multiline_comment|/*&n;&n;  Linux Driver for BusLogic MultiMaster SCSI Host Adapters&n;&n;  Copyright 1995 by Leonard N. Zubkoff &lt;lnz@dandelion.com&gt;&n;&n;  This program is free software; you may redistribute and/or modify it under&n;  the terms of the GNU General Public License Version 2 as published by the&n;  Free Software Foundation, provided that none of the source code or runtime&n;  copyright notices are removed or modified.&n;&n;  This program is distributed in the hope that it will be useful, but&n;  WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY&n;  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n;  for complete details.&n;&n;  The author respectfully requests that any modifications to this software be&n;  sent directly to him for evaluation and testing.&n;&n;  Special thanks to Wayne Yen and Alex Win of BusLogic, whose advice has been&n;  invaluable, to David Gentzel, for writing the original Linux BusLogic driver,&n;  and to Paul Gortmaker, for being such a dedicated test site.&n;&n;*/
DECL|macro|BusLogic_DriverVersion
mdefine_line|#define BusLogic_DriverVersion&t;&t;&quot;1.3.2&quot;
DECL|macro|BusLogic_DriverDate
mdefine_line|#define BusLogic_DriverDate&t;&t;&quot;13 April 1996&quot;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &quot;BusLogic.h&quot;
multiline_comment|/*&n;  BusLogic_CommandLineEntryCount is a count of the number of &quot;BusLogic=&quot;&n;  entries provided on the Linux Kernel Command Line.&n;*/
r_static
r_int
DECL|variable|BusLogic_CommandLineEntryCount
id|BusLogic_CommandLineEntryCount
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;  BusLogic_CommandLineEntries is an array of Command Line Entry structures&n;  representing the &quot;BusLogic=&quot; entries provided on the Linux Kernel Command&n;  Line.&n;*/
r_static
id|BusLogic_CommandLineEntry_T
DECL|variable|BusLogic_CommandLineEntries
id|BusLogic_CommandLineEntries
(braket
id|BusLogic_MaxHostAdapters
)braket
suffix:semicolon
multiline_comment|/*&n;  BusLogic_GlobalOptions is a bit mask of Global Options to be applied&n;  across all Host Adapters.&n;*/
r_static
r_int
DECL|variable|BusLogic_GlobalOptions
id|BusLogic_GlobalOptions
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;  BusLogic_RegisteredHostAdapters is a linked list of all the registered&n;  BusLogic Host Adapters.&n;*/
r_static
id|BusLogic_HostAdapter_T
DECL|variable|BusLogic_RegisteredHostAdapters
op_star
id|BusLogic_RegisteredHostAdapters
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;  BusLogic_StandardAddresses is the list of standard ISA I/O Addresses at&n;  which BusLogic Host Adapters may potentially be found.&n;*/
r_static
r_int
r_int
DECL|variable|BusLogic_IO_StandardAddresses
id|BusLogic_IO_StandardAddresses
(braket
)braket
op_assign
(brace
l_int|0x330
comma
l_int|0x334
comma
l_int|0x230
comma
l_int|0x234
comma
l_int|0x130
comma
l_int|0x134
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n;  BusLogic_IO_AddressProbeList is the list of I/O Addresses to be probed for&n;  potential BusLogic Host Adapters.  It is initialized by interrogating the&n;  PCI Configuration Space on PCI machines as well as from the list of&n;  standard BusLogic I/O Addresses.&n;*/
r_static
r_int
r_int
DECL|variable|BusLogic_IO_AddressProbeList
id|BusLogic_IO_AddressProbeList
(braket
id|BusLogic_IO_MaxProbeAddresses
op_plus
l_int|1
)braket
op_assign
(brace
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n;  BusLogic_IRQ_UsageCount stores a count of the number of Host Adapters using&n;  a given IRQ Channel, which is necessary to support PCI, EISA, or MCA shared&n;  interrupts.  Only IRQ Channels 9, 10, 11, 12, 14, and 15 are supported by&n;  BusLogic Host Adapters.&n;*/
r_static
r_int
DECL|variable|BusLogic_IRQ_UsageCount
id|BusLogic_IRQ_UsageCount
(braket
l_int|7
)braket
op_assign
(brace
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n;  BusLogic_CommandFailureReason holds a string identifying the reason why a&n;  call to BusLogic_Command failed.  It is only non-NULL when BusLogic_Command&n;  returns a failure code.&n;*/
r_static
r_char
DECL|variable|BusLogic_CommandFailureReason
op_star
id|BusLogic_CommandFailureReason
suffix:semicolon
multiline_comment|/*&n;  BusLogic_ProcDirectoryEntry is the BusLogic /proc/scsi directory entry.&n;*/
r_static
r_struct
id|proc_dir_entry
DECL|variable|BusLogic_ProcDirectoryEntry
id|BusLogic_ProcDirectoryEntry
op_assign
(brace
id|PROC_SCSI_BUSLOGIC
comma
l_int|8
comma
l_string|&quot;BusLogic&quot;
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
l_int|2
)brace
suffix:semicolon
multiline_comment|/*&n;  BusLogic_AnnounceDriver announces the Driver Version and Date, Author&squot;s&n;  Name, Copyright Notice, and Contact Address.&n;*/
DECL|function|BusLogic_AnnounceDriver
r_static
r_void
id|BusLogic_AnnounceDriver
c_func
(paren
r_void
)paren
(brace
r_static
id|boolean
id|DriverAnnouncementPrinted
op_assign
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|DriverAnnouncementPrinted
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi: ***** BusLogic SCSI Driver Version &quot;
id|BusLogic_DriverVersion
l_string|&quot; of &quot;
id|BusLogic_DriverDate
l_string|&quot; *****&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi: Copyright 1995 by Leonard N. Zubkoff &lt;lnz@dandelion.com&gt;&bslash;n&quot;
)paren
suffix:semicolon
id|DriverAnnouncementPrinted
op_assign
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_DriverInfo returns the Board Name to identify this SCSI Driver&n;  and Host Adapter.&n;*/
DECL|function|BusLogic_DriverInfo
r_const
r_char
op_star
id|BusLogic_DriverInfo
c_func
(paren
id|SCSI_Host_T
op_star
id|Host
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|Host-&gt;hostdata
suffix:semicolon
r_return
id|HostAdapter-&gt;BoardName
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_RegisterHostAdapter adds Host Adapter to the list of registered&n;  BusLogic Host Adapters.&n;*/
DECL|function|BusLogic_RegisterHostAdapter
r_static
r_void
id|BusLogic_RegisterHostAdapter
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
id|HostAdapter-&gt;Next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_RegisteredHostAdapters
op_ne
l_int|NULL
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|LastHostAdapter
op_assign
id|BusLogic_RegisteredHostAdapters
suffix:semicolon
id|BusLogic_HostAdapter_T
op_star
id|NextHostAdapter
suffix:semicolon
r_while
c_loop
(paren
(paren
id|NextHostAdapter
op_assign
id|LastHostAdapter-&gt;Next
)paren
op_ne
l_int|NULL
)paren
id|LastHostAdapter
op_assign
id|NextHostAdapter
suffix:semicolon
id|LastHostAdapter-&gt;Next
op_assign
id|HostAdapter
suffix:semicolon
)brace
r_else
id|BusLogic_RegisteredHostAdapters
op_assign
id|HostAdapter
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_UnregisterHostAdapter removes Host Adapter from the list of&n;  registered BusLogic Host Adapters.&n;*/
DECL|function|BusLogic_UnregisterHostAdapter
r_static
r_void
id|BusLogic_UnregisterHostAdapter
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
r_if
c_cond
(paren
id|BusLogic_RegisteredHostAdapters
op_ne
id|HostAdapter
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|LastHostAdapter
op_assign
id|BusLogic_RegisteredHostAdapters
suffix:semicolon
r_while
c_loop
(paren
id|LastHostAdapter
op_ne
l_int|NULL
op_logical_and
id|LastHostAdapter-&gt;Next
op_ne
id|HostAdapter
)paren
id|LastHostAdapter
op_assign
id|LastHostAdapter-&gt;Next
suffix:semicolon
r_if
c_cond
(paren
id|LastHostAdapter
op_ne
l_int|NULL
)paren
id|LastHostAdapter-&gt;Next
op_assign
id|HostAdapter-&gt;Next
suffix:semicolon
)brace
r_else
id|BusLogic_RegisteredHostAdapters
op_assign
id|HostAdapter-&gt;Next
suffix:semicolon
id|HostAdapter-&gt;Next
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_CreateMailboxes allocates the Outgoing and Incoming Mailboxes for&n;  Host Adapter.&n;*/
DECL|function|BusLogic_CreateMailboxes
r_static
id|boolean
id|BusLogic_CreateMailboxes
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
id|HostAdapter-&gt;FirstOutgoingMailbox
op_assign
(paren
id|BusLogic_OutgoingMailbox_T
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|HostAdapter-&gt;MailboxCount
op_star
(paren
r_sizeof
(paren
id|BusLogic_OutgoingMailbox_T
)paren
op_plus
r_sizeof
(paren
id|BusLogic_IncomingMailbox_T
)paren
)paren
comma
(paren
id|HostAdapter-&gt;BounceBuffersRequired
ques
c_cond
id|GFP_ATOMIC
op_or
id|GFP_DMA
suffix:colon
id|GFP_ATOMIC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;FirstOutgoingMailbox
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: UNABLE TO ALLOCATE MAILBOXES - DETACHING&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
id|HostAdapter-&gt;LastOutgoingMailbox
op_assign
id|HostAdapter-&gt;FirstOutgoingMailbox
op_plus
id|HostAdapter-&gt;MailboxCount
op_minus
l_int|1
suffix:semicolon
id|HostAdapter-&gt;FirstIncomingMailbox
op_assign
(paren
id|BusLogic_IncomingMailbox_T
op_star
)paren
(paren
id|HostAdapter-&gt;LastOutgoingMailbox
op_plus
l_int|1
)paren
suffix:semicolon
id|HostAdapter-&gt;LastIncomingMailbox
op_assign
id|HostAdapter-&gt;FirstIncomingMailbox
op_plus
id|HostAdapter-&gt;MailboxCount
op_minus
l_int|1
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_DestroyMailboxes deallocates the Outgoing and Incoming Mailboxes&n;  for Host Adapter.&n;*/
DECL|function|BusLogic_DestroyMailboxes
r_static
r_void
id|BusLogic_DestroyMailboxes
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
r_if
c_cond
(paren
id|HostAdapter-&gt;FirstOutgoingMailbox
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|HostAdapter-&gt;FirstOutgoingMailbox
comma
id|HostAdapter-&gt;MailboxCount
op_star
(paren
r_sizeof
(paren
id|BusLogic_OutgoingMailbox_T
)paren
op_plus
r_sizeof
(paren
id|BusLogic_IncomingMailbox_T
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_CreateCCBs allocates the initial Command Control Blocks (CCBs)&n;  for Host Adapter.&n;*/
DECL|function|BusLogic_CreateCCBs
r_static
id|boolean
id|BusLogic_CreateCCBs
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HostAdapter-&gt;InitialCCBs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|BusLogic_CCB_T
op_star
id|CCB
op_assign
(paren
id|BusLogic_CCB_T
op_star
)paren
id|scsi_init_malloc
c_func
(paren
r_sizeof
(paren
id|BusLogic_CCB_T
)paren
comma
(paren
id|HostAdapter-&gt;BounceBuffersRequired
ques
c_cond
id|GFP_ATOMIC
op_or
id|GFP_DMA
suffix:colon
id|GFP_ATOMIC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: UNABLE TO ALLOCATE CCB %d - DETACHING&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|i
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
id|memset
c_func
(paren
id|CCB
comma
l_int|0
comma
r_sizeof
(paren
id|BusLogic_CCB_T
)paren
)paren
suffix:semicolon
id|CCB-&gt;HostAdapter
op_assign
id|HostAdapter
suffix:semicolon
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Free
suffix:semicolon
id|CCB-&gt;Next
op_assign
id|HostAdapter-&gt;Free_CCBs
suffix:semicolon
id|CCB-&gt;NextAll
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|HostAdapter-&gt;Free_CCBs
op_assign
id|CCB
suffix:semicolon
id|HostAdapter-&gt;All_CCBs
op_assign
id|CCB
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_DestroyCCBs deallocates the CCBs for Host Adapter.&n;*/
DECL|function|BusLogic_DestroyCCBs
r_static
r_void
id|BusLogic_DestroyCCBs
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
id|BusLogic_CCB_T
op_star
id|NextCCB
op_assign
id|HostAdapter-&gt;All_CCBs
comma
op_star
id|CCB
suffix:semicolon
id|HostAdapter-&gt;All_CCBs
op_assign
l_int|NULL
suffix:semicolon
id|HostAdapter-&gt;Free_CCBs
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|CCB
op_assign
id|NextCCB
)paren
op_ne
l_int|NULL
)paren
(brace
id|NextCCB
op_assign
id|CCB-&gt;NextAll
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|CCB
comma
r_sizeof
(paren
id|BusLogic_CCB_T
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;  BusLogic_AllocateCCB allocates a CCB from the Host Adapter&squot;s free list,&n;  allocating more memory from the Kernel if necessary.  The Host Adapter&squot;s&n;  Lock should have already been acquired by the caller.&n;*/
DECL|function|BusLogic_AllocateCCB
r_static
id|BusLogic_CCB_T
op_star
id|BusLogic_AllocateCCB
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
r_static
r_int
r_int
id|SerialNumber
op_assign
l_int|0
suffix:semicolon
id|BusLogic_CCB_T
op_star
id|CCB
suffix:semicolon
r_int
id|Allocated
suffix:semicolon
id|CCB
op_assign
id|HostAdapter-&gt;Free_CCBs
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_ne
l_int|NULL
)paren
(brace
id|CCB-&gt;SerialNumber
op_assign
op_increment
id|SerialNumber
suffix:semicolon
id|HostAdapter-&gt;Free_CCBs
op_assign
id|CCB-&gt;Next
suffix:semicolon
id|CCB-&gt;Next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|CCB
suffix:semicolon
)brace
r_for
c_loop
(paren
id|Allocated
op_assign
l_int|0
suffix:semicolon
id|Allocated
OL
id|HostAdapter-&gt;IncrementalCCBs
suffix:semicolon
id|Allocated
op_increment
)paren
(brace
id|CCB
op_assign
(paren
id|BusLogic_CCB_T
op_star
)paren
id|scsi_init_malloc
c_func
(paren
r_sizeof
(paren
id|BusLogic_CCB_T
)paren
comma
(paren
id|HostAdapter-&gt;BounceBuffersRequired
ques
c_cond
id|GFP_ATOMIC
op_or
id|GFP_DMA
suffix:colon
id|GFP_ATOMIC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|memset
c_func
(paren
id|CCB
comma
l_int|0
comma
r_sizeof
(paren
id|BusLogic_CCB_T
)paren
)paren
suffix:semicolon
id|CCB-&gt;HostAdapter
op_assign
id|HostAdapter
suffix:semicolon
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Free
suffix:semicolon
id|CCB-&gt;Next
op_assign
id|HostAdapter-&gt;Free_CCBs
suffix:semicolon
id|CCB-&gt;NextAll
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|HostAdapter-&gt;Free_CCBs
op_assign
id|CCB
suffix:semicolon
id|HostAdapter-&gt;All_CCBs
op_assign
id|CCB
suffix:semicolon
)brace
id|CCB
op_assign
id|HostAdapter-&gt;Free_CCBs
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Failed to allocate additional CCBs&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Allocated %d additional CCBs&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|Allocated
)paren
suffix:semicolon
id|CCB-&gt;SerialNumber
op_assign
op_increment
id|SerialNumber
suffix:semicolon
id|HostAdapter-&gt;Free_CCBs
op_assign
id|CCB-&gt;Next
suffix:semicolon
id|CCB-&gt;Next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|CCB
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_DeallocateCCB deallocates a CCB, returning it to the Host Adapter&squot;s&n;  free list.  The Host Adapter&squot;s Lock should have already been acquired by the&n;  caller.&n;*/
DECL|function|BusLogic_DeallocateCCB
r_static
r_void
id|BusLogic_DeallocateCCB
c_func
(paren
id|BusLogic_CCB_T
op_star
id|CCB
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
id|CCB-&gt;HostAdapter
suffix:semicolon
id|CCB-&gt;Command
op_assign
l_int|NULL
suffix:semicolon
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Free
suffix:semicolon
id|CCB-&gt;Next
op_assign
id|HostAdapter-&gt;Free_CCBs
suffix:semicolon
id|HostAdapter-&gt;Free_CCBs
op_assign
id|CCB
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_Command sends the command OperationCode to HostAdapter, optionally&n;  providing ParameterLength bytes of ParameterData and receiving at most&n;  ReplyLength bytes of ReplyData; any excess reply data is received but&n;  discarded.&n;&n;  On success, this function returns the number of reply bytes read from&n;  the Host Adapter (including any discarded data); on failure, it returns&n;  -1 if the command was invalid, or -2 if a timeout occurred.&n;&n;  This function is only called during board detection and initialization, so&n;  performance and latency are not critical, and exclusive access to the Host&n;  Adapter hardware is assumed.  Once the board and driver are initialized, the&n;  only Host Adapter command that is issued is the single byte Execute Mailbox&n;  Command operation code , which does not require waiting for the Host Adapter&n;  Ready bit to be set in the Status Register.&n;*/
DECL|function|BusLogic_Command
r_static
r_int
id|BusLogic_Command
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
comma
id|BusLogic_OperationCode_T
id|OperationCode
comma
r_void
op_star
id|ParameterData
comma
r_int
id|ParameterLength
comma
r_void
op_star
id|ReplyData
comma
r_int
id|ReplyLength
)paren
(brace
r_int
r_char
op_star
id|ParameterPointer
op_assign
(paren
r_int
r_char
op_star
)paren
id|ParameterData
suffix:semicolon
r_int
r_char
op_star
id|ReplyPointer
op_assign
(paren
r_int
r_char
op_star
)paren
id|ReplyData
suffix:semicolon
r_int
r_char
id|StatusRegister
op_assign
l_int|0
comma
id|InterruptRegister
suffix:semicolon
r_int
id|TimeoutCounter
suffix:semicolon
r_int
id|ReplyBytes
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;    Clear out the Reply Data if provided.&n;  */
r_if
c_cond
(paren
id|ReplyLength
OG
l_int|0
)paren
id|memset
c_func
(paren
id|ReplyData
comma
l_int|0
comma
id|ReplyLength
)paren
suffix:semicolon
multiline_comment|/*&n;    Wait for the Host Adapter Ready bit to be set and the Command/Parameter&n;    Register Busy bit to be reset in the Status Register.&n;  */
id|TimeoutCounter
op_assign
id|loops_per_sec
op_rshift
l_int|3
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
id|StatusRegister
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|StatusRegister
op_amp
id|BusLogic_HostAdapterReady
)paren
op_logical_and
op_logical_neg
(paren
id|StatusRegister
op_amp
id|BusLogic_CommandParameterRegisterBusy
)paren
)paren
r_break
suffix:semicolon
)brace
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Timeout waiting for Host Adapter Ready&quot;
suffix:semicolon
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
r_return
op_minus
l_int|2
suffix:semicolon
multiline_comment|/*&n;    Write the OperationCode to the Command/Parameter Register.&n;  */
id|HostAdapter-&gt;HostAdapterCommandCompleted
op_assign
l_bool|false
suffix:semicolon
id|BusLogic_WriteCommandParameterRegister
c_func
(paren
id|HostAdapter
comma
id|OperationCode
)paren
suffix:semicolon
multiline_comment|/*&n;    Write any additional Parameter Bytes.&n;  */
id|TimeoutCounter
op_assign
l_int|10000
suffix:semicolon
r_while
c_loop
(paren
id|ParameterLength
OG
l_int|0
op_logical_and
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;Wait 100 microseconds to give the Host Adapter enough time to determine&n;&t;whether the last value written to the Command/Parameter Register was&n;&t;valid or not.  If the Command Complete bit is set in the Interrupt&n;&t;Register, then the Command Invalid bit in the Status Register will be&n;&t;reset if the Operation Code or Parameter was valid and the command&n;&t;has completed, or set if the Operation Code or Parameter was invalid.&n;&t;If the Data In Register Ready bit is set in the Status Register, then&n;&t;the Operation Code was valid, and data is waiting to be read back&n;&t;from the Host Adapter.  Otherwise, wait for the Command/Parameter&n;&t;Register Busy bit in the Status Register to be reset.&n;      */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|InterruptRegister
op_assign
id|BusLogic_ReadInterruptRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|StatusRegister
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|InterruptRegister
op_amp
id|BusLogic_CommandComplete
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterCommandCompleted
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister
op_amp
id|BusLogic_DataInRegisterReady
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister
op_amp
id|BusLogic_CommandParameterRegisterBusy
)paren
r_continue
suffix:semicolon
id|BusLogic_WriteCommandParameterRegister
c_func
(paren
id|HostAdapter
comma
op_star
id|ParameterPointer
op_increment
)paren
suffix:semicolon
id|ParameterLength
op_decrement
suffix:semicolon
)brace
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Timeout waiting for Parameter Acceptance&quot;
suffix:semicolon
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
r_return
op_minus
l_int|2
suffix:semicolon
multiline_comment|/*&n;    The Modify I/O Address command does not cause a Command Complete Interrupt.&n;  */
r_if
c_cond
(paren
id|OperationCode
op_eq
id|BusLogic_ModifyIOAddress
)paren
(brace
id|StatusRegister
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Modify I/O Address Invalid&quot;
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister
op_amp
id|BusLogic_CommandInvalid
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|BusLogic_CommandFailureReason
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;    Select an appropriate timeout value for awaiting command completion.&n;  */
r_switch
c_cond
(paren
id|OperationCode
)paren
(brace
r_case
id|BusLogic_InquireInstalledDevicesID0to7
suffix:colon
r_case
id|BusLogic_InquireInstalledDevicesID8to15
suffix:colon
r_case
id|BusLogic_InquireDevices
suffix:colon
multiline_comment|/* Approximately 60 seconds. */
id|TimeoutCounter
op_assign
id|loops_per_sec
op_lshift
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Approximately 1 second. */
id|TimeoutCounter
op_assign
id|loops_per_sec
op_rshift
l_int|4
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;    Receive any Reply Bytes, waiting for either the Command Complete bit to&n;    be set in the Interrupt Register, or for the Interrupt Handler to set the&n;    Host Adapter Command Completed bit in the Host Adapter structure.&n;  */
r_while
c_loop
(paren
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
id|InterruptRegister
op_assign
id|BusLogic_ReadInterruptRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|StatusRegister
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|InterruptRegister
op_amp
id|BusLogic_CommandComplete
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterCommandCompleted
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister
op_amp
id|BusLogic_DataInRegisterReady
)paren
r_if
c_cond
(paren
op_increment
id|ReplyBytes
op_le
id|ReplyLength
)paren
op_star
id|ReplyPointer
op_increment
op_assign
id|BusLogic_ReadDataInRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_else
id|BusLogic_ReadDataInRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OperationCode
op_eq
id|BusLogic_FetchHostAdapterLocalRAM
op_logical_and
(paren
id|StatusRegister
op_amp
id|BusLogic_HostAdapterReady
)paren
)paren
r_break
suffix:semicolon
)brace
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Timeout waiting for Command Complete&quot;
suffix:semicolon
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
r_return
op_minus
l_int|2
suffix:semicolon
multiline_comment|/*&n;    If testing Command Complete Interrupts, wait a short while in case the&n;    loop immediately above terminated due to the Command Complete bit being&n;    set in the Interrupt Register, but the interrupt hasn&squot;t actually been&n;    processed yet.  Otherwise, acknowledging the interrupt here could prevent&n;    the interrupt test from succeeding.&n;  */
r_if
c_cond
(paren
id|OperationCode
op_eq
id|BusLogic_TestCommandCompleteInterrupt
)paren
id|udelay
c_func
(paren
l_int|10000
)paren
suffix:semicolon
multiline_comment|/*&n;    Clear any pending Command Complete Interrupt.&n;  */
id|BusLogic_WriteControlRegister
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InterruptReset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_GlobalOptions
op_amp
id|BusLogic_TraceConfiguration
)paren
r_if
c_cond
(paren
id|OperationCode
op_ne
id|BusLogic_TestCommandCompleteInterrupt
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;BusLogic_Command(%02X) Status = %02X: %2d ==&gt; %2d:&quot;
comma
id|OperationCode
comma
id|StatusRegister
comma
id|ReplyLength
comma
id|ReplyBytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReplyLength
OG
id|ReplyBytes
)paren
id|ReplyLength
op_assign
id|ReplyBytes
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ReplyLength
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %02X&quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|ReplyData
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    Process Command Invalid conditions.&n;  */
r_if
c_cond
(paren
id|StatusRegister
op_amp
id|BusLogic_CommandInvalid
)paren
(brace
multiline_comment|/*&n;&t;Some early BusLogic Host Adapters may not recover properly from&n;&t;a Command Invalid condition, so if this appears to be the case,&n;&t;a Soft Reset is issued to the Host Adapter.  Potentially invalid&n;&t;commands are never attempted after Mailbox Initialization is&n;&t;performed, so there should be no Host Adapter state lost by a&n;&t;Soft Reset in response to a Command Invalid condition.&n;      */
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|StatusRegister
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister
op_ne
(paren
id|BusLogic_HostAdapterReady
op_or
id|BusLogic_InitializationRequired
)paren
)paren
(brace
id|BusLogic_WriteControlRegister
c_func
(paren
id|HostAdapter
comma
id|BusLogic_SoftReset
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Command Invalid&quot;
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;    Handle Excess Parameters Supplied conditions.&n;  */
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Excess Parameters Supplied&quot;
suffix:semicolon
r_if
c_cond
(paren
id|ParameterLength
OG
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;    Indicate the command completed successfully.&n;  */
id|BusLogic_CommandFailureReason
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ReplyBytes
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InitializeAddressProbeList initializes the list of I/O Addresses&n;  to be probed for potential BusLogic SCSI Host Adapters by interrogating the&n;  PCI Configuration Space on PCI machines as well as from the list of standard&n;  BusLogic I/O Addresses.&n;*/
DECL|function|BusLogic_InitializeAddressProbeList
r_static
r_void
id|BusLogic_InitializeAddressProbeList
c_func
(paren
r_void
)paren
(brace
r_int
id|DestinationIndex
op_assign
l_int|0
comma
id|SourceIndex
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;    If BusLogic_Setup has provided an I/O Address probe list, do not override&n;    the Kernel Command Line specifications.&n;  */
r_if
c_cond
(paren
id|BusLogic_IO_AddressProbeList
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
r_return
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
multiline_comment|/*&n;    Interrogate PCI Configuration Space for any BusLogic SCSI Host Adapters.&n;  */
r_if
c_cond
(paren
id|pcibios_present
c_func
(paren
)paren
)paren
(brace
r_int
r_int
id|BusDeviceFunction
(braket
id|BusLogic_IO_MaxProbeAddresses
)braket
suffix:semicolon
r_int
r_int
id|Index
op_assign
l_int|0
comma
id|VendorID
comma
id|DeviceID
suffix:semicolon
id|boolean
id|NonIncreasingScanningOrder
op_assign
l_bool|false
suffix:semicolon
r_int
r_char
id|Bus
comma
id|DeviceFunction
suffix:semicolon
r_int
r_int
id|BaseAddress0
suffix:semicolon
r_while
c_loop
(paren
id|pcibios_find_class
c_func
(paren
id|PCI_CLASS_STORAGE_SCSI
op_lshift
l_int|8
comma
id|Index
op_increment
comma
op_amp
id|Bus
comma
op_amp
id|DeviceFunction
)paren
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|pcibios_read_config_word
c_func
(paren
id|Bus
comma
id|DeviceFunction
comma
id|PCI_VENDOR_ID
comma
op_amp
id|VendorID
)paren
op_eq
l_int|0
op_logical_and
id|VendorID
op_eq
id|PCI_VENDOR_ID_BUSLOGIC
op_logical_and
id|pcibios_read_config_word
c_func
(paren
id|Bus
comma
id|DeviceFunction
comma
id|PCI_DEVICE_ID
comma
op_amp
id|DeviceID
)paren
op_eq
l_int|0
op_logical_and
(paren
id|DeviceID
op_eq
id|PCI_DEVICE_ID_BUSLOGIC_946C
op_logical_or
id|DeviceID
op_eq
id|PCI_DEVICE_ID_BUSLOGIC_946C_2
)paren
op_logical_and
id|pcibios_read_config_dword
c_func
(paren
id|Bus
comma
id|DeviceFunction
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|BaseAddress0
)paren
op_eq
l_int|0
op_logical_and
(paren
id|BaseAddress0
op_amp
id|PCI_BASE_ADDRESS_SPACE
)paren
op_eq
id|PCI_BASE_ADDRESS_SPACE_IO
)paren
(brace
id|BusLogic_IO_AddressProbeList
(braket
id|DestinationIndex
)braket
op_assign
id|BaseAddress0
op_amp
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
id|BusDeviceFunction
(braket
id|DestinationIndex
)braket
op_assign
(paren
id|Bus
op_lshift
l_int|8
)paren
op_or
id|DeviceFunction
suffix:semicolon
r_if
c_cond
(paren
id|DestinationIndex
OG
l_int|0
op_logical_and
id|BusDeviceFunction
(braket
id|DestinationIndex
)braket
OL
id|BusDeviceFunction
(braket
id|DestinationIndex
op_minus
l_int|1
)braket
)paren
id|NonIncreasingScanningOrder
op_assign
l_bool|true
suffix:semicolon
id|DestinationIndex
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;If there are multiple BusLogic PCI SCSI Host Adapters present and if&n;&t;they are enumerated by the PCI BIOS in an order other than by strictly&n;&t;increasing Bus Number and Device Number, then interrogate the setting&n;&t;of the AutoSCSI &quot;Use Bus And Device # For PCI Scanning Seq.&quot; option.&n;&t;If it is ON, sort the PCI Host Adapter I/O Addresses by increasing Bus&n;&t;Number and Device Number so that the Host Adapters are recognized in&n;&t;the same order by the Linux kernel as by the Host Adapter&squot;s BIOS.&n;      */
r_if
c_cond
(paren
id|DestinationIndex
OG
l_int|1
op_logical_and
id|NonIncreasingScanningOrder
)paren
(brace
id|BusLogic_FetchHostAdapterLocalRAMRequest_T
id|FetchHostAdapterLocalRAMRequest
suffix:semicolon
id|BusLogic_AutoSCSIByte45_T
id|AutoSCSIByte45
suffix:semicolon
id|BusLogic_HostAdapter_T
id|HostAdapterPrototype
suffix:semicolon
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
op_amp
id|HostAdapterPrototype
suffix:semicolon
id|HostAdapter-&gt;IO_Address
op_assign
id|BusLogic_IO_AddressProbeList
(braket
l_int|0
)braket
suffix:semicolon
id|FetchHostAdapterLocalRAMRequest.ByteOffset
op_assign
id|BusLogic_AutoSCSI_BaseOffset
op_plus
l_int|45
suffix:semicolon
id|FetchHostAdapterLocalRAMRequest.ByteCount
op_assign
r_sizeof
(paren
id|AutoSCSIByte45
)paren
suffix:semicolon
id|AutoSCSIByte45.ForceBusDeviceScanningOrder
op_assign
l_bool|false
suffix:semicolon
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_FetchHostAdapterLocalRAM
comma
op_amp
id|FetchHostAdapterLocalRAMRequest
comma
r_sizeof
(paren
id|FetchHostAdapterLocalRAMRequest
)paren
comma
op_amp
id|AutoSCSIByte45
comma
r_sizeof
(paren
id|AutoSCSIByte45
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|AutoSCSIByte45.ForceBusDeviceScanningOrder
)paren
(brace
multiline_comment|/*&n;&t;&t;Sort the I/O Addresses such that the corrseponding PCI devices&n;&t;&t;are in ascending order by Bus Number and Device Number.&n;&t;      */
r_int
id|LastInterchange
op_assign
id|DestinationIndex
op_minus
l_int|1
comma
id|Bound
comma
id|j
suffix:semicolon
r_while
c_loop
(paren
id|LastInterchange
OG
l_int|0
)paren
(brace
id|Bound
op_assign
id|LastInterchange
suffix:semicolon
id|LastInterchange
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|Bound
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|BusDeviceFunction
(braket
id|j
)braket
OG
id|BusDeviceFunction
(braket
id|j
op_plus
l_int|1
)braket
)paren
(brace
r_int
r_int
id|Temp
suffix:semicolon
id|Temp
op_assign
id|BusDeviceFunction
(braket
id|j
)braket
suffix:semicolon
id|BusDeviceFunction
(braket
id|j
)braket
op_assign
id|BusDeviceFunction
(braket
id|j
op_plus
l_int|1
)braket
suffix:semicolon
id|BusDeviceFunction
(braket
id|j
op_plus
l_int|1
)braket
op_assign
id|Temp
suffix:semicolon
id|Temp
op_assign
id|BusLogic_IO_AddressProbeList
(braket
id|j
)braket
suffix:semicolon
id|BusLogic_IO_AddressProbeList
(braket
id|j
)braket
op_assign
id|BusLogic_IO_AddressProbeList
(braket
id|j
op_plus
l_int|1
)braket
suffix:semicolon
id|BusLogic_IO_AddressProbeList
(braket
id|j
op_plus
l_int|1
)braket
op_assign
id|Temp
suffix:semicolon
id|LastInterchange
op_assign
id|j
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;    Append the list of standard BusLogic ISA I/O Addresses.&n;  */
r_while
c_loop
(paren
id|DestinationIndex
template_param
l_int|0
)paren
id|BusLogic_IO_AddressProbeList
(braket
id|DestinationIndex
op_increment
)braket
op_assign
id|BusLogic_IO_StandardAddresses
(braket
id|SourceIndex
op_increment
)braket
suffix:semicolon
id|BusLogic_IO_AddressProbeList
(braket
id|DestinationIndex
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_Failure prints a standardized error message, and then returns false.&n;*/
DECL|function|BusLogic_Failure
r_static
id|boolean
id|BusLogic_Failure
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
comma
r_char
op_star
id|ErrorMessage
)paren
(brace
id|BusLogic_AnnounceDriver
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;While configuring BusLogic Host Adapter at I/O Address 0x%X:&bslash;n&quot;
comma
id|HostAdapter-&gt;IO_Address
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s FAILED - DETACHING&bslash;n&quot;
comma
id|ErrorMessage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_CommandFailureReason
op_ne
l_int|NULL
)paren
id|printk
c_func
(paren
l_string|&quot;ADDITIONAL FAILURE INFO - %s&bslash;n&quot;
comma
id|BusLogic_CommandFailureReason
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ProbeHostAdapter probes for a BusLogic Host Adapter.&n;*/
DECL|function|BusLogic_ProbeHostAdapter
r_static
id|boolean
id|BusLogic_ProbeHostAdapter
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
id|boolean
id|TraceProbe
op_assign
(paren
id|BusLogic_GlobalOptions
op_amp
id|BusLogic_TraceProbe
)paren
suffix:semicolon
r_int
r_char
id|StatusRegister
comma
id|GeometryRegister
suffix:semicolon
multiline_comment|/*&n;    Read the Status Register to test if there is an I/O port that responds.  A&n;    nonexistent I/O port will return 0xFF, in which case there is definitely no&n;    BusLogic Host Adapter at this base I/O Address.&n;  */
id|StatusRegister
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TraceProbe
)paren
id|printk
c_func
(paren
l_string|&quot;BusLogic_Probe(0x%X): Status 0x%02X&bslash;n&quot;
comma
id|HostAdapter-&gt;IO_Address
comma
id|StatusRegister
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister
op_eq
l_int|0xFF
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/*&n;    Read the undocumented BusLogic Geometry Register to test if there is an I/O&n;    port that responds.  Adaptec Host Adapters do not implement the Geometry&n;    Register, so this test helps serve to avoid incorrectly recognizing an&n;    Adaptec 1542A or 1542B as a BusLogic.  Unfortunately, the Adaptec 1542C&n;    series does respond to the Geometry Register I/O port, but it will be&n;    rejected later when the Inquire Extended Setup Information command is&n;    issued in BusLogic_CheckHostAdapter.  The AMI FastDisk Host Adapter is a&n;    BusLogic clone that implements the same interface as earlier BusLogic&n;    boards, including the undocumented commands, and is therefore supported by&n;    this driver.  However, the AMI FastDisk always returns 0x00 upon reading&n;    the Geometry Register, so the extended translation option should always be&n;    left disabled on the AMI FastDisk.&n;  */
id|GeometryRegister
op_assign
id|BusLogic_ReadGeometryRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TraceProbe
)paren
id|printk
c_func
(paren
l_string|&quot;BusLogic_Probe(0x%X): Geometry 0x%02X&bslash;n&quot;
comma
id|HostAdapter-&gt;IO_Address
comma
id|GeometryRegister
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GeometryRegister
op_eq
l_int|0xFF
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/*&n;    Indicate the Host Adapter Probe completed successfully.&n;  */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_HardResetHostAdapter issues a Hard Reset to the Host Adapter,&n;  and waits for Host Adapter Diagnostics to complete.&n;*/
DECL|function|BusLogic_HardResetHostAdapter
r_static
id|boolean
id|BusLogic_HardResetHostAdapter
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
id|boolean
id|TraceHardReset
op_assign
(paren
id|BusLogic_GlobalOptions
op_amp
id|BusLogic_TraceHardReset
)paren
suffix:semicolon
r_int
id|TimeoutCounter
op_assign
id|loops_per_sec
op_rshift
l_int|2
suffix:semicolon
r_int
r_char
id|StatusRegister
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;    Issue a Hard Reset Command to the Host Adapter.  The Host Adapter should&n;    respond by setting Diagnostic Active in the Status Register.&n;  */
id|BusLogic_WriteControlRegister
c_func
(paren
id|HostAdapter
comma
id|BusLogic_HardReset
)paren
suffix:semicolon
multiline_comment|/*&n;    Wait until Diagnostic Active is set in the Status Register.&n;  */
r_while
c_loop
(paren
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
id|StatusRegister
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|StatusRegister
op_amp
id|BusLogic_DiagnosticActive
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TraceHardReset
)paren
id|printk
c_func
(paren
l_string|&quot;BusLogic_HardReset(0x%X): Diagnostic Active, Status 0x%02X&bslash;n&quot;
comma
id|HostAdapter-&gt;IO_Address
comma
id|StatusRegister
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/*&n;    Wait 100 microseconds to allow completion of any initial diagnostic&n;    activity which might leave the contents of the Status Register&n;    unpredictable.&n;  */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/*&n;    Wait until Diagnostic Active is reset in the Status Register.&n;  */
r_while
c_loop
(paren
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
id|StatusRegister
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|StatusRegister
op_amp
id|BusLogic_DiagnosticActive
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TraceHardReset
)paren
id|printk
c_func
(paren
l_string|&quot;BusLogic_HardReset(0x%X): Diagnostic Completed, Status 0x%02X&bslash;n&quot;
comma
id|HostAdapter-&gt;IO_Address
comma
id|StatusRegister
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/*&n;    Wait until at least one of the Diagnostic Failure, Host Adapter Ready,&n;    or Data In Register Ready bits is set in the Status Register.&n;  */
r_while
c_loop
(paren
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
id|StatusRegister
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister
op_amp
(paren
id|BusLogic_DiagnosticFailure
op_or
id|BusLogic_HostAdapterReady
op_or
id|BusLogic_DataInRegisterReady
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TraceHardReset
)paren
id|printk
c_func
(paren
l_string|&quot;BusLogic_HardReset(0x%X): Host Adapter Ready, Status 0x%02X&bslash;n&quot;
comma
id|HostAdapter-&gt;IO_Address
comma
id|StatusRegister
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/*&n;    If Diagnostic Failure is set or Host Adapter Ready is reset, then an&n;    error occurred during the Host Adapter diagnostics.  If Data In Register&n;    Ready is set, then there is an Error Code available.&n;  */
r_if
c_cond
(paren
(paren
id|StatusRegister
op_amp
id|BusLogic_DiagnosticFailure
)paren
op_logical_or
op_logical_neg
(paren
id|StatusRegister
op_amp
id|BusLogic_HostAdapterReady
)paren
)paren
(brace
id|BusLogic_CommandFailureReason
op_assign
l_int|NULL
suffix:semicolon
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;HARD RESET DIAGNOSTICS&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HOST ADAPTER STATUS REGISTER = %02X&bslash;n&quot;
comma
id|StatusRegister
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister
op_amp
id|BusLogic_DataInRegisterReady
)paren
(brace
r_int
r_char
id|ErrorCode
op_assign
id|BusLogic_ReadDataInRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HOST ADAPTER ERROR CODE = %d&bslash;n&quot;
comma
id|ErrorCode
)paren
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/*&n;    Indicate the Host Adapter Hard Reset completed successfully.&n;  */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_CheckHostAdapter checks to be sure this really is a BusLogic&n;  Host Adapter.&n;*/
DECL|function|BusLogic_CheckHostAdapter
r_static
id|boolean
id|BusLogic_CheckHostAdapter
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
id|BusLogic_ExtendedSetupInformation_T
id|ExtendedSetupInformation
suffix:semicolon
id|BusLogic_RequestedReplyLength_T
id|RequestedReplyLength
suffix:semicolon
r_int
r_int
id|ProcessorFlags
suffix:semicolon
r_int
id|Result
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Extended Setup Information command.  Only genuine&n;    BusLogic Host Adapters and true clones support this command.  Adaptec 1542C&n;    series Host Adapters that respond to the Geometry Register I/O port will&n;    fail this command.  Interrupts must be disabled around the call to&n;    BusLogic_Command since a Command Complete interrupt could occur if the IRQ&n;    Channel was previously enabled for another BusLogic Host Adapter sharing&n;    the same IRQ Channel.&n;  */
id|save_flags
c_func
(paren
id|ProcessorFlags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
suffix:semicolon
id|Result
op_assign
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireExtendedSetupInformation
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|ExtendedSetupInformation
comma
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|ProcessorFlags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_GlobalOptions
op_amp
id|BusLogic_TraceProbe
)paren
id|printk
c_func
(paren
l_string|&quot;BusLogic_Check(0x%X): Result %d&bslash;n&quot;
comma
id|HostAdapter-&gt;IO_Address
comma
id|Result
)paren
suffix:semicolon
r_return
(paren
id|Result
op_eq
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ReadHostAdapterConfiguration reads the Configuration Information&n;  from Host Adapter.&n;*/
DECL|function|BusLogic_ReadHostAdapterConfiguration
r_static
id|boolean
id|BusLogic_ReadHostAdapterConfiguration
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
id|BusLogic_BoardID_T
id|BoardID
suffix:semicolon
id|BusLogic_Configuration_T
id|Configuration
suffix:semicolon
id|BusLogic_SetupInformation_T
id|SetupInformation
suffix:semicolon
id|BusLogic_ExtendedSetupInformation_T
id|ExtendedSetupInformation
suffix:semicolon
id|BusLogic_BoardModelNumber_T
id|BoardModelNumber
suffix:semicolon
id|BusLogic_FirmwareVersion3rdDigit_T
id|FirmwareVersion3rdDigit
suffix:semicolon
id|BusLogic_FirmwareVersionLetter_T
id|FirmwareVersionLetter
suffix:semicolon
id|BusLogic_GenericIOPortInformation_T
id|GenericIOPortInformation
suffix:semicolon
id|BusLogic_FetchHostAdapterLocalRAMRequest_T
id|FetchHostAdapterLocalRAMRequest
suffix:semicolon
id|BusLogic_AutoSCSIByte15_T
id|AutoSCSIByte15
suffix:semicolon
id|BusLogic_RequestedReplyLength_T
id|RequestedReplyLength
suffix:semicolon
r_int
r_char
id|GeometryRegister
comma
op_star
id|TargetPointer
comma
id|Character
suffix:semicolon
r_int
r_int
id|AllTargetsMask
comma
id|DisconnectPermitted
suffix:semicolon
r_int
r_int
id|TaggedQueuingPermitted
comma
id|TaggedQueuingPermittedDefault
suffix:semicolon
id|boolean
id|CommonErrorRecovery
suffix:semicolon
r_int
id|TargetID
comma
id|i
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Board ID command.&n;  */
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireBoardID
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|BoardID
comma
r_sizeof
(paren
id|BoardID
)paren
)paren
op_ne
r_sizeof
(paren
id|BoardID
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE BOARD ID&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Configuration command.&n;  */
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireConfiguration
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|Configuration
comma
r_sizeof
(paren
id|Configuration
)paren
)paren
op_ne
r_sizeof
(paren
id|Configuration
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE CONFIGURATION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Setup Information command.&n;  */
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|SetupInformation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireSetupInformation
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|SetupInformation
comma
r_sizeof
(paren
id|SetupInformation
)paren
)paren
op_ne
r_sizeof
(paren
id|SetupInformation
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE SETUP INFORMATION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Extended Setup Information command.&n;  */
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireExtendedSetupInformation
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|ExtendedSetupInformation
comma
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
)paren
op_ne
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE EXTENDED SETUP INFORMATION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Board Model Number command.&n;  */
r_if
c_cond
(paren
op_logical_neg
(paren
id|BoardID.FirmwareVersion1stDigit
op_eq
l_char|&squot;2&squot;
op_logical_and
id|ExtendedSetupInformation.BusType
op_eq
l_char|&squot;A&squot;
)paren
)paren
(brace
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|BoardModelNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireBoardModelNumber
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|BoardModelNumber
comma
r_sizeof
(paren
id|BoardModelNumber
)paren
)paren
op_ne
r_sizeof
(paren
id|BoardModelNumber
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE BOARD MODEL NUMBER&quot;
)paren
suffix:semicolon
)brace
r_else
id|strcpy
c_func
(paren
id|BoardModelNumber
comma
l_string|&quot;542B&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Firmware Version 3rd Digit command.&n;  */
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireFirmwareVersion3rdDigit
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|FirmwareVersion3rdDigit
comma
r_sizeof
(paren
id|FirmwareVersion3rdDigit
)paren
)paren
op_ne
r_sizeof
(paren
id|FirmwareVersion3rdDigit
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE FIRMWARE 3RD DIGIT&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Firmware Version Letter command.&n;  */
id|FirmwareVersionLetter
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|BoardID.FirmwareVersion1stDigit
OG
l_char|&squot;3&squot;
op_logical_or
(paren
id|BoardID.FirmwareVersion1stDigit
op_eq
l_char|&squot;3&squot;
op_logical_and
id|BoardID.FirmwareVersion2ndDigit
op_ge
l_char|&squot;3&squot;
)paren
)paren
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireFirmwareVersionLetter
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|FirmwareVersionLetter
comma
r_sizeof
(paren
id|FirmwareVersionLetter
)paren
)paren
op_ne
r_sizeof
(paren
id|FirmwareVersionLetter
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE FIRMWARE VERSION LETTER&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;    BusLogic Host Adapters can be identified by their model number and&n;    the major version number of their firmware as follows:&n;&n;    5.xx&t;BusLogic &quot;W&quot; Series Host Adapters:&n;&t;&t;  BT-948/958/958D&n;    4.xx&t;BusLogic &quot;C&quot; Series Host Adapters:&n;&t;&t;  BT-946C/956C/956CD/747C/757C/757CD/445C/545C/540CF&n;    3.xx&t;BusLogic &quot;S&quot; Series Host Adapters:&n;&t;&t;  BT-747S/747D/757S/757D/445S/545S/542D&n;&t;&t;  BT-542B/742A (revision H)&n;    2.xx&t;BusLogic &quot;A&quot; Series Host Adapters:&n;&t;&t;  BT-542B/742A (revision G and below)&n;    0.xx&t;AMI FastDisk VLB/EISA BusLogic Clone Host Adapter&n;  */
multiline_comment|/*&n;    Issue the Inquire Generic I/O Port Information command to read the&n;    termination information from &quot;W&quot; Series Host Adapters.&n;  */
r_if
c_cond
(paren
id|BoardID.FirmwareVersion1stDigit
op_eq
l_char|&squot;5&squot;
)paren
(brace
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireGenericIOPortInformation
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|GenericIOPortInformation
comma
r_sizeof
(paren
id|GenericIOPortInformation
)paren
)paren
op_ne
r_sizeof
(paren
id|GenericIOPortInformation
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE GENERIC I/O PORT INFORMATION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;Save the Termination Information in the Host Adapter structure.&n;      */
r_if
c_cond
(paren
id|GenericIOPortInformation.Valid
)paren
(brace
id|HostAdapter-&gt;TerminationInfoValid
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;LowByteTerminated
op_assign
id|GenericIOPortInformation.LowByteTerminated
suffix:semicolon
id|HostAdapter-&gt;HighByteTerminated
op_assign
id|GenericIOPortInformation.HighByteTerminated
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;    Issue the Fetch Host Adapter Local RAM command to read the termination&n;    information from the AutoSCSI area of &quot;C&quot; Series Host Adapters.&n;  */
r_if
c_cond
(paren
id|BoardID.FirmwareVersion1stDigit
op_eq
l_char|&squot;4&squot;
)paren
(brace
id|FetchHostAdapterLocalRAMRequest.ByteOffset
op_assign
id|BusLogic_AutoSCSI_BaseOffset
op_plus
l_int|15
suffix:semicolon
id|FetchHostAdapterLocalRAMRequest.ByteCount
op_assign
r_sizeof
(paren
id|AutoSCSIByte15
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_FetchHostAdapterLocalRAM
comma
op_amp
id|FetchHostAdapterLocalRAMRequest
comma
r_sizeof
(paren
id|FetchHostAdapterLocalRAMRequest
)paren
comma
op_amp
id|AutoSCSIByte15
comma
r_sizeof
(paren
id|AutoSCSIByte15
)paren
)paren
op_ne
r_sizeof
(paren
id|AutoSCSIByte15
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;FETCH HOST ADAPTER LOCAL RAM&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;Save the Termination Information in the Host Adapter structure.&n;      */
id|HostAdapter-&gt;TerminationInfoValid
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;LowByteTerminated
op_assign
id|AutoSCSIByte15.LowByteTerminated
suffix:semicolon
id|HostAdapter-&gt;HighByteTerminated
op_assign
id|AutoSCSIByte15.HighByteTerminated
suffix:semicolon
)brace
multiline_comment|/*&n;    Save the Model Name and Board Name in the Host Adapter structure.&n;  */
id|TargetPointer
op_assign
id|HostAdapter-&gt;ModelName
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;B&squot;
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;T&squot;
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;-&squot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|BoardModelNumber
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Character
op_assign
id|BoardModelNumber
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|Character
op_eq
l_char|&squot; &squot;
op_logical_or
id|Character
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_break
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
id|Character
suffix:semicolon
)brace
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|strcpy
c_func
(paren
id|HostAdapter-&gt;BoardName
comma
l_string|&quot;BusLogic &quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|HostAdapter-&gt;BoardName
comma
id|HostAdapter-&gt;ModelName
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|HostAdapter-&gt;InterruptLabel
comma
id|HostAdapter-&gt;BoardName
)paren
suffix:semicolon
multiline_comment|/*&n;    Save the Firmware Version in the Host Adapter structure.&n;  */
id|TargetPointer
op_assign
id|HostAdapter-&gt;FirmwareVersion
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
id|BoardID.FirmwareVersion1stDigit
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;.&squot;
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
id|BoardID.FirmwareVersion2ndDigit
suffix:semicolon
r_if
c_cond
(paren
id|FirmwareVersion3rdDigit
op_ne
l_char|&squot; &squot;
op_logical_and
id|FirmwareVersion3rdDigit
op_ne
l_char|&squot;&bslash;0&squot;
)paren
op_star
id|TargetPointer
op_increment
op_assign
id|FirmwareVersion3rdDigit
suffix:semicolon
r_if
c_cond
(paren
id|FirmwareVersionLetter
op_ne
l_char|&squot; &squot;
op_logical_and
id|FirmwareVersionLetter
op_ne
l_char|&squot;&bslash;0&squot;
)paren
op_star
id|TargetPointer
op_increment
op_assign
id|FirmwareVersionLetter
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/*&n;    Determine the IRQ Channel and save it in the Host Adapter structure.&n;  */
r_if
c_cond
(paren
id|Configuration.IRQ_Channel9
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|9
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.IRQ_Channel10
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.IRQ_Channel11
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|11
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.IRQ_Channel12
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|12
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.IRQ_Channel14
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|14
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.IRQ_Channel15
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|15
suffix:semicolon
multiline_comment|/*&n;    Determine the DMA Channel and save it in the Host Adapter structure.&n;  */
r_if
c_cond
(paren
id|Configuration.DMA_Channel5
)paren
id|HostAdapter-&gt;DMA_Channel
op_assign
l_int|5
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.DMA_Channel6
)paren
id|HostAdapter-&gt;DMA_Channel
op_assign
l_int|6
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.DMA_Channel7
)paren
id|HostAdapter-&gt;DMA_Channel
op_assign
l_int|7
suffix:semicolon
multiline_comment|/*&n;    Save the Host Adapter SCSI ID in the Host Adapter structure.&n;  */
id|HostAdapter-&gt;SCSI_ID
op_assign
id|Configuration.HostAdapterID
suffix:semicolon
multiline_comment|/*&n;    Save the Synchronous Initiation flag and SCSI Parity Checking flag&n;    in the Host Adapter structure.&n;  */
id|HostAdapter-&gt;SynchronousInitiation
op_assign
id|SetupInformation.SynchronousInitiationEnabled
suffix:semicolon
id|HostAdapter-&gt;ParityChecking
op_assign
id|SetupInformation.ParityCheckEnabled
suffix:semicolon
multiline_comment|/*&n;    Determine the Bus Type and save it in the Host Adapter structure,&n;    overriding the DMA Channel if it is inappropriate for the bus type.&n;  */
r_switch
c_cond
(paren
id|HostAdapter-&gt;ModelName
(braket
l_int|3
)braket
)paren
(brace
r_case
l_char|&squot;4&squot;
suffix:colon
id|HostAdapter-&gt;BusType
op_assign
id|BusLogic_VESA_Bus
suffix:semicolon
id|HostAdapter-&gt;DMA_Channel
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;5&squot;
suffix:colon
id|HostAdapter-&gt;BusType
op_assign
id|BusLogic_ISA_Bus
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;6&squot;
suffix:colon
id|HostAdapter-&gt;BusType
op_assign
id|BusLogic_MCA_Bus
suffix:semicolon
id|HostAdapter-&gt;DMA_Channel
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;7&squot;
suffix:colon
id|HostAdapter-&gt;BusType
op_assign
id|BusLogic_EISA_Bus
suffix:semicolon
id|HostAdapter-&gt;DMA_Channel
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;9&squot;
suffix:colon
id|HostAdapter-&gt;BusType
op_assign
id|BusLogic_PCI_Bus
suffix:semicolon
id|HostAdapter-&gt;DMA_Channel
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;    Determine whether Extended Translation is enabled and save it in&n;    the Host Adapter structure.&n;  */
id|GeometryRegister
op_assign
id|BusLogic_ReadGeometryRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GeometryRegister
op_amp
id|BusLogic_ExtendedTranslationEnabled
)paren
id|HostAdapter-&gt;ExtendedTranslation
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/*&n;    Save the Disconnect/Reconnect Permitted flag bits in the Host Adapter&n;    structure.  The Disconnect Permitted information is only valid on &quot;W&quot; and&n;    &quot;C&quot; Series boards, but Disconnect/Reconnect is always permitted on &quot;S&quot; and&n;    &quot;A&quot; Series boards.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_ge
l_char|&squot;4&squot;
)paren
id|HostAdapter-&gt;DisconnectPermitted
op_assign
(paren
id|SetupInformation.DisconnectPermittedID8to15
op_lshift
l_int|8
)paren
op_or
id|SetupInformation.DisconnectPermittedID0to7
suffix:semicolon
r_else
id|HostAdapter-&gt;DisconnectPermitted
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/*&n;    Save the Scatter Gather Limits, Level Sensitive Interrupts flag, Wide&n;    SCSI flag, Differential SCSI flag, Automatic Configuration flag, and&n;    Ultra SCSI flag in the Host Adapter structure.&n;  */
id|HostAdapter-&gt;HostAdapterScatterGatherLimit
op_assign
id|ExtendedSetupInformation.ScatterGatherLimit
suffix:semicolon
id|HostAdapter-&gt;DriverScatterGatherLimit
op_assign
id|HostAdapter-&gt;HostAdapterScatterGatherLimit
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterScatterGatherLimit
OG
id|BusLogic_ScatterGatherLimit
)paren
id|HostAdapter-&gt;DriverScatterGatherLimit
op_assign
id|BusLogic_ScatterGatherLimit
suffix:semicolon
r_if
c_cond
(paren
id|ExtendedSetupInformation.Misc.LevelSensitiveInterrupts
)paren
id|HostAdapter-&gt;LevelSensitiveInterrupts
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;HostWideSCSI
op_assign
id|ExtendedSetupInformation.HostWideSCSI
suffix:semicolon
id|HostAdapter-&gt;HostDifferentialSCSI
op_assign
id|ExtendedSetupInformation.HostDifferentialSCSI
suffix:semicolon
id|HostAdapter-&gt;HostAutomaticConfiguration
op_assign
id|ExtendedSetupInformation.HostAutomaticConfiguration
suffix:semicolon
id|HostAdapter-&gt;HostUltraSCSI
op_assign
id|ExtendedSetupInformation.HostUltraSCSI
suffix:semicolon
multiline_comment|/*&n;    Determine the Host Adapter BIOS Address if the BIOS is enabled and&n;    save it in the Host Adapter structure.  The BIOS is disabled if the&n;    BIOS_Address is 0.&n;  */
id|HostAdapter-&gt;BIOS_Address
op_assign
id|ExtendedSetupInformation.BIOS_Address
op_lshift
l_int|12
suffix:semicolon
multiline_comment|/*&n;    ISA Host Adapters require Bounce Buffers if there is more than 16MB memory.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;BusType
op_eq
id|BusLogic_ISA_Bus
op_logical_and
id|high_memory
OG
id|MAX_DMA_ADDRESS
)paren
id|HostAdapter-&gt;BounceBuffersRequired
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/*&n;    BusLogic BT-445S Host Adapters prior to board revision E have a hardware&n;    bug whereby when the BIOS is enabled, transfers to/from the same address&n;    range the BIOS occupies modulo 16MB are handled incorrectly.  Only properly&n;    functioning BT-445S boards have firmware version 3.37, so we require that&n;    ISA Bounce Buffers be used for the buggy BT-445S models if there is more&n;    than 16MB memory.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;BIOS_Address
OG
l_int|0
op_logical_and
id|strcmp
c_func
(paren
id|HostAdapter-&gt;ModelName
comma
l_string|&quot;BT-445S&quot;
)paren
op_eq
l_int|0
op_logical_and
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;3.37&quot;
)paren
template_param
id|MAX_DMA_ADDRESS
)paren
id|HostAdapter-&gt;BounceBuffersRequired
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/*&n;    Determine the maximum number of Target IDs and Logical Units supported by&n;    this driver for Wide and Narrow Host Adapters.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;HostWideSCSI
)paren
(brace
id|HostAdapter-&gt;MaxTargetDevices
op_assign
l_int|16
suffix:semicolon
id|HostAdapter-&gt;MaxLogicalUnits
op_assign
l_int|64
suffix:semicolon
)brace
r_else
(brace
id|HostAdapter-&gt;MaxTargetDevices
op_assign
l_int|8
suffix:semicolon
id|HostAdapter-&gt;MaxLogicalUnits
op_assign
l_int|8
suffix:semicolon
)brace
multiline_comment|/*&n;    Select appropriate values for the Mailbox Count, Initial CCBs, and&n;    Incremental CCBs variables based on whether or not Strict Round Robin Mode&n;    is supported.  If Strict Round Robin Mode is supported, then there is no&n;    performance degradation in using the maximum possible number of Outgoing&n;    and Incoming Mailboxes and allowing the Tagged and Untagged Queue Depths to&n;    determine the actual utilization.  If Strict Round Robin Mode is not&n;    supported, then the Host Adapter must scan all the Outgoing Mailboxes&n;    whenever an Outgoing Mailbox entry is made, which can cause a substantial&n;    performance penalty.  The Host Adapters actually have room to store the&n;    following number of CCBs internally; that is, they can internally queue and&n;    manage this many active commands on the SCSI bus simultaneously.&n;    Performance measurements demonstrate that the Mailbox Count should be set&n;    to the maximum possible, rather than the internal CCB capacity, as it is&n;    more efficient to have the queued commands waiting in Outgoing Mailboxes if&n;    necessary than to block the process in the higher levels of the SCSI&n;    Subsystem.&n;&n;&t;192&t;  BT-948/958/958D&n;&t;100&t;  BT-946C/956C/956CD/747C/757C/757CD/445C&n;&t; 50&t;  BT-545C/540CF&n;&t; 30&t;  BT-747S/747D/757S/757D/445S/545S/542D/542B/742A&n;  */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;3.31&quot;
)paren
op_ge
l_int|0
)paren
(brace
id|HostAdapter-&gt;StrictRoundRobinModeSupported
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;MailboxCount
op_assign
l_int|255
suffix:semicolon
id|HostAdapter-&gt;InitialCCBs
op_assign
l_int|64
suffix:semicolon
id|HostAdapter-&gt;IncrementalCCBs
op_assign
l_int|32
suffix:semicolon
)brace
r_else
(brace
id|HostAdapter-&gt;StrictRoundRobinModeSupported
op_assign
l_bool|false
suffix:semicolon
id|HostAdapter-&gt;MailboxCount
op_assign
l_int|32
suffix:semicolon
id|HostAdapter-&gt;InitialCCBs
op_assign
l_int|32
suffix:semicolon
id|HostAdapter-&gt;IncrementalCCBs
op_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_eq
l_char|&squot;5&squot;
)paren
id|HostAdapter-&gt;TotalQueueDepth
op_assign
l_int|192
suffix:semicolon
r_else
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_eq
l_char|&squot;4&squot;
)paren
id|HostAdapter-&gt;TotalQueueDepth
op_assign
(paren
id|HostAdapter-&gt;BusType
op_ne
id|BusLogic_ISA_Bus
ques
c_cond
l_int|100
suffix:colon
l_int|50
)paren
suffix:semicolon
r_else
id|HostAdapter-&gt;TotalQueueDepth
op_assign
l_int|30
suffix:semicolon
multiline_comment|/*&n;    Select an appropriate value for the Tagged Queue Depth either from a&n;    Command Line Entry, or based on whether this Host Adapter requires that&n;    ISA Bounce Buffers be used.  The Tagged Queue Depth is left at 0 for&n;    automatic determination in BusLogic_SelectQueueDepths.  Initialize the&n;    Untagged Queue Depth.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;CommandLineEntry
op_ne
l_int|NULL
op_logical_and
id|HostAdapter-&gt;CommandLineEntry-&gt;TaggedQueueDepth
OG
l_int|0
)paren
id|HostAdapter-&gt;TaggedQueueDepth
op_assign
id|HostAdapter-&gt;CommandLineEntry-&gt;TaggedQueueDepth
suffix:semicolon
r_else
r_if
c_cond
(paren
id|HostAdapter-&gt;BounceBuffersRequired
)paren
id|HostAdapter-&gt;TaggedQueueDepth
op_assign
id|BusLogic_TaggedQueueDepth_BB
suffix:semicolon
r_else
id|HostAdapter-&gt;TaggedQueueDepth
op_assign
l_int|0
suffix:semicolon
id|HostAdapter-&gt;UntaggedQueueDepth
op_assign
id|BusLogic_UntaggedQueueDepth
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;UntaggedQueueDepth
OG
id|HostAdapter-&gt;TaggedQueueDepth
op_logical_and
id|HostAdapter-&gt;TaggedQueueDepth
OG
l_int|0
)paren
id|HostAdapter-&gt;UntaggedQueueDepth
op_assign
id|HostAdapter-&gt;TaggedQueueDepth
suffix:semicolon
multiline_comment|/*&n;    Select an appropriate value for Bus Settle Time either from a Command&n;    Line Entry, or from BusLogic_DefaultBusSettleTime.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;CommandLineEntry
op_ne
l_int|NULL
op_logical_and
id|HostAdapter-&gt;CommandLineEntry-&gt;BusSettleTime
OG
l_int|0
)paren
id|HostAdapter-&gt;BusSettleTime
op_assign
id|HostAdapter-&gt;CommandLineEntry-&gt;BusSettleTime
suffix:semicolon
r_else
id|HostAdapter-&gt;BusSettleTime
op_assign
id|BusLogic_DefaultBusSettleTime
suffix:semicolon
multiline_comment|/*&n;    Select an appropriate value for Local Options from a Command Line Entry.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;CommandLineEntry
op_ne
l_int|NULL
)paren
id|HostAdapter-&gt;LocalOptions
op_assign
id|HostAdapter-&gt;CommandLineEntry-&gt;LocalOptions
suffix:semicolon
multiline_comment|/*&n;    Select appropriate values for the Error Recovery Strategy array either from&n;    a Command Line Entry, or using BusLogic_ErrorRecovery_Default.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;CommandLineEntry
op_ne
l_int|NULL
)paren
id|memcpy
c_func
(paren
id|HostAdapter-&gt;ErrorRecoveryStrategy
comma
id|HostAdapter-&gt;CommandLineEntry-&gt;ErrorRecoveryStrategy
comma
r_sizeof
(paren
id|HostAdapter-&gt;ErrorRecoveryStrategy
)paren
)paren
suffix:semicolon
r_else
id|memset
c_func
(paren
id|HostAdapter-&gt;ErrorRecoveryStrategy
comma
id|BusLogic_ErrorRecovery_Default
comma
r_sizeof
(paren
id|HostAdapter-&gt;ErrorRecoveryStrategy
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;    Tagged Queuing support is available and operates properly on all &quot;W&quot; Series&n;    boards, on &quot;C&quot; Series boards with firmware version 4.22 and above, and on&n;    &quot;S&quot; Series boards with firmware version 3.35 and above.  Tagged Queuing is&n;    disabled by default when the Tagged Queue Depth is 1 since queuing multiple&n;    commands is not possible.&n;  */
id|TaggedQueuingPermittedDefault
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;TaggedQueueDepth
op_ne
l_int|1
)paren
r_switch
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;5&squot;
suffix:colon
id|TaggedQueuingPermittedDefault
op_assign
l_int|0xFFFF
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;4&squot;
suffix:colon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;4.22&quot;
)paren
op_ge
l_int|0
)paren
id|TaggedQueuingPermittedDefault
op_assign
l_int|0xFFFF
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;3&squot;
suffix:colon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;3.35&quot;
)paren
op_ge
l_int|0
)paren
id|TaggedQueuingPermittedDefault
op_assign
l_int|0xFFFF
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;    Tagged Queuing is only useful if Disconnect/Reconnect is permitted.&n;    Therefore, mask the Tagged Queuing Permitted Default bits with the&n;    Disconnect/Reconnect Permitted bits.&n;  */
id|TaggedQueuingPermittedDefault
op_and_assign
id|HostAdapter-&gt;DisconnectPermitted
suffix:semicolon
multiline_comment|/*&n;    Combine the default Tagged Queuing Permitted bits with any Command&n;    Line Entry Tagged Queuing specification.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;CommandLineEntry
op_ne
l_int|NULL
)paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_assign
(paren
id|HostAdapter-&gt;CommandLineEntry-&gt;TaggedQueuingPermitted
op_amp
id|HostAdapter-&gt;CommandLineEntry-&gt;TaggedQueuingPermittedMask
)paren
op_or
(paren
id|TaggedQueuingPermittedDefault
op_amp
op_complement
id|HostAdapter-&gt;CommandLineEntry-&gt;TaggedQueuingPermittedMask
)paren
suffix:semicolon
r_else
id|HostAdapter-&gt;TaggedQueuingPermitted
op_assign
id|TaggedQueuingPermittedDefault
suffix:semicolon
multiline_comment|/*&n;    Announce the Host Adapter Configuration.&n;  */
id|printk
c_func
(paren
l_string|&quot;scsi%d: Configuring BusLogic Model %s %s%s%s%s SCSI Host Adapter&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|HostAdapter-&gt;ModelName
comma
id|BusLogic_BusNames
(braket
id|HostAdapter-&gt;BusType
)braket
comma
(paren
id|HostAdapter-&gt;HostWideSCSI
ques
c_cond
l_string|&quot; Wide&quot;
suffix:colon
l_string|&quot;&quot;
)paren
comma
(paren
id|HostAdapter-&gt;HostDifferentialSCSI
ques
c_cond
l_string|&quot; Differential&quot;
suffix:colon
l_string|&quot;&quot;
)paren
comma
(paren
id|HostAdapter-&gt;HostUltraSCSI
ques
c_cond
l_string|&quot; Ultra&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d:   Firmware Version: %s, I/O Address: 0x%X, &quot;
l_string|&quot;IRQ Channel: %d/%s&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|HostAdapter-&gt;FirmwareVersion
comma
id|HostAdapter-&gt;IO_Address
comma
id|HostAdapter-&gt;IRQ_Channel
comma
(paren
id|HostAdapter-&gt;LevelSensitiveInterrupts
ques
c_cond
l_string|&quot;Level&quot;
suffix:colon
l_string|&quot;Edge&quot;
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d:   DMA Channel: &quot;
comma
id|HostAdapter-&gt;HostNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;DMA_Channel
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%d, &quot;
comma
id|HostAdapter-&gt;DMA_Channel
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;None, &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;BIOS_Address
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;BIOS Address: 0x%lX, &quot;
comma
id|HostAdapter-&gt;BIOS_Address
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;BIOS Address: None, &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Host Adapter SCSI ID: %d&bslash;n&quot;
comma
id|HostAdapter-&gt;SCSI_ID
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d:   Scatter/Gather Limit: %d of %d segments, &quot;
l_string|&quot;Parity Checking: %s&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|HostAdapter-&gt;DriverScatterGatherLimit
comma
id|HostAdapter-&gt;HostAdapterScatterGatherLimit
comma
(paren
id|HostAdapter-&gt;ParityChecking
ques
c_cond
l_string|&quot;Enabled&quot;
suffix:colon
l_string|&quot;Disabled&quot;
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d:   Synchronous Initiation: %s, &quot;
l_string|&quot;Extended Disk Translation: %s&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
(paren
id|HostAdapter-&gt;SynchronousInitiation
ques
c_cond
l_string|&quot;Enabled&quot;
suffix:colon
l_string|&quot;Disabled&quot;
)paren
comma
(paren
id|HostAdapter-&gt;ExtendedTranslation
ques
c_cond
l_string|&quot;Enabled&quot;
suffix:colon
l_string|&quot;Disabled&quot;
)paren
)paren
suffix:semicolon
id|AllTargetsMask
op_assign
(paren
l_int|1
op_lshift
id|HostAdapter-&gt;MaxTargetDevices
)paren
op_minus
l_int|1
suffix:semicolon
id|DisconnectPermitted
op_assign
id|HostAdapter-&gt;DisconnectPermitted
op_amp
id|AllTargetsMask
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d:   Disconnect/Reconnect: &quot;
comma
id|HostAdapter-&gt;HostNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DisconnectPermitted
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;Disabled&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|DisconnectPermitted
op_eq
id|AllTargetsMask
)paren
id|printk
c_func
(paren
l_string|&quot;Enabled&quot;
)paren
suffix:semicolon
r_else
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
(paren
id|DisconnectPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
ques
c_cond
l_char|&squot;Y&squot;
suffix:colon
l_char|&squot;N&squot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, Tagged Queuing: &quot;
)paren
suffix:semicolon
id|TaggedQueuingPermitted
op_assign
id|HostAdapter-&gt;TaggedQueuingPermitted
op_amp
id|AllTargetsMask
suffix:semicolon
r_if
c_cond
(paren
id|TaggedQueuingPermitted
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;Disabled&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|TaggedQueuingPermitted
op_eq
id|AllTargetsMask
)paren
id|printk
c_func
(paren
l_string|&quot;Enabled&quot;
)paren
suffix:semicolon
r_else
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
(paren
id|TaggedQueuingPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
ques
c_cond
l_char|&squot;Y&squot;
suffix:colon
l_char|&squot;N&squot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d:   Total Queue Depth: %d, Mailboxes: %d, Initial CCBs: %d&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|HostAdapter-&gt;TotalQueueDepth
comma
id|HostAdapter-&gt;MailboxCount
comma
id|HostAdapter-&gt;InitialCCBs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d:   Tagged Queue Depth: &quot;
comma
id|HostAdapter-&gt;HostNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;TaggedQueueDepth
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%d&quot;
comma
id|HostAdapter-&gt;TaggedQueueDepth
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;Automatic&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, Untagged Queue Depth: %d&bslash;n&quot;
comma
id|HostAdapter-&gt;UntaggedQueueDepth
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;TerminationInfoValid
)paren
r_if
c_cond
(paren
id|HostAdapter-&gt;HostWideSCSI
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d:   Host Adapter SCSI Bus Termination (Low/High): %s/%s&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
(paren
id|HostAdapter-&gt;LowByteTerminated
ques
c_cond
l_string|&quot;Enabled&quot;
suffix:colon
l_string|&quot;Disabled&quot;
)paren
comma
(paren
id|HostAdapter-&gt;HighByteTerminated
ques
c_cond
l_string|&quot;Enabled&quot;
suffix:colon
l_string|&quot;Disabled&quot;
)paren
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;scsi%d:   Host Adapter SCSI Bus Termination: %s&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
(paren
id|HostAdapter-&gt;LowByteTerminated
ques
c_cond
l_string|&quot;Enabled&quot;
suffix:colon
l_string|&quot;Disabled&quot;
)paren
)paren
suffix:semicolon
id|CommonErrorRecovery
op_assign
l_bool|true
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|1
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
r_if
c_cond
(paren
id|HostAdapter-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
op_ne
id|HostAdapter-&gt;ErrorRecoveryStrategy
(braket
l_int|0
)braket
)paren
(brace
id|CommonErrorRecovery
op_assign
l_bool|false
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi%d:   Error Recovery Strategy: &quot;
comma
id|HostAdapter-&gt;HostNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CommonErrorRecovery
)paren
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|BusLogic_ErrorRecoveryStrategyNames
(braket
id|HostAdapter-&gt;ErrorRecoveryStrategy
(braket
l_int|0
)braket
)braket
)paren
suffix:semicolon
r_else
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|BusLogic_ErrorRecoveryStrategyLetters
(braket
id|HostAdapter-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;    Indicate reading the Host Adapter Configuration completed successfully.&n;  */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_AcquireResources acquires the system resources necessary to use&n;  Host Adapter.&n;*/
DECL|function|BusLogic_AcquireResources
r_static
id|boolean
id|BusLogic_AcquireResources
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
r_if
c_cond
(paren
id|HostAdapter-&gt;IRQ_Channel
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: NO INTERRUPT CHANNEL ASSIGNED - DETACHING&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/*&n;    Acquire exclusive or shared access to the IRQ Channel.  A usage count is&n;    maintained so that PCI, EISA, or MCA shared interrupts can be supported.&n;  */
r_if
c_cond
(paren
id|BusLogic_IRQ_UsageCount
(braket
id|HostAdapter-&gt;IRQ_Channel
op_minus
l_int|9
)braket
op_increment
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|HostAdapter-&gt;IRQ_Channel
comma
id|BusLogic_InterruptHandler
comma
id|SA_INTERRUPT
op_or
id|SA_SHIRQ
comma
id|HostAdapter-&gt;InterruptLabel
comma
l_int|NULL
)paren
OL
l_int|0
)paren
(brace
id|BusLogic_IRQ_UsageCount
(braket
id|HostAdapter-&gt;IRQ_Channel
op_minus
l_int|9
)braket
op_decrement
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d: UNABLE TO ACQUIRE IRQ CHANNEL %d - DETACHING&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|HostAdapter-&gt;IRQ_Channel
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
)brace
r_else
(brace
id|BusLogic_HostAdapter_T
op_star
id|FirstHostAdapter
op_assign
id|BusLogic_RegisteredHostAdapters
suffix:semicolon
r_while
c_loop
(paren
id|FirstHostAdapter
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|FirstHostAdapter-&gt;IRQ_Channel
op_eq
id|HostAdapter-&gt;IRQ_Channel
)paren
(brace
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|FirstHostAdapter-&gt;InterruptLabel
)paren
op_plus
l_int|11
OL
r_sizeof
(paren
id|FirstHostAdapter-&gt;InterruptLabel
)paren
)paren
(brace
id|strcat
c_func
(paren
id|FirstHostAdapter-&gt;InterruptLabel
comma
l_string|&quot; + &quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|FirstHostAdapter-&gt;InterruptLabel
comma
id|HostAdapter-&gt;ModelName
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|FirstHostAdapter
op_assign
id|FirstHostAdapter-&gt;Next
suffix:semicolon
)brace
)brace
id|HostAdapter-&gt;IRQ_ChannelAcquired
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/*&n;    Acquire exclusive access to the DMA Channel.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;DMA_Channel
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|HostAdapter-&gt;DMA_Channel
comma
id|HostAdapter-&gt;BoardName
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: UNABLE TO ACQUIRE DMA CHANNEL %d - DETACHING&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|HostAdapter-&gt;DMA_Channel
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
id|set_dma_mode
c_func
(paren
id|HostAdapter-&gt;DMA_Channel
comma
id|DMA_MODE_CASCADE
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|HostAdapter-&gt;DMA_Channel
)paren
suffix:semicolon
id|HostAdapter-&gt;DMA_ChannelAcquired
op_assign
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;    Indicate the System Resource Acquisition completed successfully,&n;  */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ReleaseResources releases any system resources previously acquired&n;  by BusLogic_AcquireResources.&n;*/
DECL|function|BusLogic_ReleaseResources
r_static
r_void
id|BusLogic_ReleaseResources
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
multiline_comment|/*&n;    Release exclusive or shared access to the IRQ Channel.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;IRQ_ChannelAcquired
)paren
r_if
c_cond
(paren
op_decrement
id|BusLogic_IRQ_UsageCount
(braket
id|HostAdapter-&gt;IRQ_Channel
op_minus
l_int|9
)braket
op_eq
l_int|0
)paren
id|free_irq
c_func
(paren
id|HostAdapter-&gt;IRQ_Channel
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;    Release exclusive access to the DMA Channel.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;DMA_ChannelAcquired
)paren
id|free_dma
c_func
(paren
id|HostAdapter-&gt;DMA_Channel
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_TestInterrupts tests for proper functioning of the Host Adapter&n;  Interrupt Register and that interrupts generated by the Host Adapter are&n;  getting through to the Interrupt Handler.  A large proportion of initial&n;  problems with installing PCI Host Adapters are due to configuration problems&n;  where either the Host Adapter or Motherboard is configured incorrectly, and&n;  interrupts do not get through as a result.&n;*/
DECL|function|BusLogic_TestInterrupts
r_static
id|boolean
id|BusLogic_TestInterrupts
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
r_int
r_int
id|InitialInterruptCount
comma
id|FinalInterruptCount
suffix:semicolon
r_int
id|TestCount
op_assign
l_int|5
comma
id|i
suffix:semicolon
id|InitialInterruptCount
op_assign
id|kstat.interrupts
(braket
id|HostAdapter-&gt;IRQ_Channel
)braket
suffix:semicolon
multiline_comment|/*&n;    Issue the Test Command Complete Interrupt commands.&n;  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TestCount
suffix:semicolon
id|i
op_increment
)paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_TestCommandCompleteInterrupt
comma
l_int|NULL
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;    Verify that BusLogic_InterruptHandler was called at least TestCount times.&n;    Shared IRQ Channels could cause more than TestCount interrupts to occur,&n;    but there should never be fewer than TestCount.&n;  */
id|FinalInterruptCount
op_assign
id|kstat.interrupts
(braket
id|HostAdapter-&gt;IRQ_Channel
)braket
suffix:semicolon
r_if
c_cond
(paren
id|FinalInterruptCount
OL
id|InitialInterruptCount
op_plus
id|TestCount
)paren
(brace
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;HOST ADAPTER INTERRUPT TEST&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&bslash;&n;Interrupts are not getting through from the Host Adapter to the BusLogic&bslash;n&bslash;&n;Driver Interrupt Handler. The most likely cause is that either the Host&bslash;n&bslash;&n;Adapter or Motherboard is configured incorrectly.  Please check the Host&bslash;n&bslash;&n;Adapter configuration with AutoSCSI or by examining any dip switch and&bslash;n&bslash;&n;jumper settings on the Host Adapter, and verify that no other device is&bslash;n&bslash;&n;attempting to use the same IRQ Channel.  For PCI Host Adapters, it may also&bslash;n&bslash;&n;be necessary to investigate and manually set the PCI interrupt assignments&bslash;n&bslash;&n;and edge/level interrupt type selection in the BIOS Setup Program or with&bslash;n&bslash;&n;Motherboard jumpers.&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/*&n;    Indicate the Host Adapter Interrupt Test completed successfully.&n;  */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InitializeHostAdapter initializes Host Adapter.  This is the only&n;  function called during SCSI Host Adapter detection which modifies the state&n;  of the Host Adapter from its initial power on or hard reset state.&n;*/
DECL|function|BusLogic_InitializeHostAdapter
r_static
id|boolean
id|BusLogic_InitializeHostAdapter
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
id|BusLogic_ExtendedMailboxRequest_T
id|ExtendedMailboxRequest
suffix:semicolon
id|BusLogic_RoundRobinModeRequest_T
id|RoundRobinModeRequest
suffix:semicolon
id|BusLogic_WideModeCCBRequest_T
id|WideModeCCBRequest
suffix:semicolon
id|BusLogic_ModifyIOAddressRequest_T
id|ModifyIOAddressRequest
suffix:semicolon
r_int
id|TargetID
suffix:semicolon
multiline_comment|/*&n;    Initialize the Bus Device Reset Pending CCB, Tagged Queuing Active,&n;    Command Successful Flag, Active Command Count, and Total Command Count&n;    for each Target Device.&n;  */
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|HostAdapter-&gt;BusDeviceResetPendingCCB
(braket
id|TargetID
)braket
op_assign
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|HostAdapter-&gt;TaggedQueuingActive
comma
l_bool|false
comma
r_sizeof
(paren
id|HostAdapter-&gt;TaggedQueuingActive
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|HostAdapter-&gt;CommandSuccessfulFlag
comma
l_bool|false
comma
r_sizeof
(paren
id|HostAdapter-&gt;CommandSuccessfulFlag
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|HostAdapter-&gt;ActiveCommandCount
comma
l_int|0
comma
r_sizeof
(paren
id|HostAdapter-&gt;ActiveCommandCount
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|HostAdapter-&gt;TotalCommandCount
comma
l_int|0
comma
r_sizeof
(paren
id|HostAdapter-&gt;TotalCommandCount
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;    Initialize the Outgoing and Incoming Mailbox structures.&n;  */
id|memset
c_func
(paren
id|HostAdapter-&gt;FirstOutgoingMailbox
comma
l_int|0
comma
id|HostAdapter-&gt;MailboxCount
op_star
r_sizeof
(paren
id|BusLogic_OutgoingMailbox_T
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|HostAdapter-&gt;FirstIncomingMailbox
comma
l_int|0
comma
id|HostAdapter-&gt;MailboxCount
op_star
r_sizeof
(paren
id|BusLogic_IncomingMailbox_T
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;    Initialize the pointers to the Next Mailboxes.&n;  */
id|HostAdapter-&gt;NextOutgoingMailbox
op_assign
id|HostAdapter-&gt;FirstOutgoingMailbox
suffix:semicolon
id|HostAdapter-&gt;NextIncomingMailbox
op_assign
id|HostAdapter-&gt;FirstIncomingMailbox
suffix:semicolon
multiline_comment|/*&n;    Initialize the Host Adapter&squot;s Pointer to the Outgoing/Incoming Mailboxes.&n;  */
id|ExtendedMailboxRequest.MailboxCount
op_assign
id|HostAdapter-&gt;MailboxCount
suffix:semicolon
id|ExtendedMailboxRequest.BaseMailboxAddress
op_assign
id|HostAdapter-&gt;FirstOutgoingMailbox
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InitializeExtendedMailbox
comma
op_amp
id|ExtendedMailboxRequest
comma
r_sizeof
(paren
id|ExtendedMailboxRequest
)paren
comma
l_int|NULL
comma
l_int|0
)paren
OL
l_int|0
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;MAILBOX INITIALIZATION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;    Enable Strict Round Robin Mode if supported by the Host Adapter.  In&n;    Strict Round Robin Mode, the Host Adapter only looks at the next Outgoing&n;    Mailbox for each new command, rather than scanning through all the&n;    Outgoing Mailboxes to find any that have new commands in them.  Strict&n;    Round Robin Mode is significantly more efficient.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;StrictRoundRobinModeSupported
)paren
(brace
id|RoundRobinModeRequest
op_assign
id|BusLogic_StrictRoundRobinMode
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_EnableStrictRoundRobinMode
comma
op_amp
id|RoundRobinModeRequest
comma
r_sizeof
(paren
id|RoundRobinModeRequest
)paren
comma
l_int|NULL
comma
l_int|0
)paren
OL
l_int|0
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;ENABLE STRICT ROUND ROBIN MODE&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    For Wide SCSI Host Adapters, issue the Enable Wide Mode CCB command to&n;    allow more than 8 Logical Units per Target Device to be supported.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;HostWideSCSI
)paren
(brace
id|WideModeCCBRequest
op_assign
id|BusLogic_WideModeCCB
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_EnableWideModeCCB
comma
op_amp
id|WideModeCCBRequest
comma
r_sizeof
(paren
id|WideModeCCBRequest
)paren
comma
l_int|NULL
comma
l_int|0
)paren
OL
l_int|0
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;ENABLE WIDE MODE CCB&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    For PCI Host Adapters being accessed through the PCI compliant I/O&n;    Address, disable the ISA compatible I/O Address to avoid detecting the&n;    same Host Adapter at both I/O Addresses.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;BusType
op_eq
id|BusLogic_PCI_Bus
)paren
(brace
r_int
id|Index
suffix:semicolon
r_for
c_loop
(paren
id|Index
op_assign
l_int|0
suffix:semicolon
id|BusLogic_IO_StandardAddresses
(braket
id|Index
)braket
OG
l_int|0
suffix:semicolon
id|Index
op_increment
)paren
r_if
c_cond
(paren
id|HostAdapter-&gt;IO_Address
op_eq
id|BusLogic_IO_StandardAddresses
(braket
id|Index
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_IO_StandardAddresses
(braket
id|Index
)braket
op_eq
l_int|0
)paren
(brace
id|ModifyIOAddressRequest
op_assign
id|BusLogic_ModifyIO_Disable
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_ModifyIOAddress
comma
op_amp
id|ModifyIOAddressRequest
comma
r_sizeof
(paren
id|ModifyIOAddressRequest
)paren
comma
l_int|NULL
comma
l_int|0
)paren
OL
l_int|0
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;MODIFY I/O ADDRESS&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;    Announce Successful Initialization.&n;  */
id|printk
c_func
(paren
l_string|&quot;scsi%d: *** %s Initialized Successfully ***&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|HostAdapter-&gt;BoardName
)paren
suffix:semicolon
multiline_comment|/*&n;    Indicate the Host Adapter Initialization completed successfully.&n;  */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InquireTargetDevices inquires about the Target Devices accessible&n;  through Host Adapter and reports on the results.&n;*/
DECL|function|BusLogic_InquireTargetDevices
r_static
id|boolean
id|BusLogic_InquireTargetDevices
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
id|BusLogic_InstalledDevices_T
id|InstalledDevices
suffix:semicolon
id|BusLogic_InstalledDevices8_T
id|InstalledDevicesID0to7
suffix:semicolon
id|BusLogic_SetupInformation_T
id|SetupInformation
suffix:semicolon
id|BusLogic_SynchronousPeriod_T
id|SynchronousPeriod
suffix:semicolon
id|BusLogic_RequestedReplyLength_T
id|RequestedReplyLength
suffix:semicolon
r_int
id|TargetDevicesFound
op_assign
l_int|0
comma
id|TargetID
suffix:semicolon
multiline_comment|/*&n;    Wait a few seconds between the Host Adapter Hard Reset which initiates&n;    a SCSI Bus Reset and issuing any SCSI Commands.  Some SCSI devices get&n;    confused if they receive SCSI Commands too soon after a SCSI Bus Reset.&n;  */
id|BusLogic_Delay
c_func
(paren
id|HostAdapter-&gt;BusSettleTime
)paren
suffix:semicolon
multiline_comment|/*&n;    Inhibit the Target Devices Inquiry if requested.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;LocalOptions
op_amp
id|BusLogic_InhibitTargetInquiry
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d:   Target Device Inquiry Inhibited&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;    Issue the Inquire Devices command for &quot;W&quot; and &quot;C&quot; Series boards or the&n;    Inquire Installed Devices ID 0 to 7 command for &quot;S&quot; and &quot;A&quot; Series boards.&n;    This is necessary to force Synchronous Transfer Negotiation so that the&n;    Inquire Setup Information and Inquire Synchronous Period commands will&n;    return valid data.  The Inquire Devices command is preferable to Inquire&n;    Installed Devices ID 0 to 7 since it only probes Logical Unit 0 of each&n;    Target Device.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_ge
l_char|&squot;4&squot;
)paren
(brace
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireDevices
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|InstalledDevices
comma
r_sizeof
(paren
id|InstalledDevices
)paren
)paren
op_ne
r_sizeof
(paren
id|InstalledDevices
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE DEVICES&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireInstalledDevicesID0to7
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|InstalledDevicesID0to7
comma
r_sizeof
(paren
id|InstalledDevicesID0to7
)paren
)paren
op_ne
r_sizeof
(paren
id|InstalledDevicesID0to7
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE INSTALLED DEVICES ID 0 TO 7&quot;
)paren
suffix:semicolon
id|InstalledDevices
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
l_int|8
suffix:semicolon
id|TargetID
op_increment
)paren
r_if
c_cond
(paren
id|InstalledDevicesID0to7
(braket
id|TargetID
)braket
op_ne
l_int|0
)paren
id|InstalledDevices
op_or_assign
(paren
l_int|1
op_lshift
id|TargetID
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    Issue the Inquire Setup Information command.&n;  */
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|SetupInformation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireSetupInformation
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|SetupInformation
comma
r_sizeof
(paren
id|SetupInformation
)paren
)paren
op_ne
r_sizeof
(paren
id|SetupInformation
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE SETUP INFORMATION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Synchronous Period command.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_ge
l_char|&squot;3&squot;
)paren
(brace
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|SynchronousPeriod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireSynchronousPeriod
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|SynchronousPeriod
comma
r_sizeof
(paren
id|SynchronousPeriod
)paren
)paren
op_ne
r_sizeof
(paren
id|SynchronousPeriod
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE SYNCHRONOUS PERIOD&quot;
)paren
suffix:semicolon
)brace
r_else
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
r_if
c_cond
(paren
id|SetupInformation.SynchronousValuesID0to7
(braket
id|TargetID
)braket
dot
id|Offset
OG
l_int|0
)paren
id|SynchronousPeriod
(braket
id|TargetID
)braket
op_assign
l_int|20
op_plus
l_int|5
op_star
id|SetupInformation.SynchronousValuesID0to7
(braket
id|TargetID
)braket
dot
id|TransferPeriod
suffix:semicolon
r_else
id|SynchronousPeriod
(braket
id|TargetID
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;    Save the Installed Devices, Synchronous Values, and Synchronous Period&n;    information in the Host Adapter structure.&n;  */
id|HostAdapter-&gt;InstalledDevices
op_assign
id|InstalledDevices
suffix:semicolon
id|memcpy
c_func
(paren
id|HostAdapter-&gt;SynchronousValues
comma
id|SetupInformation.SynchronousValuesID0to7
comma
r_sizeof
(paren
id|BusLogic_SynchronousValues8_T
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostWideSCSI
)paren
id|memcpy
c_func
(paren
op_amp
id|HostAdapter-&gt;SynchronousValues
(braket
l_int|8
)braket
comma
id|SetupInformation.SynchronousValuesID8to15
comma
r_sizeof
(paren
id|BusLogic_SynchronousValues8_T
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|HostAdapter-&gt;SynchronousPeriod
comma
id|SynchronousPeriod
comma
r_sizeof
(paren
id|BusLogic_SynchronousPeriod_T
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;    Report on the Target Devices found.&n;  */
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
r_if
c_cond
(paren
id|HostAdapter-&gt;InstalledDevices
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
(brace
r_int
id|SynchronousPeriod
op_assign
id|HostAdapter-&gt;SynchronousPeriod
(braket
id|TargetID
)braket
suffix:semicolon
r_if
c_cond
(paren
id|SynchronousPeriod
OG
l_int|10
)paren
(brace
r_int
id|SynchronousTransferRate
op_assign
l_int|100000000
op_div
id|SynchronousPeriod
suffix:semicolon
r_int
id|RoundedSynchronousTransferRate
op_assign
(paren
id|SynchronousTransferRate
op_plus
l_int|5000
)paren
op_div
l_int|10000
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d:   Target %d: Synchronous at &quot;
l_string|&quot;%d.%02d mega-transfers/second, offset %d&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
comma
id|RoundedSynchronousTransferRate
op_div
l_int|100
comma
id|RoundedSynchronousTransferRate
op_mod
l_int|100
comma
id|HostAdapter-&gt;SynchronousValues
(braket
id|TargetID
)braket
dot
id|Offset
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SynchronousPeriod
OG
l_int|0
)paren
(brace
r_int
id|SynchronousTransferRate
op_assign
l_int|100000000
op_div
id|SynchronousPeriod
suffix:semicolon
r_int
id|RoundedSynchronousTransferRate
op_assign
(paren
id|SynchronousTransferRate
op_plus
l_int|50000
)paren
op_div
l_int|100000
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d:   Target %d: Synchronous at &quot;
l_string|&quot;%d.%01d mega-transfers/second, offset %d&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
comma
id|RoundedSynchronousTransferRate
op_div
l_int|10
comma
id|RoundedSynchronousTransferRate
op_mod
l_int|10
comma
id|HostAdapter-&gt;SynchronousValues
(braket
id|TargetID
)braket
dot
id|Offset
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;scsi%d:   Target %d: Asynchronous&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
)paren
suffix:semicolon
id|TargetDevicesFound
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TargetDevicesFound
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d:   No Target Devices Found&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
)paren
suffix:semicolon
multiline_comment|/*&n;    Indicate the Target Device Inquiry completed successfully.&n;  */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InitializeHostStructure initializes the fields in the SCSI Host&n;  structure.  The base, io_port, n_io_ports, irq, and dma_channel fields in the&n;  SCSI Host structure are intentionally left uninitialized, as this driver&n;  handles acquisition and release of these resources explicitly, as well as&n;  ensuring exclusive access to the Host Adapter hardware and data structures&n;  through explicit acquisition and release of the Host Adapter&squot;s Lock.&n;*/
DECL|function|BusLogic_InitializeHostStructure
r_static
r_void
id|BusLogic_InitializeHostStructure
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
comma
id|SCSI_Host_T
op_star
id|Host
)paren
(brace
id|Host-&gt;max_id
op_assign
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|Host-&gt;max_lun
op_assign
id|HostAdapter-&gt;MaxLogicalUnits
suffix:semicolon
id|Host-&gt;max_channel
op_assign
l_int|0
suffix:semicolon
id|Host-&gt;unique_id
op_assign
id|HostAdapter-&gt;IO_Address
suffix:semicolon
id|Host-&gt;this_id
op_assign
id|HostAdapter-&gt;SCSI_ID
suffix:semicolon
id|Host-&gt;can_queue
op_assign
id|HostAdapter-&gt;MailboxCount
suffix:semicolon
id|Host-&gt;sg_tablesize
op_assign
id|HostAdapter-&gt;DriverScatterGatherLimit
suffix:semicolon
id|Host-&gt;unchecked_isa_dma
op_assign
id|HostAdapter-&gt;BounceBuffersRequired
suffix:semicolon
id|Host-&gt;cmd_per_lun
op_assign
id|HostAdapter-&gt;UntaggedQueueDepth
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_SelectQueueDepths selects Queue Depths for each Target Device&n;  based on the Host Adapter&squot;s Total Queue Depth and the number, type, speed,&n;  and capabilities of the Target Devices.&n;*/
DECL|function|BusLogic_SelectQueueDepths
r_static
r_void
id|BusLogic_SelectQueueDepths
c_func
(paren
id|SCSI_Host_T
op_star
id|Host
comma
id|SCSI_Device_T
op_star
id|DeviceList
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|Host-&gt;hostdata
suffix:semicolon
r_int
id|TaggedQueueDepth
op_assign
id|HostAdapter-&gt;TaggedQueueDepth
suffix:semicolon
r_int
id|UntaggedQueueDepth
op_assign
id|HostAdapter-&gt;UntaggedQueueDepth
suffix:semicolon
r_int
id|TaggedDeviceCount
op_assign
l_int|0
comma
id|UntaggedDeviceCount
op_assign
l_int|0
suffix:semicolon
id|SCSI_Device_T
op_star
id|Device
suffix:semicolon
r_for
c_loop
(paren
id|Device
op_assign
id|DeviceList
suffix:semicolon
id|Device
op_ne
l_int|NULL
suffix:semicolon
id|Device
op_assign
id|Device-&gt;next
)paren
r_if
c_cond
(paren
id|Device-&gt;host
op_eq
id|Host
)paren
(brace
r_if
c_cond
(paren
id|Device-&gt;tagged_supported
op_logical_and
(paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_amp
(paren
l_int|1
op_lshift
id|Device-&gt;id
)paren
)paren
)paren
id|TaggedDeviceCount
op_increment
suffix:semicolon
r_else
id|UntaggedDeviceCount
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TaggedQueueDepth
op_eq
l_int|0
op_logical_and
id|TaggedDeviceCount
OG
l_int|0
)paren
id|TaggedQueueDepth
op_assign
l_int|1
op_plus
(paren
(paren
id|HostAdapter-&gt;TotalQueueDepth
op_minus
id|UntaggedDeviceCount
op_star
id|UntaggedQueueDepth
)paren
op_div
id|TaggedDeviceCount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TaggedQueueDepth
OG
id|BusLogic_MaxTaggedQueueDepth
)paren
id|TaggedQueueDepth
op_assign
id|BusLogic_MaxTaggedQueueDepth
suffix:semicolon
r_for
c_loop
(paren
id|Device
op_assign
id|DeviceList
suffix:semicolon
id|Device
op_ne
l_int|NULL
suffix:semicolon
id|Device
op_assign
id|Device-&gt;next
)paren
r_if
c_cond
(paren
id|Device-&gt;host
op_eq
id|Host
)paren
(brace
r_if
c_cond
(paren
id|Device-&gt;tagged_supported
op_logical_and
(paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_amp
(paren
l_int|1
op_lshift
id|Device-&gt;id
)paren
)paren
)paren
id|Device-&gt;queue_depth
op_assign
id|TaggedQueueDepth
suffix:semicolon
r_else
id|Device-&gt;queue_depth
op_assign
id|UntaggedQueueDepth
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_GlobalOptions
op_amp
id|BusLogic_TraceQueueDepths
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d: Setting Queue Depth for Target %d to %d&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|Device-&gt;id
comma
id|Device-&gt;queue_depth
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;  BusLogic_DetectHostAdapter probes for BusLogic Host Adapters at the standard&n;  I/O Addresses where they may be located, initializing, registering, and&n;  reporting the configuration of each BusLogic Host Adapter it finds.  It&n;  returns the number of BusLogic Host Adapters successfully initialized and&n;  registered.&n;*/
DECL|function|BusLogic_DetectHostAdapter
r_int
id|BusLogic_DetectHostAdapter
c_func
(paren
id|SCSI_Host_Template_T
op_star
id|HostTemplate
)paren
(brace
r_int
id|BusLogicHostAdapterCount
op_assign
l_int|0
comma
id|CommandLineEntryIndex
op_assign
l_int|0
suffix:semicolon
r_int
id|AddressProbeIndex
op_assign
l_int|0
suffix:semicolon
id|BusLogic_InitializeAddressProbeList
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|BusLogic_IO_AddressProbeList
(braket
id|AddressProbeIndex
)braket
OG
l_int|0
)paren
(brace
id|BusLogic_HostAdapter_T
id|HostAdapterPrototype
suffix:semicolon
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
op_amp
id|HostAdapterPrototype
suffix:semicolon
id|SCSI_Host_T
op_star
id|Host
suffix:semicolon
id|memset
c_func
(paren
id|HostAdapter
comma
l_int|0
comma
r_sizeof
(paren
id|BusLogic_HostAdapter_T
)paren
)paren
suffix:semicolon
id|HostAdapter-&gt;IO_Address
op_assign
id|BusLogic_IO_AddressProbeList
(braket
id|AddressProbeIndex
op_increment
)braket
suffix:semicolon
multiline_comment|/*&n;&t;Initialize the Command Line Entry field if an explicit I/O Address&n;&t;was specified.&n;      */
r_if
c_cond
(paren
id|CommandLineEntryIndex
OL
id|BusLogic_CommandLineEntryCount
op_logical_and
id|BusLogic_CommandLineEntries
(braket
id|CommandLineEntryIndex
)braket
dot
id|IO_Address
op_eq
id|HostAdapter-&gt;IO_Address
)paren
id|HostAdapter-&gt;CommandLineEntry
op_assign
op_amp
id|BusLogic_CommandLineEntries
(braket
id|CommandLineEntryIndex
op_increment
)braket
suffix:semicolon
multiline_comment|/*&n;&t;Check whether the I/O Address range is already in use.&n;      */
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|HostAdapter-&gt;IO_Address
comma
id|BusLogic_IO_PortCount
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;Probe the Host Adapter.  If unsuccessful, abort further initialization.&n;      */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_ProbeHostAdapter
c_func
(paren
id|HostAdapter
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;Hard Reset the Host Adapter.  If unsuccessful, abort further&n;&t;initialization.&n;      */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_HardResetHostAdapter
c_func
(paren
id|HostAdapter
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;Check the Host Adapter.  If unsuccessful, abort further initialization.&n;      */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_CheckHostAdapter
c_func
(paren
id|HostAdapter
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;Initialize the Command Line Entry field if an explicit I/O Address&n;&t;was not specified.&n;      */
r_if
c_cond
(paren
id|CommandLineEntryIndex
OL
id|BusLogic_CommandLineEntryCount
op_logical_and
id|BusLogic_CommandLineEntries
(braket
id|CommandLineEntryIndex
)braket
dot
id|IO_Address
op_eq
l_int|0
)paren
id|HostAdapter-&gt;CommandLineEntry
op_assign
op_amp
id|BusLogic_CommandLineEntries
(braket
id|CommandLineEntryIndex
op_increment
)braket
suffix:semicolon
multiline_comment|/*&n;&t;Announce the Driver Version and Date, Author&squot;s Name, Copyright Notice,&n;&t;and Contact Address.&n;      */
id|BusLogic_AnnounceDriver
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;Register usage of the I/O Address range.  From this point onward, any&n;&t;failure will be assumed to be due to a problem with the Host Adapter,&n;&t;rather than due to having mistakenly identified this port as belonging&n;&t;to a BusLogic Host Adapter.  The I/O Address range will not be&n;&t;released, thereby preventing it from being incorrectly identified as&n;&t;any other type of Host Adapter.&n;      */
id|request_region
c_func
(paren
id|HostAdapter-&gt;IO_Address
comma
id|BusLogic_IO_PortCount
comma
l_string|&quot;BusLogic&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;Register the SCSI Host structure.&n;      */
id|HostTemplate-&gt;proc_dir
op_assign
op_amp
id|BusLogic_ProcDirectoryEntry
suffix:semicolon
id|Host
op_assign
id|scsi_register
c_func
(paren
id|HostTemplate
comma
r_sizeof
(paren
id|BusLogic_HostAdapter_T
)paren
)paren
suffix:semicolon
id|HostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|Host-&gt;hostdata
suffix:semicolon
id|memcpy
c_func
(paren
id|HostAdapter
comma
op_amp
id|HostAdapterPrototype
comma
r_sizeof
(paren
id|BusLogic_HostAdapter_T
)paren
)paren
suffix:semicolon
id|HostAdapter-&gt;SCSI_Host
op_assign
id|Host
suffix:semicolon
id|HostAdapter-&gt;HostNumber
op_assign
id|Host-&gt;host_no
suffix:semicolon
id|Host-&gt;select_queue_depths
op_assign
id|BusLogic_SelectQueueDepths
suffix:semicolon
multiline_comment|/*&n;&t;Add Host Adapter to the end of the list of registered BusLogic&n;&t;Host Adapters.  In order for Command Complete Interrupts to be&n;&t;properly dismissed by BusLogic_InterruptHandler, the Host Adapter&n;&t;must be registered.  This must be done before the IRQ Channel is&n;&t;acquired, and in a shared IRQ Channel environment, must be done&n;&t;before any Command Complete Interrupts occur, since the IRQ Channel&n;&t;may have already been acquired by a previous BusLogic Host Adapter.&n;      */
id|BusLogic_RegisterHostAdapter
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
multiline_comment|/*&n;&t;Read the Host Adapter Configuration, Acquire the System Resources&n;&t;necessary to use Host Adapter and initialize the fields in the SCSI&n;&t;Host structure, then Test Interrupts, Create the Mailboxes and CCBs,&n;&t;Initialize the Host Adapter, and finally Inquire about the Target&n;&t;Devices.&n;      */
r_if
c_cond
(paren
id|BusLogic_ReadHostAdapterConfiguration
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|BusLogic_AcquireResources
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|BusLogic_TestInterrupts
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|BusLogic_CreateMailboxes
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|BusLogic_CreateCCBs
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|BusLogic_InitializeHostAdapter
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|BusLogic_InquireTargetDevices
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
multiline_comment|/*&n;&t;    Initialization has been completed successfully.  Release and&n;&t;    re-register usage of the I/O Address range so that the Model&n;&t;    Name of the Host Adapter will appear, and initialize the SCSI&n;&t;    Host structure.&n;&t;  */
id|release_region
c_func
(paren
id|HostAdapter-&gt;IO_Address
comma
id|BusLogic_IO_PortCount
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|HostAdapter-&gt;IO_Address
comma
id|BusLogic_IO_PortCount
comma
id|HostAdapter-&gt;BoardName
)paren
suffix:semicolon
id|BusLogic_InitializeHostStructure
c_func
(paren
id|HostAdapter
comma
id|Host
)paren
suffix:semicolon
id|BusLogicHostAdapterCount
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;    An error occurred during Host Adapter Configuration Querying,&n;&t;    Resource Acquisition, Interrupt Testing, CCB Creation, Host Adapter&n;&t;    Initialization, or Target Device Inquiry, so remove Host Adapter&n;&t;    from the list of registered BusLogic Host Adapters, destroy the&n;&t;    CCBs and Mailboxes, Release the System Resources, and Unregister&n;&t;    the SCSI Host.&n;&t;  */
id|BusLogic_DestroyCCBs
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_DestroyMailboxes
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_ReleaseResources
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_UnregisterHostAdapter
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|scsi_unregister
c_func
(paren
id|Host
)paren
suffix:semicolon
)brace
)brace
r_return
id|BusLogicHostAdapterCount
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ReleaseHostAdapter releases all resources previously acquired to&n;  support a specific Host Adapter, including the I/O Address range, and&n;  unregisters the BusLogic Host Adapter.&n;*/
DECL|function|BusLogic_ReleaseHostAdapter
r_int
id|BusLogic_ReleaseHostAdapter
c_func
(paren
id|SCSI_Host_T
op_star
id|Host
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|Host-&gt;hostdata
suffix:semicolon
multiline_comment|/*&n;    Destroy the CCBs and Mailboxes, and release any system resources acquired&n;    to support Host Adapter.&n;  */
id|BusLogic_DestroyCCBs
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_DestroyMailboxes
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_ReleaseResources
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
multiline_comment|/*&n;    Release usage of the I/O Address range.&n;  */
id|release_region
c_func
(paren
id|HostAdapter-&gt;IO_Address
comma
id|BusLogic_IO_PortCount
)paren
suffix:semicolon
multiline_comment|/*&n;    Remove Host Adapter from the list of registered BusLogic Host Adapters.&n;  */
id|BusLogic_UnregisterHostAdapter
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ComputeResultCode computes a SCSI Subsystem Result Code from&n;  the Host Adapter Status and Target Device Status.&n;*/
DECL|function|BusLogic_ComputeResultCode
r_static
r_int
id|BusLogic_ComputeResultCode
c_func
(paren
id|BusLogic_HostAdapterStatus_T
id|HostAdapterStatus
comma
id|BusLogic_TargetDeviceStatus_T
id|TargetDeviceStatus
)paren
(brace
r_int
id|HostStatus
suffix:semicolon
r_switch
c_cond
(paren
id|HostAdapterStatus
)paren
(brace
r_case
id|BusLogic_CommandCompletedNormally
suffix:colon
r_case
id|BusLogic_LinkedCommandCompleted
suffix:colon
r_case
id|BusLogic_LinkedCommandCompletedWithFlag
suffix:colon
id|HostStatus
op_assign
id|DID_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_SCSISelectionTimeout
suffix:colon
id|HostStatus
op_assign
id|DID_TIME_OUT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_InvalidOutgoingMailboxActionCode
suffix:colon
r_case
id|BusLogic_InvalidCommandOperationCode
suffix:colon
r_case
id|BusLogic_InvalidCommandParameter
suffix:colon
id|printk
c_func
(paren
l_string|&quot;BusLogic: BusLogic Driver Protocol Error 0x%02X&bslash;n&quot;
comma
id|HostAdapterStatus
)paren
suffix:semicolon
r_case
id|BusLogic_DataOverUnderRun
suffix:colon
r_case
id|BusLogic_UnexpectedBusFree
suffix:colon
r_case
id|BusLogic_LinkedCCBhasInvalidLUN
suffix:colon
r_case
id|BusLogic_AutoRequestSenseFailed
suffix:colon
r_case
id|BusLogic_TaggedQueuingMessageRejected
suffix:colon
r_case
id|BusLogic_UnsupportedMessageReceived
suffix:colon
r_case
id|BusLogic_HostAdapterHardwareFailed
suffix:colon
r_case
id|BusLogic_TargetDeviceReconnectedImproperly
suffix:colon
r_case
id|BusLogic_AbortQueueGenerated
suffix:colon
r_case
id|BusLogic_HostAdapterSoftwareError
suffix:colon
r_case
id|BusLogic_HostAdapterHardwareTimeoutError
suffix:colon
r_case
id|BusLogic_SCSIParityErrorDetected
suffix:colon
id|HostStatus
op_assign
id|DID_ERROR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_InvalidBusPhaseRequested
suffix:colon
r_case
id|BusLogic_TargetFailedResponseToATN
suffix:colon
r_case
id|BusLogic_HostAdapterAssertedRST
suffix:colon
r_case
id|BusLogic_OtherDeviceAssertedRST
suffix:colon
r_case
id|BusLogic_HostAdapterAssertedBusDeviceReset
suffix:colon
id|HostStatus
op_assign
id|DID_RESET
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;BusLogic: unknown Host Adapter Status 0x%02X&bslash;n&quot;
comma
id|HostAdapterStatus
)paren
suffix:semicolon
id|HostStatus
op_assign
id|DID_ERROR
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
id|HostStatus
op_lshift
l_int|16
)paren
op_or
id|TargetDeviceStatus
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InterruptHandler handles hardware interrupts from BusLogic Host&n;  Adapters.  To simplify handling shared IRQ Channels, all installed BusLogic&n;  Host Adapters are scanned whenever any one of them signals a hardware&n;  interrupt.&n;*/
DECL|function|BusLogic_InterruptHandler
r_static
r_void
id|BusLogic_InterruptHandler
c_func
(paren
r_int
id|IRQ_Channel
comma
r_void
op_star
id|DeviceIdentifier
comma
id|Registers_T
op_star
id|InterruptRegisters
)paren
(brace
id|BusLogic_CCB_T
op_star
id|FirstCompletedCCB
op_assign
l_int|NULL
comma
op_star
id|LastCompletedCCB
op_assign
l_int|NULL
suffix:semicolon
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
suffix:semicolon
r_int
id|HostAdapterResetRequestedCount
op_assign
l_int|0
suffix:semicolon
id|BusLogic_Lock_T
id|Lock
suffix:semicolon
multiline_comment|/*&n;    Iterate over the installed BusLogic Host Adapters accepting any Incoming&n;    Mailbox entries and saving the completed CCBs for processing.  This&n;    interrupt handler is installed as a fast interrupt, so interrupts are&n;    disabled when the interrupt handler is entered.&n;  */
r_for
c_loop
(paren
id|HostAdapter
op_assign
id|BusLogic_RegisteredHostAdapters
suffix:semicolon
id|HostAdapter
op_ne
l_int|NULL
suffix:semicolon
id|HostAdapter
op_assign
id|HostAdapter-&gt;Next
)paren
(brace
r_int
r_char
id|InterruptRegister
suffix:semicolon
multiline_comment|/*&n;&t;Acquire exclusive access to Host Adapter.&n;      */
id|BusLogic_AcquireHostAdapterLockID
c_func
(paren
id|HostAdapter
comma
op_amp
id|Lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;Read the Host Adapter Interrupt Register.&n;      */
id|InterruptRegister
op_assign
id|BusLogic_ReadInterruptRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|InterruptRegister
op_amp
id|BusLogic_InterruptValid
)paren
(brace
multiline_comment|/*&n;&t;    Acknowledge the interrupt and reset the Host Adapter&n;&t;    Interrupt Register.&n;&t;  */
id|BusLogic_WriteControlRegister
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InterruptReset
)paren
suffix:semicolon
multiline_comment|/*&n;&t;    Process valid SCSI Reset State and Incoming Mailbox Loaded&n;&t;    Interrupts.  Command Complete Interrupts are noted, and&n;&t;    Outgoing Mailbox Available Interrupts are ignored, as they&n;&t;    are never enabled.&n;&t;  */
r_if
c_cond
(paren
id|InterruptRegister
op_amp
id|BusLogic_SCSIResetState
)paren
(brace
id|HostAdapter-&gt;HostAdapterResetRequested
op_assign
l_bool|true
suffix:semicolon
id|HostAdapterResetRequestedCount
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|InterruptRegister
op_amp
id|BusLogic_IncomingMailboxLoaded
)paren
(brace
multiline_comment|/*&n;&t;&t;Scan through the Incoming Mailboxes in Strict Round Robin&n;&t;&t;fashion, saving any completed CCBs for further processing.&n;&t;&t;It is essential that for each CCB and SCSI Command issued,&n;&t;&t;command completion processing is performed exactly once.&n;&t;&t;Therefore, only Incoming Mailboxes with completion code&n;&t;&t;Command Completed Without Error, Command Completed With&n;&t;&t;Error, or Command Aborted At Host Request are saved for&n;&t;&t;completion processing.  When an Incoming Mailbox has a&n;&t;&t;completion code of Aborted Command Not Found, the CCB had&n;&t;&t;already completed or been aborted before the current Abort&n;&t;&t;request was processed, and so completion processing has&n;&t;&t;already occurred and no further action should be taken.&n;&t;      */
id|BusLogic_IncomingMailbox_T
op_star
id|NextIncomingMailbox
op_assign
id|HostAdapter-&gt;NextIncomingMailbox
suffix:semicolon
id|BusLogic_CompletionCode_T
id|MailboxCompletionCode
suffix:semicolon
r_while
c_loop
(paren
(paren
id|MailboxCompletionCode
op_assign
id|NextIncomingMailbox-&gt;CompletionCode
)paren
op_ne
id|BusLogic_IncomingMailboxFree
)paren
(brace
id|BusLogic_CCB_T
op_star
id|CCB
op_assign
id|NextIncomingMailbox-&gt;CCB
suffix:semicolon
r_if
c_cond
(paren
id|MailboxCompletionCode
op_ne
id|BusLogic_AbortedCommandNotFound
)paren
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Active
op_logical_or
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Reset
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;  Mark this CCB as completed and add it to the end&n;&t;&t;&t;  of the list of completed CCBs.&n;&t;&t;&t;*/
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Completed
suffix:semicolon
id|CCB-&gt;MailboxCompletionCode
op_assign
id|MailboxCompletionCode
suffix:semicolon
id|CCB-&gt;Next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|FirstCompletedCCB
op_eq
l_int|NULL
)paren
(brace
id|FirstCompletedCCB
op_assign
id|CCB
suffix:semicolon
id|LastCompletedCCB
op_assign
id|CCB
suffix:semicolon
)brace
r_else
(brace
id|LastCompletedCCB-&gt;Next
op_assign
id|CCB
suffix:semicolon
id|LastCompletedCCB
op_assign
id|CCB
suffix:semicolon
)brace
id|HostAdapter-&gt;ActiveCommandCount
(braket
id|CCB-&gt;TargetID
)braket
op_decrement
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;  If a CCB ever appears in an Incoming Mailbox and&n;&t;&t;&t;  is not marked as status Active or Reset, then there&n;&t;&t;&t;  is most likely a bug in the Host Adapter firmware.&n;&t;&t;&t;*/
id|printk
c_func
(paren
l_string|&quot;scsi%d: Illegal CCB #%d status %d in &quot;
l_string|&quot;Incoming Mailbox&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|CCB-&gt;SerialNumber
comma
id|CCB-&gt;Status
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;scsi%d: Aborted CCB #%d to Target %d &quot;
l_string|&quot;Not Found&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|CCB-&gt;SerialNumber
comma
id|CCB-&gt;TargetID
)paren
suffix:semicolon
id|NextIncomingMailbox-&gt;CompletionCode
op_assign
id|BusLogic_IncomingMailboxFree
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|NextIncomingMailbox
OG
id|HostAdapter-&gt;LastIncomingMailbox
)paren
id|NextIncomingMailbox
op_assign
id|HostAdapter-&gt;FirstIncomingMailbox
suffix:semicolon
)brace
id|HostAdapter-&gt;NextIncomingMailbox
op_assign
id|NextIncomingMailbox
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|InterruptRegister
op_amp
id|BusLogic_CommandComplete
)paren
id|HostAdapter-&gt;HostAdapterCommandCompleted
op_assign
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Release exclusive access to Host Adapter.&n;      */
id|BusLogic_ReleaseHostAdapterLockID
c_func
(paren
id|HostAdapter
comma
op_amp
id|Lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    Iterate over the completed CCBs setting the SCSI Command Result Codes,&n;    deallocating the CCBs, and calling the Completion Routines.&n;  */
r_while
c_loop
(paren
id|FirstCompletedCCB
op_ne
l_int|NULL
)paren
(brace
id|BusLogic_CCB_T
op_star
id|CCB
op_assign
id|FirstCompletedCCB
suffix:semicolon
id|SCSI_Command_T
op_star
id|Command
op_assign
id|CCB-&gt;Command
suffix:semicolon
id|FirstCompletedCCB
op_assign
id|FirstCompletedCCB-&gt;Next
suffix:semicolon
id|HostAdapter
op_assign
id|CCB-&gt;HostAdapter
suffix:semicolon
multiline_comment|/*&n;&t;Acquire exclusive access to Host Adapter.&n;      */
id|BusLogic_AcquireHostAdapterLockID
c_func
(paren
id|HostAdapter
comma
op_amp
id|Lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;Process the Completed CCB.&n;      */
r_if
c_cond
(paren
id|CCB-&gt;Opcode
op_eq
id|BusLogic_BusDeviceReset
)paren
(brace
r_int
r_char
id|TargetID
op_assign
id|CCB-&gt;TargetID
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d: Bus Device Reset CCB #%d to Target %d Completed&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|CCB-&gt;SerialNumber
comma
id|TargetID
)paren
suffix:semicolon
id|HostAdapter-&gt;TotalCommandCount
(braket
id|TargetID
)braket
op_assign
l_int|0
suffix:semicolon
id|HostAdapter-&gt;TaggedQueuingActive
(braket
id|TargetID
)braket
op_assign
l_bool|false
suffix:semicolon
multiline_comment|/*&n;&t;    Place CCB back on the Host Adapter&squot;s free list.&n;&t;  */
id|BusLogic_DeallocateCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
multiline_comment|/*&n;&t;    Bus Device Reset CCBs have the Command field non-NULL only when a&n;&t;    Bus Device Reset was requested for a Command that did not have a&n;&t;    currently active CCB in the Host Adapter (i.e., a Synchronous&n;&t;    Bus Device Reset), and hence would not have its Completion Routine&n;&t;    called otherwise.&n;&t;  */
r_while
c_loop
(paren
id|Command
op_ne
l_int|NULL
)paren
(brace
id|SCSI_Command_T
op_star
id|NextCommand
op_assign
id|Command-&gt;reset_chain
suffix:semicolon
id|Command-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|Command-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|Command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|Command
)paren
suffix:semicolon
id|Command
op_assign
id|NextCommand
suffix:semicolon
)brace
multiline_comment|/*&n;&t;    Iterate over the CCBs for this Host Adapter performing completion&n;&t;    processing for any CCBs marked as Reset for this Target.&n;&t;  */
r_for
c_loop
(paren
id|CCB
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|CCB
op_ne
l_int|NULL
suffix:semicolon
id|CCB
op_assign
id|CCB-&gt;NextAll
)paren
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Reset
op_logical_and
id|CCB-&gt;TargetID
op_eq
id|TargetID
)paren
(brace
id|Command
op_assign
id|CCB-&gt;Command
suffix:semicolon
id|BusLogic_DeallocateCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
id|HostAdapter-&gt;ActiveCommandCount
(braket
id|TargetID
)braket
op_decrement
suffix:semicolon
id|Command-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|Command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|Command
)paren
suffix:semicolon
)brace
id|HostAdapter-&gt;BusDeviceResetPendingCCB
(braket
id|TargetID
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;    Translate the Mailbox Completion Code, Host Adapter Status, and&n;&t;    Target Device Status into a SCSI Subsystem Result Code.&n;&t;  */
r_switch
c_cond
(paren
id|CCB-&gt;MailboxCompletionCode
)paren
(brace
r_case
id|BusLogic_IncomingMailboxFree
suffix:colon
r_case
id|BusLogic_AbortedCommandNotFound
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d: CCB #%d to Target %d Impossible State&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|CCB-&gt;SerialNumber
comma
id|CCB-&gt;TargetID
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_CommandCompletedWithoutError
suffix:colon
id|HostAdapter-&gt;CommandSuccessfulFlag
(braket
id|CCB-&gt;TargetID
)braket
op_assign
l_bool|true
suffix:semicolon
id|Command-&gt;result
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_CommandAbortedAtHostRequest
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d: CCB #%d to Target %d Aborted&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|CCB-&gt;SerialNumber
comma
id|CCB-&gt;TargetID
)paren
suffix:semicolon
id|Command-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_CommandCompletedWithError
suffix:colon
id|Command-&gt;result
op_assign
id|BusLogic_ComputeResultCode
c_func
(paren
id|CCB-&gt;HostAdapterStatus
comma
id|CCB-&gt;TargetDeviceStatus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_GlobalOptions
op_amp
id|BusLogic_TraceErrors
)paren
r_if
c_cond
(paren
id|CCB-&gt;HostAdapterStatus
op_ne
id|BusLogic_SCSISelectionTimeout
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d: CCB #%d Target %d: Result %X &quot;
l_string|&quot;Host Adapter Status %02X Target Status %02X&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|CCB-&gt;SerialNumber
comma
id|CCB-&gt;TargetID
comma
id|Command-&gt;result
comma
id|CCB-&gt;HostAdapterStatus
comma
id|CCB-&gt;TargetDeviceStatus
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d: CDB   &quot;
comma
id|HostAdapter-&gt;HostNumber
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CCB-&gt;CDB_Length
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %02X&quot;
comma
id|CCB-&gt;CDB
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d: Sense &quot;
comma
id|HostAdapter-&gt;HostNumber
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CCB-&gt;SenseDataLength
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %02X&quot;
comma
(paren
op_star
id|CCB-&gt;SenseDataPointer
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;    Place CCB back on the Host Adapter&squot;s free list.&n;&t;  */
id|BusLogic_DeallocateCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
multiline_comment|/*&n;&t;    Call the SCSI Command Completion Routine.&n;&t;  */
id|Command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|Command
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Release exclusive access to Host Adapter.&n;      */
id|BusLogic_ReleaseHostAdapterLockID
c_func
(paren
id|HostAdapter
comma
op_amp
id|Lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    Iterate over the Host Adapters performing any requested Host Adapter Resets.&n;  */
r_if
c_cond
(paren
id|HostAdapterResetRequestedCount
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|HostAdapter
op_assign
id|BusLogic_RegisteredHostAdapters
suffix:semicolon
id|HostAdapter
op_ne
l_int|NULL
suffix:semicolon
id|HostAdapter
op_assign
id|HostAdapter-&gt;Next
)paren
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterResetRequested
)paren
(brace
id|BusLogic_ResetHostAdapter
c_func
(paren
id|HostAdapter
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|HostAdapter-&gt;HostAdapterResetRequested
op_assign
l_bool|false
suffix:semicolon
id|scsi_mark_host_bus_reset
c_func
(paren
id|HostAdapter-&gt;SCSI_Host
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;  BusLogic_WriteOutgoingMailbox places CCB and Action Code into an Outgoing&n;  Mailbox for execution by Host Adapter.  The Host Adapter&squot;s Lock should have&n;  already been acquired by the caller.&n;*/
DECL|function|BusLogic_WriteOutgoingMailbox
r_static
id|boolean
id|BusLogic_WriteOutgoingMailbox
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
comma
id|BusLogic_ActionCode_T
id|ActionCode
comma
id|BusLogic_CCB_T
op_star
id|CCB
)paren
(brace
id|BusLogic_OutgoingMailbox_T
op_star
id|NextOutgoingMailbox
suffix:semicolon
id|NextOutgoingMailbox
op_assign
id|HostAdapter-&gt;NextOutgoingMailbox
suffix:semicolon
r_if
c_cond
(paren
id|NextOutgoingMailbox-&gt;ActionCode
op_eq
id|BusLogic_OutgoingMailboxFree
)paren
(brace
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Active
suffix:semicolon
multiline_comment|/*&n;&t;The CCB field must be written before the Action Code field since&n;&t;the Host Adapter is operating asynchronously and the locking code&n;&t;does not protect against simultaneous access by the Host Adapter.&n;      */
id|NextOutgoingMailbox-&gt;CCB
op_assign
id|CCB
suffix:semicolon
id|NextOutgoingMailbox-&gt;ActionCode
op_assign
id|ActionCode
suffix:semicolon
id|BusLogic_StartMailboxCommand
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|NextOutgoingMailbox
OG
id|HostAdapter-&gt;LastOutgoingMailbox
)paren
id|NextOutgoingMailbox
op_assign
id|HostAdapter-&gt;FirstOutgoingMailbox
suffix:semicolon
id|HostAdapter-&gt;NextOutgoingMailbox
op_assign
id|NextOutgoingMailbox
suffix:semicolon
r_if
c_cond
(paren
id|ActionCode
op_eq
id|BusLogic_MailboxStartCommand
)paren
id|HostAdapter-&gt;ActiveCommandCount
(braket
id|CCB-&gt;TargetID
)braket
op_increment
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_QueueCommand creates a CCB for Command and places it into an&n;  Outgoing Mailbox for execution by the associated Host Adapter.&n;*/
DECL|function|BusLogic_QueueCommand
r_int
id|BusLogic_QueueCommand
c_func
(paren
id|SCSI_Command_T
op_star
id|Command
comma
r_void
(paren
op_star
id|CompletionRoutine
)paren
(paren
id|SCSI_Command_T
op_star
)paren
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|Command-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_char
op_star
id|CDB
op_assign
id|Command-&gt;cmnd
suffix:semicolon
r_int
r_char
id|CDB_Length
op_assign
id|Command-&gt;cmd_len
suffix:semicolon
r_int
r_char
id|TargetID
op_assign
id|Command-&gt;target
suffix:semicolon
r_int
r_char
id|LogicalUnit
op_assign
id|Command-&gt;lun
suffix:semicolon
r_void
op_star
id|BufferPointer
op_assign
id|Command-&gt;request_buffer
suffix:semicolon
r_int
id|BufferLength
op_assign
id|Command-&gt;request_bufflen
suffix:semicolon
r_int
id|SegmentCount
op_assign
id|Command-&gt;use_sg
suffix:semicolon
id|BusLogic_Lock_T
id|Lock
suffix:semicolon
id|BusLogic_CCB_T
op_star
id|CCB
suffix:semicolon
multiline_comment|/*&n;    SCSI REQUEST_SENSE commands will be executed automatically by the Host&n;    Adapter for any errors, so they should not be executed explicitly unless&n;    the Sense Data is zero indicating that no error occurred.&n;  */
r_if
c_cond
(paren
id|CDB
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
id|Command-&gt;sense_buffer
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
(brace
id|Command-&gt;result
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
id|CompletionRoutine
c_func
(paren
id|Command
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;    Acquire exclusive access to Host Adapter.&n;  */
id|BusLogic_AcquireHostAdapterLock
c_func
(paren
id|HostAdapter
comma
op_amp
id|Lock
)paren
suffix:semicolon
multiline_comment|/*&n;    Allocate a CCB from the Host Adapter&squot;s free list.  In the unlikely event&n;    that there are none available and memory allocation fails, wait 1 second&n;    and try again.  If that fails, the Host Adapter is probably hung so we&n;    signal an error as a Host Adapter Hard Reset should be initiated soon.&n;  */
id|CCB
op_assign
id|BusLogic_AllocateCCB
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
(brace
id|BusLogic_Delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|CCB
op_assign
id|BusLogic_AllocateCCB
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
(brace
id|Command-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|CompletionRoutine
c_func
(paren
id|Command
)paren
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;    Initialize the fields in the BusLogic Command Control Block (CCB).&n;  */
r_if
c_cond
(paren
id|SegmentCount
op_eq
l_int|0
)paren
(brace
id|CCB-&gt;Opcode
op_assign
id|BusLogic_InitiatorCCB
suffix:semicolon
id|CCB-&gt;DataLength
op_assign
id|BufferLength
suffix:semicolon
id|CCB-&gt;DataPointer
op_assign
id|BufferPointer
suffix:semicolon
)brace
r_else
(brace
id|SCSI_ScatterList_T
op_star
id|ScatterList
op_assign
(paren
id|SCSI_ScatterList_T
op_star
)paren
id|BufferPointer
suffix:semicolon
r_int
id|Segment
suffix:semicolon
id|CCB-&gt;Opcode
op_assign
id|BusLogic_InitiatorCCB_ScatterGather
suffix:semicolon
id|CCB-&gt;DataLength
op_assign
id|SegmentCount
op_star
r_sizeof
(paren
id|BusLogic_ScatterGatherSegment_T
)paren
suffix:semicolon
id|CCB-&gt;DataPointer
op_assign
id|CCB-&gt;ScatterGatherList
suffix:semicolon
r_for
c_loop
(paren
id|Segment
op_assign
l_int|0
suffix:semicolon
id|Segment
OL
id|SegmentCount
suffix:semicolon
id|Segment
op_increment
)paren
(brace
id|CCB-&gt;ScatterGatherList
(braket
id|Segment
)braket
dot
id|SegmentByteCount
op_assign
id|ScatterList
(braket
id|Segment
)braket
dot
id|length
suffix:semicolon
id|CCB-&gt;ScatterGatherList
(braket
id|Segment
)braket
dot
id|SegmentDataPointer
op_assign
id|ScatterList
(braket
id|Segment
)braket
dot
id|address
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|CDB
(braket
l_int|0
)braket
)paren
(brace
r_case
id|READ_6
suffix:colon
r_case
id|READ_10
suffix:colon
id|CCB-&gt;DataDirection
op_assign
id|BusLogic_DataInLengthChecked
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
id|CCB-&gt;DataDirection
op_assign
id|BusLogic_DataOutLengthChecked
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|CCB-&gt;DataDirection
op_assign
id|BusLogic_UncheckedDataTransfer
suffix:semicolon
r_break
suffix:semicolon
)brace
id|CCB-&gt;CDB_Length
op_assign
id|CDB_Length
suffix:semicolon
id|CCB-&gt;SenseDataLength
op_assign
r_sizeof
(paren
id|Command-&gt;sense_buffer
)paren
suffix:semicolon
id|CCB-&gt;HostAdapterStatus
op_assign
l_int|0
suffix:semicolon
id|CCB-&gt;TargetDeviceStatus
op_assign
l_int|0
suffix:semicolon
id|CCB-&gt;TargetID
op_assign
id|TargetID
suffix:semicolon
id|CCB-&gt;LogicalUnit
op_assign
id|LogicalUnit
suffix:semicolon
multiline_comment|/*&n;    For Wide SCSI Host Adapters, Wide Mode CCBs are used to support more than&n;    8 Logical Units per Target, and this requires setting the overloaded&n;    TagEnable field to Logical Unit bit 5.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;HostWideSCSI
)paren
(brace
id|CCB-&gt;TagEnable
op_assign
id|LogicalUnit
op_rshift
l_int|5
suffix:semicolon
id|CCB-&gt;WideModeTagEnable
op_assign
l_bool|false
suffix:semicolon
)brace
r_else
id|CCB-&gt;TagEnable
op_assign
l_bool|false
suffix:semicolon
multiline_comment|/*&n;    BusLogic recommends that after a Reset the first couple of commands that&n;    are sent to a Target Device be sent in a non Tagged Queue fashion so that&n;    the Host Adapter and Target Device can establish Synchronous and Wide&n;    Transfer before Queue Tag messages can interfere with the Synchronous and&n;    Wide Negotiation message.  By waiting to enable Tagged Queuing until after&n;    the first BusLogic_MaxTaggedQueueDepth commands have been sent, it is&n;    assured that after a Reset any pending commands are resent before Tagged&n;    Queuing is enabled and that the Tagged Queuing message will not occur while&n;    the partition table is being printed.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;TotalCommandCount
(braket
id|TargetID
)braket
op_increment
op_eq
id|BusLogic_MaxTaggedQueueDepth
op_logical_and
(paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
op_logical_and
id|Command-&gt;device-&gt;tagged_supported
)paren
(brace
id|HostAdapter-&gt;TaggedQueuingActive
(braket
id|TargetID
)braket
op_assign
l_bool|true
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d: Tagged Queuing now active for Target %d&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HostAdapter-&gt;TaggedQueuingActive
(braket
id|TargetID
)braket
)paren
(brace
id|BusLogic_QueueTag_T
id|QueueTag
op_assign
id|BusLogic_SimpleQueueTag
suffix:semicolon
multiline_comment|/*&n;&t;When using Tagged Queuing with Simple Queue Tags, it appears that disk&n;&t;drive controllers do not guarantee that a queued command will not&n;&t;remain in a disconnected state indefinitely if commands that read or&n;&t;write nearer the head position continue to arrive without interruption.&n;&t;Therefore, for each Target Device this driver keeps track of the last&n;&t;time either the queue was empty or an Ordered Queue Tag was issued.  If&n;&t;more than 5 seconds (half the 10 second disk timeout) have elapsed&n;&t;since this last sequence point, this command will be issued with an&n;&t;Ordered Queue Tag rather than a Simple Queue Tag, which forces the&n;&t;Target Device to complete all previously queued commands before this&n;&t;command may be executed.&n;      */
r_if
c_cond
(paren
id|HostAdapter-&gt;ActiveCommandCount
(braket
id|TargetID
)braket
op_eq
l_int|0
)paren
id|HostAdapter-&gt;LastSequencePoint
(braket
id|TargetID
)braket
op_assign
id|jiffies
suffix:semicolon
r_else
r_if
c_cond
(paren
id|jiffies
op_minus
id|HostAdapter-&gt;LastSequencePoint
(braket
id|TargetID
)braket
OG
l_int|5
op_star
id|HZ
)paren
(brace
id|HostAdapter-&gt;LastSequencePoint
(braket
id|TargetID
)braket
op_assign
id|jiffies
suffix:semicolon
id|QueueTag
op_assign
id|BusLogic_OrderedQueueTag
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HostAdapter-&gt;HostWideSCSI
)paren
(brace
id|CCB-&gt;WideModeTagEnable
op_assign
l_bool|true
suffix:semicolon
id|CCB-&gt;WideModeQueueTag
op_assign
id|QueueTag
suffix:semicolon
)brace
r_else
(brace
id|CCB-&gt;TagEnable
op_assign
l_bool|true
suffix:semicolon
id|CCB-&gt;QueueTag
op_assign
id|QueueTag
suffix:semicolon
)brace
)brace
id|memcpy
c_func
(paren
id|CCB-&gt;CDB
comma
id|CDB
comma
id|CDB_Length
)paren
suffix:semicolon
id|CCB-&gt;SenseDataPointer
op_assign
(paren
id|SCSI_SenseData_T
op_star
)paren
op_amp
id|Command-&gt;sense_buffer
suffix:semicolon
id|CCB-&gt;Command
op_assign
id|Command
suffix:semicolon
id|Command-&gt;scsi_done
op_assign
id|CompletionRoutine
suffix:semicolon
multiline_comment|/*&n;    Place the CCB in an Outgoing Mailbox.  The higher levels of the SCSI&n;    Subsystem should not attempt to queue more commands than can be placed in&n;    Outgoing Mailboxes, so there should always be one free.  In the unlikely&n;    event that there are none available, wait 1 second and try again.  If&n;    that fails, the Host Adapter is probably hung so we signal an error as&n;    a Host Adapter Hard Reset should be initiated soon.&n;  */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_WriteOutgoingMailbox
c_func
(paren
id|HostAdapter
comma
id|BusLogic_MailboxStartCommand
comma
id|CCB
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: cannot write Outgoing Mailbox - Pausing for 1 second&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
)paren
suffix:semicolon
id|BusLogic_Delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_WriteOutgoingMailbox
c_func
(paren
id|HostAdapter
comma
id|BusLogic_MailboxStartCommand
comma
id|CCB
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: still cannot write Outgoing Mailbox - &quot;
l_string|&quot;Host Adapter Dead?&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
)paren
suffix:semicolon
id|BusLogic_DeallocateCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
id|Command-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|Command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|Command
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;    Release exclusive access to Host Adapter.&n;  */
id|Done
suffix:colon
id|BusLogic_ReleaseHostAdapterLock
c_func
(paren
id|HostAdapter
comma
op_amp
id|Lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_AbortCommand aborts Command if possible.&n;*/
DECL|function|BusLogic_AbortCommand
r_int
id|BusLogic_AbortCommand
c_func
(paren
id|SCSI_Command_T
op_star
id|Command
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|Command-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_char
id|TargetID
op_assign
id|Command-&gt;target
suffix:semicolon
id|BusLogic_Lock_T
id|Lock
suffix:semicolon
id|BusLogic_CCB_T
op_star
id|CCB
suffix:semicolon
r_int
id|Result
suffix:semicolon
multiline_comment|/*&n;    Acquire exclusive access to Host Adapter.&n;  */
id|BusLogic_AcquireHostAdapterLock
c_func
(paren
id|HostAdapter
comma
op_amp
id|Lock
)paren
suffix:semicolon
multiline_comment|/*&n;    If this Command has already completed, then no Abort is necessary.&n;  */
r_if
c_cond
(paren
id|Command-&gt;serial_number
op_ne
id|Command-&gt;serial_number_at_timeout
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Unable to Abort Command to Target %d - &quot;
l_string|&quot;Already Completed&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;    Attempt to find an Active CCB for this Command.  If no Active CCB for this&n;    Command is found, then no Abort is necessary.&n;  */
r_for
c_loop
(paren
id|CCB
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|CCB
op_ne
l_int|NULL
suffix:semicolon
id|CCB
op_assign
id|CCB-&gt;NextAll
)paren
r_if
c_cond
(paren
id|CCB-&gt;Command
op_eq
id|Command
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Unable to Abort Command to Target %d - No CCB Found&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Completed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Unable to Abort Command to Target %d - CCB Completed&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Reset
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Unable to Abort Command to Target %d - CCB Reset&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;    Attempt to Abort this CCB.  Firmware versions prior to 5.xx do not generate&n;    Abort Tag messages, but only generate the non-tagged Abort message.  Since&n;    non-tagged commands are not sent by the Host Adapter until the queue of&n;    outstanding tagged commands has completed, and the Abort message is treated&n;    as a non-tagged command, it is effectively impossible to abort commands&n;    when Tagged Queuing is active.  Firmware version 5.xx does generate Abort&n;    Tag messages, so it is possible to abort commands when Tagged Queuing is&n;    active.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;TaggedQueuingActive
(braket
id|TargetID
)braket
op_logical_and
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
OL
l_char|&squot;5&squot;
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Unable to Abort CCB #%d to Target %d - &quot;
l_string|&quot;Abort Tag Not Supported&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|CCB-&gt;SerialNumber
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_WriteOutgoingMailbox
c_func
(paren
id|HostAdapter
comma
id|BusLogic_MailboxAbortCommand
comma
id|CCB
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Aborting CCB #%d to Target %d&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|CCB-&gt;SerialNumber
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_ABORT_PENDING
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Unable to Abort CCB #%d to Target %d - &quot;
l_string|&quot;No Outgoing Mailboxes&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|CCB-&gt;SerialNumber
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_ABORT_BUSY
suffix:semicolon
)brace
multiline_comment|/*&n;    Release exclusive access to Host Adapter.&n;  */
id|Done
suffix:colon
id|BusLogic_ReleaseHostAdapterLock
c_func
(paren
id|HostAdapter
comma
op_amp
id|Lock
)paren
suffix:semicolon
r_return
id|Result
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ResetHostAdapter resets Host Adapter if possible, marking all&n;  currently executing SCSI Commands as having been Reset.&n;*/
DECL|function|BusLogic_ResetHostAdapter
r_static
r_int
id|BusLogic_ResetHostAdapter
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
comma
id|SCSI_Command_T
op_star
id|Command
comma
r_int
r_int
id|ResetFlags
)paren
(brace
id|BusLogic_Lock_T
id|Lock
suffix:semicolon
id|BusLogic_CCB_T
op_star
id|CCB
suffix:semicolon
r_int
id|TargetID
comma
id|Result
suffix:semicolon
multiline_comment|/*&n;    Acquire exclusive access to Host Adapter.&n;  */
id|BusLogic_AcquireHostAdapterLock
c_func
(paren
id|HostAdapter
comma
op_amp
id|Lock
)paren
suffix:semicolon
multiline_comment|/*&n;    If this is an Asynchronous Reset and this Command has already completed,&n;    then no Reset is necessary.&n;  */
r_if
c_cond
(paren
id|ResetFlags
op_amp
id|SCSI_RESET_ASYNCHRONOUS
)paren
(brace
id|TargetID
op_assign
id|Command-&gt;target
suffix:semicolon
r_if
c_cond
(paren
id|Command-&gt;serial_number
op_ne
id|Command-&gt;serial_number_at_timeout
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Unable to Reset Command to Target %d - &quot;
l_string|&quot;Already Completed or Reset&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_for
c_loop
(paren
id|CCB
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|CCB
op_ne
l_int|NULL
suffix:semicolon
id|CCB
op_assign
id|CCB-&gt;NextAll
)paren
r_if
c_cond
(paren
id|CCB-&gt;Command
op_eq
id|Command
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Unable to Reset Command to Target %d - &quot;
l_string|&quot;No CCB Found&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Completed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Unable to Reset Command to Target %d - &quot;
l_string|&quot;CCB Completed&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Reset
op_logical_and
id|HostAdapter-&gt;BusDeviceResetPendingCCB
(braket
id|TargetID
)braket
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Unable to Reset Command to Target %d - &quot;
l_string|&quot;Reset Pending&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_PENDING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|Command
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d: Resetting %s due to SCSI Reset State Interrupt&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|HostAdapter-&gt;BoardName
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;scsi%d: Resetting %s due to Target %d&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|HostAdapter-&gt;BoardName
comma
id|Command-&gt;target
)paren
suffix:semicolon
multiline_comment|/*&n;    Attempt to Reset and Reinitialize the Host Adapter.&n;  */
r_if
c_cond
(paren
op_logical_neg
(paren
id|BusLogic_HardResetHostAdapter
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|BusLogic_InitializeHostAdapter
c_func
(paren
id|HostAdapter
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Resetting %s Failed&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|HostAdapter-&gt;BoardName
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_ERROR
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;    Mark all currently executing CCBs as having been Reset.&n;  */
r_for
c_loop
(paren
id|CCB
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|CCB
op_ne
l_int|NULL
suffix:semicolon
id|CCB
op_assign
id|CCB-&gt;NextAll
)paren
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Active
)paren
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Reset
suffix:semicolon
multiline_comment|/*&n;    Wait a few seconds between the Host Adapter Hard Reset which initiates&n;    a SCSI Bus Reset and issuing any SCSI Commands.  Some SCSI devices get&n;    confused if they receive SCSI Commands too soon after a SCSI Bus Reset.&n;    Note that a timer interrupt may occur here, but all active CCBs have&n;    already been marked Reset and so a reentrant call will return Pending.&n;  */
id|BusLogic_Delay
c_func
(paren
id|HostAdapter-&gt;BusSettleTime
)paren
suffix:semicolon
multiline_comment|/*&n;    If this is a Synchronous Reset, perform completion processing for&n;    the Command being Reset.&n;  */
r_if
c_cond
(paren
id|ResetFlags
op_amp
id|SCSI_RESET_SYNCHRONOUS
)paren
(brace
id|Command-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|Command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|Command
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    Perform completion processing for all CCBs marked as Reset.&n;  */
r_for
c_loop
(paren
id|CCB
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|CCB
op_ne
l_int|NULL
suffix:semicolon
id|CCB
op_assign
id|CCB-&gt;NextAll
)paren
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Reset
)paren
(brace
id|Command
op_assign
id|CCB-&gt;Command
suffix:semicolon
id|BusLogic_DeallocateCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
r_while
c_loop
(paren
id|Command
op_ne
l_int|NULL
)paren
(brace
id|SCSI_Command_T
op_star
id|NextCommand
op_assign
id|Command-&gt;reset_chain
suffix:semicolon
id|Command-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|Command-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|Command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|Command
)paren
suffix:semicolon
id|Command
op_assign
id|NextCommand
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|HostAdapter-&gt;LastResetTime
(braket
id|TargetID
)braket
op_assign
id|jiffies
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_SUCCESS
op_or
id|SCSI_RESET_BUS_RESET
suffix:semicolon
multiline_comment|/*&n;    Release exclusive access to Host Adapter.&n;  */
id|Done
suffix:colon
id|BusLogic_ReleaseHostAdapterLock
c_func
(paren
id|HostAdapter
comma
op_amp
id|Lock
)paren
suffix:semicolon
r_return
id|Result
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_SendBusDeviceReset sends a Bus Device Reset to the Target&n;  Device associated with Command.&n;*/
DECL|function|BusLogic_SendBusDeviceReset
r_static
r_int
id|BusLogic_SendBusDeviceReset
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
comma
id|SCSI_Command_T
op_star
id|Command
comma
r_int
r_int
id|ResetFlags
)paren
(brace
r_int
r_char
id|TargetID
op_assign
id|Command-&gt;target
suffix:semicolon
id|BusLogic_Lock_T
id|Lock
suffix:semicolon
id|BusLogic_CCB_T
op_star
id|CCB
suffix:semicolon
r_int
id|Result
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;    Acquire exclusive access to Host Adapter.&n;  */
id|BusLogic_AcquireHostAdapterLock
c_func
(paren
id|HostAdapter
comma
op_amp
id|Lock
)paren
suffix:semicolon
multiline_comment|/*&n;    If this is an Asynchronous Reset and this Command has already completed,&n;    then no Reset is necessary.&n;  */
r_if
c_cond
(paren
id|ResetFlags
op_amp
id|SCSI_RESET_ASYNCHRONOUS
)paren
(brace
r_if
c_cond
(paren
id|Command-&gt;serial_number
op_ne
id|Command-&gt;serial_number_at_timeout
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Unable to Reset Command to Target %d - &quot;
l_string|&quot;Already Completed&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_for
c_loop
(paren
id|CCB
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|CCB
op_ne
l_int|NULL
suffix:semicolon
id|CCB
op_assign
id|CCB-&gt;NextAll
)paren
r_if
c_cond
(paren
id|CCB-&gt;Command
op_eq
id|Command
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Unable to Reset Command to Target %d - &quot;
l_string|&quot;No CCB Found&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Completed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Unable to Reset Command to Target %d - &quot;
l_string|&quot;CCB Completed&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Reset
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Unable to Reset Command to Target %d - &quot;
l_string|&quot;Reset Pending&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_PENDING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;    If this is a Synchronous Reset and a Bus Device Reset is already pending&n;    for this Target Device, do not send a second one.  Add this Command to&n;    the list of Commands for which completion processing must be performed&n;    when the Bus Device Reset CCB completes.&n;  */
r_if
c_cond
(paren
id|ResetFlags
op_amp
id|SCSI_RESET_SYNCHRONOUS
)paren
r_if
c_cond
(paren
(paren
id|CCB
op_assign
id|HostAdapter-&gt;BusDeviceResetPendingCCB
(braket
id|TargetID
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|Command-&gt;reset_chain
op_assign
id|CCB-&gt;Command
suffix:semicolon
id|CCB-&gt;Command
op_assign
id|Command
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_PENDING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;    Firmware versions prior to 5.xx treat a Bus Device Reset as a non-tagged&n;    command.  Since non-tagged commands are not sent by the Host Adapter until&n;    the queue of outstanding tagged commands has completed, it is effectively&n;    impossible to send a Bus Device Reset while there are tagged commands&n;    outstanding.  Therefore, in that case a full Host Adapter Hard Reset and&n;    SCSI Bus Reset must be done.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;TaggedQueuingActive
(braket
id|TargetID
)braket
op_logical_and
id|HostAdapter-&gt;ActiveCommandCount
(braket
id|TargetID
)braket
OG
l_int|0
op_logical_and
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
OL
l_char|&squot;5&squot;
)paren
r_goto
id|Done
suffix:semicolon
multiline_comment|/*&n;    Allocate a CCB from the Host Adapter&squot;s free list.  In the unlikely event&n;    that there are none available and memory allocation fails, attempt a full&n;    Host Adapter Hard Reset and SCSI Bus Reset.&n;  */
id|CCB
op_assign
id|BusLogic_AllocateCCB
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
r_goto
id|Done
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d: Sending Bus Device Reset CCB #%d to Target %d&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|CCB-&gt;SerialNumber
comma
id|TargetID
)paren
suffix:semicolon
id|CCB-&gt;Opcode
op_assign
id|BusLogic_BusDeviceReset
suffix:semicolon
id|CCB-&gt;TargetID
op_assign
id|TargetID
suffix:semicolon
multiline_comment|/*&n;    For Synchronous Resets, arrange for the interrupt handler to perform&n;    completion processing for the Command being Reset.&n;  */
r_if
c_cond
(paren
id|ResetFlags
op_amp
id|SCSI_RESET_SYNCHRONOUS
)paren
(brace
id|Command-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|CCB-&gt;Command
op_assign
id|Command
suffix:semicolon
)brace
multiline_comment|/*&n;    Attempt to write an Outgoing Mailbox with the Bus Device Reset CCB.&n;    If sending a Bus Device Reset is impossible, attempt a full Host&n;    Adapter Hard Reset and SCSI Bus Reset.&n;  */
r_if
c_cond
(paren
op_logical_neg
(paren
id|BusLogic_WriteOutgoingMailbox
c_func
(paren
id|HostAdapter
comma
id|BusLogic_MailboxStartCommand
comma
id|CCB
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: cannot write Outgoing Mailbox for Bus Device Reset&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
)paren
suffix:semicolon
id|BusLogic_DeallocateCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;    If there is a currently executing CCB in the Host Adapter for this Command&n;    (i.e. this is an Asynchronous Reset), then an Incoming Mailbox entry may be&n;    made with a completion code of BusLogic_HostAdapterAssertedBusDeviceReset.&n;    If there is no active CCB for this Command (i.e. this is a Synchronous&n;    Reset), then the Bus Device Reset CCB&squot;s Command field will have been set&n;    to the Command so that the interrupt for the completion of the Bus Device&n;    Reset can call the Completion Routine for the Command.  On successful&n;    execution of a Bus Device Reset, older firmware versions did return the&n;    pending CCBs with the appropriate completion code, but more recent firmware&n;    versions only return the Bus Device Reset CCB itself.  This driver handles&n;    both cases by marking all the currently executing CCBs to this Target&n;    Device as Reset.  When the Bus Device Reset CCB is processed by the&n;    interrupt handler, any remaining CCBs marked as Reset will have completion&n;    processing performed.&n;  */
id|HostAdapter-&gt;BusDeviceResetPendingCCB
(braket
id|TargetID
)braket
op_assign
id|CCB
suffix:semicolon
id|HostAdapter-&gt;LastResetTime
(braket
id|TargetID
)braket
op_assign
id|jiffies
suffix:semicolon
r_for
c_loop
(paren
id|CCB
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|CCB
op_ne
l_int|NULL
suffix:semicolon
id|CCB
op_assign
id|CCB-&gt;NextAll
)paren
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Active
op_logical_and
id|CCB-&gt;TargetID
op_eq
id|TargetID
)paren
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Reset
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_PENDING
suffix:semicolon
multiline_comment|/*&n;    If a Bus Device Reset was not possible for some reason, force a full&n;    Host Adapter Hard Reset and SCSI Bus Reset.&n;  */
id|Done
suffix:colon
r_if
c_cond
(paren
id|Result
OL
l_int|0
)paren
id|Result
op_assign
id|BusLogic_ResetHostAdapter
c_func
(paren
id|HostAdapter
comma
id|Command
comma
id|ResetFlags
)paren
suffix:semicolon
multiline_comment|/*&n;    Release exclusive access to Host Adapter.&n;  */
id|BusLogic_ReleaseHostAdapterLock
c_func
(paren
id|HostAdapter
comma
op_amp
id|Lock
)paren
suffix:semicolon
r_return
id|Result
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ResetCommand takes appropriate action to reset Command.&n;*/
DECL|function|BusLogic_ResetCommand
r_int
id|BusLogic_ResetCommand
c_func
(paren
id|SCSI_Command_T
op_star
id|Command
comma
r_int
r_int
id|ResetFlags
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|Command-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_char
id|TargetID
op_assign
id|Command-&gt;target
suffix:semicolon
r_int
r_char
id|ErrorRecoveryStrategy
op_assign
id|HostAdapter-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
suffix:semicolon
multiline_comment|/*&n;    Disable Tagged Queuing if it is active for this Target Device and if&n;    it has been less than 10 minutes since the last reset occurred, or since&n;    the system was initialized if no prior resets have occurred.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;TaggedQueuingActive
(braket
id|TargetID
)braket
op_logical_and
id|jiffies
op_minus
id|HostAdapter-&gt;LastResetTime
(braket
id|TargetID
)braket
OL
l_int|10
op_star
l_int|60
op_star
id|HZ
)paren
(brace
id|HostAdapter-&gt;TaggedQueuingPermitted
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TargetID
)paren
suffix:semicolon
id|HostAdapter-&gt;TaggedQueuingActive
(braket
id|TargetID
)braket
op_assign
l_bool|false
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d: Tagged Queuing now disabled for Target %d&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ErrorRecoveryStrategy
op_eq
id|BusLogic_ErrorRecovery_Default
)paren
r_if
c_cond
(paren
id|ResetFlags
op_amp
id|SCSI_RESET_SUGGEST_BUS_RESET
)paren
id|ErrorRecoveryStrategy
op_assign
id|BusLogic_ErrorRecovery_HardReset
suffix:semicolon
r_else
id|ErrorRecoveryStrategy
op_assign
id|BusLogic_ErrorRecovery_BusDeviceReset
suffix:semicolon
r_switch
c_cond
(paren
id|ErrorRecoveryStrategy
)paren
(brace
r_case
id|BusLogic_ErrorRecovery_HardReset
suffix:colon
r_return
id|BusLogic_ResetHostAdapter
c_func
(paren
id|HostAdapter
comma
id|Command
comma
id|ResetFlags
)paren
suffix:semicolon
r_case
id|BusLogic_ErrorRecovery_BusDeviceReset
suffix:colon
multiline_comment|/*&n;&t;The Bus Device Reset Error Recovery Strategy only graduates to a Hard&n;&t;Reset when no commands have completed successfully since the last Bus&n;&t;Device Reset and it has been at least 100 milliseconds.  This prevents&n;&t;a sequence of commands that all timeout together from immediately&n;&t;forcing a Hard Reset before the Bus Device Reset has had a chance to&n;&t;clear the error condition.&n;      */
r_if
c_cond
(paren
id|HostAdapter-&gt;CommandSuccessfulFlag
(braket
id|TargetID
)braket
op_logical_or
id|jiffies
op_minus
id|HostAdapter-&gt;LastResetTime
(braket
id|TargetID
)braket
OL
id|HZ
op_div
l_int|10
)paren
(brace
id|HostAdapter-&gt;CommandSuccessfulFlag
(braket
id|TargetID
)braket
op_assign
l_bool|false
suffix:semicolon
r_return
id|BusLogic_SendBusDeviceReset
c_func
(paren
id|HostAdapter
comma
id|Command
comma
id|ResetFlags
)paren
suffix:semicolon
)brace
r_else
r_return
id|BusLogic_ResetHostAdapter
c_func
(paren
id|HostAdapter
comma
id|Command
comma
id|ResetFlags
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Error Recovery for Target %d Suppressed&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|TargetID
)paren
suffix:semicolon
r_return
id|SCSI_RESET_PUNT
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_BIOSDiskParameters returns the Heads/Sectors/Cylinders BIOS Disk&n;  Parameters for Disk.  The default disk geometry is 64 heads, 32 sectors,&n;  and the appropriate number of cylinders so as not to exceed drive capacity.&n;  In order for disks equal to or larger than 1 GB to be addressable by the&n;  BIOS without exceeding the BIOS limitation of 1024 cylinders, Extended&n;  Translation may be enabled in AutoSCSI on &quot;W&quot; and &quot;C&quot; Series boards or by a&n;  dip switch setting on older boards.  With Extended Translation enabled,&n;  drives between 1 GB inclusive and 2 GB exclusive are given a disk geometry&n;  of 128 heads and 32 sectors, and drives above 2 GB inclusive are given a&n;  disk geometry of 255 heads and 63 sectors.  However, if the BIOS detects&n;  that the Extended Translation setting does not match the geometry in the&n;  partition table, then the translation inferred from the partition table&n;  will be used by the BIOS, and a warning may be displayed.&n;*/
DECL|function|BusLogic_BIOSDiskParameters
r_int
id|BusLogic_BIOSDiskParameters
c_func
(paren
id|SCSI_Disk_T
op_star
id|Disk
comma
id|KernelDevice_T
id|Device
comma
r_int
op_star
id|Parameters
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|Disk-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
id|BIOS_DiskParameters_T
op_star
id|DiskParameters
op_assign
(paren
id|BIOS_DiskParameters_T
op_star
)paren
id|Parameters
suffix:semicolon
r_struct
id|buffer_head
op_star
id|BufferHead
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;ExtendedTranslation
op_logical_and
id|Disk-&gt;capacity
op_ge
l_int|2
op_star
l_int|1024
op_star
l_int|1024
multiline_comment|/* 1 GB in 512 byte sectors */
)paren
r_if
c_cond
(paren
id|Disk-&gt;capacity
op_ge
l_int|4
op_star
l_int|1024
op_star
l_int|1024
multiline_comment|/* 2 GB in 512 byte sectors */
)paren
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|255
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|63
suffix:semicolon
)brace
r_else
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|128
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|32
suffix:semicolon
)brace
r_else
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|64
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|32
suffix:semicolon
)brace
id|DiskParameters-&gt;Cylinders
op_assign
id|Disk-&gt;capacity
op_div
(paren
id|DiskParameters-&gt;Heads
op_star
id|DiskParameters-&gt;Sectors
)paren
suffix:semicolon
multiline_comment|/*&n;    Attempt to read the first 1024 bytes from the disk device.&n;  */
id|BufferHead
op_assign
id|bread
c_func
(paren
id|MKDEV
c_func
(paren
id|MAJOR
c_func
(paren
id|Device
)paren
comma
id|MINOR
c_func
(paren
id|Device
)paren
op_amp
op_complement
l_int|0x0F
)paren
comma
l_int|0
comma
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BufferHead
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;    If the boot sector partition table flag is valid, search for a partition&n;    table entry whose end_head matches one of the standard BusLogic geometry&n;    translations (64/32, 128/32, or 255/63).&n;  */
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|BufferHead-&gt;b_data
op_plus
l_int|0x1FE
)paren
op_eq
l_int|0xAA55
)paren
(brace
r_struct
id|partition
op_star
id|PartitionEntry
op_assign
(paren
r_struct
id|partition
op_star
)paren
(paren
id|BufferHead-&gt;b_data
op_plus
l_int|0x1BE
)paren
suffix:semicolon
r_int
id|SavedCylinders
op_assign
id|DiskParameters-&gt;Cylinders
comma
id|PartitionNumber
suffix:semicolon
r_for
c_loop
(paren
id|PartitionNumber
op_assign
l_int|0
suffix:semicolon
id|PartitionNumber
OL
l_int|4
suffix:semicolon
id|PartitionNumber
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PartitionEntry-&gt;end_head
op_eq
l_int|64
op_minus
l_int|1
)paren
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|64
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|32
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PartitionEntry-&gt;end_head
op_eq
l_int|128
op_minus
l_int|1
)paren
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|128
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|32
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PartitionEntry-&gt;end_head
op_eq
l_int|255
op_minus
l_int|1
)paren
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|255
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|63
suffix:semicolon
r_break
suffix:semicolon
)brace
id|PartitionEntry
op_increment
suffix:semicolon
)brace
id|DiskParameters-&gt;Cylinders
op_assign
id|Disk-&gt;capacity
op_div
(paren
id|DiskParameters-&gt;Heads
op_star
id|DiskParameters-&gt;Sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SavedCylinders
op_ne
id|DiskParameters-&gt;Cylinders
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d: Warning: Extended Translation Setting &quot;
l_string|&quot;(&gt; 1GB Switch) does not match&bslash;n&quot;
l_string|&quot;scsi%d: Partition Table - Adopting %d/%d Geometry &quot;
l_string|&quot;from Partition Table&bslash;n&quot;
comma
id|HostAdapter-&gt;HostNumber
comma
id|HostAdapter-&gt;HostNumber
comma
id|DiskParameters-&gt;Heads
comma
id|DiskParameters-&gt;Sectors
)paren
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|BufferHead
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_Setup handles processing of Kernel Command Line Arguments.&n;&n;  For the BusLogic driver, a Kernel command line entry comprises the driver&n;  identifier &quot;BusLogic=&quot; optionally followed by a comma-separated sequence of&n;  integers and then optionally followed by a comma-separated sequence of&n;  strings.  Each command line entry applies to one BusLogic Host Adapter.&n;  Multiple command line entries may be used in systems which contain multiple&n;  BusLogic Host Adapters.&n;&n;  The first integer specified is the I/O Address at which the Host Adapter is&n;  located.  If unspecified, it defaults to 0 which means to apply this entry to&n;  the first BusLogic Host Adapter found during the default probe sequence.  If&n;  any I/O Address parameters are provided on the command line, then the default&n;  probe sequence is omitted.&n;&n;  The second integer specified is the Tagged Queue Depth to use for Target&n;  Devices that support Tagged Queuing.  The Queue Depth is the number of SCSI&n;  commands that are allowed to be concurrently presented for execution.  If&n;  unspecified, it defaults to 0 which means to use a value determined&n;  automatically based on the Host Adapter&squot;s Total Queue Depth and the number,&n;  type, speed, and capabilities of the detected Target Devices.  For Host&n;  Adapters that require ISA Bounce Buffers, the Tagged Queue Depth is&n;  automatically set to BusLogic_TaggedQueueDepth_BB to avoid excessive&n;  preallocation of DMA Bounce Buffer memory.  Target Devices that do not&n;  support Tagged Queuing use a Queue Depth of BusLogic_UntaggedQueueDepth.&n;&n;  The third integer specified is the Bus Settle Time in seconds.  This is&n;  the amount of time to wait between a Host Adapter Hard Reset which initiates&n;  a SCSI Bus Reset and issuing any SCSI Commands.  If unspecified, it defaults&n;  to 0 which means to use the value of BusLogic_DefaultBusSettleTime.&n;&n;  The fourth integer specified is the Local Options.  If unspecified, it&n;  defaults to 0.  Note that Local Options are only applied to a specific Host&n;  Adapter.&n;&n;  The fifth integer specified is the Global Options.  If unspecified, it&n;  defaults to 0.  Note that Global Options are applied across all Host&n;  Adapters.&n;&n;  The string options are used to provide control over Tagged Queuing and Error&n;  Recovery. If both Tagged Queuing and Error Recovery strings are provided, the&n;  Tagged Queuing specification string must come first.&n;&n;  The Tagged Queuing specification begins with &quot;TQ:&quot; and allows for explicitly&n;  specifying whether Tagged Queuing is permitted on Target Devices that support&n;  it.  The following specification options are available:&n;&n;  TQ:Default&t;&t;Tagged Queuing will be permitted based on the firmware&n;&t;&t;&t;version of the BusLogic Host Adapter and based on&n;&t;&t;&t;whether the Tagged Queue Depth value allows queuing&n;&t;&t;&t;multiple commands.&n;&n;  TQ:Enable&t;&t;Tagged Queuing will be enabled for all Target Devices&n;&t;&t;&t;on this Host Adapter overriding any limitation that&n;&t;&t;&t;would otherwise be imposed based on the Host Adapter&n;&t;&t;&t;firmware version.&n;&n;  TQ:Disable&t;&t;Tagged Queuing will be disabled for all Target Devices&n;&t;&t;&t;on this Host Adapter.&n;&n;  TQ:&lt;Per-Target-Spec&gt;&t;Tagged Queuing will be controlled individually for each&n;&t;&t;&t;Target Device.  &lt;Per-Target-Spec&gt; is a sequence of &quot;Y&quot;,&n;&t;&t;&t;&quot;N&quot;, and &quot;X&quot; characters.  &quot;Y&quot; enabled Tagged Queuing,&n;&t;&t;&t;&quot;N&quot; disables Tagged Queuing, and &quot;X&quot; accepts the&n;&t;&t;&t;default based on the firmware version.  The first&n;&t;&t;&t;character refers to Target Device 0, the second to&n;&t;&t;&t;Target Device 1, and so on; if the sequence of &quot;Y&quot;,&n;&t;&t;&t;&quot;N&quot;, and &quot;X&quot; characters does not cover all the Target&n;&t;&t;&t;Devices, unspecified characters are assumed to be &quot;X&quot;.&n;&n;  Note that explicitly requesting Tagged Queuing may lead to problems; this&n;  facility is provided primarily to allow disabling Tagged Queuing on Target&n;  Devices that do not implement it correctly.&n;&n;  The Error Recovery Strategy specification begins with &quot;ER:&quot; and allows for&n;  explicitly specifying the Error Recovery action to be performed when&n;  ResetCommand is called due to a SCSI Command failing to complete&n;  successfully.  The following specification options are available:&n;&n;  ER:Default&t;&t;Error Recovery will select between the Hard Reset and&n;&t;&t;&t;Bus Device Reset options based on the recommendation&n;&t;&t;&t;of the SCSI Subsystem.&n;&n;  ER:HardReset&t;&t;Error Recovery will initiate a Host Adapter Hard Reset&n;&t;&t;&t;which also causes a SCSI Bus Reset.&n;&n;  ER:BusDeviceReset&t;Error Recovery will send a Bus Device Reset message to&n;&t;&t;&t;the individual Target Device causing the error.  If&n;&t;&t;&t;Error Recovery is again initiated for this Target&n;&t;&t;&t;Device and no SCSI Command to this Target Device has&n;&t;&t;&t;completed successfully since the Bus Device Reset&n;&t;&t;&t;message was sent, then a Hard Reset will be attempted.&n;&n;  ER:None&t;&t;Error Recovery will be suppressed.  This option should&n;&t;&t;&t;only be selected if a SCSI Bus Reset or Bus Device&n;&t;&t;&t;Reset will cause the Target Device to fail completely&n;&t;&t;&t;and unrecoverably.&n;&n;  ER:&lt;Per-Target-Spec&gt;&t;Error Recovery will be controlled individually for each&n;&t;&t;&t;Target Device.  &lt;Per-Target-Spec&gt; is a sequence of &quot;D&quot;,&n;&t;&t;&t;&quot;H&quot;, &quot;B&quot;, and &quot;N&quot; characters.  &quot;D&quot; selects Default, &quot;H&quot;&n;&t;&t;&t;selects Hard Reset, &quot;B&quot; selects Bus Device Reset, and&n;&t;&t;&t;&quot;N&quot; selects None.  The first character refers to Target&n;&t;&t;&t;Device 0, the second to Target Device 1, and so on; if&n;&t;&t;&t;the sequence of &quot;D&quot;, &quot;H&quot;, &quot;B&quot;, and &quot;N&quot; characters does&n;&t;&t;&t;not cover all the possible Target Devices, unspecified&n;&t;&t;&t;characters are assumed to be &quot;D&quot;.&n;*/
DECL|function|BusLogic_Setup
r_void
id|BusLogic_Setup
c_func
(paren
r_char
op_star
id|Strings
comma
r_int
op_star
id|Integers
)paren
(brace
id|BusLogic_CommandLineEntry_T
op_star
id|CommandLineEntry
op_assign
op_amp
id|BusLogic_CommandLineEntries
(braket
id|BusLogic_CommandLineEntryCount
op_increment
)braket
suffix:semicolon
r_static
r_int
id|ProbeListIndex
op_assign
l_int|0
suffix:semicolon
r_int
id|IntegerCount
op_assign
id|Integers
(braket
l_int|0
)braket
comma
id|TargetID
comma
id|i
suffix:semicolon
id|CommandLineEntry-&gt;IO_Address
op_assign
l_int|0
suffix:semicolon
id|CommandLineEntry-&gt;TaggedQueueDepth
op_assign
l_int|0
suffix:semicolon
id|CommandLineEntry-&gt;BusSettleTime
op_assign
l_int|0
suffix:semicolon
id|CommandLineEntry-&gt;LocalOptions
op_assign
l_int|0
suffix:semicolon
id|CommandLineEntry-&gt;TaggedQueuingPermitted
op_assign
l_int|0
suffix:semicolon
id|CommandLineEntry-&gt;TaggedQueuingPermittedMask
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|CommandLineEntry-&gt;ErrorRecoveryStrategy
comma
id|BusLogic_ErrorRecovery_Default
comma
r_sizeof
(paren
id|CommandLineEntry-&gt;ErrorRecoveryStrategy
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IntegerCount
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;BusLogic: Unexpected Command Line Integers ignored&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IntegerCount
op_ge
l_int|1
)paren
(brace
r_int
r_int
id|IO_Address
op_assign
id|Integers
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|IO_Address
OG
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|BusLogic_IO_StandardAddresses
(braket
id|i
)braket
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BusLogic: Invalid Command Line Entry &quot;
l_string|&quot;(illegal I/O Address 0x%X)&bslash;n&quot;
comma
id|IO_Address
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|i
OL
id|ProbeListIndex
op_logical_and
id|IO_Address
op_eq
id|BusLogic_IO_AddressProbeList
(braket
id|i
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BusLogic: Invalid Command Line Entry &quot;
l_string|&quot;(duplicate I/O Address 0x%X)&bslash;n&quot;
comma
id|IO_Address
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|IO_Address
op_ge
l_int|0x400
op_logical_or
id|IO_Address
op_eq
id|BusLogic_IO_StandardAddresses
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
id|BusLogic_IO_AddressProbeList
(braket
id|ProbeListIndex
op_increment
)braket
op_assign
id|IO_Address
suffix:semicolon
id|BusLogic_IO_AddressProbeList
(braket
id|ProbeListIndex
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|CommandLineEntry-&gt;IO_Address
op_assign
id|IO_Address
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IntegerCount
op_ge
l_int|2
)paren
(brace
r_int
r_int
id|TaggedQueueDepth
op_assign
id|Integers
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|TaggedQueueDepth
OG
id|BusLogic_MaxTaggedQueueDepth
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BusLogic: Invalid Command Line Entry &quot;
l_string|&quot;(illegal Tagged Queue Depth %d)&bslash;n&quot;
comma
id|TaggedQueueDepth
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|CommandLineEntry-&gt;TaggedQueueDepth
op_assign
id|TaggedQueueDepth
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IntegerCount
op_ge
l_int|3
)paren
id|CommandLineEntry-&gt;BusSettleTime
op_assign
id|Integers
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|IntegerCount
op_ge
l_int|4
)paren
id|CommandLineEntry-&gt;LocalOptions
op_assign
id|Integers
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|IntegerCount
op_ge
l_int|5
)paren
id|BusLogic_GlobalOptions
op_or_assign
id|Integers
(braket
l_int|5
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|BusLogic_CommandLineEntryCount
op_eq
l_int|0
op_logical_or
id|ProbeListIndex
op_eq
l_int|0
op_logical_or
id|BusLogic_CommandLineEntryCount
op_eq
id|ProbeListIndex
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BusLogic: Invalid Command Line Entry &quot;
l_string|&quot;(all or no I/O Addresses must be specified)&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Strings
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|Strings
comma
l_string|&quot;TQ:&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
id|Strings
op_add_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|Strings
comma
l_string|&quot;Default&quot;
comma
l_int|7
)paren
op_eq
l_int|0
)paren
id|Strings
op_add_assign
l_int|7
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|Strings
comma
l_string|&quot;Enable&quot;
comma
l_int|6
)paren
op_eq
l_int|0
)paren
(brace
id|Strings
op_add_assign
l_int|6
suffix:semicolon
id|CommandLineEntry-&gt;TaggedQueuingPermitted
op_assign
l_int|0xFFFF
suffix:semicolon
id|CommandLineEntry-&gt;TaggedQueuingPermittedMask
op_assign
l_int|0xFFFF
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|Strings
comma
l_string|&quot;Disable&quot;
comma
l_int|7
)paren
op_eq
l_int|0
)paren
(brace
id|Strings
op_add_assign
l_int|7
suffix:semicolon
id|CommandLineEntry-&gt;TaggedQueuingPermitted
op_assign
l_int|0x0000
suffix:semicolon
id|CommandLineEntry-&gt;TaggedQueuingPermittedMask
op_assign
l_int|0xFFFF
suffix:semicolon
)brace
r_else
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
r_switch
c_cond
(paren
op_star
id|Strings
op_increment
)paren
(brace
r_case
l_char|&squot;Y&squot;
suffix:colon
id|CommandLineEntry-&gt;TaggedQueuingPermitted
op_or_assign
l_int|1
op_lshift
id|TargetID
suffix:semicolon
id|CommandLineEntry-&gt;TaggedQueuingPermittedMask
op_or_assign
l_int|1
op_lshift
id|TargetID
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;N&squot;
suffix:colon
id|CommandLineEntry-&gt;TaggedQueuingPermittedMask
op_or_assign
l_int|1
op_lshift
id|TargetID
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;X&squot;
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|Strings
op_decrement
suffix:semicolon
id|TargetID
op_assign
id|BusLogic_MaxTargetDevices
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_star
id|Strings
op_eq
l_char|&squot;,&squot;
)paren
id|Strings
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|Strings
comma
l_string|&quot;ER:&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
id|Strings
op_add_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|Strings
comma
l_string|&quot;Default&quot;
comma
l_int|7
)paren
op_eq
l_int|0
)paren
id|Strings
op_add_assign
l_int|7
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|Strings
comma
l_string|&quot;HardReset&quot;
comma
l_int|9
)paren
op_eq
l_int|0
)paren
(brace
id|Strings
op_add_assign
l_int|9
suffix:semicolon
id|memset
c_func
(paren
id|CommandLineEntry-&gt;ErrorRecoveryStrategy
comma
id|BusLogic_ErrorRecovery_HardReset
comma
r_sizeof
(paren
id|CommandLineEntry-&gt;ErrorRecoveryStrategy
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|Strings
comma
l_string|&quot;BusDeviceReset&quot;
comma
l_int|14
)paren
op_eq
l_int|0
)paren
(brace
id|Strings
op_add_assign
l_int|14
suffix:semicolon
id|memset
c_func
(paren
id|CommandLineEntry-&gt;ErrorRecoveryStrategy
comma
id|BusLogic_ErrorRecovery_BusDeviceReset
comma
r_sizeof
(paren
id|CommandLineEntry-&gt;ErrorRecoveryStrategy
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|Strings
comma
l_string|&quot;None&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
id|Strings
op_add_assign
l_int|4
suffix:semicolon
id|memset
c_func
(paren
id|CommandLineEntry-&gt;ErrorRecoveryStrategy
comma
id|BusLogic_ErrorRecovery_None
comma
r_sizeof
(paren
id|CommandLineEntry-&gt;ErrorRecoveryStrategy
)paren
)paren
suffix:semicolon
)brace
r_else
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
r_switch
c_cond
(paren
op_star
id|Strings
op_increment
)paren
(brace
r_case
l_char|&squot;D&squot;
suffix:colon
id|CommandLineEntry-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
op_assign
id|BusLogic_ErrorRecovery_Default
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;H&squot;
suffix:colon
id|CommandLineEntry-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
op_assign
id|BusLogic_ErrorRecovery_HardReset
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;B&squot;
suffix:colon
id|CommandLineEntry-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
op_assign
id|BusLogic_ErrorRecovery_BusDeviceReset
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;N&squot;
suffix:colon
id|CommandLineEntry-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
op_assign
id|BusLogic_ErrorRecovery_None
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|Strings
op_decrement
suffix:semicolon
id|TargetID
op_assign
id|BusLogic_MaxTargetDevices
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_star
id|Strings
op_ne
l_char|&squot;&bslash;0&squot;
)paren
id|printk
c_func
(paren
l_string|&quot;BusLogic: Unexpected Command Line String &squot;%s&squot; ignored&bslash;n&quot;
comma
id|Strings
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  Include Module support if requested.&n;*/
macro_line|#ifdef MODULE
DECL|variable|driver_template
id|SCSI_Host_Template_T
id|driver_template
op_assign
id|BUSLOGIC
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
macro_line|#endif
eof
