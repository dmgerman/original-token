multiline_comment|/*&n;&n;  Linux Driver for BusLogic MultiMaster and FlashPoint SCSI Host Adapters&n;&n;  Copyright 1995-1998 by Leonard N. Zubkoff &lt;lnz@dandelion.com&gt;&n;&n;  This program is free software; you may redistribute and/or modify it under&n;  the terms of the GNU General Public License Version 2 as published by the&n;  Free Software Foundation.&n;&n;  This program is distributed in the hope that it will be useful, but&n;  WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY&n;  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n;  for complete details.&n;&n;  The author respectfully requests that any modifications to this software be&n;  sent directly to him for evaluation and testing.&n;&n;  Special thanks to Wayne Yen, Jin-Lon Hon, and Alex Win of BusLogic, whose&n;  advice has been invaluable, to David Gentzel, for writing the original Linux&n;  BusLogic driver, and to Paul Gortmaker, for being such a dedicated test site.&n;&n;  Finally, special thanks to Mylex/BusLogic for making the FlashPoint SCCB&n;  Manager available as freely redistributable source code.&n;&n;*/
DECL|macro|BusLogic_DriverVersion
mdefine_line|#define BusLogic_DriverVersion&t;&t;&quot;2.1.15&quot;
DECL|macro|BusLogic_DriverDate
mdefine_line|#define BusLogic_DriverDate&t;&t;&quot;17 August 1998&quot;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &quot;BusLogic.h&quot;
macro_line|#include &quot;FlashPoint.c&quot;
multiline_comment|/*&n;  BusLogic_DriverOptionsCount is a count of the number of BusLogic Driver&n;  Options specifications provided via the Linux Kernel Command Line or via&n;  the Loadable Kernel Module Installation Facility.&n;*/
r_static
r_int
DECL|variable|BusLogic_DriverOptionsCount
id|BusLogic_DriverOptionsCount
suffix:semicolon
multiline_comment|/*&n;  BusLogic_DriverOptions is an array of Driver Options structures representing&n;  BusLogic Driver Options specifications provided via the Linux Kernel Command&n;  Line or via the Loadable Kernel Module Installation Facility.&n;*/
r_static
id|BusLogic_DriverOptions_T
DECL|variable|BusLogic_DriverOptions
id|BusLogic_DriverOptions
(braket
id|BusLogic_MaxHostAdapters
)braket
suffix:semicolon
multiline_comment|/*&n;  BusLogic can be assigned a string by insmod.&n;*/
macro_line|#ifdef MODULE
DECL|variable|BusLogic
r_static
r_char
op_star
id|BusLogic
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|BusLogic
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;  BusLogic_ProbeOptions is a set of Probe Options to be applied across&n;  all BusLogic Host Adapters.&n;*/
r_static
id|BusLogic_ProbeOptions_T
DECL|variable|BusLogic_ProbeOptions
id|BusLogic_ProbeOptions
suffix:semicolon
multiline_comment|/*&n;  BusLogic_GlobalOptions is a set of Global Options to be applied across&n;  all BusLogic Host Adapters.&n;*/
r_static
id|BusLogic_GlobalOptions_T
DECL|variable|BusLogic_GlobalOptions
id|BusLogic_GlobalOptions
suffix:semicolon
multiline_comment|/*&n;  BusLogic_FirstRegisteredHostAdapter and BusLogic_LastRegisteredHostAdapter&n;  are pointers to the first and last registered BusLogic Host Adapters.&n;*/
r_static
id|BusLogic_HostAdapter_T
DECL|variable|BusLogic_FirstRegisteredHostAdapter
op_star
id|BusLogic_FirstRegisteredHostAdapter
comma
DECL|variable|BusLogic_LastRegisteredHostAdapter
op_star
id|BusLogic_LastRegisteredHostAdapter
suffix:semicolon
multiline_comment|/*&n;  BusLogic_ProbeInfoCount is the number of entries in BusLogic_ProbeInfoList.&n;*/
r_static
r_int
DECL|variable|BusLogic_ProbeInfoCount
id|BusLogic_ProbeInfoCount
suffix:semicolon
multiline_comment|/*&n;  BusLogic_ProbeInfoList is the list of I/O Addresses and Bus Probe Information&n;  to be checked for potential BusLogic Host Adapters.  It is initialized by&n;  interrogating the PCI Configuration Space on PCI machines as well as from the&n;  list of standard BusLogic I/O Addresses.&n;*/
r_static
id|BusLogic_ProbeInfo_T
DECL|variable|BusLogic_ProbeInfoList
op_star
id|BusLogic_ProbeInfoList
suffix:semicolon
multiline_comment|/*&n;  BusLogic_CommandFailureReason holds a string identifying the reason why a&n;  call to BusLogic_Command failed.  It is only non-NULL when BusLogic_Command&n;  returns a failure code.&n;*/
r_static
r_char
DECL|variable|BusLogic_CommandFailureReason
op_star
id|BusLogic_CommandFailureReason
suffix:semicolon
multiline_comment|/*&n;  BusLogic_AnnounceDriver announces the Driver Version and Date, Author&squot;s&n;  Name, Copyright Notice, and Electronic Mail Address.&n;*/
DECL|function|BusLogic_AnnounceDriver
r_static
r_void
id|BusLogic_AnnounceDriver
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
id|BusLogic_Announce
c_func
(paren
l_string|&quot;***** BusLogic SCSI Driver Version &quot;
id|BusLogic_DriverVersion
l_string|&quot; of &quot;
id|BusLogic_DriverDate
l_string|&quot; *****&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_Announce
c_func
(paren
l_string|&quot;Copyright 1995-1998 by Leonard N. Zubkoff &quot;
l_string|&quot;&lt;lnz@dandelion.com&gt;&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_DriverInfo returns the Host Adapter Name to identify this SCSI&n;  Driver and Host Adapter.&n;*/
DECL|function|BusLogic_DriverInfo
r_const
r_char
op_star
id|BusLogic_DriverInfo
c_func
(paren
id|SCSI_Host_T
op_star
id|Host
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|Host-&gt;hostdata
suffix:semicolon
r_return
id|HostAdapter-&gt;FullModelName
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_RegisterHostAdapter adds Host Adapter to the list of registered&n;  BusLogic Host Adapters.&n;*/
DECL|function|BusLogic_RegisterHostAdapter
r_static
r_void
id|BusLogic_RegisterHostAdapter
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
id|HostAdapter-&gt;Next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_FirstRegisteredHostAdapter
op_eq
l_int|NULL
)paren
(brace
id|BusLogic_FirstRegisteredHostAdapter
op_assign
id|HostAdapter
suffix:semicolon
id|BusLogic_LastRegisteredHostAdapter
op_assign
id|HostAdapter
suffix:semicolon
)brace
r_else
(brace
id|BusLogic_LastRegisteredHostAdapter-&gt;Next
op_assign
id|HostAdapter
suffix:semicolon
id|BusLogic_LastRegisteredHostAdapter
op_assign
id|HostAdapter
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;  BusLogic_UnregisterHostAdapter removes Host Adapter from the list of&n;  registered BusLogic Host Adapters.&n;*/
DECL|function|BusLogic_UnregisterHostAdapter
r_static
r_void
id|BusLogic_UnregisterHostAdapter
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
r_if
c_cond
(paren
id|HostAdapter
op_eq
id|BusLogic_FirstRegisteredHostAdapter
)paren
(brace
id|BusLogic_FirstRegisteredHostAdapter
op_assign
id|BusLogic_FirstRegisteredHostAdapter-&gt;Next
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter
op_eq
id|BusLogic_LastRegisteredHostAdapter
)paren
id|BusLogic_LastRegisteredHostAdapter
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|BusLogic_HostAdapter_T
op_star
id|PreviousHostAdapter
op_assign
id|BusLogic_FirstRegisteredHostAdapter
suffix:semicolon
r_while
c_loop
(paren
id|PreviousHostAdapter
op_ne
l_int|NULL
op_logical_and
id|PreviousHostAdapter-&gt;Next
op_ne
id|HostAdapter
)paren
id|PreviousHostAdapter
op_assign
id|PreviousHostAdapter-&gt;Next
suffix:semicolon
r_if
c_cond
(paren
id|PreviousHostAdapter
op_ne
l_int|NULL
)paren
id|PreviousHostAdapter-&gt;Next
op_assign
id|HostAdapter-&gt;Next
suffix:semicolon
)brace
id|HostAdapter-&gt;Next
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InitializeCCBs initializes a group of Command Control Blocks (CCBs)&n;  for Host Adapter from the BlockSize bytes located at BlockPointer.  The newly&n;  created CCBs are added to Host Adapter&squot;s free list.&n;*/
DECL|function|BusLogic_InitializeCCBs
r_static
r_void
id|BusLogic_InitializeCCBs
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
comma
r_void
op_star
id|BlockPointer
comma
r_int
id|BlockSize
)paren
(brace
id|BusLogic_CCB_T
op_star
id|CCB
op_assign
(paren
id|BusLogic_CCB_T
op_star
)paren
id|BlockPointer
suffix:semicolon
id|memset
c_func
(paren
id|BlockPointer
comma
l_int|0
comma
id|BlockSize
)paren
suffix:semicolon
id|CCB-&gt;AllocationGroupHead
op_assign
l_bool|true
suffix:semicolon
r_while
c_loop
(paren
(paren
id|BlockSize
op_sub_assign
r_sizeof
(paren
id|BusLogic_CCB_T
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Free
suffix:semicolon
id|CCB-&gt;HostAdapter
op_assign
id|HostAdapter
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
id|CCB-&gt;CallbackFunction
op_assign
id|BusLogic_QueueCompletedCCB
suffix:semicolon
id|CCB-&gt;BaseAddress
op_assign
id|HostAdapter-&gt;FlashPointInfo.BaseAddress
suffix:semicolon
)brace
id|CCB-&gt;Next
op_assign
id|HostAdapter-&gt;Free_CCBs
suffix:semicolon
id|CCB-&gt;NextAll
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|HostAdapter-&gt;Free_CCBs
op_assign
id|CCB
suffix:semicolon
id|HostAdapter-&gt;All_CCBs
op_assign
id|CCB
suffix:semicolon
id|HostAdapter-&gt;AllocatedCCBs
op_increment
suffix:semicolon
id|CCB
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;  BusLogic_CreateInitialCCBs allocates the initial CCBs for Host Adapter.&n;*/
DECL|function|BusLogic_CreateInitialCCBs
r_static
id|boolean
id|BusLogic_CreateInitialCCBs
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
r_int
id|BlockSize
op_assign
id|BusLogic_CCB_AllocationGroupSize
op_star
r_sizeof
(paren
id|BusLogic_CCB_T
)paren
suffix:semicolon
r_while
c_loop
(paren
id|HostAdapter-&gt;AllocatedCCBs
OL
id|HostAdapter-&gt;InitialCCBs
)paren
(brace
r_void
op_star
id|BlockPointer
op_assign
id|kmalloc
c_func
(paren
id|BlockSize
comma
(paren
id|HostAdapter-&gt;BounceBuffersRequired
ques
c_cond
id|GFP_ATOMIC
op_or
id|GFP_DMA
suffix:colon
id|GFP_ATOMIC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BlockPointer
op_eq
l_int|NULL
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;UNABLE TO ALLOCATE CCB GROUP - DETACHING&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
id|BusLogic_InitializeCCBs
c_func
(paren
id|HostAdapter
comma
id|BlockPointer
comma
id|BlockSize
)paren
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_DestroyCCBs deallocates the CCBs for Host Adapter.&n;*/
DECL|function|BusLogic_DestroyCCBs
r_static
r_void
id|BusLogic_DestroyCCBs
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
id|BusLogic_CCB_T
op_star
id|NextCCB
op_assign
id|HostAdapter-&gt;All_CCBs
comma
op_star
id|CCB
suffix:semicolon
id|HostAdapter-&gt;All_CCBs
op_assign
l_int|NULL
suffix:semicolon
id|HostAdapter-&gt;Free_CCBs
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|CCB
op_assign
id|NextCCB
)paren
op_ne
l_int|NULL
)paren
(brace
id|NextCCB
op_assign
id|CCB-&gt;NextAll
suffix:semicolon
r_if
c_cond
(paren
id|CCB-&gt;AllocationGroupHead
)paren
id|kfree
c_func
(paren
id|CCB
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;  BusLogic_CreateAdditionalCCBs allocates Additional CCBs for Host Adapter.  If&n;  allocation fails and there are no remaining CCBs available, the Driver Queue&n;  Depth is decreased to a known safe value to avoid potential deadlocks when&n;  multiple host adapters share the same IRQ Channel.&n;*/
DECL|function|BusLogic_CreateAdditionalCCBs
r_static
r_void
id|BusLogic_CreateAdditionalCCBs
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
comma
r_int
id|AdditionalCCBs
comma
id|boolean
id|SuccessMessageP
)paren
(brace
r_int
id|BlockSize
op_assign
id|BusLogic_CCB_AllocationGroupSize
op_star
r_sizeof
(paren
id|BusLogic_CCB_T
)paren
suffix:semicolon
r_int
id|PreviouslyAllocated
op_assign
id|HostAdapter-&gt;AllocatedCCBs
suffix:semicolon
r_if
c_cond
(paren
id|AdditionalCCBs
op_le
l_int|0
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|HostAdapter-&gt;AllocatedCCBs
op_minus
id|PreviouslyAllocated
OL
id|AdditionalCCBs
)paren
(brace
r_void
op_star
id|BlockPointer
op_assign
id|kmalloc
c_func
(paren
id|BlockSize
comma
(paren
id|HostAdapter-&gt;BounceBuffersRequired
ques
c_cond
id|GFP_ATOMIC
op_or
id|GFP_DMA
suffix:colon
id|GFP_ATOMIC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BlockPointer
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|BusLogic_InitializeCCBs
c_func
(paren
id|HostAdapter
comma
id|BlockPointer
comma
id|BlockSize
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HostAdapter-&gt;AllocatedCCBs
OG
id|PreviouslyAllocated
)paren
(brace
r_if
c_cond
(paren
id|SuccessMessageP
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot;Allocated %d additional CCBs (total now %d)&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;AllocatedCCBs
op_minus
id|PreviouslyAllocated
comma
id|HostAdapter-&gt;AllocatedCCBs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|BusLogic_Notice
c_func
(paren
l_string|&quot;Failed to allocate additional CCBs&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;DriverQueueDepth
OG
id|HostAdapter-&gt;AllocatedCCBs
op_minus
id|HostAdapter-&gt;TargetDeviceCount
)paren
(brace
id|HostAdapter-&gt;DriverQueueDepth
op_assign
id|HostAdapter-&gt;AllocatedCCBs
op_minus
id|HostAdapter-&gt;TargetDeviceCount
suffix:semicolon
id|HostAdapter-&gt;SCSI_Host-&gt;can_queue
op_assign
id|HostAdapter-&gt;DriverQueueDepth
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;  BusLogic_AllocateCCB allocates a CCB from Host Adapter&squot;s free list,&n;  allocating more memory from the Kernel if necessary.  The Host Adapter&squot;s&n;  Lock should already have been acquired by the caller.&n;*/
DECL|function|BusLogic_AllocateCCB
r_static
id|BusLogic_CCB_T
op_star
id|BusLogic_AllocateCCB
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
r_static
r_int
r_int
id|SerialNumber
op_assign
l_int|0
suffix:semicolon
id|BusLogic_CCB_T
op_star
id|CCB
suffix:semicolon
id|CCB
op_assign
id|HostAdapter-&gt;Free_CCBs
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_ne
l_int|NULL
)paren
(brace
id|CCB-&gt;SerialNumber
op_assign
op_increment
id|SerialNumber
suffix:semicolon
id|HostAdapter-&gt;Free_CCBs
op_assign
id|CCB-&gt;Next
suffix:semicolon
id|CCB-&gt;Next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;Free_CCBs
op_eq
l_int|NULL
)paren
id|BusLogic_CreateAdditionalCCBs
c_func
(paren
id|HostAdapter
comma
id|HostAdapter-&gt;IncrementalCCBs
comma
l_bool|true
)paren
suffix:semicolon
r_return
id|CCB
suffix:semicolon
)brace
id|BusLogic_CreateAdditionalCCBs
c_func
(paren
id|HostAdapter
comma
id|HostAdapter-&gt;IncrementalCCBs
comma
l_bool|true
)paren
suffix:semicolon
id|CCB
op_assign
id|HostAdapter-&gt;Free_CCBs
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|CCB-&gt;SerialNumber
op_assign
op_increment
id|SerialNumber
suffix:semicolon
id|HostAdapter-&gt;Free_CCBs
op_assign
id|CCB-&gt;Next
suffix:semicolon
id|CCB-&gt;Next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|CCB
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_DeallocateCCB deallocates a CCB, returning it to the Host Adapter&squot;s&n;  free list.  The Host Adapter&squot;s Lock should already have been acquired by the&n;  caller.&n;*/
DECL|function|BusLogic_DeallocateCCB
r_static
r_void
id|BusLogic_DeallocateCCB
c_func
(paren
id|BusLogic_CCB_T
op_star
id|CCB
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
id|CCB-&gt;HostAdapter
suffix:semicolon
id|CCB-&gt;Command
op_assign
l_int|NULL
suffix:semicolon
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Free
suffix:semicolon
id|CCB-&gt;Next
op_assign
id|HostAdapter-&gt;Free_CCBs
suffix:semicolon
id|HostAdapter-&gt;Free_CCBs
op_assign
id|CCB
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_Command sends the command OperationCode to HostAdapter, optionally&n;  providing ParameterLength bytes of ParameterData and receiving at most&n;  ReplyLength bytes of ReplyData; any excess reply data is received but&n;  discarded.&n;&n;  On success, this function returns the number of reply bytes read from&n;  the Host Adapter (including any discarded data); on failure, it returns&n;  -1 if the command was invalid, or -2 if a timeout occurred.&n;&n;  BusLogic_Command is called exclusively during host adapter detection and&n;  initialization, so performance and latency are not critical, and exclusive&n;  access to the Host Adapter hardware is assumed.  Once the host adapter and&n;  driver are initialized, the only Host Adapter command that is issued is the&n;  single byte Execute Mailbox Command operation code, which does not require&n;  waiting for the Host Adapter Ready bit to be set in the Status Register.&n;*/
DECL|function|BusLogic_Command
r_static
r_int
id|BusLogic_Command
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
comma
id|BusLogic_OperationCode_T
id|OperationCode
comma
r_void
op_star
id|ParameterData
comma
r_int
id|ParameterLength
comma
r_void
op_star
id|ReplyData
comma
r_int
id|ReplyLength
)paren
(brace
r_int
r_char
op_star
id|ParameterPointer
op_assign
(paren
r_int
r_char
op_star
)paren
id|ParameterData
suffix:semicolon
r_int
r_char
op_star
id|ReplyPointer
op_assign
(paren
r_int
r_char
op_star
)paren
id|ReplyData
suffix:semicolon
id|BusLogic_StatusRegister_T
id|StatusRegister
suffix:semicolon
id|BusLogic_InterruptRegister_T
id|InterruptRegister
suffix:semicolon
id|ProcessorFlags_T
id|ProcessorFlags
op_assign
l_int|0
suffix:semicolon
r_int
id|ReplyBytes
op_assign
l_int|0
comma
id|Result
suffix:semicolon
r_int
id|TimeoutCounter
suffix:semicolon
multiline_comment|/*&n;    Clear out the Reply Data if provided.&n;  */
r_if
c_cond
(paren
id|ReplyLength
OG
l_int|0
)paren
id|memset
c_func
(paren
id|ReplyData
comma
l_int|0
comma
id|ReplyLength
)paren
suffix:semicolon
multiline_comment|/*&n;    If the IRQ Channel has not yet been acquired, then interrupts must be&n;    disabled while issuing host adapter commands since a Command Complete&n;    interrupt could occur if the IRQ Channel was previously enabled by another&n;    BusLogic Host Adapter or another driver sharing the same IRQ Channel.&n;  */
r_if
c_cond
(paren
op_logical_neg
id|HostAdapter-&gt;IRQ_ChannelAcquired
)paren
(brace
id|save_flags
c_func
(paren
id|ProcessorFlags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    Wait for the Host Adapter Ready bit to be set and the Command/Parameter&n;    Register Busy bit to be reset in the Status Register.&n;  */
id|TimeoutCounter
op_assign
l_int|10000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.Bits.HostAdapterReady
op_logical_and
op_logical_neg
id|StatusRegister.Bits.CommandParameterRegisterBusy
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
(brace
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Timeout waiting for Host Adapter Ready&quot;
suffix:semicolon
id|Result
op_assign
op_minus
l_int|2
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;    Write the OperationCode to the Command/Parameter Register.&n;  */
id|HostAdapter-&gt;HostAdapterCommandCompleted
op_assign
l_bool|false
suffix:semicolon
id|BusLogic_WriteCommandParameterRegister
c_func
(paren
id|HostAdapter
comma
id|OperationCode
)paren
suffix:semicolon
multiline_comment|/*&n;    Write any additional Parameter Bytes.&n;  */
id|TimeoutCounter
op_assign
l_int|10000
suffix:semicolon
r_while
c_loop
(paren
id|ParameterLength
OG
l_int|0
op_logical_and
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;Wait 100 microseconds to give the Host Adapter enough time to determine&n;&t;whether the last value written to the Command/Parameter Register was&n;&t;valid or not.  If the Command Complete bit is set in the Interrupt&n;&t;Register, then the Command Invalid bit in the Status Register will be&n;&t;reset if the Operation Code or Parameter was valid and the command&n;&t;has completed, or set if the Operation Code or Parameter was invalid.&n;&t;If the Data In Register Ready bit is set in the Status Register, then&n;&t;the Operation Code was valid, and data is waiting to be read back&n;&t;from the Host Adapter.  Otherwise, wait for the Command/Parameter&n;&t;Register Busy bit in the Status Register to be reset.&n;      */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|InterruptRegister.All
op_assign
id|BusLogic_ReadInterruptRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|InterruptRegister.Bits.CommandComplete
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterCommandCompleted
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.Bits.DataInRegisterReady
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.Bits.CommandParameterRegisterBusy
)paren
r_continue
suffix:semicolon
id|BusLogic_WriteCommandParameterRegister
c_func
(paren
id|HostAdapter
comma
op_star
id|ParameterPointer
op_increment
)paren
suffix:semicolon
id|ParameterLength
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
(brace
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Timeout waiting for Parameter Acceptance&quot;
suffix:semicolon
id|Result
op_assign
op_minus
l_int|2
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;    The Modify I/O Address command does not cause a Command Complete Interrupt.&n;  */
r_if
c_cond
(paren
id|OperationCode
op_eq
id|BusLogic_ModifyIOAddress
)paren
(brace
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.Bits.CommandInvalid
)paren
(brace
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Modify I/O Address Invalid&quot;
suffix:semicolon
id|Result
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceConfiguration
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic_Command(%02X) Status = %02X: &quot;
l_string|&quot;(Modify I/O Address)&bslash;n&quot;
comma
id|HostAdapter
comma
id|OperationCode
comma
id|StatusRegister.All
)paren
suffix:semicolon
id|Result
op_assign
l_int|0
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;    Select an appropriate timeout value for awaiting command completion.&n;  */
r_switch
c_cond
(paren
id|OperationCode
)paren
(brace
r_case
id|BusLogic_InquireInstalledDevicesID0to7
suffix:colon
r_case
id|BusLogic_InquireInstalledDevicesID8to15
suffix:colon
r_case
id|BusLogic_InquireTargetDevices
suffix:colon
multiline_comment|/* Approximately 60 seconds. */
id|TimeoutCounter
op_assign
l_int|60
op_star
l_int|10000
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Approximately 1 second. */
id|TimeoutCounter
op_assign
l_int|10000
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;    Receive any Reply Bytes, waiting for either the Command Complete bit to&n;    be set in the Interrupt Register, or for the Interrupt Handler to set the&n;    Host Adapter Command Completed bit in the Host Adapter structure.&n;  */
r_while
c_loop
(paren
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
id|InterruptRegister.All
op_assign
id|BusLogic_ReadInterruptRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|InterruptRegister.Bits.CommandComplete
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterCommandCompleted
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.Bits.DataInRegisterReady
)paren
(brace
r_if
c_cond
(paren
op_increment
id|ReplyBytes
op_le
id|ReplyLength
)paren
op_star
id|ReplyPointer
op_increment
op_assign
id|BusLogic_ReadDataInRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_else
id|BusLogic_ReadDataInRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|OperationCode
op_eq
id|BusLogic_FetchHostAdapterLocalRAM
op_logical_and
id|StatusRegister.Bits.HostAdapterReady
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
(brace
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Timeout waiting for Command Complete&quot;
suffix:semicolon
id|Result
op_assign
op_minus
l_int|2
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;    Clear any pending Command Complete Interrupt.&n;  */
id|BusLogic_InterruptReset
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
multiline_comment|/*&n;    Provide tracing information if requested.&n;  */
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceConfiguration
)paren
(brace
r_int
id|i
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic_Command(%02X) Status = %02X: %2d ==&gt; %2d:&quot;
comma
id|HostAdapter
comma
id|OperationCode
comma
id|StatusRegister.All
comma
id|ReplyLength
comma
id|ReplyBytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReplyLength
OG
id|ReplyBytes
)paren
id|ReplyLength
op_assign
id|ReplyBytes
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ReplyLength
suffix:semicolon
id|i
op_increment
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot; %02X&quot;
comma
id|HostAdapter
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|ReplyData
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    Process Command Invalid conditions.&n;  */
r_if
c_cond
(paren
id|StatusRegister.Bits.CommandInvalid
)paren
(brace
multiline_comment|/*&n;&t;Some early BusLogic Host Adapters may not recover properly from&n;&t;a Command Invalid condition, so if this appears to be the case,&n;&t;a Soft Reset is issued to the Host Adapter.  Potentially invalid&n;&t;commands are never attempted after Mailbox Initialization is&n;&t;performed, so there should be no Host Adapter state lost by a&n;&t;Soft Reset in response to a Command Invalid condition.&n;      */
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.Bits.CommandInvalid
op_logical_or
id|StatusRegister.Bits.Reserved
op_logical_or
id|StatusRegister.Bits.DataInRegisterReady
op_logical_or
id|StatusRegister.Bits.CommandParameterRegisterBusy
op_logical_or
op_logical_neg
id|StatusRegister.Bits.HostAdapterReady
op_logical_or
op_logical_neg
id|StatusRegister.Bits.InitializationRequired
op_logical_or
id|StatusRegister.Bits.DiagnosticActive
op_logical_or
id|StatusRegister.Bits.DiagnosticFailure
)paren
(brace
id|BusLogic_SoftReset
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Command Invalid&quot;
suffix:semicolon
id|Result
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;    Handle Excess Parameters Supplied conditions.&n;  */
r_if
c_cond
(paren
id|ParameterLength
OG
l_int|0
)paren
(brace
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Excess Parameters Supplied&quot;
suffix:semicolon
id|Result
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;    Indicate the command completed successfully.&n;  */
id|BusLogic_CommandFailureReason
op_assign
l_int|NULL
suffix:semicolon
id|Result
op_assign
id|ReplyBytes
suffix:semicolon
multiline_comment|/*&n;    Restore the interrupt status if necessary and return.&n;  */
id|Done
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|HostAdapter-&gt;IRQ_ChannelAcquired
)paren
id|restore_flags
c_func
(paren
id|ProcessorFlags
)paren
suffix:semicolon
r_return
id|Result
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_AppendProbeAddressISA appends a single ISA I/O Address to the list&n;  of I/O Address and Bus Probe Information to be checked for potential BusLogic&n;  Host Adapters.&n;*/
DECL|function|BusLogic_AppendProbeAddressISA
r_static
r_void
id|BusLogic_AppendProbeAddressISA
c_func
(paren
id|BusLogic_IO_Address_T
id|IO_Address
)paren
(brace
id|BusLogic_ProbeInfo_T
op_star
id|ProbeInfo
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_ProbeInfoCount
op_ge
id|BusLogic_MaxHostAdapters
)paren
r_return
suffix:semicolon
id|ProbeInfo
op_assign
op_amp
id|BusLogic_ProbeInfoList
(braket
id|BusLogic_ProbeInfoCount
op_increment
)braket
suffix:semicolon
id|ProbeInfo-&gt;HostAdapterType
op_assign
id|BusLogic_MultiMaster
suffix:semicolon
id|ProbeInfo-&gt;HostAdapterBusType
op_assign
id|BusLogic_ISA_Bus
suffix:semicolon
id|ProbeInfo-&gt;IO_Address
op_assign
id|IO_Address
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InitializeProbeInfoListISA initializes the list of I/O Address and&n;  Bus Probe Information to be checked for potential BusLogic SCSI Host Adapters&n;  only from the list of standard BusLogic MultiMaster ISA I/O Addresses.&n;*/
DECL|function|BusLogic_InitializeProbeInfoListISA
r_static
r_void
id|BusLogic_InitializeProbeInfoListISA
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|PrototypeHostAdapter
)paren
(brace
multiline_comment|/*&n;    If BusLogic Driver Options specifications requested that ISA Bus Probes&n;    be inhibited, do not proceed further.&n;  */
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.NoProbeISA
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;    Append the list of standard BusLogic MultiMaster ISA I/O Addresses.&n;  */
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe330
suffix:colon
id|check_region
c_func
(paren
l_int|0x330
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x330
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe334
suffix:colon
id|check_region
c_func
(paren
l_int|0x334
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x334
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe230
suffix:colon
id|check_region
c_func
(paren
l_int|0x230
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x230
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe234
suffix:colon
id|check_region
c_func
(paren
l_int|0x234
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x234
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe130
suffix:colon
id|check_region
c_func
(paren
l_int|0x130
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x130
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe134
suffix:colon
id|check_region
c_func
(paren
l_int|0x134
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x134
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PCI
multiline_comment|/*&n;  BusLogic_SortProbeInfo sorts a section of BusLogic_ProbeInfoList in order&n;  of increasing PCI Bus and Device Number.&n;*/
DECL|function|BusLogic_SortProbeInfo
r_static
r_void
id|BusLogic_SortProbeInfo
c_func
(paren
id|BusLogic_ProbeInfo_T
op_star
id|ProbeInfoList
comma
r_int
id|ProbeInfoCount
)paren
(brace
r_int
id|LastInterchange
op_assign
id|ProbeInfoCount
op_minus
l_int|1
comma
id|Bound
comma
id|j
suffix:semicolon
r_while
c_loop
(paren
id|LastInterchange
OG
l_int|0
)paren
(brace
id|Bound
op_assign
id|LastInterchange
suffix:semicolon
id|LastInterchange
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|Bound
suffix:semicolon
id|j
op_increment
)paren
(brace
id|BusLogic_ProbeInfo_T
op_star
id|ProbeInfo1
op_assign
op_amp
id|ProbeInfoList
(braket
id|j
)braket
suffix:semicolon
id|BusLogic_ProbeInfo_T
op_star
id|ProbeInfo2
op_assign
op_amp
id|ProbeInfoList
(braket
id|j
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ProbeInfo1-&gt;Bus
OG
id|ProbeInfo2-&gt;Bus
op_logical_or
(paren
id|ProbeInfo1-&gt;Bus
op_eq
id|ProbeInfo2-&gt;Bus
op_logical_and
(paren
id|ProbeInfo1-&gt;Device
OG
id|ProbeInfo2-&gt;Device
)paren
)paren
)paren
(brace
id|BusLogic_ProbeInfo_T
id|TempProbeInfo
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|TempProbeInfo
comma
id|ProbeInfo1
comma
r_sizeof
(paren
id|BusLogic_ProbeInfo_T
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ProbeInfo1
comma
id|ProbeInfo2
comma
r_sizeof
(paren
id|BusLogic_ProbeInfo_T
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ProbeInfo2
comma
op_amp
id|TempProbeInfo
comma
r_sizeof
(paren
id|BusLogic_ProbeInfo_T
)paren
)paren
suffix:semicolon
id|LastInterchange
op_assign
id|j
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n;  BusLogic_InitializeMultiMasterProbeInfo initializes the list of I/O Address&n;  and Bus Probe Information to be checked for potential BusLogic MultiMaster&n;  SCSI Host Adapters by interrogating the PCI Configuration Space on PCI&n;  machines as well as from the list of standard BusLogic MultiMaster ISA&n;  I/O Addresses.  It returns the number of PCI MultiMaster Host Adapters found.&n;*/
DECL|function|BusLogic_InitializeMultiMasterProbeInfo
r_static
r_int
id|BusLogic_InitializeMultiMasterProbeInfo
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|PrototypeHostAdapter
)paren
(brace
id|BusLogic_ProbeInfo_T
op_star
id|PrimaryProbeInfo
op_assign
op_amp
id|BusLogic_ProbeInfoList
(braket
id|BusLogic_ProbeInfoCount
)braket
suffix:semicolon
r_int
id|NonPrimaryPCIMultiMasterIndex
op_assign
id|BusLogic_ProbeInfoCount
op_plus
l_int|1
suffix:semicolon
r_int
id|NonPrimaryPCIMultiMasterCount
op_assign
l_int|0
comma
id|PCIMultiMasterCount
op_assign
l_int|0
suffix:semicolon
id|boolean
id|ForceBusDeviceScanningOrder
op_assign
l_bool|false
suffix:semicolon
id|boolean
id|ForceBusDeviceScanningOrderChecked
op_assign
l_bool|false
suffix:semicolon
id|boolean
id|StandardAddressSeen
(braket
l_int|6
)braket
suffix:semicolon
id|PCI_Device_T
op_star
id|PCI_Device
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_ProbeInfoCount
op_ge
id|BusLogic_MaxHostAdapters
)paren
r_return
l_int|0
suffix:semicolon
id|BusLogic_ProbeInfoCount
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|StandardAddressSeen
(braket
id|i
)braket
op_assign
l_bool|false
suffix:semicolon
multiline_comment|/*&n;    Iterate over the MultiMaster PCI Host Adapters.  For each enumerated host&n;    adapter, determine whether its ISA Compatible I/O Port is enabled and if&n;    so, whether it is assigned the Primary I/O Address.  A host adapter that is&n;    assigned the Primary I/O Address will always be the preferred boot device.&n;    The MultiMaster BIOS will first recognize a host adapter at the Primary I/O&n;    Address, then any other PCI host adapters, and finally any host adapters&n;    located at the remaining standard ISA I/O Addresses.  When a PCI host&n;    adapter is found with its ISA Compatible I/O Port enabled, a command is&n;    issued to disable the ISA Compatible I/O Port, and it is noted that the&n;    particular standard ISA I/O Address need not be probed.&n;  */
id|PrimaryProbeInfo-&gt;IO_Address
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|PCI_Device
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_BUSLOGIC
comma
id|PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER
comma
id|PCI_Device
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
id|PrototypeHostAdapter
suffix:semicolon
id|BusLogic_PCIHostAdapterInformation_T
id|PCIHostAdapterInformation
suffix:semicolon
id|BusLogic_ModifyIOAddressRequest_T
id|ModifyIOAddressRequest
suffix:semicolon
r_int
r_char
id|Bus
op_assign
id|PCI_Device-&gt;bus-&gt;number
suffix:semicolon
r_int
r_char
id|Device
op_assign
id|PCI_Device-&gt;devfn
op_rshift
l_int|3
suffix:semicolon
r_int
r_int
id|IRQ_Channel
op_assign
id|PCI_Device-&gt;irq
suffix:semicolon
r_int
r_int
id|BaseAddress0
op_assign
id|pci_resource_start
c_func
(paren
id|PCI_Device
comma
l_int|0
)paren
suffix:semicolon
r_int
r_int
id|BaseAddress1
op_assign
id|pci_resource_start
c_func
(paren
id|PCI_Device
comma
l_int|1
)paren
suffix:semicolon
id|BusLogic_IO_Address_T
id|IO_Address
op_assign
id|BaseAddress0
suffix:semicolon
id|BusLogic_PCI_Address_T
id|PCI_Address
op_assign
id|BaseAddress1
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|PCI_Device
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pci_resource_flags
c_func
(paren
id|PCI_Device
comma
l_int|0
)paren
op_amp
id|IORESOURCE_MEM
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Base Address0 0x%X not I/O for &quot;
l_string|&quot;MultiMaster Host Adapter&bslash;n&quot;
comma
l_int|NULL
comma
id|BaseAddress0
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;at PCI Bus %d Device %d I/O Address 0x%X&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
comma
id|IO_Address
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pci_resource_flags
c_func
(paren
id|PCI_Device
comma
l_int|1
)paren
op_amp
id|IORESOURCE_IO
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Base Address1 0x%X not Memory for &quot;
l_string|&quot;MultiMaster Host Adapter&bslash;n&quot;
comma
l_int|NULL
comma
id|BaseAddress1
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;at PCI Bus %d Device %d PCI Address 0x%X&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
comma
id|PCI_Address
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IRQ_Channel
op_eq
l_int|0
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: IRQ Channel %d illegal for &quot;
l_string|&quot;MultiMaster Host Adapter&bslash;n&quot;
comma
l_int|NULL
comma
id|IRQ_Channel
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;at PCI Bus %d Device %d I/O Address 0x%X&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
comma
id|IO_Address
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceProbe
)paren
(brace
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic: PCI MultiMaster Host Adapter &quot;
l_string|&quot;detected at&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic: PCI Bus %d Device %d I/O Address &quot;
l_string|&quot;0x%X PCI Address 0x%X&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
comma
id|IO_Address
comma
id|PCI_Address
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Issue the Inquire PCI Host Adapter Information command to determine&n;&t;the ISA Compatible I/O Port.  If the ISA Compatible I/O Port is&n;&t;known and enabled, note that the particular Standard ISA I/O&n;&t;Address should not be probed.&n;      */
id|HostAdapter-&gt;IO_Address
op_assign
id|IO_Address
suffix:semicolon
id|BusLogic_InterruptReset
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquirePCIHostAdapterInformation
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|PCIHostAdapterInformation
comma
r_sizeof
(paren
id|PCIHostAdapterInformation
)paren
)paren
op_eq
r_sizeof
(paren
id|PCIHostAdapterInformation
)paren
)paren
(brace
r_if
c_cond
(paren
id|PCIHostAdapterInformation.ISACompatibleIOPort
OL
l_int|6
)paren
id|StandardAddressSeen
(braket
id|PCIHostAdapterInformation
dot
id|ISACompatibleIOPort
)braket
op_assign
l_bool|true
suffix:semicolon
)brace
r_else
id|PCIHostAdapterInformation.ISACompatibleIOPort
op_assign
id|BusLogic_IO_Disable
suffix:semicolon
multiline_comment|/*&n;&t;Issue the Modify I/O Address command to disable the ISA Compatible&n;&t;I/O Port.&n;      */
id|ModifyIOAddressRequest
op_assign
id|BusLogic_IO_Disable
suffix:semicolon
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_ModifyIOAddress
comma
op_amp
id|ModifyIOAddressRequest
comma
r_sizeof
(paren
id|ModifyIOAddressRequest
)paren
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;For the first MultiMaster Host Adapter enumerated, issue the Fetch&n;&t;Host Adapter Local RAM command to read byte 45 of the AutoSCSI area,&n;&t;for the setting of the &quot;Use Bus And Device # For PCI Scanning Seq.&quot;&n;&t;option.  Issue the Inquire Board ID command since this option is&n;&t;only valid for the BT-948/958/958D.&n;      */
r_if
c_cond
(paren
op_logical_neg
id|ForceBusDeviceScanningOrderChecked
)paren
(brace
id|BusLogic_FetchHostAdapterLocalRAMRequest_T
id|FetchHostAdapterLocalRAMRequest
suffix:semicolon
id|BusLogic_AutoSCSIByte45_T
id|AutoSCSIByte45
suffix:semicolon
id|BusLogic_BoardID_T
id|BoardID
suffix:semicolon
id|FetchHostAdapterLocalRAMRequest.ByteOffset
op_assign
id|BusLogic_AutoSCSI_BaseOffset
op_plus
l_int|45
suffix:semicolon
id|FetchHostAdapterLocalRAMRequest.ByteCount
op_assign
r_sizeof
(paren
id|AutoSCSIByte45
)paren
suffix:semicolon
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_FetchHostAdapterLocalRAM
comma
op_amp
id|FetchHostAdapterLocalRAMRequest
comma
r_sizeof
(paren
id|FetchHostAdapterLocalRAMRequest
)paren
comma
op_amp
id|AutoSCSIByte45
comma
r_sizeof
(paren
id|AutoSCSIByte45
)paren
)paren
suffix:semicolon
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireBoardID
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|BoardID
comma
r_sizeof
(paren
id|BoardID
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BoardID.FirmwareVersion1stDigit
op_eq
l_char|&squot;5&squot;
)paren
id|ForceBusDeviceScanningOrder
op_assign
id|AutoSCSIByte45.ForceBusDeviceScanningOrder
suffix:semicolon
id|ForceBusDeviceScanningOrderChecked
op_assign
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Determine whether this MultiMaster Host Adapter has its ISA&n;&t;Compatible I/O Port enabled and is assigned the Primary I/O Address.&n;&t;If it does, then it is the Primary MultiMaster Host Adapter and must&n;&t;be recognized first.  If it does not, then it is added to the list&n;&t;for probing after any Primary MultiMaster Host Adapter is probed.&n;      */
r_if
c_cond
(paren
id|PCIHostAdapterInformation.ISACompatibleIOPort
op_eq
id|BusLogic_IO_330
)paren
(brace
id|PrimaryProbeInfo-&gt;HostAdapterType
op_assign
id|BusLogic_MultiMaster
suffix:semicolon
id|PrimaryProbeInfo-&gt;HostAdapterBusType
op_assign
id|BusLogic_PCI_Bus
suffix:semicolon
id|PrimaryProbeInfo-&gt;IO_Address
op_assign
id|IO_Address
suffix:semicolon
id|PrimaryProbeInfo-&gt;PCI_Address
op_assign
id|PCI_Address
suffix:semicolon
id|PrimaryProbeInfo-&gt;Bus
op_assign
id|Bus
suffix:semicolon
id|PrimaryProbeInfo-&gt;Device
op_assign
id|Device
suffix:semicolon
id|PrimaryProbeInfo-&gt;IRQ_Channel
op_assign
id|IRQ_Channel
suffix:semicolon
id|PCIMultiMasterCount
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_ProbeInfoCount
OL
id|BusLogic_MaxHostAdapters
)paren
(brace
id|BusLogic_ProbeInfo_T
op_star
id|ProbeInfo
op_assign
op_amp
id|BusLogic_ProbeInfoList
(braket
id|BusLogic_ProbeInfoCount
op_increment
)braket
suffix:semicolon
id|ProbeInfo-&gt;HostAdapterType
op_assign
id|BusLogic_MultiMaster
suffix:semicolon
id|ProbeInfo-&gt;HostAdapterBusType
op_assign
id|BusLogic_PCI_Bus
suffix:semicolon
id|ProbeInfo-&gt;IO_Address
op_assign
id|IO_Address
suffix:semicolon
id|ProbeInfo-&gt;PCI_Address
op_assign
id|PCI_Address
suffix:semicolon
id|ProbeInfo-&gt;Bus
op_assign
id|Bus
suffix:semicolon
id|ProbeInfo-&gt;Device
op_assign
id|Device
suffix:semicolon
id|ProbeInfo-&gt;IRQ_Channel
op_assign
id|IRQ_Channel
suffix:semicolon
id|NonPrimaryPCIMultiMasterCount
op_increment
suffix:semicolon
id|PCIMultiMasterCount
op_increment
suffix:semicolon
)brace
r_else
id|BusLogic_Warning
c_func
(paren
l_string|&quot;BusLogic: Too many Host Adapters &quot;
l_string|&quot;detected&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    If the AutoSCSI &quot;Use Bus And Device # For PCI Scanning Seq.&quot; option is ON&n;    for the first enumerated MultiMaster Host Adapter, and if that host adapter&n;    is a BT-948/958/958D, then the MultiMaster BIOS will recognize MultiMaster&n;    Host Adapters in the order of increasing PCI Bus and Device Number.  In&n;    that case, sort the probe information into the same order the BIOS uses.&n;    If this option is OFF, then the MultiMaster BIOS will recognize MultiMaster&n;    Host Adapters in the order they are enumerated by the PCI BIOS, and hence&n;    no sorting is necessary.&n;  */
r_if
c_cond
(paren
id|ForceBusDeviceScanningOrder
)paren
id|BusLogic_SortProbeInfo
c_func
(paren
op_amp
id|BusLogic_ProbeInfoList
(braket
id|NonPrimaryPCIMultiMasterIndex
)braket
comma
id|NonPrimaryPCIMultiMasterCount
)paren
suffix:semicolon
multiline_comment|/*&n;    If no PCI MultiMaster Host Adapter is assigned the Primary I/O Address,&n;    then the Primary I/O Address must be probed explicitly before any PCI&n;    host adapters are probed.&n;  */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_ProbeOptions.NoProbeISA
)paren
r_if
c_cond
(paren
id|PrimaryProbeInfo-&gt;IO_Address
op_eq
l_int|0
op_logical_and
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe330
suffix:colon
id|check_region
c_func
(paren
l_int|0x330
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|PrimaryProbeInfo-&gt;HostAdapterType
op_assign
id|BusLogic_MultiMaster
suffix:semicolon
id|PrimaryProbeInfo-&gt;HostAdapterBusType
op_assign
id|BusLogic_ISA_Bus
suffix:semicolon
id|PrimaryProbeInfo-&gt;IO_Address
op_assign
l_int|0x330
suffix:semicolon
)brace
multiline_comment|/*&n;    Append the list of standard BusLogic MultiMaster ISA I/O Addresses,&n;    omitting the Primary I/O Address which has already been handled.&n;  */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_ProbeOptions.NoProbeISA
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|StandardAddressSeen
(braket
l_int|1
)braket
op_logical_and
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe334
suffix:colon
id|check_region
c_func
(paren
l_int|0x334
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x334
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|StandardAddressSeen
(braket
l_int|2
)braket
op_logical_and
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe230
suffix:colon
id|check_region
c_func
(paren
l_int|0x230
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x230
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|StandardAddressSeen
(braket
l_int|3
)braket
op_logical_and
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe234
suffix:colon
id|check_region
c_func
(paren
l_int|0x234
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x234
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|StandardAddressSeen
(braket
l_int|4
)braket
op_logical_and
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe130
suffix:colon
id|check_region
c_func
(paren
l_int|0x130
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x130
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|StandardAddressSeen
(braket
l_int|5
)braket
op_logical_and
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe134
suffix:colon
id|check_region
c_func
(paren
l_int|0x134
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x134
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    Iterate over the older non-compliant MultiMaster PCI Host Adapters,&n;    noting the PCI bus location and assigned IRQ Channel.&n;  */
id|PCI_Device
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|PCI_Device
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_BUSLOGIC
comma
id|PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER_NC
comma
id|PCI_Device
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
r_char
id|Bus
op_assign
id|PCI_Device-&gt;bus-&gt;number
suffix:semicolon
r_int
r_char
id|Device
op_assign
id|PCI_Device-&gt;devfn
op_rshift
l_int|3
suffix:semicolon
r_int
r_int
id|IRQ_Channel
op_assign
id|PCI_Device-&gt;irq
suffix:semicolon
id|BusLogic_IO_Address_T
id|IO_Address
op_assign
id|pci_resource_start
c_func
(paren
id|PCI_Device
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|PCI_Device
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|IO_Address
op_eq
l_int|0
op_logical_or
id|IRQ_Channel
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BusLogic_ProbeInfoCount
suffix:semicolon
id|i
op_increment
)paren
(brace
id|BusLogic_ProbeInfo_T
op_star
id|ProbeInfo
op_assign
op_amp
id|BusLogic_ProbeInfoList
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ProbeInfo-&gt;IO_Address
op_eq
id|IO_Address
op_logical_and
id|ProbeInfo-&gt;HostAdapterType
op_eq
id|BusLogic_MultiMaster
)paren
(brace
id|ProbeInfo-&gt;HostAdapterBusType
op_assign
id|BusLogic_PCI_Bus
suffix:semicolon
id|ProbeInfo-&gt;PCI_Address
op_assign
l_int|0
suffix:semicolon
id|ProbeInfo-&gt;Bus
op_assign
id|Bus
suffix:semicolon
id|ProbeInfo-&gt;Device
op_assign
id|Device
suffix:semicolon
id|ProbeInfo-&gt;IRQ_Channel
op_assign
id|IRQ_Channel
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_return
id|PCIMultiMasterCount
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InitializeFlashPointProbeInfo initializes the list of I/O Address&n;  and Bus Probe Information to be checked for potential BusLogic FlashPoint&n;  Host Adapters by interrogating the PCI Configuration Space.  It returns the&n;  number of FlashPoint Host Adapters found.&n;*/
DECL|function|BusLogic_InitializeFlashPointProbeInfo
r_static
r_int
id|BusLogic_InitializeFlashPointProbeInfo
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|PrototypeHostAdapter
)paren
(brace
r_int
id|FlashPointIndex
op_assign
id|BusLogic_ProbeInfoCount
comma
id|FlashPointCount
op_assign
l_int|0
suffix:semicolon
id|PCI_Device_T
op_star
id|PCI_Device
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;    Interrogate PCI Configuration Space for any FlashPoint Host Adapters.&n;  */
r_while
c_loop
(paren
(paren
id|PCI_Device
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_BUSLOGIC
comma
id|PCI_DEVICE_ID_BUSLOGIC_FLASHPOINT
comma
id|PCI_Device
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
r_char
id|Bus
op_assign
id|PCI_Device-&gt;bus-&gt;number
suffix:semicolon
r_int
r_char
id|Device
op_assign
id|PCI_Device-&gt;devfn
op_rshift
l_int|3
suffix:semicolon
r_int
r_int
id|IRQ_Channel
op_assign
id|PCI_Device-&gt;irq
suffix:semicolon
r_int
r_int
id|BaseAddress0
op_assign
id|pci_resource_start
c_func
(paren
id|PCI_Device
comma
l_int|0
)paren
suffix:semicolon
r_int
r_int
id|BaseAddress1
op_assign
id|pci_resource_start
c_func
(paren
id|PCI_Device
comma
l_int|1
)paren
suffix:semicolon
id|BusLogic_IO_Address_T
id|IO_Address
op_assign
id|BaseAddress0
suffix:semicolon
id|BusLogic_PCI_Address_T
id|PCI_Address
op_assign
id|BaseAddress1
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|PCI_Device
)paren
)paren
r_continue
suffix:semicolon
macro_line|#ifndef CONFIG_SCSI_OMIT_FLASHPOINT
r_if
c_cond
(paren
id|pci_resource_flags
c_func
(paren
id|PCI_Device
comma
l_int|0
)paren
op_amp
id|IORESOURCE_MEM
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Base Address0 0x%X not I/O for &quot;
l_string|&quot;FlashPoint Host Adapter&bslash;n&quot;
comma
l_int|NULL
comma
id|BaseAddress0
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;at PCI Bus %d Device %d I/O Address 0x%X&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
comma
id|IO_Address
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pci_resource_flags
c_func
(paren
id|PCI_Device
comma
l_int|1
)paren
op_amp
id|IORESOURCE_IO
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Base Address1 0x%X not Memory for &quot;
l_string|&quot;FlashPoint Host Adapter&bslash;n&quot;
comma
l_int|NULL
comma
id|BaseAddress1
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;at PCI Bus %d Device %d PCI Address 0x%X&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
comma
id|PCI_Address
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IRQ_Channel
op_eq
l_int|0
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: IRQ Channel %d illegal for &quot;
l_string|&quot;FlashPoint Host Adapter&bslash;n&quot;
comma
l_int|NULL
comma
id|IRQ_Channel
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;at PCI Bus %d Device %d I/O Address 0x%X&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
comma
id|IO_Address
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceProbe
)paren
(brace
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic: FlashPoint Host Adapter &quot;
l_string|&quot;detected at&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic: PCI Bus %d Device %d I/O Address &quot;
l_string|&quot;0x%X PCI Address 0x%X&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
comma
id|IO_Address
comma
id|PCI_Address
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_ProbeInfoCount
OL
id|BusLogic_MaxHostAdapters
)paren
(brace
id|BusLogic_ProbeInfo_T
op_star
id|ProbeInfo
op_assign
op_amp
id|BusLogic_ProbeInfoList
(braket
id|BusLogic_ProbeInfoCount
op_increment
)braket
suffix:semicolon
id|ProbeInfo-&gt;HostAdapterType
op_assign
id|BusLogic_FlashPoint
suffix:semicolon
id|ProbeInfo-&gt;HostAdapterBusType
op_assign
id|BusLogic_PCI_Bus
suffix:semicolon
id|ProbeInfo-&gt;IO_Address
op_assign
id|IO_Address
suffix:semicolon
id|ProbeInfo-&gt;PCI_Address
op_assign
id|PCI_Address
suffix:semicolon
id|ProbeInfo-&gt;Bus
op_assign
id|Bus
suffix:semicolon
id|ProbeInfo-&gt;Device
op_assign
id|Device
suffix:semicolon
id|ProbeInfo-&gt;IRQ_Channel
op_assign
id|IRQ_Channel
suffix:semicolon
id|FlashPointCount
op_increment
suffix:semicolon
)brace
r_else
id|BusLogic_Warning
c_func
(paren
l_string|&quot;BusLogic: Too many Host Adapters &quot;
l_string|&quot;detected&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#else
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: FlashPoint Host Adapter detected at &quot;
l_string|&quot;PCI Bus %d Device %d&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: I/O Address 0x%X PCI Address 0x%X, irq %d, &quot;
l_string|&quot;but FlashPoint&bslash;n&quot;
comma
l_int|NULL
comma
id|IO_Address
comma
id|PCI_Address
comma
id|IRQ_Channel
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: support was omitted in this kernel &quot;
l_string|&quot;configuration.&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;    The FlashPoint BIOS will scan for FlashPoint Host Adapters in the order of&n;    increasing PCI Bus and Device Number, so sort the probe information into&n;    the same order the BIOS uses.&n;  */
id|BusLogic_SortProbeInfo
c_func
(paren
op_amp
id|BusLogic_ProbeInfoList
(braket
id|FlashPointIndex
)braket
comma
id|FlashPointCount
)paren
suffix:semicolon
r_return
id|FlashPointCount
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InitializeProbeInfoList initializes the list of I/O Address and Bus&n;  Probe Information to be checked for potential BusLogic SCSI Host Adapters by&n;  interrogating the PCI Configuration Space on PCI machines as well as from the&n;  list of standard BusLogic MultiMaster ISA I/O Addresses.  By default, if both&n;  FlashPoint and PCI MultiMaster Host Adapters are present, this driver will&n;  probe for FlashPoint Host Adapters first unless the BIOS primary disk is&n;  controlled by the first PCI MultiMaster Host Adapter, in which case&n;  MultiMaster Host Adapters will be probed first.  The BusLogic Driver Options&n;  specifications &quot;MultiMasterFirst&quot; and &quot;FlashPointFirst&quot; can be used to force&n;  a particular probe order.&n;*/
DECL|function|BusLogic_InitializeProbeInfoList
r_static
r_void
id|BusLogic_InitializeProbeInfoList
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|PrototypeHostAdapter
)paren
(brace
multiline_comment|/*&n;    If a PCI BIOS is present, interrogate it for MultiMaster and FlashPoint&n;    Host Adapters; otherwise, default to the standard ISA MultiMaster probe.&n;  */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_ProbeOptions.NoProbePCI
op_logical_and
id|pci_present
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.MultiMasterFirst
)paren
(brace
id|BusLogic_InitializeMultiMasterProbeInfo
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
id|BusLogic_InitializeFlashPointProbeInfo
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.FlashPointFirst
)paren
(brace
id|BusLogic_InitializeFlashPointProbeInfo
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
id|BusLogic_InitializeMultiMasterProbeInfo
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|FlashPointCount
op_assign
id|BusLogic_InitializeFlashPointProbeInfo
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
r_int
id|PCIMultiMasterCount
op_assign
id|BusLogic_InitializeMultiMasterProbeInfo
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FlashPointCount
OG
l_int|0
op_logical_and
id|PCIMultiMasterCount
OG
l_int|0
)paren
(brace
id|BusLogic_ProbeInfo_T
op_star
id|ProbeInfo
op_assign
op_amp
id|BusLogic_ProbeInfoList
(braket
id|FlashPointCount
)braket
suffix:semicolon
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
id|PrototypeHostAdapter
suffix:semicolon
id|BusLogic_FetchHostAdapterLocalRAMRequest_T
id|FetchHostAdapterLocalRAMRequest
suffix:semicolon
id|BusLogic_BIOSDriveMapByte_T
id|Drive0MapByte
suffix:semicolon
r_while
c_loop
(paren
id|ProbeInfo-&gt;HostAdapterBusType
op_ne
id|BusLogic_PCI_Bus
)paren
id|ProbeInfo
op_increment
suffix:semicolon
id|HostAdapter-&gt;IO_Address
op_assign
id|ProbeInfo-&gt;IO_Address
suffix:semicolon
id|FetchHostAdapterLocalRAMRequest.ByteOffset
op_assign
id|BusLogic_BIOS_BaseOffset
op_plus
id|BusLogic_BIOS_DriveMapOffset
op_plus
l_int|0
suffix:semicolon
id|FetchHostAdapterLocalRAMRequest.ByteCount
op_assign
r_sizeof
(paren
id|Drive0MapByte
)paren
suffix:semicolon
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_FetchHostAdapterLocalRAM
comma
op_amp
id|FetchHostAdapterLocalRAMRequest
comma
r_sizeof
(paren
id|FetchHostAdapterLocalRAMRequest
)paren
comma
op_amp
id|Drive0MapByte
comma
r_sizeof
(paren
id|Drive0MapByte
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;If the Map Byte for BIOS Drive 0 indicates that BIOS Drive 0&n;&t;&t;is controlled by this PCI MultiMaster Host Adapter, then&n;&t;&t;reverse the probe order so that MultiMaster Host Adapters are&n;&t;&t;probed before FlashPoint Host Adapters.&n;&t;      */
r_if
c_cond
(paren
id|Drive0MapByte.DiskGeometry
op_ne
id|BusLogic_BIOS_Disk_Not_Installed
)paren
(brace
id|BusLogic_ProbeInfo_T
id|SavedProbeInfo
(braket
id|BusLogic_MaxHostAdapters
)braket
suffix:semicolon
r_int
id|MultiMasterCount
op_assign
id|BusLogic_ProbeInfoCount
op_minus
id|FlashPointCount
suffix:semicolon
id|memcpy
c_func
(paren
id|SavedProbeInfo
comma
id|BusLogic_ProbeInfoList
comma
id|BusLogic_ProbeInfoCount
op_star
r_sizeof
(paren
id|BusLogic_ProbeInfo_T
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|BusLogic_ProbeInfoList
(braket
l_int|0
)braket
comma
op_amp
id|SavedProbeInfo
(braket
id|FlashPointCount
)braket
comma
id|MultiMasterCount
op_star
r_sizeof
(paren
id|BusLogic_ProbeInfo_T
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|BusLogic_ProbeInfoList
(braket
id|MultiMasterCount
)braket
comma
op_amp
id|SavedProbeInfo
(braket
l_int|0
)braket
comma
id|FlashPointCount
op_star
r_sizeof
(paren
id|BusLogic_ProbeInfo_T
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
id|BusLogic_InitializeProbeInfoListISA
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
)brace
macro_line|#endif  /* CONFIG_PCI */
multiline_comment|/*&n;  BusLogic_Failure prints a standardized error message, and then returns false.&n;*/
DECL|function|BusLogic_Failure
r_static
id|boolean
id|BusLogic_Failure
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
comma
r_char
op_star
id|ErrorMessage
)paren
(brace
id|BusLogic_AnnounceDriver
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterBusType
op_eq
id|BusLogic_PCI_Bus
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;While configuring BusLogic PCI Host Adapter at&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;Bus %d Device %d I/O Address 0x%X PCI Address 0x%X:&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;Bus
comma
id|HostAdapter-&gt;Device
comma
id|HostAdapter-&gt;IO_Address
comma
id|HostAdapter-&gt;PCI_Address
)paren
suffix:semicolon
)brace
r_else
id|BusLogic_Error
c_func
(paren
l_string|&quot;While configuring BusLogic Host Adapter at &quot;
l_string|&quot;I/O Address 0x%X:&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IO_Address
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;%s FAILED - DETACHING&bslash;n&quot;
comma
id|HostAdapter
comma
id|ErrorMessage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_CommandFailureReason
op_ne
l_int|NULL
)paren
id|BusLogic_Error
c_func
(paren
l_string|&quot;ADDITIONAL FAILURE INFO - %s&bslash;n&quot;
comma
id|HostAdapter
comma
id|BusLogic_CommandFailureReason
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ProbeHostAdapter probes for a BusLogic Host Adapter.&n;*/
DECL|function|BusLogic_ProbeHostAdapter
r_static
id|boolean
id|BusLogic_ProbeHostAdapter
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
id|BusLogic_StatusRegister_T
id|StatusRegister
suffix:semicolon
id|BusLogic_InterruptRegister_T
id|InterruptRegister
suffix:semicolon
id|BusLogic_GeometryRegister_T
id|GeometryRegister
suffix:semicolon
multiline_comment|/*&n;    FlashPoint Host Adapters are Probed by the FlashPoint SCCB Manager.&n;  */
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
id|FlashPoint_Info_T
op_star
id|FlashPointInfo
op_assign
op_amp
id|HostAdapter-&gt;FlashPointInfo
suffix:semicolon
id|FlashPointInfo-&gt;BaseAddress
op_assign
(paren
id|BusLogic_Base_Address_T
)paren
id|HostAdapter-&gt;IO_Address
suffix:semicolon
id|FlashPointInfo-&gt;IRQ_Channel
op_assign
id|HostAdapter-&gt;IRQ_Channel
suffix:semicolon
id|FlashPointInfo-&gt;Present
op_assign
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|FlashPoint_ProbeHostAdapter
c_func
(paren
id|FlashPointInfo
)paren
op_eq
l_int|0
op_logical_and
id|FlashPointInfo-&gt;Present
)paren
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: FlashPoint Host Adapter detected at &quot;
l_string|&quot;PCI Bus %d Device %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;Bus
comma
id|HostAdapter-&gt;Device
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: I/O Address 0x%X PCI Address 0x%X, &quot;
l_string|&quot;but FlashPoint&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IO_Address
comma
id|HostAdapter-&gt;PCI_Address
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Probe Function failed to validate it.&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceProbe
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic_Probe(0x%X): FlashPoint Found&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IO_Address
)paren
suffix:semicolon
multiline_comment|/*&n;&t;Indicate the Host Adapter Probe completed successfully.&n;      */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;    Read the Status, Interrupt, and Geometry Registers to test if there are I/O&n;    ports that respond, and to check the values to determine if they are from a&n;    BusLogic Host Adapter.  A nonexistent I/O port will return 0xFF, in which&n;    case there is definitely no BusLogic Host Adapter at this base I/O Address.&n;    The test here is a subset of that used by the BusLogic Host Adapter BIOS.&n;  */
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|InterruptRegister.All
op_assign
id|BusLogic_ReadInterruptRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|GeometryRegister.All
op_assign
id|BusLogic_ReadGeometryRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceProbe
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic_Probe(0x%X): Status 0x%02X, Interrupt 0x%02X, &quot;
l_string|&quot;Geometry 0x%02X&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IO_Address
comma
id|StatusRegister.All
comma
id|InterruptRegister.All
comma
id|GeometryRegister.All
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.All
op_eq
l_int|0
op_logical_or
id|StatusRegister.Bits.DiagnosticActive
op_logical_or
id|StatusRegister.Bits.CommandParameterRegisterBusy
op_logical_or
id|StatusRegister.Bits.Reserved
op_logical_or
id|StatusRegister.Bits.CommandInvalid
op_logical_or
id|InterruptRegister.Bits.Reserved
op_ne
l_int|0
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/*&n;    Check the undocumented Geometry Register to test if there is an I/O port&n;    that responded.  Adaptec Host Adapters do not implement the Geometry&n;    Register, so this test helps serve to avoid incorrectly recognizing an&n;    Adaptec 1542A or 1542B as a BusLogic.  Unfortunately, the Adaptec 1542C&n;    series does respond to the Geometry Register I/O port, but it will be&n;    rejected later when the Inquire Extended Setup Information command is&n;    issued in BusLogic_CheckHostAdapter.  The AMI FastDisk Host Adapter is a&n;    BusLogic clone that implements the same interface as earlier BusLogic&n;    Host Adapters, including the undocumented commands, and is therefore&n;    supported by this driver.  However, the AMI FastDisk always returns 0x00&n;    upon reading the Geometry Register, so the extended translation option&n;    should always be left disabled on the AMI FastDisk.&n;  */
r_if
c_cond
(paren
id|GeometryRegister.All
op_eq
l_int|0xFF
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/*&n;    Indicate the Host Adapter Probe completed successfully.&n;  */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_HardwareResetHostAdapter issues a Hardware Reset to the Host Adapter&n;  and waits for Host Adapter Diagnostics to complete.  If HardReset is true, a&n;  Hard Reset is performed which also initiates a SCSI Bus Reset.  Otherwise, a&n;  Soft Reset is performed which only resets the Host Adapter without forcing a&n;  SCSI Bus Reset.&n;*/
DECL|function|BusLogic_HardwareResetHostAdapter
r_static
id|boolean
id|BusLogic_HardwareResetHostAdapter
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
comma
id|boolean
id|HardReset
)paren
(brace
id|BusLogic_StatusRegister_T
id|StatusRegister
suffix:semicolon
r_int
id|TimeoutCounter
suffix:semicolon
multiline_comment|/*&n;    FlashPoint Host Adapters are Hard Reset by the FlashPoint SCCB Manager.&n;  */
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
id|FlashPoint_Info_T
op_star
id|FlashPointInfo
op_assign
op_amp
id|HostAdapter-&gt;FlashPointInfo
suffix:semicolon
id|FlashPointInfo-&gt;HostSoftReset
op_assign
op_logical_neg
id|HardReset
suffix:semicolon
id|FlashPointInfo-&gt;ReportDataUnderrun
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;CardHandle
op_assign
id|FlashPoint_HardwareResetHostAdapter
c_func
(paren
id|FlashPointInfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;CardHandle
op_eq
id|FlashPoint_BadCardHandle
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/*&n;&t;Indicate the Host Adapter Hard Reset completed successfully.&n;      */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;    Issue a Hard Reset or Soft Reset Command to the Host Adapter.  The Host&n;    Adapter should respond by setting Diagnostic Active in the Status Register.&n;  */
r_if
c_cond
(paren
id|HardReset
)paren
id|BusLogic_HardReset
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_else
id|BusLogic_SoftReset
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
multiline_comment|/*&n;    Wait until Diagnostic Active is set in the Status Register.&n;  */
id|TimeoutCounter
op_assign
l_int|5
op_star
l_int|10000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.Bits.DiagnosticActive
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceHardwareReset
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic_HardwareReset(0x%X): Diagnostic Active, &quot;
l_string|&quot;Status 0x%02X&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IO_Address
comma
id|StatusRegister.All
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/*&n;    Wait 100 microseconds to allow completion of any initial diagnostic&n;    activity which might leave the contents of the Status Register&n;    unpredictable.&n;  */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/*&n;    Wait until Diagnostic Active is reset in the Status Register.&n;  */
id|TimeoutCounter
op_assign
l_int|10
op_star
l_int|10000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|StatusRegister.Bits.DiagnosticActive
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceHardwareReset
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic_HardwareReset(0x%X): Diagnostic Completed, &quot;
l_string|&quot;Status 0x%02X&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IO_Address
comma
id|StatusRegister.All
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/*&n;    Wait until at least one of the Diagnostic Failure, Host Adapter Ready,&n;    or Data In Register Ready bits is set in the Status Register.&n;  */
id|TimeoutCounter
op_assign
l_int|10000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.Bits.DiagnosticFailure
op_logical_or
id|StatusRegister.Bits.HostAdapterReady
op_logical_or
id|StatusRegister.Bits.DataInRegisterReady
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceHardwareReset
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic_HardwareReset(0x%X): Host Adapter Ready, &quot;
l_string|&quot;Status 0x%02X&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IO_Address
comma
id|StatusRegister.All
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/*&n;    If Diagnostic Failure is set or Host Adapter Ready is reset, then an&n;    error occurred during the Host Adapter diagnostics.  If Data In Register&n;    Ready is set, then there is an Error Code available.&n;  */
r_if
c_cond
(paren
id|StatusRegister.Bits.DiagnosticFailure
op_logical_or
op_logical_neg
id|StatusRegister.Bits.HostAdapterReady
)paren
(brace
id|BusLogic_CommandFailureReason
op_assign
l_int|NULL
suffix:semicolon
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;HARD RESET DIAGNOSTICS&quot;
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;HOST ADAPTER STATUS REGISTER = %02X&bslash;n&quot;
comma
id|HostAdapter
comma
id|StatusRegister.All
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.Bits.DataInRegisterReady
)paren
(brace
r_int
r_char
id|ErrorCode
op_assign
id|BusLogic_ReadDataInRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;HOST ADAPTER ERROR CODE = %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|ErrorCode
)paren
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/*&n;    Indicate the Host Adapter Hard Reset completed successfully.&n;  */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_CheckHostAdapter checks to be sure this really is a BusLogic&n;  Host Adapter.&n;*/
DECL|function|BusLogic_CheckHostAdapter
r_static
id|boolean
id|BusLogic_CheckHostAdapter
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
id|BusLogic_ExtendedSetupInformation_T
id|ExtendedSetupInformation
suffix:semicolon
id|BusLogic_RequestedReplyLength_T
id|RequestedReplyLength
suffix:semicolon
id|boolean
id|Result
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/*&n;    FlashPoint Host Adapters do not require this protection.&n;  */
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
r_return
l_bool|true
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Extended Setup Information command.  Only genuine&n;    BusLogic Host Adapters and true clones support this command.  Adaptec 1542C&n;    series Host Adapters that respond to the Geometry Register I/O port will&n;    fail this command.&n;  */
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireExtendedSetupInformation
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|ExtendedSetupInformation
comma
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
)paren
op_ne
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
)paren
id|Result
op_assign
l_bool|false
suffix:semicolon
multiline_comment|/*&n;    Provide tracing information if requested and return.&n;  */
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceProbe
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic_Check(0x%X): MultiMaster %s&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IO_Address
comma
(paren
id|Result
ques
c_cond
l_string|&quot;Found&quot;
suffix:colon
l_string|&quot;Not Found&quot;
)paren
)paren
suffix:semicolon
r_return
id|Result
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ReadHostAdapterConfiguration reads the Configuration Information&n;  from Host Adapter and initializes the Host Adapter structure.&n;*/
DECL|function|BusLogic_ReadHostAdapterConfiguration
r_static
id|boolean
id|BusLogic_ReadHostAdapterConfiguration
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
id|BusLogic_BoardID_T
id|BoardID
suffix:semicolon
id|BusLogic_Configuration_T
id|Configuration
suffix:semicolon
id|BusLogic_SetupInformation_T
id|SetupInformation
suffix:semicolon
id|BusLogic_ExtendedSetupInformation_T
id|ExtendedSetupInformation
suffix:semicolon
id|BusLogic_HostAdapterModelNumber_T
id|HostAdapterModelNumber
suffix:semicolon
id|BusLogic_FirmwareVersion3rdDigit_T
id|FirmwareVersion3rdDigit
suffix:semicolon
id|BusLogic_FirmwareVersionLetter_T
id|FirmwareVersionLetter
suffix:semicolon
id|BusLogic_PCIHostAdapterInformation_T
id|PCIHostAdapterInformation
suffix:semicolon
id|BusLogic_FetchHostAdapterLocalRAMRequest_T
id|FetchHostAdapterLocalRAMRequest
suffix:semicolon
id|BusLogic_AutoSCSIData_T
id|AutoSCSIData
suffix:semicolon
id|BusLogic_GeometryRegister_T
id|GeometryRegister
suffix:semicolon
id|BusLogic_RequestedReplyLength_T
id|RequestedReplyLength
suffix:semicolon
r_int
r_char
op_star
id|TargetPointer
comma
id|Character
suffix:semicolon
r_int
id|TargetID
comma
id|i
suffix:semicolon
multiline_comment|/*&n;    Configuration Information for FlashPoint Host Adapters is provided in the&n;    FlashPoint_Info structure by the FlashPoint SCCB Manager&squot;s Probe Function.&n;    Initialize fields in the Host Adapter structure from the FlashPoint_Info&n;    structure.&n;  */
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
id|FlashPoint_Info_T
op_star
id|FlashPointInfo
op_assign
op_amp
id|HostAdapter-&gt;FlashPointInfo
suffix:semicolon
id|TargetPointer
op_assign
id|HostAdapter-&gt;ModelName
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;B&squot;
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;T&squot;
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;-&squot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|FlashPointInfo-&gt;ModelNumber
)paren
suffix:semicolon
id|i
op_increment
)paren
op_star
id|TargetPointer
op_increment
op_assign
id|FlashPointInfo-&gt;ModelNumber
(braket
id|i
)braket
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|strcpy
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
id|FlashPoint_FirmwareVersion
)paren
suffix:semicolon
id|HostAdapter-&gt;SCSI_ID
op_assign
id|FlashPointInfo-&gt;SCSI_ID
suffix:semicolon
id|HostAdapter-&gt;ExtendedTranslationEnabled
op_assign
id|FlashPointInfo-&gt;ExtendedTranslationEnabled
suffix:semicolon
id|HostAdapter-&gt;ParityCheckingEnabled
op_assign
id|FlashPointInfo-&gt;ParityCheckingEnabled
suffix:semicolon
id|HostAdapter-&gt;BusResetEnabled
op_assign
op_logical_neg
id|FlashPointInfo-&gt;HostSoftReset
suffix:semicolon
id|HostAdapter-&gt;LevelSensitiveInterrupt
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;HostWideSCSI
op_assign
id|FlashPointInfo-&gt;HostWideSCSI
suffix:semicolon
id|HostAdapter-&gt;HostDifferentialSCSI
op_assign
l_bool|false
suffix:semicolon
id|HostAdapter-&gt;HostSupportsSCAM
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;HostUltraSCSI
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;ExtendedLUNSupport
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;TerminationInfoValid
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;LowByteTerminated
op_assign
id|FlashPointInfo-&gt;LowByteTerminated
suffix:semicolon
id|HostAdapter-&gt;HighByteTerminated
op_assign
id|FlashPointInfo-&gt;HighByteTerminated
suffix:semicolon
id|HostAdapter-&gt;SCAM_Enabled
op_assign
id|FlashPointInfo-&gt;SCAM_Enabled
suffix:semicolon
id|HostAdapter-&gt;SCAM_Level2
op_assign
id|FlashPointInfo-&gt;SCAM_Level2
suffix:semicolon
id|HostAdapter-&gt;DriverScatterGatherLimit
op_assign
id|BusLogic_ScatterGatherLimit
suffix:semicolon
id|HostAdapter-&gt;MaxTargetDevices
op_assign
(paren
id|HostAdapter-&gt;HostWideSCSI
ques
c_cond
l_int|16
suffix:colon
l_int|8
)paren
suffix:semicolon
id|HostAdapter-&gt;MaxLogicalUnits
op_assign
l_int|32
suffix:semicolon
id|HostAdapter-&gt;InitialCCBs
op_assign
l_int|4
op_star
id|BusLogic_CCB_AllocationGroupSize
suffix:semicolon
id|HostAdapter-&gt;IncrementalCCBs
op_assign
id|BusLogic_CCB_AllocationGroupSize
suffix:semicolon
id|HostAdapter-&gt;DriverQueueDepth
op_assign
l_int|255
suffix:semicolon
id|HostAdapter-&gt;HostAdapterQueueDepth
op_assign
id|HostAdapter-&gt;DriverQueueDepth
suffix:semicolon
id|HostAdapter-&gt;SynchronousPermitted
op_assign
id|FlashPointInfo-&gt;SynchronousPermitted
suffix:semicolon
id|HostAdapter-&gt;FastPermitted
op_assign
id|FlashPointInfo-&gt;FastPermitted
suffix:semicolon
id|HostAdapter-&gt;UltraPermitted
op_assign
id|FlashPointInfo-&gt;UltraPermitted
suffix:semicolon
id|HostAdapter-&gt;WidePermitted
op_assign
id|FlashPointInfo-&gt;WidePermitted
suffix:semicolon
id|HostAdapter-&gt;DisconnectPermitted
op_assign
id|FlashPointInfo-&gt;DisconnectPermitted
suffix:semicolon
id|HostAdapter-&gt;TaggedQueuingPermitted
op_assign
l_int|0xFFFF
suffix:semicolon
r_goto
id|Common
suffix:semicolon
)brace
multiline_comment|/*&n;    Issue the Inquire Board ID command.&n;  */
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireBoardID
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|BoardID
comma
r_sizeof
(paren
id|BoardID
)paren
)paren
op_ne
r_sizeof
(paren
id|BoardID
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE BOARD ID&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Configuration command.&n;  */
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireConfiguration
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|Configuration
comma
r_sizeof
(paren
id|Configuration
)paren
)paren
op_ne
r_sizeof
(paren
id|Configuration
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE CONFIGURATION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Setup Information command.&n;  */
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|SetupInformation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireSetupInformation
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|SetupInformation
comma
r_sizeof
(paren
id|SetupInformation
)paren
)paren
op_ne
r_sizeof
(paren
id|SetupInformation
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE SETUP INFORMATION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Extended Setup Information command.&n;  */
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireExtendedSetupInformation
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|ExtendedSetupInformation
comma
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
)paren
op_ne
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE EXTENDED SETUP INFORMATION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Firmware Version 3rd Digit command.&n;  */
id|FirmwareVersion3rdDigit
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|BoardID.FirmwareVersion1stDigit
OG
l_char|&squot;0&squot;
)paren
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireFirmwareVersion3rdDigit
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|FirmwareVersion3rdDigit
comma
r_sizeof
(paren
id|FirmwareVersion3rdDigit
)paren
)paren
op_ne
r_sizeof
(paren
id|FirmwareVersion3rdDigit
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE FIRMWARE 3RD DIGIT&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Host Adapter Model Number command.&n;  */
r_if
c_cond
(paren
id|ExtendedSetupInformation.BusType
op_eq
l_char|&squot;A&squot;
op_logical_and
id|BoardID.FirmwareVersion1stDigit
op_eq
l_char|&squot;2&squot;
)paren
multiline_comment|/* BusLogic BT-542B ISA 2.xx */
id|strcpy
c_func
(paren
id|HostAdapterModelNumber
comma
l_string|&quot;542B&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ExtendedSetupInformation.BusType
op_eq
l_char|&squot;E&squot;
op_logical_and
id|BoardID.FirmwareVersion1stDigit
op_eq
l_char|&squot;2&squot;
op_logical_and
(paren
id|BoardID.FirmwareVersion2ndDigit
op_le
l_char|&squot;1&squot;
op_logical_or
(paren
id|BoardID.FirmwareVersion2ndDigit
op_eq
l_char|&squot;2&squot;
op_logical_and
id|FirmwareVersion3rdDigit
op_eq
l_char|&squot;0&squot;
)paren
)paren
)paren
multiline_comment|/* BusLogic BT-742A EISA 2.1x or 2.20 */
id|strcpy
c_func
(paren
id|HostAdapterModelNumber
comma
l_string|&quot;742A&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ExtendedSetupInformation.BusType
op_eq
l_char|&squot;E&squot;
op_logical_and
id|BoardID.FirmwareVersion1stDigit
op_eq
l_char|&squot;0&squot;
)paren
multiline_comment|/* AMI FastDisk EISA Series 441 0.x */
id|strcpy
c_func
(paren
id|HostAdapterModelNumber
comma
l_string|&quot;747A&quot;
)paren
suffix:semicolon
r_else
(brace
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|HostAdapterModelNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireHostAdapterModelNumber
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|HostAdapterModelNumber
comma
r_sizeof
(paren
id|HostAdapterModelNumber
)paren
)paren
op_ne
r_sizeof
(paren
id|HostAdapterModelNumber
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE HOST ADAPTER MODEL NUMBER&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    BusLogic MultiMaster Host Adapters can be identified by their model number&n;    and the major version number of their firmware as follows:&n;&n;    5.xx&t;BusLogic &quot;W&quot; Series Host Adapters:&n;&t;&t;  BT-948/958/958D&n;    4.xx&t;BusLogic &quot;C&quot; Series Host Adapters:&n;&t;&t;  BT-946C/956C/956CD/747C/757C/757CD/445C/545C/540CF&n;    3.xx&t;BusLogic &quot;S&quot; Series Host Adapters:&n;&t;&t;  BT-747S/747D/757S/757D/445S/545S/542D&n;&t;&t;  BT-542B/742A (revision H)&n;    2.xx&t;BusLogic &quot;A&quot; Series Host Adapters:&n;&t;&t;  BT-542B/742A (revision G and below)&n;    0.xx&t;AMI FastDisk VLB/EISA BusLogic Clone Host Adapter&n;  */
multiline_comment|/*&n;    Save the Model Name and Host Adapter Name in the Host Adapter structure.&n;  */
id|TargetPointer
op_assign
id|HostAdapter-&gt;ModelName
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;B&squot;
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;T&squot;
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;-&squot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|HostAdapterModelNumber
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Character
op_assign
id|HostAdapterModelNumber
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|Character
op_eq
l_char|&squot; &squot;
op_logical_or
id|Character
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_break
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
id|Character
suffix:semicolon
)brace
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/*&n;    Save the Firmware Version in the Host Adapter structure.&n;  */
id|TargetPointer
op_assign
id|HostAdapter-&gt;FirmwareVersion
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
id|BoardID.FirmwareVersion1stDigit
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;.&squot;
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
id|BoardID.FirmwareVersion2ndDigit
suffix:semicolon
r_if
c_cond
(paren
id|FirmwareVersion3rdDigit
op_ne
l_char|&squot; &squot;
op_logical_and
id|FirmwareVersion3rdDigit
op_ne
l_char|&squot;&bslash;0&squot;
)paren
op_star
id|TargetPointer
op_increment
op_assign
id|FirmwareVersion3rdDigit
suffix:semicolon
op_star
id|TargetPointer
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Firmware Version Letter command.&n;  */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;3.3&quot;
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireFirmwareVersionLetter
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|FirmwareVersionLetter
comma
r_sizeof
(paren
id|FirmwareVersionLetter
)paren
)paren
op_ne
r_sizeof
(paren
id|FirmwareVersionLetter
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE FIRMWARE VERSION LETTER&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FirmwareVersionLetter
op_ne
l_char|&squot; &squot;
op_logical_and
id|FirmwareVersionLetter
op_ne
l_char|&squot;&bslash;0&squot;
)paren
op_star
id|TargetPointer
op_increment
op_assign
id|FirmwareVersionLetter
suffix:semicolon
op_star
id|TargetPointer
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
multiline_comment|/*&n;    Save the Host Adapter SCSI ID in the Host Adapter structure.&n;  */
id|HostAdapter-&gt;SCSI_ID
op_assign
id|Configuration.HostAdapterID
suffix:semicolon
multiline_comment|/*&n;    Determine the Bus Type and save it in the Host Adapter structure, determine&n;    and save the IRQ Channel if necessary, and determine and save the DMA&n;    Channel for ISA Host Adapters.&n;  */
id|HostAdapter-&gt;HostAdapterBusType
op_assign
id|BusLogic_HostAdapterBusTypes
(braket
id|HostAdapter-&gt;ModelName
(braket
l_int|3
)braket
op_minus
l_char|&squot;4&squot;
)braket
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;IRQ_Channel
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|Configuration.IRQ_Channel9
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|9
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.IRQ_Channel10
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.IRQ_Channel11
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|11
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.IRQ_Channel12
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|12
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.IRQ_Channel14
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|14
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.IRQ_Channel15
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|15
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterBusType
op_eq
id|BusLogic_ISA_Bus
)paren
(brace
r_if
c_cond
(paren
id|Configuration.DMA_Channel5
)paren
id|HostAdapter-&gt;DMA_Channel
op_assign
l_int|5
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.DMA_Channel6
)paren
id|HostAdapter-&gt;DMA_Channel
op_assign
l_int|6
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.DMA_Channel7
)paren
id|HostAdapter-&gt;DMA_Channel
op_assign
l_int|7
suffix:semicolon
)brace
multiline_comment|/*&n;    Determine whether Extended Translation is enabled and save it in&n;    the Host Adapter structure.&n;  */
id|GeometryRegister.All
op_assign
id|BusLogic_ReadGeometryRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|HostAdapter-&gt;ExtendedTranslationEnabled
op_assign
id|GeometryRegister.Bits.ExtendedTranslationEnabled
suffix:semicolon
multiline_comment|/*&n;    Save the Scatter Gather Limits, Level Sensitive Interrupt flag, Wide&n;    SCSI flag, Differential SCSI flag, SCAM Supported flag, and&n;    Ultra SCSI flag in the Host Adapter structure.&n;  */
id|HostAdapter-&gt;HostAdapterScatterGatherLimit
op_assign
id|ExtendedSetupInformation.ScatterGatherLimit
suffix:semicolon
id|HostAdapter-&gt;DriverScatterGatherLimit
op_assign
id|HostAdapter-&gt;HostAdapterScatterGatherLimit
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterScatterGatherLimit
OG
id|BusLogic_ScatterGatherLimit
)paren
id|HostAdapter-&gt;DriverScatterGatherLimit
op_assign
id|BusLogic_ScatterGatherLimit
suffix:semicolon
r_if
c_cond
(paren
id|ExtendedSetupInformation.Misc.LevelSensitiveInterrupt
)paren
id|HostAdapter-&gt;LevelSensitiveInterrupt
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;HostWideSCSI
op_assign
id|ExtendedSetupInformation.HostWideSCSI
suffix:semicolon
id|HostAdapter-&gt;HostDifferentialSCSI
op_assign
id|ExtendedSetupInformation.HostDifferentialSCSI
suffix:semicolon
id|HostAdapter-&gt;HostSupportsSCAM
op_assign
id|ExtendedSetupInformation.HostSupportsSCAM
suffix:semicolon
id|HostAdapter-&gt;HostUltraSCSI
op_assign
id|ExtendedSetupInformation.HostUltraSCSI
suffix:semicolon
multiline_comment|/*&n;    Determine whether Extended LUN Format CCBs are supported and save the&n;    information in the Host Adapter structure.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_eq
l_char|&squot;5&squot;
op_logical_or
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_eq
l_char|&squot;4&squot;
op_logical_and
id|HostAdapter-&gt;HostWideSCSI
)paren
)paren
id|HostAdapter-&gt;ExtendedLUNSupport
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire PCI Host Adapter Information command to read the&n;    Termination Information from &quot;W&quot; series MultiMaster Host Adapters.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_eq
l_char|&squot;5&squot;
)paren
(brace
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquirePCIHostAdapterInformation
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|PCIHostAdapterInformation
comma
r_sizeof
(paren
id|PCIHostAdapterInformation
)paren
)paren
op_ne
r_sizeof
(paren
id|PCIHostAdapterInformation
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE PCI HOST ADAPTER INFORMATION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;Save the Termination Information in the Host Adapter structure.&n;      */
r_if
c_cond
(paren
id|PCIHostAdapterInformation.GenericInfoValid
)paren
(brace
id|HostAdapter-&gt;TerminationInfoValid
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;LowByteTerminated
op_assign
id|PCIHostAdapterInformation.LowByteTerminated
suffix:semicolon
id|HostAdapter-&gt;HighByteTerminated
op_assign
id|PCIHostAdapterInformation.HighByteTerminated
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;    Issue the Fetch Host Adapter Local RAM command to read the AutoSCSI data&n;    from &quot;W&quot; and &quot;C&quot; series MultiMaster Host Adapters.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_ge
l_char|&squot;4&squot;
)paren
(brace
id|FetchHostAdapterLocalRAMRequest.ByteOffset
op_assign
id|BusLogic_AutoSCSI_BaseOffset
suffix:semicolon
id|FetchHostAdapterLocalRAMRequest.ByteCount
op_assign
r_sizeof
(paren
id|AutoSCSIData
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_FetchHostAdapterLocalRAM
comma
op_amp
id|FetchHostAdapterLocalRAMRequest
comma
r_sizeof
(paren
id|FetchHostAdapterLocalRAMRequest
)paren
comma
op_amp
id|AutoSCSIData
comma
r_sizeof
(paren
id|AutoSCSIData
)paren
)paren
op_ne
r_sizeof
(paren
id|AutoSCSIData
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;FETCH HOST ADAPTER LOCAL RAM&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;Save the Parity Checking Enabled, Bus Reset Enabled, and Termination&n;&t;Information in the Host Adapter structure.&n;      */
id|HostAdapter-&gt;ParityCheckingEnabled
op_assign
id|AutoSCSIData.ParityCheckingEnabled
suffix:semicolon
id|HostAdapter-&gt;BusResetEnabled
op_assign
id|AutoSCSIData.BusResetEnabled
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_eq
l_char|&squot;4&squot;
)paren
(brace
id|HostAdapter-&gt;TerminationInfoValid
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;LowByteTerminated
op_assign
id|AutoSCSIData.LowByteTerminated
suffix:semicolon
id|HostAdapter-&gt;HighByteTerminated
op_assign
id|AutoSCSIData.HighByteTerminated
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Save the Wide Permitted, Fast Permitted, Synchronous Permitted,&n;&t;Disconnect Permitted, Ultra Permitted, and SCAM Information in the&n;&t;Host Adapter structure.&n;      */
id|HostAdapter-&gt;WidePermitted
op_assign
id|AutoSCSIData.WidePermitted
suffix:semicolon
id|HostAdapter-&gt;FastPermitted
op_assign
id|AutoSCSIData.FastPermitted
suffix:semicolon
id|HostAdapter-&gt;SynchronousPermitted
op_assign
id|AutoSCSIData.SynchronousPermitted
suffix:semicolon
id|HostAdapter-&gt;DisconnectPermitted
op_assign
id|AutoSCSIData.DisconnectPermitted
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostUltraSCSI
)paren
id|HostAdapter-&gt;UltraPermitted
op_assign
id|AutoSCSIData.UltraPermitted
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostSupportsSCAM
)paren
(brace
id|HostAdapter-&gt;SCAM_Enabled
op_assign
id|AutoSCSIData.SCAM_Enabled
suffix:semicolon
id|HostAdapter-&gt;SCAM_Level2
op_assign
id|AutoSCSIData.SCAM_Level2
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;    Initialize fields in the Host Adapter structure for &quot;S&quot; and &quot;A&quot; series&n;    MultiMaster Host Adapters.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
OL
l_char|&squot;4&squot;
)paren
(brace
r_if
c_cond
(paren
id|SetupInformation.SynchronousInitiationEnabled
)paren
(brace
id|HostAdapter-&gt;SynchronousPermitted
op_assign
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterBusType
op_eq
id|BusLogic_EISA_Bus
)paren
(brace
r_if
c_cond
(paren
id|ExtendedSetupInformation.Misc.FastOnEISA
)paren
id|HostAdapter-&gt;FastPermitted
op_assign
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|HostAdapter-&gt;ModelName
comma
l_string|&quot;BT-757&quot;
)paren
op_eq
l_int|0
)paren
id|HostAdapter-&gt;WidePermitted
op_assign
l_int|0xFF
suffix:semicolon
)brace
)brace
id|HostAdapter-&gt;DisconnectPermitted
op_assign
l_int|0xFF
suffix:semicolon
id|HostAdapter-&gt;ParityCheckingEnabled
op_assign
id|SetupInformation.ParityCheckingEnabled
suffix:semicolon
id|HostAdapter-&gt;BusResetEnabled
op_assign
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;    Determine the maximum number of Target IDs and Logical Units supported by&n;    this driver for Wide and Narrow Host Adapters.&n;  */
id|HostAdapter-&gt;MaxTargetDevices
op_assign
(paren
id|HostAdapter-&gt;HostWideSCSI
ques
c_cond
l_int|16
suffix:colon
l_int|8
)paren
suffix:semicolon
id|HostAdapter-&gt;MaxLogicalUnits
op_assign
(paren
id|HostAdapter-&gt;ExtendedLUNSupport
ques
c_cond
l_int|32
suffix:colon
l_int|8
)paren
suffix:semicolon
multiline_comment|/*&n;    Select appropriate values for the Mailbox Count, Driver Queue Depth,&n;    Initial CCBs, and Incremental CCBs variables based on whether or not Strict&n;    Round Robin Mode is supported.  If Strict Round Robin Mode is supported,&n;    then there is no performance degradation in using the maximum possible&n;    number of Outgoing and Incoming Mailboxes and allowing the Tagged and&n;    Untagged Queue Depths to determine the actual utilization.  If Strict Round&n;    Robin Mode is not supported, then the Host Adapter must scan all the&n;    Outgoing Mailboxes whenever an Outgoing Mailbox entry is made, which can&n;    cause a substantial performance penalty.  The host adapters actually have&n;    room to store the following number of CCBs internally; that is, they can&n;    internally queue and manage this many active commands on the SCSI bus&n;    simultaneously.  Performance measurements demonstrate that the Driver Queue&n;    Depth should be set to the Mailbox Count, rather than the Host Adapter&n;    Queue Depth (internal CCB capacity), as it is more efficient to have the&n;    queued commands waiting in Outgoing Mailboxes if necessary than to block&n;    the process in the higher levels of the SCSI Subsystem.&n;&n;&t;192&t;  BT-948/958/958D&n;&t;100&t;  BT-946C/956C/956CD/747C/757C/757CD/445C&n;&t; 50&t;  BT-545C/540CF&n;&t; 30&t;  BT-747S/747D/757S/757D/445S/545S/542D/542B/742A&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_eq
l_char|&squot;5&squot;
)paren
id|HostAdapter-&gt;HostAdapterQueueDepth
op_assign
l_int|192
suffix:semicolon
r_else
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_eq
l_char|&squot;4&squot;
)paren
id|HostAdapter-&gt;HostAdapterQueueDepth
op_assign
(paren
id|HostAdapter-&gt;HostAdapterBusType
op_ne
id|BusLogic_ISA_Bus
ques
c_cond
l_int|100
suffix:colon
l_int|50
)paren
suffix:semicolon
r_else
id|HostAdapter-&gt;HostAdapterQueueDepth
op_assign
l_int|30
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;3.31&quot;
)paren
op_ge
l_int|0
)paren
(brace
id|HostAdapter-&gt;StrictRoundRobinModeSupport
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;MailboxCount
op_assign
id|BusLogic_MaxMailboxes
suffix:semicolon
)brace
r_else
(brace
id|HostAdapter-&gt;StrictRoundRobinModeSupport
op_assign
l_bool|false
suffix:semicolon
id|HostAdapter-&gt;MailboxCount
op_assign
l_int|32
suffix:semicolon
)brace
id|HostAdapter-&gt;DriverQueueDepth
op_assign
id|HostAdapter-&gt;MailboxCount
suffix:semicolon
id|HostAdapter-&gt;InitialCCBs
op_assign
l_int|4
op_star
id|BusLogic_CCB_AllocationGroupSize
suffix:semicolon
id|HostAdapter-&gt;IncrementalCCBs
op_assign
id|BusLogic_CCB_AllocationGroupSize
suffix:semicolon
multiline_comment|/*&n;    Tagged Queuing support is available and operates properly on all &quot;W&quot; series&n;    MultiMaster Host Adapters, on &quot;C&quot; series MultiMaster Host Adapters with&n;    firmware version 4.22 and above, and on &quot;S&quot; series MultiMaster Host&n;    Adapters with firmware version 3.35 and above.&n;  */
id|HostAdapter-&gt;TaggedQueuingPermitted
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;5&squot;
suffix:colon
id|HostAdapter-&gt;TaggedQueuingPermitted
op_assign
l_int|0xFFFF
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;4&squot;
suffix:colon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;4.22&quot;
)paren
op_ge
l_int|0
)paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_assign
l_int|0xFFFF
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;3&squot;
suffix:colon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;3.35&quot;
)paren
op_ge
l_int|0
)paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_assign
l_int|0xFFFF
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;    Determine the Host Adapter BIOS Address if the BIOS is enabled and&n;    save it in the Host Adapter structure.  The BIOS is disabled if the&n;    BIOS_Address is 0.&n;  */
id|HostAdapter-&gt;BIOS_Address
op_assign
id|ExtendedSetupInformation.BIOS_Address
op_lshift
l_int|12
suffix:semicolon
multiline_comment|/*&n;    ISA Host Adapters require Bounce Buffers if there is more than 16MB memory.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterBusType
op_eq
id|BusLogic_ISA_Bus
op_logical_and
(paren
r_void
op_star
)paren
id|high_memory
OG
(paren
r_void
op_star
)paren
id|MAX_DMA_ADDRESS
)paren
id|HostAdapter-&gt;BounceBuffersRequired
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/*&n;    BusLogic BT-445S Host Adapters prior to board revision E have a hardware&n;    bug whereby when the BIOS is enabled, transfers to/from the same address&n;    range the BIOS occupies modulo 16MB are handled incorrectly.  Only properly&n;    functioning BT-445S Host Adapters have firmware version 3.37, so require&n;    that ISA Bounce Buffers be used for the buggy BT-445S models if there is&n;    more than 16MB memory.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;BIOS_Address
OG
l_int|0
op_logical_and
id|strcmp
c_func
(paren
id|HostAdapter-&gt;ModelName
comma
l_string|&quot;BT-445S&quot;
)paren
op_eq
l_int|0
op_logical_and
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;3.37&quot;
)paren
template_param
(paren
r_void
op_star
)paren
id|MAX_DMA_ADDRESS
)paren
id|HostAdapter-&gt;BounceBuffersRequired
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/*&n;    Initialize parameters common to MultiMaster and FlashPoint Host Adapters.&n;  */
id|Common
suffix:colon
multiline_comment|/*&n;    Initialize the Host Adapter Full Model Name from the Model Name.&n;  */
id|strcpy
c_func
(paren
id|HostAdapter-&gt;FullModelName
comma
l_string|&quot;BusLogic &quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|HostAdapter-&gt;FullModelName
comma
id|HostAdapter-&gt;ModelName
)paren
suffix:semicolon
multiline_comment|/*&n;    Select an appropriate value for the Tagged Queue Depth either from a&n;    BusLogic Driver Options specification, or based on whether this Host&n;    Adapter requires that ISA Bounce Buffers be used.  The Tagged Queue Depth&n;    is left at 0 for automatic determination in BusLogic_SelectQueueDepths.&n;    Initialize the Untagged Queue Depth.&n;  */
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
r_int
r_char
id|QueueDepth
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;DriverOptions
op_ne
l_int|NULL
op_logical_and
id|HostAdapter-&gt;DriverOptions-&gt;QueueDepth
(braket
id|TargetID
)braket
OG
l_int|0
)paren
id|QueueDepth
op_assign
id|HostAdapter-&gt;DriverOptions-&gt;QueueDepth
(braket
id|TargetID
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|HostAdapter-&gt;BounceBuffersRequired
)paren
id|QueueDepth
op_assign
id|BusLogic_TaggedQueueDepthBB
suffix:semicolon
id|HostAdapter-&gt;QueueDepth
(braket
id|TargetID
)braket
op_assign
id|QueueDepth
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HostAdapter-&gt;BounceBuffersRequired
)paren
id|HostAdapter-&gt;UntaggedQueueDepth
op_assign
id|BusLogic_UntaggedQueueDepthBB
suffix:semicolon
r_else
id|HostAdapter-&gt;UntaggedQueueDepth
op_assign
id|BusLogic_UntaggedQueueDepth
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;DriverOptions
op_ne
l_int|NULL
)paren
id|HostAdapter-&gt;CommonQueueDepth
op_assign
id|HostAdapter-&gt;DriverOptions-&gt;CommonQueueDepth
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;CommonQueueDepth
OG
l_int|0
op_logical_and
id|HostAdapter-&gt;CommonQueueDepth
OL
id|HostAdapter-&gt;UntaggedQueueDepth
)paren
id|HostAdapter-&gt;UntaggedQueueDepth
op_assign
id|HostAdapter-&gt;CommonQueueDepth
suffix:semicolon
multiline_comment|/*&n;    Tagged Queuing is only allowed if Disconnect/Reconnect is permitted.&n;    Therefore, mask the Tagged Queuing Permitted Default bits with the&n;    Disconnect/Reconnect Permitted bits.&n;  */
id|HostAdapter-&gt;TaggedQueuingPermitted
op_and_assign
id|HostAdapter-&gt;DisconnectPermitted
suffix:semicolon
multiline_comment|/*&n;    Combine the default Tagged Queuing Permitted bits with any BusLogic Driver&n;    Options Tagged Queuing specification.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;DriverOptions
op_ne
l_int|NULL
)paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_assign
(paren
id|HostAdapter-&gt;DriverOptions-&gt;TaggedQueuingPermitted
op_amp
id|HostAdapter-&gt;DriverOptions-&gt;TaggedQueuingPermittedMask
)paren
op_or
(paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_amp
op_complement
id|HostAdapter-&gt;DriverOptions-&gt;TaggedQueuingPermittedMask
)paren
suffix:semicolon
multiline_comment|/*&n;    Select appropriate values for the Error Recovery Strategy array&n;    either from a BusLogic Driver Options specification, or using&n;    BusLogic_ErrorRecovery_Default.&n;  */
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
r_if
c_cond
(paren
id|HostAdapter-&gt;DriverOptions
op_ne
l_int|NULL
)paren
id|HostAdapter-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
op_assign
id|HostAdapter-&gt;DriverOptions-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
suffix:semicolon
r_else
id|HostAdapter-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
op_assign
id|BusLogic_ErrorRecovery_Default
suffix:semicolon
multiline_comment|/*&n;    Select an appropriate value for Bus Settle Time either from a BusLogic&n;    Driver Options specification, or from BusLogic_DefaultBusSettleTime.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;DriverOptions
op_ne
l_int|NULL
op_logical_and
id|HostAdapter-&gt;DriverOptions-&gt;BusSettleTime
OG
l_int|0
)paren
id|HostAdapter-&gt;BusSettleTime
op_assign
id|HostAdapter-&gt;DriverOptions-&gt;BusSettleTime
suffix:semicolon
r_else
id|HostAdapter-&gt;BusSettleTime
op_assign
id|BusLogic_DefaultBusSettleTime
suffix:semicolon
multiline_comment|/*&n;    Indicate reading the Host Adapter Configuration completed successfully.&n;  */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ReportHostAdapterConfiguration reports the configuration of&n;  Host Adapter.&n;*/
DECL|function|BusLogic_ReportHostAdapterConfiguration
r_static
id|boolean
id|BusLogic_ReportHostAdapterConfiguration
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
r_int
r_int
id|AllTargetsMask
op_assign
(paren
l_int|1
op_lshift
id|HostAdapter-&gt;MaxTargetDevices
)paren
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|SynchronousPermitted
comma
id|FastPermitted
suffix:semicolon
r_int
r_int
id|UltraPermitted
comma
id|WidePermitted
suffix:semicolon
r_int
r_int
id|DisconnectPermitted
comma
id|TaggedQueuingPermitted
suffix:semicolon
id|boolean
id|CommonSynchronousNegotiation
comma
id|CommonTaggedQueueDepth
suffix:semicolon
id|boolean
id|CommonErrorRecovery
suffix:semicolon
r_char
id|SynchronousString
(braket
id|BusLogic_MaxTargetDevices
op_plus
l_int|1
)braket
suffix:semicolon
r_char
id|WideString
(braket
id|BusLogic_MaxTargetDevices
op_plus
l_int|1
)braket
suffix:semicolon
r_char
id|DisconnectString
(braket
id|BusLogic_MaxTargetDevices
op_plus
l_int|1
)braket
suffix:semicolon
r_char
id|TaggedQueuingString
(braket
id|BusLogic_MaxTargetDevices
op_plus
l_int|1
)braket
suffix:semicolon
r_char
id|ErrorRecoveryString
(braket
id|BusLogic_MaxTargetDevices
op_plus
l_int|1
)braket
suffix:semicolon
r_char
op_star
id|SynchronousMessage
op_assign
id|SynchronousString
suffix:semicolon
r_char
op_star
id|WideMessage
op_assign
id|WideString
suffix:semicolon
r_char
op_star
id|DisconnectMessage
op_assign
id|DisconnectString
suffix:semicolon
r_char
op_star
id|TaggedQueuingMessage
op_assign
id|TaggedQueuingString
suffix:semicolon
r_char
op_star
id|ErrorRecoveryMessage
op_assign
id|ErrorRecoveryString
suffix:semicolon
r_int
id|TargetID
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;Configuring BusLogic Model %s %s%s%s%s SCSI Host Adapter&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;ModelName
comma
id|BusLogic_HostAdapterBusNames
(braket
id|HostAdapter-&gt;HostAdapterBusType
)braket
comma
(paren
id|HostAdapter-&gt;HostWideSCSI
ques
c_cond
l_string|&quot; Wide&quot;
suffix:colon
l_string|&quot;&quot;
)paren
comma
(paren
id|HostAdapter-&gt;HostDifferentialSCSI
ques
c_cond
l_string|&quot; Differential&quot;
suffix:colon
l_string|&quot;&quot;
)paren
comma
(paren
id|HostAdapter-&gt;HostUltraSCSI
ques
c_cond
l_string|&quot; Ultra&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;  Firmware Version: %s, I/O Address: 0x%X, &quot;
l_string|&quot;IRQ Channel: %d/%s&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;FirmwareVersion
comma
id|HostAdapter-&gt;IO_Address
comma
id|HostAdapter-&gt;IRQ_Channel
comma
(paren
id|HostAdapter-&gt;LevelSensitiveInterrupt
ques
c_cond
l_string|&quot;Level&quot;
suffix:colon
l_string|&quot;Edge&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterBusType
op_ne
id|BusLogic_PCI_Bus
)paren
(brace
id|BusLogic_Info
c_func
(paren
l_string|&quot;  DMA Channel: &quot;
comma
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;DMA_Channel
OG
l_int|0
)paren
id|BusLogic_Info
c_func
(paren
l_string|&quot;%d, &quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;DMA_Channel
)paren
suffix:semicolon
r_else
id|BusLogic_Info
c_func
(paren
l_string|&quot;None, &quot;
comma
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;BIOS_Address
OG
l_int|0
)paren
id|BusLogic_Info
c_func
(paren
l_string|&quot;BIOS Address: 0x%X, &quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;BIOS_Address
)paren
suffix:semicolon
r_else
id|BusLogic_Info
c_func
(paren
l_string|&quot;BIOS Address: None, &quot;
comma
id|HostAdapter
)paren
suffix:semicolon
)brace
r_else
(brace
id|BusLogic_Info
c_func
(paren
l_string|&quot;  PCI Bus: %d, Device: %d, Address: &quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;Bus
comma
id|HostAdapter-&gt;Device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;PCI_Address
OG
l_int|0
)paren
id|BusLogic_Info
c_func
(paren
l_string|&quot;0x%X, &quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;PCI_Address
)paren
suffix:semicolon
r_else
id|BusLogic_Info
c_func
(paren
l_string|&quot;Unassigned, &quot;
comma
id|HostAdapter
)paren
suffix:semicolon
)brace
id|BusLogic_Info
c_func
(paren
l_string|&quot;Host Adapter SCSI ID: %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;SCSI_ID
)paren
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;  Parity Checking: %s, Extended Translation: %s&bslash;n&quot;
comma
id|HostAdapter
comma
(paren
id|HostAdapter-&gt;ParityCheckingEnabled
ques
c_cond
l_string|&quot;Enabled&quot;
suffix:colon
l_string|&quot;Disabled&quot;
)paren
comma
(paren
id|HostAdapter-&gt;ExtendedTranslationEnabled
ques
c_cond
l_string|&quot;Enabled&quot;
suffix:colon
l_string|&quot;Disabled&quot;
)paren
)paren
suffix:semicolon
id|AllTargetsMask
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|HostAdapter-&gt;SCSI_ID
)paren
suffix:semicolon
id|SynchronousPermitted
op_assign
id|HostAdapter-&gt;SynchronousPermitted
op_amp
id|AllTargetsMask
suffix:semicolon
id|FastPermitted
op_assign
id|HostAdapter-&gt;FastPermitted
op_amp
id|AllTargetsMask
suffix:semicolon
id|UltraPermitted
op_assign
id|HostAdapter-&gt;UltraPermitted
op_amp
id|AllTargetsMask
suffix:semicolon
r_if
c_cond
(paren
(paren
id|BusLogic_MultiMasterHostAdapterP
c_func
(paren
id|HostAdapter
)paren
op_logical_and
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_ge
l_char|&squot;4&squot;
op_logical_or
id|HostAdapter-&gt;HostAdapterBusType
op_eq
id|BusLogic_EISA_Bus
)paren
)paren
op_logical_or
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
id|CommonSynchronousNegotiation
op_assign
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|SynchronousPermitted
op_eq
l_int|0
)paren
(brace
id|SynchronousMessage
op_assign
l_string|&quot;Disabled&quot;
suffix:semicolon
id|CommonSynchronousNegotiation
op_assign
l_bool|true
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SynchronousPermitted
op_eq
id|AllTargetsMask
)paren
(brace
r_if
c_cond
(paren
id|FastPermitted
op_eq
l_int|0
)paren
(brace
id|SynchronousMessage
op_assign
l_string|&quot;Slow&quot;
suffix:semicolon
id|CommonSynchronousNegotiation
op_assign
l_bool|true
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FastPermitted
op_eq
id|AllTargetsMask
)paren
(brace
r_if
c_cond
(paren
id|UltraPermitted
op_eq
l_int|0
)paren
(brace
id|SynchronousMessage
op_assign
l_string|&quot;Fast&quot;
suffix:semicolon
id|CommonSynchronousNegotiation
op_assign
l_bool|true
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|UltraPermitted
op_eq
id|AllTargetsMask
)paren
(brace
id|SynchronousMessage
op_assign
l_string|&quot;Ultra&quot;
suffix:semicolon
id|CommonSynchronousNegotiation
op_assign
l_bool|true
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|CommonSynchronousNegotiation
)paren
(brace
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|SynchronousString
(braket
id|TargetID
)braket
op_assign
(paren
(paren
op_logical_neg
(paren
id|SynchronousPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
)paren
ques
c_cond
l_char|&squot;N&squot;
suffix:colon
(paren
op_logical_neg
(paren
id|FastPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
ques
c_cond
l_char|&squot;S&squot;
suffix:colon
(paren
op_logical_neg
(paren
id|UltraPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
ques
c_cond
l_char|&squot;F&squot;
suffix:colon
l_char|&squot;U&squot;
)paren
)paren
)paren
suffix:semicolon
id|SynchronousString
(braket
id|HostAdapter-&gt;SCSI_ID
)braket
op_assign
l_char|&squot;#&squot;
suffix:semicolon
id|SynchronousString
(braket
id|HostAdapter-&gt;MaxTargetDevices
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
r_else
id|SynchronousMessage
op_assign
(paren
id|SynchronousPermitted
op_eq
l_int|0
ques
c_cond
l_string|&quot;Disabled&quot;
suffix:colon
l_string|&quot;Enabled&quot;
)paren
suffix:semicolon
id|WidePermitted
op_assign
id|HostAdapter-&gt;WidePermitted
op_amp
id|AllTargetsMask
suffix:semicolon
r_if
c_cond
(paren
id|WidePermitted
op_eq
l_int|0
)paren
id|WideMessage
op_assign
l_string|&quot;Disabled&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|WidePermitted
op_eq
id|AllTargetsMask
)paren
id|WideMessage
op_assign
l_string|&quot;Enabled&quot;
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|WideString
(braket
id|TargetID
)braket
op_assign
(paren
(paren
id|WidePermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
ques
c_cond
l_char|&squot;Y&squot;
suffix:colon
l_char|&squot;N&squot;
)paren
suffix:semicolon
id|WideString
(braket
id|HostAdapter-&gt;SCSI_ID
)braket
op_assign
l_char|&squot;#&squot;
suffix:semicolon
id|WideString
(braket
id|HostAdapter-&gt;MaxTargetDevices
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
id|DisconnectPermitted
op_assign
id|HostAdapter-&gt;DisconnectPermitted
op_amp
id|AllTargetsMask
suffix:semicolon
r_if
c_cond
(paren
id|DisconnectPermitted
op_eq
l_int|0
)paren
id|DisconnectMessage
op_assign
l_string|&quot;Disabled&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|DisconnectPermitted
op_eq
id|AllTargetsMask
)paren
id|DisconnectMessage
op_assign
l_string|&quot;Enabled&quot;
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|DisconnectString
(braket
id|TargetID
)braket
op_assign
(paren
(paren
id|DisconnectPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
ques
c_cond
l_char|&squot;Y&squot;
suffix:colon
l_char|&squot;N&squot;
)paren
suffix:semicolon
id|DisconnectString
(braket
id|HostAdapter-&gt;SCSI_ID
)braket
op_assign
l_char|&squot;#&squot;
suffix:semicolon
id|DisconnectString
(braket
id|HostAdapter-&gt;MaxTargetDevices
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
id|TaggedQueuingPermitted
op_assign
id|HostAdapter-&gt;TaggedQueuingPermitted
op_amp
id|AllTargetsMask
suffix:semicolon
r_if
c_cond
(paren
id|TaggedQueuingPermitted
op_eq
l_int|0
)paren
id|TaggedQueuingMessage
op_assign
l_string|&quot;Disabled&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|TaggedQueuingPermitted
op_eq
id|AllTargetsMask
)paren
id|TaggedQueuingMessage
op_assign
l_string|&quot;Enabled&quot;
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|TaggedQueuingString
(braket
id|TargetID
)braket
op_assign
(paren
(paren
id|TaggedQueuingPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
ques
c_cond
l_char|&squot;Y&squot;
suffix:colon
l_char|&squot;N&squot;
)paren
suffix:semicolon
id|TaggedQueuingString
(braket
id|HostAdapter-&gt;SCSI_ID
)braket
op_assign
l_char|&squot;#&squot;
suffix:semicolon
id|TaggedQueuingString
(braket
id|HostAdapter-&gt;MaxTargetDevices
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
id|BusLogic_Info
c_func
(paren
l_string|&quot;  Synchronous Negotiation: %s, Wide Negotiation: %s&bslash;n&quot;
comma
id|HostAdapter
comma
id|SynchronousMessage
comma
id|WideMessage
)paren
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;  Disconnect/Reconnect: %s, Tagged Queuing: %s&bslash;n&quot;
comma
id|HostAdapter
comma
id|DisconnectMessage
comma
id|TaggedQueuingMessage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_MultiMasterHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
id|BusLogic_Info
c_func
(paren
l_string|&quot;  Scatter/Gather Limit: %d of %d segments, &quot;
l_string|&quot;Mailboxes: %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;DriverScatterGatherLimit
comma
id|HostAdapter-&gt;HostAdapterScatterGatherLimit
comma
id|HostAdapter-&gt;MailboxCount
)paren
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;  Driver Queue Depth: %d, &quot;
l_string|&quot;Host Adapter Queue Depth: %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;DriverQueueDepth
comma
id|HostAdapter-&gt;HostAdapterQueueDepth
)paren
suffix:semicolon
)brace
r_else
id|BusLogic_Info
c_func
(paren
l_string|&quot;  Driver Queue Depth: %d, &quot;
l_string|&quot;Scatter/Gather Limit: %d segments&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;DriverQueueDepth
comma
id|HostAdapter-&gt;DriverScatterGatherLimit
)paren
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;  Tagged Queue Depth: &quot;
comma
id|HostAdapter
)paren
suffix:semicolon
id|CommonTaggedQueueDepth
op_assign
l_bool|true
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|1
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
r_if
c_cond
(paren
id|HostAdapter-&gt;QueueDepth
(braket
id|TargetID
)braket
op_ne
id|HostAdapter-&gt;QueueDepth
(braket
l_int|0
)braket
)paren
(brace
id|CommonTaggedQueueDepth
op_assign
l_bool|false
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CommonTaggedQueueDepth
)paren
(brace
r_if
c_cond
(paren
id|HostAdapter-&gt;QueueDepth
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|BusLogic_Info
c_func
(paren
l_string|&quot;%d&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;QueueDepth
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_else
id|BusLogic_Info
c_func
(paren
l_string|&quot;Automatic&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
)brace
r_else
id|BusLogic_Info
c_func
(paren
l_string|&quot;Individual&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;, Untagged Queue Depth: %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;UntaggedQueueDepth
)paren
suffix:semicolon
id|CommonErrorRecovery
op_assign
l_bool|true
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|1
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
r_if
c_cond
(paren
id|HostAdapter-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
op_ne
id|HostAdapter-&gt;ErrorRecoveryStrategy
(braket
l_int|0
)braket
)paren
(brace
id|CommonErrorRecovery
op_assign
l_bool|false
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CommonErrorRecovery
)paren
id|ErrorRecoveryMessage
op_assign
id|BusLogic_ErrorRecoveryStrategyNames
(braket
id|HostAdapter-&gt;ErrorRecoveryStrategy
(braket
l_int|0
)braket
)braket
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|ErrorRecoveryString
(braket
id|TargetID
)braket
op_assign
id|BusLogic_ErrorRecoveryStrategyLetters
(braket
id|HostAdapter-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
)braket
suffix:semicolon
id|ErrorRecoveryString
(braket
id|HostAdapter-&gt;SCSI_ID
)braket
op_assign
l_char|&squot;#&squot;
suffix:semicolon
id|ErrorRecoveryString
(braket
id|HostAdapter-&gt;MaxTargetDevices
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
id|BusLogic_Info
c_func
(paren
l_string|&quot;  Error Recovery Strategy: %s, SCSI Bus Reset: %s&bslash;n&quot;
comma
id|HostAdapter
comma
id|ErrorRecoveryMessage
comma
(paren
id|HostAdapter-&gt;BusResetEnabled
ques
c_cond
l_string|&quot;Enabled&quot;
suffix:colon
l_string|&quot;Disabled&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;TerminationInfoValid
)paren
(brace
r_if
c_cond
(paren
id|HostAdapter-&gt;HostWideSCSI
)paren
id|BusLogic_Info
c_func
(paren
l_string|&quot;  SCSI Bus Termination: %s&quot;
comma
id|HostAdapter
comma
(paren
id|HostAdapter-&gt;LowByteTerminated
ques
c_cond
(paren
id|HostAdapter-&gt;HighByteTerminated
ques
c_cond
l_string|&quot;Both Enabled&quot;
suffix:colon
l_string|&quot;Low Enabled&quot;
)paren
suffix:colon
(paren
id|HostAdapter-&gt;HighByteTerminated
ques
c_cond
l_string|&quot;High Enabled&quot;
suffix:colon
l_string|&quot;Both Disabled&quot;
)paren
)paren
)paren
suffix:semicolon
r_else
id|BusLogic_Info
c_func
(paren
l_string|&quot;  SCSI Bus Termination: %s&quot;
comma
id|HostAdapter
comma
(paren
id|HostAdapter-&gt;LowByteTerminated
ques
c_cond
l_string|&quot;Enabled&quot;
suffix:colon
l_string|&quot;Disabled&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostSupportsSCAM
)paren
id|BusLogic_Info
c_func
(paren
l_string|&quot;, SCAM: %s&quot;
comma
id|HostAdapter
comma
(paren
id|HostAdapter-&gt;SCAM_Enabled
ques
c_cond
(paren
id|HostAdapter-&gt;SCAM_Level2
ques
c_cond
l_string|&quot;Enabled, Level 2&quot;
suffix:colon
l_string|&quot;Enabled, Level 1&quot;
)paren
suffix:colon
l_string|&quot;Disabled&quot;
)paren
)paren
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    Indicate reporting the Host Adapter configuration completed successfully.&n;  */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_AcquireResources acquires the system resources necessary to use&n;  Host Adapter.&n;*/
DECL|function|BusLogic_AcquireResources
r_static
id|boolean
id|BusLogic_AcquireResources
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
r_if
c_cond
(paren
id|HostAdapter-&gt;IRQ_Channel
op_eq
l_int|0
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;NO LEGAL INTERRUPT CHANNEL ASSIGNED - DETACHING&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/*&n;    Acquire shared access to the IRQ Channel.&n;  */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|HostAdapter-&gt;IRQ_Channel
comma
id|BusLogic_InterruptHandler
comma
id|SA_SHIRQ
comma
id|HostAdapter-&gt;FullModelName
comma
id|HostAdapter
)paren
OL
l_int|0
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;UNABLE TO ACQUIRE IRQ CHANNEL %d - DETACHING&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IRQ_Channel
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
id|HostAdapter-&gt;IRQ_ChannelAcquired
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/*&n;    Acquire exclusive access to the DMA Channel.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;DMA_Channel
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|HostAdapter-&gt;DMA_Channel
comma
id|HostAdapter-&gt;FullModelName
)paren
OL
l_int|0
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;UNABLE TO ACQUIRE DMA CHANNEL %d - DETACHING&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;DMA_Channel
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
id|set_dma_mode
c_func
(paren
id|HostAdapter-&gt;DMA_Channel
comma
id|DMA_MODE_CASCADE
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|HostAdapter-&gt;DMA_Channel
)paren
suffix:semicolon
id|HostAdapter-&gt;DMA_ChannelAcquired
op_assign
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;    Indicate the System Resource Acquisition completed successfully,&n;  */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ReleaseResources releases any system resources previously acquired&n;  by BusLogic_AcquireResources.&n;*/
DECL|function|BusLogic_ReleaseResources
r_static
r_void
id|BusLogic_ReleaseResources
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
multiline_comment|/*&n;    Release shared access to the IRQ Channel.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;IRQ_ChannelAcquired
)paren
id|free_irq
c_func
(paren
id|HostAdapter-&gt;IRQ_Channel
comma
id|HostAdapter
)paren
suffix:semicolon
multiline_comment|/*&n;    Release exclusive access to the DMA Channel.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;DMA_ChannelAcquired
)paren
id|free_dma
c_func
(paren
id|HostAdapter-&gt;DMA_Channel
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InitializeHostAdapter initializes Host Adapter.  This is the only&n;  function called during SCSI Host Adapter detection which modifies the state&n;  of the Host Adapter from its initial power on or hard reset state.&n;*/
DECL|function|BusLogic_InitializeHostAdapter
r_static
id|boolean
id|BusLogic_InitializeHostAdapter
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
id|BusLogic_ExtendedMailboxRequest_T
id|ExtendedMailboxRequest
suffix:semicolon
id|BusLogic_RoundRobinModeRequest_T
id|RoundRobinModeRequest
suffix:semicolon
id|BusLogic_SetCCBFormatRequest_T
id|SetCCBFormatRequest
suffix:semicolon
r_int
id|TargetID
suffix:semicolon
multiline_comment|/*&n;    Initialize the pointers to the first and last CCBs that are queued for&n;    completion processing.&n;  */
id|HostAdapter-&gt;FirstCompletedCCB
op_assign
l_int|NULL
suffix:semicolon
id|HostAdapter-&gt;LastCompletedCCB
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;    Initialize the Bus Device Reset Pending CCB, Tagged Queuing Active,&n;    Command Successful Flag, Active Commands, and Commands Since Reset&n;    for each Target Device.&n;  */
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
id|HostAdapter-&gt;BusDeviceResetPendingCCB
(braket
id|TargetID
)braket
op_assign
l_int|NULL
suffix:semicolon
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TaggedQueuingActive
op_assign
l_bool|false
suffix:semicolon
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|CommandSuccessfulFlag
op_assign
l_bool|false
suffix:semicolon
id|HostAdapter-&gt;ActiveCommands
(braket
id|TargetID
)braket
op_assign
l_int|0
suffix:semicolon
id|HostAdapter-&gt;CommandsSinceReset
(braket
id|TargetID
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;    FlashPoint Host Adapters do not use Outgoing and Incoming Mailboxes.&n;  */
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
r_goto
id|Done
suffix:semicolon
multiline_comment|/*&n;    Initialize the Outgoing and Incoming Mailbox pointers.&n;  */
id|HostAdapter-&gt;FirstOutgoingMailbox
op_assign
(paren
id|BusLogic_OutgoingMailbox_T
op_star
)paren
id|HostAdapter-&gt;MailboxSpace
suffix:semicolon
id|HostAdapter-&gt;LastOutgoingMailbox
op_assign
id|HostAdapter-&gt;FirstOutgoingMailbox
op_plus
id|HostAdapter-&gt;MailboxCount
op_minus
l_int|1
suffix:semicolon
id|HostAdapter-&gt;NextOutgoingMailbox
op_assign
id|HostAdapter-&gt;FirstOutgoingMailbox
suffix:semicolon
id|HostAdapter-&gt;FirstIncomingMailbox
op_assign
(paren
id|BusLogic_IncomingMailbox_T
op_star
)paren
(paren
id|HostAdapter-&gt;LastOutgoingMailbox
op_plus
l_int|1
)paren
suffix:semicolon
id|HostAdapter-&gt;LastIncomingMailbox
op_assign
id|HostAdapter-&gt;FirstIncomingMailbox
op_plus
id|HostAdapter-&gt;MailboxCount
op_minus
l_int|1
suffix:semicolon
id|HostAdapter-&gt;NextIncomingMailbox
op_assign
id|HostAdapter-&gt;FirstIncomingMailbox
suffix:semicolon
multiline_comment|/*&n;    Initialize the Outgoing and Incoming Mailbox structures.&n;  */
id|memset
c_func
(paren
id|HostAdapter-&gt;FirstOutgoingMailbox
comma
l_int|0
comma
id|HostAdapter-&gt;MailboxCount
op_star
r_sizeof
(paren
id|BusLogic_OutgoingMailbox_T
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|HostAdapter-&gt;FirstIncomingMailbox
comma
l_int|0
comma
id|HostAdapter-&gt;MailboxCount
op_star
r_sizeof
(paren
id|BusLogic_IncomingMailbox_T
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;    Initialize the Host Adapter&squot;s Pointer to the Outgoing/Incoming Mailboxes.&n;  */
id|ExtendedMailboxRequest.MailboxCount
op_assign
id|HostAdapter-&gt;MailboxCount
suffix:semicolon
id|ExtendedMailboxRequest.BaseMailboxAddress
op_assign
id|Virtual_to_Bus
c_func
(paren
id|HostAdapter-&gt;FirstOutgoingMailbox
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InitializeExtendedMailbox
comma
op_amp
id|ExtendedMailboxRequest
comma
r_sizeof
(paren
id|ExtendedMailboxRequest
)paren
comma
l_int|NULL
comma
l_int|0
)paren
OL
l_int|0
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;MAILBOX INITIALIZATION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;    Enable Strict Round Robin Mode if supported by the Host Adapter.  In&n;    Strict Round Robin Mode, the Host Adapter only looks at the next Outgoing&n;    Mailbox for each new command, rather than scanning through all the&n;    Outgoing Mailboxes to find any that have new commands in them.  Strict&n;    Round Robin Mode is significantly more efficient.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;StrictRoundRobinModeSupport
)paren
(brace
id|RoundRobinModeRequest
op_assign
id|BusLogic_StrictRoundRobinMode
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_EnableStrictRoundRobinMode
comma
op_amp
id|RoundRobinModeRequest
comma
r_sizeof
(paren
id|RoundRobinModeRequest
)paren
comma
l_int|NULL
comma
l_int|0
)paren
OL
l_int|0
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;ENABLE STRICT ROUND ROBIN MODE&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    For Host Adapters that support Extended LUN Format CCBs, issue the Set CCB&n;    Format command to allow 32 Logical Units per Target Device.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;ExtendedLUNSupport
)paren
(brace
id|SetCCBFormatRequest
op_assign
id|BusLogic_ExtendedLUNFormatCCB
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_SetCCBFormat
comma
op_amp
id|SetCCBFormatRequest
comma
r_sizeof
(paren
id|SetCCBFormatRequest
)paren
comma
l_int|NULL
comma
l_int|0
)paren
OL
l_int|0
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;SET CCB FORMAT&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    Announce Successful Initialization.&n;  */
id|Done
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|HostAdapter-&gt;HostAdapterInitialized
)paren
(brace
id|BusLogic_Info
c_func
(paren
l_string|&quot;*** %s Initialized Successfully ***&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;FullModelName
)paren
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
)brace
r_else
id|BusLogic_Warning
c_func
(paren
l_string|&quot;*** %s Initialized Successfully ***&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;FullModelName
)paren
suffix:semicolon
id|HostAdapter-&gt;HostAdapterInitialized
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/*&n;    Indicate the Host Adapter Initialization completed successfully.&n;  */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_TargetDeviceInquiry inquires about the Target Devices accessible&n;  through Host Adapter.&n;*/
DECL|function|BusLogic_TargetDeviceInquiry
r_static
id|boolean
id|BusLogic_TargetDeviceInquiry
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
id|BusLogic_InstalledDevices_T
id|InstalledDevices
suffix:semicolon
id|BusLogic_InstalledDevices8_T
id|InstalledDevicesID0to7
suffix:semicolon
id|BusLogic_SetupInformation_T
id|SetupInformation
suffix:semicolon
id|BusLogic_SynchronousPeriod_T
id|SynchronousPeriod
suffix:semicolon
id|BusLogic_RequestedReplyLength_T
id|RequestedReplyLength
suffix:semicolon
r_int
id|TargetID
suffix:semicolon
multiline_comment|/*&n;    Wait a few seconds between the Host Adapter Hard Reset which initiates&n;    a SCSI Bus Reset and issuing any SCSI Commands.  Some SCSI devices get&n;    confused if they receive SCSI Commands too soon after a SCSI Bus Reset.&n;  */
id|BusLogic_Delay
c_func
(paren
id|HostAdapter-&gt;BusSettleTime
)paren
suffix:semicolon
multiline_comment|/*&n;    FlashPoint Host Adapters do not provide for Target Device Inquiry.&n;  */
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
r_return
l_bool|true
suffix:semicolon
multiline_comment|/*&n;    Inhibit the Target Device Inquiry if requested.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;DriverOptions
op_ne
l_int|NULL
op_logical_and
id|HostAdapter-&gt;DriverOptions-&gt;LocalOptions.InhibitTargetInquiry
)paren
r_return
l_bool|true
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Target Devices command for host adapters with firmware&n;    version 4.25 or later, or the Inquire Installed Devices ID 0 to 7 command&n;    for older host adapters.  This is necessary to force Synchronous Transfer&n;    Negotiation so that the Inquire Setup Information and Inquire Synchronous&n;    Period commands will return valid data.  The Inquire Target Devices command&n;    is preferable to Inquire Installed Devices ID 0 to 7 since it only probes&n;    Logical Unit 0 of each Target Device.&n;  */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;4.25&quot;
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireTargetDevices
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|InstalledDevices
comma
r_sizeof
(paren
id|InstalledDevices
)paren
)paren
op_ne
r_sizeof
(paren
id|InstalledDevices
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE TARGET DEVICES&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TargetExists
op_assign
(paren
id|InstalledDevices
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
ques
c_cond
l_bool|true
suffix:colon
l_bool|false
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireInstalledDevicesID0to7
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|InstalledDevicesID0to7
comma
r_sizeof
(paren
id|InstalledDevicesID0to7
)paren
)paren
op_ne
r_sizeof
(paren
id|InstalledDevicesID0to7
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE INSTALLED DEVICES ID 0 TO 7&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
l_int|8
suffix:semicolon
id|TargetID
op_increment
)paren
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TargetExists
op_assign
(paren
id|InstalledDevicesID0to7
(braket
id|TargetID
)braket
op_ne
l_int|0
ques
c_cond
l_bool|true
suffix:colon
l_bool|false
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    Issue the Inquire Setup Information command.&n;  */
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|SetupInformation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireSetupInformation
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|SetupInformation
comma
r_sizeof
(paren
id|SetupInformation
)paren
)paren
op_ne
r_sizeof
(paren
id|SetupInformation
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE SETUP INFORMATION&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|HostAdapter-&gt;SynchronousOffset
(braket
id|TargetID
)braket
op_assign
(paren
id|TargetID
OL
l_int|8
ques
c_cond
id|SetupInformation.SynchronousValuesID0to7
(braket
id|TargetID
)braket
dot
id|Offset
suffix:colon
id|SetupInformation.SynchronousValuesID8to15
(braket
id|TargetID
op_minus
l_int|8
)braket
dot
id|Offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;5.06L&quot;
)paren
op_ge
l_int|0
)paren
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|WideTransfersActive
op_assign
(paren
id|TargetID
OL
l_int|8
ques
c_cond
(paren
id|SetupInformation.WideTransfersActiveID0to7
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
ques
c_cond
l_bool|true
suffix:colon
l_bool|false
)paren
suffix:colon
(paren
id|SetupInformation.WideTransfersActiveID8to15
op_amp
(paren
l_int|1
op_lshift
(paren
id|TargetID
op_minus
l_int|8
)paren
)paren
ques
c_cond
l_bool|true
suffix:colon
l_bool|false
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;    Issue the Inquire Synchronous Period command.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_ge
l_char|&squot;3&squot;
)paren
(brace
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|SynchronousPeriod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireSynchronousPeriod
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|SynchronousPeriod
comma
r_sizeof
(paren
id|SynchronousPeriod
)paren
)paren
op_ne
r_sizeof
(paren
id|SynchronousPeriod
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE SYNCHRONOUS PERIOD&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|HostAdapter-&gt;SynchronousPeriod
(braket
id|TargetID
)braket
op_assign
id|SynchronousPeriod
(braket
id|TargetID
)braket
suffix:semicolon
)brace
r_else
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
r_if
c_cond
(paren
id|SetupInformation.SynchronousValuesID0to7
(braket
id|TargetID
)braket
dot
id|Offset
OG
l_int|0
)paren
id|HostAdapter-&gt;SynchronousPeriod
(braket
id|TargetID
)braket
op_assign
l_int|20
op_plus
l_int|5
op_star
id|SetupInformation.SynchronousValuesID0to7
(braket
id|TargetID
)braket
dot
id|TransferPeriod
suffix:semicolon
multiline_comment|/*&n;    Indicate the Target Device Inquiry completed successfully.&n;  */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ReportTargetDeviceInfo reports about the Target Devices accessible&n;  through Host Adapter.&n;*/
DECL|function|BusLogic_ReportTargetDeviceInfo
r_static
r_void
id|BusLogic_ReportTargetDeviceInfo
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
r_int
id|TargetID
suffix:semicolon
multiline_comment|/*&n;    Inhibit the Target Device Inquiry and Reporting if requested.&n;  */
r_if
c_cond
(paren
id|BusLogic_MultiMasterHostAdapterP
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|HostAdapter-&gt;DriverOptions
op_ne
l_int|NULL
op_logical_and
id|HostAdapter-&gt;DriverOptions-&gt;LocalOptions.InhibitTargetInquiry
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;    Report on the Target Devices found.&n;  */
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
id|BusLogic_TargetFlags_T
op_star
id|TargetFlags
op_assign
op_amp
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
suffix:semicolon
r_if
c_cond
(paren
id|TargetFlags-&gt;TargetExists
op_logical_and
op_logical_neg
id|TargetFlags-&gt;TargetInfoReported
)paren
(brace
r_int
id|SynchronousTransferRate
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
id|boolean
id|WideTransfersActive
suffix:semicolon
id|FlashPoint_InquireTargetInfo
c_func
(paren
id|HostAdapter-&gt;CardHandle
comma
id|TargetID
comma
op_amp
id|HostAdapter-&gt;SynchronousPeriod
(braket
id|TargetID
)braket
comma
op_amp
id|HostAdapter-&gt;SynchronousOffset
(braket
id|TargetID
)braket
comma
op_amp
id|WideTransfersActive
)paren
suffix:semicolon
id|TargetFlags-&gt;WideTransfersActive
op_assign
id|WideTransfersActive
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|TargetFlags-&gt;WideTransfersSupported
op_logical_and
(paren
id|HostAdapter-&gt;WidePermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
op_logical_and
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;5.06L&quot;
)paren
OL
l_int|0
)paren
id|TargetFlags-&gt;WideTransfersActive
op_assign
l_bool|true
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;SynchronousPeriod
(braket
id|TargetID
)braket
OG
l_int|0
)paren
id|SynchronousTransferRate
op_assign
l_int|100000
op_div
id|HostAdapter-&gt;SynchronousPeriod
(braket
id|TargetID
)braket
suffix:semicolon
r_if
c_cond
(paren
id|TargetFlags-&gt;WideTransfersActive
)paren
id|SynchronousTransferRate
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|SynchronousTransferRate
op_ge
l_int|9950
)paren
(brace
id|SynchronousTransferRate
op_assign
(paren
id|SynchronousTransferRate
op_plus
l_int|50
)paren
op_div
l_int|100
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;Target %d: Queue Depth %d, %sSynchronous at &quot;
l_string|&quot;%d.%01d MB/sec, offset %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
comma
id|HostAdapter-&gt;QueueDepth
(braket
id|TargetID
)braket
comma
(paren
id|TargetFlags-&gt;WideTransfersActive
ques
c_cond
l_string|&quot;Wide &quot;
suffix:colon
l_string|&quot;&quot;
)paren
comma
id|SynchronousTransferRate
op_div
l_int|10
comma
id|SynchronousTransferRate
op_mod
l_int|10
comma
id|HostAdapter-&gt;SynchronousOffset
(braket
id|TargetID
)braket
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SynchronousTransferRate
OG
l_int|0
)paren
(brace
id|SynchronousTransferRate
op_assign
(paren
id|SynchronousTransferRate
op_plus
l_int|5
)paren
op_div
l_int|10
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;Target %d: Queue Depth %d, %sSynchronous at &quot;
l_string|&quot;%d.%02d MB/sec, offset %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
comma
id|HostAdapter-&gt;QueueDepth
(braket
id|TargetID
)braket
comma
(paren
id|TargetFlags-&gt;WideTransfersActive
ques
c_cond
l_string|&quot;Wide &quot;
suffix:colon
l_string|&quot;&quot;
)paren
comma
id|SynchronousTransferRate
op_div
l_int|100
comma
id|SynchronousTransferRate
op_mod
l_int|100
comma
id|HostAdapter-&gt;SynchronousOffset
(braket
id|TargetID
)braket
)paren
suffix:semicolon
)brace
r_else
id|BusLogic_Info
c_func
(paren
l_string|&quot;Target %d: Queue Depth %d, Asynchronous&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
comma
id|HostAdapter-&gt;QueueDepth
(braket
id|TargetID
)braket
)paren
suffix:semicolon
id|TargetFlags-&gt;TargetInfoReported
op_assign
l_bool|true
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;  BusLogic_InitializeHostStructure initializes the fields in the SCSI Host&n;  structure.  The base, io_port, n_io_ports, irq, and dma_channel fields in the&n;  SCSI Host structure are intentionally left uninitialized, as this driver&n;  handles acquisition and release of these resources explicitly, as well as&n;  ensuring exclusive access to the Host Adapter hardware and data structures&n;  through explicit acquisition and release of the Host Adapter&squot;s Lock.&n;*/
DECL|function|BusLogic_InitializeHostStructure
r_static
r_void
id|BusLogic_InitializeHostStructure
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
comma
id|SCSI_Host_T
op_star
id|Host
)paren
(brace
id|Host-&gt;max_id
op_assign
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|Host-&gt;max_lun
op_assign
id|HostAdapter-&gt;MaxLogicalUnits
suffix:semicolon
id|Host-&gt;max_channel
op_assign
l_int|0
suffix:semicolon
id|Host-&gt;unique_id
op_assign
id|HostAdapter-&gt;IO_Address
suffix:semicolon
id|Host-&gt;this_id
op_assign
id|HostAdapter-&gt;SCSI_ID
suffix:semicolon
id|Host-&gt;can_queue
op_assign
id|HostAdapter-&gt;DriverQueueDepth
suffix:semicolon
id|Host-&gt;sg_tablesize
op_assign
id|HostAdapter-&gt;DriverScatterGatherLimit
suffix:semicolon
id|Host-&gt;unchecked_isa_dma
op_assign
id|HostAdapter-&gt;BounceBuffersRequired
suffix:semicolon
id|Host-&gt;cmd_per_lun
op_assign
id|HostAdapter-&gt;UntaggedQueueDepth
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_SelectQueueDepths selects Queue Depths for each Target Device based&n;  on the Host Adapter&squot;s Total Queue Depth and the number, type, speed, and&n;  capabilities of the Target Devices.  When called for the last Host Adapter,&n;  it reports on the Target Device Information for all BusLogic Host Adapters&n;  since all the Target Devices have now been probed.&n;*/
DECL|function|BusLogic_SelectQueueDepths
r_static
r_void
id|BusLogic_SelectQueueDepths
c_func
(paren
id|SCSI_Host_T
op_star
id|Host
comma
id|SCSI_Device_T
op_star
id|DeviceList
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|Host-&gt;hostdata
suffix:semicolon
r_int
id|TaggedDeviceCount
op_assign
l_int|0
comma
id|AutomaticTaggedDeviceCount
op_assign
l_int|0
suffix:semicolon
r_int
id|UntaggedDeviceCount
op_assign
l_int|0
comma
id|AutomaticTaggedQueueDepth
op_assign
l_int|0
suffix:semicolon
r_int
id|AllocatedQueueDepth
op_assign
l_int|0
suffix:semicolon
id|SCSI_Device_T
op_star
id|Device
suffix:semicolon
r_int
id|TargetID
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
r_if
c_cond
(paren
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TargetExists
)paren
(brace
r_int
id|QueueDepth
op_assign
id|HostAdapter-&gt;QueueDepth
(braket
id|TargetID
)braket
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TaggedQueuingSupported
op_logical_and
(paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
)paren
(brace
id|TaggedDeviceCount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|QueueDepth
op_eq
l_int|0
)paren
id|AutomaticTaggedDeviceCount
op_increment
suffix:semicolon
)brace
r_else
(brace
id|UntaggedDeviceCount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|QueueDepth
op_eq
l_int|0
op_logical_or
id|QueueDepth
OG
id|HostAdapter-&gt;UntaggedQueueDepth
)paren
(brace
id|QueueDepth
op_assign
id|HostAdapter-&gt;UntaggedQueueDepth
suffix:semicolon
id|HostAdapter-&gt;QueueDepth
(braket
id|TargetID
)braket
op_assign
id|QueueDepth
suffix:semicolon
)brace
)brace
id|AllocatedQueueDepth
op_add_assign
id|QueueDepth
suffix:semicolon
r_if
c_cond
(paren
id|QueueDepth
op_eq
l_int|1
)paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TargetID
)paren
suffix:semicolon
)brace
id|HostAdapter-&gt;TargetDeviceCount
op_assign
id|TaggedDeviceCount
op_plus
id|UntaggedDeviceCount
suffix:semicolon
r_if
c_cond
(paren
id|AutomaticTaggedDeviceCount
OG
l_int|0
)paren
(brace
id|AutomaticTaggedQueueDepth
op_assign
(paren
id|HostAdapter-&gt;HostAdapterQueueDepth
op_minus
id|AllocatedQueueDepth
)paren
op_div
id|AutomaticTaggedDeviceCount
suffix:semicolon
r_if
c_cond
(paren
id|AutomaticTaggedQueueDepth
OG
id|BusLogic_MaxAutomaticTaggedQueueDepth
)paren
id|AutomaticTaggedQueueDepth
op_assign
id|BusLogic_MaxAutomaticTaggedQueueDepth
suffix:semicolon
r_if
c_cond
(paren
id|AutomaticTaggedQueueDepth
OL
id|BusLogic_MinAutomaticTaggedQueueDepth
)paren
id|AutomaticTaggedQueueDepth
op_assign
id|BusLogic_MinAutomaticTaggedQueueDepth
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
r_if
c_cond
(paren
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TargetExists
op_logical_and
id|HostAdapter-&gt;QueueDepth
(braket
id|TargetID
)braket
op_eq
l_int|0
)paren
(brace
id|AllocatedQueueDepth
op_add_assign
id|AutomaticTaggedQueueDepth
suffix:semicolon
id|HostAdapter-&gt;QueueDepth
(braket
id|TargetID
)braket
op_assign
id|AutomaticTaggedQueueDepth
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|Device
op_assign
id|DeviceList
suffix:semicolon
id|Device
op_ne
l_int|NULL
suffix:semicolon
id|Device
op_assign
id|Device-&gt;next
)paren
r_if
c_cond
(paren
id|Device-&gt;host
op_eq
id|Host
)paren
id|Device-&gt;queue_depth
op_assign
id|HostAdapter-&gt;QueueDepth
(braket
id|Device-&gt;id
)braket
suffix:semicolon
multiline_comment|/* Allocate an extra CCB for each Target Device for a Bus Device Reset. */
id|AllocatedQueueDepth
op_add_assign
id|HostAdapter-&gt;TargetDeviceCount
suffix:semicolon
r_if
c_cond
(paren
id|AllocatedQueueDepth
OG
id|HostAdapter-&gt;DriverQueueDepth
)paren
id|AllocatedQueueDepth
op_assign
id|HostAdapter-&gt;DriverQueueDepth
suffix:semicolon
id|BusLogic_CreateAdditionalCCBs
c_func
(paren
id|HostAdapter
comma
id|AllocatedQueueDepth
op_minus
id|HostAdapter-&gt;AllocatedCCBs
comma
l_bool|false
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter
op_eq
id|BusLogic_LastRegisteredHostAdapter
)paren
r_for
c_loop
(paren
id|HostAdapter
op_assign
id|BusLogic_FirstRegisteredHostAdapter
suffix:semicolon
id|HostAdapter
op_ne
l_int|NULL
suffix:semicolon
id|HostAdapter
op_assign
id|HostAdapter-&gt;Next
)paren
id|BusLogic_ReportTargetDeviceInfo
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_DetectHostAdapter probes for BusLogic Host Adapters at the standard&n;  I/O Addresses where they may be located, initializing, registering, and&n;  reporting the configuration of each BusLogic Host Adapter it finds.  It&n;  returns the number of BusLogic Host Adapters successfully initialized and&n;  registered.&n;*/
DECL|function|BusLogic_DetectHostAdapter
r_int
id|BusLogic_DetectHostAdapter
c_func
(paren
id|SCSI_Host_Template_T
op_star
id|HostTemplate
)paren
(brace
r_int
id|BusLogicHostAdapterCount
op_assign
l_int|0
comma
id|DriverOptionsIndex
op_assign
l_int|0
comma
id|ProbeIndex
suffix:semicolon
id|BusLogic_HostAdapter_T
op_star
id|PrototypeHostAdapter
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.NoProbe
)paren
r_return
l_int|0
suffix:semicolon
id|BusLogic_ProbeInfoList
op_assign
(paren
id|BusLogic_ProbeInfo_T
op_star
)paren
id|kmalloc
c_func
(paren
id|BusLogic_MaxHostAdapters
op_star
r_sizeof
(paren
id|BusLogic_ProbeInfo_T
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_ProbeInfoList
op_eq
l_int|NULL
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Unable to allocate Probe Info List&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|BusLogic_ProbeInfoList
comma
l_int|0
comma
id|BusLogic_MaxHostAdapters
op_star
r_sizeof
(paren
id|BusLogic_ProbeInfo_T
)paren
)paren
suffix:semicolon
id|PrototypeHostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|BusLogic_HostAdapter_T
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PrototypeHostAdapter
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|BusLogic_ProbeInfoList
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Unable to allocate Prototype &quot;
l_string|&quot;Host Adapter&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|PrototypeHostAdapter
comma
l_int|0
comma
r_sizeof
(paren
id|BusLogic_HostAdapter_T
)paren
)paren
suffix:semicolon
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|BusLogic
op_ne
l_int|NULL
)paren
id|BusLogic_Setup
c_func
(paren
id|BusLogic
)paren
suffix:semicolon
macro_line|#endif
id|BusLogic_InitializeProbeInfoList
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ProbeIndex
op_assign
l_int|0
suffix:semicolon
id|ProbeIndex
OL
id|BusLogic_ProbeInfoCount
suffix:semicolon
id|ProbeIndex
op_increment
)paren
(brace
id|BusLogic_ProbeInfo_T
op_star
id|ProbeInfo
op_assign
op_amp
id|BusLogic_ProbeInfoList
(braket
id|ProbeIndex
)braket
suffix:semicolon
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
id|PrototypeHostAdapter
suffix:semicolon
id|SCSI_Host_T
op_star
id|Host
suffix:semicolon
r_if
c_cond
(paren
id|ProbeInfo-&gt;IO_Address
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|memset
c_func
(paren
id|HostAdapter
comma
l_int|0
comma
r_sizeof
(paren
id|BusLogic_HostAdapter_T
)paren
)paren
suffix:semicolon
id|HostAdapter-&gt;HostAdapterType
op_assign
id|ProbeInfo-&gt;HostAdapterType
suffix:semicolon
id|HostAdapter-&gt;HostAdapterBusType
op_assign
id|ProbeInfo-&gt;HostAdapterBusType
suffix:semicolon
id|HostAdapter-&gt;IO_Address
op_assign
id|ProbeInfo-&gt;IO_Address
suffix:semicolon
id|HostAdapter-&gt;PCI_Address
op_assign
id|ProbeInfo-&gt;PCI_Address
suffix:semicolon
id|HostAdapter-&gt;Bus
op_assign
id|ProbeInfo-&gt;Bus
suffix:semicolon
id|HostAdapter-&gt;Device
op_assign
id|ProbeInfo-&gt;Device
suffix:semicolon
id|HostAdapter-&gt;IRQ_Channel
op_assign
id|ProbeInfo-&gt;IRQ_Channel
suffix:semicolon
id|HostAdapter-&gt;AddressCount
op_assign
id|BusLogic_HostAdapterAddressCount
(braket
id|HostAdapter-&gt;HostAdapterType
)braket
suffix:semicolon
multiline_comment|/*&n;&t;Probe the Host Adapter.  If unsuccessful, abort further initialization.&n;      */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_ProbeHostAdapter
c_func
(paren
id|HostAdapter
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;Hard Reset the Host Adapter.  If unsuccessful, abort further&n;&t;initialization.&n;      */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_HardwareResetHostAdapter
c_func
(paren
id|HostAdapter
comma
l_bool|true
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;Check the Host Adapter.  If unsuccessful, abort further initialization.&n;      */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_CheckHostAdapter
c_func
(paren
id|HostAdapter
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;Initialize the Driver Options field if provided.&n;      */
r_if
c_cond
(paren
id|DriverOptionsIndex
OL
id|BusLogic_DriverOptionsCount
)paren
id|HostAdapter-&gt;DriverOptions
op_assign
op_amp
id|BusLogic_DriverOptions
(braket
id|DriverOptionsIndex
op_increment
)braket
suffix:semicolon
multiline_comment|/*&n;&t;Announce the Driver Version and Date, Author&squot;s Name, Copyright Notice,&n;&t;and Electronic Mail Address.&n;      */
id|BusLogic_AnnounceDriver
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
multiline_comment|/*&n;&t;Register usage of the I/O Address range.  From this point onward, any&n;&t;failure will be assumed to be due to a problem with the Host Adapter,&n;&t;rather than due to having mistakenly identified this port as belonging&n;&t;to a BusLogic Host Adapter.  The I/O Address range will not be&n;&t;released, thereby preventing it from being incorrectly identified as&n;&t;any other type of Host Adapter.&n;      */
id|request_region
c_func
(paren
id|HostAdapter-&gt;IO_Address
comma
id|HostAdapter-&gt;AddressCount
comma
l_string|&quot;BusLogic&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;Register the SCSI Host structure.&n;      */
id|Host
op_assign
id|scsi_register
c_func
(paren
id|HostTemplate
comma
r_sizeof
(paren
id|BusLogic_HostAdapter_T
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Host
op_eq
l_int|NULL
)paren
(brace
id|release_region
c_func
(paren
id|HostAdapter-&gt;IO_Address
comma
id|HostAdapter-&gt;AddressCount
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|HostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|Host-&gt;hostdata
suffix:semicolon
id|memcpy
c_func
(paren
id|HostAdapter
comma
id|PrototypeHostAdapter
comma
r_sizeof
(paren
id|BusLogic_HostAdapter_T
)paren
)paren
suffix:semicolon
id|HostAdapter-&gt;SCSI_Host
op_assign
id|Host
suffix:semicolon
id|HostAdapter-&gt;HostNumber
op_assign
id|Host-&gt;host_no
suffix:semicolon
id|Host-&gt;select_queue_depths
op_assign
id|BusLogic_SelectQueueDepths
suffix:semicolon
multiline_comment|/*&n;&t;Add Host Adapter to the end of the list of registered BusLogic&n;&t;Host Adapters.&n;      */
id|BusLogic_RegisterHostAdapter
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
multiline_comment|/*&n;&t;Read the Host Adapter Configuration, Configure the Host Adapter,&n;&t;Acquire the System Resources necessary to use the Host Adapter, then&n;&t;Create the Initial CCBs, Initialize the Host Adapter, and finally&n;&t;perform Target Device Inquiry.&n;      */
r_if
c_cond
(paren
id|BusLogic_ReadHostAdapterConfiguration
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|BusLogic_ReportHostAdapterConfiguration
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|BusLogic_AcquireResources
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|BusLogic_CreateInitialCCBs
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|BusLogic_InitializeHostAdapter
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|BusLogic_TargetDeviceInquiry
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
multiline_comment|/*&n;&t;    Initialization has been completed successfully.  Release and&n;&t;    re-register usage of the I/O Address range so that the Model&n;&t;    Name of the Host Adapter will appear, and initialize the SCSI&n;&t;    Host structure.&n;&t;  */
id|release_region
c_func
(paren
id|HostAdapter-&gt;IO_Address
comma
id|HostAdapter-&gt;AddressCount
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|HostAdapter-&gt;IO_Address
comma
id|HostAdapter-&gt;AddressCount
comma
id|HostAdapter-&gt;FullModelName
)paren
suffix:semicolon
id|BusLogic_InitializeHostStructure
c_func
(paren
id|HostAdapter
comma
id|Host
)paren
suffix:semicolon
id|BusLogicHostAdapterCount
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;    An error occurred during Host Adapter Configuration Querying, Host&n;&t;    Adapter Configuration, Resource Acquisition, CCB Creation, Host&n;&t;    Adapter Initialization, or Target Device Inquiry, so remove Host&n;&t;    Adapter from the list of registered BusLogic Host Adapters, destroy&n;&t;    the CCBs, Release the System Resources, and Unregister the SCSI&n;&t;    Host.&n;&t;  */
id|BusLogic_DestroyCCBs
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_ReleaseResources
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_UnregisterHostAdapter
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|scsi_unregister
c_func
(paren
id|Host
)paren
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|BusLogic_ProbeInfoList
)paren
suffix:semicolon
id|BusLogic_ProbeInfoList
op_assign
l_int|NULL
suffix:semicolon
r_return
id|BusLogicHostAdapterCount
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ReleaseHostAdapter releases all resources previously acquired to&n;  support a specific Host Adapter, including the I/O Address range, and&n;  unregisters the BusLogic Host Adapter.&n;*/
DECL|function|BusLogic_ReleaseHostAdapter
r_int
id|BusLogic_ReleaseHostAdapter
c_func
(paren
id|SCSI_Host_T
op_star
id|Host
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|Host-&gt;hostdata
suffix:semicolon
multiline_comment|/*&n;    FlashPoint Host Adapters must first be released by the FlashPoint&n;    SCCB Manager.&n;  */
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
id|FlashPoint_ReleaseHostAdapter
c_func
(paren
id|HostAdapter-&gt;CardHandle
)paren
suffix:semicolon
multiline_comment|/*&n;    Destroy the CCBs and release any system resources acquired to&n;    support Host Adapter.&n;  */
id|BusLogic_DestroyCCBs
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_ReleaseResources
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
multiline_comment|/*&n;    Release usage of the I/O Address range.&n;  */
id|release_region
c_func
(paren
id|HostAdapter-&gt;IO_Address
comma
id|HostAdapter-&gt;AddressCount
)paren
suffix:semicolon
multiline_comment|/*&n;    Remove Host Adapter from the list of registered BusLogic Host Adapters.&n;  */
id|BusLogic_UnregisterHostAdapter
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_QueueCompletedCCB queues CCB for completion processing.&n;*/
DECL|function|BusLogic_QueueCompletedCCB
r_static
r_void
id|BusLogic_QueueCompletedCCB
c_func
(paren
id|BusLogic_CCB_T
op_star
id|CCB
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
id|CCB-&gt;HostAdapter
suffix:semicolon
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Completed
suffix:semicolon
id|CCB-&gt;Next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;FirstCompletedCCB
op_eq
l_int|NULL
)paren
(brace
id|HostAdapter-&gt;FirstCompletedCCB
op_assign
id|CCB
suffix:semicolon
id|HostAdapter-&gt;LastCompletedCCB
op_assign
id|CCB
suffix:semicolon
)brace
r_else
(brace
id|HostAdapter-&gt;LastCompletedCCB-&gt;Next
op_assign
id|CCB
suffix:semicolon
id|HostAdapter-&gt;LastCompletedCCB
op_assign
id|CCB
suffix:semicolon
)brace
id|HostAdapter-&gt;ActiveCommands
(braket
id|CCB-&gt;TargetID
)braket
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ComputeResultCode computes a SCSI Subsystem Result Code from&n;  the Host Adapter Status and Target Device Status.&n;*/
DECL|function|BusLogic_ComputeResultCode
r_static
r_int
id|BusLogic_ComputeResultCode
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
comma
id|BusLogic_HostAdapterStatus_T
id|HostAdapterStatus
comma
id|BusLogic_TargetDeviceStatus_T
id|TargetDeviceStatus
)paren
(brace
r_int
id|HostStatus
suffix:semicolon
r_switch
c_cond
(paren
id|HostAdapterStatus
)paren
(brace
r_case
id|BusLogic_CommandCompletedNormally
suffix:colon
r_case
id|BusLogic_LinkedCommandCompleted
suffix:colon
r_case
id|BusLogic_LinkedCommandCompletedWithFlag
suffix:colon
id|HostStatus
op_assign
id|DID_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_SCSISelectionTimeout
suffix:colon
id|HostStatus
op_assign
id|DID_TIME_OUT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_InvalidOutgoingMailboxActionCode
suffix:colon
r_case
id|BusLogic_InvalidCommandOperationCode
suffix:colon
r_case
id|BusLogic_InvalidCommandParameter
suffix:colon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;BusLogic Driver Protocol Error 0x%02X&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapterStatus
)paren
suffix:semicolon
r_case
id|BusLogic_DataUnderRun
suffix:colon
r_case
id|BusLogic_DataOverRun
suffix:colon
r_case
id|BusLogic_UnexpectedBusFree
suffix:colon
r_case
id|BusLogic_LinkedCCBhasInvalidLUN
suffix:colon
r_case
id|BusLogic_AutoRequestSenseFailed
suffix:colon
r_case
id|BusLogic_TaggedQueuingMessageRejected
suffix:colon
r_case
id|BusLogic_UnsupportedMessageReceived
suffix:colon
r_case
id|BusLogic_HostAdapterHardwareFailed
suffix:colon
r_case
id|BusLogic_TargetDeviceReconnectedImproperly
suffix:colon
r_case
id|BusLogic_AbortQueueGenerated
suffix:colon
r_case
id|BusLogic_HostAdapterSoftwareError
suffix:colon
r_case
id|BusLogic_HostAdapterHardwareTimeoutError
suffix:colon
r_case
id|BusLogic_SCSIParityErrorDetected
suffix:colon
id|HostStatus
op_assign
id|DID_ERROR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_InvalidBusPhaseRequested
suffix:colon
r_case
id|BusLogic_TargetFailedResponseToATN
suffix:colon
r_case
id|BusLogic_HostAdapterAssertedRST
suffix:colon
r_case
id|BusLogic_OtherDeviceAssertedRST
suffix:colon
r_case
id|BusLogic_HostAdapterAssertedBusDeviceReset
suffix:colon
id|HostStatus
op_assign
id|DID_RESET
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unknown Host Adapter Status 0x%02X&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapterStatus
)paren
suffix:semicolon
id|HostStatus
op_assign
id|DID_ERROR
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
id|HostStatus
op_lshift
l_int|16
)paren
op_or
id|TargetDeviceStatus
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ScanIncomingMailboxes scans the Incoming Mailboxes saving any&n;  Incoming Mailbox entries for completion processing.&n;*/
DECL|function|BusLogic_ScanIncomingMailboxes
r_static
r_void
id|BusLogic_ScanIncomingMailboxes
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
multiline_comment|/*&n;    Scan through the Incoming Mailboxes in Strict Round Robin fashion, saving&n;    any completed CCBs for further processing.  It is essential that for each&n;    CCB and SCSI Command issued, command completion processing is performed&n;    exactly once.  Therefore, only Incoming Mailboxes with completion code&n;    Command Completed Without Error, Command Completed With Error, or Command&n;    Aborted At Host Request are saved for completion processing.  When an&n;    Incoming Mailbox has a completion code of Aborted Command Not Found, the&n;    CCB had already completed or been aborted before the current Abort request&n;    was processed, and so completion processing has already occurred and no&n;    further action should be taken.&n;  */
id|BusLogic_IncomingMailbox_T
op_star
id|NextIncomingMailbox
op_assign
id|HostAdapter-&gt;NextIncomingMailbox
suffix:semicolon
id|BusLogic_CompletionCode_T
id|CompletionCode
suffix:semicolon
r_while
c_loop
(paren
(paren
id|CompletionCode
op_assign
id|NextIncomingMailbox-&gt;CompletionCode
)paren
op_ne
id|BusLogic_IncomingMailboxFree
)paren
(brace
id|BusLogic_CCB_T
op_star
id|CCB
op_assign
(paren
id|BusLogic_CCB_T
op_star
)paren
id|Bus_to_Virtual
c_func
(paren
id|NextIncomingMailbox-&gt;CCB
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CompletionCode
op_ne
id|BusLogic_AbortedCommandNotFound
)paren
(brace
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Active
op_logical_or
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Reset
)paren
(brace
multiline_comment|/*&n;&t;&t;Save the Completion Code for this CCB and queue the CCB&n;&t;&t;for completion processing.&n;&t;      */
id|CCB-&gt;CompletionCode
op_assign
id|CompletionCode
suffix:semicolon
id|BusLogic_QueueCompletedCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;If a CCB ever appears in an Incoming Mailbox and is not marked&n;&t;&t;as status Active or Reset, then there is most likely a bug in&n;&t;&t;the Host Adapter firmware.&n;&t;      */
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Illegal CCB #%ld status %d in &quot;
l_string|&quot;Incoming Mailbox&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|CCB-&gt;Status
)paren
suffix:semicolon
)brace
)brace
id|NextIncomingMailbox-&gt;CompletionCode
op_assign
id|BusLogic_IncomingMailboxFree
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|NextIncomingMailbox
OG
id|HostAdapter-&gt;LastIncomingMailbox
)paren
id|NextIncomingMailbox
op_assign
id|HostAdapter-&gt;FirstIncomingMailbox
suffix:semicolon
)brace
id|HostAdapter-&gt;NextIncomingMailbox
op_assign
id|NextIncomingMailbox
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ProcessCompletedCCBs iterates over the completed CCBs for Host&n;  Adapter setting the SCSI Command Result Codes, deallocating the CCBs, and&n;  calling the SCSI Subsystem Completion Routines.  The Host Adapter&squot;s Lock&n;  should already have been acquired by the caller.&n;*/
DECL|function|BusLogic_ProcessCompletedCCBs
r_static
r_void
id|BusLogic_ProcessCompletedCCBs
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
)paren
(brace
r_if
c_cond
(paren
id|HostAdapter-&gt;ProcessCompletedCCBsActive
)paren
r_return
suffix:semicolon
id|HostAdapter-&gt;ProcessCompletedCCBsActive
op_assign
l_bool|true
suffix:semicolon
r_while
c_loop
(paren
id|HostAdapter-&gt;FirstCompletedCCB
op_ne
l_int|NULL
)paren
(brace
id|BusLogic_CCB_T
op_star
id|CCB
op_assign
id|HostAdapter-&gt;FirstCompletedCCB
suffix:semicolon
id|SCSI_Command_T
op_star
id|Command
op_assign
id|CCB-&gt;Command
suffix:semicolon
id|HostAdapter-&gt;FirstCompletedCCB
op_assign
id|CCB-&gt;Next
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;FirstCompletedCCB
op_eq
l_int|NULL
)paren
id|HostAdapter-&gt;LastCompletedCCB
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;Process the Completed CCB.&n;      */
r_if
c_cond
(paren
id|CCB-&gt;Opcode
op_eq
id|BusLogic_BusDeviceReset
)paren
(brace
r_int
id|TargetID
op_assign
id|CCB-&gt;TargetID
suffix:semicolon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Bus Device Reset CCB #%ld to Target &quot;
l_string|&quot;%d Completed&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|TargetID
)paren
suffix:semicolon
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;TargetStatistics
(braket
id|TargetID
)braket
dot
id|BusDeviceResetsCompleted
)paren
suffix:semicolon
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TaggedQueuingActive
op_assign
l_bool|false
suffix:semicolon
id|HostAdapter-&gt;CommandsSinceReset
(braket
id|TargetID
)braket
op_assign
l_int|0
suffix:semicolon
id|HostAdapter-&gt;LastResetCompleted
(braket
id|TargetID
)braket
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t;    Place CCB back on the Host Adapter&squot;s free list.&n;&t;  */
id|BusLogic_DeallocateCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
multiline_comment|/*&n;&t;    Bus Device Reset CCBs have the Command field non-NULL only when a&n;&t;    Bus Device Reset was requested for a Command that did not have a&n;&t;    currently active CCB in the Host Adapter (i.e., a Synchronous&n;&t;    Bus Device Reset), and hence would not have its Completion Routine&n;&t;    called otherwise.&n;&t;  */
r_while
c_loop
(paren
id|Command
op_ne
l_int|NULL
)paren
(brace
id|SCSI_Command_T
op_star
id|NextCommand
op_assign
id|Command-&gt;reset_chain
suffix:semicolon
id|Command-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|Command-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|Command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|Command
)paren
suffix:semicolon
id|Command
op_assign
id|NextCommand
suffix:semicolon
)brace
multiline_comment|/*&n;&t;    Iterate over the CCBs for this Host Adapter performing completion&n;&t;    processing for any CCBs marked as Reset for this Target.&n;&t;  */
r_for
c_loop
(paren
id|CCB
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|CCB
op_ne
l_int|NULL
suffix:semicolon
id|CCB
op_assign
id|CCB-&gt;NextAll
)paren
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Reset
op_logical_and
id|CCB-&gt;TargetID
op_eq
id|TargetID
)paren
(brace
id|Command
op_assign
id|CCB-&gt;Command
suffix:semicolon
id|BusLogic_DeallocateCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
id|HostAdapter-&gt;ActiveCommands
(braket
id|TargetID
)braket
op_decrement
suffix:semicolon
id|Command-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|Command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|Command
)paren
suffix:semicolon
)brace
id|HostAdapter-&gt;BusDeviceResetPendingCCB
(braket
id|TargetID
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;    Translate the Completion Code, Host Adapter Status, and Target&n;&t;    Device Status into a SCSI Subsystem Result Code.&n;&t;  */
r_switch
c_cond
(paren
id|CCB-&gt;CompletionCode
)paren
(brace
r_case
id|BusLogic_IncomingMailboxFree
suffix:colon
r_case
id|BusLogic_AbortedCommandNotFound
suffix:colon
r_case
id|BusLogic_InvalidCCB
suffix:colon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;CCB #%ld to Target %d Impossible State&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|CCB-&gt;TargetID
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_CommandCompletedWithoutError
suffix:colon
id|HostAdapter-&gt;TargetStatistics
(braket
id|CCB-&gt;TargetID
)braket
dot
id|CommandsCompleted
op_increment
suffix:semicolon
id|HostAdapter-&gt;TargetFlags
(braket
id|CCB-&gt;TargetID
)braket
dot
id|CommandSuccessfulFlag
op_assign
l_bool|true
suffix:semicolon
id|Command-&gt;result
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_CommandAbortedAtHostRequest
suffix:colon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;CCB #%ld to Target %d Aborted&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|CCB-&gt;TargetID
)paren
suffix:semicolon
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;TargetStatistics
(braket
id|CCB-&gt;TargetID
)braket
dot
id|CommandAbortsCompleted
)paren
suffix:semicolon
id|Command-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_CommandCompletedWithError
suffix:colon
id|Command-&gt;result
op_assign
id|BusLogic_ComputeResultCode
c_func
(paren
id|HostAdapter
comma
id|CCB-&gt;HostAdapterStatus
comma
id|CCB-&gt;TargetDeviceStatus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CCB-&gt;HostAdapterStatus
op_ne
id|BusLogic_SCSISelectionTimeout
)paren
(brace
id|HostAdapter-&gt;TargetStatistics
(braket
id|CCB-&gt;TargetID
)braket
dot
id|CommandsCompleted
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceErrors
)paren
(brace
r_int
id|i
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;CCB #%ld Target %d: Result %X Host &quot;
l_string|&quot;Adapter Status %02X &quot;
l_string|&quot;Target Status %02X&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|CCB-&gt;TargetID
comma
id|Command-&gt;result
comma
id|CCB-&gt;HostAdapterStatus
comma
id|CCB-&gt;TargetDeviceStatus
)paren
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;CDB   &quot;
comma
id|HostAdapter
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CCB-&gt;CDB_Length
suffix:semicolon
id|i
op_increment
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot; %02X&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;CDB
(braket
id|i
)braket
)paren
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;Sense &quot;
comma
id|HostAdapter
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CCB-&gt;SenseDataLength
suffix:semicolon
id|i
op_increment
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot; %02X&quot;
comma
id|HostAdapter
comma
id|Command-&gt;sense_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;    When an INQUIRY command completes normally, save the&n;&t;    CmdQue (Tagged Queuing Supported) and WBus16 (16 Bit&n;&t;    Wide Data Transfers Supported) bits.&n;&t;  */
r_if
c_cond
(paren
id|CCB-&gt;CDB
(braket
l_int|0
)braket
op_eq
id|INQUIRY
op_logical_and
id|CCB-&gt;CDB
(braket
l_int|1
)braket
op_eq
l_int|0
op_logical_and
id|CCB-&gt;HostAdapterStatus
op_eq
id|BusLogic_CommandCompletedNormally
)paren
(brace
id|BusLogic_TargetFlags_T
op_star
id|TargetFlags
op_assign
op_amp
id|HostAdapter-&gt;TargetFlags
(braket
id|CCB-&gt;TargetID
)braket
suffix:semicolon
id|SCSI_Inquiry_T
op_star
id|InquiryResult
op_assign
(paren
id|SCSI_Inquiry_T
op_star
)paren
id|Command-&gt;request_buffer
suffix:semicolon
id|TargetFlags-&gt;TargetExists
op_assign
l_bool|true
suffix:semicolon
id|TargetFlags-&gt;TaggedQueuingSupported
op_assign
id|InquiryResult-&gt;CmdQue
suffix:semicolon
id|TargetFlags-&gt;WideTransfersSupported
op_assign
id|InquiryResult-&gt;WBus16
suffix:semicolon
)brace
multiline_comment|/*&n;&t;    Place CCB back on the Host Adapter&squot;s free list.&n;&t;  */
id|BusLogic_DeallocateCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
multiline_comment|/*&n;&t;    Call the SCSI Command Completion Routine.&n;&t;  */
id|Command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|Command
)paren
suffix:semicolon
)brace
)brace
id|HostAdapter-&gt;ProcessCompletedCCBsActive
op_assign
l_bool|false
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InterruptHandler handles hardware interrupts from BusLogic Host&n;  Adapters.&n;*/
DECL|function|BusLogic_InterruptHandler
r_static
r_void
id|BusLogic_InterruptHandler
c_func
(paren
r_int
id|IRQ_Channel
comma
r_void
op_star
id|DeviceIdentifier
comma
id|Registers_T
op_star
id|InterruptRegisters
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|DeviceIdentifier
suffix:semicolon
id|ProcessorFlags_T
id|ProcessorFlags
suffix:semicolon
multiline_comment|/*&n;    Acquire exclusive access to Host Adapter.&n;  */
id|BusLogic_AcquireHostAdapterLockIH
c_func
(paren
id|HostAdapter
comma
op_amp
id|ProcessorFlags
)paren
suffix:semicolon
multiline_comment|/*&n;    Handle Interrupts appropriately for each Host Adapter type.&n;  */
r_if
c_cond
(paren
id|BusLogic_MultiMasterHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
id|BusLogic_InterruptRegister_T
id|InterruptRegister
suffix:semicolon
multiline_comment|/*&n;&t;Read the Host Adapter Interrupt Register.&n;      */
id|InterruptRegister.All
op_assign
id|BusLogic_ReadInterruptRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|InterruptRegister.Bits.InterruptValid
)paren
(brace
multiline_comment|/*&n;&t;    Acknowledge the interrupt and reset the Host Adapter&n;&t;    Interrupt Register.&n;&t;  */
id|BusLogic_InterruptReset
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
multiline_comment|/*&n;&t;    Process valid External SCSI Bus Reset and Incoming Mailbox&n;&t;    Loaded Interrupts.  Command Complete Interrupts are noted,&n;&t;    and Outgoing Mailbox Available Interrupts are ignored, as&n;&t;    they are never enabled.&n;&t;  */
r_if
c_cond
(paren
id|InterruptRegister.Bits.ExternalBusReset
)paren
id|HostAdapter-&gt;HostAdapterExternalReset
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|InterruptRegister.Bits.IncomingMailboxLoaded
)paren
id|BusLogic_ScanIncomingMailboxes
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|InterruptRegister.Bits.CommandComplete
)paren
id|HostAdapter-&gt;HostAdapterCommandCompleted
op_assign
l_bool|true
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;Check if there is a pending interrupt for this Host Adapter.&n;      */
r_if
c_cond
(paren
id|FlashPoint_InterruptPending
c_func
(paren
id|HostAdapter-&gt;CardHandle
)paren
)paren
r_switch
c_cond
(paren
id|FlashPoint_HandleInterrupt
c_func
(paren
id|HostAdapter-&gt;CardHandle
)paren
)paren
(brace
r_case
id|FlashPoint_NormalInterrupt
suffix:colon
r_break
suffix:semicolon
r_case
id|FlashPoint_ExternalBusReset
suffix:colon
id|HostAdapter-&gt;HostAdapterExternalReset
op_assign
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FlashPoint_InternalError
suffix:colon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Internal FlashPoint Error detected&quot;
l_string|&quot; - Resetting Host Adapter&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
id|HostAdapter-&gt;HostAdapterInternalError
op_assign
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;    Process any completed CCBs.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;FirstCompletedCCB
op_ne
l_int|NULL
)paren
id|BusLogic_ProcessCompletedCCBs
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
multiline_comment|/*&n;    Reset the Host Adapter if requested.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterExternalReset
op_logical_or
id|HostAdapter-&gt;HostAdapterInternalError
)paren
(brace
id|BusLogic_ResetHostAdapter
c_func
(paren
id|HostAdapter
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|HostAdapter-&gt;HostAdapterExternalReset
op_assign
l_bool|false
suffix:semicolon
id|HostAdapter-&gt;HostAdapterInternalError
op_assign
l_bool|false
suffix:semicolon
id|scsi_mark_host_reset
c_func
(paren
id|HostAdapter-&gt;SCSI_Host
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    Release exclusive access to Host Adapter.&n;  */
id|BusLogic_ReleaseHostAdapterLockIH
c_func
(paren
id|HostAdapter
comma
op_amp
id|ProcessorFlags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_WriteOutgoingMailbox places CCB and Action Code into an Outgoing&n;  Mailbox for execution by Host Adapter.  The Host Adapter&squot;s Lock should&n;  already have been acquired by the caller.&n;*/
DECL|function|BusLogic_WriteOutgoingMailbox
r_static
id|boolean
id|BusLogic_WriteOutgoingMailbox
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
comma
id|BusLogic_ActionCode_T
id|ActionCode
comma
id|BusLogic_CCB_T
op_star
id|CCB
)paren
(brace
id|BusLogic_OutgoingMailbox_T
op_star
id|NextOutgoingMailbox
suffix:semicolon
id|NextOutgoingMailbox
op_assign
id|HostAdapter-&gt;NextOutgoingMailbox
suffix:semicolon
r_if
c_cond
(paren
id|NextOutgoingMailbox-&gt;ActionCode
op_eq
id|BusLogic_OutgoingMailboxFree
)paren
(brace
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Active
suffix:semicolon
multiline_comment|/*&n;&t;The CCB field must be written before the Action Code field since&n;&t;the Host Adapter is operating asynchronously and the locking code&n;&t;does not protect against simultaneous access by the Host Adapter.&n;      */
id|NextOutgoingMailbox-&gt;CCB
op_assign
id|Virtual_to_Bus
c_func
(paren
id|CCB
)paren
suffix:semicolon
id|NextOutgoingMailbox-&gt;ActionCode
op_assign
id|ActionCode
suffix:semicolon
id|BusLogic_StartMailboxCommand
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|NextOutgoingMailbox
OG
id|HostAdapter-&gt;LastOutgoingMailbox
)paren
id|NextOutgoingMailbox
op_assign
id|HostAdapter-&gt;FirstOutgoingMailbox
suffix:semicolon
id|HostAdapter-&gt;NextOutgoingMailbox
op_assign
id|NextOutgoingMailbox
suffix:semicolon
r_if
c_cond
(paren
id|ActionCode
op_eq
id|BusLogic_MailboxStartCommand
)paren
(brace
id|HostAdapter-&gt;ActiveCommands
(braket
id|CCB-&gt;TargetID
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|CCB-&gt;Opcode
op_ne
id|BusLogic_BusDeviceReset
)paren
id|HostAdapter-&gt;TargetStatistics
(braket
id|CCB-&gt;TargetID
)braket
dot
id|CommandsAttempted
op_increment
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_QueueCommand creates a CCB for Command and places it into an&n;  Outgoing Mailbox for execution by the associated Host Adapter.&n;*/
DECL|function|BusLogic_QueueCommand
r_int
id|BusLogic_QueueCommand
c_func
(paren
id|SCSI_Command_T
op_star
id|Command
comma
r_void
(paren
op_star
id|CompletionRoutine
)paren
(paren
id|SCSI_Command_T
op_star
)paren
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|Command-&gt;host-&gt;hostdata
suffix:semicolon
id|BusLogic_TargetFlags_T
op_star
id|TargetFlags
op_assign
op_amp
id|HostAdapter-&gt;TargetFlags
(braket
id|Command-&gt;target
)braket
suffix:semicolon
id|BusLogic_TargetStatistics_T
op_star
id|TargetStatistics
op_assign
id|HostAdapter-&gt;TargetStatistics
suffix:semicolon
r_int
r_char
op_star
id|CDB
op_assign
id|Command-&gt;cmnd
suffix:semicolon
r_int
id|CDB_Length
op_assign
id|Command-&gt;cmd_len
suffix:semicolon
r_int
id|TargetID
op_assign
id|Command-&gt;target
suffix:semicolon
r_int
id|LogicalUnit
op_assign
id|Command-&gt;lun
suffix:semicolon
r_void
op_star
id|BufferPointer
op_assign
id|Command-&gt;request_buffer
suffix:semicolon
r_int
id|BufferLength
op_assign
id|Command-&gt;request_bufflen
suffix:semicolon
r_int
id|SegmentCount
op_assign
id|Command-&gt;use_sg
suffix:semicolon
id|ProcessorFlags_T
id|ProcessorFlags
suffix:semicolon
id|BusLogic_CCB_T
op_star
id|CCB
suffix:semicolon
multiline_comment|/*&n;    SCSI REQUEST_SENSE commands will be executed automatically by the Host&n;    Adapter for any errors, so they should not be executed explicitly unless&n;    the Sense Data is zero indicating that no error occurred.&n;  */
r_if
c_cond
(paren
id|CDB
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
id|Command-&gt;sense_buffer
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
(brace
id|Command-&gt;result
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
id|CompletionRoutine
c_func
(paren
id|Command
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;    Acquire exclusive access to Host Adapter.&n;  */
id|BusLogic_AcquireHostAdapterLock
c_func
(paren
id|HostAdapter
comma
op_amp
id|ProcessorFlags
)paren
suffix:semicolon
multiline_comment|/*&n;    Allocate a CCB from the Host Adapter&squot;s free list.  In the unlikely event&n;    that there are none available and memory allocation fails, wait 1 second&n;    and try again.  If that fails, the Host Adapter is probably hung so signal&n;    an error as a Host Adapter Hard Reset should be initiated soon.&n;  */
id|CCB
op_assign
id|BusLogic_AllocateCCB
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
(brace
id|BusLogic_Delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|CCB
op_assign
id|BusLogic_AllocateCCB
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
(brace
id|Command-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|CompletionRoutine
c_func
(paren
id|Command
)paren
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;    Initialize the fields in the BusLogic Command Control Block (CCB).&n;  */
r_if
c_cond
(paren
id|SegmentCount
op_eq
l_int|0
)paren
(brace
id|CCB-&gt;Opcode
op_assign
id|BusLogic_InitiatorCCB
suffix:semicolon
id|CCB-&gt;DataLength
op_assign
id|BufferLength
suffix:semicolon
id|CCB-&gt;DataPointer
op_assign
id|Virtual_to_Bus
c_func
(paren
id|BufferPointer
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCSI_ScatterList_T
op_star
id|ScatterList
op_assign
(paren
id|SCSI_ScatterList_T
op_star
)paren
id|BufferPointer
suffix:semicolon
r_int
id|Segment
suffix:semicolon
id|CCB-&gt;Opcode
op_assign
id|BusLogic_InitiatorCCB_ScatterGather
suffix:semicolon
id|CCB-&gt;DataLength
op_assign
id|SegmentCount
op_star
r_sizeof
(paren
id|BusLogic_ScatterGatherSegment_T
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_MultiMasterHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
id|CCB-&gt;DataPointer
op_assign
id|Virtual_to_Bus
c_func
(paren
id|CCB-&gt;ScatterGatherList
)paren
suffix:semicolon
r_else
id|CCB-&gt;DataPointer
op_assign
id|Virtual_to_32Bit_Virtual
c_func
(paren
id|CCB-&gt;ScatterGatherList
)paren
suffix:semicolon
r_for
c_loop
(paren
id|Segment
op_assign
l_int|0
suffix:semicolon
id|Segment
OL
id|SegmentCount
suffix:semicolon
id|Segment
op_increment
)paren
(brace
id|CCB-&gt;ScatterGatherList
(braket
id|Segment
)braket
dot
id|SegmentByteCount
op_assign
id|ScatterList
(braket
id|Segment
)braket
dot
id|length
suffix:semicolon
id|CCB-&gt;ScatterGatherList
(braket
id|Segment
)braket
dot
id|SegmentDataPointer
op_assign
id|Virtual_to_Bus
c_func
(paren
id|ScatterList
(braket
id|Segment
)braket
dot
id|address
)paren
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|CDB
(braket
l_int|0
)braket
)paren
(brace
r_case
id|READ_6
suffix:colon
r_case
id|READ_10
suffix:colon
id|CCB-&gt;DataDirection
op_assign
id|BusLogic_DataInLengthChecked
suffix:semicolon
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommands
op_increment
suffix:semicolon
id|BusLogic_IncrementByteCounter
c_func
(paren
op_amp
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesRead
comma
id|BufferLength
)paren
suffix:semicolon
id|BusLogic_IncrementSizeBucket
c_func
(paren
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
comma
id|BufferLength
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
id|CCB-&gt;DataDirection
op_assign
id|BusLogic_DataOutLengthChecked
suffix:semicolon
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommands
op_increment
suffix:semicolon
id|BusLogic_IncrementByteCounter
c_func
(paren
op_amp
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesWritten
comma
id|BufferLength
)paren
suffix:semicolon
id|BusLogic_IncrementSizeBucket
c_func
(paren
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
comma
id|BufferLength
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|CCB-&gt;DataDirection
op_assign
id|BusLogic_UncheckedDataTransfer
suffix:semicolon
r_break
suffix:semicolon
)brace
id|CCB-&gt;CDB_Length
op_assign
id|CDB_Length
suffix:semicolon
id|CCB-&gt;SenseDataLength
op_assign
r_sizeof
(paren
id|Command-&gt;sense_buffer
)paren
suffix:semicolon
id|CCB-&gt;HostAdapterStatus
op_assign
l_int|0
suffix:semicolon
id|CCB-&gt;TargetDeviceStatus
op_assign
l_int|0
suffix:semicolon
id|CCB-&gt;TargetID
op_assign
id|TargetID
suffix:semicolon
id|CCB-&gt;LogicalUnit
op_assign
id|LogicalUnit
suffix:semicolon
id|CCB-&gt;TagEnable
op_assign
l_bool|false
suffix:semicolon
id|CCB-&gt;LegacyTagEnable
op_assign
l_bool|false
suffix:semicolon
multiline_comment|/*&n;    BusLogic recommends that after a Reset the first couple of commands that&n;    are sent to a Target Device be sent in a non Tagged Queue fashion so that&n;    the Host Adapter and Target Device can establish Synchronous and Wide&n;    Transfer before Queue Tag messages can interfere with the Synchronous and&n;    Wide Negotiation messages.  By waiting to enable Tagged Queuing until after&n;    the first BusLogic_MaxTaggedQueueDepth commands have been queued, it is&n;    assured that after a Reset any pending commands are requeued before Tagged&n;    Queuing is enabled and that the Tagged Queuing message will not occur while&n;    the partition table is being printed.  In addition, some devices do not&n;    properly handle the transition from non-tagged to tagged commands, so it is&n;    necessary to wait until there are no pending commands for a target device&n;    before queuing tagged commands.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;CommandsSinceReset
(braket
id|TargetID
)braket
op_increment
op_ge
id|BusLogic_MaxTaggedQueueDepth
op_logical_and
op_logical_neg
id|TargetFlags-&gt;TaggedQueuingActive
op_logical_and
id|HostAdapter-&gt;ActiveCommands
(braket
id|TargetID
)braket
op_eq
l_int|0
op_logical_and
id|TargetFlags-&gt;TaggedQueuingSupported
op_logical_and
(paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
)paren
(brace
id|TargetFlags-&gt;TaggedQueuingActive
op_assign
l_bool|true
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;Tagged Queuing now active for Target %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TargetFlags-&gt;TaggedQueuingActive
)paren
(brace
id|BusLogic_QueueTag_T
id|QueueTag
op_assign
id|BusLogic_SimpleQueueTag
suffix:semicolon
multiline_comment|/*&n;&t;When using Tagged Queuing with Simple Queue Tags, it appears that disk&n;&t;drive controllers do not guarantee that a queued command will not&n;&t;remain in a disconnected state indefinitely if commands that read or&n;&t;write nearer the head position continue to arrive without interruption.&n;&t;Therefore, for each Target Device this driver keeps track of the last&n;&t;time either the queue was empty or an Ordered Queue Tag was issued.  If&n;&t;more than 4 seconds (one fifth of the 20 second disk timeout) have&n;&t;elapsed since this last sequence point, this command will be issued&n;&t;with an Ordered Queue Tag rather than a Simple Queue Tag, which forces&n;&t;the Target Device to complete all previously queued commands before&n;&t;this command may be executed.&n;      */
r_if
c_cond
(paren
id|HostAdapter-&gt;ActiveCommands
(braket
id|TargetID
)braket
op_eq
l_int|0
)paren
id|HostAdapter-&gt;LastSequencePoint
(braket
id|TargetID
)braket
op_assign
id|jiffies
suffix:semicolon
r_else
r_if
c_cond
(paren
id|jiffies
op_minus
id|HostAdapter-&gt;LastSequencePoint
(braket
id|TargetID
)braket
OG
l_int|4
op_star
id|HZ
)paren
(brace
id|HostAdapter-&gt;LastSequencePoint
(braket
id|TargetID
)braket
op_assign
id|jiffies
suffix:semicolon
id|QueueTag
op_assign
id|BusLogic_OrderedQueueTag
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HostAdapter-&gt;ExtendedLUNSupport
)paren
(brace
id|CCB-&gt;TagEnable
op_assign
l_bool|true
suffix:semicolon
id|CCB-&gt;QueueTag
op_assign
id|QueueTag
suffix:semicolon
)brace
r_else
(brace
id|CCB-&gt;LegacyTagEnable
op_assign
l_bool|true
suffix:semicolon
id|CCB-&gt;LegacyQueueTag
op_assign
id|QueueTag
suffix:semicolon
)brace
)brace
id|memcpy
c_func
(paren
id|CCB-&gt;CDB
comma
id|CDB
comma
id|CDB_Length
)paren
suffix:semicolon
id|CCB-&gt;SenseDataPointer
op_assign
id|Virtual_to_Bus
c_func
(paren
op_amp
id|Command-&gt;sense_buffer
)paren
suffix:semicolon
id|CCB-&gt;Command
op_assign
id|Command
suffix:semicolon
id|Command-&gt;scsi_done
op_assign
id|CompletionRoutine
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_MultiMasterHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
multiline_comment|/*&n;&t;Place the CCB in an Outgoing Mailbox.  The higher levels of the SCSI&n;&t;Subsystem should not attempt to queue more commands than can be placed&n;&t;in Outgoing Mailboxes, so there should always be one free.  In the&n;&t;unlikely event that there are none available, wait 1 second and try&n;&t;again.  If that fails, the Host Adapter is probably hung so signal an&n;&t;error as a Host Adapter Hard Reset should be initiated soon.&n;      */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_WriteOutgoingMailbox
c_func
(paren
id|HostAdapter
comma
id|BusLogic_MailboxStartCommand
comma
id|CCB
)paren
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to write Outgoing Mailbox - &quot;
l_string|&quot;Pausing for 1 second&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_Delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_WriteOutgoingMailbox
c_func
(paren
id|HostAdapter
comma
id|BusLogic_MailboxStartCommand
comma
id|CCB
)paren
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Still unable to write Outgoing Mailbox - &quot;
l_string|&quot;Host Adapter Dead?&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_DeallocateCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
id|Command-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|Command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|Command
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;Call the FlashPoint SCCB Manager to start execution of the CCB.&n;      */
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Active
suffix:semicolon
id|HostAdapter-&gt;ActiveCommands
(braket
id|TargetID
)braket
op_increment
suffix:semicolon
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandsAttempted
op_increment
suffix:semicolon
id|FlashPoint_StartCCB
c_func
(paren
id|HostAdapter-&gt;CardHandle
comma
id|CCB
)paren
suffix:semicolon
multiline_comment|/*&n;&t;The Command may have already completed and BusLogic_QueueCompletedCCB&n;&t;been called, or it may still be pending.&n;      */
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Completed
)paren
id|BusLogic_ProcessCompletedCCBs
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    Release exclusive access to Host Adapter.&n;  */
id|Done
suffix:colon
id|BusLogic_ReleaseHostAdapterLock
c_func
(paren
id|HostAdapter
comma
op_amp
id|ProcessorFlags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_AbortCommand aborts Command if possible.&n;*/
DECL|function|BusLogic_AbortCommand
r_int
id|BusLogic_AbortCommand
c_func
(paren
id|SCSI_Command_T
op_star
id|Command
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|Command-&gt;host-&gt;hostdata
suffix:semicolon
r_int
id|TargetID
op_assign
id|Command-&gt;target
suffix:semicolon
id|ProcessorFlags_T
id|ProcessorFlags
suffix:semicolon
id|BusLogic_CCB_T
op_star
id|CCB
suffix:semicolon
r_int
id|Result
suffix:semicolon
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandAbortsRequested
)paren
suffix:semicolon
multiline_comment|/*&n;    Acquire exclusive access to Host Adapter.&n;  */
id|BusLogic_AcquireHostAdapterLock
c_func
(paren
id|HostAdapter
comma
op_amp
id|ProcessorFlags
)paren
suffix:semicolon
multiline_comment|/*&n;    If this Command has already completed, then no Abort is necessary.&n;  */
r_if
c_cond
(paren
id|Command-&gt;serial_number
op_ne
id|Command-&gt;serial_number_at_timeout
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Abort Command to Target %d - &quot;
l_string|&quot;Already Completed&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;    Attempt to find an Active CCB for this Command.  If no Active CCB for this&n;    Command is found, then no Abort is necessary.&n;  */
r_for
c_loop
(paren
id|CCB
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|CCB
op_ne
l_int|NULL
suffix:semicolon
id|CCB
op_assign
id|CCB-&gt;NextAll
)paren
r_if
c_cond
(paren
id|CCB-&gt;Command
op_eq
id|Command
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Abort Command to Target %d - &quot;
l_string|&quot;No CCB Found&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Completed
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Abort Command to Target %d - &quot;
l_string|&quot;CCB Completed&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Reset
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Abort Command to Target %d - &quot;
l_string|&quot;CCB Reset&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_ABORT_PENDING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_MultiMasterHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
multiline_comment|/*&n;&t;Attempt to Abort this CCB.  MultiMaster Firmware versions prior to 5.xx&n;&t;do not generate Abort Tag messages, but only generate the non-tagged&n;&t;Abort message.  Since non-tagged commands are not sent by the Host&n;&t;Adapter until the queue of outstanding tagged commands has completed,&n;&t;and the Abort message is treated as a non-tagged command, it is&n;&t;effectively impossible to abort commands when Tagged Queuing is active.&n;&t;Firmware version 5.xx does generate Abort Tag messages, so it is&n;&t;possible to abort commands when Tagged Queuing is active.&n;      */
r_if
c_cond
(paren
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TaggedQueuingActive
op_logical_and
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
OL
l_char|&squot;5&squot;
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Abort CCB #%ld to Target %d - &quot;
l_string|&quot;Abort Tag Not Supported&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_WriteOutgoingMailbox
c_func
(paren
id|HostAdapter
comma
id|BusLogic_MailboxAbortCommand
comma
id|CCB
)paren
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Aborting CCB #%ld to Target %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|TargetID
)paren
suffix:semicolon
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandAbortsAttempted
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_ABORT_PENDING
suffix:semicolon
)brace
r_else
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Abort CCB #%ld to Target %d - &quot;
l_string|&quot;No Outgoing Mailboxes&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_ABORT_BUSY
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;Call the FlashPoint SCCB Manager to abort execution of the CCB.&n;      */
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Aborting CCB #%ld to Target %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|TargetID
)paren
suffix:semicolon
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandAbortsAttempted
)paren
suffix:semicolon
id|FlashPoint_AbortCCB
c_func
(paren
id|HostAdapter-&gt;CardHandle
comma
id|CCB
)paren
suffix:semicolon
multiline_comment|/*&n;&t;The Abort may have already been completed and&n;&t;BusLogic_QueueCompletedCCB been called, or it&n;&t;may still be pending.&n;      */
id|Result
op_assign
id|SCSI_ABORT_PENDING
suffix:semicolon
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Completed
)paren
(brace
id|BusLogic_ProcessCompletedCCBs
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;    Release exclusive access to Host Adapter.&n;  */
id|Done
suffix:colon
id|BusLogic_ReleaseHostAdapterLock
c_func
(paren
id|HostAdapter
comma
op_amp
id|ProcessorFlags
)paren
suffix:semicolon
r_return
id|Result
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ResetHostAdapter resets Host Adapter if possible, marking all&n;  currently executing SCSI Commands as having been Reset.&n;*/
DECL|function|BusLogic_ResetHostAdapter
r_static
r_int
id|BusLogic_ResetHostAdapter
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
comma
id|SCSI_Command_T
op_star
id|Command
comma
r_int
r_int
id|ResetFlags
)paren
(brace
id|ProcessorFlags_T
id|ProcessorFlags
suffix:semicolon
id|BusLogic_CCB_T
op_star
id|CCB
suffix:semicolon
r_int
id|TargetID
comma
id|Result
suffix:semicolon
id|boolean
id|HardReset
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterExternalReset
)paren
(brace
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;ExternalHostAdapterResets
)paren
suffix:semicolon
id|HardReset
op_assign
l_bool|false
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterInternalError
)paren
(brace
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;HostAdapterInternalErrors
)paren
suffix:semicolon
id|HardReset
op_assign
l_bool|true
suffix:semicolon
)brace
r_else
(brace
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;TargetStatistics
(braket
id|Command-&gt;target
)braket
dot
id|HostAdapterResetsRequested
)paren
suffix:semicolon
id|HardReset
op_assign
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;    Acquire exclusive access to Host Adapter.&n;  */
id|BusLogic_AcquireHostAdapterLock
c_func
(paren
id|HostAdapter
comma
op_amp
id|ProcessorFlags
)paren
suffix:semicolon
multiline_comment|/*&n;    If this is an Asynchronous Reset and this Command has already completed,&n;    then no Reset is necessary.&n;  */
r_if
c_cond
(paren
id|ResetFlags
op_amp
id|SCSI_RESET_ASYNCHRONOUS
)paren
(brace
id|TargetID
op_assign
id|Command-&gt;target
suffix:semicolon
r_if
c_cond
(paren
id|Command-&gt;serial_number
op_ne
id|Command-&gt;serial_number_at_timeout
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Reset Command to Target %d - &quot;
l_string|&quot;Already Completed or Reset&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_for
c_loop
(paren
id|CCB
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|CCB
op_ne
l_int|NULL
suffix:semicolon
id|CCB
op_assign
id|CCB-&gt;NextAll
)paren
r_if
c_cond
(paren
id|CCB-&gt;Command
op_eq
id|Command
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Reset Command to Target %d - &quot;
l_string|&quot;No CCB Found&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Completed
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Reset Command to Target %d - &quot;
l_string|&quot;CCB Completed&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Reset
op_logical_and
id|HostAdapter-&gt;BusDeviceResetPendingCCB
(braket
id|TargetID
)braket
op_eq
l_int|NULL
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Reset Command to Target %d - &quot;
l_string|&quot;Reset Pending&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_PENDING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|Command
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterInternalError
)paren
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Resetting %s due to Host Adapter Internal Error&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;FullModelName
)paren
suffix:semicolon
r_else
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Resetting %s due to External SCSI Bus Reset&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;FullModelName
)paren
suffix:semicolon
)brace
r_else
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Resetting %s due to Target %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;FullModelName
comma
id|Command-&gt;target
)paren
suffix:semicolon
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;TargetStatistics
(braket
id|Command-&gt;target
)braket
dot
id|HostAdapterResetsAttempted
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    Attempt to Reset and Reinitialize the Host Adapter.&n;  */
r_if
c_cond
(paren
op_logical_neg
(paren
id|BusLogic_HardwareResetHostAdapter
c_func
(paren
id|HostAdapter
comma
id|HardReset
)paren
op_logical_and
id|BusLogic_InitializeHostAdapter
c_func
(paren
id|HostAdapter
)paren
)paren
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;Resetting %s Failed&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;FullModelName
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_ERROR
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Command
op_ne
l_int|NULL
)paren
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;TargetStatistics
(braket
id|Command-&gt;target
)braket
dot
id|HostAdapterResetsCompleted
)paren
suffix:semicolon
multiline_comment|/*&n;    Mark all currently executing CCBs as having been Reset.&n;  */
r_for
c_loop
(paren
id|CCB
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|CCB
op_ne
l_int|NULL
suffix:semicolon
id|CCB
op_assign
id|CCB-&gt;NextAll
)paren
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Active
)paren
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Reset
suffix:semicolon
multiline_comment|/*&n;    Wait a few seconds between the Host Adapter Hard Reset which initiates&n;    a SCSI Bus Reset and issuing any SCSI Commands.  Some SCSI devices get&n;    confused if they receive SCSI Commands too soon after a SCSI Bus Reset.&n;    Note that a timer interrupt may occur here, but all active CCBs have&n;    already been marked Reset and so a reentrant call will return Pending.&n;  */
r_if
c_cond
(paren
id|HardReset
)paren
id|BusLogic_Delay
c_func
(paren
id|HostAdapter-&gt;BusSettleTime
)paren
suffix:semicolon
multiline_comment|/*&n;    If this is a Synchronous Reset, perform completion processing for&n;    the Command being Reset.&n;  */
r_if
c_cond
(paren
id|ResetFlags
op_amp
id|SCSI_RESET_SYNCHRONOUS
)paren
(brace
id|Command-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|Command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|Command
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    Perform completion processing for all CCBs marked as Reset.&n;  */
r_for
c_loop
(paren
id|CCB
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|CCB
op_ne
l_int|NULL
suffix:semicolon
id|CCB
op_assign
id|CCB-&gt;NextAll
)paren
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Reset
)paren
(brace
id|Command
op_assign
id|CCB-&gt;Command
suffix:semicolon
id|BusLogic_DeallocateCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
r_while
c_loop
(paren
id|Command
op_ne
l_int|NULL
)paren
(brace
id|SCSI_Command_T
op_star
id|NextCommand
op_assign
id|Command-&gt;reset_chain
suffix:semicolon
id|Command-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|Command-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|Command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|Command
)paren
suffix:semicolon
id|Command
op_assign
id|NextCommand
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
id|HostAdapter-&gt;LastResetAttempted
(braket
id|TargetID
)braket
op_assign
id|jiffies
suffix:semicolon
id|HostAdapter-&gt;LastResetCompleted
(braket
id|TargetID
)braket
op_assign
id|jiffies
suffix:semicolon
)brace
id|Result
op_assign
id|SCSI_RESET_SUCCESS
op_or
id|SCSI_RESET_HOST_RESET
suffix:semicolon
multiline_comment|/*&n;    Release exclusive access to Host Adapter.&n;  */
id|Done
suffix:colon
id|BusLogic_ReleaseHostAdapterLock
c_func
(paren
id|HostAdapter
comma
op_amp
id|ProcessorFlags
)paren
suffix:semicolon
r_return
id|Result
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_SendBusDeviceReset sends a Bus Device Reset to the Target&n;  Device associated with Command.&n;*/
DECL|function|BusLogic_SendBusDeviceReset
r_static
r_int
id|BusLogic_SendBusDeviceReset
c_func
(paren
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
comma
id|SCSI_Command_T
op_star
id|Command
comma
r_int
r_int
id|ResetFlags
)paren
(brace
r_int
id|TargetID
op_assign
id|Command-&gt;target
suffix:semicolon
id|BusLogic_CCB_T
op_star
id|CCB
comma
op_star
id|XCCB
suffix:semicolon
id|ProcessorFlags_T
id|ProcessorFlags
suffix:semicolon
r_int
id|Result
op_assign
op_minus
l_int|1
suffix:semicolon
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;TargetStatistics
(braket
id|TargetID
)braket
dot
id|BusDeviceResetsRequested
)paren
suffix:semicolon
multiline_comment|/*&n;    Acquire exclusive access to Host Adapter.&n;  */
id|BusLogic_AcquireHostAdapterLock
c_func
(paren
id|HostAdapter
comma
op_amp
id|ProcessorFlags
)paren
suffix:semicolon
multiline_comment|/*&n;    If this is an Asynchronous Reset and this Command has already completed,&n;    then no Reset is necessary.&n;  */
r_if
c_cond
(paren
id|ResetFlags
op_amp
id|SCSI_RESET_ASYNCHRONOUS
)paren
(brace
r_if
c_cond
(paren
id|Command-&gt;serial_number
op_ne
id|Command-&gt;serial_number_at_timeout
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Reset Command to Target %d - &quot;
l_string|&quot;Already Completed&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_for
c_loop
(paren
id|CCB
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|CCB
op_ne
l_int|NULL
suffix:semicolon
id|CCB
op_assign
id|CCB-&gt;NextAll
)paren
r_if
c_cond
(paren
id|CCB-&gt;Command
op_eq
id|Command
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Reset Command to Target %d - &quot;
l_string|&quot;No CCB Found&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Completed
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Reset Command to Target %d - &quot;
l_string|&quot;CCB Completed&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Reset
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Reset Command to Target %d - &quot;
l_string|&quot;Reset Pending&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_PENDING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|HostAdapter-&gt;BusDeviceResetPendingCCB
(braket
id|TargetID
)braket
op_ne
l_int|NULL
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Bus Device Reset already pending to Target %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;    If this is a Synchronous Reset and a Bus Device Reset is already pending&n;    for this Target Device, do not send a second one.  Add this Command to&n;    the list of Commands for which completion processing must be performed&n;    when the Bus Device Reset CCB completes.&n;  */
r_if
c_cond
(paren
id|ResetFlags
op_amp
id|SCSI_RESET_SYNCHRONOUS
)paren
r_if
c_cond
(paren
(paren
id|CCB
op_assign
id|HostAdapter-&gt;BusDeviceResetPendingCCB
(braket
id|TargetID
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|Command-&gt;reset_chain
op_assign
id|CCB-&gt;Command
suffix:semicolon
id|CCB-&gt;Command
op_assign
id|Command
suffix:semicolon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Reset Command to Target %d - &quot;
l_string|&quot;Reset Pending&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_PENDING
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_MultiMasterHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
multiline_comment|/*&n;&t;MultiMaster Firmware versions prior to 5.xx treat a Bus Device Reset as&n;&t;a non-tagged command.  Since non-tagged commands are not sent by the&n;&t;Host Adapter until the queue of outstanding tagged commands has&n;&t;completed, it is effectively impossible to send a Bus Device Reset&n;&t;while there are tagged commands outstanding.  Therefore, in that case a&n;&t;full Host Adapter Hard Reset and SCSI Bus Reset must be done.&n;      */
r_if
c_cond
(paren
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TaggedQueuingActive
op_logical_and
id|HostAdapter-&gt;ActiveCommands
(braket
id|TargetID
)braket
OG
l_int|0
op_logical_and
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
OL
l_char|&squot;5&squot;
)paren
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;    Allocate a CCB from the Host Adapter&squot;s free list.  In the unlikely event&n;    that there are none available and memory allocation fails, attempt a full&n;    Host Adapter Hard Reset and SCSI Bus Reset.&n;  */
id|CCB
op_assign
id|BusLogic_AllocateCCB
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
r_goto
id|Done
suffix:semicolon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Sending Bus Device Reset CCB #%ld to Target %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|TargetID
)paren
suffix:semicolon
id|CCB-&gt;Opcode
op_assign
id|BusLogic_BusDeviceReset
suffix:semicolon
id|CCB-&gt;TargetID
op_assign
id|TargetID
suffix:semicolon
multiline_comment|/*&n;    For Synchronous Resets, arrange for the interrupt handler to perform&n;    completion processing for the Command being Reset.&n;  */
r_if
c_cond
(paren
id|ResetFlags
op_amp
id|SCSI_RESET_SYNCHRONOUS
)paren
(brace
id|Command-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|CCB-&gt;Command
op_assign
id|Command
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_MultiMasterHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
multiline_comment|/*&n;&t;Attempt to write an Outgoing Mailbox with the Bus Device Reset CCB.&n;&t;If sending a Bus Device Reset is impossible, attempt a full Host&n;&t;Adapter Hard Reset and SCSI Bus Reset.&n;      */
r_if
c_cond
(paren
op_logical_neg
(paren
id|BusLogic_WriteOutgoingMailbox
c_func
(paren
id|HostAdapter
comma
id|BusLogic_MailboxStartCommand
comma
id|CCB
)paren
)paren
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to write Outgoing Mailbox for &quot;
l_string|&quot;Bus Device Reset&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_DeallocateCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;Call the FlashPoint SCCB Manager to start execution of the CCB.&n;      */
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Active
suffix:semicolon
id|HostAdapter-&gt;ActiveCommands
(braket
id|TargetID
)braket
op_increment
suffix:semicolon
id|FlashPoint_StartCCB
c_func
(paren
id|HostAdapter-&gt;CardHandle
comma
id|CCB
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    If there is a currently executing CCB in the Host Adapter for this Command&n;    (i.e. this is an Asynchronous Reset), then an Incoming Mailbox entry may be&n;    made with a completion code of BusLogic_HostAdapterAssertedBusDeviceReset.&n;    If there is no active CCB for this Command (i.e. this is a Synchronous&n;    Reset), then the Bus Device Reset CCB&squot;s Command field will have been set&n;    to the Command so that the interrupt for the completion of the Bus Device&n;    Reset can call the Completion Routine for the Command.  On successful&n;    execution of a Bus Device Reset, older firmware versions did return the&n;    pending CCBs with the appropriate completion code, but more recent firmware&n;    versions only return the Bus Device Reset CCB itself.  This driver handles&n;    both cases by marking all the currently executing CCBs to this Target&n;    Device as Reset.  When the Bus Device Reset CCB is processed by the&n;    interrupt handler, any remaining CCBs marked as Reset will have completion&n;    processing performed.&n;  */
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;TargetStatistics
(braket
id|TargetID
)braket
dot
id|BusDeviceResetsAttempted
)paren
suffix:semicolon
id|HostAdapter-&gt;BusDeviceResetPendingCCB
(braket
id|TargetID
)braket
op_assign
id|CCB
suffix:semicolon
id|HostAdapter-&gt;LastResetAttempted
(braket
id|TargetID
)braket
op_assign
id|jiffies
suffix:semicolon
r_for
c_loop
(paren
id|XCCB
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|XCCB
op_ne
l_int|NULL
suffix:semicolon
id|XCCB
op_assign
id|XCCB-&gt;NextAll
)paren
r_if
c_cond
(paren
id|XCCB-&gt;Status
op_eq
id|BusLogic_CCB_Active
op_logical_and
id|XCCB-&gt;TargetID
op_eq
id|TargetID
)paren
id|XCCB-&gt;Status
op_assign
id|BusLogic_CCB_Reset
suffix:semicolon
multiline_comment|/*&n;    FlashPoint Host Adapters may have already completed the Bus Device&n;    Reset and BusLogic_QueueCompletedCCB been called, or it may still be&n;    pending.&n;  */
id|Result
op_assign
id|SCSI_RESET_PENDING
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Completed
)paren
(brace
id|BusLogic_ProcessCompletedCCBs
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|Result
op_assign
id|SCSI_RESET_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n;    If a Bus Device Reset was not possible for some reason, force a full&n;    Host Adapter Hard Reset and SCSI Bus Reset.&n;  */
id|Done
suffix:colon
r_if
c_cond
(paren
id|Result
OL
l_int|0
)paren
id|Result
op_assign
id|BusLogic_ResetHostAdapter
c_func
(paren
id|HostAdapter
comma
id|Command
comma
id|ResetFlags
)paren
suffix:semicolon
multiline_comment|/*&n;    Release exclusive access to Host Adapter.&n;  */
id|BusLogic_ReleaseHostAdapterLock
c_func
(paren
id|HostAdapter
comma
op_amp
id|ProcessorFlags
)paren
suffix:semicolon
r_return
id|Result
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ResetCommand takes appropriate action to reset Command.&n;*/
DECL|function|BusLogic_ResetCommand
r_int
id|BusLogic_ResetCommand
c_func
(paren
id|SCSI_Command_T
op_star
id|Command
comma
r_int
r_int
id|ResetFlags
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|Command-&gt;host-&gt;hostdata
suffix:semicolon
r_int
id|TargetID
op_assign
id|Command-&gt;target
suffix:semicolon
id|BusLogic_ErrorRecoveryStrategy_T
id|ErrorRecoveryStrategy
op_assign
id|HostAdapter-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
suffix:semicolon
multiline_comment|/*&n;    Disable Tagged Queuing if it is active for this Target Device and if&n;    it has been less than 10 minutes since the last reset occurred, or since&n;    the system was initialized if no prior resets have occurred.&n;  */
r_if
c_cond
(paren
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TaggedQueuingActive
op_logical_and
id|jiffies
op_minus
id|HostAdapter-&gt;LastResetCompleted
(braket
id|TargetID
)braket
OL
l_int|10
op_star
l_int|60
op_star
id|HZ
)paren
(brace
id|HostAdapter-&gt;TaggedQueuingPermitted
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TargetID
)paren
suffix:semicolon
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TaggedQueuingActive
op_assign
l_bool|false
suffix:semicolon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Tagged Queuing now disabled for Target %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|ErrorRecoveryStrategy
)paren
(brace
r_case
id|BusLogic_ErrorRecovery_Default
suffix:colon
r_if
c_cond
(paren
id|ResetFlags
op_amp
id|SCSI_RESET_SUGGEST_HOST_RESET
)paren
r_return
id|BusLogic_ResetHostAdapter
c_func
(paren
id|HostAdapter
comma
id|Command
comma
id|ResetFlags
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ResetFlags
op_amp
id|SCSI_RESET_SUGGEST_BUS_RESET
)paren
r_return
id|BusLogic_ResetHostAdapter
c_func
(paren
id|HostAdapter
comma
id|Command
comma
id|ResetFlags
)paren
suffix:semicolon
multiline_comment|/* Fall through to Bus Device Reset case. */
r_case
id|BusLogic_ErrorRecovery_BusDeviceReset
suffix:colon
multiline_comment|/*&n;&t;The Bus Device Reset Error Recovery Strategy only graduates to a Hard&n;&t;Reset when no commands have completed successfully since the last Bus&n;&t;Device Reset and it has been at least 100 milliseconds.  This prevents&n;&t;a sequence of commands that all timeout together from immediately&n;&t;forcing a Hard Reset before the Bus Device Reset has had a chance to&n;&t;clear the error condition.&n;      */
r_if
c_cond
(paren
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|CommandSuccessfulFlag
op_logical_or
id|jiffies
op_minus
id|HostAdapter-&gt;LastResetAttempted
(braket
id|TargetID
)braket
OL
id|HZ
op_div
l_int|10
)paren
(brace
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|CommandSuccessfulFlag
op_assign
l_bool|false
suffix:semicolon
r_return
id|BusLogic_SendBusDeviceReset
c_func
(paren
id|HostAdapter
comma
id|Command
comma
id|ResetFlags
)paren
suffix:semicolon
)brace
multiline_comment|/* Fall through to Hard Reset case. */
r_case
id|BusLogic_ErrorRecovery_HardReset
suffix:colon
r_return
id|BusLogic_ResetHostAdapter
c_func
(paren
id|HostAdapter
comma
id|Command
comma
id|ResetFlags
)paren
suffix:semicolon
r_case
id|BusLogic_ErrorRecovery_None
suffix:colon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Error Recovery for Target %d Suppressed&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|SCSI_RESET_PUNT
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_BIOSDiskParameters returns the Heads/Sectors/Cylinders BIOS Disk&n;  Parameters for Disk.  The default disk geometry is 64 heads, 32 sectors, and&n;  the appropriate number of cylinders so as not to exceed drive capacity.  In&n;  order for disks equal to or larger than 1 GB to be addressable by the BIOS&n;  without exceeding the BIOS limitation of 1024 cylinders, Extended Translation&n;  may be enabled in AutoSCSI on FlashPoint Host Adapters and on &quot;W&quot; and &quot;C&quot;&n;  series MultiMaster Host Adapters, or by a dip switch setting on &quot;S&quot; and &quot;A&quot;&n;  series MultiMaster Host Adapters.  With Extended Translation enabled, drives&n;  between 1 GB inclusive and 2 GB exclusive are given a disk geometry of 128&n;  heads and 32 sectors, and drives above 2 GB inclusive are given a disk&n;  geometry of 255 heads and 63 sectors.  However, if the BIOS detects that the&n;  Extended Translation setting does not match the geometry in the partition&n;  table, then the translation inferred from the partition table will be used by&n;  the BIOS, and a warning may be displayed.&n;*/
DECL|function|BusLogic_BIOSDiskParameters
r_int
id|BusLogic_BIOSDiskParameters
c_func
(paren
id|SCSI_Disk_T
op_star
id|Disk
comma
id|KernelDevice_T
id|Device
comma
r_int
op_star
id|Parameters
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
op_assign
(paren
id|BusLogic_HostAdapter_T
op_star
)paren
id|Disk-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
id|BIOS_DiskParameters_T
op_star
id|DiskParameters
op_assign
(paren
id|BIOS_DiskParameters_T
op_star
)paren
id|Parameters
suffix:semicolon
r_struct
id|buffer_head
op_star
id|BufferHead
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;ExtendedTranslationEnabled
op_logical_and
id|Disk-&gt;capacity
op_ge
l_int|2
op_star
l_int|1024
op_star
l_int|1024
multiline_comment|/* 1 GB in 512 byte sectors */
)paren
(brace
r_if
c_cond
(paren
id|Disk-&gt;capacity
op_ge
l_int|4
op_star
l_int|1024
op_star
l_int|1024
multiline_comment|/* 2 GB in 512 byte sectors */
)paren
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|255
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|63
suffix:semicolon
)brace
r_else
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|128
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|32
suffix:semicolon
)brace
)brace
r_else
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|64
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|32
suffix:semicolon
)brace
id|DiskParameters-&gt;Cylinders
op_assign
id|Disk-&gt;capacity
op_div
(paren
id|DiskParameters-&gt;Heads
op_star
id|DiskParameters-&gt;Sectors
)paren
suffix:semicolon
multiline_comment|/*&n;    Attempt to read the first 1024 bytes from the disk device.&n;  */
id|BufferHead
op_assign
id|bread
c_func
(paren
id|MKDEV
c_func
(paren
id|MAJOR
c_func
(paren
id|Device
)paren
comma
id|MINOR
c_func
(paren
id|Device
)paren
op_amp
op_complement
l_int|0x0F
)paren
comma
l_int|0
comma
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BufferHead
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;    If the boot sector partition table flag is valid, search for a partition&n;    table entry whose end_head matches one of the standard BusLogic geometry&n;    translations (64/32, 128/32, or 255/63).&n;  */
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|BufferHead-&gt;b_data
op_plus
l_int|0x1FE
)paren
op_eq
l_int|0xAA55
)paren
(brace
id|PartitionTable_T
op_star
id|FirstPartitionEntry
op_assign
(paren
id|PartitionTable_T
op_star
)paren
(paren
id|BufferHead-&gt;b_data
op_plus
l_int|0x1BE
)paren
suffix:semicolon
id|PartitionTable_T
op_star
id|PartitionEntry
op_assign
id|FirstPartitionEntry
suffix:semicolon
r_int
id|SavedCylinders
op_assign
id|DiskParameters-&gt;Cylinders
comma
id|PartitionNumber
suffix:semicolon
r_int
r_char
id|PartitionEntryEndHead
comma
id|PartitionEntryEndSector
suffix:semicolon
r_for
c_loop
(paren
id|PartitionNumber
op_assign
l_int|0
suffix:semicolon
id|PartitionNumber
OL
l_int|4
suffix:semicolon
id|PartitionNumber
op_increment
)paren
(brace
id|PartitionEntryEndHead
op_assign
id|PartitionEntry-&gt;end_head
suffix:semicolon
id|PartitionEntryEndSector
op_assign
id|PartitionEntry-&gt;end_sector
op_amp
l_int|0x3F
suffix:semicolon
r_if
c_cond
(paren
id|PartitionEntryEndHead
op_eq
l_int|64
op_minus
l_int|1
)paren
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|64
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|32
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PartitionEntryEndHead
op_eq
l_int|128
op_minus
l_int|1
)paren
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|128
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|32
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PartitionEntryEndHead
op_eq
l_int|255
op_minus
l_int|1
)paren
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|255
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|63
suffix:semicolon
r_break
suffix:semicolon
)brace
id|PartitionEntry
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PartitionNumber
op_eq
l_int|4
)paren
(brace
id|PartitionEntryEndHead
op_assign
id|FirstPartitionEntry-&gt;end_head
suffix:semicolon
id|PartitionEntryEndSector
op_assign
id|FirstPartitionEntry-&gt;end_sector
op_amp
l_int|0x3F
suffix:semicolon
)brace
id|DiskParameters-&gt;Cylinders
op_assign
id|Disk-&gt;capacity
op_div
(paren
id|DiskParameters-&gt;Heads
op_star
id|DiskParameters-&gt;Sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PartitionNumber
OL
l_int|4
op_logical_and
id|PartitionEntryEndSector
op_eq
id|DiskParameters-&gt;Sectors
)paren
(brace
r_if
c_cond
(paren
id|DiskParameters-&gt;Cylinders
op_ne
id|SavedCylinders
)paren
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Adopting Geometry %d/%d from Partition Table&bslash;n&quot;
comma
id|HostAdapter
comma
id|DiskParameters-&gt;Heads
comma
id|DiskParameters-&gt;Sectors
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PartitionEntryEndHead
OG
l_int|0
op_logical_or
id|PartitionEntryEndSector
OG
l_int|0
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Warning: Partition Table appears to &quot;
l_string|&quot;have Geometry %d/%d which is&bslash;n&quot;
comma
id|HostAdapter
comma
id|PartitionEntryEndHead
op_plus
l_int|1
comma
id|PartitionEntryEndSector
)paren
suffix:semicolon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;not compatible with current BusLogic &quot;
l_string|&quot;Host Adapter Geometry %d/%d&bslash;n&quot;
comma
id|HostAdapter
comma
id|DiskParameters-&gt;Heads
comma
id|DiskParameters-&gt;Sectors
)paren
suffix:semicolon
)brace
)brace
id|brelse
c_func
(paren
id|BufferHead
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;  BugLogic_ProcDirectoryInfo implements /proc/scsi/BusLogic/&lt;N&gt;.&n;*/
DECL|function|BusLogic_ProcDirectoryInfo
r_int
id|BusLogic_ProcDirectoryInfo
c_func
(paren
r_char
op_star
id|ProcBuffer
comma
r_char
op_star
op_star
id|StartPointer
comma
id|off_t
id|Offset
comma
r_int
id|BytesAvailable
comma
r_int
id|HostNumber
comma
r_int
id|WriteFlag
)paren
(brace
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
suffix:semicolon
id|BusLogic_TargetStatistics_T
op_star
id|TargetStatistics
suffix:semicolon
r_int
id|TargetID
comma
id|Length
suffix:semicolon
r_char
op_star
id|Buffer
suffix:semicolon
r_for
c_loop
(paren
id|HostAdapter
op_assign
id|BusLogic_FirstRegisteredHostAdapter
suffix:semicolon
id|HostAdapter
op_ne
l_int|NULL
suffix:semicolon
id|HostAdapter
op_assign
id|HostAdapter-&gt;Next
)paren
r_if
c_cond
(paren
id|HostAdapter-&gt;HostNumber
op_eq
id|HostNumber
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter
op_eq
l_int|NULL
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;Cannot find Host Adapter for SCSI Host %d&bslash;n&quot;
comma
l_int|NULL
comma
id|HostNumber
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|TargetStatistics
op_assign
id|HostAdapter-&gt;TargetStatistics
suffix:semicolon
r_if
c_cond
(paren
id|WriteFlag
)paren
(brace
id|HostAdapter-&gt;ExternalHostAdapterResets
op_assign
l_int|0
suffix:semicolon
id|HostAdapter-&gt;HostAdapterInternalErrors
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|TargetStatistics
comma
l_int|0
comma
id|BusLogic_MaxTargetDevices
op_star
r_sizeof
(paren
id|BusLogic_TargetStatistics_T
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|Buffer
op_assign
id|HostAdapter-&gt;MessageBuffer
suffix:semicolon
id|Length
op_assign
id|HostAdapter-&gt;MessageBufferLength
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&bslash;n&bslash;&n;Current Driver Queue Depth:&t;%d&bslash;n&bslash;&n;Currently Allocated CCBs:&t;%d&bslash;n&quot;
comma
id|HostAdapter-&gt;DriverQueueDepth
comma
id|HostAdapter-&gt;AllocatedCCBs
)paren
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&bslash;n&bslash;n&bslash;&n;&t;&t;&t;   DATA TRANSFER STATISTICS&bslash;n&bslash;&n;&bslash;n&bslash;&n;Target&t;Tagged Queuing&t;Queue Depth  Active  Attempted&t;Completed&bslash;n&bslash;&n;======&t;==============&t;===========  ======  =========&t;=========&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
id|BusLogic_TargetFlags_T
op_star
id|TargetFlags
op_assign
op_amp
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TargetFlags-&gt;TargetExists
)paren
r_continue
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;  %2d&t;%s&quot;
comma
id|TargetID
comma
(paren
id|TargetFlags-&gt;TaggedQueuingSupported
ques
c_cond
(paren
id|TargetFlags-&gt;TaggedQueuingActive
ques
c_cond
l_string|&quot;    Active&quot;
suffix:colon
(paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
ques
c_cond
l_string|&quot;  Permitted&quot;
suffix:colon
l_string|&quot;   Disabled&quot;
)paren
)paren
suffix:colon
l_string|&quot;Not Supported&quot;
)paren
)paren
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&t;    %3d       %3u    %9u&t;%9u&bslash;n&quot;
comma
id|HostAdapter-&gt;QueueDepth
(braket
id|TargetID
)braket
comma
id|HostAdapter-&gt;ActiveCommands
(braket
id|TargetID
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandsAttempted
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandsCompleted
)paren
suffix:semicolon
)brace
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&bslash;n&bslash;&n;Target  Read Commands  Write Commands   Total Bytes Read    Total Bytes Written&bslash;n&bslash;&n;======  =============  ==============  ===================  ===================&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
id|BusLogic_TargetFlags_T
op_star
id|TargetFlags
op_assign
op_amp
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TargetFlags-&gt;TargetExists
)paren
r_continue
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;  %2d&t;  %9u&t; %9u&quot;
comma
id|TargetID
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommands
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommands
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesRead.Billions
OG
l_int|0
)paren
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;     %9u%09u&quot;
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesRead.Billions
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesRead.Units
)paren
suffix:semicolon
r_else
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&t;&t;%9u&quot;
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesRead.Units
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesWritten.Billions
OG
l_int|0
)paren
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;   %9u%09u&bslash;n&quot;
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesWritten.Billions
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesWritten.Units
)paren
suffix:semicolon
r_else
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&t;     %9u&bslash;n&quot;
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesWritten.Units
)paren
suffix:semicolon
)brace
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&bslash;n&bslash;&n;Target  Command    0-1KB      1-2KB      2-4KB      4-8KB     8-16KB&bslash;n&bslash;&n;======  =======  =========  =========  =========  =========  =========&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
id|BusLogic_TargetFlags_T
op_star
id|TargetFlags
op_assign
op_amp
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TargetFlags-&gt;TargetExists
)paren
r_continue
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;  %2d&t; Read&t; %9u  %9u  %9u  %9u  %9u&bslash;n&quot;
comma
id|TargetID
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|0
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|1
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|2
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|3
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;  %2d&t; Write&t; %9u  %9u  %9u  %9u  %9u&bslash;n&quot;
comma
id|TargetID
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|0
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|1
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|2
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|3
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|4
)braket
)paren
suffix:semicolon
)brace
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&bslash;n&bslash;&n;Target  Command   16-32KB    32-64KB   64-128KB   128-256KB   256KB+&bslash;n&bslash;&n;======  =======  =========  =========  =========  =========  =========&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
id|BusLogic_TargetFlags_T
op_star
id|TargetFlags
op_assign
op_amp
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TargetFlags-&gt;TargetExists
)paren
r_continue
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;  %2d&t; Read&t; %9u  %9u  %9u  %9u  %9u&bslash;n&quot;
comma
id|TargetID
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|5
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|6
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|7
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|8
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|9
)braket
)paren
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;  %2d&t; Write&t; %9u  %9u  %9u  %9u  %9u&bslash;n&quot;
comma
id|TargetID
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|5
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|6
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|7
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|8
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|9
)braket
)paren
suffix:semicolon
)brace
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&bslash;n&bslash;n&bslash;&n;&t;&t;&t;   ERROR RECOVERY STATISTICS&bslash;n&bslash;&n;&bslash;n&bslash;&n;&t;  Command Aborts      Bus Device Resets&t;  Host Adapter Resets&bslash;n&bslash;&n;Target&t;Requested Completed  Requested Completed  Requested Completed&bslash;n&bslash;&n;  ID&t;&bslash;&bslash;&bslash;&bslash;&bslash;&bslash;&bslash;&bslash; Attempted ////  &bslash;&bslash;&bslash;&bslash;&bslash;&bslash;&bslash;&bslash; Attempted ////  &bslash;&bslash;&bslash;&bslash;&bslash;&bslash;&bslash;&bslash; Attempted ////&bslash;n&bslash;&n;======&t; ===== ===== =====    ===== ===== =====&t;   ===== ===== =====&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
id|BusLogic_TargetFlags_T
op_star
id|TargetFlags
op_assign
op_amp
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TargetFlags-&gt;TargetExists
)paren
r_continue
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&bslash;&n;  %2d&t; %5d %5d %5d    %5d %5d %5d&t;   %5d %5d %5d&bslash;n&quot;
comma
id|TargetID
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandAbortsRequested
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandAbortsAttempted
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandAbortsCompleted
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|BusDeviceResetsRequested
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|BusDeviceResetsAttempted
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|BusDeviceResetsCompleted
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|HostAdapterResetsRequested
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|HostAdapterResetsAttempted
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|HostAdapterResetsCompleted
)paren
suffix:semicolon
)brace
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&bslash;nExternal Host Adapter Resets: %d&bslash;n&quot;
comma
id|HostAdapter-&gt;ExternalHostAdapterResets
)paren
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;Host Adapter Internal Errors: %d&bslash;n&quot;
comma
id|HostAdapter-&gt;HostAdapterInternalErrors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Length
op_ge
id|BusLogic_MessageBufferSize
)paren
id|BusLogic_Error
c_func
(paren
l_string|&quot;Message Buffer length %d exceeds size %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|Length
comma
id|BusLogic_MessageBufferSize
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Length
op_sub_assign
id|Offset
)paren
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|Length
op_ge
id|BytesAvailable
)paren
id|Length
op_assign
id|BytesAvailable
suffix:semicolon
id|memcpy
c_func
(paren
id|ProcBuffer
comma
id|HostAdapter-&gt;MessageBuffer
op_plus
id|Offset
comma
id|Length
)paren
suffix:semicolon
op_star
id|StartPointer
op_assign
id|ProcBuffer
suffix:semicolon
r_return
id|Length
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_Message prints Driver Messages.&n;*/
DECL|function|BusLogic_Message
r_static
r_void
id|BusLogic_Message
c_func
(paren
id|BusLogic_MessageLevel_T
id|MessageLevel
comma
r_char
op_star
id|Format
comma
id|BusLogic_HostAdapter_T
op_star
id|HostAdapter
comma
dot
dot
dot
)paren
(brace
r_static
r_char
id|Buffer
(braket
id|BusLogic_LineBufferSize
)braket
suffix:semicolon
r_static
id|boolean
id|BeginningOfLine
op_assign
l_bool|true
suffix:semicolon
id|va_list
id|Arguments
suffix:semicolon
r_int
id|Length
op_assign
l_int|0
suffix:semicolon
id|va_start
c_func
(paren
id|Arguments
comma
id|HostAdapter
)paren
suffix:semicolon
id|Length
op_assign
id|vsprintf
c_func
(paren
id|Buffer
comma
id|Format
comma
id|Arguments
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|Arguments
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MessageLevel
op_eq
id|BusLogic_AnnounceLevel
)paren
(brace
r_static
r_int
id|AnnouncementLines
op_assign
l_int|0
suffix:semicolon
id|strcpy
c_func
(paren
op_amp
id|HostAdapter-&gt;MessageBuffer
(braket
id|HostAdapter-&gt;MessageBufferLength
)braket
comma
id|Buffer
)paren
suffix:semicolon
id|HostAdapter-&gt;MessageBufferLength
op_add_assign
id|Length
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|AnnouncementLines
op_le
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;%sscsi: %s&quot;
comma
id|BusLogic_MessageLevelMap
(braket
id|MessageLevel
)braket
comma
id|Buffer
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|MessageLevel
op_eq
id|BusLogic_InfoLevel
)paren
(brace
id|strcpy
c_func
(paren
op_amp
id|HostAdapter-&gt;MessageBuffer
(braket
id|HostAdapter-&gt;MessageBufferLength
)braket
comma
id|Buffer
)paren
suffix:semicolon
id|HostAdapter-&gt;MessageBufferLength
op_add_assign
id|Length
suffix:semicolon
r_if
c_cond
(paren
id|BeginningOfLine
)paren
(brace
r_if
c_cond
(paren
id|Buffer
(braket
l_int|0
)braket
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_or
id|Length
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%sscsi%d: %s&quot;
comma
id|BusLogic_MessageLevelMap
(braket
id|MessageLevel
)braket
comma
id|HostAdapter-&gt;HostNumber
comma
id|Buffer
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|Buffer
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|BeginningOfLine
)paren
(brace
r_if
c_cond
(paren
id|HostAdapter
op_ne
l_int|NULL
op_logical_and
id|HostAdapter-&gt;HostAdapterInitialized
)paren
id|printk
c_func
(paren
l_string|&quot;%sscsi%d: %s&quot;
comma
id|BusLogic_MessageLevelMap
(braket
id|MessageLevel
)braket
comma
id|HostAdapter-&gt;HostNumber
comma
id|Buffer
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%s%s&quot;
comma
id|BusLogic_MessageLevelMap
(braket
id|MessageLevel
)braket
comma
id|Buffer
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|Buffer
)paren
suffix:semicolon
)brace
id|BeginningOfLine
op_assign
(paren
id|Buffer
(braket
id|Length
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ParseKeyword parses an individual option keyword.  It returns true&n;  and updates the pointer if the keyword is recognized and false otherwise.&n;*/
DECL|function|BusLogic_ParseKeyword
r_static
id|boolean
id|BusLogic_ParseKeyword
c_func
(paren
r_char
op_star
op_star
id|StringPointer
comma
r_char
op_star
id|Keyword
)paren
(brace
r_char
op_star
id|Pointer
op_assign
op_star
id|StringPointer
suffix:semicolon
r_while
c_loop
(paren
op_star
id|Keyword
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
r_char
id|StringChar
op_assign
op_star
id|Pointer
op_increment
suffix:semicolon
r_char
id|KeywordChar
op_assign
op_star
id|Keyword
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|StringChar
op_ge
l_char|&squot;A&squot;
op_logical_and
id|StringChar
op_le
l_char|&squot;Z&squot;
)paren
id|StringChar
op_add_assign
l_char|&squot;a&squot;
op_minus
l_char|&squot;Z&squot;
suffix:semicolon
r_if
c_cond
(paren
id|KeywordChar
op_ge
l_char|&squot;A&squot;
op_logical_and
id|KeywordChar
op_le
l_char|&squot;Z&squot;
)paren
id|KeywordChar
op_add_assign
l_char|&squot;a&squot;
op_minus
l_char|&squot;Z&squot;
suffix:semicolon
r_if
c_cond
(paren
id|StringChar
op_ne
id|KeywordChar
)paren
r_return
l_bool|false
suffix:semicolon
)brace
op_star
id|StringPointer
op_assign
id|Pointer
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ParseDriverOptions handles processing of BusLogic Driver Options&n;  specifications.&n;&n;  BusLogic Driver Options may be specified either via the Linux Kernel Command&n;  Line or via the Loadable Kernel Module Installation Facility.  Driver Options&n;  for multiple host adapters may be specified either by separating the option&n;  strings by a semicolon, or by specifying multiple &quot;BusLogic=&quot; strings on the&n;  command line.  Individual option specifications for a single host adapter are&n;  separated by commas.  The Probing and Debugging Options apply to all host&n;  adapters whereas the remaining options apply individually only to the&n;  selected host adapter.&n;&n;  The BusLogic Driver Probing Options comprise the following:&n;&n;  IO:&lt;integer&gt;&n;&n;    The &quot;IO:&quot; option specifies an ISA I/O Address to be probed for a non-PCI&n;    MultiMaster Host Adapter.  If neither &quot;IO:&quot; nor &quot;NoProbeISA&quot; options are&n;    specified, then the standard list of BusLogic MultiMaster ISA I/O Addresses&n;    will be probed (0x330, 0x334, 0x230, 0x234, 0x130, and 0x134).  Multiple&n;    &quot;IO:&quot; options may be specified to precisely determine the I/O Addresses to&n;    be probed, but the probe order will always follow the standard list.&n;&n;  NoProbe&n;&n;    The &quot;NoProbe&quot; option disables all probing and therefore no BusLogic Host&n;    Adapters will be detected.&n;&n;  NoProbeISA&n;&n;    The &quot;NoProbeISA&quot; option disables probing of the standard BusLogic ISA I/O&n;    Addresses and therefore only PCI MultiMaster and FlashPoint Host Adapters&n;    will be detected.&n;&n;  NoProbePCI&n;&n;    The &quot;NoProbePCI&quot; options disables the interrogation of PCI Configuration&n;    Space and therefore only ISA Multimaster Host Adapters will be detected, as&n;    well as PCI Multimaster Host Adapters that have their ISA Compatible I/O&n;    Port set to &quot;Primary&quot; or &quot;Alternate&quot;.&n;&n;  NoSortPCI&n;&n;    The &quot;NoSortPCI&quot; option forces PCI MultiMaster Host Adapters to be&n;    enumerated in the order provided by the PCI BIOS, ignoring any setting of&n;    the AutoSCSI &quot;Use Bus And Device # For PCI Scanning Seq.&quot; option.&n;&n;  MultiMasterFirst&n;&n;    The &quot;MultiMasterFirst&quot; option forces MultiMaster Host Adapters to be probed&n;    before FlashPoint Host Adapters.  By default, if both FlashPoint and PCI&n;    MultiMaster Host Adapters are present, this driver will probe for&n;    FlashPoint Host Adapters first unless the BIOS primary disk is controlled&n;    by the first PCI MultiMaster Host Adapter, in which case MultiMaster Host&n;    Adapters will be probed first.&n;&n;  FlashPointFirst&n;&n;    The &quot;FlashPointFirst&quot; option forces FlashPoint Host Adapters to be probed&n;    before MultiMaster Host Adapters.&n;&n;  The BusLogic Driver Tagged Queuing Options allow for explicitly specifying&n;  the Queue Depth and whether Tagged Queuing is permitted for each Target&n;  Device (assuming that the Target Device supports Tagged Queuing).  The Queue&n;  Depth is the number of SCSI Commands that are allowed to be concurrently&n;  presented for execution (either to the Host Adapter or Target Device).  Note&n;  that explicitly enabling Tagged Queuing may lead to problems; the option to&n;  enable or disable Tagged Queuing is provided primarily to allow disabling&n;  Tagged Queuing on Target Devices that do not implement it correctly.  The&n;  following options are available:&n;&n;  QueueDepth:&lt;integer&gt;&n;&n;    The &quot;QueueDepth:&quot; or QD:&quot; option specifies the Queue Depth to use for all&n;    Target Devices that support Tagged Queuing, as well as the maximum Queue&n;    Depth for devices that do not support Tagged Queuing.  If no Queue Depth&n;    option is provided, the Queue Depth will be determined automatically based&n;    on the Host Adapter&squot;s Total Queue Depth and the number, type, speed, and&n;    capabilities of the detected Target Devices.  For Host Adapters that&n;    require ISA Bounce Buffers, the Queue Depth is automatically set by default&n;    to BusLogic_TaggedQueueDepthBB or BusLogic_UntaggedQueueDepthBB to avoid&n;    excessive preallocation of DMA Bounce Buffer memory.  Target Devices that&n;    do not support Tagged Queuing always have their Queue Depth set to&n;    BusLogic_UntaggedQueueDepth or BusLogic_UntaggedQueueDepthBB, unless a&n;    lower Queue Depth option is provided.  A Queue Depth of 1 automatically&n;    disables Tagged Queuing.&n;&n;  QueueDepth:[&lt;integer&gt;,&lt;integer&gt;...]&n;&n;    The &quot;QueueDepth:[...]&quot; or &quot;QD:[...]&quot; option specifies the Queue Depth&n;    individually for each Target Device.  If an &lt;integer&gt; is omitted, the&n;    associated Target Device will have its Queue Depth selected automatically.&n;&n;  TaggedQueuing:Default&n;&n;    The &quot;TaggedQueuing:Default&quot; or &quot;TQ:Default&quot; option permits Tagged Queuing&n;    based on the firmware version of the BusLogic Host Adapter and based on&n;    whether the Queue Depth allows queuing multiple commands.&n;&n;  TaggedQueuing:Enable&n;&n;    The &quot;TaggedQueuing:Enable&quot; or &quot;TQ:Enable&quot; option enables Tagged Queuing for&n;    all Target Devices on this Host Adapter, overriding any limitation that&n;    would otherwise be imposed based on the Host Adapter firmware version.&n;&n;  TaggedQueuing:Disable&n;&n;    The &quot;TaggedQueuing:Disable&quot; or &quot;TQ:Disable&quot; option disables Tagged Queuing&n;    for all Target Devices on this Host Adapter.&n;&n;  TaggedQueuing:&lt;Target-Spec&gt;&n;&n;    The &quot;TaggedQueuing:&lt;Target-Spec&gt;&quot; or &quot;TQ:&lt;Target-Spec&gt;&quot; option controls&n;    Tagged Queuing individually for each Target Device.  &lt;Target-Spec&gt; is a&n;    sequence of &quot;Y&quot;, &quot;N&quot;, and &quot;X&quot; characters.  &quot;Y&quot; enables Tagged Queuing, &quot;N&quot;&n;    disables Tagged Queuing, and &quot;X&quot; accepts the default based on the firmware&n;    version.  The first character refers to Target Device 0, the second to&n;    Target Device 1, and so on; if the sequence of &quot;Y&quot;, &quot;N&quot;, and &quot;X&quot; characters&n;    does not cover all the Target Devices, unspecified characters are assumed&n;    to be &quot;X&quot;.&n;&n;  The BusLogic Driver Error Recovery Option allows for explicitly specifying&n;  the Error Recovery action to be performed when BusLogic_ResetCommand is&n;  called due to a SCSI Command failing to complete successfully.  The following&n;  options are available:&n;&n;  ErrorRecovery:Default&n;&n;    The &quot;ErrorRecovery:Default&quot; or &quot;ER:Default&quot; option selects between the Hard&n;    Reset and Bus Device Reset options based on the recommendation of the SCSI&n;    Subsystem.&n;&n;  ErrorRecovery:HardReset&n;&n;    The &quot;ErrorRecovery:HardReset&quot; or &quot;ER:HardReset&quot; option will initiate a Host&n;    Adapter Hard Reset which also causes a SCSI Bus Reset.&n;&n;  ErrorRecovery:BusDeviceReset&n;&n;    The &quot;ErrorRecovery:BusDeviceReset&quot; or &quot;ER:BusDeviceReset&quot; option will send&n;    a Bus Device Reset message to the individual Target Device causing the&n;    error.  If Error Recovery is again initiated for this Target Device and no&n;    SCSI Command to this Target Device has completed successfully since the Bus&n;    Device Reset message was sent, then a Hard Reset will be attempted.&n;&n;  ErrorRecovery:None&n;&n;    The &quot;ErrorRecovery:None&quot; or &quot;ER:None&quot; option suppresses Error Recovery.&n;    This option should only be selected if a SCSI Bus Reset or Bus Device Reset&n;    will cause the Target Device or a critical operation to suffer a complete&n;    and unrecoverable failure.&n;&n;  ErrorRecovery:&lt;Target-Spec&gt;&n;&n;    The &quot;ErrorRecovery:&lt;Target-Spec&gt;&quot; or &quot;ER:&lt;Target-Spec&gt;&quot; option controls&n;    Error Recovery individually for each Target Device.  &lt;Target-Spec&gt; is a&n;    sequence of &quot;D&quot;, &quot;H&quot;, &quot;B&quot;, and &quot;N&quot; characters.  &quot;D&quot; selects Default, &quot;H&quot;&n;    selects Hard Reset, &quot;B&quot; selects Bus Device Reset, and &quot;N&quot; selects None.&n;    The first character refers to Target Device 0, the second to Target Device&n;    1, and so on; if the sequence of &quot;D&quot;, &quot;H&quot;, &quot;B&quot;, and &quot;N&quot; characters does not&n;    cover all the possible Target Devices, unspecified characters are assumed&n;    to be &quot;D&quot;.&n;&n;  The BusLogic Driver Miscellaneous Options comprise the following:&n;&n;  BusSettleTime:&lt;seconds&gt;&n;&n;    The &quot;BusSettleTime:&quot; or &quot;BST:&quot; option specifies the Bus Settle Time in&n;    seconds.  The Bus Settle Time is the amount of time to wait between a Host&n;    Adapter Hard Reset which initiates a SCSI Bus Reset and issuing any SCSI&n;    Commands.  If unspecified, it defaults to BusLogic_DefaultBusSettleTime.&n;&n;  InhibitTargetInquiry&n;&n;    The &quot;InhibitTargetInquiry&quot; option inhibits the execution of an Inquire&n;    Target Devices or Inquire Installed Devices command on MultiMaster Host&n;    Adapters.  This may be necessary with some older Target Devices that do not&n;    respond correctly when Logical Units above 0 are addressed.&n;&n;  The BusLogic Driver Debugging Options comprise the following:&n;&n;  TraceProbe&n;&n;    The &quot;TraceProbe&quot; option enables tracing of Host Adapter Probing.&n;&n;  TraceHardwareReset&n;&n;    The &quot;TraceHardwareReset&quot; option enables tracing of Host Adapter Hardware&n;    Reset.&n;&n;  TraceConfiguration&n;&n;    The &quot;TraceConfiguration&quot; option enables tracing of Host Adapter&n;    Configuration.&n;&n;  TraceErrors&n;&n;    The &quot;TraceErrors&quot; option enables tracing of SCSI Commands that return an&n;    error from the Target Device.  The CDB and Sense Data will be printed for&n;    each SCSI Command that fails.&n;&n;  Debug&n;&n;    The &quot;Debug&quot; option enables all debugging options.&n;&n;  The following examples demonstrate setting the Queue Depth for Target Devices&n;  1 and 2 on the first host adapter to 7 and 15, the Queue Depth for all Target&n;  Devices on the second host adapter to 31, and the Bus Settle Time on the&n;  second host adapter to 30 seconds.&n;&n;  Linux Kernel Command Line:&n;&n;    linux BusLogic=QueueDepth:[,7,15];QueueDepth:31,BusSettleTime:30&n;&n;  LILO Linux Boot Loader (in /etc/lilo.conf):&n;&n;    append = &quot;BusLogic=QueueDepth:[,7,15];QueueDepth:31,BusSettleTime:30&quot;&n;&n;  INSMOD Loadable Kernel Module Installation Facility:&n;&n;    insmod BusLogic.o &bslash;&n;&t;&squot;BusLogic=&quot;QueueDepth:[,7,15];QueueDepth:31,BusSettleTime:30&quot;&squot;&n;&n;  NOTE: Module Utilities 2.1.71 or later is required for correct parsing&n;&t;of driver options containing commas.&n;&n;*/
DECL|function|BusLogic_ParseDriverOptions
r_static
r_int
id|__init
id|BusLogic_ParseDriverOptions
c_func
(paren
r_char
op_star
id|OptionsString
)paren
(brace
r_while
c_loop
(paren
l_bool|true
)paren
(brace
id|BusLogic_DriverOptions_T
op_star
id|DriverOptions
op_assign
op_amp
id|BusLogic_DriverOptions
(braket
id|BusLogic_DriverOptionsCount
op_increment
)braket
suffix:semicolon
r_int
id|TargetID
suffix:semicolon
id|memset
c_func
(paren
id|DriverOptions
comma
l_int|0
comma
r_sizeof
(paren
id|BusLogic_DriverOptions_T
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|DriverOptions-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
op_assign
id|BusLogic_ErrorRecovery_Default
suffix:semicolon
r_while
c_loop
(paren
op_star
id|OptionsString
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
op_star
id|OptionsString
op_ne
l_char|&squot;;&squot;
)paren
(brace
multiline_comment|/* Probing Options. */
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;IO:&quot;
)paren
)paren
(brace
id|BusLogic_IO_Address_T
id|IO_Address
op_assign
id|simple_strtoul
c_func
(paren
id|OptionsString
comma
op_amp
id|OptionsString
comma
l_int|0
)paren
suffix:semicolon
id|BusLogic_ProbeOptions.LimitedProbeISA
op_assign
l_bool|true
suffix:semicolon
r_switch
c_cond
(paren
id|IO_Address
)paren
(brace
r_case
l_int|0x330
suffix:colon
id|BusLogic_ProbeOptions.Probe330
op_assign
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x334
suffix:colon
id|BusLogic_ProbeOptions.Probe334
op_assign
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x230
suffix:colon
id|BusLogic_ProbeOptions.Probe230
op_assign
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x234
suffix:colon
id|BusLogic_ProbeOptions.Probe234
op_assign
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x130
suffix:colon
id|BusLogic_ProbeOptions.Probe130
op_assign
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x134
suffix:colon
id|BusLogic_ProbeOptions.Probe134
op_assign
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Invalid Driver Options &quot;
l_string|&quot;(illegal I/O Address 0x%X)&bslash;n&quot;
comma
l_int|NULL
comma
id|IO_Address
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;NoProbeISA&quot;
)paren
)paren
id|BusLogic_ProbeOptions.NoProbeISA
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;NoProbePCI&quot;
)paren
)paren
id|BusLogic_ProbeOptions.NoProbePCI
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;NoProbe&quot;
)paren
)paren
id|BusLogic_ProbeOptions.NoProbe
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;NoSortPCI&quot;
)paren
)paren
id|BusLogic_ProbeOptions.NoSortPCI
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;MultiMasterFirst&quot;
)paren
)paren
id|BusLogic_ProbeOptions.MultiMasterFirst
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;FlashPointFirst&quot;
)paren
)paren
id|BusLogic_ProbeOptions.FlashPointFirst
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/* Tagged Queuing Options. */
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;QueueDepth:[&quot;
)paren
op_logical_or
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;QD:[&quot;
)paren
)paren
(brace
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
r_int
r_int
id|QueueDepth
op_assign
id|simple_strtoul
c_func
(paren
id|OptionsString
comma
op_amp
id|OptionsString
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|QueueDepth
OG
id|BusLogic_MaxTaggedQueueDepth
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Invalid Driver Options &quot;
l_string|&quot;(illegal Queue Depth %d)&bslash;n&quot;
comma
l_int|NULL
comma
id|QueueDepth
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DriverOptions-&gt;QueueDepth
(braket
id|TargetID
)braket
op_assign
id|QueueDepth
suffix:semicolon
r_if
c_cond
(paren
op_star
id|OptionsString
op_eq
l_char|&squot;,&squot;
)paren
id|OptionsString
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|OptionsString
op_eq
l_char|&squot;]&squot;
)paren
r_break
suffix:semicolon
r_else
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Invalid Driver Options &quot;
l_string|&quot;(&squot;,&squot; or &squot;]&squot; expected at &squot;%s&squot;)&bslash;n&quot;
comma
l_int|NULL
comma
id|OptionsString
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_star
id|OptionsString
op_ne
l_char|&squot;]&squot;
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Invalid Driver Options &quot;
l_string|&quot;(&squot;]&squot; expected at &squot;%s&squot;)&bslash;n&quot;
comma
l_int|NULL
comma
id|OptionsString
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|OptionsString
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;QueueDepth:&quot;
)paren
op_logical_or
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;QD:&quot;
)paren
)paren
(brace
r_int
r_int
id|QueueDepth
op_assign
id|simple_strtoul
c_func
(paren
id|OptionsString
comma
op_amp
id|OptionsString
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|QueueDepth
op_eq
l_int|0
op_logical_or
id|QueueDepth
OG
id|BusLogic_MaxTaggedQueueDepth
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Invalid Driver Options &quot;
l_string|&quot;(illegal Queue Depth %d)&bslash;n&quot;
comma
l_int|NULL
comma
id|QueueDepth
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DriverOptions-&gt;CommonQueueDepth
op_assign
id|QueueDepth
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|DriverOptions-&gt;QueueDepth
(braket
id|TargetID
)braket
op_assign
id|QueueDepth
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;TaggedQueuing:&quot;
)paren
op_logical_or
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;TQ:&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;Default&quot;
)paren
)paren
(brace
id|DriverOptions-&gt;TaggedQueuingPermitted
op_assign
l_int|0x0000
suffix:semicolon
id|DriverOptions-&gt;TaggedQueuingPermittedMask
op_assign
l_int|0x0000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;Enable&quot;
)paren
)paren
(brace
id|DriverOptions-&gt;TaggedQueuingPermitted
op_assign
l_int|0xFFFF
suffix:semicolon
id|DriverOptions-&gt;TaggedQueuingPermittedMask
op_assign
l_int|0xFFFF
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;Disable&quot;
)paren
)paren
(brace
id|DriverOptions-&gt;TaggedQueuingPermitted
op_assign
l_int|0x0000
suffix:semicolon
id|DriverOptions-&gt;TaggedQueuingPermittedMask
op_assign
l_int|0xFFFF
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|TargetBit
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
comma
id|TargetBit
op_assign
l_int|1
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
comma
id|TargetBit
op_lshift_assign
l_int|1
)paren
r_switch
c_cond
(paren
op_star
id|OptionsString
op_increment
)paren
(brace
r_case
l_char|&squot;Y&squot;
suffix:colon
id|DriverOptions-&gt;TaggedQueuingPermitted
op_or_assign
id|TargetBit
suffix:semicolon
id|DriverOptions-&gt;TaggedQueuingPermittedMask
op_or_assign
id|TargetBit
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;N&squot;
suffix:colon
id|DriverOptions-&gt;TaggedQueuingPermitted
op_and_assign
op_complement
id|TargetBit
suffix:semicolon
id|DriverOptions-&gt;TaggedQueuingPermittedMask
op_or_assign
id|TargetBit
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;X&squot;
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|OptionsString
op_decrement
suffix:semicolon
id|TargetID
op_assign
id|BusLogic_MaxTargetDevices
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Error Recovery Option. */
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;ErrorRecovery:&quot;
)paren
op_logical_or
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;ER:&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;Default&quot;
)paren
)paren
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|DriverOptions-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
op_assign
id|BusLogic_ErrorRecovery_Default
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;HardReset&quot;
)paren
)paren
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|DriverOptions-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
op_assign
id|BusLogic_ErrorRecovery_HardReset
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;BusDeviceReset&quot;
)paren
)paren
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|DriverOptions-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
op_assign
id|BusLogic_ErrorRecovery_BusDeviceReset
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;None&quot;
)paren
)paren
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|DriverOptions-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
op_assign
id|BusLogic_ErrorRecovery_None
suffix:semicolon
r_else
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
r_switch
c_cond
(paren
op_star
id|OptionsString
op_increment
)paren
(brace
r_case
l_char|&squot;D&squot;
suffix:colon
id|DriverOptions-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
op_assign
id|BusLogic_ErrorRecovery_Default
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;H&squot;
suffix:colon
id|DriverOptions-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
op_assign
id|BusLogic_ErrorRecovery_HardReset
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;B&squot;
suffix:colon
id|DriverOptions-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
op_assign
id|BusLogic_ErrorRecovery_BusDeviceReset
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;N&squot;
suffix:colon
id|DriverOptions-&gt;ErrorRecoveryStrategy
(braket
id|TargetID
)braket
op_assign
id|BusLogic_ErrorRecovery_None
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|OptionsString
op_decrement
suffix:semicolon
id|TargetID
op_assign
id|BusLogic_MaxTargetDevices
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Miscellaneous Options. */
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;BusSettleTime:&quot;
)paren
op_logical_or
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;BST:&quot;
)paren
)paren
(brace
r_int
r_int
id|BusSettleTime
op_assign
id|simple_strtoul
c_func
(paren
id|OptionsString
comma
op_amp
id|OptionsString
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusSettleTime
OG
l_int|5
op_star
l_int|60
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Invalid Driver Options &quot;
l_string|&quot;(illegal Bus Settle Time %d)&bslash;n&quot;
comma
l_int|NULL
comma
id|BusSettleTime
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DriverOptions-&gt;BusSettleTime
op_assign
id|BusSettleTime
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;InhibitTargetInquiry&quot;
)paren
)paren
id|DriverOptions-&gt;LocalOptions.InhibitTargetInquiry
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/* Debugging Options. */
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;TraceProbe&quot;
)paren
)paren
id|BusLogic_GlobalOptions.TraceProbe
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;TraceHardwareReset&quot;
)paren
)paren
id|BusLogic_GlobalOptions.TraceHardwareReset
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;TraceConfiguration&quot;
)paren
)paren
id|BusLogic_GlobalOptions.TraceConfiguration
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;TraceErrors&quot;
)paren
)paren
id|BusLogic_GlobalOptions.TraceErrors
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;Debug&quot;
)paren
)paren
(brace
id|BusLogic_GlobalOptions.TraceProbe
op_assign
l_bool|true
suffix:semicolon
id|BusLogic_GlobalOptions.TraceHardwareReset
op_assign
l_bool|true
suffix:semicolon
id|BusLogic_GlobalOptions.TraceConfiguration
op_assign
l_bool|true
suffix:semicolon
id|BusLogic_GlobalOptions.TraceErrors
op_assign
l_bool|true
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|OptionsString
op_eq
l_char|&squot;,&squot;
)paren
id|OptionsString
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|OptionsString
op_ne
l_char|&squot;;&squot;
op_logical_and
op_star
id|OptionsString
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Unexpected Driver Option &squot;%s&squot; &quot;
l_string|&quot;ignored&bslash;n&quot;
comma
l_int|NULL
comma
id|OptionsString
)paren
suffix:semicolon
op_star
id|OptionsString
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|BusLogic_DriverOptionsCount
op_eq
l_int|0
op_logical_or
id|BusLogic_ProbeInfoCount
op_eq
l_int|0
op_logical_or
id|BusLogic_DriverOptionsCount
op_eq
id|BusLogic_ProbeInfoCount
)paren
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Invalid Driver Options &quot;
l_string|&quot;(all or no I/O Addresses must be specified)&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Tagged Queuing is disabled when the Queue Depth is 1 since queuing&n;&t;multiple commands is not possible.&n;      */
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
r_if
c_cond
(paren
id|DriverOptions-&gt;QueueDepth
(braket
id|TargetID
)braket
op_eq
l_int|1
)paren
(brace
r_int
r_int
id|TargetBit
op_assign
l_int|1
op_lshift
id|TargetID
suffix:semicolon
id|DriverOptions-&gt;TaggedQueuingPermitted
op_and_assign
op_complement
id|TargetBit
suffix:semicolon
id|DriverOptions-&gt;TaggedQueuingPermittedMask
op_or_assign
id|TargetBit
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|OptionsString
op_eq
l_char|&squot;;&squot;
)paren
id|OptionsString
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|OptionsString
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_Setup handles processing of Kernel Command Line Arguments.&n;*/
r_static
r_int
id|__init
DECL|function|BusLogic_Setup
id|BusLogic_Setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|ints
(braket
l_int|3
)braket
suffix:semicolon
(paren
r_void
)paren
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Obsolete Command Line Entry &quot;
l_string|&quot;Format Ignored&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|str
op_eq
l_int|NULL
op_logical_or
op_star
id|str
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|BusLogic_ParseDriverOptions
c_func
(paren
id|str
)paren
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;BusLogic=&quot;
comma
id|BusLogic_Setup
)paren
suffix:semicolon
multiline_comment|/*&n;  Get it all started&n;*/
DECL|variable|driver_template
r_static
id|SCSI_Host_Template_T
id|driver_template
op_assign
id|BUSLOGIC
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
eof
