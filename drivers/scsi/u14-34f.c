multiline_comment|/*&n; *      u14-34f.c - Low-level driver for UltraStor 14F/34F SCSI host adapters.&n; *&n; *      01 Nov 2000 Rev. 6.02 for linux 2.4.0-test11&n; *        + Removed old scsi error handling support.&n; *        + The obsolete boot option flag eh:n is silently ignored.&n; *        + Removed error messages while a disk drive is powered up at&n; *          boot time.&n; *        + Improved boot messages: all tagged capable device are&n; *          indicated as &quot;tagged&quot;.&n; *&n; *      16 Sep 1999 Rev. 5.11 for linux 2.2.12 and 2.3.18&n; *        + Updated to the new __setup interface for boot command line options.&n; *        + When loaded as a module, accepts the new parameter boot_options&n; *          which value is a string with the same format of the kernel boot&n; *          command line options. A valid example is:&n; *          modprobe u14-34f boot_options=&bslash;&quot;0x230,0x340,lc:y,mq:4&bslash;&quot;&n; *&n; *      22 Jul 1999 Rev. 5.00 for linux 2.2.10 and 2.3.11&n; *        + Removed pre-2.2 source code compatibility.&n; *&n; *      26 Jul 1998 Rev. 4.33 for linux 2.0.35 and 2.1.111&n; *          Added command line option (et:[y|n]) to use the existing&n; *          translation (returned by scsicam_bios_param) as disk geometry.&n; *          The default is et:n, which uses the disk geometry jumpered&n; *          on the board.&n; *          The default value et:n is compatible with all previous revisions&n; *          of this driver.&n; *&n; *      28 May 1998 Rev. 4.32 for linux 2.0.33 and 2.1.104&n; *          Increased busy timeout from 10 msec. to 200 msec. while&n; *          processing interrupts.&n; *&n; *      18 May 1998 Rev. 4.31 for linux 2.0.33 and 2.1.102&n; *          Improved abort handling during the eh recovery process.&n; *&n; *      13 May 1998 Rev. 4.30 for linux 2.0.33 and 2.1.101&n; *          The driver is now fully SMP safe, including the&n; *          abort and reset routines.&n; *          Added command line options (eh:[y|n]) to choose between&n; *          new_eh_code and the old scsi code.&n; *          If linux version &gt;= 2.1.101 the default is eh:y, while the eh&n; *          option is ignored for previous releases and the old scsi code&n; *          is used.&n; *&n; *      18 Apr 1998 Rev. 4.20 for linux 2.0.33 and 2.1.97&n; *          Reworked interrupt handler.&n; *&n; *      11 Apr 1998 rev. 4.05 for linux 2.0.33 and 2.1.95&n; *          Major reliability improvement: when a batch with overlapping&n; *          requests is detected, requests are queued one at a time&n; *          eliminating any possible board or drive reordering.&n; *&n; *      10 Apr 1998 rev. 4.04 for linux 2.0.33 and 2.1.95&n; *          Improved SMP support (if linux version &gt;= 2.1.95).&n; *&n; *       9 Apr 1998 rev. 4.03 for linux 2.0.33 and 2.1.94&n; *          Performance improvement: when sequential i/o is detected,&n; *          always use direct sort instead of reverse sort.&n; *&n; *       4 Apr 1998 rev. 4.02 for linux 2.0.33 and 2.1.92&n; *          io_port is now unsigned long.&n; *&n; *      17 Mar 1998 rev. 4.01 for linux 2.0.33 and 2.1.88&n; *          Use new scsi error handling code (if linux version &gt;= 2.1.88).&n; *          Use new interrupt code.&n; *&n; *      12 Sep 1997 rev. 3.11 for linux 2.0.30 and 2.1.55&n; *          Use of udelay inside the wait loops to avoid timeout&n; *          problems with fast cpus.&n; *          Removed check about useless calls to the interrupt service&n; *          routine (reported on SMP systems only).&n; *          At initialization time &quot;sorted/unsorted&quot; is displayed instead&n; *          of &quot;linked/unlinked&quot; to reinforce the fact that &quot;linking&quot; is&n; *          nothing but &quot;elevator sorting&quot; in the actual implementation.&n; *&n; *      17 May 1997 rev. 3.10 for linux 2.0.30 and 2.1.38&n; *          Use of serial_number_at_timeout in abort and reset processing.&n; *          Use of the __initfunc and __initdata macro in setup code.&n; *          Minor cleanups in the list_statistics code.&n; *&n; *      24 Feb 1997 rev. 3.00 for linux 2.0.29 and 2.1.26&n; *          When loading as a module, parameter passing is now supported&n; *          both in 2.0 and in 2.1 style.&n; *          Fixed data transfer direction for some SCSI opcodes.&n; *          Immediate acknowledge to request sense commands.&n; *          Linked commands to each disk device are now reordered by elevator&n; *          sorting. Rare cases in which reordering of write requests could&n; *          cause wrong results are managed.&n; *&n; *      18 Jan 1997 rev. 2.60 for linux 2.1.21 and 2.0.28&n; *          Added command line options to enable/disable linked commands&n; *          (lc:[y|n]), old firmware support (of:[y|n]) and to set the max&n; *          queue depth (mq:xx). Default is &quot;u14-34f=lc:n,of:n,mq:8&quot;.&n; *          Improved command linking.&n; *&n; *       8 Jan 1997 rev. 2.50 for linux 2.1.20 and 2.0.27&n; *          Added linked command support.&n; *&n; *       3 Dec 1996 rev. 2.40 for linux 2.1.14 and 2.0.27&n; *          Added queue depth adjustment.&n; *&n; *      22 Nov 1996 rev. 2.30 for linux 2.1.12 and 2.0.26&n; *          The list of i/o ports to be probed can be overwritten by the&n; *          &quot;u14-34f=port0,port1,....&quot; boot command line option.&n; *          Scatter/gather lists are now allocated by a number of kmalloc&n; *          calls, in order to avoid the previous size limit of 64Kb.&n; *&n; *      16 Nov 1996 rev. 2.20 for linux 2.1.10 and 2.0.25&n; *          Added multichannel support.&n; *&n; *      27 Sep 1996 rev. 2.12 for linux 2.1.0&n; *          Portability cleanups (virtual/bus addressing, little/big endian&n; *          support).&n; *&n; *      09 Jul 1996 rev. 2.11 for linux 2.0.4&n; *          &quot;Data over/under-run&quot; no longer implies a redo on all targets.&n; *          Number of internal retries is now limited.&n; *&n; *      16 Apr 1996 rev. 2.10 for linux 1.3.90&n; *          New argument &quot;reset_flags&quot; to the reset routine.&n; *&n; *      21 Jul 1995 rev. 2.02 for linux 1.3.11&n; *          Fixed Data Transfer Direction for some SCSI commands.&n; *&n; *      13 Jun 1995 rev. 2.01 for linux 1.2.10&n; *          HAVE_OLD_UX4F_FIRMWARE should be defined for U34F boards when&n; *          the firmware prom is not the latest one (28008-006).&n; *&n; *      11 Mar 1995 rev. 2.00 for linux 1.2.0&n; *          Fixed a bug which prevented media change detection for removable&n; *          disk drives.&n; *&n; *      23 Feb 1995 rev. 1.18 for linux 1.1.94&n; *          Added a check for scsi_register returning NULL.&n; *&n; *      11 Feb 1995 rev. 1.17 for linux 1.1.91&n; *          U14F qualified to run with 32 sglists.&n; *          Now DEBUG_RESET is disabled by default.&n; *&n; *       9 Feb 1995 rev. 1.16 for linux 1.1.90&n; *          Use host-&gt;wish_block instead of host-&gt;block.&n; *&n; *       8 Feb 1995 rev. 1.15 for linux 1.1.89&n; *          Cleared target_time_out counter while performing a reset.&n; *&n; *      28 Jan 1995 rev. 1.14 for linux 1.1.86&n; *          Added module support.&n; *          Log and do a retry when a disk drive returns a target status&n; *          different from zero on a recovered error.&n; *          Auto detects if U14F boards have an old firmware revision.&n; *          Max number of scatter/gather lists set to 16 for all boards&n; *          (most installation run fine using 33 sglists, while other&n; *          has problems when using more then 16).&n; *&n; *      16 Jan 1995 rev. 1.13 for linux 1.1.81&n; *          Display a message if check_region detects a port address&n; *          already in use.&n; *&n; *      15 Dec 1994 rev. 1.12 for linux 1.1.74&n; *          The host-&gt;block flag is set for all the detected ISA boards.&n; *&n; *      30 Nov 1994 rev. 1.11 for linux 1.1.68&n; *          Redo i/o on target status CHECK_CONDITION for TYPE_DISK only.&n; *          Added optional support for using a single board at a time.&n; *&n; *      14 Nov 1994 rev. 1.10 for linux 1.1.63&n; *&n; *      28 Oct 1994 rev. 1.09 for linux 1.1.58  Final BETA release.&n; *      16 Jul 1994 rev. 1.00 for linux 1.1.29  Initial ALPHA release.&n; *&n; *          This driver is a total replacement of the original UltraStor&n; *          scsi driver, but it supports ONLY the 14F and 34F boards.&n; *          It can be configured in the same kernel in which the original&n; *          ultrastor driver is configured to allow the original U24F&n; *          support.&n; *&n; *          Multiple U14F and/or U34F host adapters are supported.&n; *&n; *  Copyright (C) 1994-2000 Dario Ballabio (ballabio_dario@emc.com)&n; *&n; *  Alternate email: dario.ballabio@inwind.it, dario.ballabio@tiscalinet.it&n; *&n; *  Redistribution and use in source and binary forms, with or without&n; *  modification, are permitted provided that redistributions of source&n; *  code retain the above copyright notice and this comment without&n; *  modification.&n; *&n; *      WARNING: if your 14/34F board has an old firmware revision (see below)&n; *               you must change &quot;#undef&quot; into &quot;#define&quot; in the following&n; *               statement.&n; */
DECL|macro|HAVE_OLD_UX4F_FIRMWARE
macro_line|#undef HAVE_OLD_UX4F_FIRMWARE
multiline_comment|/*&n; *  The UltraStor 14F, 24F, and 34F are a family of intelligent, high&n; *  performance SCSI-2 host adapters.&n; *  Here is the scoop on the various models:&n; *&n; *  14F - ISA first-party DMA HA with floppy support and WD1003 emulation.&n; *  24F - EISA Bus Master HA with floppy support and WD1003 emulation.&n; *  34F - VESA Local-Bus Bus Master HA (no WD1003 emulation).&n; *&n; *  This code has been tested with up to two U14F boards, using both&n; *  firmware 28004-005/38004-004 (BIOS rev. 2.00) and the latest firmware&n; *  28004-006/38004-005 (BIOS rev. 2.01).&n; *&n; *  The latest firmware is required in order to get reliable operations when&n; *  clustering is enabled. ENABLE_CLUSTERING provides a performance increase&n; *  up to 50% on sequential access.&n; *&n; *  Since the Scsi_Host_Template structure is shared among all 14F and 34F,&n; *  the last setting of use_clustering is in effect for all of these boards.&n; *&n; *  Here a sample configuration using two U14F boards:&n; *&n; U14F0: ISA 0x330, BIOS 0xc8000, IRQ 11, DMA 5, SG 32, MB 16, of:n, lc:y, mq:8.&n; U14F1: ISA 0x340, BIOS 0x00000, IRQ 10, DMA 6, SG 32, MB 16, of:n, lc:y, mq:8.&n; *&n; *  The boot controller must have its BIOS enabled, while other boards can&n; *  have their BIOS disabled, or enabled to an higher address.&n; *  Boards are named Ux4F0, Ux4F1..., according to the port address order in&n; *  the io_port[] array.&n; *&n; *  The following facts are based on real testing results (not on&n; *  documentation) on the above U14F board.&n; *&n; *  - The U14F board should be jumpered for bus on time less or equal to 7&n; *    microseconds, while the default is 11 microseconds. This is order to&n; *    get acceptable performance while using floppy drive and hard disk&n; *    together. The jumpering for 7 microseconds is: JP13 pin 15-16,&n; *    JP14 pin 7-8 and pin 9-10.&n; *    The reduction has a little impact on scsi performance.&n; *&n; *  - If scsi bus length exceeds 3m., the scsi bus speed needs to be reduced&n; *    from 10Mhz to 5Mhz (do this by inserting a jumper on JP13 pin 7-8).&n; *&n; *  - If U14F on board firmware is older than 28004-006/38004-005,&n; *    the U14F board is unable to provide reliable operations if the scsi&n; *    request length exceeds 16Kbyte. When this length is exceeded the&n; *    behavior is:&n; *    - adapter_status equal 0x96 or 0xa3 or 0x93 or 0x94;&n; *    - adapter_status equal 0 and target_status equal 2 on for all targets&n; *      in the next operation following the reset.&n; *    This sequence takes a long time (&gt;3 seconds), so in the meantime&n; *    the SD_TIMEOUT in sd.c could expire giving rise to scsi aborts&n; *    (SD_TIMEOUT has been increased from 3 to 6 seconds in 1.1.31).&n; *    Because of this I had to DISABLE_CLUSTERING and to work around the&n; *    bus reset in the interrupt service routine, returning DID_BUS_BUSY&n; *    so that the operations are retried without complains from the scsi.c&n; *    code.&n; *    Any reset of the scsi bus is going to kill tape operations, since&n; *    no retry is allowed for tapes. Bus resets are more likely when the&n; *    scsi bus is under heavy load.&n; *    Requests using scatter/gather have a maximum length of 16 x 1024 bytes&n; *    when DISABLE_CLUSTERING is in effect, but unscattered requests could be&n; *    larger than 16Kbyte.&n; *&n; *    The new firmware has fixed all the above problems.&n; *&n; *  For U34F boards the latest bios prom is 38008-002 (BIOS rev. 2.01),&n; *  the latest firmware prom is 28008-006. Older firmware 28008-005 has&n; *  problems when using more then 16 scatter/gather lists.&n; *&n; *  The list of i/o ports to be probed can be totally replaced by the&n; *  boot command line option: &quot;u14-34f=port0,port1,port2,...&quot;, where the&n; *  port0, port1... arguments are ISA/VESA addresses to be probed.&n; *  For example using &quot;u14-34f=0x230,0x340&quot;, the driver probes only the two&n; *  addresses 0x230 and 0x340 in this order; &quot;u14-34f=0&quot; totally disables&n; *  this driver.&n; *&n; *  After the optional list of detection probes, other possible command line&n; *  options are:&n; *&n; *  et:y  use disk geometry returned by scsicam_bios_param;&n; *  et:n  use disk geometry jumpered on the board;&n; *  lc:y  enables linked commands;&n; *  lc:n  disables linked commands;&n; *  of:y  enables old firmware support;&n; *  of:n  disables old firmware support;&n; *  mq:xx set the max queue depth to the value xx (2 &lt;= xx &lt;= 8).&n; *&n; *  The default value is: &quot;u14-34f=lc:n,of:n,mq:8,et:n&quot;.&n; *  An example using the list of detection probes could be:&n; *  &quot;u14-34f=0x230,0x340,lc:y,of:n,mq:4,et:n&quot;.&n; *&n; *  When loading as a module, parameters can be specified as well.&n; *  The above example would be (use 1 in place of y and 0 in place of n):&n; *&n; *  modprobe u14-34f io_port=0x230,0x340 linked_comm=1 have_old_firmware=0 &bslash;&n; *                max_queue_depth=4 ext_tran=0&n; *&n; *  ----------------------------------------------------------------------------&n; *  In this implementation, linked commands are designed to work with any DISK&n; *  or CD-ROM, since this linking has only the intent of clustering (time-wise)&n; *  and reordering by elevator sorting commands directed to each device,&n; *  without any relation with the actual SCSI protocol between the controller&n; *  and the device.&n; *  If Q is the queue depth reported at boot time for each device (also named&n; *  cmds/lun) and Q &gt; 2, whenever there is already an active command to the&n; *  device all other commands to the same device  (up to Q-1) are kept waiting&n; *  in the elevator sorting queue. When the active command completes, the&n; *  commands in this queue are sorted by sector address. The sort is chosen&n; *  between increasing or decreasing by minimizing the seek distance between&n; *  the sector of the commands just completed and the sector of the first&n; *  command in the list to be sorted.&n; *  Trivial math assures that the unsorted average seek distance when doing&n; *  random seeks over S sectors is S/3.&n; *  When (Q-1) requests are uniformly distributed over S sectors, the average&n; *  distance between two adjacent requests is S/((Q-1) + 1), so the sorted&n; *  average seek distance for (Q-1) random requests over S sectors is S/Q.&n; *  The elevator sorting hence divides the seek distance by a factor Q/3.&n; *  The above pure geometric remarks are valid in all cases and the&n; *  driver effectively reduces the seek distance by the predicted factor&n; *  when there are Q concurrent read i/o operations on the device, but this&n; *  does not necessarily results in a noticeable performance improvement:&n; *  your mileage may vary....&n; *&n; *  Note: command reordering inside a batch of queued commands could cause&n; *        wrong results only if there is at least one write request and the&n; *        intersection (sector-wise) of all requests is not empty.&n; *        When the driver detects a batch including overlapping requests&n; *        (a really rare event) strict serial (pid) order is enforced.&n; *  ----------------------------------------------------------------------------&n; *&n; *  The boards are named Ux4F0, Ux4F1,... according to the detection order.&n; *&n; *  In order to support multiple ISA boards in a reliable way,&n; *  the driver sets host-&gt;wish_block = TRUE for all ISA boards.&n; */
macro_line|#include &lt;linux/version.h&gt;
macro_line|#ifndef LinuxVersionCode
DECL|macro|LinuxVersionCode
mdefine_line|#define LinuxVersionCode(v, p, s) (((v)&lt;&lt;16)+((p)&lt;&lt;8)+(s))
macro_line|#endif
DECL|macro|MAX_INT_PARAM
mdefine_line|#define MAX_INT_PARAM 10
macro_line|#if defined(MODULE)
macro_line|#include &lt;linux/module.h&gt;
id|MODULE_PARM
c_func
(paren
id|boot_options
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io_port
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_INT_PARAM
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|linked_comm
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|have_old_firmware
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|link_statistics
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_queue_depth
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ext_tran
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Dario Ballabio&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &quot;u14-34f.h&quot;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
DECL|macro|SPIN_FLAGS
mdefine_line|#define SPIN_FLAGS unsigned long spin_flags;
DECL|macro|SPIN_LOCK
mdefine_line|#define SPIN_LOCK spin_lock_irq(&amp;io_request_lock);
DECL|macro|SPIN_LOCK_SAVE
mdefine_line|#define SPIN_LOCK_SAVE spin_lock_irqsave(&amp;io_request_lock, spin_flags);
DECL|macro|SPIN_UNLOCK
mdefine_line|#define SPIN_UNLOCK spin_unlock_irq(&amp;io_request_lock);
DECL|macro|SPIN_UNLOCK_RESTORE
mdefine_line|#define SPIN_UNLOCK_RESTORE &bslash;&n;                  spin_unlock_irqrestore(&amp;io_request_lock, spin_flags);
multiline_comment|/* Values for the PRODUCT_ID ports for the 14/34F */
DECL|macro|PRODUCT_ID1
mdefine_line|#define PRODUCT_ID1  0x56
DECL|macro|PRODUCT_ID2
mdefine_line|#define PRODUCT_ID2  0x40        /* NOTE: Only upper nibble is used */
multiline_comment|/* Subversion values */
DECL|macro|ISA
mdefine_line|#define ISA  0
DECL|macro|ESA
mdefine_line|#define ESA 1
DECL|macro|OP_HOST_ADAPTER
mdefine_line|#define OP_HOST_ADAPTER   0x1
DECL|macro|OP_SCSI
mdefine_line|#define OP_SCSI           0x2
DECL|macro|OP_RESET
mdefine_line|#define OP_RESET          0x4
DECL|macro|DTD_SCSI
mdefine_line|#define DTD_SCSI          0x0
DECL|macro|DTD_IN
mdefine_line|#define DTD_IN            0x1
DECL|macro|DTD_OUT
mdefine_line|#define DTD_OUT           0x2
DECL|macro|DTD_NONE
mdefine_line|#define DTD_NONE          0x3
DECL|macro|HA_CMD_INQUIRY
mdefine_line|#define HA_CMD_INQUIRY    0x1
DECL|macro|HA_CMD_SELF_DIAG
mdefine_line|#define HA_CMD_SELF_DIAG  0x2
DECL|macro|HA_CMD_READ_BUFF
mdefine_line|#define HA_CMD_READ_BUFF  0x3
DECL|macro|HA_CMD_WRITE_BUFF
mdefine_line|#define HA_CMD_WRITE_BUFF 0x4
DECL|macro|DEBUG_LINKED_COMMANDS
macro_line|#undef  DEBUG_LINKED_COMMANDS
DECL|macro|DEBUG_DETECT
macro_line|#undef  DEBUG_DETECT
DECL|macro|DEBUG_INTERRUPT
macro_line|#undef  DEBUG_INTERRUPT
DECL|macro|DEBUG_RESET
macro_line|#undef  DEBUG_RESET
DECL|macro|DEBUG_GENERATE_ERRORS
macro_line|#undef  DEBUG_GENERATE_ERRORS
DECL|macro|DEBUG_GENERATE_ABORTS
macro_line|#undef  DEBUG_GENERATE_ABORTS
DECL|macro|DEBUG_GEOMETRY
macro_line|#undef  DEBUG_GEOMETRY
DECL|macro|MAX_ISA
mdefine_line|#define MAX_ISA 3
DECL|macro|MAX_VESA
mdefine_line|#define MAX_VESA 1
DECL|macro|MAX_EISA
mdefine_line|#define MAX_EISA 0
DECL|macro|MAX_PCI
mdefine_line|#define MAX_PCI 0
DECL|macro|MAX_BOARDS
mdefine_line|#define MAX_BOARDS (MAX_ISA + MAX_VESA + MAX_EISA + MAX_PCI)
DECL|macro|MAX_CHANNEL
mdefine_line|#define MAX_CHANNEL 1
DECL|macro|MAX_LUN
mdefine_line|#define MAX_LUN 8
DECL|macro|MAX_TARGET
mdefine_line|#define MAX_TARGET 8
DECL|macro|MAX_MAILBOXES
mdefine_line|#define MAX_MAILBOXES 16
DECL|macro|MAX_SGLIST
mdefine_line|#define MAX_SGLIST 32
DECL|macro|MAX_SAFE_SGLIST
mdefine_line|#define MAX_SAFE_SGLIST 16
DECL|macro|MAX_INTERNAL_RETRIES
mdefine_line|#define MAX_INTERNAL_RETRIES 64
DECL|macro|MAX_CMD_PER_LUN
mdefine_line|#define MAX_CMD_PER_LUN 2
DECL|macro|MAX_TAGGED_CMD_PER_LUN
mdefine_line|#define MAX_TAGGED_CMD_PER_LUN (MAX_MAILBOXES - MAX_CMD_PER_LUN)
DECL|macro|SKIP
mdefine_line|#define SKIP ULONG_MAX
DECL|macro|FALSE
mdefine_line|#define FALSE 0
DECL|macro|TRUE
mdefine_line|#define TRUE 1
DECL|macro|FREE
mdefine_line|#define FREE 0
DECL|macro|IN_USE
mdefine_line|#define IN_USE   1
DECL|macro|LOCKED
mdefine_line|#define LOCKED   2
DECL|macro|IN_RESET
mdefine_line|#define IN_RESET 3
DECL|macro|IGNORE
mdefine_line|#define IGNORE   4
DECL|macro|READY
mdefine_line|#define READY    5
DECL|macro|ABORTING
mdefine_line|#define ABORTING 6
DECL|macro|NO_DMA
mdefine_line|#define NO_DMA  0xff
DECL|macro|MAXLOOP
mdefine_line|#define MAXLOOP  10000
DECL|macro|REG_LCL_MASK
mdefine_line|#define REG_LCL_MASK      0
DECL|macro|REG_LCL_INTR
mdefine_line|#define REG_LCL_INTR      1
DECL|macro|REG_SYS_MASK
mdefine_line|#define REG_SYS_MASK      2
DECL|macro|REG_SYS_INTR
mdefine_line|#define REG_SYS_INTR      3
DECL|macro|REG_PRODUCT_ID1
mdefine_line|#define REG_PRODUCT_ID1   4
DECL|macro|REG_PRODUCT_ID2
mdefine_line|#define REG_PRODUCT_ID2   5
DECL|macro|REG_CONFIG1
mdefine_line|#define REG_CONFIG1       6
DECL|macro|REG_CONFIG2
mdefine_line|#define REG_CONFIG2       7
DECL|macro|REG_OGM
mdefine_line|#define REG_OGM           8
DECL|macro|REG_ICM
mdefine_line|#define REG_ICM           12
DECL|macro|REGION_SIZE
mdefine_line|#define REGION_SIZE       13
DECL|macro|BSY_ASSERTED
mdefine_line|#define BSY_ASSERTED      0x01
DECL|macro|IRQ_ASSERTED
mdefine_line|#define IRQ_ASSERTED      0x01
DECL|macro|CMD_RESET
mdefine_line|#define CMD_RESET         0xc0
DECL|macro|CMD_OGM_INTR
mdefine_line|#define CMD_OGM_INTR      0x01
DECL|macro|CMD_CLR_INTR
mdefine_line|#define CMD_CLR_INTR      0x01
DECL|macro|CMD_ENA_INTR
mdefine_line|#define CMD_ENA_INTR      0x81
DECL|macro|ASOK
mdefine_line|#define ASOK              0x00
DECL|macro|ASST
mdefine_line|#define ASST              0x91
DECL|macro|YESNO
mdefine_line|#define YESNO(a) ((a) ? &squot;y&squot; : &squot;n&squot;)
DECL|macro|TLDEV
mdefine_line|#define TLDEV(type) ((type) == TYPE_DISK || (type) == TYPE_ROM)
DECL|macro|PACKED
mdefine_line|#define PACKED          __attribute__((packed))
DECL|struct|sg_list
r_struct
id|sg_list
(brace
DECL|member|address
r_int
r_int
id|address
suffix:semicolon
multiline_comment|/* Segment Address */
DECL|member|num_bytes
r_int
r_int
id|num_bytes
suffix:semicolon
multiline_comment|/* Segment Length */
)brace
suffix:semicolon
multiline_comment|/* MailBox SCSI Command Packet */
DECL|struct|mscp
r_struct
id|mscp
(brace
DECL|member|opcode
r_int
r_char
id|opcode
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* type of command */
DECL|member|xdir
r_int
r_char
id|xdir
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* data transfer direction */
DECL|member|dcn
r_int
r_char
id|dcn
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* disable disconnect */
DECL|member|ca
r_int
r_char
id|ca
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* use cache (if available) */
DECL|member|sg
r_int
r_char
id|sg
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* scatter/gather operation */
DECL|member|target
r_int
r_char
id|target
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* SCSI target id */
DECL|member|channel
r_int
r_char
id|channel
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* SCSI channel number */
DECL|member|lun
r_int
r_char
id|lun
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* SCSI logical unit number */
DECL|member|PACKED
r_int
r_int
id|data_address
id|PACKED
suffix:semicolon
multiline_comment|/* transfer data pointer */
DECL|member|PACKED
r_int
r_int
id|data_len
id|PACKED
suffix:semicolon
multiline_comment|/* length in bytes */
DECL|member|PACKED
r_int
r_int
id|link_address
id|PACKED
suffix:semicolon
multiline_comment|/* for linking command chains */
DECL|member|clink_id
r_int
r_char
id|clink_id
suffix:semicolon
multiline_comment|/* identifies command in chain */
DECL|member|use_sg
r_int
r_char
id|use_sg
suffix:semicolon
multiline_comment|/* (if sg is set) 8 bytes per list */
DECL|member|sense_len
r_int
r_char
id|sense_len
suffix:semicolon
DECL|member|scsi_cdbs_len
r_int
r_char
id|scsi_cdbs_len
suffix:semicolon
multiline_comment|/* 6, 10, or 12 */
DECL|member|scsi_cdbs
r_int
r_char
id|scsi_cdbs
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* SCSI commands */
DECL|member|adapter_status
r_int
r_char
id|adapter_status
suffix:semicolon
multiline_comment|/* non-zero indicates HA error */
DECL|member|target_status
r_int
r_char
id|target_status
suffix:semicolon
multiline_comment|/* non-zero indicates target error */
DECL|member|PACKED
r_int
r_int
id|sense_addr
id|PACKED
suffix:semicolon
DECL|member|SCpnt
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
DECL|member|index
r_int
r_int
id|index
suffix:semicolon
multiline_comment|/* cp index */
DECL|member|sglist
r_struct
id|sg_list
op_star
id|sglist
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|hostdata
r_struct
id|hostdata
(brace
DECL|member|cp
r_struct
id|mscp
id|cp
(braket
id|MAX_MAILBOXES
)braket
suffix:semicolon
multiline_comment|/* Mailboxes for this board */
DECL|member|cp_stat
r_int
r_int
id|cp_stat
(braket
id|MAX_MAILBOXES
)braket
suffix:semicolon
multiline_comment|/* FREE, IN_USE, LOCKED, IN_RESET */
DECL|member|last_cp_used
r_int
r_int
id|last_cp_used
suffix:semicolon
multiline_comment|/* Index of last mailbox used */
DECL|member|iocount
r_int
r_int
id|iocount
suffix:semicolon
multiline_comment|/* Total i/o done for this board */
DECL|member|board_number
r_int
id|board_number
suffix:semicolon
multiline_comment|/* Number of this board */
DECL|member|board_name
r_char
id|board_name
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Name of this board */
DECL|member|board_id
r_char
id|board_id
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/* data from INQUIRY on this board */
DECL|member|in_reset
r_int
id|in_reset
suffix:semicolon
multiline_comment|/* True if board is doing a reset */
DECL|member|target_to
r_int
id|target_to
(braket
id|MAX_TARGET
)braket
(braket
id|MAX_CHANNEL
)braket
suffix:semicolon
multiline_comment|/* N. of timeout errors on target */
DECL|member|target_redo
r_int
id|target_redo
(braket
id|MAX_TARGET
)braket
(braket
id|MAX_CHANNEL
)braket
suffix:semicolon
multiline_comment|/* If TRUE redo i/o on target */
DECL|member|retries
r_int
r_int
id|retries
suffix:semicolon
multiline_comment|/* Number of internal retries */
DECL|member|last_retried_pid
r_int
r_int
id|last_retried_pid
suffix:semicolon
multiline_comment|/* Pid of last retried command */
DECL|member|subversion
r_int
r_char
id|subversion
suffix:semicolon
multiline_comment|/* Bus type, either ISA or ESA */
DECL|member|heads
r_int
r_char
id|heads
suffix:semicolon
DECL|member|sectors
r_int
r_char
id|sectors
suffix:semicolon
multiline_comment|/* slot != 0 for the U24F, slot == 0 for both the U14F and U34F */
DECL|member|slot
r_int
r_char
id|slot
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|sh
r_static
r_struct
id|Scsi_Host
op_star
id|sh
(braket
id|MAX_BOARDS
op_plus
l_int|1
)braket
suffix:semicolon
DECL|variable|driver_name
r_static
r_const
r_char
op_star
id|driver_name
op_assign
l_string|&quot;Ux4F&quot;
suffix:semicolon
DECL|variable|sha
r_static
r_char
id|sha
(braket
id|MAX_BOARDS
)braket
suffix:semicolon
multiline_comment|/* Initialize num_boards so that ihdlr can work while detect is in progress */
DECL|variable|num_boards
r_static
r_int
r_int
id|num_boards
op_assign
id|MAX_BOARDS
suffix:semicolon
DECL|variable|io_port
r_static
r_int
r_int
id|io_port
(braket
)braket
op_assign
(brace
multiline_comment|/* Space for MAX_INT_PARAM ports usable while loading as a module */
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
id|SKIP
comma
multiline_comment|/* Possible ISA/VESA ports */
l_int|0x330
comma
l_int|0x340
comma
l_int|0x230
comma
l_int|0x240
comma
l_int|0x210
comma
l_int|0x130
comma
l_int|0x140
comma
multiline_comment|/* End of list */
l_int|0x0
)brace
suffix:semicolon
DECL|macro|HD
mdefine_line|#define HD(board) ((struct hostdata *) &amp;sh[board]-&gt;hostdata)
DECL|macro|BN
mdefine_line|#define BN(board) (HD(board)-&gt;board_name)
DECL|macro|SWAP_BYTE
mdefine_line|#define SWAP_BYTE(x) ((unsigned long)( &bslash;&n;        (((unsigned long)(x) &amp; 0x000000ffU) &lt;&lt; 24) | &bslash;&n;        (((unsigned long)(x) &amp; 0x0000ff00U) &lt;&lt;  8) | &bslash;&n;        (((unsigned long)(x) &amp; 0x00ff0000U) &gt;&gt;  8) | &bslash;&n;        (((unsigned long)(x) &amp; 0xff000000U) &gt;&gt; 24)))
macro_line|#if defined(__BIG_ENDIAN)
DECL|macro|H2DEV
mdefine_line|#define H2DEV(x) SWAP_BYTE(x)
macro_line|#else
DECL|macro|H2DEV
mdefine_line|#define H2DEV(x) (x)
macro_line|#endif
DECL|macro|DEV2H
mdefine_line|#define DEV2H(x) H2DEV(x)
DECL|macro|V2DEV
mdefine_line|#define V2DEV(addr) ((addr) ? H2DEV(virt_to_bus((void *)addr)) : 0)
DECL|macro|DEV2V
mdefine_line|#define DEV2V(addr) ((addr) ? DEV2H(bus_to_virt((unsigned long)addr)) : 0)
r_static
r_void
id|do_interrupt_handler
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|flush_dev
c_func
(paren
id|Scsi_Device
op_star
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
DECL|variable|do_trace
r_static
r_int
id|do_trace
op_assign
id|FALSE
suffix:semicolon
DECL|variable|setup_done
r_static
r_int
id|setup_done
op_assign
id|FALSE
suffix:semicolon
DECL|variable|link_statistics
r_static
r_int
id|link_statistics
suffix:semicolon
DECL|variable|ext_tran
r_static
r_int
id|ext_tran
op_assign
id|FALSE
suffix:semicolon
DECL|variable|boot_options
r_static
r_char
op_star
id|boot_options
suffix:semicolon
macro_line|#if defined(HAVE_OLD_UX4F_FIRMWARE)
DECL|variable|have_old_firmware
r_static
r_int
id|have_old_firmware
op_assign
id|TRUE
suffix:semicolon
macro_line|#else
DECL|variable|have_old_firmware
r_static
r_int
id|have_old_firmware
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_SCSI_U14_34F_LINKED_COMMANDS)
DECL|variable|linked_comm
r_static
r_int
id|linked_comm
op_assign
id|TRUE
suffix:semicolon
macro_line|#else
DECL|variable|linked_comm
r_static
r_int
id|linked_comm
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_SCSI_U14_34F_MAX_TAGS)
DECL|variable|max_queue_depth
r_static
r_int
id|max_queue_depth
op_assign
id|CONFIG_SCSI_U14_34F_MAX_TAGS
suffix:semicolon
macro_line|#else
DECL|variable|max_queue_depth
r_static
r_int
id|max_queue_depth
op_assign
id|MAX_CMD_PER_LUN
suffix:semicolon
macro_line|#endif
DECL|function|select_queue_depths
r_static
r_void
id|select_queue_depths
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
id|Scsi_Device
op_star
id|devlist
)paren
(brace
id|Scsi_Device
op_star
id|dev
suffix:semicolon
r_int
id|j
comma
id|ntag
op_assign
l_int|0
comma
id|nuntag
op_assign
l_int|0
comma
id|tqd
comma
id|utqd
suffix:semicolon
id|j
op_assign
(paren
(paren
r_struct
id|hostdata
op_star
)paren
id|host-&gt;hostdata
)paren
op_member_access_from_pointer
id|board_number
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|devlist
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;host
op_ne
id|host
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|TLDEV
c_func
(paren
id|dev-&gt;type
)paren
op_logical_and
(paren
id|dev-&gt;tagged_supported
op_logical_or
id|linked_comm
)paren
)paren
id|ntag
op_increment
suffix:semicolon
r_else
id|nuntag
op_increment
suffix:semicolon
)brace
id|utqd
op_assign
id|MAX_CMD_PER_LUN
suffix:semicolon
id|tqd
op_assign
(paren
id|host-&gt;can_queue
op_minus
id|utqd
op_star
id|nuntag
)paren
op_div
(paren
id|ntag
ques
c_cond
id|ntag
suffix:colon
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tqd
OG
id|max_queue_depth
)paren
id|tqd
op_assign
id|max_queue_depth
suffix:semicolon
r_if
c_cond
(paren
id|tqd
OL
id|MAX_CMD_PER_LUN
)paren
id|tqd
op_assign
id|MAX_CMD_PER_LUN
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|devlist
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_char
op_star
id|tag_suffix
op_assign
l_string|&quot;&quot;
comma
op_star
id|link_suffix
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;host
op_ne
id|host
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|TLDEV
c_func
(paren
id|dev-&gt;type
)paren
op_logical_and
(paren
id|dev-&gt;tagged_supported
op_logical_or
id|linked_comm
)paren
)paren
id|dev-&gt;queue_depth
op_assign
id|tqd
suffix:semicolon
r_else
id|dev-&gt;queue_depth
op_assign
id|utqd
suffix:semicolon
r_if
c_cond
(paren
id|TLDEV
c_func
(paren
id|dev-&gt;type
)paren
)paren
(brace
r_if
c_cond
(paren
id|linked_comm
op_logical_and
id|dev-&gt;queue_depth
OG
l_int|2
)paren
id|link_suffix
op_assign
l_string|&quot;, sorted&quot;
suffix:semicolon
r_else
id|link_suffix
op_assign
l_string|&quot;, unsorted&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;tagged_supported
op_logical_and
id|TLDEV
c_func
(paren
id|dev-&gt;type
)paren
op_logical_and
id|dev-&gt;tagged_queue
)paren
id|tag_suffix
op_assign
l_string|&quot;, soft-tagged&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dev-&gt;tagged_supported
op_logical_and
id|TLDEV
c_func
(paren
id|dev-&gt;type
)paren
)paren
id|tag_suffix
op_assign
l_string|&quot;, tagged&quot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: scsi%d, channel %d, id %d, lun %d, cmds/lun %d%s%s.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|host-&gt;host_no
comma
id|dev-&gt;channel
comma
id|dev-&gt;id
comma
id|dev-&gt;lun
comma
id|dev-&gt;queue_depth
comma
id|link_suffix
comma
id|tag_suffix
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|wait_on_busy
r_static
r_inline
r_int
id|wait_on_busy
c_func
(paren
r_int
r_int
id|iobase
comma
r_int
r_int
id|loop
)paren
(brace
r_while
c_loop
(paren
id|inb
c_func
(paren
id|iobase
op_plus
id|REG_LCL_INTR
)paren
op_amp
id|BSY_ASSERTED
)paren
(brace
id|udelay
c_func
(paren
l_int|1L
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|loop
op_eq
l_int|0
)paren
r_return
id|TRUE
suffix:semicolon
)brace
r_return
id|FALSE
suffix:semicolon
)brace
DECL|function|board_inquiry
r_static
r_int
id|board_inquiry
c_func
(paren
r_int
r_int
id|j
)paren
(brace
r_struct
id|mscp
op_star
id|cpp
suffix:semicolon
r_int
r_int
id|time
comma
id|limit
op_assign
l_int|0
suffix:semicolon
id|cpp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
l_int|0
)braket
suffix:semicolon
id|memset
c_func
(paren
id|cpp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mscp
)paren
)paren
suffix:semicolon
id|cpp-&gt;opcode
op_assign
id|OP_HOST_ADAPTER
suffix:semicolon
id|cpp-&gt;xdir
op_assign
id|DTD_IN
suffix:semicolon
id|cpp-&gt;data_address
op_assign
id|V2DEV
c_func
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|board_id
)paren
suffix:semicolon
id|cpp-&gt;data_len
op_assign
id|H2DEV
c_func
(paren
r_sizeof
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|board_id
)paren
)paren
suffix:semicolon
id|cpp-&gt;scsi_cdbs_len
op_assign
l_int|6
suffix:semicolon
id|cpp-&gt;scsi_cdbs
(braket
l_int|0
)braket
op_assign
id|HA_CMD_INQUIRY
suffix:semicolon
r_if
c_cond
(paren
id|wait_on_busy
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
id|MAXLOOP
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: board_inquiry, adapter busy.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
l_int|0
)braket
op_assign
id|IGNORE
suffix:semicolon
multiline_comment|/* Clear the interrupt indication */
id|outb
c_func
(paren
id|CMD_CLR_INTR
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_SYS_INTR
)paren
suffix:semicolon
multiline_comment|/* Store pointer in OGM address bytes */
id|outl
c_func
(paren
id|V2DEV
c_func
(paren
id|cpp
)paren
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_OGM
)paren
suffix:semicolon
multiline_comment|/* Issue OGM interrupt */
id|outb
c_func
(paren
id|CMD_OGM_INTR
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_LCL_INTR
)paren
suffix:semicolon
id|SPIN_UNLOCK
id|time
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
(paren
id|jiffies
op_minus
id|time
)paren
OL
id|HZ
op_logical_and
id|limit
op_increment
OL
l_int|20000
)paren
id|udelay
c_func
(paren
l_int|100L
)paren
suffix:semicolon
id|SPIN_LOCK
r_if
c_cond
(paren
id|cpp-&gt;adapter_status
op_logical_or
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
l_int|0
)braket
op_ne
id|FREE
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
l_int|0
)braket
op_assign
id|FREE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: board_inquiry, err 0x%x.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|cpp-&gt;adapter_status
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
r_return
id|FALSE
suffix:semicolon
)brace
DECL|function|port_detect
r_static
r_inline
r_int
id|port_detect
"&bslash;"
(paren
r_int
r_int
id|port_base
comma
r_int
r_int
id|j
comma
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
r_char
id|irq
comma
id|dma_channel
comma
id|subversion
comma
id|i
suffix:semicolon
r_int
r_char
id|in_byte
suffix:semicolon
r_char
op_star
id|bus_type
comma
id|dma_name
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Allowed BIOS base addresses (NULL indicates reserved) */
r_int
r_int
id|bios_segment_table
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
l_int|0xc4000
comma
l_int|0xc8000
comma
l_int|0xcc000
comma
l_int|0xd0000
comma
l_int|0xd4000
comma
l_int|0xd8000
comma
l_int|0xdc000
)brace
suffix:semicolon
multiline_comment|/* Allowed IRQs */
r_int
r_char
id|interrupt_table
(braket
l_int|4
)braket
op_assign
(brace
l_int|15
comma
l_int|14
comma
l_int|11
comma
l_int|10
)brace
suffix:semicolon
multiline_comment|/* Allowed DMA channels for ISA (0 indicates reserved) */
r_int
r_char
id|dma_channel_table
(braket
l_int|4
)braket
op_assign
(brace
l_int|5
comma
l_int|6
comma
l_int|7
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* Head/sector mappings */
r_struct
(brace
r_int
r_char
id|heads
suffix:semicolon
r_int
r_char
id|sectors
suffix:semicolon
)brace
id|mapping_table
(braket
l_int|4
)braket
op_assign
(brace
(brace
l_int|16
comma
l_int|63
)brace
comma
(brace
l_int|64
comma
l_int|32
)brace
comma
(brace
l_int|64
comma
l_int|63
)brace
comma
(brace
l_int|64
comma
l_int|32
)brace
)brace
suffix:semicolon
r_struct
id|config_1
(brace
r_int
r_char
id|bios_segment
suffix:colon
l_int|3
suffix:semicolon
r_int
r_char
id|removable_disks_as_fixed
suffix:colon
l_int|1
suffix:semicolon
r_int
r_char
id|interrupt
suffix:colon
l_int|2
suffix:semicolon
r_int
r_char
id|dma_channel
suffix:colon
l_int|2
suffix:semicolon
)brace
id|config_1
suffix:semicolon
r_struct
id|config_2
(brace
r_int
r_char
id|ha_scsi_id
suffix:colon
l_int|3
suffix:semicolon
r_int
r_char
id|mapping_mode
suffix:colon
l_int|2
suffix:semicolon
r_int
r_char
id|bios_drive_number
suffix:colon
l_int|1
suffix:semicolon
r_int
r_char
id|tfr_port
suffix:colon
l_int|2
suffix:semicolon
)brace
id|config_2
suffix:semicolon
r_char
id|name
(braket
l_int|16
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%s%d&quot;
comma
id|driver_name
comma
id|j
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|port_base
comma
id|REGION_SIZE
)paren
)paren
(brace
macro_line|#if defined(DEBUG_DETECT)
id|printk
c_func
(paren
l_string|&quot;%s: address 0x%03lx in use, skipping probe.&bslash;n&quot;
comma
id|name
comma
id|port_base
)paren
suffix:semicolon
macro_line|#endif
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port_base
op_plus
id|REG_PRODUCT_ID1
)paren
op_ne
id|PRODUCT_ID1
)paren
r_return
id|FALSE
suffix:semicolon
id|in_byte
op_assign
id|inb
c_func
(paren
id|port_base
op_plus
id|REG_PRODUCT_ID2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|in_byte
op_amp
l_int|0xf0
)paren
op_ne
id|PRODUCT_ID2
)paren
r_return
id|FALSE
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
op_amp
id|config_1
op_assign
id|inb
c_func
(paren
id|port_base
op_plus
id|REG_CONFIG1
)paren
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
op_amp
id|config_2
op_assign
id|inb
c_func
(paren
id|port_base
op_plus
id|REG_CONFIG2
)paren
suffix:semicolon
id|irq
op_assign
id|interrupt_table
(braket
id|config_1.interrupt
)braket
suffix:semicolon
id|dma_channel
op_assign
id|dma_channel_table
(braket
id|config_1.dma_channel
)braket
suffix:semicolon
id|subversion
op_assign
(paren
id|in_byte
op_amp
l_int|0x0f
)paren
suffix:semicolon
multiline_comment|/* Board detected, allocate its IRQ */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|irq
comma
id|do_interrupt_handler
comma
id|SA_INTERRUPT
op_or
(paren
(paren
id|subversion
op_eq
id|ESA
)paren
ques
c_cond
id|SA_SHIRQ
suffix:colon
l_int|0
)paren
comma
id|driver_name
comma
(paren
r_void
op_star
)paren
op_amp
id|sha
(braket
id|j
)braket
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to allocate IRQ %u, detaching.&bslash;n&quot;
comma
id|name
comma
id|irq
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|subversion
op_eq
id|ISA
op_logical_and
id|request_dma
c_func
(paren
id|dma_channel
comma
id|driver_name
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to allocate DMA channel %u, detaching.&bslash;n&quot;
comma
id|name
comma
id|dma_channel
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|irq
comma
op_amp
id|sha
(braket
id|j
)braket
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|have_old_firmware
)paren
id|tpnt-&gt;use_clustering
op_assign
id|DISABLE_CLUSTERING
suffix:semicolon
id|sh
(braket
id|j
)braket
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
r_sizeof
(paren
r_struct
id|hostdata
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to register host, detaching.&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|irq
comma
op_amp
id|sha
(braket
id|j
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subversion
op_eq
id|ISA
)paren
id|free_dma
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_assign
id|port_base
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|unique_id
op_assign
id|port_base
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|n_io_port
op_assign
id|REGION_SIZE
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|base
op_assign
id|bios_segment_table
(braket
id|config_1.bios_segment
)braket
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|irq
op_assign
id|irq
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
op_assign
id|MAX_SGLIST
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|this_id
op_assign
id|config_2.ha_scsi_id
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
op_assign
id|MAX_MAILBOXES
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|cmd_per_lun
op_assign
id|MAX_CMD_PER_LUN
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|select_queue_depths
op_assign
id|select_queue_depths
suffix:semicolon
macro_line|#if defined(DEBUG_DETECT)
(brace
r_int
r_char
id|sys_mask
comma
id|lcl_mask
suffix:semicolon
id|sys_mask
op_assign
id|inb
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_SYS_MASK
)paren
suffix:semicolon
id|lcl_mask
op_assign
id|inb
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_LCL_MASK
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SYS_MASK 0x%x, LCL_MASK 0x%x.&bslash;n&quot;
comma
id|sys_mask
comma
id|lcl_mask
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Probably a bogus host scsi id, set it to the dummy value */
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|this_id
op_eq
l_int|0
)paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|this_id
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* If BIOS is disabled, force enable interrupts */
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|base
op_eq
l_int|0
)paren
id|outb
c_func
(paren
id|CMD_ENA_INTR
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_SYS_MASK
)paren
suffix:semicolon
multiline_comment|/* Register the I/O space that we use */
id|request_region
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|n_io_port
comma
id|driver_name
)paren
suffix:semicolon
id|memset
c_func
(paren
id|HD
c_func
(paren
id|j
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|hostdata
)paren
)paren
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|heads
op_assign
id|mapping_table
(braket
id|config_2.mapping_mode
)braket
dot
id|heads
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|sectors
op_assign
id|mapping_table
(braket
id|config_2.mapping_mode
)braket
dot
id|sectors
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|subversion
op_assign
id|subversion
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|board_number
op_assign
id|j
suffix:semicolon
r_if
c_cond
(paren
id|have_old_firmware
)paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
op_assign
id|MAX_SAFE_SGLIST
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|subversion
op_eq
id|ESA
)paren
(brace
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|unchecked_isa_dma
op_assign
id|FALSE
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|dma_channel
op_assign
id|NO_DMA
suffix:semicolon
id|sprintf
c_func
(paren
id|BN
c_func
(paren
id|j
)paren
comma
l_string|&quot;U34F%d&quot;
comma
id|j
)paren
suffix:semicolon
id|bus_type
op_assign
l_string|&quot;VESA&quot;
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|flags
suffix:semicolon
id|scsi_register_blocked_host
c_func
(paren
id|sh
(braket
id|j
)braket
)paren
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|unchecked_isa_dma
op_assign
id|TRUE
suffix:semicolon
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|dma_channel
comma
id|DMA_MODE_CASCADE
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|dma_channel
op_assign
id|dma_channel
suffix:semicolon
id|sprintf
c_func
(paren
id|BN
c_func
(paren
id|j
)paren
comma
l_string|&quot;U14F%d&quot;
comma
id|j
)paren
suffix:semicolon
id|bus_type
op_assign
l_string|&quot;ISA&quot;
suffix:semicolon
)brace
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_channel
op_assign
id|MAX_CHANNEL
op_minus
l_int|1
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_id
op_assign
id|MAX_TARGET
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_lun
op_assign
id|MAX_LUN
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|subversion
op_eq
id|ISA
op_logical_and
op_logical_neg
id|board_inquiry
c_func
(paren
id|j
)paren
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|board_id
(braket
l_int|40
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|board_id
(braket
l_int|32
)braket
comma
l_string|&quot;06000600&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|board_id
(braket
l_int|8
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: firmware %s is outdated, FW PROM should be 28004-006.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|board_id
(braket
l_int|32
)braket
)paren
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|hostt-&gt;use_clustering
op_assign
id|DISABLE_CLUSTERING
suffix:semicolon
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
op_assign
id|MAX_SAFE_SGLIST
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dma_channel
op_eq
id|NO_DMA
)paren
id|sprintf
c_func
(paren
id|dma_name
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;BMST&quot;
)paren
suffix:semicolon
r_else
id|sprintf
c_func
(paren
id|dma_name
comma
l_string|&quot;DMA %u&quot;
comma
id|dma_channel
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
)paren
op_member_access_from_pointer
id|sglist
op_assign
id|kmalloc
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
op_star
r_sizeof
(paren
r_struct
id|sg_list
)paren
comma
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|unchecked_isa_dma
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
op_or
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: kmalloc SGlist failed, mbox %d, detaching.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
id|u14_34f_release
c_func
(paren
id|sh
(braket
id|j
)braket
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|max_queue_depth
OG
id|MAX_TAGGED_CMD_PER_LUN
)paren
id|max_queue_depth
op_assign
id|MAX_TAGGED_CMD_PER_LUN
suffix:semicolon
r_if
c_cond
(paren
id|max_queue_depth
OL
id|MAX_CMD_PER_LUN
)paren
id|max_queue_depth
op_assign
id|MAX_CMD_PER_LUN
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;UltraStor 14F/34F: Copyright (C) 1994-2000 Dario Ballabio.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s config options -&gt; of:%c, lc:%c, mq:%d, et:%c.&bslash;n&quot;
comma
id|driver_name
comma
id|YESNO
c_func
(paren
id|have_old_firmware
)paren
comma
id|YESNO
c_func
(paren
id|linked_comm
)paren
comma
id|max_queue_depth
comma
id|YESNO
c_func
(paren
id|ext_tran
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: %s 0x%03lx, BIOS 0x%05x, IRQ %u, %s, SG %d, MB %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|bus_type
comma
(paren
r_int
r_int
)paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
(paren
r_int
)paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|base
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|irq
comma
id|dma_name
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|sg_tablesize
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_id
OG
l_int|8
op_logical_or
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_lun
OG
l_int|8
)paren
id|printk
c_func
(paren
l_string|&quot;%s: wide SCSI support enabled, max_id %u, max_lun %u.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_id
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_lun
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_channel
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%s: SCSI channel %u enabled, host target ID %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|this_id
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
DECL|function|internal_setup
r_static
r_void
id|internal_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_int
id|i
comma
id|argc
op_assign
id|ints
(braket
l_int|0
)braket
suffix:semicolon
r_char
op_star
id|cur
op_assign
id|str
comma
op_star
id|pc
suffix:semicolon
r_if
c_cond
(paren
id|argc
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|argc
OG
id|MAX_INT_PARAM
)paren
id|argc
op_assign
id|MAX_INT_PARAM
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
id|io_port
(braket
id|i
)braket
op_assign
id|ints
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
id|io_port
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|setup_done
op_assign
id|TRUE
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cur
op_logical_and
(paren
id|pc
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;:&squot;
)paren
)paren
)paren
(brace
r_int
id|val
op_assign
l_int|0
comma
id|c
op_assign
op_star
op_increment
id|pc
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;n&squot;
op_logical_or
id|c
op_eq
l_char|&squot;N&squot;
)paren
id|val
op_assign
id|FALSE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;y&squot;
op_logical_or
id|c
op_eq
l_char|&squot;Y&squot;
)paren
id|val
op_assign
id|TRUE
suffix:semicolon
r_else
id|val
op_assign
(paren
r_int
)paren
id|simple_strtoul
c_func
(paren
id|pc
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;lc:&quot;
comma
l_int|3
)paren
)paren
id|linked_comm
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;of:&quot;
comma
l_int|3
)paren
)paren
id|have_old_firmware
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;mq:&quot;
comma
l_int|3
)paren
)paren
id|max_queue_depth
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;ls:&quot;
comma
l_int|3
)paren
)paren
id|link_statistics
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;et:&quot;
comma
l_int|3
)paren
)paren
id|ext_tran
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cur
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;,&squot;
)paren
)paren
)paren
op_increment
id|cur
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|option_setup
r_static
r_int
id|option_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|ints
(braket
id|MAX_INT_PARAM
)braket
suffix:semicolon
r_char
op_star
id|cur
op_assign
id|str
suffix:semicolon
r_int
id|i
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_logical_and
id|isdigit
c_func
(paren
op_star
id|cur
)paren
op_logical_and
id|i
op_le
id|MAX_INT_PARAM
)paren
(brace
id|ints
(braket
id|i
op_increment
)braket
op_assign
id|simple_strtoul
c_func
(paren
id|cur
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cur
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;,&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
id|cur
op_increment
suffix:semicolon
)brace
id|ints
(braket
l_int|0
)braket
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
id|internal_setup
c_func
(paren
id|cur
comma
id|ints
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|u14_34f_detect
r_int
id|u14_34f_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
r_int
id|j
op_assign
l_int|0
comma
id|k
suffix:semicolon
id|tpnt-&gt;proc_name
op_assign
l_string|&quot;u14-34f&quot;
suffix:semicolon
r_if
c_cond
(paren
id|boot_options
)paren
(brace
id|option_setup
c_func
(paren
id|boot_options
)paren
suffix:semicolon
)brace
macro_line|#if defined(MODULE)
multiline_comment|/* io_port could have been modified when loading as a module */
r_if
c_cond
(paren
id|io_port
(braket
l_int|0
)braket
op_ne
id|SKIP
)paren
(brace
id|setup_done
op_assign
id|TRUE
suffix:semicolon
id|io_port
(braket
id|MAX_INT_PARAM
)braket
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|MAX_BOARDS
op_plus
l_int|1
suffix:semicolon
id|k
op_increment
)paren
id|sh
(braket
id|k
)braket
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|io_port
(braket
id|k
)braket
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
id|io_port
(braket
id|k
)braket
op_eq
id|SKIP
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
id|MAX_BOARDS
op_logical_and
id|port_detect
c_func
(paren
id|io_port
(braket
id|k
)braket
comma
id|j
comma
id|tpnt
)paren
)paren
id|j
op_increment
suffix:semicolon
)brace
id|num_boards
op_assign
id|j
suffix:semicolon
r_return
id|j
suffix:semicolon
)brace
DECL|function|build_sg_list
r_static
r_inline
r_void
id|build_sg_list
c_func
(paren
r_struct
id|mscp
op_star
id|cpp
comma
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|k
comma
id|data_len
op_assign
l_int|0
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sgpnt
suffix:semicolon
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;request_buffer
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|k
op_increment
)paren
(brace
id|cpp-&gt;sglist
(braket
id|k
)braket
dot
id|address
op_assign
id|V2DEV
c_func
(paren
id|sgpnt
(braket
id|k
)braket
dot
id|address
)paren
suffix:semicolon
id|cpp-&gt;sglist
(braket
id|k
)braket
dot
id|num_bytes
op_assign
id|H2DEV
c_func
(paren
id|sgpnt
(braket
id|k
)braket
dot
id|length
)paren
suffix:semicolon
id|data_len
op_add_assign
id|sgpnt
(braket
id|k
)braket
dot
id|length
suffix:semicolon
)brace
id|cpp-&gt;use_sg
op_assign
id|SCpnt-&gt;use_sg
suffix:semicolon
id|cpp-&gt;data_address
op_assign
id|V2DEV
c_func
(paren
id|cpp-&gt;sglist
)paren
suffix:semicolon
id|cpp-&gt;data_len
op_assign
id|H2DEV
c_func
(paren
id|data_len
)paren
suffix:semicolon
)brace
DECL|function|do_qcomm
r_static
r_inline
r_int
id|do_qcomm
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_struct
id|mscp
op_star
id|cpp
suffix:semicolon
r_static
r_const
r_int
r_char
id|data_out_cmds
(braket
)braket
op_assign
(brace
l_int|0x0a
comma
l_int|0x2a
comma
l_int|0x15
comma
l_int|0x55
comma
l_int|0x04
comma
l_int|0x07
comma
l_int|0x18
comma
l_int|0x1d
comma
l_int|0x24
comma
l_int|0x2e
comma
l_int|0x30
comma
l_int|0x31
comma
l_int|0x32
comma
l_int|0x38
comma
l_int|0x39
comma
l_int|0x3a
comma
l_int|0x3b
comma
l_int|0x3d
comma
l_int|0x3f
comma
l_int|0x40
comma
l_int|0x41
comma
l_int|0x4c
comma
l_int|0xaa
comma
l_int|0xae
comma
l_int|0xb0
comma
l_int|0xb1
comma
l_int|0xb2
comma
l_int|0xb6
comma
l_int|0xea
comma
l_int|0x1b
)brace
suffix:semicolon
r_static
r_const
r_int
r_char
id|data_none_cmds
(braket
)braket
op_assign
(brace
l_int|0x01
comma
l_int|0x0b
comma
l_int|0x10
comma
l_int|0x11
comma
l_int|0x13
comma
l_int|0x16
comma
l_int|0x17
comma
l_int|0x19
comma
l_int|0x2b
comma
l_int|0x1e
comma
l_int|0x2c
comma
l_int|0xac
comma
l_int|0x2f
comma
l_int|0xaf
comma
l_int|0x33
comma
l_int|0xb3
comma
l_int|0x35
comma
l_int|0x36
comma
l_int|0x45
comma
l_int|0x47
comma
l_int|0x48
comma
l_int|0x49
comma
l_int|0xa9
comma
l_int|0x4b
comma
l_int|0xa5
comma
l_int|0xa6
comma
l_int|0xb5
)brace
suffix:semicolon
multiline_comment|/* j is the board number */
id|j
op_assign
(paren
(paren
r_struct
id|hostdata
op_star
)paren
id|SCpnt-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|board_number
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host_scribble
)paren
id|panic
c_func
(paren
l_string|&quot;%s: qcomm, pid %ld, SCpnt %p already active.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCpnt-&gt;pid
comma
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/* i is the mailbox number, look for the first free mailbox&n;      starting from last_cp_used */
id|i
op_assign
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|last_cp_used
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
suffix:semicolon
id|k
op_increment
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_ge
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
)paren
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|FREE
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|last_cp_used
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|k
op_eq
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: qcomm, no free mailbox.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Set pointer to control packet structure */
id|cpp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
suffix:semicolon
id|memset
c_func
(paren
id|cpp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mscp
)paren
op_minus
r_sizeof
(paren
r_struct
id|sg_list
op_star
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cpp-&gt;index
op_assign
id|i
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|cpp-&gt;index
suffix:semicolon
r_if
c_cond
(paren
id|do_trace
)paren
id|printk
c_func
(paren
l_string|&quot;%s: qcomm, mbox %d, target %d.%d:%d, pid %ld.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
id|cpp-&gt;xdir
op_assign
id|DTD_IN
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|ARRAY_SIZE
c_func
(paren
id|data_out_cmds
)paren
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|data_out_cmds
(braket
id|k
)braket
)paren
(brace
id|cpp-&gt;xdir
op_assign
id|DTD_OUT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cpp-&gt;xdir
op_eq
id|DTD_IN
)paren
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|ARRAY_SIZE
c_func
(paren
id|data_none_cmds
)paren
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|data_none_cmds
(braket
id|k
)braket
)paren
(brace
id|cpp-&gt;xdir
op_assign
id|DTD_NONE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cpp-&gt;opcode
op_assign
id|OP_SCSI
suffix:semicolon
id|cpp-&gt;channel
op_assign
id|SCpnt-&gt;channel
suffix:semicolon
id|cpp-&gt;target
op_assign
id|SCpnt-&gt;target
suffix:semicolon
id|cpp-&gt;lun
op_assign
id|SCpnt-&gt;lun
suffix:semicolon
id|cpp-&gt;SCpnt
op_assign
id|SCpnt
suffix:semicolon
id|cpp-&gt;sense_addr
op_assign
id|V2DEV
c_func
(paren
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|cpp-&gt;sense_len
op_assign
r_sizeof
id|SCpnt-&gt;sense_buffer
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
id|cpp-&gt;sg
op_assign
id|TRUE
suffix:semicolon
id|build_sg_list
c_func
(paren
id|cpp
comma
id|SCpnt
)paren
suffix:semicolon
)brace
r_else
(brace
id|cpp-&gt;data_address
op_assign
id|V2DEV
c_func
(paren
id|SCpnt-&gt;request_buffer
)paren
suffix:semicolon
id|cpp-&gt;data_len
op_assign
id|H2DEV
c_func
(paren
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
)brace
id|cpp-&gt;scsi_cdbs_len
op_assign
id|SCpnt-&gt;cmd_len
suffix:semicolon
id|memcpy
c_func
(paren
id|cpp-&gt;scsi_cdbs
comma
id|SCpnt-&gt;cmnd
comma
id|cpp-&gt;scsi_cdbs_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|linked_comm
op_logical_and
id|SCpnt-&gt;device-&gt;queue_depth
OG
l_int|2
op_logical_and
id|TLDEV
c_func
(paren
id|SCpnt-&gt;device-&gt;type
)paren
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|READY
suffix:semicolon
id|flush_dev
c_func
(paren
id|SCpnt-&gt;device
comma
id|SCpnt-&gt;request.sector
comma
id|j
comma
id|FALSE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wait_on_busy
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
id|MAXLOOP
)paren
)paren
(brace
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: qcomm, target %d.%d:%d, pid %ld, adapter busy.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Store pointer in OGM address bytes */
id|outl
c_func
(paren
id|V2DEV
c_func
(paren
id|cpp
)paren
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_OGM
)paren
suffix:semicolon
multiline_comment|/* Issue OGM interrupt */
id|outb
c_func
(paren
id|CMD_OGM_INTR
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_LCL_INTR
)paren
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|IN_USE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|u14_34f_queuecommand
r_int
id|u14_34f_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
id|rtn
suffix:semicolon
id|rtn
op_assign
id|do_qcomm
c_func
(paren
id|SCpnt
comma
id|done
)paren
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
DECL|function|do_abort
r_static
r_inline
r_int
id|do_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCarg
)paren
(brace
r_int
r_int
id|i
comma
id|j
suffix:semicolon
id|j
op_assign
(paren
(paren
r_struct
id|hostdata
op_star
)paren
id|SCarg-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|board_number
suffix:semicolon
r_if
c_cond
(paren
id|SCarg-&gt;host_scribble
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, target %d.%d:%d, pid %ld inactive.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCarg-&gt;channel
comma
id|SCarg-&gt;target
comma
id|SCarg-&gt;lun
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
id|i
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|SCarg-&gt;host_scribble
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: abort, mbox %d, target %d.%d:%d, pid %ld.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCarg-&gt;channel
comma
id|SCarg-&gt;target
comma
id|SCarg-&gt;lun
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
)paren
id|panic
c_func
(paren
l_string|&quot;%s: abort, invalid SCarg-&gt;host_scribble.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_on_busy
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
id|MAXLOOP
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, timeout error.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|FREE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, mbox %d is free.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|IN_USE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, mbox %d is in use.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCarg
op_ne
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
dot
id|SCpnt
)paren
id|panic
c_func
(paren
l_string|&quot;%s: abort, mbox %d, SCarg %p, cp SCpnt %p.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCarg
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
dot
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_SYS_INTR
)paren
op_amp
id|IRQ_ASSERTED
)paren
id|printk
c_func
(paren
l_string|&quot;%s: abort, mbox %d, interrupt pending.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCarg-&gt;eh_state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
id|SCarg-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s, abort, mbox %d, eh_state timeout, pid %ld.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
r_return
id|FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|IN_RESET
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, mbox %d is in reset.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|LOCKED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: abort, mbox %d is locked.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|READY
op_logical_or
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|ABORTING
)paren
(brace
id|SCarg-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|SCarg-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s, abort, mbox %d ready, DID_ABORT, pid %ld done.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
id|SCarg
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|SCarg
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
id|panic
c_func
(paren
l_string|&quot;%s: abort, mbox %d, invalid cp_stat.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
)brace
DECL|function|u14_34f_abort
r_int
id|u14_34f_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCarg
)paren
(brace
r_return
id|do_abort
c_func
(paren
id|SCarg
)paren
suffix:semicolon
)brace
DECL|function|do_reset
r_static
r_inline
r_int
id|do_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCarg
)paren
(brace
r_int
r_int
id|i
comma
id|j
comma
id|time
comma
id|k
comma
id|c
comma
id|limit
op_assign
l_int|0
suffix:semicolon
r_int
id|arg_done
op_assign
id|FALSE
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|j
op_assign
(paren
(paren
r_struct
id|hostdata
op_star
)paren
id|SCarg-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|board_number
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: reset, enter, target %d.%d:%d, pid %ld.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCarg-&gt;channel
comma
id|SCarg-&gt;target
comma
id|SCarg-&gt;lun
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCarg-&gt;host_scribble
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
l_string|&quot;%s: reset, pid %ld inactive.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|in_reset
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: reset, exit, already in reset.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wait_on_busy
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
id|MAXLOOP
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: reset, exit, timeout error.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|retries
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
op_le
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_channel
suffix:semicolon
id|c
op_increment
)paren
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_id
suffix:semicolon
id|k
op_increment
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_redo
(braket
id|k
)braket
(braket
id|c
)braket
op_assign
id|TRUE
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_to
(braket
id|k
)braket
(braket
id|c
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|FREE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|LOCKED
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: reset, locked mbox %d forced free.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|SCpnt
op_assign
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
dot
id|SCpnt
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;%s: reset, mbox %d, SCpnt == NULL.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|READY
op_logical_or
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|ABORTING
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|ABORTING
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: reset, mbox %d aborting, pid %ld.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
)brace
r_else
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|IN_RESET
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: reset, mbox %d in reset, pid %ld.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;host_scribble
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;%s: reset, mbox %d, garbled SCpnt.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|SCpnt-&gt;host_scribble
op_ne
id|i
)paren
id|panic
c_func
(paren
l_string|&quot;%s: reset, mbox %d, index mismatch.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;scsi_done
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;%s: reset, mbox %d, SCpnt-&gt;scsi_done == NULL.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_eq
id|SCarg
)paren
id|arg_done
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wait_on_busy
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
id|MAXLOOP
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: reset, cannot reset, timeout error.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
id|outb
c_func
(paren
id|CMD_RESET
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_LCL_INTR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: reset, board reset done, enabling interrupts.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_RESET)
id|do_trace
op_assign
id|TRUE
suffix:semicolon
macro_line|#endif
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|in_reset
op_assign
id|TRUE
suffix:semicolon
id|SPIN_UNLOCK
id|time
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
(paren
id|jiffies
op_minus
id|time
)paren
OL
(paren
l_int|10
op_star
id|HZ
)paren
op_logical_and
id|limit
op_increment
OL
l_int|200000
)paren
id|udelay
c_func
(paren
l_int|100L
)paren
suffix:semicolon
id|SPIN_LOCK
id|printk
c_func
(paren
l_string|&quot;%s: reset, interrupts disabled, loops %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|limit
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|IN_RESET
)paren
(brace
id|SCpnt
op_assign
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
dot
id|SCpnt
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* This mailbox is still waiting for its interrupt */
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|LOCKED
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s, reset, mbox %d locked, DID_RESET, pid %ld done.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|ABORTING
)paren
(brace
id|SCpnt
op_assign
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
dot
id|SCpnt
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* This mailbox was never queued to the adapter */
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s, reset, mbox %d aborting, DID_RESET, pid %ld done.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Any other mailbox has already been set free by interrupt */
r_continue
suffix:semicolon
id|SCpnt
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|in_reset
op_assign
id|FALSE
suffix:semicolon
id|do_trace
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|arg_done
)paren
id|printk
c_func
(paren
l_string|&quot;%s: reset, exit, pid %ld done.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCarg-&gt;pid
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%s: reset, exit.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
DECL|function|u14_34f_reset
r_int
id|u14_34f_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCarg
)paren
(brace
r_return
id|do_reset
c_func
(paren
id|SCarg
)paren
suffix:semicolon
)brace
DECL|function|u14_34f_biosparam
r_int
id|u14_34f_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
op_star
id|dkinfo
)paren
(brace
r_int
r_int
id|j
op_assign
l_int|0
suffix:semicolon
r_int
id|size
op_assign
id|disk-&gt;capacity
suffix:semicolon
id|dkinfo
(braket
l_int|0
)braket
op_assign
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|heads
suffix:semicolon
id|dkinfo
(braket
l_int|1
)braket
op_assign
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|sectors
suffix:semicolon
id|dkinfo
(braket
l_int|2
)braket
op_assign
id|size
op_div
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|heads
op_star
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ext_tran
op_logical_and
(paren
id|scsicam_bios_param
c_func
(paren
id|disk
comma
id|dev
comma
id|dkinfo
)paren
OL
l_int|0
)paren
)paren
(brace
id|dkinfo
(braket
l_int|0
)braket
op_assign
l_int|255
suffix:semicolon
id|dkinfo
(braket
l_int|1
)braket
op_assign
l_int|63
suffix:semicolon
id|dkinfo
(braket
l_int|2
)braket
op_assign
id|size
op_div
(paren
id|dkinfo
(braket
l_int|0
)braket
op_star
id|dkinfo
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
macro_line|#if defined (DEBUG_GEOMETRY)
id|printk
(paren
l_string|&quot;%s: biosparam, head=%d, sec=%d, cyl=%d.&bslash;n&quot;
comma
id|driver_name
comma
id|dkinfo
(braket
l_int|0
)braket
comma
id|dkinfo
(braket
l_int|1
)braket
comma
id|dkinfo
(braket
l_int|2
)braket
)paren
suffix:semicolon
macro_line|#endif
r_return
id|FALSE
suffix:semicolon
)brace
DECL|function|sort
r_static
r_void
id|sort
c_func
(paren
r_int
r_int
id|sk
(braket
)braket
comma
r_int
r_int
id|da
(braket
)braket
comma
r_int
r_int
id|n
comma
r_int
r_int
id|rev
)paren
(brace
r_int
r_int
id|i
comma
id|j
comma
id|k
comma
id|y
suffix:semicolon
r_int
r_int
id|x
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|k
op_assign
id|i
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|k
op_plus
l_int|1
suffix:semicolon
id|j
OL
id|n
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|rev
)paren
(brace
r_if
c_cond
(paren
id|sk
(braket
id|j
)braket
OG
id|sk
(braket
id|k
)braket
)paren
id|k
op_assign
id|j
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sk
(braket
id|j
)braket
OL
id|sk
(braket
id|k
)braket
)paren
id|k
op_assign
id|j
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
op_ne
id|i
)paren
(brace
id|x
op_assign
id|sk
(braket
id|k
)braket
suffix:semicolon
id|sk
(braket
id|k
)braket
op_assign
id|sk
(braket
id|i
)braket
suffix:semicolon
id|sk
(braket
id|i
)braket
op_assign
id|x
suffix:semicolon
id|y
op_assign
id|da
(braket
id|k
)braket
suffix:semicolon
id|da
(braket
id|k
)braket
op_assign
id|da
(braket
id|i
)braket
suffix:semicolon
id|da
(braket
id|i
)braket
op_assign
id|y
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
DECL|function|reorder
r_static
r_inline
r_int
id|reorder
c_func
(paren
r_int
r_int
id|j
comma
r_int
r_int
id|cursec
comma
r_int
r_int
id|ihdlr
comma
r_int
r_int
id|il
(braket
)braket
comma
r_int
r_int
id|n_ready
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_struct
id|mscp
op_star
id|cpp
suffix:semicolon
r_int
r_int
id|k
comma
id|n
suffix:semicolon
r_int
r_int
id|rev
op_assign
id|FALSE
comma
id|s
op_assign
id|TRUE
comma
id|r
op_assign
id|TRUE
suffix:semicolon
r_int
r_int
id|input_only
op_assign
id|TRUE
comma
id|overlap
op_assign
id|FALSE
suffix:semicolon
r_int
r_int
id|sl
(braket
id|n_ready
)braket
comma
id|pl
(braket
id|n_ready
)braket
comma
id|ll
(braket
id|n_ready
)braket
suffix:semicolon
r_int
r_int
id|maxsec
op_assign
l_int|0
comma
id|minsec
op_assign
id|ULONG_MAX
comma
id|seek
op_assign
l_int|0
comma
id|iseek
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|ioseek
op_assign
l_int|0
suffix:semicolon
r_static
r_int
r_int
id|flushcount
op_assign
l_int|0
comma
id|batchcount
op_assign
l_int|0
comma
id|sortcount
op_assign
l_int|0
suffix:semicolon
r_static
r_int
r_int
id|readycount
op_assign
l_int|0
comma
id|ovlcount
op_assign
l_int|0
comma
id|inputcount
op_assign
l_int|0
suffix:semicolon
r_static
r_int
r_int
id|readysorted
op_assign
l_int|0
comma
id|revcount
op_assign
l_int|0
suffix:semicolon
r_static
r_int
r_int
id|seeksorted
op_assign
l_int|0
comma
id|seeknosort
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|link_statistics
op_logical_and
op_logical_neg
(paren
op_increment
id|flushcount
op_mod
id|link_statistics
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;fc %d bc %d ic %d oc %d rc %d rs %d sc %d re %d&quot;
"&bslash;"
l_string|&quot; av %ldK as %ldK.&bslash;n&quot;
comma
id|flushcount
comma
id|batchcount
comma
id|inputcount
comma
id|ovlcount
comma
id|readycount
comma
id|readysorted
comma
id|sortcount
comma
id|revcount
comma
id|seeknosort
op_div
(paren
id|readycount
op_plus
l_int|1
)paren
comma
id|seeksorted
op_div
(paren
id|readycount
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_ready
op_le
l_int|1
)paren
r_return
id|FALSE
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|n_ready
suffix:semicolon
id|n
op_increment
)paren
(brace
id|k
op_assign
id|il
(braket
id|n
)braket
suffix:semicolon
id|cpp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|k
)braket
suffix:semicolon
id|SCpnt
op_assign
id|cpp-&gt;SCpnt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cpp-&gt;xdir
op_eq
id|DTD_IN
)paren
)paren
id|input_only
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request.sector
OL
id|minsec
)paren
id|minsec
op_assign
id|SCpnt-&gt;request.sector
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request.sector
OG
id|maxsec
)paren
id|maxsec
op_assign
id|SCpnt-&gt;request.sector
suffix:semicolon
id|sl
(braket
id|n
)braket
op_assign
id|SCpnt-&gt;request.sector
suffix:semicolon
id|ioseek
op_add_assign
id|SCpnt-&gt;request.nr_sectors
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|sl
(braket
id|n
)braket
OL
id|sl
(braket
id|n
op_minus
l_int|1
)braket
)paren
id|s
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|sl
(braket
id|n
)braket
OG
id|sl
(braket
id|n
op_minus
l_int|1
)braket
)paren
id|r
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|link_statistics
)paren
(brace
r_if
c_cond
(paren
id|sl
(braket
id|n
)braket
OG
id|sl
(braket
id|n
op_minus
l_int|1
)braket
)paren
id|seek
op_add_assign
id|sl
(braket
id|n
)braket
op_minus
id|sl
(braket
id|n
op_minus
l_int|1
)braket
suffix:semicolon
r_else
id|seek
op_add_assign
id|sl
(braket
id|n
op_minus
l_int|1
)braket
op_minus
id|sl
(braket
id|n
)braket
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|link_statistics
)paren
(brace
r_if
c_cond
(paren
id|cursec
OG
id|sl
(braket
l_int|0
)braket
)paren
id|seek
op_add_assign
id|cursec
op_minus
id|sl
(braket
l_int|0
)braket
suffix:semicolon
r_else
id|seek
op_add_assign
id|sl
(braket
l_int|0
)braket
op_minus
id|cursec
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cursec
OG
(paren
(paren
id|maxsec
op_plus
id|minsec
)paren
op_div
l_int|2
)paren
)paren
id|rev
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|ioseek
OG
(paren
(paren
id|maxsec
op_minus
id|minsec
)paren
op_div
l_int|2
)paren
)paren
id|rev
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|rev
op_logical_and
id|r
)paren
op_logical_or
(paren
op_logical_neg
id|rev
op_logical_and
id|s
)paren
)paren
)paren
id|sort
c_func
(paren
id|sl
comma
id|il
comma
id|n_ready
comma
id|rev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|input_only
)paren
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|n_ready
suffix:semicolon
id|n
op_increment
)paren
(brace
id|k
op_assign
id|il
(braket
id|n
)braket
suffix:semicolon
id|cpp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|k
)braket
suffix:semicolon
id|SCpnt
op_assign
id|cpp-&gt;SCpnt
suffix:semicolon
id|ll
(braket
id|n
)braket
op_assign
id|SCpnt-&gt;request.nr_sectors
suffix:semicolon
id|pl
(braket
id|n
)braket
op_assign
id|SCpnt-&gt;pid
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sl
(braket
id|n
)braket
op_eq
id|sl
(braket
id|n
op_minus
l_int|1
)braket
)paren
op_logical_or
(paren
op_logical_neg
id|rev
op_logical_and
(paren
(paren
id|sl
(braket
id|n
op_minus
l_int|1
)braket
op_plus
id|ll
(braket
id|n
op_minus
l_int|1
)braket
)paren
OG
id|sl
(braket
id|n
)braket
)paren
)paren
op_logical_or
(paren
id|rev
op_logical_and
(paren
(paren
id|sl
(braket
id|n
)braket
op_plus
id|ll
(braket
id|n
)braket
)paren
OG
id|sl
(braket
id|n
op_minus
l_int|1
)braket
)paren
)paren
)paren
id|overlap
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|overlap
)paren
id|sort
c_func
(paren
id|pl
comma
id|il
comma
id|n_ready
comma
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link_statistics
)paren
(brace
r_if
c_cond
(paren
id|cursec
OG
id|sl
(braket
l_int|0
)braket
)paren
id|iseek
op_assign
id|cursec
op_minus
id|sl
(braket
l_int|0
)braket
suffix:semicolon
r_else
id|iseek
op_assign
id|sl
(braket
l_int|0
)braket
op_minus
id|cursec
suffix:semicolon
id|batchcount
op_increment
suffix:semicolon
id|readycount
op_add_assign
id|n_ready
suffix:semicolon
id|seeknosort
op_add_assign
id|seek
op_div
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
id|input_only
)paren
id|inputcount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|overlap
)paren
(brace
id|ovlcount
op_increment
suffix:semicolon
id|seeksorted
op_add_assign
id|iseek
op_div
l_int|1024
suffix:semicolon
)brace
r_else
id|seeksorted
op_add_assign
(paren
id|iseek
op_plus
id|maxsec
op_minus
id|minsec
)paren
op_div
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
id|rev
op_logical_and
op_logical_neg
id|r
)paren
(brace
id|revcount
op_increment
suffix:semicolon
id|readysorted
op_add_assign
id|n_ready
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rev
op_logical_and
op_logical_neg
id|s
)paren
(brace
id|sortcount
op_increment
suffix:semicolon
id|readysorted
op_add_assign
id|n_ready
suffix:semicolon
)brace
)brace
macro_line|#if defined(DEBUG_LINKED_COMMANDS)
r_if
c_cond
(paren
id|link_statistics
op_logical_and
(paren
id|overlap
op_logical_or
op_logical_neg
(paren
id|flushcount
op_mod
id|link_statistics
)paren
)paren
)paren
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|n_ready
suffix:semicolon
id|n
op_increment
)paren
(brace
id|k
op_assign
id|il
(braket
id|n
)braket
suffix:semicolon
id|cpp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|k
)braket
suffix:semicolon
id|SCpnt
op_assign
id|cpp-&gt;SCpnt
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s %d.%d:%d pid %ld mb %d fc %d nr %d sec %ld ns %ld&quot;
"&bslash;"
l_string|&quot; cur %ld s:%c r:%c rev:%c in:%c ov:%c xd %d.&bslash;n&quot;
comma
(paren
id|ihdlr
ques
c_cond
l_string|&quot;ihdlr&quot;
suffix:colon
l_string|&quot;qcomm&quot;
)paren
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;pid
comma
id|k
comma
id|flushcount
comma
id|n_ready
comma
id|SCpnt-&gt;request.sector
comma
id|SCpnt-&gt;request.nr_sectors
comma
id|cursec
comma
id|YESNO
c_func
(paren
id|s
)paren
comma
id|YESNO
c_func
(paren
id|r
)paren
comma
id|YESNO
c_func
(paren
id|rev
)paren
comma
id|YESNO
c_func
(paren
id|input_only
)paren
comma
id|YESNO
c_func
(paren
id|overlap
)paren
comma
id|cpp-&gt;xdir
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|overlap
suffix:semicolon
)brace
DECL|function|flush_dev
r_static
r_void
id|flush_dev
c_func
(paren
id|Scsi_Device
op_star
id|dev
comma
r_int
r_int
id|cursec
comma
r_int
r_int
id|j
comma
r_int
r_int
id|ihdlr
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_struct
id|mscp
op_star
id|cpp
suffix:semicolon
r_int
r_int
id|k
comma
id|n
comma
id|n_ready
op_assign
l_int|0
comma
id|il
(braket
id|MAX_MAILBOXES
)braket
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|k
)braket
op_ne
id|READY
op_logical_and
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|k
)braket
op_ne
id|IN_USE
)paren
r_continue
suffix:semicolon
id|cpp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|k
)braket
suffix:semicolon
id|SCpnt
op_assign
id|cpp-&gt;SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;device
op_ne
id|dev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|k
)braket
op_eq
id|IN_USE
)paren
r_return
suffix:semicolon
id|il
(braket
id|n_ready
op_increment
)braket
op_assign
id|k
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reorder
c_func
(paren
id|j
comma
id|cursec
comma
id|ihdlr
comma
id|il
comma
id|n_ready
)paren
)paren
id|n_ready
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|n_ready
suffix:semicolon
id|n
op_increment
)paren
(brace
id|k
op_assign
id|il
(braket
id|n
)braket
suffix:semicolon
id|cpp
op_assign
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|k
)braket
suffix:semicolon
id|SCpnt
op_assign
id|cpp-&gt;SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|wait_on_busy
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
id|MAXLOOP
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s, target %d.%d:%d, pid %ld, mbox %d, adapter&quot;
"&bslash;"
l_string|&quot; busy, will abort.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
(paren
id|ihdlr
ques
c_cond
l_string|&quot;ihdlr&quot;
suffix:colon
l_string|&quot;qcomm&quot;
)paren
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;pid
comma
id|k
)paren
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|k
)braket
op_assign
id|ABORTING
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|outl
c_func
(paren
id|V2DEV
c_func
(paren
id|cpp
)paren
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_OGM
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CMD_OGM_INTR
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_LCL_INTR
)paren
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|k
)braket
op_assign
id|IN_USE
suffix:semicolon
)brace
)brace
DECL|function|ihdlr
r_static
r_inline
r_void
id|ihdlr
c_func
(paren
r_int
id|irq
comma
r_int
r_int
id|j
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_int
r_int
id|i
comma
id|k
comma
id|c
comma
id|status
comma
id|tstatus
comma
id|reg
comma
id|ret
suffix:semicolon
r_struct
id|mscp
op_star
id|spp
comma
op_star
id|cpp
suffix:semicolon
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|irq
op_ne
id|irq
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ihdlr, irq %d, sh[j]-&gt;irq %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|irq
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|irq
)paren
suffix:semicolon
multiline_comment|/* Check if this board need to be serviced */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|reg
op_assign
id|inb
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_SYS_INTR
)paren
)paren
op_amp
id|IRQ_ASSERTED
)paren
)paren
r_return
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|do_trace
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, enter, irq %d, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|irq
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
multiline_comment|/* Check if this board is still busy */
r_if
c_cond
(paren
id|wait_on_busy
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
l_int|20
op_star
id|MAXLOOP
)paren
)paren
(brace
id|outb
c_func
(paren
id|CMD_CLR_INTR
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_SYS_INTR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, busy timeout error,  irq %d, reg 0x%x, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|irq
comma
id|reg
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spp
op_assign
(paren
r_struct
id|mscp
op_star
)paren
id|DEV2V
c_func
(paren
id|ret
op_assign
id|inl
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_ICM
)paren
)paren
suffix:semicolon
id|cpp
op_assign
id|spp
suffix:semicolon
multiline_comment|/* Clear interrupt pending flag */
id|outb
c_func
(paren
id|CMD_CLR_INTR
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
op_plus
id|REG_SYS_INTR
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_GENERATE_ABORTS)
r_if
c_cond
(paren
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
OG
l_int|500
)paren
op_logical_and
(paren
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
op_mod
l_int|500
)paren
OL
l_int|3
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif
multiline_comment|/* Find the mailbox to be serviced on this board */
id|i
op_assign
id|cpp
op_minus
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
suffix:semicolon
r_if
c_cond
(paren
id|cpp
OL
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
op_logical_or
id|cpp
op_ge
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
op_plus
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
op_logical_or
id|i
op_ge
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ihdlr, invalid mscp bus address %p, cp0 %p.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
(paren
r_void
op_star
)paren
id|ret
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|IGNORE
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|LOCKED
)paren
(brace
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d unlocked, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|FREE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d is free, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_eq
id|IN_RESET
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d is in reset.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_ne
id|IN_USE
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d, invalid cp_stat: %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
)paren
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp_stat
(braket
id|i
)braket
op_assign
id|FREE
suffix:semicolon
id|SCpnt
op_assign
id|cpp-&gt;SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d, SCpnt == NULL.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host_scribble
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d, pid %ld, SCpnt %p garbled.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;pid
comma
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|SCpnt-&gt;host_scribble
op_ne
id|i
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %d, pid %ld, index mismatch %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|SCpnt-&gt;pid
comma
op_star
(paren
r_int
r_int
op_star
)paren
id|SCpnt-&gt;host_scribble
)paren
suffix:semicolon
r_if
c_cond
(paren
id|linked_comm
op_logical_and
id|SCpnt-&gt;device-&gt;queue_depth
OG
l_int|2
op_logical_and
id|TLDEV
c_func
(paren
id|SCpnt-&gt;device-&gt;type
)paren
)paren
id|flush_dev
c_func
(paren
id|SCpnt-&gt;device
comma
id|SCpnt-&gt;request.sector
comma
id|j
comma
id|TRUE
)paren
suffix:semicolon
id|tstatus
op_assign
id|status_byte
c_func
(paren
id|spp-&gt;target_status
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_GENERATE_ERRORS)
r_if
c_cond
(paren
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
OG
l_int|500
)paren
op_logical_and
(paren
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
op_mod
l_int|200
)paren
OL
l_int|2
)paren
)paren
id|spp-&gt;adapter_status
op_assign
l_int|0x01
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|spp-&gt;adapter_status
)paren
(brace
r_case
id|ASOK
suffix:colon
multiline_comment|/* status OK */
multiline_comment|/* Forces a reset if a disk drive keeps returning BUSY */
r_if
c_cond
(paren
id|tstatus
op_eq
id|BUSY
op_logical_and
id|SCpnt-&gt;device-&gt;type
op_ne
id|TYPE_TAPE
)paren
id|status
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* If there was a bus reset, redo operation on each target */
r_else
r_if
c_cond
(paren
id|tstatus
op_ne
id|GOOD
op_logical_and
id|SCpnt-&gt;device-&gt;type
op_eq
id|TYPE_DISK
op_logical_and
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_redo
(braket
id|SCpnt-&gt;target
)braket
(braket
id|SCpnt-&gt;channel
)braket
)paren
id|status
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* Works around a flaw in scsi.c */
r_else
r_if
c_cond
(paren
id|tstatus
op_eq
id|CHECK_CONDITION
op_logical_and
id|SCpnt-&gt;device-&gt;type
op_eq
id|TYPE_DISK
op_logical_and
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
id|RECOVERED_ERROR
)paren
id|status
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
r_else
id|status
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|tstatus
op_eq
id|GOOD
)paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_redo
(braket
id|SCpnt-&gt;target
)braket
(braket
id|SCpnt-&gt;channel
)braket
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|spp-&gt;target_status
op_logical_and
id|SCpnt-&gt;device-&gt;type
op_eq
id|TYPE_DISK
op_logical_and
(paren
op_logical_neg
(paren
id|tstatus
op_eq
id|CHECK_CONDITION
op_logical_and
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
op_le
l_int|1000
op_logical_and
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
id|NOT_READY
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, target %d.%d:%d, pid %ld, &quot;
"&bslash;"
l_string|&quot;target_status 0x%x, sense key 0x%x.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;pid
comma
id|spp-&gt;target_status
comma
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_to
(braket
id|SCpnt-&gt;target
)braket
(braket
id|SCpnt-&gt;channel
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|last_retried_pid
op_eq
id|SCpnt-&gt;pid
)paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|retries
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ASST
suffix:colon
multiline_comment|/* Selection Time Out */
r_if
c_cond
(paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_to
(braket
id|SCpnt-&gt;target
)braket
(braket
id|SCpnt-&gt;channel
)braket
OG
l_int|1
)paren
id|status
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_else
(brace
id|status
op_assign
id|DID_TIME_OUT
op_lshift
l_int|16
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_to
(braket
id|SCpnt-&gt;target
)braket
(braket
id|SCpnt-&gt;channel
)braket
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Perform a limited number of internal retries */
r_case
l_int|0x93
suffix:colon
multiline_comment|/* Unexpected bus free */
r_case
l_int|0x94
suffix:colon
multiline_comment|/* Target bus phase sequence failure */
r_case
l_int|0x96
suffix:colon
multiline_comment|/* Illegal SCSI command */
r_case
l_int|0xa3
suffix:colon
multiline_comment|/* SCSI bus reset error */
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
op_le
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_channel
suffix:semicolon
id|c
op_increment
)paren
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|max_id
suffix:semicolon
id|k
op_increment
)paren
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|target_redo
(braket
id|k
)braket
(braket
id|c
)braket
op_assign
id|TRUE
suffix:semicolon
r_case
l_int|0x92
suffix:colon
multiline_comment|/* Data over/under-run */
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;type
op_ne
id|TYPE_TAPE
op_logical_and
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|retries
OL
id|MAX_INTERNAL_RETRIES
)paren
(brace
macro_line|#if defined(DID_SOFT_ERROR)
id|status
op_assign
id|DID_SOFT_ERROR
op_lshift
l_int|16
suffix:semicolon
macro_line|#else
id|status
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
macro_line|#endif
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|retries
op_increment
suffix:semicolon
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|last_retried_pid
op_assign
id|SCpnt-&gt;pid
suffix:semicolon
)brace
r_else
id|status
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
multiline_comment|/* Invalid command */
r_case
l_int|0x02
suffix:colon
multiline_comment|/* Invalid parameters */
r_case
l_int|0x03
suffix:colon
multiline_comment|/* Invalid data list */
r_case
l_int|0x84
suffix:colon
multiline_comment|/* SCSI bus abort error */
r_case
l_int|0x9b
suffix:colon
multiline_comment|/* Auto request sense error */
r_case
l_int|0x9f
suffix:colon
multiline_comment|/* Unexpected command complete message error */
r_case
l_int|0xff
suffix:colon
multiline_comment|/* Invalid parameter in the S/G list */
r_default
suffix:colon
id|status
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
)brace
id|SCpnt-&gt;result
op_assign
id|status
op_or
id|spp-&gt;target_status
suffix:semicolon
macro_line|#if defined(DEBUG_INTERRUPT)
r_if
c_cond
(paren
id|SCpnt-&gt;result
op_logical_or
id|do_trace
)paren
macro_line|#else
r_if
c_cond
(paren
(paren
id|spp-&gt;adapter_status
op_ne
id|ASOK
op_logical_and
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
OG
l_int|1000
)paren
op_logical_or
(paren
id|spp-&gt;adapter_status
op_ne
id|ASOK
op_logical_and
id|spp-&gt;adapter_status
op_ne
id|ASST
op_logical_and
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
op_le
l_int|1000
)paren
op_logical_or
id|do_trace
op_logical_or
id|msg_byte
c_func
(paren
id|spp-&gt;target_status
)paren
)paren
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, mbox %2d, err 0x%x:%x,&quot;
"&bslash;"
l_string|&quot; target %d.%d:%d, pid %ld, reg 0x%x, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|i
comma
id|spp-&gt;adapter_status
comma
id|spp-&gt;target_status
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;pid
comma
id|reg
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
multiline_comment|/* Set the command state to inactive */
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_trace
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ihdlr, exit, irq %d, count %d.&bslash;n&quot;
comma
id|BN
c_func
(paren
id|j
)paren
comma
id|irq
comma
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|iocount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|do_interrupt_handler
r_static
r_void
id|do_interrupt_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|shap
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|j
suffix:semicolon
id|SPIN_FLAGS
multiline_comment|/* Check if the interrupt must be processed by this handler */
r_if
c_cond
(paren
(paren
id|j
op_assign
(paren
r_int
r_int
)paren
(paren
(paren
r_char
op_star
)paren
id|shap
op_minus
id|sha
)paren
)paren
op_ge
id|num_boards
)paren
r_return
suffix:semicolon
id|SPIN_LOCK_SAVE
id|ihdlr
c_func
(paren
id|irq
comma
id|j
)paren
suffix:semicolon
id|SPIN_UNLOCK_RESTORE
)brace
DECL|function|u14_34f_release
r_int
id|u14_34f_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_int
r_int
id|i
comma
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|sh
(braket
id|j
)braket
op_ne
l_int|NULL
op_logical_and
id|sh
(braket
id|j
)braket
op_ne
id|shpnt
suffix:semicolon
id|j
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;%s: release, invalid Scsi_Host pointer.&bslash;n&quot;
comma
id|driver_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|unchecked_isa_dma
)paren
(brace
id|scsi_deregister_blocked_host
c_func
(paren
id|sh
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|can_queue
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
)paren
op_member_access_from_pointer
id|sglist
)paren
id|kfree
c_func
(paren
(paren
op_amp
id|HD
c_func
(paren
id|j
)paren
op_member_access_from_pointer
id|cp
(braket
id|i
)braket
)paren
op_member_access_from_pointer
id|sglist
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|irq
comma
op_amp
id|sha
(braket
id|j
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|dma_channel
op_ne
id|NO_DMA
)paren
id|free_dma
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|dma_channel
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|io_port
comma
id|sh
(braket
id|j
)braket
op_member_access_from_pointer
id|n_io_port
)paren
suffix:semicolon
id|scsi_unregister
c_func
(paren
id|sh
(braket
id|j
)braket
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|ULTRASTOR_14_34F
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
macro_line|#ifndef MODULE
id|__setup
c_func
(paren
l_string|&quot;u14-34f=&quot;
comma
id|option_setup
)paren
suffix:semicolon
macro_line|#endif /* end MODULE */
eof
