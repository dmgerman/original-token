multiline_comment|/*&n; *  scsi.c Copyright (C) 1992 Drew Eckhardt&n; *         Copyright (C) 1993, 1994, 1995, 1999 Eric Youngdale&n; *&n; *  generic mid-level SCSI driver&n; *      Initial versions: Drew Eckhardt&n; *      Subsequent revisions: Eric Youngdale&n; *&n; *  &lt;drew@colorado.edu&gt;&n; *&n; *  Bug correction thanks go to :&n; *      Rik Faith &lt;faith@cs.unc.edu&gt;&n; *      Tommy Thorn &lt;tthorn&gt;&n; *      Thomas Wuensche &lt;tw@fgb1.fgb.mw.tu-muenchen.de&gt;&n; *&n; *  Modified by Eric Youngdale eric@andante.org or ericy@gnu.ai.mit.edu to&n; *  add scatter-gather, multiple outstanding request, and other&n; *  enhancements.&n; *&n; *  Native multichannel, wide scsi, /proc/scsi and hot plugging&n; *  support added by Michael Neuffer &lt;mike@i-connect.net&gt;&n; *&n; *  Added request_module(&quot;scsi_hostadapter&quot;) for kerneld:&n; *  (Put an &quot;alias scsi_hostadapter your_hostadapter&quot; in /etc/modules.conf)&n; *  Bjorn Ekwall  &lt;bj0rn@blox.se&gt;&n; *  (changed to kmod)&n; *&n; *  Major improvements to the timeout, abort, and reset processing,&n; *  as well as performance modifications for large queue depths by&n; *  Leonard N. Zubkoff &lt;lnz@dandelion.com&gt;&n; *&n; *  Converted cli() code to spinlocks, Ingo Molnar&n; *&n; *  Jiffies wrap fixes (host-&gt;resetting), 3 Dec 1998 Andrea Arcangeli&n; *&n; *  out_of_space hacks, D. Gilbert (dpg) 990608&n; */
DECL|macro|REVISION
mdefine_line|#define REVISION&t;&quot;Revision: 1.00&quot;
DECL|macro|VERSION
mdefine_line|#define VERSION&t;&t;&quot;Id: scsi.c 1.00 2000/09/26&quot;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#ifdef CONFIG_KMOD
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#endif
DECL|macro|USE_STATIC_SCSI_MEMORY
macro_line|#undef USE_STATIC_SCSI_MEMORY
DECL|variable|proc_scsi
r_struct
id|proc_dir_entry
op_star
id|proc_scsi
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_static
r_int
id|scsi_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
suffix:semicolon
r_static
r_void
id|scsi_dump_status
c_func
(paren
r_int
id|level
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;   static const char RCSid[] = &quot;$Header: /vger/u4/cvs/linux/drivers/scsi/scsi.c,v 1.38 1997/01/19 23:07:18 davem Exp $&quot;;&n; */
multiline_comment|/*&n; * Definitions and constants.&n; */
DECL|macro|MIN_RESET_DELAY
mdefine_line|#define MIN_RESET_DELAY (2*HZ)
multiline_comment|/* Do not call reset on error if we just did a reset within 15 sec. */
DECL|macro|MIN_RESET_PERIOD
mdefine_line|#define MIN_RESET_PERIOD (15*HZ)
multiline_comment|/*&n; * Data declarations.&n; */
DECL|variable|scsi_pid
r_int
r_int
id|scsi_pid
suffix:semicolon
DECL|variable|last_cmnd
id|Scsi_Cmnd
op_star
id|last_cmnd
suffix:semicolon
multiline_comment|/* Command groups 3 and 4 are reserved and should never be used.  */
DECL|variable|scsi_command_size
r_const
r_int
r_char
id|scsi_command_size
(braket
l_int|8
)braket
op_assign
(brace
l_int|6
comma
l_int|10
comma
l_int|10
comma
l_int|12
comma
l_int|12
comma
l_int|12
comma
l_int|10
comma
l_int|10
)brace
suffix:semicolon
DECL|variable|serial_number
r_static
r_int
r_int
id|serial_number
suffix:semicolon
DECL|variable|scsi_bh_queue_head
r_static
id|Scsi_Cmnd
op_star
id|scsi_bh_queue_head
suffix:semicolon
DECL|variable|scsi_bh_queue_tail
r_static
id|Scsi_Cmnd
op_star
id|scsi_bh_queue_tail
suffix:semicolon
multiline_comment|/*&n; * Note - the initial logging level can be set here to log events at boot time.&n; * After the system is up, you may enable logging via the /proc interface.&n; */
DECL|variable|scsi_logging_level
r_int
r_int
id|scsi_logging_level
suffix:semicolon
DECL|variable|scsi_device_types
r_const
r_char
op_star
r_const
id|scsi_device_types
(braket
id|MAX_SCSI_DEVICE_CODE
)braket
op_assign
(brace
l_string|&quot;Direct-Access    &quot;
comma
l_string|&quot;Sequential-Access&quot;
comma
l_string|&quot;Printer          &quot;
comma
l_string|&quot;Processor        &quot;
comma
l_string|&quot;WORM             &quot;
comma
l_string|&quot;CD-ROM           &quot;
comma
l_string|&quot;Scanner          &quot;
comma
l_string|&quot;Optical Device   &quot;
comma
l_string|&quot;Medium Changer   &quot;
comma
l_string|&quot;Communications   &quot;
comma
l_string|&quot;Unknown          &quot;
comma
l_string|&quot;Unknown          &quot;
comma
l_string|&quot;Unknown          &quot;
comma
l_string|&quot;Enclosure        &quot;
comma
)brace
suffix:semicolon
multiline_comment|/* &n; * Function prototypes.&n; */
r_extern
r_void
id|scsi_times_out
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_void
id|scsi_build_commandblocks
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/*&n; * These are the interface to the old error handling code.  It should go away&n; * someday soon.&n; */
r_extern
r_void
id|scsi_old_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_extern
r_void
id|scsi_old_times_out
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n; * Function:    scsi_initialize_queue()&n; *&n; * Purpose:     Selects queue handler function for a device.&n; *&n; * Arguments:   SDpnt   - device for which we need a handler function.&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: No locking assumed or required.&n; *&n; * Notes:       Most devices will end up using scsi_request_fn for the&n; *              handler function (at least as things are done now).&n; *              The &quot;block&quot; feature basically ensures that only one of&n; *              the blocked hosts is active at one time, mainly to work around&n; *              buggy DMA chipsets where the memory gets starved.&n; *              For this case, we have a special handler function, which&n; *              does some checks and ultimately calls scsi_request_fn.&n; *&n; *              The single_lun feature is a similar special case.&n; *&n; *              We handle these things by stacking the handlers.  The&n; *              special case handlers simply check a few conditions,&n; *              and return if they are not supposed to do anything.&n; *              In the event that things are OK, then they call the next&n; *              handler in the list - ultimately they call scsi_request_fn&n; *              to do the dirty deed.&n; */
DECL|function|scsi_initialize_queue
r_void
id|scsi_initialize_queue
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
comma
r_struct
id|Scsi_Host
op_star
id|SHpnt
)paren
(brace
id|blk_init_queue
c_func
(paren
op_amp
id|SDpnt-&gt;request_queue
comma
id|scsi_request_fn
)paren
suffix:semicolon
id|blk_queue_headactive
c_func
(paren
op_amp
id|SDpnt-&gt;request_queue
comma
l_int|0
)paren
suffix:semicolon
id|SDpnt-&gt;request_queue.queuedata
op_assign
(paren
r_void
op_star
)paren
id|SDpnt
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|scsi_logging_level
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|scsi_logging_level
comma
l_string|&quot;SCSI logging level; should be zero or nonzero&quot;
)paren
suffix:semicolon
macro_line|#else
DECL|function|scsi_logging_setup
r_static
r_int
id|__init
id|scsi_logging_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|tmp
)paren
op_eq
l_int|1
)paren
(brace
id|scsi_logging_level
op_assign
(paren
id|tmp
ques
c_cond
op_complement
l_int|0
suffix:colon
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi_logging_setup : usage scsi_logging_level=n &quot;
l_string|&quot;(n should be 0 or non-zero)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|__setup
c_func
(paren
l_string|&quot;scsi_logging=&quot;
comma
id|scsi_logging_setup
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;Issue a command and wait for it to complete&n; */
DECL|function|scsi_wait_done
r_static
r_void
id|scsi_wait_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
id|req
op_assign
op_amp
id|SCpnt-&gt;request
suffix:semicolon
id|req-&gt;rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
multiline_comment|/* Busy, but indicate request done */
r_if
c_cond
(paren
id|req-&gt;sem
op_ne
l_int|NULL
)paren
(brace
id|up
c_func
(paren
id|req-&gt;sem
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This lock protects the freelist for all devices on the system.&n; * We could make this finer grained by having a single lock per&n; * device if it is ever found that there is excessive contention&n; * on this lock.&n; */
DECL|variable|device_request_lock
r_static
id|spinlock_t
id|device_request_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Used to protect insertion into and removal from the queue of&n; * commands to be processed by the bottom half handler.&n; */
DECL|variable|scsi_bhqueue_lock
r_static
id|spinlock_t
id|scsi_bhqueue_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Function:    scsi_allocate_request&n; *&n; * Purpose:     Allocate a request descriptor.&n; *&n; * Arguments:   device    - device for which we want a request&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; *&n; * Returns:     Pointer to request block.&n; *&n; * Notes:       With the new queueing code, it becomes important&n; *              to track the difference between a command and a&n; *              request.  A request is a pending item in the queue that&n; *              has not yet reached the top of the queue.&n; */
DECL|function|scsi_allocate_request
id|Scsi_Request
op_star
id|scsi_allocate_request
c_func
(paren
id|Scsi_Device
op_star
id|device
)paren
(brace
id|Scsi_Request
op_star
id|SRpnt
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
id|panic
c_func
(paren
l_string|&quot;No device passed to scsi_allocate_request().&bslash;n&quot;
)paren
suffix:semicolon
id|SRpnt
op_assign
(paren
id|Scsi_Request
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Request
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SRpnt
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|SRpnt
comma
l_int|0
comma
r_sizeof
(paren
id|Scsi_Request
)paren
)paren
suffix:semicolon
id|SRpnt-&gt;sr_device
op_assign
id|device
suffix:semicolon
id|SRpnt-&gt;sr_host
op_assign
id|device-&gt;host
suffix:semicolon
id|SRpnt-&gt;sr_magic
op_assign
id|SCSI_REQ_MAGIC
suffix:semicolon
id|SRpnt-&gt;sr_data_direction
op_assign
id|SCSI_DATA_UNKNOWN
suffix:semicolon
r_return
id|SRpnt
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_release_request&n; *&n; * Purpose:     Release a request descriptor.&n; *&n; * Arguments:   device    - device for which we want a request&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; *&n; * Returns:     Pointer to request block.&n; *&n; * Notes:       With the new queueing code, it becomes important&n; *              to track the difference between a command and a&n; *              request.  A request is a pending item in the queue that&n; *              has not yet reached the top of the queue.  We still need&n; *              to free a request when we are done with it, of course.&n; */
DECL|function|scsi_release_request
r_void
id|scsi_release_request
c_func
(paren
id|Scsi_Request
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;sr_command
op_ne
l_int|NULL
)paren
(brace
id|scsi_release_command
c_func
(paren
id|req-&gt;sr_command
)paren
suffix:semicolon
id|req-&gt;sr_command
op_assign
l_int|NULL
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_allocate_device&n; *&n; * Purpose:     Allocate a command descriptor.&n; *&n; * Arguments:   device    - device for which we want a command descriptor&n; *              wait      - 1 if we should wait in the event that none&n; *                          are available.&n; *              interruptible - 1 if we should unblock and return NULL&n; *                          in the event that we must wait, and a signal&n; *                          arrives.&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; *&n; * Returns:     Pointer to command descriptor.&n; *&n; * Notes:       Prior to the new queue code, this function was not SMP-safe.&n; *&n; *              If the wait flag is true, and we are waiting for a free&n; *              command block, this function will interrupt and return&n; *              NULL in the event that a signal arrives that needs to&n; *              be handled.&n; *&n; *              This function is deprecated, and drivers should be&n; *              rewritten to use Scsi_Request instead of Scsi_Cmnd.&n; */
DECL|function|scsi_allocate_device
id|Scsi_Cmnd
op_star
id|scsi_allocate_device
c_func
(paren
id|Scsi_Device
op_star
id|device
comma
r_int
id|wait
comma
r_int
id|interruptable
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
id|panic
c_func
(paren
l_string|&quot;No device passed to scsi_allocate_device().&bslash;n&quot;
)paren
suffix:semicolon
id|host
op_assign
id|device-&gt;host
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
op_eq
l_int|1
)paren
(brace
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;device_blocked
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;single_lun
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * FIXME(eric) - this is not at all optimal.  Given that&n;&t;&t;&t;&t; * single lun devices are rare and usually slow&n;&t;&t;&t;&t; * (i.e. CD changers), this is good enough for now, but&n;&t;&t;&t;&t; * we may want to come back and optimize this later.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * Scan through all of the devices attached to this&n;&t;&t;&t;&t; * host, and see if any are active or not.  If so,&n;&t;&t;&t;&t; * we need to defer this command.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * We really need a busy counter per device.  This would&n;&t;&t;&t;&t; * allow us to more easily figure out whether we should&n;&t;&t;&t;&t; * do anything here or not.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Only look for other devices on the same bus&n;&t;&t;&t;&t;&t; * with the same target ID.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|SDpnt-&gt;channel
op_ne
id|device-&gt;channel
op_logical_or
id|SDpnt-&gt;id
op_ne
id|device-&gt;id
op_logical_or
id|SDpnt
op_eq
id|device
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|SDpnt-&gt;device_active
)paren
op_ne
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SDpnt
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Some other device in this cluster is busy.&n;&t;&t;&t;&t;&t; * If asked to wait, we need to wait, otherwise&n;&t;&t;&t;&t;&t; * return NULL.&n;&t;&t;&t;&t;&t; */
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|busy
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Now we can check for a free command block for this device.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|SCpnt
op_assign
id|device-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_eq
id|RQ_INACTIVE
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * If we couldn&squot;t find a free command block, and we have been&n;&t;&t; * asked to wait, then do so.&n;&t;&t; */
r_if
c_cond
(paren
id|SCpnt
)paren
(brace
r_break
suffix:semicolon
)brace
id|busy
suffix:colon
multiline_comment|/*&n;&t;&t; * If we have been asked to wait for a free block, then&n;&t;&t; * wait here.&n;&t;&t; */
r_if
c_cond
(paren
id|wait
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
multiline_comment|/*&n;                         * We need to wait for a free commandblock.  We need to&n;                         * insert ourselves into the list before we release the&n;                         * lock.  This way if a block were released the same&n;                         * microsecond that we released the lock, the call&n;                         * to schedule() wouldn&squot;t block (well, it might switch,&n;                         * but the current task will still be schedulable.&n;                         */
id|add_wait_queue
c_func
(paren
op_amp
id|device-&gt;scpnt_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|interruptable
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
)brace
r_else
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * This should block until a device command block&n;&t;&t;&t; * becomes available.&n;&t;&t;&t; */
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|device-&gt;scpnt_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/*&n;                         * FIXME - Isn&squot;t this redundant??  Someone&n;                         * else will have forced the state back to running.&n;                         */
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
multiline_comment|/*&n;                         * In the event that a signal has arrived that we need&n;                         * to consider, then simply return NULL.  Everyone&n;                         * that calls us should be prepared for this&n;                         * possibility, and pass the appropriate code back&n;                         * to the user.&n;                         */
r_if
c_cond
(paren
id|interruptable
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* And no one is waiting for this&n;&t;&t;&t;&t;&t; * to complete */
id|atomic_inc
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|SCpnt-&gt;device-&gt;device_active
)paren
suffix:semicolon
id|SCpnt-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;bufflen
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the scatter-gather flag */
id|SCpnt-&gt;old_use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No default transfer size */
id|SCpnt-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;sc_data_direction
op_assign
id|SCSI_DATA_UNKNOWN
suffix:semicolon
id|SCpnt-&gt;sc_request
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;sc_magic
op_assign
id|SCSI_CMND_MAGIC
suffix:semicolon
id|SCpnt-&gt;result
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do not flag underflow conditions */
id|SCpnt-&gt;old_underflow
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;resid
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_INITIALIZING
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_HIGHLEVEL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Activating command for device %d (%d)&bslash;n&quot;
comma
id|SCpnt-&gt;target
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
)paren
)paren
suffix:semicolon
r_return
id|SCpnt
suffix:semicolon
)brace
DECL|function|__scsi_release_command
r_inline
r_void
id|__scsi_release_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
id|SDpnt
op_assign
id|SCpnt-&gt;device
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_UNUSED
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_NOBODY
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|SDpnt-&gt;device_active
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Deactivating command for device %d (active=%d, failed=%d)&bslash;n&quot;
comma
id|SCpnt-&gt;target
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
comma
id|SCpnt-&gt;host-&gt;host_failed
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;host_failed
op_ne
l_int|0
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Error handler thread %d %d&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;in_recovery
comma
id|SCpnt-&gt;host-&gt;eh_active
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the host is having troubles, then look to see if this was the last&n;&t; * command that might have failed.  If so, wake up the error handler.&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;in_recovery
op_logical_and
op_logical_neg
id|SCpnt-&gt;host-&gt;eh_active
op_logical_and
id|SCpnt-&gt;host-&gt;host_busy
op_eq
id|SCpnt-&gt;host-&gt;host_failed
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Waking error handler thread (%d)&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;eh_wait-&gt;count
)paren
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
id|SCpnt-&gt;host-&gt;eh_wait
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;         * Wake up anyone waiting for this device.  Do this after we&n;         * have released the lock, as they will need it as soon as&n;         * they wake up.  &n;         */
id|wake_up
c_func
(paren
op_amp
id|SDpnt-&gt;scpnt_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_release_command&n; *&n; * Purpose:     Release a command block.&n; *&n; * Arguments:   SCpnt - command block we are releasing.&n; *&n; * Notes:       The command block can no longer be used by the caller once&n; *              this funciton is called.  This is in effect the inverse&n; *              of scsi_allocate_device.  Note that we also must perform&n; *              a couple of additional tasks.  We must first wake up any&n; *              processes that might have blocked waiting for a command&n; *              block, and secondly we must hit the queue handler function&n; *              to make sure that the device is busy.  Note - there is an&n; *              option to not do this - there were instances where we could&n; *              recurse too deeply and blow the stack if this happened&n; *              when we were indirectly called from the request function&n; *              itself.&n; *&n; *              The idea is that a lot of the mid-level internals gunk&n; *              gets hidden in this function.  Upper level drivers don&squot;t&n; *              have any chickens to wave in the air to get things to&n; *              work reliably.&n; *&n; *              This function is deprecated, and drivers should be&n; *              rewritten to use Scsi_Request instead of Scsi_Cmnd.&n; */
DECL|function|scsi_release_command
r_void
id|scsi_release_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|request_queue_t
op_star
id|q
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SCpnt-&gt;device
suffix:semicolon
id|__scsi_release_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n;         * Finally, hit the queue request function to make sure that&n;         * the device is actually busy if there are requests present.&n;         * This won&squot;t block - if the device cannot take any more, life&n;         * will go on.  &n;         */
id|q
op_assign
op_amp
id|SDpnt-&gt;request_queue
suffix:semicolon
id|scsi_queue_next_request
c_func
(paren
id|q
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_dispatch_command&n; *&n; * Purpose:     Dispatch a command to the low-level driver.&n; *&n; * Arguments:   SCpnt - command block we are dispatching.&n; *&n; * Notes:&n; */
DECL|function|scsi_dispatch_cmd
r_int
id|scsi_dispatch_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
macro_line|#ifdef DEBUG_DELAY
r_int
r_int
id|clock
suffix:semicolon
macro_line|#endif
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_int
id|rtn
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
op_amp
id|io_request_lock
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if DEBUG
r_int
r_int
op_star
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __mips__
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;move&bslash;t%0,$31&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
)paren
suffix:semicolon
macro_line|#else
id|ret
op_assign
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
multiline_comment|/* Assign a unique nonzero serial_number. */
r_if
c_cond
(paren
op_increment
id|serial_number
op_eq
l_int|0
)paren
id|serial_number
op_assign
l_int|1
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
id|serial_number
suffix:semicolon
multiline_comment|/*&n;&t; * We will wait MIN_RESET_DELAY clock ticks after the last reset so&n;&t; * we can avoid the drive not being ready.&n;&t; */
id|timeout
op_assign
id|host-&gt;last_reset
op_plus
id|MIN_RESET_DELAY
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;resetting
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
r_int
id|ticks_remaining
op_assign
id|timeout
op_minus
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t;&t; * NOTE: This may be executed from within an interrupt&n;&t;&t; * handler!  This is bad, but for now, it&squot;ll do.  The irq&n;&t;&t; * level of the interrupt handler has been masked out by the&n;&t;&t; * platform dependent interrupt handling code already, so the&n;&t;&t; * sti() here will not cause another call to the SCSI host&squot;s&n;&t;&t; * interrupt handler (assuming there is one irq-level per&n;&t;&t; * host).&n;&t;&t; */
r_while
c_loop
(paren
op_decrement
id|ticks_remaining
op_ge
l_int|0
)paren
id|mdelay
c_func
(paren
l_int|1
op_plus
l_int|999
op_div
id|HZ
)paren
suffix:semicolon
id|host-&gt;resetting
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|host-&gt;hostt-&gt;use_new_eh_code
)paren
(brace
id|scsi_add_timer
c_func
(paren
id|SCpnt
comma
id|SCpnt-&gt;timeout_per_command
comma
id|scsi_times_out
)paren
suffix:semicolon
)brace
r_else
(brace
id|scsi_add_timer
c_func
(paren
id|SCpnt
comma
id|SCpnt-&gt;timeout_per_command
comma
id|scsi_old_times_out
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We will use a queued command if possible, otherwise we will emulate the&n;&t; * queuing and calling of completion function ourselves.&n;&t; */
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_dispatch_cmnd (host = %d, channel = %d, target = %d, &quot;
l_string|&quot;command = %p, buffer = %p, &bslash;nbufflen = %d, done = %p)&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;bufflen
comma
id|SCpnt-&gt;done
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_QUEUED
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;can_queue
)paren
(brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;queuecommand : routine at %p&bslash;n&quot;
comma
id|host-&gt;hostt-&gt;queuecommand
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Use the old error handling code if we haven&squot;t converted the driver&n;&t;&t; * to use the new one yet.  Note - only the new queuecommand variant&n;&t;&t; * passes a meaningful return value.&n;&t;&t; */
r_if
c_cond
(paren
id|host-&gt;hostt-&gt;use_new_eh_code
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|rtn
op_assign
id|host-&gt;hostt
op_member_access_from_pointer
id|queuecommand
c_func
(paren
id|SCpnt
comma
id|scsi_done
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_ne
l_int|0
)paren
(brace
id|scsi_delete_timer
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|scsi_mlqueue_insert
c_func
(paren
id|SCpnt
comma
id|SCSI_MLQUEUE_HOST_BUSY
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;queuecommand : request rejected&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|host-&gt;hostt
op_member_access_from_pointer
id|queuecommand
c_func
(paren
id|SCpnt
comma
id|scsi_old_done
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|temp
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;command() :  routine at %p&bslash;n&quot;
comma
id|host-&gt;hostt-&gt;command
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|temp
op_assign
id|host-&gt;hostt
op_member_access_from_pointer
id|command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|temp
suffix:semicolon
macro_line|#ifdef DEBUG_DELAY
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|clock
op_assign
id|jiffies
op_plus
l_int|4
op_star
id|HZ
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|clock
)paren
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;done(host = %d, result = %04x) : routine at %p&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|temp
comma
id|host-&gt;hostt-&gt;command
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|host-&gt;hostt-&gt;use_new_eh_code
)paren
(brace
id|scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
r_else
(brace
id|scsi_old_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;leaving scsi_dispatch_cmnd()&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
DECL|variable|scsi_devfs_handle
id|devfs_handle_t
id|scsi_devfs_handle
suffix:semicolon
multiline_comment|/*&n; * scsi_do_cmd sends all the commands out to the low-level driver.  It&n; * handles the specifics required for each low level driver - ie queued&n; * or non queued.  It also prevents conflicts when different high level&n; * drivers go for the same host at the same time.&n; */
DECL|function|scsi_wait_req
r_void
id|scsi_wait_req
(paren
id|Scsi_Request
op_star
id|SRpnt
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_int
id|timeout
comma
r_int
id|retries
)paren
(brace
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|sem
)paren
suffix:semicolon
id|SRpnt-&gt;sr_request.sem
op_assign
op_amp
id|sem
suffix:semicolon
id|SRpnt-&gt;sr_request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|scsi_do_req
(paren
id|SRpnt
comma
(paren
r_void
op_star
)paren
id|cmnd
comma
id|buffer
comma
id|bufflen
comma
id|scsi_wait_done
comma
id|timeout
comma
id|retries
)paren
suffix:semicolon
id|down
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|SRpnt-&gt;sr_request.sem
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|SRpnt-&gt;sr_command
op_ne
l_int|NULL
)paren
(brace
id|scsi_release_command
c_func
(paren
id|SRpnt-&gt;sr_command
)paren
suffix:semicolon
id|SRpnt-&gt;sr_command
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:    scsi_do_req&n; *&n; * Purpose:     Queue a SCSI request&n; *&n; * Arguments:   SRpnt     - command descriptor.&n; *              cmnd      - actual SCSI command to be performed.&n; *              buffer    - data buffer.&n; *              bufflen   - size of data buffer.&n; *              done      - completion function to be run.&n; *              timeout   - how long to let it run before timeout.&n; *              retries   - number of retries we allow.&n; *&n; * Lock status: With the new queueing code, this is SMP-safe, and no locks&n; *              need be held upon entry.   The old queueing code the lock was&n; *              assumed to be held upon entry.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:       Prior to the new queue code, this function was not SMP-safe.&n; *              Also, this function is now only used for queueing requests&n; *              for things like ioctls and character device requests - this&n; *              is because we essentially just inject a request into the&n; *              queue for the device. Normal block device handling manipulates&n; *              the queue directly.&n; */
DECL|function|scsi_do_req
r_void
id|scsi_do_req
c_func
(paren
id|Scsi_Request
op_star
id|SRpnt
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
comma
r_int
id|timeout
comma
r_int
id|retries
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
op_assign
id|SRpnt-&gt;sr_device
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SDpnt-&gt;host
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
op_amp
id|io_request_lock
comma
l_int|0
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|4
comma
(brace
r_int
id|i
suffix:semicolon
r_int
id|target
op_assign
id|SDpnt-&gt;id
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi_do_req (host = %d, channel = %d target = %d, &quot;
l_string|&quot;buffer =%p, bufflen = %d, done = %p, timeout = %d, &quot;
l_string|&quot;retries = %d)&bslash;n&quot;
l_string|&quot;command : &quot;
comma
id|host-&gt;host_no
comma
id|SDpnt-&gt;channel
comma
id|target
comma
id|buffer
comma
id|bufflen
comma
id|done
comma
id|timeout
comma
id|retries
)paren
suffix:semicolon
r_for
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;%02x  &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Invalid or not present host.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the upper level driver is reusing these things, then&n;&t; * we should release the low-level block now.  Another one will&n;&t; * be allocated later when this request is getting queued.&n;&t; */
r_if
c_cond
(paren
id|SRpnt-&gt;sr_command
op_ne
l_int|NULL
)paren
(brace
id|scsi_release_command
c_func
(paren
id|SRpnt-&gt;sr_command
)paren
suffix:semicolon
id|SRpnt-&gt;sr_command
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We must prevent reentrancy to the lowlevel host driver.  This prevents&n;&t; * it - we enter a loop until the host we want to talk to is not busy.&n;&t; * Race conditions are prevented, as interrupts are disabled in between the&n;&t; * time we check for the host being not busy, and the time we mark it busy&n;&t; * ourselves.&n;&t; */
multiline_comment|/*&n;&t; * Our own function scsi_done (which marks the host as not busy, disables&n;&t; * the timeout counter, etc) will be called by us or by the&n;&t; * scsi_hosts[host].queuecommand() function needs to also call&n;&t; * the completion function for the high level driver.&n;&t; */
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SRpnt-&gt;sr_cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|cmnd
comma
r_sizeof
(paren
id|SRpnt-&gt;sr_cmnd
)paren
)paren
suffix:semicolon
id|SRpnt-&gt;sr_bufflen
op_assign
id|bufflen
suffix:semicolon
id|SRpnt-&gt;sr_buffer
op_assign
id|buffer
suffix:semicolon
id|SRpnt-&gt;sr_allowed
op_assign
id|retries
suffix:semicolon
id|SRpnt-&gt;sr_done
op_assign
id|done
suffix:semicolon
id|SRpnt-&gt;sr_timeout_per_command
op_assign
id|timeout
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SRpnt-&gt;sr_cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|cmnd
comma
r_sizeof
(paren
id|SRpnt-&gt;sr_cmnd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SRpnt-&gt;sr_cmd_len
op_eq
l_int|0
)paren
id|SRpnt-&gt;sr_cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|SRpnt-&gt;sr_cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point, we merely set up the command, stick it in the normal&n;&t; * request queue, and return.  Eventually that request will come to the&n;&t; * top of the list, and will be dispatched.&n;&t; */
id|scsi_insert_special_req
c_func
(paren
id|SRpnt
comma
l_int|0
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Leaving scsi_do_cmd()&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_init_cmd_from_req&n; *&n; * Purpose:     Queue a SCSI command&n; * Purpose:     Initialize a Scsi_Cmnd from a Scsi_Request&n; *&n; * Arguments:   SCpnt     - command descriptor.&n; *              SRpnt     - Request from the queue.&n; *&n; * Lock status: None needed.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:       Mainly transfer data from the request structure to the&n; *              command structure.  The request structure is allocated&n; *              using the normal memory allocator, and requests can pile&n; *              up to more or less any depth.  The command structure represents&n; *              a consumable resource, as these are allocated into a pool&n; *              when the SCSI subsystem initializes.  The preallocation is&n; *              required so that in low-memory situations a disk I/O request&n; *              won&squot;t cause the memory manager to try and write out a page.&n; *              The request structure is generally used by ioctls and character&n; *              devices.&n; */
DECL|function|scsi_init_cmd_from_req
r_void
id|scsi_init_cmd_from_req
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
id|Scsi_Request
op_star
id|SRpnt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
op_amp
id|io_request_lock
comma
l_int|0
)paren
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_MIDLEVEL
suffix:semicolon
id|SRpnt-&gt;sr_command
op_assign
id|SCpnt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Invalid or not present host.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|SCpnt-&gt;cmd_len
op_assign
id|SRpnt-&gt;sr_cmd_len
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SRpnt-&gt;sr_use_sg
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|SCpnt-&gt;request
comma
(paren
r_const
r_void
op_star
)paren
op_amp
id|SRpnt-&gt;sr_request
comma
r_sizeof
(paren
id|SRpnt-&gt;sr_request
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|SRpnt-&gt;sr_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;bufflen
op_assign
id|SRpnt-&gt;sr_bufflen
suffix:semicolon
id|SCpnt-&gt;buffer
op_assign
id|SRpnt-&gt;sr_buffer
suffix:semicolon
id|SCpnt-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;retries
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;allowed
op_assign
id|SRpnt-&gt;sr_allowed
suffix:semicolon
id|SCpnt-&gt;done
op_assign
id|SRpnt-&gt;sr_done
suffix:semicolon
id|SCpnt-&gt;timeout_per_command
op_assign
id|SRpnt-&gt;sr_timeout_per_command
suffix:semicolon
id|SCpnt-&gt;sc_data_direction
op_assign
id|SRpnt-&gt;sr_data_direction
suffix:semicolon
id|SCpnt-&gt;sglist_len
op_assign
id|SRpnt-&gt;sr_sglist_len
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
id|SRpnt-&gt;sr_underflow
suffix:semicolon
id|SCpnt-&gt;sc_request
op_assign
id|SRpnt
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|SRpnt-&gt;sr_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;cmnd
)paren
)paren
suffix:semicolon
multiline_comment|/* Zero the sense buffer.  Some host adapters automatically request&n;&t; * sense on error.  0 is not a valid sense code.&n;&t; */
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|SRpnt-&gt;sr_buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|SRpnt-&gt;sr_bufflen
suffix:semicolon
id|SCpnt-&gt;old_use_sg
op_assign
id|SCpnt-&gt;use_sg
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;cmd_len
op_eq
l_int|0
)paren
id|SCpnt-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|SCpnt-&gt;old_cmd_len
op_assign
id|SCpnt-&gt;cmd_len
suffix:semicolon
id|SCpnt-&gt;sc_old_data_direction
op_assign
id|SCpnt-&gt;sc_data_direction
suffix:semicolon
id|SCpnt-&gt;old_underflow
op_assign
id|SCpnt-&gt;underflow
suffix:semicolon
multiline_comment|/* Start the timer ticking.  */
id|SCpnt-&gt;internal_timeout
op_assign
id|NORMAL_TIMEOUT
suffix:semicolon
id|SCpnt-&gt;abort_reason
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;result
op_assign
l_int|0
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Leaving scsi_do_cmd()&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_do_cmd&n; *&n; * Purpose:     Queue a SCSI command&n; *&n; * Arguments:   SCpnt     - command descriptor.&n; *              cmnd      - actual SCSI command to be performed.&n; *              buffer    - data buffer.&n; *              bufflen   - size of data buffer.&n; *              done      - completion function to be run.&n; *              timeout   - how long to let it run before timeout.&n; *              retries   - number of retries we allow.&n; *&n; * Lock status: With the new queueing code, this is SMP-safe, and no locks&n; *              need be held upon entry.   The old queueing code the lock was&n; *              assumed to be held upon entry.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:       Prior to the new queue code, this function was not SMP-safe.&n; *              Also, this function is now only used for queueing requests&n; *              for things like ioctls and character device requests - this&n; *              is because we essentially just inject a request into the&n; *              queue for the device. Normal block device handling manipulates&n; *              the queue directly.&n; */
DECL|function|scsi_do_cmd
r_void
id|scsi_do_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
comma
r_int
id|timeout
comma
r_int
id|retries
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
op_amp
id|io_request_lock
comma
l_int|0
)paren
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_MIDLEVEL
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|4
comma
(brace
r_int
id|i
suffix:semicolon
r_int
id|target
op_assign
id|SCpnt-&gt;target
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi_do_cmd (host = %d, channel = %d target = %d, &quot;
l_string|&quot;buffer =%p, bufflen = %d, done = %p, timeout = %d, &quot;
l_string|&quot;retries = %d)&bslash;n&quot;
l_string|&quot;command : &quot;
comma
id|host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|target
comma
id|buffer
comma
id|bufflen
comma
id|done
comma
id|timeout
comma
id|retries
)paren
suffix:semicolon
r_for
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;%02x  &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Invalid or not present host.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We must prevent reentrancy to the lowlevel host driver.  This prevents&n;&t; * it - we enter a loop until the host we want to talk to is not busy.&n;&t; * Race conditions are prevented, as interrupts are disabled in between the&n;&t; * time we check for the host being not busy, and the time we mark it busy&n;&t; * ourselves.&n;&t; */
multiline_comment|/*&n;&t; * Our own function scsi_done (which marks the host as not busy, disables&n;&t; * the timeout counter, etc) will be called by us or by the&n;&t; * scsi_hosts[host].queuecommand() function needs to also call&n;&t; * the completion function for the high level driver.&n;&t; */
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;bufflen
op_assign
id|bufflen
suffix:semicolon
id|SCpnt-&gt;buffer
op_assign
id|buffer
suffix:semicolon
id|SCpnt-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;retries
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;allowed
op_assign
id|retries
suffix:semicolon
id|SCpnt-&gt;done
op_assign
id|done
suffix:semicolon
id|SCpnt-&gt;timeout_per_command
op_assign
id|timeout
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;cmnd
)paren
)paren
suffix:semicolon
multiline_comment|/* Zero the sense buffer.  Some host adapters automatically request&n;&t; * sense on error.  0 is not a valid sense code.&n;&t; */
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|bufflen
suffix:semicolon
id|SCpnt-&gt;old_use_sg
op_assign
id|SCpnt-&gt;use_sg
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;cmd_len
op_eq
l_int|0
)paren
id|SCpnt-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|SCpnt-&gt;old_cmd_len
op_assign
id|SCpnt-&gt;cmd_len
suffix:semicolon
id|SCpnt-&gt;sc_old_data_direction
op_assign
id|SCpnt-&gt;sc_data_direction
suffix:semicolon
id|SCpnt-&gt;old_underflow
op_assign
id|SCpnt-&gt;underflow
suffix:semicolon
multiline_comment|/* Start the timer ticking.  */
id|SCpnt-&gt;internal_timeout
op_assign
id|NORMAL_TIMEOUT
suffix:semicolon
id|SCpnt-&gt;abort_reason
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * At this point, we merely set up the command, stick it in the normal&n;&t; * request queue, and return.  Eventually that request will come to the&n;&t; * top of the list, and will be dispatched.&n;&t; */
id|scsi_insert_special_cmd
c_func
(paren
id|SCpnt
comma
l_int|0
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Leaving scsi_do_cmd()&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is the mid-level interrupt routine, which decides how&n; *  to handle error conditions.  Each invocation of this function must&n; *  do one and *only* one of the following:&n; *&n; *      1) Insert command in BH queue.&n; *      2) Activate error handler for host.&n; *&n; * FIXME(eric) - I am concerned about stack overflow (still).  An&n; * interrupt could come while we are processing the bottom queue,&n; * which would cause another command to be stuffed onto the bottom&n; * queue, and it would in turn be processed as that interrupt handler&n; * is returning.  Given a sufficiently steady rate of returning&n; * commands, this could cause the stack to overflow.  I am not sure&n; * what is the most appropriate solution here - we should probably&n; * keep a depth count, and not process any commands while we still&n; * have a bottom handler active higher in the stack.&n; *&n; * There is currently code in the bottom half handler to monitor&n; * recursion in the bottom handler and report if it ever happens.  If&n; * this becomes a problem, it won&squot;t be hard to engineer something to&n; * deal with it so that only the outer layer ever does any real&n; * processing.  &n; */
DECL|function|scsi_done
r_void
id|scsi_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|tstatus
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t have to worry about this one timing out any more.&n;&t; */
id|tstatus
op_assign
id|scsi_delete_timer
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we are unable to remove the timer, it means that the command&n;&t; * has already timed out.  In this case, we have no choice but to&n;&t; * let the timeout function run, as we have no idea where in fact&n;&t; * that function could really be.  It might be on another processor,&n;&t; * etc, etc.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tstatus
)paren
(brace
id|SCpnt-&gt;done_late
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Set the serial numbers back to zero */
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * First, see whether this command already timed out.  If so, we ignore&n;&t; * the response.  We treat it as if the command never finished.&n;&t; *&n;&t; * Since serial_number is now 0, the error handler cound detect this&n;&t; * situation and avoid to call the the low level driver abort routine.&n;&t; * (DB)&n;         *&n;         * FIXME(eric) - I believe that this test is now redundant, due to&n;         * the test of the return status of del_timer().&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Ignoring completion of %p due to timeout status&quot;
comma
id|SCpnt
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|scsi_bhqueue_lock
comma
id|flags
)paren
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_BHQUEUE
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_BH_HANDLER
suffix:semicolon
id|SCpnt-&gt;bh_next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Next, put this command in the BH queue.&n;&t; * &n;&t; * We need a spinlock here, or compare and exchange if we can reorder incoming&n;&t; * Scsi_Cmnds, as it happens pretty often scsi_done is called multiple times&n;&t; * before bh is serviced. -jj&n;&t; *&n;&t; * We already have the io_request_lock here, since we are called from the&n;&t; * interrupt handler or the error handler. (DB)&n;&t; *&n;&t; * This may be true at the moment, but I would like to wean all of the low&n;&t; * level drivers away from using io_request_lock.   Technically they should&n;&t; * all use their own locking.  I am adding a small spinlock to protect&n;&t; * this datastructure to make it safe for that day.  (ERY)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|scsi_bh_queue_head
)paren
(brace
id|scsi_bh_queue_head
op_assign
id|SCpnt
suffix:semicolon
id|scsi_bh_queue_tail
op_assign
id|SCpnt
suffix:semicolon
)brace
r_else
(brace
id|scsi_bh_queue_tail-&gt;bh_next
op_assign
id|SCpnt
suffix:semicolon
id|scsi_bh_queue_tail
op_assign
id|SCpnt
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|scsi_bhqueue_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the bottom half handler to be run.&n;&t; */
id|mark_bh
c_func
(paren
id|SCSI_BH
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Procedure:   scsi_bottom_half_handler&n; *&n; * Purpose:     Called after we have finished processing interrupts, it&n; *              performs post-interrupt handling for commands that may&n; *              have completed.&n; *&n; * Notes:       This is called with all interrupts enabled.  This should reduce&n; *              interrupt latency, stack depth, and reentrancy of the low-level&n; *              drivers.&n; *&n; * The io_request_lock is required in all the routine. There was a subtle&n; * race condition when scsi_done is called after a command has already&n; * timed out but before the time out is processed by the error handler.&n; * (DB)&n; *&n; * I believe I have corrected this.  We simply monitor the return status of&n; * del_timer() - if this comes back as 0, it means that the timer has fired&n; * and that a timeout is in progress.   I have modified scsi_done() such&n; * that in this instance the command is never inserted in the bottom&n; * half queue.  Thus the only time we hold the lock here is when&n; * we wish to atomically remove the contents of the queue.&n; */
DECL|function|scsi_bottom_half_handler
r_void
id|scsi_bottom_half_handler
c_func
(paren
r_void
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCnext
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_while
c_loop
(paren
l_int|1
op_eq
l_int|1
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|scsi_bhqueue_lock
comma
id|flags
)paren
suffix:semicolon
id|SCpnt
op_assign
id|scsi_bh_queue_head
suffix:semicolon
id|scsi_bh_queue_head
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|scsi_bhqueue_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
id|SCnext
op_assign
id|SCpnt-&gt;bh_next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCnext
)paren
(brace
id|SCnext
op_assign
id|SCpnt-&gt;bh_next
suffix:semicolon
r_switch
c_cond
(paren
id|scsi_decide_disposition
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_case
id|SUCCESS
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Add to BH queue.&n;&t;&t;&t;&t; */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command finished %d %d 0x%x&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_busy
comma
id|SCpnt-&gt;host-&gt;host_failed
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|scsi_finish_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NEEDS_RETRY
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * We only come in here if we want to retry a command.  The&n;&t;&t;&t;&t; * test to see whether the command should be retried should be&n;&t;&t;&t;&t; * keeping track of the number of tries, so we don&squot;t end up looping,&n;&t;&t;&t;&t; * of course.&n;&t;&t;&t;&t; */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command needs retry %d %d 0x%x&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_busy
comma
id|SCpnt-&gt;host-&gt;host_failed
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|scsi_retry_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ADD_TO_MLQUEUE
suffix:colon
multiline_comment|/* &n;&t;&t;&t;&t; * This typically happens for a QUEUE_FULL message -&n;&t;&t;&t;&t; * typically only when the queue depth is only&n;&t;&t;&t;&t; * approximate for a given device.  Adding a command&n;&t;&t;&t;&t; * to the queue for the device will prevent further commands&n;&t;&t;&t;&t; * from being sent to the device, so we shouldn&squot;t end up&n;&t;&t;&t;&t; * with tons of things being sent down that shouldn&squot;t be.&n;&t;&t;&t;&t; */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command rejected as device queue full, put on ml queue %p&bslash;n&quot;
comma
id|SCpnt
)paren
)paren
suffix:semicolon
id|scsi_mlqueue_insert
c_func
(paren
id|SCpnt
comma
id|SCSI_MLQUEUE_DEVICE_BUSY
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Here we have a fatal error of some sort.  Turn it over to&n;&t;&t;&t;&t; * the error handler.&n;&t;&t;&t;&t; */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command failed %p %x active=%d busy=%d failed=%d&bslash;n&quot;
comma
id|SCpnt
comma
id|SCpnt-&gt;result
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
comma
id|SCpnt-&gt;host-&gt;host_busy
comma
id|SCpnt-&gt;host-&gt;host_failed
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Dump the sense information too.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|status_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
op_amp
id|CHECK_CONDITION
)paren
op_ne
l_int|0
)paren
(brace
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|print_sense
c_func
(paren
l_string|&quot;bh&quot;
comma
id|SCpnt
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;eh_wait
op_ne
l_int|NULL
)paren
(brace
id|SCpnt-&gt;host-&gt;host_failed
op_increment
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_ERROR_HANDLER
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_FAILED
suffix:semicolon
id|SCpnt-&gt;host-&gt;in_recovery
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If the host is having troubles, then look to see if this was the last&n;&t;&t;&t;&t;&t; * command that might have failed.  If so, wake up the error handler.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;host_busy
op_eq
id|SCpnt-&gt;host-&gt;host_failed
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Waking error handler thread (%d)&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;eh_wait-&gt;count
)paren
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
id|SCpnt-&gt;host-&gt;eh_wait
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * We only get here if the error recovery thread has died.&n;&t;&t;&t;&t;&t; */
id|scsi_finish_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* for(; SCpnt...) */
)brace
multiline_comment|/* while(1==1) */
)brace
multiline_comment|/*&n; * Function:    scsi_retry_command&n; *&n; * Purpose:     Send a command back to the low level to be retried.&n; *&n; * Notes:       This command is always executed in the context of the&n; *              bottom half handler, or the error handler thread. Low&n; *              level drivers should not become re-entrant as a result of&n; *              this.&n; */
DECL|function|scsi_retry_command
r_int
id|scsi_retry_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|SCpnt-&gt;buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|SCpnt-&gt;bufflen
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|SCpnt-&gt;old_cmd_len
suffix:semicolon
id|SCpnt-&gt;sc_data_direction
op_assign
id|SCpnt-&gt;sc_old_data_direction
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
id|SCpnt-&gt;old_underflow
suffix:semicolon
multiline_comment|/*&n;         * Zero the sense information from the last time we tried&n;         * this command.&n;         */
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
r_return
id|scsi_dispatch_cmd
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_finish_command&n; *&n; * Purpose:     Pass command off to upper layer for finishing of I/O&n; *              request, waking processes that are waiting on results,&n; *              etc.&n; */
DECL|function|scsi_finish_command
r_void
id|scsi_finish_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|Scsi_Device
op_star
id|device
suffix:semicolon
id|Scsi_Request
op_star
id|SRpnt
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
op_amp
id|io_request_lock
comma
l_int|0
)paren
suffix:semicolon
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|device
op_assign
id|SCpnt-&gt;device
suffix:semicolon
multiline_comment|/*&n;         * We need to protect the decrement, as otherwise a race condition&n;         * would exist.  Fiddling with SCpnt isn&squot;t a problem as the&n;         * design only allows a single SCpnt to be active in only&n;         * one execution context, but the device and host structures are&n;         * shared.&n;         */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|host-&gt;host_busy
op_decrement
suffix:semicolon
multiline_comment|/* Indicate that we are free */
id|device-&gt;device_busy
op_decrement
suffix:semicolon
multiline_comment|/* Decrement device usage counter. */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;         * Clear the flags which say that the device/host is no longer&n;         * capable of accepting new commands.  These are set in scsi_queue.c&n;         * for both the queue full condition on a device, and for a&n;         * host full condition on the host.&n;         */
id|host-&gt;host_blocked
op_assign
id|FALSE
suffix:semicolon
id|device-&gt;device_blocked
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/*&n;&t; * If we have valid sense information, then some kind of recovery&n;&t; * must have taken place.  Make a note of this.&n;&t; */
r_if
c_cond
(paren
id|scsi_sense_valid
c_func
(paren
id|SCpnt
)paren
)paren
(brace
id|SCpnt-&gt;result
op_or_assign
(paren
id|DRIVER_SENSE
op_lshift
l_int|24
)paren
suffix:semicolon
)brace
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Notifying upper driver of completion for device %d %x&bslash;n&quot;
comma
id|SCpnt-&gt;device-&gt;id
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_HIGHLEVEL
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_FINISHED
suffix:semicolon
multiline_comment|/* We can get here with use_sg=0, causing a panic in the upper level (DB) */
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
multiline_comment|/*&n;&t;* If there is an associated request structure, copy the data over before we call the&n;&t;* completion function.&n;&t;*/
id|SRpnt
op_assign
id|SCpnt-&gt;sc_request
suffix:semicolon
r_if
c_cond
(paren
id|SRpnt
op_ne
l_int|NULL
)paren
(brace
id|SRpnt-&gt;sr_result
op_assign
id|SRpnt-&gt;sr_command-&gt;result
suffix:semicolon
r_if
c_cond
(paren
id|SRpnt-&gt;sr_result
op_ne
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|SRpnt-&gt;sr_sense_buffer
comma
id|SRpnt-&gt;sr_command-&gt;sense_buffer
comma
r_sizeof
(paren
id|SRpnt-&gt;sr_sense_buffer
)paren
)paren
suffix:semicolon
)brace
)brace
id|SCpnt
op_member_access_from_pointer
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
r_static
r_int
id|scsi_register_host
c_func
(paren
id|Scsi_Host_Template
op_star
)paren
suffix:semicolon
r_static
r_void
id|scsi_unregister_host
c_func
(paren
id|Scsi_Host_Template
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * Function:    scsi_release_commandblocks()&n; *&n; * Purpose:     Release command blocks associated with a device.&n; *&n; * Arguments:   SDpnt   - device&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: No locking assumed or required.&n; *&n; * Notes:&n; */
DECL|function|scsi_release_commandblocks
r_void
id|scsi_release_commandblocks
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
comma
op_star
id|SCnext
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCnext
)paren
(brace
id|SDpnt-&gt;device_queue
op_assign
id|SCnext
op_assign
id|SCpnt-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|SCpnt
)paren
suffix:semicolon
)brace
id|SDpnt-&gt;has_cmdblocks
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;queue_depth
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_build_commandblocks()&n; *&n; * Purpose:     Allocate command blocks associated with a device.&n; *&n; * Arguments:   SDpnt   - device&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: No locking assumed or required.&n; *&n; * Notes:&n; */
DECL|function|scsi_build_commandblocks
r_void
id|scsi_build_commandblocks
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SDpnt-&gt;host
suffix:semicolon
r_int
id|j
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;queue_depth
op_eq
l_int|0
)paren
(brace
id|SDpnt-&gt;queue_depth
op_assign
id|host-&gt;cmd_per_lun
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;queue_depth
op_eq
l_int|0
)paren
id|SDpnt-&gt;queue_depth
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* live to fight another day */
)brace
id|SDpnt-&gt;device_queue
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|SDpnt-&gt;queue_depth
suffix:semicolon
id|j
op_increment
)paren
(brace
id|SCpnt
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Cmnd
)paren
comma
id|GFP_ATOMIC
op_or
(paren
id|host-&gt;unchecked_isa_dma
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|SCpnt
)paren
r_break
suffix:semicolon
multiline_comment|/* If not, the next line will oops ... */
id|memset
c_func
(paren
id|SCpnt
comma
l_int|0
comma
r_sizeof
(paren
id|Scsi_Cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;host
op_assign
id|host
suffix:semicolon
id|SCpnt-&gt;device
op_assign
id|SDpnt
suffix:semicolon
id|SCpnt-&gt;target
op_assign
id|SDpnt-&gt;id
suffix:semicolon
id|SCpnt-&gt;lun
op_assign
id|SDpnt-&gt;lun
suffix:semicolon
id|SCpnt-&gt;channel
op_assign
id|SDpnt-&gt;channel
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;old_use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;old_cmd_len
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;old_underflow
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;resid
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;next
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SDpnt-&gt;device_queue
op_assign
id|SCpnt
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_UNUSED
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_NOBODY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
OL
id|SDpnt-&gt;queue_depth
)paren
(brace
multiline_comment|/* low on space (D.Gilbert 990424) */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi_build_commandblocks: want=%d, space for=%d blocks&bslash;n&quot;
comma
id|SDpnt-&gt;queue_depth
comma
id|j
)paren
suffix:semicolon
id|SDpnt-&gt;queue_depth
op_assign
id|j
suffix:semicolon
id|SDpnt-&gt;has_cmdblocks
op_assign
(paren
l_int|0
op_ne
id|j
)paren
suffix:semicolon
)brace
r_else
(brace
id|SDpnt-&gt;has_cmdblocks
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
id|proc_scsi_gen_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|length
comma
r_void
op_star
id|data
)paren
suffix:semicolon
DECL|function|scsi_host_no_insert
r_void
id|__init
id|scsi_host_no_insert
c_func
(paren
r_char
op_star
id|str
comma
r_int
id|n
)paren
(brace
id|Scsi_Host_Name
op_star
id|shn
comma
op_star
id|shn2
suffix:semicolon
r_int
id|len
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|str
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_logical_and
(paren
id|shn
op_assign
(paren
id|Scsi_Host_Name
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Host_Name
)paren
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|shn-&gt;name
op_assign
id|kmalloc
c_func
(paren
id|len
op_plus
l_int|1
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|strncpy
c_func
(paren
id|shn-&gt;name
comma
id|str
comma
id|len
)paren
suffix:semicolon
id|shn-&gt;name
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|shn-&gt;host_no
op_assign
id|n
suffix:semicolon
id|shn-&gt;host_registered
op_assign
l_int|0
suffix:semicolon
id|shn-&gt;loaded_as_module
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* numbers shouldn&squot;t be freed in any case */
id|shn-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|scsi_host_no_list
)paren
(brace
r_for
c_loop
(paren
id|shn2
op_assign
id|scsi_host_no_list
suffix:semicolon
id|shn2-&gt;next
suffix:semicolon
id|shn2
op_assign
id|shn2-&gt;next
)paren
suffix:semicolon
id|shn2-&gt;next
op_assign
id|shn
suffix:semicolon
)brace
r_else
id|scsi_host_no_list
op_assign
id|shn
suffix:semicolon
id|max_scsi_hosts
op_assign
id|n
op_plus
l_int|1
suffix:semicolon
)brace
r_else
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|shn
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|scsi_proc_info
r_static
r_int
id|scsi_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
id|Scsi_Device
op_star
id|scd
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|HBA_ptr
suffix:semicolon
r_int
id|size
comma
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * First, see if there are any attached devices or not.&n;&t; */
r_for
c_loop
(paren
id|HBA_ptr
op_assign
id|scsi_hostlist
suffix:semicolon
id|HBA_ptr
suffix:semicolon
id|HBA_ptr
op_assign
id|HBA_ptr-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|HBA_ptr-&gt;host_queue
op_ne
l_int|NULL
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Attached devices: %s&bslash;n&quot;
comma
(paren
id|HBA_ptr
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;none&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_for
c_loop
(paren
id|HBA_ptr
op_assign
id|scsi_hostlist
suffix:semicolon
id|HBA_ptr
suffix:semicolon
id|HBA_ptr
op_assign
id|HBA_ptr-&gt;next
)paren
(brace
macro_line|#if 0
id|size
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;scsi%2d: %s&bslash;n&quot;
comma
(paren
r_int
)paren
id|HBA_ptr-&gt;host_no
comma
id|HBA_ptr-&gt;hostt-&gt;procname
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|scd
op_assign
id|HBA_ptr-&gt;host_queue
suffix:semicolon
id|scd
suffix:semicolon
id|scd
op_assign
id|scd-&gt;next
)paren
(brace
id|proc_print_scsidevice
c_func
(paren
id|scd
comma
id|buffer
comma
op_amp
id|size
comma
id|len
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
r_goto
id|stop_output
suffix:semicolon
)brace
)brace
id|stop_output
suffix:colon
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start slop */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
multiline_comment|/* Ending slop */
r_return
(paren
id|len
)paren
suffix:semicolon
)brace
DECL|function|proc_scsi_gen_write
r_static
r_int
id|proc_scsi_gen_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|length
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|Scsi_Device_Template
op_star
id|SDTpnt
suffix:semicolon
id|Scsi_Device
op_star
id|scd
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|HBA_ptr
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_int
id|host
comma
id|channel
comma
id|id
comma
id|lun
suffix:semicolon
r_char
op_star
id|buffer
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
op_logical_or
id|length
OG
id|PAGE_SIZE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|buffer
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|copy_from_user
c_func
(paren
id|buffer
comma
id|buf
comma
id|length
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|length
OL
l_int|11
op_logical_or
id|strncmp
c_func
(paren
l_string|&quot;scsi&quot;
comma
id|buffer
comma
l_int|4
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Usage: echo &quot;scsi dump #N&quot; &gt; /proc/scsi/scsi&n;&t; * to dump status of all scsi commands.  The number is used to specify the level&n;&t; * of detail in the dump.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
l_string|&quot;dump&quot;
comma
id|buffer
op_plus
l_int|5
comma
l_int|4
)paren
)paren
(brace
r_int
r_int
id|level
suffix:semicolon
id|p
op_assign
id|buffer
op_plus
l_int|10
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_goto
id|out
suffix:semicolon
id|level
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|scsi_dump_status
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Usage: echo &quot;scsi log token #N&quot; &gt; /proc/scsi/scsi&n;&t; * where token is one of [error,scan,mlqueue,mlcomplete,llqueue,&n;&t; * llcomplete,hlqueue,hlcomplete]&n;&t; */
macro_line|#ifdef CONFIG_SCSI_LOGGING&t;&t;/* { */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
l_string|&quot;log&quot;
comma
id|buffer
op_plus
l_int|5
comma
l_int|3
)paren
)paren
(brace
r_char
op_star
id|token
suffix:semicolon
r_int
r_int
id|level
suffix:semicolon
id|p
op_assign
id|buffer
op_plus
l_int|9
suffix:semicolon
id|token
op_assign
id|p
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_ne
l_char|&squot; &squot;
op_logical_and
op_star
id|p
op_ne
l_char|&squot;&bslash;t&squot;
op_logical_and
op_star
id|p
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|p
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|token
comma
l_string|&quot;all&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Turn on absolutely everything.&n;&t;&t;&t;&t; */
id|scsi_logging_level
op_assign
op_complement
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|token
comma
l_string|&quot;none&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Turn off absolutely everything.&n;&t;&t;&t;&t; */
id|scsi_logging_level
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|level
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Now figure out what to do with it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;error&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_ERROR_RECOVERY_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;timeout&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_TIMEOUT_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;scan&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_SCAN_BUS_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;mlqueue&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_MLQUEUE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;mlcomplete&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_MLCOMPLETE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;llqueue&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_LLQUEUE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;llcomplete&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_LLCOMPLETE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;hlqueue&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_HLQUEUE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;hlcomplete&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_HLCOMPLETE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;ioctl&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_IOCTL_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
(brace
r_goto
id|out
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi logging level set to 0x%8.8x&bslash;n&quot;
comma
id|scsi_logging_level
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_SCSI_LOGGING */ /* } */
multiline_comment|/*&n;&t; * Usage: echo &quot;scsi add-single-device 0 1 2 3&quot; &gt;/proc/scsi/scsi&n;&t; * with  &quot;0 1 2 3&quot; replaced by your &quot;Host Channel Id Lun&quot;.&n;&t; * Consider this feature BETA.&n;&t; *     CAUTION: This is not for hotplugging your peripherals. As&n;&t; *     SCSI was not designed for this you could damage your&n;&t; *     hardware !&n;&t; * However perhaps it is legal to switch on an&n;&t; * already connected device. It is perhaps not&n;&t; * guaranteed this device doesn&squot;t corrupt an ongoing data transfer.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
l_string|&quot;add-single-device&quot;
comma
id|buffer
op_plus
l_int|5
comma
l_int|17
)paren
)paren
(brace
id|p
op_assign
id|buffer
op_plus
l_int|23
suffix:semicolon
id|host
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|channel
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|id
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|lun
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi singledevice %d %d %d %d&bslash;n&quot;
comma
id|host
comma
id|channel
comma
id|id
comma
id|lun
)paren
suffix:semicolon
r_for
c_loop
(paren
id|HBA_ptr
op_assign
id|scsi_hostlist
suffix:semicolon
id|HBA_ptr
suffix:semicolon
id|HBA_ptr
op_assign
id|HBA_ptr-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|HBA_ptr-&gt;host_no
op_eq
id|host
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HBA_ptr
)paren
r_goto
id|out
suffix:semicolon
r_for
c_loop
(paren
id|scd
op_assign
id|HBA_ptr-&gt;host_queue
suffix:semicolon
id|scd
suffix:semicolon
id|scd
op_assign
id|scd-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|scd-&gt;channel
op_eq
id|channel
op_logical_and
id|scd-&gt;id
op_eq
id|id
op_logical_and
id|scd-&gt;lun
op_eq
id|lun
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|err
op_assign
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
id|scd
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* We do not yet support unplugging */
id|scan_scsis
c_func
(paren
id|HBA_ptr
comma
l_int|1
comma
id|channel
comma
id|id
comma
id|lun
)paren
suffix:semicolon
multiline_comment|/* FIXME (DB) This assumes that the queue_depth routines can be used&n;&t;&t;   in this context as well, while they were all designed to be&n;&t;&t;   called only once after the detect routine. (DB) */
multiline_comment|/* queue_depth routine moved to inside scan_scsis(,1,,,) so&n;&t;&t;   it is called before build_commandblocks() */
id|err
op_assign
id|length
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Usage: echo &quot;scsi remove-single-device 0 1 2 3&quot; &gt;/proc/scsi/scsi&n;&t; * with  &quot;0 1 2 3&quot; replaced by your &quot;Host Channel Id Lun&quot;.&n;&t; *&n;&t; * Consider this feature pre-BETA.&n;&t; *&n;&t; *     CAUTION: This is not for hotplugging your peripherals. As&n;&t; *     SCSI was not designed for this you could damage your&n;&t; *     hardware and thoroughly confuse the SCSI subsystem.&n;&t; *&n;&t; */
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
l_string|&quot;remove-single-device&quot;
comma
id|buffer
op_plus
l_int|5
comma
l_int|20
)paren
)paren
(brace
id|p
op_assign
id|buffer
op_plus
l_int|26
suffix:semicolon
id|host
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|channel
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|id
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|lun
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|HBA_ptr
op_assign
id|scsi_hostlist
suffix:semicolon
id|HBA_ptr
suffix:semicolon
id|HBA_ptr
op_assign
id|HBA_ptr-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|HBA_ptr-&gt;host_no
op_eq
id|host
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HBA_ptr
)paren
r_goto
id|out
suffix:semicolon
r_for
c_loop
(paren
id|scd
op_assign
id|HBA_ptr-&gt;host_queue
suffix:semicolon
id|scd
suffix:semicolon
id|scd
op_assign
id|scd-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|scd-&gt;channel
op_eq
id|channel
op_logical_and
id|scd-&gt;id
op_eq
id|id
op_logical_and
id|scd-&gt;lun
op_eq
id|lun
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|scd
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* there is no such device attached */
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|scd-&gt;access_count
)paren
r_goto
id|out
suffix:semicolon
id|SDTpnt
op_assign
id|scsi_devicelist
suffix:semicolon
r_while
c_loop
(paren
id|SDTpnt
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|SDTpnt-&gt;detach
)paren
(paren
op_star
id|SDTpnt-&gt;detach
)paren
(paren
id|scd
)paren
suffix:semicolon
id|SDTpnt
op_assign
id|SDTpnt-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scd-&gt;attached
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Nobody is using this device any more.&n;&t;&t;&t; * Free all of the command structures.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|HBA_ptr-&gt;hostt-&gt;revoke
)paren
id|HBA_ptr-&gt;hostt
op_member_access_from_pointer
id|revoke
c_func
(paren
id|scd
)paren
suffix:semicolon
id|devfs_unregister
(paren
id|scd-&gt;de
)paren
suffix:semicolon
id|scsi_release_commandblocks
c_func
(paren
id|scd
)paren
suffix:semicolon
multiline_comment|/* Now we can remove the device structure */
r_if
c_cond
(paren
id|scd-&gt;next
op_ne
l_int|NULL
)paren
id|scd-&gt;next-&gt;prev
op_assign
id|scd-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
id|scd-&gt;prev
op_ne
l_int|NULL
)paren
id|scd-&gt;prev-&gt;next
op_assign
id|scd-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|HBA_ptr-&gt;host_queue
op_eq
id|scd
)paren
(brace
id|HBA_ptr-&gt;host_queue
op_assign
id|scd-&gt;next
suffix:semicolon
)brace
id|blk_cleanup_queue
c_func
(paren
op_amp
id|scd-&gt;request_queue
)paren
suffix:semicolon
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|scd
)paren
suffix:semicolon
)brace
r_else
(brace
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|out
suffix:colon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|buffer
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * This entry point should be called by a driver if it is trying&n; * to add a low level scsi driver to the system.&n; */
DECL|function|scsi_register_host
r_static
r_int
id|scsi_register_host
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|pcount
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|out_of_space
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tpnt-&gt;next
op_logical_or
op_logical_neg
id|tpnt-&gt;detect
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Must be already loaded, or&n;&t;&t;&t;&t; * no detect routine available&n;&t;&t;&t;&t; */
id|pcount
op_assign
id|next_scsi_host
suffix:semicolon
multiline_comment|/* The detect routine must carefully spinunlock/spinlock if &n;&t;   it enables interrupts, since all interrupt handlers do &n;&t;   spinlock as well.&n;&t;   All lame drivers are going to fail due to the following &n;&t;   spinlock. For the time beeing let&squot;s use it only for drivers &n;&t;   using the new scsi code. NOTE: the detect routine could&n;&t;   redefine the value tpnt-&gt;use_new_eh_code. (DB, 13 May 1998) */
r_if
c_cond
(paren
id|tpnt-&gt;use_new_eh_code
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|tpnt-&gt;present
op_assign
id|tpnt
op_member_access_from_pointer
id|detect
c_func
(paren
id|tpnt
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
id|tpnt-&gt;present
op_assign
id|tpnt
op_member_access_from_pointer
id|detect
c_func
(paren
id|tpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tpnt-&gt;present
)paren
(brace
r_if
c_cond
(paren
id|pcount
op_eq
id|next_scsi_host
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;present
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi: Failure to register low-level scsi driver&quot;
)paren
suffix:semicolon
id|scsi_unregister_host
c_func
(paren
id|tpnt
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * The low-level driver failed to register a driver.&n;&t;&t;&t; * We can do this now.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|scsi_register
c_func
(paren
id|tpnt
comma
l_int|0
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi: register failed.&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_unregister_host
c_func
(paren
id|tpnt
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|tpnt-&gt;next
op_assign
id|scsi_hosts
suffix:semicolon
multiline_comment|/* Add to the linked list */
id|scsi_hosts
op_assign
id|tpnt
suffix:semicolon
multiline_comment|/* Add the new driver to /proc/scsi */
macro_line|#ifdef CONFIG_PROC_FS
id|build_proc_dir_entries
c_func
(paren
id|tpnt
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Add the kernel threads for each host adapter that will&n;&t;&t; * handle error correction.&n;&t;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_eq
id|tpnt
op_logical_and
id|shpnt-&gt;hostt-&gt;use_new_eh_code
)paren
(brace
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|sem
)paren
suffix:semicolon
id|shpnt-&gt;eh_notify
op_assign
op_amp
id|sem
suffix:semicolon
id|kernel_thread
c_func
(paren
(paren
r_int
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|scsi_error_handler
comma
(paren
r_void
op_star
)paren
id|shpnt
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Now wait for the kernel error thread to initialize itself&n;&t;&t;&t;&t; * as it might be needed when we scan the bus.&n;&t;&t;&t;&t; */
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|shpnt-&gt;eh_notify
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_eq
id|tpnt
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;info
)paren
(brace
id|name
op_assign
id|tpnt
op_member_access_from_pointer
id|info
c_func
(paren
id|shpnt
)paren
suffix:semicolon
)brace
r_else
(brace
id|name
op_assign
id|tpnt-&gt;name
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi%d : %s&bslash;n&quot;
comma
multiline_comment|/* And print a little message */
id|shpnt-&gt;host_no
comma
id|name
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* The next step is to call scan_scsis here.  This generates the&n;&t;&t; * Scsi_Devices entries&n;&t;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_eq
id|tpnt
)paren
(brace
id|scan_scsis
c_func
(paren
id|shpnt
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;select_queue_depths
op_ne
l_int|NULL
)paren
(brace
(paren
id|shpnt-&gt;select_queue_depths
)paren
(paren
id|shpnt
comma
id|shpnt-&gt;host_queue
)paren
suffix:semicolon
)brace
)brace
)brace
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|sdtpnt-&gt;init
op_logical_and
id|sdtpnt-&gt;dev_noticed
)paren
(paren
op_star
id|sdtpnt-&gt;init
)paren
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Next we create the Scsi_Cmnd structures for this host &n;&t;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
r_if
c_cond
(paren
id|SDpnt-&gt;host-&gt;hostt
op_eq
id|tpnt
)paren
(brace
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;attach
)paren
(paren
op_star
id|sdtpnt-&gt;attach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;attached
)paren
(brace
id|scsi_build_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|SDpnt-&gt;has_cmdblocks
)paren
id|out_of_space
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; * Now that we have all of the devices, resize the DMA pool,&n;&t;&t; * as required.  */
r_if
c_cond
(paren
op_logical_neg
id|out_of_space
)paren
id|scsi_resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* This does any final handling that is required. */
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|sdtpnt-&gt;finish
op_logical_and
id|sdtpnt-&gt;nr_dev
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;finish
)paren
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#if defined(USE_STATIC_SCSI_MEMORY)
id|printk
c_func
(paren
l_string|&quot;SCSI memory: total %ldKb, used %ldKb, free %ldKb.&bslash;n&quot;
comma
(paren
id|scsi_memory_upper_value
op_minus
id|scsi_memory_lower_value
)paren
op_div
l_int|1024
comma
(paren
id|scsi_init_memory_start
op_minus
id|scsi_memory_lower_value
)paren
op_div
l_int|1024
comma
(paren
id|scsi_memory_upper_value
op_minus
id|scsi_init_memory_start
)paren
op_div
l_int|1024
)paren
suffix:semicolon
macro_line|#endif
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|out_of_space
)paren
(brace
id|scsi_unregister_host
c_func
(paren
id|tpnt
)paren
suffix:semicolon
multiline_comment|/* easiest way to clean up?? */
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Similarly, this entry point should be called by a loadable module if it&n; * is trying to remove a low level scsi driver from the system.&n; *&n; * Note - there is a fatal flaw in the deregister module function.&n; * There is no way to return a code that says &squot;I cannot be unloaded now&squot;.&n; * The system relies entirely upon usage counts that are maintained,&n; * and the assumption is that if the usage count is 0, then the module&n; * can be unloaded.&n; */
DECL|function|scsi_unregister_host
r_static
r_void
id|scsi_unregister_host
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|online_status
suffix:semicolon
r_int
id|pcount0
comma
id|pcount
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt1
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|sh1
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_char
id|name
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/* host_no&gt;=10^9? I don&squot;t think so. */
multiline_comment|/*&n;&t; * First verify that this host adapter is completely free with no pending&n;&t; * commands &n;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SDpnt-&gt;host-&gt;hostt
op_eq
id|tpnt
op_logical_and
id|SDpnt-&gt;host-&gt;hostt-&gt;module
op_logical_and
id|GET_USE_COUNT
c_func
(paren
id|SDpnt-&gt;host-&gt;hostt-&gt;module
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * FIXME(eric) - We need to find a way to notify the&n;&t;&t;&t; * low level driver that we are shutting down - via the&n;&t;&t;&t; * special device entry that still needs to get added. &n;&t;&t;&t; *&n;&t;&t;&t; * Is detach interface below good enough for this?&n;&t;&t;&t; */
)brace
)brace
multiline_comment|/*&n;&t; * FIXME(eric) put a spinlock on this.  We force all of the devices offline&n;&t; * to help prevent race conditions where other hosts/processors could try and&n;&t; * get in and queue a command.&n;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SDpnt-&gt;host-&gt;hostt
op_eq
id|tpnt
)paren
id|SDpnt-&gt;online
op_assign
id|FALSE
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_ne
id|tpnt
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Loop over all of the commands associated with the device.  If any of&n;&t;&t;&t; * them are busy, then set the state back to inactive and bail.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
id|online_status
op_assign
id|SDpnt-&gt;online
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SCSI device not inactive - rq_status=%d, target=%d, pid=%ld, state=%d, owner=%d.&bslash;n&quot;
comma
id|SCpnt-&gt;request.rq_status
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;pid
comma
id|SCpnt-&gt;state
comma
id|SCpnt-&gt;owner
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt1
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt1
suffix:semicolon
id|SDpnt1
op_assign
id|SDpnt1-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt1-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_eq
id|RQ_SCSI_DISCONNECTING
)paren
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
)brace
id|SDpnt-&gt;online
op_assign
id|online_status
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Device busy???&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * No, this device is really free.  Mark it as such, and&n;&t;&t;&t;&t; * continue on.&n;&t;&t;&t;&t; */
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_DISCONNECTING
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_DISCONNECTING
suffix:semicolon
multiline_comment|/* Mark as busy */
)brace
)brace
)brace
multiline_comment|/* Next we detach the high level drivers from the Scsi_Device structures */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_ne
id|tpnt
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;detach
)paren
(paren
op_star
id|sdtpnt-&gt;detach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/* If something still attached, punt */
r_if
c_cond
(paren
id|SDpnt-&gt;attached
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Attached usage count = %d&bslash;n&quot;
comma
id|SDpnt-&gt;attached
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|devfs_unregister
(paren
id|SDpnt-&gt;de
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Next, kill the kernel error recovery thread for this host.&n;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_eq
id|tpnt
op_logical_and
id|shpnt-&gt;hostt-&gt;use_new_eh_code
op_logical_and
id|shpnt-&gt;ehandler
op_ne
l_int|NULL
)paren
(brace
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|sem
)paren
suffix:semicolon
id|shpnt-&gt;eh_notify
op_assign
op_amp
id|sem
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGHUP
comma
id|shpnt-&gt;ehandler
comma
l_int|1
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|shpnt-&gt;eh_notify
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* Next we free up the Scsi_Cmnd structures for this host */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_ne
id|tpnt
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
)paren
(brace
id|scsi_release_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
op_amp
id|SDpnt-&gt;request_queue
)paren
suffix:semicolon
multiline_comment|/* Next free up the Scsi_Device structures for this host */
id|shpnt-&gt;host_queue
op_assign
id|SDpnt-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|SDpnt
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Next we go through and remove the instances of the individual hosts&n;&t; * that were detected */
id|pcount0
op_assign
id|next_scsi_host
suffix:semicolon
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|sh1
)paren
(brace
id|sh1
op_assign
id|shpnt-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_ne
id|tpnt
)paren
r_continue
suffix:semicolon
id|pcount
op_assign
id|next_scsi_host
suffix:semicolon
multiline_comment|/* Remove the /proc/scsi directory entry */
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%d&quot;
comma
id|shpnt-&gt;host_no
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|name
comma
id|tpnt-&gt;proc_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tpnt-&gt;release
)paren
(paren
op_star
id|tpnt-&gt;release
)paren
(paren
id|shpnt
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* This is the default case for the release function.&n;&t;&t;&t; * It should do the right thing for most correctly&n;&t;&t;&t; * written host adapters.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|shpnt-&gt;irq
)paren
id|free_irq
c_func
(paren
id|shpnt-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;dma_channel
op_ne
l_int|0xff
)paren
id|free_dma
c_func
(paren
id|shpnt-&gt;dma_channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;io_port
op_logical_and
id|shpnt-&gt;n_io_port
)paren
id|release_region
c_func
(paren
id|shpnt-&gt;io_port
comma
id|shpnt-&gt;n_io_port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pcount
op_eq
id|next_scsi_host
)paren
id|scsi_unregister
c_func
(paren
id|shpnt
)paren
suffix:semicolon
id|tpnt-&gt;present
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there are absolutely no more hosts left, it is safe&n;&t; * to completely nuke the DMA pool.  The resize operation will&n;&t; * do the right thing and free everything.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|scsi_hosts
)paren
id|scsi_resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcount0
op_ne
id|next_scsi_host
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi : %d host%s left.&bslash;n&quot;
comma
id|next_scsi_host
comma
(paren
id|next_scsi_host
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
suffix:semicolon
macro_line|#if defined(USE_STATIC_SCSI_MEMORY)
id|printk
c_func
(paren
l_string|&quot;SCSI memory: total %ldKb, used %ldKb, free %ldKb.&bslash;n&quot;
comma
(paren
id|scsi_memory_upper_value
op_minus
id|scsi_memory_lower_value
)paren
op_div
l_int|1024
comma
(paren
id|scsi_init_memory_start
op_minus
id|scsi_memory_lower_value
)paren
op_div
l_int|1024
comma
(paren
id|scsi_memory_upper_value
op_minus
id|scsi_init_memory_start
)paren
op_div
l_int|1024
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Remove it from the linked list and /proc if all&n;&t; * hosts were successfully removed (ie preset == 0)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tpnt-&gt;present
)paren
(brace
id|Scsi_Host_Template
op_star
op_star
id|SHTp
op_assign
op_amp
id|scsi_hosts
suffix:semicolon
id|Scsi_Host_Template
op_star
id|SHT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|SHT
op_assign
op_star
id|SHTp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|SHT
op_eq
id|tpnt
)paren
(brace
op_star
id|SHTp
op_assign
id|SHT-&gt;next
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|tpnt-&gt;proc_name
comma
id|proc_scsi
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|SHTp
op_assign
op_amp
id|SHT-&gt;next
suffix:semicolon
)brace
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
r_static
r_int
id|scsi_unregister_device
c_func
(paren
r_struct
id|Scsi_Device_Template
op_star
id|tpnt
)paren
suffix:semicolon
multiline_comment|/*&n; * This entry point should be called by a loadable module if it is trying&n; * add a high level scsi driver to the system.&n; */
DECL|function|scsi_register_device_module
r_static
r_int
id|scsi_register_device_module
c_func
(paren
r_struct
id|Scsi_Device_Template
op_star
id|tpnt
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_int
id|out_of_space
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tpnt-&gt;next
)paren
r_return
l_int|1
suffix:semicolon
id|scsi_register_device
c_func
(paren
id|tpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First scan the devices that we know about, and see if we notice them.&n;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;detect
)paren
id|SDpnt-&gt;attached
op_add_assign
(paren
op_star
id|tpnt-&gt;detect
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If any of the devices would match this driver, then perform the&n;&t; * init function.&n;&t; */
r_if
c_cond
(paren
id|tpnt-&gt;init
op_logical_and
id|tpnt-&gt;dev_noticed
)paren
r_if
c_cond
(paren
(paren
op_star
id|tpnt-&gt;init
)paren
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Now actually connect the devices to the new driver.&n;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;attach
)paren
(paren
op_star
id|tpnt-&gt;attach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If this driver attached to the device, and don&squot;t have any&n;&t;&t;&t; * command blocks for this device, allocate some.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|SDpnt-&gt;attached
op_logical_and
id|SDpnt-&gt;has_cmdblocks
op_eq
l_int|0
)paren
(brace
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
id|scsi_build_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|SDpnt-&gt;has_cmdblocks
)paren
id|out_of_space
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * This does any final handling that is required.&n;&t; */
r_if
c_cond
(paren
id|tpnt-&gt;finish
op_logical_and
id|tpnt-&gt;nr_dev
)paren
(paren
op_star
id|tpnt-&gt;finish
)paren
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|out_of_space
)paren
id|scsi_resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|out_of_space
)paren
(brace
id|scsi_unregister_device
c_func
(paren
id|tpnt
)paren
suffix:semicolon
multiline_comment|/* easiest way to clean up?? */
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scsi_unregister_device
r_static
r_int
id|scsi_unregister_device
c_func
(paren
r_struct
id|Scsi_Device_Template
op_star
id|tpnt
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|spnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|prev_spnt
suffix:semicolon
multiline_comment|/*&n;&t; * If we are busy, this is not going to fly.&n;&t; */
r_if
c_cond
(paren
id|GET_USE_COUNT
c_func
(paren
id|tpnt-&gt;module
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Next, detach the devices from the driver.&n;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;detach
)paren
(paren
op_star
id|tpnt-&gt;detach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;attached
op_eq
l_int|0
)paren
(brace
id|SDpnt-&gt;online
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Nobody is using this device any more.  Free all of the&n;&t;&t;&t;&t; * command structures.&n;&t;&t;&t;&t; */
id|scsi_release_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Extract the template from the linked list.&n;&t; */
id|spnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|prev_spnt
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|spnt
op_ne
id|tpnt
)paren
(brace
id|prev_spnt
op_assign
id|spnt
suffix:semicolon
id|spnt
op_assign
id|spnt-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev_spnt
op_eq
l_int|NULL
)paren
id|scsi_devicelist
op_assign
id|tpnt-&gt;next
suffix:semicolon
r_else
id|prev_spnt-&gt;next
op_assign
id|spnt-&gt;next
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
multiline_comment|/*&n;&t; * Final cleanup for the driver is done in the driver sources in the&n;&t; * cleanup function.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function should be called by drivers which needs to register&n; * with the midlevel scsi system. As of 2.4.0-test9pre3 this is our&n; * main device/hosts register function&t;/mathiasen&n; */
DECL|function|scsi_register_module
r_int
id|scsi_register_module
c_func
(paren
r_int
id|module_type
comma
r_void
op_star
id|ptr
)paren
(brace
r_switch
c_cond
(paren
id|module_type
)paren
(brace
r_case
id|MODULE_SCSI_HA
suffix:colon
r_return
id|scsi_register_host
c_func
(paren
(paren
id|Scsi_Host_Template
op_star
)paren
id|ptr
)paren
suffix:semicolon
multiline_comment|/* Load upper level device handler of some kind */
r_case
id|MODULE_SCSI_DEV
suffix:colon
macro_line|#ifdef CONFIG_KMOD
r_if
c_cond
(paren
id|scsi_hosts
op_eq
l_int|NULL
)paren
id|request_module
c_func
(paren
l_string|&quot;scsi_hostadapter&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|scsi_register_device_module
c_func
(paren
(paren
r_struct
id|Scsi_Device_Template
op_star
)paren
id|ptr
)paren
suffix:semicolon
multiline_comment|/* The rest of these are not yet implemented */
multiline_comment|/* Load constants.o */
r_case
id|MODULE_SCSI_CONST
suffix:colon
multiline_comment|/* Load specialized ioctl handler for some device.  Intended for&n;&t;&t; * cdroms that have non-SCSI2 audio command sets. */
r_case
id|MODULE_SCSI_IOCTL
suffix:colon
r_default
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Reverse the actions taken above&n; */
DECL|function|scsi_unregister_module
r_void
id|scsi_unregister_module
c_func
(paren
r_int
id|module_type
comma
r_void
op_star
id|ptr
)paren
(brace
r_switch
c_cond
(paren
id|module_type
)paren
(brace
r_case
id|MODULE_SCSI_HA
suffix:colon
id|scsi_unregister_host
c_func
(paren
(paren
id|Scsi_Host_Template
op_star
)paren
id|ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODULE_SCSI_DEV
suffix:colon
id|scsi_unregister_device
c_func
(paren
(paren
r_struct
id|Scsi_Device_Template
op_star
)paren
id|ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* The rest of these are not yet implemented. */
r_case
id|MODULE_SCSI_CONST
suffix:colon
r_case
id|MODULE_SCSI_IOCTL
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/*&n; * Function:    scsi_dump_status&n; *&n; * Purpose:     Brain dump of scsi system, used for problem solving.&n; *&n; * Arguments:   level - used to indicate level of detail.&n; *&n; * Notes:       The level isn&squot;t used at all yet, but we need to find some way&n; *              of sensibly logging varying degrees of information.  A quick one-line&n; *              display of each command, plus the status would be most useful.&n; *&n; *              This does depend upon CONFIG_SCSI_LOGGING - I do want some way of turning&n; *              it all off if the user wants a lean and mean kernel.  It would probably&n; *              also be useful to allow the user to specify one single host to be dumped.&n; *              A second argument to the function would be useful for that purpose.&n; *&n; *              FIXME - some formatting of the output into tables would be very handy.&n; */
DECL|function|scsi_dump_status
r_static
r_void
id|scsi_dump_status
c_func
(paren
r_int
id|level
)paren
(brace
macro_line|#ifdef CONFIG_SCSI_LOGGING&t;&t;/* { */
r_int
id|i
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Dump of scsi host parameters:&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; %d %d %d : %d %d&bslash;n&quot;
comma
id|shpnt-&gt;host_failed
comma
id|shpnt-&gt;host_busy
comma
id|atomic_read
c_func
(paren
op_amp
id|shpnt-&gt;host_active
)paren
comma
id|shpnt-&gt;host_blocked
comma
id|shpnt-&gt;host_self_blocked
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Dump of scsi command parameters:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;h:c:t:l (dev sect nsect cnumsec sg) (ret all flg) (to/cmd to ito) cmd snse result&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
multiline_comment|/*  (0) h:c:t:l (dev sect nsect cnumsec sg) (ret all flg) (to/cmd to ito) cmd snse result %d %x      */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(%3d) %2d:%1d:%2d:%2d (%6s %4ld %4ld %4ld %4x %1d) (%1d %1d 0x%2x) (%4d %4d %4d) 0x%2.2x 0x%2.2x 0x%8.8x&bslash;n&quot;
comma
id|i
op_increment
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|kdevname
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
comma
id|SCpnt-&gt;request.sector
comma
id|SCpnt-&gt;request.nr_sectors
comma
id|SCpnt-&gt;request.current_nr_sectors
comma
id|SCpnt-&gt;request.rq_status
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;retries
comma
id|SCpnt-&gt;allowed
comma
id|SCpnt-&gt;flags
comma
id|SCpnt-&gt;timeout_per_command
comma
id|SCpnt-&gt;timeout
comma
id|SCpnt-&gt;internal_timeout
comma
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
comma
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
comma
id|SCpnt-&gt;result
)paren
suffix:semicolon
)brace
)brace
)brace
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
multiline_comment|/* Now dump the request lists for each block device */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Dump of pending block device requests&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_BLKDEV
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|list_head
op_star
id|queue_head
suffix:semicolon
id|queue_head
op_assign
op_amp
id|blk_dev
(braket
id|i
)braket
dot
id|request_queue.queue_head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|queue_head
)paren
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d: &quot;
comma
id|i
)paren
suffix:semicolon
id|entry
op_assign
id|queue_head-&gt;next
suffix:semicolon
r_do
(brace
id|req
op_assign
id|blkdev_entry_to_request
c_func
(paren
id|entry
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;(%s %d %ld %ld %ld) &quot;
comma
id|kdevname
c_func
(paren
id|req-&gt;rq_dev
)paren
comma
id|req-&gt;cmd
comma
id|req-&gt;sector
comma
id|req-&gt;nr_sectors
comma
id|req-&gt;current_nr_sectors
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|entry
op_assign
id|entry-&gt;next
)paren
op_ne
id|queue_head
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#endif&t;/* CONFIG_SCSI_LOGGING */ /* } */
)brace
macro_line|#endif&t;&t;&t;&t;/* CONFIG_PROC_FS */
DECL|function|scsi_host_no_init
r_static
r_int
id|__init
id|scsi_host_no_init
(paren
r_char
op_star
id|str
)paren
(brace
r_static
r_int
id|next_no
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|temp
suffix:semicolon
r_while
c_loop
(paren
id|str
)paren
(brace
id|temp
op_assign
id|str
suffix:semicolon
r_while
c_loop
(paren
op_star
id|temp
op_logical_and
(paren
op_star
id|temp
op_ne
l_char|&squot;:&squot;
)paren
op_logical_and
(paren
op_star
id|temp
op_ne
l_char|&squot;,&squot;
)paren
)paren
id|temp
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|temp
)paren
id|temp
op_assign
l_int|NULL
suffix:semicolon
r_else
op_star
id|temp
op_increment
op_assign
l_int|0
suffix:semicolon
id|scsi_host_no_insert
c_func
(paren
id|str
comma
id|next_no
)paren
suffix:semicolon
id|str
op_assign
id|temp
suffix:semicolon
id|next_no
op_increment
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|scsihosts
r_static
r_char
op_star
id|scsihosts
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|scsihosts
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;SCSI core&quot;
)paren
suffix:semicolon
macro_line|#ifndef MODULE
DECL|function|scsi_setup
r_int
id|__init
id|scsi_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|scsihosts
op_assign
id|str
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;scsihosts=&quot;
comma
id|scsi_setup
)paren
suffix:semicolon
macro_line|#endif
DECL|function|init_scsi
r_static
r_int
id|__init
id|init_scsi
c_func
(paren
r_void
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|generic
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SCSI subsystem driver &quot;
id|REVISION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_init_minimal_dma_pool
c_func
(paren
)paren
op_ne
l_int|0
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This makes /proc/scsi and /proc/scsi/scsi visible.&n;&t; */
macro_line|#ifdef CONFIG_PROC_FS
id|proc_scsi
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;scsi&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|proc_scsi
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;cannot init /proc/scsi&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|generic
op_assign
id|create_proc_info_entry
(paren
l_string|&quot;scsi/scsi&quot;
comma
l_int|0
comma
l_int|0
comma
id|scsi_proc_info
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|generic
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;cannot init /proc/scsi/scsi&bslash;n&quot;
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;scsi&quot;
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|generic-&gt;write_proc
op_assign
id|proc_scsi_gen_write
suffix:semicolon
macro_line|#endif
id|scsi_devfs_handle
op_assign
id|devfs_mk_dir
(paren
l_int|NULL
comma
l_string|&quot;scsi&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsihosts
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi: host order: %s&bslash;n&quot;
comma
id|scsihosts
)paren
suffix:semicolon
id|scsi_host_no_init
(paren
id|scsihosts
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This is where the processing takes place for most everything&n;&t; * when commands are completed.&n;&t; */
id|init_bh
c_func
(paren
id|SCSI_BH
comma
id|scsi_bottom_half_handler
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|exit_scsi
r_static
r_void
id|__exit
id|exit_scsi
c_func
(paren
r_void
)paren
(brace
id|Scsi_Host_Name
op_star
id|shn
comma
op_star
id|shn2
op_assign
l_int|NULL
suffix:semicolon
id|remove_bh
c_func
(paren
id|SCSI_BH
)paren
suffix:semicolon
id|devfs_unregister
(paren
id|scsi_devfs_handle
)paren
suffix:semicolon
r_for
c_loop
(paren
id|shn
op_assign
id|scsi_host_no_list
suffix:semicolon
id|shn
suffix:semicolon
id|shn
op_assign
id|shn-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shn-&gt;name
)paren
id|kfree
c_func
(paren
id|shn-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shn2
)paren
id|kfree
(paren
id|shn2
)paren
suffix:semicolon
id|shn2
op_assign
id|shn
suffix:semicolon
)brace
r_if
c_cond
(paren
id|shn2
)paren
id|kfree
(paren
id|shn2
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/* No, we&squot;re not here anymore. Don&squot;t show the /proc/scsi files. */
id|remove_proc_entry
(paren
l_string|&quot;scsi/scsi&quot;
comma
l_int|0
)paren
suffix:semicolon
id|remove_proc_entry
(paren
l_string|&quot;scsi&quot;
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Free up the DMA pool.&n;&t; */
id|scsi_resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|init_scsi
id|module_init
c_func
(paren
id|init_scsi
)paren
suffix:semicolon
DECL|variable|exit_scsi
id|module_exit
c_func
(paren
id|exit_scsi
)paren
suffix:semicolon
multiline_comment|/*&n; * Function:    scsi_get_host_dev()&n; *&n; * Purpose:     Create a Scsi_Device that points to the host adapter itself.&n; *&n; * Arguments:   SHpnt   - Host that needs a Scsi_Device&n; *&n; * Lock status: None assumed.&n; *&n; * Returns:     The Scsi_Device or NULL&n; *&n; * Notes:&n; */
DECL|function|scsi_get_host_dev
id|Scsi_Device
op_star
id|scsi_get_host_dev
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|SHpnt
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
multiline_comment|/*&n;         * Attach a single Scsi_Device to the Scsi_Host - this should&n;         * be made to look like a &quot;pseudo-device&quot; that points to the&n;         * HA itself.  For the moment, we include it at the head of&n;         * the host_queue itself - I don&squot;t think we want to show this&n;         * to the HA in select_queue_depths(), as this would probably confuse&n;         * matters.&n;         * Note - this device is not accessible from any high-level&n;         * drivers (including generics), which is probably not&n;         * optimal.  We can add hooks later to attach &n;         */
id|SDpnt
op_assign
(paren
id|Scsi_Device
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Device
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|SDpnt
comma
l_int|0
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
id|SDpnt-&gt;host
op_assign
id|SHpnt
suffix:semicolon
id|SDpnt-&gt;id
op_assign
id|SHpnt-&gt;this_id
suffix:semicolon
id|SDpnt-&gt;type
op_assign
op_minus
l_int|1
suffix:semicolon
id|SDpnt-&gt;queue_depth
op_assign
l_int|1
suffix:semicolon
id|scsi_build_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
id|scsi_initialize_queue
c_func
(paren
id|SDpnt
comma
id|SHpnt
)paren
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;         * Initialize the object that we will use to wait for command blocks.&n;         */
id|init_waitqueue_head
c_func
(paren
op_amp
id|SDpnt-&gt;scpnt_wait
)paren
suffix:semicolon
r_return
id|SDpnt
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_free_host_dev()&n; *&n; * Purpose:     Create a Scsi_Device that points to the host adapter itself.&n; *&n; * Arguments:   SHpnt   - Host that needs a Scsi_Device&n; *&n; * Lock status: None assumed.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:&n; */
DECL|function|scsi_free_host_dev
r_void
id|scsi_free_host_dev
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
id|SDpnt-&gt;id
op_ne
(paren
r_int
r_char
)paren
id|SDpnt-&gt;host-&gt;this_id
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Attempt to delete wrong device&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|blk_cleanup_queue
c_func
(paren
op_amp
id|SDpnt-&gt;request_queue
)paren
suffix:semicolon
multiline_comment|/*&n;         * We only have a single SCpnt attached to this device.  Free&n;         * it now.&n;         */
id|scsi_release_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: nil&n; * tab-width: 8&n; * End:&n; */
eof
