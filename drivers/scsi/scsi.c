multiline_comment|/*&n; *  scsi.c Copyright (C) 1992 Drew Eckhardt&n; *         Copyright (C) 1993, 1994, 1995 Eric Youngdale&n; *&n; *  generic mid-level SCSI driver&n; *      Initial versions: Drew Eckhardt&n; *      Subsequent revisions: Eric Youngdale&n; *&n; *  &lt;drew@colorado.edu&gt;&n; *&n; *  Bug correction thanks go to :&n; *      Rik Faith &lt;faith@cs.unc.edu&gt;&n; *      Tommy Thorn &lt;tthorn&gt;&n; *      Thomas Wuensche &lt;tw@fgb1.fgb.mw.tu-muenchen.de&gt;&n; *&n; *  Modified by Eric Youngdale eric@andante.jic.com or ericy@gnu.ai.mit.edu to&n; *  add scatter-gather, multiple outstanding request, and other&n; *  enhancements.&n; *&n; *  Native multichannel, wide scsi, /proc/scsi and hot plugging&n; *  support added by Michael Neuffer &lt;mike@i-connect.net&gt;&n; *&n; *  Added request_module(&quot;scsi_hostadapter&quot;) for kerneld:&n; *  (Put an &quot;alias scsi_hostadapter your_hostadapter&quot; in /etc/modules.conf)&n; *  Bjorn Ekwall  &lt;bj0rn@blox.se&gt;&n; *  (changed to kmod)&n; *&n; *  Major improvements to the timeout, abort, and reset processing,&n; *  as well as performance modifications for large queue depths by&n; *  Leonard N. Zubkoff &lt;lnz@dandelion.com&gt;&n; *&n; *  Converted cli() code to spinlocks, Ingo Molnar&n; *&n; *  Jiffies wrap fixes (host-&gt;resetting), 3 Dec 1998 Andrea Arcangeli&n; *&n; *  out_of_space hacks, D. Gilbert (dpg) 990608&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#ifdef CONFIG_KMOD
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#endif
DECL|macro|USE_STATIC_SCSI_MEMORY
macro_line|#undef USE_STATIC_SCSI_MEMORY
DECL|variable|proc_scsi
r_struct
id|proc_dir_entry
op_star
id|proc_scsi
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_static
r_int
id|scsi_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
suffix:semicolon
r_static
r_void
id|scsi_dump_status
c_func
(paren
r_int
id|level
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;   static const char RCSid[] = &quot;$Header: /vger/u4/cvs/linux/drivers/scsi/scsi.c,v 1.38 1997/01/19 23:07:18 davem Exp $&quot;;&n; */
multiline_comment|/*&n; * Definitions and constants.&n; */
DECL|macro|INTERNAL_ERROR
mdefine_line|#define INTERNAL_ERROR (panic (&quot;Internal error in file %s, line %d.&bslash;n&quot;, __FILE__, __LINE__))
multiline_comment|/*&n; * PAGE_SIZE must be a multiple of the sector size (512).  True&n; * for all reasonably recent architectures (even the VAX...).&n; */
DECL|macro|SECTOR_SIZE
mdefine_line|#define SECTOR_SIZE&t;&t;512
DECL|macro|SECTORS_PER_PAGE
mdefine_line|#define SECTORS_PER_PAGE&t;(PAGE_SIZE/SECTOR_SIZE)
macro_line|#if SECTORS_PER_PAGE &lt;= 8
DECL|typedef|FreeSectorBitmap
r_typedef
r_int
r_char
id|FreeSectorBitmap
suffix:semicolon
macro_line|#elif SECTORS_PER_PAGE &lt;= 32
DECL|typedef|FreeSectorBitmap
r_typedef
r_int
r_int
id|FreeSectorBitmap
suffix:semicolon
macro_line|#else
macro_line|#error You lose.
macro_line|#endif
DECL|macro|MIN_RESET_DELAY
mdefine_line|#define MIN_RESET_DELAY (2*HZ)
multiline_comment|/* Do not call reset on error if we just did a reset within 15 sec. */
DECL|macro|MIN_RESET_PERIOD
mdefine_line|#define MIN_RESET_PERIOD (15*HZ)
multiline_comment|/* The following devices are known not to tolerate a lun != 0 scan for&n; * one reason or another.  Some will respond to all luns, others will&n; * lock up.&n; */
DECL|macro|BLIST_NOLUN
mdefine_line|#define BLIST_NOLUN     &t;0x001
DECL|macro|BLIST_FORCELUN
mdefine_line|#define BLIST_FORCELUN  &t;0x002
DECL|macro|BLIST_BORKEN
mdefine_line|#define BLIST_BORKEN    &t;0x004
DECL|macro|BLIST_KEY
mdefine_line|#define BLIST_KEY       &t;0x008
DECL|macro|BLIST_SINGLELUN
mdefine_line|#define BLIST_SINGLELUN &t;0x010
DECL|macro|BLIST_NOTQ
mdefine_line|#define BLIST_NOTQ&t;&t;0x020
DECL|macro|BLIST_SPARSELUN
mdefine_line|#define BLIST_SPARSELUN &t;0x040
DECL|macro|BLIST_MAX5LUN
mdefine_line|#define BLIST_MAX5LUN&t;&t;0x080
DECL|macro|BLIST_ISDISK
mdefine_line|#define BLIST_ISDISK    &t;0x100
DECL|macro|BLIST_ISROM
mdefine_line|#define BLIST_ISROM     &t;0x200
DECL|macro|BLIST_GHOST
mdefine_line|#define BLIST_GHOST     &t;0x400   
multiline_comment|/*&n; * Data declarations.&n; */
DECL|variable|scsi_pid
r_int
r_int
id|scsi_pid
op_assign
l_int|0
suffix:semicolon
DECL|variable|last_cmnd
id|Scsi_Cmnd
op_star
id|last_cmnd
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Command groups 3 and 4 are reserved and should never be used.  */
DECL|variable|scsi_command_size
r_const
r_int
r_char
id|scsi_command_size
(braket
l_int|8
)braket
op_assign
(brace
l_int|6
comma
l_int|10
comma
l_int|10
comma
l_int|12
comma
l_int|12
comma
l_int|12
comma
l_int|10
comma
l_int|10
)brace
suffix:semicolon
DECL|variable|serial_number
r_static
r_int
r_int
id|serial_number
op_assign
l_int|0
suffix:semicolon
DECL|variable|scsi_bh_queue_head
r_static
id|Scsi_Cmnd
op_star
id|scsi_bh_queue_head
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|scsi_bh_queue_tail
r_static
id|Scsi_Cmnd
op_star
id|scsi_bh_queue_tail
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|dma_malloc_freelist
r_static
id|FreeSectorBitmap
op_star
id|dma_malloc_freelist
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|need_isa_bounce_buffers
r_static
r_int
id|need_isa_bounce_buffers
suffix:semicolon
DECL|variable|dma_sectors
r_static
r_int
r_int
id|dma_sectors
op_assign
l_int|0
suffix:semicolon
DECL|variable|scsi_dma_free_sectors
r_int
r_int
id|scsi_dma_free_sectors
op_assign
l_int|0
suffix:semicolon
DECL|variable|scsi_need_isa_buffer
r_int
r_int
id|scsi_need_isa_buffer
op_assign
l_int|0
suffix:semicolon
DECL|variable|dma_malloc_pages
r_static
r_int
r_char
op_star
op_star
id|dma_malloc_pages
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * Note - the initial logging level can be set here to log events at boot time.&n; * After the system is up, you may enable logging via the /proc interface.&n; */
DECL|variable|scsi_logging_level
r_int
r_int
id|scsi_logging_level
op_assign
l_int|0
suffix:semicolon
DECL|variable|host_active
r_volatile
r_struct
id|Scsi_Host
op_star
id|host_active
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|scsi_device_types
r_const
r_char
op_star
r_const
id|scsi_device_types
(braket
id|MAX_SCSI_DEVICE_CODE
)braket
op_assign
(brace
l_string|&quot;Direct-Access    &quot;
comma
l_string|&quot;Sequential-Access&quot;
comma
l_string|&quot;Printer          &quot;
comma
l_string|&quot;Processor        &quot;
comma
l_string|&quot;WORM             &quot;
comma
l_string|&quot;CD-ROM           &quot;
comma
l_string|&quot;Scanner          &quot;
comma
l_string|&quot;Optical Device   &quot;
comma
l_string|&quot;Medium Changer   &quot;
comma
l_string|&quot;Communications   &quot;
comma
l_string|&quot;Unknown          &quot;
comma
l_string|&quot;Unknown          &quot;
comma
l_string|&quot;Unknown          &quot;
comma
l_string|&quot;Enclosure        &quot;
comma
)brace
suffix:semicolon
multiline_comment|/* &n; * Function prototypes.&n; */
r_static
r_void
id|resize_dma_pool
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|data
)paren
suffix:semicolon
r_extern
r_void
id|scsi_times_out
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_static
r_int
id|scan_scsis_single
c_func
(paren
r_int
id|channel
comma
r_int
id|dev
comma
r_int
id|lun
comma
r_int
op_star
id|max_scsi_dev
comma
r_int
op_star
id|sparse_lun
comma
id|Scsi_Device
op_star
op_star
id|SDpnt
comma
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_char
op_star
id|scsi_result
)paren
suffix:semicolon
r_void
id|scsi_build_commandblocks
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
)paren
suffix:semicolon
r_static
r_int
id|scsi_unregister_device
c_func
(paren
r_struct
id|Scsi_Device_Template
op_star
id|tpnt
)paren
suffix:semicolon
multiline_comment|/*&n; * These are the interface to the old error handling code.  It should go away&n; * someday soon.&n; */
r_extern
r_void
id|scsi_old_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_extern
r_void
id|scsi_old_times_out
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
DECL|macro|SCSI_BLOCK
mdefine_line|#define SCSI_BLOCK(DEVICE, HOST)                                         &bslash;&n;&t;        ((HOST-&gt;block &amp;&amp; host_active &amp;&amp; HOST != host_active)          &bslash;&n;  &t;&t;|| ((HOST)-&gt;can_queue &amp;&amp; HOST-&gt;host_busy &gt;= HOST-&gt;can_queue)  &bslash;&n;&t;        || ((HOST)-&gt;host_blocked)                                     &bslash;&n;&t;        || ((DEVICE) != NULL &amp;&amp; (DEVICE)-&gt;device_blocked) )
DECL|struct|dev_info
r_struct
id|dev_info
(brace
DECL|member|vendor
r_const
r_char
op_star
id|vendor
suffix:semicolon
DECL|member|model
r_const
r_char
op_star
id|model
suffix:semicolon
DECL|member|revision
r_const
r_char
op_star
id|revision
suffix:semicolon
multiline_comment|/* Latest revision known to be bad.  Not used yet */
DECL|member|flags
r_int
id|flags
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * This is what was previously known as the blacklist.  The concept&n; * has been expanded so that we can specify other types of things we&n; * need to be aware of.&n; */
DECL|variable|device_list
r_static
r_struct
id|dev_info
id|device_list
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;Aashima&quot;
comma
l_string|&quot;IMAGERY 2400SP&quot;
comma
l_string|&quot;1.03&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;CHINON&quot;
comma
l_string|&quot;CD-ROM CDS-431&quot;
comma
l_string|&quot;H42&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;CHINON&quot;
comma
l_string|&quot;CD-ROM CDS-535&quot;
comma
l_string|&quot;Q14&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;DENON&quot;
comma
l_string|&quot;DRD-25X&quot;
comma
l_string|&quot;V&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if probed for lun != 0 */
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;DK312C&quot;
comma
l_string|&quot;CM81&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun - dtg */
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;DK314C&quot;
comma
l_string|&quot;CR21&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;IMS&quot;
comma
l_string|&quot;CDD521/10&quot;
comma
l_string|&quot;2.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-3280&quot;
comma
l_string|&quot;PR02&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-4380S&quot;
comma
l_string|&quot;B3C&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;MXT-1240S&quot;
comma
l_string|&quot;I1.2&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up when LUN&gt;0 polled */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-4170S&quot;
comma
l_string|&quot;B5A&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up sometimes when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-8760S&quot;
comma
l_string|&quot;B7B&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* guess what? */
(brace
l_string|&quot;MEDIAVIS&quot;
comma
l_string|&quot;RENO CD-ROMX2A&quot;
comma
l_string|&quot;2.03&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/*Responds to all lun */
(brace
l_string|&quot;MICROP&quot;
comma
l_string|&quot;4110&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_NOTQ
)brace
comma
multiline_comment|/* Buggy Tagged Queuing */
(brace
l_string|&quot;NEC&quot;
comma
l_string|&quot;CD-ROM DRIVE:841&quot;
comma
l_string|&quot;1.0&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;PHILIPS&quot;
comma
l_string|&quot;PCA80SC&quot;
comma
l_string|&quot;V4-2&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;RODIME&quot;
comma
l_string|&quot;RO3000S&quot;
comma
l_string|&quot;2.33&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;SANYO&quot;
comma
l_string|&quot;CRD-250S&quot;
comma
l_string|&quot;1.20&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1&n;&t;&t;&t;&t;&t;&t;&t;&t; * for aha152x controller, which causes&n;&t;&t;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST157N&quot;
comma
l_string|&quot;&bslash;004|j&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1&n;&t;&t;&t;&t;&t;&t;&t;&t; * for aha152x controller, which causes&n;&t;&t;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST296&quot;
comma
l_string|&quot;921&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST1581&quot;
comma
l_string|&quot;6538&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-541&quot;
comma
l_string|&quot;4.3d&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-55S&quot;
comma
l_string|&quot;1.0i&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-561&quot;
comma
l_string|&quot;1.7x&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-8012&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;TANDBERG&quot;
comma
l_string|&quot;TDC 3600&quot;
comma
l_string|&quot;U07&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;CD-R55S&quot;
comma
l_string|&quot;1.0H&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1&n;&t;&t;&t;&t;&t;&t;&t;&t; * for seagate controller, which causes&n;&t;&t;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;MT-2ST/45S2-27&quot;
comma
l_string|&quot;RV M&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;TEXEL&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1&n;&t;&t;&t;&t;&t;&t;&t;&t; * for seagate controller, which causes&n;&t;&t;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;LPS525S&quot;
comma
l_string|&quot;3110&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks sometimes if polled for lun != 0 */
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;PD1225S&quot;
comma
l_string|&quot;3110&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks sometimes if polled for lun != 0 */
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;FIREBALL ST4.3S&quot;
comma
l_string|&quot;0F0C&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up when polled for lun != 0 */
(brace
l_string|&quot;MEDIAVIS&quot;
comma
l_string|&quot;CDR-H93MV&quot;
comma
l_string|&quot;1.31&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;SANKYO&quot;
comma
l_string|&quot;CP525&quot;
comma
l_string|&quot;6.64&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQ SENSE, extra reset */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C1750A&quot;
comma
l_string|&quot;3226&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iic */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C1790A&quot;
comma
l_string|&quot;&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iip */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C2500A&quot;
comma
l_string|&quot;&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iicx */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CDR100&quot;
comma
l_string|&quot;1.00&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CDR102&quot;
comma
l_string|&quot;1.00&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0  &n;&t;&t;&t;&t;&t;&t;&t;&t; * extra reset */
(brace
l_string|&quot;RELISYS&quot;
comma
l_string|&quot;Scorpio&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all LUN */
multiline_comment|/*&n; * Other types of devices that have special flags.&n; */
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-8001&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_BORKEN
)brace
comma
(brace
l_string|&quot;TEXEL&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_BORKEN
)brace
comma
(brace
l_string|&quot;IOMEGA&quot;
comma
l_string|&quot;Io20S         *F&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;INSITE&quot;
comma
l_string|&quot;Floptical   F*8I&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;INSITE&quot;
comma
l_string|&quot;I325VM&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;NRC&quot;
comma
l_string|&quot;MBR-7&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NRC&quot;
comma
l_string|&quot;MBR-7.4&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;REGAL&quot;
comma
l_string|&quot;CDC-4X&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_MAX5LUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NAKAMICH&quot;
comma
l_string|&quot;MJ-4.8S&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NAKAMICH&quot;
comma
l_string|&quot;MJ-5.16S&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-600&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-602X&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-604X&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;EMULEX&quot;
comma
l_string|&quot;MD21/S2     ESDI&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;CANON&quot;
comma
l_string|&quot;IPUBJD&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;nCipher&quot;
comma
l_string|&quot;Fastness Crypto&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;NEC&quot;
comma
l_string|&quot;PD-1 ODX654P&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;MATSHITA&quot;
comma
l_string|&quot;PD-1&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;iomega&quot;
comma
l_string|&quot;jaz 1GB&quot;
comma
l_string|&quot;J.86&quot;
comma
id|BLIST_NOTQ
op_or
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;CREATIVE&quot;
comma
l_string|&quot;DVD-RAM RAM&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_GHOST
)brace
comma
(brace
l_string|&quot;MATSHITA&quot;
comma
l_string|&quot;PD-2 LF-D100&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_GHOST
)brace
comma
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;GF-1050&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_GHOST
)brace
comma
multiline_comment|/* Hitachi SCSI DVD-RAM */
(brace
l_string|&quot;TOSHIBA&quot;
comma
l_string|&quot;CDROM&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_ISROM
)brace
comma
multiline_comment|/*&n;&t; * Must be at end of list...&n;&t; */
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|function|get_device_flags
r_static
r_int
id|get_device_flags
c_func
(paren
r_int
r_char
op_star
id|response_data
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|pnt
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|device_list
(braket
id|i
)braket
dot
id|vendor
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|pnt
op_assign
op_amp
id|response_data
(braket
l_int|8
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_eq
l_char|&squot; &squot;
)paren
id|pnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|vendor
comma
id|pnt
comma
id|strlen
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|vendor
)paren
)paren
)paren
r_continue
suffix:semicolon
id|pnt
op_assign
op_amp
id|response_data
(braket
l_int|16
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_eq
l_char|&squot; &squot;
)paren
id|pnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|model
comma
id|pnt
comma
id|strlen
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|model
)paren
)paren
)paren
r_continue
suffix:semicolon
r_return
id|device_list
(braket
id|i
)braket
dot
id|flags
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scan_scsis_done
r_static
r_void
id|scan_scsis_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;scan_scsis_done(%p, %06x)&bslash;n&quot;
comma
id|SCpnt-&gt;host
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request.sem
op_ne
l_int|NULL
)paren
id|up
c_func
(paren
id|SCpnt-&gt;request.sem
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|scsi_logging_level
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|scsi_logging_level
comma
l_string|&quot;SCSI logging level; should be zero or nonzero&quot;
)paren
suffix:semicolon
macro_line|#else
DECL|function|scsi_logging_setup
r_static
r_int
id|__init
id|scsi_logging_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|tmp
)paren
op_eq
l_int|1
)paren
(brace
id|scsi_logging_level
op_assign
(paren
id|tmp
ques
c_cond
op_complement
l_int|0
suffix:colon
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi_logging_setup : usage scsi_logging_level=n &quot;
l_string|&quot;(n should be 0 or non-zero)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|__setup
c_func
(paren
l_string|&quot;scsi_logging=&quot;
comma
id|scsi_logging_setup
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SCSI_MULTI_LUN
DECL|variable|max_scsi_luns
r_static
r_int
id|max_scsi_luns
op_assign
l_int|8
suffix:semicolon
macro_line|#else
DECL|variable|max_scsi_luns
r_static
r_int
id|max_scsi_luns
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|max_scsi_luns
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_scsi_luns
comma
l_string|&quot;last scsi LUN (should be between 1 and 8)&quot;
)paren
suffix:semicolon
macro_line|#else
DECL|function|scsi_luns_setup
r_static
r_int
id|__init
id|scsi_luns_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|tmp
)paren
op_eq
l_int|1
)paren
(brace
id|max_scsi_luns
op_assign
id|tmp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi_luns_setup : usage max_scsi_luns=n &quot;
l_string|&quot;(n should be between 1 and 8)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|__setup
c_func
(paren
l_string|&quot;max_scsi_luns=&quot;
comma
id|scsi_luns_setup
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;Issue a command and wait for it to complete&n; */
DECL|function|scsi_wait_cmd
r_void
id|scsi_wait_cmd
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
comma
r_int
id|timeout
comma
r_int
id|retries
)paren
(brace
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|sem
)paren
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
op_amp
id|sem
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|scsi_do_cmd
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|cmnd
comma
id|buffer
comma
id|bufflen
comma
id|done
comma
id|timeout
comma
id|retries
)paren
suffix:semicolon
id|down
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *  Detecting SCSI devices :&n; *  We scan all present host adapter&squot;s busses,  from ID 0 to ID (max_id).&n; *  We use the INQUIRY command, determine device type, and pass the ID /&n; *  lun address of all sequential devices to the tape driver, all random&n; *  devices to the disk driver.&n; */
DECL|function|scan_scsis
r_static
r_void
id|scan_scsis
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
id|unchar
id|hardcoded
comma
id|unchar
id|hchannel
comma
id|unchar
id|hid
comma
id|unchar
id|hlun
)paren
(brace
r_int
id|channel
suffix:semicolon
r_int
id|dev
suffix:semicolon
r_int
id|lun
suffix:semicolon
r_int
id|max_dev_lun
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_int
r_char
op_star
id|scsi_result
suffix:semicolon
r_int
r_char
id|scsi_result0
(braket
l_int|256
)braket
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDtail
suffix:semicolon
r_int
id|sparse_lun
suffix:semicolon
id|scsi_result
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|scsi_init_malloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Cmnd
)paren
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
)paren
(brace
id|SDpnt
op_assign
(paren
id|Scsi_Device
op_star
)paren
id|scsi_init_malloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Device
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Register the queue for the device.  All I/O requests will come&n;&t;&t;&t; * in through here.  We also need to register a pointer to&n;&t;&t;&t; * ourselves, since the queue handler won&squot;t know what device&n;&t;&t;&t; * the queue actually represents.   We could look it up, but it&n;&t;&t;&t; * is pointless work.&n;&t;&t;&t; */
id|blk_init_queue
c_func
(paren
op_amp
id|SDpnt-&gt;request_queue
comma
id|scsi_request_fn
)paren
suffix:semicolon
id|blk_queue_headactive
c_func
(paren
op_amp
id|SDpnt-&gt;request_queue
comma
l_int|0
)paren
suffix:semicolon
id|SDpnt-&gt;request_queue.queuedata
op_assign
(paren
r_void
op_star
)paren
id|SDpnt
suffix:semicolon
multiline_comment|/* Make sure we have something that is valid for DMA purposes */
id|scsi_result
op_assign
(paren
(paren
op_logical_neg
id|shpnt-&gt;unchecked_isa_dma
)paren
ques
c_cond
op_amp
id|scsi_result0
(braket
l_int|0
)braket
suffix:colon
id|scsi_init_malloc
c_func
(paren
l_int|512
comma
id|GFP_DMA
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|scsi_result
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to obtain scsi_result buffer&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We must chain ourself in the host_queue, so commands can time out &n;&t; */
id|SCpnt-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|SDpnt-&gt;device_queue
op_assign
id|SCpnt
suffix:semicolon
id|SDpnt-&gt;host
op_assign
id|shpnt
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
id|initialize_merge_fn
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|SDpnt-&gt;device_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Next, hook the device to the host in question.&n;&t; */
id|SDpnt-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|SDpnt-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;host_queue
op_ne
l_int|NULL
)paren
(brace
id|SDtail
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SDtail-&gt;next
op_ne
l_int|NULL
)paren
id|SDtail
op_assign
id|SDtail-&gt;next
suffix:semicolon
id|SDtail-&gt;next
op_assign
id|SDpnt
suffix:semicolon
id|SDpnt-&gt;prev
op_assign
id|SDtail
suffix:semicolon
)brace
r_else
(brace
id|shpnt-&gt;host_queue
op_assign
id|SDpnt
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We need to increment the counter for this one device so we can track when&n;&t; * things are quiet.&n;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|shpnt-&gt;host_active
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hardcoded
op_eq
l_int|1
)paren
(brace
id|Scsi_Device
op_star
id|oldSDpnt
op_assign
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
id|channel
op_assign
id|hchannel
suffix:semicolon
r_if
c_cond
(paren
id|channel
OG
id|shpnt-&gt;max_channel
)paren
r_goto
id|leave
suffix:semicolon
id|dev
op_assign
id|hid
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ge
id|shpnt-&gt;max_id
)paren
r_goto
id|leave
suffix:semicolon
id|lun
op_assign
id|hlun
suffix:semicolon
r_if
c_cond
(paren
id|lun
op_ge
id|shpnt-&gt;max_lun
)paren
r_goto
id|leave
suffix:semicolon
id|scan_scsis_single
c_func
(paren
id|channel
comma
id|dev
comma
id|lun
comma
op_amp
id|max_dev_lun
comma
op_amp
id|sparse_lun
comma
op_amp
id|SDpnt
comma
id|SCpnt
comma
id|shpnt
comma
id|scsi_result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt
op_ne
id|oldSDpnt
)paren
(brace
multiline_comment|/* it could happen the blockdevice hasn&squot;t yet been inited */
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;init
op_logical_and
id|sdtpnt-&gt;dev_noticed
)paren
(paren
op_star
id|sdtpnt-&gt;init
)paren
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|sdtpnt-&gt;attach
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;attach
)paren
(paren
id|oldSDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldSDpnt-&gt;attached
)paren
(brace
id|scsi_build_commandblocks
c_func
(paren
id|oldSDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|oldSDpnt-&gt;has_cmdblocks
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scan_scsis: DANGER, no command blocks&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* What to do now ?? */
)brace
)brace
)brace
)brace
id|resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|sdtpnt-&gt;finish
op_logical_and
id|sdtpnt-&gt;nr_dev
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;finish
)paren
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Actual LUN. PC ordering is 0-&gt;n IBM/spec ordering is n-&gt;0 */
r_int
id|order_dev
suffix:semicolon
r_for
c_loop
(paren
id|channel
op_assign
l_int|0
suffix:semicolon
id|channel
op_le
id|shpnt-&gt;max_channel
suffix:semicolon
id|channel
op_increment
)paren
(brace
r_for
c_loop
(paren
id|dev
op_assign
l_int|0
suffix:semicolon
id|dev
OL
id|shpnt-&gt;max_id
suffix:semicolon
op_increment
id|dev
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;reverse_ordering
)paren
multiline_comment|/* Shift to scanning 15,14,13... or 7,6,5,4, */
id|order_dev
op_assign
id|shpnt-&gt;max_id
op_minus
id|dev
op_minus
l_int|1
suffix:semicolon
r_else
id|order_dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;this_id
op_ne
id|order_dev
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * We need the for so our continue, etc. work fine. We put this in&n;&t;&t;&t;&t;&t; * a variable so that we can override it during the scan if we&n;&t;&t;&t;&t;&t; * detect a device *KNOWN* to have multiple logical units.&n;&t;&t;&t;&t;&t; */
id|max_dev_lun
op_assign
(paren
id|max_scsi_luns
OL
id|shpnt-&gt;max_lun
ques
c_cond
id|max_scsi_luns
suffix:colon
id|shpnt-&gt;max_lun
)paren
suffix:semicolon
id|sparse_lun
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
id|max_dev_lun
suffix:semicolon
op_increment
id|lun
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|scan_scsis_single
c_func
(paren
id|channel
comma
id|order_dev
comma
id|lun
comma
op_amp
id|max_dev_lun
comma
op_amp
id|sparse_lun
comma
op_amp
id|SDpnt
comma
id|SCpnt
comma
id|shpnt
comma
id|scsi_result
)paren
op_logical_and
op_logical_neg
id|sparse_lun
)paren
r_break
suffix:semicolon
multiline_comment|/* break means don&squot;t probe further for luns!=0 */
)brace
multiline_comment|/* for lun ends */
)brace
multiline_comment|/* if this_id != id ends */
)brace
multiline_comment|/* for dev ends */
)brace
multiline_comment|/* for channel ends */
)brace
multiline_comment|/* if/else hardcoded */
multiline_comment|/*&n;&t; * We need to decrement the counter for this one device&n;&t; * so we know when everything is quiet.&n;&t; */
id|atomic_dec
c_func
(paren
op_amp
id|shpnt-&gt;host_active
)paren
suffix:semicolon
id|leave
suffix:colon
(brace
multiline_comment|/* Unchain SCpnt from host_queue */
id|Scsi_Device
op_star
id|prev
comma
op_star
id|next
suffix:semicolon
id|Scsi_Device
op_star
id|dqptr
suffix:semicolon
r_for
c_loop
(paren
id|dqptr
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|dqptr
op_ne
id|SDpnt
suffix:semicolon
id|dqptr
op_assign
id|dqptr-&gt;next
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dqptr
)paren
(brace
id|prev
op_assign
id|dqptr-&gt;prev
suffix:semicolon
id|next
op_assign
id|dqptr-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;next
op_assign
id|next
suffix:semicolon
r_else
id|shpnt-&gt;host_queue
op_assign
id|next
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
id|next-&gt;prev
op_assign
id|prev
suffix:semicolon
)brace
)brace
multiline_comment|/* Last device block does not exist.  Free memory. */
r_if
c_cond
(paren
id|SDpnt
op_ne
l_int|NULL
)paren
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|SDpnt
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_ne
l_int|NULL
)paren
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|SCpnt
comma
r_sizeof
(paren
id|Scsi_Cmnd
)paren
)paren
suffix:semicolon
multiline_comment|/* If we allocated a buffer so we could do DMA, free it now */
r_if
c_cond
(paren
id|scsi_result
op_ne
op_amp
id|scsi_result0
(braket
l_int|0
)braket
op_logical_and
id|scsi_result
op_ne
l_int|NULL
)paren
(brace
id|scsi_init_free
c_func
(paren
id|scsi_result
comma
l_int|512
)paren
suffix:semicolon
)brace
(brace
id|Scsi_Device
op_star
id|sdev
suffix:semicolon
id|Scsi_Cmnd
op_star
id|scmd
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;Host status for host %p:&bslash;n&quot;
comma
id|shpnt
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdev
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|sdev
suffix:semicolon
id|sdev
op_assign
id|sdev-&gt;next
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;Device %d %p: &quot;
comma
id|sdev-&gt;id
comma
id|sdev
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|scmd
op_assign
id|sdev-&gt;device_queue
suffix:semicolon
id|scmd
suffix:semicolon
id|scmd
op_assign
id|scmd-&gt;next
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;%p &quot;
comma
id|scmd
)paren
)paren
suffix:semicolon
)brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * The worker for scan_scsis.&n; * Returning 0 means Please don&squot;t ask further for lun!=0, 1 means OK go on.&n; * Global variables used : scsi_devices(linked list)&n; */
DECL|function|scan_scsis_single
r_int
id|scan_scsis_single
c_func
(paren
r_int
id|channel
comma
r_int
id|dev
comma
r_int
id|lun
comma
r_int
op_star
id|max_dev_lun
comma
r_int
op_star
id|sparse_lun
comma
id|Scsi_Device
op_star
op_star
id|SDpnt2
comma
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_char
op_star
id|scsi_result
)paren
(brace
r_int
r_char
id|scsi_cmd
(braket
l_int|12
)braket
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDtail
comma
op_star
id|SDpnt
op_assign
op_star
id|SDpnt2
suffix:semicolon
r_int
id|bflags
comma
id|type
op_assign
op_minus
l_int|1
suffix:semicolon
r_static
r_int
id|ghost_channel
op_assign
op_minus
l_int|1
comma
id|ghost_dev
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|org_lun
op_assign
id|lun
suffix:semicolon
id|SDpnt-&gt;host
op_assign
id|shpnt
suffix:semicolon
id|SDpnt-&gt;id
op_assign
id|dev
suffix:semicolon
id|SDpnt-&gt;lun
op_assign
id|lun
suffix:semicolon
id|SDpnt-&gt;channel
op_assign
id|channel
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|channel
op_eq
id|ghost_channel
)paren
op_logical_and
(paren
id|dev
op_eq
id|ghost_dev
)paren
op_logical_and
(paren
id|lun
op_eq
l_int|1
)paren
)paren
(brace
id|SDpnt-&gt;lun
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ghost_channel
op_assign
id|ghost_dev
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Some low level driver could use device-&gt;type (DB) */
id|SDpnt-&gt;type
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Assume that the device will have handshaking problems, and then fix this&n;&t; * field later if it turns out it doesn&squot;t&n;&t; */
id|SDpnt-&gt;borken
op_assign
l_int|1
suffix:semicolon
id|SDpnt-&gt;was_reset
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;expecting_cc_ua
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;starved
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|TEST_UNIT_READY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
id|lun
op_lshift
l_int|5
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;host
op_assign
id|SDpnt-&gt;host
suffix:semicolon
id|SCpnt-&gt;device
op_assign
id|SDpnt
suffix:semicolon
id|SCpnt-&gt;target
op_assign
id|SDpnt-&gt;id
suffix:semicolon
id|SCpnt-&gt;lun
op_assign
id|SDpnt-&gt;lun
suffix:semicolon
id|SCpnt-&gt;channel
op_assign
id|SDpnt-&gt;channel
suffix:semicolon
id|scsi_wait_cmd
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
l_int|NULL
comma
l_int|0
comma
id|scan_scsis_done
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|5
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi: scan_scsis_single id %d lun %d. Return code 0x%08x&bslash;n&quot;
comma
id|dev
comma
id|lun
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|print_driverbyte
c_func
(paren
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|print_hostbyte
c_func
(paren
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;result
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|driver_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
op_amp
id|DRIVER_SENSE
)paren
op_logical_or
(paren
id|status_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
op_amp
id|CHECK_CONDITION
)paren
)paren
op_logical_and
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x70
)paren
op_rshift
l_int|4
)paren
op_eq
l_int|7
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|NOT_READY
)paren
op_logical_and
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|UNIT_ATTENTION
)paren
op_logical_and
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|ILLEGAL_REQUEST
op_logical_or
id|lun
OG
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi: performing INQUIRY&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Build an INQUIRY command block.&n;&t; */
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|255
suffix:semicolon
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
id|scsi_wait_cmd
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|256
comma
id|scan_scsis_done
comma
id|SCSI_TIMEOUT
comma
l_int|3
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi: INQUIRY %s with code 0x%x&bslash;n&quot;
comma
id|SCpnt-&gt;result
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;successful&quot;
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;result
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* assume no peripheral if any sort of error */
multiline_comment|/*&n;&t; * Check the peripheral qualifier field - this tells us whether LUNS&n;&t; * are supported here or not.&n;&t; */
r_if
c_cond
(paren
(paren
id|scsi_result
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
op_eq
l_int|3
)paren
(brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* assume no peripheral if any sort of error */
)brace
multiline_comment|/*&n;&t; * Get any flags for this device.  &n;&t; */
id|bflags
op_assign
id|get_device_flags
(paren
id|scsi_result
)paren
suffix:semicolon
multiline_comment|/*   The Toshiba ROM was &quot;gender-changed&quot; here as an inline hack.&n;&t;      This is now much more generic.&n;&t;      This is a mess: What we really want is to leave the scsi_result&n;&t;      alone, and just change the SDpnt structure. And the SDpnt is what&n;&t;      we want print_inquiry to print.  -- REW&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_ISDISK
)paren
(brace
id|scsi_result
(braket
l_int|0
)braket
op_assign
id|TYPE_DISK
suffix:semicolon
id|scsi_result
(braket
l_int|1
)braket
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* removable */
)brace
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_ISROM
)paren
(brace
id|scsi_result
(braket
l_int|0
)braket
op_assign
id|TYPE_ROM
suffix:semicolon
id|scsi_result
(braket
l_int|1
)braket
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* removable */
)brace
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_GHOST
)paren
(brace
r_if
c_cond
(paren
(paren
id|ghost_channel
op_eq
id|channel
)paren
op_logical_and
(paren
id|ghost_dev
op_eq
id|dev
)paren
op_logical_and
(paren
id|org_lun
op_eq
l_int|1
)paren
)paren
(brace
id|lun
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|ghost_channel
op_assign
id|channel
suffix:semicolon
id|ghost_dev
op_assign
id|dev
suffix:semicolon
id|scsi_result
(braket
l_int|0
)braket
op_assign
id|TYPE_MOD
suffix:semicolon
id|scsi_result
(braket
l_int|1
)braket
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* removable */
)brace
)brace
id|memcpy
c_func
(paren
id|SDpnt-&gt;vendor
comma
id|scsi_result
op_plus
l_int|8
comma
l_int|8
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|SDpnt-&gt;model
comma
id|scsi_result
op_plus
l_int|16
comma
l_int|16
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|SDpnt-&gt;rev
comma
id|scsi_result
op_plus
l_int|32
comma
l_int|4
)paren
suffix:semicolon
id|SDpnt-&gt;removable
op_assign
(paren
l_int|0x80
op_amp
id|scsi_result
(braket
l_int|1
)braket
)paren
op_rshift
l_int|7
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
id|SDpnt-&gt;lockable
op_assign
id|SDpnt-&gt;removable
suffix:semicolon
id|SDpnt-&gt;changed
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;access_count
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;has_cmdblocks
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Currently, all sequential devices are assumed to be tapes, all random&n;&t; * devices disk, with the appropriate read only flags set for ROM / WORM&n;&t; * treated as RO.&n;&t; */
r_switch
c_cond
(paren
id|type
op_assign
(paren
id|scsi_result
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
)paren
(brace
r_case
id|TYPE_TAPE
suffix:colon
r_case
id|TYPE_DISK
suffix:colon
r_case
id|TYPE_MOD
suffix:colon
r_case
id|TYPE_PROCESSOR
suffix:colon
r_case
id|TYPE_SCANNER
suffix:colon
r_case
id|TYPE_MEDIUM_CHANGER
suffix:colon
r_case
id|TYPE_ENCLOSURE
suffix:colon
id|SDpnt-&gt;writeable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_WORM
suffix:colon
r_case
id|TYPE_ROM
suffix:colon
id|SDpnt-&gt;writeable
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi: unknown type %d&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
)brace
id|SDpnt-&gt;device_blocked
op_assign
id|FALSE
suffix:semicolon
id|SDpnt-&gt;device_busy
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;single_lun
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;soft_reset
op_assign
(paren
id|scsi_result
(braket
l_int|7
)braket
op_amp
l_int|1
)paren
op_logical_and
(paren
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|7
)paren
op_eq
l_int|2
)paren
suffix:semicolon
id|SDpnt-&gt;random
op_assign
(paren
id|type
op_eq
id|TYPE_TAPE
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|SDpnt-&gt;type
op_assign
(paren
id|type
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|print_inquiry
c_func
(paren
id|scsi_result
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;detect
)paren
id|SDpnt-&gt;attached
op_add_assign
(paren
op_star
id|sdtpnt-&gt;detect
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
id|SDpnt-&gt;scsi_level
op_assign
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;scsi_level
op_ge
l_int|2
op_logical_or
(paren
id|SDpnt-&gt;scsi_level
op_eq
l_int|1
op_logical_and
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
)paren
id|SDpnt-&gt;scsi_level
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Accommodate drivers that want to sleep when they should be in a polling&n;&t; * loop.&n;&t; */
id|SDpnt-&gt;disconnect
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Set the tagged_queue flag for SCSI-II devices that purport to support&n;&t; * tagged queuing in the INQUIRY data.&n;&t; */
id|SDpnt-&gt;tagged_queue
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|SDpnt-&gt;scsi_level
op_ge
id|SCSI_2
)paren
op_logical_and
(paren
id|scsi_result
(braket
l_int|7
)braket
op_amp
l_int|2
)paren
op_logical_and
op_logical_neg
(paren
id|bflags
op_amp
id|BLIST_NOTQ
)paren
)paren
(brace
id|SDpnt-&gt;tagged_supported
op_assign
l_int|1
suffix:semicolon
id|SDpnt-&gt;current_tag
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Some revisions of the Texel CD ROM drives have handshaking problems when&n;&t; * used with the Seagate controllers.  Before we know what type of device&n;&t; * we&squot;re talking to, we assume it&squot;s borken and then change it here if it&n;&t; * turns out that it isn&squot;t a TEXEL drive.&n;&t; */
r_if
c_cond
(paren
(paren
id|bflags
op_amp
id|BLIST_BORKEN
)paren
op_eq
l_int|0
)paren
id|SDpnt-&gt;borken
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we want to only allow I/O to one of the luns attached to this device&n;&t; * at a time, then we set this flag.&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_SINGLELUN
)paren
id|SDpnt-&gt;single_lun
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * These devices need this &quot;key&quot; to unlock the devices so we can use it&n;&t; */
r_if
c_cond
(paren
(paren
id|bflags
op_amp
id|BLIST_KEY
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unlocked floptical drive.&bslash;n&quot;
)paren
suffix:semicolon
id|SDpnt-&gt;lockable
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x2e
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|0x2a
suffix:semicolon
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
id|scsi_wait_cmd
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|0x2a
comma
id|scan_scsis_done
comma
id|SCSI_TIMEOUT
comma
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Detach the command from the device. It was just a temporary to be used while&n;&t; * scanning the bus - the real ones will be allocated later.&n;&t; */
id|SDpnt-&gt;device_queue
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * This device was already hooked up to the host in question,&n;&t; * so at this point we just let go of it and it should be fine.  We do need to&n;&t; * allocate a new one and attach it to the host so that we can further scan the bus.&n;&t; */
id|SDpnt
op_assign
(paren
id|Scsi_Device
op_star
)paren
id|scsi_init_malloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Device
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
op_star
id|SDpnt2
op_assign
id|SDpnt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SDpnt
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: scan_scsis_single: Cannot malloc&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Register the queue for the device.  All I/O requests will come&n;&t; * in through here.  We also need to register a pointer to&n;&t; * ourselves, since the queue handler won&squot;t know what device&n;&t; * the queue actually represents.   We could look it up, but it&n;&t; * is pointless work.&n;&t; */
id|blk_init_queue
c_func
(paren
op_amp
id|SDpnt-&gt;request_queue
comma
id|scsi_request_fn
)paren
suffix:semicolon
id|blk_queue_headactive
c_func
(paren
op_amp
id|SDpnt-&gt;request_queue
comma
l_int|0
)paren
suffix:semicolon
id|SDpnt-&gt;request_queue.queuedata
op_assign
(paren
r_void
op_star
)paren
id|SDpnt
suffix:semicolon
id|SDpnt-&gt;host
op_assign
id|shpnt
suffix:semicolon
id|initialize_merge_fn
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * And hook up our command block to the new device we will be testing&n;&t; * for.&n;&t; */
id|SDpnt-&gt;device_queue
op_assign
id|SCpnt
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|SDpnt-&gt;device_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since we just found one device, there had damn well better be one in the list&n;&t; * already.&n;&t; */
r_if
c_cond
(paren
id|shpnt-&gt;host_queue
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;scan_scsis_single: Host queue == NULL&bslash;n&quot;
)paren
suffix:semicolon
id|SDtail
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SDtail-&gt;next
)paren
(brace
id|SDtail
op_assign
id|SDtail-&gt;next
suffix:semicolon
)brace
multiline_comment|/* Add this device to the linked list at the end */
id|SDtail-&gt;next
op_assign
id|SDpnt
suffix:semicolon
id|SDpnt-&gt;prev
op_assign
id|SDtail
suffix:semicolon
id|SDpnt-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Some scsi devices cannot be polled for lun != 0 due to firmware bugs&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_NOLUN
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* break; */
multiline_comment|/*&n;&t; * If this device is known to support sparse multiple units, override the&n;&t; * other settings, and scan all of them.&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_SPARSELUN
)paren
(brace
op_star
id|max_dev_lun
op_assign
l_int|8
suffix:semicolon
op_star
id|sparse_lun
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If this device is known to support multiple units, override the other&n;&t; * settings, and scan all of them.&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_FORCELUN
)paren
(brace
op_star
id|max_dev_lun
op_assign
l_int|8
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * REGAL CDC-4X: avoid hang after LUN 4&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_MAX5LUN
)paren
(brace
op_star
id|max_dev_lun
op_assign
l_int|5
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If this device is Ghosted, scan upto two luns. (It physically only&n;&t; * has one). -- REW&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_GHOST
)paren
(brace
op_star
id|max_dev_lun
op_assign
l_int|2
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We assume the device can&squot;t handle lun!=0 if: - it reports scsi-0 (ANSI&n;&t; * SCSI Revision 0) (old drives like MAXTOR XT-3280) or - it reports scsi-1&n;&t; * (ANSI SCSI Revision 1) and Response Data Format 0&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *  Flag bits for the internal_timeout array&n; */
DECL|macro|NORMAL_TIMEOUT
mdefine_line|#define NORMAL_TIMEOUT 0
DECL|macro|IN_ABORT
mdefine_line|#define IN_ABORT  1
DECL|macro|IN_RESET
mdefine_line|#define IN_RESET  2
DECL|macro|IN_RESET2
mdefine_line|#define IN_RESET2 4
DECL|macro|IN_RESET3
mdefine_line|#define IN_RESET3 8
multiline_comment|/* This function takes a quick look at a request, and decides if it&n; * can be queued now, or if there would be a stall while waiting for&n; * something else to finish.  This routine assumes that interrupts are&n; * turned off when entering the routine.  It is the responsibility&n; * of the calling code to ensure that this is the case.&n; */
multiline_comment|/* This function returns a structure pointer that will be valid for&n; * the device.  The wait parameter tells us whether we should wait for&n; * the unit to become free or not.  We are also able to tell this routine&n; * not to return a descriptor if the host is unable to accept any more&n; * commands for the time being.  We need to keep in mind that there is no&n; * guarantee that the host remain not busy.  Keep in mind the&n; * scsi_request_queueable function also knows the internal allocation scheme&n; * of the packets for each device&n; */
multiline_comment|/*&n; * This lock protects the freelist for all devices on the system.&n; * We could make this finer grained by having a single lock per&n; * device if it is ever found that there is excessive contention&n; * on this lock.&n; */
DECL|variable|device_request_lock
r_static
id|spinlock_t
id|device_request_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Used for access to internal allocator used for DMA safe buffers.&n; */
DECL|variable|allocator_request_lock
r_static
id|spinlock_t
id|allocator_request_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Used to protect insertion into and removal from the queue of&n; * commands to be processed by the bottom half handler.&n; */
DECL|variable|scsi_bhqueue_lock
r_static
id|spinlock_t
id|scsi_bhqueue_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Function:    scsi_allocate_device&n; *&n; * Purpose:     Allocate a command descriptor.&n; *&n; * Arguments:   device    - device for which we want a command descriptor&n; *              wait      - 1 if we should wait in the event that none&n; *                          are available.&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; *&n; * Returns:     Pointer to command descriptor.&n; *&n; * Notes:       Prior to the new queue code, this function was not SMP-safe.&n; */
DECL|function|scsi_allocate_device
id|Scsi_Cmnd
op_star
id|scsi_allocate_device
c_func
(paren
id|Scsi_Device
op_star
id|device
comma
r_int
id|wait
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
id|panic
c_func
(paren
l_string|&quot;No device passed to scsi_allocate_device().&bslash;n&quot;
)paren
suffix:semicolon
id|host
op_assign
id|device-&gt;host
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
op_eq
l_int|1
)paren
(brace
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;device_blocked
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;single_lun
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * FIXME(eric) - this is not at all optimal.  Given that&n;&t;&t;&t;&t; * single lun devices are rare and usually slow&n;&t;&t;&t;&t; * (i.e. CD changers), this is good enough for now, but&n;&t;&t;&t;&t; * we may want to come back and optimize this later.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * Scan through all of the devices attached to this&n;&t;&t;&t;&t; * host, and see if any are active or not.  If so,&n;&t;&t;&t;&t; * we need to defer this command.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * We really need a busy counter per device.  This would&n;&t;&t;&t;&t; * allow us to more easily figure out whether we should&n;&t;&t;&t;&t; * do anything here or not.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Only look for other devices on the same bus&n;&t;&t;&t;&t;&t; * with the same target ID.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|SDpnt-&gt;channel
op_ne
id|device-&gt;channel
op_logical_or
id|SDpnt-&gt;id
op_ne
id|device-&gt;id
op_logical_or
id|SDpnt
op_eq
id|device
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SCpnt
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SDpnt
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Some other device in this cluster is busy.&n;&t;&t;&t;&t;&t; * If asked to wait, we need to wait, otherwise&n;&t;&t;&t;&t;&t; * return NULL.&n;&t;&t;&t;&t;&t; */
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Now we can check for a free command block for this device.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|SCpnt
op_assign
id|device-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_eq
id|RQ_INACTIVE
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * If we couldn&squot;t find a free command block, and we have been&n;&t;&t; * asked to wait, then do so.&n;&t;&t; */
r_if
c_cond
(paren
id|SCpnt
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we have been asked to wait for a free block, then&n;&t;&t; * wait here.&n;&t;&t; */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This should block until a device command block&n;&t;&t;&t; * becomes available.&n;&t;&t;&t; */
id|sleep_on
c_func
(paren
op_amp
id|device-&gt;device_wait
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* And no one is waiting for this&n;&t;&t;&t;&t;&t; * to complete */
id|atomic_inc
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the scatter-gather flag */
id|SCpnt-&gt;old_use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No default transfer size */
id|SCpnt-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do not flag underflow conditions */
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_INITIALIZING
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_HIGHLEVEL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Activating command for device %d (%d)&bslash;n&quot;
comma
id|SCpnt-&gt;target
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
)paren
)paren
suffix:semicolon
r_return
id|SCpnt
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_release_command&n; *&n; * Purpose:     Release a command block.&n; *&n; * Arguments:   SCpnt - command block we are releasing.&n; *&n; * Notes:       The command block can no longer be used by the caller once&n; *              this funciton is called.  This is in effect the inverse&n; *              of scsi_allocate_device/scsi_request_queueable.&n; */
DECL|function|scsi_release_command
r_void
id|scsi_release_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_UNUSED
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_NOBODY
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Deactivating command for device %d (active=%d, failed=%d)&bslash;n&quot;
comma
id|SCpnt-&gt;target
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
comma
id|SCpnt-&gt;host-&gt;host_failed
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;host_failed
op_ne
l_int|0
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Error handler thread %d %d&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;in_recovery
comma
id|SCpnt-&gt;host-&gt;eh_active
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the host is having troubles, then look to see if this was the last&n;&t; * command that might have failed.  If so, wake up the error handler.&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;in_recovery
op_logical_and
op_logical_neg
id|SCpnt-&gt;host-&gt;eh_active
op_logical_and
id|SCpnt-&gt;host-&gt;host_busy
op_eq
id|SCpnt-&gt;host-&gt;host_failed
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Waking error handler thread (%d)&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;eh_wait-&gt;count
)paren
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
id|SCpnt-&gt;host-&gt;eh_wait
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is inline because we have stack problemes if we recurse to deeply.&n; */
DECL|function|scsi_dispatch_cmd
r_int
id|scsi_dispatch_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
macro_line|#ifdef DEBUG_DELAY
r_int
r_int
id|clock
suffix:semicolon
macro_line|#endif
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_int
id|rtn
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
op_amp
id|io_request_lock
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if DEBUG
r_int
r_int
op_star
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __mips__
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;move&bslash;t%0,$31&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
)paren
suffix:semicolon
macro_line|#else
id|ret
op_assign
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
multiline_comment|/* Assign a unique nonzero serial_number. */
r_if
c_cond
(paren
op_increment
id|serial_number
op_eq
l_int|0
)paren
id|serial_number
op_assign
l_int|1
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
id|serial_number
suffix:semicolon
multiline_comment|/*&n;&t; * We will wait MIN_RESET_DELAY clock ticks after the last reset so&n;&t; * we can avoid the drive not being ready.&n;&t; */
id|timeout
op_assign
id|host-&gt;last_reset
op_plus
id|MIN_RESET_DELAY
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;resetting
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
r_int
id|ticks_remaining
op_assign
id|timeout
op_minus
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t;&t; * NOTE: This may be executed from within an interrupt&n;&t;&t; * handler!  This is bad, but for now, it&squot;ll do.  The irq&n;&t;&t; * level of the interrupt handler has been masked out by the&n;&t;&t; * platform dependent interrupt handling code already, so the&n;&t;&t; * sti() here will not cause another call to the SCSI host&squot;s&n;&t;&t; * interrupt handler (assuming there is one irq-level per&n;&t;&t; * host).&n;&t;&t; */
r_while
c_loop
(paren
op_decrement
id|ticks_remaining
op_ge
l_int|0
)paren
id|mdelay
c_func
(paren
l_int|1
op_plus
l_int|999
op_div
id|HZ
)paren
suffix:semicolon
id|host-&gt;resetting
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|host-&gt;hostt-&gt;use_new_eh_code
)paren
(brace
id|scsi_add_timer
c_func
(paren
id|SCpnt
comma
id|SCpnt-&gt;timeout_per_command
comma
id|scsi_times_out
)paren
suffix:semicolon
)brace
r_else
(brace
id|scsi_add_timer
c_func
(paren
id|SCpnt
comma
id|SCpnt-&gt;timeout_per_command
comma
id|scsi_old_times_out
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We will use a queued command if possible, otherwise we will emulate the&n;&t; * queuing and calling of completion function ourselves.&n;&t; */
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_dispatch_cmnd (host = %d, channel = %d, target = %d, &quot;
l_string|&quot;command = %p, buffer = %p, &bslash;nbufflen = %d, done = %p)&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;bufflen
comma
id|SCpnt-&gt;done
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_QUEUED
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;can_queue
)paren
(brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;queuecommand : routine at %p&bslash;n&quot;
comma
id|host-&gt;hostt-&gt;queuecommand
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Use the old error handling code if we haven&squot;t converted the driver&n;&t;&t; * to use the new one yet.  Note - only the new queuecommand variant&n;&t;&t; * passes a meaningful return value.&n;&t;&t; */
r_if
c_cond
(paren
id|host-&gt;hostt-&gt;use_new_eh_code
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|rtn
op_assign
id|host-&gt;hostt
op_member_access_from_pointer
id|queuecommand
c_func
(paren
id|SCpnt
comma
id|scsi_done
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_ne
l_int|0
)paren
(brace
id|scsi_delete_timer
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|scsi_mlqueue_insert
c_func
(paren
id|SCpnt
comma
id|SCSI_MLQUEUE_HOST_BUSY
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|host-&gt;hostt
op_member_access_from_pointer
id|queuecommand
c_func
(paren
id|SCpnt
comma
id|scsi_old_done
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|temp
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;command() :  routine at %p&bslash;n&quot;
comma
id|host-&gt;hostt-&gt;command
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|temp
op_assign
id|host-&gt;hostt
op_member_access_from_pointer
id|command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|temp
suffix:semicolon
macro_line|#ifdef DEBUG_DELAY
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|clock
op_assign
id|jiffies
op_plus
l_int|4
op_star
id|HZ
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|clock
)paren
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;done(host = %d, result = %04x) : routine at %p&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|temp
comma
id|host-&gt;hostt-&gt;command
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|host-&gt;hostt-&gt;use_new_eh_code
)paren
(brace
id|scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
r_else
(brace
id|scsi_old_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;leaving scsi_dispatch_cmnd()&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
multiline_comment|/*&n; * scsi_do_cmd sends all the commands out to the low-level driver.  It&n; * handles the specifics required for each low level driver - ie queued&n; * or non queued.  It also prevents conflicts when different high level&n; * drivers go for the same host at the same time.&n; */
multiline_comment|/*&n; * Function:    scsi_do_cmd&n; *&n; * Purpose:     Queue a SCSI command&n; *&n; * Arguments:   SCpnt     - command descriptor.&n; *              cmnd      - actual SCSI command to be performed.&n; *              buffer    - data buffer.&n; *              bufflen   - size of data buffer.&n; *              done      - completion function to be run.&n; *              timeout   - how long to let it run before timeout.&n; *              retries   - number of retries we allow.&n; *&n; * Lock status: With the new queueing code, this is SMP-safe, and no locks&n; *              need be held upon entry.   The old queueing code the lock was&n; *              assumed to be held upon entry.&n; *&n; * Returns:     Pointer to command descriptor.&n; *&n; * Notes:       Prior to the new queue code, this function was not SMP-safe.&n; *              Also, this function is now only used for queueing requests&n; *              for things like ioctls and character device requests - this&n; *              is because we essentially just inject a request into the&n; *              queue for the device. Normal block device handling manipulates&n; *              the queue directly.&n; */
DECL|function|scsi_do_cmd
r_void
id|scsi_do_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
comma
r_int
id|timeout
comma
r_int
id|retries
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|Scsi_Device
op_star
id|device
op_assign
id|SCpnt-&gt;device
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
op_amp
id|io_request_lock
comma
l_int|0
)paren
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_MIDLEVEL
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|4
comma
(brace
r_int
id|i
suffix:semicolon
r_int
id|target
op_assign
id|SCpnt-&gt;target
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi_do_cmd (host = %d, channel = %d target = %d, &quot;
l_string|&quot;buffer =%p, bufflen = %d, done = %p, timeout = %d, &quot;
l_string|&quot;retries = %d)&bslash;n&quot;
l_string|&quot;command : &quot;
comma
id|host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|target
comma
id|buffer
comma
id|bufflen
comma
id|done
comma
id|timeout
comma
id|retries
)paren
suffix:semicolon
r_for
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;%02x  &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Invalid or not present host.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We must prevent reentrancy to the lowlevel host driver.  This prevents&n;&t; * it - we enter a loop until the host we want to talk to is not busy.&n;&t; * Race conditions are prevented, as interrupts are disabled in between the&n;&t; * time we check for the host being not busy, and the time we mark it busy&n;&t; * ourselves.&n;&t; */
id|host-&gt;host_busy
op_increment
suffix:semicolon
id|device-&gt;device_busy
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Our own function scsi_done (which marks the host as not busy, disables&n;&t; * the timeout counter, etc) will be called by us or by the&n;&t; * scsi_hosts[host].queuecommand() function needs to also call&n;&t; * the completion function for the high level driver.&n;&t; */
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|cmnd
comma
l_int|12
)paren
suffix:semicolon
id|SCpnt-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;bufflen
op_assign
id|bufflen
suffix:semicolon
id|SCpnt-&gt;buffer
op_assign
id|buffer
suffix:semicolon
id|SCpnt-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;retries
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;allowed
op_assign
id|retries
suffix:semicolon
id|SCpnt-&gt;done
op_assign
id|done
suffix:semicolon
id|SCpnt-&gt;timeout_per_command
op_assign
id|timeout
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|cmnd
comma
l_int|12
)paren
suffix:semicolon
multiline_comment|/* Zero the sense buffer.  Some host adapters automatically request&n;&t; * sense on error.  0 is not a valid sense code.&n;&t; */
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|bufflen
suffix:semicolon
id|SCpnt-&gt;old_use_sg
op_assign
id|SCpnt-&gt;use_sg
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;cmd_len
op_eq
l_int|0
)paren
id|SCpnt-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|SCpnt-&gt;old_cmd_len
op_assign
id|SCpnt-&gt;cmd_len
suffix:semicolon
multiline_comment|/* Start the timer ticking.  */
id|SCpnt-&gt;internal_timeout
op_assign
id|NORMAL_TIMEOUT
suffix:semicolon
id|SCpnt-&gt;abort_reason
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * At this point, we merely set up the command, stick it in the normal&n;&t; * request queue, and return.  Eventually that request will come to the&n;&t; * top of the list, and will be dispatched.&n;&t; */
id|scsi_insert_special_cmd
c_func
(paren
id|SCpnt
comma
l_int|0
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Leaving scsi_do_cmd()&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is the mid-level interrupt routine, which decides how&n; *  to handle error conditions.  Each invocation of this function must&n; *  do one and *only* one of the following:&n; *&n; *      1) Insert command in BH queue.&n; *      2) Activate error handler for host.&n; *&n; * FIXME(eric) - I am concerned about stack overflow (still).  An&n; * interrupt could come while we are processing the bottom queue,&n; * which would cause another command to be stuffed onto the bottom&n; * queue, and it would in turn be processed as that interrupt handler&n; * is returning.  Given a sufficiently steady rate of returning&n; * commands, this could cause the stack to overflow.  I am not sure&n; * what is the most appropriate solution here - we should probably&n; * keep a depth count, and not process any commands while we still&n; * have a bottom handler active higher in the stack.&n; *&n; * There is currently code in the bottom half handler to monitor&n; * recursion in the bottom handler and report if it ever happens.  If&n; * this becomes a problem, it won&squot;t be hard to engineer something to&n; * deal with it so that only the outer layer ever does any real&n; * processing.  &n; */
DECL|function|scsi_done
r_void
id|scsi_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|tstatus
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t have to worry about this one timing out any more.&n;&t; */
id|tstatus
op_assign
id|scsi_delete_timer
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we are unable to remove the timer, it means that the command&n;&t; * has already timed out.  In this case, we have no choice but to&n;&t; * let the timeout function run, as we have no idea where in fact&n;&t; * that function could really be.  It might be on another processor,&n;&t; * etc, etc.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tstatus
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Set the serial numbers back to zero */
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * First, see whether this command already timed out.  If so, we ignore&n;&t; * the response.  We treat it as if the command never finished.&n;&t; *&n;&t; * Since serial_number is now 0, the error handler cound detect this&n;&t; * situation and avoid to call the the low level driver abort routine.&n;&t; * (DB)&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Ignoring completion of %p due to timeout status&quot;
comma
id|SCpnt
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|scsi_bhqueue_lock
comma
id|flags
)paren
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_BHQUEUE
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_BH_HANDLER
suffix:semicolon
id|SCpnt-&gt;bh_next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Next, put this command in the BH queue.&n;&t; * &n;&t; * We need a spinlock here, or compare and exchange if we can reorder incoming&n;&t; * Scsi_Cmnds, as it happens pretty often scsi_done is called multiple times&n;&t; * before bh is serviced. -jj&n;&t; *&n;&t; * We already have the io_request_lock here, since we are called from the&n;&t; * interrupt handler or the error handler. (DB)&n;&t; *&n;&t; * This may be true at the moment, but I would like to wean all of the low&n;&t; * level drivers away from using io_request_lock.   Technically they should&n;&t; * all use their own locking.  I am adding a small spinlock to protect&n;&t; * this datastructure to make it safe for that day.  (ERY)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|scsi_bh_queue_head
)paren
(brace
id|scsi_bh_queue_head
op_assign
id|SCpnt
suffix:semicolon
id|scsi_bh_queue_tail
op_assign
id|SCpnt
suffix:semicolon
)brace
r_else
(brace
id|scsi_bh_queue_tail-&gt;bh_next
op_assign
id|SCpnt
suffix:semicolon
id|scsi_bh_queue_tail
op_assign
id|SCpnt
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|scsi_bhqueue_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the bottom half handler to be run.&n;&t; */
id|mark_bh
c_func
(paren
id|SCSI_BH
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Procedure:   scsi_bottom_half_handler&n; *&n; * Purpose:     Called after we have finished processing interrupts, it&n; *              performs post-interrupt handling for commands that may&n; *              have completed.&n; *&n; * Notes:       This is called with all interrupts enabled.  This should reduce&n; *              interrupt latency, stack depth, and reentrancy of the low-level&n; *              drivers.&n; *&n; * The io_request_lock is required in all the routine. There was a subtle&n; * race condition when scsi_done is called after a command has already&n; * timed out but before the time out is processed by the error handler.&n; * (DB)&n; *&n; * I believe I have corrected this.  We simply monitor the return status of&n; * del_timer() - if this comes back as 0, it means that the timer has fired&n; * and that a timeout is in progress.   I have modified scsi_done() such&n; * that in this instance the command is never inserted in the bottom&n; * half queue.  Thus the only time we hold the lock here is when&n; * we wish to atomically remove the contents of the queue.&n; */
DECL|function|scsi_bottom_half_handler
r_void
id|scsi_bottom_half_handler
c_func
(paren
r_void
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCnext
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_while
c_loop
(paren
l_int|1
op_eq
l_int|1
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|scsi_bhqueue_lock
comma
id|flags
)paren
suffix:semicolon
id|SCpnt
op_assign
id|scsi_bh_queue_head
suffix:semicolon
id|scsi_bh_queue_head
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|scsi_bhqueue_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
id|SCnext
op_assign
id|SCpnt-&gt;bh_next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCnext
)paren
(brace
id|SCnext
op_assign
id|SCpnt-&gt;bh_next
suffix:semicolon
r_switch
c_cond
(paren
id|scsi_decide_disposition
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_case
id|SUCCESS
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Add to BH queue.&n;&t;&t;&t;&t; */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command finished %d %d 0x%x&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_busy
comma
id|SCpnt-&gt;host-&gt;host_failed
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|scsi_finish_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NEEDS_RETRY
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * We only come in here if we want to retry a command.  The&n;&t;&t;&t;&t; * test to see whether the command should be retried should be&n;&t;&t;&t;&t; * keeping track of the number of tries, so we don&squot;t end up looping,&n;&t;&t;&t;&t; * of course.&n;&t;&t;&t;&t; */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command needs retry %d %d 0x%x&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_busy
comma
id|SCpnt-&gt;host-&gt;host_failed
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|scsi_retry_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ADD_TO_MLQUEUE
suffix:colon
multiline_comment|/* &n;&t;&t;&t;&t; * This typically happens for a QUEUE_FULL message -&n;&t;&t;&t;&t; * typically only when the queue depth is only&n;&t;&t;&t;&t; * approximate for a given device.  Adding a command&n;&t;&t;&t;&t; * to the queue for the device will prevent further commands&n;&t;&t;&t;&t; * from being sent to the device, so we shouldn&squot;t end up&n;&t;&t;&t;&t; * with tons of things being sent down that shouldn&squot;t be.&n;&t;&t;&t;&t; */
id|scsi_mlqueue_insert
c_func
(paren
id|SCpnt
comma
id|SCSI_MLQUEUE_DEVICE_BUSY
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Here we have a fatal error of some sort.  Turn it over to&n;&t;&t;&t;&t; * the error handler.&n;&t;&t;&t;&t; */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command failed %p %x active=%d busy=%d failed=%d&bslash;n&quot;
comma
id|SCpnt
comma
id|SCpnt-&gt;result
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
comma
id|SCpnt-&gt;host-&gt;host_busy
comma
id|SCpnt-&gt;host-&gt;host_failed
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Dump the sense information too.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|status_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
op_amp
id|CHECK_CONDITION
)paren
op_ne
l_int|0
)paren
(brace
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|print_sense
c_func
(paren
l_string|&quot;bh&quot;
comma
id|SCpnt
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;eh_wait
op_ne
l_int|NULL
)paren
(brace
id|SCpnt-&gt;host-&gt;host_failed
op_increment
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_ERROR_HANDLER
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_FAILED
suffix:semicolon
id|SCpnt-&gt;host-&gt;in_recovery
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If the host is having troubles, then look to see if this was the last&n;&t;&t;&t;&t;&t; * command that might have failed.  If so, wake up the error handler.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;host_busy
op_eq
id|SCpnt-&gt;host-&gt;host_failed
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Waking error handler thread (%d)&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;eh_wait-&gt;count
)paren
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
id|SCpnt-&gt;host-&gt;eh_wait
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * We only get here if the error recovery thread has died.&n;&t;&t;&t;&t;&t; */
id|scsi_finish_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* for(; SCpnt...) */
)brace
multiline_comment|/* while(1==1) */
)brace
multiline_comment|/*&n; * Function:    scsi_retry_command&n; *&n; * Purpose:     Send a command back to the low level to be retried.&n; *&n; * Notes:       This command is always executed in the context of the&n; *              bottom half handler, or the error handler thread. Low&n; *              level drivers should not become re-entrant as a result of&n; *              this.&n; */
DECL|function|scsi_retry_command
r_int
id|scsi_retry_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|SCpnt-&gt;buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|SCpnt-&gt;bufflen
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|SCpnt-&gt;old_cmd_len
suffix:semicolon
r_return
id|scsi_dispatch_cmd
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_finish_command&n; *&n; * Purpose:     Pass command off to upper layer for finishing of I/O&n; *              request, waking processes that are waiting on results,&n; *              etc.&n; */
DECL|function|scsi_finish_command
r_void
id|scsi_finish_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|Scsi_Device
op_star
id|device
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
op_amp
id|io_request_lock
comma
l_int|0
)paren
suffix:semicolon
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|device
op_assign
id|SCpnt-&gt;device
suffix:semicolon
id|host-&gt;host_busy
op_decrement
suffix:semicolon
multiline_comment|/* Indicate that we are free */
id|device-&gt;device_busy
op_decrement
suffix:semicolon
multiline_comment|/* Decrement device usage counter. */
multiline_comment|/*&n;&t; * If we have valid sense information, then some kind of recovery&n;&t; * must have taken place.  Make a note of this.&n;&t; */
r_if
c_cond
(paren
id|scsi_sense_valid
c_func
(paren
id|SCpnt
)paren
)paren
(brace
id|SCpnt-&gt;result
op_or_assign
(paren
id|DRIVER_SENSE
op_lshift
l_int|24
)paren
suffix:semicolon
)brace
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Notifying upper driver of completion for device %d %x&bslash;n&quot;
comma
id|SCpnt-&gt;device-&gt;id
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_HIGHLEVEL
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_FINISHED
suffix:semicolon
multiline_comment|/* We can get here with use_sg=0, causing a panic in the upper level (DB) */
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt
op_member_access_from_pointer
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MODULES
r_static
r_int
id|scsi_register_host
c_func
(paren
id|Scsi_Host_Template
op_star
)paren
suffix:semicolon
r_static
r_void
id|scsi_unregister_host
c_func
(paren
id|Scsi_Host_Template
op_star
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Function:    scsi_malloc&n; *&n; * Purpose:     Allocate memory from the DMA-safe pool.&n; *&n; * Arguments:   len       - amount of memory we need.&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; *&n; * Returns:     Pointer to memory block.&n; *&n; * Notes:       Prior to the new queue code, this function was not SMP-safe.&n; *              This function can only allocate in units of sectors&n; *              (i.e. 512 bytes).&n; *&n; *              We cannot use the normal system allocator becuase we need&n; *              to be able to guarantee that we can process a complete disk&n; *              I/O request without touching the system allocator.  Think&n; *              about it - if the system were heavily swapping, and tried to&n; *              write out a block of memory to disk, and the SCSI code needed&n; *              to allocate more memory in order to be able to write the&n; *              data to disk, you would wedge the system.&n; */
DECL|function|scsi_malloc
r_void
op_star
id|scsi_malloc
c_func
(paren
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|nbits
comma
id|mask
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|len
op_mod
id|SECTOR_SIZE
op_ne
l_int|0
op_logical_or
id|len
OG
id|PAGE_SIZE
)paren
r_return
l_int|NULL
suffix:semicolon
id|nbits
op_assign
id|len
op_rshift
l_int|9
suffix:semicolon
id|mask
op_assign
(paren
l_int|1
op_lshift
id|nbits
)paren
op_minus
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|i
op_increment
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
op_le
id|SECTORS_PER_PAGE
op_minus
id|nbits
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|dma_malloc_freelist
(braket
id|i
)braket
op_amp
(paren
id|mask
op_lshift
id|j
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|dma_malloc_freelist
(braket
id|i
)braket
op_or_assign
(paren
id|mask
op_lshift
id|j
)paren
suffix:semicolon
id|scsi_dma_free_sectors
op_sub_assign
id|nbits
suffix:semicolon
macro_line|#ifdef DEBUG
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;SMalloc: %d %p [From:%p]&bslash;n&quot;
comma
id|len
comma
id|dma_malloc_pages
(braket
id|i
)braket
op_plus
(paren
id|j
op_lshift
l_int|9
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SMalloc: %d %p [From:%p]&bslash;n&quot;
comma
id|len
comma
id|dma_malloc_pages
(braket
id|i
)braket
op_plus
(paren
id|j
op_lshift
l_int|9
)paren
)paren
suffix:semicolon
macro_line|#endif
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|dma_malloc_pages
(braket
id|i
)braket
op_plus
(paren
id|j
op_lshift
l_int|9
)paren
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Nope.  No more */
)brace
multiline_comment|/*&n; * Function:    scsi_free&n; *&n; * Purpose:     Free memory into the DMA-safe pool.&n; *&n; * Arguments:   ptr       - data block we are freeing.&n; *              len       - size of block we are freeing.&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       This function *must* only be used to free memory&n; *              allocated from scsi_malloc().&n; *&n; *              Prior to the new queue code, this function was not SMP-safe.&n; *              This function can only allocate in units of sectors&n; *              (i.e. 512 bytes).&n; */
DECL|function|scsi_free
r_int
id|scsi_free
c_func
(paren
r_void
op_star
id|obj
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|page
comma
id|sector
comma
id|nbits
comma
id|mask
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG
r_int
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __mips__
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;move&bslash;t%0,$31&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
)paren
suffix:semicolon
macro_line|#else
id|ret
op_assign
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;scsi_free %p %d&bslash;n&quot;
comma
id|obj
comma
id|len
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;SFree: %p %d&bslash;n&quot;
comma
id|obj
comma
id|len
)paren
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
l_int|0
suffix:semicolon
id|page
OL
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|page
op_increment
)paren
(brace
r_int
r_int
id|page_addr
op_assign
(paren
r_int
r_int
)paren
id|dma_malloc_pages
(braket
id|page
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|obj
op_ge
id|page_addr
op_logical_and
(paren
r_int
r_int
)paren
id|obj
OL
id|page_addr
op_plus
id|PAGE_SIZE
)paren
(brace
id|sector
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|obj
)paren
op_minus
id|page_addr
)paren
op_rshift
l_int|9
suffix:semicolon
id|nbits
op_assign
id|len
op_rshift
l_int|9
suffix:semicolon
id|mask
op_assign
(paren
l_int|1
op_lshift
id|nbits
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mask
op_lshift
id|sector
)paren
op_ge
(paren
l_int|1
op_lshift
id|SECTORS_PER_PAGE
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;scsi_free:Bad memory alignment&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dma_malloc_freelist
(braket
id|page
)braket
op_amp
(paren
id|mask
op_lshift
id|sector
)paren
)paren
op_ne
(paren
id|mask
op_lshift
id|sector
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;scsi_free(obj=%p, len=%d) called from %08lx&bslash;n&quot;
comma
id|obj
comma
id|len
comma
id|ret
)paren
suffix:semicolon
macro_line|#endif
id|panic
c_func
(paren
l_string|&quot;scsi_free:Trying to free unused memory&quot;
)paren
suffix:semicolon
)brace
id|scsi_dma_free_sectors
op_add_assign
id|nbits
suffix:semicolon
id|dma_malloc_freelist
(braket
id|page
)braket
op_and_assign
op_complement
(paren
id|mask
op_lshift
id|sector
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|panic
c_func
(paren
l_string|&quot;scsi_free:Bad offset&quot;
)paren
suffix:semicolon
)brace
DECL|variable|scsi_loadable_module_flag
r_int
id|scsi_loadable_module_flag
suffix:semicolon
multiline_comment|/* Set after we scan builtin drivers */
DECL|function|scsi_init_malloc
r_void
op_star
id|scsi_init_malloc
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|gfp_mask
)paren
(brace
r_void
op_star
id|retval
suffix:semicolon
multiline_comment|/*&n;&t; * For buffers used by the DMA pool, we assume page aligned &n;&t; * structures.&n;&t; */
r_if
c_cond
(paren
(paren
id|size
op_mod
id|PAGE_SIZE
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|order
comma
id|a_size
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
comma
id|a_size
op_assign
id|PAGE_SIZE
suffix:semicolon
id|a_size
OL
id|size
suffix:semicolon
id|order
op_increment
comma
id|a_size
op_lshift_assign
l_int|1
)paren
suffix:semicolon
id|retval
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|gfp_mask
op_or
id|GFP_DMA
comma
id|order
)paren
suffix:semicolon
)brace
r_else
id|retval
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
id|memset
c_func
(paren
id|retval
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|scsi_init_free
r_void
id|scsi_init_free
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
r_int
id|size
)paren
(brace
multiline_comment|/*&n;&t; * We need this special code here because the DMA pool assumes&n;&t; * page aligned data.  Besides, it is wasteful to allocate&n;&t; * page sized chunks with kmalloc.&n;&t; */
r_if
c_cond
(paren
(paren
id|size
op_mod
id|PAGE_SIZE
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|order
comma
id|a_size
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
comma
id|a_size
op_assign
id|PAGE_SIZE
suffix:semicolon
id|a_size
OL
id|size
suffix:semicolon
id|order
op_increment
comma
id|a_size
op_lshift_assign
l_int|1
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|ptr
comma
id|order
)paren
suffix:semicolon
)brace
r_else
id|kfree
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
DECL|function|scsi_build_commandblocks
r_void
id|scsi_build_commandblocks
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SDpnt-&gt;host
suffix:semicolon
r_int
id|j
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;queue_depth
op_eq
l_int|0
)paren
id|SDpnt-&gt;queue_depth
op_assign
id|host-&gt;cmd_per_lun
suffix:semicolon
id|SDpnt-&gt;device_queue
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|SDpnt-&gt;queue_depth
suffix:semicolon
id|j
op_increment
)paren
(brace
id|SCpnt
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|scsi_init_malloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Cmnd
)paren
comma
id|GFP_ATOMIC
op_or
(paren
id|host-&gt;unchecked_isa_dma
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|SCpnt
)paren
r_break
suffix:semicolon
multiline_comment|/* If not, the next line will oops ... */
id|memset
c_func
(paren
op_amp
id|SCpnt-&gt;eh_timeout
comma
l_int|0
comma
r_sizeof
(paren
id|SCpnt-&gt;eh_timeout
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;host
op_assign
id|host
suffix:semicolon
id|SCpnt-&gt;device
op_assign
id|SDpnt
suffix:semicolon
id|SCpnt-&gt;target
op_assign
id|SDpnt-&gt;id
suffix:semicolon
id|SCpnt-&gt;lun
op_assign
id|SDpnt-&gt;lun
suffix:semicolon
id|SCpnt-&gt;channel
op_assign
id|SDpnt-&gt;channel
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
id|SCpnt-&gt;host_wait
op_assign
id|FALSE
suffix:semicolon
id|SCpnt-&gt;device_wait
op_assign
id|FALSE
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;old_use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;old_cmd_len
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;resid
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;next
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SDpnt-&gt;device_queue
op_assign
id|SCpnt
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_UNUSED
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_NOBODY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
OL
id|SDpnt-&gt;queue_depth
)paren
(brace
multiline_comment|/* low on space (D.Gilbert 990424) */
id|printk
c_func
(paren
l_string|&quot;scsi_build_commandblocks: want=%d, space for=%d blocks&bslash;n&quot;
comma
id|SDpnt-&gt;queue_depth
comma
id|j
)paren
suffix:semicolon
id|SDpnt-&gt;queue_depth
op_assign
id|j
suffix:semicolon
id|SDpnt-&gt;has_cmdblocks
op_assign
(paren
l_int|0
op_ne
id|j
)paren
suffix:semicolon
)brace
r_else
(brace
id|SDpnt-&gt;has_cmdblocks
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
id|ssize_t
id|proc_scsi_gen_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|length
comma
r_void
op_star
id|data
)paren
suffix:semicolon
macro_line|#ifndef MODULE&t;&t;&t;/* { */
multiline_comment|/*&n; * scsi_dev_init() is our initialization routine, which in turn calls host&n; * initialization, bus scanning, and sd/st initialization routines.&n; * This is only used at boot time.&n; */
DECL|function|scsi_dev_init
r_int
id|__init
id|scsi_dev_init
c_func
(paren
r_void
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
r_struct
id|proc_dir_entry
op_star
id|generic
suffix:semicolon
macro_line|#ifdef FOO_ON_YOU
r_return
suffix:semicolon
macro_line|#endif
multiline_comment|/* Yes we&squot;re here... */
multiline_comment|/*&n;&t; * This makes /proc/scsi and /proc/scsi/scsi visible.&n;&t; */
macro_line|#ifdef CONFIG_PROC_FS
id|proc_scsi
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;scsi&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|proc_scsi
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;cannot init /proc/scsi&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|generic
op_assign
id|create_proc_info_entry
(paren
l_string|&quot;scsi/scsi&quot;
comma
l_int|0
comma
l_int|0
comma
id|scsi_proc_info
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|generic
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;cannot init /proc/scsi/scsi&bslash;n&quot;
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;scsi&quot;
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|generic-&gt;write_proc
op_assign
id|proc_scsi_gen_write
suffix:semicolon
macro_line|#endif
multiline_comment|/* Init a few things so we can &quot;malloc&quot; memory. */
id|scsi_loadable_module_flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* initialize all hosts */
id|scsi_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This is where the processing takes place for most everything&n;&t; * when commands are completed.  Until we do this, we will not be able&n;&t; * to queue any commands.&n;&t; */
id|init_bh
c_func
(paren
id|SCSI_BH
comma
id|scsi_bottom_half_handler
)paren
suffix:semicolon
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
id|scan_scsis
c_func
(paren
id|shpnt
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* scan for scsi devices */
r_if
c_cond
(paren
id|shpnt-&gt;select_queue_depths
op_ne
l_int|NULL
)paren
(paren
id|shpnt-&gt;select_queue_depths
)paren
(paren
id|shpnt
comma
id|shpnt-&gt;host_queue
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi : detected &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;dev_noticed
op_logical_and
id|sdtpnt-&gt;name
)paren
id|printk
c_func
(paren
l_string|&quot;%d SCSI %s%s &quot;
comma
id|sdtpnt-&gt;dev_noticed
comma
id|sdtpnt-&gt;name
comma
(paren
id|sdtpnt-&gt;dev_noticed
op_ne
l_int|1
)paren
ques
c_cond
l_string|&quot;s&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;total.&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;init
op_logical_and
id|sdtpnt-&gt;dev_noticed
)paren
(paren
op_star
id|sdtpnt-&gt;init
)paren
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
multiline_comment|/* SDpnt-&gt;scsi_request_fn = NULL; */
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;attach
)paren
(paren
op_star
id|sdtpnt-&gt;attach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;attached
)paren
(brace
id|scsi_build_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|SDpnt-&gt;has_cmdblocks
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi_dev_init: DANGER, no command blocks&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* What to do now ?? */
)brace
)brace
)brace
)brace
multiline_comment|/*&n;&t; * This should build the DMA pool.&n;&t; */
id|resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * OK, now we finish the initialization by doing spin-up, read&n;&t; * capacity, etc, etc&n;&t; */
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;finish
op_logical_and
id|sdtpnt-&gt;nr_dev
)paren
(paren
op_star
id|sdtpnt-&gt;finish
)paren
(paren
)paren
suffix:semicolon
id|scsi_loadable_module_flag
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* MODULE */&t;&t;/* } */
DECL|function|print_inquiry
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|data
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Vendor: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Model: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Rev: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
OL
l_int|36
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Type:   %s &quot;
comma
id|i
OL
id|MAX_SCSI_DEVICE_CODE
ques
c_cond
id|scsi_device_types
(braket
id|i
)braket
suffix:colon
l_string|&quot;Unknown          &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                 ANSI SCSI revision: %02x&quot;
comma
id|data
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|data
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot; CCS&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|scsi_proc_info
r_static
r_int
id|scsi_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
id|Scsi_Device
op_star
id|scd
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|HBA_ptr
suffix:semicolon
r_int
id|size
comma
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * First, see if there are any attached devices or not.&n;&t; */
r_for
c_loop
(paren
id|HBA_ptr
op_assign
id|scsi_hostlist
suffix:semicolon
id|HBA_ptr
suffix:semicolon
id|HBA_ptr
op_assign
id|HBA_ptr-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|HBA_ptr-&gt;host_queue
op_ne
l_int|NULL
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Attached devices: %s&bslash;n&quot;
comma
(paren
id|HBA_ptr
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;none&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_for
c_loop
(paren
id|HBA_ptr
op_assign
id|scsi_hostlist
suffix:semicolon
id|HBA_ptr
suffix:semicolon
id|HBA_ptr
op_assign
id|HBA_ptr-&gt;next
)paren
(brace
macro_line|#if 0
id|size
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;scsi%2d: %s&bslash;n&quot;
comma
(paren
r_int
)paren
id|HBA_ptr-&gt;host_no
comma
id|HBA_ptr-&gt;hostt-&gt;procname
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|scd
op_assign
id|HBA_ptr-&gt;host_queue
suffix:semicolon
id|scd
suffix:semicolon
id|scd
op_assign
id|scd-&gt;next
)paren
(brace
id|proc_print_scsidevice
c_func
(paren
id|scd
comma
id|buffer
comma
op_amp
id|size
comma
id|len
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
r_goto
id|stop_output
suffix:semicolon
)brace
)brace
id|stop_output
suffix:colon
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start slop */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
multiline_comment|/* Ending slop */
r_return
(paren
id|len
)paren
suffix:semicolon
)brace
DECL|function|proc_scsi_gen_write
r_static
id|ssize_t
id|proc_scsi_gen_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|length
comma
r_void
op_star
id|data
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|SDTpnt
suffix:semicolon
id|Scsi_Device
op_star
id|scd
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|HBA_ptr
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_int
id|host
comma
id|channel
comma
id|id
comma
id|lun
suffix:semicolon
r_char
op_star
id|buffer
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
op_logical_or
id|length
OG
id|PAGE_SIZE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|buffer
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|copy_from_user
c_func
(paren
id|buffer
comma
id|buf
comma
id|length
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|length
OL
l_int|11
op_logical_or
id|strncmp
c_func
(paren
l_string|&quot;scsi&quot;
comma
id|buffer
comma
l_int|4
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Usage: echo &quot;scsi dump #N&quot; &gt; /proc/scsi/scsi&n;&t; * to dump status of all scsi commands.  The number is used to specify the level&n;&t; * of detail in the dump.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
l_string|&quot;dump&quot;
comma
id|buffer
op_plus
l_int|5
comma
l_int|4
)paren
)paren
(brace
r_int
r_int
id|level
suffix:semicolon
id|p
op_assign
id|buffer
op_plus
l_int|10
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_goto
id|out
suffix:semicolon
id|level
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|scsi_dump_status
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Usage: echo &quot;scsi log token #N&quot; &gt; /proc/scsi/scsi&n;&t; * where token is one of [error,scan,mlqueue,mlcomplete,llqueue,&n;&t; * llcomplete,hlqueue,hlcomplete]&n;&t; */
macro_line|#ifdef CONFIG_SCSI_LOGGING&t;&t;/* { */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
l_string|&quot;log&quot;
comma
id|buffer
op_plus
l_int|5
comma
l_int|3
)paren
)paren
(brace
r_char
op_star
id|token
suffix:semicolon
r_int
r_int
id|level
suffix:semicolon
id|p
op_assign
id|buffer
op_plus
l_int|9
suffix:semicolon
id|token
op_assign
id|p
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_ne
l_char|&squot; &squot;
op_logical_and
op_star
id|p
op_ne
l_char|&squot;&bslash;t&squot;
op_logical_and
op_star
id|p
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|p
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|token
comma
l_string|&quot;all&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Turn on absolutely everything.&n;&t;&t;&t;&t; */
id|scsi_logging_level
op_assign
op_complement
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|token
comma
l_string|&quot;none&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Turn off absolutely everything.&n;&t;&t;&t;&t; */
id|scsi_logging_level
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|level
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Now figure out what to do with it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;error&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_ERROR_RECOVERY_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;timeout&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_TIMEOUT_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;scan&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_SCAN_BUS_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;mlqueue&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_MLQUEUE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;mlcomplete&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_MLCOMPLETE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;llqueue&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_LLQUEUE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;llcomplete&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_LLCOMPLETE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;hlqueue&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_HLQUEUE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;hlcomplete&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_HLCOMPLETE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;ioctl&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_IOCTL_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
(brace
r_goto
id|out
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;scsi logging level set to 0x%8.8x&bslash;n&quot;
comma
id|scsi_logging_level
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_SCSI_LOGGING */ /* } */
multiline_comment|/*&n;&t; * Usage: echo &quot;scsi add-single-device 0 1 2 3&quot; &gt;/proc/scsi/scsi&n;&t; * with  &quot;0 1 2 3&quot; replaced by your &quot;Host Channel Id Lun&quot;.&n;&t; * Consider this feature BETA.&n;&t; *     CAUTION: This is not for hotplugging your peripherals. As&n;&t; *     SCSI was not designed for this you could damage your&n;&t; *     hardware !&n;&t; * However perhaps it is legal to switch on an&n;&t; * already connected device. It is perhaps not&n;&t; * guaranteed this device doesn&squot;t corrupt an ongoing data transfer.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
l_string|&quot;add-single-device&quot;
comma
id|buffer
op_plus
l_int|5
comma
l_int|17
)paren
)paren
(brace
id|p
op_assign
id|buffer
op_plus
l_int|23
suffix:semicolon
id|host
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|channel
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|id
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|lun
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi singledevice %d %d %d %d&bslash;n&quot;
comma
id|host
comma
id|channel
comma
id|id
comma
id|lun
)paren
suffix:semicolon
r_for
c_loop
(paren
id|HBA_ptr
op_assign
id|scsi_hostlist
suffix:semicolon
id|HBA_ptr
suffix:semicolon
id|HBA_ptr
op_assign
id|HBA_ptr-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|HBA_ptr-&gt;host_no
op_eq
id|host
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HBA_ptr
)paren
r_goto
id|out
suffix:semicolon
r_for
c_loop
(paren
id|scd
op_assign
id|HBA_ptr-&gt;host_queue
suffix:semicolon
id|scd
suffix:semicolon
id|scd
op_assign
id|scd-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|scd-&gt;channel
op_eq
id|channel
op_logical_and
id|scd-&gt;id
op_eq
id|id
op_logical_and
id|scd-&gt;lun
op_eq
id|lun
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|err
op_assign
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
id|scd
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* We do not yet support unplugging */
id|scan_scsis
c_func
(paren
id|HBA_ptr
comma
l_int|1
comma
id|channel
comma
id|id
comma
id|lun
)paren
suffix:semicolon
multiline_comment|/* FIXME (DB) This assumes that the queue_depth routines can be used&n;&t;&t;   in this context as well, while they were all designed to be&n;&t;&t;   called only once after the detect routine. (DB) */
r_if
c_cond
(paren
id|HBA_ptr-&gt;select_queue_depths
op_ne
l_int|NULL
)paren
(paren
id|HBA_ptr-&gt;select_queue_depths
)paren
(paren
id|HBA_ptr
comma
id|HBA_ptr-&gt;host_queue
)paren
suffix:semicolon
id|err
op_assign
id|length
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Usage: echo &quot;scsi remove-single-device 0 1 2 3&quot; &gt;/proc/scsi/scsi&n;&t; * with  &quot;0 1 2 3&quot; replaced by your &quot;Host Channel Id Lun&quot;.&n;&t; *&n;&t; * Consider this feature pre-BETA.&n;&t; *&n;&t; *     CAUTION: This is not for hotplugging your peripherals. As&n;&t; *     SCSI was not designed for this you could damage your&n;&t; *     hardware and thoroughly confuse the SCSI subsystem.&n;&t; *&n;&t; */
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
l_string|&quot;remove-single-device&quot;
comma
id|buffer
op_plus
l_int|5
comma
l_int|20
)paren
)paren
(brace
id|p
op_assign
id|buffer
op_plus
l_int|26
suffix:semicolon
id|host
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|channel
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|id
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|lun
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|HBA_ptr
op_assign
id|scsi_hostlist
suffix:semicolon
id|HBA_ptr
suffix:semicolon
id|HBA_ptr
op_assign
id|HBA_ptr-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|HBA_ptr-&gt;host_no
op_eq
id|host
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HBA_ptr
)paren
r_goto
id|out
suffix:semicolon
r_for
c_loop
(paren
id|scd
op_assign
id|HBA_ptr-&gt;host_queue
suffix:semicolon
id|scd
suffix:semicolon
id|scd
op_assign
id|scd-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|scd-&gt;channel
op_eq
id|channel
op_logical_and
id|scd-&gt;id
op_eq
id|id
op_logical_and
id|scd-&gt;lun
op_eq
id|lun
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|scd
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* there is no such device attached */
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|scd-&gt;access_count
)paren
r_goto
id|out
suffix:semicolon
id|SDTpnt
op_assign
id|scsi_devicelist
suffix:semicolon
r_while
c_loop
(paren
id|SDTpnt
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|SDTpnt-&gt;detach
)paren
(paren
op_star
id|SDTpnt-&gt;detach
)paren
(paren
id|scd
)paren
suffix:semicolon
id|SDTpnt
op_assign
id|SDTpnt-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scd-&gt;attached
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Nobody is using this device any more.&n;&t;&t;&t; * Free all of the command structures.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|SCpnt
op_assign
id|scd-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
id|scd-&gt;device_queue
op_assign
id|SCpnt-&gt;next
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|SCpnt
comma
r_sizeof
(paren
op_star
id|SCpnt
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Now we can remove the device structure */
r_if
c_cond
(paren
id|scd-&gt;next
op_ne
l_int|NULL
)paren
id|scd-&gt;next-&gt;prev
op_assign
id|scd-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
id|scd-&gt;prev
op_ne
l_int|NULL
)paren
id|scd-&gt;prev-&gt;next
op_assign
id|scd-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|HBA_ptr-&gt;host_queue
op_eq
id|scd
)paren
(brace
id|HBA_ptr-&gt;host_queue
op_assign
id|scd-&gt;next
suffix:semicolon
)brace
id|blk_cleanup_queue
c_func
(paren
op_amp
id|scd-&gt;request_queue
)paren
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|scd
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|out
suffix:colon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|buffer
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Function:    resize_dma_pool&n; *&n; * Purpose:     Ensure that the DMA pool is sufficiently large to be&n; *              able to guarantee that we can always process I/O requests&n; *              without calling the system allocator.&n; *&n; * Arguments:   None.&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       Prior to the new queue code, this function was not SMP-safe.&n; *              Go through the device list and recompute the most appropriate&n; *              size for the dma pool.  Then grab more memory (as required).&n; */
DECL|function|resize_dma_pool
r_static
r_void
id|resize_dma_pool
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|k
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|FreeSectorBitmap
op_star
id|new_dma_malloc_freelist
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|new_dma_sectors
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|new_need_isa_buffer
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
op_star
id|new_dma_malloc_pages
op_assign
l_int|NULL
suffix:semicolon
r_int
id|out_of_space
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_hostlist
)paren
(brace
multiline_comment|/*&n;&t;&t; * Free up the DMA pool.&n;&t;&t; */
r_if
c_cond
(paren
id|scsi_dma_free_sectors
op_ne
id|dma_sectors
)paren
id|panic
c_func
(paren
l_string|&quot;SCSI DMA pool memory leak %d %d&bslash;n&quot;
comma
id|scsi_dma_free_sectors
comma
id|dma_sectors
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|i
op_increment
)paren
id|scsi_init_free
c_func
(paren
id|dma_malloc_pages
(braket
id|i
)braket
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_pages
)paren
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_pages
comma
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|dma_malloc_pages
)paren
)paren
suffix:semicolon
id|dma_malloc_pages
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_freelist
)paren
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_freelist
comma
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|dma_malloc_freelist
)paren
)paren
suffix:semicolon
id|dma_malloc_freelist
op_assign
l_int|NULL
suffix:semicolon
id|dma_sectors
op_assign
l_int|0
suffix:semicolon
id|scsi_dma_free_sectors
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Next, check to see if we need to extend the DMA buffer pool */
id|new_dma_sectors
op_assign
l_int|2
op_star
id|SECTORS_PER_PAGE
suffix:semicolon
multiline_comment|/* Base value we use */
r_if
c_cond
(paren
id|__pa
c_func
(paren
id|high_memory
)paren
op_minus
l_int|1
OG
id|ISA_DMA_THRESHOLD
)paren
id|need_isa_bounce_buffers
op_assign
l_int|1
suffix:semicolon
r_else
id|need_isa_bounce_buffers
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|scsi_devicelist
)paren
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
id|new_dma_sectors
op_add_assign
id|SECTORS_PER_PAGE
suffix:semicolon
multiline_comment|/* Increment for each host */
r_for
c_loop
(paren
id|host
op_assign
id|scsi_hostlist
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * sd and sr drivers allocate scatterlists.&n;&t;&t;&t; * sr drivers may allocate for each command 1x2048 or 2x1024 extra&n;&t;&t;&t; * buffers for 2k sector size and 1k fs.&n;&t;&t;&t; * sg driver allocates buffers &lt; 4k.&n;&t;&t;&t; * st driver does not need buffers from the dma pool.&n;&t;&t;&t; * estimate 4k buffer/command for devices of unknown type (should panic).&n;&t;&t;&t; */
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_eq
id|TYPE_WORM
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_ROM
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_DISK
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_MOD
)paren
(brace
id|new_dma_sectors
op_add_assign
(paren
(paren
id|host-&gt;sg_tablesize
op_star
r_sizeof
(paren
r_struct
id|scatterlist
)paren
op_plus
l_int|511
)paren
op_rshift
l_int|9
)paren
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_eq
id|TYPE_WORM
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_ROM
)paren
id|new_dma_sectors
op_add_assign
(paren
l_int|2048
op_rshift
l_int|9
)paren
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_eq
id|TYPE_SCANNER
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_PROCESSOR
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_MEDIUM_CHANGER
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_ENCLOSURE
)paren
(brace
id|new_dma_sectors
op_add_assign
(paren
l_int|4096
op_rshift
l_int|9
)paren
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_ne
id|TYPE_TAPE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: unknown device type %d&bslash;n&quot;
comma
id|SDpnt-&gt;type
)paren
suffix:semicolon
id|new_dma_sectors
op_add_assign
(paren
l_int|4096
op_rshift
l_int|9
)paren
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|host-&gt;unchecked_isa_dma
op_logical_and
id|need_isa_bounce_buffers
op_logical_and
id|SDpnt-&gt;type
op_ne
id|TYPE_TAPE
)paren
(brace
id|new_dma_sectors
op_add_assign
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
op_star
id|host-&gt;sg_tablesize
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
id|new_need_isa_buffer
op_increment
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef DEBUG_INIT
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: needed dma sectors = %d&bslash;n&quot;
comma
id|new_dma_sectors
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* limit DMA memory to 32MB: */
id|new_dma_sectors
op_assign
(paren
id|new_dma_sectors
op_plus
l_int|15
)paren
op_amp
l_int|0xfff0
suffix:semicolon
multiline_comment|/*&n;&t; * We never shrink the buffers - this leads to&n;&t; * race conditions that I would rather not even think&n;&t; * about right now.&n;&t; */
macro_line|#if 0&t;&t;&t;&t;/* Why do this? No gain and risks out_of_space */
r_if
c_cond
(paren
id|new_dma_sectors
OL
id|dma_sectors
)paren
id|new_dma_sectors
op_assign
id|dma_sectors
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|new_dma_sectors
op_le
id|dma_sectors
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* best to quit while we are in front */
)brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|20
suffix:semicolon
op_increment
id|k
)paren
(brace
multiline_comment|/* just in case */
id|out_of_space
op_assign
l_int|0
suffix:semicolon
id|size
op_assign
(paren
id|new_dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
id|FreeSectorBitmap
)paren
suffix:semicolon
id|new_dma_malloc_freelist
op_assign
(paren
id|FreeSectorBitmap
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_dma_malloc_freelist
)paren
(brace
id|size
op_assign
(paren
id|new_dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|new_dma_malloc_pages
)paren
suffix:semicolon
id|new_dma_malloc_pages
op_assign
(paren
r_int
r_char
op_star
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_dma_malloc_pages
)paren
(brace
id|size
op_assign
(paren
id|new_dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
id|FreeSectorBitmap
)paren
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|new_dma_malloc_freelist
comma
id|size
)paren
suffix:semicolon
id|out_of_space
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
id|out_of_space
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|out_of_space
)paren
op_logical_and
(paren
id|new_dma_sectors
OG
id|dma_sectors
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|i
OL
id|new_dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|new_dma_malloc_pages
(braket
id|i
)braket
op_assign
(paren
r_int
r_char
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|PAGE_SIZE
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_dma_malloc_pages
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
id|new_dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
(brace
multiline_comment|/* clean up */
r_int
id|k
op_assign
id|i
suffix:semicolon
id|out_of_space
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|k
suffix:semicolon
op_increment
id|i
)paren
id|scsi_init_free
c_func
(paren
id|new_dma_malloc_pages
(braket
id|i
)braket
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|out_of_space
)paren
(brace
multiline_comment|/* try scaling down new_dma_sectors request */
id|printk
c_func
(paren
l_string|&quot;scsi::resize_dma_pool: WARNING, dma_sectors=%u, &quot;
l_string|&quot;wanted=%u, scaling&bslash;n&quot;
comma
id|dma_sectors
comma
id|new_dma_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_dma_sectors
OL
(paren
l_int|8
op_star
id|SECTORS_PER_PAGE
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* pretty well hopeless ... */
id|new_dma_sectors
op_assign
(paren
id|new_dma_sectors
op_star
l_int|3
)paren
op_div
l_int|4
suffix:semicolon
id|new_dma_sectors
op_assign
(paren
id|new_dma_sectors
op_plus
l_int|15
)paren
op_amp
l_int|0xfff0
suffix:semicolon
r_if
c_cond
(paren
id|new_dma_sectors
op_le
id|dma_sectors
)paren
r_break
suffix:semicolon
multiline_comment|/* stick with what we have got */
)brace
r_else
r_break
suffix:semicolon
multiline_comment|/* found space ... */
)brace
multiline_comment|/* end of for loop */
r_if
c_cond
(paren
id|out_of_space
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
id|scsi_need_isa_buffer
op_assign
id|new_need_isa_buffer
suffix:semicolon
multiline_comment|/* some useful info */
id|printk
c_func
(paren
l_string|&quot;      WARNING, not enough memory, pool not expanded&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* When we dick with the actual DMA list, we need to&n;&t; * protect things&n;&t; */
r_if
c_cond
(paren
id|dma_malloc_freelist
)paren
(brace
id|size
op_assign
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
id|FreeSectorBitmap
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_dma_malloc_freelist
comma
id|dma_malloc_freelist
comma
id|size
)paren
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_freelist
comma
id|size
)paren
suffix:semicolon
)brace
id|dma_malloc_freelist
op_assign
id|new_dma_malloc_freelist
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_pages
)paren
(brace
id|size
op_assign
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|dma_malloc_pages
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_dma_malloc_pages
comma
id|dma_malloc_pages
comma
id|size
)paren
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_pages
comma
id|size
)paren
suffix:semicolon
)brace
id|scsi_dma_free_sectors
op_add_assign
id|new_dma_sectors
op_minus
id|dma_sectors
suffix:semicolon
id|dma_malloc_pages
op_assign
id|new_dma_malloc_pages
suffix:semicolon
id|dma_sectors
op_assign
id|new_dma_sectors
suffix:semicolon
id|scsi_need_isa_buffer
op_assign
id|new_need_isa_buffer
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|allocator_request_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_INIT
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: dma free sectors   = %d&bslash;n&quot;
comma
id|scsi_dma_free_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: dma sectors        = %d&bslash;n&quot;
comma
id|dma_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: need isa buffers   = %d&bslash;n&quot;
comma
id|scsi_need_isa_buffer
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_MODULES&t;&t;/* a big #ifdef block... */
multiline_comment|/*&n; * This entry point should be called by a loadable module if it is trying&n; * add a low level scsi driver to the system.&n; */
DECL|function|scsi_register_host
r_static
r_int
id|scsi_register_host
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|pcount
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|out_of_space
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tpnt-&gt;next
op_logical_or
op_logical_neg
id|tpnt-&gt;detect
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Must be already loaded, or&n;&t;&t;&t;&t; * no detect routine available&n;&t;&t;&t;&t; */
id|pcount
op_assign
id|next_scsi_host
suffix:semicolon
multiline_comment|/* The detect routine must carefully spinunlock/spinlock if &n;&t;   it enables interrupts, since all interrupt handlers do &n;&t;   spinlock as well.&n;&t;   All lame drivers are going to fail due to the following &n;&t;   spinlock. For the time beeing let&squot;s use it only for drivers &n;&t;   using the new scsi code. NOTE: the detect routine could&n;&t;   redefine the value tpnt-&gt;use_new_eh_code. (DB, 13 May 1998) */
r_if
c_cond
(paren
id|tpnt-&gt;use_new_eh_code
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|tpnt-&gt;present
op_assign
id|tpnt
op_member_access_from_pointer
id|detect
c_func
(paren
id|tpnt
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
id|tpnt-&gt;present
op_assign
id|tpnt
op_member_access_from_pointer
id|detect
c_func
(paren
id|tpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tpnt-&gt;present
)paren
(brace
r_if
c_cond
(paren
id|pcount
op_eq
id|next_scsi_host
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;present
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Failure to register low-level scsi driver&quot;
)paren
suffix:semicolon
id|scsi_unregister_host
c_func
(paren
id|tpnt
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * The low-level driver failed to register a driver.  We&n;&t;&t;&t; *  can do this now.&n;&t;&t;&t; */
id|scsi_register
c_func
(paren
id|tpnt
comma
l_int|0
)paren
suffix:semicolon
)brace
id|tpnt-&gt;next
op_assign
id|scsi_hosts
suffix:semicolon
multiline_comment|/* Add to the linked list */
id|scsi_hosts
op_assign
id|tpnt
suffix:semicolon
multiline_comment|/* Add the new driver to /proc/scsi */
macro_line|#ifdef CONFIG_PROC_FS
id|build_proc_dir_entries
c_func
(paren
id|tpnt
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Add the kernel threads for each host adapter that will&n;&t;&t; * handle error correction.&n;&t;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_eq
id|tpnt
op_logical_and
id|shpnt-&gt;hostt-&gt;use_new_eh_code
)paren
(brace
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|sem
)paren
suffix:semicolon
id|shpnt-&gt;eh_notify
op_assign
op_amp
id|sem
suffix:semicolon
id|kernel_thread
c_func
(paren
(paren
r_int
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|scsi_error_handler
comma
(paren
r_void
op_star
)paren
id|shpnt
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Now wait for the kernel error thread to initialize itself&n;&t;&t;&t;&t; * as it might be needed when we scan the bus.&n;&t;&t;&t;&t; */
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|shpnt-&gt;eh_notify
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_eq
id|tpnt
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;info
)paren
(brace
id|name
op_assign
id|tpnt
op_member_access_from_pointer
id|info
c_func
(paren
id|shpnt
)paren
suffix:semicolon
)brace
r_else
(brace
id|name
op_assign
id|tpnt-&gt;name
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : %s&bslash;n&quot;
comma
multiline_comment|/* And print a little message */
id|shpnt-&gt;host_no
comma
id|name
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;scsi : %d host%s.&bslash;n&quot;
comma
id|next_scsi_host
comma
(paren
id|next_scsi_host
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
suffix:semicolon
multiline_comment|/* The next step is to call scan_scsis here.  This generates the&n;&t;&t; * Scsi_Devices entries&n;&t;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_eq
id|tpnt
)paren
(brace
id|scan_scsis
c_func
(paren
id|shpnt
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;select_queue_depths
op_ne
l_int|NULL
)paren
(brace
(paren
id|shpnt-&gt;select_queue_depths
)paren
(paren
id|shpnt
comma
id|shpnt-&gt;host_queue
)paren
suffix:semicolon
)brace
)brace
)brace
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|sdtpnt-&gt;init
op_logical_and
id|sdtpnt-&gt;dev_noticed
)paren
(paren
op_star
id|sdtpnt-&gt;init
)paren
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Next we create the Scsi_Cmnd structures for this host &n;&t;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
r_if
c_cond
(paren
id|SDpnt-&gt;host-&gt;hostt
op_eq
id|tpnt
)paren
(brace
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;attach
)paren
(paren
op_star
id|sdtpnt-&gt;attach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;attached
)paren
(brace
id|scsi_build_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|SDpnt-&gt;has_cmdblocks
)paren
id|out_of_space
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; * Now that we have all of the devices, resize the DMA pool,&n;&t;&t; * as required.  */
r_if
c_cond
(paren
op_logical_neg
id|out_of_space
)paren
id|resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* This does any final handling that is required. */
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|sdtpnt-&gt;finish
op_logical_and
id|sdtpnt-&gt;nr_dev
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;finish
)paren
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#if defined(USE_STATIC_SCSI_MEMORY)
id|printk
c_func
(paren
l_string|&quot;SCSI memory: total %ldKb, used %ldKb, free %ldKb.&bslash;n&quot;
comma
(paren
id|scsi_memory_upper_value
op_minus
id|scsi_memory_lower_value
)paren
op_div
l_int|1024
comma
(paren
id|scsi_init_memory_start
op_minus
id|scsi_memory_lower_value
)paren
op_div
l_int|1024
comma
(paren
id|scsi_memory_upper_value
op_minus
id|scsi_init_memory_start
)paren
op_div
l_int|1024
)paren
suffix:semicolon
macro_line|#endif
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|out_of_space
)paren
(brace
id|scsi_unregister_host
c_func
(paren
id|tpnt
)paren
suffix:semicolon
multiline_comment|/* easiest way to clean up?? */
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Similarly, this entry point should be called by a loadable module if it&n; * is trying to remove a low level scsi driver from the system.&n; *&n; * Note - there is a fatal flaw in the deregister module function.&n; * There is no way to return a code that says &squot;I cannot be unloaded now&squot;.&n; * The system relies entirely upon usage counts that are maintained,&n; * and the assumption is that if the usage count is 0, then the module&n; * can be unloaded.&n; */
DECL|function|scsi_unregister_host
r_static
r_void
id|scsi_unregister_host
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|online_status
suffix:semicolon
r_int
id|pcount
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt1
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|sh1
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
id|Scsi_Host_Template
op_star
id|SHT
suffix:semicolon
id|Scsi_Host_Template
op_star
id|SHTp
suffix:semicolon
r_char
id|name
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/* host_no&gt;=10^9? I don&squot;t think so. */
multiline_comment|/*&n;&t; * First verify that this host adapter is completely free with no pending&n;&t; * commands &n;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SDpnt-&gt;host-&gt;hostt
op_eq
id|tpnt
op_logical_and
id|SDpnt-&gt;host-&gt;hostt-&gt;module
op_logical_and
id|GET_USE_COUNT
c_func
(paren
id|SDpnt-&gt;host-&gt;hostt-&gt;module
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * FIXME(eric) - We need to find a way to notify the&n;&t;&t;&t; * low level driver that we are shutting down - via the&n;&t;&t;&t; * special device entry that still needs to get added. &n;&t;&t;&t; *&n;&t;&t;&t; * Is detach interface below good enough for this?&n;&t;&t;&t; */
)brace
)brace
multiline_comment|/*&n;&t; * FIXME(eric) put a spinlock on this.  We force all of the devices offline&n;&t; * to help prevent race conditions where other hosts/processors could try and&n;&t; * get in and queue a command.&n;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SDpnt-&gt;host-&gt;hostt
op_eq
id|tpnt
)paren
id|SDpnt-&gt;online
op_assign
id|FALSE
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_ne
id|tpnt
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Loop over all of the commands associated with the device.  If any of&n;&t;&t;&t; * them are busy, then set the state back to inactive and bail.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
id|online_status
op_assign
id|SDpnt-&gt;online
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI device not inactive - rq_status=%d, target=%d, pid=%ld, state=%d, owner=%d.&bslash;n&quot;
comma
id|SCpnt-&gt;request.rq_status
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;pid
comma
id|SCpnt-&gt;state
comma
id|SCpnt-&gt;owner
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt1
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt1
suffix:semicolon
id|SDpnt1
op_assign
id|SDpnt1-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt1-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_eq
id|RQ_SCSI_DISCONNECTING
)paren
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
)brace
id|SDpnt-&gt;online
op_assign
id|online_status
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Device busy???&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * No, this device is really free.  Mark it as such, and&n;&t;&t;&t;&t; * continue on.&n;&t;&t;&t;&t; */
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_DISCONNECTING
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_DISCONNECTING
suffix:semicolon
multiline_comment|/* Mark as busy */
)brace
)brace
)brace
multiline_comment|/* Next we detach the high level drivers from the Scsi_Device structures */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_ne
id|tpnt
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;detach
)paren
(paren
op_star
id|sdtpnt-&gt;detach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/* If something still attached, punt */
r_if
c_cond
(paren
id|SDpnt-&gt;attached
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attached usage count = %d&bslash;n&quot;
comma
id|SDpnt-&gt;attached
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Next, kill the kernel error recovery thread for this host.&n;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_eq
id|tpnt
op_logical_and
id|shpnt-&gt;hostt-&gt;use_new_eh_code
op_logical_and
id|shpnt-&gt;ehandler
op_ne
l_int|NULL
)paren
(brace
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|sem
)paren
suffix:semicolon
id|shpnt-&gt;eh_notify
op_assign
op_amp
id|sem
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|shpnt-&gt;ehandler
comma
l_int|1
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|shpnt-&gt;eh_notify
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* Next we free up the Scsi_Cmnd structures for this host */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_ne
id|tpnt
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
)paren
(brace
r_while
c_loop
(paren
id|SDpnt-&gt;device_queue
)paren
(brace
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue-&gt;next
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|SDpnt-&gt;device_queue
comma
r_sizeof
(paren
id|Scsi_Cmnd
)paren
)paren
suffix:semicolon
id|SDpnt-&gt;device_queue
op_assign
id|SCpnt
suffix:semicolon
)brace
id|SDpnt-&gt;has_cmdblocks
op_assign
l_int|0
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
op_amp
id|SDpnt-&gt;request_queue
)paren
suffix:semicolon
multiline_comment|/* Next free up the Scsi_Device structures for this host */
id|shpnt-&gt;host_queue
op_assign
id|SDpnt-&gt;next
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|SDpnt
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Next we go through and remove the instances of the individual hosts&n;&t; * that were detected */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|sh1
)paren
(brace
id|sh1
op_assign
id|shpnt-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_ne
id|tpnt
op_logical_or
op_logical_neg
id|shpnt-&gt;loaded_as_module
)paren
r_continue
suffix:semicolon
id|pcount
op_assign
id|next_scsi_host
suffix:semicolon
multiline_comment|/* Remove the /proc/scsi directory entry */
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;%d&quot;
comma
id|shpnt-&gt;host_no
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|name
comma
id|tpnt-&gt;proc_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tpnt-&gt;release
)paren
(paren
op_star
id|tpnt-&gt;release
)paren
(paren
id|shpnt
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* This is the default case for the release function.&n;&t;&t;&t; * It should do the right thing for most correctly&n;&t;&t;&t; * written host adapters.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|shpnt-&gt;irq
)paren
id|free_irq
c_func
(paren
id|shpnt-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;dma_channel
op_ne
l_int|0xff
)paren
id|free_dma
c_func
(paren
id|shpnt-&gt;dma_channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;io_port
op_logical_and
id|shpnt-&gt;n_io_port
)paren
id|release_region
c_func
(paren
id|shpnt-&gt;io_port
comma
id|shpnt-&gt;n_io_port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pcount
op_eq
id|next_scsi_host
)paren
id|scsi_unregister
c_func
(paren
id|shpnt
)paren
suffix:semicolon
id|tpnt-&gt;present
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there are absolutely no more hosts left, it is safe&n;&t; * to completely nuke the DMA pool.  The resize operation will&n;&t; * do the right thing and free everything.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|scsi_hosts
)paren
id|resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi : %d host%s.&bslash;n&quot;
comma
id|next_scsi_host
comma
(paren
id|next_scsi_host
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
suffix:semicolon
macro_line|#if defined(USE_STATIC_SCSI_MEMORY)
id|printk
c_func
(paren
l_string|&quot;SCSI memory: total %ldKb, used %ldKb, free %ldKb.&bslash;n&quot;
comma
(paren
id|scsi_memory_upper_value
op_minus
id|scsi_memory_lower_value
)paren
op_div
l_int|1024
comma
(paren
id|scsi_init_memory_start
op_minus
id|scsi_memory_lower_value
)paren
op_div
l_int|1024
comma
(paren
id|scsi_memory_upper_value
op_minus
id|scsi_init_memory_start
)paren
op_div
l_int|1024
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* There were some hosts that were loaded at boot time, so we cannot&n;&t;   do any more than this */
r_if
c_cond
(paren
id|tpnt-&gt;present
)paren
r_return
suffix:semicolon
multiline_comment|/* OK, this is the very last step.  Remove this host adapter from the&n;&t;   linked list. */
r_for
c_loop
(paren
id|SHTp
op_assign
l_int|NULL
comma
id|SHT
op_assign
id|scsi_hosts
suffix:semicolon
id|SHT
suffix:semicolon
id|SHTp
op_assign
id|SHT
comma
id|SHT
op_assign
id|SHT-&gt;next
)paren
r_if
c_cond
(paren
id|SHT
op_eq
id|tpnt
)paren
(brace
r_if
c_cond
(paren
id|SHTp
)paren
id|SHTp-&gt;next
op_assign
id|SHT-&gt;next
suffix:semicolon
r_else
id|scsi_hosts
op_assign
id|SHT-&gt;next
suffix:semicolon
id|SHT-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Rebuild the /proc/scsi directory entries */
id|remove_proc_entry
c_func
(paren
id|tpnt-&gt;proc_name
comma
id|proc_scsi
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/*&n; * This entry point should be called by a loadable module if it is trying&n; * add a high level scsi driver to the system.&n; */
DECL|function|scsi_register_device_module
r_static
r_int
id|scsi_register_device_module
c_func
(paren
r_struct
id|Scsi_Device_Template
op_star
id|tpnt
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_int
id|out_of_space
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tpnt-&gt;next
)paren
r_return
l_int|1
suffix:semicolon
id|scsi_register_device
c_func
(paren
id|tpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First scan the devices that we know about, and see if we notice them.&n;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;detect
)paren
id|SDpnt-&gt;attached
op_add_assign
(paren
op_star
id|tpnt-&gt;detect
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If any of the devices would match this driver, then perform the&n;&t; * init function.&n;&t; */
r_if
c_cond
(paren
id|tpnt-&gt;init
op_logical_and
id|tpnt-&gt;dev_noticed
)paren
r_if
c_cond
(paren
(paren
op_star
id|tpnt-&gt;init
)paren
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Now actually connect the devices to the new driver.&n;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;attach
)paren
(paren
op_star
id|tpnt-&gt;attach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If this driver attached to the device, and don&squot;t have any&n;&t;&t;&t; * command blocks for this device, allocate some.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|SDpnt-&gt;attached
op_logical_and
id|SDpnt-&gt;has_cmdblocks
op_eq
l_int|0
)paren
(brace
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
id|scsi_build_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|SDpnt-&gt;has_cmdblocks
)paren
id|out_of_space
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * This does any final handling that is required.&n;&t; */
r_if
c_cond
(paren
id|tpnt-&gt;finish
op_logical_and
id|tpnt-&gt;nr_dev
)paren
(paren
op_star
id|tpnt-&gt;finish
)paren
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|out_of_space
)paren
id|resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|out_of_space
)paren
(brace
id|scsi_unregister_device
c_func
(paren
id|tpnt
)paren
suffix:semicolon
multiline_comment|/* easiest way to clean up?? */
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scsi_unregister_device
r_static
r_int
id|scsi_unregister_device
c_func
(paren
r_struct
id|Scsi_Device_Template
op_star
id|tpnt
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|spnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|prev_spnt
suffix:semicolon
multiline_comment|/*&n;&t; * If we are busy, this is not going to fly.&n;&t; */
r_if
c_cond
(paren
id|GET_USE_COUNT
c_func
(paren
id|tpnt-&gt;module
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Next, detach the devices from the driver.&n;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;detach
)paren
(paren
op_star
id|tpnt-&gt;detach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;attached
op_eq
l_int|0
)paren
(brace
id|SDpnt-&gt;online
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Nobody is using this device any more.  Free all of the&n;&t;&t;&t;&t; * command structures.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt
op_eq
id|SDpnt-&gt;device_queue
)paren
id|SDpnt-&gt;device_queue
op_assign
id|SCpnt-&gt;next
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|SCpnt
comma
r_sizeof
(paren
op_star
id|SCpnt
)paren
)paren
suffix:semicolon
)brace
id|SDpnt-&gt;has_cmdblocks
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Extract the template from the linked list.&n;&t; */
id|spnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|prev_spnt
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|spnt
op_ne
id|tpnt
)paren
(brace
id|prev_spnt
op_assign
id|spnt
suffix:semicolon
id|spnt
op_assign
id|spnt-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev_spnt
op_eq
l_int|NULL
)paren
id|scsi_devicelist
op_assign
id|tpnt-&gt;next
suffix:semicolon
r_else
id|prev_spnt-&gt;next
op_assign
id|spnt-&gt;next
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
multiline_comment|/*&n;&t; * Final cleanup for the driver is done in the driver sources in the&n;&t; * cleanup function.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scsi_register_module
r_int
id|scsi_register_module
c_func
(paren
r_int
id|module_type
comma
r_void
op_star
id|ptr
)paren
(brace
r_switch
c_cond
(paren
id|module_type
)paren
(brace
r_case
id|MODULE_SCSI_HA
suffix:colon
r_return
id|scsi_register_host
c_func
(paren
(paren
id|Scsi_Host_Template
op_star
)paren
id|ptr
)paren
suffix:semicolon
multiline_comment|/* Load upper level device handler of some kind */
r_case
id|MODULE_SCSI_DEV
suffix:colon
macro_line|#ifdef CONFIG_KMOD
r_if
c_cond
(paren
id|scsi_hosts
op_eq
l_int|NULL
)paren
id|request_module
c_func
(paren
l_string|&quot;scsi_hostadapter&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|scsi_register_device_module
c_func
(paren
(paren
r_struct
id|Scsi_Device_Template
op_star
)paren
id|ptr
)paren
suffix:semicolon
multiline_comment|/* The rest of these are not yet implemented */
multiline_comment|/* Load constants.o */
r_case
id|MODULE_SCSI_CONST
suffix:colon
multiline_comment|/* Load specialized ioctl handler for some device.  Intended for&n;&t;&t; * cdroms that have non-SCSI2 audio command sets. */
r_case
id|MODULE_SCSI_IOCTL
suffix:colon
r_default
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|scsi_unregister_module
r_void
id|scsi_unregister_module
c_func
(paren
r_int
id|module_type
comma
r_void
op_star
id|ptr
)paren
(brace
r_switch
c_cond
(paren
id|module_type
)paren
(brace
r_case
id|MODULE_SCSI_HA
suffix:colon
id|scsi_unregister_host
c_func
(paren
(paren
id|Scsi_Host_Template
op_star
)paren
id|ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODULE_SCSI_DEV
suffix:colon
id|scsi_unregister_device
c_func
(paren
(paren
r_struct
id|Scsi_Device_Template
op_star
)paren
id|ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* The rest of these are not yet implemented. */
r_case
id|MODULE_SCSI_CONST
suffix:colon
r_case
id|MODULE_SCSI_IOCTL
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
r_return
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* CONFIG_MODULES */
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/*&n; * Function:    scsi_dump_status&n; *&n; * Purpose:     Brain dump of scsi system, used for problem solving.&n; *&n; * Arguments:   level - used to indicate level of detail.&n; *&n; * Notes:       The level isn&squot;t used at all yet, but we need to find some way&n; *              of sensibly logging varying degrees of information.  A quick one-line&n; *              display of each command, plus the status would be most useful.&n; *&n; *              This does depend upon CONFIG_SCSI_LOGGING - I do want some way of turning&n; *              it all off if the user wants a lean and mean kernel.  It would probably&n; *              also be useful to allow the user to specify one single host to be dumped.&n; *              A second argument to the function would be useful for that purpose.&n; *&n; *              FIXME - some formatting of the output into tables would be very handy.&n; */
DECL|function|scsi_dump_status
r_static
r_void
id|scsi_dump_status
c_func
(paren
r_int
id|level
)paren
(brace
macro_line|#ifdef CONFIG_SCSI_LOGGING&t;&t;/* { */
r_int
id|i
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Dump of scsi host parameters:&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %d %d %d : %d&bslash;n&quot;
comma
id|shpnt-&gt;host_failed
comma
id|shpnt-&gt;host_busy
comma
id|atomic_read
c_func
(paren
op_amp
id|shpnt-&gt;host_active
)paren
comma
id|shpnt-&gt;host_blocked
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Dump of scsi command parameters:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;h:c:t:l (dev sect nsect cnumsec sg) (ret all flg) (to/cmd to ito) cmd snse result&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
multiline_comment|/*  (0) h:c:t:l (dev sect nsect cnumsec sg) (ret all flg) (to/cmd to ito) cmd snse result %d %x      */
id|printk
c_func
(paren
l_string|&quot;(%3d) %2d:%1d:%2d:%2d (%6s %4ld %4ld %4ld %4x %1d) (%1d %1d 0x%2x) (%4d %4d %4d) 0x%2.2x 0x%2.2x 0x%8.8x&bslash;n&quot;
comma
id|i
op_increment
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|kdevname
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
comma
id|SCpnt-&gt;request.sector
comma
id|SCpnt-&gt;request.nr_sectors
comma
id|SCpnt-&gt;request.current_nr_sectors
comma
id|SCpnt-&gt;request.rq_status
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;retries
comma
id|SCpnt-&gt;allowed
comma
id|SCpnt-&gt;flags
comma
id|SCpnt-&gt;timeout_per_command
comma
id|SCpnt-&gt;timeout
comma
id|SCpnt-&gt;internal_timeout
comma
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
comma
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
comma
id|SCpnt-&gt;result
)paren
suffix:semicolon
)brace
)brace
)brace
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
multiline_comment|/* Now dump the request lists for each block device */
id|printk
c_func
(paren
l_string|&quot;Dump of pending block device requests&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_BLKDEV
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|blk_dev
(braket
id|i
)braket
dot
id|request_queue.current_request
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d: &quot;
comma
id|i
)paren
suffix:semicolon
id|req
op_assign
id|blk_dev
(braket
id|i
)braket
dot
id|request_queue.current_request
suffix:semicolon
r_while
c_loop
(paren
id|req
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(%s %d %ld %ld %ld) &quot;
comma
id|kdevname
c_func
(paren
id|req-&gt;rq_dev
)paren
comma
id|req-&gt;cmd
comma
id|req-&gt;sector
comma
id|req-&gt;nr_sectors
comma
id|req-&gt;current_nr_sectors
)paren
suffix:semicolon
id|req
op_assign
id|req-&gt;next
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;wait_for_request = %p&bslash;n&quot;
comma
op_amp
id|wait_for_request
)paren
suffix:semicolon
macro_line|#endif&t;/* CONFIG_SCSI_LOGGING */ /* } */
)brace
macro_line|#endif&t;&t;&t;&t;/* CONFIG_PROC_FS */
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
r_int
id|has_space
op_assign
l_int|0
suffix:semicolon
r_struct
id|proc_dir_entry
op_star
id|generic
suffix:semicolon
multiline_comment|/*&n;&t; * This makes /proc/scsi and /proc/scsi/scsi visible.&n;&t; */
macro_line|#ifdef CONFIG_PROC_FS
id|proc_scsi
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;scsi&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|proc_scsi
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;cannot init /proc/scsi&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|generic
op_assign
id|create_proc_info_entry
(paren
l_string|&quot;scsi/scsi&quot;
comma
l_int|0
comma
l_int|0
comma
id|scsi_proc_info
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|generic
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;cannot init /proc/scsi/scsi&bslash;n&quot;
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;scsi&quot;
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|generic-&gt;write_proc
op_assign
id|proc_scsi_gen_write
suffix:semicolon
macro_line|#endif
id|scsi_loadable_module_flag
op_assign
l_int|1
suffix:semicolon
id|dma_sectors
op_assign
id|PAGE_SIZE
op_div
id|SECTOR_SIZE
suffix:semicolon
id|scsi_dma_free_sectors
op_assign
id|dma_sectors
suffix:semicolon
multiline_comment|/*&n;&t; * Set up a minimal DMA buffer list - this will be used during scan_scsis&n;&t; * in some cases.&n;&t; */
multiline_comment|/* One bit per sector to indicate free/busy */
id|size
op_assign
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
id|FreeSectorBitmap
)paren
suffix:semicolon
id|dma_malloc_freelist
op_assign
(paren
id|FreeSectorBitmap
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_freelist
)paren
(brace
multiline_comment|/* One pointer per page for the page list */
id|dma_malloc_pages
op_assign
(paren
r_int
r_char
op_star
op_star
)paren
id|scsi_init_malloc
c_func
(paren
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|dma_malloc_pages
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_pages
)paren
(brace
id|dma_malloc_pages
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_char
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|PAGE_SIZE
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_pages
(braket
l_int|0
)braket
)paren
id|has_space
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|has_space
)paren
(brace
r_if
c_cond
(paren
id|dma_malloc_freelist
)paren
(brace
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_freelist
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_pages
)paren
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_pages
comma
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|dma_malloc_pages
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi::init_module: failed, out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This is where the processing takes place for most everything&n;&t; * when commands are completed.&n;&t; */
id|init_bh
c_func
(paren
id|SCSI_BH
comma
id|scsi_bottom_half_handler
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|remove_bh
c_func
(paren
id|SCSI_BH
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/* No, we&squot;re not here anymore. Don&squot;t show the /proc/scsi files. */
id|remove_proc_entry
(paren
l_string|&quot;scsi/scsi&quot;
comma
l_int|0
)paren
suffix:semicolon
id|remove_proc_entry
(paren
l_string|&quot;scsi&quot;
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Free up the DMA pool.&n;&t; */
id|resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* MODULE */
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: nil&n; * tab-width: 8&n; * End:&n; */
eof
