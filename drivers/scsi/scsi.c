multiline_comment|/*&n; *  scsi.c Copyright (C) 1992 Drew Eckhardt&n; *         Copyright (C) 1993, 1994, 1995 Eric Youngdale&n; *&n; *  generic mid-level SCSI driver&n; *      Initial versions: Drew Eckhardt&n; *      Subsequent revisions: Eric Youngdale&n; *&n; *  &lt;drew@colorado.edu&gt;&n; *&n; *  Bug correction thanks go to :&n; *      Rik Faith &lt;faith@cs.unc.edu&gt;&n; *      Tommy Thorn &lt;tthorn&gt;&n; *      Thomas Wuensche &lt;tw@fgb1.fgb.mw.tu-muenchen.de&gt;&n; *&n; *  Modified by Eric Youngdale eric@andante.jic.com or ericy@gnu.ai.mit.edu to&n; *  add scatter-gather, multiple outstanding request, and other&n; *  enhancements.&n; *&n; *  Native multichannel, wide scsi, /proc/scsi and hot plugging&n; *  support added by Michael Neuffer &lt;mike@i-connect.net&gt;&n; *&n; *  Added request_module(&quot;scsi_hostadapter&quot;) for kerneld:&n; *  (Put an &quot;alias scsi_hostadapter your_hostadapter&quot; in /etc/conf.modules)&n; *  Bjorn Ekwall  &lt;bj0rn@blox.se&gt;&n; *  (changed to kmod)&n; *&n; *  Major improvements to the timeout, abort, and reset processing,&n; *  as well as performance modifications for large queue depths by&n; *  Leonard N. Zubkoff &lt;lnz@dandelion.com&gt;&n; *&n; *  Converted cli() code to spinlocks, Ingo Molnar&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/spinlock.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#ifdef CONFIG_KMOD
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#endif
DECL|macro|USE_STATIC_SCSI_MEMORY
macro_line|#undef USE_STATIC_SCSI_MEMORY
multiline_comment|/*&n;static const char RCSid[] = &quot;$Header: /vger/u4/cvs/linux/drivers/scsi/scsi.c,v 1.38 1997/01/19 23:07:18 davem Exp $&quot;;&n;*/
multiline_comment|/*&n; * Definitions and constants.&n; */
DECL|macro|INTERNAL_ERROR
mdefine_line|#define INTERNAL_ERROR (panic (&quot;Internal error in file %s, line %d.&bslash;n&quot;, __FILE__, __LINE__))
multiline_comment|/*&n; * PAGE_SIZE must be a multiple of the sector size (512).  True&n; * for all reasonably recent architectures (even the VAX...).&n; */
DECL|macro|SECTOR_SIZE
mdefine_line|#define SECTOR_SIZE&t;&t;512
DECL|macro|SECTORS_PER_PAGE
mdefine_line|#define SECTORS_PER_PAGE&t;(PAGE_SIZE/SECTOR_SIZE)
macro_line|#if SECTORS_PER_PAGE &lt;= 8
DECL|typedef|FreeSectorBitmap
r_typedef
r_int
r_char
id|FreeSectorBitmap
suffix:semicolon
macro_line|#elif SECTORS_PER_PAGE &lt;= 32
DECL|typedef|FreeSectorBitmap
r_typedef
r_int
r_int
id|FreeSectorBitmap
suffix:semicolon
macro_line|#else
macro_line|# error You lose.
macro_line|#endif
DECL|macro|MAX_SCSI_DEVICE_CODE
mdefine_line|#define MAX_SCSI_DEVICE_CODE 10
macro_line|#ifdef DEBUG
DECL|macro|SCSI_TIMEOUT
mdefine_line|#define SCSI_TIMEOUT (5*HZ)
macro_line|#else
DECL|macro|SCSI_TIMEOUT
mdefine_line|#define SCSI_TIMEOUT (2*HZ)
macro_line|#endif
DECL|macro|MIN_RESET_DELAY
mdefine_line|#define MIN_RESET_DELAY (2*HZ)
multiline_comment|/* Do not call reset on error if we just did a reset within 15 sec. */
DECL|macro|MIN_RESET_PERIOD
mdefine_line|#define MIN_RESET_PERIOD (15*HZ)
multiline_comment|/* The following devices are known not to tolerate a lun != 0 scan for&n; * one reason or another.  Some will respond to all luns, others will&n; * lock up.&n; */
DECL|macro|BLIST_NOLUN
mdefine_line|#define BLIST_NOLUN     0x01
DECL|macro|BLIST_FORCELUN
mdefine_line|#define BLIST_FORCELUN  0x02
DECL|macro|BLIST_BORKEN
mdefine_line|#define BLIST_BORKEN    0x04
DECL|macro|BLIST_KEY
mdefine_line|#define BLIST_KEY       0x08
DECL|macro|BLIST_SINGLELUN
mdefine_line|#define BLIST_SINGLELUN 0x10
DECL|macro|BLIST_NOTQ
mdefine_line|#define BLIST_NOTQ&t;0x20
DECL|macro|BLIST_SPARSELUN
mdefine_line|#define BLIST_SPARSELUN 0x40
multiline_comment|/*&n; * Data declarations.&n; */
DECL|variable|scsi_pid
r_int
r_int
id|scsi_pid
op_assign
l_int|0
suffix:semicolon
DECL|variable|last_cmnd
id|Scsi_Cmnd
op_star
id|last_cmnd
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Command groups 3 and 4 are reserved and should never be used.  */
DECL|variable|scsi_command_size
r_const
r_int
r_char
id|scsi_command_size
(braket
l_int|8
)braket
op_assign
(brace
l_int|6
comma
l_int|10
comma
l_int|10
comma
l_int|12
comma
l_int|12
comma
l_int|12
comma
l_int|10
comma
l_int|10
)brace
suffix:semicolon
DECL|variable|serial_number
r_static
r_int
r_int
id|serial_number
op_assign
l_int|0
suffix:semicolon
DECL|variable|scsi_bh_queue_head
r_static
id|Scsi_Cmnd
op_star
id|scsi_bh_queue_head
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|scsi_bh_queue_tail
r_static
id|Scsi_Cmnd
op_star
id|scsi_bh_queue_tail
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|scsi_bh_queue_spin
r_static
id|spinlock_t
id|scsi_bh_queue_spin
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|dma_malloc_freelist
r_static
id|FreeSectorBitmap
op_star
id|dma_malloc_freelist
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|need_isa_bounce_buffers
r_static
r_int
id|need_isa_bounce_buffers
suffix:semicolon
DECL|variable|dma_sectors
r_static
r_int
r_int
id|dma_sectors
op_assign
l_int|0
suffix:semicolon
DECL|variable|scsi_dma_free_sectors
r_int
r_int
id|scsi_dma_free_sectors
op_assign
l_int|0
suffix:semicolon
DECL|variable|scsi_need_isa_buffer
r_int
r_int
id|scsi_need_isa_buffer
op_assign
l_int|0
suffix:semicolon
DECL|variable|dma_malloc_pages
r_static
r_int
r_char
op_star
op_star
id|dma_malloc_pages
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * Note - the initial logging level can be set here to log events at boot time.&n; * After the system is up, you may enable logging via the /proc interface.&n; */
DECL|variable|scsi_logging_level
r_int
r_int
id|scsi_logging_level
op_assign
l_int|0
suffix:semicolon
DECL|variable|host_active
r_volatile
r_struct
id|Scsi_Host
op_star
id|host_active
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if CONFIG_PROC_FS
multiline_comment|/* &n; * This is the pointer to the /proc/scsi code.&n; * It is only initialized to !=0 if the scsi code is present&n; */
DECL|variable|proc_scsi_scsi
r_struct
id|proc_dir_entry
id|proc_scsi_scsi
op_assign
(brace
id|PROC_SCSI_SCSI
comma
l_int|4
comma
l_string|&quot;scsi&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
macro_line|#endif
DECL|variable|scsi_device_types
r_const
r_char
op_star
r_const
id|scsi_device_types
(braket
id|MAX_SCSI_DEVICE_CODE
)braket
op_assign
(brace
l_string|&quot;Direct-Access    &quot;
comma
l_string|&quot;Sequential-Access&quot;
comma
l_string|&quot;Printer          &quot;
comma
l_string|&quot;Processor        &quot;
comma
l_string|&quot;WORM             &quot;
comma
l_string|&quot;CD-ROM           &quot;
comma
l_string|&quot;Scanner          &quot;
comma
l_string|&quot;Optical Device   &quot;
comma
l_string|&quot;Medium Changer   &quot;
comma
l_string|&quot;Communications   &quot;
)brace
suffix:semicolon
multiline_comment|/* &n; * Function prototypes.&n; */
r_static
r_void
id|resize_dma_pool
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|data
)paren
suffix:semicolon
r_extern
r_void
id|scsi_times_out
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_static
r_int
id|scan_scsis_single
(paren
r_int
id|channel
comma
r_int
id|dev
comma
r_int
id|lun
comma
r_int
op_star
id|max_scsi_dev
comma
r_int
op_star
id|sparse_lun
comma
id|Scsi_Device
op_star
op_star
id|SDpnt
comma
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_char
op_star
id|scsi_result
)paren
suffix:semicolon
r_void
id|scsi_build_commandblocks
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/*&n; * These are the interface to the old error handling code.  It should go away&n; * someday soon.&n; */
r_extern
r_void
id|scsi_old_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_extern
r_void
id|scsi_old_times_out
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
macro_line|#if CONFIG_PROC_FS
r_extern
r_int
(paren
op_star
id|dispatch_scsi_info_ptr
)paren
(paren
r_int
id|ino
comma
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|inout
)paren
suffix:semicolon
r_extern
r_int
id|dispatch_scsi_info
c_func
(paren
r_int
id|ino
comma
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|inout
)paren
suffix:semicolon
macro_line|#endif
DECL|macro|SCSI_BLOCK
mdefine_line|#define SCSI_BLOCK(DEVICE, HOST)                                                &bslash;&n;                ((HOST-&gt;block &amp;&amp; host_active &amp;&amp; HOST != host_active)            &bslash;&n;&t;&t;  || ((HOST)-&gt;can_queue &amp;&amp; HOST-&gt;host_busy &gt;= HOST-&gt;can_queue)    &bslash;&n;                  || ((HOST)-&gt;host_blocked)                                       &bslash;&n;                  || ((DEVICE) != NULL &amp;&amp; (DEVICE)-&gt;device_blocked) )
r_static
r_void
id|scsi_dump_status
c_func
(paren
r_int
id|level
)paren
suffix:semicolon
DECL|struct|dev_info
r_struct
id|dev_info
(brace
DECL|member|vendor
r_const
r_char
op_star
id|vendor
suffix:semicolon
DECL|member|model
r_const
r_char
op_star
id|model
suffix:semicolon
DECL|member|revision
r_const
r_char
op_star
id|revision
suffix:semicolon
multiline_comment|/* Latest revision known to be bad.  Not used yet */
DECL|member|flags
r_int
id|flags
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * This is what was previously known as the blacklist.  The concept&n; * has been expanded so that we can specify other types of things we&n; * need to be aware of.&n; */
DECL|variable|device_list
r_static
r_struct
id|dev_info
id|device_list
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;Aashima&quot;
comma
l_string|&quot;IMAGERY 2400SP&quot;
comma
l_string|&quot;1.03&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;CHINON&quot;
comma
l_string|&quot;CD-ROM CDS-431&quot;
comma
l_string|&quot;H42&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;CHINON&quot;
comma
l_string|&quot;CD-ROM CDS-535&quot;
comma
l_string|&quot;Q14&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;DENON&quot;
comma
l_string|&quot;DRD-25X&quot;
comma
l_string|&quot;V&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if probed for lun != 0 */
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;DK312C&quot;
comma
l_string|&quot;CM81&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun - dtg */
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;DK314C&quot;
comma
l_string|&quot;CR21&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;IMS&quot;
comma
l_string|&quot;CDD521/10&quot;
comma
l_string|&quot;2.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-3280&quot;
comma
l_string|&quot;PR02&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-4380S&quot;
comma
l_string|&quot;B3C&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;MXT-1240S&quot;
comma
l_string|&quot;I1.2&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up when LUN&gt;0 polled */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-4170S&quot;
comma
l_string|&quot;B5A&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up sometimes when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-8760S&quot;
comma
l_string|&quot;B7B&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* guess what? */
(brace
l_string|&quot;MEDIAVIS&quot;
comma
l_string|&quot;RENO CD-ROMX2A&quot;
comma
l_string|&quot;2.03&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/*Responds to all lun */
(brace
l_string|&quot;MICROP&quot;
comma
l_string|&quot;4110&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_NOTQ
)brace
comma
multiline_comment|/* Buggy Tagged Queuing */
(brace
l_string|&quot;NEC&quot;
comma
l_string|&quot;CD-ROM DRIVE:841&quot;
comma
l_string|&quot;1.0&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;RODIME&quot;
comma
l_string|&quot;RO3000S&quot;
comma
l_string|&quot;2.33&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;SANYO&quot;
comma
l_string|&quot;CRD-250S&quot;
comma
l_string|&quot;1.20&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1&n;&t;&t;&t;&t;&t;&t; * for aha152x controller, which causes&n;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST157N&quot;
comma
l_string|&quot;&bslash;004|j&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1&n;&t;&t;&t;&t;&t;&t; * for aha152x controller, which causes&n;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST296&quot;
comma
l_string|&quot;921&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST1581&quot;
comma
l_string|&quot;6538&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-541&quot;
comma
l_string|&quot;4.3d&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-55S&quot;
comma
l_string|&quot;1.0i&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-561&quot;
comma
l_string|&quot;1.7x&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;TANDBERG&quot;
comma
l_string|&quot;TDC 3600&quot;
comma
l_string|&quot;U07&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;CD-R55S&quot;
comma
l_string|&quot;1.0H&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1&n;&t;&t;&t;&t;&t;&t; * for seagate controller, which causes&n;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;TEXEL&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1&n;&t;&t;&t;&t;&t;&t; * for seagate controller, which causes&n;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;LPS525S&quot;
comma
l_string|&quot;3110&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks sometimes if polled for lun != 0 */
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;PD1225S&quot;
comma
l_string|&quot;3110&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks sometimes if polled for lun != 0 */
(brace
l_string|&quot;MEDIAVIS&quot;
comma
l_string|&quot;CDR-H93MV&quot;
comma
l_string|&quot;1.31&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;SANKYO&quot;
comma
l_string|&quot;CP525&quot;
comma
l_string|&quot;6.64&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQ SENSE, extra reset */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C1750A&quot;
comma
l_string|&quot;3226&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iic */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C1790A&quot;
comma
l_string|&quot;&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iip */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C2500A&quot;
comma
l_string|&quot;&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iicx */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CDR102&quot;
comma
l_string|&quot;1.00&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* extra reset */
multiline_comment|/*&n; * Other types of devices that have special flags.&n; */
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-8001&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_BORKEN
)brace
comma
(brace
l_string|&quot;TEXEL&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_BORKEN
)brace
comma
(brace
l_string|&quot;IOMEGA&quot;
comma
l_string|&quot;Io20S         *F&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;INSITE&quot;
comma
l_string|&quot;Floptical   F*8I&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;INSITE&quot;
comma
l_string|&quot;I325VM&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;NRC&quot;
comma
l_string|&quot;MBR-7&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NRC&quot;
comma
l_string|&quot;MBR-7.4&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NAKAMICH&quot;
comma
l_string|&quot;MJ-4.8S&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-602X&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-604X&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;EMULEX&quot;
comma
l_string|&quot;MD21/S2     ESDI&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;CANON&quot;
comma
l_string|&quot;IPUBJD&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;nCipher&quot;
comma
l_string|&quot;Fastness Crypto&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;MATSHITA&quot;
comma
l_string|&quot;PD&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CDR100&quot;
comma
l_string|&quot;1.00&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CDR102&quot;
comma
l_string|&quot;1.00&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
multiline_comment|/*&n; * Must be at end of list...&n; */
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|function|get_device_flags
r_static
r_int
(def_block
id|get_device_flags
c_func
(paren
r_int
r_char
op_star
id|response_data
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|pnt
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|device_list
(braket
id|i
)braket
dot
id|vendor
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|pnt
op_assign
op_amp
id|response_data
(braket
l_int|8
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_eq
l_char|&squot; &squot;
)paren
(brace
id|pnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|vendor
comma
id|pnt
comma
id|strlen
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|vendor
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|pnt
op_assign
op_amp
id|response_data
(braket
l_int|16
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_eq
l_char|&squot; &squot;
)paren
(brace
id|pnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|model
comma
id|pnt
comma
id|strlen
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|model
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_return
id|device_list
(braket
id|i
)braket
dot
id|flags
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * Function:    scsi_make_blocked_list&n; *&n; * Purpose:     Build linked list of hosts that require blocking.&n; *&n; * Arguments:   None.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       Blocking is sort of a hack that is used to prevent more than one&n; *              host adapter from being active at one time.  This is used in cases&n; *              where the ISA bus becomes unreliable if you have more than one&n; *              host adapter really pumping data through.&n; *&n; *              We spent a lot of time examining the problem, and I *believe* that&n; *              the problem is bus related as opposed to being a driver bug.&n; *&n; *              The blocked list is used as part of the synchronization object&n; *              that we use to ensure that only one host is active at one time.&n; *              I (ERY) would like to make this go away someday, but this would&n; *              require that we have a recursive mutex object.&n; */
r_void
DECL|function|scsi_make_blocked_list
id|scsi_make_blocked_list
c_func
(paren
r_void
)paren
(brace
r_int
id|block_count
op_assign
l_int|0
comma
id|index
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|sh
(braket
l_int|128
)braket
comma
op_star
id|shpnt
suffix:semicolon
multiline_comment|/*&n;     * Create a circular linked list from the scsi hosts which have&n;     * the &quot;wish_block&quot; field in the Scsi_Host structure set.&n;     * The blocked list should include all the scsi hosts using ISA DMA.&n;     * In some systems, using two dma channels simultaneously causes&n;     * unpredictable results.&n;     * Among the scsi hosts in the blocked list, only one host at a time&n;     * is allowed to have active commands queued. The transition from&n;     * one active host to the next one is allowed only when host_busy == 0&n;     * for the active host (which implies host_busy == 0 for all the hosts&n;     * in the list). Moreover for block devices the transition to a new&n;     * active host is allowed only when a request is completed, since a&n;     * block device request can be divided into multiple scsi commands&n;     * (when there are few sg lists or clustering is disabled).&n;     *&n;     * (DB, 4 Feb 1995)&n;     */
id|host_active
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
macro_line|#if 0
multiline_comment|/*&n;&t; * Is this is a candidate for the blocked list?&n;&t; * Useful to put into the blocked list all the hosts whose driver&n;&t; * does not know about the host-&gt;block feature.&n;&t; */
r_if
c_cond
(paren
id|shpnt-&gt;unchecked_isa_dma
)paren
id|shpnt-&gt;wish_block
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|shpnt-&gt;wish_block
)paren
id|sh
(braket
id|block_count
op_increment
)braket
op_assign
id|shpnt
suffix:semicolon
)brace
r_if
c_cond
(paren
id|block_count
op_eq
l_int|1
)paren
id|sh
(braket
l_int|0
)braket
op_member_access_from_pointer
id|block
op_assign
l_int|NULL
suffix:semicolon
r_else
r_if
c_cond
(paren
id|block_count
OG
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|block_count
op_minus
l_int|1
suffix:semicolon
id|index
op_increment
)paren
(brace
id|sh
(braket
id|index
)braket
op_member_access_from_pointer
id|block
op_assign
id|sh
(braket
id|index
op_plus
l_int|1
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : added to blocked host list.&bslash;n&quot;
comma
id|sh
(braket
id|index
)braket
op_member_access_from_pointer
id|host_no
)paren
suffix:semicolon
)brace
id|sh
(braket
id|block_count
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|block
op_assign
id|sh
(braket
l_int|0
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : added to blocked host list.&bslash;n&quot;
comma
id|sh
(braket
id|index
)braket
op_member_access_from_pointer
id|host_no
)paren
suffix:semicolon
)brace
)brace
DECL|function|scan_scsis_done
r_static
r_void
id|scan_scsis_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|1
comma
id|printk
(paren
l_string|&quot;scan_scsis_done(%p, %06x)&bslash;n&quot;
comma
id|SCpnt-&gt;host
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request.sem
op_ne
l_int|NULL
)paren
id|up
c_func
(paren
id|SCpnt-&gt;request.sem
)paren
suffix:semicolon
)brace
DECL|function|scsi_logging_setup
r_void
id|scsi_logging_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi_logging_setup : usage scsi_logging_level=n &quot;
l_string|&quot;(n should be 0 or non-zero)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|scsi_logging_level
op_assign
(paren
id|ints
(braket
l_int|1
)braket
)paren
ques
c_cond
op_complement
l_int|0
suffix:colon
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_SCSI_MULTI_LUN
DECL|variable|max_scsi_luns
r_static
r_int
id|max_scsi_luns
op_assign
l_int|8
suffix:semicolon
macro_line|#else
DECL|variable|max_scsi_luns
r_static
r_int
id|max_scsi_luns
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
DECL|function|scsi_luns_setup
r_void
id|scsi_luns_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ne
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;scsi_luns_setup : usage max_scsi_luns=n (n should be between 1 and 8)&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|max_scsi_luns
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; *  Detecting SCSI devices :&n; *  We scan all present host adapter&squot;s busses,  from ID 0 to ID (max_id).&n; *  We use the INQUIRY command, determine device type, and pass the ID /&n; *  lun address of all sequential devices to the tape driver, all random&n; *  devices to the disk driver.&n; */
DECL|function|scan_scsis
r_static
r_void
id|scan_scsis
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
id|unchar
id|hardcoded
comma
id|unchar
id|hchannel
comma
id|unchar
id|hid
comma
id|unchar
id|hlun
)paren
(brace
r_int
id|channel
suffix:semicolon
r_int
id|dev
suffix:semicolon
r_int
id|lun
suffix:semicolon
r_int
id|max_dev_lun
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_int
r_char
op_star
id|scsi_result
suffix:semicolon
r_int
r_char
id|scsi_result0
(braket
l_int|256
)braket
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDtail
suffix:semicolon
r_int
id|sparse_lun
suffix:semicolon
id|SCpnt
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|scsi_init_malloc
(paren
r_sizeof
(paren
id|Scsi_Cmnd
)paren
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
id|memset
(paren
id|SCpnt
comma
l_int|0
comma
r_sizeof
(paren
id|Scsi_Cmnd
)paren
)paren
suffix:semicolon
id|SDpnt
op_assign
(paren
id|Scsi_Device
op_star
)paren
id|scsi_init_malloc
(paren
r_sizeof
(paren
id|Scsi_Device
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|memset
(paren
id|SDpnt
comma
l_int|0
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
multiline_comment|/* Make sure we have something that is valid for DMA purposes */
id|scsi_result
op_assign
(paren
(paren
op_logical_neg
id|shpnt-&gt;unchecked_isa_dma
)paren
ques
c_cond
op_amp
id|scsi_result0
(braket
l_int|0
)braket
suffix:colon
id|scsi_init_malloc
(paren
l_int|512
comma
id|GFP_DMA
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_result
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;Unable to obtain scsi_result buffer&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/*&n;   * We must chain ourself in the host_queue, so commands can time out &n;   */
id|SCpnt-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|SDpnt-&gt;device_queue
op_assign
id|SCpnt
suffix:semicolon
id|SDpnt-&gt;host
op_assign
id|shpnt
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;   * Next, hook the device to the host in question.&n;   */
id|SDpnt-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|SDpnt-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;host_queue
op_ne
l_int|NULL
)paren
(brace
id|SDtail
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SDtail-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|SDtail
op_assign
id|SDtail-&gt;next
suffix:semicolon
)brace
id|SDtail-&gt;next
op_assign
id|SDpnt
suffix:semicolon
id|SDpnt-&gt;prev
op_assign
id|SDtail
suffix:semicolon
)brace
r_else
(brace
id|shpnt-&gt;host_queue
op_assign
id|SDpnt
suffix:semicolon
)brace
multiline_comment|/*&n;   * We need to increment the counter for this one device so we can track when&n;   * things are quiet.&n;   */
id|atomic_inc
c_func
(paren
op_amp
id|shpnt-&gt;host_active
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hardcoded
op_eq
l_int|1
)paren
(brace
id|Scsi_Device
op_star
id|oldSDpnt
op_assign
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
id|channel
op_assign
id|hchannel
suffix:semicolon
r_if
c_cond
(paren
id|channel
OG
id|shpnt-&gt;max_channel
)paren
(brace
r_goto
id|leave
suffix:semicolon
)brace
id|dev
op_assign
id|hid
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ge
id|shpnt-&gt;max_id
)paren
(brace
r_goto
id|leave
suffix:semicolon
)brace
id|lun
op_assign
id|hlun
suffix:semicolon
r_if
c_cond
(paren
id|lun
op_ge
id|shpnt-&gt;max_lun
)paren
(brace
r_goto
id|leave
suffix:semicolon
)brace
id|scan_scsis_single
(paren
id|channel
comma
id|dev
comma
id|lun
comma
op_amp
id|max_dev_lun
comma
op_amp
id|sparse_lun
comma
op_amp
id|SDpnt
comma
id|SCpnt
comma
id|shpnt
comma
id|scsi_result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt
op_ne
id|oldSDpnt
)paren
(brace
multiline_comment|/* it could happen the blockdevice hasn&squot;t yet been inited */
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;init
op_logical_and
id|sdtpnt-&gt;dev_noticed
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;init
)paren
(paren
)paren
suffix:semicolon
)brace
id|oldSDpnt-&gt;scsi_request_fn
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;attach
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;attach
)paren
(paren
id|oldSDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldSDpnt-&gt;attached
)paren
(brace
id|scsi_build_commandblocks
c_func
(paren
id|oldSDpnt
)paren
suffix:semicolon
)brace
)brace
id|resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|sdtpnt-&gt;finish
op_logical_and
id|sdtpnt-&gt;nr_dev
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;finish
)paren
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|channel
op_assign
l_int|0
suffix:semicolon
id|channel
op_le
id|shpnt-&gt;max_channel
suffix:semicolon
id|channel
op_increment
)paren
(brace
r_for
c_loop
(paren
id|dev
op_assign
l_int|0
suffix:semicolon
id|dev
OL
id|shpnt-&gt;max_id
suffix:semicolon
op_increment
id|dev
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;this_id
op_ne
id|dev
)paren
(brace
multiline_comment|/*&n;           * We need the for so our continue, etc. work fine. We put this in&n;           * a variable so that we can override it during the scan if we&n;           * detect a device *KNOWN* to have multiple logical units.&n;           */
id|max_dev_lun
op_assign
(paren
id|max_scsi_luns
OL
id|shpnt-&gt;max_lun
ques
c_cond
id|max_scsi_luns
suffix:colon
id|shpnt-&gt;max_lun
)paren
suffix:semicolon
id|sparse_lun
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
id|max_dev_lun
suffix:semicolon
op_increment
id|lun
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|scan_scsis_single
(paren
id|channel
comma
id|dev
comma
id|lun
comma
op_amp
id|max_dev_lun
comma
op_amp
id|sparse_lun
comma
op_amp
id|SDpnt
comma
id|SCpnt
comma
id|shpnt
comma
id|scsi_result
)paren
op_logical_and
op_logical_neg
id|sparse_lun
)paren
r_break
suffix:semicolon
multiline_comment|/* break means don&squot;t probe further for luns!=0 */
)brace
multiline_comment|/* for lun ends */
)brace
multiline_comment|/* if this_id != id ends */
)brace
multiline_comment|/* for dev ends */
)brace
multiline_comment|/* for channel ends */
)brace
multiline_comment|/* if/else hardcoded */
multiline_comment|/*&n;   * We need to decrement the counter for this one device&n;   * so we know when everything is quiet.&n;   */
id|atomic_dec
c_func
(paren
op_amp
id|shpnt-&gt;host_active
)paren
suffix:semicolon
id|leave
suffix:colon
(brace
multiline_comment|/* Unchain SCpnt from host_queue */
id|Scsi_Device
op_star
id|prev
comma
op_star
id|next
suffix:semicolon
id|Scsi_Device
op_star
id|dqptr
suffix:semicolon
r_for
c_loop
(paren
id|dqptr
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|dqptr
op_ne
id|SDpnt
suffix:semicolon
id|dqptr
op_assign
id|dqptr-&gt;next
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dqptr
)paren
(brace
id|prev
op_assign
id|dqptr-&gt;prev
suffix:semicolon
id|next
op_assign
id|dqptr-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
(brace
id|prev-&gt;next
op_assign
id|next
suffix:semicolon
)brace
r_else
id|shpnt-&gt;host_queue
op_assign
id|next
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
(brace
id|next-&gt;prev
op_assign
id|prev
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Last device block does not exist.  Free memory. */
r_if
c_cond
(paren
id|SDpnt
op_ne
l_int|NULL
)paren
id|scsi_init_free
(paren
(paren
r_char
op_star
)paren
id|SDpnt
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_ne
l_int|NULL
)paren
id|scsi_init_free
(paren
(paren
r_char
op_star
)paren
id|SCpnt
comma
r_sizeof
(paren
id|Scsi_Cmnd
)paren
)paren
suffix:semicolon
multiline_comment|/* If we allocated a buffer so we could do DMA, free it now */
r_if
c_cond
(paren
id|scsi_result
op_ne
op_amp
id|scsi_result0
(braket
l_int|0
)braket
op_logical_and
id|scsi_result
op_ne
l_int|NULL
)paren
(brace
id|scsi_init_free
(paren
id|scsi_result
comma
l_int|512
)paren
suffix:semicolon
)brace
(brace
id|Scsi_Device
op_star
id|sdev
suffix:semicolon
id|Scsi_Cmnd
op_star
id|scmd
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;Host status for host %p:&bslash;n&quot;
comma
id|shpnt
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdev
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|sdev
suffix:semicolon
id|sdev
op_assign
id|sdev-&gt;next
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;Device %d %p: &quot;
comma
id|sdev-&gt;id
comma
id|sdev
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|scmd
op_assign
id|sdev-&gt;device_queue
suffix:semicolon
id|scmd
suffix:semicolon
id|scmd
op_assign
id|scmd-&gt;next
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;%p &quot;
comma
id|scmd
)paren
)paren
suffix:semicolon
)brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * The worker for scan_scsis.&n; * Returning 0 means Please don&squot;t ask further for lun!=0, 1 means OK go on.&n; * Global variables used : scsi_devices(linked list)&n; */
DECL|function|scan_scsis_single
r_int
id|scan_scsis_single
(paren
r_int
id|channel
comma
r_int
id|dev
comma
r_int
id|lun
comma
r_int
op_star
id|max_dev_lun
comma
r_int
op_star
id|sparse_lun
comma
id|Scsi_Device
op_star
op_star
id|SDpnt2
comma
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_char
op_star
id|scsi_result
)paren
(brace
r_int
r_char
id|scsi_cmd
(braket
l_int|12
)braket
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDtail
comma
op_star
id|SDpnt
op_assign
op_star
id|SDpnt2
suffix:semicolon
r_int
id|bflags
comma
id|type
op_assign
op_minus
l_int|1
suffix:semicolon
id|SDpnt-&gt;host
op_assign
id|shpnt
suffix:semicolon
id|SDpnt-&gt;id
op_assign
id|dev
suffix:semicolon
id|SDpnt-&gt;lun
op_assign
id|lun
suffix:semicolon
id|SDpnt-&gt;channel
op_assign
id|channel
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Some low level driver could use device-&gt;type (DB) */
id|SDpnt-&gt;type
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;   * Assume that the device will have handshaking problems, and then fix this&n;   * field later if it turns out it doesn&squot;t&n;   */
id|SDpnt-&gt;borken
op_assign
l_int|1
suffix:semicolon
id|SDpnt-&gt;was_reset
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;expecting_cc_ua
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|TEST_UNIT_READY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
id|lun
op_lshift
l_int|5
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;host
op_assign
id|SDpnt-&gt;host
suffix:semicolon
id|SCpnt-&gt;device
op_assign
id|SDpnt
suffix:semicolon
id|SCpnt-&gt;target
op_assign
id|SDpnt-&gt;id
suffix:semicolon
id|SCpnt-&gt;lun
op_assign
id|SDpnt-&gt;lun
suffix:semicolon
id|SCpnt-&gt;channel
op_assign
id|SDpnt-&gt;channel
suffix:semicolon
(brace
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
op_amp
id|sem
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|scsi_do_cmd
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|256
comma
id|scan_scsis_done
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|5
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|down
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
)brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
(paren
l_string|&quot;scsi: scan_scsis_single id %d lun %d. Return code 0x%08x&bslash;n&quot;
comma
id|dev
comma
id|lun
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|print_driverbyte
c_func
(paren
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|print_hostbyte
c_func
(paren
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;result
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|driver_byte
(paren
id|SCpnt-&gt;result
)paren
op_amp
id|DRIVER_SENSE
)paren
op_logical_or
(paren
id|status_byte
(paren
id|SCpnt-&gt;result
)paren
op_amp
id|CHECK_CONDITION
)paren
)paren
op_logical_and
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x70
)paren
op_rshift
l_int|4
)paren
op_eq
l_int|7
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|NOT_READY
)paren
op_logical_and
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|UNIT_ATTENTION
)paren
op_logical_and
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|ILLEGAL_REQUEST
op_logical_or
id|lun
OG
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
(paren
l_string|&quot;scsi: performing INQUIRY&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;   * Build an INQUIRY command block.&n;   */
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|255
suffix:semicolon
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
(brace
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
op_amp
id|sem
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|scsi_do_cmd
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|256
comma
id|scan_scsis_done
comma
id|SCSI_TIMEOUT
comma
l_int|3
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|down
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
)brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
(paren
l_string|&quot;scsi: INQUIRY %s with code 0x%x&bslash;n&quot;
comma
id|SCpnt-&gt;result
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;successful&quot;
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;result
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* assume no peripheral if any sort of error */
multiline_comment|/*&n;   * Check the peripheral qualifier field - this tells us whether LUNS&n;   * are supported here or not.&n;   */
r_if
c_cond
(paren
(paren
id|scsi_result
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
op_eq
l_int|3
)paren
(brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* assume no peripheral if any sort of error */
)brace
multiline_comment|/*&n;   * It would seem some TOSHIBA CDROM gets things wrong&n;   */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
(paren
id|scsi_result
op_plus
l_int|8
comma
l_string|&quot;TOSHIBA&quot;
comma
l_int|7
)paren
op_logical_and
op_logical_neg
id|strncmp
(paren
id|scsi_result
op_plus
l_int|16
comma
l_string|&quot;CD-ROM&quot;
comma
l_int|6
)paren
op_logical_and
id|scsi_result
(braket
l_int|0
)braket
op_eq
id|TYPE_DISK
)paren
(brace
id|scsi_result
(braket
l_int|0
)braket
op_assign
id|TYPE_ROM
suffix:semicolon
id|scsi_result
(braket
l_int|1
)braket
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* removable */
)brace
id|memcpy
(paren
id|SDpnt-&gt;vendor
comma
id|scsi_result
op_plus
l_int|8
comma
l_int|8
)paren
suffix:semicolon
id|memcpy
(paren
id|SDpnt-&gt;model
comma
id|scsi_result
op_plus
l_int|16
comma
l_int|16
)paren
suffix:semicolon
id|memcpy
(paren
id|SDpnt-&gt;rev
comma
id|scsi_result
op_plus
l_int|32
comma
l_int|4
)paren
suffix:semicolon
id|SDpnt-&gt;removable
op_assign
(paren
l_int|0x80
op_amp
id|scsi_result
(braket
l_int|1
)braket
)paren
op_rshift
l_int|7
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
id|SDpnt-&gt;lockable
op_assign
id|SDpnt-&gt;removable
suffix:semicolon
id|SDpnt-&gt;changed
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;access_count
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;has_cmdblocks
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   * Currently, all sequential devices are assumed to be tapes, all random&n;   * devices disk, with the appropriate read only flags set for ROM / WORM&n;   * treated as RO.&n;   */
r_switch
c_cond
(paren
id|type
op_assign
(paren
id|scsi_result
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
)paren
(brace
r_case
id|TYPE_TAPE
suffix:colon
r_case
id|TYPE_DISK
suffix:colon
r_case
id|TYPE_MOD
suffix:colon
r_case
id|TYPE_PROCESSOR
suffix:colon
r_case
id|TYPE_SCANNER
suffix:colon
id|SDpnt-&gt;writeable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_WORM
suffix:colon
r_case
id|TYPE_ROM
suffix:colon
id|SDpnt-&gt;writeable
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;scsi: unknown type %d&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
)brace
id|SDpnt-&gt;device_blocked
op_assign
id|FALSE
suffix:semicolon
id|SDpnt-&gt;device_busy
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;single_lun
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;soft_reset
op_assign
(paren
id|scsi_result
(braket
l_int|7
)braket
op_amp
l_int|1
)paren
op_logical_and
(paren
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|7
)paren
op_eq
l_int|2
)paren
suffix:semicolon
id|SDpnt-&gt;random
op_assign
(paren
id|type
op_eq
id|TYPE_TAPE
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|SDpnt-&gt;type
op_assign
(paren
id|type
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|print_inquiry
(paren
id|scsi_result
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;detect
)paren
id|SDpnt-&gt;attached
op_add_assign
(paren
op_star
id|sdtpnt-&gt;detect
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
id|SDpnt-&gt;scsi_level
op_assign
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;scsi_level
op_ge
l_int|2
op_logical_or
(paren
id|SDpnt-&gt;scsi_level
op_eq
l_int|1
op_logical_and
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
)paren
id|SDpnt-&gt;scsi_level
op_increment
suffix:semicolon
multiline_comment|/*&n;   * Accommodate drivers that want to sleep when they should be in a polling&n;   * loop.&n;   */
id|SDpnt-&gt;disconnect
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   * Get any flags for this device.&n;   */
id|bflags
op_assign
id|get_device_flags
(paren
id|scsi_result
)paren
suffix:semicolon
multiline_comment|/*&n;   * Set the tagged_queue flag for SCSI-II devices that purport to support&n;   * tagged queuing in the INQUIRY data.&n;   */
id|SDpnt-&gt;tagged_queue
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|SDpnt-&gt;scsi_level
op_ge
id|SCSI_2
)paren
op_logical_and
(paren
id|scsi_result
(braket
l_int|7
)braket
op_amp
l_int|2
)paren
op_logical_and
op_logical_neg
(paren
id|bflags
op_amp
id|BLIST_NOTQ
)paren
)paren
(brace
id|SDpnt-&gt;tagged_supported
op_assign
l_int|1
suffix:semicolon
id|SDpnt-&gt;current_tag
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;   * Some revisions of the Texel CD ROM drives have handshaking problems when&n;   * used with the Seagate controllers.  Before we know what type of device&n;   * we&squot;re talking to, we assume it&squot;s borken and then change it here if it&n;   * turns out that it isn&squot;t a TEXEL drive.&n;   */
r_if
c_cond
(paren
(paren
id|bflags
op_amp
id|BLIST_BORKEN
)paren
op_eq
l_int|0
)paren
id|SDpnt-&gt;borken
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   * If we want to only allow I/O to one of the luns attached to this device&n;   * at a time, then we set this flag.&n;   */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_SINGLELUN
)paren
id|SDpnt-&gt;single_lun
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;   * These devices need this &quot;key&quot; to unlock the devices so we can use it&n;   */
r_if
c_cond
(paren
(paren
id|bflags
op_amp
id|BLIST_KEY
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;Unlocked floptical drive.&bslash;n&quot;
)paren
suffix:semicolon
id|SDpnt-&gt;lockable
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x2e
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|0x2a
suffix:semicolon
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
(brace
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
op_amp
id|sem
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|scsi_do_cmd
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|0x2a
comma
id|scan_scsis_done
comma
id|SCSI_TIMEOUT
comma
l_int|3
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|down
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Detach the command from the device. It was just a temporary to be used while&n;   * scanning the bus - the real ones will be allocated later.&n;   */
id|SDpnt-&gt;device_queue
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;   * This device was already hooked up to the host in question,&n;   * so at this point we just let go of it and it should be fine.  We do need to&n;   * allocate a new one and attach it to the host so that we can further scan the bus.&n;   */
id|SDpnt
op_assign
(paren
id|Scsi_Device
op_star
)paren
id|scsi_init_malloc
(paren
r_sizeof
(paren
id|Scsi_Device
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
op_star
id|SDpnt2
op_assign
id|SDpnt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SDpnt
)paren
(brace
id|printk
(paren
l_string|&quot;scsi: scan_scsis_single: Cannot malloc&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
(paren
id|SDpnt
comma
l_int|0
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;   * And hook up our command block to the new device we will be testing&n;   * for.&n;   */
id|SDpnt-&gt;device_queue
op_assign
id|SCpnt
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;   * Since we just found one device, there had damn well better be one in the list&n;   * already.&n;   */
r_if
c_cond
(paren
id|shpnt-&gt;host_queue
op_eq
l_int|NULL
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;scan_scsis_single: Host queue == NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|SDtail
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SDtail-&gt;next
)paren
(brace
id|SDtail
op_assign
id|SDtail-&gt;next
suffix:semicolon
)brace
multiline_comment|/* Add this device to the linked list at the end */
id|SDtail-&gt;next
op_assign
id|SDpnt
suffix:semicolon
id|SDpnt-&gt;prev
op_assign
id|SDtail
suffix:semicolon
id|SDpnt-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;   * Some scsi devices cannot be polled for lun != 0 due to firmware bugs&n;   */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_NOLUN
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* break; */
multiline_comment|/*&n;   * If this device is known to support sparse multiple units, override the&n;   * other settings, and scan all of them.&n;   */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_SPARSELUN
)paren
(brace
op_star
id|max_dev_lun
op_assign
l_int|8
suffix:semicolon
op_star
id|sparse_lun
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;   * If this device is known to support multiple units, override the other&n;   * settings, and scan all of them.&n;   */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_FORCELUN
)paren
(brace
op_star
id|max_dev_lun
op_assign
l_int|8
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;   * We assume the device can&squot;t handle lun!=0 if: - it reports scsi-0 (ANSI&n;   * SCSI Revision 0) (old drives like MAXTOR XT-3280) or - it reports scsi-1&n;   * (ANSI SCSI Revision 1) and Response Data Format 0&n;   */
r_if
c_cond
(paren
(paren
(paren
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *  Flag bits for the internal_timeout array&n; */
DECL|macro|NORMAL_TIMEOUT
mdefine_line|#define NORMAL_TIMEOUT 0
DECL|macro|IN_ABORT
mdefine_line|#define IN_ABORT  1
DECL|macro|IN_RESET
mdefine_line|#define IN_RESET  2
DECL|macro|IN_RESET2
mdefine_line|#define IN_RESET2 4
DECL|macro|IN_RESET3
mdefine_line|#define IN_RESET3 8
multiline_comment|/* This function takes a quick look at a request, and decides if it&n; * can be queued now, or if there would be a stall while waiting for&n; * something else to finish.  This routine assumes that interrupts are&n; * turned off when entering the routine.  It is the responsibility&n; * of the calling code to ensure that this is the case.&n; */
DECL|function|scsi_request_queueable
id|Scsi_Cmnd
op_star
id|scsi_request_queueable
(paren
r_struct
id|request
op_star
id|req
comma
id|Scsi_Device
op_star
id|device
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tablesize
suffix:semicolon
id|Scsi_Cmnd
op_star
id|found
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|bhp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
id|panic
(paren
l_string|&quot;No device passed to scsi_request_queueable().&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
op_logical_and
id|req-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
id|panic
c_func
(paren
l_string|&quot;Inactive in scsi_request_queueable&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * Look for a free command block.  If we have been instructed not to queue&n;     * multiple commands to multi-lun devices, then check to see what else is&n;     * going for this device first.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;single_lun
)paren
(brace
id|SCpnt
op_assign
id|device-&gt;device_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_break
suffix:semicolon
)brace
id|SCpnt
op_assign
id|SCpnt-&gt;next
suffix:semicolon
)brace
)brace
r_else
(brace
id|SCpnt
op_assign
id|device-&gt;device_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;channel
op_eq
id|device-&gt;channel
op_logical_and
id|SCpnt-&gt;target
op_eq
id|device-&gt;id
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;lun
op_eq
id|device-&gt;lun
)paren
(brace
r_if
c_cond
(paren
id|found
op_eq
l_int|NULL
op_logical_and
id|SCpnt-&gt;request.rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
id|found
op_assign
id|SCpnt
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
)paren
(brace
multiline_comment|/*&n;&t;&t;     * I think that we should really limit things to one&n;&t;&t;     * outstanding command per device - this is what tends&n;                     * to trip up buggy firmware.&n;&t;&t;     */
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
id|SCpnt
op_assign
id|SCpnt-&gt;next
suffix:semicolon
)brace
id|SCpnt
op_assign
id|found
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|SCSI_BLOCK
c_func
(paren
id|device
comma
id|device-&gt;host
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|SCpnt-&gt;request
comma
id|req
comma
r_sizeof
(paren
r_struct
id|request
)paren
)paren
suffix:semicolon
id|tablesize
op_assign
id|device-&gt;host-&gt;sg_tablesize
suffix:semicolon
id|bhp
op_assign
id|bh
op_assign
id|req-&gt;bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tablesize
)paren
(brace
id|bh
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Take a quick look through the table to see how big it is.&n;&t; * We already have our copy of req, so we can mess with that&n;&t; * if we want to.&n;&t; */
r_while
c_loop
(paren
id|req-&gt;nr_sectors
op_logical_and
id|bh
)paren
(brace
id|bhp
op_assign
id|bhp-&gt;b_reqnext
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bhp
op_logical_or
op_logical_neg
id|CONTIGUOUS_BUFFERS
c_func
(paren
id|bh
comma
id|bhp
)paren
)paren
(brace
id|tablesize
op_decrement
suffix:semicolon
)brace
id|req-&gt;nr_sectors
op_sub_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|req-&gt;sector
op_add_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tablesize
)paren
(brace
r_break
suffix:semicolon
)brace
id|bh
op_assign
id|bhp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|req-&gt;nr_sectors
op_logical_and
id|bh
op_logical_and
id|bh-&gt;b_reqnext
)paren
(brace
multiline_comment|/* Any leftovers? */
id|SCpnt-&gt;request.bhtail
op_assign
id|bh
suffix:semicolon
id|req-&gt;bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
multiline_comment|/* Divide request */
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
id|bh
op_assign
id|req-&gt;bh
suffix:semicolon
multiline_comment|/* Now reset things so that req looks OK */
id|SCpnt-&gt;request.nr_sectors
op_sub_assign
id|req-&gt;nr_sectors
suffix:semicolon
id|req-&gt;current_nr_sectors
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|req-&gt;buffer
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Wait until whole thing done */
)brace
r_else
(brace
id|req-&gt;rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|wait_for_request
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
multiline_comment|/* Busy, but no request */
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* And no one is waiting for the device&n;&t;&t;&t;&t;      * either */
)brace
id|atomic_inc
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Activating command for device %d (%d)&bslash;n&quot;
comma
id|SCpnt-&gt;target
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the scatter-gather flag */
id|SCpnt-&gt;old_use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Since not everyone seems to set the device info correctly&n; * before Scsi_Cmnd gets send out to scsi_do_command, we do it here.&n; */
id|SCpnt-&gt;channel
op_assign
id|device-&gt;channel
suffix:semicolon
id|SCpnt-&gt;lun
op_assign
id|device-&gt;lun
suffix:semicolon
id|SCpnt-&gt;target
op_assign
id|device-&gt;id
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_INITIALIZING
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_HIGHLEVEL
suffix:semicolon
r_return
id|SCpnt
suffix:semicolon
)brace
multiline_comment|/* This function returns a structure pointer that will be valid for&n; * the device.  The wait parameter tells us whether we should wait for&n; * the unit to become free or not.  We are also able to tell this routine&n; * not to return a descriptor if the host is unable to accept any more&n; * commands for the time being.  We need to keep in mind that there is no&n; * guarantee that the host remain not busy.  Keep in mind the&n; * scsi_request_queueable function also knows the internal allocation scheme&n; * of the packets for each device&n; */
DECL|function|scsi_allocate_device
id|Scsi_Cmnd
op_star
id|scsi_allocate_device
(paren
r_struct
id|request
op_star
op_star
id|reqp
comma
id|Scsi_Device
op_star
id|device
comma
r_int
id|wait
)paren
(brace
id|kdev_t
id|dev
suffix:semicolon
r_struct
id|request
op_star
id|req
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tablesize
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|bhp
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCwait
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Cmnd
op_star
id|found
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
id|panic
(paren
l_string|&quot;No device passed to scsi_allocate_device().&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reqp
)paren
id|req
op_assign
op_star
id|reqp
suffix:semicolon
multiline_comment|/* See if this request has already been queued by an interrupt routine */
r_if
c_cond
(paren
id|req
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|dev
op_assign
id|req-&gt;rq_dev
suffix:semicolon
)brace
r_else
id|dev
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unused */
id|host
op_assign
id|device-&gt;host
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
op_logical_and
id|SCSI_BLOCK
c_func
(paren
id|device
comma
id|host
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
l_int|1
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;single_lun
)paren
(brace
id|SCpnt
op_assign
id|device-&gt;device_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt
)paren
(brace
id|SCwait
op_assign
id|SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_break
suffix:semicolon
)brace
id|SCpnt
op_assign
id|SCpnt-&gt;next
suffix:semicolon
)brace
)brace
r_else
(brace
id|SCpnt
op_assign
id|device-&gt;device_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;channel
op_eq
id|device-&gt;channel
op_logical_and
id|SCpnt-&gt;target
op_eq
id|device-&gt;id
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;lun
op_eq
id|device-&gt;lun
)paren
(brace
id|SCwait
op_assign
id|SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|found
op_eq
l_int|NULL
op_logical_and
id|SCpnt-&gt;request.rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
id|found
op_assign
id|SCpnt
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * I think that we should really limit things to one&n;&t;&t;&t; * outstanding command per device - this is what tends&n;                         * to trip up buggy firmware.&n;&t;&t;&t; */
id|found
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|SCpnt
op_assign
id|SCpnt-&gt;next
suffix:semicolon
)brace
id|SCpnt
op_assign
id|found
suffix:semicolon
)brace
multiline_comment|/* See if this request has already been queued by an interrupt routine&n;&t; */
r_if
c_cond
(paren
id|req
op_logical_and
(paren
id|req-&gt;rq_status
op_eq
id|RQ_INACTIVE
op_logical_or
id|req-&gt;rq_dev
op_ne
id|dev
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
op_logical_or
id|SCpnt-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
)paren
multiline_comment|/* Might have changed */
(brace
r_if
c_cond
(paren
id|wait
op_logical_and
id|SCwait
op_logical_and
id|SCwait-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
multiline_comment|/* FIXME!!!! */
id|sleep_on
c_func
(paren
op_amp
id|device-&gt;device_wait
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
multiline_comment|/* FIXME!!!! */
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCwait
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to allocate device channel %d,&quot;
l_string|&quot; target %d, lun %d&bslash;n&quot;
comma
id|device-&gt;channel
comma
id|device-&gt;id
comma
id|device-&gt;lun
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;No device found in scsi_allocate_device&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|req
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|SCpnt-&gt;request
comma
id|req
comma
r_sizeof
(paren
r_struct
id|request
)paren
)paren
suffix:semicolon
id|tablesize
op_assign
id|device-&gt;host-&gt;sg_tablesize
suffix:semicolon
id|bhp
op_assign
id|bh
op_assign
id|req-&gt;bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tablesize
)paren
(brace
id|bh
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Take a quick look through the table to see how big it is.&n;&t;&t; * We already have our copy of req, so we can mess with that&n;&t;&t; * if we want to.&n;&t;&t; */
r_while
c_loop
(paren
id|req-&gt;nr_sectors
op_logical_and
id|bh
)paren
(brace
id|bhp
op_assign
id|bhp-&gt;b_reqnext
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bhp
op_logical_or
op_logical_neg
id|CONTIGUOUS_BUFFERS
c_func
(paren
id|bh
comma
id|bhp
)paren
)paren
(brace
id|tablesize
op_decrement
suffix:semicolon
)brace
id|req-&gt;nr_sectors
op_sub_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|req-&gt;sector
op_add_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tablesize
)paren
(brace
r_break
suffix:semicolon
)brace
id|bh
op_assign
id|bhp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|req-&gt;nr_sectors
op_logical_and
id|bh
op_logical_and
id|bh-&gt;b_reqnext
)paren
(brace
multiline_comment|/* Any leftovers? */
id|SCpnt-&gt;request.bhtail
op_assign
id|bh
suffix:semicolon
id|req-&gt;bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
multiline_comment|/* Divide request */
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
id|bh
op_assign
id|req-&gt;bh
suffix:semicolon
multiline_comment|/* Now reset things so that req looks OK */
id|SCpnt-&gt;request.nr_sectors
op_sub_assign
id|req-&gt;nr_sectors
suffix:semicolon
id|req-&gt;current_nr_sectors
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|req-&gt;buffer
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Wait until whole thing done*/
)brace
r_else
(brace
id|req-&gt;rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
op_star
id|reqp
op_assign
id|req-&gt;next
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|wait_for_request
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* And no one is waiting for this&n;&t;&t;&t;&t;&t;      * to complete */
)brace
id|atomic_inc
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Activating command for device %d (%d)&bslash;n&quot;
comma
id|SCpnt-&gt;target
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the scatter-gather flag */
id|SCpnt-&gt;old_use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No default transfer size */
id|SCpnt-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do not flag underflow conditions */
multiline_comment|/* Since not everyone seems to set the device info correctly&n;     * before Scsi_Cmnd gets send out to scsi_do_command, we do it here.&n;     * FIXME(eric) This doesn&squot;t make any sense.&n;     */
id|SCpnt-&gt;channel
op_assign
id|device-&gt;channel
suffix:semicolon
id|SCpnt-&gt;lun
op_assign
id|device-&gt;lun
suffix:semicolon
id|SCpnt-&gt;target
op_assign
id|device-&gt;id
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_INITIALIZING
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_HIGHLEVEL
suffix:semicolon
r_return
id|SCpnt
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_release_command&n; *&n; * Purpose:     Release a command block.&n; *&n; * Arguments:   SCpnt - command block we are releasing.&n; *&n; * Notes:       The command block can no longer be used by the caller once&n; *              this funciton is called.  This is in effect the inverse&n; *              of scsi_allocate_device/scsi_request_queueable.&n; */
r_void
DECL|function|scsi_release_command
id|scsi_release_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_UNUSED
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_NOBODY
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Deactivating command for device %d (active=%d, failed=%d)&bslash;n&quot;
comma
id|SCpnt-&gt;target
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
comma
id|SCpnt-&gt;host-&gt;host_failed
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;host_failed
op_ne
l_int|0
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Error handler thread %d %d&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;in_recovery
comma
id|SCpnt-&gt;host-&gt;eh_active
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * If the host is having troubles, then look to see if this was the last&n;   * command that might have failed.  If so, wake up the error handler.&n;   */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;in_recovery
op_logical_and
op_logical_neg
id|SCpnt-&gt;host-&gt;eh_active
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
op_eq
id|SCpnt-&gt;host-&gt;host_failed
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Waking error handler thread (%d)&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;eh_wait-&gt;count
)paren
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
id|SCpnt-&gt;host-&gt;eh_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is inline because we have stack problemes if we recurse to deeply.&n; */
DECL|function|internal_cmnd
r_inline
r_int
id|internal_cmnd
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
macro_line|#ifdef DEBUG_DELAY
r_int
r_int
id|clock
suffix:semicolon
macro_line|#endif
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_int
id|rtn
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
macro_line|#if DEBUG
r_int
r_int
op_star
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __mips__
id|__asm__
id|__volatile__
(paren
l_string|&quot;move&bslash;t%0,$31&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
)paren
suffix:semicolon
macro_line|#else
id|ret
op_assign
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
multiline_comment|/* Assign a unique nonzero serial_number. */
r_if
c_cond
(paren
op_increment
id|serial_number
op_eq
l_int|0
)paren
id|serial_number
op_assign
l_int|1
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
id|serial_number
suffix:semicolon
multiline_comment|/*&n;     * We will wait MIN_RESET_DELAY clock ticks after the last reset so&n;     * we can avoid the drive not being ready.&n;     */
id|timeout
op_assign
id|host-&gt;last_reset
op_plus
id|MIN_RESET_DELAY
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
OL
id|timeout
)paren
(brace
r_int
id|ticks_remaining
op_assign
id|timeout
op_minus
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE: This may be executed from within an interrupt&n;&t; * handler!  This is bad, but for now, it&squot;ll do.  The irq&n;&t; * level of the interrupt handler has been masked out by the&n;&t; * platform dependent interrupt handling code already, so the&n;&t; * sti() here will not cause another call to the SCSI host&squot;s&n;&t; * interrupt handler (assuming there is one irq-level per&n;&t; * host).&n;&t; */
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|ticks_remaining
op_ge
l_int|0
)paren
id|udelay
c_func
(paren
l_int|1000000
op_div
id|HZ
)paren
suffix:semicolon
id|host-&gt;last_reset
op_assign
id|jiffies
op_minus
id|MIN_RESET_DELAY
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|host-&gt;hostt-&gt;use_new_eh_code
)paren
(brace
id|scsi_add_timer
c_func
(paren
id|SCpnt
comma
id|SCpnt-&gt;timeout_per_command
comma
id|scsi_times_out
)paren
suffix:semicolon
)brace
r_else
(brace
id|scsi_add_timer
c_func
(paren
id|SCpnt
comma
id|SCpnt-&gt;timeout_per_command
comma
id|scsi_old_times_out
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * We will use a queued command if possible, otherwise we will emulate the&n;     * queuing and calling of completion function ourselves.&n;     */
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;internal_cmnd (host = %d, channel = %d, target = %d, &quot;
l_string|&quot;command = %p, buffer = %p, &bslash;nbufflen = %d, done = %p)&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;bufflen
comma
id|SCpnt-&gt;done
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_QUEUED
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;can_queue
)paren
(brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;queuecommand : routine at %p&bslash;n&quot;
comma
id|host-&gt;hostt-&gt;queuecommand
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;         * Use the old error handling code if we haven&squot;t converted the driver&n;         * to use the new one yet.  Note - only the new queuecommand variant&n;         * passes a meaningful return value.&n;         */
r_if
c_cond
(paren
id|host-&gt;hostt-&gt;use_new_eh_code
)paren
(brace
id|rtn
op_assign
id|host-&gt;hostt-&gt;queuecommand
(paren
id|SCpnt
comma
id|scsi_done
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_ne
l_int|0
)paren
(brace
id|scsi_mlqueue_insert
c_func
(paren
id|SCpnt
comma
id|SCSI_MLQUEUE_HOST_BUSY
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|host-&gt;hostt-&gt;queuecommand
(paren
id|SCpnt
comma
id|scsi_old_done
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|temp
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;command() :  routine at %p&bslash;n&quot;
comma
id|host-&gt;hostt-&gt;command
)paren
)paren
suffix:semicolon
id|temp
op_assign
id|host-&gt;hostt-&gt;command
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|temp
suffix:semicolon
macro_line|#ifdef DEBUG_DELAY
id|clock
op_assign
id|jiffies
op_plus
l_int|4
op_star
id|HZ
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|clock
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;done(host = %d, result = %04x) : routine at %p&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|temp
comma
id|host-&gt;hostt-&gt;command
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|host-&gt;hostt-&gt;use_new_eh_code
)paren
(brace
id|scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
r_else
(brace
id|scsi_old_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
)brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;leaving internal_cmnd()&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
multiline_comment|/*&n; * scsi_do_cmd sends all the commands out to the low-level driver.  It&n; * handles the specifics required for each low level driver - ie queued&n; * or non queued.  It also prevents conflicts when different high level&n; * drivers go for the same host at the same time.&n; */
DECL|function|scsi_do_cmd
r_void
id|scsi_do_cmd
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
comma
r_int
id|timeout
comma
r_int
id|retries
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|Scsi_Device
op_star
id|device
op_assign
id|SCpnt-&gt;device
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_MIDLEVEL
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|4
comma
(brace
r_int
id|i
suffix:semicolon
r_int
id|target
op_assign
id|SCpnt-&gt;target
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi_do_cmd (host = %d, channel = %d target = %d, &quot;
l_string|&quot;buffer =%p, bufflen = %d, done = %p, timeout = %d, &quot;
l_string|&quot;retries = %d)&bslash;n&quot;
l_string|&quot;command : &quot;
comma
id|host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|target
comma
id|buffer
comma
id|bufflen
comma
id|done
comma
id|timeout
comma
id|retries
)paren
suffix:semicolon
r_for
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
op_increment
id|i
)paren
id|printk
(paren
l_string|&quot;%02x  &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
(brace
id|panic
(paren
l_string|&quot;Invalid or not present host.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * We must prevent reentrancy to the lowlevel host driver.  This prevents&n;     * it - we enter a loop until the host we want to talk to is not busy.&n;     * Race conditions are prevented, as interrupts are disabled in between the&n;     * time we check for the host being not busy, and the time we mark it busy&n;     * ourselves.&n;     */
id|SCpnt-&gt;pid
op_assign
id|scsi_pid
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|SCSI_BLOCK
c_func
(paren
(paren
id|Scsi_Device
op_star
)paren
l_int|NULL
comma
id|host
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
multiline_comment|/* FIXME!!! */
id|SCSI_SLEEP
c_func
(paren
op_amp
id|host-&gt;host_wait
comma
id|SCSI_BLOCK
c_func
(paren
(paren
id|Scsi_Device
op_star
)paren
l_int|NULL
comma
id|host
)paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
multiline_comment|/* FIXME!!! */
)brace
r_if
c_cond
(paren
id|host-&gt;block
)paren
id|host_active
op_assign
id|host
suffix:semicolon
id|host-&gt;host_busy
op_increment
suffix:semicolon
id|device-&gt;device_busy
op_increment
suffix:semicolon
multiline_comment|/*&n;     * Our own function scsi_done (which marks the host as not busy, disables&n;     * the timeout counter, etc) will be called by us or by the&n;     * scsi_hosts[host].queuecommand() function needs to also call&n;     * the completion function for the high level driver.&n;     */
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|cmnd
comma
l_int|12
)paren
suffix:semicolon
id|SCpnt-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;bufflen
op_assign
id|bufflen
suffix:semicolon
id|SCpnt-&gt;buffer
op_assign
id|buffer
suffix:semicolon
id|SCpnt-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;retries
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;allowed
op_assign
id|retries
suffix:semicolon
id|SCpnt-&gt;done
op_assign
id|done
suffix:semicolon
id|SCpnt-&gt;timeout_per_command
op_assign
id|timeout
suffix:semicolon
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|cmnd
comma
l_int|12
)paren
suffix:semicolon
multiline_comment|/* Zero the sense buffer.  Some host adapters automatically request&n;     * sense on error.  0 is not a valid sense code.&n;     */
id|memset
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|bufflen
suffix:semicolon
id|SCpnt-&gt;old_use_sg
op_assign
id|SCpnt-&gt;use_sg
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;cmd_len
op_eq
l_int|0
)paren
id|SCpnt-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|SCpnt-&gt;old_cmd_len
op_assign
id|SCpnt-&gt;cmd_len
suffix:semicolon
multiline_comment|/* Start the timer ticking.  */
id|SCpnt-&gt;internal_timeout
op_assign
id|NORMAL_TIMEOUT
suffix:semicolon
id|SCpnt-&gt;abort_reason
op_assign
l_int|0
suffix:semicolon
id|internal_cmnd
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
(paren
l_string|&quot;Leaving scsi_do_cmd()&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This function is the mid-level interrupt routine, which decides how&n; *  to handle error conditions.  Each invocation of this function must&n; *  do one and *only* one of the following:&n; *&n; *      1) Insert command in BH queue.&n; *      2) Activate error handler for host.&n; *&n; * FIXME(eric) - I am concerned about stack overflow (still).  An interrupt could&n; * come while we are processing the bottom queue, which would cause another command&n; * to be stuffed onto the bottom queue, and it would in turn be processed as that&n; * interrupt handler is returning.  Given a sufficiently steady rate of returning&n; * commands, this could cause the stack to overflow.  I am not sure what is the most&n; * appropriate solution here - we should probably keep a depth count, and not process&n; * any commands while we still have a bottom handler active higher in the stack.&n; *&n; * There is currently code in the bottom half handler to monitor recursion in the bottom&n; * handler and report if it ever happens.  If this becomes a problem, it won&squot;t be hard to&n; * engineer something to deal with it so that only the outer layer ever does any real&n; * processing.&n; */
r_void
DECL|function|scsi_done
id|scsi_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;   * We don&squot;t have to worry about this one timing out any more.&n;   */
id|scsi_delete_timer
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n;   * First, see whether this command already timed out.  If so, we ignore&n;   * the response.  We treat it as if the command never finished.&n;   */
r_if
c_cond
(paren
id|SCpnt-&gt;state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Ignoring completion of %p due to timeout status&quot;
comma
id|SCpnt
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_BHQUEUE
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_BH_HANDLER
suffix:semicolon
id|SCpnt-&gt;bh_next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;   * Next, put this command in the BH queue.  All processing of the command&n;   * past this point will take place with interrupts turned on.&n;   * We start by atomicly swapping the pointer into the queue head slot.&n;   * If it was NULL before, then everything is fine, and we are done&n;   * (this is the normal case).  If it was not NULL, then we block interrupts,&n;   * and link them together.&n;   * We need a spinlock here, or compare and exchange if we can reorder incoming&n;   * Scsi_Cmnds, as it happens pretty often scsi_done is called multiple times&n;   * before bh is serviced. -jj&n;   */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|scsi_bh_queue_spin
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_bh_queue_head
)paren
(brace
id|scsi_bh_queue_head
op_assign
id|SCpnt
suffix:semicolon
id|scsi_bh_queue_tail
op_assign
id|SCpnt
suffix:semicolon
)brace
r_else
(brace
id|scsi_bh_queue_tail-&gt;bh_next
op_assign
id|SCpnt
suffix:semicolon
id|scsi_bh_queue_tail
op_assign
id|SCpnt
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|scsi_bh_queue_spin
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;   * Mark the bottom half handler to be run.&n;   */
id|mark_bh
c_func
(paren
id|SCSI_BH
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Procedure:   scsi_bottom_half_handler&n; *&n; * Purpose:     Called after we have finished processing interrupts, it&n; *              performs post-interrupt handling for commands that may&n; *              have completed.&n; *&n; * Notes:       This is called with all interrupts enabled.  This should reduce&n; *              interrupt latency, stack depth, and reentrancy of the low-level&n; *              drivers.&n; */
DECL|function|scsi_bottom_half_handler
r_void
id|scsi_bottom_half_handler
c_func
(paren
r_void
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCnext
suffix:semicolon
r_static
id|atomic_t
id|recursion_depth
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_while
c_loop
(paren
l_int|1
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;       * If the counter is &gt; 0, that means that there is another interrupt handler&n;       * out there somewhere processing commands.  We don&squot;t want to get these guys&n;       * nested as this can lead to stack overflow problems, and there isn&squot;t any&n;       * real sense in it anyways.&n;       */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|recursion_depth
)paren
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI bottom half recursion depth = %d &bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|recursion_depth
)paren
)paren
suffix:semicolon
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;SCSI bottom half recursion depth = %d &bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|recursion_depth
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;       * We need to hold the spinlock, so that nobody is tampering with the queue. -jj&n;       * We will process everything we find in the list here.&n;       */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|scsi_bh_queue_spin
comma
id|flags
)paren
suffix:semicolon
id|SCpnt
op_assign
id|scsi_bh_queue_head
suffix:semicolon
id|scsi_bh_queue_head
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|scsi_bh_queue_spin
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|recursion_depth
)paren
suffix:semicolon
id|SCnext
op_assign
id|SCpnt-&gt;bh_next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCnext
)paren
(brace
id|SCnext
op_assign
id|SCpnt-&gt;bh_next
suffix:semicolon
r_switch
c_cond
(paren
id|scsi_decide_disposition
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_case
id|SUCCESS
suffix:colon
multiline_comment|/*&n;               * Add to BH queue.&n;               */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command finished %d %d 0x%x&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_busy
comma
id|SCpnt-&gt;host-&gt;host_failed
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|scsi_finish_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NEEDS_RETRY
suffix:colon
multiline_comment|/*&n;               * We only come in here if we want to retry a command.  The&n;               * test to see whether the command should be retried should be&n;               * keeping track of the number of tries, so we don&squot;t end up looping,&n;               * of course.&n;               */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command needs retry %d %d 0x%x&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_busy
comma
id|SCpnt-&gt;host-&gt;host_failed
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|scsi_retry_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ADD_TO_MLQUEUE
suffix:colon
multiline_comment|/* &n;               * This typically happens for a QUEUE_FULL message -&n;               * typically only when the queue depth is only&n;               * approximate for a given device.  Adding a command&n;               * to the queue for the device will prevent further commands&n;               * from being sent to the device, so we shouldn&squot;t end up&n;               * with tons of things being sent down that shouldn&squot;t be.&n;               */
id|scsi_mlqueue_insert
c_func
(paren
id|SCpnt
comma
id|SCSI_MLQUEUE_DEVICE_BUSY
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;               * Here we have a fatal error of some sort.  Turn it over to&n;               * the error handler.&n;               */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command failed %p %x active=%d busy=%d failed=%d&bslash;n&quot;
comma
id|SCpnt
comma
id|SCpnt-&gt;result
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
comma
id|SCpnt-&gt;host-&gt;host_busy
comma
id|SCpnt-&gt;host-&gt;host_failed
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;               * Dump the sense information too.&n;               */
r_if
c_cond
(paren
(paren
id|status_byte
(paren
id|SCpnt-&gt;result
)paren
op_amp
id|CHECK_CONDITION
)paren
op_ne
l_int|0
)paren
(brace
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|print_sense
c_func
(paren
l_string|&quot;bh&quot;
comma
id|SCpnt
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;eh_wait
op_ne
l_int|NULL
)paren
(brace
id|SCpnt-&gt;host-&gt;host_failed
op_increment
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_ERROR_HANDLER
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_FAILED
suffix:semicolon
id|SCpnt-&gt;host-&gt;in_recovery
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;                   * If the host is having troubles, then look to see if this was the last&n;                   * command that might have failed.  If so, wake up the error handler.&n;                   */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
op_eq
id|SCpnt-&gt;host-&gt;host_failed
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Waking error handler thread (%d)&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;eh_wait-&gt;count
)paren
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
id|SCpnt-&gt;host-&gt;eh_wait
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;                   * We only get here if the error recovery thread has died.&n;                   */
id|scsi_finish_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* for(; SCpnt...) */
id|atomic_dec
c_func
(paren
op_amp
id|recursion_depth
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* while(1==1) */
)brace
multiline_comment|/*&n; * Function:    scsi_retry_command&n; *&n; * Purpose:     Send a command back to the low level to be retried.&n; *&n; * Notes:       This command is always executed in the context of the&n; *              bottom half handler, or the error handler thread. Low&n; *              level drivers should not become re-entrant as a result of&n; *              this.&n; */
r_int
DECL|function|scsi_retry_command
id|scsi_retry_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|SCpnt-&gt;buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|SCpnt-&gt;bufflen
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|SCpnt-&gt;old_cmd_len
suffix:semicolon
r_return
id|internal_cmnd
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_finish_command&n; *&n; * Purpose:     Pass command off to upper layer for finishing of I/O&n; *              request, waking processes that are waiting on results,&n; *              etc.&n; */
r_void
DECL|function|scsi_finish_command
id|scsi_finish_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|Scsi_Device
op_star
id|device
suffix:semicolon
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|device
op_assign
id|SCpnt-&gt;device
suffix:semicolon
id|host-&gt;host_busy
op_decrement
suffix:semicolon
multiline_comment|/* Indicate that we are free */
id|device-&gt;device_busy
op_decrement
suffix:semicolon
multiline_comment|/* Decrement device usage counter. */
r_if
c_cond
(paren
id|host-&gt;block
op_logical_and
id|host-&gt;host_busy
op_eq
l_int|0
)paren
(brace
id|host_active
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* For block devices &quot;wake_up&quot; is done in end_scsi_request */
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
op_ne
id|SCSI_DISK_MAJOR
op_logical_and
id|MAJOR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
op_ne
id|SCSI_CDROM_MAJOR
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
id|next
op_assign
id|host-&gt;block
suffix:semicolon
id|next
op_ne
id|host
suffix:semicolon
id|next
op_assign
id|next-&gt;block
)paren
id|wake_up
c_func
(paren
op_amp
id|next-&gt;host_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * Now try and drain the mid-level queue if any commands have been&n;     * inserted.  Check to see whether the queue even has anything in&n;     * it first, as otherwise this is useless overhead.&n;     */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;pending_commands
op_ne
l_int|NULL
)paren
(brace
id|scsi_mlqueue_finish
c_func
(paren
id|SCpnt-&gt;host
comma
id|SCpnt-&gt;device
)paren
suffix:semicolon
)brace
id|wake_up
c_func
(paren
op_amp
id|host-&gt;host_wait
)paren
suffix:semicolon
multiline_comment|/*&n;     * If we have valid sense information, then some kind of recovery&n;     * must have taken place.  Make a note of this.&n;     */
r_if
c_cond
(paren
id|scsi_sense_valid
c_func
(paren
id|SCpnt
)paren
)paren
(brace
id|SCpnt-&gt;result
op_or_assign
(paren
id|DRIVER_SENSE
op_lshift
l_int|24
)paren
suffix:semicolon
)brace
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Notifying upper driver of completion for device %d %x&bslash;n&quot;
comma
id|SCpnt-&gt;device-&gt;id
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_HIGHLEVEL
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_FINISHED
suffix:semicolon
id|SCpnt-&gt;done
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MODULES
r_static
r_int
id|scsi_register_host
c_func
(paren
id|Scsi_Host_Template
op_star
)paren
suffix:semicolon
r_static
r_void
id|scsi_unregister_host
c_func
(paren
id|Scsi_Host_Template
op_star
)paren
suffix:semicolon
macro_line|#endif
DECL|function|scsi_malloc
r_void
op_star
id|scsi_malloc
c_func
(paren
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|nbits
comma
id|mask
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|len
op_mod
id|SECTOR_SIZE
op_ne
l_int|0
op_logical_or
id|len
OG
id|PAGE_SIZE
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|nbits
op_assign
id|len
op_rshift
l_int|9
suffix:semicolon
id|mask
op_assign
(paren
l_int|1
op_lshift
id|nbits
)paren
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|i
op_increment
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
op_le
id|SECTORS_PER_PAGE
op_minus
id|nbits
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|dma_malloc_freelist
(braket
id|i
)braket
op_amp
(paren
id|mask
op_lshift
id|j
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|dma_malloc_freelist
(braket
id|i
)braket
op_or_assign
(paren
id|mask
op_lshift
id|j
)paren
suffix:semicolon
id|scsi_dma_free_sectors
op_sub_assign
id|nbits
suffix:semicolon
macro_line|#ifdef DEBUG
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;SMalloc: %d %p [From:%p]&bslash;n&quot;
comma
id|len
comma
id|dma_malloc_pages
(braket
id|i
)braket
op_plus
(paren
id|j
op_lshift
l_int|9
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SMalloc: %d %p [From:%p]&bslash;n&quot;
comma
id|len
comma
id|dma_malloc_pages
(braket
id|i
)braket
op_plus
(paren
id|j
op_lshift
l_int|9
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|dma_malloc_pages
(braket
id|i
)braket
op_plus
(paren
id|j
op_lshift
l_int|9
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Nope.  No more */
)brace
DECL|function|scsi_free
r_int
id|scsi_free
c_func
(paren
r_void
op_star
id|obj
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|page
comma
id|sector
comma
id|nbits
comma
id|mask
suffix:semicolon
macro_line|#ifdef DEBUG
r_int
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __mips__
id|__asm__
id|__volatile__
(paren
l_string|&quot;move&bslash;t%0,$31&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
)paren
suffix:semicolon
macro_line|#else
id|ret
op_assign
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;scsi_free %p %d&bslash;n&quot;
comma
id|obj
comma
id|len
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;SFree: %p %d&bslash;n&quot;
comma
id|obj
comma
id|len
)paren
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|page
op_assign
l_int|0
suffix:semicolon
id|page
OL
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|page
op_increment
)paren
(brace
r_int
r_int
id|page_addr
op_assign
(paren
r_int
r_int
)paren
id|dma_malloc_pages
(braket
id|page
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|obj
op_ge
id|page_addr
op_logical_and
(paren
r_int
r_int
)paren
id|obj
OL
id|page_addr
op_plus
id|PAGE_SIZE
)paren
(brace
id|sector
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|obj
)paren
op_minus
id|page_addr
)paren
op_rshift
l_int|9
suffix:semicolon
id|nbits
op_assign
id|len
op_rshift
l_int|9
suffix:semicolon
id|mask
op_assign
(paren
l_int|1
op_lshift
id|nbits
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mask
op_lshift
id|sector
)paren
op_ge
(paren
l_int|1
op_lshift
id|SECTORS_PER_PAGE
)paren
)paren
id|panic
(paren
l_string|&quot;scsi_free:Bad memory alignment&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dma_malloc_freelist
(braket
id|page
)braket
op_amp
(paren
id|mask
op_lshift
id|sector
)paren
)paren
op_ne
(paren
id|mask
op_lshift
id|sector
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;scsi_free(obj=%p, len=%d) called from %08lx&bslash;n&quot;
comma
id|obj
comma
id|len
comma
id|ret
)paren
suffix:semicolon
macro_line|#endif
id|panic
c_func
(paren
l_string|&quot;scsi_free:Trying to free unused memory&quot;
)paren
suffix:semicolon
)brace
id|scsi_dma_free_sectors
op_add_assign
id|nbits
suffix:semicolon
id|dma_malloc_freelist
(braket
id|page
)braket
op_and_assign
op_complement
(paren
id|mask
op_lshift
id|sector
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|panic
c_func
(paren
l_string|&quot;scsi_free:Bad offset&quot;
)paren
suffix:semicolon
)brace
DECL|variable|scsi_loadable_module_flag
r_int
id|scsi_loadable_module_flag
suffix:semicolon
multiline_comment|/* Set after we scan builtin drivers */
DECL|function|scsi_init_malloc
r_void
op_star
id|scsi_init_malloc
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|gfp_mask
)paren
(brace
r_void
op_star
id|retval
suffix:semicolon
multiline_comment|/*&n;     * For buffers used by the DMA pool, we assume page aligned &n;     * structures.&n;     */
r_if
c_cond
(paren
(paren
id|size
op_mod
id|PAGE_SIZE
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|order
comma
id|a_size
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
comma
id|a_size
op_assign
id|PAGE_SIZE
suffix:semicolon
id|a_size
OL
id|size
suffix:semicolon
id|order
op_increment
comma
id|a_size
op_lshift_assign
l_int|1
)paren
suffix:semicolon
id|retval
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|gfp_mask
op_or
id|GFP_DMA
comma
id|order
)paren
suffix:semicolon
)brace
r_else
id|retval
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
id|memset
c_func
(paren
id|retval
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|scsi_init_free
r_void
id|scsi_init_free
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
r_int
id|size
)paren
(brace
multiline_comment|/*&n;     * We need this special code here because the DMA pool assumes&n;     * page aligned data.  Besides, it is wasteful to allocate&n;     * page sized chunks with kmalloc.&n;     */
r_if
c_cond
(paren
(paren
id|size
op_mod
id|PAGE_SIZE
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|order
comma
id|a_size
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
comma
id|a_size
op_assign
id|PAGE_SIZE
suffix:semicolon
id|a_size
OL
id|size
suffix:semicolon
id|order
op_increment
comma
id|a_size
op_lshift_assign
l_int|1
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|ptr
comma
id|order
)paren
suffix:semicolon
)brace
r_else
id|kfree
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
DECL|function|scsi_build_commandblocks
r_void
id|scsi_build_commandblocks
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SDpnt-&gt;host
suffix:semicolon
r_int
id|j
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;queue_depth
op_eq
l_int|0
)paren
id|SDpnt-&gt;queue_depth
op_assign
id|host-&gt;cmd_per_lun
suffix:semicolon
id|SDpnt-&gt;device_queue
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|SDpnt-&gt;queue_depth
suffix:semicolon
id|j
op_increment
)paren
(brace
id|SCpnt
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|scsi_init_malloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Cmnd
)paren
comma
id|GFP_ATOMIC
op_or
(paren
id|host-&gt;unchecked_isa_dma
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|SCpnt-&gt;eh_timeout
comma
l_int|0
comma
r_sizeof
(paren
id|SCpnt-&gt;eh_timeout
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;host
op_assign
id|host
suffix:semicolon
id|SCpnt-&gt;device
op_assign
id|SDpnt
suffix:semicolon
id|SCpnt-&gt;target
op_assign
id|SDpnt-&gt;id
suffix:semicolon
id|SCpnt-&gt;lun
op_assign
id|SDpnt-&gt;lun
suffix:semicolon
id|SCpnt-&gt;channel
op_assign
id|SDpnt-&gt;channel
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
id|SCpnt-&gt;host_wait
op_assign
id|FALSE
suffix:semicolon
id|SCpnt-&gt;device_wait
op_assign
id|FALSE
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;old_use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;old_cmd_len
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;next
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SDpnt-&gt;device_queue
op_assign
id|SCpnt
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_UNUSED
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_NOBODY
suffix:semicolon
)brace
id|SDpnt-&gt;has_cmdblocks
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#ifndef MODULE /* { */
multiline_comment|/*&n; * scsi_dev_init() is our initialization routine, which in turn calls host&n; * initialization, bus scanning, and sd/st initialization routines.&n; * This is only used at boot time.&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|scsi_dev_init
c_func
(paren
r_void
)paren
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
macro_line|#ifdef FOO_ON_YOU
r_return
suffix:semicolon
macro_line|#endif
multiline_comment|/* Yes we&squot;re here... */
macro_line|#if CONFIG_PROC_FS
id|dispatch_scsi_info_ptr
op_assign
id|dispatch_scsi_info
suffix:semicolon
macro_line|#endif
multiline_comment|/* Init a few things so we can &quot;malloc&quot; memory. */
id|scsi_loadable_module_flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Register the /proc/scsi/scsi entry */
macro_line|#if CONFIG_PROC_FS
id|proc_scsi_register
c_func
(paren
l_int|0
comma
op_amp
id|proc_scsi_scsi
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* initialize all hosts */
id|scsi_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * This is where the processing takes place for most everything&n;     * when commands are completed.  Until we do this, we will not be able&n;     * to queue any commands.&n;     */
id|init_bh
c_func
(paren
id|SCSI_BH
comma
id|scsi_bottom_half_handler
)paren
suffix:semicolon
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
id|scan_scsis
c_func
(paren
id|shpnt
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* scan for scsi devices */
r_if
c_cond
(paren
id|shpnt-&gt;select_queue_depths
op_ne
l_int|NULL
)paren
(paren
id|shpnt-&gt;select_queue_depths
)paren
(paren
id|shpnt
comma
id|shpnt-&gt;host_queue
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi : detected &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;dev_noticed
op_logical_and
id|sdtpnt-&gt;name
)paren
id|printk
c_func
(paren
l_string|&quot;%d SCSI %s%s &quot;
comma
id|sdtpnt-&gt;dev_noticed
comma
id|sdtpnt-&gt;name
comma
(paren
id|sdtpnt-&gt;dev_noticed
op_ne
l_int|1
)paren
ques
c_cond
l_string|&quot;s&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;total.&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;init
op_logical_and
id|sdtpnt-&gt;dev_noticed
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;init
)paren
(paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
multiline_comment|/* SDpnt-&gt;scsi_request_fn = NULL; */
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;attach
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;attach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SDpnt-&gt;attached
)paren
(brace
id|scsi_build_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;     * This should build the DMA pool.&n;     */
id|resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * OK, now we finish the initialization by doing spin-up, read&n;     * capacity, etc, etc&n;     */
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;finish
op_logical_and
id|sdtpnt-&gt;nr_dev
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;finish
)paren
(paren
)paren
suffix:semicolon
)brace
id|scsi_loadable_module_flag
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* MODULE */   /* } */
DECL|function|print_inquiry
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|data
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Vendor: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Model: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Rev: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
OL
l_int|36
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Type:   %s &quot;
comma
id|i
OL
id|MAX_SCSI_DEVICE_CODE
ques
c_cond
id|scsi_device_types
(braket
id|i
)braket
suffix:colon
l_string|&quot;Unknown          &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                 ANSI SCSI revision: %02x&quot;
comma
id|data
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|data
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot; CCS&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|scsi_proc_info
r_int
id|scsi_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|SDTpnt
suffix:semicolon
id|Scsi_Device
op_star
id|scd
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|HBA_ptr
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_int
id|host
comma
id|channel
comma
id|id
comma
id|lun
suffix:semicolon
r_int
id|size
comma
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|inout
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;         * First, see if there are any attached devices or not.&n;         */
r_for
c_loop
(paren
id|HBA_ptr
op_assign
id|scsi_hostlist
suffix:semicolon
id|HBA_ptr
suffix:semicolon
id|HBA_ptr
op_assign
id|HBA_ptr-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|HBA_ptr-&gt;host_queue
op_ne
l_int|NULL
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Attached devices: %s&bslash;n&quot;
comma
(paren
id|HBA_ptr
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;none&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_for
c_loop
(paren
id|HBA_ptr
op_assign
id|scsi_hostlist
suffix:semicolon
id|HBA_ptr
suffix:semicolon
id|HBA_ptr
op_assign
id|HBA_ptr-&gt;next
)paren
(brace
macro_line|#if 0
id|size
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;scsi%2d: %s&bslash;n&quot;
comma
(paren
r_int
)paren
id|HBA_ptr-&gt;host_no
comma
id|HBA_ptr-&gt;hostt-&gt;procname
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|scd
op_assign
id|HBA_ptr-&gt;host_queue
suffix:semicolon
id|scd
suffix:semicolon
id|scd
op_assign
id|scd-&gt;next
)paren
(brace
id|proc_print_scsidevice
c_func
(paren
id|scd
comma
id|buffer
comma
op_amp
id|size
comma
id|len
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
r_goto
id|stop_output
suffix:semicolon
)brace
)brace
id|stop_output
suffix:colon
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start slop */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
multiline_comment|/* Ending slop */
r_return
(paren
id|len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer
op_logical_or
id|length
OL
l_int|11
op_logical_or
id|strncmp
c_func
(paren
l_string|&quot;scsi&quot;
comma
id|buffer
comma
l_int|4
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;     * Usage: echo &quot;scsi dump #N&quot; &gt; /proc/scsi/scsi&n;     * to dump status of all scsi commands.  The number is used to specify the level&n;     * of detail in the dump.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
l_string|&quot;dump&quot;
comma
id|buffer
op_plus
l_int|5
comma
l_int|4
)paren
)paren
(brace
r_int
r_int
id|level
suffix:semicolon
id|p
op_assign
id|buffer
op_plus
l_int|10
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
id|level
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|scsi_dump_status
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Usage: echo &quot;scsi log token #N&quot; &gt; /proc/scsi/scsi&n;     * where token is one of [error,scan,mlqueue,mlcomplete,llqueue,&n;     * llcomplete,hlqueue,hlcomplete]&n;     */
macro_line|#if CONFIG_SCSI_LOGGING /* { */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
l_string|&quot;log&quot;
comma
id|buffer
op_plus
l_int|5
comma
l_int|3
)paren
)paren
(brace
r_char
op_star
id|token
suffix:semicolon
r_int
r_int
id|level
suffix:semicolon
id|p
op_assign
id|buffer
op_plus
l_int|9
suffix:semicolon
id|token
op_assign
id|p
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_ne
l_char|&squot; &squot;
op_logical_and
op_star
id|p
op_ne
l_char|&squot;&bslash;t&squot;
op_logical_and
op_star
id|p
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|p
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|token
comma
l_string|&quot;all&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;                 * Turn on absolutely everything.&n;                 */
id|scsi_logging_level
op_assign
op_complement
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|token
comma
l_string|&quot;none&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;                 * Turn off absolutely everything.&n;                 */
id|scsi_logging_level
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|level
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;             * Now figure out what to do with it.&n;             */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;error&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_ERROR_RECOVERY_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;timeout&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_TIMEOUT_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;scan&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_SCAN_BUS_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;mlqueue&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_MLQUEUE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;mlcomplete&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_MLCOMPLETE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;llqueue&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_LLQUEUE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;llcomplete&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_LLCOMPLETE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;hlqueue&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_HLQUEUE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;hlcomplete&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_HLCOMPLETE_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|token
comma
l_string|&quot;ioctl&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_SET_IOCTL_LOGGING
c_func
(paren
id|level
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;scsi logging level set to 0x%8.8x&bslash;n&quot;
comma
id|scsi_logging_level
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SCSI_LOGGING */ /* } */
multiline_comment|/*&n;     * Usage: echo &quot;scsi add-single-device 0 1 2 3&quot; &gt;/proc/scsi/scsi&n;     * with  &quot;0 1 2 3&quot; replaced by your &quot;Host Channel Id Lun&quot;.&n;     * Consider this feature BETA.&n;     *     CAUTION: This is not for hotplugging your peripherals. As&n;     *     SCSI was not designed for this you could damage your&n;     *     hardware !&n;     * However perhaps it is legal to switch on an&n;     * already connected device. It is perhaps not&n;     * guaranteed this device doesn&squot;t corrupt an ongoing data transfer.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
l_string|&quot;add-single-device&quot;
comma
id|buffer
op_plus
l_int|5
comma
l_int|17
)paren
)paren
(brace
id|p
op_assign
id|buffer
op_plus
l_int|23
suffix:semicolon
id|host
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|channel
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|id
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|lun
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi singledevice %d %d %d %d&bslash;n&quot;
comma
id|host
comma
id|channel
comma
id|id
comma
id|lun
)paren
suffix:semicolon
r_for
c_loop
(paren
id|HBA_ptr
op_assign
id|scsi_hostlist
suffix:semicolon
id|HBA_ptr
suffix:semicolon
id|HBA_ptr
op_assign
id|HBA_ptr-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|HBA_ptr-&gt;host_no
op_eq
id|host
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|HBA_ptr
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_for
c_loop
(paren
id|scd
op_assign
id|HBA_ptr-&gt;host_queue
suffix:semicolon
id|scd
suffix:semicolon
id|scd
op_assign
id|scd-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|scd-&gt;channel
op_eq
id|channel
op_logical_and
id|scd-&gt;id
op_eq
id|id
op_logical_and
id|scd-&gt;lun
op_eq
id|lun
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|scd
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
multiline_comment|/* We do not yet support unplugging */
id|scan_scsis
(paren
id|HBA_ptr
comma
l_int|1
comma
id|channel
comma
id|id
comma
id|lun
)paren
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
multiline_comment|/*&n;     * Usage: echo &quot;scsi remove-single-device 0 1 2 3&quot; &gt;/proc/scsi/scsi&n;     * with  &quot;0 1 2 3&quot; replaced by your &quot;Host Channel Id Lun&quot;.&n;     *&n;     * Consider this feature pre-BETA.&n;     *&n;     *     CAUTION: This is not for hotplugging your peripherals. As&n;     *     SCSI was not designed for this you could damage your&n;     *     hardware and thoroughly confuse the SCSI subsystem.&n;     *&n;     */
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
l_string|&quot;remove-single-device&quot;
comma
id|buffer
op_plus
l_int|5
comma
l_int|20
)paren
)paren
(brace
id|p
op_assign
id|buffer
op_plus
l_int|26
suffix:semicolon
id|host
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|channel
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|id
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|lun
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|HBA_ptr
op_assign
id|scsi_hostlist
suffix:semicolon
id|HBA_ptr
suffix:semicolon
id|HBA_ptr
op_assign
id|HBA_ptr-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|HBA_ptr-&gt;host_no
op_eq
id|host
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|HBA_ptr
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_for
c_loop
(paren
id|scd
op_assign
id|HBA_ptr-&gt;host_queue
suffix:semicolon
id|scd
suffix:semicolon
id|scd
op_assign
id|scd-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|scd-&gt;channel
op_eq
id|channel
op_logical_and
id|scd-&gt;id
op_eq
id|id
op_logical_and
id|scd-&gt;lun
op_eq
id|lun
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|scd
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* there is no such device attached */
r_if
c_cond
(paren
id|scd-&gt;access_count
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|SDTpnt
op_assign
id|scsi_devicelist
suffix:semicolon
r_while
c_loop
(paren
id|SDTpnt
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|SDTpnt-&gt;detach
)paren
(brace
(paren
op_star
id|SDTpnt-&gt;detach
)paren
(paren
id|scd
)paren
suffix:semicolon
)brace
id|SDTpnt
op_assign
id|SDTpnt-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scd-&gt;attached
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;             * Nobody is using this device any more.&n;             * Free all of the command structures.&n;             */
r_for
c_loop
(paren
id|SCpnt
op_assign
id|scd-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
id|scd-&gt;device_queue
op_assign
id|SCpnt-&gt;next
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|SCpnt
comma
r_sizeof
(paren
op_star
id|SCpnt
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Now we can remove the device structure */
r_if
c_cond
(paren
id|scd-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|scd-&gt;next-&gt;prev
op_assign
id|scd-&gt;prev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scd-&gt;prev
op_ne
l_int|NULL
)paren
(brace
id|scd-&gt;prev-&gt;next
op_assign
id|scd-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HBA_ptr-&gt;host_queue
op_eq
id|scd
)paren
(brace
id|HBA_ptr-&gt;host_queue
op_assign
id|scd-&gt;next
suffix:semicolon
)brace
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|scd
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Go through the device list and recompute the most appropriate size&n; * for the dma pool.  Then grab more memory (as required).&n; */
DECL|function|resize_dma_pool
r_static
r_void
id|resize_dma_pool
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|FreeSectorBitmap
op_star
id|new_dma_malloc_freelist
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|new_dma_sectors
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|new_need_isa_buffer
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
op_star
id|new_dma_malloc_pages
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_hostlist
)paren
(brace
multiline_comment|/*&n;&t; * Free up the DMA pool.&n;&t; */
r_if
c_cond
(paren
id|scsi_dma_free_sectors
op_ne
id|dma_sectors
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;SCSI DMA pool memory leak %d %d&bslash;n&quot;
comma
id|scsi_dma_free_sectors
comma
id|dma_sectors
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scsi_init_free
c_func
(paren
id|dma_malloc_pages
(braket
id|i
)braket
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dma_malloc_pages
)paren
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_pages
comma
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|dma_malloc_pages
)paren
)paren
suffix:semicolon
id|dma_malloc_pages
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_freelist
)paren
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_freelist
comma
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|dma_malloc_freelist
)paren
)paren
suffix:semicolon
id|dma_malloc_freelist
op_assign
l_int|NULL
suffix:semicolon
id|dma_sectors
op_assign
l_int|0
suffix:semicolon
id|scsi_dma_free_sectors
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Next, check to see if we need to extend the DMA buffer pool */
id|new_dma_sectors
op_assign
l_int|2
op_star
id|SECTORS_PER_PAGE
suffix:semicolon
multiline_comment|/* Base value we use */
r_if
c_cond
(paren
id|__pa
c_func
(paren
id|high_memory
)paren
op_minus
l_int|1
OG
id|ISA_DMA_THRESHOLD
)paren
id|need_isa_bounce_buffers
op_assign
l_int|1
suffix:semicolon
r_else
id|need_isa_bounce_buffers
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|scsi_devicelist
)paren
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
id|new_dma_sectors
op_add_assign
id|SECTORS_PER_PAGE
suffix:semicolon
)brace
multiline_comment|/* Increment for each host */
r_for
c_loop
(paren
id|host
op_assign
id|scsi_hostlist
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
multiline_comment|/*&n;             * sd and sr drivers allocate scatterlists.&n;             * sr drivers may allocate for each command 1x2048 or 2x1024 extra&n;             * buffers for 2k sector size and 1k fs.&n;             * sg driver allocates buffers &lt; 4k.&n;             * st driver does not need buffers from the dma pool.&n;             * estimate 4k buffer/command for devices of unknown type (should panic).&n;             */
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_eq
id|TYPE_WORM
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_ROM
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_DISK
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_MOD
)paren
(brace
id|new_dma_sectors
op_add_assign
(paren
(paren
id|host-&gt;sg_tablesize
op_star
r_sizeof
(paren
r_struct
id|scatterlist
)paren
op_plus
l_int|511
)paren
op_rshift
l_int|9
)paren
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_eq
id|TYPE_WORM
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_ROM
)paren
id|new_dma_sectors
op_add_assign
(paren
l_int|2048
op_rshift
l_int|9
)paren
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_eq
id|TYPE_SCANNER
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_PROCESSOR
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_MEDIUM_CHANGER
)paren
(brace
id|new_dma_sectors
op_add_assign
(paren
l_int|4096
op_rshift
l_int|9
)paren
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_ne
id|TYPE_TAPE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: unknown device type %d&bslash;n&quot;
comma
id|SDpnt-&gt;type
)paren
suffix:semicolon
id|new_dma_sectors
op_add_assign
(paren
l_int|4096
op_rshift
l_int|9
)paren
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|host-&gt;unchecked_isa_dma
op_logical_and
id|need_isa_bounce_buffers
op_logical_and
id|SDpnt-&gt;type
op_ne
id|TYPE_TAPE
)paren
(brace
id|new_dma_sectors
op_add_assign
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
op_star
id|host-&gt;sg_tablesize
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
id|new_need_isa_buffer
op_increment
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef DEBUG_INIT
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: needed dma sectors = %d&bslash;n&quot;
comma
id|new_dma_sectors
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* limit DMA memory to 32MB: */
id|new_dma_sectors
op_assign
(paren
id|new_dma_sectors
op_plus
l_int|15
)paren
op_amp
l_int|0xfff0
suffix:semicolon
multiline_comment|/*&n;     * We never shrink the buffers - this leads to&n;     * race conditions that I would rather not even think&n;     * about right now.&n;     */
r_if
c_cond
(paren
id|new_dma_sectors
OL
id|dma_sectors
)paren
(brace
id|new_dma_sectors
op_assign
id|dma_sectors
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_dma_sectors
)paren
(brace
id|size
op_assign
(paren
id|new_dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
id|FreeSectorBitmap
)paren
suffix:semicolon
id|new_dma_malloc_freelist
op_assign
(paren
id|FreeSectorBitmap
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|memset
c_func
(paren
id|new_dma_malloc_freelist
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|size
op_assign
(paren
id|new_dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|new_dma_malloc_pages
)paren
suffix:semicolon
id|new_dma_malloc_pages
op_assign
(paren
r_int
r_char
op_star
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|memset
c_func
(paren
id|new_dma_malloc_pages
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * If we need more buffers, expand the list.&n;     */
r_if
c_cond
(paren
id|new_dma_sectors
OG
id|dma_sectors
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|i
OL
id|new_dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|new_dma_malloc_pages
(braket
id|i
)braket
op_assign
(paren
r_int
r_char
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|PAGE_SIZE
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* When we dick with the actual DMA list, we need to&n;     * protect things&n;     */
r_if
c_cond
(paren
id|dma_malloc_freelist
)paren
(brace
id|size
op_assign
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
id|FreeSectorBitmap
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_dma_malloc_freelist
comma
id|dma_malloc_freelist
comma
id|size
)paren
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_freelist
comma
id|size
)paren
suffix:semicolon
)brace
id|dma_malloc_freelist
op_assign
id|new_dma_malloc_freelist
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_pages
)paren
(brace
id|size
op_assign
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|dma_malloc_pages
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_dma_malloc_pages
comma
id|dma_malloc_pages
comma
id|size
)paren
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_pages
comma
id|size
)paren
suffix:semicolon
)brace
id|scsi_dma_free_sectors
op_add_assign
id|new_dma_sectors
op_minus
id|dma_sectors
suffix:semicolon
id|dma_malloc_pages
op_assign
id|new_dma_malloc_pages
suffix:semicolon
id|dma_sectors
op_assign
id|new_dma_sectors
suffix:semicolon
id|scsi_need_isa_buffer
op_assign
id|new_need_isa_buffer
suffix:semicolon
macro_line|#ifdef DEBUG_INIT
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: dma free sectors   = %d&bslash;n&quot;
comma
id|scsi_dma_free_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: dma sectors        = %d&bslash;n&quot;
comma
id|dma_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: need isa buffers   = %d&bslash;n&quot;
comma
id|scsi_need_isa_buffer
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_MODULES&t;&t;/* a big #ifdef block... */
multiline_comment|/*&n; * This entry point should be called by a loadable module if it is trying&n; * add a low level scsi driver to the system.&n; */
DECL|function|scsi_register_host
r_static
r_int
id|scsi_register_host
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|pcount
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
id|tpnt-&gt;next
op_logical_or
op_logical_neg
id|tpnt-&gt;detect
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Must be already loaded, or&n;&t;&t;&t;&t;&t;       * no detect routine available&n;&t;&t;&t;&t;&t;       */
id|pcount
op_assign
id|next_scsi_host
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tpnt-&gt;present
op_assign
id|tpnt
op_member_access_from_pointer
id|detect
c_func
(paren
id|tpnt
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|pcount
op_eq
id|next_scsi_host
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;present
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Failure to register low-level scsi driver&quot;
)paren
suffix:semicolon
id|scsi_unregister_host
c_func
(paren
id|tpnt
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;             * The low-level driver failed to register a driver.  We&n;&t;     *  can do this now.&n;&t;     */
id|scsi_register
c_func
(paren
id|tpnt
comma
l_int|0
)paren
suffix:semicolon
)brace
id|tpnt-&gt;next
op_assign
id|scsi_hosts
suffix:semicolon
multiline_comment|/* Add to the linked list */
id|scsi_hosts
op_assign
id|tpnt
suffix:semicolon
multiline_comment|/* Add the new driver to /proc/scsi */
macro_line|#if CONFIG_PROC_FS
id|build_proc_dir_entries
c_func
(paren
id|tpnt
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;         * Add the kernel threads for each host adapter that will&n;         * handle error correction.&n;         */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_eq
id|tpnt
op_logical_and
id|shpnt-&gt;hostt-&gt;use_new_eh_code
)paren
(brace
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
id|shpnt-&gt;eh_notify
op_assign
op_amp
id|sem
suffix:semicolon
id|kernel_thread
c_func
(paren
(paren
r_int
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|scsi_error_handler
comma
(paren
r_void
op_star
)paren
id|shpnt
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;                 * Now wait for the kernel error thread to initialize itself&n;                 * as it might be needed when we scan the bus.&n;                 */
id|down
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|shpnt-&gt;eh_notify
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_eq
id|tpnt
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;info
)paren
(brace
id|name
op_assign
id|tpnt
op_member_access_from_pointer
id|info
c_func
(paren
id|shpnt
)paren
suffix:semicolon
)brace
r_else
(brace
id|name
op_assign
id|tpnt-&gt;name
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;scsi%d : %s&bslash;n&quot;
comma
multiline_comment|/* And print a little message */
id|shpnt-&gt;host_no
comma
id|name
)paren
suffix:semicolon
)brace
)brace
id|printk
(paren
l_string|&quot;scsi : %d host%s.&bslash;n&quot;
comma
id|next_scsi_host
comma
(paren
id|next_scsi_host
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|scsi_make_blocked_list
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* The next step is to call scan_scsis here.  This generates the&n;&t; * Scsi_Devices entries&n;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_eq
id|tpnt
)paren
(brace
id|scan_scsis
c_func
(paren
id|shpnt
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;select_queue_depths
op_ne
l_int|NULL
)paren
(brace
(paren
id|shpnt-&gt;select_queue_depths
)paren
(paren
id|shpnt
comma
id|shpnt-&gt;host_queue
)paren
suffix:semicolon
)brace
)brace
)brace
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|sdtpnt-&gt;init
op_logical_and
id|sdtpnt-&gt;dev_noticed
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;init
)paren
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;         * Next we create the Scsi_Cmnd structures for this host &n;         */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
r_if
c_cond
(paren
id|SDpnt-&gt;host-&gt;hostt
op_eq
id|tpnt
)paren
(brace
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;attach
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;attach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SDpnt-&gt;attached
)paren
(brace
id|scsi_build_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Now that we have all of the devices, resize the DMA pool,&n;&t; * as required.  */
id|resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* This does any final handling that is required. */
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|sdtpnt-&gt;finish
op_logical_and
id|sdtpnt-&gt;nr_dev
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;finish
)paren
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#if defined(USE_STATIC_SCSI_MEMORY)
id|printk
(paren
l_string|&quot;SCSI memory: total %ldKb, used %ldKb, free %ldKb.&bslash;n&quot;
comma
(paren
id|scsi_memory_upper_value
op_minus
id|scsi_memory_lower_value
)paren
op_div
l_int|1024
comma
(paren
id|scsi_init_memory_start
op_minus
id|scsi_memory_lower_value
)paren
op_div
l_int|1024
comma
(paren
id|scsi_memory_upper_value
op_minus
id|scsi_init_memory_start
)paren
op_div
l_int|1024
)paren
suffix:semicolon
macro_line|#endif
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Similarly, this entry point should be called by a loadable module if it&n; * is trying to remove a low level scsi driver from the system.&n; *&n; * Note - there is a fatal flaw in the deregister module function.&n; * There is no way to return a code that says &squot;I cannot be unloaded now&squot;.&n; * The system relies entirely upon usage counts that are maintained,&n; * and the assumption is that if the usage count is 0, then the module&n; * can be unloaded.&n; */
DECL|function|scsi_unregister_host
r_static
r_void
id|scsi_unregister_host
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|online_status
suffix:semicolon
r_int
id|pcount
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt1
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|sh1
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
id|Scsi_Host_Template
op_star
id|SHT
suffix:semicolon
id|Scsi_Host_Template
op_star
id|SHTp
suffix:semicolon
multiline_comment|/*&n;     * First verify that this host adapter is completely free with no pending&n;     * commands &n;     */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SDpnt-&gt;host-&gt;hostt
op_eq
id|tpnt
op_logical_and
id|SDpnt-&gt;host-&gt;hostt-&gt;module
op_logical_and
id|SDpnt-&gt;host-&gt;hostt-&gt;module-&gt;usecount
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* &n;             * FIXME(eric) - We need to find a way to notify the&n;             * low level driver that we are shutting down - via the&n;             * special device entry that still needs to get added. &n;             *&n;             * Is detach interface below good enough for this?&n;             */
)brace
)brace
multiline_comment|/*&n;     * FIXME(eric) put a spinlock on this.  We force all of the devices offline&n;     * to help prevent race conditions where other hosts/processors could try and&n;     * get in and queue a command.&n;     */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SDpnt-&gt;host-&gt;hostt
op_eq
id|tpnt
)paren
(brace
id|SDpnt-&gt;online
op_assign
id|FALSE
suffix:semicolon
)brace
)brace
)brace
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_ne
id|tpnt
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
multiline_comment|/*&n;             * Loop over all of the commands associated with the device.  If any of&n;             * them are busy, then set the state back to inactive and bail.&n;             */
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
id|online_status
op_assign
id|SDpnt-&gt;online
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI device not inactive - state=%d, id=%d&bslash;n&quot;
comma
id|SCpnt-&gt;request.rq_status
comma
id|SCpnt-&gt;target
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt1
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt1
suffix:semicolon
id|SDpnt1
op_assign
id|SDpnt1-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt1-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_eq
id|RQ_SCSI_DISCONNECTING
)paren
(brace
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
)brace
)brace
id|SDpnt-&gt;online
op_assign
id|online_status
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Device busy???&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;                 * No, this device is really free.  Mark it as such, and&n;                 * continue on.&n;                 */
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_DISCONNECTING
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_DISCONNECTING
suffix:semicolon
multiline_comment|/* Mark as busy */
)brace
)brace
)brace
multiline_comment|/* Next we detach the high level drivers from the Scsi_Device structures */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_ne
id|tpnt
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;detach
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;detach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
multiline_comment|/* If something still attached, punt */
r_if
c_cond
(paren
id|SDpnt-&gt;attached
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attached usage count = %d&bslash;n&quot;
comma
id|SDpnt-&gt;attached
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;     * Next, kill the kernel error recovery thread for this host.&n;     */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_eq
id|tpnt
op_logical_and
id|shpnt-&gt;hostt-&gt;use_new_eh_code
op_logical_and
id|shpnt-&gt;ehandler
op_ne
l_int|NULL
)paren
(brace
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
id|shpnt-&gt;eh_notify
op_assign
op_amp
id|sem
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|shpnt-&gt;ehandler
comma
l_int|1
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|shpnt-&gt;eh_notify
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* Next we free up the Scsi_Cmnd structures for this host */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_ne
id|tpnt
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
)paren
(brace
r_while
c_loop
(paren
id|SDpnt-&gt;device_queue
)paren
(brace
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue-&gt;next
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|SDpnt-&gt;device_queue
comma
r_sizeof
(paren
id|Scsi_Cmnd
)paren
)paren
suffix:semicolon
id|SDpnt-&gt;device_queue
op_assign
id|SCpnt
suffix:semicolon
)brace
id|SDpnt-&gt;has_cmdblocks
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Next free up the Scsi_Device structures for this host */
id|shpnt-&gt;host_queue
op_assign
id|SDpnt-&gt;next
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|SDpnt
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Next we go through and remove the instances of the individual hosts&n;     * that were detected */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|sh1
)paren
(brace
id|sh1
op_assign
id|shpnt-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_eq
id|tpnt
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;loaded_as_module
)paren
(brace
id|pcount
op_assign
id|next_scsi_host
suffix:semicolon
multiline_comment|/* Remove the /proc/scsi directory entry */
macro_line|#if CONFIG_PROC_FS
id|proc_scsi_unregister
c_func
(paren
id|tpnt-&gt;proc_dir
comma
id|shpnt-&gt;host_no
op_plus
id|PROC_SCSI_FILE
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tpnt-&gt;release
)paren
(brace
(paren
op_star
id|tpnt-&gt;release
)paren
(paren
id|shpnt
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This is the default case for the release function.&n;&t;&t;     * It should do the right thing for most correctly&n;&t;&t;     * written host adapters.&n;&t;&t;     */
r_if
c_cond
(paren
id|shpnt-&gt;irq
)paren
id|free_irq
c_func
(paren
id|shpnt-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;dma_channel
op_ne
l_int|0xff
)paren
id|free_dma
c_func
(paren
id|shpnt-&gt;dma_channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;io_port
op_logical_and
id|shpnt-&gt;n_io_port
)paren
id|release_region
c_func
(paren
id|shpnt-&gt;io_port
comma
id|shpnt-&gt;n_io_port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pcount
op_eq
id|next_scsi_host
)paren
(brace
id|scsi_unregister
c_func
(paren
id|shpnt
)paren
suffix:semicolon
)brace
id|tpnt-&gt;present
op_decrement
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;     * If there are absolutely no more hosts left, it is safe&n;     * to completely nuke the DMA pool.  The resize operation will&n;     * do the right thing and free everything.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|scsi_hosts
)paren
(brace
id|resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;scsi : %d host%s.&bslash;n&quot;
comma
id|next_scsi_host
comma
(paren
id|next_scsi_host
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
suffix:semicolon
macro_line|#if defined(USE_STATIC_SCSI_MEMORY)
id|printk
(paren
l_string|&quot;SCSI memory: total %ldKb, used %ldKb, free %ldKb.&bslash;n&quot;
comma
(paren
id|scsi_memory_upper_value
op_minus
id|scsi_memory_lower_value
)paren
op_div
l_int|1024
comma
(paren
id|scsi_init_memory_start
op_minus
id|scsi_memory_lower_value
)paren
op_div
l_int|1024
comma
(paren
id|scsi_memory_upper_value
op_minus
id|scsi_init_memory_start
)paren
op_div
l_int|1024
)paren
suffix:semicolon
macro_line|#endif
id|scsi_make_blocked_list
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* There were some hosts that were loaded at boot time, so we cannot&n;       do any more than this */
r_if
c_cond
(paren
id|tpnt-&gt;present
)paren
r_return
suffix:semicolon
multiline_comment|/* OK, this is the very last step.  Remove this host adapter from the&n;       linked list. */
r_for
c_loop
(paren
id|SHTp
op_assign
l_int|NULL
comma
id|SHT
op_assign
id|scsi_hosts
suffix:semicolon
id|SHT
suffix:semicolon
id|SHTp
op_assign
id|SHT
comma
id|SHT
op_assign
id|SHT-&gt;next
)paren
r_if
c_cond
(paren
id|SHT
op_eq
id|tpnt
)paren
(brace
r_if
c_cond
(paren
id|SHTp
)paren
(brace
id|SHTp-&gt;next
op_assign
id|SHT-&gt;next
suffix:semicolon
)brace
r_else
id|scsi_hosts
op_assign
id|SHT-&gt;next
suffix:semicolon
id|SHT-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Rebuild the /proc/scsi directory entries */
macro_line|#if CONFIG_PROC_FS
id|proc_scsi_unregister
c_func
(paren
id|tpnt-&gt;proc_dir
comma
id|tpnt-&gt;proc_dir-&gt;low_ino
)paren
suffix:semicolon
macro_line|#endif
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/*&n; * This entry point should be called by a loadable module if it is trying&n; * add a high level scsi driver to the system.&n; */
DECL|function|scsi_register_device_module
r_static
r_int
id|scsi_register_device_module
c_func
(paren
r_struct
id|Scsi_Device_Template
op_star
id|tpnt
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_if
c_cond
(paren
id|tpnt-&gt;next
)paren
r_return
l_int|1
suffix:semicolon
id|scsi_register_device
c_func
(paren
id|tpnt
)paren
suffix:semicolon
multiline_comment|/*&n;     * First scan the devices that we know about, and see if we notice them.&n;     */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;detect
)paren
(brace
id|SDpnt-&gt;attached
op_add_assign
(paren
op_star
id|tpnt-&gt;detect
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;     * If any of the devices would match this driver, then perform the&n;     * init function.&n;     */
r_if
c_cond
(paren
id|tpnt-&gt;init
op_logical_and
id|tpnt-&gt;dev_noticed
)paren
r_if
c_cond
(paren
(paren
op_star
id|tpnt-&gt;init
)paren
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;     * Now actually connect the devices to the new driver.&n;     */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;attach
)paren
(brace
(paren
op_star
id|tpnt-&gt;attach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;             * If this driver attached to the device, and don&squot;t have any&n;             * command blocks for this device, allocate some.&n;             */
r_if
c_cond
(paren
id|SDpnt-&gt;attached
op_logical_and
id|SDpnt-&gt;has_cmdblocks
op_eq
l_int|0
)paren
(brace
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
id|scsi_build_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;     * This does any final handling that is required.&n;     */
r_if
c_cond
(paren
id|tpnt-&gt;finish
op_logical_and
id|tpnt-&gt;nr_dev
)paren
(brace
(paren
op_star
id|tpnt-&gt;finish
)paren
(paren
)paren
suffix:semicolon
)brace
id|resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scsi_unregister_device
r_static
r_int
id|scsi_unregister_device
c_func
(paren
r_struct
id|Scsi_Device_Template
op_star
id|tpnt
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|spnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|prev_spnt
suffix:semicolon
multiline_comment|/*&n;     * If we are busy, this is not going to fly.&n;     */
r_if
c_cond
(paren
id|tpnt-&gt;module-&gt;usecount
op_ne
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * Next, detach the devices from the driver.&n;     */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;detach
)paren
(brace
(paren
op_star
id|tpnt-&gt;detach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SDpnt-&gt;attached
op_eq
l_int|0
)paren
(brace
id|SDpnt-&gt;online
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/*&n;&t;         * Nobody is using this device any more.  Free all of the&n;&t;         * command structures.&n;&t;         */
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt
op_eq
id|SDpnt-&gt;device_queue
)paren
(brace
id|SDpnt-&gt;device_queue
op_assign
id|SCpnt-&gt;next
suffix:semicolon
)brace
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|SCpnt
comma
r_sizeof
(paren
op_star
id|SCpnt
)paren
)paren
suffix:semicolon
)brace
id|SDpnt-&gt;has_cmdblocks
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;     * Extract the template from the linked list.&n;     */
id|spnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|prev_spnt
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|spnt
op_ne
id|tpnt
)paren
(brace
id|prev_spnt
op_assign
id|spnt
suffix:semicolon
id|spnt
op_assign
id|spnt-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev_spnt
op_eq
l_int|NULL
)paren
(brace
id|scsi_devicelist
op_assign
id|tpnt-&gt;next
suffix:semicolon
)brace
r_else
id|prev_spnt-&gt;next
op_assign
id|spnt-&gt;next
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
multiline_comment|/*&n;     * Final cleanup for the driver is done in the driver sources in the&n;     * cleanup function.&n;     */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scsi_register_module
r_int
id|scsi_register_module
c_func
(paren
r_int
id|module_type
comma
r_void
op_star
id|ptr
)paren
(brace
r_switch
c_cond
(paren
id|module_type
)paren
(brace
r_case
id|MODULE_SCSI_HA
suffix:colon
r_return
id|scsi_register_host
c_func
(paren
(paren
id|Scsi_Host_Template
op_star
)paren
id|ptr
)paren
suffix:semicolon
multiline_comment|/* Load upper level device handler of some kind */
r_case
id|MODULE_SCSI_DEV
suffix:colon
macro_line|#ifdef CONFIG_KMOD
r_if
c_cond
(paren
id|scsi_hosts
op_eq
l_int|NULL
)paren
id|request_module
c_func
(paren
l_string|&quot;scsi_hostadapter&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|scsi_register_device_module
c_func
(paren
(paren
r_struct
id|Scsi_Device_Template
op_star
)paren
id|ptr
)paren
suffix:semicolon
multiline_comment|/* The rest of these are not yet implemented */
multiline_comment|/* Load constants.o */
r_case
id|MODULE_SCSI_CONST
suffix:colon
multiline_comment|/* Load specialized ioctl handler for some device.  Intended for&n;&t; * cdroms that have non-SCSI2 audio command sets. */
r_case
id|MODULE_SCSI_IOCTL
suffix:colon
r_default
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|scsi_unregister_module
r_void
id|scsi_unregister_module
c_func
(paren
r_int
id|module_type
comma
r_void
op_star
id|ptr
)paren
(brace
r_switch
c_cond
(paren
id|module_type
)paren
(brace
r_case
id|MODULE_SCSI_HA
suffix:colon
id|scsi_unregister_host
c_func
(paren
(paren
id|Scsi_Host_Template
op_star
)paren
id|ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODULE_SCSI_DEV
suffix:colon
id|scsi_unregister_device
c_func
(paren
(paren
r_struct
id|Scsi_Device_Template
op_star
)paren
id|ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* The rest of these are not yet implemented. */
r_case
id|MODULE_SCSI_CONST
suffix:colon
r_case
id|MODULE_SCSI_IOCTL
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
r_return
suffix:semicolon
)brace
macro_line|#endif&t;&t;/* CONFIG_MODULES */
multiline_comment|/*&n; * Function:    scsi_dump_status&n; *&n; * Purpose:     Brain dump of scsi system, used for problem solving.&n; *&n; * Arguments:   level - used to indicate level of detail.&n; *&n; * Notes:       The level isn&squot;t used at all yet, but we need to find some way&n; *              of sensibly logging varying degrees of information.  A quick one-line&n; *              display of each command, plus the status would be most useful.&n; *&n; *              This does depend upon CONFIG_SCSI_LOGGING - I do want some way of turning&n; *              it all off if the user wants a lean and mean kernel.  It would probably&n; *              also be useful to allow the user to specify one single host to be dumped.&n; *              A second argument to the function would be useful for that purpose.&n; *&n; *              FIXME - some formatting of the output into tables would be very handy.&n; */
r_static
r_void
DECL|function|scsi_dump_status
id|scsi_dump_status
c_func
(paren
r_int
id|level
)paren
(brace
macro_line|#if CONFIG_PROC_FS
macro_line|#if CONFIG_SCSI_LOGGING /* { */
r_int
id|i
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Dump of scsi host parameters:&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %d %d %d : %d %p&bslash;n&quot;
comma
id|shpnt-&gt;host_failed
comma
id|shpnt-&gt;host_busy
comma
id|atomic_read
c_func
(paren
op_amp
id|shpnt-&gt;host_active
)paren
comma
id|shpnt-&gt;host_blocked
comma
id|shpnt-&gt;pending_commands
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Dump of scsi command parameters:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;h:c:t:l (dev sect nsect cnumsec sg) (ret all flg) (to/cmd to ito) cmd snse result&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
multiline_comment|/*  (0) h:c:t:l (dev sect nsect cnumsec sg) (ret all flg) (to/cmd to ito) cmd snse result %d %x      */
id|printk
c_func
(paren
l_string|&quot;(%3d) %2d:%1d:%2d:%2d (%6s %4ld %4ld %4ld %4x %1d) (%1d %1d 0x%2x) (%4d %4d %4d) 0x%2.2x 0x%2.2x 0x%8.8x&bslash;n&quot;
comma
id|i
op_increment
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|kdevname
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
comma
id|SCpnt-&gt;request.sector
comma
id|SCpnt-&gt;request.nr_sectors
comma
id|SCpnt-&gt;request.current_nr_sectors
comma
id|SCpnt-&gt;request.rq_status
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;retries
comma
id|SCpnt-&gt;allowed
comma
id|SCpnt-&gt;flags
comma
id|SCpnt-&gt;timeout_per_command
comma
id|SCpnt-&gt;timeout
comma
id|SCpnt-&gt;internal_timeout
comma
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
comma
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
comma
id|SCpnt-&gt;result
)paren
suffix:semicolon
)brace
)brace
)brace
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
multiline_comment|/* Now dump the request lists for each block device */
id|printk
c_func
(paren
l_string|&quot;Dump of pending block device requests&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_BLKDEV
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|blk_dev
(braket
id|i
)braket
dot
id|current_request
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d: &quot;
comma
id|i
)paren
suffix:semicolon
id|req
op_assign
id|blk_dev
(braket
id|i
)braket
dot
id|current_request
suffix:semicolon
r_while
c_loop
(paren
id|req
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(%s %d %ld %ld %ld) &quot;
comma
id|kdevname
c_func
(paren
id|req-&gt;rq_dev
)paren
comma
id|req-&gt;cmd
comma
id|req-&gt;sector
comma
id|req-&gt;nr_sectors
comma
id|req-&gt;current_nr_sectors
)paren
suffix:semicolon
id|req
op_assign
id|req-&gt;next
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;wait_for_request = %p&bslash;n&quot;
comma
id|wait_for_request
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SCSI_LOGGING */ /* } */
macro_line|#endif /* CONFIG_PROC_FS */
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
multiline_comment|/*&n;     * This makes /proc/scsi visible.&n;     */
macro_line|#if CONFIG_PROC_FS
id|dispatch_scsi_info_ptr
op_assign
id|dispatch_scsi_info
suffix:semicolon
macro_line|#endif
id|scsi_loadable_module_flag
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Register the /proc/scsi/scsi entry */
macro_line|#if CONFIG_PROC_FS
id|proc_scsi_register
c_func
(paren
l_int|0
comma
op_amp
id|proc_scsi_scsi
)paren
suffix:semicolon
macro_line|#endif
id|dma_sectors
op_assign
id|PAGE_SIZE
op_div
id|SECTOR_SIZE
suffix:semicolon
id|scsi_dma_free_sectors
op_assign
id|dma_sectors
suffix:semicolon
multiline_comment|/*&n;     * Set up a minimal DMA buffer list - this will be used during scan_scsis&n;     * in some cases.&n;     */
multiline_comment|/* One bit per sector to indicate free/busy */
id|size
op_assign
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
id|FreeSectorBitmap
)paren
suffix:semicolon
id|dma_malloc_freelist
op_assign
(paren
r_int
r_char
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dma_malloc_freelist
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* One pointer per page for the page list */
id|dma_malloc_pages
op_assign
(paren
r_int
r_char
op_star
op_star
)paren
id|scsi_init_malloc
c_func
(paren
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|dma_malloc_pages
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|dma_malloc_pages
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_char
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|PAGE_SIZE
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
multiline_comment|/*&n;     * This is where the processing takes place for most everything&n;     * when commands are completed.&n;     */
id|init_bh
c_func
(paren
id|SCSI_BH
comma
id|scsi_bottom_half_handler
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|remove_bh
c_func
(paren
id|SCSI_BH
)paren
suffix:semicolon
macro_line|#if CONFIG_PROC_FS
id|proc_scsi_unregister
c_func
(paren
l_int|0
comma
id|PROC_SCSI_SCSI
)paren
suffix:semicolon
multiline_comment|/* No, we&squot;re not here anymore. Don&squot;t show the /proc/scsi files. */
id|dispatch_scsi_info_ptr
op_assign
l_int|0L
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;     * Free up the DMA pool.&n;     */
id|resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: nil&n; * tab-width: 8&n; * End:&n; */
eof
