multiline_comment|/*&n; *&t;scsi.c Copyright (C) 1992 Drew Eckhardt &n; *&t;       Copyright (C) 1993, 1994 Eric Youngdale&n; *&n; *&t;generic mid-level SCSI driver by&n; *&t;&t;Drew Eckhardt &n; *&n; *&t;&lt;drew@colorado.edu&gt;&n; *&n; *&t;Bug correction thanks go to : &n; *&t;&t;Rik Faith &lt;faith@cs.unc.edu&gt;&n; *&t;&t;Tommy Thorn &lt;tthorn&gt;&n; *&t;&t;Thomas Wuensche &lt;tw@fgb1.fgb.mw.tu-muenchen.de&gt;&n; * &n; *       Modified by Eric Youngdale ericy@cais.com to&n; *       add scatter-gather, multiple outstanding request, and other&n; *       enhancements.&n; */
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &quot;../block/blk.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;constants.h&quot;
multiline_comment|/*&n;static const char RCSid[] = &quot;$Header: /usr/src/linux/kernel/blk_drv/scsi/RCS/scsi.c,v 1.5 1993/09/24 12:45:18 drew Exp drew $&quot;;&n;*/
multiline_comment|/* Command groups 3 and 4 are reserved and should never be used.  */
DECL|variable|scsi_command_size
r_const
r_int
r_char
id|scsi_command_size
(braket
l_int|8
)braket
op_assign
(brace
l_int|6
comma
l_int|10
comma
l_int|10
comma
l_int|12
comma
l_int|12
comma
l_int|12
comma
l_int|10
comma
l_int|10
)brace
suffix:semicolon
DECL|macro|INTERNAL_ERROR
mdefine_line|#define INTERNAL_ERROR (panic (&quot;Internal error in file %s, line %d.&bslash;n&quot;, __FILE__, __LINE__))
r_static
r_void
id|scsi_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_static
r_int
id|update_timeout
(paren
id|Scsi_Cmnd
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|data
)paren
suffix:semicolon
r_static
r_void
id|scsi_times_out
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
DECL|variable|time_start
r_static
r_int
id|time_start
suffix:semicolon
DECL|variable|time_elapsed
r_static
r_int
id|time_elapsed
suffix:semicolon
DECL|macro|MAX_SCSI_DEVICE_CODE
mdefine_line|#define MAX_SCSI_DEVICE_CODE 10
DECL|variable|scsi_device_types
r_const
r_char
op_star
r_const
id|scsi_device_types
(braket
id|MAX_SCSI_DEVICE_CODE
)braket
op_assign
(brace
l_string|&quot;Direct-Access    &quot;
comma
l_string|&quot;Sequential-Access&quot;
comma
l_string|&quot;Printer          &quot;
comma
l_string|&quot;Processor        &quot;
comma
l_string|&quot;WORM             &quot;
comma
l_string|&quot;CD-ROM           &quot;
comma
l_string|&quot;Scanner          &quot;
comma
l_string|&quot;Optical Device   &quot;
comma
l_string|&quot;Medium Changer   &quot;
comma
l_string|&quot;Communications   &quot;
)brace
suffix:semicolon
multiline_comment|/*&n;&t;global variables : &n;&t;scsi_devices an array of these specifying the address for each &n;&t;(host, id, LUN)&n;*/
DECL|variable|scsi_devices
id|Scsi_Device
op_star
id|scsi_devices
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Process ID of SCSI commands */
DECL|variable|scsi_pid
r_int
r_int
id|scsi_pid
op_assign
l_int|0
suffix:semicolon
DECL|variable|generic_sense
r_static
r_int
r_char
id|generic_sense
(braket
l_int|6
)braket
op_assign
(brace
id|REQUEST_SENSE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|255
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* This variable is merely a hook so that we can debug the kernel with gdb. */
DECL|variable|last_cmnd
id|Scsi_Cmnd
op_star
id|last_cmnd
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; *&t;As the scsi do command functions are intelligent, and may need to &n; *&t;redo a command, we need to keep track of the last command &n; *&t;executed on each one.&n; */
DECL|macro|WAS_RESET
mdefine_line|#define WAS_RESET &t;0x01
DECL|macro|WAS_TIMEDOUT
mdefine_line|#define WAS_TIMEDOUT &t;0x02
DECL|macro|WAS_SENSE
mdefine_line|#define WAS_SENSE&t;0x04
DECL|macro|IS_RESETTING
mdefine_line|#define IS_RESETTING&t;0x08
DECL|macro|IS_ABORTING
mdefine_line|#define IS_ABORTING&t;0x10
DECL|macro|ASKED_FOR_SENSE
mdefine_line|#define ASKED_FOR_SENSE 0x20
multiline_comment|/*&n; *&t;This is the number  of clock ticks we should wait before we time out &n; *&t;and abort the command.  This is for  where the scsi.c module generates &n; *&t;the command, not where it originates from a higher level, in which&n; *&t;case the timeout is specified there.&n; *&n; *&t;ABORT_TIMEOUT and RESET_TIMEOUT are the timeouts for RESET and ABORT&n; *&t;respectively.&n; */
macro_line|#ifdef DEBUG_TIMEOUT
r_static
r_void
id|scsi_dump_status
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG
DECL|macro|SCSI_TIMEOUT
mdefine_line|#define SCSI_TIMEOUT 500
macro_line|#else
DECL|macro|SCSI_TIMEOUT
mdefine_line|#define SCSI_TIMEOUT 100
macro_line|#endif
macro_line|#ifdef DEBUG
DECL|macro|SENSE_TIMEOUT
mdefine_line|#define SENSE_TIMEOUT SCSI_TIMEOUT
DECL|macro|ABORT_TIMEOUT
mdefine_line|#define ABORT_TIMEOUT SCSI_TIMEOUT
DECL|macro|RESET_TIMEOUT
mdefine_line|#define RESET_TIMEOUT SCSI_TIMEOUT
macro_line|#else
DECL|macro|SENSE_TIMEOUT
mdefine_line|#define SENSE_TIMEOUT 50
DECL|macro|RESET_TIMEOUT
mdefine_line|#define RESET_TIMEOUT 50
DECL|macro|ABORT_TIMEOUT
mdefine_line|#define ABORT_TIMEOUT 50
DECL|macro|MIN_RESET_DELAY
mdefine_line|#define MIN_RESET_DELAY 100
macro_line|#endif
multiline_comment|/* The following devices are known not to tolerate a lun != 0 scan for&n;   one reason or another.  Some will respond to all luns, others will&n;   lock up. */
DECL|struct|blist
r_struct
id|blist
(brace
DECL|member|vendor
r_char
op_star
id|vendor
suffix:semicolon
DECL|member|model
r_char
op_star
id|model
suffix:semicolon
DECL|member|revision
r_char
op_star
id|revision
suffix:semicolon
multiline_comment|/* Latest revision known to be bad.  Not used yet */
)brace
suffix:semicolon
DECL|variable|blacklist
r_static
r_struct
id|blist
id|blacklist
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;CHINON&quot;
comma
l_string|&quot;CD-ROM CDS-431&quot;
comma
l_string|&quot;H42&quot;
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;CHINON&quot;
comma
l_string|&quot;CD-ROM CDS-535&quot;
comma
l_string|&quot;Q14&quot;
)brace
comma
multiline_comment|/* Lockup if polled for lun != 0 */
(brace
l_string|&quot;DENON&quot;
comma
l_string|&quot;DRD-25X&quot;
comma
l_string|&quot;V&quot;
)brace
comma
multiline_comment|/* A cdrom that locks up when probed at lun != 0 */
(brace
l_string|&quot;IMS&quot;
comma
l_string|&quot;CDD521/10&quot;
comma
l_string|&quot;2.06&quot;
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-3280&quot;
comma
l_string|&quot;PR02&quot;
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-4380S&quot;
comma
l_string|&quot;B3C&quot;
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;MXT-1240S&quot;
comma
l_string|&quot;I1.2&quot;
)brace
comma
multiline_comment|/* Locks up when LUN &gt; 0 polled */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-4170S&quot;
comma
l_string|&quot;B5A&quot;
)brace
comma
multiline_comment|/* Locks-up sometimes when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-8760S&quot;
comma
l_string|&quot;B7B&quot;
)brace
comma
multiline_comment|/* guess what? */
(brace
l_string|&quot;NEC&quot;
comma
l_string|&quot;CD-ROM DRIVE:841&quot;
comma
l_string|&quot;1.0&quot;
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;RODIME&quot;
comma
l_string|&quot;RO3000S&quot;
comma
l_string|&quot;2.33&quot;
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST157N&quot;
comma
l_string|&quot;&bslash;004|j&quot;
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1 for aha152x&n;&t;&t;&t;&t;     * controller, which causes SCSI code to reset bus.*/
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST296&quot;
comma
l_string|&quot;921&quot;
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-541&quot;
comma
l_string|&quot;4.3d&quot;
)brace
comma
(brace
l_string|&quot;TANDBERG&quot;
comma
l_string|&quot;TDC 3600&quot;
comma
l_string|&quot;U07&quot;
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1 for seagate&n;&t;&t;&t;&t; * controller, which causes SCSI code to reset bus.*/
(brace
l_string|&quot;TEXEL&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1 for seagate&n;&t;&t;&t;&t; * controller, which causes SCSI code to reset bus.*/
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;LPS525S&quot;
comma
l_string|&quot;3110&quot;
)brace
comma
multiline_comment|/* Locks sometimes if polled for lun != 0 */
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;PD1225S&quot;
comma
l_string|&quot;3110&quot;
)brace
comma
multiline_comment|/* Locks sometimes if polled for lun != 0 */
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|function|blacklisted
r_static
r_int
(def_block
id|blacklisted
c_func
(paren
r_int
r_char
op_star
id|response_data
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|pnt
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|blacklist
(braket
id|i
)braket
dot
id|vendor
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|pnt
op_assign
op_amp
id|response_data
(braket
l_int|8
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_eq
l_char|&squot; &squot;
)paren
(brace
id|pnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|blacklist
(braket
id|i
)braket
dot
id|vendor
comma
id|pnt
comma
id|strlen
c_func
(paren
id|blacklist
(braket
id|i
)braket
dot
id|vendor
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|pnt
op_assign
op_amp
id|response_data
(braket
l_int|16
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_eq
l_char|&squot; &squot;
)paren
(brace
id|pnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|blacklist
(braket
id|i
)braket
dot
id|model
comma
id|pnt
comma
id|strlen
c_func
(paren
id|blacklist
(braket
id|i
)braket
dot
id|model
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
suffix:semicolon
)brace
)def_block
suffix:semicolon
multiline_comment|/*&n; *&t;As the actual SCSI command runs in the background, we must set up a &n; *&t;flag that tells scan_scsis() when the result it has is valid.  &n; *&t;scan_scsis can set the_result to -1, and watch for it to become the &n; *&t;actual return code for that call.  the scan_scsis_done function() is &n; *&t;our user specified completion function that is passed on to the  &n; *&t;scsi_do_cmd() function.&n; */
DECL|variable|in_scan_scsis
r_volatile
r_int
id|in_scan_scsis
op_assign
l_int|0
suffix:semicolon
DECL|variable|the_result
r_static
r_int
id|the_result
suffix:semicolon
DECL|function|scan_scsis_done
r_static
r_void
id|scan_scsis_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;scan_scsis_done(%d, %06x)&bslash;n&quot;
comma
id|SCpnt-&gt;host
comma
id|SCpnt-&gt;result
)paren
suffix:semicolon
macro_line|#endif&t;
id|SCpnt-&gt;request.dev
op_assign
l_int|0xfffe
suffix:semicolon
)brace
macro_line|#ifdef NO_MULTI_LUN
DECL|variable|max_scsi_luns
r_static
r_int
id|max_scsi_luns
op_assign
l_int|1
suffix:semicolon
macro_line|#else
DECL|variable|max_scsi_luns
r_static
r_int
id|max_scsi_luns
op_assign
l_int|8
suffix:semicolon
macro_line|#endif
DECL|function|scsi_luns_setup
r_void
id|scsi_luns_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ne
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;scsi_luns_setup : usage max_scsi_luns=n (n should be between 1 and 8)&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|max_scsi_luns
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Detecting SCSI devices :&t;&n; *&t;We scan all present host adapter&squot;s busses,  from ID 0 to ID 6.  &n; *&t;We use the INQUIRY command, determine device type, and pass the ID / &n; *&t;lun address of all sequential devices to the tape driver, all random &n; *&t;devices to the disk driver.&n; */
DECL|function|scan_scsis
r_static
r_void
id|scan_scsis
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_int
id|dev
comma
id|lun
comma
id|type
suffix:semicolon
r_int
r_char
id|scsi_cmd
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_char
id|scsi_result
(braket
l_int|256
)braket
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
comma
op_star
id|SDtail
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
id|Scsi_Cmnd
id|SCmd
suffix:semicolon
op_increment
id|in_scan_scsis
suffix:semicolon
id|lun
op_assign
l_int|0
suffix:semicolon
id|type
op_assign
op_minus
l_int|1
suffix:semicolon
id|SCmd.next
op_assign
l_int|NULL
suffix:semicolon
id|SCmd.prev
op_assign
l_int|NULL
suffix:semicolon
id|SDpnt
op_assign
(paren
id|Scsi_Device
op_star
)paren
id|scsi_init_malloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
id|SDtail
op_assign
id|scsi_devices
suffix:semicolon
r_if
c_cond
(paren
id|scsi_devices
)paren
(brace
r_while
c_loop
(paren
id|SDtail-&gt;next
)paren
(brace
id|SDtail
op_assign
id|SDtail-&gt;next
suffix:semicolon
)brace
)brace
id|shpnt-&gt;host_queue
op_assign
op_amp
id|SCmd
suffix:semicolon
multiline_comment|/* We need this so that&n;&t;&t;&t;&t;&t; commands can time out */
r_for
c_loop
(paren
id|dev
op_assign
l_int|0
suffix:semicolon
id|dev
OL
l_int|8
suffix:semicolon
op_increment
id|dev
)paren
r_if
c_cond
(paren
id|shpnt-&gt;this_id
op_ne
id|dev
)paren
multiline_comment|/*&n; * We need the for so our continue, etc. work fine.&n; */
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
id|max_scsi_luns
suffix:semicolon
op_increment
id|lun
)paren
(brace
id|SDpnt-&gt;host
op_assign
id|shpnt
suffix:semicolon
id|SDpnt-&gt;id
op_assign
id|dev
suffix:semicolon
id|SDpnt-&gt;lun
op_assign
id|lun
suffix:semicolon
id|SDpnt-&gt;device_wait
op_assign
l_int|NULL
suffix:semicolon
id|SDpnt-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|SDpnt-&gt;attached
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Assume that the device will have handshaking problems, and then &n; * fix this field later if it turns out it doesn&squot;t.&n; */
id|SDpnt-&gt;borken
op_assign
l_int|1
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|TEST_UNIT_READY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
id|lun
op_lshift
l_int|5
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|SCmd.host
op_assign
id|shpnt
suffix:semicolon
id|SCmd.target
op_assign
id|dev
suffix:semicolon
id|SCmd.lun
op_assign
id|lun
suffix:semicolon
id|SCmd.request.dev
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* Mark not busy */
id|SCmd.use_sg
op_assign
l_int|0
suffix:semicolon
id|SCmd.old_use_sg
op_assign
l_int|0
suffix:semicolon
id|SCmd.transfersize
op_assign
l_int|0
suffix:semicolon
id|SCmd.underflow
op_assign
l_int|0
suffix:semicolon
id|scsi_do_cmd
(paren
op_amp
id|SCmd
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|256
comma
id|scan_scsis_done
comma
id|SCSI_TIMEOUT
op_plus
l_int|400
comma
l_int|5
)paren
suffix:semicolon
r_while
c_loop
(paren
id|SCmd.request.dev
op_ne
l_int|0xfffe
)paren
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(DEBUG_INIT)
id|printk
c_func
(paren
l_string|&quot;scsi: scan SCSIS id %d lun %d&bslash;n&quot;
comma
id|dev
comma
id|lun
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi: return code %08x&bslash;n&quot;
comma
id|SCmd.result
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SCmd.result
)paren
(brace
r_if
c_cond
(paren
(paren
id|driver_byte
c_func
(paren
id|SCmd.result
)paren
op_amp
id|DRIVER_SENSE
)paren
op_logical_and
(paren
(paren
id|SCmd.sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x70
)paren
op_rshift
l_int|4
)paren
op_eq
l_int|7
)paren
(brace
r_if
c_cond
(paren
id|SCmd.sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xe0
)paren
r_continue
suffix:semicolon
multiline_comment|/* No devices here... */
r_if
c_cond
(paren
(paren
(paren
id|SCmd.sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|NOT_READY
)paren
op_logical_and
(paren
(paren
id|SCmd.sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|UNIT_ATTENTION
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
)brace
r_else
r_break
suffix:semicolon
)brace
suffix:semicolon
macro_line|#if defined (DEBUG) || defined(DEBUG_INIT)
id|printk
c_func
(paren
l_string|&quot;scsi: performing INQUIRY&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;   * Build an INQUIRY command block.  &n;&t;   */
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|255
suffix:semicolon
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|SCmd.request.dev
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* Mark not busy */
id|scsi_do_cmd
(paren
op_amp
id|SCmd
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|256
comma
id|scan_scsis_done
comma
id|SCSI_TIMEOUT
comma
l_int|3
)paren
suffix:semicolon
r_while
c_loop
(paren
id|SCmd.request.dev
op_ne
l_int|0xfffe
)paren
suffix:semicolon
id|the_result
op_assign
id|SCmd.result
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(DEBUG_INIT)
r_if
c_cond
(paren
op_logical_neg
id|the_result
)paren
id|printk
c_func
(paren
l_string|&quot;scsi: INQUIRY successful&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;scsi: INQUIRY failed with code %08x&bslash;n&quot;
comma
id|the_result
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|the_result
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* skip other luns on this device */
r_if
c_cond
(paren
op_logical_neg
id|the_result
)paren
(brace
multiline_comment|/* It would seem some TOSHIBA CD-ROM gets things wrong */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|scsi_result
op_plus
l_int|8
comma
l_string|&quot;TOSHIBA&quot;
comma
l_int|7
)paren
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|scsi_result
op_plus
l_int|16
comma
l_string|&quot;CD-ROM&quot;
comma
l_int|6
)paren
op_logical_and
id|scsi_result
(braket
l_int|0
)braket
op_eq
id|TYPE_DISK
)paren
(brace
id|scsi_result
(braket
l_int|0
)braket
op_assign
id|TYPE_ROM
suffix:semicolon
id|scsi_result
(braket
l_int|1
)braket
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* removable */
)brace
id|SDpnt-&gt;removable
op_assign
(paren
l_int|0x80
op_amp
id|scsi_result
(braket
l_int|1
)braket
)paren
op_rshift
l_int|7
suffix:semicolon
id|SDpnt-&gt;lockable
op_assign
id|SDpnt-&gt;removable
suffix:semicolon
id|SDpnt-&gt;changed
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;access_count
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;busy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n; *&t;Currently, all sequential devices are assumed to be tapes,&n; *&t;all random devices disk, with the appropriate read only &n; *&t;flags set for ROM / WORM treated as RO.&n; */
r_switch
c_cond
(paren
id|type
op_assign
id|scsi_result
(braket
l_int|0
)braket
)paren
(brace
r_case
id|TYPE_TAPE
suffix:colon
r_case
id|TYPE_DISK
suffix:colon
r_case
id|TYPE_MOD
suffix:colon
id|SDpnt-&gt;writeable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_WORM
suffix:colon
r_case
id|TYPE_ROM
suffix:colon
id|SDpnt-&gt;writeable
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
macro_line|#if 0
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;scsi: unknown type %d&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
id|print_inquiry
c_func
(paren
id|scsi_result
)paren
suffix:semicolon
macro_line|#endif
id|type
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
)brace
id|SDpnt-&gt;soft_reset
op_assign
(paren
id|scsi_result
(braket
l_int|7
)braket
op_amp
l_int|1
)paren
op_logical_and
(paren
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|7
)paren
op_eq
l_int|2
)paren
suffix:semicolon
id|SDpnt-&gt;random
op_assign
(paren
id|type
op_eq
id|TYPE_TAPE
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|SDpnt-&gt;type
op_assign
id|type
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
)paren
(brace
id|print_inquiry
c_func
(paren
id|scsi_result
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;detect
)paren
(brace
id|SDpnt-&gt;attached
op_add_assign
(paren
op_star
id|sdtpnt-&gt;detect
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
id|SDpnt-&gt;scsi_level
op_assign
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;scsi_level
op_ge
l_int|2
op_logical_or
(paren
id|SDpnt-&gt;scsi_level
op_eq
l_int|1
op_logical_and
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
)paren
id|SDpnt-&gt;scsi_level
op_increment
suffix:semicolon
multiline_comment|/* &n; * Set the tagged_queue flag for SCSI-II devices that purport to support&n; * tagged queuing in the INQUIRY data.&n; */
id|SDpnt-&gt;tagged_queue
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|SDpnt-&gt;scsi_level
op_ge
id|SCSI_2
)paren
op_logical_and
(paren
id|scsi_result
(braket
l_int|7
)braket
op_amp
l_int|2
)paren
)paren
(brace
id|SDpnt-&gt;tagged_supported
op_assign
l_int|1
suffix:semicolon
id|SDpnt-&gt;current_tag
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Accommodate drivers that want to sleep when they should be in a polling&n; * loop.&n; */
id|SDpnt-&gt;disconnect
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Some revisions of the Texel CD ROM drives have handshaking&n; * problems when used with the Seagate controllers.  Before we&n; * know what type of device we&squot;re talking to, we assume it&squot;s &n; * borken and then change it here if it turns out that it isn&squot;t&n; * a TEXEL drive.&n; */
r_if
c_cond
(paren
id|strncmp
c_func
(paren
l_string|&quot;TEXEL&quot;
comma
(paren
r_char
op_star
)paren
op_amp
id|scsi_result
(braket
l_int|8
)braket
comma
l_int|5
)paren
op_ne
l_int|0
op_logical_or
id|strncmp
c_func
(paren
l_string|&quot;CD-ROM&quot;
comma
(paren
r_char
op_star
)paren
op_amp
id|scsi_result
(braket
l_int|16
)braket
comma
l_int|6
)paren
op_ne
l_int|0
multiline_comment|/* &n; * XXX 1.06 has problems, some one should figure out the others too so&n; * ALL TEXEL drives don&squot;t suffer in performance, especially when I finish&n; * integrating my seagate patches which do multiple I_T_L nexuses.&n; */
macro_line|#ifdef notyet
op_logical_or
(paren
id|strncmp
(paren
l_string|&quot;1.06&quot;
comma
(paren
r_char
op_star
)paren
op_amp
id|scsi_result
(braket
(braket
comma
l_int|4
)paren
op_ne
l_int|0
)paren
)paren
)paren
macro_line|#endif
)paren
id|SDpnt-&gt;borken
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* These devices need this &quot;key&quot; to unlock the device&n;&t;&t;     so we can use it */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
l_string|&quot;INSITE&quot;
comma
op_amp
id|scsi_result
(braket
l_int|8
)braket
comma
l_int|6
)paren
op_eq
l_int|0
op_logical_and
(paren
id|memcmp
c_func
(paren
l_string|&quot;Floptical   F*8I&quot;
comma
op_amp
id|scsi_result
(braket
l_int|16
)braket
comma
l_int|16
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
c_func
(paren
l_string|&quot;I325VM&quot;
comma
op_amp
id|scsi_result
(braket
l_int|16
)braket
comma
l_int|6
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unlocked floptical drive.&bslash;n&quot;
)paren
suffix:semicolon
id|SDpnt-&gt;lockable
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x2e
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|0x2a
suffix:semicolon
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|SCmd.request.dev
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* Mark not busy */
id|scsi_do_cmd
(paren
op_amp
id|SCmd
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|0x2a
comma
id|scan_scsis_done
comma
id|SCSI_TIMEOUT
comma
l_int|3
)paren
suffix:semicolon
r_while
c_loop
(paren
id|SCmd.request.dev
op_ne
l_int|0xfffe
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Add this device to the linked list at the end */
r_if
c_cond
(paren
id|SDtail
)paren
(brace
id|SDtail-&gt;next
op_assign
id|SDpnt
suffix:semicolon
)brace
r_else
id|scsi_devices
op_assign
id|SDpnt
suffix:semicolon
id|SDtail
op_assign
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
(paren
id|Scsi_Device
op_star
)paren
id|scsi_init_malloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
multiline_comment|/* Some scsi devices cannot be polled for lun != 0&n;&t;&t;     due to firmware bugs */
r_if
c_cond
(paren
id|blacklisted
c_func
(paren
id|scsi_result
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Old drives like the MAXTOR XT-3280 say vers=0 */
r_if
c_cond
(paren
(paren
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* Some scsi-1 peripherals do not handle lun != 0.&n;&t;&t;     I am assuming that scsi-2 peripherals do better */
r_if
c_cond
(paren
(paren
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* if result == DID_OK ends */
)brace
multiline_comment|/* for lun ends */
id|shpnt-&gt;host_queue
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* No longer needed here */
id|printk
c_func
(paren
l_string|&quot;scsi : detected &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;dev_noticed
op_logical_and
id|sdtpnt-&gt;name
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d SCSI %s%s &quot;
comma
id|sdtpnt-&gt;dev_noticed
comma
id|sdtpnt-&gt;name
comma
(paren
id|sdtpnt-&gt;dev_noticed
op_ne
l_int|1
)paren
ques
c_cond
l_string|&quot;s&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;total.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Last device block does not exist.  Free memory. */
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|SDpnt
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
id|in_scan_scsis
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* scan_scsis  ends */
multiline_comment|/*&n; *&t;Flag bits for the internal_timeout array &n; */
DECL|macro|NORMAL_TIMEOUT
mdefine_line|#define NORMAL_TIMEOUT 0
DECL|macro|IN_ABORT
mdefine_line|#define IN_ABORT 1
DECL|macro|IN_RESET
mdefine_line|#define IN_RESET 2
multiline_comment|/*&n;&t;This is our time out function, called when the timer expires for a &n;&t;given host adapter.  It will attempt to abort the currently executing &n;&t;command, that failing perform a kernel panic.&n;*/
DECL|function|scsi_times_out
r_static
r_void
id|scsi_times_out
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_switch
c_cond
(paren
id|SCpnt-&gt;internal_timeout
op_amp
(paren
id|IN_ABORT
op_or
id|IN_RESET
)paren
)paren
(brace
r_case
id|NORMAL_TIMEOUT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|in_scan_scsis
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi : aborting command due to timeout : pid %lu, scsi%d, id %d, lun %d &quot;
comma
id|SCpnt-&gt;pid
comma
id|SCpnt-&gt;host-&gt;host_no
comma
(paren
r_int
)paren
id|SCpnt-&gt;target
comma
(paren
r_int
)paren
id|SCpnt-&gt;lun
)paren
suffix:semicolon
id|print_command
(paren
id|SCpnt-&gt;cmnd
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TIMEOUT
id|scsi_dump_status
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
op_logical_neg
id|scsi_abort
(paren
id|SCpnt
comma
id|DID_TIME_OUT
)paren
)paren
r_return
suffix:semicolon
r_case
id|IN_ABORT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SCSI host %d abort() timed out - reseting&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_reset
(paren
id|SCpnt
)paren
)paren
r_return
suffix:semicolon
r_case
id|IN_RESET
suffix:colon
r_case
(paren
id|IN_ABORT
op_or
id|IN_RESET
)paren
suffix:colon
multiline_comment|/* This might be controversial, but if there is a bus hang,&n;&t;&t;     you might conceivably want the machine up and running&n;&t;&t;     esp if you have an ide disk. */
id|printk
c_func
(paren
l_string|&quot;Unable to reset scsi host %d - &quot;
comma
id|SCpnt-&gt;host-&gt;host_no
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;probably a SCSI bus hang.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
id|INTERNAL_ERROR
suffix:semicolon
)brace
)brace
multiline_comment|/* This function takes a quick look at a request, and decides if it&n;can be queued now, or if there would be a stall while waiting for&n;something else to finish.  This routine assumes that interrupts are&n;turned off when entering the routine.  It is the responsibility&n;of the calling code to ensure that this is the case. */
DECL|function|request_queueable
id|Scsi_Cmnd
op_star
id|request_queueable
(paren
r_struct
id|request
op_star
id|req
comma
id|Scsi_Device
op_star
id|device
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tablesize
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|bhp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
id|panic
(paren
l_string|&quot;No device passed to allocate_device().&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
op_logical_and
id|req-&gt;dev
op_le
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Invalid device in allocate_device&quot;
)paren
suffix:semicolon
id|SCpnt
op_assign
id|device-&gt;host-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;target
op_eq
id|device-&gt;id
op_logical_and
id|SCpnt-&gt;lun
op_eq
id|device-&gt;lun
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;request.dev
OL
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|SCpnt
op_assign
id|SCpnt-&gt;next
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;host-&gt;hostt-&gt;can_queue
op_logical_and
id|device-&gt;host-&gt;host_busy
op_ge
id|device-&gt;host-&gt;hostt-&gt;can_queue
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|SCpnt-&gt;request
comma
id|req
comma
r_sizeof
(paren
r_struct
id|request
)paren
)paren
suffix:semicolon
id|tablesize
op_assign
id|device-&gt;host-&gt;sg_tablesize
suffix:semicolon
id|bhp
op_assign
id|bh
op_assign
id|req-&gt;bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tablesize
)paren
(brace
id|bh
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Take a quick look through the table to see how big it is.  We already&n;       have our copy of req, so we can mess with that if we want to.  */
r_while
c_loop
(paren
id|req-&gt;nr_sectors
op_logical_and
id|bh
)paren
(brace
id|bhp
op_assign
id|bhp-&gt;b_reqnext
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bhp
op_logical_or
op_logical_neg
id|CONTIGUOUS_BUFFERS
c_func
(paren
id|bh
comma
id|bhp
)paren
)paren
(brace
id|tablesize
op_decrement
suffix:semicolon
)brace
id|req-&gt;nr_sectors
op_sub_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|req-&gt;sector
op_add_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tablesize
)paren
(brace
r_break
suffix:semicolon
)brace
id|bh
op_assign
id|bhp
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;nr_sectors
op_logical_and
id|bh
op_logical_and
id|bh-&gt;b_reqnext
)paren
(brace
multiline_comment|/* Any leftovers? */
id|SCpnt-&gt;request.bhtail
op_assign
id|bh
suffix:semicolon
id|req-&gt;bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
multiline_comment|/* Divide request */
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
id|bh
op_assign
id|req-&gt;bh
suffix:semicolon
multiline_comment|/* Now reset things so that req looks OK */
id|SCpnt-&gt;request.nr_sectors
op_sub_assign
id|req-&gt;nr_sectors
suffix:semicolon
id|req-&gt;current_nr_sectors
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|req-&gt;buffer
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Wait until whole thing done */
)brace
r_else
(brace
id|req-&gt;dev
op_assign
op_minus
l_int|1
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|wait_for_request
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
r_else
(brace
id|SCpnt-&gt;request.dev
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* Busy, but no request */
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* And no one is waiting for the device either */
)brace
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the scatter-gather flag */
id|SCpnt-&gt;old_use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
r_return
id|SCpnt
suffix:semicolon
)brace
multiline_comment|/* This function returns a structure pointer that will be valid for&n;the device.  The wait parameter tells us whether we should wait for&n;the unit to become free or not.  We are also able to tell this routine&n;not to return a descriptor if the host is unable to accept any more&n;commands for the time being.  We need to keep in mind that there is no&n;guarantee that the host remain not busy.  Keep in mind the&n;request_queueable function also knows the internal allocation scheme&n;of the packets for each device */
DECL|function|allocate_device
id|Scsi_Cmnd
op_star
id|allocate_device
(paren
r_struct
id|request
op_star
op_star
id|reqp
comma
id|Scsi_Device
op_star
id|device
comma
r_int
id|wait
)paren
(brace
r_int
id|dev
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|request
op_star
id|req
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tablesize
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|bhp
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCwait
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
id|panic
(paren
l_string|&quot;No device passed to allocate_device().&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reqp
)paren
id|req
op_assign
op_star
id|reqp
suffix:semicolon
multiline_comment|/* See if this request has already been queued by an interrupt routine */
r_if
c_cond
(paren
id|req
op_logical_and
(paren
id|dev
op_assign
id|req-&gt;dev
)paren
op_le
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|host
op_assign
id|device-&gt;host
suffix:semicolon
r_while
c_loop
(paren
l_int|1
op_eq
l_int|1
)paren
(brace
id|SCpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;target
op_eq
id|device-&gt;id
op_logical_and
id|SCpnt-&gt;lun
op_eq
id|device-&gt;lun
)paren
(brace
id|SCwait
op_assign
id|SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request.dev
OL
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
suffix:semicolon
)brace
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* See if this request has already been queued by an interrupt routine */
r_if
c_cond
(paren
id|req
op_logical_and
(paren
(paren
id|req-&gt;dev
OL
l_int|0
)paren
op_logical_or
(paren
id|req-&gt;dev
op_ne
id|dev
)paren
)paren
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
op_logical_or
id|SCpnt-&gt;request.dev
op_ge
l_int|0
)paren
multiline_comment|/* Might have changed */
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|SCwait
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to allocate device target %d, lun %d&bslash;n&quot;
comma
id|device-&gt;id
comma
id|device-&gt;lun
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;No device found in allocate_device&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
id|SCSI_SLEEP
c_func
(paren
op_amp
id|device-&gt;device_wait
comma
(paren
id|SCwait-&gt;request.dev
OG
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|req
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|SCpnt-&gt;request
comma
id|req
comma
r_sizeof
(paren
r_struct
id|request
)paren
)paren
suffix:semicolon
id|tablesize
op_assign
id|device-&gt;host-&gt;sg_tablesize
suffix:semicolon
id|bhp
op_assign
id|bh
op_assign
id|req-&gt;bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tablesize
)paren
(brace
id|bh
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Take a quick look through the table to see how big it is.  We already&n;&t;     have our copy of req, so we can mess with that if we want to.  */
r_while
c_loop
(paren
id|req-&gt;nr_sectors
op_logical_and
id|bh
)paren
(brace
id|bhp
op_assign
id|bhp-&gt;b_reqnext
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bhp
op_logical_or
op_logical_neg
id|CONTIGUOUS_BUFFERS
c_func
(paren
id|bh
comma
id|bhp
)paren
)paren
(brace
id|tablesize
op_decrement
suffix:semicolon
)brace
id|req-&gt;nr_sectors
op_sub_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|req-&gt;sector
op_add_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tablesize
)paren
(brace
r_break
suffix:semicolon
)brace
id|bh
op_assign
id|bhp
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;nr_sectors
op_logical_and
id|bh
op_logical_and
id|bh-&gt;b_reqnext
)paren
(brace
multiline_comment|/* Any leftovers? */
id|SCpnt-&gt;request.bhtail
op_assign
id|bh
suffix:semicolon
id|req-&gt;bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
multiline_comment|/* Divide request */
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
id|bh
op_assign
id|req-&gt;bh
suffix:semicolon
multiline_comment|/* Now reset things so that req looks OK */
id|SCpnt-&gt;request.nr_sectors
op_sub_assign
id|req-&gt;nr_sectors
suffix:semicolon
id|req-&gt;current_nr_sectors
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|req-&gt;buffer
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Wait until whole thing done */
)brace
r_else
(brace
id|req-&gt;dev
op_assign
op_minus
l_int|1
suffix:semicolon
op_star
id|reqp
op_assign
id|req-&gt;next
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|wait_for_request
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
r_else
(brace
id|SCpnt-&gt;request.dev
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* Busy */
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* And no one is waiting for this to complete */
)brace
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the scatter-gather flag */
id|SCpnt-&gt;old_use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No default transfer size */
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do not flag underflow conditions */
r_return
id|SCpnt
suffix:semicolon
)brace
multiline_comment|/*&n;&t;This is inline because we have stack problemes if we recurse to deeply.&n;*/
DECL|function|internal_cmnd
r_inline
r_void
id|internal_cmnd
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|temp
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
macro_line|#ifdef DEBUG_DELAY&t;
r_int
id|clock
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
op_amp
id|SCpnt
OL
id|current-&gt;kernel_stack_page
)paren
id|panic
c_func
(paren
l_string|&quot;Kernel stack overflow.&quot;
)paren
suffix:semicolon
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
multiline_comment|/*&n;&t;We will wait MIN_RESET_DELAY clock ticks after the last reset so &n;&t;we can avoid the drive not being ready.&n;*/
id|temp
op_assign
id|host-&gt;last_reset
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|temp
)paren
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|SCpnt-&gt;timeout_per_command
)paren
suffix:semicolon
multiline_comment|/*&n;&t;We will use a queued command if possible, otherwise we will emulate the&n;&t;queuing and calling of completion function ourselves. &n;*/
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;internal_cmnd (host = %d, target = %d, command = %08x, buffer =  %08x, &bslash;n&quot;
l_string|&quot;bufflen = %d, done = %08x)&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;bufflen
comma
id|SCpnt-&gt;done
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|host-&gt;hostt-&gt;can_queue
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;queuecommand : routine at %08x&bslash;n&quot;
comma
id|host-&gt;hostt-&gt;queuecommand
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* This locking tries to prevent all sorts of races between&n;&t;&t;     queuecommand and the interrupt code.  In effect,&n;&t;&t;     we are only allowed to be in queuecommand once at&n;&t;&t;     any given time, and we can only be in the interrupt&n;&t;&t;     handler and the queuecommand function at the same time&n;&t;&t;     when queuecommand is called while servicing the&n;&t;&t;     interrupt. */
r_if
c_cond
(paren
op_logical_neg
id|intr_count
op_logical_and
id|SCpnt-&gt;host-&gt;irq
)paren
(brace
id|disable_irq
c_func
(paren
id|SCpnt-&gt;host-&gt;irq
)paren
suffix:semicolon
)brace
id|host-&gt;hostt-&gt;queuecommand
(paren
id|SCpnt
comma
id|scsi_done
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|intr_count
op_logical_and
id|SCpnt-&gt;host-&gt;irq
)paren
(brace
id|enable_irq
c_func
(paren
id|SCpnt-&gt;host-&gt;irq
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;command() :  routine at %08x&bslash;n&quot;
comma
id|host-&gt;hostt-&gt;command
)paren
suffix:semicolon
macro_line|#endif
id|temp
op_assign
id|host-&gt;hostt-&gt;command
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|temp
suffix:semicolon
macro_line|#ifdef DEBUG_DELAY
id|clock
op_assign
id|jiffies
op_plus
l_int|400
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|clock
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;done(host = %d, result = %04x) : routine at %08x&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|temp
comma
id|done
)paren
suffix:semicolon
macro_line|#endif
id|scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;leaving internal_cmnd()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|scsi_request_sense
r_static
r_void
id|scsi_request_sense
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|SCpnt-&gt;flags
op_or_assign
id|WAS_SENSE
op_or
id|ASKED_FOR_SENSE
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|SENSE_TIMEOUT
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|generic_sense
comma
r_sizeof
(paren
id|generic_sense
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|SCpnt-&gt;lun
op_lshift
l_int|5
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
op_amp
id|SCpnt-&gt;sense_buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|internal_cmnd
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
)brace
multiline_comment|/*&n;&t;scsi_do_cmd sends all the commands out to the low-level driver.  It &n;&t;handles the specifics required for each low level driver - ie queued &n;&t;or non queued.  It also prevents conflicts when different high level &n;&t;drivers go for the same host at the same time.&n;*/
DECL|function|scsi_do_cmd
r_void
id|scsi_do_cmd
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
comma
r_int
id|timeout
comma
r_int
id|retries
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
macro_line|#ifdef DEBUG
(brace
r_int
id|i
suffix:semicolon
r_int
id|target
op_assign
id|SCpnt-&gt;target
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi_do_cmd (host = %d, target = %d, buffer =%08x, &quot;
l_string|&quot;bufflen = %d, done = %08x, timeout = %d, retries = %d)&bslash;n&quot;
l_string|&quot;command : &quot;
comma
id|host-&gt;host_no
comma
id|target
comma
id|buffer
comma
id|bufflen
comma
id|done
comma
id|timeout
comma
id|retries
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
op_increment
id|i
)paren
id|printk
(paren
l_string|&quot;%02x  &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
(brace
id|panic
(paren
l_string|&quot;Invalid or not present host. %d&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;We must prevent reentrancy to the lowlevel host driver.  This prevents &n;&t;it - we enter a loop until the host we want to talk to is not busy.   &n;&t;Race conditions are prevented, as interrupts are disabled in between the&n;&t;time we check for the host being not busy, and the time we mark it busy&n;&t;ourselves.&n;*/
id|SCpnt-&gt;pid
op_assign
id|scsi_pid
op_increment
suffix:semicolon
r_while
c_loop
(paren
l_int|1
op_eq
l_int|1
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;hostt-&gt;can_queue
op_logical_and
id|host-&gt;host_busy
op_ge
id|host-&gt;hostt-&gt;can_queue
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|SCSI_SLEEP
c_func
(paren
op_amp
id|host-&gt;host_wait
comma
(paren
id|host-&gt;host_busy
op_ge
id|host-&gt;hostt-&gt;can_queue
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|host-&gt;host_busy
op_increment
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;Our own function scsi_done (which marks the host as not busy, disables &n;&t;the timeout counter, etc) will be called by us or by the &n;&t;scsi_hosts[host].queuecommand() function needs to also call&n;&t;the completion function for the high level driver.&n;&n;*/
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
(paren
r_void
op_star
)paren
id|cmnd
comma
l_int|12
)paren
suffix:semicolon
macro_line|#if 0
id|SCpnt-&gt;host
op_assign
id|host
suffix:semicolon
id|SCpnt-&gt;target
op_assign
id|target
suffix:semicolon
id|SCpnt-&gt;lun
op_assign
(paren
id|SCpnt-&gt;data_cmnd
(braket
l_int|1
)braket
op_rshift
l_int|5
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt-&gt;bufflen
op_assign
id|bufflen
suffix:semicolon
id|SCpnt-&gt;buffer
op_assign
id|buffer
suffix:semicolon
id|SCpnt-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;retries
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;allowed
op_assign
id|retries
suffix:semicolon
id|SCpnt-&gt;done
op_assign
id|done
suffix:semicolon
id|SCpnt-&gt;timeout_per_command
op_assign
id|timeout
suffix:semicolon
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|cmnd
comma
l_int|12
)paren
suffix:semicolon
multiline_comment|/* Zero the sense buffer.  Some host adapters automatically request&n;&t;   sense on error.  0 is not a valid sense code.  */
id|memset
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|bufflen
suffix:semicolon
id|SCpnt-&gt;old_use_sg
op_assign
id|SCpnt-&gt;use_sg
suffix:semicolon
multiline_comment|/* Start the timer ticking.  */
id|SCpnt-&gt;internal_timeout
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;abort_reason
op_assign
l_int|0
suffix:semicolon
id|internal_cmnd
(paren
id|SCpnt
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;Leaving scsi_do_cmd()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t;The scsi_done() function disables the timeout timer for the scsi host, &n;&t;marks the host as not busy, and calls the user specified completion &n;&t;function for that host&squot;s current command.&n;*/
DECL|function|reset
r_static
r_void
id|reset
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;scsi: reset(%d)&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt-&gt;flags
op_or_assign
(paren
id|WAS_RESET
op_or
id|IS_RESETTING
)paren
suffix:semicolon
id|scsi_reset
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;performing request sense&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0  /* FIXME - remove this when done */
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|NEEDS_JUMPSTART
)paren
(brace
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|NEEDS_JUMPSTART
suffix:semicolon
id|scsi_request_sense
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
)brace
DECL|function|check_sense
r_static
r_int
id|check_sense
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
multiline_comment|/* If there is no sense information, request it.  If we have already&n;     requested it, there is no point in asking again - the firmware must be&n;     confused. */
r_if
c_cond
(paren
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x70
)paren
op_rshift
l_int|4
)paren
op_ne
l_int|7
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|SCpnt-&gt;flags
op_amp
id|ASKED_FOR_SENSE
)paren
)paren
(brace
r_return
id|SUGGEST_SENSE
suffix:semicolon
)brace
r_else
r_return
id|SUGGEST_RETRY
suffix:semicolon
)brace
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|ASKED_FOR_SENSE
suffix:semicolon
macro_line|#ifdef DEBUG_INIT
id|printk
c_func
(paren
l_string|&quot;scsi%d : &quot;
comma
id|SCpnt-&gt;host-&gt;host_no
)paren
suffix:semicolon
id|print_sense
c_func
(paren
l_string|&quot;&quot;
comma
id|SCpnt
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xe0
)paren
r_return
id|SUGGEST_ABORT
suffix:semicolon
r_switch
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
(brace
r_case
id|NO_SENSE
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|RECOVERED_ERROR
suffix:colon
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;type
op_eq
id|TYPE_TAPE
)paren
r_return
id|SUGGEST_IS_OK
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
r_case
id|ABORTED_COMMAND
suffix:colon
r_return
id|SUGGEST_RETRY
suffix:semicolon
r_case
id|NOT_READY
suffix:colon
r_case
id|UNIT_ATTENTION
suffix:colon
r_return
id|SUGGEST_ABORT
suffix:semicolon
multiline_comment|/* these three are not supported */
r_case
id|COPY_ABORTED
suffix:colon
r_case
id|VOLUME_OVERFLOW
suffix:colon
r_case
id|MISCOMPARE
suffix:colon
r_case
id|MEDIUM_ERROR
suffix:colon
r_return
id|SUGGEST_REMAP
suffix:semicolon
r_case
id|BLANK_CHECK
suffix:colon
r_case
id|DATA_PROTECT
suffix:colon
r_case
id|HARDWARE_ERROR
suffix:colon
r_case
id|ILLEGAL_REQUEST
suffix:colon
r_default
suffix:colon
r_return
id|SUGGEST_ABORT
suffix:semicolon
)brace
)brace
multiline_comment|/* This function is the mid-level interrupt routine, which decides how&n; *  to handle error conditions.  Each invocation of this function must&n; *  do one and *only* one of the following:&n; *&n; *  (1) Call last_cmnd[host].done.  This is done for fatal errors and&n; *      normal completion, and indicates that the handling for this&n; *      request is complete.&n; *  (2) Call internal_cmnd to requeue the command.  This will result in&n; *      scsi_done being called again when the retry is complete.&n; *  (3) Call scsi_request_sense.  This asks the host adapter/drive for&n; *      more information about the error condition.  When the information&n; *      is available, scsi_done will be called again.&n; *  (4) Call reset().  This is sort of a last resort, and the idea is that&n; *      this may kick things loose and get the drive working again.  reset()&n; *      automatically calls scsi_request_sense, and thus scsi_done will be&n; *      called again once the reset is complete.&n; *&n; *      If none of the above actions are taken, the drive in question&n; * will hang. If more than one of the above actions are taken by&n; * scsi_done, then unpredictable behavior will result.&n; */
DECL|function|scsi_done
r_static
r_void
id|scsi_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
m_exit
op_assign
l_int|0
suffix:semicolon
r_int
id|checked
suffix:semicolon
r_int
id|oldto
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
r_int
id|result
op_assign
id|SCpnt-&gt;result
suffix:semicolon
id|oldto
op_assign
id|update_timeout
c_func
(paren
id|SCpnt
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TIMEOUT
r_if
c_cond
(paren
id|result
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Non-zero result in scsi_done %x %d:%d&bslash;n&quot;
comma
id|result
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* If we requested an abort, (and we got it) then fix up the return&n;&t;   status to say why */
r_if
c_cond
(paren
id|host_byte
c_func
(paren
id|result
)paren
op_eq
id|DID_ABORT
op_logical_and
id|SCpnt-&gt;abort_reason
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|result
op_assign
(paren
id|result
op_amp
l_int|0xff00ffff
)paren
op_or
(paren
id|SCpnt-&gt;abort_reason
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
DECL|macro|FINISHED
mdefine_line|#define FINISHED 0
DECL|macro|MAYREDO
mdefine_line|#define MAYREDO  1
DECL|macro|REDO
mdefine_line|#define REDO&t; 3
DECL|macro|PENDING
mdefine_line|#define PENDING  4
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;In scsi_done(host = %d, result = %06x)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|result
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|host_byte
c_func
(paren
id|result
)paren
)paren
(brace
r_case
id|DID_OK
suffix:colon
r_if
c_cond
(paren
id|status_byte
c_func
(paren
id|result
)paren
op_logical_and
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_SENSE
)paren
)paren
multiline_comment|/* Failed to obtain sense information */
(brace
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|WAS_SENSE
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|SENSE_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_RESET
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : target %d lun %d request sense failed, performing reset.&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
)paren
suffix:semicolon
id|reset
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
m_exit
op_assign
(paren
id|DRIVER_HARD
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
id|status
op_assign
id|FINISHED
suffix:semicolon
)brace
)brace
r_else
r_switch
c_cond
(paren
id|msg_byte
c_func
(paren
id|result
)paren
)paren
(brace
r_case
id|COMMAND_COMPLETE
suffix:colon
r_switch
c_cond
(paren
id|status_byte
c_func
(paren
id|result
)paren
)paren
(brace
r_case
id|GOOD
suffix:colon
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_SENSE
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;In scsi_done, GOOD status, COMMAND COMPLETE, parsing sense information.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|WAS_SENSE
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|SENSE_TIMEOUT
suffix:semicolon
r_switch
c_cond
(paren
id|checked
op_assign
id|check_sense
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_case
id|SUGGEST_SENSE
suffix:colon
r_case
l_int|0
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;NO SENSE.  status = REDO&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_IS_OK
suffix:colon
r_break
suffix:semicolon
r_case
id|SUGGEST_REMAP
suffix:colon
r_case
id|SUGGEST_RETRY
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SENSE SUGGEST REMAP or SUGGEST RETRY - status = MAYREDO&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_RETRY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_ABORT
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SENSE SUGGEST ABORT - status = FINISHED&quot;
)paren
suffix:semicolon
macro_line|#endif
id|status
op_assign
id|FINISHED
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Internal error %s %d &bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;COMMAND COMPLETE message returned, status = FINISHED. &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
m_exit
op_assign
id|DRIVER_OK
suffix:semicolon
id|status
op_assign
id|FINISHED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CHECK_CONDITION
suffix:colon
r_switch
c_cond
(paren
id|check_sense
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_REMAP
suffix:colon
r_case
id|SUGGEST_RETRY
suffix:colon
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_RETRY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_ABORT
suffix:colon
id|status
op_assign
id|FINISHED
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_SENSE
suffix:colon
id|scsi_request_sense
(paren
id|SCpnt
)paren
suffix:semicolon
id|status
op_assign
id|PENDING
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CONDITION_GOOD
suffix:colon
r_case
id|INTERMEDIATE_GOOD
suffix:colon
r_case
id|INTERMEDIATE_C_GOOD
suffix:colon
r_break
suffix:semicolon
r_case
id|BUSY
suffix:colon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESERVATION_CONFLICT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : RESERVATION CONFLICT performing reset.&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
)paren
suffix:semicolon
id|reset
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#if 0
m_exit
op_assign
id|DRIVER_SOFT
op_or
id|SUGGEST_ABORT
suffix:semicolon
id|status
op_assign
id|MAYREDO
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Internal error %s %d &bslash;n&quot;
l_string|&quot;status byte = %d &bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|status_byte
c_func
(paren
id|result
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;scsi: unsupported message byte %d received&bslash;n&quot;
comma
id|msg_byte
c_func
(paren
id|result
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DID_TIME_OUT
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Host returned DID_TIME_OUT - &quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_TIMEDOUT
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Aborting&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif&t;
m_exit
op_assign
(paren
id|DRIVER_TIMEOUT
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;Retrying.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt-&gt;flags
op_or_assign
id|WAS_TIMEDOUT
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DID_BUS_BUSY
suffix:colon
r_case
id|DID_PARITY
suffix:colon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_NO_CONNECT
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Couldn&squot;t connect.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
m_exit
op_assign
(paren
id|DRIVER_HARD
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_ERROR
suffix:colon
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
(paren
id|DRIVER_HARD
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_BAD_TARGET
suffix:colon
r_case
id|DID_ABORT
suffix:colon
m_exit
op_assign
(paren
id|DRIVER_INVALID
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_RESET
suffix:colon
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|IS_RESETTING
)paren
(brace
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|IS_RESETTING
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg_byte
c_func
(paren
id|result
)paren
op_eq
id|GOOD
op_logical_and
id|status_byte
c_func
(paren
id|result
)paren
op_eq
id|CHECK_CONDITION
)paren
(brace
r_switch
c_cond
(paren
id|check_sense
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_REMAP
suffix:colon
r_case
id|SUGGEST_RETRY
suffix:colon
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_RETRY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_ABORT
suffix:colon
id|status
op_assign
id|FINISHED
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_SENSE
suffix:colon
id|scsi_request_sense
(paren
id|SCpnt
)paren
suffix:semicolon
id|status
op_assign
id|PENDING
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
id|REDO
suffix:semicolon
m_exit
op_assign
id|SUGGEST_RETRY
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
m_exit
op_assign
(paren
id|DRIVER_ERROR
op_or
id|SUGGEST_DIE
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|FINISHED
suffix:colon
r_case
id|PENDING
suffix:colon
r_break
suffix:semicolon
r_case
id|MAYREDO
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;In MAYREDO, allowing %d retries, have %d&bslash;n&quot;
comma
id|SCpnt-&gt;allowed
comma
id|SCpnt-&gt;retries
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
op_increment
id|SCpnt-&gt;retries
)paren
OL
id|SCpnt-&gt;allowed
)paren
(brace
r_if
c_cond
(paren
(paren
id|SCpnt-&gt;retries
op_ge
(paren
id|SCpnt-&gt;allowed
op_rshift
l_int|1
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_RESET
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : reseting for second half of retries.&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
)paren
suffix:semicolon
id|reset
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
id|FINISHED
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* fall through to REDO */
r_case
id|REDO
suffix:colon
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_SENSE
)paren
id|scsi_request_sense
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_else
(brace
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|SCpnt-&gt;buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|SCpnt-&gt;bufflen
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|internal_cmnd
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|INTERNAL_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_eq
id|FINISHED
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Calling done function - at address %08x&bslash;n&quot;
comma
id|SCpnt-&gt;done
)paren
suffix:semicolon
macro_line|#endif
id|host-&gt;host_busy
op_decrement
suffix:semicolon
multiline_comment|/* Indicate that we are free */
id|wake_up
c_func
(paren
op_amp
id|host-&gt;host_wait
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|result
op_or
(paren
(paren
m_exit
op_amp
l_int|0xff
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;done
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
DECL|macro|FINISHED
macro_line|#undef FINISHED
DECL|macro|REDO
macro_line|#undef REDO
DECL|macro|MAYREDO
macro_line|#undef MAYREDO
DECL|macro|PENDING
macro_line|#undef PENDING
)brace
multiline_comment|/*&n;&t;The scsi_abort function interfaces with the abort() function of the host&n;&t;we are aborting, and causes the current command to not complete.  The &n;&t;caller should deal with any error messages or status returned on the &n;&t;next call.&n;&t;&n;&t;This will not be called reentrantly for a given host.&n;*/
multiline_comment|/*&n;&t;Since we&squot;re nice guys and specified that abort() and reset()&n;&t;can be non-reentrant.  The internal_timeout flags are used for&n;&t;this.&n;*/
DECL|function|scsi_abort
r_int
id|scsi_abort
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|why
)paren
(brace
r_int
id|oldto
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;internal_timeout
op_amp
id|IN_ABORT
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt-&gt;internal_timeout
op_amp
id|IN_ABORT
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCpnt-&gt;internal_timeout
op_or_assign
id|IN_ABORT
suffix:semicolon
id|oldto
op_assign
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|ABORT_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|SCpnt-&gt;flags
op_amp
id|IS_RESETTING
)paren
op_logical_and
id|SCpnt-&gt;device-&gt;soft_reset
)paren
(brace
multiline_comment|/* OK, this command must have died when we did the&n;&t;&t;&t;     reset.  The device itself must have lied. */
id|printk
c_func
(paren
l_string|&quot;Stale command on %d:%d appears to have died when&quot;
l_string|&quot; the bus was reset&bslash;n&quot;
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host-&gt;host_busy
)paren
(brace
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|SCpnt-&gt;abort_reason
op_assign
id|why
suffix:semicolon
r_switch
c_cond
(paren
id|host-&gt;hostt
op_member_access_from_pointer
m_abort
(paren
id|SCpnt
)paren
)paren
(brace
multiline_comment|/* We do not know how to abort.  Try waiting another&n;&t;&t;&t;     time increment and see if this helps. Set the&n;&t;&t;&t;     WAS_TIMEDOUT flag set so we do not try this twice&n;&t;&t;&t;     */
r_case
id|SCSI_ABORT_BUSY
suffix:colon
multiline_comment|/* Tough call - returning 1 from&n;&t;&t;&t;&t;&t;&t; this is too severe */
r_case
id|SCSI_ABORT_SNOOZE
suffix:colon
r_if
c_cond
(paren
id|why
op_eq
id|DID_TIME_OUT
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_TIMEDOUT
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Indicate we cannot handle this.&n;&t;&t;&t;&t;&t;   We drop down into the reset handler&n;&t;&t;&t;&t;&t;   and try again */
)brace
r_else
(brace
id|SCpnt-&gt;flags
op_or_assign
id|WAS_TIMEDOUT
suffix:semicolon
id|oldto
op_assign
id|SCpnt-&gt;timeout_per_command
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_ABORT_PENDING
suffix:colon
r_if
c_cond
(paren
id|why
op_ne
id|DID_TIME_OUT
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_ABORT_SUCCESS
suffix:colon
multiline_comment|/* We should have already aborted this one.  No&n;&t;&t;&t;     need to adjust timeout */
r_case
id|SCSI_ABORT_NOT_RUNNING
suffix:colon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_ABORT_ERROR
suffix:colon
r_default
suffix:colon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|scsi_reset
r_int
id|scsi_reset
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|temp
comma
id|oldto
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt1
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Danger Will Robinson! - SCSI bus for host %d is being reset.&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;internal_timeout
op_amp
id|IN_RESET
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt-&gt;internal_timeout
op_amp
id|IN_RESET
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCpnt-&gt;internal_timeout
op_or_assign
id|IN_RESET
suffix:semicolon
id|oldto
op_assign
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|RESET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;host_busy
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|SCpnt1
op_assign
id|host-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt1
)paren
(brace
r_if
c_cond
(paren
id|SCpnt1-&gt;request.dev
OG
l_int|0
)paren
(brace
macro_line|#if 0&t;&t;&t;&t;  
r_if
c_cond
(paren
op_logical_neg
(paren
id|SCpnt1-&gt;flags
op_amp
id|IS_RESETTING
)paren
op_logical_and
op_logical_neg
(paren
id|SCpnt1-&gt;internal_timeout
op_amp
id|IN_ABORT
)paren
)paren
id|scsi_abort
c_func
(paren
id|SCpnt1
comma
id|DID_RESET
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt1-&gt;flags
op_or_assign
id|IS_RESETTING
suffix:semicolon
)brace
id|SCpnt1
op_assign
id|SCpnt1-&gt;next
suffix:semicolon
)brace
suffix:semicolon
id|temp
op_assign
id|host-&gt;hostt
op_member_access_from_pointer
id|reset
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
r_else
(brace
id|host-&gt;host_busy
op_increment
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|temp
op_assign
id|host-&gt;hostt
op_member_access_from_pointer
id|reset
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|host-&gt;last_reset
op_assign
id|jiffies
suffix:semicolon
id|host-&gt;host_busy
op_decrement
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;scsi reset function returned %d&bslash;n&quot;
comma
id|temp
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|temp
)paren
(brace
r_case
id|SCSI_RESET_SUCCESS
suffix:colon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_RESET
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_RESET_PENDING
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_RESET_PUNT
suffix:colon
r_case
id|SCSI_RESET_WAKEUP
suffix:colon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_RESET
suffix:semicolon
id|scsi_request_sense
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_RESET_SNOOZE
suffix:colon
multiline_comment|/* In this case, we set the timeout field to 0&n;&t;&t;&t;     so that this command does not time out any more,&n;&t;&t;&t;     and we return 1 so that we get a message on the&n;&t;&t;&t;     screen. */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_RESET
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
l_int|0
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If you snooze, you lose... */
r_case
id|SCSI_RESET_ERROR
suffix:colon
r_default
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
r_return
id|temp
suffix:semicolon
)brace
)brace
)brace
DECL|function|scsi_main_timeout
r_static
r_void
id|scsi_main_timeout
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t;&t;We must not enter update_timeout with a timeout condition still pending.&n;&t;*/
r_int
id|timed_out
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
r_do
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|update_timeout
c_func
(paren
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;Find all timers such that they have 0 or negative (shouldn&squot;t happen)&n;&t;&t;time remaining on them.&n;&t;*/
id|timed_out
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|host
op_assign
id|scsi_hostlist
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;timeout
op_eq
op_minus
l_int|1
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|SCpnt-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|scsi_times_out
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
op_increment
id|timed_out
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
suffix:semicolon
)brace
r_while
c_loop
(paren
id|timed_out
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;The strategy is to cause the timer code to call scsi_times_out()&n;&t;when the soonest timeout is pending.  &n;&t;The arguments are used when we are queueing a new command, because&n;&t;we do not want to subtract the time used from this time, but when we&n;&t;set the timer, we want to take this value into account.&n;*/
DECL|function|update_timeout
r_static
r_int
id|update_timeout
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCset
comma
r_int
id|timeout
)paren
(brace
r_int
r_int
id|least
comma
id|used
suffix:semicolon
r_int
r_int
id|oldto
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;Figure out how much time has passed since the last time the timeouts &n;   &t;were updated &n;*/
id|used
op_assign
(paren
id|time_start
)paren
ques
c_cond
(paren
id|jiffies
op_minus
id|time_start
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;Find out what is due to timeout soonest, and adjust all timeouts for&n;&t;the amount of time that has passed since the last time we called &n;&t;update_timeout. &n;*/
id|oldto
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|SCset
)paren
(brace
id|oldto
op_assign
id|SCset-&gt;timeout
op_minus
id|used
suffix:semicolon
id|SCset-&gt;timeout
op_assign
id|timeout
op_plus
id|used
suffix:semicolon
)brace
suffix:semicolon
id|least
op_assign
l_int|0xffffffff
suffix:semicolon
r_for
c_loop
(paren
id|host
op_assign
id|scsi_hostlist
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
r_for
c_loop
(paren
id|SCpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;timeout
OG
l_int|0
)paren
(brace
id|SCpnt-&gt;timeout
op_sub_assign
id|used
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;timeout
op_le
l_int|0
)paren
(brace
id|SCpnt-&gt;timeout
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;timeout
OG
l_int|0
op_logical_and
id|SCpnt-&gt;timeout
OL
id|least
)paren
(brace
id|least
op_assign
id|SCpnt-&gt;timeout
suffix:semicolon
)brace
)brace
suffix:semicolon
multiline_comment|/*&n;&t;If something is due to timeout again, then we will set the next timeout &n;&t;interrupt to occur.  Otherwise, timeouts are disabled.&n;*/
r_if
c_cond
(paren
id|least
op_ne
l_int|0xffffffff
)paren
(brace
id|time_start
op_assign
id|jiffies
suffix:semicolon
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|expires
op_assign
(paren
id|time_elapsed
op_assign
id|least
)paren
op_plus
id|jiffies
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|SCSI_TIMER
suffix:semicolon
)brace
r_else
(brace
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|expires
op_assign
id|time_start
op_assign
id|time_elapsed
op_assign
l_int|0
suffix:semicolon
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|SCSI_TIMER
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|oldto
suffix:semicolon
)brace
DECL|variable|dma_malloc_freelist
r_static
r_int
r_int
op_star
id|dma_malloc_freelist
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|dma_sectors
r_static
r_int
r_int
id|dma_sectors
op_assign
l_int|0
suffix:semicolon
DECL|variable|dma_free_sectors
r_int
r_int
id|dma_free_sectors
op_assign
l_int|0
suffix:semicolon
DECL|variable|need_isa_buffer
r_int
r_int
id|need_isa_buffer
op_assign
l_int|0
suffix:semicolon
DECL|variable|dma_malloc_buffer
r_static
r_int
r_char
op_star
id|dma_malloc_buffer
op_assign
l_int|NULL
suffix:semicolon
DECL|function|scsi_malloc
r_void
op_star
id|scsi_malloc
c_func
(paren
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|nbits
comma
id|mask
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_amp
l_int|0x1ff
)paren
op_logical_or
id|len
OG
l_int|8192
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|nbits
op_assign
id|len
op_rshift
l_int|9
suffix:semicolon
id|mask
op_assign
(paren
l_int|1
op_lshift
id|nbits
)paren
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|dma_sectors
op_rshift
l_int|4
)paren
suffix:semicolon
id|i
op_increment
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|17
op_minus
id|nbits
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|dma_malloc_freelist
(braket
id|i
)braket
op_amp
(paren
id|mask
op_lshift
id|j
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|dma_malloc_freelist
(braket
id|i
)braket
op_or_assign
(paren
id|mask
op_lshift
id|j
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|dma_free_sectors
op_sub_assign
id|nbits
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SMalloc: %d %x &quot;
comma
id|len
comma
id|dma_malloc_buffer
op_plus
(paren
id|i
op_lshift
l_int|13
)paren
op_plus
(paren
id|j
op_lshift
l_int|9
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|dma_malloc_buffer
op_plus
(paren
id|i
op_lshift
l_int|13
)paren
op_plus
(paren
id|j
op_lshift
l_int|9
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Nope.  No more */
)brace
DECL|function|scsi_free
r_int
id|scsi_free
c_func
(paren
r_void
op_star
id|obj
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|offset
suffix:semicolon
r_int
id|page
comma
id|sector
comma
id|nbits
comma
id|mask
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Sfree %x %d&bslash;n&quot;
comma
id|obj
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
id|offset
op_assign
(paren
(paren
r_int
)paren
id|obj
)paren
op_minus
(paren
(paren
r_int
)paren
id|dma_malloc_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Bad offset&quot;
)paren
suffix:semicolon
id|page
op_assign
id|offset
op_rshift
l_int|13
suffix:semicolon
id|sector
op_assign
id|offset
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|sector
op_ge
id|dma_sectors
)paren
(brace
id|panic
(paren
l_string|&quot;Bad page&quot;
)paren
suffix:semicolon
)brace
id|sector
op_assign
(paren
id|offset
op_rshift
l_int|9
)paren
op_amp
l_int|15
suffix:semicolon
id|nbits
op_assign
id|len
op_rshift
l_int|9
suffix:semicolon
id|mask
op_assign
(paren
l_int|1
op_lshift
id|nbits
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mask
op_lshift
id|sector
)paren
OG
l_int|0xffff
)paren
id|panic
(paren
l_string|&quot;Bad memory alignment&quot;
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_freelist
(braket
id|page
)braket
op_amp
(paren
id|mask
op_lshift
id|sector
)paren
op_ne
(paren
id|mask
op_lshift
id|sector
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Trying to free unused memory&quot;
)paren
suffix:semicolon
)brace
id|dma_free_sectors
op_add_assign
id|nbits
suffix:semicolon
id|dma_malloc_freelist
(braket
id|page
)braket
op_and_assign
op_complement
(paren
id|mask
op_lshift
id|sector
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* These are special functions that can be used to obtain memory at boot time.&n;   They act line a malloc function, but they simply take memory from the&n;   pool */
DECL|variable|scsi_init_memory_start
r_static
r_int
r_int
id|scsi_init_memory_start
op_assign
l_int|0
suffix:semicolon
DECL|variable|scsi_loadable_module_flag
r_int
id|scsi_loadable_module_flag
suffix:semicolon
multiline_comment|/* Set after we scan builtin drivers */
DECL|function|scsi_init_malloc
r_void
op_star
id|scsi_init_malloc
c_func
(paren
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|scsi_loadable_module_flag
)paren
(brace
id|retval
op_assign
(paren
r_int
r_int
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|scsi_init_memory_start
suffix:semicolon
id|scsi_init_memory_start
op_add_assign
id|size
suffix:semicolon
)brace
r_return
(paren
r_void
op_star
)paren
id|retval
suffix:semicolon
)brace
DECL|function|scsi_init_free
r_void
id|scsi_init_free
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
r_int
id|size
)paren
(brace
multiline_comment|/* FIXME - not right.  We need to compare addresses to see whether this was&n;     kmalloc&squot;d or not */
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|ptr
OL
id|scsi_loadable_module_flag
)paren
(brace
id|kfree
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|ptr
)paren
op_plus
id|size
op_eq
id|scsi_init_memory_start
)paren
(brace
id|scsi_init_memory_start
op_assign
(paren
r_int
r_int
)paren
id|ptr
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;scsi_dev_init() is our initialization routine, which in turn calls host &n;&t;initialization, bus scanning, and sd/st initialization routines.  It &n;&t;should be called from main().&n;*/
DECL|function|scsi_dev_init
r_int
r_int
id|scsi_dev_init
(paren
r_int
r_int
id|memory_start
comma
r_int
r_int
id|memory_end
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
macro_line|#ifdef FOO_ON_YOU
r_return
suffix:semicolon
macro_line|#endif&t;
multiline_comment|/* Init a few things so we can &quot;malloc&quot; memory. */
id|scsi_loadable_module_flag
op_assign
l_int|0
suffix:semicolon
id|scsi_init_memory_start
op_assign
id|memory_start
suffix:semicolon
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|fn
op_assign
id|scsi_main_timeout
suffix:semicolon
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|expires
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* initialize all hosts */
id|scsi_init
c_func
(paren
)paren
suffix:semicolon
id|scsi_devices
op_assign
(paren
id|Scsi_Device
op_star
)paren
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
id|scan_scsis
c_func
(paren
id|shpnt
)paren
suffix:semicolon
multiline_comment|/* scan for scsi devices */
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;init
op_logical_and
id|sdtpnt-&gt;dev_noticed
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;init
)paren
(paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|scsi_devices
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_int
id|j
suffix:semicolon
id|SDpnt-&gt;scsi_request_fn
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;attach
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;attach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_ne
op_minus
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|SDpnt-&gt;host-&gt;hostt-&gt;cmd_per_lun
suffix:semicolon
id|j
op_increment
)paren
(brace
id|SCpnt
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|scsi_init_malloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;host
op_assign
id|SDpnt-&gt;host
suffix:semicolon
id|SCpnt-&gt;device
op_assign
id|SDpnt
suffix:semicolon
id|SCpnt-&gt;target
op_assign
id|SDpnt-&gt;id
suffix:semicolon
id|SCpnt-&gt;lun
op_assign
id|SDpnt-&gt;lun
suffix:semicolon
id|SCpnt-&gt;request.dev
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Mark not busy */
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;old_use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|host
op_assign
id|SDpnt-&gt;host
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;host_queue
)paren
(brace
id|host-&gt;host_queue-&gt;prev
op_assign
id|SCpnt
suffix:semicolon
)brace
id|SCpnt-&gt;next
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SCpnt-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|host-&gt;host_queue
op_assign
id|SCpnt
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|scsi_devicelist
)paren
id|dma_sectors
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* Base value we use */
r_for
c_loop
(paren
id|SDpnt
op_assign
id|scsi_devices
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
id|host
op_assign
id|SDpnt-&gt;host
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_ne
id|TYPE_TAPE
)paren
(brace
id|dma_sectors
op_add_assign
(paren
(paren
id|host-&gt;sg_tablesize
op_star
r_sizeof
(paren
r_struct
id|scatterlist
)paren
op_plus
l_int|511
)paren
op_rshift
l_int|9
)paren
op_star
id|host-&gt;hostt-&gt;cmd_per_lun
suffix:semicolon
)brace
r_if
c_cond
(paren
id|host-&gt;unchecked_isa_dma
op_logical_and
id|memory_end
op_minus
l_int|1
OG
id|ISA_DMA_THRESHOLD
op_logical_and
id|SDpnt-&gt;type
op_ne
id|TYPE_TAPE
)paren
(brace
id|dma_sectors
op_add_assign
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
op_star
id|host-&gt;sg_tablesize
op_star
id|host-&gt;hostt-&gt;cmd_per_lun
suffix:semicolon
id|need_isa_buffer
op_increment
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
id|dma_sectors
op_assign
(paren
id|dma_sectors
op_plus
l_int|15
)paren
op_amp
l_int|0xfff0
suffix:semicolon
id|dma_free_sectors
op_assign
id|dma_sectors
suffix:semicolon
multiline_comment|/* This must be a multiple of 16 */
id|scsi_init_memory_start
op_assign
(paren
id|scsi_init_memory_start
op_plus
l_int|3
)paren
op_amp
l_int|0xfffffffc
suffix:semicolon
id|dma_malloc_freelist
op_assign
(paren
r_int
r_int
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|dma_sectors
op_rshift
l_int|3
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dma_malloc_freelist
comma
l_int|0
comma
id|dma_sectors
op_rshift
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Some host adapters require buffers to be word aligned */
r_if
c_cond
(paren
id|scsi_init_memory_start
op_amp
l_int|1
)paren
(brace
id|scsi_init_memory_start
op_increment
suffix:semicolon
)brace
id|dma_malloc_buffer
op_assign
(paren
r_int
r_char
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|dma_sectors
op_lshift
l_int|9
)paren
suffix:semicolon
multiline_comment|/* OK, now we finish the initialization by doing spin-up, read&n;&t;   capacity, etc, etc */
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;finish
op_logical_and
id|sdtpnt-&gt;nr_dev
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;finish
)paren
(paren
)paren
suffix:semicolon
)brace
id|scsi_loadable_module_flag
op_assign
l_int|1
suffix:semicolon
r_return
id|scsi_init_memory_start
suffix:semicolon
)brace
DECL|function|print_inquiry
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|data
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Vendor: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Model: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Rev: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
OL
l_int|36
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Type:   %s &quot;
comma
id|i
OL
id|MAX_SCSI_DEVICE_CODE
ques
c_cond
id|scsi_device_types
(braket
id|i
)braket
suffix:colon
l_string|&quot;Unknown          &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                 ANSI SCSI revision: %02x&quot;
comma
id|data
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|data
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot; CCS&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_TIMEOUT
r_static
r_void
DECL|function|scsi_dump_status
id|scsi_dump_status
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|i1
suffix:semicolon
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Dump of scsi parameters:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hosts
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
r_for
c_loop
(paren
id|SCpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
multiline_comment|/*  (0) 0:0:0 (802 123434 8 8 0) (3 3 2) (%d %d %d) %d %x      */
id|printk
c_func
(paren
l_string|&quot;(%d) %d:%d:%d (%4.4x %d %d %d %d) (%d %d %x) (%d %d %d) %x %x %x&bslash;n&quot;
comma
id|i
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;request.dev
comma
id|SCpnt-&gt;request.sector
comma
id|SCpnt-&gt;request.nr_sectors
comma
id|SCpnt-&gt;request.current_nr_sectors
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;retries
comma
id|SCpnt-&gt;allowed
comma
id|SCpnt-&gt;flags
comma
id|SCpnt-&gt;timeout_per_command
comma
id|SCpnt-&gt;timeout
comma
id|SCpnt-&gt;internal_timeout
comma
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
comma
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
comma
id|SCpnt-&gt;result
)paren
suffix:semicolon
)brace
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;wait_for_request = %x&bslash;n&quot;
comma
id|wait_for_request
)paren
suffix:semicolon
multiline_comment|/* Now dump the request lists for each block device */
id|printk
c_func
(paren
l_string|&quot;Dump of pending block device requests&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_BLKDEV
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|blk_dev
(braket
id|i
)braket
dot
id|current_request
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d: &quot;
comma
id|i
)paren
suffix:semicolon
id|req
op_assign
id|blk_dev
(braket
id|i
)braket
dot
id|current_request
suffix:semicolon
r_while
c_loop
(paren
id|req
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(%x %d %d %d %d) &quot;
comma
id|req-&gt;dev
comma
id|req-&gt;cmd
comma
id|req-&gt;sector
comma
id|req-&gt;nr_sectors
comma
id|req-&gt;current_nr_sectors
)paren
suffix:semicolon
id|req
op_assign
id|req-&gt;next
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
