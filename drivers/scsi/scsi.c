multiline_comment|/*&n; *  scsi.c Copyright (C) 1992 Drew Eckhardt&n; *         Copyright (C) 1993, 1994, 1995 Eric Youngdale&n; *&n; *  generic mid-level SCSI driver&n; *      Initial versions: Drew Eckhardt&n; *      Subsequent revisions: Eric Youngdale&n; *&n; *  &lt;drew@colorado.edu&gt;&n; *&n; *  Bug correction thanks go to :&n; *      Rik Faith &lt;faith@cs.unc.edu&gt;&n; *      Tommy Thorn &lt;tthorn&gt;&n; *      Thomas Wuensche &lt;tw@fgb1.fgb.mw.tu-muenchen.de&gt;&n; *&n; *  Modified by Eric Youngdale eric@aib.com to&n; *  add scatter-gather, multiple outstanding request, and other&n; *  enhancements.&n; *&n; *  Native multichannel and wide scsi support added &n; *  by Michael Neuffer neuffer@goofy.zdv.uni-mainz.de&n; *&n; *  Added request_module(&quot;scsi_hostadapter&quot;) for kerneld:&n; *  (Put an &quot;alias scsi_hostadapter your_hostadapter&quot; in /etc/conf.modules)&n; *  Bjorn Ekwall  &lt;bj0rn@blox.se&gt;&n; *&n; *  Major improvements to the timeout, abort, and reset processing,&n; *  as well as performance modifications for large queue depths by&n; *  Leonard N. Zubkoff &lt;lnz@dandelion.com&gt;&n; */
multiline_comment|/*&n; * Don&squot;t import our own symbols, as this would severely mess up our&n; * symbol tables.&n; */
DECL|macro|_SCSI_SYMS_VER_
mdefine_line|#define _SCSI_SYMS_VER_
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#ifdef CONFIG_KERNELD
macro_line|#include &lt;linux/kerneld.h&gt;
macro_line|#endif
DECL|macro|USE_STATIC_SCSI_MEMORY
macro_line|#undef USE_STATIC_SCSI_MEMORY
multiline_comment|/*&n;static const char RCSid[] = &quot;$Header: /usr/src/linux/kernel/blk_drv/scsi/RCS/scsi.c,v 1.5 1993/09/24 12:45:18 drew Exp drew $&quot;;&n;*/
multiline_comment|/* Command groups 3 and 4 are reserved and should never be used.  */
DECL|variable|scsi_command_size
r_const
r_int
r_char
id|scsi_command_size
(braket
l_int|8
)braket
op_assign
(brace
l_int|6
comma
l_int|10
comma
l_int|10
comma
l_int|12
comma
l_int|12
comma
l_int|12
comma
l_int|10
comma
l_int|10
)brace
suffix:semicolon
DECL|macro|INTERNAL_ERROR
mdefine_line|#define INTERNAL_ERROR (panic (&quot;Internal error in file %s, line %d.&bslash;n&quot;, __FILE__, __LINE__))
multiline_comment|/*&n; * PAGE_SIZE must be a multiple of the sector size (512).  True&n; * for all reasonably recent architectures (even the VAX...).&n; */
DECL|macro|SECTOR_SIZE
mdefine_line|#define SECTOR_SIZE&t;&t;512
DECL|macro|SECTORS_PER_PAGE
mdefine_line|#define SECTORS_PER_PAGE&t;(PAGE_SIZE/SECTOR_SIZE)
macro_line|#if SECTORS_PER_PAGE &lt;= 8
DECL|typedef|FreeSectorBitmap
r_typedef
r_int
r_char
id|FreeSectorBitmap
suffix:semicolon
macro_line|#elif SECTORS_PER_PAGE &lt;= 32
DECL|typedef|FreeSectorBitmap
r_typedef
r_int
r_int
id|FreeSectorBitmap
suffix:semicolon
macro_line|#else
macro_line|# error You lose.
macro_line|#endif
r_static
r_void
id|scsi_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_static
r_int
id|update_timeout
(paren
id|Scsi_Cmnd
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|data
)paren
suffix:semicolon
r_static
r_void
id|scsi_times_out
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_static
r_int
id|scan_scsis_single
(paren
r_int
id|channel
comma
r_int
id|dev
comma
r_int
id|lun
comma
r_int
op_star
id|max_scsi_dev
comma
r_int
op_star
id|sparse_lun
comma
id|Scsi_Device
op_star
op_star
id|SDpnt
comma
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_char
op_star
id|scsi_result
)paren
suffix:semicolon
r_void
id|scsi_build_commandblocks
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MODULES
r_extern
r_struct
id|symbol_table
id|scsi_symbol_table
suffix:semicolon
macro_line|#endif
DECL|variable|dma_malloc_freelist
r_static
id|FreeSectorBitmap
op_star
id|dma_malloc_freelist
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|scsi_need_isa_bounce_buffers
r_static
r_int
id|scsi_need_isa_bounce_buffers
suffix:semicolon
DECL|variable|dma_sectors
r_static
r_int
r_int
id|dma_sectors
op_assign
l_int|0
suffix:semicolon
DECL|variable|dma_free_sectors
r_int
r_int
id|dma_free_sectors
op_assign
l_int|0
suffix:semicolon
DECL|variable|need_isa_buffer
r_int
r_int
id|need_isa_buffer
op_assign
l_int|0
suffix:semicolon
DECL|variable|dma_malloc_pages
r_static
r_int
r_char
op_star
op_star
id|dma_malloc_pages
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|time_start
r_static
r_int
id|time_start
suffix:semicolon
DECL|variable|time_elapsed
r_static
r_int
id|time_elapsed
suffix:semicolon
DECL|variable|host_active
r_static
r_volatile
r_struct
id|Scsi_Host
op_star
id|host_active
op_assign
l_int|NULL
suffix:semicolon
DECL|macro|SCSI_BLOCK
mdefine_line|#define SCSI_BLOCK(HOST) ((HOST-&gt;block &amp;&amp; host_active &amp;&amp; HOST != host_active) &bslash;&n;&t;&t;&t;  || (HOST-&gt;can_queue &amp;&amp; HOST-&gt;host_busy &gt;= HOST-&gt;can_queue))
DECL|macro|MAX_SCSI_DEVICE_CODE
mdefine_line|#define MAX_SCSI_DEVICE_CODE 10
DECL|variable|scsi_device_types
r_const
r_char
op_star
r_const
id|scsi_device_types
(braket
id|MAX_SCSI_DEVICE_CODE
)braket
op_assign
(brace
l_string|&quot;Direct-Access    &quot;
comma
l_string|&quot;Sequential-Access&quot;
comma
l_string|&quot;Printer          &quot;
comma
l_string|&quot;Processor        &quot;
comma
l_string|&quot;WORM             &quot;
comma
l_string|&quot;CD-ROM           &quot;
comma
l_string|&quot;Scanner          &quot;
comma
l_string|&quot;Optical Device   &quot;
comma
l_string|&quot;Medium Changer   &quot;
comma
l_string|&quot;Communications   &quot;
)brace
suffix:semicolon
multiline_comment|/*&n; * global variables :&n; * scsi_devices an array of these specifying the address for each&n; * (host, id, LUN)&n; */
DECL|variable|scsi_devices
id|Scsi_Device
op_star
id|scsi_devices
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Process ID of SCSI commands */
DECL|variable|scsi_pid
r_int
r_int
id|scsi_pid
op_assign
l_int|0
suffix:semicolon
DECL|variable|serial_number
r_static
r_int
r_int
id|serial_number
op_assign
l_int|0
suffix:semicolon
DECL|variable|generic_sense
r_static
r_int
r_char
id|generic_sense
(braket
l_int|6
)braket
op_assign
(brace
id|REQUEST_SENSE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|255
comma
l_int|0
)brace
suffix:semicolon
r_static
r_void
id|resize_dma_pool
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* This variable is merely a hook so that we can debug the kernel with gdb. */
DECL|variable|last_cmnd
id|Scsi_Cmnd
op_star
id|last_cmnd
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* This is the pointer to the /proc/scsi code. &n; * It is only initialized to !=0 if the scsi code is present &n; */
macro_line|#if CONFIG_PROC_FS 
r_extern
r_int
(paren
op_star
id|dispatch_scsi_info_ptr
)paren
(paren
r_int
id|ino
comma
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|inout
)paren
suffix:semicolon
r_extern
r_int
id|dispatch_scsi_info
c_func
(paren
r_int
id|ino
comma
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|inout
)paren
suffix:semicolon
DECL|variable|proc_scsi_scsi
r_struct
id|proc_dir_entry
id|proc_scsi_scsi
op_assign
(brace
id|PROC_SCSI_SCSI
comma
l_int|4
comma
l_string|&quot;scsi&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *  This is the number  of clock ticks we should wait before we time out&n; *  and abort the command.  This is for  where the scsi.c module generates&n; *  the command, not where it originates from a higher level, in which&n; *  case the timeout is specified there.&n; *&n; *  ABORT_TIMEOUT and RESET_TIMEOUT are the timeouts for RESET and ABORT&n; *  respectively.&n; */
macro_line|#ifdef DEBUG_TIMEOUT
r_static
r_void
id|scsi_dump_status
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG
DECL|macro|SCSI_TIMEOUT
mdefine_line|#define SCSI_TIMEOUT (5*HZ)
macro_line|#else
DECL|macro|SCSI_TIMEOUT
mdefine_line|#define SCSI_TIMEOUT (2*HZ)
macro_line|#endif
macro_line|#ifdef DEBUG
DECL|macro|SENSE_TIMEOUT
mdefine_line|#define SENSE_TIMEOUT SCSI_TIMEOUT
DECL|macro|ABORT_TIMEOUT
mdefine_line|#define ABORT_TIMEOUT SCSI_TIMEOUT
DECL|macro|RESET_TIMEOUT
mdefine_line|#define RESET_TIMEOUT SCSI_TIMEOUT
macro_line|#else
DECL|macro|SENSE_TIMEOUT
mdefine_line|#define SENSE_TIMEOUT (5*HZ/10)
DECL|macro|RESET_TIMEOUT
mdefine_line|#define RESET_TIMEOUT (5*HZ/10)
DECL|macro|ABORT_TIMEOUT
mdefine_line|#define ABORT_TIMEOUT (5*HZ/10)
macro_line|#endif
DECL|macro|MIN_RESET_DELAY
mdefine_line|#define MIN_RESET_DELAY (2*HZ)
multiline_comment|/* Do not call reset on error if we just did a reset within 15 sec. */
DECL|macro|MIN_RESET_PERIOD
mdefine_line|#define MIN_RESET_PERIOD (15*HZ)
multiline_comment|/* The following devices are known not to tolerate a lun != 0 scan for&n; * one reason or another.  Some will respond to all luns, others will&n; * lock up. &n; */
DECL|macro|BLIST_NOLUN
mdefine_line|#define BLIST_NOLUN     0x01
DECL|macro|BLIST_FORCELUN
mdefine_line|#define BLIST_FORCELUN  0x02
DECL|macro|BLIST_BORKEN
mdefine_line|#define BLIST_BORKEN    0x04
DECL|macro|BLIST_KEY
mdefine_line|#define BLIST_KEY       0x08
DECL|macro|BLIST_SINGLELUN
mdefine_line|#define BLIST_SINGLELUN 0x10
DECL|macro|BLIST_NOTQ
mdefine_line|#define BLIST_NOTQ&t;0x20
DECL|macro|BLIST_SPARSELUN
mdefine_line|#define BLIST_SPARSELUN 0x40
DECL|struct|dev_info
r_struct
id|dev_info
(brace
DECL|member|vendor
r_const
r_char
op_star
id|vendor
suffix:semicolon
DECL|member|model
r_const
r_char
op_star
id|model
suffix:semicolon
DECL|member|revision
r_const
r_char
op_star
id|revision
suffix:semicolon
multiline_comment|/* Latest revision known to be bad.  Not used yet */
DECL|member|flags
r_int
id|flags
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * This is what was previously known as the blacklist.  The concept&n; * has been expanded so that we can specify other types of things we&n; * need to be aware of.&n; */
DECL|variable|device_list
r_static
r_struct
id|dev_info
id|device_list
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;CHINON&quot;
comma
l_string|&quot;CD-ROM CDS-431&quot;
comma
l_string|&quot;H42&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;CHINON&quot;
comma
l_string|&quot;CD-ROM CDS-535&quot;
comma
l_string|&quot;Q14&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;DENON&quot;
comma
l_string|&quot;DRD-25X&quot;
comma
l_string|&quot;V&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if probed for lun != 0 */
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;DK312C&quot;
comma
l_string|&quot;CM81&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun - dtg */
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;DK314C&quot;
comma
l_string|&quot;CR21&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;IMS&quot;
comma
l_string|&quot;CDD521/10&quot;
comma
l_string|&quot;2.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-3280&quot;
comma
l_string|&quot;PR02&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-4380S&quot;
comma
l_string|&quot;B3C&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;MXT-1240S&quot;
comma
l_string|&quot;I1.2&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up when LUN&gt;0 polled */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-4170S&quot;
comma
l_string|&quot;B5A&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up sometimes when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-8760S&quot;
comma
l_string|&quot;B7B&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* guess what? */
(brace
l_string|&quot;MEDIAVIS&quot;
comma
l_string|&quot;RENO CD-ROMX2A&quot;
comma
l_string|&quot;2.03&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/*Responds to all lun */
(brace
l_string|&quot;MICROP&quot;
comma
l_string|&quot;4110&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_NOTQ
)brace
comma
multiline_comment|/* Buggy Tagged Queuing */
(brace
l_string|&quot;NEC&quot;
comma
l_string|&quot;CD-ROM DRIVE:841&quot;
comma
l_string|&quot;1.0&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;RODIME&quot;
comma
l_string|&quot;RO3000S&quot;
comma
l_string|&quot;2.33&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;SANYO&quot;
comma
l_string|&quot;CRD-250S&quot;
comma
l_string|&quot;1.20&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1 &n;&t;&t;&t;&t;&t;&t; * for aha152x controller, which causes &n;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST157N&quot;
comma
l_string|&quot;&bslash;004|j&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1 &n;&t;&t;&t;&t;&t;&t; * for aha152x controller, which causes &n;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST296&quot;
comma
l_string|&quot;921&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST1581&quot;
comma
l_string|&quot;6538&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-541&quot;
comma
l_string|&quot;4.3d&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-55S&quot;
comma
l_string|&quot;1.0i&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-561&quot;
comma
l_string|&quot;1.7x&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;TANDBERG&quot;
comma
l_string|&quot;TDC 3600&quot;
comma
l_string|&quot;U07&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1 &n;&t;&t;&t;&t;&t;&t; * for seagate controller, which causes &n;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;TEXEL&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1 &n;&t;&t;&t;&t;&t;&t; * for seagate controller, which causes &n;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;LPS525S&quot;
comma
l_string|&quot;3110&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks sometimes if polled for lun != 0 */
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;PD1225S&quot;
comma
l_string|&quot;3110&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks sometimes if polled for lun != 0 */
(brace
l_string|&quot;MEDIAVIS&quot;
comma
l_string|&quot;CDR-H93MV&quot;
comma
l_string|&quot;1.31&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;SANKYO&quot;
comma
l_string|&quot;CP525&quot;
comma
l_string|&quot;6.64&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQ SENSE, extra reset */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C1750A&quot;
comma
l_string|&quot;3226&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iic */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C1790A&quot;
comma
l_string|&quot;&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iip */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C2500A&quot;
comma
l_string|&quot;&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iicx */
multiline_comment|/*&n; * Other types of devices that have special flags.&n; */
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-8001&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_BORKEN
)brace
comma
(brace
l_string|&quot;TEXEL&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_BORKEN
)brace
comma
(brace
l_string|&quot;INSITE&quot;
comma
l_string|&quot;Floptical   F*8I&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;INSITE&quot;
comma
l_string|&quot;I325VM&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;NRC&quot;
comma
l_string|&quot;MBR-7&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-602X&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-604X&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;EMULEX&quot;
comma
l_string|&quot;MD21/S2     ESDI&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;CANON&quot;
comma
l_string|&quot;IPUBJD&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
multiline_comment|/*&n; * Must be at end of list...&n; */
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|function|get_device_flags
r_static
r_int
(def_block
id|get_device_flags
c_func
(paren
r_int
r_char
op_star
id|response_data
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|pnt
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|device_list
(braket
id|i
)braket
dot
id|vendor
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|pnt
op_assign
op_amp
id|response_data
(braket
l_int|8
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_eq
l_char|&squot; &squot;
)paren
(brace
id|pnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|vendor
comma
id|pnt
comma
id|strlen
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|vendor
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|pnt
op_assign
op_amp
id|response_data
(braket
l_int|16
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_eq
l_char|&squot; &squot;
)paren
(brace
id|pnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|model
comma
id|pnt
comma
id|strlen
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|model
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_return
id|device_list
(braket
id|i
)braket
dot
id|flags
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)def_block
DECL|function|scsi_make_blocked_list
r_void
id|scsi_make_blocked_list
c_func
(paren
r_void
)paren
(brace
r_int
id|block_count
op_assign
l_int|0
comma
id|index
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|sh
(braket
l_int|128
)braket
comma
op_star
id|shpnt
suffix:semicolon
multiline_comment|/*&n;     * Create a circular linked list from the scsi hosts which have&n;     * the &quot;wish_block&quot; field in the Scsi_Host structure set.&n;     * The blocked list should include all the scsi hosts using ISA DMA.&n;     * In some systems, using two dma channels simultaneously causes&n;     * unpredictable results.&n;     * Among the scsi hosts in the blocked list, only one host at a time&n;     * is allowed to have active commands queued. The transition from&n;     * one active host to the next one is allowed only when host_busy == 0&n;     * for the active host (which implies host_busy == 0 for all the hosts&n;     * in the list). Moreover for block devices the transition to a new&n;     * active host is allowed only when a request is completed, since a&n;     * block device request can be divided into multiple scsi commands&n;     * (when there are few sg lists or clustering is disabled).&n;     *&n;     * (DB, 4 Feb 1995)&n;     */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|host_active
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
macro_line|#if 0
multiline_comment|/*&n;&t; * Is this is a candidate for the blocked list?&n;&t; * Useful to put into the blocked list all the hosts whose driver&n;&t; * does not know about the host-&gt;block feature.&n;&t; */
r_if
c_cond
(paren
id|shpnt-&gt;unchecked_isa_dma
)paren
id|shpnt-&gt;wish_block
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|shpnt-&gt;wish_block
)paren
id|sh
(braket
id|block_count
op_increment
)braket
op_assign
id|shpnt
suffix:semicolon
)brace
r_if
c_cond
(paren
id|block_count
op_eq
l_int|1
)paren
id|sh
(braket
l_int|0
)braket
op_member_access_from_pointer
id|block
op_assign
l_int|NULL
suffix:semicolon
r_else
r_if
c_cond
(paren
id|block_count
OG
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|block_count
op_minus
l_int|1
suffix:semicolon
id|index
op_increment
)paren
(brace
id|sh
(braket
id|index
)braket
op_member_access_from_pointer
id|block
op_assign
id|sh
(braket
id|index
op_plus
l_int|1
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : added to blocked host list.&bslash;n&quot;
comma
id|sh
(braket
id|index
)braket
op_member_access_from_pointer
id|host_no
)paren
suffix:semicolon
)brace
id|sh
(braket
id|block_count
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|block
op_assign
id|sh
(braket
l_int|0
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : added to blocked host list.&bslash;n&quot;
comma
id|sh
(braket
id|index
)braket
op_member_access_from_pointer
id|host_no
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|scan_scsis_done
r_static
r_void
id|scan_scsis_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;scan_scsis_done(%p, %06x)&bslash;n&quot;
comma
id|SCpnt-&gt;host
comma
id|SCpnt-&gt;result
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request.sem
op_ne
l_int|NULL
)paren
id|up
c_func
(paren
id|SCpnt-&gt;request.sem
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SCSI_MULTI_LUN
DECL|variable|max_scsi_luns
r_static
r_int
id|max_scsi_luns
op_assign
l_int|8
suffix:semicolon
macro_line|#else
DECL|variable|max_scsi_luns
r_static
r_int
id|max_scsi_luns
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
DECL|function|scsi_luns_setup
r_void
id|scsi_luns_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ne
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;scsi_luns_setup : usage max_scsi_luns=n (n should be between 1 and 8)&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|max_scsi_luns
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; *  Detecting SCSI devices :&n; *  We scan all present host adapter&squot;s busses,  from ID 0 to ID (max_id).&n; *  We use the INQUIRY command, determine device type, and pass the ID /&n; *  lun address of all sequential devices to the tape driver, all random&n; *  devices to the disk driver.&n; */
DECL|function|scan_scsis
r_static
r_void
id|scan_scsis
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
id|unchar
id|hardcoded
comma
id|unchar
id|hchannel
comma
id|unchar
id|hid
comma
id|unchar
id|hlun
)paren
(brace
r_int
id|dev
comma
id|lun
comma
id|channel
suffix:semicolon
r_int
r_char
id|scsi_result0
(braket
l_int|256
)braket
suffix:semicolon
r_int
r_char
op_star
id|scsi_result
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_int
id|max_dev_lun
comma
id|sparse_lun
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|scsi_init_malloc
(paren
r_sizeof
(paren
id|Scsi_Cmnd
)paren
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
id|SDpnt
op_assign
(paren
id|Scsi_Device
op_star
)paren
id|scsi_init_malloc
(paren
r_sizeof
(paren
id|Scsi_Device
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|memset
(paren
id|SCpnt
comma
l_int|0
comma
r_sizeof
(paren
id|Scsi_Cmnd
)paren
)paren
suffix:semicolon
multiline_comment|/* Make sure we have something that is valid for DMA purposes */
id|scsi_result
op_assign
(paren
(paren
op_logical_neg
id|shpnt-&gt;unchecked_isa_dma
)paren
ques
c_cond
op_amp
id|scsi_result0
(braket
l_int|0
)braket
suffix:colon
id|scsi_init_malloc
(paren
l_int|512
comma
id|GFP_DMA
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_result
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;Unable to obtain scsi_result buffer&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/* We must chain ourself in the host_queue, so commands can time out */
r_if
c_cond
(paren
id|shpnt-&gt;host_queue
)paren
(brace
id|shpnt-&gt;host_queue-&gt;prev
op_assign
id|SCpnt
suffix:semicolon
)brace
id|SCpnt-&gt;next
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SCpnt-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|shpnt-&gt;host_queue
op_assign
id|SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|hardcoded
op_eq
l_int|1
)paren
(brace
id|Scsi_Device
op_star
id|oldSDpnt
op_assign
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
id|channel
op_assign
id|hchannel
suffix:semicolon
r_if
c_cond
(paren
id|channel
OG
id|shpnt-&gt;max_channel
)paren
(brace
r_goto
id|leave
suffix:semicolon
)brace
id|dev
op_assign
id|hid
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ge
id|shpnt-&gt;max_id
)paren
(brace
r_goto
id|leave
suffix:semicolon
)brace
id|lun
op_assign
id|hlun
suffix:semicolon
r_if
c_cond
(paren
id|lun
op_ge
id|shpnt-&gt;max_lun
)paren
(brace
r_goto
id|leave
suffix:semicolon
)brace
id|scan_scsis_single
(paren
id|channel
comma
id|dev
comma
id|lun
comma
op_amp
id|max_dev_lun
comma
op_amp
id|sparse_lun
comma
op_amp
id|SDpnt
comma
id|SCpnt
comma
id|shpnt
comma
id|scsi_result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt
op_ne
id|oldSDpnt
)paren
(brace
multiline_comment|/* it could happen the blockdevice hasn&squot;t yet been inited */
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;init
op_logical_and
id|sdtpnt-&gt;dev_noticed
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;init
)paren
(paren
)paren
suffix:semicolon
)brace
id|oldSDpnt-&gt;scsi_request_fn
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;attach
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;attach
)paren
(paren
id|oldSDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldSDpnt-&gt;attached
)paren
(brace
id|scsi_build_commandblocks
c_func
(paren
id|oldSDpnt
)paren
suffix:semicolon
)brace
)brace
id|resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|sdtpnt-&gt;finish
op_logical_and
id|sdtpnt-&gt;nr_dev
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;finish
)paren
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|channel
op_assign
l_int|0
suffix:semicolon
id|channel
op_le
id|shpnt-&gt;max_channel
suffix:semicolon
id|channel
op_increment
)paren
(brace
r_for
c_loop
(paren
id|dev
op_assign
l_int|0
suffix:semicolon
id|dev
OL
id|shpnt-&gt;max_id
suffix:semicolon
op_increment
id|dev
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;this_id
op_ne
id|dev
)paren
(brace
multiline_comment|/*&n;           * We need the for so our continue, etc. work fine. We put this in&n;           * a variable so that we can override it during the scan if we&n;           * detect a device *KNOWN* to have multiple logical units.&n;           */
id|max_dev_lun
op_assign
(paren
id|max_scsi_luns
OL
id|shpnt-&gt;max_lun
ques
c_cond
id|max_scsi_luns
suffix:colon
id|shpnt-&gt;max_lun
)paren
suffix:semicolon
id|sparse_lun
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
id|max_dev_lun
suffix:semicolon
op_increment
id|lun
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|scan_scsis_single
(paren
id|channel
comma
id|dev
comma
id|lun
comma
op_amp
id|max_dev_lun
comma
op_amp
id|sparse_lun
comma
op_amp
id|SDpnt
comma
id|SCpnt
comma
id|shpnt
comma
id|scsi_result
)paren
op_logical_and
op_logical_neg
id|sparse_lun
)paren
r_break
suffix:semicolon
multiline_comment|/* break means don&squot;t probe further for luns!=0 */
)brace
multiline_comment|/* for lun ends */
)brace
multiline_comment|/* if this_id != id ends */
)brace
multiline_comment|/* for dev ends */
)brace
multiline_comment|/* for channel ends */
)brace
multiline_comment|/* if/else hardcoded */
id|leave
suffix:colon
(brace
multiline_comment|/* Unchain SCpnt from host_queue */
id|Scsi_Cmnd
op_star
id|prev
comma
op_star
id|next
comma
op_star
id|hqptr
suffix:semicolon
r_for
c_loop
(paren
id|hqptr
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|hqptr
op_ne
id|SCpnt
suffix:semicolon
id|hqptr
op_assign
id|hqptr-&gt;next
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hqptr
)paren
(brace
id|prev
op_assign
id|hqptr-&gt;prev
suffix:semicolon
id|next
op_assign
id|hqptr-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
(brace
id|prev-&gt;next
op_assign
id|next
suffix:semicolon
)brace
r_else
id|shpnt-&gt;host_queue
op_assign
id|next
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
(brace
id|next-&gt;prev
op_assign
id|prev
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Last device block does not exist.  Free memory. */
r_if
c_cond
(paren
id|SDpnt
op_ne
l_int|NULL
)paren
id|scsi_init_free
(paren
(paren
r_char
op_star
)paren
id|SDpnt
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_ne
l_int|NULL
)paren
id|scsi_init_free
(paren
(paren
r_char
op_star
)paren
id|SCpnt
comma
r_sizeof
(paren
id|Scsi_Cmnd
)paren
)paren
suffix:semicolon
multiline_comment|/* If we allocated a buffer so we could do DMA, free it now */
r_if
c_cond
(paren
id|scsi_result
op_ne
op_amp
id|scsi_result0
(braket
l_int|0
)braket
op_logical_and
id|scsi_result
op_ne
l_int|NULL
)paren
id|scsi_init_free
(paren
id|scsi_result
comma
l_int|512
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The worker for scan_scsis.&n; * Returning 0 means Please don&squot;t ask further for lun!=0, 1 means OK go on.&n; * Global variables used : scsi_devices(linked list)&n; */
DECL|function|scan_scsis_single
r_int
id|scan_scsis_single
(paren
r_int
id|channel
comma
r_int
id|dev
comma
r_int
id|lun
comma
r_int
op_star
id|max_dev_lun
comma
r_int
op_star
id|sparse_lun
comma
id|Scsi_Device
op_star
op_star
id|SDpnt2
comma
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_char
op_star
id|scsi_result
)paren
(brace
r_int
r_char
id|scsi_cmd
(braket
l_int|12
)braket
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDtail
comma
op_star
id|SDpnt
op_assign
op_star
id|SDpnt2
suffix:semicolon
r_int
id|bflags
comma
id|type
op_assign
op_minus
l_int|1
suffix:semicolon
id|SDtail
op_assign
id|scsi_devices
suffix:semicolon
r_if
c_cond
(paren
id|scsi_devices
)paren
r_while
c_loop
(paren
id|SDtail-&gt;next
)paren
id|SDtail
op_assign
id|SDtail-&gt;next
suffix:semicolon
id|memset
(paren
id|SDpnt
comma
l_int|0
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
id|SDpnt-&gt;host
op_assign
id|shpnt
suffix:semicolon
id|SDpnt-&gt;id
op_assign
id|dev
suffix:semicolon
id|SDpnt-&gt;lun
op_assign
id|lun
suffix:semicolon
id|SDpnt-&gt;channel
op_assign
id|channel
suffix:semicolon
multiline_comment|/* Some low level driver could use device-&gt;type (DB) */
id|SDpnt-&gt;type
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;   * Assume that the device will have handshaking problems, and then fix this&n;   * field later if it turns out it doesn&squot;t&n;   */
id|SDpnt-&gt;borken
op_assign
l_int|1
suffix:semicolon
id|SDpnt-&gt;was_reset
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;expecting_cc_ua
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|TEST_UNIT_READY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
id|lun
op_lshift
l_int|5
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;host
op_assign
id|SDpnt-&gt;host
suffix:semicolon
id|SCpnt-&gt;device
op_assign
id|SDpnt
suffix:semicolon
id|SCpnt-&gt;target
op_assign
id|SDpnt-&gt;id
suffix:semicolon
id|SCpnt-&gt;lun
op_assign
id|SDpnt-&gt;lun
suffix:semicolon
id|SCpnt-&gt;channel
op_assign
id|SDpnt-&gt;channel
suffix:semicolon
(brace
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
op_amp
id|sem
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|scsi_do_cmd
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|256
comma
id|scan_scsis_done
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|5
)paren
suffix:semicolon
id|down
(paren
op_amp
id|sem
)paren
suffix:semicolon
)brace
macro_line|#if defined(DEBUG) || defined(DEBUG_INIT)
id|printk
(paren
l_string|&quot;scsi: scan_scsis_single id %d lun %d. Return code 0x%08x&bslash;n&quot;
comma
id|dev
comma
id|lun
comma
id|SCpnt-&gt;result
)paren
suffix:semicolon
id|print_driverbyte
c_func
(paren
id|SCpnt-&gt;result
)paren
suffix:semicolon
id|print_hostbyte
c_func
(paren
id|SCpnt-&gt;result
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SCpnt-&gt;result
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|driver_byte
(paren
id|SCpnt-&gt;result
)paren
op_amp
id|DRIVER_SENSE
)paren
op_logical_or
(paren
id|status_byte
(paren
id|SCpnt-&gt;result
)paren
op_amp
id|CHECK_CONDITION
)paren
)paren
op_logical_and
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x70
)paren
op_rshift
l_int|4
)paren
op_eq
l_int|7
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|NOT_READY
)paren
op_logical_and
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|UNIT_ATTENTION
)paren
op_logical_and
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|ILLEGAL_REQUEST
op_logical_or
id|lun
OG
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if defined (DEBUG) || defined(DEBUG_INIT)
id|printk
(paren
l_string|&quot;scsi: performing INQUIRY&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;   * Build an INQUIRY command block.&n;   */
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|255
suffix:semicolon
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
(brace
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
op_amp
id|sem
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|scsi_do_cmd
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|256
comma
id|scan_scsis_done
comma
id|SCSI_TIMEOUT
comma
l_int|3
)paren
suffix:semicolon
id|down
(paren
op_amp
id|sem
)paren
suffix:semicolon
)brace
macro_line|#if defined(DEBUG) || defined(DEBUG_INIT)
id|printk
(paren
l_string|&quot;scsi: INQUIRY %s with code 0x%x&bslash;n&quot;
comma
id|SCpnt-&gt;result
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;successful&quot;
comma
id|SCpnt-&gt;result
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SCpnt-&gt;result
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* assume no peripheral if any sort of error */
multiline_comment|/*&n;   * Check the peripheral qualifier field - this tells us whether LUNS&n;   * are supported here or not.&n;   */
r_if
c_cond
(paren
(paren
id|scsi_result
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
op_eq
l_int|3
)paren
(brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* assume no peripheral if any sort of error */
)brace
multiline_comment|/*&n;   * It would seem some TOSHIBA CDROM gets things wrong&n;   */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
(paren
id|scsi_result
op_plus
l_int|8
comma
l_string|&quot;TOSHIBA&quot;
comma
l_int|7
)paren
op_logical_and
op_logical_neg
id|strncmp
(paren
id|scsi_result
op_plus
l_int|16
comma
l_string|&quot;CD-ROM&quot;
comma
l_int|6
)paren
op_logical_and
id|scsi_result
(braket
l_int|0
)braket
op_eq
id|TYPE_DISK
)paren
(brace
id|scsi_result
(braket
l_int|0
)braket
op_assign
id|TYPE_ROM
suffix:semicolon
id|scsi_result
(braket
l_int|1
)braket
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* removable */
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
(paren
id|scsi_result
op_plus
l_int|8
comma
l_string|&quot;NEC&quot;
comma
l_int|3
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
(paren
id|scsi_result
op_plus
l_int|16
comma
l_string|&quot;CD-ROM DRIVE:84 &quot;
comma
l_int|16
)paren
op_logical_or
op_logical_neg
id|strncmp
(paren
id|scsi_result
op_plus
l_int|16
comma
l_string|&quot;CD-ROM DRIVE:25&quot;
comma
l_int|15
)paren
)paren
id|SDpnt-&gt;manufacturer
op_assign
id|SCSI_MAN_NEC_OLDCDR
suffix:semicolon
r_else
id|SDpnt-&gt;manufacturer
op_assign
id|SCSI_MAN_NEC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
(paren
id|scsi_result
op_plus
l_int|8
comma
l_string|&quot;TOSHIBA&quot;
comma
l_int|7
)paren
)paren
id|SDpnt-&gt;manufacturer
op_assign
id|SCSI_MAN_TOSHIBA
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
(paren
id|scsi_result
op_plus
l_int|8
comma
l_string|&quot;SONY&quot;
comma
l_int|4
)paren
)paren
id|SDpnt-&gt;manufacturer
op_assign
id|SCSI_MAN_SONY
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
(paren
id|scsi_result
op_plus
l_int|8
comma
l_string|&quot;PIONEER&quot;
comma
l_int|7
)paren
)paren
id|SDpnt-&gt;manufacturer
op_assign
id|SCSI_MAN_PIONEER
suffix:semicolon
r_else
id|SDpnt-&gt;manufacturer
op_assign
id|SCSI_MAN_UNKNOWN
suffix:semicolon
id|memcpy
(paren
id|SDpnt-&gt;vendor
comma
id|scsi_result
op_plus
l_int|8
comma
l_int|8
)paren
suffix:semicolon
id|memcpy
(paren
id|SDpnt-&gt;model
comma
id|scsi_result
op_plus
l_int|16
comma
l_int|16
)paren
suffix:semicolon
id|memcpy
(paren
id|SDpnt-&gt;rev
comma
id|scsi_result
op_plus
l_int|32
comma
l_int|4
)paren
suffix:semicolon
id|SDpnt-&gt;removable
op_assign
(paren
l_int|0x80
op_amp
id|scsi_result
(braket
l_int|1
)braket
)paren
op_rshift
l_int|7
suffix:semicolon
id|SDpnt-&gt;lockable
op_assign
id|SDpnt-&gt;removable
suffix:semicolon
id|SDpnt-&gt;changed
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;access_count
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;has_cmdblocks
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   * Currently, all sequential devices are assumed to be tapes, all random&n;   * devices disk, with the appropriate read only flags set for ROM / WORM&n;   * treated as RO.&n;   */
r_switch
c_cond
(paren
id|type
op_assign
(paren
id|scsi_result
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
)paren
(brace
r_case
id|TYPE_TAPE
suffix:colon
r_case
id|TYPE_DISK
suffix:colon
r_case
id|TYPE_MOD
suffix:colon
r_case
id|TYPE_PROCESSOR
suffix:colon
r_case
id|TYPE_SCANNER
suffix:colon
id|SDpnt-&gt;writeable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_WORM
suffix:colon
r_case
id|TYPE_ROM
suffix:colon
id|SDpnt-&gt;writeable
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;scsi: unknown type %d&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
)brace
id|SDpnt-&gt;single_lun
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;soft_reset
op_assign
(paren
id|scsi_result
(braket
l_int|7
)braket
op_amp
l_int|1
)paren
op_logical_and
(paren
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|7
)paren
op_eq
l_int|2
)paren
suffix:semicolon
id|SDpnt-&gt;random
op_assign
(paren
id|type
op_eq
id|TYPE_TAPE
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|SDpnt-&gt;type
op_assign
(paren
id|type
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|print_inquiry
(paren
id|scsi_result
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;detect
)paren
id|SDpnt-&gt;attached
op_add_assign
(paren
op_star
id|sdtpnt-&gt;detect
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
id|SDpnt-&gt;scsi_level
op_assign
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;scsi_level
op_ge
l_int|2
op_logical_or
(paren
id|SDpnt-&gt;scsi_level
op_eq
l_int|1
op_logical_and
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
)paren
id|SDpnt-&gt;scsi_level
op_increment
suffix:semicolon
multiline_comment|/*&n;   * Accommodate drivers that want to sleep when they should be in a polling&n;   * loop.&n;   */
id|SDpnt-&gt;disconnect
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   * Get any flags for this device.&n;   */
id|bflags
op_assign
id|get_device_flags
(paren
id|scsi_result
)paren
suffix:semicolon
multiline_comment|/*&n;   * Set the tagged_queue flag for SCSI-II devices that purport to support&n;   * tagged queuing in the INQUIRY data.&n;   */
id|SDpnt-&gt;tagged_queue
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|SDpnt-&gt;scsi_level
op_ge
id|SCSI_2
)paren
op_logical_and
(paren
id|scsi_result
(braket
l_int|7
)braket
op_amp
l_int|2
)paren
op_logical_and
op_logical_neg
(paren
id|bflags
op_amp
id|BLIST_NOTQ
)paren
)paren
(brace
id|SDpnt-&gt;tagged_supported
op_assign
l_int|1
suffix:semicolon
id|SDpnt-&gt;current_tag
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;   * Some revisions of the Texel CD ROM drives have handshaking problems when&n;   * used with the Seagate controllers.  Before we know what type of device&n;   * we&squot;re talking to, we assume it&squot;s borken and then change it here if it&n;   * turns out that it isn&squot;t a TEXEL drive.&n;   */
r_if
c_cond
(paren
(paren
id|bflags
op_amp
id|BLIST_BORKEN
)paren
op_eq
l_int|0
)paren
id|SDpnt-&gt;borken
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   * These devices need this &quot;key&quot; to unlock the devices so we can use it&n;   */
r_if
c_cond
(paren
(paren
id|bflags
op_amp
id|BLIST_KEY
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;Unlocked floptical drive.&bslash;n&quot;
)paren
suffix:semicolon
id|SDpnt-&gt;lockable
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x2e
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|0x2a
suffix:semicolon
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
(brace
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
op_amp
id|sem
suffix:semicolon
id|scsi_do_cmd
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|0x2a
comma
id|scan_scsis_done
comma
id|SCSI_TIMEOUT
comma
l_int|3
)paren
suffix:semicolon
id|down
(paren
op_amp
id|sem
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Add this device to the linked list at the end */
r_if
c_cond
(paren
id|SDtail
)paren
id|SDtail-&gt;next
op_assign
id|SDpnt
suffix:semicolon
r_else
id|scsi_devices
op_assign
id|SDpnt
suffix:semicolon
id|SDtail
op_assign
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
(paren
id|Scsi_Device
op_star
)paren
id|scsi_init_malloc
(paren
r_sizeof
(paren
id|Scsi_Device
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
op_star
id|SDpnt2
op_assign
id|SDpnt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SDpnt
)paren
id|printk
(paren
l_string|&quot;scsi: scan_scsis_single: Cannot malloc&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;   * Some scsi devices cannot be polled for lun != 0 due to firmware bugs&n;   */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_NOLUN
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* break; */
multiline_comment|/*&n;   * If we want to only allow I/O to one of the luns attached to this device&n;   * at a time, then we set this flag.&n;   */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_SINGLELUN
)paren
id|SDpnt-&gt;single_lun
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;   * If this device is known to support sparse multiple units, override the&n;   * other settings, and scan all of them.&n;   */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_SPARSELUN
)paren
(brace
op_star
id|max_dev_lun
op_assign
l_int|8
suffix:semicolon
op_star
id|sparse_lun
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;   * If this device is known to support multiple units, override the other&n;   * settings, and scan all of them.&n;   */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_FORCELUN
)paren
(brace
op_star
id|max_dev_lun
op_assign
l_int|8
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;   * We assume the device can&squot;t handle lun!=0 if: - it reports scsi-0 (ANSI&n;   * SCSI Revision 0) (old drives like MAXTOR XT-3280) or - it reports scsi-1&n;   * (ANSI SCSI Revision 1) and Response Data Format 0&n;   */
r_if
c_cond
(paren
(paren
(paren
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *  Flag bits for the internal_timeout array&n; */
DECL|macro|NORMAL_TIMEOUT
mdefine_line|#define NORMAL_TIMEOUT 0
DECL|macro|IN_ABORT
mdefine_line|#define IN_ABORT  1
DECL|macro|IN_RESET
mdefine_line|#define IN_RESET  2
DECL|macro|IN_RESET2
mdefine_line|#define IN_RESET2 4
DECL|macro|IN_RESET3
mdefine_line|#define IN_RESET3 8
multiline_comment|/*&n; * This is our time out function, called when the timer expires for a&n; * given host adapter.  It will attempt to abort the currently executing&n; * command, that failing perform a kernel panic.&n; */
DECL|function|scsi_times_out
r_static
r_void
id|scsi_times_out
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_switch
c_cond
(paren
id|SCpnt-&gt;internal_timeout
op_amp
(paren
id|IN_ABORT
op_or
id|IN_RESET
op_or
id|IN_RESET2
op_or
id|IN_RESET3
)paren
)paren
(brace
r_case
id|NORMAL_TIMEOUT
suffix:colon
(brace
macro_line|#ifdef DEBUG_TIMEOUT
id|scsi_dump_status
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
op_logical_neg
id|scsi_abort
(paren
id|SCpnt
comma
id|DID_TIME_OUT
)paren
)paren
r_return
suffix:semicolon
r_case
id|IN_ABORT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SCSI host %d abort (pid %ld) timed out - resetting&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_reset
(paren
id|SCpnt
comma
id|SCSI_RESET_ASYNCHRONOUS
)paren
)paren
r_return
suffix:semicolon
r_case
id|IN_RESET
suffix:colon
r_case
(paren
id|IN_ABORT
op_or
id|IN_RESET
)paren
suffix:colon
multiline_comment|/* This might be controversial, but if there is a bus hang,&n;&t; * you might conceivably want the machine up and running&n;&t; * esp if you have an ide disk. &n;&t; */
id|printk
c_func
(paren
l_string|&quot;SCSI host %d channel %d reset (pid %ld) timed out - &quot;
l_string|&quot;trying harder&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_RESET
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_or_assign
id|IN_RESET2
suffix:semicolon
id|scsi_reset
(paren
id|SCpnt
comma
id|SCSI_RESET_ASYNCHRONOUS
op_or
id|SCSI_RESET_SUGGEST_BUS_RESET
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
(paren
id|IN_ABORT
op_or
id|IN_RESET
op_or
id|IN_RESET2
)paren
suffix:colon
multiline_comment|/* Obviously the bus reset didn&squot;t work.&n;&t; * Let&squot;s try even harder and call for an HBA reset.&n;         * Maybe the HBA itself crashed and this will shake it loose.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;SCSI host %d reset (pid %ld) timed out - trying to shake it loose&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
(paren
id|IN_RESET
op_or
id|IN_RESET2
)paren
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_or_assign
id|IN_RESET3
suffix:semicolon
id|scsi_reset
(paren
id|SCpnt
comma
id|SCSI_RESET_ASYNCHRONOUS
op_or
id|SCSI_RESET_SUGGEST_HOST_RESET
)paren
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SCSI host %d reset (pid %ld) timed out again -&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;pid
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;probably an unrecoverable SCSI bus or device hang.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* This function takes a quick look at a request, and decides if it&n; * can be queued now, or if there would be a stall while waiting for&n; * something else to finish.  This routine assumes that interrupts are&n; * turned off when entering the routine.  It is the responsibility&n; * of the calling code to ensure that this is the case. &n; */
DECL|function|request_queueable
id|Scsi_Cmnd
op_star
id|request_queueable
(paren
r_struct
id|request
op_star
id|req
comma
id|Scsi_Device
op_star
id|device
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tablesize
suffix:semicolon
id|Scsi_Cmnd
op_star
id|found
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|bhp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
id|panic
(paren
l_string|&quot;No device passed to request_queueable().&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
op_logical_and
id|req-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
id|panic
c_func
(paren
l_string|&quot;Inactive in request_queueable&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * Look for a free command block.  If we have been instructed not to queue&n;     * multiple commands to multi-lun devices, then check to see what else is &n;     * going for this device first.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;single_lun
)paren
(brace
id|SCpnt
op_assign
id|device-&gt;device_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_break
suffix:semicolon
)brace
id|SCpnt
op_assign
id|SCpnt-&gt;device_next
suffix:semicolon
)brace
)brace
r_else
(brace
id|SCpnt
op_assign
id|device-&gt;host-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;channel
op_eq
id|device-&gt;channel
op_logical_and
id|SCpnt-&gt;target
op_eq
id|device-&gt;id
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;lun
op_eq
id|device-&gt;lun
)paren
(brace
r_if
c_cond
(paren
id|found
op_eq
l_int|NULL
op_logical_and
id|SCpnt-&gt;request.rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
id|found
op_assign
id|SCpnt
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
)paren
(brace
multiline_comment|/*&n;&t;&t;     * I think that we should really limit things to one&n;&t;&t;     * outstanding command per device - this is what tends &n;                     * to trip up buggy firmware.&n;&t;&t;     */
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
id|SCpnt
op_assign
id|SCpnt-&gt;next
suffix:semicolon
)brace
id|SCpnt
op_assign
id|found
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|SCSI_BLOCK
c_func
(paren
id|device-&gt;host
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|SCpnt-&gt;request
comma
id|req
comma
r_sizeof
(paren
r_struct
id|request
)paren
)paren
suffix:semicolon
id|tablesize
op_assign
id|device-&gt;host-&gt;sg_tablesize
suffix:semicolon
id|bhp
op_assign
id|bh
op_assign
id|req-&gt;bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tablesize
)paren
(brace
id|bh
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Take a quick look through the table to see how big it is.  &n;&t; * We already have our copy of req, so we can mess with that &n;&t; * if we want to. &n;&t; */
r_while
c_loop
(paren
id|req-&gt;nr_sectors
op_logical_and
id|bh
)paren
(brace
id|bhp
op_assign
id|bhp-&gt;b_reqnext
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bhp
op_logical_or
op_logical_neg
id|CONTIGUOUS_BUFFERS
c_func
(paren
id|bh
comma
id|bhp
)paren
)paren
(brace
id|tablesize
op_decrement
suffix:semicolon
)brace
id|req-&gt;nr_sectors
op_sub_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|req-&gt;sector
op_add_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tablesize
)paren
(brace
r_break
suffix:semicolon
)brace
id|bh
op_assign
id|bhp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|req-&gt;nr_sectors
op_logical_and
id|bh
op_logical_and
id|bh-&gt;b_reqnext
)paren
(brace
multiline_comment|/* Any leftovers? */
id|SCpnt-&gt;request.bhtail
op_assign
id|bh
suffix:semicolon
id|req-&gt;bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
multiline_comment|/* Divide request */
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
id|bh
op_assign
id|req-&gt;bh
suffix:semicolon
multiline_comment|/* Now reset things so that req looks OK */
id|SCpnt-&gt;request.nr_sectors
op_sub_assign
id|req-&gt;nr_sectors
suffix:semicolon
id|req-&gt;current_nr_sectors
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|req-&gt;buffer
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Wait until whole thing done */
)brace
r_else
(brace
id|req-&gt;rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|wait_for_request
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
multiline_comment|/* Busy, but no request */
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* And no one is waiting for the device &n;&t;&t;&t;&t;      * either */
)brace
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the scatter-gather flag */
id|SCpnt-&gt;old_use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Since not everyone seems to set the device info correctly&n; * before Scsi_Cmnd gets send out to scsi_do_command, we do it here.&n; */
id|SCpnt-&gt;channel
op_assign
id|device-&gt;channel
suffix:semicolon
id|SCpnt-&gt;lun
op_assign
id|device-&gt;lun
suffix:semicolon
id|SCpnt-&gt;target
op_assign
id|device-&gt;id
suffix:semicolon
r_return
id|SCpnt
suffix:semicolon
)brace
multiline_comment|/* This function returns a structure pointer that will be valid for&n; * the device.  The wait parameter tells us whether we should wait for&n; * the unit to become free or not.  We are also able to tell this routine&n; * not to return a descriptor if the host is unable to accept any more&n; * commands for the time being.  We need to keep in mind that there is no&n; * guarantee that the host remain not busy.  Keep in mind the&n; * request_queueable function also knows the internal allocation scheme&n; * of the packets for each device &n; */
DECL|function|allocate_device
id|Scsi_Cmnd
op_star
id|allocate_device
(paren
r_struct
id|request
op_star
op_star
id|reqp
comma
id|Scsi_Device
op_star
id|device
comma
r_int
id|wait
)paren
(brace
id|kdev_t
id|dev
suffix:semicolon
r_struct
id|request
op_star
id|req
op_assign
l_int|NULL
suffix:semicolon
r_int
id|tablesize
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|bhp
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCwait
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Cmnd
op_star
id|found
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
id|panic
(paren
l_string|&quot;No device passed to allocate_device().&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reqp
)paren
id|req
op_assign
op_star
id|reqp
suffix:semicolon
multiline_comment|/* See if this request has already been queued by an interrupt routine */
r_if
c_cond
(paren
id|req
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|dev
op_assign
id|req-&gt;rq_dev
suffix:semicolon
)brace
r_else
id|dev
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unused */
id|host
op_assign
id|device-&gt;host
suffix:semicolon
r_if
c_cond
(paren
id|intr_count
op_logical_and
id|SCSI_BLOCK
c_func
(paren
id|host
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
l_int|1
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;single_lun
)paren
(brace
id|SCpnt
op_assign
id|device-&gt;device_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt
)paren
(brace
id|SCwait
op_assign
id|SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_break
suffix:semicolon
)brace
id|SCpnt
op_assign
id|SCpnt-&gt;device_next
suffix:semicolon
)brace
)brace
r_else
(brace
id|SCpnt
op_assign
id|device-&gt;host-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;channel
op_eq
id|device-&gt;channel
op_logical_and
id|SCpnt-&gt;target
op_eq
id|device-&gt;id
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;lun
op_eq
id|device-&gt;lun
)paren
(brace
id|SCwait
op_assign
id|SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|found
op_eq
l_int|NULL
op_logical_and
id|SCpnt-&gt;request.rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
id|found
op_assign
id|SCpnt
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * I think that we should really limit things to one&n;&t;&t;&t; * outstanding command per device - this is what tends&n;                         * to trip up buggy firmware.&n;&t;&t;&t; */
id|found
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|SCpnt
op_assign
id|SCpnt-&gt;next
suffix:semicolon
)brace
id|SCpnt
op_assign
id|found
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* See if this request has already been queued by an interrupt routine&n;&t; */
r_if
c_cond
(paren
id|req
op_logical_and
(paren
id|req-&gt;rq_status
op_eq
id|RQ_INACTIVE
op_logical_or
id|req-&gt;rq_dev
op_ne
id|dev
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
op_logical_or
id|SCpnt-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
)paren
multiline_comment|/* Might have changed */
(brace
macro_line|#if 1&t;/* NEW CODE */
r_if
c_cond
(paren
id|wait
op_logical_and
id|SCwait
op_logical_and
id|SCwait-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|device-&gt;device_wait
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCwait
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to allocate device channel %d,&quot;
l_string|&quot; target %d, lun %d&bslash;n&quot;
comma
id|device-&gt;channel
comma
id|device-&gt;id
comma
id|device-&gt;lun
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;No device found in allocate_device&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#else&t;/* ORIGINAL CODE */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|SCwait
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to allocate device channel %d, target&quot;
l_string|&quot; %d, lun %d&bslash;n&quot;
comma
id|device-&gt;channel
comma
id|device-&gt;id
comma
id|device-&gt;lun
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;No device found in allocate_device&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|SCSI_SLEEP
c_func
(paren
op_amp
id|device-&gt;device_wait
comma
(paren
id|SCwait-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
id|req
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|SCpnt-&gt;request
comma
id|req
comma
r_sizeof
(paren
r_struct
id|request
)paren
)paren
suffix:semicolon
id|tablesize
op_assign
id|device-&gt;host-&gt;sg_tablesize
suffix:semicolon
id|bhp
op_assign
id|bh
op_assign
id|req-&gt;bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tablesize
)paren
(brace
id|bh
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Take a quick look through the table to see how big it is.  &n;&t;&t; * We already have our copy of req, so we can mess with that &n;&t;&t; * if we want to.  &n;&t;&t; */
r_while
c_loop
(paren
id|req-&gt;nr_sectors
op_logical_and
id|bh
)paren
(brace
id|bhp
op_assign
id|bhp-&gt;b_reqnext
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bhp
op_logical_or
op_logical_neg
id|CONTIGUOUS_BUFFERS
c_func
(paren
id|bh
comma
id|bhp
)paren
)paren
(brace
id|tablesize
op_decrement
suffix:semicolon
)brace
id|req-&gt;nr_sectors
op_sub_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|req-&gt;sector
op_add_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tablesize
)paren
(brace
r_break
suffix:semicolon
)brace
id|bh
op_assign
id|bhp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|req-&gt;nr_sectors
op_logical_and
id|bh
op_logical_and
id|bh-&gt;b_reqnext
)paren
(brace
multiline_comment|/* Any leftovers? */
id|SCpnt-&gt;request.bhtail
op_assign
id|bh
suffix:semicolon
id|req-&gt;bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
multiline_comment|/* Divide request */
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
id|bh
op_assign
id|req-&gt;bh
suffix:semicolon
multiline_comment|/* Now reset things so that req looks OK */
id|SCpnt-&gt;request.nr_sectors
op_sub_assign
id|req-&gt;nr_sectors
suffix:semicolon
id|req-&gt;current_nr_sectors
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|req-&gt;buffer
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Wait until whole thing done*/
)brace
r_else
(brace
id|req-&gt;rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
op_star
id|reqp
op_assign
id|req-&gt;next
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|wait_for_request
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* And no one is waiting for this &n;&t;&t;&t;&t;&t;      * to complete */
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the scatter-gather flag */
id|SCpnt-&gt;old_use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No default transfer size */
id|SCpnt-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do not flag underflow conditions */
multiline_comment|/* Since not everyone seems to set the device info correctly&n;     * before Scsi_Cmnd gets send out to scsi_do_command, we do it here.&n;     */
id|SCpnt-&gt;channel
op_assign
id|device-&gt;channel
suffix:semicolon
id|SCpnt-&gt;lun
op_assign
id|device-&gt;lun
suffix:semicolon
id|SCpnt-&gt;target
op_assign
id|device-&gt;id
suffix:semicolon
r_return
id|SCpnt
suffix:semicolon
)brace
multiline_comment|/*&n; * This is inline because we have stack problemes if we recurse to deeply.&n; */
DECL|function|internal_cmnd
r_inline
r_void
id|internal_cmnd
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|flags
comma
id|timeout
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
macro_line|#ifdef DEBUG_DELAY
r_int
r_int
id|clock
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG
r_int
r_int
op_star
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __mips__
id|__asm__
id|__volatile__
(paren
l_string|&quot;move&bslash;t%0,$31&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
)paren
suffix:semicolon
macro_line|#else
id|ret
op_assign
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Assign a unique nonzero serial_number. */
r_if
c_cond
(paren
op_increment
id|serial_number
op_eq
l_int|0
)paren
id|serial_number
op_assign
l_int|1
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
id|serial_number
suffix:semicolon
multiline_comment|/*&n;     * We will wait MIN_RESET_DELAY clock ticks after the last reset so&n;     * we can avoid the drive not being ready.&n;     */
id|timeout
op_assign
id|host-&gt;last_reset
op_plus
id|MIN_RESET_DELAY
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
OL
id|timeout
)paren
(brace
multiline_comment|/*&n;         * NOTE: This may be executed from within an interrupt&n;         * handler!  This is bad, but for now, it&squot;ll do.  The irq&n;         * level of the interrupt handler has been masked out by the&n;         * platform dependent interrupt handling code already, so the&n;         * sti() here will not cause another call to the SCSI host&squot;s&n;         * interrupt handler (assuming there is one irq-level per&n;         * host).&n;         */
id|sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|timeout
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|SCpnt-&gt;timeout_per_command
)paren
suffix:semicolon
multiline_comment|/*&n;     * We will use a queued command if possible, otherwise we will emulate the&n;     * queuing and calling of completion function ourselves.&n;     */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;internal_cmnd (host = %d, channel = %d, target = %d, &quot;
l_string|&quot;command = %p, buffer = %p, &bslash;nbufflen = %d, done = %p)&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;bufflen
comma
id|SCpnt-&gt;done
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|host-&gt;can_queue
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;queuecommand : routine at %p&bslash;n&quot;
comma
id|host-&gt;hostt-&gt;queuecommand
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* This locking tries to prevent all sorts of races between&n;&t; * queuecommand and the interrupt code.  In effect,&n;&t; * we are only allowed to be in queuecommand once at&n;&t; * any given time, and we can only be in the interrupt&n;&t; * handler and the queuecommand function at the same time&n;&t; * when queuecommand is called while servicing the&n;&t; * interrupt. &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|intr_count
op_logical_and
id|SCpnt-&gt;host-&gt;irq
)paren
(brace
id|disable_irq
c_func
(paren
id|SCpnt-&gt;host-&gt;irq
)paren
suffix:semicolon
)brace
id|host-&gt;hostt-&gt;queuecommand
(paren
id|SCpnt
comma
id|scsi_done
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|intr_count
op_logical_and
id|SCpnt-&gt;host-&gt;irq
)paren
(brace
id|enable_irq
c_func
(paren
id|SCpnt-&gt;host-&gt;irq
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|temp
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;command() :  routine at %p&bslash;n&quot;
comma
id|host-&gt;hostt-&gt;command
)paren
suffix:semicolon
macro_line|#endif
id|temp
op_assign
id|host-&gt;hostt-&gt;command
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|temp
suffix:semicolon
macro_line|#ifdef DEBUG_DELAY
id|clock
op_assign
id|jiffies
op_plus
l_int|4
op_star
id|HZ
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|clock
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;done(host = %d, result = %04x) : routine at %p&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|temp
comma
id|host-&gt;hostt-&gt;command
)paren
suffix:semicolon
macro_line|#endif
id|scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;leaving internal_cmnd()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|scsi_request_sense
r_static
r_void
id|scsi_request_sense
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|SCpnt-&gt;flags
op_or_assign
id|WAS_SENSE
op_or
id|ASKED_FOR_SENSE
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|SENSE_TIMEOUT
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|generic_sense
comma
r_sizeof
(paren
id|generic_sense
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|SCpnt-&gt;lun
op_lshift
l_int|5
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
op_amp
id|SCpnt-&gt;sense_buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|internal_cmnd
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * scsi_do_cmd sends all the commands out to the low-level driver.  It&n; * handles the specifics required for each low level driver - ie queued&n; * or non queued.  It also prevents conflicts when different high level&n; * drivers go for the same host at the same time.&n; */
DECL|function|scsi_do_cmd
r_void
id|scsi_do_cmd
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
comma
r_int
id|timeout
comma
r_int
id|retries
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
macro_line|#ifdef DEBUG
(brace
r_int
id|i
suffix:semicolon
r_int
id|target
op_assign
id|SCpnt-&gt;target
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi_do_cmd (host = %d, channel = %d target = %d, &quot;
l_string|&quot;buffer =%p, bufflen = %d, done = %p, timeout = %d, &quot;
l_string|&quot;retries = %d)&bslash;n&quot;
l_string|&quot;command : &quot;
comma
id|host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|target
comma
id|buffer
comma
id|bufflen
comma
id|done
comma
id|timeout
comma
id|retries
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
op_increment
id|i
)paren
id|printk
(paren
l_string|&quot;%02x  &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
(brace
id|panic
(paren
l_string|&quot;Invalid or not present host.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * We must prevent reentrancy to the lowlevel host driver.  This prevents&n;     * it - we enter a loop until the host we want to talk to is not busy.&n;     * Race conditions are prevented, as interrupts are disabled in between the&n;     * time we check for the host being not busy, and the time we mark it busy&n;     * ourselves.&n;     */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|SCpnt-&gt;pid
op_assign
id|scsi_pid
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|SCSI_BLOCK
c_func
(paren
id|host
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|SCSI_SLEEP
c_func
(paren
op_amp
id|host-&gt;host_wait
comma
id|SCSI_BLOCK
c_func
(paren
id|host
)paren
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|host-&gt;block
)paren
id|host_active
op_assign
id|host
suffix:semicolon
id|host-&gt;host_busy
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;     * Our own function scsi_done (which marks the host as not busy, disables&n;     * the timeout counter, etc) will be called by us or by the&n;     * scsi_hosts[host].queuecommand() function needs to also call&n;     * the completion function for the high level driver.&n;     */
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|cmnd
comma
l_int|12
)paren
suffix:semicolon
macro_line|#if 0
id|SCpnt-&gt;host
op_assign
id|host
suffix:semicolon
id|SCpnt-&gt;channel
op_assign
id|channel
suffix:semicolon
id|SCpnt-&gt;target
op_assign
id|target
suffix:semicolon
id|SCpnt-&gt;lun
op_assign
(paren
id|SCpnt-&gt;data_cmnd
(braket
l_int|1
)braket
op_rshift
l_int|5
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;bufflen
op_assign
id|bufflen
suffix:semicolon
id|SCpnt-&gt;buffer
op_assign
id|buffer
suffix:semicolon
id|SCpnt-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;retries
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;allowed
op_assign
id|retries
suffix:semicolon
id|SCpnt-&gt;done
op_assign
id|done
suffix:semicolon
id|SCpnt-&gt;timeout_per_command
op_assign
id|timeout
suffix:semicolon
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|cmnd
comma
l_int|12
)paren
suffix:semicolon
multiline_comment|/* Zero the sense buffer.  Some host adapters automatically request&n;     * sense on error.  0 is not a valid sense code.  &n;     */
id|memset
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|bufflen
suffix:semicolon
id|SCpnt-&gt;old_use_sg
op_assign
id|SCpnt-&gt;use_sg
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;cmd_len
op_eq
l_int|0
)paren
id|SCpnt-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|SCpnt-&gt;old_cmd_len
op_assign
id|SCpnt-&gt;cmd_len
suffix:semicolon
multiline_comment|/* Start the timer ticking.  */
id|SCpnt-&gt;internal_timeout
op_assign
id|NORMAL_TIMEOUT
suffix:semicolon
id|SCpnt-&gt;abort_reason
op_assign
l_int|0
suffix:semicolon
id|internal_cmnd
(paren
id|SCpnt
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;Leaving scsi_do_cmd()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|check_sense
r_static
r_int
id|check_sense
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
multiline_comment|/* If there is no sense information, request it.  If we have already&n;     * requested it, there is no point in asking again - the firmware must&n;     * be confused. &n;     */
r_if
c_cond
(paren
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x70
)paren
op_rshift
l_int|4
)paren
op_ne
l_int|7
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|SCpnt-&gt;flags
op_amp
id|ASKED_FOR_SENSE
)paren
)paren
(brace
r_return
id|SUGGEST_SENSE
suffix:semicolon
)brace
r_else
r_return
id|SUGGEST_RETRY
suffix:semicolon
)brace
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|ASKED_FOR_SENSE
suffix:semicolon
macro_line|#ifdef DEBUG_INIT
id|printk
c_func
(paren
l_string|&quot;scsi%d, channel%d : &quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
)paren
suffix:semicolon
id|print_sense
c_func
(paren
l_string|&quot;&quot;
comma
id|SCpnt
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xe0
)paren
r_return
id|SUGGEST_ABORT
suffix:semicolon
r_switch
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
(brace
r_case
id|NO_SENSE
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|RECOVERED_ERROR
suffix:colon
r_return
id|SUGGEST_IS_OK
suffix:semicolon
r_case
id|ABORTED_COMMAND
suffix:colon
r_return
id|SUGGEST_RETRY
suffix:semicolon
r_case
id|NOT_READY
suffix:colon
r_case
id|UNIT_ATTENTION
suffix:colon
multiline_comment|/*&n;         * If we are expecting a CC/UA because of a bus reset that we&n;         * performed, treat this just as a retry.  Otherwise this is&n;         * information that we should pass up to the upper-level driver&n;         * so that we can deal with it there.&n;         */
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;expecting_cc_ua
)paren
(brace
id|SCpnt-&gt;device-&gt;expecting_cc_ua
op_assign
l_int|0
suffix:semicolon
r_return
id|SUGGEST_RETRY
suffix:semicolon
)brace
r_return
id|SUGGEST_ABORT
suffix:semicolon
multiline_comment|/* these three are not supported */
r_case
id|COPY_ABORTED
suffix:colon
r_case
id|VOLUME_OVERFLOW
suffix:colon
r_case
id|MISCOMPARE
suffix:colon
r_case
id|MEDIUM_ERROR
suffix:colon
r_return
id|SUGGEST_REMAP
suffix:semicolon
r_case
id|BLANK_CHECK
suffix:colon
r_case
id|DATA_PROTECT
suffix:colon
r_case
id|HARDWARE_ERROR
suffix:colon
r_case
id|ILLEGAL_REQUEST
suffix:colon
r_default
suffix:colon
r_return
id|SUGGEST_ABORT
suffix:semicolon
)brace
)brace
multiline_comment|/* This function is the mid-level interrupt routine, which decides how&n; *  to handle error conditions.  Each invocation of this function must&n; *  do one and *only* one of the following:&n; *&n; *  (1) Call last_cmnd[host].done.  This is done for fatal errors and&n; *      normal completion, and indicates that the handling for this&n; *      request is complete.&n; *  (2) Call internal_cmnd to requeue the command.  This will result in&n; *      scsi_done being called again when the retry is complete.&n; *  (3) Call scsi_request_sense.  This asks the host adapter/drive for&n; *      more information about the error condition.  When the information&n; *      is available, scsi_done will be called again.&n; *  (4) Call reset().  This is sort of a last resort, and the idea is that&n; *      this may kick things loose and get the drive working again.  reset()&n; *      automatically calls scsi_request_sense, and thus scsi_done will be&n; *      called again once the reset is complete.&n; *&n; *      If none of the above actions are taken, the drive in question&n; *      will hang. If more than one of the above actions are taken by&n; *      scsi_done, then unpredictable behavior will result.&n; */
DECL|function|scsi_done
r_static
r_void
id|scsi_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
m_exit
op_assign
l_int|0
suffix:semicolon
r_int
id|checked
suffix:semicolon
r_int
id|oldto
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
r_int
id|result
op_assign
id|SCpnt-&gt;result
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|oldto
op_assign
id|update_timeout
c_func
(paren
id|SCpnt
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TIMEOUT
r_if
c_cond
(paren
id|result
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Non-zero result in scsi_done %x %d:%d&bslash;n&quot;
comma
id|result
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* If we requested an abort, (and we got it) then fix up the return&n;     *  status to say why &n;     */
r_if
c_cond
(paren
id|host_byte
c_func
(paren
id|result
)paren
op_eq
id|DID_ABORT
op_logical_and
id|SCpnt-&gt;abort_reason
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|result
op_assign
(paren
id|result
op_amp
l_int|0xff00ffff
)paren
op_or
(paren
id|SCpnt-&gt;abort_reason
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
DECL|macro|FINISHED
mdefine_line|#define FINISHED 0
DECL|macro|MAYREDO
mdefine_line|#define MAYREDO  1
DECL|macro|REDO
mdefine_line|#define REDO     3
DECL|macro|PENDING
mdefine_line|#define PENDING  4
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;In scsi_done(host = %d, result = %06x)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|result
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_SENSE
)paren
(brace
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|SCpnt-&gt;old_cmd_len
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|host_byte
c_func
(paren
id|result
)paren
)paren
(brace
r_case
id|DID_OK
suffix:colon
r_if
c_cond
(paren
id|status_byte
c_func
(paren
id|result
)paren
op_logical_and
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_SENSE
)paren
)paren
multiline_comment|/* Failed to obtain sense information */
(brace
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|WAS_SENSE
suffix:semicolon
macro_line|#if 0&t;/* This cannot possibly be correct. */
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|SENSE_TIMEOUT
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_RESET
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : channel %d target %d lun %d request sense&quot;
l_string|&quot; failed, performing reset.&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
)paren
suffix:semicolon
id|scsi_reset
c_func
(paren
id|SCpnt
comma
id|SCSI_RESET_SYNCHRONOUS
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
m_exit
op_assign
(paren
id|DRIVER_HARD
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
id|status
op_assign
id|FINISHED
suffix:semicolon
)brace
)brace
r_else
r_switch
c_cond
(paren
id|msg_byte
c_func
(paren
id|result
)paren
)paren
(brace
r_case
id|COMMAND_COMPLETE
suffix:colon
r_switch
c_cond
(paren
id|status_byte
c_func
(paren
id|result
)paren
)paren
(brace
r_case
id|GOOD
suffix:colon
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_SENSE
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;In scsi_done, GOOD status, COMMAND COMPLETE, &quot;
l_string|&quot;parsing sense information.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|WAS_SENSE
suffix:semicolon
macro_line|#if 0&t;/* This cannot possibly be correct. */
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|SENSE_TIMEOUT
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|checked
op_assign
id|check_sense
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_case
id|SUGGEST_SENSE
suffix:colon
r_case
l_int|0
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;NO SENSE.  status = REDO&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_IS_OK
suffix:colon
r_break
suffix:semicolon
r_case
id|SUGGEST_REMAP
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SENSE SUGGEST REMAP - status = FINISHED&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|status
op_assign
id|FINISHED
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_RETRY
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SENSE SUGGEST RETRY - status = MAYREDO&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_RETRY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_ABORT
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SENSE SUGGEST ABORT - status = FINISHED&quot;
)paren
suffix:semicolon
macro_line|#endif
id|status
op_assign
id|FINISHED
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Internal error %s %d &bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end WAS_SENSE */
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;COMMAND COMPLETE message returned, &quot;
l_string|&quot;status = FINISHED. &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
m_exit
op_assign
id|DRIVER_OK
suffix:semicolon
id|status
op_assign
id|FINISHED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CHECK_CONDITION
suffix:colon
r_case
id|COMMAND_TERMINATED
suffix:colon
r_switch
c_cond
(paren
id|check_sense
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_REMAP
suffix:colon
id|status
op_assign
id|FINISHED
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_RETRY
suffix:colon
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_RETRY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_ABORT
suffix:colon
id|status
op_assign
id|FINISHED
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_SENSE
suffix:colon
id|scsi_request_sense
(paren
id|SCpnt
)paren
suffix:semicolon
id|status
op_assign
id|PENDING
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CONDITION_GOOD
suffix:colon
r_case
id|INTERMEDIATE_GOOD
suffix:colon
r_case
id|INTERMEDIATE_C_GOOD
suffix:colon
r_break
suffix:semicolon
r_case
id|BUSY
suffix:colon
r_case
id|QUEUE_FULL
suffix:colon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESERVATION_CONFLICT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d, channel %d : RESERVATION CONFLICT performing&quot;
l_string|&quot; reset.&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
)paren
suffix:semicolon
id|scsi_reset
c_func
(paren
id|SCpnt
comma
id|SCSI_RESET_SYNCHRONOUS
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#if 0
m_exit
op_assign
id|DRIVER_SOFT
op_or
id|SUGGEST_ABORT
suffix:semicolon
id|status
op_assign
id|MAYREDO
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Internal error %s %d &bslash;n&quot;
l_string|&quot;status byte = %d &bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|status_byte
c_func
(paren
id|result
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;scsi: unsupported message byte %d received&bslash;n&quot;
comma
id|msg_byte
c_func
(paren
id|result
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DID_TIME_OUT
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Host returned DID_TIME_OUT - &quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_TIMEDOUT
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Aborting&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;      Allow TEST_UNIT_READY and INQUIRY commands to timeout early&n;&t;      without causing resets.  All other commands should be retried.&n;&t;    */
r_if
c_cond
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|TEST_UNIT_READY
op_logical_and
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|INQUIRY
)paren
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
(paren
id|DRIVER_TIMEOUT
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;Retrying.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt-&gt;flags
op_or_assign
id|WAS_TIMEDOUT
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DID_BUS_BUSY
suffix:colon
r_case
id|DID_PARITY
suffix:colon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_NO_CONNECT
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Couldn&squot;t connect.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
m_exit
op_assign
(paren
id|DRIVER_HARD
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_ERROR
suffix:colon
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
(paren
id|DRIVER_HARD
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_BAD_TARGET
suffix:colon
r_case
id|DID_ABORT
suffix:colon
m_exit
op_assign
(paren
id|DRIVER_INVALID
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_RESET
suffix:colon
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|IS_RESETTING
)paren
(brace
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|IS_RESETTING
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg_byte
c_func
(paren
id|result
)paren
op_eq
id|GOOD
op_logical_and
id|status_byte
c_func
(paren
id|result
)paren
op_eq
id|CHECK_CONDITION
)paren
(brace
r_switch
c_cond
(paren
id|check_sense
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_REMAP
suffix:colon
r_case
id|SUGGEST_RETRY
suffix:colon
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_RETRY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_ABORT
suffix:colon
id|status
op_assign
id|FINISHED
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_SENSE
suffix:colon
id|scsi_request_sense
(paren
id|SCpnt
)paren
suffix:semicolon
id|status
op_assign
id|PENDING
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
id|REDO
suffix:semicolon
m_exit
op_assign
id|SUGGEST_RETRY
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
m_exit
op_assign
(paren
id|DRIVER_ERROR
op_or
id|SUGGEST_DIE
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|FINISHED
suffix:colon
r_case
id|PENDING
suffix:colon
r_break
suffix:semicolon
r_case
id|MAYREDO
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;In MAYREDO, allowing %d retries, have %d&bslash;n&quot;
comma
id|SCpnt-&gt;allowed
comma
id|SCpnt-&gt;retries
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
op_increment
id|SCpnt-&gt;retries
)paren
OL
id|SCpnt-&gt;allowed
)paren
(brace
r_if
c_cond
(paren
(paren
id|SCpnt-&gt;retries
op_ge
(paren
id|SCpnt-&gt;allowed
op_rshift
l_int|1
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|jiffies
OL
id|SCpnt-&gt;host-&gt;last_reset
op_plus
id|MIN_RESET_PERIOD
)paren
op_logical_and
op_logical_neg
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_RESET
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d channel %d : resetting for second half of retries.&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
)paren
suffix:semicolon
id|scsi_reset
c_func
(paren
id|SCpnt
comma
id|SCSI_RESET_SYNCHRONOUS
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
id|FINISHED
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* fall through to REDO */
r_case
id|REDO
suffix:colon
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_SENSE
)paren
id|scsi_request_sense
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_else
(brace
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|SCpnt-&gt;buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|SCpnt-&gt;bufflen
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|SCpnt-&gt;old_cmd_len
suffix:semicolon
id|internal_cmnd
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|INTERNAL_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_eq
id|FINISHED
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Calling done function - at address %p&bslash;n&quot;
comma
id|SCpnt-&gt;done
)paren
suffix:semicolon
macro_line|#endif
id|host-&gt;host_busy
op_decrement
suffix:semicolon
multiline_comment|/* Indicate that we are free */
r_if
c_cond
(paren
id|host-&gt;block
op_logical_and
id|host-&gt;host_busy
op_eq
l_int|0
)paren
(brace
id|host_active
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* For block devices &quot;wake_up&quot; is done in end_scsi_request */
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
op_ne
id|SCSI_DISK_MAJOR
op_logical_and
id|MAJOR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
op_ne
id|SCSI_CDROM_MAJOR
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
id|next
op_assign
id|host-&gt;block
suffix:semicolon
id|next
op_ne
id|host
suffix:semicolon
id|next
op_assign
id|next-&gt;block
)paren
id|wake_up
c_func
(paren
op_amp
id|next-&gt;host_wait
)paren
suffix:semicolon
)brace
)brace
id|wake_up
c_func
(paren
op_amp
id|host-&gt;host_wait
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|result
op_or
(paren
(paren
m_exit
op_amp
l_int|0xff
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|SCpnt-&gt;old_cmd_len
suffix:semicolon
id|SCpnt-&gt;done
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
DECL|macro|FINISHED
macro_line|#undef FINISHED
DECL|macro|REDO
macro_line|#undef REDO
DECL|macro|MAYREDO
macro_line|#undef MAYREDO
DECL|macro|PENDING
macro_line|#undef PENDING
)brace
multiline_comment|/*&n; * The scsi_abort function interfaces with the abort() function of the host&n; * we are aborting, and causes the current command to not complete.  The&n; * caller should deal with any error messages or status returned on the&n; * next call.&n; * &n; * This will not be called reentrantly for a given host.&n; */
multiline_comment|/*&n; * Since we&squot;re nice guys and specified that abort() and reset()&n; * can be non-reentrant.  The internal_timeout flags are used for&n; * this.&n; */
DECL|function|scsi_abort
r_int
id|scsi_abort
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|why
)paren
(brace
r_int
id|oldto
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Protect against races here.  If the command is done, or we are&n;&t; * on a different command forget it.&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;serial_number
op_ne
id|SCpnt-&gt;serial_number_at_timeout
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;internal_timeout
op_amp
id|IN_ABORT
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt-&gt;internal_timeout
op_amp
id|IN_ABORT
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCpnt-&gt;internal_timeout
op_or_assign
id|IN_ABORT
suffix:semicolon
id|oldto
op_assign
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|ABORT_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|SCpnt-&gt;flags
op_amp
id|IS_RESETTING
)paren
op_logical_and
id|SCpnt-&gt;device-&gt;soft_reset
)paren
(brace
multiline_comment|/* OK, this command must have died when we did the&n;&t;&t; *  reset.  The device itself must have lied. &n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;Stale command on %d %d:%d appears to have died when&quot;
l_string|&quot; the bus was reset&bslash;n&quot;
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host-&gt;host_busy
)paren
(brace
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi : aborting command due to timeout : pid %lu, scsi%d,&quot;
l_string|&quot; channel %d, id %d, lun %d &quot;
comma
id|SCpnt-&gt;pid
comma
id|SCpnt-&gt;host-&gt;host_no
comma
(paren
r_int
)paren
id|SCpnt-&gt;channel
comma
(paren
r_int
)paren
id|SCpnt-&gt;target
comma
(paren
r_int
)paren
id|SCpnt-&gt;lun
)paren
suffix:semicolon
id|print_command
(paren
id|SCpnt-&gt;cmnd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;serial_number
op_ne
id|SCpnt-&gt;serial_number_at_timeout
)paren
r_return
l_int|0
suffix:semicolon
id|SCpnt-&gt;abort_reason
op_assign
id|why
suffix:semicolon
r_switch
c_cond
(paren
id|host-&gt;hostt
op_member_access_from_pointer
m_abort
(paren
id|SCpnt
)paren
)paren
(brace
multiline_comment|/* We do not know how to abort.  Try waiting another&n;&t;&t; * time increment and see if this helps. Set the&n;&t;&t; * WAS_TIMEDOUT flag set so we do not try this twice&n;&t;&t; */
r_case
id|SCSI_ABORT_BUSY
suffix:colon
multiline_comment|/* Tough call - returning 1 from&n;&t;&t;&t;&t;   * this is too severe &n;&t;&t;&t;&t;   */
r_case
id|SCSI_ABORT_SNOOZE
suffix:colon
r_if
c_cond
(paren
id|why
op_eq
id|DID_TIME_OUT
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_TIMEDOUT
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Indicate we cannot handle this.&n;&t;&t;&t;&t;   * We drop down into the reset handler&n;&t;&t;&t;&t;   * and try again &n;&t;&t;&t;&t;   */
)brace
r_else
(brace
id|SCpnt-&gt;flags
op_or_assign
id|WAS_TIMEDOUT
suffix:semicolon
id|oldto
op_assign
id|SCpnt-&gt;timeout_per_command
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_ABORT_PENDING
suffix:colon
r_if
c_cond
(paren
id|why
op_ne
id|DID_TIME_OUT
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_ABORT_SUCCESS
suffix:colon
multiline_comment|/* We should have already aborted this one.  No&n;&t;&t; * need to adjust timeout &n;&t;&t; */
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_ABORT_NOT_RUNNING
suffix:colon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_ABORT_ERROR
suffix:colon
r_default
suffix:colon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* Mark a single SCSI Device as having been reset. */
DECL|function|scsi_mark_device_reset
r_static
r_inline
r_void
id|scsi_mark_device_reset
c_func
(paren
id|Scsi_Device
op_star
id|Device
)paren
(brace
id|Device-&gt;was_reset
op_assign
l_int|1
suffix:semicolon
id|Device-&gt;expecting_cc_ua
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Mark all SCSI Devices on a specific Host as having been reset. */
DECL|function|scsi_mark_host_reset
r_void
id|scsi_mark_host_reset
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|Host
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_for
c_loop
(paren
id|SCpnt
op_assign
id|Host-&gt;host_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
id|scsi_mark_device_reset
c_func
(paren
id|SCpnt-&gt;device
)paren
suffix:semicolon
)brace
multiline_comment|/* Mark all SCSI Devices on a specific Host Bus as having been reset. */
DECL|function|scsi_mark_bus_reset
r_void
id|scsi_mark_bus_reset
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|Host
comma
r_int
id|channel
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_for
c_loop
(paren
id|SCpnt
op_assign
id|Host-&gt;host_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;channel
op_eq
id|channel
)paren
id|scsi_mark_device_reset
c_func
(paren
id|SCpnt-&gt;device
)paren
suffix:semicolon
)brace
DECL|function|scsi_reset
r_int
id|scsi_reset
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_int
id|reset_flags
)paren
(brace
r_int
id|temp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt1
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SCSI bus is being reset for host %d channel %d.&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|SCpnt-&gt;channel
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;     * First of all, we need to make a recommendation to the low-level&n;     * driver as to whether a BUS_DEVICE_RESET should be performed,&n;     * or whether we should do a full BUS_RESET.  There is no simple&n;     * algorithm here - we basically use a series of heuristics&n;     * to determine what we should do.&n;     */
id|SCpnt-&gt;host-&gt;suggest_bus_reset
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/*&n;     * First see if all of the active devices on the bus have&n;     * been jammed up so that we are attempting resets.  If so,&n;     * then suggest a bus reset.  Forcing a bus reset could&n;     * result in some race conditions, but no more than&n;     * you would usually get with timeouts.  We will cross&n;     * that bridge when we come to it.&n;     *&n;     * This is actually a pretty bad idea, since a sequence of&n;     * commands will often timeout together and this will cause a&n;     * Bus Device Reset followed immediately by a SCSI Bus Reset.&n;     * If all of the active devices really are jammed up, the&n;     * Bus Device Reset will quickly timeout and scsi_times_out&n;     * will follow up with a SCSI Bus Reset anyway.&n;     */
id|SCpnt1
op_assign
id|host-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt1
)paren
(brace
r_if
c_cond
(paren
id|SCpnt1-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
op_logical_and
(paren
id|SCpnt1-&gt;flags
op_amp
(paren
id|WAS_RESET
op_or
id|IS_RESETTING
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|SCpnt1
op_assign
id|SCpnt1-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt1
op_eq
l_int|NULL
)paren
(brace
id|reset_flags
op_or_assign
id|SCSI_RESET_SUGGEST_BUS_RESET
suffix:semicolon
)brace
multiline_comment|/*&n;     * If the code that called us is suggesting a hard reset, then&n;     * definitely request it.  This usually occurs because a&n;     * BUS_DEVICE_RESET times out.&n;     *&n;     * Passing reset_flags along takes care of this automatically.&n;     */
r_if
c_cond
(paren
id|reset_flags
op_amp
id|SCSI_RESET_SUGGEST_BUS_RESET
)paren
(brace
id|SCpnt-&gt;host-&gt;suggest_bus_reset
op_assign
id|TRUE
suffix:semicolon
)brace
macro_line|#endif
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Protect against races here.  If the command is done, or we are&n;&t; * on a different command forget it.&n;&t; */
r_if
c_cond
(paren
id|reset_flags
op_amp
id|SCSI_RESET_ASYNCHRONOUS
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;serial_number
op_ne
id|SCpnt-&gt;serial_number_at_timeout
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;internal_timeout
op_amp
id|IN_RESET
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt-&gt;internal_timeout
op_amp
id|IN_RESET
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCpnt-&gt;internal_timeout
op_or_assign
id|IN_RESET
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|RESET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;host_busy
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|SCpnt1
op_assign
id|host-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt1
)paren
(brace
r_if
c_cond
(paren
id|SCpnt1-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
)paren
(brace
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
(paren
id|SCpnt1-&gt;flags
op_amp
id|IS_RESETTING
)paren
op_logical_and
op_logical_neg
(paren
id|SCpnt1-&gt;internal_timeout
op_amp
id|IN_ABORT
)paren
)paren
id|scsi_abort
c_func
(paren
id|SCpnt1
comma
id|DID_RESET
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt1-&gt;flags
op_or_assign
(paren
id|WAS_RESET
op_or
id|IS_RESETTING
)paren
suffix:semicolon
)brace
id|SCpnt1
op_assign
id|SCpnt1-&gt;next
suffix:semicolon
)brace
id|host-&gt;last_reset
op_assign
id|jiffies
suffix:semicolon
id|temp
op_assign
id|host-&gt;hostt
op_member_access_from_pointer
id|reset
c_func
(paren
id|SCpnt
comma
id|reset_flags
)paren
suffix:semicolon
id|host-&gt;last_reset
op_assign
id|jiffies
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|host-&gt;block
)paren
id|host-&gt;host_busy
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|host-&gt;last_reset
op_assign
id|jiffies
suffix:semicolon
id|SCpnt-&gt;flags
op_or_assign
(paren
id|WAS_RESET
op_or
id|IS_RESETTING
)paren
suffix:semicolon
id|temp
op_assign
id|host-&gt;hostt
op_member_access_from_pointer
id|reset
c_func
(paren
id|SCpnt
comma
id|reset_flags
)paren
suffix:semicolon
id|host-&gt;last_reset
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host-&gt;block
)paren
id|host-&gt;host_busy
op_decrement
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;scsi reset function returned %d&bslash;n&quot;
comma
id|temp
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;             * Now figure out what we need to do, based upon&n;             * what the low level driver said that it did.&n;&t;     * If the result is SCSI_RESET_SUCCESS, SCSI_RESET_PENDING,&n;&t;     * or SCSI_RESET_WAKEUP, then the low level driver did a&n;&t;     * bus device reset or bus reset, so we should go through&n;&t;     * and mark one or all of the devices on that bus&n;&t;     * as having been reset.&n;             */
r_switch
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_ACTION
)paren
(brace
r_case
id|SCSI_RESET_SUCCESS
suffix:colon
r_if
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_HOST_RESET
)paren
id|scsi_mark_host_reset
c_func
(paren
id|host
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_BUS_RESET
)paren
id|scsi_mark_bus_reset
c_func
(paren
id|host
comma
id|SCpnt-&gt;channel
)paren
suffix:semicolon
r_else
id|scsi_mark_device_reset
c_func
(paren
id|SCpnt-&gt;device
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
(paren
id|IN_RESET
op_or
id|IN_RESET2
op_or
id|IN_RESET3
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_RESET_PENDING
suffix:colon
r_if
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_HOST_RESET
)paren
id|scsi_mark_host_reset
c_func
(paren
id|host
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_BUS_RESET
)paren
id|scsi_mark_bus_reset
c_func
(paren
id|host
comma
id|SCpnt-&gt;channel
)paren
suffix:semicolon
r_else
id|scsi_mark_device_reset
c_func
(paren
id|SCpnt-&gt;device
)paren
suffix:semicolon
r_case
id|SCSI_RESET_NOT_RUNNING
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_RESET_PUNT
suffix:colon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
(paren
id|IN_RESET
op_or
id|IN_RESET2
op_or
id|IN_RESET3
)paren
suffix:semicolon
id|scsi_request_sense
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_RESET_WAKEUP
suffix:colon
r_if
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_HOST_RESET
)paren
id|scsi_mark_host_reset
c_func
(paren
id|host
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_BUS_RESET
)paren
id|scsi_mark_bus_reset
c_func
(paren
id|host
comma
id|SCpnt-&gt;channel
)paren
suffix:semicolon
r_else
id|scsi_mark_device_reset
c_func
(paren
id|SCpnt-&gt;device
)paren
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
(paren
id|IN_RESET
op_or
id|IN_RESET2
op_or
id|IN_RESET3
)paren
suffix:semicolon
id|scsi_request_sense
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n;                 * If a bus reset was performed, we&n;                 * need to wake up each and every command&n;                 * that was active on the bus or if it was a HBA&n;                 * reset all active commands on all channels&n;                 */
r_if
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_HOST_RESET
)paren
(brace
id|SCpnt1
op_assign
id|host-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt1
)paren
(brace
r_if
c_cond
(paren
id|SCpnt1-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
op_logical_and
id|SCpnt1
op_ne
id|SCpnt
)paren
id|scsi_request_sense
(paren
id|SCpnt1
)paren
suffix:semicolon
id|SCpnt1
op_assign
id|SCpnt1-&gt;next
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|temp
op_amp
id|SCSI_RESET_BUS_RESET
)paren
(brace
id|SCpnt1
op_assign
id|host-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt1
)paren
(brace
r_if
c_cond
(paren
id|SCpnt1-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
op_logical_and
id|SCpnt1
op_ne
id|SCpnt
op_logical_and
id|SCpnt1-&gt;channel
op_eq
id|SCpnt-&gt;channel
)paren
(brace
id|scsi_request_sense
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
id|SCpnt1
op_assign
id|SCpnt1-&gt;next
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_RESET_SNOOZE
suffix:colon
multiline_comment|/* In this case, we set the timeout field to 0&n;&t;&t; * so that this command does not time out any more,&n;&t;&t; * and we return 1 so that we get a message on the&n;&t;&t; * screen. &n;&t;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
(paren
id|IN_RESET
op_or
id|IN_RESET2
op_or
id|IN_RESET3
)paren
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
l_int|0
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* If you snooze, you lose... */
r_case
id|SCSI_RESET_ERROR
suffix:colon
r_default
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
r_return
id|temp
suffix:semicolon
)brace
)brace
)brace
DECL|function|scsi_main_timeout
r_static
r_void
id|scsi_main_timeout
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;     * We must not enter update_timeout with a timeout condition still pending.&n;     */
r_int
id|timed_out
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|update_timeout
c_func
(paren
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;     * Find all timers such that they have 0 or negative (shouldn&squot;t happen)&n;     * time remaining on them.&n;     */
id|timed_out
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|host
op_assign
id|scsi_hostlist
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;timeout
op_eq
op_minus
l_int|1
)paren
(brace
id|SCpnt-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
id|SCpnt-&gt;serial_number
suffix:semicolon
op_increment
id|timed_out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|timed_out
OG
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|host
op_assign
id|scsi_hostlist
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;serial_number_at_timeout
OG
l_int|0
op_logical_and
id|SCpnt-&gt;serial_number_at_timeout
op_eq
id|SCpnt-&gt;serial_number
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|scsi_times_out
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The strategy is to cause the timer code to call scsi_times_out()&n; * when the soonest timeout is pending.&n; * The arguments are used when we are queueing a new command, because&n; * we do not want to subtract the time used from this time, but when we&n; * set the timer, we want to take this value into account.&n; */
DECL|function|update_timeout
r_static
r_int
id|update_timeout
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCset
comma
r_int
id|timeout
)paren
(brace
r_int
r_int
id|least
comma
id|used
suffix:semicolon
r_int
r_int
id|oldto
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|oldto
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * This routine can be a performance bottleneck under high loads, since&n;     * it is called twice per SCSI operation: once when internal_cmnd is&n;     * called, and again when scsi_done completes the command.  To limit&n;     * the load this routine can cause, we shortcut processing if no clock&n;     * ticks have occurred since the last time it was called.&n;     */
r_if
c_cond
(paren
id|jiffies
op_eq
id|time_start
op_logical_and
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|expires
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|SCset
)paren
(brace
id|oldto
op_assign
id|SCset-&gt;timeout
suffix:semicolon
id|SCset-&gt;timeout
op_assign
id|timeout
suffix:semicolon
r_if
c_cond
(paren
id|timeout
OG
l_int|0
op_logical_and
id|jiffies
op_plus
id|timeout
OL
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|expires
)paren
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|oldto
suffix:semicolon
)brace
multiline_comment|/*&n;     * Figure out how much time has passed since the last time the timeouts&n;     * were updated&n;     */
id|used
op_assign
(paren
id|time_start
)paren
ques
c_cond
(paren
id|jiffies
op_minus
id|time_start
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * Find out what is due to timeout soonest, and adjust all timeouts for&n;     * the amount of time that has passed since the last time we called&n;     * update_timeout.&n;     */
id|oldto
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|SCset
)paren
(brace
id|oldto
op_assign
id|SCset-&gt;timeout
op_minus
id|used
suffix:semicolon
id|SCset-&gt;timeout
op_assign
id|timeout
suffix:semicolon
)brace
id|least
op_assign
l_int|0xffffffff
suffix:semicolon
r_for
c_loop
(paren
id|host
op_assign
id|scsi_hostlist
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
r_for
c_loop
(paren
id|SCpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;timeout
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|SCpnt
op_ne
id|SCset
)paren
id|SCpnt-&gt;timeout
op_sub_assign
id|used
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;timeout
op_le
l_int|0
)paren
(brace
id|SCpnt-&gt;timeout
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;timeout
OG
l_int|0
op_logical_and
id|SCpnt-&gt;timeout
OL
id|least
)paren
(brace
id|least
op_assign
id|SCpnt-&gt;timeout
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * If something is due to timeout again, then we will set the next timeout&n;     * interrupt to occur.  Otherwise, timeouts are disabled.&n;     */
r_if
c_cond
(paren
id|least
op_ne
l_int|0xffffffff
)paren
(brace
id|time_start
op_assign
id|jiffies
suffix:semicolon
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|expires
op_assign
(paren
id|time_elapsed
op_assign
id|least
)paren
op_plus
id|jiffies
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|SCSI_TIMER
suffix:semicolon
)brace
r_else
(brace
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|expires
op_assign
id|time_start
op_assign
id|time_elapsed
op_assign
l_int|0
suffix:semicolon
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|SCSI_TIMER
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|oldto
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MODULES
r_static
r_int
id|scsi_register_host
c_func
(paren
id|Scsi_Host_Template
op_star
)paren
suffix:semicolon
r_static
r_void
id|scsi_unregister_host
c_func
(paren
id|Scsi_Host_Template
op_star
)paren
suffix:semicolon
macro_line|#endif
DECL|function|scsi_malloc
r_void
op_star
id|scsi_malloc
c_func
(paren
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|nbits
comma
id|mask
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|len
op_mod
id|SECTOR_SIZE
op_ne
l_int|0
op_logical_or
id|len
OG
id|PAGE_SIZE
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|nbits
op_assign
id|len
op_rshift
l_int|9
suffix:semicolon
id|mask
op_assign
(paren
l_int|1
op_lshift
id|nbits
)paren
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|i
op_increment
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
op_le
id|SECTORS_PER_PAGE
op_minus
id|nbits
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|dma_malloc_freelist
(braket
id|i
)braket
op_amp
(paren
id|mask
op_lshift
id|j
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|dma_malloc_freelist
(braket
id|i
)braket
op_or_assign
(paren
id|mask
op_lshift
id|j
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|dma_free_sectors
op_sub_assign
id|nbits
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SMalloc: %d %p&bslash;n&quot;
comma
id|len
comma
id|dma_malloc_pages
(braket
id|i
)braket
op_plus
(paren
id|j
op_lshift
l_int|9
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|dma_malloc_pages
(braket
id|i
)braket
op_plus
(paren
id|j
op_lshift
l_int|9
)paren
)paren
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Nope.  No more */
)brace
DECL|function|scsi_free
r_int
id|scsi_free
c_func
(paren
r_void
op_star
id|obj
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|page
comma
id|sector
comma
id|nbits
comma
id|mask
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG
r_int
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __mips__
id|__asm__
id|__volatile__
(paren
l_string|&quot;move&bslash;t%0,$31&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
)paren
suffix:semicolon
macro_line|#else
id|ret
op_assign
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;scsi_free %p %d&bslash;n&quot;
comma
id|obj
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|page
op_assign
l_int|0
suffix:semicolon
id|page
OL
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|page
op_increment
)paren
(brace
r_int
r_int
id|page_addr
op_assign
(paren
r_int
r_int
)paren
id|dma_malloc_pages
(braket
id|page
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|obj
op_ge
id|page_addr
op_logical_and
(paren
r_int
r_int
)paren
id|obj
OL
id|page_addr
op_plus
id|PAGE_SIZE
)paren
(brace
id|sector
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|obj
)paren
op_minus
id|page_addr
)paren
op_rshift
l_int|9
suffix:semicolon
id|nbits
op_assign
id|len
op_rshift
l_int|9
suffix:semicolon
id|mask
op_assign
(paren
l_int|1
op_lshift
id|nbits
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mask
op_lshift
id|sector
)paren
op_ge
(paren
l_int|1
op_lshift
id|SECTORS_PER_PAGE
)paren
)paren
id|panic
(paren
l_string|&quot;scsi_free:Bad memory alignment&quot;
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dma_malloc_freelist
(braket
id|page
)braket
op_amp
(paren
id|mask
op_lshift
id|sector
)paren
)paren
op_ne
(paren
id|mask
op_lshift
id|sector
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;scsi_free(obj=%p, len=%d) called from %08lx&bslash;n&quot;
comma
id|obj
comma
id|len
comma
id|ret
)paren
suffix:semicolon
macro_line|#endif
id|panic
c_func
(paren
l_string|&quot;scsi_free:Trying to free unused memory&quot;
)paren
suffix:semicolon
)brace
id|dma_free_sectors
op_add_assign
id|nbits
suffix:semicolon
id|dma_malloc_freelist
(braket
id|page
)braket
op_and_assign
op_complement
(paren
id|mask
op_lshift
id|sector
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|panic
c_func
(paren
l_string|&quot;scsi_free:Bad offset&quot;
)paren
suffix:semicolon
)brace
DECL|variable|scsi_loadable_module_flag
r_int
id|scsi_loadable_module_flag
suffix:semicolon
multiline_comment|/* Set after we scan builtin drivers */
DECL|function|scsi_init_malloc
r_void
op_star
id|scsi_init_malloc
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|priority
)paren
(brace
r_void
op_star
id|retval
suffix:semicolon
multiline_comment|/*&n;     * For buffers used by the DMA pool, we assume page aligned &n;     * structures.&n;     */
r_if
c_cond
(paren
(paren
id|size
op_mod
id|PAGE_SIZE
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|order
comma
id|a_size
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
comma
id|a_size
op_assign
id|PAGE_SIZE
suffix:semicolon
id|a_size
OL
id|size
suffix:semicolon
id|order
op_increment
comma
id|a_size
op_lshift_assign
l_int|1
)paren
suffix:semicolon
id|retval
op_assign
(paren
r_void
op_star
)paren
id|__get_dma_pages
c_func
(paren
id|priority
op_amp
id|GFP_LEVEL_MASK
comma
id|order
)paren
suffix:semicolon
)brace
r_else
id|retval
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
id|memset
c_func
(paren
id|retval
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|scsi_init_free
r_void
id|scsi_init_free
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
r_int
id|size
)paren
(brace
multiline_comment|/*&n;     * We need this special code here because the DMA pool assumes&n;     * page aligned data.  Besides, it is wasteful to allocate&n;     * page sized chunks with kmalloc.&n;     */
r_if
c_cond
(paren
(paren
id|size
op_mod
id|PAGE_SIZE
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|order
comma
id|a_size
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
comma
id|a_size
op_assign
id|PAGE_SIZE
suffix:semicolon
id|a_size
OL
id|size
suffix:semicolon
id|order
op_increment
comma
id|a_size
op_lshift_assign
l_int|1
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|ptr
comma
id|order
)paren
suffix:semicolon
)brace
r_else
id|kfree
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
DECL|function|scsi_build_commandblocks
r_void
id|scsi_build_commandblocks
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SDpnt-&gt;host
suffix:semicolon
r_int
id|j
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;queue_depth
op_eq
l_int|0
)paren
id|SDpnt-&gt;queue_depth
op_assign
id|host-&gt;cmd_per_lun
suffix:semicolon
id|SDpnt-&gt;device_queue
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|SDpnt-&gt;queue_depth
suffix:semicolon
id|j
op_increment
)paren
(brace
id|SCpnt
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|scsi_init_malloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Cmnd
)paren
comma
id|GFP_ATOMIC
op_or
(paren
id|host-&gt;unchecked_isa_dma
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;host
op_assign
id|host
suffix:semicolon
id|SCpnt-&gt;device
op_assign
id|SDpnt
suffix:semicolon
id|SCpnt-&gt;target
op_assign
id|SDpnt-&gt;id
suffix:semicolon
id|SCpnt-&gt;lun
op_assign
id|SDpnt-&gt;lun
suffix:semicolon
id|SCpnt-&gt;channel
op_assign
id|SDpnt-&gt;channel
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;old_use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;old_cmd_len
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;host_queue
)paren
(brace
id|host-&gt;host_queue-&gt;prev
op_assign
id|SCpnt
suffix:semicolon
)brace
id|SCpnt-&gt;next
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SCpnt-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|host-&gt;host_queue
op_assign
id|SCpnt
suffix:semicolon
id|SCpnt-&gt;device_next
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SDpnt-&gt;device_queue
op_assign
id|SCpnt
suffix:semicolon
)brace
id|SDpnt-&gt;has_cmdblocks
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * scsi_dev_init() is our initialization routine, which in turn calls host&n; * initialization, bus scanning, and sd/st initialization routines. &n; */
DECL|function|scsi_dev_init
r_int
id|scsi_dev_init
c_func
(paren
r_void
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
macro_line|#ifdef FOO_ON_YOU
r_return
suffix:semicolon
macro_line|#endif
multiline_comment|/* Yes we&squot;re here... */
macro_line|#if CONFIG_PROC_FS 
id|dispatch_scsi_info_ptr
op_assign
id|dispatch_scsi_info
suffix:semicolon
macro_line|#endif
multiline_comment|/* Init a few things so we can &quot;malloc&quot; memory. */
id|scsi_loadable_module_flag
op_assign
l_int|0
suffix:semicolon
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|fn
op_assign
id|scsi_main_timeout
suffix:semicolon
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|expires
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_MODULES
id|register_symtab
c_func
(paren
op_amp
id|scsi_symbol_table
)paren
suffix:semicolon
macro_line|#endif    
multiline_comment|/* Register the /proc/scsi/scsi entry */
macro_line|#if CONFIG_PROC_FS 
id|proc_scsi_register
c_func
(paren
l_int|0
comma
op_amp
id|proc_scsi_scsi
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* initialize all hosts */
id|scsi_init
c_func
(paren
)paren
suffix:semicolon
id|scsi_devices
op_assign
(paren
id|Scsi_Device
op_star
)paren
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
id|scan_scsis
c_func
(paren
id|shpnt
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* scan for scsi devices */
r_if
c_cond
(paren
id|shpnt-&gt;select_queue_depths
op_ne
l_int|NULL
)paren
(paren
id|shpnt-&gt;select_queue_depths
)paren
(paren
id|shpnt
comma
id|scsi_devices
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi : detected &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;dev_noticed
op_logical_and
id|sdtpnt-&gt;name
)paren
id|printk
c_func
(paren
l_string|&quot;%d SCSI %s%s &quot;
comma
id|sdtpnt-&gt;dev_noticed
comma
id|sdtpnt-&gt;name
comma
(paren
id|sdtpnt-&gt;dev_noticed
op_ne
l_int|1
)paren
ques
c_cond
l_string|&quot;s&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;total.&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;init
op_logical_and
id|sdtpnt-&gt;dev_noticed
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;init
)paren
(paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|SDpnt
op_assign
id|scsi_devices
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
id|SDpnt-&gt;scsi_request_fn
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;attach
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;attach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SDpnt-&gt;attached
)paren
(brace
id|scsi_build_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * This should build the DMA pool.&n;     */
id|resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * OK, now we finish the initialization by doing spin-up, read&n;     * capacity, etc, etc &n;     */
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;finish
op_logical_and
id|sdtpnt-&gt;nr_dev
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;finish
)paren
(paren
)paren
suffix:semicolon
)brace
id|scsi_loadable_module_flag
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|print_inquiry
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|data
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Vendor: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Model: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Rev: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
OL
l_int|36
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Type:   %s &quot;
comma
id|i
OL
id|MAX_SCSI_DEVICE_CODE
ques
c_cond
id|scsi_device_types
(braket
id|i
)braket
suffix:colon
l_string|&quot;Unknown          &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                 ANSI SCSI revision: %02x&quot;
comma
id|data
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|data
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot; CCS&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|scsi_proc_info
r_int
id|scsi_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|SDTpnt
suffix:semicolon
id|Scsi_Device
op_star
id|scd
comma
op_star
id|scd_h
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|HBA_ptr
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_int
id|host
comma
id|channel
comma
id|id
comma
id|lun
suffix:semicolon
r_int
id|size
comma
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
id|scd
op_assign
id|scsi_devices
suffix:semicolon
id|HBA_ptr
op_assign
id|scsi_hostlist
suffix:semicolon
r_if
c_cond
(paren
id|inout
op_eq
l_int|0
)paren
(brace
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Attached devices: %s&bslash;n&quot;
comma
(paren
id|scd
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;none&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_while
c_loop
(paren
id|HBA_ptr
)paren
(brace
macro_line|#if 0
id|size
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;scsi%2d: %s&bslash;n&quot;
comma
(paren
r_int
)paren
id|HBA_ptr-&gt;host_no
comma
id|HBA_ptr-&gt;hostt-&gt;procname
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
macro_line|#endif
id|scd
op_assign
id|scsi_devices
suffix:semicolon
r_while
c_loop
(paren
id|scd
)paren
(brace
r_if
c_cond
(paren
id|scd-&gt;host
op_eq
id|HBA_ptr
)paren
(brace
id|proc_print_scsidevice
c_func
(paren
id|scd
comma
id|buffer
comma
op_amp
id|size
comma
id|len
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
r_goto
id|stop_output
suffix:semicolon
)brace
id|scd
op_assign
id|scd-&gt;next
suffix:semicolon
)brace
id|HBA_ptr
op_assign
id|HBA_ptr-&gt;next
suffix:semicolon
)brace
id|stop_output
suffix:colon
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start slop */
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
multiline_comment|/* Ending slop */
r_return
(paren
id|len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer
op_logical_or
id|length
OL
l_int|25
op_logical_or
id|strncmp
c_func
(paren
l_string|&quot;scsi&quot;
comma
id|buffer
comma
l_int|4
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;     * Usage: echo &quot;scsi add-single-device 0 1 2 3&quot; &gt;/proc/scsi/scsi&n;     * with  &quot;0 1 2 3&quot; replaced by your &quot;Host Channel Id Lun&quot;.&n;     * Consider this feature BETA.&n;     *     CAUTION: This is not for hotplugging your peripherals. As&n;     *     SCSI was not designed for this you could damage your&n;     *     hardware !  &n;     * However perhaps it is legal to switch on an&n;     * already connected device. It is perhaps not &n;     * guaranteed this device doesn&squot;t corrupt an ongoing data transfer.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
l_string|&quot;add-single-device&quot;
comma
id|buffer
op_plus
l_int|5
comma
l_int|17
)paren
)paren
(brace
id|p
op_assign
id|buffer
op_plus
l_int|23
suffix:semicolon
id|host
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|channel
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|id
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|lun
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi singledevice %d %d %d %d&bslash;n&quot;
comma
id|host
comma
id|channel
comma
id|id
comma
id|lun
)paren
suffix:semicolon
r_while
c_loop
(paren
id|scd
op_logical_and
(paren
id|scd-&gt;host-&gt;host_no
op_ne
id|host
op_logical_or
id|scd-&gt;channel
op_ne
id|channel
op_logical_or
id|scd-&gt;id
op_ne
id|id
op_logical_or
id|scd-&gt;lun
op_ne
id|lun
)paren
)paren
(brace
id|scd
op_assign
id|scd-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scd
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
multiline_comment|/* We do not yet support unplugging */
r_while
c_loop
(paren
id|HBA_ptr
op_logical_and
id|HBA_ptr-&gt;host_no
op_ne
id|host
)paren
(brace
id|HBA_ptr
op_assign
id|HBA_ptr-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|HBA_ptr
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|scan_scsis
(paren
id|HBA_ptr
comma
l_int|1
comma
id|channel
comma
id|id
comma
id|lun
)paren
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
multiline_comment|/*&n;     * Usage: echo &quot;scsi remove-single-device 0 1 2 3&quot; &gt;/proc/scsi/scsi&n;     * with  &quot;0 1 2 3&quot; replaced by your &quot;Host Channel Id Lun&quot;.&n;     *&n;     * Consider this feature pre-BETA.&n;     *&n;     *     CAUTION: This is not for hotplugging your peripherals. As&n;     *     SCSI was not designed for this you could damage your&n;     *     hardware and thoroughly confuse the SCSI subsystem.  &n;     *&n;     */
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
l_string|&quot;remove-single-device&quot;
comma
id|buffer
op_plus
l_int|5
comma
l_int|20
)paren
)paren
(brace
id|p
op_assign
id|buffer
op_plus
l_int|26
suffix:semicolon
id|host
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|channel
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|id
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
id|lun
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|scd
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|scd-&gt;host-&gt;host_no
op_eq
id|host
op_logical_and
id|scd-&gt;channel
op_eq
id|channel
op_logical_and
id|scd-&gt;id
op_eq
id|id
op_logical_and
id|scd-&gt;lun
op_eq
id|lun
)paren
(brace
r_break
suffix:semicolon
)brace
id|scd_h
op_assign
id|scd
suffix:semicolon
id|scd
op_assign
id|scd-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scd
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* there is no such device attached */
r_if
c_cond
(paren
id|scd-&gt;access_count
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|SDTpnt
op_assign
id|scsi_devicelist
suffix:semicolon
r_while
c_loop
(paren
id|SDTpnt
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|SDTpnt-&gt;detach
)paren
(brace
(paren
op_star
id|SDTpnt-&gt;detach
)paren
(paren
id|scd
)paren
suffix:semicolon
)brace
id|SDTpnt
op_assign
id|SDTpnt-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scd-&gt;attached
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;             * Nobody is using this device any more.&n;             * Free all of the command structures.&n;             */
r_for
c_loop
(paren
id|SCpnt
op_assign
id|scd-&gt;host-&gt;host_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;device
op_eq
id|scd
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;prev
op_ne
l_int|NULL
)paren
(brace
id|SCpnt-&gt;prev-&gt;next
op_assign
id|SCpnt-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|SCpnt-&gt;next-&gt;prev
op_assign
id|SCpnt-&gt;prev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt
op_eq
id|scd-&gt;host-&gt;host_queue
)paren
(brace
id|scd-&gt;host-&gt;host_queue
op_assign
id|SCpnt-&gt;next
suffix:semicolon
)brace
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|SCpnt
comma
r_sizeof
(paren
op_star
id|SCpnt
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Now we can remove the device structure */
r_if
c_cond
(paren
id|scd_h
op_ne
l_int|NULL
)paren
(brace
id|scd_h-&gt;next
op_assign
id|scd-&gt;next
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scsi_devices
op_eq
id|scd
)paren
(brace
multiline_comment|/* We had a hit on the first entry of the device list */
id|scsi_devices
op_assign
id|scd-&gt;next
suffix:semicolon
)brace
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|scd
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Go through the device list and recompute the most appropriate size&n; * for the dma pool.  Then grab more memory (as required).&n; */
DECL|function|resize_dma_pool
r_static
r_void
id|resize_dma_pool
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|FreeSectorBitmap
op_star
id|new_dma_malloc_freelist
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|new_dma_sectors
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|new_need_isa_buffer
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
op_star
id|new_dma_malloc_pages
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_devices
)paren
(brace
multiline_comment|/*&n;&t; * Free up the DMA pool.&n;&t; */
r_if
c_cond
(paren
id|dma_free_sectors
op_ne
id|dma_sectors
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;SCSI DMA pool memory leak %d %d&bslash;n&quot;
comma
id|dma_free_sectors
comma
id|dma_sectors
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scsi_init_free
c_func
(paren
id|dma_malloc_pages
(braket
id|i
)braket
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dma_malloc_pages
)paren
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_pages
comma
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|dma_malloc_pages
)paren
)paren
suffix:semicolon
id|dma_malloc_pages
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_freelist
)paren
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_freelist
comma
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|dma_malloc_freelist
)paren
)paren
suffix:semicolon
id|dma_malloc_freelist
op_assign
l_int|NULL
suffix:semicolon
id|dma_sectors
op_assign
l_int|0
suffix:semicolon
id|dma_free_sectors
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Next, check to see if we need to extend the DMA buffer pool */
id|new_dma_sectors
op_assign
l_int|2
op_star
id|SECTORS_PER_PAGE
suffix:semicolon
multiline_comment|/* Base value we use */
r_if
c_cond
(paren
id|high_memory
op_minus
l_int|1
OG
id|ISA_DMA_THRESHOLD
)paren
id|scsi_need_isa_bounce_buffers
op_assign
l_int|1
suffix:semicolon
r_else
id|scsi_need_isa_bounce_buffers
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|scsi_devicelist
)paren
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
id|new_dma_sectors
op_add_assign
id|SECTORS_PER_PAGE
suffix:semicolon
)brace
multiline_comment|/* Increment for each host */
r_for
c_loop
(paren
id|SDpnt
op_assign
id|scsi_devices
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
id|host
op_assign
id|SDpnt-&gt;host
suffix:semicolon
multiline_comment|/*&n;&t; * sd and sr drivers allocate scatterlists.&n;&t; * sr drivers may allocate for each command 1x2048 or 2x1024 extra &n;&t; * buffers for 2k sector size and 1k fs.&n;&t; * sg driver allocates buffers &lt; 4k.&n;&t; * st driver does not need buffers from the dma pool.&n;&t; * estimate 4k buffer/command for devices of unknown type (should panic).&n;&t; */
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_eq
id|TYPE_WORM
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_ROM
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_DISK
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_MOD
)paren
(brace
id|new_dma_sectors
op_add_assign
(paren
(paren
id|host-&gt;sg_tablesize
op_star
r_sizeof
(paren
r_struct
id|scatterlist
)paren
op_plus
l_int|511
)paren
op_rshift
l_int|9
)paren
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_eq
id|TYPE_WORM
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_ROM
)paren
id|new_dma_sectors
op_add_assign
(paren
l_int|2048
op_rshift
l_int|9
)paren
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_eq
id|TYPE_SCANNER
op_logical_or
id|SDpnt-&gt;type
op_eq
id|TYPE_PROCESSOR
)paren
(brace
id|new_dma_sectors
op_add_assign
(paren
l_int|4096
op_rshift
l_int|9
)paren
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|SDpnt-&gt;type
op_ne
id|TYPE_TAPE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: unknown device type %d&bslash;n&quot;
comma
id|SDpnt-&gt;type
)paren
suffix:semicolon
id|new_dma_sectors
op_add_assign
(paren
l_int|4096
op_rshift
l_int|9
)paren
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|host-&gt;unchecked_isa_dma
op_logical_and
id|scsi_need_isa_bounce_buffers
op_logical_and
id|SDpnt-&gt;type
op_ne
id|TYPE_TAPE
)paren
(brace
id|new_dma_sectors
op_add_assign
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
op_star
id|host-&gt;sg_tablesize
op_star
id|SDpnt-&gt;queue_depth
suffix:semicolon
id|new_need_isa_buffer
op_increment
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG_INIT
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: needed dma sectors = %d&bslash;n&quot;
comma
id|new_dma_sectors
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* limit DMA memory to 32MB: */
id|new_dma_sectors
op_assign
(paren
id|new_dma_sectors
op_plus
l_int|15
)paren
op_amp
l_int|0xfff0
suffix:semicolon
multiline_comment|/*&n;     * We never shrink the buffers - this leads to&n;     * race conditions that I would rather not even think&n;     * about right now.&n;     */
r_if
c_cond
(paren
id|new_dma_sectors
OL
id|dma_sectors
)paren
(brace
id|new_dma_sectors
op_assign
id|dma_sectors
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_dma_sectors
)paren
(brace
id|size
op_assign
(paren
id|new_dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
id|FreeSectorBitmap
)paren
suffix:semicolon
id|new_dma_malloc_freelist
op_assign
(paren
id|FreeSectorBitmap
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|memset
c_func
(paren
id|new_dma_malloc_freelist
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|size
op_assign
(paren
id|new_dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|new_dma_malloc_pages
)paren
suffix:semicolon
id|new_dma_malloc_pages
op_assign
(paren
r_int
r_char
op_star
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|memset
c_func
(paren
id|new_dma_malloc_pages
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * If we need more buffers, expand the list.&n;     */
r_if
c_cond
(paren
id|new_dma_sectors
OG
id|dma_sectors
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|i
OL
id|new_dma_sectors
op_div
id|SECTORS_PER_PAGE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|new_dma_malloc_pages
(braket
id|i
)braket
op_assign
(paren
r_int
r_char
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|PAGE_SIZE
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* When we dick with the actual DMA list, we need to &n;     * protect things &n;     */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_freelist
)paren
(brace
id|size
op_assign
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
id|FreeSectorBitmap
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_dma_malloc_freelist
comma
id|dma_malloc_freelist
comma
id|size
)paren
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_freelist
comma
id|size
)paren
suffix:semicolon
)brace
id|dma_malloc_freelist
op_assign
id|new_dma_malloc_freelist
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_pages
)paren
(brace
id|size
op_assign
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|dma_malloc_pages
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_dma_malloc_pages
comma
id|dma_malloc_pages
comma
id|size
)paren
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|dma_malloc_pages
comma
id|size
)paren
suffix:semicolon
)brace
id|dma_free_sectors
op_add_assign
id|new_dma_sectors
op_minus
id|dma_sectors
suffix:semicolon
id|dma_malloc_pages
op_assign
id|new_dma_malloc_pages
suffix:semicolon
id|dma_sectors
op_assign
id|new_dma_sectors
suffix:semicolon
id|need_isa_buffer
op_assign
id|new_need_isa_buffer
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_INIT
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: dma free sectors   = %d&bslash;n&quot;
comma
id|dma_free_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: dma sectors        = %d&bslash;n&quot;
comma
id|dma_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;resize_dma_pool: need isa buffers   = %d&bslash;n&quot;
comma
id|need_isa_buffer
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_MODULES&t;&t;/* a big #ifdef block... */
multiline_comment|/*&n; * This entry point should be called by a loadable module if it is trying&n; * add a low level scsi driver to the system.&n; */
DECL|function|scsi_register_host
r_static
r_int
id|scsi_register_host
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|pcount
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
id|tpnt-&gt;next
op_logical_or
op_logical_neg
id|tpnt-&gt;detect
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Must be already loaded, or&n;&t;&t;&t;&t;&t;       * no detect routine available &n;&t;&t;&t;&t;&t;       */
id|pcount
op_assign
id|next_scsi_host
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tpnt-&gt;present
op_assign
id|tpnt
op_member_access_from_pointer
id|detect
c_func
(paren
id|tpnt
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|pcount
op_eq
id|next_scsi_host
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;present
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Failure to register low-level scsi driver&quot;
)paren
suffix:semicolon
id|scsi_unregister_host
c_func
(paren
id|tpnt
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* The low-level driver failed to register a driver.  We&n;&t;     *  can do this now. &n;&t;     */
id|scsi_register
c_func
(paren
id|tpnt
comma
l_int|0
)paren
suffix:semicolon
)brace
id|tpnt-&gt;next
op_assign
id|scsi_hosts
suffix:semicolon
multiline_comment|/* Add to the linked list */
id|scsi_hosts
op_assign
id|tpnt
suffix:semicolon
multiline_comment|/* Add the new driver to /proc/scsi */
macro_line|#if CONFIG_PROC_FS 
id|build_proc_dir_entries
c_func
(paren
id|tpnt
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_eq
id|tpnt
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;info
)paren
(brace
id|name
op_assign
id|tpnt
op_member_access_from_pointer
id|info
c_func
(paren
id|shpnt
)paren
suffix:semicolon
)brace
r_else
id|name
op_assign
id|tpnt-&gt;name
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : %s&bslash;n&quot;
comma
multiline_comment|/* And print a little message */
id|shpnt-&gt;host_no
comma
id|name
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;scsi : %d host%s.&bslash;n&quot;
comma
id|next_scsi_host
comma
(paren
id|next_scsi_host
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|scsi_make_blocked_list
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* The next step is to call scan_scsis here.  This generates the&n;&t; * Scsi_Devices entries &n;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_eq
id|tpnt
)paren
(brace
id|scan_scsis
c_func
(paren
id|shpnt
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;init
op_logical_and
id|sdtpnt-&gt;dev_noticed
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;init
)paren
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Next we create the Scsi_Cmnd structures for this host */
r_for
c_loop
(paren
id|SDpnt
op_assign
id|scsi_devices
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
r_if
c_cond
(paren
id|SDpnt-&gt;host-&gt;hostt
op_eq
id|tpnt
)paren
(brace
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;attach
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;attach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SDpnt-&gt;attached
)paren
(brace
id|scsi_build_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now that we have all of the devices, resize the DMA pool,&n;&t; * as required.  */
id|resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* This does any final handling that is required. */
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;finish
op_logical_and
id|sdtpnt-&gt;nr_dev
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;finish
)paren
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#if defined(USE_STATIC_SCSI_MEMORY)
id|printk
(paren
l_string|&quot;SCSI memory: total %ldKb, used %ldKb, free %ldKb.&bslash;n&quot;
comma
(paren
id|scsi_memory_upper_value
op_minus
id|scsi_memory_lower_value
)paren
op_div
l_int|1024
comma
(paren
id|scsi_init_memory_start
op_minus
id|scsi_memory_lower_value
)paren
op_div
l_int|1024
comma
(paren
id|scsi_memory_upper_value
op_minus
id|scsi_init_memory_start
)paren
op_div
l_int|1024
)paren
suffix:semicolon
macro_line|#endif
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Similarly, this entry point should be called by a loadable module if it&n; * is trying to remove a low level scsi driver from the system.&n; */
DECL|function|scsi_unregister_host
r_static
r_void
id|scsi_unregister_host
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
id|Scsi_Host_Template
op_star
id|SHT
comma
op_star
id|SHTp
suffix:semicolon
id|Scsi_Device
op_star
id|sdpnt
comma
op_star
id|sdppnt
comma
op_star
id|sdpnt1
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
op_star
id|sh1
suffix:semicolon
r_int
id|pcount
suffix:semicolon
multiline_comment|/* First verify that this host adapter is completely free with no pending&n;     * commands */
r_for
c_loop
(paren
id|sdpnt
op_assign
id|scsi_devices
suffix:semicolon
id|sdpnt
suffix:semicolon
id|sdpnt
op_assign
id|sdpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdpnt-&gt;host-&gt;hostt
op_eq
id|tpnt
op_logical_and
id|sdpnt-&gt;host-&gt;hostt-&gt;usage_count
op_logical_and
op_star
id|sdpnt-&gt;host-&gt;hostt-&gt;usage_count
)paren
(brace
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_ne
id|tpnt
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|SCpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_ne
id|RQ_INACTIVE
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SCpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;request.rq_status
op_eq
id|RQ_SCSI_DISCONNECTING
)paren
(brace
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Device busy???&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_DISCONNECTING
suffix:semicolon
multiline_comment|/* Mark as busy */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Next we detach the high level drivers from the Scsi_Device structures */
r_for
c_loop
(paren
id|sdpnt
op_assign
id|scsi_devices
suffix:semicolon
id|sdpnt
suffix:semicolon
id|sdpnt
op_assign
id|sdpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdpnt-&gt;host-&gt;hostt
op_eq
id|tpnt
)paren
(brace
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;detach
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;detach
)paren
(paren
id|sdpnt
)paren
suffix:semicolon
)brace
multiline_comment|/* If something still attached, punt */
r_if
c_cond
(paren
id|sdpnt-&gt;attached
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attached usage count = %d&bslash;n&quot;
comma
id|sdpnt-&gt;attached
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Next we free up the Scsi_Cmnd structures for this host */
r_for
c_loop
(paren
id|sdpnt
op_assign
id|scsi_devices
suffix:semicolon
id|sdpnt
suffix:semicolon
id|sdpnt
op_assign
id|sdpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdpnt-&gt;host-&gt;hostt
op_eq
id|tpnt
)paren
r_while
c_loop
(paren
id|sdpnt-&gt;host-&gt;host_queue
)paren
(brace
id|SCpnt
op_assign
id|sdpnt-&gt;host-&gt;host_queue-&gt;next
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|sdpnt-&gt;host-&gt;host_queue
comma
r_sizeof
(paren
id|Scsi_Cmnd
)paren
)paren
suffix:semicolon
id|sdpnt-&gt;host-&gt;host_queue
op_assign
id|SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
)paren
id|SCpnt-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|sdpnt-&gt;has_cmdblocks
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Next free up the Scsi_Device structures for this host */
id|sdppnt
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|sdpnt
op_assign
id|scsi_devices
suffix:semicolon
id|sdpnt
suffix:semicolon
id|sdpnt
op_assign
id|sdpnt1
)paren
(brace
id|sdpnt1
op_assign
id|sdpnt-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|sdpnt-&gt;host-&gt;hostt
op_eq
id|tpnt
)paren
(brace
r_if
c_cond
(paren
id|sdppnt
)paren
id|sdppnt-&gt;next
op_assign
id|sdpnt-&gt;next
suffix:semicolon
r_else
id|scsi_devices
op_assign
id|sdpnt-&gt;next
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|sdpnt
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
)brace
r_else
id|sdppnt
op_assign
id|sdpnt
suffix:semicolon
)brace
multiline_comment|/* Next we go through and remove the instances of the individual hosts&n;     * that were detected */
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
r_while
c_loop
(paren
id|shpnt
)paren
(brace
id|sh1
op_assign
id|shpnt-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;hostt
op_eq
id|tpnt
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;loaded_as_module
)paren
(brace
id|pcount
op_assign
id|next_scsi_host
suffix:semicolon
multiline_comment|/* Remove the /proc/scsi directory entry */
macro_line|#if CONFIG_PROC_FS 
id|proc_scsi_unregister
c_func
(paren
id|tpnt-&gt;proc_dir
comma
id|shpnt-&gt;host_no
op_plus
id|PROC_SCSI_FILE
)paren
suffix:semicolon
macro_line|#endif   
r_if
c_cond
(paren
id|tpnt-&gt;release
)paren
(brace
(paren
op_star
id|tpnt-&gt;release
)paren
(paren
id|shpnt
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This is the default case for the release function.  &n;&t;&t;     * It should do the right thing for most correctly &n;&t;&t;     * written host adapters. &n;&t;&t;     */
r_if
c_cond
(paren
id|shpnt-&gt;irq
)paren
id|free_irq
c_func
(paren
id|shpnt-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;dma_channel
op_ne
l_int|0xff
)paren
id|free_dma
c_func
(paren
id|shpnt-&gt;dma_channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;io_port
op_logical_and
id|shpnt-&gt;n_io_port
)paren
id|release_region
c_func
(paren
id|shpnt-&gt;io_port
comma
id|shpnt-&gt;n_io_port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pcount
op_eq
id|next_scsi_host
)paren
(brace
id|scsi_unregister
c_func
(paren
id|shpnt
)paren
suffix:semicolon
)brace
id|tpnt-&gt;present
op_decrement
suffix:semicolon
)brace
)brace
id|shpnt
op_assign
id|sh1
suffix:semicolon
)brace
multiline_comment|/*&n;     * If there are absolutely no more hosts left, it is safe&n;     * to completely nuke the DMA pool.  The resize operation will&n;     * do the right thing and free everything.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|scsi_devices
)paren
(brace
id|resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;scsi : %d host%s.&bslash;n&quot;
comma
id|next_scsi_host
comma
(paren
id|next_scsi_host
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
suffix:semicolon
macro_line|#if defined(USE_STATIC_SCSI_MEMORY)
id|printk
(paren
l_string|&quot;SCSI memory: total %ldKb, used %ldKb, free %ldKb.&bslash;n&quot;
comma
(paren
id|scsi_memory_upper_value
op_minus
id|scsi_memory_lower_value
)paren
op_div
l_int|1024
comma
(paren
id|scsi_init_memory_start
op_minus
id|scsi_memory_lower_value
)paren
op_div
l_int|1024
comma
(paren
id|scsi_memory_upper_value
op_minus
id|scsi_init_memory_start
)paren
op_div
l_int|1024
)paren
suffix:semicolon
macro_line|#endif
id|scsi_make_blocked_list
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* There were some hosts that were loaded at boot time, so we cannot&n;       do any more than this */
r_if
c_cond
(paren
id|tpnt-&gt;present
)paren
r_return
suffix:semicolon
multiline_comment|/* OK, this is the very last step.  Remove this host adapter from the&n;       linked list. */
r_for
c_loop
(paren
id|SHTp
op_assign
l_int|NULL
comma
id|SHT
op_assign
id|scsi_hosts
suffix:semicolon
id|SHT
suffix:semicolon
id|SHTp
op_assign
id|SHT
comma
id|SHT
op_assign
id|SHT-&gt;next
)paren
r_if
c_cond
(paren
id|SHT
op_eq
id|tpnt
)paren
(brace
r_if
c_cond
(paren
id|SHTp
)paren
(brace
id|SHTp-&gt;next
op_assign
id|SHT-&gt;next
suffix:semicolon
)brace
r_else
id|scsi_hosts
op_assign
id|SHT-&gt;next
suffix:semicolon
id|SHT-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Rebuild the /proc/scsi directory entries */
macro_line|#if CONFIG_PROC_FS 
id|proc_scsi_unregister
c_func
(paren
id|tpnt-&gt;proc_dir
comma
id|tpnt-&gt;proc_dir-&gt;low_ino
)paren
suffix:semicolon
macro_line|#endif
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/*&n; * This entry point should be called by a loadable module if it is trying&n; * add a high level scsi driver to the system.&n; */
DECL|function|scsi_register_device_module
r_static
r_int
id|scsi_register_device_module
c_func
(paren
r_struct
id|Scsi_Device_Template
op_star
id|tpnt
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_if
c_cond
(paren
id|tpnt-&gt;next
)paren
r_return
l_int|1
suffix:semicolon
id|scsi_register_device
c_func
(paren
id|tpnt
)paren
suffix:semicolon
multiline_comment|/*&n;     * First scan the devices that we know about, and see if we notice them.&n;     */
r_for
c_loop
(paren
id|SDpnt
op_assign
id|scsi_devices
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
r_if
c_cond
(paren
id|tpnt-&gt;detect
)paren
(brace
id|SDpnt-&gt;attached
op_add_assign
(paren
op_star
id|tpnt-&gt;detect
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * If any of the devices would match this driver, then perform the&n;     * init function.&n;     */
r_if
c_cond
(paren
id|tpnt-&gt;init
op_logical_and
id|tpnt-&gt;dev_noticed
)paren
r_if
c_cond
(paren
(paren
op_star
id|tpnt-&gt;init
)paren
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;     * Now actually connect the devices to the new driver.&n;     */
r_for
c_loop
(paren
id|SDpnt
op_assign
id|scsi_devices
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;attach
)paren
(brace
(paren
op_star
id|tpnt-&gt;attach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If this driver attached to the device, and we no longer&n;&t; * have anything attached, release the scsi command blocks.&n;&t; */
r_if
c_cond
(paren
id|SDpnt-&gt;attached
op_logical_and
id|SDpnt-&gt;has_cmdblocks
op_eq
l_int|0
)paren
(brace
id|scsi_build_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * This does any final handling that is required. &n;     */
r_if
c_cond
(paren
id|tpnt-&gt;finish
op_logical_and
id|tpnt-&gt;nr_dev
)paren
(brace
(paren
op_star
id|tpnt-&gt;finish
)paren
(paren
)paren
suffix:semicolon
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scsi_unregister_device
r_static
r_int
id|scsi_unregister_device
c_func
(paren
r_struct
id|Scsi_Device_Template
op_star
id|tpnt
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|spnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|prev_spnt
suffix:semicolon
multiline_comment|/*&n;     * If we are busy, this is not going to fly.&n;     */
r_if
c_cond
(paren
op_star
id|tpnt-&gt;usage_count
op_ne
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * Next, detach the devices from the driver.&n;     */
r_for
c_loop
(paren
id|SDpnt
op_assign
id|scsi_devices
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tpnt-&gt;detach
)paren
(brace
(paren
op_star
id|tpnt-&gt;detach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SDpnt-&gt;attached
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;     * Nobody is using this device any more.  Free all of the&n;&t;     * command structures.&n;&t;     */
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;host-&gt;host_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;device
op_eq
id|SDpnt
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;prev
op_ne
l_int|NULL
)paren
(brace
id|SCpnt-&gt;prev-&gt;next
op_assign
id|SCpnt-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|SCpnt-&gt;next-&gt;prev
op_assign
id|SCpnt-&gt;prev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt
op_eq
id|SDpnt-&gt;host-&gt;host_queue
)paren
(brace
id|SDpnt-&gt;host-&gt;host_queue
op_assign
id|SCpnt-&gt;next
suffix:semicolon
)brace
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|SCpnt
comma
r_sizeof
(paren
op_star
id|SCpnt
)paren
)paren
suffix:semicolon
)brace
)brace
id|SDpnt-&gt;has_cmdblocks
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * Extract the template from the linked list.&n;     */
id|spnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|prev_spnt
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|spnt
op_ne
id|tpnt
)paren
(brace
id|prev_spnt
op_assign
id|spnt
suffix:semicolon
id|spnt
op_assign
id|spnt-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev_spnt
op_eq
l_int|NULL
)paren
(brace
id|scsi_devicelist
op_assign
id|tpnt-&gt;next
suffix:semicolon
)brace
r_else
id|prev_spnt-&gt;next
op_assign
id|spnt-&gt;next
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
multiline_comment|/*&n;     * Final cleanup for the driver is done in the driver sources in the &n;     * cleanup function.&n;     */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scsi_register_module
r_int
id|scsi_register_module
c_func
(paren
r_int
id|module_type
comma
r_void
op_star
id|ptr
)paren
(brace
r_switch
c_cond
(paren
id|module_type
)paren
(brace
r_case
id|MODULE_SCSI_HA
suffix:colon
r_return
id|scsi_register_host
c_func
(paren
(paren
id|Scsi_Host_Template
op_star
)paren
id|ptr
)paren
suffix:semicolon
multiline_comment|/* Load upper level device handler of some kind */
r_case
id|MODULE_SCSI_DEV
suffix:colon
macro_line|#ifdef CONFIG_KERNELD
r_if
c_cond
(paren
id|scsi_hosts
op_eq
l_int|NULL
)paren
id|request_module
c_func
(paren
l_string|&quot;scsi_hostadapter&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|scsi_register_device_module
c_func
(paren
(paren
r_struct
id|Scsi_Device_Template
op_star
)paren
id|ptr
)paren
suffix:semicolon
multiline_comment|/* The rest of these are not yet implemented */
multiline_comment|/* Load constants.o */
r_case
id|MODULE_SCSI_CONST
suffix:colon
multiline_comment|/* Load specialized ioctl handler for some device.  Intended for &n;&t; * cdroms that have non-SCSI2 audio command sets. */
r_case
id|MODULE_SCSI_IOCTL
suffix:colon
r_default
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|scsi_unregister_module
r_void
id|scsi_unregister_module
c_func
(paren
r_int
id|module_type
comma
r_void
op_star
id|ptr
)paren
(brace
r_switch
c_cond
(paren
id|module_type
)paren
(brace
r_case
id|MODULE_SCSI_HA
suffix:colon
id|scsi_unregister_host
c_func
(paren
(paren
id|Scsi_Host_Template
op_star
)paren
id|ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODULE_SCSI_DEV
suffix:colon
id|scsi_unregister_device
c_func
(paren
(paren
r_struct
id|Scsi_Device_Template
op_star
)paren
id|ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* The rest of these are not yet implemented. */
r_case
id|MODULE_SCSI_CONST
suffix:colon
r_case
id|MODULE_SCSI_IOCTL
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
r_return
suffix:semicolon
)brace
macro_line|#endif&t;&t;/* CONFIG_MODULES */
macro_line|#ifdef DEBUG_TIMEOUT
r_static
r_void
DECL|function|scsi_dump_status
id|scsi_dump_status
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Dump of scsi parameters:&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_hostlist
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|shpnt-&gt;next
)paren
r_for
c_loop
(paren
id|SCpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
multiline_comment|/*  (0) 0:0:0:0 (802 123434 8 8 0) (3 3 2) (%d %d %d) %d %x      */
id|printk
c_func
(paren
l_string|&quot;(%d) %d:%d:%d:%d (%s %ld %ld %ld %d) (%d %d %x) (%d %d %d) %x %x %x&bslash;n&quot;
comma
id|i
op_increment
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|kdevname
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
comma
id|SCpnt-&gt;request.sector
comma
id|SCpnt-&gt;request.nr_sectors
comma
id|SCpnt-&gt;request.current_nr_sectors
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;retries
comma
id|SCpnt-&gt;allowed
comma
id|SCpnt-&gt;flags
comma
id|SCpnt-&gt;timeout_per_command
comma
id|SCpnt-&gt;timeout
comma
id|SCpnt-&gt;internal_timeout
comma
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
comma
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
comma
id|SCpnt-&gt;result
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;wait_for_request = %p&bslash;n&quot;
comma
id|wait_for_request
)paren
suffix:semicolon
multiline_comment|/* Now dump the request lists for each block device */
id|printk
c_func
(paren
l_string|&quot;Dump of pending block device requests&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_BLKDEV
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|blk_dev
(braket
id|i
)braket
dot
id|current_request
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d: &quot;
comma
id|i
)paren
suffix:semicolon
id|req
op_assign
id|blk_dev
(braket
id|i
)braket
dot
id|current_request
suffix:semicolon
r_while
c_loop
(paren
id|req
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(%s %d %ld %ld %ld) &quot;
comma
id|kdevname
c_func
(paren
id|req-&gt;rq_dev
)paren
comma
id|req-&gt;cmd
comma
id|req-&gt;sector
comma
id|req-&gt;nr_sectors
comma
id|req-&gt;current_nr_sectors
)paren
suffix:semicolon
id|req
op_assign
id|req-&gt;next
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
multiline_comment|/*&n;     * This makes /proc/scsi visible.&n;     */
macro_line|#if CONFIG_PROC_FS
id|dispatch_scsi_info_ptr
op_assign
id|dispatch_scsi_info
suffix:semicolon
macro_line|#endif
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|fn
op_assign
id|scsi_main_timeout
suffix:semicolon
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|expires
op_assign
l_int|0
suffix:semicolon
id|register_symtab
c_func
(paren
op_amp
id|scsi_symbol_table
)paren
suffix:semicolon
id|scsi_loadable_module_flag
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Register the /proc/scsi/scsi entry */
macro_line|#if CONFIG_PROC_FS
id|proc_scsi_register
c_func
(paren
l_int|0
comma
op_amp
id|proc_scsi_scsi
)paren
suffix:semicolon
macro_line|#endif
id|dma_sectors
op_assign
id|PAGE_SIZE
op_div
id|SECTOR_SIZE
suffix:semicolon
id|dma_free_sectors
op_assign
id|dma_sectors
suffix:semicolon
multiline_comment|/*&n;     * Set up a minimal DMA buffer list - this will be used during scan_scsis&n;     * in some cases.&n;     */
multiline_comment|/* One bit per sector to indicate free/busy */
id|size
op_assign
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
id|FreeSectorBitmap
)paren
suffix:semicolon
id|dma_malloc_freelist
op_assign
(paren
r_int
r_char
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dma_malloc_freelist
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* One pointer per page for the page list */
id|dma_malloc_pages
op_assign
(paren
r_int
r_char
op_star
op_star
)paren
id|scsi_init_malloc
c_func
(paren
(paren
id|dma_sectors
op_div
id|SECTORS_PER_PAGE
)paren
op_star
r_sizeof
(paren
op_star
id|dma_malloc_pages
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|dma_malloc_pages
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_char
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|PAGE_SIZE
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
macro_line|#if CONFIG_PROC_FS
id|proc_scsi_unregister
c_func
(paren
l_int|0
comma
id|PROC_SCSI_SCSI
)paren
suffix:semicolon
multiline_comment|/* No, we&squot;re not here anymore. Don&squot;t show the /proc/scsi files. */
id|dispatch_scsi_info_ptr
op_assign
l_int|0L
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;     * Free up the DMA pool.&n;     */
id|resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|fn
op_assign
l_int|NULL
suffix:semicolon
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|expires
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: nil&n; * tab-width: 8&n; * End:&n; */
eof
