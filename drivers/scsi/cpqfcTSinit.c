multiline_comment|/* Copyright(c) 2000, Compaq Computer Corporation &n; * Fibre Channel Host Bus Adapter &n; * 64-bit, 66MHz PCI &n; * Originally developed and tested on:&n; * (front): [chip] Tachyon TS HPFC-5166A/1.2  L2C1090 ...&n; *          SP# P225CXCBFIEL6T, Rev XC&n; *          SP# 161290-001, Rev XD&n; * (back): Board No. 010008-001 A/W Rev X5, FAB REV X5&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; * Written by Don Zimmerman&n; * IOCTL and procfs added by Jouke Numan&n; * SMP testing by Chel Van Gennip&n; *&n; * portions copied from:&n; * QLogic CPQFCTS SCSI-FCP&n; * Written by Erik H. Moe, ehm@cris.com&n; * Copyright 1995, Erik H. Moe&n; * Renamed and updated to 1.3.x by Michael Griffith &lt;grif@cs.ucr.edu&gt; &n; * Chris Loveland &lt;cwl@iol.unh.edu&gt; to support the isp2100 and isp2200&n;*/
DECL|macro|LinuxVersionCode
mdefine_line|#define LinuxVersionCode(v, p, s) (((v)&lt;&lt;16)+((p)&lt;&lt;8)+(s))
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;  
singleline_comment|// request_region() prototype
macro_line|#include &lt;linux/vmalloc.h&gt; 
singleline_comment|// ioremap()
macro_line|#ifdef __alpha__
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#endif
macro_line|#include &lt;asm/unistd.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;   
singleline_comment|// ioctl related
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,3,18)
macro_line|#include &lt;asm/spinlock.h&gt;
macro_line|#else
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#endif
macro_line|#include &quot;sd.h&quot;
macro_line|#include &lt;scsi/scsi_ioctl.h&gt;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;cpqfcTSchip.h&quot;
macro_line|#include &quot;cpqfcTSstructs.h&quot;
macro_line|#include &quot;cpqfcTS.h&quot;
macro_line|#include &lt;linux/module.h&gt;
multiline_comment|/* Embedded module documentation macros - see module.h */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Compaq Computer Corporation&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Driver for Compaq 64-bit/66Mhz PCI Fibre Channel HBA&quot;
)paren
suffix:semicolon
singleline_comment|// This struct was originally defined in 
singleline_comment|// /usr/src/linux/include/linux/proc_fs.h
singleline_comment|// since it&squot;s only partially implemented, we only use first
singleline_comment|// few fields...
singleline_comment|// NOTE: proc_fs changes in 2.4 kernel
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,3,27)
DECL|variable|proc_scsi_cpqfcTS
r_static
r_struct
id|proc_dir_entry
id|proc_scsi_cpqfcTS
op_assign
(brace
id|PROC_SCSI_CPQFCTS
comma
singleline_comment|// ushort low_ino (enumerated list)
l_int|7
comma
singleline_comment|// ushort namelen
id|DEV_NAME
comma
singleline_comment|// const char* name
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
singleline_comment|// mode_t mode
l_int|2
singleline_comment|// nlink_t nlink
singleline_comment|// etc. ...
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/* local function to load our per-HBA (local) data for chip&n;   registers, FC link state, all FC exchanges, etc.&n;&n;   We allocate space and compute address offsets for the&n;   most frequently accessed addresses; others (like World Wide&n;   Name) are not necessary.&n;   &n;*/
DECL|function|Cpqfc_initHBAdata
r_static
r_void
id|Cpqfc_initHBAdata
c_func
(paren
id|CPQFCHBA
op_star
id|cpqfcHBAdata
comma
r_struct
id|pci_dev
op_star
id|PciDev
)paren
(brace
id|cpqfcHBAdata-&gt;PciDev
op_assign
id|PciDev
suffix:semicolon
singleline_comment|// copy PCI info ptr
singleline_comment|// since x86 port space is 64k, we only need the lower 16 bits
id|cpqfcHBAdata-&gt;fcChip.Registers.IOBaseL
op_assign
id|PciDev-&gt;base_address
(braket
l_int|1
)braket
op_amp
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.Registers.IOBaseU
op_assign
id|PciDev-&gt;base_address
(braket
l_int|2
)braket
op_amp
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
singleline_comment|// 32-bit memory addresses
id|cpqfcHBAdata-&gt;fcChip.Registers.MemBase
op_assign
id|PciDev-&gt;base_address
(braket
l_int|3
)braket
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
op_assign
id|ioremap
c_func
(paren
id|PciDev-&gt;base_address
(braket
l_int|3
)braket
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
comma
l_int|0x200
)paren
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.Registers.RAMBase
op_assign
id|PciDev-&gt;base_address
(braket
l_int|4
)braket
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.Registers.SROMBase
op_assign
singleline_comment|// NULL for HP TS adapter
id|PciDev-&gt;base_address
(braket
l_int|5
)braket
suffix:semicolon
singleline_comment|// now the Tachlite chip registers
singleline_comment|// the REGISTER struct holds both the physical address &amp; last
singleline_comment|// written value (some TL registers are WRITE ONLY)
id|cpqfcHBAdata-&gt;fcChip.Registers.SFQconsumerIndex.address
op_assign
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
op_plus
id|TL_MEM_SFQ_CONSUMER_INDEX
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.Registers.ERQproducerIndex.address
op_assign
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
op_plus
id|TL_MEM_ERQ_PRODUCER_INDEX
suffix:semicolon
singleline_comment|// TL Frame Manager
id|cpqfcHBAdata-&gt;fcChip.Registers.FMconfig.address
op_assign
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
op_plus
id|TL_MEM_FM_CONFIG
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.Registers.FMcontrol.address
op_assign
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
op_plus
id|TL_MEM_FM_CONTROL
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.Registers.FMstatus.address
op_assign
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
op_plus
id|TL_MEM_FM_STATUS
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.Registers.FMLinkStatus1.address
op_assign
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
op_plus
id|TL_MEM_FM_LINK_STAT1
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.Registers.FMLinkStatus2.address
op_assign
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
op_plus
id|TL_MEM_FM_LINK_STAT2
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.Registers.FMBB_CreditZero.address
op_assign
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
op_plus
id|TL_MEM_FM_BB_CREDIT0
suffix:semicolon
singleline_comment|// TL Control Regs
id|cpqfcHBAdata-&gt;fcChip.Registers.TYconfig.address
op_assign
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
op_plus
id|TL_MEM_TACH_CONFIG
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.Registers.TYcontrol.address
op_assign
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
op_plus
id|TL_MEM_TACH_CONTROL
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.Registers.TYstatus.address
op_assign
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
op_plus
id|TL_MEM_TACH_STATUS
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.Registers.rcv_al_pa.address
op_assign
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
op_plus
id|TL_MEM_FM_RCV_AL_PA
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.Registers.ed_tov.address
op_assign
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
op_plus
id|TL_MEM_FM_ED_TOV
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.Registers.INTEN.address
op_assign
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
op_plus
id|IINTEN
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.Registers.INTPEND.address
op_assign
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
op_plus
id|IINTPEND
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.Registers.INTSTAT.address
op_assign
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
op_plus
id|IINTSTAT
suffix:semicolon
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  cpqfcHBAdata-&gt;fcChip.Registers. :&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;    IOBaseL = %x&bslash;n&quot;
comma
id|cpqfcHBAdata-&gt;fcChip.Registers.IOBaseL
)paren
)paren
suffix:semicolon
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;    IOBaseU = %x&bslash;n&quot;
comma
id|cpqfcHBAdata-&gt;fcChip.Registers.IOBaseU
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; ioremap&squot;d Membase: %p&bslash;n&quot;
comma
id|cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase
)paren
suffix:semicolon
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;    SFQconsumerIndex.address = %p&bslash;n&quot;
comma
id|cpqfcHBAdata-&gt;fcChip.Registers.SFQconsumerIndex.address
)paren
)paren
suffix:semicolon
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;    ERQproducerIndex.address = %p&bslash;n&quot;
comma
id|cpqfcHBAdata-&gt;fcChip.Registers.ERQproducerIndex.address
)paren
)paren
suffix:semicolon
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;    TYconfig.address = %p&bslash;n&quot;
comma
id|cpqfcHBAdata-&gt;fcChip.Registers.TYconfig.address
)paren
)paren
suffix:semicolon
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;    FMconfig.address = %p&bslash;n&quot;
comma
id|cpqfcHBAdata-&gt;fcChip.Registers.FMconfig.address
)paren
)paren
suffix:semicolon
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;    FMcontrol.address = %p&bslash;n&quot;
comma
id|cpqfcHBAdata-&gt;fcChip.Registers.FMcontrol.address
)paren
)paren
suffix:semicolon
singleline_comment|// set default options for FC controller (chip)
id|cpqfcHBAdata-&gt;fcChip.Options.initiator
op_assign
l_int|1
suffix:semicolon
singleline_comment|// default: SCSI initiator
id|cpqfcHBAdata-&gt;fcChip.Options.target
op_assign
l_int|0
suffix:semicolon
singleline_comment|// default: SCSI target
id|cpqfcHBAdata-&gt;fcChip.Options.extLoopback
op_assign
l_int|0
suffix:semicolon
singleline_comment|// default: no loopback @GBIC
id|cpqfcHBAdata-&gt;fcChip.Options.intLoopback
op_assign
l_int|0
suffix:semicolon
singleline_comment|// default: no loopback inside chip
singleline_comment|// set highest and lowest FC-PH version the adapter/driver supports
singleline_comment|// (NOT strict compliance)
id|cpqfcHBAdata-&gt;fcChip.highest_FCPH_ver
op_assign
id|FC_PH3
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.lowest_FCPH_ver
op_assign
id|FC_PH43
suffix:semicolon
singleline_comment|// set function points for this controller / adapter
id|cpqfcHBAdata-&gt;fcChip.ResetTachyon
op_assign
id|CpqTsResetTachLite
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.FreezeTachyon
op_assign
id|CpqTsFreezeTachlite
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.UnFreezeTachyon
op_assign
id|CpqTsUnFreezeTachlite
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.CreateTachyonQues
op_assign
id|CpqTsCreateTachLiteQues
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.DestroyTachyonQues
op_assign
id|CpqTsDestroyTachLiteQues
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.InitializeTachyon
op_assign
id|CpqTsInitializeTachLite
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.LaserControl
op_assign
id|CpqTsLaserControl
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.ProcessIMQEntry
op_assign
id|CpqTsProcessIMQEntry
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.InitializeFrameManager
op_assign
id|CpqTsInitializeFrameManager
suffix:semicolon
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.ReadWriteWWN
op_assign
id|CpqTsReadWriteWWN
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip.ReadWriteNVRAM
op_assign
id|CpqTsReadWriteNVRAM
suffix:semicolon
)brace
multiline_comment|/* (borrowed from linux/drivers/scsi/hosts.c) */
DECL|function|launch_FCworker_thread
r_static
r_void
id|launch_FCworker_thread
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|HostAdapter
)paren
(brace
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|sem
)paren
suffix:semicolon
id|CPQFCHBA
op_star
id|cpqfcHBAdata
op_assign
(paren
id|CPQFCHBA
op_star
)paren
id|HostAdapter-&gt;hostdata
suffix:semicolon
id|ENTER
c_func
(paren
l_string|&quot;launch_FC_worker_thread&quot;
)paren
suffix:semicolon
id|cpqfcHBAdata-&gt;notify_wt
op_assign
op_amp
id|sem
suffix:semicolon
id|kernel_thread
c_func
(paren
(paren
r_int
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|cpqfcTSWorkerThread
comma
(paren
r_void
op_star
)paren
id|HostAdapter
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;   * Now wait for the kernel error thread to initialize itself&n;&n;   */
id|down
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|cpqfcHBAdata-&gt;notify_wt
op_assign
l_int|NULL
suffix:semicolon
id|LEAVE
c_func
(paren
l_string|&quot;launch_FC_worker_thread&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* &quot;Entry&quot; point to discover if any supported PCI &n;   bus adapter can be found&n;*/
singleline_comment|// We&squot;re supporting:
singleline_comment|// Compaq 64-bit, 66MHz HBA with Tachyon TS
singleline_comment|// Agilent XL2 
DECL|macro|HBA_TYPES
mdefine_line|#define HBA_TYPES 2
DECL|function|cpqfcTS_detect
r_int
id|cpqfcTS_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|ScsiHostTemplate
)paren
(brace
r_int
id|NumberOfAdapters
op_assign
l_int|0
suffix:semicolon
singleline_comment|// how many of our PCI adapters are found?
r_struct
id|pci_dev
op_star
id|PciDev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|HostAdapter
op_assign
l_int|NULL
suffix:semicolon
id|CPQFCHBA
op_star
id|cpqfcHBAdata
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|timer_list
op_star
id|cpqfcTStimer
op_assign
l_int|NULL
suffix:semicolon
id|SupportedPCIcards
id|PCIids
(braket
id|HBA_TYPES
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ENTER
c_func
(paren
l_string|&quot;cpqfcTS_detect&quot;
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,3,27)
id|ScsiHostTemplate-&gt;proc_dir
op_assign
op_amp
id|proc_scsi_cpqfcTS
suffix:semicolon
macro_line|#else
id|ScsiHostTemplate-&gt;proc_name
op_assign
l_string|&quot;cpqfcTS&quot;
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|pci_present
c_func
(paren
)paren
op_eq
l_int|0
)paren
singleline_comment|// no PCI busses?
(brace
id|printk
c_func
(paren
l_string|&quot;  no PCI bus?@#!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|NumberOfAdapters
suffix:semicolon
)brace
singleline_comment|// what HBA adapters are we supporting?
id|PCIids
(braket
l_int|0
)braket
dot
id|vendor_id
op_assign
id|PCI_VENDOR_ID_COMPAQ
suffix:semicolon
id|PCIids
(braket
l_int|0
)braket
dot
id|device_id
op_assign
id|CPQ_DEVICE_ID
suffix:semicolon
id|PCIids
(braket
l_int|1
)braket
dot
id|vendor_id
op_assign
id|PCI_VENDOR_ID_HP
suffix:semicolon
singleline_comment|// i.e. 103Ch (Agilent == HP for now)
id|PCIids
(braket
l_int|1
)braket
dot
id|device_id
op_assign
id|AGILENT_XL2_ID
suffix:semicolon
singleline_comment|// i.e. 1029h
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HBA_TYPES
suffix:semicolon
id|i
op_increment
)paren
(brace
singleline_comment|// look for all HBAs of each type
r_while
c_loop
(paren
(paren
id|PciDev
op_assign
id|pci_find_device
c_func
(paren
id|PCIids
(braket
id|i
)braket
dot
id|vendor_id
comma
id|PCIids
(braket
id|i
)braket
dot
id|device_id
comma
id|PciDev
)paren
)paren
)paren
(brace
singleline_comment|// NOTE: (kernel 2.2.12-32) limits allocation to 128k bytes...
id|printk
c_func
(paren
l_string|&quot; scsi_register allocating %d bytes for FC HBA&bslash;n&quot;
comma
(paren
id|ULONG
)paren
r_sizeof
(paren
id|CPQFCHBA
)paren
)paren
suffix:semicolon
id|HostAdapter
op_assign
id|scsi_register
c_func
(paren
id|ScsiHostTemplate
comma
r_sizeof
(paren
id|CPQFCHBA
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  HBA found!&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  HostAdapter-&gt;PciDev-&gt;irq = %u&bslash;n&quot;
comma
id|PciDev-&gt;irq
)paren
)paren
suffix:semicolon
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  PciDev-&gt;baseaddress[]= %lx&bslash;n&quot;
comma
id|PciDev-&gt;base_address
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  PciDev-&gt;baseaddress[]= %lx&bslash;n&quot;
comma
id|PciDev-&gt;base_address
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  PciDev-&gt;baseaddress[]= %lx&bslash;n&quot;
comma
id|PciDev-&gt;base_address
(braket
l_int|2
)braket
)paren
)paren
suffix:semicolon
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  PciDev-&gt;baseaddress[]= %lx&bslash;n&quot;
comma
id|PciDev-&gt;base_address
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
id|HostAdapter-&gt;irq
op_assign
id|PciDev-&gt;irq
suffix:semicolon
singleline_comment|// copy for Scsi layers
singleline_comment|// HP Tachlite uses two (255-byte) ranges of Port I/O (lower &amp; upper),
singleline_comment|// for a total I/O port address space of 512 bytes.
singleline_comment|// mask out the I/O port address (lower) &amp; record
id|HostAdapter-&gt;io_port
op_assign
(paren
r_int
r_int
)paren
id|PciDev-&gt;base_address
(braket
l_int|1
)braket
op_amp
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
id|HostAdapter-&gt;n_io_port
op_assign
l_int|0xff
suffix:semicolon
singleline_comment|// i.e., expect 128 targets (arbitrary number), while the
singleline_comment|//  RA-4000 supports 32 LUNs
id|HostAdapter-&gt;max_id
op_assign
l_int|0
suffix:semicolon
singleline_comment|// incremented as devices log in    
id|HostAdapter-&gt;max_lun
op_assign
id|CPQFCTS_MAX_LUN
suffix:semicolon
singleline_comment|// LUNs per FC device
id|HostAdapter-&gt;max_channel
op_assign
id|CPQFCTS_MAX_CHANNEL
suffix:semicolon
singleline_comment|// multiple busses?
id|HostAdapter-&gt;hostt-&gt;use_new_eh_code
op_assign
l_int|1
suffix:semicolon
singleline_comment|// new error handling
singleline_comment|// get the pointer to our HBA specific data... (one for
singleline_comment|// each HBA on the PCI bus(ses)).
id|cpqfcHBAdata
op_assign
(paren
id|CPQFCHBA
op_star
)paren
id|HostAdapter-&gt;hostdata
suffix:semicolon
singleline_comment|// make certain our data struct is clear
id|memset
c_func
(paren
id|cpqfcHBAdata
comma
l_int|0
comma
r_sizeof
(paren
id|CPQFCHBA
)paren
)paren
suffix:semicolon
singleline_comment|// initialize our HBA info
id|cpqfcHBAdata-&gt;HBAnum
op_assign
id|NumberOfAdapters
suffix:semicolon
id|cpqfcHBAdata-&gt;HostAdapter
op_assign
id|HostAdapter
suffix:semicolon
singleline_comment|// back ptr
id|Cpqfc_initHBAdata
c_func
(paren
id|cpqfcHBAdata
comma
id|PciDev
)paren
suffix:semicolon
singleline_comment|// fill MOST fields
id|cpqfcHBAdata-&gt;HBAnum
op_assign
id|NumberOfAdapters
suffix:semicolon
singleline_comment|// request necessary resources and check for conflicts
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|HostAdapter-&gt;irq
comma
id|cpqfcTS_intr_handler
comma
id|SA_INTERRUPT
op_or
id|SA_SHIRQ
comma
id|DEV_NAME
comma
id|HostAdapter
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; IRQ %u already used&bslash;n&quot;
comma
id|HostAdapter-&gt;irq
)paren
suffix:semicolon
id|scsi_unregister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
singleline_comment|// Since we have two 256-byte I/O port ranges (upper
singleline_comment|// and lower), check them both
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|cpqfcHBAdata-&gt;fcChip.Registers.IOBaseU
comma
l_int|0xff
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  cpqfcTS address in use: %x&bslash;n&quot;
comma
id|cpqfcHBAdata-&gt;fcChip.Registers.IOBaseU
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|HostAdapter-&gt;irq
comma
id|HostAdapter
)paren
suffix:semicolon
id|scsi_unregister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|cpqfcHBAdata-&gt;fcChip.Registers.IOBaseL
comma
l_int|0xff
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  cpqfcTS address in use: %x&bslash;n&quot;
comma
id|cpqfcHBAdata-&gt;fcChip.Registers.IOBaseL
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|HostAdapter-&gt;irq
comma
id|HostAdapter
)paren
suffix:semicolon
id|scsi_unregister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
singleline_comment|// OK, we should be able to grab everything we need now.
id|request_region
c_func
(paren
id|cpqfcHBAdata-&gt;fcChip.Registers.IOBaseL
comma
l_int|0xff
comma
id|DEV_NAME
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|cpqfcHBAdata-&gt;fcChip.Registers.IOBaseU
comma
l_int|0xff
comma
id|DEV_NAME
)paren
suffix:semicolon
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  Requesting 255 I/O addresses @ %x&bslash;n&quot;
comma
id|cpqfcHBAdata-&gt;fcChip.Registers.IOBaseL
)paren
)paren
suffix:semicolon
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  Requesting 255 I/O addresses @ %x&bslash;n&quot;
comma
id|cpqfcHBAdata-&gt;fcChip.Registers.IOBaseU
)paren
)paren
suffix:semicolon
singleline_comment|// start our kernel worker thread
id|launch_FCworker_thread
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
singleline_comment|// start our TimerTask...
id|cpqfcTStimer
op_assign
op_amp
id|cpqfcHBAdata-&gt;cpqfcTStimer
suffix:semicolon
id|init_timer
c_func
(paren
id|cpqfcTStimer
)paren
suffix:semicolon
singleline_comment|// Linux clears next/prev values
id|cpqfcTStimer-&gt;expires
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
singleline_comment|// one second
id|cpqfcTStimer-&gt;data
op_assign
(paren
r_int
r_int
)paren
id|cpqfcHBAdata
suffix:semicolon
singleline_comment|// this adapter
id|cpqfcTStimer-&gt;function
op_assign
id|cpqfcTSheartbeat
suffix:semicolon
singleline_comment|// handles timeouts, housekeeping
id|add_timer
c_func
(paren
id|cpqfcTStimer
)paren
suffix:semicolon
singleline_comment|// give it to Linux
singleline_comment|// now initialize our hardware...
id|cpqfcHBAdata-&gt;fcChip
dot
id|InitializeTachyon
c_func
(paren
id|cpqfcHBAdata
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
id|cpqfcHBAdata-&gt;fcStatsTime
op_assign
id|jiffies
suffix:semicolon
singleline_comment|// (for FC Statistics delta)
singleline_comment|// give our HBA time to initialize and login current devices...
(brace
singleline_comment|// The Brocade switch (e.g. 2400, 2010, etc.) as of March 2000,
singleline_comment|// has the following algorithm for FL_Port startup:
singleline_comment|// Time(sec) Action
singleline_comment|// 0:        Device Plugin and LIP(F7,F7) transmission
singleline_comment|// 1.0       LIP incoming
singleline_comment|// 1.027     LISA incoming, no CLS! (link not up)
singleline_comment|// 1.028     NOS incoming (switch test for N_Port)
singleline_comment|// 1.577     ED_TOV expired, transmit LIPs again&t;
singleline_comment|// 3.0       LIP(F8,F7) incoming (switch passes Tach Prim.Sig)
singleline_comment|// 3.028     LILP received, link up, FLOGI starts
singleline_comment|// slowest(worst) case, measured on 1Gb Finisar GT analyzer
r_int
id|wait_time
suffix:semicolon
r_for
c_loop
(paren
id|wait_time
op_assign
id|jiffies
op_plus
l_int|4
op_star
id|HZ
suffix:semicolon
id|wait_time
OG
id|jiffies
suffix:semicolon
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
singleline_comment|// (our worker task needs to run)
)brace
id|NumberOfAdapters
op_increment
suffix:semicolon
)brace
singleline_comment|// end of while()
)brace
id|LEAVE
c_func
(paren
l_string|&quot;cpqfcTS_detect&quot;
)paren
suffix:semicolon
r_return
id|NumberOfAdapters
suffix:semicolon
)brace
DECL|function|my_ioctl_done
r_static
r_void
id|my_ioctl_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
id|req
op_assign
op_amp
id|SCpnt-&gt;request
suffix:semicolon
id|req-&gt;rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
multiline_comment|/* Busy, but indicate request done */
r_if
c_cond
(paren
id|req-&gt;sem
op_ne
l_int|NULL
)paren
(brace
id|up
c_func
(paren
id|req-&gt;sem
)paren
suffix:semicolon
)brace
)brace
DECL|function|cpqfcTS_ioctl
r_int
id|cpqfcTS_ioctl
c_func
(paren
id|Scsi_Device
op_star
id|ScsiDev
comma
r_int
id|Cmnd
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|HostAdapter
op_assign
id|ScsiDev-&gt;host
suffix:semicolon
id|CPQFCHBA
op_star
id|cpqfcHBAdata
op_assign
(paren
id|CPQFCHBA
op_star
)paren
id|HostAdapter-&gt;hostdata
suffix:semicolon
id|PTACHYON
id|fcChip
op_assign
op_amp
id|cpqfcHBAdata-&gt;fcChip
suffix:semicolon
id|PFC_LOGGEDIN_PORT
id|pLoggedInPort
suffix:semicolon
id|Scsi_Cmnd
id|DumCmnd
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|VENDOR_IOCTL_REQ
id|ioc
suffix:semicolon
id|cpqfc_passthru_t
op_star
id|vendor_cmd
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|Scsi_Cmnd
op_star
id|ScsiPassThruCmnd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ENTER
c_func
(paren
l_string|&quot;cpqfcTS_ioctl&quot;
)paren
suffix:semicolon
singleline_comment|// can we find an FC device mapping to this SCSI target?
id|DumCmnd.channel
op_assign
id|ScsiDev-&gt;channel
suffix:semicolon
singleline_comment|// For searching
id|DumCmnd.target
op_assign
id|ScsiDev-&gt;id
suffix:semicolon
id|pLoggedInPort
op_assign
id|fcFindLoggedInPort
c_func
(paren
id|fcChip
comma
op_amp
id|DumCmnd
comma
singleline_comment|// search Scsi Nexus
l_int|0
comma
singleline_comment|// DON&squot;T search linked list for FC port id
l_int|NULL
comma
singleline_comment|// DON&squot;T search linked list for FC WWN
l_int|NULL
)paren
suffix:semicolon
singleline_comment|// DON&squot;T care about end of list
r_if
c_cond
(paren
id|pLoggedInPort
op_eq
l_int|NULL
)paren
singleline_comment|// not found!
(brace
id|result
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
r_else
singleline_comment|// we know what FC device to operate on...
(brace
r_switch
c_cond
(paren
id|Cmnd
)paren
(brace
singleline_comment|// Passthrough provides a mechanism to bypass the RAID
singleline_comment|// or other controller and talk directly to the devices
singleline_comment|// (e.g. physical disk drive)
singleline_comment|// Passthrough commands, unfortunately, tend to be vendor
singleline_comment|// specific; this is tailored to COMPAQ&squot;s RAID (RA4x00)
r_case
id|CPQFCTS_SCSI_PASSTHRU
suffix:colon
(brace
r_void
op_star
id|buf
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// for kernel space buffer for user data
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
singleline_comment|// must be super user to send stuff directly to the
singleline_comment|// controller and/or physical drives...
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
singleline_comment|// copy the caller&squot;s struct to our space.
id|copy_from_user_ret
c_func
(paren
op_amp
id|ioc
comma
id|arg
comma
r_sizeof
(paren
id|VENDOR_IOCTL_REQ
)paren
comma
op_minus
id|EFAULT
)paren
suffix:semicolon
id|vendor_cmd
op_assign
id|ioc.argp
suffix:semicolon
singleline_comment|// i.e., CPQ specific command struct
singleline_comment|// If necessary, grab a kernel/DMA buffer
r_if
c_cond
(paren
id|vendor_cmd-&gt;len
)paren
(brace
id|buf
op_assign
id|kmalloc
c_func
(paren
id|vendor_cmd-&gt;len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
singleline_comment|// Now build a SCSI_CMND to pass down...
singleline_comment|// This function allocates and sets Scsi_Cmnd ptrs such as
singleline_comment|//  -&gt;channel, -&gt;target, -&gt;host
id|ScsiPassThruCmnd
op_assign
id|scsi_allocate_device
c_func
(paren
l_int|NULL
comma
id|ScsiDev
comma
l_int|1
)paren
suffix:semicolon
singleline_comment|// Need data from user?
singleline_comment|// make sure caller&squot;s buffer is in kernel space.
r_if
c_cond
(paren
(paren
id|vendor_cmd-&gt;rw_flag
op_eq
id|VENDOR_WRITE_OPCODE
)paren
op_logical_and
id|vendor_cmd-&gt;len
)paren
(brace
id|copy_from_user_ret
c_func
(paren
id|buf
comma
id|vendor_cmd-&gt;bufp
comma
id|vendor_cmd-&gt;len
comma
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
singleline_comment|// copy the CDB (if/when MAX_COMMAND_SIZE is 16, remove copy below)
id|memcpy
c_func
(paren
op_amp
id|ScsiPassThruCmnd-&gt;cmnd
(braket
l_int|0
)braket
comma
op_amp
id|vendor_cmd-&gt;cdb
(braket
l_int|0
)braket
comma
id|MAX_COMMAND_SIZE
)paren
suffix:semicolon
singleline_comment|// we want to copy all 16 bytes into the FCP-SCSI CDB,
singleline_comment|// although the actual passthru only uses up to the
singleline_comment|// first 12.
id|ScsiPassThruCmnd-&gt;cmd_len
op_assign
l_int|16
suffix:semicolon
singleline_comment|// sizeof FCP-SCSI CDB
singleline_comment|// Unfortunately, the SCSI command cmnd[] field has only
singleline_comment|// 12 bytes.  Ideally the MAX_COMMAND_SIZE should be increased
singleline_comment|// to 16 for newer Fibre Channel and SCSI-3 larger CDBs.
singleline_comment|// However, to avoid a mandatory kernel rebuild, we use the SCp
singleline_comment|// spare field to store the extra 4 bytes ( ugly :-(
r_if
c_cond
(paren
id|MAX_COMMAND_SIZE
OL
l_int|16
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|ScsiPassThruCmnd-&gt;SCp.buffers_residual
comma
op_amp
id|vendor_cmd-&gt;cdb
(braket
l_int|12
)braket
comma
l_int|4
)paren
suffix:semicolon
)brace
id|ScsiPassThruCmnd-&gt;SCp.sent_command
op_assign
l_int|1
suffix:semicolon
singleline_comment|// PASSTHRU!
singleline_comment|// suppress LUN masking
singleline_comment|// and VSA logic
singleline_comment|// Use spare fields to copy FCP-SCSI LUN address info...
id|ScsiPassThruCmnd-&gt;SCp.phase
op_assign
id|vendor_cmd-&gt;bus
suffix:semicolon
id|ScsiPassThruCmnd-&gt;SCp.have_data_in
op_assign
id|vendor_cmd-&gt;pdrive
suffix:semicolon
singleline_comment|// We copy the scheme used by scsi.c to submit commands
singleline_comment|// to our own HBA.  We do this in order to stall the
singleline_comment|// thread calling the IOCTL until it completes, and use
singleline_comment|// the same &quot;_quecommand&quot; function for synchronizing
singleline_comment|// FC Link events with our &quot;worker thread&quot;.
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
(brace
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|sem
)paren
suffix:semicolon
id|ScsiPassThruCmnd-&gt;request.sem
op_assign
op_amp
id|sem
suffix:semicolon
singleline_comment|// eventually gets us to our own _quecommand routine
id|scsi_do_cmd
c_func
(paren
id|ScsiPassThruCmnd
comma
op_amp
id|vendor_cmd-&gt;cdb
(braket
l_int|0
)braket
comma
id|buf
comma
id|vendor_cmd-&gt;len
comma
id|my_ioctl_done
comma
l_int|10
op_star
id|HZ
comma
l_int|1
)paren
suffix:semicolon
singleline_comment|// timeout,retries
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// Other I/Os can now resume; we wait for our ioctl
singleline_comment|// command to complete
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|ScsiPassThruCmnd-&gt;request.sem
op_assign
l_int|NULL
suffix:semicolon
)brace
id|result
op_assign
id|ScsiPassThruCmnd-&gt;result
suffix:semicolon
singleline_comment|// copy any sense data back to caller
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|vendor_cmd-&gt;sense_data
comma
singleline_comment|// see struct def - size=40
id|ScsiPassThruCmnd-&gt;sense_buffer
comma
r_sizeof
(paren
id|ScsiPassThruCmnd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
)brace
id|SDpnt
op_assign
id|ScsiPassThruCmnd-&gt;device
suffix:semicolon
id|scsi_release_command
c_func
(paren
id|ScsiPassThruCmnd
)paren
suffix:semicolon
singleline_comment|// &quot;de-allocate&quot;
id|ScsiPassThruCmnd
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SDpnt-&gt;was_reset
op_logical_and
id|SDpnt-&gt;scsi_request_fn
)paren
(paren
op_star
id|SDpnt-&gt;scsi_request_fn
)paren
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|SDpnt-&gt;device_wait
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// need to pass data back to user (space)?
r_if
c_cond
(paren
(paren
id|vendor_cmd-&gt;rw_flag
op_eq
id|VENDOR_READ_OPCODE
)paren
op_logical_and
id|vendor_cmd-&gt;len
)paren
(brace
id|copy_to_user_ret
c_func
(paren
id|vendor_cmd-&gt;bufp
comma
id|buf
comma
id|vendor_cmd-&gt;len
comma
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
)paren
(brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
r_case
id|CPQFCTS_GETPCIINFO
suffix:colon
(brace
id|cpqfc_pci_info_struct
id|pciinfo
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|pciinfo.bus
op_assign
id|cpqfcHBAdata-&gt;PciDev-&gt;bus-&gt;number
suffix:semicolon
id|pciinfo.dev_fn
op_assign
id|cpqfcHBAdata-&gt;PciDev-&gt;devfn
suffix:semicolon
id|pciinfo.board_id
op_assign
id|cpqfcHBAdata-&gt;PciDev-&gt;device
op_or
(paren
id|cpqfcHBAdata-&gt;PciDev-&gt;vendor
op_lshift
l_int|16
)paren
suffix:semicolon
id|copy_to_user_ret
c_func
(paren
id|arg
comma
op_amp
id|pciinfo
comma
r_sizeof
(paren
id|cpqfc_pci_info_struct
)paren
comma
op_minus
id|EFAULT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CPQFCTS_GETDRIVVER
suffix:colon
(brace
id|DriverVer_type
id|DriverVer
op_assign
id|CPQFCTS_DRIVER_VER
c_func
(paren
id|VER_MAJOR
comma
id|VER_MINOR
comma
id|VER_SUBMINOR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|copy_to_user_ret
c_func
(paren
id|arg
comma
op_amp
id|DriverVer
comma
r_sizeof
(paren
id|DriverVer
)paren
comma
op_minus
id|EFAULT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|SCSI_IOCTL_FC_TARGET_ADDRESS
suffix:colon
id|result
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
r_sizeof
(paren
id|Scsi_FCTargAddress
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_break
suffix:semicolon
id|put_user
c_func
(paren
id|pLoggedInPort-&gt;port_id
comma
op_amp
(paren
(paren
id|Scsi_FCTargAddress
op_star
)paren
id|arg
)paren
op_member_access_from_pointer
id|host_port_id
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|3
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
singleline_comment|// copy the LOGIN port&squot;s WWN
id|put_user
c_func
(paren
id|pLoggedInPort-&gt;u.ucWWN
(braket
id|i
)braket
comma
op_amp
(paren
(paren
id|Scsi_FCTargAddress
op_star
)paren
id|arg
)paren
op_member_access_from_pointer
id|host_wwn
(braket
id|j
op_increment
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|7
suffix:semicolon
id|i
OG
l_int|3
suffix:semicolon
id|i
op_decrement
)paren
(brace
singleline_comment|// copy the LOGIN port&squot;s WWN
id|put_user
c_func
(paren
id|pLoggedInPort-&gt;u.ucWWN
(braket
id|i
)braket
comma
op_amp
(paren
(paren
id|Scsi_FCTargAddress
op_star
)paren
id|arg
)paren
op_member_access_from_pointer
id|host_wwn
(braket
id|j
op_increment
)braket
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|result
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|LEAVE
c_func
(paren
l_string|&quot;cpqfcTS_ioctl&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* &quot;Release&quot; the Host Bus Adapter...&n;   disable interrupts, stop the HBA, release the interrupt,&n;   and free all resources */
DECL|function|cpqfcTS_release
r_int
id|cpqfcTS_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|HostAdapter
)paren
(brace
id|CPQFCHBA
op_star
id|cpqfcHBAdata
op_assign
(paren
id|CPQFCHBA
op_star
)paren
id|HostAdapter-&gt;hostdata
suffix:semicolon
id|ENTER
c_func
(paren
l_string|&quot;cpqfcTS_release&quot;
)paren
suffix:semicolon
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot; cpqfcTS: delete timer...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|cpqfcHBAdata-&gt;cpqfcTStimer
)paren
suffix:semicolon
singleline_comment|// disable the hardware...
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot; disable hardware, destroy queues, free mem&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|cpqfcHBAdata-&gt;fcChip
dot
id|ResetTachyon
c_func
(paren
id|cpqfcHBAdata
comma
id|CLEAR_FCPORTS
)paren
suffix:semicolon
singleline_comment|// kill kernel thread
r_if
c_cond
(paren
id|cpqfcHBAdata-&gt;worker_thread
)paren
singleline_comment|// (only if exists)
(brace
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|sem
)paren
suffix:semicolon
singleline_comment|// synchronize thread kill
id|cpqfcHBAdata-&gt;notify_wt
op_assign
op_amp
id|sem
suffix:semicolon
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot; killing kernel thread&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|cpqfcHBAdata-&gt;worker_thread
comma
l_int|1
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|cpqfcHBAdata-&gt;notify_wt
op_assign
l_int|NULL
suffix:semicolon
)brace
singleline_comment|// free Linux resources
id|DEBUG_PCI
c_func
(paren
id|printk
c_func
(paren
l_string|&quot; cpqfcTS: freeing resources...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|HostAdapter-&gt;irq
comma
id|HostAdapter
)paren
suffix:semicolon
id|scsi_unregister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|cpqfcHBAdata-&gt;fcChip.Registers.IOBaseL
comma
l_int|0xff
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|cpqfcHBAdata-&gt;fcChip.Registers.IOBaseU
comma
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* we get &quot;vfree: bad address&quot; executing this - need to investigate... &n;  if( (void*)((unsigned long)cpqfcHBAdata-&gt;fcChip.Registers.MemBase) !=&n;      cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase)&n;    vfree( cpqfcHBAdata-&gt;fcChip.Registers.ReMapMemBase);&n;*/
id|LEAVE
c_func
(paren
l_string|&quot;cpqfcTS_release&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cpqfcTS_info
r_const
r_char
op_star
id|cpqfcTS_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|HostAdapter
)paren
(brace
r_static
r_char
id|buf
(braket
l_int|300
)braket
suffix:semicolon
id|CPQFCHBA
op_star
id|cpqfcHBA
suffix:semicolon
r_int
id|BusSpeed
comma
id|BusWidth
suffix:semicolon
singleline_comment|// get the pointer to our Scsi layer HBA buffer  
id|cpqfcHBA
op_assign
(paren
id|CPQFCHBA
op_star
)paren
id|HostAdapter-&gt;hostdata
suffix:semicolon
id|BusWidth
op_assign
(paren
id|cpqfcHBA-&gt;fcChip.Registers.PCIMCTR
op_amp
l_int|0x4
)paren
OG
l_int|0
ques
c_cond
l_int|64
suffix:colon
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|cpqfcHBA-&gt;fcChip.Registers.TYconfig.value
op_amp
l_int|0x80000000
)paren
(brace
id|BusSpeed
op_assign
l_int|66
suffix:semicolon
)brace
r_else
id|BusSpeed
op_assign
l_int|33
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s: WWN %08X%08X&bslash;n on PCI bus %d device 0x%02x irq %d IObaseL 0x%x, MEMBASE 0x%x&bslash;nPCI bus width %d bits, bus speed %d MHz&bslash;nFCP-SCSI Driver v%d.%d.%d&quot;
comma
id|cpqfcHBA-&gt;fcChip.Name
comma
id|cpqfcHBA-&gt;fcChip.Registers.wwn_hi
comma
id|cpqfcHBA-&gt;fcChip.Registers.wwn_lo
comma
id|cpqfcHBA-&gt;PciDev-&gt;bus-&gt;number
comma
id|cpqfcHBA-&gt;PciDev-&gt;device
comma
id|HostAdapter-&gt;irq
comma
id|cpqfcHBA-&gt;fcChip.Registers.IOBaseL
comma
id|cpqfcHBA-&gt;fcChip.Registers.MemBase
comma
id|BusWidth
comma
id|BusSpeed
comma
id|VER_MAJOR
comma
id|VER_MINOR
comma
id|VER_SUBMINOR
)paren
suffix:semicolon
id|cpqfcTSDecodeGBICtype
c_func
(paren
op_amp
id|cpqfcHBA-&gt;fcChip
comma
op_amp
id|buf
(braket
id|strlen
c_func
(paren
id|buf
)paren
)braket
)paren
suffix:semicolon
id|cpqfcTSGetLPSM
c_func
(paren
op_amp
id|cpqfcHBA-&gt;fcChip
comma
op_amp
id|buf
(braket
id|strlen
c_func
(paren
id|buf
)paren
)braket
)paren
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// /proc/scsi support. The following routines allow us to do &squot;normal&squot;
singleline_comment|// sprintf like calls to return the currently requested piece (buflenght
singleline_comment|// chars, starting at bufoffset) of the file. Although procfs allows for
singleline_comment|// a 1 Kb bytes overflow after te supplied buffer, I consider it bad 
singleline_comment|// programming to use it to make programming a little simpler. This piece
singleline_comment|// of coding is borrowed from ncr53c8xx.c with some modifications 
singleline_comment|//
DECL|struct|info_str
r_struct
id|info_str
(brace
DECL|member|buffer
r_char
op_star
id|buffer
suffix:semicolon
singleline_comment|// Pointer to output buffer
DECL|member|buflength
r_int
id|buflength
suffix:semicolon
singleline_comment|// It&squot;s length
DECL|member|bufoffset
r_int
id|bufoffset
suffix:semicolon
singleline_comment|// File offset corresponding with buf[0]
DECL|member|buffillen
r_int
id|buffillen
suffix:semicolon
singleline_comment|// Current filled length 
DECL|member|filpos
r_int
id|filpos
suffix:semicolon
singleline_comment|// Current file offset
)brace
suffix:semicolon
DECL|function|copy_mem_info
r_static
r_void
id|copy_mem_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|data
comma
r_int
id|datalen
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;filpos
OL
id|info-&gt;bufoffset
)paren
(brace
singleline_comment|// Current offset before buffer offset
r_if
c_cond
(paren
id|info-&gt;filpos
op_plus
id|datalen
op_le
id|info-&gt;bufoffset
)paren
(brace
id|info-&gt;filpos
op_add_assign
id|datalen
suffix:semicolon
singleline_comment|// Discard if completely before buffer
r_return
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// Partial copy, set to begin
id|data
op_add_assign
(paren
id|info-&gt;bufoffset
op_minus
id|info-&gt;filpos
)paren
suffix:semicolon
id|datalen
op_sub_assign
(paren
id|info-&gt;bufoffset
op_minus
id|info-&gt;filpos
)paren
suffix:semicolon
id|info-&gt;filpos
op_assign
id|info-&gt;bufoffset
suffix:semicolon
)brace
)brace
id|info-&gt;filpos
op_add_assign
id|datalen
suffix:semicolon
singleline_comment|// Update current offset
r_if
c_cond
(paren
id|info-&gt;buffillen
op_eq
id|info-&gt;buflength
)paren
singleline_comment|// Buffer full, discard
r_return
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;buflength
op_minus
id|info-&gt;buffillen
OL
id|datalen
)paren
singleline_comment|// Overflows buffer ?
id|datalen
op_assign
id|info-&gt;buflength
op_minus
id|info-&gt;buffillen
suffix:semicolon
id|memcpy
c_func
(paren
id|info-&gt;buffer
op_plus
id|info-&gt;buffillen
comma
id|data
comma
id|datalen
)paren
suffix:semicolon
id|info-&gt;buffillen
op_add_assign
id|datalen
suffix:semicolon
)brace
DECL|function|copy_info
r_static
r_int
id|copy_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
l_int|400
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|len
op_assign
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
id|copy_mem_info
c_func
(paren
id|info
comma
id|buf
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
singleline_comment|// Routine to get data for /proc RAM filesystem
singleline_comment|//
DECL|function|cpqfcTS_proc_info
r_int
id|cpqfcTS_proc_info
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|Scsi_Cmnd
id|DumCmnd
suffix:semicolon
r_int
id|Chan
comma
id|Targ
comma
id|i
suffix:semicolon
r_struct
id|info_str
id|info
suffix:semicolon
id|CPQFCHBA
op_star
id|cpqfcHBA
suffix:semicolon
id|PTACHYON
id|fcChip
suffix:semicolon
id|PFC_LOGGEDIN_PORT
id|pLoggedInPort
suffix:semicolon
r_char
id|buf
(braket
l_int|81
)braket
suffix:semicolon
singleline_comment|// Search the Scsi host list for our controller
r_for
c_loop
(paren
id|host
op_assign
id|scsi_hostlist
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
r_if
c_cond
(paren
id|host-&gt;host_no
op_eq
id|hostno
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
r_return
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
id|inout
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
singleline_comment|// get the pointer to our Scsi layer HBA buffer  
id|cpqfcHBA
op_assign
(paren
id|CPQFCHBA
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|fcChip
op_assign
op_amp
id|cpqfcHBA-&gt;fcChip
suffix:semicolon
op_star
id|start
op_assign
id|buffer
suffix:semicolon
id|info.buffer
op_assign
id|buffer
suffix:semicolon
id|info.buflength
op_assign
id|length
suffix:semicolon
id|info.bufoffset
op_assign
id|offset
suffix:semicolon
id|info.filpos
op_assign
l_int|0
suffix:semicolon
id|info.buffillen
op_assign
l_int|0
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Driver version = %d.%d.%d&quot;
comma
id|VER_MAJOR
comma
id|VER_MINOR
comma
id|VER_SUBMINOR
)paren
suffix:semicolon
id|cpqfcTSDecodeGBICtype
c_func
(paren
op_amp
id|cpqfcHBA-&gt;fcChip
comma
op_amp
id|buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|cpqfcTSGetLPSM
c_func
(paren
op_amp
id|cpqfcHBA-&gt;fcChip
comma
op_amp
id|buf
(braket
id|strlen
c_func
(paren
id|buf
)paren
)braket
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
DECL|macro|DISPLAY_WWN_INFO
mdefine_line|#define DISPLAY_WWN_INFO
macro_line|#ifdef DISPLAY_WWN_INFO
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;WWN database: (&bslash;&quot;port_id: 000000&bslash;&quot; means disconnected)&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|Chan
op_assign
l_int|0
suffix:semicolon
id|Chan
op_le
id|host-&gt;max_channel
suffix:semicolon
id|Chan
op_increment
)paren
(brace
id|DumCmnd.channel
op_assign
id|Chan
suffix:semicolon
r_for
c_loop
(paren
id|Targ
op_assign
l_int|0
suffix:semicolon
id|Targ
op_le
id|host-&gt;max_id
suffix:semicolon
id|Targ
op_increment
)paren
(brace
id|DumCmnd.target
op_assign
id|Targ
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pLoggedInPort
op_assign
id|fcFindLoggedInPort
c_func
(paren
id|fcChip
comma
op_amp
id|DumCmnd
comma
singleline_comment|// search Scsi Nexus
l_int|0
comma
singleline_comment|// DON&squot;T search list for FC port id
l_int|NULL
comma
singleline_comment|// DON&squot;T search list for FC WWN
l_int|NULL
)paren
)paren
)paren
(brace
singleline_comment|// DON&squot;T care about end of list
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Host: scsi%d Channel: %02d TargetId: %02d -&gt; WWN: &quot;
comma
id|hostno
comma
id|Chan
comma
id|Targ
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
singleline_comment|// copy the LOGIN port&squot;s WWN
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;%02X&quot;
comma
id|pLoggedInPort-&gt;u.ucWWN
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|7
suffix:semicolon
id|i
OG
l_int|3
suffix:semicolon
id|i
op_decrement
)paren
(brace
singleline_comment|// copy the LOGIN port&squot;s WWN
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;%02X&quot;
comma
id|pLoggedInPort-&gt;u.ucWWN
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot; port_id: %06X&bslash;n&quot;
comma
id|pLoggedInPort-&gt;port_id
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
singleline_comment|// Unfortunately, the proc_info buffer isn&squot;t big enough
singleline_comment|// for everything we would like...
singleline_comment|// For FC stats, compile this and turn off WWN stuff above  
singleline_comment|//#define DISPLAY_FC_STATS
macro_line|#ifdef DISPLAY_FC_STATS
singleline_comment|// get the Fibre Channel statistics
(brace
r_int
id|DeltaSecs
op_assign
(paren
id|jiffies
op_minus
id|cpqfcHBA-&gt;fcStatsTime
)paren
op_div
id|HZ
suffix:semicolon
r_int
id|days
comma
id|hours
comma
id|minutes
comma
id|secs
suffix:semicolon
id|days
op_assign
id|DeltaSecs
op_div
(paren
l_int|3600
op_star
l_int|24
)paren
suffix:semicolon
singleline_comment|// days
id|hours
op_assign
(paren
id|DeltaSecs
op_mod
(paren
l_int|3600
op_star
l_int|24
)paren
)paren
op_div
l_int|3600
suffix:semicolon
singleline_comment|// hours
id|minutes
op_assign
(paren
id|DeltaSecs
op_mod
l_int|3600
op_div
l_int|60
)paren
suffix:semicolon
singleline_comment|// minutes
id|secs
op_assign
id|DeltaSecs
op_mod
l_int|60
suffix:semicolon
singleline_comment|// secs
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Fibre Channel Stats (time dd:hh:mm:ss %02u:%02u:%02u:%02u&bslash;n&quot;
comma
id|days
comma
id|hours
comma
id|minutes
comma
id|secs
)paren
suffix:semicolon
)brace
id|cpqfcHBA-&gt;fcStatsTime
op_assign
id|jiffies
suffix:semicolon
singleline_comment|// (for next delta)
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  LinkUp           %9u     LinkDown      %u&bslash;n&quot;
comma
id|fcChip-&gt;fcStats.linkUp
comma
id|fcChip-&gt;fcStats.linkDown
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Loss of Signal   %9u     Loss of Sync  %u&bslash;n&quot;
comma
id|fcChip-&gt;fcStats.LossofSignal
comma
id|fcChip-&gt;fcStats.LossofSync
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Discarded Frames %9u     Bad CRC Frame %u&bslash;n&quot;
comma
id|fcChip-&gt;fcStats.Dis_Frm
comma
id|fcChip-&gt;fcStats.Bad_CRC
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  TACH LinkFailTX  %9u     TACH LinkFailRX     %u&bslash;n&quot;
comma
id|fcChip-&gt;fcStats.linkFailTX
comma
id|fcChip-&gt;fcStats.linkFailRX
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  TACH RxEOFa      %9u     TACH Elastic Store  %u&bslash;n&quot;
comma
id|fcChip-&gt;fcStats.Rx_EOFa
comma
id|fcChip-&gt;fcStats.e_stores
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  BufferCreditWait %9uus   TACH FM Inits %u&bslash;n&quot;
comma
id|fcChip-&gt;fcStats.BB0_Timer
op_star
l_int|10
comma
id|fcChip-&gt;fcStats.FMinits
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  FC-2 Timeouts    %9u     FC-2 Logouts  %u&bslash;n&quot;
comma
id|fcChip-&gt;fcStats.timeouts
comma
id|fcChip-&gt;fcStats.logouts
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  FC-2 Aborts      %9u     FC-4 Aborts   %u&bslash;n&quot;
comma
id|fcChip-&gt;fcStats.FC2aborted
comma
id|fcChip-&gt;fcStats.FC4aborted
)paren
suffix:semicolon
singleline_comment|// clear the counters
id|cpqfcTSClearLinkStatusCounters
c_func
(paren
id|fcChip
)paren
suffix:semicolon
macro_line|#endif
r_return
id|info.buffillen
suffix:semicolon
)brace
macro_line|#if DEBUG_CMND
DECL|function|ScsiToAscii
id|UCHAR
op_star
id|ScsiToAscii
c_func
(paren
id|UCHAR
id|ScsiCommand
)paren
(brace
multiline_comment|/*++&n;&n;Routine Description:&n;&n;   Converts a SCSI command to a text string for debugging purposes.&n;&n;&n;Arguments:&n;&n;   ScsiCommand -- hex value SCSI Command&n;&n;&n;Return Value:&n;&n;   An ASCII, null-terminated string if found, else returns NULL.&n;&n;Original code from M. McGowen, Compaq&n;--*/
r_switch
c_cond
(paren
id|ScsiCommand
)paren
(brace
r_case
l_int|0x00
suffix:colon
r_return
l_string|&quot;Test Unit Ready&quot;
suffix:semicolon
r_case
l_int|0x01
suffix:colon
r_return
l_string|&quot;Rezero Unit or Rewind&quot;
suffix:semicolon
r_case
l_int|0x02
suffix:colon
r_return
l_string|&quot;Request Block Address&quot;
suffix:semicolon
r_case
l_int|0x03
suffix:colon
r_return
l_string|&quot;Requese Sense&quot;
suffix:semicolon
r_case
l_int|0x04
suffix:colon
r_return
l_string|&quot;Format Unit&quot;
suffix:semicolon
r_case
l_int|0x05
suffix:colon
r_return
l_string|&quot;Read Block Limits&quot;
suffix:semicolon
r_case
l_int|0x07
suffix:colon
r_return
l_string|&quot;Reassign Blocks&quot;
suffix:semicolon
r_case
l_int|0x08
suffix:colon
r_return
l_string|&quot;Read (6)&quot;
suffix:semicolon
r_case
l_int|0x0a
suffix:colon
r_return
l_string|&quot;Write (6)&quot;
suffix:semicolon
r_case
l_int|0x0b
suffix:colon
r_return
l_string|&quot;Seek (6)&quot;
suffix:semicolon
r_case
l_int|0x12
suffix:colon
r_return
l_string|&quot;Inquiry&quot;
suffix:semicolon
r_case
l_int|0x15
suffix:colon
r_return
l_string|&quot;Mode Select (6)&quot;
suffix:semicolon
r_case
l_int|0x16
suffix:colon
r_return
l_string|&quot;Reserve&quot;
suffix:semicolon
r_case
l_int|0x17
suffix:colon
r_return
l_string|&quot;Release&quot;
suffix:semicolon
r_case
l_int|0x1a
suffix:colon
r_return
l_string|&quot;ModeSen(6)&quot;
suffix:semicolon
r_case
l_int|0x1b
suffix:colon
r_return
l_string|&quot;Start/Stop Unit&quot;
suffix:semicolon
r_case
l_int|0x1c
suffix:colon
r_return
l_string|&quot;Receive Diagnostic Results&quot;
suffix:semicolon
r_case
l_int|0x1d
suffix:colon
r_return
l_string|&quot;Send Diagnostic&quot;
suffix:semicolon
r_case
l_int|0x25
suffix:colon
r_return
l_string|&quot;Read Capacity&quot;
suffix:semicolon
r_case
l_int|0x28
suffix:colon
r_return
l_string|&quot;Read (10)&quot;
suffix:semicolon
r_case
l_int|0x2a
suffix:colon
r_return
l_string|&quot;Write (10)&quot;
suffix:semicolon
r_case
l_int|0x2b
suffix:colon
r_return
l_string|&quot;Seek (10)&quot;
suffix:semicolon
r_case
l_int|0x2e
suffix:colon
r_return
l_string|&quot;Write and Verify&quot;
suffix:semicolon
r_case
l_int|0x2f
suffix:colon
r_return
l_string|&quot;Verify&quot;
suffix:semicolon
r_case
l_int|0x34
suffix:colon
r_return
l_string|&quot;Pre-Fetch&quot;
suffix:semicolon
r_case
l_int|0x35
suffix:colon
r_return
l_string|&quot;Synchronize Cache&quot;
suffix:semicolon
r_case
l_int|0x37
suffix:colon
r_return
l_string|&quot;Read Defect Data (10)&quot;
suffix:semicolon
r_case
l_int|0x3b
suffix:colon
r_return
l_string|&quot;Write Buffer&quot;
suffix:semicolon
r_case
l_int|0x3c
suffix:colon
r_return
l_string|&quot;Read Buffer&quot;
suffix:semicolon
r_case
l_int|0x3e
suffix:colon
r_return
l_string|&quot;Read Long&quot;
suffix:semicolon
r_case
l_int|0x3f
suffix:colon
r_return
l_string|&quot;Write Long&quot;
suffix:semicolon
r_case
l_int|0x41
suffix:colon
r_return
l_string|&quot;Write Same&quot;
suffix:semicolon
r_case
l_int|0x4c
suffix:colon
r_return
l_string|&quot;Log Select&quot;
suffix:semicolon
r_case
l_int|0x4d
suffix:colon
r_return
l_string|&quot;Log Sense&quot;
suffix:semicolon
r_case
l_int|0x56
suffix:colon
r_return
l_string|&quot;Reserve (10)&quot;
suffix:semicolon
r_case
l_int|0x57
suffix:colon
r_return
l_string|&quot;Release (10)&quot;
suffix:semicolon
r_case
l_int|0xa0
suffix:colon
r_return
l_string|&quot;ReportLuns&quot;
suffix:semicolon
r_case
l_int|0xb7
suffix:colon
r_return
l_string|&quot;Read Defect Data (12)&quot;
suffix:semicolon
r_case
l_int|0xca
suffix:colon
r_return
l_string|&quot;Peripheral Device Addressing SCSI Passthrough&quot;
suffix:semicolon
r_case
l_int|0xcb
suffix:colon
r_return
l_string|&quot;Compaq Array Firmware Passthrough&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
singleline_comment|// end ScsiToAscii()
DECL|function|cpqfcTS_print_scsi_cmd
r_void
id|cpqfcTS_print_scsi_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cpqfcTS: (%s) chnl 0x%02x, trgt = 0x%02x, lun = 0x%02x, cmd_len = 0x%02x&bslash;n&quot;
comma
id|ScsiToAscii
c_func
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
comma
id|cmd-&gt;channel
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
singleline_comment|// Test Unit Ready?
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Cmnd-&gt;request_bufflen = 0x%X, -&gt;use_sg = %d, -&gt;bufflen = %d&bslash;n&quot;
comma
id|cmd-&gt;request_bufflen
comma
id|cmd-&gt;use_sg
comma
id|cmd-&gt;bufflen
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Cmnd-&gt;request_buffer = %p, -&gt;sglist_len = %d, -&gt;buffer = %p&bslash;n&quot;
comma
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;sglist_len
comma
id|cmd-&gt;buffer
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;0x%02x &quot;
comma
id|cmd-&gt;cmnd
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;&t;&t;&t;/* DEBUG_CMND */
DECL|function|QueCmndOnBoardLock
r_static
r_void
id|QueCmndOnBoardLock
c_func
(paren
id|CPQFCHBA
op_star
id|cpqfcHBAdata
comma
id|Scsi_Cmnd
op_star
id|Cmnd
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CPQFCTS_REQ_QUEUE_LEN
suffix:semicolon
id|i
op_increment
)paren
(brace
singleline_comment|// find spare slot
r_if
c_cond
(paren
id|cpqfcHBAdata-&gt;BoardLockCmnd
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
id|cpqfcHBAdata-&gt;BoardLockCmnd
(braket
id|i
)braket
op_assign
id|Cmnd
suffix:semicolon
singleline_comment|//      printk(&quot; BoardLockCmnd[%d] %p Queued, chnl/target/lun %d/%d/%d&bslash;n&quot;,
singleline_comment|//        i,Cmnd, Cmnd-&gt;channel, Cmnd-&gt;target, Cmnd-&gt;lun);
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_ge
id|CPQFCTS_REQ_QUEUE_LEN
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; cpqfcTS WARNING: Lost Cmnd %p on BoardLock Q full!&quot;
comma
id|Cmnd
)paren
suffix:semicolon
)brace
)brace
DECL|function|QueLinkDownCmnd
r_static
r_void
id|QueLinkDownCmnd
c_func
(paren
id|CPQFCHBA
op_star
id|cpqfcHBAdata
comma
id|Scsi_Cmnd
op_star
id|Cmnd
)paren
(brace
r_int
id|indx
suffix:semicolon
singleline_comment|// Remember the command ptr so we can return; we&squot;ll complete when
singleline_comment|// the device comes back, causing immediate retry
r_for
c_loop
(paren
id|indx
op_assign
l_int|0
suffix:semicolon
id|indx
OL
id|CPQFCTS_REQ_QUEUE_LEN
suffix:semicolon
id|indx
op_increment
)paren
singleline_comment|//, SCptr++)
(brace
r_if
c_cond
(paren
id|cpqfcHBAdata-&gt;LinkDnCmnd
(braket
id|indx
)braket
op_eq
l_int|NULL
)paren
singleline_comment|// available?
(brace
macro_line|#ifdef DUMMYCMND_DBG
id|printk
c_func
(paren
l_string|&quot; @add Cmnd %p to LnkDnCmnd[%d]@ &quot;
comma
id|Cmnd
comma
id|indx
)paren
suffix:semicolon
macro_line|#endif
id|cpqfcHBAdata-&gt;LinkDnCmnd
(braket
id|indx
)braket
op_assign
id|Cmnd
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|indx
op_ge
id|CPQFCTS_REQ_QUEUE_LEN
)paren
singleline_comment|// no space for Cmnd??
(brace
singleline_comment|// this will result in an _abort call later (with possible trouble)
id|printk
c_func
(paren
l_string|&quot;no buffer for LinkDnCmnd!! %p&bslash;n&quot;
comma
id|Cmnd
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// The file &quot;hosts.h&quot; says not to call scsi_done from
singleline_comment|// inside _queuecommand, so we&squot;ll do it from the heartbeat timer
DECL|function|QueBadTargetCmnd
r_static
r_void
id|QueBadTargetCmnd
c_func
(paren
id|CPQFCHBA
op_star
id|cpqfcHBAdata
comma
id|Scsi_Cmnd
op_star
id|Cmnd
)paren
(brace
r_int
id|i
suffix:semicolon
singleline_comment|//    printk(&quot; can&squot;t find target %d&bslash;n&quot;, Cmnd-&gt;target);
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CPQFCTS_MAX_TARGET_ID
suffix:semicolon
id|i
op_increment
)paren
(brace
singleline_comment|// find spare slot
r_if
c_cond
(paren
id|cpqfcHBAdata-&gt;BadTargetCmnd
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
id|cpqfcHBAdata-&gt;BadTargetCmnd
(braket
id|i
)braket
op_assign
id|Cmnd
suffix:semicolon
singleline_comment|//      printk(&quot; BadTargetCmnd[%d] %p Queued, chnl/target/lun %d/%d/%d&bslash;n&quot;,
singleline_comment|//          i,Cmnd, Cmnd-&gt;channel, Cmnd-&gt;target, Cmnd-&gt;lun);
r_break
suffix:semicolon
)brace
)brace
)brace
singleline_comment|// This is the &quot;main&quot; entry point for Linux Scsi commands --
singleline_comment|// it all starts here.
DECL|function|cpqfcTS_queuecommand
r_int
id|cpqfcTS_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|Cmnd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|HostAdapter
op_assign
id|Cmnd-&gt;host
suffix:semicolon
id|CPQFCHBA
op_star
id|cpqfcHBAdata
op_assign
(paren
id|CPQFCHBA
op_star
)paren
id|HostAdapter-&gt;hostdata
suffix:semicolon
id|PTACHYON
id|fcChip
op_assign
op_amp
id|cpqfcHBAdata-&gt;fcChip
suffix:semicolon
id|TachFCHDR_GCMND
id|fchs
suffix:semicolon
singleline_comment|// only use for FC destination id field  
id|PFC_LOGGEDIN_PORT
id|pLoggedInPort
suffix:semicolon
id|ULONG
id|ulStatus
comma
id|SESTtype
suffix:semicolon
id|LONG
id|ExchangeID
suffix:semicolon
id|ENTER
c_func
(paren
l_string|&quot;cpqfcTS_queuecommand&quot;
)paren
suffix:semicolon
id|PCI_TRACEO
c_func
(paren
(paren
id|ULONG
)paren
id|Cmnd
comma
l_int|0x98
)paren
id|Cmnd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
macro_line|#ifdef DEBUG_CMND  
id|cpqfcTS_print_scsi_cmd
c_func
(paren
id|Cmnd
)paren
suffix:semicolon
macro_line|#endif
singleline_comment|// prevent board contention with kernel thread...  
r_if
c_cond
(paren
id|cpqfcHBAdata-&gt;BoardLock
)paren
(brace
singleline_comment|//    printk(&quot; @BrdLck Hld@ &quot;);
id|QueCmndOnBoardLock
c_func
(paren
id|cpqfcHBAdata
comma
id|Cmnd
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// in the current system (2.2.12), this routine is called
singleline_comment|// after spin_lock_irqsave(), so INTs are disabled. However,
singleline_comment|// we might have something pending in the LinkQ, which
singleline_comment|// might cause the WorkerTask to run.  In case that
singleline_comment|// happens, make sure we lock it out.
id|PCI_TRACE
c_func
(paren
l_int|0x98
)paren
id|CPQ_SPINLOCK_HBA
c_func
(paren
id|cpqfcHBAdata
)paren
id|PCI_TRACE
c_func
(paren
l_int|0x98
)paren
singleline_comment|// can we find an FC device mapping to this SCSI target?
id|pLoggedInPort
op_assign
id|fcFindLoggedInPort
c_func
(paren
id|fcChip
comma
id|Cmnd
comma
singleline_comment|// search Scsi Nexus
l_int|0
comma
singleline_comment|// DON&squot;T search linked list for FC port id
l_int|NULL
comma
singleline_comment|// DON&squot;T search linked list for FC WWN
l_int|NULL
)paren
suffix:semicolon
singleline_comment|// DON&squot;T care about end of list
r_if
c_cond
(paren
id|pLoggedInPort
op_eq
l_int|NULL
)paren
singleline_comment|// not found!
(brace
singleline_comment|//    printk(&quot; @Q bad targ cmnd %p@ &quot;, Cmnd);
id|QueBadTargetCmnd
c_func
(paren
id|cpqfcHBAdata
comma
id|Cmnd
)paren
suffix:semicolon
)brace
r_else
singleline_comment|// we know what FC device to send to...
(brace
singleline_comment|// does this device support FCP target functions?
singleline_comment|// (determined by PRLI field)
r_if
c_cond
(paren
op_logical_neg
(paren
id|pLoggedInPort-&gt;fcp_info
op_amp
id|TARGET_FUNCTION
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; Doesn&squot;t support TARGET functions port_id %Xh&bslash;n&quot;
comma
id|pLoggedInPort-&gt;port_id
)paren
suffix:semicolon
id|QueBadTargetCmnd
c_func
(paren
id|cpqfcHBAdata
comma
id|Cmnd
)paren
suffix:semicolon
)brace
singleline_comment|// In this case (previous login OK), the device is temporarily
singleline_comment|// unavailable waiting for re-login, in which case we expect it
singleline_comment|// to be back in between 25 - 500ms.  
singleline_comment|// If the FC port doesn&squot;t log back in within several seconds
singleline_comment|// (i.e. implicit &quot;logout&quot;), or we get an explicit logout,
singleline_comment|// we set &quot;device_blocked&quot; in Scsi_Device struct; in this
singleline_comment|// case 30 seconds will elapse before Linux/Scsi sends another
singleline_comment|// command to the device.
r_else
r_if
c_cond
(paren
id|pLoggedInPort-&gt;prli
op_ne
id|TRUE
)paren
(brace
singleline_comment|//      printk(&quot;Device (Chnl/Target %d/%d) invalid PRLI, port_id %06lXh&bslash;n&quot;,
singleline_comment|//        Cmnd-&gt;channel, Cmnd-&gt;target, pLoggedInPort-&gt;port_id);
id|QueLinkDownCmnd
c_func
(paren
id|cpqfcHBAdata
comma
id|Cmnd
)paren
suffix:semicolon
singleline_comment|//    Need to use &quot;blocked&quot; flag??   &t;
singleline_comment|//&t;Cmnd-&gt;device-&gt;device_blocked = TRUE; // just let it timeout
)brace
r_else
singleline_comment|// device supports TARGET functions, and is logged in...
(brace
singleline_comment|// (context of fchs is to &quot;reply&quot; to...)
id|fchs.s_id
op_assign
id|pLoggedInPort-&gt;port_id
suffix:semicolon
singleline_comment|// destination FC address
singleline_comment|// what is the data direction?  For data TO the device,
singleline_comment|// we need IWE (Intiator Write Entry).  Otherwise, IRE.
r_if
c_cond
(paren
id|Cmnd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_10
op_logical_or
id|Cmnd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_6
op_logical_or
id|Cmnd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_BUFFER
op_logical_or
id|Cmnd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|VENDOR_WRITE_OPCODE
op_logical_or
singleline_comment|// CPQ specific 
id|Cmnd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SELECT
)paren
(brace
id|SESTtype
op_assign
id|SCSI_IWE
suffix:semicolon
singleline_comment|// data from HBA to Device
)brace
r_else
id|SESTtype
op_assign
id|SCSI_IRE
suffix:semicolon
singleline_comment|// data from Device to HBA
id|ulStatus
op_assign
id|cpqfcTSBuildExchange
c_func
(paren
id|cpqfcHBAdata
comma
id|SESTtype
comma
singleline_comment|// e.g. Initiator Read Entry (IRE)
op_amp
id|fchs
comma
singleline_comment|// we are originator; only use d_id
id|Cmnd
comma
singleline_comment|// Linux SCSI command (with scatter/gather list)
op_amp
id|ExchangeID
)paren
suffix:semicolon
singleline_comment|// fcController-&gt;fcExchanges index, -1 if failed
r_if
c_cond
(paren
op_logical_neg
id|ulStatus
)paren
singleline_comment|// Exchange setup?
(brace
r_if
c_cond
(paren
id|cpqfcHBAdata-&gt;BoardLock
)paren
(brace
id|TriggerHBA
c_func
(paren
id|fcChip-&gt;Registers.ReMapMemBase
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; @bl! %d, xID %Xh@ &quot;
comma
id|current-&gt;pid
comma
id|ExchangeID
)paren
suffix:semicolon
)brace
id|ulStatus
op_assign
id|cpqfcTSStartExchange
c_func
(paren
id|cpqfcHBAdata
comma
id|ExchangeID
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ulStatus
)paren
(brace
id|PCI_TRACEO
c_func
(paren
id|ExchangeID
comma
l_int|0xB8
)paren
singleline_comment|// submitted to Tach&squot;s Outbound Que (ERQ PI incremented)
singleline_comment|// waited for completion for ELS type (Login frames issued
singleline_comment|// synchronously)
)brace
r_else
singleline_comment|// check reason for Exchange not being started - we might
singleline_comment|// want to Queue and start later, or fail with error
(brace
id|printk
c_func
(paren
l_string|&quot;quecommand: cpqfcTSStartExchange failed: %Xh&bslash;n&quot;
comma
id|ulStatus
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// end good BuildExchange status
r_else
singleline_comment|// SEST table probably full  -- why? hardware hang?
(brace
id|printk
c_func
(paren
l_string|&quot;quecommand: cpqfcTSBuildExchange faild: %Xh&bslash;n&quot;
comma
id|ulStatus
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// end can&squot;t do FCP-SCSI target functions
)brace
singleline_comment|// end can&squot;t find target (FC device)
id|CPQ_SPINUNLOCK_HBA
c_func
(paren
id|cpqfcHBAdata
)paren
)brace
id|PCI_TRACEO
c_func
(paren
(paren
id|ULONG
)paren
id|Cmnd
comma
l_int|0x9C
)paren
id|LEAVE
c_func
(paren
l_string|&quot;cpqfcTS_queuecommand&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// Entry point for upper Scsi layer intiated abort.  Typically
singleline_comment|// this is called if the command (for hard disk) fails to complete
singleline_comment|// in 30 seconds.  This driver intends to complete all disk commands
singleline_comment|// within Exchange &quot;.timeOut&quot; seconds (now 7) with target status, or
singleline_comment|// in case of &quot;.timeOut&quot; expiration, a DID_SOFT_ERROR which causes
singleline_comment|// immediate retry.
singleline_comment|// If any disk commands get the _abort call, except for the case that
singleline_comment|// the physical device was removed or unavailable due to hardware
singleline_comment|// errors, it should be considered a driver error and reported to
singleline_comment|// the author.
DECL|function|cpqfcTS_abort
r_int
id|cpqfcTS_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|Cmnd
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|HostAdapter
op_assign
id|Cmnd-&gt;host
suffix:semicolon
singleline_comment|// get the pointer to our Scsi layer HBA buffer  
id|CPQFCHBA
op_star
id|cpqfcHBAdata
op_assign
(paren
id|CPQFCHBA
op_star
)paren
id|HostAdapter-&gt;hostdata
suffix:semicolon
id|PTACHYON
id|fcChip
op_assign
op_amp
id|cpqfcHBAdata-&gt;fcChip
suffix:semicolon
id|FC_EXCHANGES
op_star
id|Exchanges
op_assign
id|fcChip-&gt;Exchanges
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ENTER
c_func
(paren
l_string|&quot;cpqfcTS_abort&quot;
)paren
suffix:semicolon
id|Cmnd-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
singleline_comment|// assume we&squot;ll find it
id|printk
c_func
(paren
l_string|&quot; @Linux _abort Scsi_Cmnd %p &quot;
comma
id|Cmnd
)paren
suffix:semicolon
singleline_comment|// See if we can find a Cmnd pointer that matches...
singleline_comment|// The most likely case is we accepted the command
singleline_comment|// from Linux Scsi (e.g. ceated a SEST entry) and it
singleline_comment|// got lost somehow.  If we can&squot;t find any reference
singleline_comment|// to the passed pointer, we can only presume it
singleline_comment|// got completed as far as our driver is concerned.
singleline_comment|// If we found it, we will try to abort it through
singleline_comment|// common mechanism.  If FC ABTS is successful (ACC)
singleline_comment|// or is rejected (RJT) by target, we will call
singleline_comment|// Scsi &quot;done&quot; quickly.  Otherwise, the ABTS will timeout
singleline_comment|// and we&squot;ll call &quot;done&quot; later.
singleline_comment|// Search the SEST exchanges for a matching Cmnd ptr.
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TACH_SEST_LEN
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|Exchanges-&gt;fcExchange
(braket
id|i
)braket
dot
id|Cmnd
op_eq
id|Cmnd
)paren
(brace
singleline_comment|// found it!
id|printk
c_func
(paren
l_string|&quot; x_ID %Xh, type %Xh&bslash;n&quot;
comma
id|i
comma
id|Exchanges-&gt;fcExchange
(braket
id|i
)braket
dot
id|type
)paren
suffix:semicolon
id|Exchanges-&gt;fcExchange
(braket
id|i
)braket
dot
id|status
op_assign
id|INITIATOR_ABORT
suffix:semicolon
singleline_comment|// seconds default
id|Exchanges-&gt;fcExchange
(braket
id|i
)braket
dot
id|timeOut
op_assign
l_int|10
suffix:semicolon
singleline_comment|// seconds default (changed later)
singleline_comment|// Since we need to immediately return the aborted Cmnd to Scsi 
singleline_comment|// upper layers, we can&squot;t make future reference to any of it&squot;s 
singleline_comment|// fields (e.g the Nexus).
id|cpqfcTSPutLinkQue
c_func
(paren
id|cpqfcHBAdata
comma
id|BLS_ABTS
comma
op_amp
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_ge
id|TACH_SEST_LEN
)paren
singleline_comment|// didn&squot;t find Cmnd ptr in chip&squot;s SEST?
(brace
singleline_comment|// now search our non-SEST buffers (i.e. Cmnd waiting to
singleline_comment|// start on the HBA or waiting to complete with error for retry).
singleline_comment|// first check BadTargetCmnd
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CPQFCTS_MAX_TARGET_ID
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpqfcHBAdata-&gt;BadTargetCmnd
(braket
id|i
)braket
op_eq
id|Cmnd
)paren
(brace
id|cpqfcHBAdata-&gt;BadTargetCmnd
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;in BadTargetCmnd Q&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Done
suffix:semicolon
singleline_comment|// exit
)brace
)brace
singleline_comment|// if not found above...
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CPQFCTS_REQ_QUEUE_LEN
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpqfcHBAdata-&gt;LinkDnCmnd
(braket
id|i
)braket
op_eq
id|Cmnd
)paren
(brace
id|cpqfcHBAdata-&gt;LinkDnCmnd
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;in LinkDnCmnd Q&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CPQFCTS_REQ_QUEUE_LEN
suffix:semicolon
id|i
op_increment
)paren
(brace
singleline_comment|// find spare slot
r_if
c_cond
(paren
id|cpqfcHBAdata-&gt;BoardLockCmnd
(braket
id|i
)braket
op_eq
id|Cmnd
)paren
(brace
id|cpqfcHBAdata-&gt;BoardLockCmnd
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;in BoardLockCmnd Q&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
)brace
id|Cmnd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
singleline_comment|// Hmmm...
id|printk
c_func
(paren
l_string|&quot;Not found! &quot;
)paren
suffix:semicolon
singleline_comment|//    panic(&quot;_abort&quot;);
)brace
id|Done
suffix:colon
singleline_comment|//    panic(&quot;_abort&quot;);
id|LEAVE
c_func
(paren
l_string|&quot;cpqfcTS_abort&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
singleline_comment|// (see scsi.h)
)brace
singleline_comment|// To be done...&t;
DECL|function|cpqfcTS_reset
r_int
id|cpqfcTS_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|Cmnd
comma
r_int
r_int
id|reset_flags
)paren
(brace
r_int
id|return_status
op_assign
id|SUCCESS
suffix:semicolon
id|ENTER
c_func
(paren
l_string|&quot;cpqfcTS_reset&quot;
)paren
suffix:semicolon
id|LEAVE
c_func
(paren
l_string|&quot;cpqfcTS_reset&quot;
)paren
suffix:semicolon
r_return
id|return_status
suffix:semicolon
)brace
multiline_comment|/* This function determines the bios parameters for a given&n;   harddisk. These tend to be numbers that are made up by the&n;   host adapter.  Parameters:&n;   size, device number, list (heads, sectors,cylinders).&n;   (from hosts.h)&n;*/
DECL|function|cpqfcTS_biosparam
r_int
id|cpqfcTS_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|n
comma
r_int
id|ip
(braket
)braket
)paren
(brace
r_int
id|size
op_assign
id|disk-&gt;capacity
suffix:semicolon
id|ENTER
c_func
(paren
l_string|&quot;cpqfcTS_biosparam&quot;
)paren
suffix:semicolon
id|ip
(braket
l_int|0
)braket
op_assign
l_int|64
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|32
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
id|size
op_rshift
l_int|11
suffix:semicolon
r_if
c_cond
(paren
id|ip
(braket
l_int|2
)braket
OG
l_int|1024
)paren
(brace
id|ip
(braket
l_int|0
)braket
op_assign
l_int|255
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|63
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
id|size
op_div
(paren
id|ip
(braket
l_int|0
)braket
op_star
id|ip
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|LEAVE
c_func
(paren
l_string|&quot;cpqfcTS_biosparam&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cpqfcTS_intr_handler
r_void
id|cpqfcTS_intr_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
comma
id|InfLoopBrk
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|HostAdapter
op_assign
id|dev_id
suffix:semicolon
id|CPQFCHBA
op_star
id|cpqfcHBA
op_assign
(paren
id|CPQFCHBA
op_star
)paren
id|HostAdapter-&gt;hostdata
suffix:semicolon
r_int
id|MoreMessages
op_assign
l_int|1
suffix:semicolon
singleline_comment|// assume we have something to do
id|UCHAR
id|IntPending
suffix:semicolon
id|ENTER
c_func
(paren
l_string|&quot;intr_handler&quot;
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// is this our INT?
id|IntPending
op_assign
id|readb
c_func
(paren
id|cpqfcHBA-&gt;fcChip.Registers.INTPEND.address
)paren
suffix:semicolon
singleline_comment|// broken boards can generate messages forever, so
singleline_comment|// prevent the infinite loop
DECL|macro|INFINITE_IMQ_BREAK
mdefine_line|#define INFINITE_IMQ_BREAK 10000
r_if
c_cond
(paren
id|IntPending
)paren
(brace
singleline_comment|// mask our HBA interrupts until we handle it...
id|writeb
c_func
(paren
l_int|0
comma
id|cpqfcHBA-&gt;fcChip.Registers.INTEN.address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IntPending
op_amp
l_int|0x4
)paren
singleline_comment|// &quot;INT&quot; - Tach wrote to IMQ
(brace
r_while
c_loop
(paren
(paren
op_increment
id|InfLoopBrk
OL
id|INFINITE_IMQ_BREAK
)paren
op_logical_and
(paren
id|MoreMessages
op_eq
l_int|1
)paren
)paren
(brace
id|MoreMessages
op_assign
id|CpqTsProcessIMQEntry
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
singleline_comment|// ret 0 when done
)brace
r_if
c_cond
(paren
id|InfLoopBrk
op_ge
id|INFINITE_IMQ_BREAK
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;WARNING: Compaq FC adapter generating excessive INTs -REPLACE&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;or investigate alternate causes (e.g. physical FC layer)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
singleline_comment|// working normally - re-enable INTs and continue
id|writeb
c_func
(paren
l_int|0x1F
comma
id|cpqfcHBA-&gt;fcChip.Registers.INTEN.address
)paren
suffix:semicolon
)brace
singleline_comment|// (...ProcessIMQEntry() clears INT by writing IMQ consumer)
r_else
singleline_comment|// indications of errors or problems...
singleline_comment|// these usually indicate critical system hardware problems.
(brace
r_if
c_cond
(paren
id|IntPending
op_amp
l_int|0x10
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; cpqfcTS adapter external memory parity error detected&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IntPending
op_amp
l_int|0x8
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; cpqfcTS adapter PCI master address crossed 45-bit boundary&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IntPending
op_amp
l_int|0x2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; cpqfcTS adapter DMA error detected&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IntPending
op_amp
l_int|0x1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; cpqfcTS adapter PCI error detected&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|LEAVE
c_func
(paren
l_string|&quot;intr_handler&quot;
)paren
suffix:semicolon
)brace
DECL|function|cpqfcTSDecodeGBICtype
r_int
id|cpqfcTSDecodeGBICtype
c_func
(paren
id|PTACHYON
id|fcChip
comma
r_char
id|cErrorString
(braket
)braket
)paren
(brace
singleline_comment|// Verify GBIC type (if any) and correct Tachyon Port State Machine
singleline_comment|// (GBIC) module definition is:
singleline_comment|// GPIO1, GPIO0, GPIO4 for MD2, MD1, MD0.  The input states appear
singleline_comment|// to be inverted -- i.e., a setting of 111 is read when there is NO
singleline_comment|// GBIC present.  The Module Def (MD) spec says 000 is &quot;no GBIC&quot;
singleline_comment|// Hard code the bit states to detect Copper, 
singleline_comment|// Long wave (single mode), Short wave (multi-mode), and absent GBIC
id|ULONG
id|ulBuff
suffix:semicolon
id|sprintf
c_func
(paren
id|cErrorString
comma
l_string|&quot;&bslash;nGBIC detected: &quot;
)paren
suffix:semicolon
id|ulBuff
op_assign
id|fcChip-&gt;Registers.TYstatus.value
op_amp
l_int|0x13
suffix:semicolon
r_switch
c_cond
(paren
id|ulBuff
)paren
(brace
r_case
l_int|0x13
suffix:colon
singleline_comment|// GPIO4, GPIO1, GPIO0 = 111; no GBIC!
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;NONE! &quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
r_case
l_int|0x11
suffix:colon
singleline_comment|// Copper GBIC detected
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;Copper. &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x10
suffix:colon
singleline_comment|// Long-wave (single mode) GBIC detected
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;Long-wave. &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1
suffix:colon
singleline_comment|// Short-wave (multi mode) GBIC detected
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;Short-wave. &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
singleline_comment|// unknown GBIC - presumably it will work (?)
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;Unknown. &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// end switch GBIC detection
r_return
id|TRUE
suffix:semicolon
)brace
DECL|function|cpqfcTSGetLPSM
r_int
id|cpqfcTSGetLPSM
c_func
(paren
id|PTACHYON
id|fcChip
comma
r_char
id|cErrorString
(braket
)braket
)paren
(brace
singleline_comment|// Tachyon&squot;s Frame Manager LPSM in LinkDown state?
singleline_comment|// (For non-loop port, check PSM instead.)
singleline_comment|// return string with state and FALSE is Link Down
r_int
id|LinkUp
suffix:semicolon
r_if
c_cond
(paren
id|fcChip-&gt;Registers.FMstatus.value
op_amp
l_int|0x80
)paren
(brace
id|LinkUp
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
id|LinkUp
op_assign
id|TRUE
suffix:semicolon
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot; LPSM %Xh &quot;
comma
(paren
id|fcChip-&gt;Registers.FMstatus.value
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|fcChip-&gt;Registers.FMstatus.value
op_amp
l_int|0xF0
)paren
(brace
singleline_comment|// bits set in LPSM
r_case
l_int|0x10
suffix:colon
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;ARB&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x20
suffix:colon
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;ARBwon&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x30
suffix:colon
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;OPEN&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;OPENed&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x50
suffix:colon
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;XmitCLS&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x60
suffix:colon
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;RxCLS&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x70
suffix:colon
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;Xfer&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x80
suffix:colon
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;Init&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x90
suffix:colon
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;O-IInitFin&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xa0
suffix:colon
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;O-IProtocol&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xb0
suffix:colon
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;O-ILipRcvd&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xc0
suffix:colon
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;HostControl&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xd0
suffix:colon
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;LoopFail&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xe0
suffix:colon
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;Offline&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xf0
suffix:colon
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;OldPort&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_default
suffix:colon
id|sprintf
c_func
(paren
op_amp
id|cErrorString
(braket
id|strlen
c_func
(paren
id|cErrorString
)paren
)braket
comma
l_string|&quot;Monitor&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|LinkUp
suffix:semicolon
)brace
macro_line|#include &quot;linux/malloc.h&quot;
singleline_comment|// Dynamic memory allocation alignment routines
singleline_comment|// HP&squot;s Tachyon Fibre Channel Controller chips require
singleline_comment|// certain memory queues and register pointers to be aligned
singleline_comment|// on various boundaries, usually the size of the Queue in question.
singleline_comment|// Alignment might be on 2, 4, 8, ... or even 512 byte boundaries.
singleline_comment|// Since most O/Ss don&squot;t allow this (usually only Cache aligned -
singleline_comment|// 32-byte boundary), these routines provide generic alignment (after
singleline_comment|// O/S allocation) at any boundary, and store the original allocated
singleline_comment|// pointer for deletion (O/S free function).  Typically, we expect
singleline_comment|// these functions to only be called at HBA initialization and
singleline_comment|// removal time (load and unload times)
singleline_comment|// ALGORITHM notes:
singleline_comment|// Memory allocation varies by compiler and platform.  In the worst case,
singleline_comment|// we are only assured BYTE allignment, but in the best case, we can
singleline_comment|// request allocation on any desired boundary.  Our strategy: pad the
singleline_comment|// allocation request size (i.e. waste memory) so that we are assured
singleline_comment|// of passing desired boundary near beginning of contiguous space, then
singleline_comment|// mask out lower address bits.
singleline_comment|// We define the following algorithm:
singleline_comment|//   allocBoundary - compiler/platform specific address alignment
singleline_comment|//                   in number of bytes (default is single byte; i.e. 1)
singleline_comment|//   n_alloc       - number of bytes application wants @ aligned address
singleline_comment|//   ab            - alignment boundary, in bytes (e.g. 4, 32, ...)
singleline_comment|//   t_alloc       - total allocation needed to ensure desired boundary
singleline_comment|//   mask          - to clear least significant address bits for boundary
singleline_comment|//   Compute:
singleline_comment|//   t_alloc = n_alloc + (ab - allocBoundary)
singleline_comment|//   allocate t_alloc bytes @ alloc_address
singleline_comment|//   mask =  NOT (ab - 1)
singleline_comment|//       (e.g. if ab=32  _0001 1111  -&gt; _1110 0000
singleline_comment|//   aligned_address = alloc_address &amp; mask
singleline_comment|//   set n_alloc bytes to 0
singleline_comment|//   return aligned_address (NULL if failed)
singleline_comment|//
singleline_comment|// If u32_AlignedAddress is non-zero, then search for BaseAddress (stored
singleline_comment|// from previous allocation).  If found, invoke call to FREE the memory.
singleline_comment|// Return NULL if BaseAddress not found
singleline_comment|// we need about 8 allocations per HBA.  Figuring at most 10 HBAs per server
singleline_comment|// size the dynamic_mem array at 80.
DECL|function|fcMemManager
r_void
op_star
id|fcMemManager
c_func
(paren
id|ALIGNED_MEM
op_star
id|dynamic_mem
comma
id|ULONG
id|n_alloc
comma
id|ULONG
id|ab
comma
id|ULONG
id|u32_AlignedAddress
)paren
(brace
id|USHORT
id|allocBoundary
op_assign
l_int|1
suffix:semicolon
singleline_comment|// compiler specific - worst case 1
singleline_comment|// best case - replace malloc() call
singleline_comment|// with function that allocates exactly
singleline_comment|// at desired boundary
r_int
r_int
id|ulAddress
suffix:semicolon
id|ULONG
id|t_alloc
comma
id|i
suffix:semicolon
r_void
op_star
id|alloc_address
op_assign
l_int|0
suffix:semicolon
singleline_comment|// def. error code / address not found
id|LONG
id|mask
suffix:semicolon
singleline_comment|// must be 32-bits wide!
id|ENTER
c_func
(paren
l_string|&quot;fcMemManager&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|u32_AlignedAddress
)paren
singleline_comment|// are we freeing existing memory?
(brace
singleline_comment|//    printk(&quot; freeing AlignedAddress %Xh&bslash;n&quot;, u32_AlignedAddress);
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DYNAMIC_ALLOCATIONS
suffix:semicolon
id|i
op_increment
)paren
singleline_comment|// look for the base address
(brace
singleline_comment|//    printk(&quot;dynamic_mem[%u].AlignedAddress %lX&bslash;n&quot;, i, dynamic_mem[i].AlignedAddress);
r_if
c_cond
(paren
id|dynamic_mem
(braket
id|i
)braket
dot
id|AlignedAddress
op_eq
id|u32_AlignedAddress
)paren
(brace
id|alloc_address
op_assign
id|dynamic_mem
(braket
id|i
)braket
dot
id|BaseAllocated
suffix:semicolon
singleline_comment|// &squot;success&squot; status
id|kfree
c_func
(paren
id|dynamic_mem
(braket
id|i
)braket
dot
id|BaseAllocated
)paren
suffix:semicolon
singleline_comment|// return pages to kernel
id|dynamic_mem
(braket
id|i
)braket
dot
id|BaseAllocated
op_assign
l_int|0
suffix:semicolon
singleline_comment|// clear for next use
id|dynamic_mem
(braket
id|i
)braket
dot
id|AlignedAddress
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
singleline_comment|// quit for loop; done
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|n_alloc
)paren
singleline_comment|// want new memory?
(brace
id|t_alloc
op_assign
id|n_alloc
op_plus
(paren
id|ab
op_minus
id|allocBoundary
)paren
suffix:semicolon
singleline_comment|// pad bytes for alignment
singleline_comment|//    printk(&quot;kmalloc() for Tach alignment: %ld bytes&bslash;n&quot;, t_alloc);
id|alloc_address
op_assign
singleline_comment|// total bytes (NumberOfBytes)
id|kmalloc
c_func
(paren
id|t_alloc
comma
id|GFP_KERNEL
)paren
suffix:semicolon
singleline_comment|// allow thread block to free pages 
singleline_comment|// now mask off least sig. bits of address
r_if
c_cond
(paren
id|alloc_address
)paren
singleline_comment|// (only if non-NULL)
(brace
singleline_comment|// find place to store ptr, so we
singleline_comment|// can free it later...
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DYNAMIC_ALLOCATIONS
suffix:semicolon
id|i
op_increment
)paren
singleline_comment|// look for free slot
(brace
r_if
c_cond
(paren
id|dynamic_mem
(braket
id|i
)braket
dot
id|BaseAllocated
op_eq
l_int|0
)paren
singleline_comment|// take 1st available
(brace
id|dynamic_mem
(braket
id|i
)braket
dot
id|BaseAllocated
op_assign
id|alloc_address
suffix:semicolon
singleline_comment|// address from O/S
r_break
suffix:semicolon
)brace
)brace
id|mask
op_assign
(paren
id|LONG
)paren
(paren
id|ab
op_minus
l_int|1
)paren
suffix:semicolon
singleline_comment|// mask all low-order bits
id|mask
op_assign
op_complement
id|mask
suffix:semicolon
singleline_comment|// invert bits
id|ulAddress
op_assign
(paren
r_int
r_int
)paren
id|alloc_address
suffix:semicolon
id|ulAddress
op_add_assign
(paren
id|ab
op_minus
id|allocBoundary
)paren
suffix:semicolon
singleline_comment|// add the alignment bytes-
singleline_comment|// then truncate address...
id|alloc_address
op_assign
(paren
r_void
op_star
)paren
(paren
id|ulAddress
op_amp
id|mask
)paren
suffix:semicolon
id|dynamic_mem
(braket
id|i
)braket
dot
id|AlignedAddress
op_assign
(paren
id|ULONG
)paren
(paren
id|ulAddress
op_amp
id|mask
)paren
suffix:semicolon
singleline_comment|// 32bit Tach address
id|memset
c_func
(paren
id|alloc_address
comma
l_int|0
comma
id|n_alloc
)paren
suffix:semicolon
singleline_comment|// clear new memory
)brace
r_else
singleline_comment|// O/S dynamic mem alloc failed!
id|alloc_address
op_assign
l_int|0
suffix:semicolon
singleline_comment|// (for debugging breakpt)
)brace
id|LEAVE
c_func
(paren
l_string|&quot;fcMemManager&quot;
)paren
suffix:semicolon
r_return
id|alloc_address
suffix:semicolon
singleline_comment|// good (or NULL) address
)brace
macro_line|#ifdef MODULE
DECL|variable|driver_template
id|Scsi_Host_Template
id|driver_template
op_assign
id|CPQFCTS
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
macro_line|#endif
eof
