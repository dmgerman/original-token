multiline_comment|/* fdomain.c -- Future Domain TMC-16x0 SCSI driver&n; * Created: Sun May  3 18:53:19 1992 by faith@cs.unc.edu&n; * Revised: Mon Dec 28 21:59:02 1998 by faith@acm.org&n; * Author: Rickard E. Faith, faith@cs.unc.edu&n; * Copyright 1992-1996, 1998 Rickard E. Faith (faith@acm.org)&n;&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n;&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n;&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; **************************************************************************&n;&n; SUMMARY:&n;&n; Future Domain BIOS versions supported for autodetect:&n;    2.0, 3.0, 3.2, 3.4 (1.0), 3.5 (2.0), 3.6, 3.61&n; Chips are supported:&n;    TMC-1800, TMC-18C50, TMC-18C30, TMC-36C70&n; Boards supported:&n;    Future Domain TMC-1650, TMC-1660, TMC-1670, TMC-1680, TMC-1610M/MER/MEX&n;    Future Domain TMC-3260 (PCI)&n;    Quantum ISA-200S, ISA-250MG&n;    Adaptec AHA-2920A (PCI) [BUT *NOT* AHA-2920C -- use aic7xxx instead]&n;    IBM ?&n; LILO/INSMOD command-line options:&n;    fdomain=&lt;PORT_BASE&gt;,&lt;IRQ&gt;[,&lt;ADAPTER_ID&gt;]&n;&n;&n;    &n; NOTE:&n;&n; The Adaptec AHA-2920C has an Adaptec AIC-7850 chip on it.&n; Use the aic7xxx driver for this board.&n;       &n; The Adaptec AHA-2920A has a Future Domain chip on it, so this is the right&n; driver for that card.  Unfortunately, the boxes will probably just say&n; &quot;2920&quot;, so you&squot;ll have to look on the card for a Future Domain logo, or a&n; letter after the 2920.&n;&n; &n; &n; THANKS:&n;&n; Thanks to Adaptec for providing PCI boards for testing.  This finally&n; enabled me to test the PCI detection and correct it for PCI boards that do&n; not have a BIOS at a standard ISA location.  For PCI boards, LILO/INSMOD&n; command-line options should no longer be needed.  --RF 18Nov98&n;&n;&n; &n; DESCRIPTION:&n; &n; This is the Linux low-level SCSI driver for Future Domain TMC-1660/1680&n; TMC-1650/1670, and TMC-3260 SCSI host adapters.  The 1650 and 1670 have a&n; 25-pin external connector, whereas the 1660 and 1680 have a SCSI-2 50-pin&n; high-density external connector.  The 1670 and 1680 have floppy disk&n; controllers built in.  The TMC-3260 is a PCI bus card.&n;&n; Future Domain&squot;s older boards are based on the TMC-1800 chip, and this&n; driver was originally written for a TMC-1680 board with the TMC-1800 chip.&n; More recently, boards are being produced with the TMC-18C50 and TMC-18C30&n; chips.  The latest and greatest board may not work with this driver.  If&n; you have to patch this driver so that it will recognize your board&squot;s BIOS&n; signature, then the driver may fail to function after the board is&n; detected.&n;&n; Please note that the drive ordering that Future Domain implemented in BIOS&n; versions 3.4 and 3.5 is the opposite of the order (currently) used by the&n; rest of the SCSI industry.  If you have BIOS version 3.4 or 3.5, and have&n; more then one drive, then the drive ordering will be the reverse of that&n; which you see under DOS.  For example, under DOS SCSI ID 0 will be D: and&n; SCSI ID 1 will be C: (the boot device).  Under Linux, SCSI ID 0 will be&n; /dev/sda and SCSI ID 1 will be /dev/sdb.  The Linux ordering is consistent&n; with that provided by all the other SCSI drivers for Linux.  If you want&n; this changed, you will probably have to patch the higher level SCSI code.&n; If you do so, please send me patches that are protected by #ifdefs.&n;&n; If you have a TMC-8xx or TMC-9xx board, then this is not the driver for&n; your board.  Please refer to the Seagate driver for more information and&n; possible support.&n;&n; &n; &n; HISTORY:&n;&n; Linux       Driver      Driver&n; Version     Version     Date         Support/Notes&n;&n;             0.0          3 May 1992  V2.0 BIOS; 1800 chip&n; 0.97        1.9         28 Jul 1992&n; 0.98.6      3.1         27 Nov 1992&n; 0.99        3.2          9 Dec 1992&n;&n; 0.99.3      3.3         10 Jan 1993  V3.0 BIOS&n; 0.99.5      3.5         18 Feb 1993&n; 0.99.10     3.6         15 May 1993  V3.2 BIOS; 18C50 chip&n; 0.99.11     3.17         3 Jul 1993  (now under RCS)&n; 0.99.12     3.18        13 Aug 1993&n; 0.99.14     5.6         31 Oct 1993  (reselection code removed)&n;&n; 0.99.15     5.9         23 Jan 1994  V3.4 BIOS (preliminary)&n; 1.0.8/1.1.1 5.15         1 Apr 1994  V3.4 BIOS; 18C30 chip (preliminary)&n; 1.0.9/1.1.3 5.16         7 Apr 1994  V3.4 BIOS; 18C30 chip&n; 1.1.38      5.18        30 Jul 1994  36C70 chip (PCI version of 18C30)&n; 1.1.62      5.20         2 Nov 1994  V3.5 BIOS&n; 1.1.73      5.22         7 Dec 1994  Quantum ISA-200S board; V2.0 BIOS&n;&n; 1.1.82      5.26        14 Jan 1995  V3.5 BIOS; TMC-1610M/MER/MEX board&n; 1.2.10      5.28         5 Jun 1995  Quantum ISA-250MG board; V2.0, V2.01 BIOS&n; 1.3.4       5.31        23 Jun 1995  PCI BIOS-32 detection (preliminary)&n; 1.3.7       5.33         4 Jul 1995  PCI BIOS-32 detection&n; 1.3.28      5.36        17 Sep 1995  V3.61 BIOS; LILO command-line support&n; 1.3.34      5.39        12 Oct 1995  V3.60 BIOS; /proc&n; 1.3.72      5.39         8 Feb 1996  Adaptec AHA-2920 board&n; 1.3.85      5.41         4 Apr 1996&n; 2.0.12      5.44         8 Aug 1996  Use ID 7 for all PCI cards&n; 2.1.1       5.45         2 Oct 1996  Update ROM accesses for 2.1.x&n; 2.1.97      5.46&t; 23 Apr 1998  Rewritten PCI detection routines [mj]&n; 2.1.11x     5.47&t;  9 Aug 1998  Touched for 8 SCSI disk majors support&n;             5.48        18 Nov 1998  BIOS no longer needed for PCI detection&n; 2.2.0       5.50        28 Dec 1998  Support insmod parameters&n; &n;&n; REFERENCES USED:&n;&n; &quot;TMC-1800 SCSI Chip Specification (FDC-1800T)&quot;, Future Domain Corporation,&n; 1990.&n;&n; &quot;Technical Reference Manual: 18C50 SCSI Host Adapter Chip&quot;, Future Domain&n; Corporation, January 1992.&n;&n; &quot;LXT SCSI Products: Specifications and OEM Technical Manual (Revision&n; B/September 1991)&quot;, Maxtor Corporation, 1991.&n;&n; &quot;7213S product Manual (Revision P3)&quot;, Maxtor Corporation, 1992.&n;&n; &quot;Draft Proposed American National Standard: Small Computer System&n; Interface - 2 (SCSI-2)&quot;, Global Engineering Documents. (X3T9.2/86-109,&n; revision 10h, October 17, 1991)&n;&n; Private communications, Drew Eckhardt (drew@cs.colorado.edu) and Eric&n; Youngdale (ericy@cais.com), 1992.&n;&n; Private communication, Tuong Le (Future Domain Engineering department),&n; 1994. (Disk geometry computations for Future Domain BIOS version 3.4, and&n; TMC-18C30 detection.)&n;&n; Hogan, Thom. The Programmer&squot;s PC Sourcebook. Microsoft Press, 1988. Page&n; 60 (2.39: Disk Partition Table Layout).&n;&n; &quot;18C30 Technical Reference Manual&quot;, Future Domain Corporation, 1993, page&n; 6-1.&n;&n;&n; &n; NOTES ON REFERENCES:&n;&n; The Maxtor manuals were free.  Maxtor telephone technical support is&n; great!&n;&n; The Future Domain manuals were $25 and $35.  They document the chip, not&n; the TMC-16x0 boards, so some information I had to guess at.  In 1992,&n; Future Domain sold DOS BIOS source for $250 and the UN*X driver source was&n; $750, but these required a non-disclosure agreement, so even if I could&n; have afforded them, they would *not* have been useful for writing this&n; publically distributable driver.  Future Domain technical support has&n; provided some information on the phone and have sent a few useful FAXs.&n; They have been much more helpful since they started to recognize that the&n; word &quot;Linux&quot; refers to an operating system :-).&n;&n; &n;&n; ALPHA TESTERS:&n;&n; There are many other alpha testers that come and go as the driver&n; develops.  The people listed here were most helpful in times of greatest&n; need (mostly early on -- I&squot;ve probably left out a few worthy people in&n; more recent times):&n;&n; Todd Carrico (todd@wutc.wustl.edu), Dan Poirier (poirier@cs.unc.edu ), Ken&n; Corey (kenc@sol.acs.unt.edu), C. de Bruin (bruin@bruin@sterbbs.nl), Sakari&n; Aaltonen (sakaria@vipunen.hit.fi), John Rice (rice@xanth.cs.odu.edu), Brad&n; Yearwood (brad@optilink.com), and Ray Toy (toy@soho.crd.ge.com).&n;&n; Special thanks to Tien-Wan Yang (twyang@cs.uh.edu), who graciously lent me&n; his 18C50-based card for debugging.  He is the sole reason that this&n; driver works with the 18C50 chip.&n;&n; Thanks to Dave Newman (dnewman@crl.com) for providing initial patches for&n; the version 3.4 BIOS.&n;&n; Thanks to James T. McKinley (mckinley@msupa.pa.msu.edu) for providing&n; patches that support the TMC-3260, a PCI bus card with the 36C70 chip.&n; The 36C70 chip appears to be &quot;completely compatible&quot; with the 18C30 chip.&n;&n; Thanks to Eric Kasten (tigger@petroglyph.cl.msu.edu) for providing the&n; patch for the version 3.5 BIOS.&n;&n; Thanks for Stephen Henson (shenson@nyx10.cs.du.edu) for providing the&n; patch for the Quantum ISA-200S SCSI adapter.&n; &n; Thanks to Adam Bowen for the signature to the 1610M/MER/MEX scsi cards, to&n; Martin Andrews (andrewm@ccfadm.eeg.ccf.org) for the signature to some&n; random TMC-1680 repackaged by IBM; and to Mintak Ng (mintak@panix.com) for&n; the version 3.61 BIOS signature.&n;&n; Thanks for Mark Singer (elf@netcom.com) and Richard Simpson&n; (rsimpson@ewrcsdra.demon.co.uk) for more Quantum signatures and detective&n; work on the Quantum RAM layout.&n;&n; Special thanks to James T. McKinley (mckinley@msupa.pa.msu.edu) for&n; providing patches for proper PCI BIOS32-mediated detection of the TMC-3260&n; card (a PCI bus card with the 36C70 chip).  Please send James PCI-related&n; bug reports.&n;&n; Thanks to Tom Cavin (tec@usa1.com) for preliminary command-line option&n; patches.&n;&n; New PCI detection code written by Martin Mares &lt;mj@atrey.karlin.mff.cuni.cz&gt;&n;&n; Insmod parameter code based on patches from Daniel Graham&n; &lt;graham@balance.uoregon.edu&gt;. &n; &n; All of the alpha testers deserve much thanks.&n;&n;&n;&n; NOTES ON USER DEFINABLE OPTIONS:&n;&n; DEBUG: This turns on the printing of various debug information.&n;&n; ENABLE_PARITY: This turns on SCSI parity checking.  With the current&n; driver, all attached devices must support SCSI parity.  If none of your&n; devices support parity, then you can probably get the driver to work by&n; turning this option off.  I have no way of testing this, however, and it&n; would appear that no one ever uses this option.&n;&n; FIFO_COUNT: The host adapter has an 8K cache (host adapters based on the&n; 18C30 chip have a 2k cache).  When this many 512 byte blocks are filled by&n; the SCSI device, an interrupt will be raised.  Therefore, this could be as&n; low as 0, or as high as 16.  Note, however, that values which are too high&n; or too low seem to prevent any interrupts from occurring, and thereby lock&n; up the machine.  I have found that 2 is a good number, but throughput may&n; be increased by changing this value to values which are close to 2.&n; Please let me know if you try any different values.&n;&n; DO_DETECT: This activates some old scan code which was needed before the&n; high level drivers got fixed.  If you are having trouble with the driver,&n; turning this on should not hurt, and might help.  Please let me know if&n; this is the case, since this code will be removed from future drivers.&n;&n; RESELECTION: This is no longer an option, since I gave up trying to&n; implement it in version 4.x of this driver.  It did not improve&n; performance at all and made the driver unstable (because I never found one&n; of the two race conditions which were introduced by the multiple&n; outstanding command code).  The instability seems a very high price to pay&n; just so that you don&squot;t have to wait for the tape to rewind.  If you want&n; this feature implemented, send me patches.  I&squot;ll be happy to send a copy&n; of my (broken) driver to anyone who would like to see a copy.&n;&n; **************************************************************************/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#ifdef PCMCIA
DECL|macro|MODULE
macro_line|#undef MODULE
macro_line|#endif
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;fdomain.h&quot;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/config.h&gt;&t;/* for CONFIG_PCI */
DECL|macro|VERSION
mdefine_line|#define VERSION          &quot;$Revision: 5.50 $&quot;
multiline_comment|/* START OF USER DEFINABLE OPTIONS */
DECL|macro|DEBUG
mdefine_line|#define DEBUG            1&t;/* Enable debugging output */
DECL|macro|ENABLE_PARITY
mdefine_line|#define ENABLE_PARITY    1&t;/* Enable SCSI Parity */
DECL|macro|FIFO_COUNT
mdefine_line|#define FIFO_COUNT       2&t;/* Number of 512 byte blocks before INTR */
DECL|macro|DO_DETECT
mdefine_line|#define DO_DETECT        0&t;/* Do device detection here (see scsi.c) */
multiline_comment|/* END OF USER DEFINABLE OPTIONS */
macro_line|#if DEBUG
DECL|macro|EVERY_ACCESS
mdefine_line|#define EVERY_ACCESS     0&t;/* Write a line on every scsi access */
DECL|macro|ERRORS_ONLY
mdefine_line|#define ERRORS_ONLY      1&t;/* Only write a line if there is an error */
DECL|macro|DEBUG_DETECT
mdefine_line|#define DEBUG_DETECT     0&t;/* Debug fdomain_16x0_detect() */
DECL|macro|DEBUG_MESSAGES
mdefine_line|#define DEBUG_MESSAGES   1&t;/* Debug MESSAGE IN phase */
DECL|macro|DEBUG_ABORT
mdefine_line|#define DEBUG_ABORT      1&t;/* Debug abort() routine */
DECL|macro|DEBUG_RESET
mdefine_line|#define DEBUG_RESET      1&t;/* Debug reset() routine */
DECL|macro|DEBUG_RACE
mdefine_line|#define DEBUG_RACE       1      /* Debug interrupt-driven race condition */
macro_line|#else
DECL|macro|EVERY_ACCESS
mdefine_line|#define EVERY_ACCESS     0&t;/* LEAVE THESE ALONE--CHANGE THE ONES ABOVE */
DECL|macro|ERRORS_ONLY
mdefine_line|#define ERRORS_ONLY      0
DECL|macro|DEBUG_DETECT
mdefine_line|#define DEBUG_DETECT     0
DECL|macro|DEBUG_MESSAGES
mdefine_line|#define DEBUG_MESSAGES   0
DECL|macro|DEBUG_ABORT
mdefine_line|#define DEBUG_ABORT      0
DECL|macro|DEBUG_RESET
mdefine_line|#define DEBUG_RESET      0
DECL|macro|DEBUG_RACE
mdefine_line|#define DEBUG_RACE       0
macro_line|#endif
multiline_comment|/* Errors are reported on the line, so we don&squot;t need to report them again */
macro_line|#if EVERY_ACCESS
DECL|macro|ERRORS_ONLY
macro_line|#undef ERRORS_ONLY
DECL|macro|ERRORS_ONLY
mdefine_line|#define ERRORS_ONLY      0
macro_line|#endif
macro_line|#if ENABLE_PARITY
DECL|macro|PARITY_MASK
mdefine_line|#define PARITY_MASK      0x08
macro_line|#else
DECL|macro|PARITY_MASK
mdefine_line|#define PARITY_MASK      0x00
macro_line|#endif
DECL|enum|chip_type
r_enum
id|chip_type
(brace
DECL|enumerator|unknown
id|unknown
op_assign
l_int|0x00
comma
DECL|enumerator|tmc1800
id|tmc1800
op_assign
l_int|0x01
comma
DECL|enumerator|tmc18c50
id|tmc18c50
op_assign
l_int|0x02
comma
DECL|enumerator|tmc18c30
id|tmc18c30
op_assign
l_int|0x03
comma
)brace
suffix:semicolon
r_enum
(brace
DECL|enumerator|in_arbitration
id|in_arbitration
op_assign
l_int|0x02
comma
DECL|enumerator|in_selection
id|in_selection
op_assign
l_int|0x04
comma
DECL|enumerator|in_other
id|in_other
op_assign
l_int|0x08
comma
DECL|enumerator|disconnect
id|disconnect
op_assign
l_int|0x10
comma
DECL|enumerator|aborted
id|aborted
op_assign
l_int|0x20
comma
DECL|enumerator|sent_ident
id|sent_ident
op_assign
l_int|0x40
comma
)brace
suffix:semicolon
DECL|enum|in_port_type
r_enum
id|in_port_type
(brace
DECL|enumerator|Read_SCSI_Data
id|Read_SCSI_Data
op_assign
l_int|0
comma
DECL|enumerator|SCSI_Status
id|SCSI_Status
op_assign
l_int|1
comma
DECL|enumerator|TMC_Status
id|TMC_Status
op_assign
l_int|2
comma
DECL|enumerator|FIFO_Status
id|FIFO_Status
op_assign
l_int|3
comma
multiline_comment|/* tmc18c50/tmc18c30 only */
DECL|enumerator|Interrupt_Cond
id|Interrupt_Cond
op_assign
l_int|4
comma
multiline_comment|/* tmc18c50/tmc18c30 only */
DECL|enumerator|LSB_ID_Code
id|LSB_ID_Code
op_assign
l_int|5
comma
DECL|enumerator|MSB_ID_Code
id|MSB_ID_Code
op_assign
l_int|6
comma
DECL|enumerator|Read_Loopback
id|Read_Loopback
op_assign
l_int|7
comma
DECL|enumerator|SCSI_Data_NoACK
id|SCSI_Data_NoACK
op_assign
l_int|8
comma
DECL|enumerator|Interrupt_Status
id|Interrupt_Status
op_assign
l_int|9
comma
DECL|enumerator|Configuration1
id|Configuration1
op_assign
l_int|10
comma
DECL|enumerator|Configuration2
id|Configuration2
op_assign
l_int|11
comma
multiline_comment|/* tmc18c50/tmc18c30 only */
DECL|enumerator|Read_FIFO
id|Read_FIFO
op_assign
l_int|12
comma
DECL|enumerator|FIFO_Data_Count
id|FIFO_Data_Count
op_assign
l_int|14
)brace
suffix:semicolon
DECL|enum|out_port_type
r_enum
id|out_port_type
(brace
DECL|enumerator|Write_SCSI_Data
id|Write_SCSI_Data
op_assign
l_int|0
comma
DECL|enumerator|SCSI_Cntl
id|SCSI_Cntl
op_assign
l_int|1
comma
DECL|enumerator|Interrupt_Cntl
id|Interrupt_Cntl
op_assign
l_int|2
comma
DECL|enumerator|SCSI_Mode_Cntl
id|SCSI_Mode_Cntl
op_assign
l_int|3
comma
DECL|enumerator|TMC_Cntl
id|TMC_Cntl
op_assign
l_int|4
comma
DECL|enumerator|Memory_Cntl
id|Memory_Cntl
op_assign
l_int|5
comma
multiline_comment|/* tmc18c50/tmc18c30 only */
DECL|enumerator|Write_Loopback
id|Write_Loopback
op_assign
l_int|7
comma
DECL|enumerator|IO_Control
id|IO_Control
op_assign
l_int|11
comma
multiline_comment|/* tmc18c30 only */
DECL|enumerator|Write_FIFO
id|Write_FIFO
op_assign
l_int|12
)brace
suffix:semicolon
DECL|variable|port_base
r_static
r_int
id|port_base
op_assign
l_int|0
suffix:semicolon
DECL|variable|bios_base
r_static
r_int
r_int
id|bios_base
op_assign
l_int|0
suffix:semicolon
DECL|variable|bios_major
r_static
r_int
id|bios_major
op_assign
l_int|0
suffix:semicolon
DECL|variable|bios_minor
r_static
r_int
id|bios_minor
op_assign
l_int|0
suffix:semicolon
DECL|variable|PCI_bus
r_static
r_int
id|PCI_bus
op_assign
l_int|0
suffix:semicolon
DECL|variable|Quantum
r_static
r_int
id|Quantum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Quantum board variant */
DECL|variable|interrupt_level
r_static
r_int
id|interrupt_level
op_assign
l_int|0
suffix:semicolon
DECL|variable|in_command
r_static
r_volatile
r_int
id|in_command
op_assign
l_int|0
suffix:semicolon
DECL|variable|current_SC
r_static
id|Scsi_Cmnd
op_star
id|current_SC
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|chip
r_static
r_enum
id|chip_type
id|chip
op_assign
id|unknown
suffix:semicolon
DECL|variable|adapter_mask
r_static
r_int
id|adapter_mask
op_assign
l_int|0
suffix:semicolon
DECL|variable|this_id
r_static
r_int
id|this_id
op_assign
l_int|0
suffix:semicolon
DECL|variable|setup_called
r_static
r_int
id|setup_called
op_assign
l_int|0
suffix:semicolon
macro_line|#if DEBUG_RACE
DECL|variable|in_interrupt_flag
r_static
r_volatile
r_int
id|in_interrupt_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|variable|SCSI_Mode_Cntl_port
r_static
r_int
id|SCSI_Mode_Cntl_port
suffix:semicolon
DECL|variable|FIFO_Data_Count_port
r_static
r_int
id|FIFO_Data_Count_port
suffix:semicolon
DECL|variable|Interrupt_Cntl_port
r_static
r_int
id|Interrupt_Cntl_port
suffix:semicolon
DECL|variable|Interrupt_Status_port
r_static
r_int
id|Interrupt_Status_port
suffix:semicolon
DECL|variable|Read_FIFO_port
r_static
r_int
id|Read_FIFO_port
suffix:semicolon
DECL|variable|Read_SCSI_Data_port
r_static
r_int
id|Read_SCSI_Data_port
suffix:semicolon
DECL|variable|SCSI_Cntl_port
r_static
r_int
id|SCSI_Cntl_port
suffix:semicolon
DECL|variable|SCSI_Data_NoACK_port
r_static
r_int
id|SCSI_Data_NoACK_port
suffix:semicolon
DECL|variable|SCSI_Status_port
r_static
r_int
id|SCSI_Status_port
suffix:semicolon
DECL|variable|TMC_Cntl_port
r_static
r_int
id|TMC_Cntl_port
suffix:semicolon
DECL|variable|TMC_Status_port
r_static
r_int
id|TMC_Status_port
suffix:semicolon
DECL|variable|Write_FIFO_port
r_static
r_int
id|Write_FIFO_port
suffix:semicolon
DECL|variable|Write_SCSI_Data_port
r_static
r_int
id|Write_SCSI_Data_port
suffix:semicolon
DECL|variable|FIFO_Size
r_static
r_int
id|FIFO_Size
op_assign
l_int|0x2000
suffix:semicolon
multiline_comment|/* 8k FIFO for&n;&t;&t;&t;&t;&t;&t;pre-tmc18c30 chips */
r_extern
r_void
id|do_fdomain_16x0_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
macro_line|#ifdef MODULE
multiline_comment|/* Allow insmod parameters to be like LILO&n;                                   parameters.  For example:&n;&t;&t;&t;&t;   insmod fdomain fdomain=0x140,11&n;&t;&t;&t;&t;*/
DECL|variable|fdomain
r_static
r_char
op_star
id|fdomain
op_assign
l_int|NULL
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|fdomain
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|addresses
r_static
r_int
r_int
id|addresses
(braket
)braket
op_assign
(brace
l_int|0xc8000
comma
l_int|0xca000
comma
l_int|0xce000
comma
l_int|0xde000
comma
l_int|0xcc000
comma
multiline_comment|/* Extra addresses for PCI boards */
l_int|0xd0000
comma
l_int|0xe0000
comma
)brace
suffix:semicolon
DECL|macro|ADDRESS_COUNT
mdefine_line|#define ADDRESS_COUNT (sizeof( addresses ) / sizeof( unsigned ))
DECL|variable|ports
r_static
r_int
r_int
id|ports
(braket
)braket
op_assign
(brace
l_int|0x140
comma
l_int|0x150
comma
l_int|0x160
comma
l_int|0x170
)brace
suffix:semicolon
DECL|macro|PORT_COUNT
mdefine_line|#define PORT_COUNT (sizeof( ports ) / sizeof( unsigned short ))
DECL|variable|ints
r_static
r_int
r_int
id|ints
(braket
)braket
op_assign
(brace
l_int|3
comma
l_int|5
comma
l_int|10
comma
l_int|11
comma
l_int|12
comma
l_int|14
comma
l_int|15
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n;&n;  READ THIS BEFORE YOU ADD A SIGNATURE!&n;&n;  READING THIS SHORT NOTE CAN SAVE YOU LOTS OF TIME!&n;&n;  READ EVERY WORD, ESPECIALLY THE WORD *NOT*&n;&n;  This driver works *ONLY* for Future Domain cards using the TMC-1800,&n;  TMC-18C50, or TMC-18C30 chip.  This includes models TMC-1650, 1660, 1670,&n;  and 1680.  These are all 16-bit cards.&n;&n;  The following BIOS signature signatures are for boards which do *NOT*&n;  work with this driver (these TMC-8xx and TMC-9xx boards may work with the&n;  Seagate driver):&n;&n;  FUTURE DOMAIN CORP. (C) 1986-1988 V4.0I 03/16/88&n;  FUTURE DOMAIN CORP. (C) 1986-1989 V5.0C2/14/89&n;  FUTURE DOMAIN CORP. (C) 1986-1989 V6.0A7/28/89&n;  FUTURE DOMAIN CORP. (C) 1986-1990 V6.0105/31/90&n;  FUTURE DOMAIN CORP. (C) 1986-1990 V6.0209/18/90&n;  FUTURE DOMAIN CORP. (C) 1986-1990 V7.009/18/90&n;  FUTURE DOMAIN CORP. (C) 1992 V8.00.004/02/92&n;&n;  (The cards which do *NOT* work are all 8-bit cards -- although some of&n;  them have a 16-bit form-factor, the upper 8-bits are used only for IRQs&n;  and are *NOT* used for data.  You can tell the difference by following&n;  the tracings on the circuit board -- if only the IRQ lines are involved,&n;  you have a &quot;8-bit&quot; card, and should *NOT* use this driver.)&n;&n;*/
DECL|struct|signature
r_struct
id|signature
(brace
DECL|member|signature
r_const
r_char
op_star
id|signature
suffix:semicolon
DECL|member|sig_offset
r_int
id|sig_offset
suffix:semicolon
DECL|member|sig_length
r_int
id|sig_length
suffix:semicolon
DECL|member|major_bios_version
r_int
id|major_bios_version
suffix:semicolon
DECL|member|minor_bios_version
r_int
id|minor_bios_version
suffix:semicolon
DECL|member|flag
r_int
id|flag
suffix:semicolon
multiline_comment|/* 1 == PCI_bus, 2 == ISA_200S, 3 == ISA_250MG, 4 == ISA_200S */
DECL|variable|signatures
)brace
id|signatures
(braket
)braket
op_assign
(brace
multiline_comment|/*          1         2         3         4         5         6 */
multiline_comment|/* 123456789012345678901234567890123456789012345678901234567890 */
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.07/28/89&quot;
comma
l_int|5
comma
l_int|50
comma
l_int|2
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1990 1800-V1.07/28/89&quot;
comma
l_int|5
comma
l_int|50
comma
l_int|2
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.07/28/89&quot;
comma
l_int|72
comma
l_int|50
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.0&quot;
comma
l_int|73
comma
l_int|43
comma
l_int|2
comma
l_int|0
comma
l_int|3
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1991 1800-V2.0.&quot;
comma
l_int|72
comma
l_int|39
comma
l_int|2
comma
l_int|0
comma
l_int|4
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1992 V3.00.004/02/92&quot;
comma
l_int|5
comma
l_int|44
comma
l_int|3
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN TMC-18XX (C) 1993 V3.203/12/93&quot;
comma
l_int|5
comma
l_int|44
comma
l_int|3
comma
l_int|2
comma
l_int|0
)brace
comma
(brace
l_string|&quot;IBM F1 P2 BIOS v1.0104/29/93&quot;
comma
l_int|5
comma
l_int|28
comma
l_int|3
comma
op_minus
l_int|1
comma
l_int|0
)brace
comma
(brace
l_string|&quot;Future Domain Corp. V1.0008/18/93&quot;
comma
l_int|5
comma
l_int|33
comma
l_int|3
comma
l_int|4
comma
l_int|0
)brace
comma
(brace
l_string|&quot;Future Domain Corp. V1.0008/18/93&quot;
comma
l_int|26
comma
l_int|33
comma
l_int|3
comma
l_int|4
comma
l_int|1
)brace
comma
(brace
l_string|&quot;Adaptec AHA-2920 PCI-SCSI Card&quot;
comma
l_int|42
comma
l_int|31
comma
l_int|3
comma
op_minus
l_int|1
comma
l_int|1
)brace
comma
(brace
l_string|&quot;IBM F1 P264/32&quot;
comma
l_int|5
comma
l_int|14
comma
l_int|3
comma
op_minus
l_int|1
comma
l_int|1
)brace
comma
multiline_comment|/* This next signature may not be a 3.5 bios */
(brace
l_string|&quot;Future Domain Corp. V2.0108/18/93&quot;
comma
l_int|5
comma
l_int|33
comma
l_int|3
comma
l_int|5
comma
l_int|0
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP.  V3.5008/18/93&quot;
comma
l_int|5
comma
l_int|34
comma
l_int|3
comma
l_int|5
comma
l_int|0
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN 18c30/18c50/1800 (C) 1994 V3.5&quot;
comma
l_int|5
comma
l_int|44
comma
l_int|3
comma
l_int|5
comma
l_int|0
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP.  V3.6008/18/93&quot;
comma
l_int|5
comma
l_int|34
comma
l_int|3
comma
l_int|6
comma
l_int|0
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP.  V3.6108/18/93&quot;
comma
l_int|5
comma
l_int|34
comma
l_int|3
comma
l_int|6
comma
l_int|0
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN TMC-18XX&quot;
comma
l_int|5
comma
l_int|22
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|0
)brace
comma
multiline_comment|/* READ NOTICE ABOVE *BEFORE* YOU WASTE YOUR TIME ADDING A SIGNATURE&n;    Also, fix the disk geometry code for your signature and send your&n;    changes for faith@cs.unc.edu.  Above all, do *NOT* change any old&n;    signatures!&n;&n;    Note that the last line will match a &quot;generic&quot; 18XX bios.  Because&n;    Future Domain has changed the host SCSI ID and/or the location of the&n;    geometry information in the on-board RAM area for each of the first&n;    three BIOS&squot;s, it is still important to enter a fully qualified&n;    signature in the table for any new BIOS&squot;s (after the host SCSI ID and&n;    geometry location are verified). */
)brace
suffix:semicolon
DECL|macro|SIGNATURE_COUNT
mdefine_line|#define SIGNATURE_COUNT (sizeof( signatures ) / sizeof( struct signature ))
DECL|function|print_banner
r_static
r_void
id|print_banner
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|shpnt
)paren
r_return
suffix:semicolon
multiline_comment|/* This won&squot;t ever happen */
r_if
c_cond
(paren
id|bios_major
OL
l_int|0
op_logical_and
id|bios_minor
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: &lt;fdomain&gt; No BIOS; using scsi id %d&bslash;n&quot;
comma
id|shpnt-&gt;host_no
comma
id|shpnt-&gt;this_id
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: &lt;fdomain&gt; BIOS version &quot;
comma
id|shpnt-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bios_major
op_ge
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%d.&quot;
comma
id|bios_major
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;?.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bios_minor
op_ge
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%d&quot;
comma
id|bios_minor
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;?.&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; at 0x%lx using scsi id %d&bslash;n&quot;
comma
id|bios_base
comma
id|shpnt-&gt;this_id
)paren
suffix:semicolon
)brace
multiline_comment|/* If this driver works for later FD PCI&n;&t;&t;&t;&t;   boards, we will have to modify banner&n;&t;&t;&t;&t;   for additional PCI cards, but for now if&n;&t;&t;&t;&t;   it&squot;s PCI it&squot;s a TMC-3260 - JTM */
id|printk
c_func
(paren
l_string|&quot;scsi%d: &lt;fdomain&gt; %s chip at 0x%x irq &quot;
comma
id|shpnt-&gt;host_no
comma
id|chip
op_eq
id|tmc1800
ques
c_cond
l_string|&quot;TMC-1800&quot;
suffix:colon
(paren
id|chip
op_eq
id|tmc18c50
ques
c_cond
l_string|&quot;TMC-18C50&quot;
suffix:colon
(paren
id|chip
op_eq
id|tmc18c30
ques
c_cond
(paren
id|PCI_bus
ques
c_cond
l_string|&quot;TMC-36C70 (PCI bus)&quot;
suffix:colon
l_string|&quot;TMC-18C30&quot;
)paren
suffix:colon
l_string|&quot;Unknown&quot;
)paren
)paren
comma
id|port_base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|interrupt_level
)paren
id|printk
c_func
(paren
l_string|&quot;%d&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&lt;none&gt;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|fdomain_setup
r_static
r_int
id|__init
id|fdomain_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|ints
(braket
l_int|4
)braket
suffix:semicolon
(paren
r_void
)paren
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
r_if
c_cond
(paren
id|setup_called
op_increment
op_logical_or
id|ints
(braket
l_int|0
)braket
template_param
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt;&quot;
l_string|&quot; Usage: fdomain=&lt;PORT_BASE&gt;,&lt;IRQ&gt;[,&lt;ADAPTER_ID&gt;]&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; Bad LILO/INSMOD parameters?&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|port_base
op_assign
id|ints
(braket
l_int|0
)braket
op_ge
l_int|1
ques
c_cond
id|ints
(braket
l_int|1
)braket
suffix:colon
l_int|0
suffix:semicolon
id|interrupt_level
op_assign
id|ints
(braket
l_int|0
)braket
op_ge
l_int|2
ques
c_cond
id|ints
(braket
l_int|2
)braket
suffix:colon
l_int|0
suffix:semicolon
id|this_id
op_assign
id|ints
(braket
l_int|0
)braket
op_ge
l_int|3
ques
c_cond
id|ints
(braket
l_int|3
)braket
suffix:colon
l_int|0
suffix:semicolon
id|bios_major
op_assign
id|bios_minor
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Use geometry for BIOS version &gt;= 3.4 */
op_increment
id|setup_called
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;fdomain=&quot;
comma
id|fdomain_setup
)paren
suffix:semicolon
DECL|function|do_pause
r_static
r_void
id|do_pause
c_func
(paren
r_int
id|amount
)paren
multiline_comment|/* Pause for amount*10 milliseconds */
(brace
r_do
(brace
id|udelay
c_func
(paren
l_int|10
op_star
l_int|1000
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|amount
)paren
suffix:semicolon
)brace
DECL|function|fdomain_make_bus_idle
r_inline
r_static
r_void
id|fdomain_make_bus_idle
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCSI_Mode_Cntl_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip
op_eq
id|tmc18c50
op_logical_or
id|chip
op_eq
id|tmc18c30
)paren
id|outb
c_func
(paren
l_int|0x21
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Clear forced intr. */
r_else
id|outb
c_func
(paren
l_int|0x01
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
)brace
DECL|function|fdomain_is_valid_port
r_static
r_int
id|fdomain_is_valid_port
c_func
(paren
r_int
id|port
)paren
(brace
macro_line|#if DEBUG_DETECT 
id|printk
c_func
(paren
l_string|&quot; (%x%x),&quot;
comma
id|inb
c_func
(paren
id|port
op_plus
id|MSB_ID_Code
)paren
comma
id|inb
c_func
(paren
id|port
op_plus
id|LSB_ID_Code
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* The MCA ID is a unique id for each MCA compatible board.  We&n;      are using ISA boards, but Future Domain provides the MCA ID&n;      anyway.  We can use this ID to ensure that this is a Future&n;      Domain TMC-1660/TMC-1680.&n;    */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
id|LSB_ID_Code
)paren
op_ne
l_int|0xe9
)paren
(brace
multiline_comment|/* test for 0x6127 id */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
id|LSB_ID_Code
)paren
op_ne
l_int|0x27
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
id|MSB_ID_Code
)paren
op_ne
l_int|0x61
)paren
r_return
l_int|0
suffix:semicolon
id|chip
op_assign
id|tmc1800
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* test for 0xe960 id */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
id|MSB_ID_Code
)paren
op_ne
l_int|0x60
)paren
r_return
l_int|0
suffix:semicolon
id|chip
op_assign
id|tmc18c50
suffix:semicolon
multiline_comment|/* Try to toggle 32-bit mode.  This only&n;&t;&t;&t;&t;   works on an 18c30 chip.  (User reports&n;&t;&t;&t;&t;   say this works, so we should switch to&n;&t;&t;&t;&t;   it in the near future.) */
id|outb
c_func
(paren
l_int|0x80
comma
id|port
op_plus
id|IO_Control
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|port
op_plus
id|Configuration2
)paren
op_amp
l_int|0x80
)paren
op_eq
l_int|0x80
)paren
(brace
id|outb
c_func
(paren
l_int|0x00
comma
id|port
op_plus
id|IO_Control
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|port
op_plus
id|Configuration2
)paren
op_amp
l_int|0x80
)paren
op_eq
l_int|0x00
)paren
(brace
id|chip
op_assign
id|tmc18c30
suffix:semicolon
id|FIFO_Size
op_assign
l_int|0x800
suffix:semicolon
multiline_comment|/* 2k FIFO */
)brace
)brace
multiline_comment|/* If that failed, we are an 18c50. */
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|fdomain_test_loopback
r_static
r_int
id|fdomain_test_loopback
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|255
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
id|i
comma
id|port_base
op_plus
id|Write_Loopback
)paren
suffix:semicolon
id|result
op_assign
id|inb
c_func
(paren
id|port_base
op_plus
id|Read_Loopback
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|result
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* fdomain_get_irq assumes that we have a valid MCA ID for a&n;   TMC-1660/TMC-1680 Future Domain board.  Now, check to be sure the&n;   bios_base matches these ports.  If someone was unlucky enough to have&n;   purchased more than one Future Domain board, then they will have to&n;   modify this code, as we only detect one board here.  [The one with the&n;   lowest bios_base.]&n;&n;   Note that this routine is only used for systems without a PCI BIOS32&n;   (e.g., ISA bus).  For PCI bus systems, this routine will likely fail&n;   unless one of the IRQs listed in the ints array is used by the board.&n;   Sometimes it is possible to use the computer&squot;s BIOS setup screen to&n;   configure a PCI system so that one of these IRQs will be used by the&n;   Future Domain card. */
DECL|function|fdomain_get_irq
r_static
r_int
id|fdomain_get_irq
c_func
(paren
r_int
id|base
)paren
(brace
r_int
id|options
op_assign
id|inb
c_func
(paren
id|base
op_plus
id|Configuration1
)paren
suffix:semicolon
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; Options = %x&bslash;n&quot;
comma
id|options
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check for board with lowest bios_base --&n;&t;&t;&t;&t;   this isn&squot;t valid for the 18c30 or for&n;&t;&t;&t;&t;   boards on the PCI bus, so just assume we&n;&t;&t;&t;&t;   have the right board. */
r_if
c_cond
(paren
id|chip
op_ne
id|tmc18c30
op_logical_and
op_logical_neg
id|PCI_bus
op_logical_and
id|addresses
(braket
(paren
id|options
op_amp
l_int|0xc0
)paren
op_rshift
l_int|6
)braket
op_ne
id|bios_base
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|ints
(braket
(paren
id|options
op_amp
l_int|0x0e
)paren
op_rshift
l_int|1
)braket
suffix:semicolon
)brace
DECL|function|fdomain_isa_detect
r_static
r_int
id|fdomain_isa_detect
c_func
(paren
r_int
op_star
id|irq
comma
r_int
op_star
id|iobase
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|base
op_assign
l_int|0xdeadbeef
suffix:semicolon
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; fdomain_isa_detect:&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|bios_base
op_logical_and
id|i
OL
id|ADDRESS_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; %lx(%lx),&quot;
comma
id|addresses
(braket
id|i
)braket
comma
id|bios_base
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|bios_base
op_logical_and
id|j
OL
id|SIGNATURE_COUNT
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|isa_check_signature
c_func
(paren
id|addresses
(braket
id|i
)braket
op_plus
id|signatures
(braket
id|j
)braket
dot
id|sig_offset
comma
id|signatures
(braket
id|j
)braket
dot
id|signature
comma
id|signatures
(braket
id|j
)braket
dot
id|sig_length
)paren
)paren
(brace
id|bios_major
op_assign
id|signatures
(braket
id|j
)braket
dot
id|major_bios_version
suffix:semicolon
id|bios_minor
op_assign
id|signatures
(braket
id|j
)braket
dot
id|minor_bios_version
suffix:semicolon
id|PCI_bus
op_assign
(paren
id|signatures
(braket
id|j
)braket
dot
id|flag
op_eq
l_int|1
)paren
suffix:semicolon
id|Quantum
op_assign
(paren
id|signatures
(braket
id|j
)braket
dot
id|flag
OG
l_int|1
)paren
ques
c_cond
id|signatures
(braket
id|j
)braket
dot
id|flag
suffix:colon
l_int|0
suffix:semicolon
id|bios_base
op_assign
id|addresses
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|bios_major
op_eq
l_int|2
)paren
(brace
multiline_comment|/* The TMC-1660/TMC-1680 has a RAM area just after the BIOS ROM.&n;&t; Assuming the ROM is enabled (otherwise we wouldn&squot;t have been&n;&t; able to read the ROM signature :-), then the ROM sets up the&n;&t; RAM area with some magic numbers, such as a list of port&n;&t; base addresses and a list of the disk &quot;geometry&quot; reported to&n;&t; DOS (this geometry has nothing to do with physical geometry).&n;       */
r_switch
c_cond
(paren
id|Quantum
)paren
(brace
r_case
l_int|2
suffix:colon
multiline_comment|/* ISA_200S */
r_case
l_int|3
suffix:colon
multiline_comment|/* ISA_250MG */
id|base
op_assign
id|readb
c_func
(paren
id|bios_base
op_plus
l_int|0x1fa2
)paren
op_plus
(paren
id|readb
c_func
(paren
id|bios_base
op_plus
l_int|0x1fa3
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* ISA_200S (another one) */
id|base
op_assign
id|readb
c_func
(paren
id|bios_base
op_plus
l_int|0x1fa3
)paren
op_plus
(paren
id|readb
c_func
(paren
id|bios_base
op_plus
l_int|0x1fa4
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|base
op_assign
id|readb
c_func
(paren
id|bios_base
op_plus
l_int|0x1fcc
)paren
op_plus
(paren
id|readb
c_func
(paren
id|bios_base
op_plus
l_int|0x1fcd
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; %x,&quot;
comma
id|base
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|flag
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|flag
op_logical_and
id|i
OL
id|PORT_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|base
op_eq
id|ports
(braket
id|i
)braket
)paren
op_increment
id|flag
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flag
op_logical_and
id|fdomain_is_valid_port
c_func
(paren
id|base
)paren
)paren
(brace
op_star
id|irq
op_assign
id|fdomain_get_irq
c_func
(paren
id|base
)paren
suffix:semicolon
op_star
id|iobase
op_assign
id|base
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* This is a bad sign.  It usually means that someone patched the&n;&t; BIOS signature list (the signatures variable) to contain a BIOS&n;&t; signature for a board *OTHER THAN* the TMC-1660/TMC-1680. */
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; RAM FAILED, &quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Anyway, the alternative to finding the address in the RAM is to just&n;      search through every possible port address for one that is attached&n;      to the Future Domain card.  Don&squot;t panic, though, about reading all&n;      these random port addresses -- there are rumors that the Future&n;      Domain BIOS does something very similar.&n;&n;      Do not, however, check ports which the kernel knows are being used by&n;      another driver. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PORT_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|base
op_assign
id|ports
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|base
comma
l_int|0x10
)paren
)paren
(brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; (%x inuse),&quot;
comma
id|base
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
)brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; %x,&quot;
comma
id|base
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|flag
op_assign
id|fdomain_is_valid_port
c_func
(paren
id|base
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
macro_line|#if DEBUG_DETECT
r_if
c_cond
(paren
id|flag
)paren
id|printk
c_func
(paren
l_string|&quot; SUCCESS&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; FAILURE&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* iobase not found */
op_star
id|irq
op_assign
id|fdomain_get_irq
c_func
(paren
id|base
)paren
suffix:semicolon
op_star
id|iobase
op_assign
id|base
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* success */
)brace
multiline_comment|/* PCI detection function: int fdomain_pci_bios_detect(int* irq, int*&n;   iobase) This function gets the Interrupt Level and I/O base address from&n;   the PCI configuration registers. */
macro_line|#ifdef CONFIG_PCI
DECL|function|fdomain_pci_bios_detect
r_static
r_int
id|fdomain_pci_bios_detect
c_func
(paren
r_int
op_star
id|irq
comma
r_int
op_star
id|iobase
)paren
(brace
r_int
r_int
id|pci_irq
suffix:semicolon
multiline_comment|/* PCI interrupt line */
r_int
r_int
id|pci_base
suffix:semicolon
multiline_comment|/* PCI I/O base address */
r_struct
id|pci_dev
op_star
id|pdev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#if DEBUG_DETECT
multiline_comment|/* Tell how to print a list of the known PCI devices from bios32 and&n;      list vendor and device IDs being used if in debug mode.  */
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; INFO: use lspci -v to see list of PCI devices&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; TMC-3260 detect:&quot;
l_string|&quot; Using Vendor ID: 0x%x and Device ID: 0x%x&bslash;n&quot;
comma
id|PCI_VENDOR_ID_FD
comma
id|PCI_DEVICE_ID_FD_36C70
)paren
suffix:semicolon
macro_line|#endif 
r_if
c_cond
(paren
(paren
id|pdev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_FD
comma
id|PCI_DEVICE_ID_FD_36C70
comma
id|pdev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pdev
)paren
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; TMC-3260 detect:&quot;
l_string|&quot; PCI bus %u, device %u, function %u&bslash;n&quot;
comma
id|pdev-&gt;bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|pdev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|pdev-&gt;devfn
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* We now have the appropriate device function for the FD board so we&n;      just read the PCI config info from the registers.  */
id|pci_base
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|pci_irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
multiline_comment|/* Now we have the I/O base address and interrupt from the PCI&n;      configuration registers. */
op_star
id|irq
op_assign
id|pci_irq
suffix:semicolon
op_star
id|iobase
op_assign
id|pci_base
suffix:semicolon
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; TMC-3260 detect:&quot;
l_string|&quot; IRQ = %d, I/O base = 0x%x [0x%lx]&bslash;n&quot;
comma
op_star
id|irq
comma
op_star
id|iobase
comma
id|pci_base
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|fdomain_is_valid_port
c_func
(paren
op_star
id|iobase
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt;&quot;
l_string|&quot; PCI card detected, but driver not loaded (invalid port)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Fill in a few global variables.  Ugh. */
id|bios_major
op_assign
id|bios_minor
op_assign
op_minus
l_int|1
suffix:semicolon
id|PCI_bus
op_assign
l_int|1
suffix:semicolon
id|Quantum
op_assign
l_int|0
suffix:semicolon
id|bios_base
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
DECL|function|fdomain_16x0_detect
r_int
id|fdomain_16x0_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|retcode
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
macro_line|#if DO_DETECT
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|j
op_assign
l_int|0
suffix:semicolon
r_const
r_int
id|buflen
op_assign
l_int|255
suffix:semicolon
id|Scsi_Cmnd
id|SCinit
suffix:semicolon
r_int
r_char
id|do_inquiry
(braket
)braket
op_assign
(brace
id|INQUIRY
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|buflen
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|do_request_sense
(braket
)braket
op_assign
(brace
id|REQUEST_SENSE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|buflen
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|do_read_capacity
(braket
)braket
op_assign
(brace
id|READ_CAPACITY
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|buf
(braket
id|buflen
)braket
suffix:semicolon
macro_line|#endif
id|tpnt-&gt;proc_name
op_assign
l_string|&quot;fdomain&quot;
suffix:semicolon
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|fdomain
)paren
id|fdomain_setup
c_func
(paren
id|fdomain
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|setup_called
)paren
(brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; No BIOS, using port_base = 0x%x, irq = %d&bslash;n&quot;
comma
id|port_base
comma
id|interrupt_level
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|fdomain_is_valid_port
c_func
(paren
id|port_base
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; Cannot locate chip at port base 0x%x&bslash;n&quot;
comma
id|port_base
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; Bad LILO/INSMOD parameters?&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
multiline_comment|/* Try PCI detection first */
id|flag
op_assign
id|fdomain_pci_bios_detect
c_func
(paren
op_amp
id|interrupt_level
comma
op_amp
id|port_base
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
multiline_comment|/* Then try ISA bus detection */
id|flag
op_assign
id|fdomain_isa_detect
c_func
(paren
op_amp
id|interrupt_level
comma
op_amp
id|port_base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; Detection failed (no card)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|SCSI_Mode_Cntl_port
op_assign
id|port_base
op_plus
id|SCSI_Mode_Cntl
suffix:semicolon
id|FIFO_Data_Count_port
op_assign
id|port_base
op_plus
id|FIFO_Data_Count
suffix:semicolon
id|Interrupt_Cntl_port
op_assign
id|port_base
op_plus
id|Interrupt_Cntl
suffix:semicolon
id|Interrupt_Status_port
op_assign
id|port_base
op_plus
id|Interrupt_Status
suffix:semicolon
id|Read_FIFO_port
op_assign
id|port_base
op_plus
id|Read_FIFO
suffix:semicolon
id|Read_SCSI_Data_port
op_assign
id|port_base
op_plus
id|Read_SCSI_Data
suffix:semicolon
id|SCSI_Cntl_port
op_assign
id|port_base
op_plus
id|SCSI_Cntl
suffix:semicolon
id|SCSI_Data_NoACK_port
op_assign
id|port_base
op_plus
id|SCSI_Data_NoACK
suffix:semicolon
id|SCSI_Status_port
op_assign
id|port_base
op_plus
id|SCSI_Status
suffix:semicolon
id|TMC_Cntl_port
op_assign
id|port_base
op_plus
id|TMC_Cntl
suffix:semicolon
id|TMC_Status_port
op_assign
id|port_base
op_plus
id|TMC_Status
suffix:semicolon
id|Write_FIFO_port
op_assign
id|port_base
op_plus
id|Write_FIFO
suffix:semicolon
id|Write_SCSI_Data_port
op_assign
id|port_base
op_plus
id|Write_SCSI_Data
suffix:semicolon
id|fdomain_16x0_reset
c_func
(paren
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdomain_test_loopback
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; Detection failed&quot;
l_string|&quot; (loopback test failed at port base 0x%x)&bslash;n&quot;
comma
id|port_base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|setup_called
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; Bad LILO/INSMOD parameters?&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|this_id
)paren
(brace
id|tpnt-&gt;this_id
op_assign
(paren
id|this_id
op_amp
l_int|0x07
)paren
suffix:semicolon
id|adapter_mask
op_assign
(paren
l_int|1
op_lshift
id|tpnt-&gt;this_id
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|PCI_bus
op_logical_or
(paren
id|bios_major
op_eq
l_int|3
op_logical_and
id|bios_minor
op_ge
l_int|2
)paren
op_logical_or
id|bios_major
OL
l_int|0
)paren
(brace
id|tpnt-&gt;this_id
op_assign
l_int|7
suffix:semicolon
id|adapter_mask
op_assign
l_int|0x80
suffix:semicolon
)brace
r_else
(brace
id|tpnt-&gt;this_id
op_assign
l_int|6
suffix:semicolon
id|adapter_mask
op_assign
l_int|0x40
suffix:semicolon
)brace
)brace
multiline_comment|/* Print out a banner here in case we can&squot;t&n;&t;&t;&t;&t;   get resources.  */
id|shpnt
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shpnt
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|shpnt-&gt;irq
op_assign
id|interrupt_level
suffix:semicolon
id|shpnt-&gt;io_port
op_assign
id|port_base
suffix:semicolon
id|shpnt-&gt;n_io_port
op_assign
l_int|0x10
suffix:semicolon
id|print_banner
c_func
(paren
id|shpnt
)paren
suffix:semicolon
multiline_comment|/* Log IRQ with kernel */
r_if
c_cond
(paren
op_logical_neg
id|interrupt_level
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt;&quot;
l_string|&quot; Card Detected, but driver not loaded (no IRQ)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Register the IRQ with the kernel */
id|retcode
op_assign
id|request_irq
c_func
(paren
id|interrupt_level
comma
id|do_fdomain_16x0_intr
comma
l_int|0
comma
l_string|&quot;fdomain&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retcode
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|retcode
op_eq
op_minus
id|EINVAL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; IRQ %d is bad!&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                This shouldn&squot;t happen!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                Send mail to faith@acm.org&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|retcode
op_eq
op_minus
id|EBUSY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; IRQ %d is already in use!&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                Please use another IRQ!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; Error getting IRQ %d&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                This shouldn&squot;t happen!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                Send mail to faith@acm.org&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; Detected, but driver not loaded (IRQ)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Log I/O ports with kernel */
id|request_region
c_func
(paren
id|port_base
comma
l_int|0x10
comma
l_string|&quot;fdomain&quot;
)paren
suffix:semicolon
macro_line|#if DO_DETECT
multiline_comment|/* These routines are here because of the way the SCSI bus behaves after&n;      a reset.  This appropriate behavior was not handled correctly by the&n;      higher level SCSI routines when I first wrote this driver.  Now,&n;      however, correct scan routines are part of scsi.c and these routines&n;      are no longer needed.  However, this code is still good for&n;      debugging.  */
id|SCinit.request_buffer
op_assign
id|SCinit.buffer
op_assign
id|buf
suffix:semicolon
id|SCinit.request_bufflen
op_assign
id|SCinit.bufflen
op_assign
r_sizeof
(paren
id|buf
)paren
op_minus
l_int|1
suffix:semicolon
id|SCinit.use_sg
op_assign
l_int|0
suffix:semicolon
id|SCinit.lun
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; detection routine scanning for devices:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|SCinit.target
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|tpnt-&gt;this_id
)paren
multiline_comment|/* Skip host adapter */
r_continue
suffix:semicolon
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_request_sense
comma
r_sizeof
(paren
id|do_request_sense
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
(brace
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_inquiry
comma
r_sizeof
(paren
id|do_inquiry
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;     SCSI ID %d: &quot;
comma
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|8
suffix:semicolon
id|j
OL
(paren
id|buf
(braket
l_int|4
)braket
OL
l_int|32
ques
c_cond
id|buf
(braket
l_int|4
)braket
suffix:colon
l_int|32
)paren
suffix:semicolon
id|j
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|buf
(braket
id|j
)braket
op_ge
l_int|20
ques
c_cond
id|buf
(braket
id|j
)braket
suffix:colon
l_char|&squot; &squot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_read_capacity
comma
r_sizeof
(paren
id|do_read_capacity
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
(brace
r_int
r_int
id|blocks
comma
id|size
comma
id|capacity
suffix:semicolon
id|blocks
op_assign
(paren
id|buf
(braket
l_int|0
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buf
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buf
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
id|buf
(braket
l_int|3
)braket
suffix:semicolon
id|size
op_assign
(paren
id|buf
(braket
l_int|4
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buf
(braket
l_int|5
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buf
(braket
l_int|6
)braket
op_lshift
l_int|8
)paren
op_or
id|buf
(braket
l_int|7
)braket
suffix:semicolon
id|capacity
op_assign
op_plus
(paren
op_plus
(paren
id|blocks
op_div
l_int|1024L
)paren
op_star
op_plus
(paren
id|size
op_star
l_int|10L
)paren
)paren
op_div
l_int|1024L
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%lu MB (%lu byte blocks)&quot;
comma
(paren
(paren
id|capacity
op_plus
l_int|5L
)paren
op_div
l_int|10L
)paren
comma
id|size
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_request_sense
comma
r_sizeof
(paren
id|do_request_sense
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_request_sense
comma
r_sizeof
(paren
id|do_request_sense
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Maximum of one adapter will be detected. */
)brace
DECL|function|fdomain_16x0_info
r_const
r_char
op_star
id|fdomain_16x0_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|ignore
)paren
(brace
r_static
r_char
id|buffer
(braket
l_int|128
)braket
suffix:semicolon
r_char
op_star
id|pt
suffix:semicolon
id|strcpy
c_func
(paren
id|buffer
comma
l_string|&quot;Future Domain 16-bit SCSI Driver Version&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|VERSION
comma
l_char|&squot;:&squot;
)paren
)paren
(brace
multiline_comment|/* Assume VERSION is an RCS Revision string */
id|strcat
c_func
(paren
id|buffer
comma
id|strchr
c_func
(paren
id|VERSION
comma
l_char|&squot;:&squot;
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|pt
op_assign
id|strrchr
c_func
(paren
id|buffer
comma
l_char|&squot;$&squot;
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pt
)paren
multiline_comment|/* Stripped RCS Revision string? */
id|pt
op_assign
id|buffer
op_plus
id|strlen
c_func
(paren
id|buffer
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pt
op_ne
l_char|&squot; &squot;
)paren
op_increment
id|pt
suffix:semicolon
op_star
id|pt
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Assume VERSION is a number */
id|strcat
c_func
(paren
id|buffer
comma
l_string|&quot; &quot;
id|VERSION
)paren
suffix:semicolon
)brace
r_return
id|buffer
suffix:semicolon
)brace
multiline_comment|/* First pass at /proc information routine. */
multiline_comment|/*&n; * inout : decides on the direction of the dataflow and the meaning of the &n; *         variables&n; * buffer: If inout==FALSE data is being written to it else read from it&n; * *start: If inout==FALSE start of the valid data in the buffer&n; * offset: If inout==FALSE offset from the beginning of the imaginary file &n; *         from which we start writing into the buffer&n; * length: If inout==FALSE max number of bytes to be written into the buffer &n; *         else number of bytes in the buffer&n; */
DECL|function|fdomain_16x0_proc_info
r_int
id|fdomain_16x0_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
r_const
r_char
op_star
id|info
op_assign
id|fdomain_16x0_info
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|pos
suffix:semicolon
r_int
id|begin
suffix:semicolon
r_if
c_cond
(paren
id|inout
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
id|begin
op_assign
l_int|0
suffix:semicolon
id|strcpy
c_func
(paren
id|buffer
comma
id|info
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|buffer
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_assign
id|len
op_assign
id|strlen
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_int
id|fdomain_arbitrate
c_func
(paren
r_void
)paren
(brace
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;fdomain_arbitrate()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
l_int|0x00
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Disable data drivers */
id|outb
c_func
(paren
id|adapter_mask
comma
id|port_base
op_plus
id|SCSI_Data_NoACK
)paren
suffix:semicolon
multiline_comment|/* Set our id bit */
id|outb
c_func
(paren
l_int|0x04
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Start arbitration */
id|timeout
op_assign
l_int|500
suffix:semicolon
r_do
(brace
id|status
op_assign
id|inb
c_func
(paren
id|TMC_Status_port
)paren
suffix:semicolon
multiline_comment|/* Read adapter status */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x02
)paren
multiline_comment|/* Arbitration complete */
r_return
l_int|0
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Wait one millisecond */
)brace
r_while
c_loop
(paren
op_decrement
id|timeout
)paren
suffix:semicolon
multiline_comment|/* Make bus idle */
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Arbitration failed, status = %x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; Arbitration failed, status = %x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
DECL|function|fdomain_select
r_static
r_int
id|fdomain_select
c_func
(paren
r_int
id|target
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_static
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|0x82
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Bus Enable + Select */
id|outb
c_func
(paren
id|adapter_mask
op_or
(paren
l_int|1
op_lshift
id|target
)paren
comma
id|SCSI_Data_NoACK_port
)paren
suffix:semicolon
multiline_comment|/* Stop arbitration and enable parity */
id|outb
c_func
(paren
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
id|timeout
op_assign
l_int|350
suffix:semicolon
multiline_comment|/* 350 msec */
r_do
(brace
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
suffix:semicolon
multiline_comment|/* Read adapter status */
r_if
c_cond
(paren
id|status
op_amp
l_int|1
)paren
(brace
multiline_comment|/* Busy asserted */
multiline_comment|/* Enable SCSI Bus (on error, should make bus idle with 0) */
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* wait one msec */
)brace
r_while
c_loop
(paren
op_decrement
id|timeout
)paren
suffix:semicolon
multiline_comment|/* Make bus idle */
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
r_if
c_cond
(paren
op_logical_neg
id|target
)paren
id|printk
c_func
(paren
l_string|&quot;Selection failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
op_logical_neg
id|target
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
multiline_comment|/* Skip first failure for all chips. */
op_increment
id|flag
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; Selection failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|my_done
r_void
id|my_done
c_func
(paren
r_int
id|error
)paren
(brace
r_if
c_cond
(paren
id|in_command
)paren
(brace
id|in_command
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
id|current_SC-&gt;result
op_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
id|current_SC-&gt;scsi_done
)paren
id|current_SC
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|current_SC
)paren
suffix:semicolon
r_else
id|panic
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; current_SC-&gt;scsi_done() == NULL&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|panic
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; my_done() called outside of command&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if DEBUG_RACE
id|in_interrupt_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
DECL|function|do_fdomain_16x0_intr
r_void
id|do_fdomain_16x0_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
id|data_count
suffix:semicolon
multiline_comment|/* The fdomain_16x0_intr is only called via&n;&t;&t;&t;&t;   the interrupt handler.  The goal of the&n;&t;&t;&t;&t;   sti() here is to allow other&n;&t;&t;&t;&t;   interruptions while this routine is&n;&t;&t;&t;&t;   running. */
multiline_comment|/* sti();&t;&t;&t; Yes, we really want sti() here if we want to lock up our machine */
id|outb
c_func
(paren
l_int|0x00
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* We usually have one spurious interrupt after each command.  Ignore it. */
r_if
c_cond
(paren
op_logical_neg
id|in_command
op_logical_or
op_logical_neg
id|current_SC
)paren
(brace
multiline_comment|/* Spurious interrupt */
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Spurious interrupt, in_command = %d, current_SC = %x&bslash;n&quot;
comma
id|in_command
comma
id|current_SC
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* Abort calls my_done, so we do nothing here. */
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|aborted
)paren
(brace
macro_line|#if DEBUG_ABORT
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; Interrupt after abort, ignoring&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;      return; */
)brace
macro_line|#if DEBUG_RACE
op_increment
id|in_interrupt_flag
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|in_arbitration
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|TMC_Status_port
)paren
suffix:semicolon
multiline_comment|/* Read adapter status */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
l_int|0x02
)paren
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; AFAIL &quot;
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|my_done
c_func
(paren
id|DID_BUS_BUSY
op_lshift
l_int|16
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|current_SC-&gt;SCp.phase
op_assign
id|in_selection
suffix:semicolon
id|outb
c_func
(paren
l_int|0x40
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x82
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Bus Enable + Select */
id|outb
c_func
(paren
id|adapter_mask
op_or
(paren
l_int|1
op_lshift
id|current_SC-&gt;target
)paren
comma
id|SCSI_Data_NoACK_port
)paren
suffix:semicolon
multiline_comment|/* Stop arbitration and enable parity */
id|outb
c_func
(paren
l_int|0x10
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
macro_line|#if DEBUG_RACE
id|in_interrupt_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|in_selection
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
l_int|0x01
)paren
)paren
(brace
multiline_comment|/* Try again, for slow devices */
r_if
c_cond
(paren
id|fdomain_select
c_func
(paren
id|current_SC-&gt;target
)paren
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; SFAIL &quot;
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|my_done
c_func
(paren
id|DID_NO_CONNECT
op_lshift
l_int|16
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; AltSel &quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Stop arbitration and enable parity */
id|outb
c_func
(paren
l_int|0x10
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
)brace
)brace
id|current_SC-&gt;SCp.phase
op_assign
id|in_other
suffix:semicolon
id|outb
c_func
(paren
l_int|0x90
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
macro_line|#if DEBUG_RACE
id|in_interrupt_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* current_SC-&gt;SCp.phase == in_other: this is the body of the routine */
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* REQ */
r_switch
c_cond
(paren
id|status
op_amp
l_int|0x0e
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/* COMMAND OUT */
id|outb
c_func
(paren
id|current_SC-&gt;cmnd
(braket
id|current_SC-&gt;SCp.sent_command
op_increment
)braket
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;CMD = %x,&quot;
comma
id|current_SC-&gt;cmnd
(braket
id|current_SC-&gt;SCp.sent_command
op_minus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x00
suffix:colon
multiline_comment|/* DATA OUT -- tmc18c50/tmc18c30 only */
r_if
c_cond
(paren
id|chip
op_ne
id|tmc1800
op_logical_and
op_logical_neg
id|current_SC-&gt;SCp.have_data_in
)paren
(brace
id|current_SC-&gt;SCp.have_data_in
op_assign
op_minus
l_int|1
suffix:semicolon
id|outb
c_func
(paren
l_int|0xd0
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x04
suffix:colon
multiline_comment|/* DATA IN -- tmc18c50/tmc18c30 only */
r_if
c_cond
(paren
id|chip
op_ne
id|tmc1800
op_logical_and
op_logical_neg
id|current_SC-&gt;SCp.have_data_in
)paren
(brace
id|current_SC-&gt;SCp.have_data_in
op_assign
l_int|1
suffix:semicolon
id|outb
c_func
(paren
l_int|0x90
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x0c
suffix:colon
multiline_comment|/* STATUS IN */
id|current_SC-&gt;SCp.Status
op_assign
id|inb
c_func
(paren
id|Read_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Status = %x, &quot;
comma
id|current_SC-&gt;SCp.Status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
id|current_SC-&gt;SCp.Status
op_logical_and
id|current_SC-&gt;SCp.Status
op_ne
l_int|2
op_logical_and
id|current_SC-&gt;SCp.Status
op_ne
l_int|8
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; target = %d, command = %x, status = %x&bslash;n&quot;
comma
id|current_SC-&gt;target
comma
id|current_SC-&gt;cmnd
(braket
l_int|0
)braket
comma
id|current_SC-&gt;SCp.Status
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0a
suffix:colon
multiline_comment|/* MESSAGE OUT */
id|outb
c_func
(paren
id|MESSAGE_REJECT
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
multiline_comment|/* Reject */
r_break
suffix:semicolon
r_case
l_int|0x0e
suffix:colon
multiline_comment|/* MESSAGE IN */
id|current_SC-&gt;SCp.Message
op_assign
id|inb
c_func
(paren
id|Read_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Message = %x, &quot;
comma
id|current_SC-&gt;SCp.Message
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.Message
)paren
op_increment
id|done
suffix:semicolon
macro_line|#if DEBUG_MESSAGES || EVERY_ACCESS
r_if
c_cond
(paren
id|current_SC-&gt;SCp.Message
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; message = %x&bslash;n&quot;
comma
id|current_SC-&gt;SCp.Message
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|chip
op_eq
id|tmc1800
op_logical_and
op_logical_neg
id|current_SC-&gt;SCp.have_data_in
op_logical_and
(paren
id|current_SC-&gt;SCp.sent_command
op_ge
id|current_SC-&gt;cmd_len
)paren
)paren
(brace
multiline_comment|/* We have to get the FIFO direction&n;&t;&t;&t;&t;   correct, so I&squot;ve made a table based&n;&t;&t;&t;&t;   on the SCSI Standard of which commands&n;&t;&t;&t;&t;   appear to require a DATA OUT phase.&n;&t;&t;&t;&t; */
multiline_comment|/*&n;&t;p. 94: Command for all device types&n;&t;CHANGE DEFINITION            40 DATA OUT&n;&t;COMPARE                      39 DATA OUT&n;&t;COPY                         18 DATA OUT&n;&t;COPY AND VERIFY              3a DATA OUT&n;&t;INQUIRY                      12 &n;&t;LOG SELECT                   4c DATA OUT&n;&t;LOG SENSE                    4d&n;&t;MODE SELECT (6)              15 DATA OUT&n;&t;MODE SELECT (10)             55 DATA OUT&n;&t;MODE SENSE (6)               1a&n;&t;MODE SENSE (10)              5a&n;&t;READ BUFFER                  3c&n;&t;RECEIVE DIAGNOSTIC RESULTS   1c&n;&t;REQUEST SENSE                03&n;&t;SEND DIAGNOSTIC              1d DATA OUT&n;&t;TEST UNIT READY              00&n;&t;WRITE BUFFER                 3b DATA OUT&n;&n;&t;p.178: Commands for direct-access devices (not listed on p. 94)&n;&t;FORMAT UNIT                  04 DATA OUT&n;&t;LOCK-UNLOCK CACHE            36&n;&t;PRE-FETCH                    34&n;&t;PREVENT-ALLOW MEDIUM REMOVAL 1e&n;&t;READ (6)/RECEIVE             08&n;&t;READ (10)                    3c&n;&t;READ CAPACITY                25&n;&t;READ DEFECT DATA (10)        37&n;&t;READ LONG                    3e&n;&t;REASSIGN BLOCKS              07 DATA OUT&n;&t;RELEASE                      17&n;&t;RESERVE                      16 DATA OUT&n;&t;REZERO UNIT/REWIND           01&n;&t;SEARCH DATA EQUAL (10)       31 DATA OUT&n;&t;SEARCH DATA HIGH (10)        30 DATA OUT&n;&t;SEARCH DATA LOW (10)         32 DATA OUT&n;&t;SEEK (6)                     0b&n;&t;SEEK (10)                    2b&n;&t;SET LIMITS (10)              33&n;&t;START STOP UNIT              1b&n;&t;SYNCHRONIZE CACHE            35&n;&t;VERIFY (10)                  2f&n;&t;WRITE (6)/PRINT/SEND         0a DATA OUT&n;&t;WRITE (10)/SEND              2a DATA OUT&n;&t;WRITE AND VERIFY (10)        2e DATA OUT&n;&t;WRITE LONG                   3f DATA OUT&n;&t;WRITE SAME                   41 DATA OUT ?&n;&n;&t;p. 261: Commands for sequential-access devices (not previously listed)&n;&t;ERASE                        19&n;&t;LOAD UNLOAD                  1b&n;&t;LOCATE                       2b&n;&t;READ BLOCK LIMITS            05&n;&t;READ POSITION                34&n;&t;READ REVERSE                 0f&n;&t;RECOVER BUFFERED DATA        14&n;&t;SPACE                        11&n;&t;WRITE FILEMARKS              10 ?&n;&n;&t;p. 298: Commands for printer devices (not previously listed)&n;&t;****** NOT SUPPORTED BY THIS DRIVER, since 0b is SEEK (6) *****&n;&t;SLEW AND PRINT               0b DATA OUT  -- same as seek&n;&t;STOP PRINT                   1b&n;&t;SYNCHRONIZE BUFFER           10&n;&n;&t;p. 315: Commands for processor devices (not previously listed)&n;&t;&n;&t;p. 321: Commands for write-once devices (not previously listed)&n;&t;MEDIUM SCAN                  38&n;&t;READ (12)                    a8&n;&t;SEARCH DATA EQUAL (12)       b1 DATA OUT&n;&t;SEARCH DATA HIGH (12)        b0 DATA OUT&n;&t;SEARCH DATA LOW (12)         b2 DATA OUT&n;&t;SET LIMITS (12)              b3&n;&t;VERIFY (12)                  af&n;&t;WRITE (12)                   aa DATA OUT&n;&t;WRITE AND VERIFY (12)        ae DATA OUT&n;&n;&t;p. 332: Commands for CD-ROM devices (not previously listed)&n;&t;PAUSE/RESUME                 4b&n;&t;PLAY AUDIO (10)              45&n;&t;PLAY AUDIO (12)              a5&n;&t;PLAY AUDIO MSF               47&n;&t;PLAY TRACK RELATIVE (10)     49&n;&t;PLAY TRACK RELATIVE (12)     a9&n;&t;READ HEADER                  44&n;&t;READ SUB-CHANNEL             42&n;&t;READ TOC                     43&n;&n;&t;p. 370: Commands for scanner devices (not previously listed)&n;&t;GET DATA BUFFER STATUS       34&n;&t;GET WINDOW                   25&n;&t;OBJECT POSITION              31&n;&t;SCAN                         1b&n;&t;SET WINDOW                   24 DATA OUT&n;&n;&t;p. 391: Commands for optical memory devices (not listed)&n;&t;ERASE (10)                   2c&n;&t;ERASE (12)                   ac&n;&t;MEDIUM SCAN                  38 DATA OUT&n;&t;READ DEFECT DATA (12)        b7&n;&t;READ GENERATION              29&n;&t;READ UPDATED BLOCK           2d&n;&t;UPDATE BLOCK                 3d DATA OUT&n;&n;&t;p. 419: Commands for medium changer devices (not listed)&n;&t;EXCHANGE MEDIUM              46&n;&t;INITIALIZE ELEMENT STATUS    07&n;&t;MOVE MEDIUM                  a5&n;&t;POSITION TO ELEMENT          2b&n;&t;READ ELEMENT STATUS          b8&n;&t;REQUEST VOL. ELEMENT ADDRESS b5&n;&t;SEND VOLUME TAG              b6 DATA OUT&n;&n;&t;p. 454: Commands for communications devices (not listed previously)&n;&t;GET MESSAGE (6)              08&n;&t;GET MESSAGE (10)             28&n;&t;GET MESSAGE (12)             a8&n;      */
r_switch
c_cond
(paren
id|current_SC-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|CHANGE_DEFINITION
suffix:colon
r_case
id|COMPARE
suffix:colon
r_case
id|COPY
suffix:colon
r_case
id|COPY_VERIFY
suffix:colon
r_case
id|LOG_SELECT
suffix:colon
r_case
id|MODE_SELECT
suffix:colon
r_case
id|MODE_SELECT_10
suffix:colon
r_case
id|SEND_DIAGNOSTIC
suffix:colon
r_case
id|WRITE_BUFFER
suffix:colon
r_case
id|FORMAT_UNIT
suffix:colon
r_case
id|REASSIGN_BLOCKS
suffix:colon
r_case
id|RESERVE
suffix:colon
r_case
id|SEARCH_EQUAL
suffix:colon
r_case
id|SEARCH_HIGH
suffix:colon
r_case
id|SEARCH_LOW
suffix:colon
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
r_case
id|WRITE_VERIFY
suffix:colon
r_case
l_int|0x3f
suffix:colon
r_case
l_int|0x41
suffix:colon
r_case
l_int|0xb1
suffix:colon
r_case
l_int|0xb0
suffix:colon
r_case
l_int|0xb2
suffix:colon
r_case
l_int|0xaa
suffix:colon
r_case
l_int|0xae
suffix:colon
r_case
l_int|0x24
suffix:colon
r_case
l_int|0x38
suffix:colon
r_case
l_int|0x3d
suffix:colon
r_case
l_int|0xb6
suffix:colon
r_case
l_int|0xea
suffix:colon
multiline_comment|/* alternate number for WRITE LONG */
id|current_SC-&gt;SCp.have_data_in
op_assign
op_minus
l_int|1
suffix:semicolon
id|outb
c_func
(paren
l_int|0xd0
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x00
suffix:colon
r_default
suffix:colon
id|current_SC-&gt;SCp.have_data_in
op_assign
l_int|1
suffix:semicolon
id|outb
c_func
(paren
l_int|0x90
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|current_SC-&gt;SCp.have_data_in
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* DATA OUT */
r_while
c_loop
(paren
(paren
id|data_count
op_assign
id|FIFO_Size
op_minus
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
)paren
OG
l_int|512
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;DC=%d, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
OG
id|current_SC-&gt;SCp.this_residual
)paren
id|data_count
op_assign
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
r_if
c_cond
(paren
id|data_count
OG
l_int|0
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;%d OUT, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
id|outb
c_func
(paren
op_star
id|current_SC-&gt;SCp.ptr
op_increment
comma
id|Write_FIFO_port
)paren
suffix:semicolon
op_decrement
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
id|outsw
c_func
(paren
id|Write_FIFO_port
comma
id|current_SC-&gt;SCp.ptr
comma
id|data_count
)paren
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_sub_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.this_residual
)paren
(brace
r_if
c_cond
(paren
id|current_SC-&gt;SCp.buffers_residual
)paren
(brace
op_decrement
id|current_SC-&gt;SCp.buffers_residual
suffix:semicolon
op_increment
id|current_SC-&gt;SCp.buffer
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|current_SC-&gt;SCp.have_data_in
op_eq
l_int|1
)paren
(brace
multiline_comment|/* DATA IN */
r_while
c_loop
(paren
(paren
id|data_count
op_assign
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
)paren
OG
l_int|0
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;DC=%d, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
OG
id|current_SC-&gt;SCp.this_residual
)paren
id|data_count
op_assign
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
r_if
c_cond
(paren
id|data_count
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;%d IN, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
op_star
id|current_SC-&gt;SCp.ptr
op_increment
op_assign
id|inb
c_func
(paren
id|Read_FIFO_port
)paren
suffix:semicolon
op_decrement
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Number of words */
id|insw
c_func
(paren
id|Read_FIFO_port
comma
id|current_SC-&gt;SCp.ptr
comma
id|data_count
)paren
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_sub_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.this_residual
op_logical_and
id|current_SC-&gt;SCp.buffers_residual
)paren
(brace
op_decrement
id|current_SC-&gt;SCp.buffers_residual
suffix:semicolon
op_increment
id|current_SC-&gt;SCp.buffer
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|done
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; ** IN DONE %d ** &quot;
comma
id|current_SC-&gt;SCp.have_data_in
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
id|current_SC-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
op_logical_neg
id|current_SC-&gt;SCp.Status
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|current_SC-&gt;request_buffer
op_plus
l_int|2
)paren
)paren
op_amp
l_int|0x0f
)paren
(brace
r_int
r_char
id|key
suffix:semicolon
r_int
r_char
id|code
suffix:semicolon
r_int
r_char
id|qualifier
suffix:semicolon
id|key
op_assign
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|current_SC-&gt;request_buffer
op_plus
l_int|2
)paren
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|code
op_assign
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|current_SC-&gt;request_buffer
op_plus
l_int|12
)paren
)paren
suffix:semicolon
id|qualifier
op_assign
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|current_SC-&gt;request_buffer
op_plus
l_int|13
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|key
op_ne
id|UNIT_ATTENTION
op_logical_and
op_logical_neg
(paren
id|key
op_eq
id|NOT_READY
op_logical_and
id|code
op_eq
l_int|0x04
op_logical_and
(paren
op_logical_neg
id|qualifier
op_logical_or
id|qualifier
op_eq
l_int|0x02
op_logical_or
id|qualifier
op_eq
l_int|0x01
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
(paren
id|code
op_eq
l_int|0x25
op_logical_or
id|code
op_eq
l_int|0x24
op_logical_or
op_logical_neg
id|code
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; REQUEST SENSE&quot;
l_string|&quot; Key = %x, Code = %x, Qualifier = %x&bslash;n&quot;
comma
id|key
comma
id|code
comma
id|qualifier
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;BEFORE MY_DONE. . .&quot;
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|my_done
c_func
(paren
(paren
id|current_SC-&gt;SCp.Status
op_amp
l_int|0xff
)paren
op_or
(paren
(paren
id|current_SC-&gt;SCp.Message
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|DID_OK
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;RETURNING.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|disconnect
)paren
(brace
id|outb
c_func
(paren
l_int|0xd0
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
l_int|0x90
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
)brace
)brace
macro_line|#if DEBUG_RACE
id|in_interrupt_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|function|fdomain_16x0_queue
r_int
id|fdomain_16x0_queue
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_if
c_cond
(paren
id|in_command
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; fdomain_16x0_queue() NOT REENTRANT!&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;queue: target = %d cmnd = 0x%02x pieces = %d size = %u&bslash;n&quot;
comma
id|SCpnt-&gt;target
comma
op_star
(paren
r_int
r_char
op_star
)paren
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
macro_line|#endif
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
id|current_SC
op_assign
id|SCpnt
suffix:semicolon
multiline_comment|/* Save this for the done function */
id|current_SC-&gt;scsi_done
op_assign
id|done
suffix:semicolon
multiline_comment|/* Initialize static data */
r_if
c_cond
(paren
id|current_SC-&gt;use_sg
)paren
(brace
id|current_SC-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|current_SC-&gt;request_buffer
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|current_SC-&gt;SCp.buffers_residual
op_assign
id|current_SC-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|current_SC-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|current_SC-&gt;request_buffer
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;request_bufflen
suffix:semicolon
id|current_SC-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|current_SC-&gt;SCp.buffers_residual
op_assign
l_int|0
suffix:semicolon
)brace
id|current_SC-&gt;SCp.Status
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.Message
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.have_data_in
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.sent_command
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_assign
id|in_arbitration
suffix:semicolon
multiline_comment|/* Start arbitration */
id|outb
c_func
(paren
l_int|0x00
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Disable data drivers */
id|outb
c_func
(paren
id|adapter_mask
comma
id|SCSI_Data_NoACK_port
)paren
suffix:semicolon
multiline_comment|/* Set our id bit */
op_increment
id|in_command
suffix:semicolon
id|outb
c_func
(paren
l_int|0x20
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x14
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Start arbitration */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The following code, which simulates the old-style command function, was&n;   taken from Tommy Thorn&squot;s aha1542.c file.  This code is Copyright (C)&n;   1992 Tommy Thorn. */
DECL|variable|internal_done_flag
r_static
r_volatile
r_int
id|internal_done_flag
op_assign
l_int|0
suffix:semicolon
DECL|variable|internal_done_errcode
r_static
r_volatile
r_int
id|internal_done_errcode
op_assign
l_int|0
suffix:semicolon
DECL|function|internal_done
r_static
r_void
id|internal_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|internal_done_errcode
op_assign
id|SCpnt-&gt;result
suffix:semicolon
op_increment
id|internal_done_flag
suffix:semicolon
)brace
DECL|function|fdomain_16x0_command
r_int
id|fdomain_16x0_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|fdomain_16x0_queue
c_func
(paren
id|SCpnt
comma
id|internal_done
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|internal_done_flag
)paren
suffix:semicolon
id|internal_done_flag
op_assign
l_int|0
suffix:semicolon
r_return
id|internal_done_errcode
suffix:semicolon
)brace
multiline_comment|/* End of code derived from Tommy Thorn&squot;s work. */
DECL|function|print_info
r_void
id|print_info
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|imr
suffix:semicolon
r_int
r_int
id|irr
suffix:semicolon
r_int
r_int
id|isr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
op_logical_or
op_logical_neg
id|SCpnt-&gt;host
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; Cannot provide detailed information&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|fdomain_16x0_info
c_func
(paren
id|SCpnt-&gt;host
)paren
)paren
suffix:semicolon
id|print_banner
c_func
(paren
id|SCpnt-&gt;host
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|SCpnt-&gt;SCp.phase
)paren
(brace
r_case
id|in_arbitration
suffix:colon
id|printk
c_func
(paren
l_string|&quot;arbitration &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|in_selection
suffix:colon
id|printk
c_func
(paren
l_string|&quot;selection &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|in_other
suffix:colon
id|printk
c_func
(paren
l_string|&quot;other &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;unknown &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;(%d), target = %d cmnd = 0x%02x pieces = %d size = %u&bslash;n&quot;
comma
id|SCpnt-&gt;SCp.phase
comma
id|SCpnt-&gt;target
comma
op_star
(paren
r_int
r_char
op_star
)paren
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sent_command = %d, have_data_in = %d, timeout = %d&bslash;n&quot;
comma
id|SCpnt-&gt;SCp.sent_command
comma
id|SCpnt-&gt;SCp.have_data_in
comma
id|SCpnt-&gt;timeout
)paren
suffix:semicolon
macro_line|#if DEBUG_RACE
id|printk
c_func
(paren
l_string|&quot;in_interrupt_flag = %d&bslash;n&quot;
comma
id|in_interrupt_flag
)paren
suffix:semicolon
macro_line|#endif
id|imr
op_assign
(paren
id|inb
c_func
(paren
l_int|0x0a1
)paren
op_lshift
l_int|8
)paren
op_plus
id|inb
c_func
(paren
l_int|0x21
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0a
comma
l_int|0xa0
)paren
suffix:semicolon
id|irr
op_assign
id|inb
c_func
(paren
l_int|0xa0
)paren
op_lshift
l_int|8
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0a
comma
l_int|0x20
)paren
suffix:semicolon
id|irr
op_add_assign
id|inb
c_func
(paren
l_int|0x20
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0b
comma
l_int|0xa0
)paren
suffix:semicolon
id|isr
op_assign
id|inb
c_func
(paren
l_int|0xa0
)paren
op_lshift
l_int|8
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0b
comma
l_int|0x20
)paren
suffix:semicolon
id|isr
op_add_assign
id|inb
c_func
(paren
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/* Print out interesting information */
id|printk
c_func
(paren
l_string|&quot;IMR = 0x%04x&quot;
comma
id|imr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imr
op_amp
(paren
l_int|1
op_lshift
id|interrupt_level
)paren
)paren
id|printk
c_func
(paren
l_string|&quot; (masked)&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, IRR = 0x%04x, ISR = 0x%04x&bslash;n&quot;
comma
id|irr
comma
id|isr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SCSI Status      = 0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TMC Status       = 0x%02x&quot;
comma
id|inb
c_func
(paren
id|TMC_Status_port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|TMC_Status_port
op_amp
l_int|1
)paren
)paren
id|printk
c_func
(paren
l_string|&quot; (interrupt)&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Interrupt Status = 0x%02x&quot;
comma
id|inb
c_func
(paren
id|Interrupt_Status_port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|Interrupt_Status_port
)paren
op_amp
l_int|0x08
)paren
id|printk
c_func
(paren
l_string|&quot; (enabled)&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip
op_eq
id|tmc18c50
op_logical_or
id|chip
op_eq
id|tmc18c30
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FIFO Status      = 0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|port_base
op_plus
id|FIFO_Status
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Int. Condition   = 0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|port_base
op_plus
id|Interrupt_Cond
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Configuration 1  = 0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|port_base
op_plus
id|Configuration1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip
op_eq
id|tmc18c50
op_logical_or
id|chip
op_eq
id|tmc18c30
)paren
id|printk
c_func
(paren
l_string|&quot;Configuration 2  = 0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|port_base
op_plus
id|Configuration2
)paren
)paren
suffix:semicolon
)brace
DECL|function|fdomain_16x0_abort
r_int
id|fdomain_16x0_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if EVERY_ACCESS || ERRORS_ONLY || DEBUG_ABORT
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; abort &quot;
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_command
)paren
(brace
macro_line|#if EVERY_ACCESS || ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot; (not in command)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if DEBUG_ABORT
id|print_info
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
macro_line|#endif
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_or_assign
id|aborted
suffix:semicolon
id|current_SC-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Aborts are not done well. . . */
id|my_done
c_func
(paren
id|DID_ABORT
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
DECL|function|fdomain_16x0_reset
r_int
id|fdomain_16x0_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_int
id|ignored
)paren
(brace
macro_line|#if DEBUG_RESET
r_static
r_int
id|called_once
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
id|SCpnt
)paren
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; SCSI Bus Reset&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG_RESET
r_if
c_cond
(paren
id|called_once
)paren
id|print_info
c_func
(paren
id|current_SC
)paren
suffix:semicolon
id|called_once
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
l_int|1
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|do_pause
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|do_pause
c_func
(paren
l_int|115
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCSI_Mode_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Unless this is the very first call (i.e., SCPnt == NULL), everything&n;      is probably hosed at this point.  We will, however, try to keep&n;      things going by informing the high-level code that we need help. */
r_return
id|SCSI_RESET_WAKEUP
suffix:semicolon
)brace
macro_line|#include &quot;sd.h&quot;
macro_line|#include &lt;scsi/scsi_ioctl.h&gt;
DECL|function|fdomain_16x0_biosparam
r_int
id|fdomain_16x0_biosparam
c_func
(paren
id|Scsi_Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
op_star
id|info_array
)paren
(brace
r_int
id|drive
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|512
op_plus
r_sizeof
(paren
id|Scsi_Ioctl_Command
)paren
)braket
suffix:semicolon
id|Scsi_Ioctl_Command
op_star
id|sic
op_assign
(paren
id|Scsi_Ioctl_Command
op_star
)paren
id|buf
suffix:semicolon
r_int
id|size
op_assign
id|disk-&gt;capacity
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|sic-&gt;data
suffix:semicolon
r_int
r_char
id|do_read
(braket
)braket
op_assign
(brace
id|READ_6
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
)brace
suffix:semicolon
r_int
id|retcode
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_struct
id|drive_info
(brace
r_int
r_int
id|cylinders
suffix:semicolon
r_int
r_char
id|heads
suffix:semicolon
r_int
r_char
id|sectors
suffix:semicolon
)brace
id|i
suffix:semicolon
multiline_comment|/* NOTES:&n;      The RAM area starts at 0x1f00 from the bios_base address.&n;&n;      For BIOS Version 2.0:&n;      &n;      The drive parameter table seems to start at 0x1f30.&n;      The first byte&squot;s purpose is not known.&n;      Next is the cylinder, head, and sector information.&n;      The last 4 bytes appear to be the drive&squot;s size in sectors.&n;      The other bytes in the drive parameter table are unknown.&n;      If anyone figures them out, please send me mail, and I will&n;      update these notes.&n;&n;      Tape drives do not get placed in this table.&n;&n;      There is another table at 0x1fea:&n;      If the byte is 0x01, then the SCSI ID is not in use.&n;      If the byte is 0x18 or 0x48, then the SCSI ID is in use,&n;      although tapes don&squot;t seem to be in this table.  I haven&squot;t&n;      seen any other numbers (in a limited sample).&n;&n;      0x1f2d is a drive count (i.e., not including tapes)&n;&n;      The table at 0x1fcc are I/O ports addresses for the various&n;      operations.  I calculate these by hand in this driver code.&n;&n;      &n;      &n;      For the ISA-200S version of BIOS Version 2.0:&n;&n;      The drive parameter table starts at 0x1f33.&n;&n;      WARNING: Assume that the table entry is 25 bytes long.  Someone needs&n;      to check this for the Quantum ISA-200S card.&n;&n;      &n;      &n;      For BIOS Version 3.2:&n;&n;      The drive parameter table starts at 0x1f70.  Each entry is&n;      0x0a bytes long.  Heads are one less than we need to report.&n;    */
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|dev
)paren
op_ne
id|SCSI_DISK0_MAJOR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: &lt;fdomain&gt; fdomain_16x0_biosparam: too many disks&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|drive
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|bios_major
op_eq
l_int|2
)paren
(brace
r_switch
c_cond
(paren
id|Quantum
)paren
(brace
r_case
l_int|2
suffix:colon
multiline_comment|/* ISA_200S */
multiline_comment|/* The value of 25 has never been verified.&n;&t;&t;&t;&t;   It should probably be 15. */
id|offset
op_assign
id|bios_base
op_plus
l_int|0x1f33
op_plus
id|drive
op_star
l_int|25
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* ISA_250MG */
id|offset
op_assign
id|bios_base
op_plus
l_int|0x1f36
op_plus
id|drive
op_star
l_int|15
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* ISA_200S (another one) */
id|offset
op_assign
id|bios_base
op_plus
l_int|0x1f34
op_plus
id|drive
op_star
l_int|15
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|offset
op_assign
id|bios_base
op_plus
l_int|0x1f31
op_plus
id|drive
op_star
l_int|25
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memcpy_fromio
c_func
(paren
op_amp
id|i
comma
id|offset
comma
r_sizeof
(paren
r_struct
id|drive_info
)paren
)paren
suffix:semicolon
id|info_array
(braket
l_int|0
)braket
op_assign
id|i.heads
suffix:semicolon
id|info_array
(braket
l_int|1
)braket
op_assign
id|i.sectors
suffix:semicolon
id|info_array
(braket
l_int|2
)braket
op_assign
id|i.cylinders
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bios_major
op_eq
l_int|3
op_logical_and
id|bios_minor
op_ge
l_int|0
op_logical_and
id|bios_minor
OL
l_int|4
)paren
(brace
multiline_comment|/* 3.0 and 3.2 BIOS */
id|memcpy_fromio
c_func
(paren
op_amp
id|i
comma
id|bios_base
op_plus
l_int|0x1f71
op_plus
id|drive
op_star
l_int|10
comma
r_sizeof
(paren
r_struct
id|drive_info
)paren
)paren
suffix:semicolon
id|info_array
(braket
l_int|0
)braket
op_assign
id|i.heads
op_plus
l_int|1
suffix:semicolon
id|info_array
(braket
l_int|1
)braket
op_assign
id|i.sectors
suffix:semicolon
id|info_array
(braket
l_int|2
)braket
op_assign
id|i.cylinders
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* 3.4 BIOS (and up?) */
multiline_comment|/* This algorithm was provided by Future Domain (much thanks!). */
id|sic-&gt;inlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* zero bytes out */
id|sic-&gt;outlen
op_assign
l_int|512
suffix:semicolon
multiline_comment|/* one sector in */
id|memcpy
c_func
(paren
id|data
comma
id|do_read
comma
r_sizeof
(paren
id|do_read
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|kernel_scsi_ioctl
c_func
(paren
id|disk-&gt;device
comma
id|SCSI_IOCTL_SEND_COMMAND
comma
id|sic
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
multiline_comment|/* SCSI command ok */
op_logical_and
id|data
(braket
l_int|511
)braket
op_eq
l_int|0xaa
op_logical_and
id|data
(braket
l_int|510
)braket
op_eq
l_int|0x55
multiline_comment|/* Partition table valid */
op_logical_and
id|data
(braket
l_int|0x1c2
)braket
)paren
(brace
multiline_comment|/* Partition type */
multiline_comment|/* The partition table layout is as follows:&n;&n;&t;    Start: 0x1b3h&n;&t;    Offset: 0 = partition status&n;&t;&t;    1 = starting head&n;&t;&t;    2 = starting sector and cylinder (word, encoded)&n;&t;&t;    4 = partition type&n;&t;&t;    5 = ending head&n;&t;&t;    6 = ending sector and cylinder (word, encoded)&n;&t;&t;    8 = starting absolute sector (double word)&n;&t;&t;    c = number of sectors (double word)&n;&t;    Signature: 0x1fe = 0x55aa&n;&n;&t;    So, this algorithm assumes:&n;&t;    1) the first partition table is in use,&n;&t;    2) the data in the first entry is correct, and&n;&t;    3) partitions never divide cylinders&n;&n;&t;    Note that (1) may be FALSE for NetBSD (and other BSD flavors),&n;&t;    as well as for Linux.  Note also, that Linux doesn&squot;t pay any&n;&t;    attention to the fields that are used by this algorithm -- it&n;&t;    only uses the absolute sector data.  Recent versions of Linux&squot;s&n;&t;    fdisk(1) will fill this data in correctly, and forthcoming&n;&t;    versions will check for consistency.&n;&n;&t;    Checking for a non-zero partition type is not part of the&n;&t;    Future Domain algorithm, but it seemed to be a reasonable thing&n;&t;    to do, especially in the Linux and BSD worlds. */
id|info_array
(braket
l_int|0
)braket
op_assign
id|data
(braket
l_int|0x1c3
)braket
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* heads */
id|info_array
(braket
l_int|1
)braket
op_assign
id|data
(braket
l_int|0x1c4
)braket
op_amp
l_int|0x3f
suffix:semicolon
multiline_comment|/* sectors */
)brace
r_else
(brace
multiline_comment|/* Note that this new method guarantees that there will always be&n;&t;    less than 1024 cylinders on a platter.  This is good for drives&n;&t;    up to approximately 7.85GB (where 1GB = 1024 * 1024 kB). */
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|size
op_ge
l_int|0x7e0000U
)paren
(brace
id|info_array
(braket
l_int|0
)braket
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* heads   = 255 */
id|info_array
(braket
l_int|1
)braket
op_assign
l_int|0x3f
suffix:semicolon
multiline_comment|/* sectors =  63 */
)brace
r_else
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|size
op_ge
l_int|0x200000U
)paren
(brace
id|info_array
(braket
l_int|0
)braket
op_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* heads   = 128 */
id|info_array
(braket
l_int|1
)braket
op_assign
l_int|0x3f
suffix:semicolon
multiline_comment|/* sectors =  63 */
)brace
r_else
(brace
id|info_array
(braket
l_int|0
)braket
op_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* heads   =  64 */
id|info_array
(braket
l_int|1
)braket
op_assign
l_int|0x20
suffix:semicolon
multiline_comment|/* sectors =  32 */
)brace
)brace
multiline_comment|/* For both methods, compute the cylinders */
id|info_array
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_int
)paren
id|size
op_div
(paren
id|info_array
(braket
l_int|0
)braket
op_star
id|info_array
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Eventually this will go into an include file, but this will be later */
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|FDOMAIN_16X0
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
eof
