multiline_comment|/* $Id: $&n; *  linux/drivers/scsi/wd7000.c&n; *&n; *  Copyright (C) 1992  Thomas Wuensche&n; *&t;closely related to the aha1542 driver from Tommy Thorn&n; *&t;( as close as different hardware allows on a lowlevel-driver :-) )&n; *&n; *  Revised (and renamed) by John Boyd &lt;boyd@cis.ohio-state.edu&gt; to&n; *  accommodate Eric Youngdale&squot;s modifications to scsi.c.  Nov 1992.&n; *&n; *  Additional changes to support scatter/gather.  Dec. 1992.  tw/jb&n; *&n; *  No longer tries to reset SCSI bus at boot (it wasn&squot;t working anyway).&n; *  Rewritten to support multiple host adapters.&n; *  Miscellaneous cleanup.&n; *  So far, still doesn&squot;t do reset or abort correctly, since I have no idea&n; *  how to do them with this board (8^(.                      Jan 1994 jb&n; *&n; * This driver now supports both of the two standard configurations (per&n; * the 3.36 Owner&squot;s Manual, my latest reference) by the same method as&n; * before; namely, by looking for a BIOS signature.  Thus, the location of&n; * the BIOS signature determines the board configuration.  Until I have&n; * time to do something more flexible, users should stick to one of the&n; * following:&n; *&n; * Standard configuration for single-adapter systems:&n; *    - BIOS at CE00h&n; *    - I/O base address 350h&n; *    - IRQ level 15&n; *    - DMA channel 6&n; * Standard configuration for a second adapter in a system:&n; *    - BIOS at C800h&n; *    - I/O base address 330h&n; *    - IRQ level 11&n; *    - DMA channel 5&n; *&n; * Anyone who can recompile the kernel is welcome to add others as need&n; * arises, but unpredictable results may occur if there are conflicts.&n; * In any event, if there are multiple adapters in a system, they MUST&n; * use different I/O bases, IRQ levels, and DMA channels, since they will be&n; * indistinguishable (and in direct conflict) otherwise.&n; *&n; *   As a point of information, the NO_OP command toggles the CMD_RDY bit&n; * of the status port, and this fact could be used as a test for the I/O&n; * base address (or more generally, board detection).  There is an interrupt&n; * status port, so IRQ probing could also be done.  I suppose the full&n; * DMA diagnostic could be used to detect the DMA channel being used.  I&n; * haven&squot;t done any of this, though, because I think there&squot;s too much of&n; * a chance that such explorations could be destructive, if some other&n; * board&squot;s resources are used inadvertently.  So, call me a wimp, but I&n; * don&squot;t want to try it.  The only kind of exploration I trust is memory&n; * exploration, since it&squot;s more certain that reading memory won&squot;t be&n; * destructive.&n; *&n; * More to my liking would be a LILO boot command line specification, such&n; * as is used by the aha152x driver (and possibly others).  I&squot;ll look into&n; * it, as I have time...&n; *&n; *   I get mail occasionally from people who either are using or are&n; * considering using a WD7000 with Linux.  There is a variety of&n; * nomenclature describing WD7000&squot;s.  To the best of my knowledge, the&n; * following is a brief summary (from an old WD doc - I don&squot;t work for&n; * them or anything like that):&n; *&n; * WD7000-FASST2: This is a WD7000 board with the real-mode SST ROM BIOS&n; *        installed.  Last I heard, the BIOS was actually done by Columbia&n; *        Data Products.  The BIOS is only used by this driver (and thus&n; *        by Linux) to identify the board; none of it can be executed under&n; *        Linux.&n; *&n; * WD7000-ASC: This is the original adapter board, with or without BIOS.&n; *        The board uses a WD33C93 or WD33C93A SBIC, which in turn is&n; *        controlled by an onboard Z80 processor.  The board interface&n; *        visible to the host CPU is defined effectively by the Z80&squot;s&n; *        firmware, and it is this firmware&squot;s revision level that is&n; *        determined and reported by this driver.  (The version of the&n; *        on-board BIOS is of no interest whatsoever.)  The host CPU has&n; *        no access to the SBIC; hence the fact that it is a WD33C93 is&n; *        also of no interest to this driver.&n; *&n; * WD7000-AX:&n; * WD7000-MX:&n; * WD7000-EX: These are newer versions of the WD7000-ASC.  The -ASC is&n; *        largely built from discrete components; these boards use more&n; *        integration.  The -AX is an ISA bus board (like the -ASC),&n; *        the -MX is an MCA (i.e., PS/2) bus board), and the -EX is an&n; *        EISA bus board.&n; *&n; *  At the time of my documentation, the -?X boards were &quot;future&quot; products,&n; *  and were not yet available.  However, I vaguely recall that Thomas&n; *  Wuensche had an -AX, so I believe at least it is supported by this&n; *  driver.  I have no personal knowledge of either -MX or -EX boards.&n; *&n; *  P.S. Just recently, I&squot;ve discovered (directly from WD and Future&n; *  Domain) that all but the WD7000-EX have been out of production for&n; *  two years now.  FD has production rights to the 7000-EX, and are&n; *  producing it under a new name, and with a new BIOS.  If anyone has&n; *  one of the FD boards, it would be nice to come up with a signature&n; *  for it.&n; *                                                           J.B. Jan 1994.&n; *&n; *&n; *  Revisions by Miroslav Zagorac &lt;zaga@fly.cc.fer.hr&gt;&n; *&n; *  08/24/1996.&n; *&n; *  Enhancement for wd7000_detect function has been made, so you don&squot;t have&n; *  to enter BIOS ROM address in initialisation data (see struct Config).&n; *  We cannot detect IRQ, DMA and I/O base address for now, so we have to&n; *  enter them as arguments while wd_7000 is detected. If someone has IRQ,&n; *  DMA or I/O base address set to some other value, he can enter them in&n; *  configuration without any problem. Also I wrote a function wd7000_setup,&n; *  so now you can enter WD-7000 definition as kernel arguments,&n; *  as in lilo.conf:&n; *&n; *     append=&quot;wd7000=IRQ,DMA,IO&quot;&n; *&n; *  PS: If card BIOS ROM is disabled, function wd7000_detect now will recognize&n; *      adapter, unlike the old one. Anyway, BIOS ROM from WD7000 adapter is&n; *      useless for Linux. B^)&n; *&n; *&n; *  09/06/1996.&n; *&n; *  Autodetecting of I/O base address from wd7000_detect function is removed,&n; *  some little bugs removed, etc...&n; *&n; *  Thanks to Roger Scott for driver debugging.&n; *&n; *  06/07/1997&n; *&n; *  Added support for /proc file system (/proc/scsi/wd7000/[0...] files).&n; *  Now, driver can handle hard disks with capacity &gt;1GB.&n; *&n; *  01/15/1998&n; *&n; *  Added support for BUS_ON and BUS_OFF parameters in config line.&n; *  Miscellaneous cleanup.&n; *&n; *  03/01/1998&n; *&n; *  WD7000 driver now work on kernels &gt;= 2.1.x&n; */
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#endif
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &lt;scsi/scsicam.h&gt;
DECL|macro|ANY2SCSI_INLINE
mdefine_line|#define ANY2SCSI_INLINE&t;&t;/* undef this to use old macros */
DECL|macro|WD7000_DEBUG
macro_line|#undef  WD7000_DEBUG&t;&t;/* general debug                */
macro_line|#include &quot;wd7000.h&quot;
macro_line|#include &lt;linux/stat.h&gt;
multiline_comment|/*&n; *  Mailbox structure sizes.&n; *  I prefer to keep the number of ICMBs much larger than the number of&n; *  OGMBs.  OGMBs are used very quickly by the driver to start one or&n; *  more commands, while ICMBs are used by the host adapter per command.&n; */
DECL|macro|OGMB_CNT
mdefine_line|#define OGMB_CNT&t;16
DECL|macro|ICMB_CNT
mdefine_line|#define ICMB_CNT&t;32
multiline_comment|/*&n; *  Scb&squot;s are shared by all active adapters.  So, if they all become busy,&n; *  callers may be made to wait in alloc_scbs for them to free.  That can&n; *  be avoided by setting MAX_SCBS to NUM_CONFIG * WD7000_Q.  If you&squot;d&n; *  rather conserve memory, use a smaller number (&gt; 0, of course) - things&n; *  will should still work OK.&n; */
DECL|macro|MAX_SCBS
mdefine_line|#define MAX_SCBS        32
multiline_comment|/*&n; *  WD7000-specific mailbox structure&n; *&n; */
DECL|struct|mailbox
r_typedef
r_volatile
r_struct
id|mailbox
(brace
DECL|member|status
id|unchar
id|status
suffix:semicolon
DECL|member|scbptr
id|unchar
id|scbptr
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* SCSI-style - MSB first (big endian) */
DECL|typedef|Mailbox
)brace
id|Mailbox
suffix:semicolon
multiline_comment|/*&n; *  This structure should contain all per-adapter global data.  I.e., any&n; *  new global per-adapter data should put in here.&n; */
DECL|struct|adapter
r_typedef
r_struct
id|adapter
(brace
DECL|member|sh
r_struct
id|Scsi_Host
op_star
id|sh
suffix:semicolon
multiline_comment|/* Pointer to Scsi_Host structure    */
DECL|member|iobase
r_int
id|iobase
suffix:semicolon
multiline_comment|/* This adapter&squot;s I/O base address   */
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* This adapter&squot;s IRQ level          */
DECL|member|dma
r_int
id|dma
suffix:semicolon
multiline_comment|/* This adapter&squot;s DMA channel        */
DECL|member|int_counter
r_int
id|int_counter
suffix:semicolon
multiline_comment|/* This adapter&squot;s interrupt counter  */
DECL|member|bus_on
r_int
id|bus_on
suffix:semicolon
multiline_comment|/* This adapter&squot;s BUS_ON time        */
DECL|member|bus_off
r_int
id|bus_off
suffix:semicolon
multiline_comment|/* This adapter&squot;s BUS_OFF time       */
r_struct
(brace
multiline_comment|/* This adapter&squot;s mailboxes          */
DECL|member|ogmb
id|Mailbox
id|ogmb
(braket
id|OGMB_CNT
)braket
suffix:semicolon
multiline_comment|/* Outgoing mailboxes                */
DECL|member|icmb
id|Mailbox
id|icmb
(braket
id|ICMB_CNT
)braket
suffix:semicolon
multiline_comment|/* Incoming mailboxes                */
DECL|member|mb
)brace
id|mb
suffix:semicolon
DECL|member|next_ogmb
r_int
id|next_ogmb
suffix:semicolon
multiline_comment|/* to reduce contention at mailboxes */
DECL|member|control
id|unchar
id|control
suffix:semicolon
multiline_comment|/* shadows CONTROL port value        */
DECL|member|rev1
DECL|member|rev2
id|unchar
id|rev1
comma
id|rev2
suffix:semicolon
multiline_comment|/* filled in by wd7000_revision      */
DECL|typedef|Adapter
)brace
id|Adapter
suffix:semicolon
multiline_comment|/*&n; * (linear) base address for ROM BIOS&n; */
DECL|variable|wd7000_biosaddr
r_static
r_const
r_int
id|wd7000_biosaddr
(braket
)braket
op_assign
(brace
l_int|0xc0000
comma
l_int|0xc2000
comma
l_int|0xc4000
comma
l_int|0xc6000
comma
l_int|0xc8000
comma
l_int|0xca000
comma
l_int|0xcc000
comma
l_int|0xce000
comma
l_int|0xd0000
comma
l_int|0xd2000
comma
l_int|0xd4000
comma
l_int|0xd6000
comma
l_int|0xd8000
comma
l_int|0xda000
comma
l_int|0xdc000
comma
l_int|0xde000
)brace
suffix:semicolon
DECL|macro|NUM_ADDRS
mdefine_line|#define NUM_ADDRS (sizeof(wd7000_biosaddr)/sizeof(long))
DECL|variable|wd7000_iobase
r_static
r_const
r_int
r_int
id|wd7000_iobase
(braket
)braket
op_assign
(brace
l_int|0x0300
comma
l_int|0x0308
comma
l_int|0x0310
comma
l_int|0x0318
comma
l_int|0x0320
comma
l_int|0x0328
comma
l_int|0x0330
comma
l_int|0x0338
comma
l_int|0x0340
comma
l_int|0x0348
comma
l_int|0x0350
comma
l_int|0x0358
comma
l_int|0x0360
comma
l_int|0x0368
comma
l_int|0x0370
comma
l_int|0x0378
comma
l_int|0x0380
comma
l_int|0x0388
comma
l_int|0x0390
comma
l_int|0x0398
comma
l_int|0x03a0
comma
l_int|0x03a8
comma
l_int|0x03b0
comma
l_int|0x03b8
comma
l_int|0x03c0
comma
l_int|0x03c8
comma
l_int|0x03d0
comma
l_int|0x03d8
comma
l_int|0x03e0
comma
l_int|0x03e8
comma
l_int|0x03f0
comma
l_int|0x03f8
)brace
suffix:semicolon
DECL|macro|NUM_IOPORTS
mdefine_line|#define NUM_IOPORTS (sizeof(wd7000_iobase)/sizeof(unsigned short))
DECL|variable|wd7000_irq
r_static
r_const
r_int
id|wd7000_irq
(braket
)braket
op_assign
(brace
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|7
comma
l_int|9
comma
l_int|10
comma
l_int|11
comma
l_int|12
comma
l_int|14
comma
l_int|15
)brace
suffix:semicolon
DECL|macro|NUM_IRQS
mdefine_line|#define NUM_IRQS (sizeof(wd7000_irq)/sizeof(short))
DECL|variable|wd7000_dma
r_static
r_const
r_int
id|wd7000_dma
(braket
)braket
op_assign
(brace
l_int|5
comma
l_int|6
comma
l_int|7
)brace
suffix:semicolon
DECL|macro|NUM_DMAS
mdefine_line|#define NUM_DMAS (sizeof(wd7000_dma)/sizeof(short))
multiline_comment|/*&n; * possible irq range&n; */
DECL|macro|IRQ_MIN
mdefine_line|#define IRQ_MIN   3
DECL|macro|IRQ_MAX
mdefine_line|#define IRQ_MAX   15
DECL|macro|IRQS
mdefine_line|#define IRQS      (IRQ_MAX - IRQ_MIN + 1)
multiline_comment|/*&n; * The following is set up by wd7000_detect, and used thereafter by&n; * wd7000_intr_handle to map the irq level to the corresponding Adapter.&n; * Note that if SA_INTERRUPT is not used, wd7000_intr_handle must be&n; * changed to pick up the IRQ level correctly.&n; */
DECL|variable|wd7000_host
r_static
r_struct
id|Scsi_Host
op_star
id|wd7000_host
(braket
id|IRQS
)braket
suffix:semicolon
DECL|macro|BUS_ON
mdefine_line|#define BUS_ON    64&t;/* x 125ns = 8000ns (BIOS default) */
DECL|macro|BUS_OFF
mdefine_line|#define BUS_OFF   15&t;/* x 125ns = 1875ns (BIOS default) */
multiline_comment|/*&n; *  Standard Adapter Configurations - used by wd7000_detect&n; */
r_typedef
r_struct
(brace
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* IRQ level                                  */
DECL|member|dma
r_int
id|dma
suffix:semicolon
multiline_comment|/* DMA channel                                */
DECL|member|iobase
r_int
id|iobase
suffix:semicolon
multiline_comment|/* I/O base address                           */
DECL|member|bus_on
r_int
id|bus_on
suffix:semicolon
multiline_comment|/* Time that WD7000 spends on the AT-bus when */
multiline_comment|/* transferring data. BIOS default is 8000ns. */
DECL|member|bus_off
r_int
id|bus_off
suffix:semicolon
multiline_comment|/* Time that WD7000 spends OFF THE BUS after  */
multiline_comment|/* while it is transferring data.             */
multiline_comment|/* BIOS default is 1875ns                     */
DECL|typedef|Config
)brace
id|Config
suffix:semicolon
multiline_comment|/*&n; * Add here your configuration...&n; */
DECL|variable|configs
r_static
id|Config
id|configs
(braket
)braket
op_assign
(brace
(brace
l_int|15
comma
l_int|6
comma
l_int|0x350
comma
id|BUS_ON
comma
id|BUS_OFF
)brace
comma
multiline_comment|/* defaults for single adapter */
(brace
l_int|11
comma
l_int|5
comma
l_int|0x320
comma
id|BUS_ON
comma
id|BUS_OFF
)brace
comma
multiline_comment|/* defaults for second adapter */
(brace
l_int|7
comma
l_int|6
comma
l_int|0x350
comma
id|BUS_ON
comma
id|BUS_OFF
)brace
comma
multiline_comment|/* My configuration (Zaga)     */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|0x0
comma
id|BUS_ON
comma
id|BUS_OFF
)brace
multiline_comment|/* Empty slot                  */
)brace
suffix:semicolon
DECL|macro|NUM_CONFIGS
mdefine_line|#define NUM_CONFIGS (sizeof(configs)/sizeof(Config))
multiline_comment|/*&n; *  The following list defines strings to look for in the BIOS that identify&n; *  it as the WD7000-FASST2 SST BIOS.  I suspect that something should be&n; *  added for the Future Domain version.&n; */
DECL|struct|signature
r_typedef
r_struct
id|signature
(brace
DECL|member|sig
r_const
r_char
op_star
id|sig
suffix:semicolon
multiline_comment|/* String to look for            */
DECL|member|ofs
r_int
r_int
id|ofs
suffix:semicolon
multiline_comment|/* offset from BIOS base address */
DECL|member|len
r_int
id|len
suffix:semicolon
multiline_comment|/* length of string              */
DECL|typedef|Signature
)brace
id|Signature
suffix:semicolon
DECL|variable|signatures
r_static
r_const
id|Signature
id|signatures
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;SSTBIOS&quot;
comma
l_int|0x0000d
comma
l_int|7
)brace
multiline_comment|/* &quot;SSTBIOS&quot; @ offset 0x0000d */
)brace
suffix:semicolon
DECL|macro|NUM_SIGNATURES
mdefine_line|#define NUM_SIGNATURES (sizeof(signatures)/sizeof(Signature))
multiline_comment|/*&n; *  I/O Port Offsets and Bit Definitions&n; *  4 addresses are used.  Those not defined here are reserved.&n; */
DECL|macro|ASC_STAT
mdefine_line|#define ASC_STAT        0&t;/* Status,  Read          */
DECL|macro|ASC_COMMAND
mdefine_line|#define ASC_COMMAND     0&t;/* Command, Write         */
DECL|macro|ASC_INTR_STAT
mdefine_line|#define ASC_INTR_STAT   1&t;/* Interrupt Status, Read */
DECL|macro|ASC_INTR_ACK
mdefine_line|#define ASC_INTR_ACK    1&t;/* Acknowledge, Write     */
DECL|macro|ASC_CONTROL
mdefine_line|#define ASC_CONTROL     2&t;/* Control, Write         */
multiline_comment|/*&n; * ASC Status Port&n; */
DECL|macro|INT_IM
mdefine_line|#define INT_IM&t;&t;0x80&t;/* Interrupt Image Flag           */
DECL|macro|CMD_RDY
mdefine_line|#define CMD_RDY&t;&t;0x40&t;/* Command Port Ready             */
DECL|macro|CMD_REJ
mdefine_line|#define CMD_REJ&t;&t;0x20&t;/* Command Port Byte Rejected     */
DECL|macro|ASC_INIT
mdefine_line|#define ASC_INIT        0x10&t;/* ASC Initialized Flag           */
DECL|macro|ASC_STATMASK
mdefine_line|#define ASC_STATMASK    0xf0&t;/* The lower 4 Bytes are reserved */
multiline_comment|/*&n; * COMMAND opcodes&n; *&n; *  Unfortunately, I have no idea how to properly use some of these commands,&n; *  as the OEM manual does not make it clear.  I have not been able to use&n; *  enable/disable unsolicited interrupts or the reset commands with any&n; *  discernible effect whatsoever.  I think they may be related to certain&n; *  ICB commands, but again, the OEM manual doesn&squot;t make that clear.&n; */
DECL|macro|NO_OP
mdefine_line|#define NO_OP             0&t;/* NO-OP toggles CMD_RDY bit in ASC_STAT  */
DECL|macro|INITIALIZATION
mdefine_line|#define INITIALIZATION    1&t;/* initialization (10 bytes)              */
DECL|macro|DISABLE_UNS_INTR
mdefine_line|#define DISABLE_UNS_INTR  2&t;/* disable unsolicited interrupts         */
DECL|macro|ENABLE_UNS_INTR
mdefine_line|#define ENABLE_UNS_INTR   3&t;/* enable unsolicited interrupts          */
DECL|macro|INTR_ON_FREE_OGMB
mdefine_line|#define INTR_ON_FREE_OGMB 4&t;/* interrupt on free OGMB                 */
DECL|macro|SOFT_RESET
mdefine_line|#define SOFT_RESET        5&t;/* SCSI bus soft reset                    */
DECL|macro|HARD_RESET_ACK
mdefine_line|#define HARD_RESET_ACK    6&t;/* SCSI bus hard reset acknowledge        */
DECL|macro|START_OGMB
mdefine_line|#define START_OGMB        0x80&t;/* start command in OGMB (n)              */
DECL|macro|SCAN_OGMBS
mdefine_line|#define SCAN_OGMBS        0xc0&t;/* start multiple commands, signature (n) */
multiline_comment|/*    where (n) = lower 6 bits            */
multiline_comment|/*&n; * For INITIALIZATION:&n; */
DECL|struct|initCmd
r_typedef
r_struct
id|initCmd
(brace
DECL|member|op
id|unchar
id|op
suffix:semicolon
multiline_comment|/* command opcode (= 1)                    */
DECL|member|ID
id|unchar
id|ID
suffix:semicolon
multiline_comment|/* Adapter&squot;s SCSI ID                       */
DECL|member|bus_on
id|unchar
id|bus_on
suffix:semicolon
multiline_comment|/* Bus on time, x 125ns (see below)        */
DECL|member|bus_off
id|unchar
id|bus_off
suffix:semicolon
multiline_comment|/* Bus off time, &quot;&quot;         &quot;&quot;             */
DECL|member|rsvd
id|unchar
id|rsvd
suffix:semicolon
multiline_comment|/* Reserved                                */
DECL|member|mailboxes
id|unchar
id|mailboxes
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Address of Mailboxes, MSB first         */
DECL|member|ogmbs
id|unchar
id|ogmbs
suffix:semicolon
multiline_comment|/* Number of outgoing MBs, max 64, 0,1 = 1 */
DECL|member|icmbs
id|unchar
id|icmbs
suffix:semicolon
multiline_comment|/* Number of incoming MBs,   &quot;&quot;       &quot;&quot;   */
DECL|typedef|InitCmd
)brace
id|InitCmd
suffix:semicolon
multiline_comment|/*&n; * Interrupt Status Port - also returns diagnostic codes at ASC reset&n; *&n; * if msb is zero, the lower bits are diagnostic status&n; * Diagnostics:&n; * 01   No diagnostic error occurred&n; * 02   RAM failure&n; * 03   FIFO R/W failed&n; * 04   SBIC register read/write failed&n; * 05   Initialization D-FF failed&n; * 06   Host IRQ D-FF failed&n; * 07   ROM checksum error&n; * Interrupt status (bitwise):&n; * 10NNNNNN   outgoing mailbox NNNNNN is free&n; * 11NNNNNN   incoming mailbox NNNNNN needs service&n; */
DECL|macro|MB_INTR
mdefine_line|#define MB_INTR    0xC0&t;&t;/* Mailbox Service possible/required */
DECL|macro|IMB_INTR
mdefine_line|#define IMB_INTR   0x40&t;&t;/* 1 Incoming / 0 Outgoing           */
DECL|macro|MB_MASK
mdefine_line|#define MB_MASK    0x3f&t;&t;/* mask for mailbox number           */
multiline_comment|/*&n; * CONTROL port bits&n; */
DECL|macro|INT_EN
mdefine_line|#define INT_EN     0x08&t;&t;/* Interrupt Enable */
DECL|macro|DMA_EN
mdefine_line|#define DMA_EN     0x04&t;&t;/* DMA Enable       */
DECL|macro|SCSI_RES
mdefine_line|#define SCSI_RES   0x02&t;&t;/* SCSI Reset       */
DECL|macro|ASC_RES
mdefine_line|#define ASC_RES    0x01&t;&t;/* ASC Reset        */
multiline_comment|/*&n; * Driver data structures:&n; *   - mb and scbs are required for interfacing with the host adapter.&n; *     An SCB has extra fields not visible to the adapter; mb&squot;s&n; *     _cannot_ do this, since the adapter assumes they are contiguous in&n; *     memory, 4 bytes each, with ICMBs following OGMBs, and uses this fact&n; *     to access them.&n; *   - An icb is for host-only (non-SCSI) commands.  ICBs are 16 bytes each;&n; *     the additional bytes are used only by the driver.&n; *   - For now, a pool of SCBs are kept in global storage by this driver,&n; *     and are allocated and freed as needed.&n; *&n; *  The 7000-FASST2 marks OGMBs empty as soon as it has _started_ a command,&n; *  not when it has finished.  Since the SCB must be around for completion,&n; *  problems arise when SCBs correspond to OGMBs, which may be reallocated&n; *  earlier (or delayed unnecessarily until a command completes).&n; *  Mailboxes are used as transient data structures, simply for&n; *  carrying SCB addresses to/from the 7000-FASST2.&n; *&n; *  Note also since SCBs are not &quot;permanently&quot; associated with mailboxes,&n; *  there is no need to keep a global list of Scsi_Cmnd pointers indexed&n; *  by OGMB.   Again, SCBs reference their Scsi_Cmnds directly, so mailbox&n; *  indices need not be involved.&n; */
multiline_comment|/*&n; *  WD7000-specific scatter/gather element structure&n; */
DECL|struct|sgb
r_typedef
r_struct
id|sgb
(brace
DECL|member|len
id|unchar
id|len
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|ptr
id|unchar
id|ptr
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Also SCSI-style - MSB first */
DECL|typedef|Sgb
)brace
id|Sgb
suffix:semicolon
DECL|struct|scb
r_typedef
r_struct
id|scb
(brace
multiline_comment|/* Command Control Block 5.4.1               */
DECL|member|op
id|unchar
id|op
suffix:semicolon
multiline_comment|/* Command Control Block Operation Code      */
DECL|member|idlun
id|unchar
id|idlun
suffix:semicolon
multiline_comment|/* op=0,2:Target Id, op=1:Initiator Id       */
multiline_comment|/* Outbound data transfer, length is checked */
multiline_comment|/* Inbound data transfer, length is checked  */
multiline_comment|/* Logical Unit Number                       */
DECL|member|cdb
id|unchar
id|cdb
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* SCSI Command Block                        */
DECL|member|status
r_volatile
id|unchar
id|status
suffix:semicolon
multiline_comment|/* SCSI Return Status                        */
DECL|member|vue
r_volatile
id|unchar
id|vue
suffix:semicolon
multiline_comment|/* Vendor Unique Error Code                  */
DECL|member|maxlen
id|unchar
id|maxlen
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Maximum Data Transfer Length              */
DECL|member|dataptr
id|unchar
id|dataptr
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* SCSI Data Block Pointer                   */
DECL|member|linkptr
id|unchar
id|linkptr
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Next Command Link Pointer                 */
DECL|member|direc
id|unchar
id|direc
suffix:semicolon
multiline_comment|/* Transfer Direction                        */
DECL|member|reserved2
id|unchar
id|reserved2
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* SCSI Command Descriptor Block             */
multiline_comment|/* end of hardware SCB                       */
DECL|member|SCpnt
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
multiline_comment|/* Scsi_Cmnd using this SCB                  */
DECL|member|sgb
id|Sgb
id|sgb
(braket
id|WD7000_SG
)braket
suffix:semicolon
multiline_comment|/* Scatter/gather list for this SCB          */
DECL|member|host
id|Adapter
op_star
id|host
suffix:semicolon
multiline_comment|/* host adapter                              */
DECL|member|next
r_struct
id|scb
op_star
id|next
suffix:semicolon
multiline_comment|/* for lists of scbs                         */
DECL|typedef|Scb
)brace
id|Scb
suffix:semicolon
multiline_comment|/*&n; *  This driver is written to allow host-only commands to be executed.&n; *  These use a 16-byte block called an ICB.  The format is extended by the&n; *  driver to 18 bytes, to support the status returned in the ICMB and&n; *  an execution phase code.&n; *&n; *  There are other formats besides these; these are the ones I&squot;ve tried&n; *  to use.  Formats for some of the defined ICB opcodes are not defined&n; *  (notably, get/set unsolicited interrupt status) in my copy of the OEM&n; *  manual, and others are ambiguous/hard to follow.&n; */
DECL|macro|ICB_OP_MASK
mdefine_line|#define ICB_OP_MASK           0x80&t;/* distinguishes scbs from icbs        */
DECL|macro|ICB_OP_OPEN_RBUF
mdefine_line|#define ICB_OP_OPEN_RBUF      0x80&t;/* open receive buffer                 */
DECL|macro|ICB_OP_RECV_CMD
mdefine_line|#define ICB_OP_RECV_CMD       0x81&t;/* receive command from initiator      */
DECL|macro|ICB_OP_RECV_DATA
mdefine_line|#define ICB_OP_RECV_DATA      0x82&t;/* receive data from initiator         */
DECL|macro|ICB_OP_RECV_SDATA
mdefine_line|#define ICB_OP_RECV_SDATA     0x83&t;/* receive data with status from init. */
DECL|macro|ICB_OP_SEND_DATA
mdefine_line|#define ICB_OP_SEND_DATA      0x84&t;/* send data with status to initiator  */
DECL|macro|ICB_OP_SEND_STAT
mdefine_line|#define ICB_OP_SEND_STAT      0x86&t;/* send command status to initiator    */
multiline_comment|/* 0x87 is reserved                    */
DECL|macro|ICB_OP_READ_INIT
mdefine_line|#define ICB_OP_READ_INIT      0x88&t;/* read initialization bytes           */
DECL|macro|ICB_OP_READ_ID
mdefine_line|#define ICB_OP_READ_ID        0x89&t;/* read adapter&squot;s SCSI ID              */
DECL|macro|ICB_OP_SET_UMASK
mdefine_line|#define ICB_OP_SET_UMASK      0x8A&t;/* set unsolicited interrupt mask      */
DECL|macro|ICB_OP_GET_UMASK
mdefine_line|#define ICB_OP_GET_UMASK      0x8B&t;/* read unsolicited interrupt mask     */
DECL|macro|ICB_OP_GET_REVISION
mdefine_line|#define ICB_OP_GET_REVISION   0x8C&t;/* read firmware revision level        */
DECL|macro|ICB_OP_DIAGNOSTICS
mdefine_line|#define ICB_OP_DIAGNOSTICS    0x8D&t;/* execute diagnostics                 */
DECL|macro|ICB_OP_SET_EPARMS
mdefine_line|#define ICB_OP_SET_EPARMS     0x8E&t;/* set execution parameters            */
DECL|macro|ICB_OP_GET_EPARMS
mdefine_line|#define ICB_OP_GET_EPARMS     0x8F&t;/* read execution parameters           */
DECL|struct|icbRecvCmd
r_typedef
r_struct
id|icbRecvCmd
(brace
DECL|member|op
id|unchar
id|op
suffix:semicolon
DECL|member|IDlun
id|unchar
id|IDlun
suffix:semicolon
multiline_comment|/* Initiator SCSI ID/lun     */
DECL|member|len
id|unchar
id|len
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* command buffer length     */
DECL|member|ptr
id|unchar
id|ptr
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* command buffer address    */
DECL|member|rsvd
id|unchar
id|rsvd
(braket
l_int|7
)braket
suffix:semicolon
multiline_comment|/* reserved                  */
DECL|member|vue
r_volatile
id|unchar
id|vue
suffix:semicolon
multiline_comment|/* vendor-unique error code  */
DECL|member|status
r_volatile
id|unchar
id|status
suffix:semicolon
multiline_comment|/* returned (icmb) status    */
DECL|member|phase
r_volatile
id|unchar
id|phase
suffix:semicolon
multiline_comment|/* used by interrupt handler */
DECL|typedef|IcbRecvCmd
)brace
id|IcbRecvCmd
suffix:semicolon
DECL|struct|icbSendStat
r_typedef
r_struct
id|icbSendStat
(brace
DECL|member|op
id|unchar
id|op
suffix:semicolon
DECL|member|IDlun
id|unchar
id|IDlun
suffix:semicolon
multiline_comment|/* Target SCSI ID/lun                  */
DECL|member|stat
id|unchar
id|stat
suffix:semicolon
multiline_comment|/* (outgoing) completion status byte 1 */
DECL|member|rsvd
id|unchar
id|rsvd
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* reserved                            */
DECL|member|vue
r_volatile
id|unchar
id|vue
suffix:semicolon
multiline_comment|/* vendor-unique error code            */
DECL|member|status
r_volatile
id|unchar
id|status
suffix:semicolon
multiline_comment|/* returned (icmb) status              */
DECL|member|phase
r_volatile
id|unchar
id|phase
suffix:semicolon
multiline_comment|/* used by interrupt handler           */
DECL|typedef|IcbSendStat
)brace
id|IcbSendStat
suffix:semicolon
DECL|struct|icbRevLvl
r_typedef
r_struct
id|icbRevLvl
(brace
DECL|member|op
id|unchar
id|op
suffix:semicolon
DECL|member|primary
r_volatile
id|unchar
id|primary
suffix:semicolon
multiline_comment|/* primary revision level (returned)   */
DECL|member|secondary
r_volatile
id|unchar
id|secondary
suffix:semicolon
multiline_comment|/* secondary revision level (returned) */
DECL|member|rsvd
id|unchar
id|rsvd
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* reserved                            */
DECL|member|vue
r_volatile
id|unchar
id|vue
suffix:semicolon
multiline_comment|/* vendor-unique error code            */
DECL|member|status
r_volatile
id|unchar
id|status
suffix:semicolon
multiline_comment|/* returned (icmb) status              */
DECL|member|phase
r_volatile
id|unchar
id|phase
suffix:semicolon
multiline_comment|/* used by interrupt handler           */
DECL|typedef|IcbRevLvl
)brace
id|IcbRevLvl
suffix:semicolon
DECL|struct|icbUnsMask
r_typedef
r_struct
id|icbUnsMask
(brace
multiline_comment|/* I&squot;m totally guessing here */
DECL|member|op
id|unchar
id|op
suffix:semicolon
DECL|member|mask
r_volatile
id|unchar
id|mask
(braket
l_int|14
)braket
suffix:semicolon
multiline_comment|/* mask bits                 */
macro_line|#if 0
id|unchar
id|rsvd
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* reserved                  */
macro_line|#endif
DECL|member|vue
r_volatile
id|unchar
id|vue
suffix:semicolon
multiline_comment|/* vendor-unique error code  */
DECL|member|status
r_volatile
id|unchar
id|status
suffix:semicolon
multiline_comment|/* returned (icmb) status    */
DECL|member|phase
r_volatile
id|unchar
id|phase
suffix:semicolon
multiline_comment|/* used by interrupt handler */
DECL|typedef|IcbUnsMask
)brace
id|IcbUnsMask
suffix:semicolon
DECL|struct|icbDiag
r_typedef
r_struct
id|icbDiag
(brace
DECL|member|op
id|unchar
id|op
suffix:semicolon
DECL|member|type
id|unchar
id|type
suffix:semicolon
multiline_comment|/* diagnostics type code (0-3) */
DECL|member|len
id|unchar
id|len
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* buffer length               */
DECL|member|ptr
id|unchar
id|ptr
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* buffer address              */
DECL|member|rsvd
id|unchar
id|rsvd
(braket
l_int|7
)braket
suffix:semicolon
multiline_comment|/* reserved                    */
DECL|member|vue
r_volatile
id|unchar
id|vue
suffix:semicolon
multiline_comment|/* vendor-unique error code    */
DECL|member|status
r_volatile
id|unchar
id|status
suffix:semicolon
multiline_comment|/* returned (icmb) status      */
DECL|member|phase
r_volatile
id|unchar
id|phase
suffix:semicolon
multiline_comment|/* used by interrupt handler   */
DECL|typedef|IcbDiag
)brace
id|IcbDiag
suffix:semicolon
DECL|macro|ICB_DIAG_POWERUP
mdefine_line|#define ICB_DIAG_POWERUP   0&t;/* Power-up diags only       */
DECL|macro|ICB_DIAG_WALKING
mdefine_line|#define ICB_DIAG_WALKING   1&t;/* walking 1&squot;s pattern       */
DECL|macro|ICB_DIAG_DMA
mdefine_line|#define ICB_DIAG_DMA       2&t;/* DMA - system memory diags */
DECL|macro|ICB_DIAG_FULL
mdefine_line|#define ICB_DIAG_FULL      3&t;/* do both 1 &amp; 2             */
DECL|struct|icbParms
r_typedef
r_struct
id|icbParms
(brace
DECL|member|op
id|unchar
id|op
suffix:semicolon
DECL|member|rsvd1
id|unchar
id|rsvd1
suffix:semicolon
multiline_comment|/* reserved                  */
DECL|member|len
id|unchar
id|len
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* parms buffer length       */
DECL|member|ptr
id|unchar
id|ptr
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* parms buffer address      */
DECL|member|idx
id|unchar
id|idx
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* index (MSB-LSB)           */
DECL|member|rsvd2
id|unchar
id|rsvd2
(braket
l_int|5
)braket
suffix:semicolon
multiline_comment|/* reserved                  */
DECL|member|vue
r_volatile
id|unchar
id|vue
suffix:semicolon
multiline_comment|/* vendor-unique error code  */
DECL|member|status
r_volatile
id|unchar
id|status
suffix:semicolon
multiline_comment|/* returned (icmb) status    */
DECL|member|phase
r_volatile
id|unchar
id|phase
suffix:semicolon
multiline_comment|/* used by interrupt handler */
DECL|typedef|IcbParms
)brace
id|IcbParms
suffix:semicolon
DECL|struct|icbAny
r_typedef
r_struct
id|icbAny
(brace
DECL|member|op
id|unchar
id|op
suffix:semicolon
DECL|member|data
id|unchar
id|data
(braket
l_int|14
)braket
suffix:semicolon
multiline_comment|/* format-specific data      */
DECL|member|vue
r_volatile
id|unchar
id|vue
suffix:semicolon
multiline_comment|/* vendor-unique error code  */
DECL|member|status
r_volatile
id|unchar
id|status
suffix:semicolon
multiline_comment|/* returned (icmb) status    */
DECL|member|phase
r_volatile
id|unchar
id|phase
suffix:semicolon
multiline_comment|/* used by interrupt handler */
DECL|typedef|IcbAny
)brace
id|IcbAny
suffix:semicolon
DECL|union|icb
r_typedef
r_union
id|icb
(brace
DECL|member|op
id|unchar
id|op
suffix:semicolon
multiline_comment|/* ICB opcode                     */
DECL|member|recv_cmd
id|IcbRecvCmd
id|recv_cmd
suffix:semicolon
multiline_comment|/* format for receive command     */
DECL|member|send_stat
id|IcbSendStat
id|send_stat
suffix:semicolon
multiline_comment|/* format for send status         */
DECL|member|rev_lvl
id|IcbRevLvl
id|rev_lvl
suffix:semicolon
multiline_comment|/* format for get revision level  */
DECL|member|diag
id|IcbDiag
id|diag
suffix:semicolon
multiline_comment|/* format for execute diagnostics */
DECL|member|eparms
id|IcbParms
id|eparms
suffix:semicolon
multiline_comment|/* format for get/set exec parms  */
DECL|member|icb
id|IcbAny
id|icb
suffix:semicolon
multiline_comment|/* generic format                 */
DECL|member|data
id|unchar
id|data
(braket
l_int|18
)braket
suffix:semicolon
DECL|typedef|Icb
)brace
id|Icb
suffix:semicolon
macro_line|#ifdef MODULE
DECL|variable|wd7000
r_static
r_char
op_star
id|wd7000
op_assign
l_int|NULL
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|wd7000
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *  Driver SCB structure pool.&n; *&n; *  The SCBs declared here are shared by all host adapters; hence, this&n; *  structure is not part of the Adapter structure.&n; */
DECL|variable|scbs
r_static
id|Scb
id|scbs
(braket
id|MAX_SCBS
)braket
suffix:semicolon
DECL|variable|scbfree
r_static
id|Scb
op_star
id|scbfree
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* free list         */
DECL|variable|freescbs
r_static
r_int
id|freescbs
op_assign
id|MAX_SCBS
suffix:semicolon
multiline_comment|/* free list counter */
multiline_comment|/*&n; *  END of data/declarations - code follows.&n; */
DECL|function|setup_error
r_static
r_void
id|setup_error
(paren
r_char
op_star
id|mesg
comma
r_int
op_star
id|ints
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_eq
l_int|3
)paren
id|printk
(paren
l_string|&quot;wd7000_setup: &bslash;&quot;wd7000=%d,%d,0x%x&bslash;&quot; -&gt; %s&bslash;n&quot;
comma
id|ints
(braket
l_int|1
)braket
comma
id|ints
(braket
l_int|2
)braket
comma
id|ints
(braket
l_int|3
)braket
comma
id|mesg
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_eq
l_int|4
)paren
id|printk
(paren
l_string|&quot;wd7000_setup: &bslash;&quot;wd7000=%d,%d,0x%x,%d&bslash;&quot; -&gt; %s&bslash;n&quot;
comma
id|ints
(braket
l_int|1
)braket
comma
id|ints
(braket
l_int|2
)braket
comma
id|ints
(braket
l_int|3
)braket
comma
id|ints
(braket
l_int|4
)braket
comma
id|mesg
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;wd7000_setup: &bslash;&quot;wd7000=%d,%d,0x%x,%d,%d&bslash;&quot; -&gt; %s&bslash;n&quot;
comma
id|ints
(braket
l_int|1
)braket
comma
id|ints
(braket
l_int|2
)braket
comma
id|ints
(braket
l_int|3
)braket
comma
id|ints
(braket
l_int|4
)braket
comma
id|ints
(braket
l_int|5
)braket
comma
id|mesg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: You can now set these options from the kernel&squot;s &quot;command line&quot;.&n; * The syntax is:&n; *&n; *     wd7000=&lt;IRQ&gt;,&lt;DMA&gt;,&lt;IO&gt;[,&lt;BUS_ON&gt;[,&lt;BUS_OFF&gt;]]&n; *&n; * , where BUS_ON and BUS_OFF are in nanoseconds. BIOS default values&n; * are 8000ns for BUS_ON and 1875ns for BUS_OFF.&n; * eg:&n; *     wd7000=7,6,0x350&n; *&n; * will configure the driver for a WD-7000 controller&n; * using IRQ 15 with a DMA channel 6, at IO base address 0x350.&n; */
DECL|function|wd7000_setup
r_static
r_int
id|__init
id|wd7000_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_static
r_int
id|wd7000_card_num
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|ints
(braket
l_int|6
)braket
suffix:semicolon
(paren
r_void
)paren
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wd7000_card_num
op_ge
id|NUM_CONFIGS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;wd7000_setup: Too many &bslash;&quot;wd7000=&bslash;&quot; configurations in &quot;
l_string|&quot;command line!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ints
(braket
l_int|0
)braket
OL
l_int|3
)paren
op_logical_or
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|5
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;wd7000_setup: Error in command line!  &quot;
l_string|&quot;Usage: wd7000=&lt;IRQ&gt;,&lt;DMA&gt;,IO&gt;[,&lt;BUS_ON&gt;[,&lt;BUS_OFF&gt;]]&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_IRQS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ints
(braket
l_int|1
)braket
op_eq
id|wd7000_irq
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|NUM_IRQS
)paren
(brace
id|setup_error
c_func
(paren
l_string|&quot;invalid IRQ.&quot;
comma
id|ints
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|configs
(braket
id|wd7000_card_num
)braket
dot
id|irq
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_DMAS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ints
(braket
l_int|2
)braket
op_eq
id|wd7000_dma
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|NUM_DMAS
)paren
(brace
id|setup_error
c_func
(paren
l_string|&quot;invalid DMA channel.&quot;
comma
id|ints
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|configs
(braket
id|wd7000_card_num
)braket
dot
id|dma
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_IOPORTS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ints
(braket
l_int|3
)braket
op_eq
id|wd7000_iobase
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|NUM_IOPORTS
)paren
(brace
id|setup_error
c_func
(paren
l_string|&quot;invalid I/O base address.&quot;
comma
id|ints
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|configs
(braket
id|wd7000_card_num
)braket
dot
id|iobase
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|3
)paren
(brace
r_if
c_cond
(paren
(paren
id|ints
(braket
l_int|4
)braket
OL
l_int|500
)paren
op_logical_or
(paren
id|ints
(braket
l_int|4
)braket
OG
l_int|31875
)paren
)paren
(brace
id|setup_error
c_func
(paren
l_string|&quot;BUS_ON value is out of range (500 to 31875 nanoseconds)!&quot;
comma
id|ints
)paren
suffix:semicolon
id|configs
(braket
id|wd7000_card_num
)braket
dot
id|bus_on
op_assign
id|BUS_ON
suffix:semicolon
)brace
r_else
id|configs
(braket
id|wd7000_card_num
)braket
dot
id|bus_on
op_assign
id|ints
(braket
l_int|4
)braket
op_div
l_int|125
suffix:semicolon
)brace
r_else
id|configs
(braket
id|wd7000_card_num
)braket
dot
id|bus_on
op_assign
id|BUS_ON
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|4
)paren
(brace
r_if
c_cond
(paren
(paren
id|ints
(braket
l_int|5
)braket
OL
l_int|500
)paren
op_logical_or
(paren
id|ints
(braket
l_int|5
)braket
OG
l_int|31875
)paren
)paren
(brace
id|setup_error
c_func
(paren
l_string|&quot;BUS_OFF value is out of range (500 to 31875 nanoseconds)!&quot;
comma
id|ints
)paren
suffix:semicolon
id|configs
(braket
id|wd7000_card_num
)braket
dot
id|bus_off
op_assign
id|BUS_OFF
suffix:semicolon
)brace
r_else
id|configs
(braket
id|wd7000_card_num
)braket
dot
id|bus_off
op_assign
id|ints
(braket
l_int|5
)braket
op_div
l_int|125
suffix:semicolon
)brace
r_else
id|configs
(braket
id|wd7000_card_num
)braket
dot
id|bus_off
op_assign
id|BUS_OFF
suffix:semicolon
r_if
c_cond
(paren
id|wd7000_card_num
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|wd7000_card_num
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
r_for
c_loop
(paren
id|j
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|j
OL
id|wd7000_card_num
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|configs
(braket
id|i
)braket
dot
id|irq
op_eq
id|configs
(braket
id|j
)braket
dot
id|irq
)paren
(brace
id|setup_error
c_func
(paren
l_string|&quot;duplicated IRQ!&quot;
comma
id|ints
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|configs
(braket
id|i
)braket
dot
id|dma
op_eq
id|configs
(braket
id|j
)braket
dot
id|dma
)paren
(brace
id|setup_error
c_func
(paren
l_string|&quot;duplicated DMA channel!&quot;
comma
id|ints
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|configs
(braket
id|i
)braket
dot
id|iobase
op_eq
id|configs
(braket
id|j
)braket
dot
id|iobase
)paren
(brace
id|setup_error
(paren
l_string|&quot;duplicated I/O base address!&quot;
comma
id|ints
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;wd7000_setup: IRQ=%d, DMA=%d, I/O=0x%x, BUS_ON=%dns, BUS_OFF=%dns&bslash;n&quot;
comma
id|configs
(braket
id|wd7000_card_num
)braket
dot
id|irq
comma
id|configs
(braket
id|wd7000_card_num
)braket
dot
id|dma
comma
id|configs
(braket
id|wd7000_card_num
)braket
dot
id|iobase
comma
id|configs
(braket
id|wd7000_card_num
)braket
dot
id|bus_on
op_star
l_int|125
comma
id|configs
(braket
id|wd7000_card_num
)braket
dot
id|bus_off
op_star
l_int|125
)paren
suffix:semicolon
macro_line|#endif
id|wd7000_card_num
op_increment
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;wd7000=&quot;
comma
id|wd7000_setup
)paren
suffix:semicolon
macro_line|#ifdef ANY2SCSI_INLINE
multiline_comment|/*&n; * Since they&squot;re used a lot, I&squot;ve redone the following from the macros&n; * formerly in wd7000.h, hopefully to speed them up by getting rid of&n; * all the shifting (it may not matter; GCC might have done as well anyway).&n; *&n; * xany2scsi and xscsi2int were not being used, and are no longer defined.&n; * (They were simply 4-byte versions of these routines).&n; */
r_typedef
r_union
(brace
multiline_comment|/* let&squot;s cheat... */
DECL|member|i
r_int
id|i
suffix:semicolon
DECL|member|u
id|unchar
id|u
(braket
r_sizeof
(paren
r_int
)paren
)braket
suffix:semicolon
multiline_comment|/* the sizeof(int) makes it more portable */
DECL|typedef|i_u
)brace
id|i_u
suffix:semicolon
DECL|function|any2scsi
r_static
r_inline
r_void
id|any2scsi
(paren
id|unchar
op_star
id|scsi
comma
r_int
id|any
)paren
(brace
op_star
id|scsi
op_increment
op_assign
(paren
(paren
id|i_u
)paren
id|any
)paren
dot
id|u
(braket
l_int|2
)braket
suffix:semicolon
op_star
id|scsi
op_increment
op_assign
(paren
(paren
id|i_u
)paren
id|any
)paren
dot
id|u
(braket
l_int|1
)braket
suffix:semicolon
op_star
id|scsi
op_increment
op_assign
(paren
(paren
id|i_u
)paren
id|any
)paren
dot
id|u
(braket
l_int|0
)braket
suffix:semicolon
)brace
DECL|function|scsi2int
r_static
r_inline
r_int
id|scsi2int
(paren
id|unchar
op_star
id|scsi
)paren
(brace
id|i_u
id|result
suffix:semicolon
id|result.i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clears unused bytes */
id|result.u
(braket
l_int|2
)braket
op_assign
op_star
id|scsi
op_increment
suffix:semicolon
id|result.u
(braket
l_int|1
)braket
op_assign
op_star
id|scsi
op_increment
suffix:semicolon
id|result.u
(braket
l_int|0
)braket
op_assign
op_star
id|scsi
op_increment
suffix:semicolon
r_return
(paren
id|result.i
)paren
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/*&n; * These are the old ones - I&squot;ve just moved them here...&n; */
DECL|macro|any2scsi
macro_line|#undef any2scsi
DECL|macro|any2scsi
mdefine_line|#define any2scsi(up, p)   (up)[0] = (((unsigned long) (p)) &gt;&gt; 16);&t;&bslash;&n;&t;&t;&t;  (up)[1] = ((unsigned long) (p)) &gt;&gt; 8;&t;&t;&bslash;&n;&t;&t;&t;  (up)[2] = ((unsigned long) (p));
DECL|macro|scsi2int
macro_line|#undef scsi2int
DECL|macro|scsi2int
mdefine_line|#define scsi2int(up)   ( (((unsigned long) *(up)) &lt;&lt; 16) +&t;&bslash;&n;&t;&t;&t; (((unsigned long) (up)[1]) &lt;&lt; 8) +&t;&bslash;&n;&t;&t;&t; ((unsigned long) (up)[2]) )
macro_line|#endif
DECL|function|wd7000_enable_intr
r_static
r_inline
r_void
id|wd7000_enable_intr
(paren
id|Adapter
op_star
id|host
)paren
(brace
id|host-&gt;control
op_or_assign
id|INT_EN
suffix:semicolon
id|outb
(paren
id|host-&gt;control
comma
id|host-&gt;iobase
op_plus
id|ASC_CONTROL
)paren
suffix:semicolon
)brace
DECL|function|wd7000_enable_dma
r_static
r_inline
r_void
id|wd7000_enable_dma
(paren
id|Adapter
op_star
id|host
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|host-&gt;control
op_or_assign
id|DMA_EN
suffix:semicolon
id|outb
(paren
id|host-&gt;control
comma
id|host-&gt;iobase
op_plus
id|ASC_CONTROL
)paren
suffix:semicolon
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|set_dma_mode
(paren
id|host-&gt;dma
comma
id|DMA_MODE_CASCADE
)paren
suffix:semicolon
id|enable_dma
(paren
id|host-&gt;dma
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|macro|WAITnexttimeout
mdefine_line|#define WAITnexttimeout 200&t;/* 2 seconds */
DECL|function|WAIT
r_static
r_inline
r_int
id|WAIT
(paren
r_int
id|port
comma
r_int
id|mask
comma
r_int
id|allof
comma
r_int
id|noneof
)paren
(brace
r_register
r_int
id|WAITbits
suffix:semicolon
r_register
r_int
r_int
id|WAITtimeout
op_assign
id|jiffies
op_plus
id|WAITnexttimeout
suffix:semicolon
r_while
c_loop
(paren
id|time_before_eq
c_func
(paren
id|jiffies
comma
id|WAITtimeout
)paren
)paren
(brace
id|WAITbits
op_assign
id|inb
(paren
id|port
)paren
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|WAITbits
op_amp
id|allof
)paren
op_eq
id|allof
)paren
op_logical_and
(paren
(paren
id|WAITbits
op_amp
id|noneof
)paren
op_eq
l_int|0
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|delay
r_static
r_inline
r_void
id|delay
(paren
r_int
id|how_long
)paren
(brace
r_register
r_int
r_int
id|time
op_assign
id|jiffies
op_plus
id|how_long
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|time
)paren
)paren
suffix:semicolon
)brace
DECL|function|command_out
r_static
r_inline
r_int
id|command_out
(paren
id|Adapter
op_star
id|host
comma
id|unchar
op_star
id|cmd
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|WAIT
(paren
id|host-&gt;iobase
op_plus
id|ASC_STAT
comma
id|ASC_STATMASK
comma
id|CMD_RDY
comma
l_int|0
)paren
)paren
(brace
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
r_do
(brace
id|outb
(paren
op_star
id|cmd
comma
id|host-&gt;iobase
op_plus
id|ASC_COMMAND
)paren
suffix:semicolon
id|WAIT
(paren
id|host-&gt;iobase
op_plus
id|ASC_STAT
comma
id|ASC_STATMASK
comma
id|CMD_RDY
comma
l_int|0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|inb
(paren
id|host-&gt;iobase
op_plus
id|ASC_STAT
)paren
op_amp
id|CMD_REJ
)paren
suffix:semicolon
id|cmd
op_increment
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;wd7000 command_out: WAIT failed(%d)&bslash;n&quot;
comma
id|len
op_plus
l_int|1
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  This version of alloc_scbs is in preparation for supporting multiple&n; *  commands per lun and command chaining, by queueing pending commands.&n; *  We will need to allocate Scbs in blocks since they will wait to be&n; *  executed so there is the possibility of deadlock otherwise.&n; *  Also, to keep larger requests from being starved by smaller requests,&n; *  we limit access to this routine with an internal busy flag, so that&n; *  the satisfiability of a request is not dependent on the size of the&n; *  request.&n; */
DECL|function|alloc_scbs
r_static
r_inline
id|Scb
op_star
id|alloc_scbs
(paren
r_int
id|needed
)paren
(brace
r_register
id|Scb
op_star
id|scb
comma
op_star
id|p
suffix:semicolon
r_register
r_int
r_int
id|flags
suffix:semicolon
r_register
r_int
r_int
id|timeout
op_assign
id|jiffies
op_plus
id|WAITnexttimeout
suffix:semicolon
r_register
r_int
r_int
id|now
suffix:semicolon
r_static
r_int
id|busy
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|needed
op_le
l_int|0
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* sanity check */
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|busy
)paren
(brace
multiline_comment|/* someone else is allocating */
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|now
op_assign
id|jiffies
suffix:semicolon
id|now
op_eq
id|jiffies
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* wait a jiffy */
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
)brace
id|busy
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* not busy now; it&squot;s our turn */
r_while
c_loop
(paren
id|freescbs
OL
id|needed
)paren
(brace
id|timeout
op_assign
id|jiffies
op_plus
id|WAITnexttimeout
suffix:semicolon
r_do
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|now
op_assign
id|jiffies
suffix:semicolon
id|now
op_eq
id|jiffies
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* wait a jiffy */
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|freescbs
OL
id|needed
op_logical_and
id|time_before_eq
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  If we get here with enough free Scbs, we can take them.&n;&t; *  Otherwise, we timed out and didn&squot;t get enough.&n;&t; */
r_if
c_cond
(paren
id|freescbs
OL
id|needed
)paren
(brace
id|busy
op_assign
l_int|0
suffix:semicolon
id|panic
(paren
l_string|&quot;wd7000: can&squot;t get enough free SCBs.&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
id|scb
op_assign
id|scbfree
suffix:semicolon
id|freescbs
op_sub_assign
id|needed
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|needed
suffix:semicolon
id|i
op_increment
)paren
(brace
id|p
op_assign
id|scbfree
suffix:semicolon
id|scbfree
op_assign
id|p-&gt;next
suffix:semicolon
)brace
id|p-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|busy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we&squot;re done */
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
id|scb
)paren
suffix:semicolon
)brace
DECL|function|free_scb
r_static
r_inline
r_void
id|free_scb
(paren
id|Scb
op_star
id|scb
)paren
(brace
r_register
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|memset
(paren
id|scb
comma
l_int|0
comma
r_sizeof
(paren
id|Scb
)paren
)paren
suffix:semicolon
id|scb-&gt;next
op_assign
id|scbfree
suffix:semicolon
id|scbfree
op_assign
id|scb
suffix:semicolon
id|freescbs
op_increment
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|init_scbs
r_static
r_inline
r_void
id|init_scbs
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|scbfree
op_assign
op_amp
(paren
id|scbs
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|memset
(paren
id|scbs
comma
l_int|0
comma
r_sizeof
(paren
id|scbs
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SCBS
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scbs
(braket
id|i
)braket
dot
id|next
op_assign
op_amp
(paren
id|scbs
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|scbs
(braket
id|i
)braket
dot
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
)brace
id|scbs
(braket
id|MAX_SCBS
op_minus
l_int|1
)braket
dot
id|next
op_assign
l_int|NULL
suffix:semicolon
id|scbs
(braket
id|MAX_SCBS
op_minus
l_int|1
)braket
dot
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|mail_out
r_static
r_int
id|mail_out
(paren
id|Adapter
op_star
id|host
comma
id|Scb
op_star
id|scbptr
)paren
multiline_comment|/*&n; *  Note: this can also be used for ICBs; just cast to the parm type.&n; */
(brace
r_register
r_int
id|i
comma
id|ogmb
suffix:semicolon
r_register
r_int
r_int
id|flags
suffix:semicolon
id|unchar
id|start_ogmb
suffix:semicolon
id|Mailbox
op_star
id|ogmbs
op_assign
id|host-&gt;mb.ogmb
suffix:semicolon
r_int
op_star
id|next_ogmb
op_assign
op_amp
(paren
id|host-&gt;next_ogmb
)paren
suffix:semicolon
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;wd7000_mail_out: 0x%06lx&quot;
comma
(paren
r_int
)paren
id|scbptr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* We first look for a free outgoing mailbox */
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|ogmb
op_assign
op_star
id|next_ogmb
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|OGMB_CNT
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ogmbs
(braket
id|ogmb
)braket
dot
id|status
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot; using OGMB 0x%x&quot;
comma
id|ogmb
)paren
suffix:semicolon
macro_line|#endif
id|ogmbs
(braket
id|ogmb
)braket
dot
id|status
op_assign
l_int|1
suffix:semicolon
id|any2scsi
(paren
(paren
id|unchar
op_star
)paren
id|ogmbs
(braket
id|ogmb
)braket
dot
id|scbptr
comma
(paren
r_int
)paren
id|scbptr
)paren
suffix:semicolon
op_star
id|next_ogmb
op_assign
(paren
id|ogmb
op_plus
l_int|1
)paren
op_mod
id|OGMB_CNT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
id|ogmb
op_assign
(paren
id|ogmb
op_plus
l_int|1
)paren
op_mod
id|OGMB_CNT
suffix:semicolon
)brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;, scb is 0x%06lx&quot;
comma
(paren
r_int
)paren
id|scbptr
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|i
op_ge
id|OGMB_CNT
)paren
(brace
multiline_comment|/*&n;&t; *  Alternatively, we might issue the &quot;interrupt on free OGMB&quot;,&n;&t; *  and sleep, but it must be ensured that it isn&squot;t the init&n;&t; *  task running.  Instead, this version assumes that the caller&n;&t; *  will be persistent, and try again.  Since it&squot;s the adapter&n;&t; *  that marks OGMB&squot;s free, waiting even with interrupts off&n;&t; *  should work, since they are freed very quickly in most cases.&n;&t; */
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;, no free OGMBs.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|wd7000_enable_intr
(paren
id|host
)paren
suffix:semicolon
id|start_ogmb
op_assign
id|START_OGMB
op_or
id|ogmb
suffix:semicolon
id|command_out
(paren
id|host
comma
op_amp
id|start_ogmb
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;, awaiting interrupt.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|make_code
r_int
id|make_code
(paren
r_int
id|hosterr
comma
r_int
id|scsierr
)paren
(brace
macro_line|#ifdef WD7000_DEBUG
r_int
id|in_error
op_assign
id|hosterr
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
(paren
id|hosterr
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Reserved */
id|hosterr
op_assign
id|DID_ERROR
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* Command Complete, no errors */
id|hosterr
op_assign
id|DID_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* Command complete, error logged in scb status (scsierr) */
id|hosterr
op_assign
id|DID_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* Command failed to complete - timeout */
id|hosterr
op_assign
id|DID_TIME_OUT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
multiline_comment|/* Command terminated; Bus reset by external device */
id|hosterr
op_assign
id|DID_RESET
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* Unexpected Command Received w/ host as target */
id|hosterr
op_assign
id|DID_BAD_TARGET
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|80
suffix:colon
multiline_comment|/* Unexpected Reselection */
r_case
l_int|81
suffix:colon
multiline_comment|/* Unexpected Selection */
id|hosterr
op_assign
id|DID_BAD_INTR
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|82
suffix:colon
multiline_comment|/* Abort Command Message  */
id|hosterr
op_assign
id|DID_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|83
suffix:colon
multiline_comment|/* SCSI Bus Software Reset */
r_case
l_int|84
suffix:colon
multiline_comment|/* SCSI Bus Hardware Reset */
id|hosterr
op_assign
id|DID_RESET
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Reserved */
id|hosterr
op_assign
id|DID_ERROR
suffix:semicolon
)brace
macro_line|#ifdef WD7000_DEBUG
r_if
c_cond
(paren
id|scsierr
op_logical_or
id|hosterr
)paren
id|printk
(paren
l_string|&quot;&bslash;nSCSI command error: SCSI 0x%02x host 0x%04x return %d&bslash;n&quot;
comma
id|scsierr
comma
id|in_error
comma
id|hosterr
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|scsierr
op_or
(paren
id|hosterr
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
)brace
DECL|function|wd7000_scsi_done
r_static
r_void
id|wd7000_scsi_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;wd7000_scsi_done: 0x%06lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|SCpnt
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt-&gt;SCp.phase
op_assign
l_int|0
suffix:semicolon
)brace
DECL|macro|wd7000_intr_ack
mdefine_line|#define wd7000_intr_ack(host)   outb (0, host-&gt;iobase + ASC_INTR_ACK)
DECL|function|wd7000_intr_handle
r_void
id|wd7000_intr_handle
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_register
r_int
id|flag
comma
id|icmb
comma
id|errstatus
comma
id|icmb_status
suffix:semicolon
r_register
r_int
id|host_error
comma
id|scsi_error
suffix:semicolon
r_register
id|Scb
op_star
id|scb
suffix:semicolon
multiline_comment|/* for SCSI commands */
r_register
id|IcbAny
op_star
id|icb
suffix:semicolon
multiline_comment|/* for host commands */
r_register
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|Adapter
op_star
id|host
op_assign
(paren
id|Adapter
op_star
)paren
id|wd7000_host
(braket
id|irq
op_minus
id|IRQ_MIN
)braket
op_member_access_from_pointer
id|hostdata
suffix:semicolon
multiline_comment|/* This MUST be set!!! */
id|Mailbox
op_star
id|icmbs
op_assign
id|host-&gt;mb.icmb
suffix:semicolon
id|host-&gt;int_counter
op_increment
suffix:semicolon
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;wd7000_intr_handle: irq = %d, host = 0x%06lx&bslash;n&quot;
comma
id|irq
comma
(paren
r_int
)paren
id|host
)paren
suffix:semicolon
macro_line|#endif
id|flag
op_assign
id|inb
(paren
id|host-&gt;iobase
op_plus
id|ASC_INTR_STAT
)paren
suffix:semicolon
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;wd7000_intr_handle: intr stat = 0x%02x&bslash;n&quot;
comma
id|flag
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
(paren
id|host-&gt;iobase
op_plus
id|ASC_STAT
)paren
op_amp
id|INT_IM
)paren
)paren
(brace
multiline_comment|/* NB: these are _very_ possible if IRQ 15 is being used, since&n;&t; * it&squot;s the &quot;garbage collector&quot; on the 2nd 8259 PIC.  Specifically,&n;&t; * any interrupt signal into the 8259 which can&squot;t be identified&n;&t; * comes out as 7 from the 8259, which is 15 to the host.  Thus, it&n;&t; * is a good thing the WD7000 has an interrupt status port, so we&n;&t; * can sort these out.  Otherwise, electrical noise and other such&n;&t; * problems would be indistinguishable from valid interrupts...&n;&t; */
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;wd7000_intr_handle: phantom interrupt...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|wd7000_intr_ack
(paren
id|host
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flag
op_amp
id|MB_INTR
)paren
(brace
multiline_comment|/* The interrupt is for a mailbox */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
id|IMB_INTR
)paren
)paren
(brace
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;wd7000_intr_handle: free outgoing mailbox&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;     * If sleep_on() and the &quot;interrupt on free OGMB&quot; command are&n;&t;     * used in mail_out(), wake_up() should correspondingly be called&n;&t;     * here.  For now, we don&squot;t need to do anything special.&n;&t;     */
id|wd7000_intr_ack
(paren
id|host
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The interrupt is for an incoming mailbox */
id|icmb
op_assign
id|flag
op_amp
id|MB_MASK
suffix:semicolon
id|icmb_status
op_assign
id|icmbs
(braket
id|icmb
)braket
dot
id|status
suffix:semicolon
r_if
c_cond
(paren
id|icmb_status
op_amp
l_int|0x80
)paren
(brace
multiline_comment|/* unsolicited - result in ICMB */
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;wd7000_intr_handle: unsolicited interrupt 0x%02x&bslash;n&quot;
comma
id|icmb_status
)paren
suffix:semicolon
macro_line|#endif
id|wd7000_intr_ack
(paren
id|host
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Aaaargh! (Zaga) */
id|scb
op_assign
id|bus_to_virt
c_func
(paren
id|scsi2int
(paren
(paren
id|unchar
op_star
)paren
id|icmbs
(braket
id|icmb
)braket
dot
id|scbptr
)paren
)paren
suffix:semicolon
id|icmbs
(braket
id|icmb
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;op
op_amp
id|ICB_OP_MASK
)paren
)paren
(brace
multiline_comment|/* an SCB is done */
id|SCpnt
op_assign
id|scb-&gt;SCpnt
suffix:semicolon
r_if
c_cond
(paren
op_decrement
(paren
id|SCpnt-&gt;SCp.phase
)paren
op_le
l_int|0
)paren
(brace
multiline_comment|/* all scbs are done */
id|host_error
op_assign
id|scb-&gt;vue
op_or
(paren
id|icmb_status
op_lshift
l_int|8
)paren
suffix:semicolon
id|scsi_error
op_assign
id|scb-&gt;status
suffix:semicolon
id|errstatus
op_assign
id|make_code
(paren
id|host_error
comma
id|scsi_error
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|errstatus
suffix:semicolon
id|free_scb
(paren
id|scb
)paren
suffix:semicolon
id|SCpnt-&gt;scsi_done
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* an ICB is done */
id|icb
op_assign
(paren
id|IcbAny
op_star
)paren
id|scb
suffix:semicolon
id|icb-&gt;status
op_assign
id|icmb_status
suffix:semicolon
id|icb-&gt;phase
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* incoming mailbox */
)brace
id|wd7000_intr_ack
(paren
id|host
)paren
suffix:semicolon
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;wd7000_intr_handle: return from interrupt handler&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|do_wd7000_intr_handle
r_void
id|do_wd7000_intr_handle
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|wd7000_intr_handle
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|wd7000_queuecommand
r_int
id|wd7000_queuecommand
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_register
id|Scb
op_star
id|scb
suffix:semicolon
r_register
id|Sgb
op_star
id|sgb
suffix:semicolon
r_register
id|unchar
op_star
id|cdb
op_assign
(paren
id|unchar
op_star
)paren
id|SCpnt-&gt;cmnd
suffix:semicolon
r_register
id|unchar
id|idlun
suffix:semicolon
r_register
r_int
id|cdblen
suffix:semicolon
id|Adapter
op_star
id|host
op_assign
(paren
id|Adapter
op_star
)paren
id|SCpnt-&gt;host-&gt;hostdata
suffix:semicolon
id|cdblen
op_assign
id|SCpnt-&gt;cmd_len
suffix:semicolon
id|idlun
op_assign
(paren
(paren
id|SCpnt-&gt;target
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
)paren
op_or
(paren
id|SCpnt-&gt;lun
op_amp
l_int|7
)paren
suffix:semicolon
id|SCpnt-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|SCpnt-&gt;SCp.phase
op_assign
l_int|1
suffix:semicolon
id|scb
op_assign
id|alloc_scbs
(paren
l_int|1
)paren
suffix:semicolon
id|scb-&gt;idlun
op_assign
id|idlun
suffix:semicolon
id|memcpy
(paren
id|scb-&gt;cdb
comma
id|cdb
comma
id|cdblen
)paren
suffix:semicolon
id|scb-&gt;direc
op_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* Disable direction check */
id|scb-&gt;SCpnt
op_assign
id|SCpnt
suffix:semicolon
multiline_comment|/* so we can find stuff later */
id|SCpnt-&gt;host_scribble
op_assign
(paren
id|unchar
op_star
)paren
id|scb
suffix:semicolon
id|scb-&gt;host
op_assign
id|host
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;request_buffer
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;sg_tablesize
op_eq
id|SG_NONE
)paren
(brace
id|panic
(paren
l_string|&quot;wd7000_queuecommand: scatter/gather not supported.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;Using scatter/gather with %d elements.&bslash;n&quot;
comma
id|SCpnt-&gt;use_sg
)paren
suffix:semicolon
macro_line|#endif
id|sgb
op_assign
id|scb-&gt;sgb
suffix:semicolon
id|scb-&gt;op
op_assign
l_int|1
suffix:semicolon
id|any2scsi
(paren
id|scb-&gt;dataptr
comma
(paren
r_int
)paren
id|sgb
)paren
suffix:semicolon
id|any2scsi
(paren
id|scb-&gt;maxlen
comma
id|SCpnt-&gt;use_sg
op_star
r_sizeof
(paren
id|Sgb
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
id|any2scsi
(paren
id|sgb
(braket
id|i
)braket
dot
id|ptr
comma
(paren
r_int
)paren
id|sg
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|any2scsi
(paren
id|sgb
(braket
id|i
)braket
dot
id|len
comma
id|sg
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|scb-&gt;op
op_assign
l_int|0
suffix:semicolon
id|any2scsi
(paren
id|scb-&gt;dataptr
comma
(paren
r_int
)paren
id|SCpnt-&gt;request_buffer
)paren
suffix:semicolon
id|any2scsi
(paren
id|scb-&gt;maxlen
comma
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|mail_out
(paren
id|host
comma
id|scb
)paren
)paren
suffix:semicolon
multiline_comment|/* keep trying */
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|wd7000_command
r_int
id|wd7000_command
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|wd7000_queuecommand
(paren
id|SCpnt
comma
id|wd7000_scsi_done
)paren
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt-&gt;SCp.phase
OG
l_int|0
)paren
id|barrier
(paren
)paren
suffix:semicolon
multiline_comment|/* phase counts scbs down to 0 */
r_return
(paren
id|SCpnt-&gt;result
)paren
suffix:semicolon
)brace
DECL|function|wd7000_diagnostics
r_int
id|wd7000_diagnostics
(paren
id|Adapter
op_star
id|host
comma
r_int
id|code
)paren
(brace
r_static
id|IcbDiag
id|icb
op_assign
(brace
id|ICB_OP_DIAGNOSTICS
)brace
suffix:semicolon
r_static
id|unchar
id|buf
(braket
l_int|256
)braket
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|icb.type
op_assign
id|code
suffix:semicolon
id|any2scsi
(paren
id|icb.len
comma
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
id|any2scsi
(paren
id|icb.ptr
comma
(paren
r_int
)paren
op_amp
id|buf
)paren
suffix:semicolon
id|icb.phase
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;     * This routine is only called at init, so there should be OGMBs&n;     * available.  I&squot;m assuming so here.  If this is going to&n;     * fail, I can just let the timeout catch the failure.&n;     */
id|mail_out
(paren
id|host
comma
(paren
r_struct
id|scb
op_star
)paren
op_amp
id|icb
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
id|WAITnexttimeout
suffix:semicolon
multiline_comment|/* wait up to 2 seconds */
r_while
c_loop
(paren
id|icb.phase
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
id|barrier
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for completion */
r_if
c_cond
(paren
id|icb.phase
)paren
(brace
id|printk
(paren
l_string|&quot;wd7000_diagnostics: timed out.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|make_code
(paren
id|icb.vue
op_or
(paren
id|icb.status
op_lshift
l_int|8
)paren
comma
l_int|0
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;wd7000_diagnostics: failed (0x%02x,0x%02x)&bslash;n&quot;
comma
id|icb.vue
comma
id|icb.status
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|wd7000_init
r_int
id|wd7000_init
(paren
id|Adapter
op_star
id|host
)paren
(brace
id|InitCmd
id|init_cmd
op_assign
(brace
id|INITIALIZATION
comma
l_int|7
comma
id|host-&gt;bus_on
comma
id|host-&gt;bus_off
comma
l_int|0
comma
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
id|OGMB_CNT
comma
id|ICMB_CNT
)brace
suffix:semicolon
r_int
id|diag
suffix:semicolon
multiline_comment|/*&n;     *  Reset the adapter - only.  The SCSI bus was initialized at power-up,&n;     *  and we need to do this just so we control the mailboxes, etc.&n;     */
id|outb
(paren
id|ASC_RES
comma
id|host-&gt;iobase
op_plus
id|ASC_CONTROL
)paren
suffix:semicolon
id|delay
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* reset pulse: this is 10ms, only need 25us */
id|outb
(paren
l_int|0
comma
id|host-&gt;iobase
op_plus
id|ASC_CONTROL
)paren
suffix:semicolon
id|host-&gt;control
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* this must always shadow ASC_CONTROL */
r_if
c_cond
(paren
id|WAIT
(paren
id|host-&gt;iobase
op_plus
id|ASC_STAT
comma
id|ASC_STATMASK
comma
id|CMD_RDY
comma
l_int|0
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;wd7000_init: WAIT timed out.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* 0 = not ok */
)brace
r_if
c_cond
(paren
(paren
id|diag
op_assign
id|inb
(paren
id|host-&gt;iobase
op_plus
id|ASC_INTR_STAT
)paren
)paren
op_ne
l_int|1
)paren
(brace
id|printk
(paren
l_string|&quot;wd7000_init: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|diag
)paren
(brace
r_case
l_int|2
suffix:colon
id|printk
(paren
l_string|&quot;RAM failure.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
(paren
l_string|&quot;FIFO R/W failed&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|printk
(paren
l_string|&quot;SBIC register R/W failed&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|printk
(paren
l_string|&quot;Initialization D-FF failed.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|printk
(paren
l_string|&quot;Host IRQ D-FF failed.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|printk
(paren
l_string|&quot;ROM checksum error.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;diagnostic code 0x%02Xh received.&bslash;n&quot;
comma
id|diag
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear mailboxes */
id|memset
(paren
op_amp
(paren
id|host-&gt;mb
)paren
comma
l_int|0
comma
r_sizeof
(paren
id|host-&gt;mb
)paren
)paren
suffix:semicolon
multiline_comment|/* Execute init command */
id|any2scsi
(paren
(paren
id|unchar
op_star
)paren
op_amp
(paren
id|init_cmd.mailboxes
)paren
comma
(paren
r_int
)paren
op_amp
(paren
id|host-&gt;mb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|command_out
(paren
id|host
comma
(paren
id|unchar
op_star
)paren
op_amp
id|init_cmd
comma
r_sizeof
(paren
id|init_cmd
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;wd7000_init: adapter initialization failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|WAIT
(paren
id|host-&gt;iobase
op_plus
id|ASC_STAT
comma
id|ASC_STATMASK
comma
id|ASC_INIT
comma
l_int|0
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;wd7000_init: WAIT timed out.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
(paren
id|host-&gt;irq
comma
id|do_wd7000_intr_handle
comma
id|SA_INTERRUPT
comma
l_string|&quot;wd7000&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;wd7000_init: can&squot;t get IRQ %d.&bslash;n&quot;
comma
id|host-&gt;irq
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_dma
(paren
id|host-&gt;dma
comma
l_string|&quot;wd7000&quot;
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;wd7000_init: can&squot;t get DMA channel %d.&bslash;n&quot;
comma
id|host-&gt;dma
)paren
suffix:semicolon
id|free_irq
(paren
id|host-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|wd7000_enable_dma
(paren
id|host
)paren
suffix:semicolon
id|wd7000_enable_intr
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wd7000_diagnostics
(paren
id|host
comma
id|ICB_DIAG_FULL
)paren
)paren
(brace
id|free_dma
(paren
id|host-&gt;dma
)paren
suffix:semicolon
id|free_irq
(paren
id|host-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|wd7000_revision
r_void
id|wd7000_revision
(paren
id|Adapter
op_star
id|host
)paren
(brace
r_static
id|IcbRevLvl
id|icb
op_assign
(brace
id|ICB_OP_GET_REVISION
)brace
suffix:semicolon
id|icb.phase
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;     * Like diagnostics, this is only done at init time, in fact, from&n;     * wd7000_detect, so there should be OGMBs available.  If it fails,&n;     * the only damage will be that the revision will show up as 0.0,&n;     * which in turn means that scatter/gather will be disabled.&n;     */
id|mail_out
(paren
id|host
comma
(paren
r_struct
id|scb
op_star
)paren
op_amp
id|icb
)paren
suffix:semicolon
r_while
c_loop
(paren
id|icb.phase
)paren
id|barrier
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for completion */
id|host-&gt;rev1
op_assign
id|icb.primary
suffix:semicolon
id|host-&gt;rev2
op_assign
id|icb.secondary
suffix:semicolon
)brace
DECL|macro|SPRINTF
macro_line|#undef SPRINTF
DECL|macro|SPRINTF
mdefine_line|#define SPRINTF(args...) { if (pos &lt; (buffer + length)) pos += sprintf (pos, ## args); }
DECL|function|wd7000_set_info
r_int
id|wd7000_set_info
(paren
r_char
op_star
id|buffer
comma
r_int
id|length
comma
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;Buffer = &lt;%.*s&gt;, length = %d&bslash;n&quot;
comma
id|length
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;     * Currently this is a no-op&n;     */
id|printk
(paren
l_string|&quot;Sorry, this function is currently out of order...&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
id|length
)paren
suffix:semicolon
)brace
DECL|function|wd7000_proc_info
r_int
id|wd7000_proc_info
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Device
op_star
id|scd
suffix:semicolon
id|Adapter
op_star
id|adapter
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|pos
op_assign
id|buffer
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef WD7000_DEBUG
id|Mailbox
op_star
id|ogmbs
comma
op_star
id|icmbs
suffix:semicolon
r_int
id|count
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;     * Find the specified host board.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IRQS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|wd7000_host
(braket
id|i
)braket
op_logical_and
(paren
id|wd7000_host
(braket
id|i
)braket
op_member_access_from_pointer
id|host_no
op_eq
id|hostno
)paren
)paren
(brace
id|host
op_assign
id|wd7000_host
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;     * Host not found!&n;     */
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
r_return
(paren
op_minus
id|ESRCH
)paren
suffix:semicolon
multiline_comment|/*&n;     * Has data been written to the file ?&n;     */
r_if
c_cond
(paren
id|inout
)paren
r_return
(paren
id|wd7000_set_info
(paren
id|buffer
comma
id|length
comma
id|host
)paren
)paren
suffix:semicolon
id|adapter
op_assign
(paren
id|Adapter
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;Host scsi%d: Western Digital WD-7000 (rev %d.%d)&bslash;n&quot;
comma
id|hostno
comma
id|adapter-&gt;rev1
comma
id|adapter-&gt;rev2
)paren
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;  IO base:      0x%x&bslash;n&quot;
comma
id|adapter-&gt;iobase
)paren
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;  IRQ:          %d&bslash;n&quot;
comma
id|adapter-&gt;irq
)paren
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;  DMA channel:  %d&bslash;n&quot;
comma
id|adapter-&gt;dma
)paren
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;  Interrupts:   %d&bslash;n&quot;
comma
id|adapter-&gt;int_counter
)paren
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;  BUS_ON time:  %d nanoseconds&bslash;n&quot;
comma
id|adapter-&gt;bus_on
op_star
l_int|125
)paren
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;  BUS_OFF time: %d nanoseconds&bslash;n&quot;
comma
id|adapter-&gt;bus_off
op_star
l_int|125
)paren
suffix:semicolon
macro_line|#ifdef WD7000_DEBUG
id|ogmbs
op_assign
id|adapter-&gt;mb.ogmb
suffix:semicolon
id|icmbs
op_assign
id|adapter-&gt;mb.icmb
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;&bslash;nControl port value: 0x%x&bslash;n&quot;
comma
id|adapter-&gt;control
)paren
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;Incoming mailbox:&bslash;n&quot;
)paren
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;  size: %d&bslash;n&quot;
comma
id|ICMB_CNT
)paren
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;  queued messages: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|count
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ICMB_CNT
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|icmbs
(braket
id|i
)braket
dot
id|status
)paren
(brace
id|count
op_increment
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;0x%x &quot;
comma
id|i
)paren
suffix:semicolon
)brace
id|SPRINTF
(paren
id|count
ques
c_cond
l_string|&quot;&bslash;n&quot;
suffix:colon
l_string|&quot;none&bslash;n&quot;
)paren
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;Outgoing mailbox:&bslash;n&quot;
)paren
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;  size: %d&bslash;n&quot;
comma
id|OGMB_CNT
)paren
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;  next message: 0x%x&bslash;n&quot;
comma
id|adapter-&gt;next_ogmb
)paren
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;  queued messages: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|count
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|OGMB_CNT
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ogmbs
(braket
id|i
)braket
dot
id|status
)paren
(brace
id|count
op_increment
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;0x%x &quot;
comma
id|i
)paren
suffix:semicolon
)brace
id|SPRINTF
(paren
id|count
ques
c_cond
l_string|&quot;&bslash;n&quot;
suffix:colon
l_string|&quot;none&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;     * Display driver information for each device attached to the board.&n;     */
id|scd
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;&bslash;nAttached devices: %s&bslash;n&quot;
comma
id|scd
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;none&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|scd
suffix:semicolon
id|scd
op_assign
id|scd-&gt;next
)paren
r_if
c_cond
(paren
id|scd-&gt;host-&gt;host_no
op_eq
id|hostno
)paren
(brace
id|SPRINTF
(paren
l_string|&quot;  [Channel: %02d, Id: %02d, Lun: %02d]  &quot;
comma
id|scd-&gt;channel
comma
id|scd-&gt;id
comma
id|scd-&gt;lun
)paren
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;%s &quot;
comma
(paren
id|scd-&gt;type
OL
id|MAX_SCSI_DEVICE_CODE
)paren
ques
c_cond
id|scsi_device_types
(braket
(paren
r_int
)paren
id|scd-&gt;type
)braket
suffix:colon
l_string|&quot;Unknown device&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|8
)paren
op_logical_and
(paren
id|scd-&gt;vendor
(braket
id|i
)braket
op_ge
l_int|0x20
)paren
suffix:semicolon
id|i
op_increment
)paren
id|SPRINTF
(paren
l_string|&quot;%c&quot;
comma
id|scd-&gt;vendor
(braket
id|i
)braket
)paren
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|16
)paren
op_logical_and
(paren
id|scd-&gt;model
(braket
id|i
)braket
op_ge
l_int|0x20
)paren
suffix:semicolon
id|i
op_increment
)paren
id|SPRINTF
(paren
l_string|&quot;%c&quot;
comma
id|scd-&gt;model
(braket
id|i
)braket
)paren
suffix:semicolon
id|SPRINTF
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|SPRINTF
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;     * Calculate start of next buffer, and return value.&n;     */
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pos
op_minus
id|buffer
)paren
OL
id|offset
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|pos
op_minus
id|buffer
op_minus
id|offset
)paren
OL
id|length
)paren
r_return
(paren
id|pos
op_minus
id|buffer
op_minus
id|offset
)paren
suffix:semicolon
r_else
r_return
(paren
id|length
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Returns the number of adapters this driver is supporting.&n; *&n; *  The source for hosts.c says to wait to call scsi_register until 100%&n; *  sure about an adapter.  We need to do it a little sooner here; we&n; *  need the storage set up by scsi_register before wd7000_init, and&n; *  changing the location of an Adapter structure is more trouble than&n; *  calling scsi_unregister.&n; *&n; */
DECL|function|wd7000_detect
r_int
id|wd7000_detect
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|present
op_assign
l_int|0
comma
id|biosaddr_ptr
comma
id|sig_ptr
comma
id|i
comma
id|pass
suffix:semicolon
r_int
id|biosptr
(braket
id|NUM_CONFIGS
)braket
suffix:semicolon
r_int
id|iobase
suffix:semicolon
id|Adapter
op_star
id|host
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|sh
suffix:semicolon
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;wd7000_detect: started&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|wd7000
)paren
id|wd7000_setup
c_func
(paren
id|wd7000
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IRQS
suffix:semicolon
id|wd7000_host
(braket
id|i
op_increment
)braket
op_assign
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_CONFIGS
suffix:semicolon
id|biosptr
(braket
id|i
op_increment
)braket
op_assign
op_minus
l_int|1
)paren
suffix:semicolon
id|tpnt-&gt;proc_name
op_assign
l_string|&quot;wd7000&quot;
suffix:semicolon
id|tpnt-&gt;proc_info
op_assign
op_amp
id|wd7000_proc_info
suffix:semicolon
multiline_comment|/*&n;     * Set up SCB free list, which is shared by all adapters&n;     */
id|init_scbs
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pass
op_assign
l_int|0
suffix:semicolon
id|pass
OL
id|NUM_CONFIGS
suffix:semicolon
id|pass
op_increment
)paren
(brace
multiline_comment|/*&n;&t; * First, search for BIOS SIGNATURE...&n;&t; */
r_for
c_loop
(paren
id|biosaddr_ptr
op_assign
l_int|0
suffix:semicolon
id|biosaddr_ptr
OL
id|NUM_ADDRS
suffix:semicolon
id|biosaddr_ptr
op_increment
)paren
r_for
c_loop
(paren
id|sig_ptr
op_assign
l_int|0
suffix:semicolon
id|sig_ptr
OL
id|NUM_SIGNATURES
suffix:semicolon
id|sig_ptr
op_increment
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pass
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|biosptr
(braket
id|i
)braket
op_eq
id|biosaddr_ptr
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|pass
)paren
(brace
r_void
op_star
id|biosaddr
op_assign
id|ioremap
(paren
id|wd7000_biosaddr
(braket
id|biosaddr_ptr
)braket
op_plus
id|signatures
(braket
id|sig_ptr
)braket
dot
id|ofs
comma
id|signatures
(braket
id|sig_ptr
)braket
dot
id|len
)paren
suffix:semicolon
r_int
id|bios_match
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|biosaddr
)paren
(brace
id|bios_match
op_assign
id|memcmp
(paren
(paren
r_char
op_star
)paren
id|biosaddr
comma
id|signatures
(braket
id|sig_ptr
)braket
dot
id|sig
comma
id|signatures
(braket
id|sig_ptr
)braket
dot
id|len
)paren
suffix:semicolon
)brace
id|iounmap
(paren
id|biosaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bios_match
)paren
r_goto
id|bios_matched
suffix:semicolon
)brace
)brace
id|bios_matched
suffix:colon
multiline_comment|/*&n;&t; * BIOS SIGNATURE has been found.&n;&t; */
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;wd7000_detect: pass %d&bslash;n&quot;
comma
id|pass
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|biosaddr_ptr
op_eq
id|NUM_ADDRS
)paren
id|printk
(paren
l_string|&quot;WD-7000 SST BIOS not detected...&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;WD-7000 SST BIOS detected at 0x%lx: checking...&bslash;n&quot;
comma
id|wd7000_biosaddr
(braket
id|biosaddr_ptr
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|configs
(braket
id|pass
)braket
dot
id|irq
OL
l_int|0
)paren
r_continue
suffix:semicolon
id|iobase
op_assign
id|configs
(braket
id|pass
)braket
dot
id|iobase
suffix:semicolon
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;wd7000_detect: check IO 0x%x region...&bslash;n&quot;
comma
id|iobase
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|check_region
(paren
id|iobase
comma
l_int|4
)paren
)paren
(brace
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;wd7000_detect: ASC reset (IO 0x%x) ...&quot;
comma
id|iobase
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;     * ASC reset...&n;&t;     */
id|outb
(paren
id|ASC_RES
comma
id|iobase
op_plus
id|ASC_CONTROL
)paren
suffix:semicolon
id|delay
(paren
l_int|1
)paren
suffix:semicolon
id|outb
(paren
l_int|0
comma
id|iobase
op_plus
id|ASC_CONTROL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|WAIT
(paren
id|iobase
op_plus
id|ASC_STAT
comma
id|ASC_STATMASK
comma
id|CMD_RDY
comma
l_int|0
)paren
)paren
macro_line|#ifdef WD7000_DEBUG
(brace
id|printk
(paren
l_string|&quot;failed!&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
id|printk
(paren
l_string|&quot;ok!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
r_continue
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|inb
(paren
id|iobase
op_plus
id|ASC_INTR_STAT
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; *  We register here, to get a pointer to the extra space,&n;&t;&t; *  which we&squot;ll use as the Adapter structure (host) for&n;&t;&t; *  this adapter.  It is located just after the registered&n;&t;&t; *  Scsi_Host structure (sh), and is located by the empty&n;&t;&t; *  array hostdata.&n;&t;&t; */
id|sh
op_assign
id|scsi_register
(paren
id|tpnt
comma
r_sizeof
(paren
id|Adapter
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
id|host
op_assign
(paren
id|Adapter
op_star
)paren
id|sh-&gt;hostdata
suffix:semicolon
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;wd7000_detect: adapter allocated at 0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|host
)paren
suffix:semicolon
macro_line|#endif
id|memset
(paren
id|host
comma
l_int|0
comma
r_sizeof
(paren
id|Adapter
)paren
)paren
suffix:semicolon
id|host-&gt;irq
op_assign
id|configs
(braket
id|pass
)braket
dot
id|irq
suffix:semicolon
id|host-&gt;dma
op_assign
id|configs
(braket
id|pass
)braket
dot
id|dma
suffix:semicolon
id|host-&gt;iobase
op_assign
id|iobase
suffix:semicolon
id|host-&gt;int_counter
op_assign
l_int|0
suffix:semicolon
id|host-&gt;bus_on
op_assign
id|configs
(braket
id|pass
)braket
dot
id|bus_on
suffix:semicolon
id|host-&gt;bus_off
op_assign
id|configs
(braket
id|pass
)braket
dot
id|bus_off
suffix:semicolon
id|host-&gt;sh
op_assign
id|wd7000_host
(braket
id|host-&gt;irq
op_minus
id|IRQ_MIN
)braket
op_assign
id|sh
suffix:semicolon
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;wd7000_detect: Trying init WD-7000 card at IO &quot;
l_string|&quot;0x%x, IRQ %d, DMA %d...&bslash;n&quot;
comma
id|host-&gt;iobase
comma
id|host-&gt;irq
comma
id|host-&gt;dma
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|wd7000_init
(paren
id|host
)paren
)paren
(brace
multiline_comment|/* Initialization failed */
id|scsi_unregister
(paren
id|sh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  OK from here - we&squot;ll use this adapter/configuration.&n;&t;&t; */
id|wd7000_revision
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* important for scatter/gather */
multiline_comment|/*&n;&t;&t; * Register our ports.&n;&t;&t; */
id|request_region
(paren
id|host-&gt;iobase
comma
l_int|4
comma
l_string|&quot;wd7000&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  For boards before rev 6.0, scatter/gather isn&squot;t supported.&n;&t;&t; */
r_if
c_cond
(paren
id|host-&gt;rev1
OL
l_int|6
)paren
id|sh-&gt;sg_tablesize
op_assign
id|SG_NONE
suffix:semicolon
id|present
op_increment
suffix:semicolon
multiline_comment|/* count it */
r_if
c_cond
(paren
id|biosaddr_ptr
op_ne
id|NUM_ADDRS
)paren
id|biosptr
(braket
id|pass
)braket
op_assign
id|biosaddr_ptr
suffix:semicolon
id|printk
(paren
l_string|&quot;Western Digital WD-7000 (rev %d.%d) &quot;
comma
id|host-&gt;rev1
comma
id|host-&gt;rev2
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;using IO 0x%x, IRQ %d, DMA %d.&bslash;n&quot;
comma
id|host-&gt;iobase
comma
id|host-&gt;irq
comma
id|host-&gt;dma
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;  BUS_ON time: %dns, BUS_OFF time: %dns&bslash;n&quot;
comma
id|host-&gt;bus_on
op_star
l_int|125
comma
id|host-&gt;bus_off
op_star
l_int|125
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef WD7000_DEBUG
r_else
id|printk
(paren
l_string|&quot;wd7000_detect: IO 0x%x region already allocated!&bslash;n&quot;
comma
id|iobase
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
op_logical_neg
id|present
)paren
id|printk
(paren
l_string|&quot;Failed initialization of WD-7000 SCSI card!&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|present
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  I have absolutely NO idea how to do an abort with the WD7000...&n; */
DECL|function|wd7000_abort
r_int
id|wd7000_abort
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|Adapter
op_star
id|host
op_assign
(paren
id|Adapter
op_star
)paren
id|SCpnt-&gt;host-&gt;hostdata
suffix:semicolon
r_if
c_cond
(paren
id|inb
(paren
id|host-&gt;iobase
op_plus
id|ASC_STAT
)paren
op_amp
id|INT_IM
)paren
(brace
id|printk
(paren
l_string|&quot;wd7000_abort: lost interrupt&bslash;n&quot;
)paren
suffix:semicolon
id|wd7000_intr_handle
(paren
id|host-&gt;irq
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
id|SCSI_ABORT_SUCCESS
)paren
suffix:semicolon
)brace
r_return
(paren
id|SCSI_ABORT_SNOOZE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  I also have no idea how to do a reset...&n; */
DECL|function|wd7000_reset
r_int
id|wd7000_reset
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_int
id|unused
)paren
(brace
r_return
(paren
id|SCSI_RESET_PUNT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  This was borrowed directly from aha1542.c. (Zaga)&n; */
DECL|function|wd7000_biosparam
r_int
id|wd7000_biosparam
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
op_star
id|ip
)paren
(brace
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;wd7000_biosparam: dev=%s, size=%d, &quot;
comma
id|kdevname
(paren
id|dev
)paren
comma
id|disk-&gt;capacity
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;     * try default translation&n;     */
id|ip
(braket
l_int|0
)braket
op_assign
l_int|64
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|32
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
id|disk-&gt;capacity
op_div
(paren
l_int|64
op_star
l_int|32
)paren
suffix:semicolon
multiline_comment|/*&n;     * for disks &gt;1GB do some guessing&n;     */
r_if
c_cond
(paren
id|ip
(braket
l_int|2
)braket
op_ge
l_int|1024
)paren
(brace
r_int
id|info
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * try to figure out the geometry from the partition table&n;&t; */
r_if
c_cond
(paren
(paren
id|scsicam_bios_param
(paren
id|disk
comma
id|dev
comma
id|info
)paren
OL
l_int|0
)paren
op_logical_or
op_logical_neg
(paren
(paren
(paren
id|info
(braket
l_int|0
)braket
op_eq
l_int|64
)paren
op_logical_and
(paren
id|info
(braket
l_int|1
)braket
op_eq
l_int|32
)paren
)paren
op_logical_or
(paren
(paren
id|info
(braket
l_int|0
)braket
op_eq
l_int|255
)paren
op_logical_and
(paren
id|info
(braket
l_int|1
)braket
op_eq
l_int|63
)paren
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;wd7000_biosparam: unable to verify geometry for disk with &gt;1GB.&bslash;n&quot;
l_string|&quot;                  using extended translation.&bslash;n&quot;
)paren
suffix:semicolon
id|ip
(braket
l_int|0
)braket
op_assign
l_int|255
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|63
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
id|disk-&gt;capacity
op_div
(paren
l_int|255
op_star
l_int|63
)paren
suffix:semicolon
)brace
r_else
(brace
id|ip
(braket
l_int|0
)braket
op_assign
id|info
(braket
l_int|0
)braket
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
id|info
(braket
l_int|1
)braket
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
id|info
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|info
(braket
l_int|0
)braket
op_eq
l_int|255
)paren
id|printk
(paren
l_string|&quot;wd7000_biosparam: current partition table is using extended translation.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef WD7000_DEBUG
id|printk
(paren
l_string|&quot;bios geometry: head=%d, sec=%d, cyl=%d&bslash;n&quot;
comma
id|ip
(braket
l_int|0
)braket
comma
id|ip
(braket
l_int|1
)braket
comma
id|ip
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;WARNING: check, if the bios geometry is correct.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Eventually this will go into an include file, but this will be later */
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|WD7000
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
eof
