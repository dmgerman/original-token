multiline_comment|/*&n; *    in2000.c -  Linux device driver for the&n; *                Always IN2000 ISA SCSI card.&n; *&n; * Copyright (c) 1996 John Shifflett, GeoLog Consulting&n; *    john@geolog.com&n; *    jshiffle@netcom.com&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; *&n; * Drew Eckhardt&squot;s excellent &squot;Generic NCR5380&squot; sources provided&n; * much of the inspiration and some of the code for this driver.&n; * The Linux IN2000 driver distributed in the Linux kernels through&n; * version 1.2.13 was an extremely valuable reference on the arcane&n; * (and still mysterious) workings of the IN2000&squot;s fifo. It also&n; * is where I lifted in2000_biosparam(), the gist of the card&n; * detection scheme, and other bits of code. Many thanks to the&n; * talented and courageous people who wrote, contributed to, and&n; * maintained that driver (including Brad McLean, Shaun Savage,&n; * Bill Earnest, Larry Doolittle, Roger Sunshine, John Luckey,&n; * Matt Postiff, Peter Lu, zerucha@shell.portal.com, and Eric&n; * Youngdale). I should also mention the driver written by&n; * Hamish Macdonald for the (GASP!) Amiga A2091 card, included&n; * in the Linux-m68k distribution; it gave me a good initial&n; * understanding of the proper way to run a WD33c93 chip, and I&n; * ended up stealing lots of code from it.&n; *&n; * _This_ driver is (I feel) an improvement over the old one in&n; * several respects:&n; *    -  All problems relating to the data size of a SCSI request are&n; *          gone (as far as I know). The old driver couldn&squot;t handle&n; *          swapping to partitions because that involved 4k blocks, nor&n; *          could it deal with the st.c tape driver unmodified, because&n; *          that usually involved 4k - 32k blocks. The old driver never&n; *          quite got away from a morbid dependence on 2k block sizes -&n; *          which of course is the size of the card&squot;s fifo.&n; *&n; *    -  Target Disconnection/Reconnection is now supported. Any&n; *          system with more than one device active on the SCSI bus&n; *          will benefit from this. The driver defaults to what I&squot;m&n; *          calling &squot;adaptive disconnect&squot; - meaning that each command&n; *          is evaluated individually as to whether or not it should&n; *          be run with the option to disconnect/reselect (if the&n; *          device chooses), or as a &quot;SCSI-bus-hog&quot;.&n; *&n; *    -  Synchronous data transfers are now supported. Because there&n; *          are a few devices (and many improperly terminated systems)&n; *          that choke when doing sync, the default is sync DISABLED&n; *          for all devices. This faster protocol can (and should!)&n; *          be enabled on selected devices via the command-line.&n; *&n; *    -  Runtime operating parameters can now be specified through&n; *       either the LILO or the &squot;insmod&squot; command line. For LILO do:&n; *          &quot;in2000=blah,blah,blah&quot;&n; *       and with insmod go like:&n; *          &quot;insmod /usr/src/linux/modules/in2000.o setup_strings=blah,blah&quot;&n; *       The defaults should be good for most people. See the comment&n; *       for &squot;setup_strings&squot; below for more details.&n; *&n; *    -  The old driver relied exclusively on what the Western Digital&n; *          docs call &quot;Combination Level 2 Commands&quot;, which are a great&n; *          idea in that the CPU is relieved of a lot of interrupt&n; *          overhead. However, by accepting a certain (user-settable)&n; *          amount of additional interrupts, this driver achieves&n; *          better control over the SCSI bus, and data transfers are&n; *          almost as fast while being much easier to define, track,&n; *          and debug.&n; *&n; *    -  You can force detection of a card whose BIOS has been disabled.&n; *&n; *    -  Multiple IN2000 cards might almost be supported. I&squot;ve tried to&n; *       keep it in mind, but have no way to test...&n; *&n; *&n; * TODO:&n; *       tagged queuing. multiple cards.&n; *&n; *&n; * NOTE:&n; *       When using this or any other SCSI driver as a module, you&squot;ll&n; *       find that with the stock kernel, at most _two_ SCSI hard&n; *       drives will be linked into the device list (ie, usable).&n; *       If your IN2000 card has more than 2 disks on its bus, you&n; *       might want to change the define of &squot;SD_EXTRA_DEVS&squot; in the&n; *       &squot;hosts.h&squot; file from 2 to whatever is appropriate. It took&n; *       me a while to track down this surprisingly obscure and&n; *       undocumented little &quot;feature&quot;.&n; *&n; *&n; * People with bug reports, wish-lists, complaints, comments,&n; * or improvements are asked to pah-leeez email me (John Shifflett)&n; * at john@geolog.com or jshiffle@netcom.com! I&squot;m anxious to get&n; * this thing into as good a shape as possible, and I&squot;m positive&n; * there are lots of lurking bugs and &quot;Stupid Places&quot;.&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &quot;hosts.h&quot;
DECL|macro|IN2000_VERSION
mdefine_line|#define IN2000_VERSION    &quot;1.33&quot;
DECL|macro|IN2000_DATE
mdefine_line|#define IN2000_DATE       &quot;26/August/1998&quot;
macro_line|#include &quot;in2000.h&quot;
multiline_comment|/*&n; * &squot;setup_strings&squot; is a single string used to pass operating parameters and&n; * settings from the kernel/module command-line to the driver. &squot;setup_args[]&squot;&n; * is an array of strings that define the compile-time default values for&n; * these settings. If Linux boots with a LILO or insmod command-line, those&n; * settings are combined with &squot;setup_args[]&squot;. Note that LILO command-lines&n; * are prefixed with &quot;in2000=&quot; while insmod uses a &quot;setup_strings=&quot; prefix.&n; * The driver recognizes the following keywords (lower case required) and&n; * arguments:&n; *&n; * -  ioport:addr    -Where addr is IO address of a (usually ROM-less) card.&n; * -  noreset        -No optional args. Prevents SCSI bus reset at boot time.&n; * -  nosync:x       -x is a bitmask where the 1st 7 bits correspond with&n; *                    the 7 possible SCSI devices (bit 0 for device #0, etc).&n; *                    Set a bit to PREVENT sync negotiation on that device.&n; *                    The driver default is sync DISABLED on all devices.&n; * -  period:ns      -ns is the minimum # of nanoseconds in a SCSI data transfer&n; *                    period. Default is 500; acceptable values are 250 - 1000.&n; * -  disconnect:x   -x = 0 to never allow disconnects, 2 to always allow them.&n; *                    x = 1 does &squot;adaptive&squot; disconnects, which is the default&n; *                    and generally the best choice.&n; * -  debug:x        -If &squot;DEBUGGING_ON&squot; is defined, x is a bitmask that causes&n; *                    various types of debug output to printed - see the DB_xxx&n; *                    defines in in2000.h&n; * -  proc:x         -If &squot;PROC_INTERFACE&squot; is defined, x is a bitmask that&n; *                    determines how the /proc interface works and what it&n; *                    does - see the PR_xxx defines in in2000.h&n; *&n; * Syntax Notes:&n; * -  Numeric arguments can be decimal or the &squot;0x&squot; form of hex notation. There&n; *    _must_ be a colon between a keyword and its numeric argument, with no&n; *    spaces.&n; * -  Keywords are separated by commas, no spaces, in the standard kernel&n; *    command-line manner.&n; * -  A keyword in the &squot;nth&squot; comma-separated command-line member will overwrite&n; *    the &squot;nth&squot; element of setup_args[]. A blank command-line member (in&n; *    other words, a comma with no preceding keyword) will _not_ overwrite&n; *    the corresponding setup_args[] element.&n; *&n; * A few LILO examples (for insmod, use &squot;setup_strings&squot; instead of &squot;in2000&squot;):&n; * -  in2000=ioport:0x220,noreset&n; * -  in2000=period:250,disconnect:2,nosync:0x03&n; * -  in2000=debug:0x1e&n; * -  in2000=proc:3&n; */
multiline_comment|/* Normally, no defaults are specified... */
DECL|variable|setup_args
r_static
r_char
op_star
id|setup_args
(braket
)braket
op_assign
(brace
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
)brace
suffix:semicolon
multiline_comment|/* filled in by &squot;insmod&squot; */
DECL|variable|setup_strings
r_static
r_char
op_star
id|setup_strings
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef MODULE_PARM
id|MODULE_PARM
c_func
(paren
id|setup_strings
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|instance_list
r_static
r_struct
id|Scsi_Host
op_star
id|instance_list
op_assign
l_int|0
suffix:semicolon
DECL|function|read_3393
r_static
r_inline
id|uchar
id|read_3393
c_func
(paren
r_struct
id|IN2000_hostdata
op_star
id|hostdata
comma
id|uchar
id|reg_num
)paren
(brace
id|write1_io
c_func
(paren
id|reg_num
comma
id|IO_WD_ADDR
)paren
suffix:semicolon
r_return
id|read1_io
c_func
(paren
id|IO_WD_DATA
)paren
suffix:semicolon
)brace
DECL|macro|READ_AUX_STAT
mdefine_line|#define READ_AUX_STAT() read1_io(IO_WD_ASR)
DECL|function|write_3393
r_static
r_inline
r_void
id|write_3393
c_func
(paren
r_struct
id|IN2000_hostdata
op_star
id|hostdata
comma
id|uchar
id|reg_num
comma
id|uchar
id|value
)paren
(brace
id|write1_io
c_func
(paren
id|reg_num
comma
id|IO_WD_ADDR
)paren
suffix:semicolon
id|write1_io
c_func
(paren
id|value
comma
id|IO_WD_DATA
)paren
suffix:semicolon
)brace
DECL|function|write_3393_cmd
r_static
r_inline
r_void
id|write_3393_cmd
c_func
(paren
r_struct
id|IN2000_hostdata
op_star
id|hostdata
comma
id|uchar
id|cmd
)paren
(brace
multiline_comment|/*   while (READ_AUX_STAT() &amp; ASR_CIP)&n;      printk(&quot;|&quot;);*/
id|write1_io
c_func
(paren
id|WD_COMMAND
comma
id|IO_WD_ADDR
)paren
suffix:semicolon
id|write1_io
c_func
(paren
id|cmd
comma
id|IO_WD_DATA
)paren
suffix:semicolon
)brace
DECL|function|read_1_byte
r_static
id|uchar
id|read_1_byte
c_func
(paren
r_struct
id|IN2000_hostdata
op_star
id|hostdata
)paren
(brace
id|uchar
id|asr
comma
id|x
op_assign
l_int|0
suffix:semicolon
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_POLLED
)paren
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_TRANS_INFO
op_or
l_int|0x80
)paren
suffix:semicolon
r_do
(brace
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asr
op_amp
id|ASR_DBR
)paren
id|x
op_assign
id|read_3393
c_func
(paren
id|hostdata
comma
id|WD_DATA
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
DECL|function|write_3393_count
r_static
r_void
id|write_3393_count
c_func
(paren
r_struct
id|IN2000_hostdata
op_star
id|hostdata
comma
r_int
r_int
id|value
)paren
(brace
id|write1_io
c_func
(paren
id|WD_TRANSFER_COUNT_MSB
comma
id|IO_WD_ADDR
)paren
suffix:semicolon
id|write1_io
c_func
(paren
(paren
id|value
op_rshift
l_int|16
)paren
comma
id|IO_WD_DATA
)paren
suffix:semicolon
id|write1_io
c_func
(paren
(paren
id|value
op_rshift
l_int|8
)paren
comma
id|IO_WD_DATA
)paren
suffix:semicolon
id|write1_io
c_func
(paren
id|value
comma
id|IO_WD_DATA
)paren
suffix:semicolon
)brace
DECL|function|read_3393_count
r_static
r_int
r_int
id|read_3393_count
c_func
(paren
r_struct
id|IN2000_hostdata
op_star
id|hostdata
)paren
(brace
r_int
r_int
id|value
suffix:semicolon
id|write1_io
c_func
(paren
id|WD_TRANSFER_COUNT_MSB
comma
id|IO_WD_ADDR
)paren
suffix:semicolon
id|value
op_assign
id|read1_io
c_func
(paren
id|IO_WD_DATA
)paren
op_lshift
l_int|16
suffix:semicolon
id|value
op_or_assign
id|read1_io
c_func
(paren
id|IO_WD_DATA
)paren
op_lshift
l_int|8
suffix:semicolon
id|value
op_or_assign
id|read1_io
c_func
(paren
id|IO_WD_DATA
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
multiline_comment|/* The 33c93 needs to be told which direction a command transfers its&n; * data; we use this function to figure it out. Returns true if there&n; * will be a DATA_OUT phase with this command, false otherwise.&n; * (Thanks to Joerg Dorchain for the research and suggestion.)&n; */
DECL|function|is_dir_out
r_static
r_int
id|is_dir_out
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
r_case
id|WRITE_12
suffix:colon
r_case
id|WRITE_LONG
suffix:colon
r_case
id|WRITE_SAME
suffix:colon
r_case
id|WRITE_BUFFER
suffix:colon
r_case
id|WRITE_VERIFY
suffix:colon
r_case
id|WRITE_VERIFY_12
suffix:colon
r_case
id|COMPARE
suffix:colon
r_case
id|COPY
suffix:colon
r_case
id|COPY_VERIFY
suffix:colon
r_case
id|SEARCH_EQUAL
suffix:colon
r_case
id|SEARCH_HIGH
suffix:colon
r_case
id|SEARCH_LOW
suffix:colon
r_case
id|SEARCH_EQUAL_12
suffix:colon
r_case
id|SEARCH_HIGH_12
suffix:colon
r_case
id|SEARCH_LOW_12
suffix:colon
r_case
id|FORMAT_UNIT
suffix:colon
r_case
id|REASSIGN_BLOCKS
suffix:colon
r_case
id|RESERVE
suffix:colon
r_case
id|MODE_SELECT
suffix:colon
r_case
id|MODE_SELECT_10
suffix:colon
r_case
id|LOG_SELECT
suffix:colon
r_case
id|SEND_DIAGNOSTIC
suffix:colon
r_case
id|CHANGE_DEFINITION
suffix:colon
r_case
id|UPDATE_BLOCK
suffix:colon
r_case
id|SET_WINDOW
suffix:colon
r_case
id|MEDIUM_SCAN
suffix:colon
r_case
id|SEND_VOLUME_TAG
suffix:colon
r_case
l_int|0xea
suffix:colon
r_return
l_int|1
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|variable|sx_table
r_static
r_struct
id|sx_period
id|sx_table
(braket
)braket
op_assign
(brace
(brace
l_int|1
comma
l_int|0x20
)brace
comma
(brace
l_int|252
comma
l_int|0x20
)brace
comma
(brace
l_int|376
comma
l_int|0x30
)brace
comma
(brace
l_int|500
comma
l_int|0x40
)brace
comma
(brace
l_int|624
comma
l_int|0x50
)brace
comma
(brace
l_int|752
comma
l_int|0x60
)brace
comma
(brace
l_int|876
comma
l_int|0x70
)brace
comma
(brace
l_int|1000
comma
l_int|0x00
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|function|round_period
r_static
r_int
id|round_period
c_func
(paren
r_int
r_int
id|period
)paren
(brace
r_int
id|x
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|1
suffix:semicolon
id|sx_table
(braket
id|x
)braket
dot
id|period_ns
suffix:semicolon
id|x
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|period
op_le
id|sx_table
(braket
id|x
op_minus
l_int|0
)braket
dot
id|period_ns
)paren
op_logical_and
(paren
id|period
OG
id|sx_table
(braket
id|x
op_minus
l_int|1
)braket
dot
id|period_ns
)paren
)paren
(brace
r_return
id|x
suffix:semicolon
)brace
)brace
r_return
l_int|7
suffix:semicolon
)brace
DECL|function|calc_sync_xfer
r_static
id|uchar
id|calc_sync_xfer
c_func
(paren
r_int
r_int
id|period
comma
r_int
r_int
id|offset
)paren
(brace
id|uchar
id|result
suffix:semicolon
id|period
op_mul_assign
l_int|4
suffix:semicolon
multiline_comment|/* convert SDTR code to ns */
id|result
op_assign
id|sx_table
(braket
id|round_period
c_func
(paren
id|period
)paren
)braket
dot
id|reg_value
suffix:semicolon
id|result
op_or_assign
(paren
id|offset
OL
id|OPTIMUM_SX_OFF
)paren
ques
c_cond
id|offset
suffix:colon
id|OPTIMUM_SX_OFF
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_static
r_void
id|in2000_execute
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
suffix:semicolon
DECL|function|in2000_queuecommand
r_int
id|in2000_queuecommand
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|IN2000_hostdata
op_star
id|hostdata
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|IN2000_hostdata
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|DB
c_func
(paren
id|DB_QUEUE_COMMAND
comma
id|printk
c_func
(paren
l_string|&quot;Q-%d-%02x-%ld(&quot;
comma
id|cmd-&gt;target
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|cmd-&gt;pid
)paren
)paren
multiline_comment|/* Set up a few fields in the Scsi_Cmnd structure for our own use:&n; *  - host_scribble is the pointer to the next cmd in the input queue&n; *  - scsi_done points to the routine we call when a cmd is finished&n; *  - result is what you&squot;d expect&n; */
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We use the Scsi_Pointer structure that&squot;s included with each command&n; * as a scratchpad (as it&squot;s intended to be used!). The handy thing about&n; * the SCp.xxx fields is that they&squot;re always associated with a given&n; * cmd, and are preserved across disconnect-reselect. This means we&n; * can pretty much ignore SAVE_POINTERS and RESTORE_POINTERS messages&n; * if we keep all the critical pointers and counters in SCp:&n; *  - SCp.ptr is the pointer into the RAM buffer&n; *  - SCp.this_residual is the size of that buffer&n; *  - SCp.buffer points to the current scatter-gather buffer&n; *  - SCp.buffers_residual tells us how many S.G. buffers there are&n; *  - SCp.have_data_in helps keep track of &gt;2048 byte transfers&n; *  - SCp.sent_command is not used&n; *  - SCp.phase records this command&squot;s SRCID_ER bit setting&n; */
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
id|cmd-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
id|cmd-&gt;SCp.buffers_residual
op_assign
id|cmd-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|cmd-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
r_else
(brace
id|cmd-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.buffers_residual
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
)brace
id|cmd-&gt;SCp.have_data_in
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We don&squot;t set SCp.phase here - that&squot;s done in in2000_execute() */
multiline_comment|/* WD docs state that at the conclusion of a &quot;LEVEL2&quot; command, the&n; * status byte can be retrieved from the LUN register. Apparently,&n; * this is the case only for *uninterrupted* LEVEL2 commands! If&n; * there are any unexpected phases entered, even if they are 100%&n; * legal (different devices may choose to do things differently),&n; * the LEVEL2 command sequence is exited. This often occurs prior&n; * to receiving the status byte, in which case the driver does a&n; * status phase interrupt and gets the status byte on its own.&n; * While such a command can then be &quot;resumed&quot; (ie restarted to&n; * finish up as a LEVEL2 command), the LUN register will NOT be&n; * a valid status byte at the command&squot;s conclusion, and we must&n; * use the byte obtained during the earlier interrupt. Here, we&n; * preset SCp.Status to an illegal value (0xff) so that when&n; * this command finally completes, we can tell where the actual&n; * status byte is stored.&n; */
id|cmd-&gt;SCp.Status
op_assign
id|ILLEGAL_STATUS_BYTE
suffix:semicolon
multiline_comment|/* We need to disable interrupts before messing with the input&n; * queue and calling in2000_execute().&n; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;    * Add the cmd to the end of &squot;input_Q&squot;. Note that REQUEST_SENSE&n;    * commands are added to the head of the queue so that the desired&n;    * sense data is not lost before REQUEST_SENSE executes.&n;    */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;input_Q
)paren
op_logical_or
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
)paren
(brace
id|cmd-&gt;host_scribble
op_assign
(paren
id|uchar
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|hostdata-&gt;input_Q
op_assign
id|cmd
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* find the end of the queue */
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|tmp-&gt;host_scribble
suffix:semicolon
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
suffix:semicolon
id|tmp-&gt;host_scribble
op_assign
(paren
id|uchar
op_star
)paren
id|cmd
suffix:semicolon
)brace
multiline_comment|/* We know that there&squot;s at least one command in &squot;input_Q&squot; now.&n; * Go see if any of them are runnable!&n; */
id|in2000_execute
c_func
(paren
id|cmd-&gt;host
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_QUEUE_COMMAND
comma
id|printk
c_func
(paren
l_string|&quot;)Q-%ld &quot;
comma
id|cmd-&gt;pid
)paren
)paren
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine attempts to start a scsi command. If the host_card is&n; * already connected, we give up immediately. Otherwise, look through&n; * the input_Q, using the first command we find that&squot;s intended&n; * for a currently non-busy target/lun.&n; * Note that this function is always called with interrupts already&n; * disabled (either from in2000_queuecommand() or in2000_intr()).&n; */
DECL|function|in2000_execute
r_static
r_void
id|in2000_execute
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
r_struct
id|IN2000_hostdata
op_star
id|hostdata
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
comma
op_star
id|prev
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
op_star
id|sp
suffix:semicolon
r_int
r_int
id|f
suffix:semicolon
r_int
r_int
id|flushbuf
(braket
l_int|16
)braket
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|IN2000_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|DB
c_func
(paren
id|DB_EXECUTE
comma
id|printk
c_func
(paren
l_string|&quot;EX(&quot;
)paren
)paren
r_if
c_cond
(paren
id|hostdata-&gt;selecting
op_logical_or
id|hostdata-&gt;connected
)paren
(brace
id|DB
c_func
(paren
id|DB_EXECUTE
comma
id|printk
c_func
(paren
l_string|&quot;)EX-0 &quot;
)paren
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;     * Search through the input_Q for a command destined&n;     * for an idle target/lun.&n;     */
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|prev
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cmd
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
)paren
)paren
r_break
suffix:semicolon
id|prev
op_assign
id|cmd
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
)brace
multiline_comment|/* quit if queue empty or all possible targets are busy */
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
id|DB
c_func
(paren
id|DB_EXECUTE
comma
id|printk
c_func
(paren
l_string|&quot;)EX-1 &quot;
)paren
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/*  remove command from queue */
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;host_scribble
op_assign
id|cmd-&gt;host_scribble
suffix:semicolon
r_else
id|hostdata-&gt;input_Q
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
macro_line|#ifdef PROC_STATISTICS
id|hostdata-&gt;cmd_cnt
(braket
id|cmd-&gt;target
)braket
op_increment
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Start the selection process&n; */
r_if
c_cond
(paren
id|is_dir_out
c_func
(paren
id|cmd
)paren
)paren
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_DESTINATION_ID
comma
id|cmd-&gt;target
)paren
suffix:semicolon
r_else
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_DESTINATION_ID
comma
id|cmd-&gt;target
op_or
id|DSTID_DPD
)paren
suffix:semicolon
multiline_comment|/* Now we need to figure out whether or not this command is a good&n; * candidate for disconnect/reselect. We guess to the best of our&n; * ability, based on a set of hierarchical rules. When several&n; * devices are operating simultaneously, disconnects are usually&n; * an advantage. In a single device system, or if only 1 device&n; * is being accessed, transfers usually go faster if disconnects&n; * are not allowed:&n; *&n; * + Commands should NEVER disconnect if hostdata-&gt;disconnect =&n; *   DIS_NEVER (this holds for tape drives also), and ALWAYS&n; *   disconnect if hostdata-&gt;disconnect = DIS_ALWAYS.&n; * + Tape drive commands should always be allowed to disconnect.&n; * + Disconnect should be allowed if disconnected_Q isn&squot;t empty.&n; * + Commands should NOT disconnect if input_Q is empty.&n; * + Disconnect should be allowed if there are commands in input_Q&n; *   for a different target/lun. In this case, the other commands&n; *   should be made disconnect-able, if not already.&n; *&n; * I know, I know - this code would flunk me out of any&n; * &quot;C Programming 101&quot; class ever offered. But it&squot;s easy&n; * to change around and experiment with for now.&n; */
id|cmd-&gt;SCp.phase
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* assume no disconnect */
r_if
c_cond
(paren
id|hostdata-&gt;disconnect
op_eq
id|DIS_NEVER
)paren
r_goto
id|no
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;disconnect
op_eq
id|DIS_ALWAYS
)paren
r_goto
id|yes
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;type
op_eq
l_int|1
)paren
multiline_comment|/* tape drive? */
r_goto
id|yes
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;disconnected_Q
)paren
multiline_comment|/* other commands disconnected? */
r_goto
id|yes
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;input_Q
)paren
)paren
multiline_comment|/* input_Q empty? */
r_goto
id|no
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|prev
suffix:semicolon
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|prev-&gt;host_scribble
)paren
(brace
r_if
c_cond
(paren
(paren
id|prev-&gt;target
op_ne
id|cmd-&gt;target
)paren
op_logical_or
(paren
id|prev-&gt;lun
op_ne
id|cmd-&gt;lun
)paren
)paren
(brace
r_for
c_loop
(paren
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|prev
suffix:semicolon
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|prev-&gt;host_scribble
)paren
id|prev-&gt;SCp.phase
op_assign
l_int|1
suffix:semicolon
r_goto
id|yes
suffix:semicolon
)brace
)brace
r_goto
id|no
suffix:semicolon
id|yes
suffix:colon
id|cmd-&gt;SCp.phase
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef PROC_STATISTICS
id|hostdata-&gt;disc_allowed_cnt
(braket
id|cmd-&gt;target
)braket
op_increment
suffix:semicolon
macro_line|#endif
id|no
suffix:colon
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_SOURCE_ID
comma
(paren
(paren
id|cmd-&gt;SCp.phase
)paren
ques
c_cond
id|SRCID_ER
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_TARGET_LUN
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_SYNCHRONOUS_TRANSFER
comma
id|hostdata-&gt;sync_xfer
(braket
id|cmd-&gt;target
)braket
)paren
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;level2
op_le
id|L2_NONE
)paren
op_logical_or
(paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_eq
id|SS_UNSET
)paren
)paren
(brace
multiline_comment|/*&n;          * Do a &squot;Select-With-ATN&squot; command. This will end with&n;          * one of the following interrupts:&n;          *    CSR_RESEL_AM:  failure - can try again later.&n;          *    CSR_TIMEOUT:   failure - give up.&n;          *    CSR_SELECT:    success - proceed.&n;          */
id|hostdata-&gt;selecting
op_assign
id|cmd
suffix:semicolon
multiline_comment|/* Every target has its own synchronous transfer setting, kept in&n; * the sync_xfer array, and a corresponding status byte in sync_stat[].&n; * Each target&squot;s sync_stat[] entry is initialized to SS_UNSET, and its&n; * sync_xfer[] entry is initialized to the default/safe value. SS_UNSET&n; * means that the parameters are undetermined as yet, and that we&n; * need to send an SDTR message to this device after selection is&n; * complete. We set SS_FIRST to tell the interrupt routine to do so,&n; * unless we don&squot;t want to even _try_ synchronous transfers: In this&n; * case we set SS_SET to make the defaults final.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_eq
id|SS_UNSET
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;sync_off
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
)paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_assign
id|SS_SET
suffix:semicolon
r_else
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_assign
id|SS_FIRST
suffix:semicolon
)brace
id|hostdata-&gt;state
op_assign
id|S_SELECTING
suffix:semicolon
id|write_3393_count
c_func
(paren
id|hostdata
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* this guarantees a DATA_PHASE interrupt */
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_SEL_ATN
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;          * Do a &squot;Select-With-ATN-Xfer&squot; command. This will end with&n;          * one of the following interrupts:&n;          *    CSR_RESEL_AM:  failure - can try again later.&n;          *    CSR_TIMEOUT:   failure - give up.&n;          *    anything else: success - proceed.&n;          */
id|hostdata-&gt;connected
op_assign
id|cmd
suffix:semicolon
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_COMMAND_PHASE
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* copy command_descriptor_block into WD chip&n;    * (take advantage of auto-incrementing)&n;    */
id|write1_io
c_func
(paren
id|WD_CDB_1
comma
id|IO_WD_ADDR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
id|write1_io
c_func
(paren
id|cmd-&gt;cmnd
(braket
id|i
)braket
comma
id|IO_WD_DATA
)paren
suffix:semicolon
multiline_comment|/* The wd33c93 only knows about Group 0, 1, and 5 commands when&n;    * it&squot;s doing a &squot;select-and-transfer&squot;. To be safe, we write the&n;    * size of the CDB into the OWN_ID register for every case. This&n;    * way there won&squot;t be problems with vendor-unique, audio, etc.&n;    */
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_OWN_ID
comma
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
multiline_comment|/* When doing a non-disconnect command, we can save ourselves a DATA&n;    * phase interrupt later by setting everything up now. With writes we&n;    * need to pre-fill the fifo; if there&squot;s room for the 32 flush bytes,&n;    * put them in there too - that&squot;ll avoid a fifo interrupt. Reads are&n;    * somewhat simpler.&n;    * KLUDGE NOTE: It seems that you can&squot;t completely fill the fifo here:&n;    * This results in the IO_FIFO_COUNT register rolling over to zero,&n;    * and apparently the gate array logic sees this as empty, not full,&n;    * so the 3393 chip is never signalled to start reading from the&n;    * fifo. Or maybe it&squot;s seen as a permanent fifo interrupt condition.&n;    * Regardless, we fix this by temporarily pretending that the fifo&n;    * is 16 bytes smaller. (I see now that the old driver has a comment&n;    * about &quot;don&squot;t fill completely&quot; in an analogous place - must be the&n;    * same deal.) This results in CDROM, swap partitions, and tape drives&n;    * needing an extra interrupt per write command - I think we can live&n;    * with that!&n;    */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cmd-&gt;SCp.phase
)paren
)paren
(brace
id|write_3393_count
c_func
(paren
id|hostdata
comma
id|cmd-&gt;SCp.this_residual
)paren
suffix:semicolon
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_BUS
)paren
suffix:semicolon
id|write1_io
c_func
(paren
l_int|0
comma
id|IO_FIFO_WRITE
)paren
suffix:semicolon
multiline_comment|/* clear fifo counter, write mode */
r_if
c_cond
(paren
id|is_dir_out
c_func
(paren
id|cmd
)paren
)paren
(brace
id|hostdata-&gt;fifo
op_assign
id|FI_FIFO_WRITING
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|cmd-&gt;SCp.this_residual
)paren
OG
(paren
id|IN2000_FIFO_SIZE
op_minus
l_int|16
)paren
)paren
id|i
op_assign
id|IN2000_FIFO_SIZE
op_minus
l_int|16
suffix:semicolon
id|cmd-&gt;SCp.have_data_in
op_assign
id|i
suffix:semicolon
multiline_comment|/* this much data in fifo */
id|i
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Gulp. Assuming modulo 2. */
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
id|cmd-&gt;SCp.ptr
suffix:semicolon
id|f
op_assign
id|hostdata-&gt;io_base
op_plus
id|IO_FIFO
suffix:semicolon
macro_line|#ifdef FAST_WRITE_IO
id|FAST_WRITE2_IO
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
r_while
c_loop
(paren
id|i
op_decrement
)paren
id|write2_io
c_func
(paren
op_star
id|sp
op_increment
comma
id|IO_FIFO
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Is there room for the flush bytes? */
r_if
c_cond
(paren
id|cmd-&gt;SCp.have_data_in
op_le
(paren
(paren
id|IN2000_FIFO_SIZE
op_minus
l_int|16
)paren
op_minus
l_int|32
)paren
)paren
(brace
id|sp
op_assign
id|flushbuf
suffix:semicolon
id|i
op_assign
l_int|16
suffix:semicolon
macro_line|#ifdef FAST_WRITE_IO
id|FAST_WRITE2_IO
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
r_while
c_loop
(paren
id|i
op_decrement
)paren
id|write2_io
c_func
(paren
l_int|0
comma
id|IO_FIFO
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
(brace
id|write1_io
c_func
(paren
l_int|0
comma
id|IO_FIFO_READ
)paren
suffix:semicolon
multiline_comment|/* put fifo in read mode */
id|hostdata-&gt;fifo
op_assign
id|FI_FIFO_READING
suffix:semicolon
id|cmd-&gt;SCp.have_data_in
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* nothing transfered yet */
)brace
)brace
r_else
(brace
id|write_3393_count
c_func
(paren
id|hostdata
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* this guarantees a DATA_PHASE interrupt */
)brace
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    * Since the SCSI bus can handle only 1 connection at a time,&n;    * we get out of here now. If the selection fails, or when&n;    * the command disconnects, we&squot;ll come back to this routine&n;    * to search the input_Q again...&n;    */
id|DB
c_func
(paren
id|DB_EXECUTE
comma
id|printk
c_func
(paren
l_string|&quot;%s%ld)EX-2 &quot;
comma
(paren
id|cmd-&gt;SCp.phase
)paren
ques
c_cond
l_string|&quot;d:&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|cmd-&gt;pid
)paren
)paren
)brace
DECL|function|transfer_pio
r_static
r_void
id|transfer_pio
c_func
(paren
id|uchar
op_star
id|buf
comma
r_int
id|cnt
comma
r_int
id|data_in_dir
comma
r_struct
id|IN2000_hostdata
op_star
id|hostdata
)paren
(brace
id|uchar
id|asr
suffix:semicolon
id|DB
c_func
(paren
id|DB_TRANSFER
comma
id|printk
c_func
(paren
l_string|&quot;(%p,%d,%s)&quot;
comma
id|buf
comma
id|cnt
comma
id|data_in_dir
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
)paren
)paren
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_POLLED
)paren
suffix:semicolon
id|write_3393_count
c_func
(paren
id|hostdata
comma
id|cnt
)paren
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_TRANS_INFO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_in_dir
)paren
(brace
r_do
(brace
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asr
op_amp
id|ASR_DBR
)paren
op_star
id|buf
op_increment
op_assign
id|read_3393
c_func
(paren
id|hostdata
comma
id|WD_DATA
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_do
(brace
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asr
op_amp
id|ASR_DBR
)paren
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_DATA
comma
op_star
id|buf
op_increment
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Note: we are returning with the interrupt UN-cleared.&n;   * Since (presumably) an entire I/O operation has&n;   * completed, the bus phase is probably different, and&n;   * the interrupt routine will discover this when it&n;   * responds to the uncleared int.&n;   */
)brace
DECL|function|transfer_bytes
r_static
r_void
id|transfer_bytes
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|data_in_dir
)paren
(brace
r_struct
id|IN2000_hostdata
op_star
id|hostdata
suffix:semicolon
r_int
r_int
op_star
id|sp
suffix:semicolon
r_int
r_int
id|f
suffix:semicolon
r_int
id|i
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|IN2000_hostdata
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
multiline_comment|/* Normally, you&squot;d expect &squot;this_residual&squot; to be non-zero here.&n; * In a series of scatter-gather transfers, however, this&n; * routine will usually be called with &squot;this_residual&squot; equal&n; * to 0 and &squot;buffers_residual&squot; non-zero. This means that a&n; * previous transfer completed, clearing &squot;this_residual&squot;, and&n; * now we need to setup the next scatter-gather buffer as the&n; * source or destination for THIS transfer.&n; */
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;SCp.this_residual
op_logical_and
id|cmd-&gt;SCp.buffers_residual
)paren
(brace
op_increment
id|cmd-&gt;SCp.buffer
suffix:semicolon
op_decrement
id|cmd-&gt;SCp.buffers_residual
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|cmd-&gt;SCp.buffer-&gt;address
suffix:semicolon
)brace
multiline_comment|/* Set up hardware registers */
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_SYNCHRONOUS_TRANSFER
comma
id|hostdata-&gt;sync_xfer
(braket
id|cmd-&gt;target
)braket
)paren
suffix:semicolon
id|write_3393_count
c_func
(paren
id|hostdata
comma
id|cmd-&gt;SCp.this_residual
)paren
suffix:semicolon
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_BUS
)paren
suffix:semicolon
id|write1_io
c_func
(paren
l_int|0
comma
id|IO_FIFO_WRITE
)paren
suffix:semicolon
multiline_comment|/* zero counter, assume write */
multiline_comment|/* Reading is easy. Just issue the command and return - we&squot;ll&n; * get an interrupt later when we have actual data to worry about.&n; */
r_if
c_cond
(paren
id|data_in_dir
)paren
(brace
id|write1_io
c_func
(paren
l_int|0
comma
id|IO_FIFO_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hostdata-&gt;level2
op_ge
id|L2_DATA
)paren
op_logical_or
(paren
id|hostdata-&gt;level2
op_eq
id|L2_BASIC
op_logical_and
id|cmd-&gt;SCp.phase
op_eq
l_int|0
)paren
)paren
(brace
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_COMMAND_PHASE
comma
l_int|0x45
)paren
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
)brace
r_else
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_TRANS_INFO
)paren
suffix:semicolon
id|hostdata-&gt;fifo
op_assign
id|FI_FIFO_READING
suffix:semicolon
id|cmd-&gt;SCp.have_data_in
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Writing is more involved - we&squot;ll start the WD chip and write as&n; * much data to the fifo as we can right now. Later interrupts will&n; * write any bytes that don&squot;t make it at this stage.&n; */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;level2
op_ge
id|L2_DATA
)paren
op_logical_or
(paren
id|hostdata-&gt;level2
op_eq
id|L2_BASIC
op_logical_and
id|cmd-&gt;SCp.phase
op_eq
l_int|0
)paren
)paren
(brace
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_COMMAND_PHASE
comma
l_int|0x45
)paren
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
)brace
r_else
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_TRANS_INFO
)paren
suffix:semicolon
id|hostdata-&gt;fifo
op_assign
id|FI_FIFO_WRITING
suffix:semicolon
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
id|cmd-&gt;SCp.ptr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|cmd-&gt;SCp.this_residual
)paren
OG
id|IN2000_FIFO_SIZE
)paren
id|i
op_assign
id|IN2000_FIFO_SIZE
suffix:semicolon
id|cmd-&gt;SCp.have_data_in
op_assign
id|i
suffix:semicolon
id|i
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Gulp. We assume this_residual is modulo 2 */
id|f
op_assign
id|hostdata-&gt;io_base
op_plus
id|IO_FIFO
suffix:semicolon
macro_line|#ifdef FAST_WRITE_IO
id|FAST_WRITE2_IO
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
r_while
c_loop
(paren
id|i
op_decrement
)paren
id|write2_io
c_func
(paren
op_star
id|sp
op_increment
comma
id|IO_FIFO
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* We need to use spin_lock_irqsave() &amp; spin_unlock_irqrestore() in this&n; * function in order to work in an SMP environment. (I&squot;d be surprised&n; * if the driver is ever used by anyone on a real multi-CPU motherboard,&n; * but it _does_ need to be able to compile and run in an SMP kernel.)&n; */
DECL|function|in2000_intr
r_static
r_void
id|in2000_intr
(paren
r_int
id|irqnum
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|ptregs
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_struct
id|IN2000_hostdata
op_star
id|hostdata
suffix:semicolon
id|Scsi_Cmnd
op_star
id|patch
comma
op_star
id|cmd
suffix:semicolon
id|uchar
id|asr
comma
id|sr
comma
id|phs
comma
id|id
comma
id|lun
comma
op_star
id|ucp
comma
id|msg
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
r_int
id|length
suffix:semicolon
r_int
r_int
op_star
id|sp
suffix:semicolon
r_int
r_int
id|f
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_for
c_loop
(paren
id|instance
op_assign
id|instance_list
suffix:semicolon
id|instance
suffix:semicolon
id|instance
op_assign
id|instance-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|instance-&gt;irq
op_eq
id|irqnum
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;*** Hmm... interrupts are screwed up! ***&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|hostdata
op_assign
(paren
r_struct
id|IN2000_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
multiline_comment|/* Get the spin_lock and disable further ints, for SMP */
id|CLISPIN_LOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef PROC_STATISTICS
id|hostdata-&gt;int_cnt
op_increment
suffix:semicolon
macro_line|#endif
multiline_comment|/* The IN2000 card has 2 interrupt sources OR&squot;ed onto its IRQ line - the&n; * WD3393 chip and the 2k fifo (which is actually a dual-port RAM combined&n; * with a big logic array, so it&squot;s a little different than what you might&n; * expect). As far as I know, there&squot;s no reason that BOTH can&squot;t be active&n; * at the same time, but there&squot;s a problem: while we can read the 3393&n; * to tell if _it_ wants an interrupt, I don&squot;t know of a way to ask the&n; * fifo the same question. The best we can do is check the 3393 and if&n; * it _isn&squot;t_ the source of the interrupt, then we can be pretty sure&n; * that the fifo is the culprit.&n; *  UPDATE: I have it on good authority (Bill Earnest) that bit 0 of the&n; *          IO_FIFO_COUNT register mirrors the fifo interrupt state. I&n; *          assume that bit clear means interrupt active. As it turns&n; *          out, the driver really doesn&squot;t need to check for this after&n; *          all, so my remarks above about a &squot;problem&squot; can safely be&n; *          ignored. The way the logic is set up, there&squot;s no advantage&n; *          (that I can see) to worrying about it.&n; *&n; * It seems that the fifo interrupt signal is negated when we extract&n; * bytes during read or write bytes during write.&n; *  - fifo will interrupt when data is moving from it to the 3393, and&n; *    there are 31 (or less?) bytes left to go. This is sort of short-&n; *    sighted: what if you don&squot;t WANT to do more? In any case, our&n; *    response is to push more into the fifo - either actual data or&n; *    dummy bytes if need be. Note that we apparently have to write at&n; *    least 32 additional bytes to the fifo after an interrupt in order&n; *    to get it to release the ones it was holding on to - writing fewer&n; *    than 32 will result in another fifo int.&n; *  UPDATE: Again, info from Bill Earnest makes this more understandable:&n; *          32 bytes = two counts of the fifo counter register. He tells&n; *          me that the fifo interrupt is a non-latching signal derived&n; *          from a straightforward boolean interpretation of the 7&n; *          highest bits of the fifo counter and the fifo-read/fifo-write&n; *          state. Who&squot;d a thought?&n; */
id|write1_io
c_func
(paren
l_int|0
comma
id|IO_LED_ON
)paren
suffix:semicolon
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
)paren
(brace
multiline_comment|/* no WD33c93 interrupt? */
multiline_comment|/* Ok. This is definitely a FIFO-only interrupt.&n; *&n; * If FI_FIFO_READING is set, there are up to 2048 bytes waiting to be read,&n; * maybe more to come from the SCSI bus. Read as many as we can out of the&n; * fifo and into memory at the location of SCp.ptr[SCp.have_data_in], and&n; * update have_data_in afterwards.&n; *&n; * If we have FI_FIFO_WRITING, the FIFO has almost run out of bytes to move&n; * into the WD3393 chip (I think the interrupt happens when there are 31&n; * bytes left, but it may be fewer...). The 3393 is still waiting, so we&n; * shove some more into the fifo, which gets things moving again. If the&n; * original SCSI command specified more than 2048 bytes, there may still&n; * be some of that data left: fine - use it (from SCp.ptr[SCp.have_data_in]).&n; * Don&squot;t forget to update have_data_in. If we&squot;ve already written out the&n; * entire buffer, feed 32 dummy bytes to the fifo - they&squot;re needed to&n; * push out the remaining real data.&n; *    (Big thanks to Bill Earnest for getting me out of the mud in here.)&n; */
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;connected
suffix:semicolon
multiline_comment|/* assume we&squot;re connected */
id|CHECK_NULL
c_func
(paren
id|cmd
comma
l_string|&quot;fifo_int&quot;
)paren
r_if
c_cond
(paren
id|hostdata-&gt;fifo
op_eq
id|FI_FIFO_READING
)paren
(brace
id|DB
c_func
(paren
id|DB_FIFO
comma
id|printk
c_func
(paren
l_string|&quot;{R:%02x} &quot;
comma
id|read1_io
c_func
(paren
id|IO_FIFO_COUNT
)paren
)paren
)paren
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|cmd-&gt;SCp.ptr
op_plus
id|cmd-&gt;SCp.have_data_in
)paren
suffix:semicolon
id|i
op_assign
id|read1_io
c_func
(paren
id|IO_FIFO_COUNT
)paren
op_amp
l_int|0xfe
suffix:semicolon
id|i
op_lshift_assign
l_int|2
suffix:semicolon
multiline_comment|/* # of words waiting in the fifo */
id|f
op_assign
id|hostdata-&gt;io_base
op_plus
id|IO_FIFO
suffix:semicolon
macro_line|#ifdef FAST_READ_IO
id|FAST_READ2_IO
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
r_while
c_loop
(paren
id|i
op_decrement
)paren
op_star
id|sp
op_increment
op_assign
id|read2_io
c_func
(paren
id|IO_FIFO
)paren
suffix:semicolon
macro_line|#endif
id|i
op_assign
id|sp
op_minus
(paren
r_int
r_int
op_star
)paren
(paren
id|cmd-&gt;SCp.ptr
op_plus
id|cmd-&gt;SCp.have_data_in
)paren
suffix:semicolon
id|i
op_lshift_assign
l_int|1
suffix:semicolon
id|cmd-&gt;SCp.have_data_in
op_add_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hostdata-&gt;fifo
op_eq
id|FI_FIFO_WRITING
)paren
(brace
id|DB
c_func
(paren
id|DB_FIFO
comma
id|printk
c_func
(paren
l_string|&quot;{W:%02x} &quot;
comma
id|read1_io
c_func
(paren
id|IO_FIFO_COUNT
)paren
)paren
)paren
multiline_comment|/* If all bytes have been written to the fifo, flush out the stragglers.&n; * Note that while writing 16 dummy words seems arbitrary, we don&squot;t&n; * have another choice that I can see. What we really want is to read&n; * the 3393 transfer count register (that would tell us how many bytes&n; * needed flushing), but the TRANSFER_INFO command hasn&squot;t completed&n; * yet (not enough bytes!) and that register won&squot;t be accessible. So,&n; * we use 16 words - a number obtained through trial and error.&n; *  UPDATE: Bill says this is exactly what Always does, so there.&n; *          More thanks due him for help in this section.&n; */
r_if
c_cond
(paren
id|cmd-&gt;SCp.this_residual
op_eq
id|cmd-&gt;SCp.have_data_in
)paren
(brace
id|i
op_assign
l_int|16
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
)paren
multiline_comment|/* write 32 dummy bytes */
id|write2_io
c_func
(paren
l_int|0
comma
id|IO_FIFO
)paren
suffix:semicolon
)brace
multiline_comment|/* If there are still bytes left in the SCSI buffer, write as many as we&n; * can out to the fifo.&n; */
r_else
(brace
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|cmd-&gt;SCp.ptr
op_plus
id|cmd-&gt;SCp.have_data_in
)paren
suffix:semicolon
id|i
op_assign
id|cmd-&gt;SCp.this_residual
op_minus
id|cmd-&gt;SCp.have_data_in
suffix:semicolon
multiline_comment|/* bytes yet to go */
id|j
op_assign
id|read1_io
c_func
(paren
id|IO_FIFO_COUNT
)paren
op_amp
l_int|0xfe
suffix:semicolon
id|j
op_lshift_assign
l_int|2
suffix:semicolon
multiline_comment|/* how many words the fifo has room for */
r_if
c_cond
(paren
(paren
id|j
op_lshift
l_int|1
)paren
OG
id|i
)paren
id|j
op_assign
(paren
id|i
op_rshift
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|j
op_decrement
)paren
id|write2_io
c_func
(paren
op_star
id|sp
op_increment
comma
id|IO_FIFO
)paren
suffix:semicolon
id|i
op_assign
id|sp
op_minus
(paren
r_int
r_int
op_star
)paren
(paren
id|cmd-&gt;SCp.ptr
op_plus
id|cmd-&gt;SCp.have_data_in
)paren
suffix:semicolon
id|i
op_lshift_assign
l_int|1
suffix:semicolon
id|cmd-&gt;SCp.have_data_in
op_add_assign
id|i
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;*** Spurious FIFO interrupt ***&quot;
)paren
suffix:semicolon
)brace
id|write1_io
c_func
(paren
l_int|0
comma
id|IO_LED_OFF
)paren
suffix:semicolon
multiline_comment|/* release the SMP spin_lock and restore irq state */
id|CLISPIN_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* This interrupt was triggered by the WD33c93 chip. The fifo interrupt&n; * may also be asserted, but we don&squot;t bother to check it: we get more&n; * detailed info from FIFO_READING and FIFO_WRITING (see below).&n; */
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;connected
suffix:semicolon
multiline_comment|/* assume we&squot;re connected */
id|sr
op_assign
id|read_3393
c_func
(paren
id|hostdata
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
multiline_comment|/* clear the interrupt */
id|phs
op_assign
id|read_3393
c_func
(paren
id|hostdata
comma
id|WD_COMMAND_PHASE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
op_logical_and
(paren
id|sr
op_ne
id|CSR_RESEL_AM
op_logical_and
id|sr
op_ne
id|CSR_TIMEOUT
op_logical_and
id|sr
op_ne
id|CSR_SELECT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nNR:wd-intr-1&bslash;n&quot;
)paren
suffix:semicolon
id|write1_io
c_func
(paren
l_int|0
comma
id|IO_LED_OFF
)paren
suffix:semicolon
multiline_comment|/* release the SMP spin_lock and restore irq state */
id|CLISPIN_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;{%02x:%02x-&quot;
comma
id|asr
comma
id|sr
)paren
)paren
multiline_comment|/* After starting a FIFO-based transfer, the next _WD3393_ interrupt is&n; * guaranteed to be in response to the completion of the transfer.&n; * If we were reading, there&squot;s probably data in the fifo that needs&n; * to be copied into RAM - do that here. Also, we have to update&n; * &squot;this_residual&squot; and &squot;ptr&squot; based on the contents of the&n; * TRANSFER_COUNT register, in case the device decided to do an&n; * intermediate disconnect (a device may do this if it has to&n; * do a seek,  or just to be nice and let other devices have&n; * some bus time during long transfers).&n; * After doing whatever is necessary with the fifo, we go on and&n; * service the WD3393 interrupt normally.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;fifo
op_eq
id|FI_FIFO_READING
)paren
(brace
multiline_comment|/* buffer index = start-of-buffer + #-of-bytes-already-read */
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|cmd-&gt;SCp.ptr
op_plus
id|cmd-&gt;SCp.have_data_in
)paren
suffix:semicolon
multiline_comment|/* bytes remaining in fifo = (total-wanted - #-not-got) - #-already-read */
id|i
op_assign
(paren
id|cmd-&gt;SCp.this_residual
op_minus
id|read_3393_count
c_func
(paren
id|hostdata
)paren
)paren
op_minus
id|cmd-&gt;SCp.have_data_in
suffix:semicolon
id|i
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Gulp. We assume this will always be modulo 2 */
id|f
op_assign
id|hostdata-&gt;io_base
op_plus
id|IO_FIFO
suffix:semicolon
macro_line|#ifdef FAST_READ_IO
id|FAST_READ2_IO
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
r_while
c_loop
(paren
id|i
op_decrement
)paren
op_star
id|sp
op_increment
op_assign
id|read2_io
c_func
(paren
id|IO_FIFO
)paren
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;fifo
op_assign
id|FI_FIFO_UNUSED
suffix:semicolon
id|length
op_assign
id|cmd-&gt;SCp.this_residual
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|read_3393_count
c_func
(paren
id|hostdata
)paren
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_add_assign
(paren
id|length
op_minus
id|cmd-&gt;SCp.this_residual
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_TRANSFER
comma
id|printk
c_func
(paren
l_string|&quot;(%p,%d)&quot;
comma
id|cmd-&gt;SCp.ptr
comma
id|cmd-&gt;SCp.this_residual
)paren
)paren
)brace
r_else
r_if
c_cond
(paren
id|hostdata-&gt;fifo
op_eq
id|FI_FIFO_WRITING
)paren
(brace
id|hostdata-&gt;fifo
op_assign
id|FI_FIFO_UNUSED
suffix:semicolon
id|length
op_assign
id|cmd-&gt;SCp.this_residual
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|read_3393_count
c_func
(paren
id|hostdata
)paren
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_add_assign
(paren
id|length
op_minus
id|cmd-&gt;SCp.this_residual
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_TRANSFER
comma
id|printk
c_func
(paren
l_string|&quot;(%p,%d)&quot;
comma
id|cmd-&gt;SCp.ptr
comma
id|cmd-&gt;SCp.this_residual
)paren
)paren
)brace
multiline_comment|/* Respond to the specific WD3393 interrupt - there are quite a few! */
r_switch
c_cond
(paren
id|sr
)paren
(brace
r_case
id|CSR_TIMEOUT
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;TIMEOUT&quot;
)paren
)paren
r_if
c_cond
(paren
id|hostdata-&gt;state
op_eq
id|S_RUNNING_LEVEL2
)paren
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;selecting
suffix:semicolon
multiline_comment|/* get a valid cmd */
id|CHECK_NULL
c_func
(paren
id|cmd
comma
l_string|&quot;csr_timeout&quot;
)paren
id|hostdata-&gt;selecting
op_assign
l_int|NULL
suffix:semicolon
)brace
id|cmd-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/* We are not connected to a target - check to see if there&n; * are commands waiting to be executed.&n; */
id|in2000_execute
c_func
(paren
id|instance
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Note: this interrupt should not occur in a LEVEL2 command */
r_case
id|CSR_SELECT
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;SELECT&quot;
)paren
)paren
id|hostdata-&gt;connected
op_assign
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;selecting
suffix:semicolon
id|CHECK_NULL
c_func
(paren
id|cmd
comma
l_string|&quot;csr_select&quot;
)paren
id|hostdata-&gt;selecting
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* construct an IDENTIFY message with correct disconnect bit */
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
(paren
l_int|0x80
op_or
l_int|0x00
op_or
id|cmd-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;SCp.phase
)paren
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_or_assign
l_int|0x40
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_eq
id|SS_FIRST
)paren
(brace
macro_line|#ifdef SYNC_DEBUG
id|printk
c_func
(paren
l_string|&quot; sending SDTR &quot;
)paren
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_assign
id|SS_WAITING
suffix:semicolon
multiline_comment|/* tack on a 2nd message to ask about synchronous transfers */
id|hostdata-&gt;outgoing_msg
(braket
l_int|1
)braket
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|2
)braket
op_assign
l_int|3
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|3
)braket
op_assign
id|EXTENDED_SDTR
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|4
)braket
op_assign
id|OPTIMUM_SX_PER
op_div
l_int|4
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|5
)braket
op_assign
id|OPTIMUM_SX_OFF
suffix:semicolon
id|hostdata-&gt;outgoing_len
op_assign
l_int|6
suffix:semicolon
)brace
r_else
id|hostdata-&gt;outgoing_len
op_assign
l_int|1
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_XFER_DONE
op_or
id|PHS_DATA_IN
suffix:colon
r_case
id|CSR_UNEXP
op_or
id|PHS_DATA_IN
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_DATA_IN
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;IN-%d.%d&quot;
comma
id|cmd-&gt;SCp.this_residual
comma
id|cmd-&gt;SCp.buffers_residual
)paren
)paren
id|transfer_bytes
c_func
(paren
id|cmd
comma
id|DATA_IN_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;state
op_ne
id|S_RUNNING_LEVEL2
)paren
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_XFER_DONE
op_or
id|PHS_DATA_OUT
suffix:colon
r_case
id|CSR_UNEXP
op_or
id|PHS_DATA_OUT
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_DATA_OUT
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;OUT-%d.%d&quot;
comma
id|cmd-&gt;SCp.this_residual
comma
id|cmd-&gt;SCp.buffers_residual
)paren
)paren
id|transfer_bytes
c_func
(paren
id|cmd
comma
id|DATA_OUT_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;state
op_ne
id|S_RUNNING_LEVEL2
)paren
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Note: this interrupt should not occur in a LEVEL2 command */
r_case
id|CSR_XFER_DONE
op_or
id|PHS_COMMAND
suffix:colon
r_case
id|CSR_UNEXP
op_or
id|PHS_COMMAND
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_COMMAND
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;CMND-%02x,%ld&quot;
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|cmd-&gt;pid
)paren
)paren
id|transfer_pio
c_func
(paren
id|cmd-&gt;cmnd
comma
id|cmd-&gt;cmd_len
comma
id|DATA_OUT_DIR
comma
id|hostdata
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_XFER_DONE
op_or
id|PHS_STATUS
suffix:colon
r_case
id|CSR_UNEXP
op_or
id|PHS_STATUS
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_STATUS
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;STATUS=&quot;
)paren
)paren
id|cmd-&gt;SCp.Status
op_assign
id|read_1_byte
c_func
(paren
id|hostdata
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|cmd-&gt;SCp.Status
)paren
)paren
r_if
c_cond
(paren
id|hostdata-&gt;level2
op_ge
id|L2_BASIC
)paren
(brace
id|sr
op_assign
id|read_3393
c_func
(paren
id|hostdata
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
multiline_comment|/* clear interrupt */
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_COMMAND_PHASE
comma
l_int|0x50
)paren
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
)brace
r_else
(brace
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CSR_XFER_DONE
op_or
id|PHS_MESS_IN
suffix:colon
r_case
id|CSR_UNEXP
op_or
id|PHS_MESS_IN
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_MESS_IN
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;MSG_IN=&quot;
)paren
)paren
id|msg
op_assign
id|read_1_byte
c_func
(paren
id|hostdata
)paren
suffix:semicolon
id|sr
op_assign
id|read_3393
c_func
(paren
id|hostdata
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
multiline_comment|/* clear interrupt */
id|hostdata-&gt;incoming_msg
(braket
id|hostdata-&gt;incoming_ptr
)braket
op_assign
id|msg
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;incoming_msg
(braket
l_int|0
)braket
op_eq
id|EXTENDED_MESSAGE
)paren
id|msg
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
r_else
id|hostdata-&gt;incoming_ptr
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.Message
op_assign
id|msg
suffix:semicolon
r_switch
c_cond
(paren
id|msg
)paren
(brace
r_case
id|COMMAND_COMPLETE
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;CCMP-%ld&quot;
comma
id|cmd-&gt;pid
)paren
)paren
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_PRE_CMP_DISC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SAVE_POINTERS
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;SDP&quot;
)paren
)paren
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESTORE_POINTERS
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;RDP&quot;
)paren
)paren
r_if
c_cond
(paren
id|hostdata-&gt;level2
op_ge
id|L2_BASIC
)paren
(brace
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_COMMAND_PHASE
comma
l_int|0x45
)paren
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
)brace
r_else
(brace
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISCONNECT
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;DIS&quot;
)paren
)paren
id|cmd-&gt;device-&gt;disconnect
op_assign
l_int|1
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_PRE_TMP_DISC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MESSAGE_REJECT
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;REJ&quot;
)paren
)paren
macro_line|#ifdef SYNC_DEBUG
id|printk
c_func
(paren
l_string|&quot;-REJ-&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_eq
id|SS_WAITING
)paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_assign
id|SS_SET
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EXTENDED_MESSAGE
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;EXT&quot;
)paren
)paren
id|ucp
op_assign
id|hostdata-&gt;incoming_msg
suffix:semicolon
macro_line|#ifdef SYNC_DEBUG
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|ucp
(braket
id|hostdata-&gt;incoming_ptr
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Is this the last byte of the extended message? */
r_if
c_cond
(paren
(paren
id|hostdata-&gt;incoming_ptr
op_ge
l_int|2
)paren
op_logical_and
(paren
id|hostdata-&gt;incoming_ptr
op_eq
(paren
id|ucp
(braket
l_int|1
)braket
op_plus
l_int|1
)paren
)paren
)paren
(brace
r_switch
c_cond
(paren
id|ucp
(braket
l_int|2
)braket
)paren
(brace
multiline_comment|/* what&squot;s the EXTENDED code? */
r_case
id|EXTENDED_SDTR
suffix:colon
id|id
op_assign
id|calc_sync_xfer
c_func
(paren
id|ucp
(braket
l_int|3
)braket
comma
id|ucp
(braket
l_int|4
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_ne
id|SS_WAITING
)paren
(brace
multiline_comment|/* A device has sent an unsolicited SDTR message; rather than go&n; * through the effort of decoding it and then figuring out what&n; * our reply should be, we&squot;re just gonna say that we have a&n; * synchronous fifo depth of 0. This will result in asynchronous&n; * transfers - not ideal but so much easier.&n; * Actually, this is OK because it assures us that if we don&squot;t&n; * specifically ask for sync transfers, we won&squot;t do any.&n; */
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_ASSERT_ATN
)paren
suffix:semicolon
multiline_comment|/* want MESS_OUT */
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|1
)braket
op_assign
l_int|3
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|2
)braket
op_assign
id|EXTENDED_SDTR
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|3
)braket
op_assign
id|hostdata-&gt;default_sx_per
op_div
l_int|4
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;outgoing_len
op_assign
l_int|5
suffix:semicolon
id|hostdata-&gt;sync_xfer
(braket
id|cmd-&gt;target
)braket
op_assign
id|calc_sync_xfer
c_func
(paren
id|hostdata-&gt;default_sx_per
op_div
l_int|4
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|hostdata-&gt;sync_xfer
(braket
id|cmd-&gt;target
)braket
op_assign
id|id
suffix:semicolon
)brace
macro_line|#ifdef SYNC_DEBUG
id|printk
c_func
(paren
l_string|&quot;sync_xfer=%02x&quot;
comma
id|hostdata-&gt;sync_xfer
(braket
id|cmd-&gt;target
)braket
)paren
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;sync_stat
(braket
id|cmd-&gt;target
)braket
op_assign
id|SS_SET
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EXTENDED_WDTR
suffix:colon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_ASSERT_ATN
)paren
suffix:semicolon
multiline_comment|/* want MESS_OUT */
id|printk
c_func
(paren
l_string|&quot;sending WDTR &quot;
)paren
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|2
)braket
op_assign
id|EXTENDED_WDTR
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 8 bit transfer width */
id|hostdata-&gt;outgoing_len
op_assign
l_int|4
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_ASSERT_ATN
)paren
suffix:semicolon
multiline_comment|/* want MESS_OUT */
id|printk
c_func
(paren
l_string|&quot;Rejecting Unknown Extended Message(%02x). &quot;
comma
id|ucp
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
id|MESSAGE_REJECT
suffix:semicolon
id|hostdata-&gt;outgoing_len
op_assign
l_int|1
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hostdata-&gt;incoming_ptr
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We need to read more MESS_IN bytes for the extended message */
r_else
(brace
id|hostdata-&gt;incoming_ptr
op_increment
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Rejecting Unknown Message(%02x) &quot;
comma
id|msg
)paren
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_ASSERT_ATN
)paren
suffix:semicolon
multiline_comment|/* want MESS_OUT */
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
id|MESSAGE_REJECT
suffix:semicolon
id|hostdata-&gt;outgoing_len
op_assign
l_int|1
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Note: this interrupt will occur only after a LEVEL2 command */
r_case
id|CSR_SEL_XFER_DONE
suffix:colon
multiline_comment|/* Make sure that reselection is enabled at this point - it may&n; * have been turned off for the command that just completed.&n; */
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_SOURCE_ID
comma
id|SRCID_ER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|phs
op_eq
l_int|0x60
)paren
(brace
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;SX-DONE-%ld&quot;
comma
id|cmd-&gt;pid
)paren
)paren
id|cmd-&gt;SCp.Message
op_assign
id|COMMAND_COMPLETE
suffix:semicolon
id|lun
op_assign
id|read_3393
c_func
(paren
id|hostdata
comma
id|WD_TARGET_LUN
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;:%d.%d&quot;
comma
id|cmd-&gt;SCp.Status
comma
id|lun
)paren
)paren
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;SCp.Status
op_eq
id|ILLEGAL_STATUS_BYTE
)paren
id|cmd-&gt;SCp.Status
op_assign
id|lun
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
id|cmd-&gt;SCp.Status
op_ne
id|GOOD
)paren
id|cmd-&gt;result
op_assign
(paren
id|cmd-&gt;result
op_amp
l_int|0x00ffff
)paren
op_or
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
r_else
id|cmd-&gt;result
op_assign
id|cmd-&gt;SCp.Status
op_or
(paren
id|cmd-&gt;SCp.Message
op_lshift
l_int|8
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/* We are no longer connected to a target - check to see if&n; * there are commands waiting to be executed.&n; */
id|in2000_execute
c_func
(paren
id|instance
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%02x:%02x:%02x-%ld: Unknown SEL_XFER_DONE phase!!---&quot;
comma
id|asr
comma
id|sr
comma
id|phs
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Note: this interrupt will occur only after a LEVEL2 command */
r_case
id|CSR_SDP
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;SDP&quot;
)paren
)paren
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_COMMAND_PHASE
comma
l_int|0x41
)paren
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_XFER_DONE
op_or
id|PHS_MESS_OUT
suffix:colon
r_case
id|CSR_UNEXP
op_or
id|PHS_MESS_OUT
suffix:colon
r_case
id|CSR_SRV_REQ
op_or
id|PHS_MESS_OUT
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;MSG_OUT=&quot;
)paren
)paren
multiline_comment|/* To get here, we&squot;ve probably requested MESSAGE_OUT and have&n; * already put the correct bytes in outgoing_msg[] and filled&n; * in outgoing_len. We simply send them out to the SCSI bus.&n; * Sometimes we get MESSAGE_OUT phase when we&squot;re not expecting&n; * it - like when our SDTR message is rejected by a target. Some&n; * targets send the REJECT before receiving all of the extended&n; * message, and then seem to go back to MESSAGE_OUT for a byte&n; * or two. Not sure why, or if I&squot;m doing something wrong to&n; * cause this to happen. Regardless, it seems that sending&n; * NOP messages in these situations results in no harm and&n; * makes everyone happy.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;outgoing_len
op_eq
l_int|0
)paren
(brace
id|hostdata-&gt;outgoing_len
op_assign
l_int|1
suffix:semicolon
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
op_assign
id|NOP
suffix:semicolon
)brace
id|transfer_pio
c_func
(paren
id|hostdata-&gt;outgoing_msg
comma
id|hostdata-&gt;outgoing_len
comma
id|DATA_OUT_DIR
comma
id|hostdata
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|hostdata-&gt;outgoing_msg
(braket
l_int|0
)braket
)paren
)paren
id|hostdata-&gt;outgoing_len
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_UNEXP_DISC
suffix:colon
multiline_comment|/* I think I&squot;ve seen this after a request-sense that was in response&n; * to an error condition, but not sure. We certainly need to do&n; * something when we get this interrupt - the question is &squot;what?&squot;.&n; * Let&squot;s think positively, and assume some command has finished&n; * in a legal manner (like a command that provokes a request-sense),&n; * so we treat it as a normal command-complete-disconnect.&n; */
multiline_comment|/* Make sure that reselection is enabled at this point - it may&n; * have been turned off for the command that just completed.&n; */
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_SOURCE_ID
comma
id|SRCID_ER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; - Already disconnected! &quot;
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
multiline_comment|/* release the SMP spin_lock and restore irq state */
id|CLISPIN_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;UNEXP_DISC-%ld&quot;
comma
id|cmd-&gt;pid
)paren
)paren
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
id|cmd-&gt;SCp.Status
op_ne
id|GOOD
)paren
id|cmd-&gt;result
op_assign
(paren
id|cmd-&gt;result
op_amp
l_int|0x00ffff
)paren
op_or
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
r_else
id|cmd-&gt;result
op_assign
id|cmd-&gt;SCp.Status
op_or
(paren
id|cmd-&gt;SCp.Message
op_lshift
l_int|8
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/* We are no longer connected to a target - check to see if&n; * there are commands waiting to be executed.&n; */
id|in2000_execute
c_func
(paren
id|instance
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_DISC
suffix:colon
multiline_comment|/* Make sure that reselection is enabled at this point - it may&n; * have been turned off for the command that just completed.&n; */
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_SOURCE_ID
comma
id|SRCID_ER
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;DISC-%ld&quot;
comma
id|cmd-&gt;pid
)paren
)paren
r_if
c_cond
(paren
id|cmd
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; - Already disconnected! &quot;
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|hostdata-&gt;state
)paren
(brace
r_case
id|S_PRE_CMP_DISC
suffix:colon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;:%d&quot;
comma
id|cmd-&gt;SCp.Status
)paren
)paren
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
id|cmd-&gt;SCp.Status
op_ne
id|GOOD
)paren
id|cmd-&gt;result
op_assign
(paren
id|cmd-&gt;result
op_amp
l_int|0x00ffff
)paren
op_or
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
r_else
id|cmd-&gt;result
op_assign
id|cmd-&gt;SCp.Status
op_or
(paren
id|cmd-&gt;SCp.Message
op_lshift
l_int|8
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_PRE_TMP_DISC
suffix:colon
r_case
id|S_RUNNING_LEVEL2
suffix:colon
id|cmd-&gt;host_scribble
op_assign
(paren
id|uchar
op_star
)paren
id|hostdata-&gt;disconnected_Q
suffix:semicolon
id|hostdata-&gt;disconnected_Q
op_assign
id|cmd
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
macro_line|#ifdef PROC_STATISTICS
id|hostdata-&gt;disc_done_cnt
(braket
id|cmd-&gt;target
)braket
op_increment
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;*** Unexpected DISCONNECT interrupt! ***&quot;
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
)brace
multiline_comment|/* We are no longer connected to a target - check to see if&n; * there are commands waiting to be executed.&n; */
id|in2000_execute
c_func
(paren
id|instance
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR_RESEL_AM
suffix:colon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;RESEL&quot;
)paren
)paren
multiline_comment|/* First we have to make sure this reselection didn&squot;t */
multiline_comment|/* happen during Arbitration/Selection of some other device. */
multiline_comment|/* If yes, put losing command back on top of input_Q. */
r_if
c_cond
(paren
id|hostdata-&gt;level2
op_le
id|L2_NONE
)paren
(brace
r_if
c_cond
(paren
id|hostdata-&gt;selecting
)paren
(brace
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;selecting
suffix:semicolon
id|hostdata-&gt;selecting
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
(paren
id|uchar
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|hostdata-&gt;input_Q
op_assign
id|cmd
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|phs
op_eq
l_int|0x00
)paren
(brace
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
(paren
id|uchar
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|hostdata-&gt;input_Q
op_assign
id|cmd
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;---%02x:%02x:%02x-TROUBLE: Intrusive ReSelect!---&quot;
comma
id|asr
comma
id|sr
comma
id|phs
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;r&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* OK - find out which device reselected us. */
id|id
op_assign
id|read_3393
c_func
(paren
id|hostdata
comma
id|WD_SOURCE_ID
)paren
suffix:semicolon
id|id
op_and_assign
id|SRCID_MASK
suffix:semicolon
multiline_comment|/* and extract the lun from the ID message. (Note that we don&squot;t&n;    * bother to check for a valid message here - I guess this is&n;    * not the right way to go, but....)&n;    */
id|lun
op_assign
id|read_3393
c_func
(paren
id|hostdata
comma
id|WD_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;level2
OL
id|L2_RESELECT
)paren
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_NEGATE_ACK
)paren
suffix:semicolon
id|lun
op_and_assign
l_int|7
suffix:semicolon
multiline_comment|/* Now we look for the command that&squot;s reconnecting. */
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_Q
suffix:semicolon
id|patch
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|id
op_eq
id|cmd-&gt;target
op_logical_and
id|lun
op_eq
id|cmd-&gt;lun
)paren
r_break
suffix:semicolon
id|patch
op_assign
id|cmd
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
)brace
multiline_comment|/* Hmm. Couldn&squot;t find a valid command.... What to do? */
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;---TROUBLE: target %d.%d not in disconnect queue---&quot;
comma
id|id
comma
id|lun
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Ok, found the command - now start it up again. */
r_if
c_cond
(paren
id|patch
)paren
id|patch-&gt;host_scribble
op_assign
id|cmd-&gt;host_scribble
suffix:semicolon
r_else
id|hostdata-&gt;disconnected_Q
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
id|hostdata-&gt;connected
op_assign
id|cmd
suffix:semicolon
multiline_comment|/* We don&squot;t need to worry about &squot;initialize_SCp()&squot; or &squot;hostdata-&gt;busy[]&squot;&n;    * because these things are preserved over a disconnect.&n;    * But we DO need to fix the DPD bit so it&squot;s correct for this command.&n;    */
r_if
c_cond
(paren
id|is_dir_out
c_func
(paren
id|cmd
)paren
)paren
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_DESTINATION_ID
comma
id|cmd-&gt;target
)paren
suffix:semicolon
r_else
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_DESTINATION_ID
comma
id|cmd-&gt;target
op_or
id|DSTID_DPD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;level2
op_ge
id|L2_RESELECT
)paren
(brace
id|write_3393_count
c_func
(paren
id|hostdata
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* we want a DATA_PHASE interrupt */
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_COMMAND_PHASE
comma
l_int|0x45
)paren
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_SEL_ATN_XFER
)paren
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_RUNNING_LEVEL2
suffix:semicolon
)brace
r_else
id|hostdata-&gt;state
op_assign
id|S_CONNECTED
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;-%ld&quot;
comma
id|cmd-&gt;pid
)paren
)paren
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;--UNKNOWN INTERRUPT:%02x:%02x:%02x--&quot;
comma
id|asr
comma
id|sr
comma
id|phs
)paren
suffix:semicolon
)brace
id|write1_io
c_func
(paren
l_int|0
comma
id|IO_LED_OFF
)paren
suffix:semicolon
id|DB
c_func
(paren
id|DB_INTR
comma
id|printk
c_func
(paren
l_string|&quot;} &quot;
)paren
)paren
multiline_comment|/* release the SMP spin_lock and restore irq state */
id|CLISPIN_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|macro|RESET_CARD
mdefine_line|#define RESET_CARD         0
DECL|macro|RESET_CARD_AND_BUS
mdefine_line|#define RESET_CARD_AND_BUS 1
DECL|macro|B_FLAG
mdefine_line|#define B_FLAG 0x80
DECL|function|reset_hardware
r_static
r_int
id|reset_hardware
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
id|type
)paren
(brace
r_struct
id|IN2000_hostdata
op_star
id|hostdata
suffix:semicolon
r_int
id|qt
comma
id|x
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|IN2000_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|write1_io
c_func
(paren
l_int|0
comma
id|IO_LED_ON
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|RESET_CARD_AND_BUS
)paren
(brace
id|write1_io
c_func
(paren
l_int|0
comma
id|IO_CARD_RESET
)paren
suffix:semicolon
id|x
op_assign
id|read1_io
c_func
(paren
id|IO_HARDWARE
)paren
suffix:semicolon
)brace
id|x
op_assign
id|read_3393
c_func
(paren
id|hostdata
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
multiline_comment|/* clear any WD intrpt */
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_OWN_ID
comma
id|instance-&gt;this_id
op_or
id|OWNID_EAF
op_or
id|OWNID_RAF
op_or
id|OWNID_FS_8
)paren
suffix:semicolon
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_POLLED
)paren
suffix:semicolon
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_SYNCHRONOUS_TRANSFER
comma
id|calc_sync_xfer
c_func
(paren
id|hostdata-&gt;default_sx_per
op_div
l_int|4
comma
id|DEFAULT_SX_OFF
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|write1_io
c_func
(paren
l_int|0
comma
id|IO_FIFO_WRITE
)paren
suffix:semicolon
multiline_comment|/* clear fifo counter */
id|write1_io
c_func
(paren
l_int|0
comma
id|IO_FIFO_READ
)paren
suffix:semicolon
multiline_comment|/* start fifo out in read mode */
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_COMMAND
comma
id|WD_CMD_RESET
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|READ_AUX_STAT
c_func
(paren
)paren
op_amp
id|ASR_INT
)paren
)paren
suffix:semicolon
multiline_comment|/* wait for RESET to complete */
id|x
op_assign
id|read_3393
c_func
(paren
id|hostdata
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
multiline_comment|/* clear interrupt */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_QUEUE_TAG
comma
l_int|0xa5
)paren
suffix:semicolon
multiline_comment|/* any random number */
id|qt
op_assign
id|read_3393
c_func
(paren
id|hostdata
comma
id|WD_QUEUE_TAG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qt
op_eq
l_int|0xa5
)paren
(brace
id|x
op_or_assign
id|B_FLAG
suffix:semicolon
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_QUEUE_TAG
comma
l_int|0
)paren
suffix:semicolon
)brace
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_TIMEOUT_PERIOD
comma
id|TIMEOUT_PERIOD_VALUE
)paren
suffix:semicolon
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_POLLED
)paren
suffix:semicolon
id|write1_io
c_func
(paren
l_int|0
comma
id|IO_LED_OFF
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
DECL|function|in2000_reset
r_int
id|in2000_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_int
id|reset_flags
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_struct
id|IN2000_hostdata
op_star
id|hostdata
suffix:semicolon
r_int
id|x
suffix:semicolon
id|instance
op_assign
id|cmd-&gt;host
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|IN2000_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d: Reset. &quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* do scsi-reset here */
id|reset_hardware
c_func
(paren
id|instance
comma
id|RESET_CARD_AND_BUS
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|8
suffix:semicolon
id|x
op_increment
)paren
(brace
id|hostdata-&gt;busy
(braket
id|x
)braket
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;sync_xfer
(braket
id|x
)braket
op_assign
id|calc_sync_xfer
c_func
(paren
id|DEFAULT_SX_PER
op_div
l_int|4
comma
id|DEFAULT_SX_OFF
)paren
suffix:semicolon
id|hostdata-&gt;sync_stat
(braket
id|x
)braket
op_assign
id|SS_UNSET
suffix:semicolon
multiline_comment|/* using default sync values */
)brace
id|hostdata-&gt;input_Q
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;selecting
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;disconnected_Q
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
id|hostdata-&gt;fifo
op_assign
id|FI_FIFO_UNUSED
suffix:semicolon
id|hostdata-&gt;incoming_ptr
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;outgoing_len
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|in2000_abort
r_int
id|in2000_abort
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_struct
id|IN2000_hostdata
op_star
id|hostdata
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
comma
op_star
id|prev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|uchar
id|sr
comma
id|asr
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|instance
op_assign
id|cmd-&gt;host
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|IN2000_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d: Abort-&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;(asr=%02x,count=%ld,resid=%d,buf_resid=%d,have_data=%d,FC=%02x)- &quot;
comma
id|READ_AUX_STAT
c_func
(paren
)paren
comma
id|read_3393_count
c_func
(paren
id|hostdata
)paren
comma
id|cmd-&gt;SCp.this_residual
comma
id|cmd-&gt;SCp.buffers_residual
comma
id|cmd-&gt;SCp.have_data_in
comma
id|read1_io
c_func
(paren
id|IO_FIFO_COUNT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * Case 1 : If the command hasn&squot;t been issued yet, we simply remove it&n; *     from the inout_Q.&n; */
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;input_Q
suffix:semicolon
id|prev
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|tmp
op_eq
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;host_scribble
op_assign
id|cmd-&gt;host_scribble
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d: Abort - removing command %ld from input_Q. &quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
id|prev
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
suffix:semicolon
)brace
multiline_comment|/*&n; * Case 2 : If the command is connected, we&squot;re going to fail the abort&n; *     and let the high level SCSI driver retry at a later time or&n; *     issue a reset.&n; *&n; *     Timeouts, and therefore aborted commands, will be highly unlikely&n; *     and handling them cleanly in this situation would make the common&n; *     case of noresets less efficient, and would pollute our code.  So,&n; *     we fail.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;connected
op_eq
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Aborting connected command %ld - &quot;
comma
id|instance-&gt;host_no
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sending wd33c93 ABORT command - &quot;
)paren
suffix:semicolon
id|write_3393
c_func
(paren
id|hostdata
comma
id|WD_CONTROL
comma
id|CTRL_IDI
op_or
id|CTRL_EDI
op_or
id|CTRL_POLLED
)paren
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_ABORT
)paren
suffix:semicolon
multiline_comment|/* Now we have to attempt to flush out the FIFO... */
id|printk
c_func
(paren
l_string|&quot;flushing fifo - &quot;
)paren
suffix:semicolon
id|timeout
op_assign
l_int|1000000
suffix:semicolon
r_do
(brace
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|asr
op_amp
id|ASR_DBR
)paren
id|read_3393
c_func
(paren
id|hostdata
comma
id|WD_DATA
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|asr
op_amp
id|ASR_INT
)paren
op_logical_and
id|timeout
op_decrement
OG
l_int|0
)paren
suffix:semicolon
id|sr
op_assign
id|read_3393
c_func
(paren
id|hostdata
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;asr=%02x, sr=%02x, %ld bytes un-transferred (timeout=%ld) - &quot;
comma
id|asr
comma
id|sr
comma
id|read_3393_count
c_func
(paren
id|hostdata
)paren
comma
id|timeout
)paren
suffix:semicolon
multiline_comment|/*&n;    * Abort command processed.&n;    * Still connected.&n;    * We must disconnect.&n;    */
id|printk
c_func
(paren
l_string|&quot;sending wd33c93 DISCONNECT command - &quot;
)paren
suffix:semicolon
id|write_3393_cmd
c_func
(paren
id|hostdata
comma
id|WD_CMD_DISCONNECT
)paren
suffix:semicolon
id|timeout
op_assign
l_int|1000000
suffix:semicolon
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|asr
op_amp
id|ASR_CIP
)paren
op_logical_and
id|timeout
op_decrement
OG
l_int|0
)paren
id|asr
op_assign
id|READ_AUX_STAT
c_func
(paren
)paren
suffix:semicolon
id|sr
op_assign
id|read_3393
c_func
(paren
id|hostdata
comma
id|WD_SCSI_STATUS
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;asr=%02x, sr=%02x.&quot;
comma
id|asr
comma
id|sr
)paren
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|in2000_execute
(paren
id|instance
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Case 3: If the command is currently disconnected from the bus,&n; * we&squot;re not going to expend much effort here: Let&squot;s just return&n; * an ABORT_SNOOZE and hope for the best...&n; */
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_Q
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|tmp-&gt;host_scribble
)paren
r_if
c_cond
(paren
id|cmd
op_eq
id|tmp
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Sending ABORT_SNOOZE. &quot;
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
multiline_comment|/*&n; * Case 4 : If we reached this point, the command was not found in any of&n; *     the queues.&n; *&n; * We probably reached this point because of an unlikely race condition&n; * between the command completing successfully and the abortion code,&n; * so we won&squot;t panic, but we will notify the user in case something really&n; * broke.&n; */
id|in2000_execute
(paren
id|instance
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d: warning : SCSI command probably completed successfully&quot;
l_string|&quot;         before abortion. &quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
DECL|macro|MAX_IN2000_HOSTS
mdefine_line|#define MAX_IN2000_HOSTS 3
DECL|macro|MAX_SETUP_ARGS
mdefine_line|#define MAX_SETUP_ARGS (sizeof(setup_args) / sizeof(char *))
DECL|macro|SETUP_BUFFER_SIZE
mdefine_line|#define SETUP_BUFFER_SIZE 200
DECL|variable|setup_buffer
r_static
r_char
id|setup_buffer
(braket
id|SETUP_BUFFER_SIZE
)braket
suffix:semicolon
DECL|variable|setup_used
r_static
r_char
id|setup_used
(braket
id|MAX_SETUP_ARGS
)braket
suffix:semicolon
DECL|variable|done_setup
r_static
r_int
id|done_setup
op_assign
l_int|0
suffix:semicolon
DECL|function|in2000_setup
r_void
id|__init
id|in2000_setup
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|p1
comma
op_star
id|p2
suffix:semicolon
id|strncpy
c_func
(paren
id|setup_buffer
comma
id|str
comma
id|SETUP_BUFFER_SIZE
)paren
suffix:semicolon
id|setup_buffer
(braket
id|SETUP_BUFFER_SIZE
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|p1
op_assign
id|setup_buffer
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p1
op_logical_and
(paren
id|i
OL
id|MAX_SETUP_ARGS
)paren
)paren
(brace
id|p2
op_assign
id|strchr
c_func
(paren
id|p1
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p2
)paren
(brace
op_star
id|p2
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|p1
op_ne
id|p2
)paren
id|setup_args
(braket
id|i
)braket
op_assign
id|p1
suffix:semicolon
id|p1
op_assign
id|p2
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_else
(brace
id|setup_args
(braket
id|i
)braket
op_assign
id|p1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SETUP_ARGS
suffix:semicolon
id|i
op_increment
)paren
id|setup_used
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|done_setup
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* check_setup_args() returns index if key found, 0 if not&n; */
DECL|function|check_setup_args
r_static
r_int
id|__init
id|check_setup_args
c_func
(paren
r_char
op_star
id|key
comma
r_int
op_star
id|flags
comma
r_int
op_star
id|val
comma
r_char
op_star
id|buf
)paren
(brace
r_int
id|x
suffix:semicolon
r_char
op_star
id|cp
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|MAX_SETUP_ARGS
suffix:semicolon
id|x
op_increment
)paren
(brace
r_if
c_cond
(paren
id|setup_used
(braket
id|x
)braket
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|setup_args
(braket
id|x
)braket
comma
id|key
comma
id|strlen
c_func
(paren
id|key
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_eq
id|MAX_SETUP_ARGS
)paren
r_return
l_int|0
suffix:semicolon
id|setup_used
(braket
id|x
)braket
op_assign
l_int|1
suffix:semicolon
id|cp
op_assign
id|setup_args
(braket
id|x
)braket
op_plus
id|strlen
c_func
(paren
id|key
)paren
suffix:semicolon
op_star
id|val
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|cp
op_ne
l_char|&squot;:&squot;
)paren
r_return
op_increment
id|x
suffix:semicolon
id|cp
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|cp
op_ge
l_char|&squot;0&squot;
)paren
op_logical_and
(paren
op_star
id|cp
op_le
l_char|&squot;9&squot;
)paren
)paren
(brace
op_star
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|cp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
op_increment
id|x
suffix:semicolon
)brace
multiline_comment|/* The &quot;correct&quot; (ie portable) way to access memory-mapped hardware&n; * such as the IN2000 EPROM and dip switch is through the use of&n; * special macros declared in &squot;asm/io.h&squot;. We use readb() and readl()&n; * when reading from the card&squot;s BIOS area in in2000_detect().&n; */
DECL|variable|in2000__INITDATA
r_static
r_const
r_int
r_int
op_star
id|bios_tab
(braket
)braket
id|in2000__INITDATA
op_assign
(brace
(paren
r_int
r_int
op_star
)paren
l_int|0xc8000
comma
(paren
r_int
r_int
op_star
)paren
l_int|0xd0000
comma
(paren
r_int
r_int
op_star
)paren
l_int|0xd8000
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|in2000__INITDATA
r_static
r_const
r_int
r_int
id|base_tab
(braket
)braket
id|in2000__INITDATA
op_assign
(brace
l_int|0x220
comma
l_int|0x200
comma
l_int|0x110
comma
l_int|0x100
comma
)brace
suffix:semicolon
DECL|variable|in2000__INITDATA
r_static
r_const
r_int
id|int_tab
(braket
)braket
id|in2000__INITDATA
op_assign
(brace
l_int|15
comma
l_int|14
comma
l_int|11
comma
l_int|10
)brace
suffix:semicolon
DECL|function|in2000_detect
r_int
id|__init
id|in2000_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_struct
id|IN2000_hostdata
op_star
id|hostdata
suffix:semicolon
r_int
id|detect_count
suffix:semicolon
r_int
id|bios
suffix:semicolon
r_int
id|x
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
id|uchar
id|switches
suffix:semicolon
id|uchar
id|hrev
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_int
id|val
suffix:semicolon
r_char
id|buf
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/* Thanks to help from Bill Earnest, probing for IN2000 cards is a&n; * pretty straightforward and fool-proof operation. There are 3&n; * possible locations for the IN2000 EPROM in memory space - if we&n; * find a BIOS signature, we can read the dip switch settings from&n; * the byte at BIOS+32 (shadowed in by logic on the card). From 2&n; * of the switch bits we get the card&squot;s address in IO space. There&squot;s&n; * an image of the dip switch there, also, so we have a way to back-&n; * check that this really is an IN2000 card. Very nifty. Use the&n; * &squot;ioport:xx&squot; command-line parameter if your BIOS EPROM is absent&n; * or disabled.&n; */
r_if
c_cond
(paren
op_logical_neg
id|done_setup
op_logical_and
id|setup_strings
)paren
id|in2000_setup
c_func
(paren
id|setup_strings
comma
l_int|0
)paren
suffix:semicolon
id|detect_count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|bios
op_assign
l_int|0
suffix:semicolon
id|bios_tab
(braket
id|bios
)braket
suffix:semicolon
id|bios
op_increment
)paren
(brace
r_if
c_cond
(paren
id|check_setup_args
c_func
(paren
l_string|&quot;ioport&quot;
comma
op_amp
id|flags
comma
op_amp
id|val
comma
id|buf
)paren
)paren
(brace
id|base
op_assign
id|val
suffix:semicolon
id|switches
op_assign
op_complement
id|inb
c_func
(paren
id|base
op_plus
id|IO_SWITCHES
)paren
op_amp
l_int|0xff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Forcing IN2000 detection at IOport 0x%x &quot;
comma
id|base
)paren
suffix:semicolon
id|bios
op_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n; * There have been a couple of BIOS versions with different layouts&n; * for the obvious ID strings. We look for the 2 most common ones and&n; * hope that they cover all the cases...&n; */
r_else
r_if
c_cond
(paren
id|readl
c_func
(paren
id|bios_tab
(braket
id|bios
)braket
op_plus
l_int|0x04
)paren
op_eq
l_int|0x41564f4e
op_logical_or
id|readl
c_func
(paren
id|bios_tab
(braket
id|bios
)braket
op_plus
l_int|0x0c
)paren
op_eq
l_int|0x61776c41
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Found IN2000 BIOS at 0x%x &quot;
comma
(paren
r_int
r_int
)paren
id|bios_tab
(braket
id|bios
)braket
)paren
suffix:semicolon
multiline_comment|/* Read the switch image that&squot;s mapped into EPROM space */
id|switches
op_assign
op_complement
(paren
(paren
id|readb
c_func
(paren
id|bios_tab
(braket
id|bios
)braket
op_plus
l_int|0x08
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
multiline_comment|/* Find out where the IO space is */
id|x
op_assign
id|switches
op_amp
(paren
id|SW_ADDR0
op_or
id|SW_ADDR1
)paren
suffix:semicolon
id|base
op_assign
id|base_tab
(braket
id|x
)braket
suffix:semicolon
multiline_comment|/* Check for the IN2000 signature in IO space. */
id|x
op_assign
op_complement
id|inb
c_func
(paren
id|base
op_plus
id|IO_SWITCHES
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|x
op_ne
id|switches
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bad IO signature: %02x vs %02x.&bslash;n&quot;
comma
id|x
comma
id|switches
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
r_continue
suffix:semicolon
multiline_comment|/* OK. We have a base address for the IO ports - run a few safety checks */
r_if
c_cond
(paren
op_logical_neg
(paren
id|switches
op_amp
id|SW_BIT7
)paren
)paren
(brace
multiline_comment|/* I _think_ all cards do this */
id|printk
c_func
(paren
l_string|&quot;There is no IN-2000 SCSI card at IOport 0x%03x!&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Let&squot;s assume any hardware version will work, although the driver&n; * has only been tested on 0x21, 0x22, 0x25, 0x26, and 0x27. We&squot;ll&n; * print out the rev number for reference later, but accept them all.&n; */
id|hrev
op_assign
id|inb
c_func
(paren
id|base
op_plus
id|IO_HARDWARE
)paren
suffix:semicolon
multiline_comment|/* Bit 2 tells us if interrupts are disabled */
r_if
c_cond
(paren
id|switches
op_amp
id|SW_DISINT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;The IN-2000 SCSI card at IOport 0x%03x &quot;
comma
id|base
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;is not configured for interrupt operation!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;This driver requires an interrupt: cancelling detection.&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Ok. We accept that there&squot;s an IN2000 at ioaddr &squot;base&squot;. Now&n; * initialize it.&n; */
id|tpnt-&gt;proc_name
op_assign
l_string|&quot;in2000&quot;
suffix:semicolon
id|instance
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
r_sizeof
(paren
r_struct
id|IN2000_hostdata
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|instance
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
id|detect_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|instance_list
)paren
id|instance_list
op_assign
id|instance
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|IN2000_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
id|instance-&gt;io_port
op_assign
id|hostdata-&gt;io_base
op_assign
id|base
suffix:semicolon
id|hostdata-&gt;dip_switch
op_assign
id|switches
suffix:semicolon
id|hostdata-&gt;hrev
op_assign
id|hrev
suffix:semicolon
id|write1_io
c_func
(paren
l_int|0
comma
id|IO_FIFO_WRITE
)paren
suffix:semicolon
multiline_comment|/* clear fifo counter */
id|write1_io
c_func
(paren
l_int|0
comma
id|IO_FIFO_READ
)paren
suffix:semicolon
multiline_comment|/* start fifo out in read mode */
id|write1_io
c_func
(paren
l_int|0
comma
id|IO_INTR_MASK
)paren
suffix:semicolon
multiline_comment|/* allow all ints */
id|x
op_assign
id|int_tab
(braket
(paren
id|switches
op_amp
(paren
id|SW_INT0
op_or
id|SW_INT1
)paren
)paren
op_rshift
id|SW_INT_SHIFT
)braket
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|x
comma
id|in2000_intr
comma
id|SA_INTERRUPT
comma
l_string|&quot;in2000&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;in2000_detect: Unable to allocate IRQ.&bslash;n&quot;
)paren
suffix:semicolon
id|detect_count
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|instance-&gt;irq
op_assign
id|x
suffix:semicolon
id|instance-&gt;n_io_port
op_assign
l_int|13
suffix:semicolon
id|request_region
c_func
(paren
id|base
comma
l_int|13
comma
l_string|&quot;in2000&quot;
)paren
suffix:semicolon
multiline_comment|/* lock in this IO space for our use */
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|8
suffix:semicolon
id|x
op_increment
)paren
(brace
id|hostdata-&gt;busy
(braket
id|x
)braket
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;sync_xfer
(braket
id|x
)braket
op_assign
id|calc_sync_xfer
c_func
(paren
id|DEFAULT_SX_PER
op_div
l_int|4
comma
id|DEFAULT_SX_OFF
)paren
suffix:semicolon
id|hostdata-&gt;sync_stat
(braket
id|x
)braket
op_assign
id|SS_UNSET
suffix:semicolon
multiline_comment|/* using default sync values */
macro_line|#ifdef PROC_STATISTICS
id|hostdata-&gt;cmd_cnt
(braket
id|x
)braket
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;disc_allowed_cnt
(braket
id|x
)braket
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;disc_done_cnt
(braket
id|x
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
id|hostdata-&gt;input_Q
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;selecting
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;disconnected_Q
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;state
op_assign
id|S_UNCONNECTED
suffix:semicolon
id|hostdata-&gt;fifo
op_assign
id|FI_FIFO_UNUSED
suffix:semicolon
id|hostdata-&gt;level2
op_assign
id|L2_BASIC
suffix:semicolon
id|hostdata-&gt;disconnect
op_assign
id|DIS_ADAPTIVE
suffix:semicolon
id|hostdata-&gt;args
op_assign
id|DEBUG_DEFAULTS
suffix:semicolon
id|hostdata-&gt;incoming_ptr
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;outgoing_len
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;default_sx_per
op_assign
id|DEFAULT_SX_PER
suffix:semicolon
multiline_comment|/* Older BIOS&squot;s had a &squot;sync on/off&squot; switch - use its setting */
r_if
c_cond
(paren
id|readl
c_func
(paren
id|bios_tab
(braket
id|bios
)braket
op_plus
l_int|0x04
)paren
op_eq
l_int|0x41564f4e
op_logical_and
(paren
id|switches
op_amp
id|SW_SYNC_DOS5
)paren
)paren
id|hostdata-&gt;sync_off
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* sync defaults to on */
r_else
id|hostdata-&gt;sync_off
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* sync defaults to off */
macro_line|#ifdef PROC_INTERFACE
id|hostdata-&gt;proc
op_assign
id|PR_VERSION
op_or
id|PR_INFO
op_or
id|PR_STATISTICS
op_or
id|PR_CONNECTED
op_or
id|PR_INPUTQ
op_or
id|PR_DISCQ
op_or
id|PR_STOP
suffix:semicolon
macro_line|#ifdef PROC_STATISTICS
id|hostdata-&gt;int_cnt
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_if
c_cond
(paren
id|check_setup_args
c_func
(paren
l_string|&quot;nosync&quot;
comma
op_amp
id|flags
comma
op_amp
id|val
comma
id|buf
)paren
)paren
id|hostdata-&gt;sync_off
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|check_setup_args
c_func
(paren
l_string|&quot;period&quot;
comma
op_amp
id|flags
comma
op_amp
id|val
comma
id|buf
)paren
)paren
id|hostdata-&gt;default_sx_per
op_assign
id|sx_table
(braket
id|round_period
c_func
(paren
(paren
r_int
r_int
)paren
id|val
)paren
)braket
dot
id|period_ns
suffix:semicolon
r_if
c_cond
(paren
id|check_setup_args
c_func
(paren
l_string|&quot;disconnect&quot;
comma
op_amp
id|flags
comma
op_amp
id|val
comma
id|buf
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|val
op_ge
id|DIS_NEVER
)paren
op_logical_and
(paren
id|val
op_le
id|DIS_ALWAYS
)paren
)paren
id|hostdata-&gt;disconnect
op_assign
id|val
suffix:semicolon
r_else
id|hostdata-&gt;disconnect
op_assign
id|DIS_ADAPTIVE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_setup_args
c_func
(paren
l_string|&quot;noreset&quot;
comma
op_amp
id|flags
comma
op_amp
id|val
comma
id|buf
)paren
)paren
id|hostdata-&gt;args
op_xor_assign
id|A_NO_SCSI_RESET
suffix:semicolon
r_if
c_cond
(paren
id|check_setup_args
c_func
(paren
l_string|&quot;level2&quot;
comma
op_amp
id|flags
comma
op_amp
id|val
comma
id|buf
)paren
)paren
id|hostdata-&gt;level2
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|check_setup_args
c_func
(paren
l_string|&quot;debug&quot;
comma
op_amp
id|flags
comma
op_amp
id|val
comma
id|buf
)paren
)paren
id|hostdata-&gt;args
op_assign
(paren
id|val
op_amp
id|DB_MASK
)paren
suffix:semicolon
macro_line|#ifdef PROC_INTERFACE
r_if
c_cond
(paren
id|check_setup_args
c_func
(paren
l_string|&quot;proc&quot;
comma
op_amp
id|flags
comma
op_amp
id|val
comma
id|buf
)paren
)paren
id|hostdata-&gt;proc
op_assign
id|val
suffix:semicolon
macro_line|#endif
id|x
op_assign
id|reset_hardware
c_func
(paren
id|instance
comma
(paren
id|hostdata-&gt;args
op_amp
id|A_NO_SCSI_RESET
)paren
ques
c_cond
id|RESET_CARD
suffix:colon
id|RESET_CARD_AND_BUS
)paren
suffix:semicolon
id|hostdata-&gt;microcode
op_assign
id|read_3393
c_func
(paren
id|hostdata
comma
id|WD_CDB_1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
op_amp
l_int|0x01
)paren
(brace
r_if
c_cond
(paren
id|x
op_amp
id|B_FLAG
)paren
id|hostdata-&gt;chip
op_assign
id|C_WD33C93B
suffix:semicolon
r_else
id|hostdata-&gt;chip
op_assign
id|C_WD33C93A
suffix:semicolon
)brace
r_else
id|hostdata-&gt;chip
op_assign
id|C_WD33C93
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;dip_switch=%02x irq=%d ioport=%02x floppy=%s sync/DOS5=%s &quot;
comma
(paren
id|switches
op_amp
l_int|0x7f
)paren
comma
id|instance-&gt;irq
comma
id|hostdata-&gt;io_base
comma
(paren
id|switches
op_amp
id|SW_FLOPPY
)paren
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
comma
(paren
id|switches
op_amp
id|SW_SYNC_DOS5
)paren
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;hardware_ver=%02x chip=%s microcode=%02x&bslash;n&quot;
comma
id|hrev
comma
(paren
id|hostdata-&gt;chip
op_eq
id|C_WD33C93
)paren
ques
c_cond
l_string|&quot;WD33c93&quot;
suffix:colon
(paren
id|hostdata-&gt;chip
op_eq
id|C_WD33C93A
)paren
ques
c_cond
l_string|&quot;WD33c93A&quot;
suffix:colon
(paren
id|hostdata-&gt;chip
op_eq
id|C_WD33C93B
)paren
ques
c_cond
l_string|&quot;WD33c93B&quot;
suffix:colon
l_string|&quot;unknown&quot;
comma
id|hostdata-&gt;microcode
)paren
suffix:semicolon
macro_line|#ifdef DEBUGGING_ON
id|printk
c_func
(paren
l_string|&quot;setup_args = &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|MAX_SETUP_ARGS
suffix:semicolon
id|x
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%s,&quot;
comma
id|setup_args
(braket
id|x
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|hostdata-&gt;sync_off
op_eq
l_int|0xff
)paren
id|printk
c_func
(paren
l_string|&quot;Sync-transfer DISABLED on all devices: ENABLE from command-line&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IN2000 driver version %s - %s&bslash;n&quot;
comma
id|IN2000_VERSION
comma
id|IN2000_DATE
)paren
suffix:semicolon
)brace
r_return
id|detect_count
suffix:semicolon
)brace
multiline_comment|/* NOTE: I lifted this function straight out of the old driver,&n; *       and have not tested it. Presumably it does what it&squot;s&n; *       supposed to do...&n; */
DECL|function|in2000_biosparam
r_int
id|in2000_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
op_star
id|iinfo
)paren
(brace
r_int
id|size
suffix:semicolon
id|size
op_assign
id|disk-&gt;capacity
suffix:semicolon
id|iinfo
(braket
l_int|0
)braket
op_assign
l_int|64
suffix:semicolon
id|iinfo
(braket
l_int|1
)braket
op_assign
l_int|32
suffix:semicolon
id|iinfo
(braket
l_int|2
)braket
op_assign
id|size
op_rshift
l_int|11
suffix:semicolon
multiline_comment|/* This should approximate the large drive handling that the DOS ASPI manager&n;   uses.  Drives very near the boundaries may not be handled correctly (i.e.&n;   near 2.0 Gb and 4.0 Gb) */
r_if
c_cond
(paren
id|iinfo
(braket
l_int|2
)braket
OG
l_int|1024
)paren
(brace
id|iinfo
(braket
l_int|0
)braket
op_assign
l_int|64
suffix:semicolon
id|iinfo
(braket
l_int|1
)braket
op_assign
l_int|63
suffix:semicolon
id|iinfo
(braket
l_int|2
)braket
op_assign
id|disk-&gt;capacity
op_div
(paren
id|iinfo
(braket
l_int|0
)braket
op_star
id|iinfo
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iinfo
(braket
l_int|2
)braket
OG
l_int|1024
)paren
(brace
id|iinfo
(braket
l_int|0
)braket
op_assign
l_int|128
suffix:semicolon
id|iinfo
(braket
l_int|1
)braket
op_assign
l_int|63
suffix:semicolon
id|iinfo
(braket
l_int|2
)braket
op_assign
id|disk-&gt;capacity
op_div
(paren
id|iinfo
(braket
l_int|0
)braket
op_star
id|iinfo
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iinfo
(braket
l_int|2
)braket
OG
l_int|1024
)paren
(brace
id|iinfo
(braket
l_int|0
)braket
op_assign
l_int|255
suffix:semicolon
id|iinfo
(braket
l_int|1
)braket
op_assign
l_int|63
suffix:semicolon
id|iinfo
(braket
l_int|2
)braket
op_assign
id|disk-&gt;capacity
op_div
(paren
id|iinfo
(braket
l_int|0
)braket
op_star
id|iinfo
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|in2000_proc_info
r_int
id|in2000_proc_info
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|len
comma
r_int
id|hn
comma
r_int
id|in
)paren
(brace
macro_line|#ifdef PROC_INTERFACE
r_char
op_star
id|bp
suffix:semicolon
r_char
id|tbuf
(braket
l_int|128
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_struct
id|IN2000_hostdata
op_star
id|hd
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_int
id|x
comma
id|i
suffix:semicolon
r_static
r_int
id|stop
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|instance
op_assign
id|instance_list
suffix:semicolon
id|instance
suffix:semicolon
id|instance
op_assign
id|instance-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|instance-&gt;host_no
op_eq
id|hn
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;*** Hmm... Can&squot;t find host #%d!&bslash;n&quot;
comma
id|hn
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ESRCH
)paren
suffix:semicolon
)brace
id|hd
op_assign
(paren
r_struct
id|IN2000_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
multiline_comment|/* If &squot;in&squot; is TRUE we need to _read_ the proc file. We accept the following&n; * keywords (same format as command-line, but only ONE per read):&n; *    debug&n; *    disconnect&n; *    period&n; *    resync&n; *    proc&n; */
r_if
c_cond
(paren
id|in
)paren
(brace
id|buf
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|bp
op_assign
id|buf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|bp
comma
l_string|&quot;debug:&quot;
comma
l_int|6
)paren
)paren
(brace
id|bp
op_add_assign
l_int|6
suffix:semicolon
id|hd-&gt;args
op_assign
id|simple_strtoul
c_func
(paren
id|bp
comma
l_int|NULL
comma
l_int|0
)paren
op_amp
id|DB_MASK
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|bp
comma
l_string|&quot;disconnect:&quot;
comma
l_int|11
)paren
)paren
(brace
id|bp
op_add_assign
l_int|11
suffix:semicolon
id|x
op_assign
id|simple_strtoul
c_func
(paren
id|bp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
template_param
id|DIS_ALWAYS
)paren
id|x
op_assign
id|DIS_ADAPTIVE
suffix:semicolon
id|hd-&gt;disconnect
op_assign
id|x
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|bp
comma
l_string|&quot;period:&quot;
comma
l_int|7
)paren
)paren
(brace
id|bp
op_add_assign
l_int|7
suffix:semicolon
id|x
op_assign
id|simple_strtoul
c_func
(paren
id|bp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|hd-&gt;default_sx_per
op_assign
id|sx_table
(braket
id|round_period
c_func
(paren
(paren
r_int
r_int
)paren
id|x
)paren
)braket
dot
id|period_ns
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|bp
comma
l_string|&quot;resync:&quot;
comma
l_int|7
)paren
)paren
(brace
id|bp
op_add_assign
l_int|7
suffix:semicolon
id|x
op_assign
id|simple_strtoul
c_func
(paren
id|bp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|x
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|hd-&gt;sync_stat
(braket
id|i
)braket
op_assign
id|SS_UNSET
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|bp
comma
l_string|&quot;proc:&quot;
comma
l_int|5
)paren
)paren
(brace
id|bp
op_add_assign
l_int|5
suffix:semicolon
id|hd-&gt;proc
op_assign
id|simple_strtoul
c_func
(paren
id|bp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|bp
comma
l_string|&quot;level2:&quot;
comma
l_int|7
)paren
)paren
(brace
id|bp
op_add_assign
l_int|7
suffix:semicolon
id|hd-&gt;level2
op_assign
id|simple_strtoul
c_func
(paren
id|bp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|bp
op_assign
id|buf
suffix:semicolon
op_star
id|bp
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;proc
op_amp
id|PR_VERSION
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;&bslash;nVersion %s - %s. Compiled %s %s&quot;
comma
id|IN2000_VERSION
comma
id|IN2000_DATE
comma
id|__DATE__
comma
id|__TIME__
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hd-&gt;proc
op_amp
id|PR_INFO
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;&bslash;ndip_switch=%02x: irq=%d io=%02x floppy=%s sync/DOS5=%s&quot;
comma
(paren
id|hd-&gt;dip_switch
op_amp
l_int|0x7f
)paren
comma
id|instance-&gt;irq
comma
id|hd-&gt;io_base
comma
(paren
id|hd-&gt;dip_switch
op_amp
l_int|0x40
)paren
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
comma
(paren
id|hd-&gt;dip_switch
op_amp
l_int|0x20
)paren
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;nsync_xfer[] =       &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|7
suffix:semicolon
id|x
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;&bslash;t%02x&quot;
comma
id|hd-&gt;sync_xfer
(braket
id|x
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
)brace
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;nsync_stat[] =       &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|7
suffix:semicolon
id|x
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;&bslash;t%02x&quot;
comma
id|hd-&gt;sync_stat
(braket
id|x
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef PROC_STATISTICS
r_if
c_cond
(paren
id|hd-&gt;proc
op_amp
id|PR_STATISTICS
)paren
(brace
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;ncommands issued:    &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|7
suffix:semicolon
id|x
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;&bslash;t%ld&quot;
comma
id|hd-&gt;cmd_cnt
(braket
id|x
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
)brace
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;ndisconnects allowed:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|7
suffix:semicolon
id|x
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;&bslash;t%ld&quot;
comma
id|hd-&gt;disc_allowed_cnt
(braket
id|x
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
)brace
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;ndisconnects done:   &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|7
suffix:semicolon
id|x
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;&bslash;t%ld&quot;
comma
id|hd-&gt;disc_done_cnt
(braket
id|x
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot;&bslash;ninterrupts:      &bslash;t%ld&quot;
comma
id|hd-&gt;int_cnt
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|hd-&gt;proc
op_amp
id|PR_CONNECTED
)paren
(brace
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;nconnected:     &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;connected
)paren
(brace
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hd-&gt;connected
suffix:semicolon
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot; %ld-%d:%d(%02x)&quot;
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|hd-&gt;proc
op_amp
id|PR_INPUTQ
)paren
(brace
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;ninput_Q:       &quot;
)paren
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hd-&gt;input_Q
suffix:semicolon
r_while
c_loop
(paren
id|cmd
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot; %ld-%d:%d(%02x)&quot;
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|hd-&gt;proc
op_amp
id|PR_DISCQ
)paren
(brace
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;ndisconnected_Q:&quot;
)paren
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hd-&gt;disconnected_Q
suffix:semicolon
r_while
c_loop
(paren
id|cmd
)paren
(brace
id|sprintf
c_func
(paren
id|tbuf
comma
l_string|&quot; %ld-%d:%d(%02x)&quot;
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|tbuf
)paren
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|hd-&gt;proc
op_amp
id|PR_TEST
)paren
(brace
suffix:semicolon
multiline_comment|/* insert your own custom function here */
)brace
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|stop
)paren
(brace
id|stop
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* return 0 to signal end-of-file */
)brace
r_if
c_cond
(paren
id|off
OG
l_int|0x40000
)paren
multiline_comment|/* ALWAYS stop after 256k bytes have been read */
id|stop
op_assign
l_int|1
suffix:semicolon
suffix:semicolon
r_if
c_cond
(paren
id|hd-&gt;proc
op_amp
id|PR_STOP
)paren
multiline_comment|/* stop every other time */
id|stop
op_assign
l_int|1
suffix:semicolon
r_return
id|strlen
c_func
(paren
id|bp
)paren
suffix:semicolon
macro_line|#else    /* PROC_INTERFACE */
r_return
l_int|0
suffix:semicolon
macro_line|#endif   /* PROC_INTERFACE */
)brace
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|IN2000
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
eof
