multiline_comment|/*&n; *  This file is in2000.c, written and&n; *  Copyright (C) 1993  Brad McLean&n; *&t;Last edit 08/25/94 WDE&n; * Disclaimer:&n; * Note:  This is ugly.  I know it, I wrote it, but my whole&n; * focus was on getting the damn thing up and out quickly.&n; * Future stuff that would be nice:  Command chaining, and&n; * a local queue of commands would speed stuff up considerably.&n; * Disconnection needs some supporting code.  All of this&n; * is beyond the scope of what I wanted to address, but if you&n; * have time and patience, more power to you.&n; * Also, there are some constants scattered throughout that&n; * should have defines, and I should have built functions to&n; * address the registers on the WD chip.&n; * Oh well, I&squot;m out of time for this project.&n; * The one good thing to be said is that you can use the card.&n; */
multiline_comment|/*&n; * This module was updated by Shaun Savage first on 5-13-93&n; * At that time the write was fixed, irq detection, and some&n; * timing stuff.  since that time other problems were fixed.&n; * On 7-20-93 this file was updated for patch level 11&n; * There are still problems with it but it work on 95% of&n; * the machines.  There are still problems with it working with&n; * IDE drives, as swap drive and HD that support reselection.&n; * But for most people it will work.&n; */
multiline_comment|/* More changes by Bill Earnest, wde@aluxpo.att.com&n; * through 4/07/94. Includes rewrites of FIFO routines,&n; * length-limited commands to make swap partitions work.&n; * Merged the changes released by Larry Doolittle, based on input&n; * from Jon Luckey, Roger Sunshine, John Shifflett. The FAST_FIFO&n; * doesn&squot;t work for me. Scatter-gather code from Eric. The change to&n; * an IF stmt. in the interrupt routine finally made it stable.&n; * Limiting swap request size patch to ll_rw_blk.c not needed now.&n; * Please ignore the clutter of debug stmts., pretty can come later.&n; */
multiline_comment|/* Merged code from Matt Postiff improving the auto-sense validation&n; * for all I/O addresses. Some reports of problems still come in, but&n; * have been unable to reproduce or localize the cause. Some are from&n; * LUN &gt; 0 problems, but that is not host specific. Now 6/6/94.&n; */
multiline_comment|/* Changes for 1.1.28 kernel made 7/19/94, code not affected. (WDE)&n; */
multiline_comment|/* Changes for 1.1.43+ kernels made 8/25/94, code added to check for&n; * new BIOS version, derived by jshiffle@netcom.com. (WDE)&n; *&n; * 1/7/95 Fix from Peter Lu (swift@world.std.com) for datalen vs. dataptr&n; * logic, much more stable under load.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/head.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;../block/blk.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &quot;in2000.h&quot;
multiline_comment|/*#define FAST_FIFO_IO*/
multiline_comment|/*#define DEBUG*/
macro_line|#ifdef DEBUG
DECL|macro|DEB
mdefine_line|#define DEB(x) x
macro_line|#else
DECL|macro|DEB
mdefine_line|#define DEB(x)
macro_line|#endif
multiline_comment|/* These functions are based on include/asm/io.h */
macro_line|#ifndef inw
DECL|function|inw
r_inline
r_static
r_int
r_int
id|inw
c_func
(paren
r_int
r_int
id|port
)paren
(brace
r_int
r_int
id|_v
suffix:semicolon
id|__asm__
r_volatile
(paren
l_string|&quot;inw %1,%0&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|_v
)paren
suffix:colon
l_string|&quot;d&quot;
(paren
(paren
r_int
r_int
)paren
id|port
)paren
)paren
suffix:semicolon
r_return
id|_v
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifndef outw
DECL|function|outw
r_inline
r_static
r_void
id|outw
c_func
(paren
r_int
r_int
id|value
comma
r_int
r_int
id|port
)paren
(brace
id|__asm__
r_volatile
(paren
l_string|&quot;outw %0,%1&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;a&quot;
(paren
(paren
r_int
r_int
)paren
id|value
)paren
comma
l_string|&quot;d&quot;
(paren
(paren
r_int
r_int
)paren
id|port
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* These functions are lifted from drivers/block/hd.c */
DECL|macro|port_read
mdefine_line|#define port_read(port,buf,nr) &bslash;&n;__asm__(&quot;cld;rep;insw&quot;: :&quot;d&quot; (port),&quot;D&quot; (buf),&quot;c&quot; (nr):&quot;cx&quot;,&quot;di&quot;)
DECL|macro|port_write
mdefine_line|#define port_write(port,buf,nr) &bslash;&n;__asm__(&quot;cld;rep;outsw&quot;: :&quot;d&quot; (port),&quot;S&quot; (buf),&quot;c&quot; (nr):&quot;cx&quot;,&quot;si&quot;)
DECL|variable|base
r_static
r_int
r_int
id|base
suffix:semicolon
DECL|variable|ficmsk
r_static
r_int
r_int
id|ficmsk
suffix:semicolon
DECL|variable|irq_level
r_static
r_int
r_char
id|irq_level
suffix:semicolon
DECL|variable|in2000_datalen
r_static
r_int
id|in2000_datalen
suffix:semicolon
DECL|variable|in2000_nsegment
r_static
r_int
r_int
id|in2000_nsegment
suffix:semicolon
DECL|variable|in2000_current_segment
r_static
r_int
r_int
id|in2000_current_segment
suffix:semicolon
DECL|variable|in2000_dataptr
r_static
r_int
r_int
op_star
id|in2000_dataptr
suffix:semicolon
DECL|variable|in2000_datawrite
r_static
r_char
id|in2000_datawrite
suffix:semicolon
DECL|variable|in2000_scatter
r_static
r_struct
id|scatterlist
op_star
id|in2000_scatter
suffix:semicolon
DECL|variable|in2000_SCptr
r_static
id|Scsi_Cmnd
op_star
id|in2000_SCptr
op_assign
l_int|0
suffix:semicolon
DECL|variable|in2000_done
r_static
r_void
(paren
op_star
id|in2000_done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
DECL|function|in2000_test_port
r_static
r_int
id|in2000_test_port
c_func
(paren
r_int
id|index
)paren
(brace
r_static
r_const
r_int
op_star
id|bios_tab
(braket
)braket
op_assign
(brace
(paren
r_int
op_star
)paren
l_int|0xc8000
comma
(paren
r_int
op_star
)paren
l_int|0xd0000
comma
(paren
r_int
op_star
)paren
l_int|0xd8000
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
id|tmp
suffix:semicolon
id|tmp
op_assign
id|inb
c_func
(paren
id|INFLED
)paren
suffix:semicolon
multiline_comment|/* First, see if the DIP switch values are valid */
multiline_comment|/* The test of B7 may fail on some early boards, mine works. */
r_if
c_cond
(paren
(paren
(paren
op_complement
id|tmp
op_amp
l_int|0x3
)paren
op_ne
id|index
)paren
op_logical_or
(paren
id|tmp
op_amp
l_int|0x80
)paren
op_logical_or
op_logical_neg
(paren
id|tmp
op_amp
l_int|0x4
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IN-2000 probe got dip setting of %02X&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
id|tmp
op_assign
id|inb
c_func
(paren
id|INVERS
)paren
suffix:semicolon
multiline_comment|/* Add some extra sanity checks here */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_star
(paren
id|bios_tab
(braket
id|i
)braket
op_plus
l_int|0x04
)paren
op_eq
l_int|0x41564f4e
op_logical_or
op_star
(paren
id|bios_tab
(braket
id|i
)braket
op_plus
l_int|0xc
)paren
op_eq
l_int|0x61776c41
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IN-2000 probe found hdw. vers. %02x, BIOS at %06x&bslash;n&quot;
comma
id|tmp
comma
(paren
r_int
r_int
)paren
id|bios_tab
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;in2000 BIOS not found.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * retrieve the current transaction counter from the WD&n; */
DECL|function|in2000_txcnt
r_static
r_int
id|in2000_txcnt
c_func
(paren
r_void
)paren
(brace
r_int
id|total
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|INSTAT
)paren
op_amp
l_int|0x20
)paren
(brace
r_return
l_int|0xffffff
suffix:semicolon
)brace
multiline_comment|/* not readable now */
id|outb
c_func
(paren
id|TXCNTH
comma
id|INSTAT
)paren
suffix:semicolon
multiline_comment|/* then autoincrement */
id|total
op_assign
(paren
id|inb
c_func
(paren
id|INDATA
)paren
op_amp
l_int|0xff
)paren
op_lshift
l_int|16
suffix:semicolon
id|outb
c_func
(paren
id|TXCNTM
comma
id|INSTAT
)paren
suffix:semicolon
id|total
op_add_assign
(paren
id|inb
c_func
(paren
id|INDATA
)paren
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
suffix:semicolon
id|outb
c_func
(paren
id|TXCNTL
comma
id|INSTAT
)paren
suffix:semicolon
id|total
op_add_assign
(paren
id|inb
c_func
(paren
id|INDATA
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
id|total
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: the FIFO is screwy, and has a counter granularity of 16 bytes, so&n; * we have to reconcile the FIFO counter, the transaction byte count from the&n; * WD chip, and of course, our desired transaction size.  It may look strange,&n; * and could probably use improvement, but it works, for now.&n; */
DECL|function|in2000_fifo_out
r_static
r_void
id|in2000_fifo_out
c_func
(paren
r_void
)paren
multiline_comment|/* uses FIFOCNTR */
(brace
r_int
id|count
comma
id|infcnt
comma
id|txcnt
suffix:semicolon
id|infcnt
op_assign
id|inb
c_func
(paren
id|INFCNT
)paren
op_amp
l_int|0xfe
suffix:semicolon
multiline_comment|/* FIFO counter */
r_do
(brace
id|txcnt
op_assign
id|in2000_txcnt
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*DEB(printk(&quot;FIw:%d %02x %d&bslash;n&quot;, in2000_datalen, infcnt, txcnt));*/
id|count
op_assign
(paren
id|infcnt
op_lshift
l_int|3
)paren
op_minus
l_int|32
suffix:semicolon
multiline_comment|/* don&squot;t fill completely */
r_if
c_cond
(paren
id|count
OG
id|in2000_datalen
)paren
id|count
op_assign
id|in2000_datalen
suffix:semicolon
multiline_comment|/* limit to actual data on hand */
id|count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Words, not bytes */
macro_line|#ifdef FAST_FIFO_IO
r_if
c_cond
(paren
id|count
)paren
(brace
id|port_write
c_func
(paren
id|INFIFO
comma
id|in2000_dataptr
comma
id|count
)paren
suffix:semicolon
id|in2000_datalen
op_sub_assign
(paren
id|count
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#else
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|outw
c_func
(paren
op_star
id|in2000_dataptr
op_increment
comma
id|INFIFO
)paren
suffix:semicolon
id|in2000_datalen
op_sub_assign
l_int|2
suffix:semicolon
)brace
macro_line|#endif
)brace
r_while
c_loop
(paren
(paren
id|in2000_datalen
OG
l_int|0
)paren
op_logical_and
(paren
(paren
id|infcnt
op_assign
(paren
id|inb
c_func
(paren
id|INFCNT
)paren
)paren
op_amp
l_int|0xfe
)paren
op_ge
l_int|0x20
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* If scatter-gather, go on to next segment */
r_if
c_cond
(paren
op_logical_neg
id|in2000_datalen
op_logical_and
op_increment
id|in2000_current_segment
OL
id|in2000_nsegment
)paren
(brace
id|in2000_scatter
op_increment
suffix:semicolon
id|in2000_datalen
op_assign
id|in2000_scatter-&gt;length
suffix:semicolon
id|in2000_dataptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|in2000_scatter-&gt;address
suffix:semicolon
)brace
r_if
c_cond
(paren
id|in2000_datalen
op_le
l_int|0
)paren
(brace
id|ficmsk
op_assign
l_int|0
suffix:semicolon
id|count
op_assign
l_int|32
suffix:semicolon
multiline_comment|/* Always says to use this much flush */
r_while
c_loop
(paren
id|count
op_decrement
)paren
id|outw
c_func
(paren
l_int|0
comma
id|INFIFO
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|2
comma
id|ININTR
)paren
suffix:semicolon
multiline_comment|/* Mask FIFO Interrupts when done */
)brace
)brace
DECL|function|in2000_fifo_in
r_static
r_void
id|in2000_fifo_in
c_func
(paren
r_void
)paren
multiline_comment|/* uses FIFOCNTR */
(brace
r_int
id|fic
comma
id|count
comma
id|count2
suffix:semicolon
id|count
op_assign
id|inb
c_func
(paren
id|INFCNT
)paren
op_amp
l_int|0xe1
suffix:semicolon
r_do
(brace
id|count2
op_assign
id|count
suffix:semicolon
id|count
op_assign
(paren
id|fic
op_assign
id|inb
c_func
(paren
id|INFCNT
)paren
)paren
op_amp
l_int|0xe1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_ne
id|count2
)paren
suffix:semicolon
id|DEB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;FIir:%d %02x %08x&bslash;n&quot;
comma
id|in2000_datalen
comma
id|fic
comma
(paren
r_int
r_int
)paren
id|in2000_dataptr
)paren
)paren
suffix:semicolon
r_do
(brace
id|count2
op_assign
id|in2000_txcnt
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* bytes yet to come over SCSI bus */
id|DEB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;FIr:%d %02x %08x %08x&bslash;n&quot;
comma
id|in2000_datalen
comma
id|fic
comma
id|count2
comma
(paren
r_int
r_int
)paren
id|in2000_dataptr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count2
OG
l_int|65536
)paren
(brace
id|count2
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fic
OG
l_int|128
)paren
(brace
id|count
op_assign
l_int|1024
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|fic
OG
l_int|64
)paren
(brace
id|count
op_assign
l_int|512
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|fic
OG
l_int|32
)paren
id|count
op_assign
l_int|256
suffix:semicolon
r_else
r_if
c_cond
(paren
id|count2
OL
id|in2000_datalen
)paren
multiline_comment|/* if drive has &lt; what we want */
id|count
op_assign
id|in2000_datalen
op_minus
id|count2
suffix:semicolon
multiline_comment|/* FIFO has the rest */
r_if
c_cond
(paren
id|count
OG
id|in2000_datalen
)paren
multiline_comment|/* count2 is lesser of FIFO &amp; rqst */
id|count2
op_assign
id|in2000_datalen
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/* converted to word count */
r_else
id|count2
op_assign
id|count
op_rshift
l_int|1
suffix:semicolon
id|count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* also to words */
id|count
op_sub_assign
id|count2
suffix:semicolon
multiline_comment|/* extra left over in FIFO */
macro_line|#ifdef FAST_FIFO_IO
r_if
c_cond
(paren
id|count2
)paren
(brace
id|port_read
c_func
(paren
id|INFIFO
comma
id|in2000_dataptr
comma
id|count2
)paren
suffix:semicolon
id|in2000_datalen
op_sub_assign
(paren
id|count2
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#else
r_while
c_loop
(paren
id|count2
op_decrement
)paren
(brace
op_star
id|in2000_dataptr
op_increment
op_assign
id|inw
c_func
(paren
id|INFIFO
)paren
suffix:semicolon
id|in2000_datalen
op_sub_assign
l_int|2
suffix:semicolon
)brace
macro_line|#endif
)brace
r_while
c_loop
(paren
(paren
id|in2000_datalen
OG
l_int|0
)paren
op_logical_and
(paren
id|fic
op_assign
id|inb
c_func
(paren
id|INFCNT
)paren
)paren
)paren
(brace
suffix:semicolon
)brace
id|DEB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;FIer:%d %02x %08x&bslash;n&quot;
comma
id|in2000_datalen
comma
id|fic
comma
(paren
r_int
r_int
)paren
id|in2000_dataptr
)paren
)paren
suffix:semicolon
multiline_comment|/*    while ( count-- )&n;    &t;inw(INFIFO);*/
multiline_comment|/* Throw away some extra stuff */
r_if
c_cond
(paren
op_logical_neg
id|in2000_datalen
op_logical_and
op_increment
id|in2000_current_segment
OL
id|in2000_nsegment
)paren
(brace
id|in2000_scatter
op_increment
suffix:semicolon
id|in2000_datalen
op_assign
id|in2000_scatter-&gt;length
suffix:semicolon
id|in2000_dataptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|in2000_scatter-&gt;address
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|in2000_datalen
)paren
(brace
id|outb
c_func
(paren
l_int|2
comma
id|ININTR
)paren
suffix:semicolon
multiline_comment|/* Mask FIFO Interrupts when done */
id|ficmsk
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|in2000_intr_handle
r_static
r_void
id|in2000_intr_handle
c_func
(paren
r_int
id|foo
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|count
comma
id|auxstatus
comma
id|scsistatus
comma
id|cmdphase
comma
id|scsibyte
suffix:semicolon
r_int
id|action
op_assign
l_int|0
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCptr
suffix:semicolon
id|DEB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;INT:%d %02x %08x&bslash;n&quot;
comma
id|in2000_datalen
comma
id|inb
c_func
(paren
id|INFCNT
)paren
comma
(paren
r_int
r_int
)paren
id|in2000_dataptr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|ficmsk
op_amp
(paren
id|count
op_assign
id|inb
c_func
(paren
id|INFCNT
)paren
)paren
)paren
op_eq
l_int|0xfe
)paren
op_logical_or
(paren
(paren
id|inb
c_func
(paren
id|INSTAT
)paren
op_amp
l_int|0x8c
)paren
op_eq
l_int|0x80
)paren
)paren
(brace
multiline_comment|/* FIFO interrupt or WD interrupt */
id|auxstatus
op_assign
id|inb
c_func
(paren
id|INSTAT
)paren
suffix:semicolon
multiline_comment|/* need to save now */
id|outb
c_func
(paren
id|SCSIST
comma
id|INSTAT
)paren
suffix:semicolon
id|scsistatus
op_assign
id|inb
c_func
(paren
id|INDATA
)paren
suffix:semicolon
multiline_comment|/* This clears the WD intrpt bit */
id|outb
c_func
(paren
id|TARGETU
comma
id|INSTAT
)paren
suffix:semicolon
multiline_comment|/* then autoincrement */
id|scsibyte
op_assign
id|inb
c_func
(paren
id|INDATA
)paren
suffix:semicolon
multiline_comment|/* Get the scsi status byte */
id|outb
c_func
(paren
id|CMDPHAS
comma
id|INSTAT
)paren
suffix:semicolon
id|cmdphase
op_assign
id|inb
c_func
(paren
id|INDATA
)paren
suffix:semicolon
id|DEB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;(int2000:%02x %02x %02x %02x %02x)&bslash;n&quot;
comma
id|count
comma
id|auxstatus
comma
id|scsistatus
comma
id|cmdphase
comma
id|scsibyte
)paren
)paren
suffix:semicolon
multiline_comment|/* Why do we assume that we need to send more data here??? ERY */
r_if
c_cond
(paren
id|in2000_datalen
)paren
multiline_comment|/* data xfer pending */
(brace
r_if
c_cond
(paren
id|in2000_dataptr
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
l_string|&quot;int2000: dataptr=NULL datalen=%d&bslash;n&quot;
comma
id|in2000_datalen
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|in2000_datawrite
)paren
id|in2000_fifo_out
c_func
(paren
)paren
suffix:semicolon
r_else
id|in2000_fifo_in
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|auxstatus
op_amp
l_int|0x8c
)paren
op_eq
l_int|0x80
)paren
(brace
multiline_comment|/* There is a WD Chip interrupt &amp; register read good */
id|outb
c_func
(paren
l_int|2
comma
id|ININTR
)paren
suffix:semicolon
multiline_comment|/* Disable fifo interrupts */
id|ficmsk
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* 16=Select &amp; transfer complete, 85=got disconnect */
r_if
c_cond
(paren
(paren
id|scsistatus
op_ne
l_int|0x16
)paren
op_logical_and
(paren
id|scsistatus
op_ne
l_int|0x85
)paren
op_logical_and
(paren
id|scsistatus
op_ne
l_int|0x42
)paren
)paren
(brace
multiline_comment|/*&t;   &t;printk(&quot;(WDi2000:%02x %02x %02x %02x %02x)&bslash;n&quot;,count,auxstatus,&n;&t;&t;&t;scsistatus,cmdphase,scsibyte);*/
multiline_comment|/*&t;&t;printk(&quot;QDAT:%d %08x %02x&bslash;n&quot;,&n;&t;&t;in2000_datalen,(unsigned int)in2000_dataptr,ficmsk);*/
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|scsistatus
op_amp
l_int|0xf0
)paren
(brace
r_case
l_int|0x00
suffix:colon
multiline_comment|/* Card Reset Completed */
id|action
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x10
suffix:colon
multiline_comment|/* Successful Command Completion */
r_if
c_cond
(paren
id|scsistatus
op_amp
l_int|0x8
)paren
id|action
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x20
suffix:colon
multiline_comment|/* Command Paused or Aborted */
r_if
c_cond
(paren
(paren
id|scsistatus
op_amp
l_int|0x8
)paren
)paren
id|action
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|scsistatus
op_amp
l_int|7
)paren
OL
l_int|2
)paren
id|action
op_assign
l_int|2
suffix:semicolon
r_else
id|result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
multiline_comment|/* Terminated early */
r_if
c_cond
(paren
id|scsistatus
op_amp
l_int|0x8
)paren
id|action
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|scsistatus
op_amp
l_int|7
)paren
OG
l_int|2
)paren
id|action
op_assign
l_int|2
suffix:semicolon
r_else
id|result
op_assign
id|DID_TIME_OUT
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x80
suffix:colon
multiline_comment|/* Service Required from SCSI bus */
r_if
c_cond
(paren
id|scsistatus
op_amp
l_int|0x8
)paren
id|action
op_assign
l_int|1
suffix:semicolon
r_else
id|action
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* end switch(scsistatus) */
id|outb
c_func
(paren
l_int|0
comma
id|INFLED
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
l_int|0x02
suffix:colon
multiline_comment|/* Issue an abort */
id|outb
c_func
(paren
id|COMMAND
comma
id|INSTAT
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|INDATA
)paren
suffix:semicolon
multiline_comment|/* ABORT COMMAND */
id|result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
r_case
l_int|0x00
suffix:colon
multiline_comment|/* Basically all done */
r_if
c_cond
(paren
op_logical_neg
id|in2000_SCptr
)paren
r_return
suffix:semicolon
id|in2000_SCptr-&gt;result
op_assign
id|result
op_or
id|scsibyte
suffix:semicolon
id|SCptr
op_assign
id|in2000_SCptr
suffix:semicolon
id|in2000_SCptr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|in2000_done
)paren
(paren
op_star
id|in2000_done
)paren
(paren
id|SCptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
multiline_comment|/* We need to reissue a command */
id|outb
c_func
(paren
id|CMDPHAS
comma
id|INSTAT
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|scsistatus
op_amp
l_int|7
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Data out phase */
r_case
l_int|1
suffix:colon
multiline_comment|/* Data in phase */
r_case
l_int|4
suffix:colon
multiline_comment|/* Unspec info out phase */
r_case
l_int|5
suffix:colon
multiline_comment|/* Unspec info in phase */
r_case
l_int|6
suffix:colon
multiline_comment|/* Message in phase */
r_case
l_int|7
suffix:colon
multiline_comment|/* Message in phase */
id|outb
c_func
(paren
l_int|0x41
comma
id|INDATA
)paren
suffix:semicolon
multiline_comment|/* rdy to disconn */
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* command phase */
id|outb
c_func
(paren
l_int|0x30
comma
id|INDATA
)paren
suffix:semicolon
multiline_comment|/* rdy to send cmd bytes */
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* status phase */
id|outb
c_func
(paren
l_int|0x45
comma
id|INDATA
)paren
suffix:semicolon
multiline_comment|/* To go to status phase,*/
id|outb
c_func
(paren
id|TXCNTH
comma
id|INSTAT
)paren
suffix:semicolon
multiline_comment|/* elim. data, autoinc */
id|outb
c_func
(paren
l_int|0
comma
id|INDATA
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|INDATA
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|INDATA
)paren
suffix:semicolon
id|in2000_datalen
op_assign
l_int|0
suffix:semicolon
id|in2000_dataptr
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* end switch(scsistatus) */
id|outb
c_func
(paren
id|COMMAND
comma
id|INSTAT
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|8
comma
id|INDATA
)paren
suffix:semicolon
multiline_comment|/* RESTART THE COMMAND */
r_break
suffix:semicolon
r_case
l_int|0x03
suffix:colon
multiline_comment|/* Finish up a Card Reset */
id|outb
c_func
(paren
id|TIMEOUT
comma
id|INSTAT
)paren
suffix:semicolon
multiline_comment|/* I got these values */
multiline_comment|/* by reverse Engineering */
id|outb
c_func
(paren
id|IN2000_TMOUT
comma
id|INDATA
)paren
suffix:semicolon
multiline_comment|/* the Always&squot; bios. */
id|outb
c_func
(paren
id|CONTROL
comma
id|INSTAT
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|INDATA
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SYNCTXR
comma
id|INSTAT
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x40
comma
id|INDATA
)paren
suffix:semicolon
multiline_comment|/* async, 4 cyc xfer per. */
r_break
suffix:semicolon
)brace
multiline_comment|/* end switch(action) */
)brace
multiline_comment|/* end if auxstatus for WD int */
)brace
multiline_comment|/* end while intrpt active */
)brace
DECL|function|in2000_queuecommand
r_int
id|in2000_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|unchar
id|direction
suffix:semicolon
id|unchar
op_star
id|cmd
op_assign
(paren
id|unchar
op_star
)paren
id|SCpnt-&gt;cmnd
suffix:semicolon
id|unchar
id|target
op_assign
id|SCpnt-&gt;target
suffix:semicolon
r_void
op_star
id|buff
op_assign
id|SCpnt-&gt;request_buffer
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|bufflen
op_assign
id|SCpnt-&gt;request_bufflen
suffix:semicolon
r_int
id|timeout
comma
id|size
comma
id|loop
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;     * This SCSI command has no data phase, but unfortunately the mid-level&n;     * SCSI drivers ask for 256 bytes of data xfer.  Our card hangs if you&n;     * do this, so we protect against it here.  It would be nice if the mid-&n;     * level could be changed, but who knows if that would break other host&n;     * adapter drivers.&n;     */
r_if
c_cond
(paren
op_star
id|cmd
op_eq
id|TEST_UNIT_READY
)paren
id|bufflen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * What it looks like.  Boy did I get tired of reading it&squot;s output.&n;     */
r_if
c_cond
(paren
op_star
id|cmd
op_eq
id|READ_10
op_logical_or
op_star
id|cmd
op_eq
id|WRITE_10
)paren
(brace
id|i
op_assign
id|xscsi2int
c_func
(paren
(paren
id|cmd
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|cmd
op_eq
id|READ_6
op_logical_or
op_star
id|cmd
op_eq
id|WRITE_6
)paren
(brace
id|i
op_assign
id|scsi2int
c_func
(paren
(paren
id|cmd
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|i
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;in2000qcmd: pos %d len %d &quot;
comma
id|i
comma
id|bufflen
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi cmd:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCpnt-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|cmd
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|direction
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* assume for most commands */
r_if
c_cond
(paren
op_star
id|cmd
op_eq
id|WRITE_10
op_logical_or
op_star
id|cmd
op_eq
id|WRITE_6
)paren
id|direction
op_assign
l_int|0
suffix:semicolon
id|size
op_assign
id|SCpnt-&gt;cmd_len
suffix:semicolon
multiline_comment|/* CDB length */
multiline_comment|/*&n;     * Setup our current pointers&n;     * This is where you would allocate a control structure in a queue,&n;     * If you were going to upgrade this to do multiple issue.&n;     * Note that datalen and dataptr exist because we can change the&n;     * values during the course of the operation, while managing the&n;     * FIFO.&n;     * Note the nasty little first clause.  In theory, the mid-level&n;     * drivers should never hand us more than one command at a time,&n;     * but just in case someone gets cute in configuring the driver,&n;     * we&squot;ll protect them, although not very politely.&n;     */
r_if
c_cond
(paren
id|in2000_SCptr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;in2000_queue_command waiting for free command block!&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|in2000_SCptr
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|timeout
op_assign
id|jiffies
op_plus
l_int|5
suffix:semicolon
id|timeout
OG
id|jiffies
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|INSTAT
)paren
op_amp
l_int|0xb0
)paren
)paren
(brace
id|timeout
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|inb
c_func
(paren
id|INSTAT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SCSIST
comma
id|INSTAT
)paren
suffix:semicolon
id|inb
c_func
(paren
id|INDATA
)paren
suffix:semicolon
id|outb
c_func
(paren
id|TARGETU
comma
id|INSTAT
)paren
suffix:semicolon
multiline_comment|/* then autoinc */
id|inb
c_func
(paren
id|INDATA
)paren
suffix:semicolon
id|inb
c_func
(paren
id|INDATA
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|timeout
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;in2000_queue_command timeout!&bslash;n&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_TIME_OUT
op_lshift
l_int|16
suffix:semicolon
(paren
op_star
id|done
)paren
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Added for scatter-gather support */
id|in2000_nsegment
op_assign
id|SCpnt-&gt;use_sg
suffix:semicolon
id|in2000_current_segment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
id|in2000_scatter
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|buff
suffix:semicolon
id|in2000_datalen
op_assign
id|in2000_scatter-&gt;length
suffix:semicolon
id|in2000_dataptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|in2000_scatter-&gt;address
suffix:semicolon
)brace
r_else
(brace
id|in2000_scatter
op_assign
l_int|NULL
suffix:semicolon
id|in2000_datalen
op_assign
id|bufflen
suffix:semicolon
id|in2000_dataptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|buff
suffix:semicolon
)brace
suffix:semicolon
id|in2000_done
op_assign
id|done
suffix:semicolon
id|in2000_SCptr
op_assign
id|SCpnt
suffix:semicolon
multiline_comment|/*&n;     * Write the CDB to the card, then the LUN, the length, and the target.&n;     */
id|outb
c_func
(paren
id|TOTSECT
comma
id|INSTAT
)paren
suffix:semicolon
multiline_comment|/* start here then autoincrement */
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|size
suffix:semicolon
id|loop
op_increment
)paren
id|outb
c_func
(paren
id|cmd
(braket
id|loop
)braket
comma
id|INDATA
)paren
suffix:semicolon
id|outb
c_func
(paren
id|TARGETU
comma
id|INSTAT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SCpnt-&gt;lun
op_amp
l_int|7
comma
id|INDATA
)paren
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|outb
c_func
(paren
id|TXCNTH
comma
id|INSTAT
)paren
suffix:semicolon
multiline_comment|/* then autoincrement */
id|outb
c_func
(paren
id|bufflen
op_rshift
l_int|16
comma
id|INDATA
)paren
suffix:semicolon
id|outb
c_func
(paren
id|bufflen
op_rshift
l_int|8
comma
id|INDATA
)paren
suffix:semicolon
id|outb
c_func
(paren
id|bufflen
comma
id|INDATA
)paren
suffix:semicolon
id|outb
c_func
(paren
id|target
op_amp
l_int|7
comma
id|INDATA
)paren
suffix:semicolon
multiline_comment|/*&n;     * Set up the FIFO&n;     */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* so FIFO init waits till WD set */
id|outb
c_func
(paren
l_int|0
comma
id|INFRST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
l_int|1
)paren
(brace
id|in2000_datawrite
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|INFWRT
)paren
suffix:semicolon
)brace
r_else
(brace
id|in2000_datawrite
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|16
suffix:semicolon
op_decrement
id|loop
suffix:semicolon
)paren
multiline_comment|/* preload the outgoing fifo */
(brace
id|outw
c_func
(paren
op_star
id|in2000_dataptr
op_increment
comma
id|INFIFO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in2000_datalen
OG
l_int|0
)paren
(brace
id|in2000_datalen
op_sub_assign
l_int|2
suffix:semicolon
)brace
)brace
)brace
id|ficmsk
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/*&n;     * Start it up&n;     */
id|outb
c_func
(paren
id|CONTROL
comma
id|INSTAT
)paren
suffix:semicolon
multiline_comment|/* WD BUS Mode */
id|outb
c_func
(paren
l_int|0x4C
comma
id|INDATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in2000_datalen
)paren
multiline_comment|/* if data xfer cmd */
id|outb
c_func
(paren
l_int|0
comma
id|ININTR
)paren
suffix:semicolon
multiline_comment|/* Enable FIFO intrpt some boards? */
id|outb
c_func
(paren
id|COMMAND
comma
id|INSTAT
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|INNLED
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|8
comma
id|INDATA
)paren
suffix:semicolon
multiline_comment|/* Select w/ATN &amp; Transfer */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* let the intrpt rip */
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|internal_done_flag
r_static
r_volatile
r_int
id|internal_done_flag
op_assign
l_int|0
suffix:semicolon
DECL|variable|internal_done_errcode
r_static
r_volatile
r_int
id|internal_done_errcode
op_assign
l_int|0
suffix:semicolon
DECL|function|internal_done
r_static
r_void
id|internal_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|internal_done_errcode
op_assign
id|SCpnt-&gt;result
suffix:semicolon
op_increment
id|internal_done_flag
suffix:semicolon
)brace
DECL|function|in2000_command
r_int
id|in2000_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|in2000_queuecommand
c_func
(paren
id|SCpnt
comma
id|internal_done
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|internal_done_flag
)paren
suffix:semicolon
id|internal_done_flag
op_assign
l_int|0
suffix:semicolon
r_return
id|internal_done_errcode
suffix:semicolon
)brace
DECL|function|in2000_detect
r_int
id|in2000_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
multiline_comment|/* Order chosen to reduce conflicts with some multi-port serial boards */
r_int
id|base_tab
(braket
)braket
op_assign
(brace
l_int|0x220
comma
l_int|0x200
comma
l_int|0x110
comma
l_int|0x100
)brace
suffix:semicolon
r_int
id|int_tab
(braket
)braket
op_assign
(brace
l_int|15
comma
l_int|14
comma
l_int|11
comma
l_int|10
)brace
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_int
id|loop
comma
id|tmp
suffix:semicolon
id|DEB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;in2000_detect: &bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
l_int|4
suffix:semicolon
id|loop
op_increment
)paren
(brace
id|base
op_assign
id|base_tab
(braket
id|loop
)braket
suffix:semicolon
r_if
c_cond
(paren
id|in2000_test_port
c_func
(paren
id|loop
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|loop
op_eq
l_int|4
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Read the dip switch values again for miscellaneous checking and&n;     informative messages */
id|tmp
op_assign
id|inb
c_func
(paren
id|INFLED
)paren
suffix:semicolon
multiline_comment|/* Bit 2 tells us if interrupts are disabled */
r_if
c_cond
(paren
(paren
id|tmp
op_amp
l_int|0x4
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;The IN-2000 is not configured for interrupt operation&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Change the DIP switch settings to enable interrupt operation&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Bit 6 tells us about floppy controller */
id|printk
c_func
(paren
l_string|&quot;IN-2000 probe found floppy controller on IN-2000 &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
l_int|0x40
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;enabled&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;disabled&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Bit 5 tells us about synch/asynch mode */
id|printk
c_func
(paren
l_string|&quot;IN-2000 probe found IN-2000 in &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
l_int|0x20
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;synchronous mode&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;asynchronous mode&bslash;n&quot;
)paren
suffix:semicolon
id|irq_level
op_assign
id|int_tab
(braket
(paren
(paren
op_complement
id|inb
c_func
(paren
id|INFLED
)paren
op_rshift
l_int|3
)paren
op_amp
l_int|0x3
)paren
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Configuring IN2000 at IO:%x, IRQ %d&quot;
macro_line|#ifdef FAST_FIFO_IO
l_string|&quot; (using fast FIFO I/O code)&quot;
macro_line|#endif
l_string|&quot;&bslash;n&quot;
comma
id|base
comma
id|irq_level
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|2
comma
id|ININTR
)paren
suffix:semicolon
multiline_comment|/* Shut off the FIFO first, so it won&squot;t ask for data.*/
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|irq_level
comma
id|in2000_intr_handle
comma
l_int|0
comma
l_string|&quot;in2000&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;in2000_detect: Unable to allocate IRQ.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0
comma
id|INFWRT
)paren
suffix:semicolon
multiline_comment|/* read mode so WD can intrpt */
id|outb
c_func
(paren
id|SCSIST
comma
id|INSTAT
)paren
suffix:semicolon
id|inb
c_func
(paren
id|INDATA
)paren
suffix:semicolon
multiline_comment|/* free status reg, clear WD intrpt */
id|outb
c_func
(paren
id|OWNID
comma
id|INSTAT
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x7
comma
id|INDATA
)paren
suffix:semicolon
multiline_comment|/* we use addr 7 */
id|outb
c_func
(paren
id|COMMAND
comma
id|INSTAT
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|INDATA
)paren
suffix:semicolon
multiline_comment|/* do chip reset */
id|shpnt
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Set these up so that we can unload the driver properly. */
id|shpnt-&gt;io_port
op_assign
id|base
suffix:semicolon
id|shpnt-&gt;n_io_port
op_assign
l_int|12
suffix:semicolon
id|shpnt-&gt;irq
op_assign
id|irq_level
suffix:semicolon
id|request_region
c_func
(paren
id|base
comma
l_int|12
comma
l_string|&quot;in2000&quot;
)paren
suffix:semicolon
multiline_comment|/* Prevent other drivers from using this space */
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|in2000_abort
r_int
id|in2000_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|DEB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;in2000_abort&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * Ask no stupid questions, just order the abort.&n;     */
id|outb
c_func
(paren
id|COMMAND
comma
id|INSTAT
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|INDATA
)paren
suffix:semicolon
multiline_comment|/* Abort Command */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|delay
r_static
r_inline
r_void
id|delay
c_func
(paren
r_int
id|how_long
)paren
(brace
r_int
r_int
id|time
op_assign
id|jiffies
op_plus
id|how_long
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|time
)paren
suffix:semicolon
)brace
DECL|function|in2000_reset
r_int
id|in2000_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|DEB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;in2000_reset called&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * Note: this is finished off by an incoming interrupt&n;     */
id|outb
c_func
(paren
l_int|0
comma
id|INFWRT
)paren
suffix:semicolon
multiline_comment|/* read mode so WD can intrpt */
id|outb
c_func
(paren
id|SCSIST
comma
id|INSTAT
)paren
suffix:semicolon
id|inb
c_func
(paren
id|INDATA
)paren
suffix:semicolon
id|outb
c_func
(paren
id|OWNID
comma
id|INSTAT
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x7
comma
id|INDATA
)paren
suffix:semicolon
multiline_comment|/* ID=7,noadv, no parity, clk div=2 (8-10Mhz clk) */
id|outb
c_func
(paren
id|COMMAND
comma
id|INSTAT
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|INDATA
)paren
suffix:semicolon
multiline_comment|/* reset WD chip */
id|delay
c_func
(paren
l_int|2
)paren
suffix:semicolon
macro_line|#ifdef SCSI_RESET_PENDING
r_return
id|SCSI_RESET_PENDING
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|SCpnt
)paren
(brace
id|SCpnt-&gt;flags
op_or_assign
id|NEEDS_JUMPSTART
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
DECL|function|in2000_biosparam
r_int
id|in2000_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
r_int
id|dev
comma
r_int
op_star
id|iinfo
)paren
(brace
r_int
id|size
op_assign
id|disk-&gt;capacity
suffix:semicolon
id|DEB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;in2000_biosparam&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|iinfo
(braket
l_int|0
)braket
op_assign
l_int|64
suffix:semicolon
id|iinfo
(braket
l_int|1
)braket
op_assign
l_int|32
suffix:semicolon
id|iinfo
(braket
l_int|2
)braket
op_assign
id|size
op_rshift
l_int|11
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
