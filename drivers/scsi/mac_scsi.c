multiline_comment|/*&n; * Generic Macintosh NCR5380 driver&n; *&n; * Copyright 1998, Michael Schmitz &lt;mschmitz@lbl.gov&gt;&n; *&n; * derived in part from:&n; */
multiline_comment|/*&n; * Generic Generic NCR5380 driver&n; *&n; * Copyright 1995, Russell King&n; *&n; * ALPHA RELEASE 1.&n; *&n; * For more information, please consult&n; *&n; * NCR 5380 Family&n; * SCSI Protocol Controller&n; * Databook&n; *&n; * NCR Microelectronics&n; * 1635 Aeroplaza Drive&n; * Colorado Springs, CO 80916&n; * 1+ (719) 578-3400&n; * 1+ (800) 334-5454&n; */
multiline_comment|/*&n; * Options :&n; *&n; * PARITY - enable parity checking.  Not supported.&n; *&n; * SCSI2 - enable support for SCSI-II tagged queueing.  Untested.&n; *&n; * USLEEP - enable support for devices that don&squot;t disconnect.  Untested.&n; */
multiline_comment|/*&n; * $Log: mac_NCR5380.c,v $&n; */
DECL|macro|AUTOSENSE
mdefine_line|#define AUTOSENSE
macro_line|#if 0
mdefine_line|#define PSEUDO_DMA
macro_line|#endif
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/macintosh.h&gt;
macro_line|#include &lt;asm/macints.h&gt;
macro_line|#include &lt;asm/machw.h&gt;
macro_line|#include &lt;asm/mac_via.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;mac_scsi.h&quot;
macro_line|#include &quot;NCR5380.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#if 0
mdefine_line|#define NDEBUG (NDEBUG_INTR | NDEBUG_PSEUDO_DMA | NDEBUG_ARBITRATION | NDEBUG_SELECTION | NDEBUG_RESELECTION)
macro_line|#else
DECL|macro|NDEBUG
mdefine_line|#define NDEBUG (NDEBUG_ABORT)
macro_line|#endif
DECL|macro|RESET_BOOT
mdefine_line|#define RESET_BOOT
DECL|macro|DRIVER_SETUP
mdefine_line|#define DRIVER_SETUP
multiline_comment|/*&n; * BUG can be used to trigger a strange code-size related hang on 2.1 kernels&n; */
macro_line|#ifdef BUG
DECL|macro|RESET_BOOT
macro_line|#undef RESET_BOOT
DECL|macro|DRIVER_SETUP
macro_line|#undef DRIVER_SETUP
macro_line|#endif
DECL|macro|ENABLE_IRQ
mdefine_line|#define&t;ENABLE_IRQ()&t;mac_enable_irq( IRQ_MAC_SCSI ); 
DECL|macro|DISABLE_IRQ
mdefine_line|#define&t;DISABLE_IRQ()&t;mac_disable_irq( IRQ_MAC_SCSI );
macro_line|#ifdef RESET_BOOT
r_static
r_void
id|mac_scsi_reset_boot
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
suffix:semicolon
macro_line|#endif
r_static
r_char
id|macscsi_read
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
id|reg
)paren
suffix:semicolon
r_static
r_void
id|macscsi_write
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
id|reg
comma
r_int
id|value
)paren
suffix:semicolon
DECL|variable|setup_can_queue
r_static
r_int
id|setup_can_queue
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|setup_cmd_per_lun
r_static
r_int
id|setup_cmd_per_lun
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|setup_sg_tablesize
r_static
r_int
id|setup_sg_tablesize
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef SUPPORT_TAGS
DECL|variable|setup_use_tagged_queuing
r_static
r_int
id|setup_use_tagged_queuing
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
DECL|variable|setup_hostid
r_static
r_int
id|setup_hostid
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|polled_scsi_on
r_static
r_int
id|polled_scsi_on
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Time (in jiffies) to wait after a reset; the SCSI standard calls for 250ms,&n; * we usually do 0.5s to be on the safe side. But Toshiba CD-ROMs once more&n; * need ten times the standard value... */
DECL|macro|TOSHIBA_DELAY
mdefine_line|#define TOSHIBA_DELAY
macro_line|#ifdef TOSHIBA_DELAY
DECL|macro|AFTER_RESET_DELAY
mdefine_line|#define&t;AFTER_RESET_DELAY&t;(5*HZ/2)
macro_line|#else
DECL|macro|AFTER_RESET_DELAY
mdefine_line|#define&t;AFTER_RESET_DELAY&t;(HZ/2)
macro_line|#endif
DECL|variable|mac_scsi_regp
r_static
r_volatile
r_int
r_char
op_star
id|mac_scsi_regp
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|mac_scsi_drq
r_static
r_volatile
r_int
r_char
op_star
id|mac_scsi_drq
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|mac_scsi_nodrq
r_static
r_volatile
r_int
r_char
op_star
id|mac_scsi_nodrq
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * Function : mac_scsi_setup(char *str, int *ints)&n; *&n; * Purpose : booter command line initialization of the overrides array,&n; *&n; * Inputs : str - unused, ints - array of integer parameters with ints[0]&n; *&t;equal to the number of ints.&n; *&n; */
DECL|function|mac_scsi_setup
r_static
r_int
id|__init
id|mac_scsi_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
macro_line|#ifdef DRIVER_SETUP
multiline_comment|/* Format of mac5380 parameter is:&n;&t; *   mac5380=&lt;can_queue&gt;,&lt;cmd_per_lun&gt;,&lt;sg_tablesize&gt;,&lt;hostid&gt;,&lt;use_tags&gt;&n;&t; * Negative values mean don&squot;t change.&n;&t; */
multiline_comment|/* Grmbl... the standard parameter parsing can&squot;t handle negative numbers&n;&t; * :-( So let&squot;s do it ourselves!&n;&t; */
r_int
id|i
op_assign
id|ints
(braket
l_int|0
)braket
op_plus
l_int|1
comma
id|fact
suffix:semicolon
r_while
c_loop
(paren
id|str
op_logical_and
(paren
id|isdigit
c_func
(paren
op_star
id|str
)paren
op_logical_or
op_star
id|str
op_eq
l_char|&squot;-&squot;
)paren
op_logical_and
id|i
op_le
l_int|10
)paren
(brace
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;-&squot;
)paren
id|fact
op_assign
op_minus
l_int|1
comma
op_increment
id|str
suffix:semicolon
r_else
id|fact
op_assign
l_int|1
suffix:semicolon
id|ints
(braket
id|i
op_increment
)braket
op_assign
id|simple_strtoul
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
op_star
id|fact
suffix:semicolon
r_if
c_cond
(paren
(paren
id|str
op_assign
id|strchr
c_func
(paren
id|str
comma
l_char|&squot;,&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
op_increment
id|str
suffix:semicolon
)brace
id|ints
(braket
l_int|0
)braket
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OL
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mac_scsi_setup: no arguments!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|1
)braket
OG
l_int|0
)paren
multiline_comment|/* no limits on this, just &gt; 0 */
id|setup_can_queue
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|2
)braket
OG
l_int|0
)paren
id|setup_cmd_per_lun
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|3
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|3
)braket
op_ge
l_int|0
)paren
(brace
id|setup_sg_tablesize
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Must be &lt;= SG_ALL (255) */
r_if
c_cond
(paren
id|setup_sg_tablesize
OG
id|SG_ALL
)paren
id|setup_sg_tablesize
op_assign
id|SG_ALL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|4
)paren
(brace
multiline_comment|/* Must be between 0 and 7 */
r_if
c_cond
(paren
id|ints
(braket
l_int|4
)braket
op_ge
l_int|0
op_logical_and
id|ints
(braket
l_int|4
)braket
op_le
l_int|7
)paren
id|setup_hostid
op_assign
id|ints
(braket
l_int|4
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ints
(braket
l_int|4
)braket
OG
l_int|7
)paren
id|printk
c_func
(paren
l_string|&quot;mac_scsi_setup: invalid host ID %d !&bslash;n&quot;
comma
id|ints
(braket
l_int|4
)braket
)paren
suffix:semicolon
)brace
macro_line|#ifdef SUPPORT_TAGS
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|5
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|5
)braket
op_ge
l_int|0
)paren
id|setup_use_tagged_queuing
op_assign
op_logical_neg
op_logical_neg
id|ints
(braket
l_int|5
)braket
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;mac5380=&quot;
comma
id|mac_scsi_setup
)paren
suffix:semicolon
macro_line|#if 0
mdefine_line|#define MAC_ADDRESS(card) (ecard_address((card), ECARD_IOC, ECARD_SLOW) + 0x800)
mdefine_line|#define MAC_IRQ(card)     ((card)-&gt;irq)
macro_line|#endif
multiline_comment|/*&n; * XXX: status debug&n; */
DECL|variable|default_instance
r_static
r_struct
id|Scsi_Host
op_star
id|default_instance
suffix:semicolon
multiline_comment|/*&n; * Function : int macscsi_detect(Scsi_Host_Template * tpnt)&n; *&n; * Purpose : initializes mac NCR5380 driver based on the&n; *&t;command line / compile time port and irq definitions.&n; *&n; * Inputs : tpnt - template for this SCSI adapter.&n; *&n; * Returns : 1 if a host adapter was found, 0 if not.&n; *&n; */
DECL|function|macscsi_detect
r_int
id|macscsi_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|called
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MACH_IS_MAC
op_logical_or
id|called
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|macintosh_config-&gt;scsi_type
op_ne
id|MAC_SCSI_OLD
)paren
r_return
l_int|0
suffix:semicolon
id|tpnt-&gt;proc_name
op_assign
l_string|&quot;mac5380&quot;
suffix:semicolon
multiline_comment|/* setup variables */
id|tpnt-&gt;can_queue
op_assign
(paren
id|setup_can_queue
OG
l_int|0
)paren
ques
c_cond
id|setup_can_queue
suffix:colon
id|CAN_QUEUE
suffix:semicolon
id|tpnt-&gt;cmd_per_lun
op_assign
(paren
id|setup_cmd_per_lun
OG
l_int|0
)paren
ques
c_cond
id|setup_cmd_per_lun
suffix:colon
id|CMD_PER_LUN
suffix:semicolon
id|tpnt-&gt;sg_tablesize
op_assign
(paren
id|setup_sg_tablesize
op_ge
l_int|0
)paren
ques
c_cond
id|setup_sg_tablesize
suffix:colon
id|SG_TABLESIZE
suffix:semicolon
r_if
c_cond
(paren
id|setup_hostid
op_ge
l_int|0
)paren
id|tpnt-&gt;this_id
op_assign
id|setup_hostid
suffix:semicolon
r_else
(brace
multiline_comment|/* use 7 as default */
id|tpnt-&gt;this_id
op_assign
l_int|7
suffix:semicolon
)brace
macro_line|#ifdef SUPPORT_TAGS
r_if
c_cond
(paren
id|setup_use_tagged_queuing
OL
l_int|0
)paren
id|setup_use_tagged_queuing
op_assign
id|DEFAULT_USE_TAGGED_QUEUING
suffix:semicolon
macro_line|#endif
macro_line|#if 0&t;/* loop over multiple adapters (Powerbooks ??) */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|mac_num_scsi
suffix:semicolon
id|count
op_increment
)paren
(brace
macro_line|#endif
id|instance
op_assign
id|scsi_register
(paren
id|tpnt
comma
r_sizeof
(paren
r_struct
id|NCR5380_hostdata
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|instance
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
id|default_instance
op_assign
id|instance
suffix:semicolon
r_if
c_cond
(paren
id|macintosh_config-&gt;ident
op_eq
id|MAC_MODEL_IIFX
)paren
(brace
id|mac_scsi_regp
op_assign
id|via1
op_plus
l_int|0x8000
suffix:semicolon
id|mac_scsi_drq
op_assign
id|via1
op_plus
l_int|0xE000
suffix:semicolon
id|mac_scsi_nodrq
op_assign
id|via1
op_plus
l_int|0xC000
suffix:semicolon
)brace
r_else
(brace
id|mac_scsi_regp
op_assign
id|via1
op_plus
l_int|0x10000
suffix:semicolon
id|mac_scsi_drq
op_assign
id|via1
op_plus
l_int|0x6000
suffix:semicolon
id|mac_scsi_nodrq
op_assign
id|via1
op_plus
l_int|0x12000
suffix:semicolon
)brace
id|instance-&gt;io_port
op_assign
(paren
r_int
r_int
)paren
id|mac_scsi_regp
suffix:semicolon
id|instance-&gt;irq
op_assign
id|IRQ_MAC_SCSI
suffix:semicolon
macro_line|#ifdef RESET_BOOT
id|mac_scsi_reset_boot
c_func
(paren
id|instance
)paren
suffix:semicolon
macro_line|#endif
id|NCR5380_init
c_func
(paren
id|instance
comma
l_int|0
)paren
suffix:semicolon
id|instance-&gt;n_io_port
op_assign
l_int|255
suffix:semicolon
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
)paren
op_member_access_from_pointer
id|ctrl
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|instance-&gt;irq
op_ne
id|IRQ_NONE
)paren
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|instance-&gt;irq
comma
id|NCR5380_intr
comma
id|IRQ_FLG_SLOW
comma
l_string|&quot;ncr5380&quot;
comma
id|NCR5380_intr
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: IRQ%d not free, interrupts disabled&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|instance-&gt;irq
)paren
suffix:semicolon
id|instance-&gt;irq
op_assign
id|IRQ_NONE
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: generic 5380 at port %lX irq&quot;
comma
id|instance-&gt;host_no
comma
id|instance-&gt;io_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|instance-&gt;irq
op_eq
id|IRQ_NONE
)paren
id|printk
(paren
l_string|&quot;s disabled&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot; %d&quot;
comma
id|instance-&gt;irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; options CAN_QUEUE=%d CMD_PER_LUN=%d release=%d&quot;
comma
id|instance-&gt;can_queue
comma
id|instance-&gt;cmd_per_lun
comma
id|MACSCSI_PUBLIC_RELEASE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nscsi%d:&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|NCR5380_print_options
c_func
(paren
id|instance
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 0&t;/* multiple adapters */
)brace
macro_line|#endif
id|called
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|macscsi_release
r_int
id|macscsi_release
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;irq
op_ne
id|IRQ_NONE
)paren
id|free_irq
(paren
id|shpnt-&gt;irq
comma
id|NCR5380_intr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef RESET_BOOT
multiline_comment|/*&n; * Our &squot;bus reset on boot&squot; function&n; */
DECL|function|mac_scsi_reset_boot
r_static
r_void
id|mac_scsi_reset_boot
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
r_int
r_int
id|end
suffix:semicolon
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do a SCSI reset to clean up the bus during initialization. No messing&n;&t; * with the queues, interrupts, or locks necessary here.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;Macintosh SCSI: resetting the SCSI bus...&quot;
)paren
suffix:semicolon
multiline_comment|/* switch off SCSI IRQ - catch an interrupt without IRQ bit set else */
id|mac_disable_irq
c_func
(paren
id|IRQ_MAC_SCSI
)paren
suffix:semicolon
multiline_comment|/* get in phase */
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* assert RST */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_RST
)paren
suffix:semicolon
multiline_comment|/* The min. reset hold time is 25us, so 40us should be enough */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/* reset RST and interrupt */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
r_for
c_loop
(paren
id|end
op_assign
id|jiffies
op_plus
id|AFTER_RESET_DELAY
suffix:semicolon
id|jiffies
OL
id|end
suffix:semicolon
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* switch on SCSI IRQ again */
id|mac_enable_irq
c_func
(paren
id|IRQ_MAC_SCSI
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; done&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|macscsi_info
r_const
r_char
op_star
id|macscsi_info
(paren
r_struct
id|Scsi_Host
op_star
id|spnt
)paren
(brace
r_return
l_string|&quot;&quot;
suffix:semicolon
)brace
DECL|function|restore_irq
r_void
id|restore_irq
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|flags
op_assign
(paren
id|flags
op_amp
op_complement
l_int|0x0700
)paren
op_or
(paren
id|regs-&gt;sr
op_amp
l_int|0x0700
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pseudo-DMA transfer functions, copied and modified from Russel King&squot;s&n; * ARM 5380 driver (cumana_1)&n; *&n; * Work in progress (sort of), didn&squot;t work last time I checked, don&squot;t use!&n; */
macro_line|#ifdef NOT_EFFICIENT
DECL|macro|CTRL
mdefine_line|#define CTRL(p,v)     outb(*ctrl = (v), (p) - 577)
DECL|macro|STAT
mdefine_line|#define STAT(p)       inb((p)+1)
DECL|macro|IN
mdefine_line|#define IN(p)         inb((p))
DECL|macro|OUT
mdefine_line|#define OUT(v,p)      outb((v), (p))
macro_line|#else
macro_line|#if 0
mdefine_line|#define CTRL(p,v)&t;(p[-2308] = (*ctrl = (v)))
macro_line|#else
DECL|macro|CTRL
mdefine_line|#define CTRL(p,v)&t;(*ctrl = (v))
macro_line|#endif
DECL|macro|STAT
mdefine_line|#define STAT(p)&t;&t;(p[1&lt;&lt;4])
DECL|macro|IN
mdefine_line|#define IN(p)&t;&t;(*(p))
DECL|macro|IN2
mdefine_line|#define IN2(p)&t;&t;((unsigned short)(*(volatile unsigned long *)(p)))
DECL|macro|OUT
mdefine_line|#define OUT(v,p)&t;(*(p) = (v))
DECL|macro|OUT2
mdefine_line|#define OUT2(v,p)&t;(*((volatile unsigned long *)(p)) = (v))
macro_line|#endif
DECL|macro|L
mdefine_line|#define L(v)&t;&t;(((v)&lt;&lt;16)|((v) &amp; 0x0000ffff))
DECL|macro|H
mdefine_line|#define H(v)&t;&t;(((v)&gt;&gt;16)|((v) &amp; 0xffff0000))
DECL|macro|ioaddr
mdefine_line|#define ioaddr(v)&t;(v)
DECL|function|NCR5380_pwrite
r_static
r_inline
r_int
id|NCR5380_pwrite
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
r_char
op_star
id|addr
comma
r_int
id|len
)paren
(brace
r_int
op_star
id|ctrl
op_assign
op_amp
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
)paren
op_member_access_from_pointer
id|ctrl
suffix:semicolon
r_int
id|oldctrl
op_assign
op_star
id|ctrl
suffix:semicolon
r_int
r_int
op_star
id|laddr
suffix:semicolon
macro_line|#ifdef NOT_EFFICIENT
r_int
id|iobase
op_assign
id|instance-&gt;io_port
suffix:semicolon
r_int
id|dma_io
op_assign
id|mac_scsi_nodrq
suffix:semicolon
macro_line|#else
r_volatile
r_int
r_char
op_star
id|iobase
op_assign
(paren
r_int
r_char
op_star
)paren
id|ioaddr
c_func
(paren
id|instance-&gt;io_port
)paren
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|dma_io
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|mac_scsi_nodrq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|CTRL
c_func
(paren
id|iobase
comma
l_int|0x02
)paren
suffix:semicolon
id|laddr
op_assign
(paren
r_int
r_int
op_star
)paren
id|addr
suffix:semicolon
r_while
c_loop
(paren
id|len
op_ge
l_int|32
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
r_int
id|v
suffix:semicolon
id|status
op_assign
id|STAT
c_func
(paren
id|iobase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x80
)paren
(brace
r_goto
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
l_int|0x40
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|v
op_assign
op_star
id|laddr
op_increment
suffix:semicolon
id|OUT2
c_func
(paren
id|L
c_func
(paren
id|v
)paren
comma
id|dma_io
)paren
suffix:semicolon
id|OUT2
c_func
(paren
id|H
c_func
(paren
id|v
)paren
comma
id|dma_io
)paren
suffix:semicolon
id|v
op_assign
op_star
id|laddr
op_increment
suffix:semicolon
id|OUT2
c_func
(paren
id|L
c_func
(paren
id|v
)paren
comma
id|dma_io
)paren
suffix:semicolon
id|OUT2
c_func
(paren
id|H
c_func
(paren
id|v
)paren
comma
id|dma_io
)paren
suffix:semicolon
id|v
op_assign
op_star
id|laddr
op_increment
suffix:semicolon
id|OUT2
c_func
(paren
id|L
c_func
(paren
id|v
)paren
comma
id|dma_io
)paren
suffix:semicolon
id|OUT2
c_func
(paren
id|H
c_func
(paren
id|v
)paren
comma
id|dma_io
)paren
suffix:semicolon
id|v
op_assign
op_star
id|laddr
op_increment
suffix:semicolon
id|OUT2
c_func
(paren
id|L
c_func
(paren
id|v
)paren
comma
id|dma_io
)paren
suffix:semicolon
id|OUT2
c_func
(paren
id|H
c_func
(paren
id|v
)paren
comma
id|dma_io
)paren
suffix:semicolon
id|v
op_assign
op_star
id|laddr
op_increment
suffix:semicolon
id|OUT2
c_func
(paren
id|L
c_func
(paren
id|v
)paren
comma
id|dma_io
)paren
suffix:semicolon
id|OUT2
c_func
(paren
id|H
c_func
(paren
id|v
)paren
comma
id|dma_io
)paren
suffix:semicolon
id|v
op_assign
op_star
id|laddr
op_increment
suffix:semicolon
id|OUT2
c_func
(paren
id|L
c_func
(paren
id|v
)paren
comma
id|dma_io
)paren
suffix:semicolon
id|OUT2
c_func
(paren
id|H
c_func
(paren
id|v
)paren
comma
id|dma_io
)paren
suffix:semicolon
id|v
op_assign
op_star
id|laddr
op_increment
suffix:semicolon
id|OUT2
c_func
(paren
id|L
c_func
(paren
id|v
)paren
comma
id|dma_io
)paren
suffix:semicolon
id|OUT2
c_func
(paren
id|H
c_func
(paren
id|v
)paren
comma
id|dma_io
)paren
suffix:semicolon
id|v
op_assign
op_star
id|laddr
op_increment
suffix:semicolon
id|OUT2
c_func
(paren
id|L
c_func
(paren
id|v
)paren
comma
id|dma_io
)paren
suffix:semicolon
id|OUT2
c_func
(paren
id|H
c_func
(paren
id|v
)paren
comma
id|dma_io
)paren
suffix:semicolon
id|len
op_sub_assign
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|addr
op_assign
(paren
r_int
r_char
op_star
)paren
id|laddr
suffix:semicolon
id|CTRL
c_func
(paren
id|iobase
comma
l_int|0x12
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_int
id|status
suffix:semicolon
id|status
op_assign
id|STAT
c_func
(paren
id|iobase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x80
)paren
(brace
r_goto
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
l_int|0x40
)paren
(brace
id|OUT
c_func
(paren
op_star
id|addr
op_increment
comma
id|dma_io
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|len
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|status
op_assign
id|STAT
c_func
(paren
id|iobase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x80
)paren
(brace
r_goto
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
l_int|0x40
)paren
(brace
id|OUT
c_func
(paren
op_star
id|addr
op_increment
comma
id|dma_io
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|len
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
id|end
suffix:colon
id|CTRL
c_func
(paren
id|iobase
comma
id|oldctrl
op_or
l_int|0x40
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|NCR5380_pread
r_static
r_inline
r_int
id|NCR5380_pread
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
r_char
op_star
id|addr
comma
r_int
id|len
)paren
(brace
r_int
op_star
id|ctrl
op_assign
op_amp
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
)paren
op_member_access_from_pointer
id|ctrl
suffix:semicolon
r_int
id|oldctrl
op_assign
op_star
id|ctrl
suffix:semicolon
r_int
r_int
op_star
id|laddr
suffix:semicolon
macro_line|#ifdef NOT_EFFICIENT
r_int
id|iobase
op_assign
id|instance-&gt;io_port
suffix:semicolon
r_int
id|dma_io
op_assign
id|mac_scsi_nodrq
suffix:semicolon
macro_line|#else
r_volatile
r_int
r_char
op_star
id|iobase
op_assign
(paren
r_int
r_char
op_star
)paren
id|ioaddr
c_func
(paren
id|instance-&gt;io_port
)paren
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|dma_io
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
(paren
r_int
)paren
id|mac_scsi_nodrq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|CTRL
c_func
(paren
id|iobase
comma
l_int|0x00
)paren
suffix:semicolon
id|laddr
op_assign
(paren
r_int
r_int
op_star
)paren
id|addr
suffix:semicolon
r_while
c_loop
(paren
id|len
op_ge
l_int|32
)paren
(brace
r_int
id|status
suffix:semicolon
id|status
op_assign
id|STAT
c_func
(paren
id|iobase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x80
)paren
(brace
r_goto
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
l_int|0x40
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
op_star
id|laddr
op_increment
op_assign
id|IN2
c_func
(paren
id|dma_io
)paren
op_or
(paren
id|IN2
c_func
(paren
id|dma_io
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
op_star
id|laddr
op_increment
op_assign
id|IN2
c_func
(paren
id|dma_io
)paren
op_or
(paren
id|IN2
c_func
(paren
id|dma_io
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
op_star
id|laddr
op_increment
op_assign
id|IN2
c_func
(paren
id|dma_io
)paren
op_or
(paren
id|IN2
c_func
(paren
id|dma_io
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
op_star
id|laddr
op_increment
op_assign
id|IN2
c_func
(paren
id|dma_io
)paren
op_or
(paren
id|IN2
c_func
(paren
id|dma_io
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
op_star
id|laddr
op_increment
op_assign
id|IN2
c_func
(paren
id|dma_io
)paren
op_or
(paren
id|IN2
c_func
(paren
id|dma_io
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
op_star
id|laddr
op_increment
op_assign
id|IN2
c_func
(paren
id|dma_io
)paren
op_or
(paren
id|IN2
c_func
(paren
id|dma_io
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
op_star
id|laddr
op_increment
op_assign
id|IN2
c_func
(paren
id|dma_io
)paren
op_or
(paren
id|IN2
c_func
(paren
id|dma_io
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
op_star
id|laddr
op_increment
op_assign
id|IN2
c_func
(paren
id|dma_io
)paren
op_or
(paren
id|IN2
c_func
(paren
id|dma_io
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|len
op_sub_assign
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|addr
op_assign
(paren
r_int
r_char
op_star
)paren
id|laddr
suffix:semicolon
id|CTRL
c_func
(paren
id|iobase
comma
l_int|0x10
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_int
id|status
suffix:semicolon
id|status
op_assign
id|STAT
c_func
(paren
id|iobase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x80
)paren
(brace
r_goto
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
l_int|0x40
)paren
(brace
op_star
id|addr
op_increment
op_assign
id|IN
c_func
(paren
id|dma_io
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|len
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|status
op_assign
id|STAT
c_func
(paren
id|iobase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x80
)paren
(brace
r_goto
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
l_int|0x40
)paren
(brace
op_star
id|addr
op_increment
op_assign
id|IN
c_func
(paren
id|dma_io
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|len
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
id|end
suffix:colon
id|CTRL
c_func
(paren
id|iobase
comma
id|oldctrl
op_or
l_int|0x40
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|macro|STAT
macro_line|#undef STAT
DECL|macro|CTRL
macro_line|#undef CTRL
DECL|macro|IN
macro_line|#undef IN
DECL|macro|OUT
macro_line|#undef OUT
multiline_comment|/*&n; * NCR 5380 register access functions&n; */
macro_line|#ifdef ORIG
macro_line|#if 0
mdefine_line|#define CTRL(p,v) outb(*ctrl = (v), (p) - 577)
macro_line|#else
DECL|macro|CTRL
mdefine_line|#define CTRL(p,v) (*ctrl = (v))
macro_line|#endif
DECL|function|macscsi_read
r_static
r_char
id|macscsi_read
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
id|reg
)paren
(brace
r_int
id|iobase
op_assign
id|instance-&gt;io_port
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
op_star
id|ctrl
op_assign
op_amp
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
)paren
op_member_access_from_pointer
id|ctrl
suffix:semicolon
id|CTRL
c_func
(paren
id|iobase
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if 0
id|i
op_assign
id|inb
c_func
(paren
id|iobase
op_plus
l_int|64
op_plus
id|reg
)paren
suffix:semicolon
macro_line|#else
id|i
op_assign
id|inb
c_func
(paren
id|iobase
op_plus
id|reg
op_lshift
l_int|4
)paren
suffix:semicolon
macro_line|#endif
id|CTRL
c_func
(paren
id|iobase
comma
l_int|0x40
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|macscsi_write
r_static
r_void
id|macscsi_write
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
id|reg
comma
r_int
id|value
)paren
(brace
r_int
id|iobase
op_assign
id|instance-&gt;io_port
suffix:semicolon
r_int
op_star
id|ctrl
op_assign
op_amp
(paren
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
)paren
op_member_access_from_pointer
id|ctrl
suffix:semicolon
id|CTRL
c_func
(paren
id|iobase
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if 0
id|outb
c_func
(paren
id|value
comma
id|iobase
op_plus
l_int|64
op_plus
id|reg
)paren
suffix:semicolon
macro_line|#else
id|outb
c_func
(paren
id|value
comma
id|iobase
op_plus
id|reg
op_lshift
l_int|4
)paren
suffix:semicolon
macro_line|#endif
id|CTRL
c_func
(paren
id|iobase
comma
l_int|0x40
)paren
suffix:semicolon
)brace
DECL|macro|CTRL
macro_line|#undef CTRL
macro_line|#else
DECL|function|macscsi_read
r_static
r_char
id|macscsi_read
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
id|reg
)paren
(brace
r_return
id|mac_scsi_regp
(braket
id|reg
op_lshift
l_int|4
)braket
suffix:semicolon
)brace
DECL|function|macscsi_write
r_static
r_void
id|macscsi_write
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
id|reg
comma
r_int
id|value
)paren
(brace
id|mac_scsi_regp
(braket
id|reg
op_lshift
l_int|4
)braket
op_assign
id|value
suffix:semicolon
)brace
macro_line|#endif
macro_line|#include &quot;NCR5380.c&quot;
multiline_comment|/*&n; * Debug stuff - to be called on NMI, or sysrq key. Use at your own risk; &n; * reentering NCR5380_print_status seems to have ugly side effects&n; */
DECL|function|scsi_mac_debug
r_void
id|scsi_mac_debug
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|default_instance
)paren
(brace
macro_line|#if 0
id|NCR5380_setup
c_func
(paren
id|default_instance
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_IRQ
)paren
(brace
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_print_status
c_func
(paren
id|default_instance
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#if 0
id|polled_scsi_on
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Helper function for interrupt trouble. More ugly side effects here.&n; */
DECL|function|scsi_mac_polled
r_void
id|scsi_mac_polled
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|NCR5380_local_declare
c_func
(paren
)paren
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
macro_line|#if 0
r_for
c_loop
(paren
id|instance
op_assign
id|first_instance
suffix:semicolon
id|instance
op_logical_and
(paren
id|instance-&gt;hostt
op_eq
id|the_template
)paren
suffix:semicolon
id|instance
op_assign
id|instance-&gt;next
)paren
r_if
c_cond
(paren
id|instance-&gt;irq
op_eq
id|IRQ_MAC_SCSI
op_logical_and
id|polled_scsi_on
)paren
(brace
macro_line|#else
id|instance
op_assign
id|default_instance
suffix:semicolon
macro_line|#endif
id|NCR5380_setup
c_func
(paren
id|instance
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_IRQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI poll&bslash;n&quot;
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_intr
c_func
(paren
id|IRQ_MAC_SCSI
comma
id|instance
comma
l_int|NULL
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#if 0
)brace
macro_line|#endif
)brace
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|MAC_NCR5380
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
eof
