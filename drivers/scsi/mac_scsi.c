multiline_comment|/*&n; * mac_scsi.c   -- Device dependent functions for the Macintosh NCR5380 SCSI &n; *&t;&t;   port (MacII style machines, no DMA).&n; *&n; * based on:&n; */
multiline_comment|/*&n; * atari_scsi.c -- Device dependent functions for the Atari generic SCSI port&n; *&n; * Copyright 1994 Roman Hodek &lt;Roman.Hodek@informatik.uni-erlangen.de&gt;&n; *&n; *   Loosely based on the work of Robert De Vries&squot; team and added:&n; *    - working real DMA&n; *    - Falcon support (untested yet!)   ++bjoern fixed and now it works&n; *    - lots of extensions and bug fixes.&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file COPYING in the main directory of this archive&n; * for more details.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
DECL|macro|NDEBUG_ABORT
mdefine_line|#define NDEBUG_ABORT&t;0x800000
DECL|macro|NDEBUG_TAGS
mdefine_line|#define NDEBUG_TAGS&t;0x1000000
DECL|macro|NDEBUG_MERGING
mdefine_line|#define NDEBUG_MERGING&t;0x2000000
DECL|macro|NDEBUG
mdefine_line|#define NDEBUG (0)
DECL|macro|AUTOSENSE
mdefine_line|#define AUTOSENSE
multiline_comment|/* MSch: Tested the pseudo-DMA code on Atari for the Mac68k port ... */
multiline_comment|/* Defining neither PSEUDO_DMA nor REAL_DMA -&gt; PIO transfer, sloooow ! */
multiline_comment|/*#define&t;REAL_DMA*/
multiline_comment|/* never supported on NCR5380 Macs */
multiline_comment|/*&n; * Usage: define PSEUDO_DMA to use hardware-handshaked PIO mode (TBI)&n; *        undef  PSEUDO_DMA to use pure PIO mode&n; */
multiline_comment|/*#define PSEUDO_DMA*/
multiline_comment|/* currently gives trouble on some Macs */
macro_line|#ifdef PSEUDO_DMA
DECL|macro|EMULATE_PSEUDO_DMA
mdefine_line|#define EMULATE_PSEUDO_DMA
DECL|macro|DMA_WORKS_RIGHT
mdefine_line|#define DMA_WORKS_RIGHT
DECL|macro|UNSAFE
mdefine_line|#define UNSAFE
macro_line|#endif
multiline_comment|/* Support tagged queuing? (on devices that are able to... :-) */
DECL|macro|SUPPORT_TAGS
mdefine_line|#define&t;SUPPORT_TAGS
DECL|macro|MAX_TAGS
mdefine_line|#define&t;MAX_TAGS 32
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/machw.h&gt;
macro_line|#include &lt;asm/macints.h&gt;
macro_line|#include &lt;asm/macintosh.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/traps.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;mac_scsi.h&quot;
macro_line|#include &quot;NCR5380.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
DECL|variable|proc_scsi_mac
r_struct
id|proc_dir_entry
id|proc_scsi_mac
op_assign
(brace
id|PROC_SCSI_MAC
comma
l_int|8
comma
l_string|&quot;mac_5380&quot;
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
l_int|2
)brace
suffix:semicolon
multiline_comment|/*&n; * Define RBV_HACK to run the SCSI driver on RBV Macs; undefine to&n; * try getting better interrupt latency&n; */
DECL|macro|RBV_HACK
mdefine_line|#define RBV_HACK
macro_line|#ifdef RBV_HACK
DECL|macro|ENABLE_IRQ
mdefine_line|#define&t;ENABLE_IRQ()&t;mac_turnon_irq( IRQ_MAC_SCSI ); 
DECL|macro|DISABLE_IRQ
mdefine_line|#define&t;DISABLE_IRQ()&t;mac_turnoff_irq( IRQ_MAC_SCSI );
macro_line|#else
DECL|macro|ENABLE_IRQ
mdefine_line|#define&t;ENABLE_IRQ()&t;mac_enable_irq( IRQ_MAC_SCSI ); 
DECL|macro|DISABLE_IRQ
mdefine_line|#define&t;DISABLE_IRQ()&t;mac_disable_irq( IRQ_MAC_SCSI );
macro_line|#endif
DECL|macro|HOSTDATA_DMALEN
mdefine_line|#define HOSTDATA_DMALEN&t;&t;(((struct NCR5380_hostdata *) &bslash;&n;&t;&t;&t;&t;(mac_scsi_host-&gt;hostdata))-&gt;dma_len)
multiline_comment|/* Time (in jiffies) to wait after a reset; the SCSI standard calls for 250ms,&n; * we usually do 0.5s to be on the safe side. But Toshiba CD-ROMs once more&n; * need ten times the standard value... */
macro_line|#ifndef CONFIG_MAC_SCSI_TOSHIBA_DELAY
DECL|macro|AFTER_RESET_DELAY
mdefine_line|#define&t;AFTER_RESET_DELAY&t;(HZ/2)
macro_line|#else
DECL|macro|AFTER_RESET_DELAY
mdefine_line|#define&t;AFTER_RESET_DELAY&t;(5*HZ/2)
macro_line|#endif
multiline_comment|/***************************** Prototypes *****************************/
macro_line|#ifdef REAL_DMA
r_static
r_int
id|scsi_dma_is_ignored_buserr
c_func
(paren
r_int
r_char
id|dma_stat
)paren
suffix:semicolon
r_static
r_void
id|mac_scsi_fetch_restbytes
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|mac_scsi_dma_residual
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
suffix:semicolon
r_static
r_int
id|mac_classify_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_int
r_int
id|mac_dma_xfer_len
c_func
(paren
r_int
r_int
id|wanted_len
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|write_flag
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef PSEUDO_DMA
r_static
r_int
id|mac_pdma_read
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
r_char
op_star
id|dst
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|mac_pdma_write
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
r_char
op_star
id|src
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
r_int
id|mac_dma_xfer_len
c_func
(paren
r_int
r_int
id|wanted_len
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|write_flag
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|scsi_mac_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dummy
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
suffix:semicolon
r_static
r_void
id|mac_scsi_reset_boot
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_char
id|mac_scsi_reg_read
c_func
(paren
r_int
r_char
id|reg
)paren
suffix:semicolon
r_static
r_void
id|mac_scsi_reg_write
c_func
(paren
r_int
r_char
id|reg
comma
r_int
r_char
id|value
)paren
suffix:semicolon
multiline_comment|/************************* End of Prototypes **************************/
DECL|variable|mac_scsi_host
r_static
r_struct
id|Scsi_Host
op_star
id|mac_scsi_host
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if 0
r_static
r_int
r_char
(paren
op_star
id|mac_scsi_reg_read
)paren
(paren
r_int
r_char
id|reg
)paren
suffix:semicolon
r_static
r_void
(paren
op_star
id|mac_scsi_reg_write
)paren
(paren
r_int
r_char
id|reg
comma
r_int
r_char
id|value
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef REAL_DMA
DECL|variable|mac_dma_residual
DECL|variable|mac_dma_startaddr
r_static
r_int
r_int
id|mac_dma_residual
comma
id|mac_dma_startaddr
suffix:semicolon
DECL|variable|mac_dma_active
r_static
r_int
id|mac_dma_active
suffix:semicolon
multiline_comment|/* pointer to the dribble buffer */
DECL|variable|mac_dma_buffer
r_static
r_char
op_star
id|mac_dma_buffer
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* precalculated physical address of the dribble buffer */
DECL|variable|mac_dma_phys_buffer
r_static
r_int
r_int
id|mac_dma_phys_buffer
suffix:semicolon
multiline_comment|/* != 0 tells the int handler to copy data from the dribble buffer */
DECL|variable|mac_dma_orig_addr
r_static
r_char
op_star
id|mac_dma_orig_addr
suffix:semicolon
multiline_comment|/* size of the dribble buffer; 4k seems enough, since the Falcon cannot use&n; * scatter-gather anyway, so most transfers are 1024 byte only. In the rare&n; * cases where requests to physical contiguous buffers have been merged, this&n; * request is &lt;= 4k (one page). So I don&squot;t think we have to split transfers&n; * just due to this buffer size...&n; */
DECL|macro|MAC_BUFFER_SIZE
mdefine_line|#define&t;MAC_BUFFER_SIZE&t;(4096)
macro_line|#if 1  /* FIXME: is that an issue for Macs?? */
multiline_comment|/* mask for address bits that can&squot;t be used with the ST-DMA */
DECL|variable|mac_dma_stram_mask
r_static
r_int
r_int
id|mac_dma_stram_mask
suffix:semicolon
DECL|macro|STRAM_ADDR
mdefine_line|#define STRAM_ADDR(a)&t;(((a) &amp; mac_dma_stram_mask) == 0)
macro_line|#endif
multiline_comment|/* number of bytes to cut from a transfer to handle NCR overruns */
DECL|variable|mac_read_overruns
r_static
r_int
id|mac_read_overruns
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#ifdef PSEUDO_DMA
DECL|variable|mac_pdma_residual
DECL|variable|mac_pdma_startaddr
DECL|variable|mac_pdma_current
r_static
r_int
r_int
id|mac_pdma_residual
comma
id|mac_pdma_startaddr
comma
id|mac_pdma_current
suffix:semicolon
DECL|variable|mac_pdma_active
r_static
r_int
id|mac_pdma_active
suffix:semicolon
multiline_comment|/* FIXME: is that an issue for Macs?? */
multiline_comment|/* mask for address bits that can&squot;t be used with the ST-DMA */
DECL|variable|mac_dma_stram_mask
r_static
r_int
r_int
id|mac_dma_stram_mask
suffix:semicolon
DECL|macro|STRAM_ADDR
mdefine_line|#define STRAM_ADDR(a)&t;(((a) &amp; mac_dma_stram_mask) == 0)
DECL|variable|mac_read_overruns
r_static
r_int
id|mac_read_overruns
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|variable|setup_can_queue
r_static
r_int
id|setup_can_queue
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|setup_cmd_per_lun
r_static
r_int
id|setup_cmd_per_lun
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|setup_sg_tablesize
r_static
r_int
id|setup_sg_tablesize
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef SUPPORT_TAGS
DECL|variable|setup_use_tagged_queuing
r_static
r_int
id|setup_use_tagged_queuing
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
DECL|variable|setup_hostid
r_static
r_int
id|setup_hostid
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#if defined(REAL_DMA)
macro_line|#if 0  /* FIXME */
r_static
r_int
id|scsi_dma_is_ignored_buserr
c_func
(paren
r_int
r_char
id|dma_stat
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|addr
op_assign
id|SCSI_DMA_READ_P
c_func
(paren
id|dma_addr
)paren
comma
id|end_addr
suffix:semicolon
r_if
c_cond
(paren
id|dma_stat
op_amp
l_int|0x01
)paren
(brace
multiline_comment|/* A bus error happens when DMA-ing from the last page of a&n;&t;&t; * physical memory chunk (DMA prefetch!), but that doesn&squot;t hurt.&n;&t;&t; * Check for this case:&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|boot_info.num_memory
suffix:semicolon
op_increment
id|i
)paren
(brace
id|end_addr
op_assign
id|boot_info.memory
(braket
id|i
)braket
dot
id|addr
op_plus
id|boot_info.memory
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end_addr
op_le
id|addr
op_logical_and
id|addr
op_le
id|end_addr
op_plus
l_int|4
)paren
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Dead code... wasn&squot;t called anyway :-) and causes some trouble, because at&n; * end-of-DMA, both SCSI ints are triggered simultaneously, so the NCR int has&n; * to clear the DMA int pending bit before it allows other level 6 interrupts.&n; */
r_static
r_void
id|scsi_dma_buserr
(paren
r_int
id|irq
comma
r_void
op_star
id|dummy
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_int
r_char
id|dma_stat
op_assign
id|tt_scsi_dma.dma_ctrl
suffix:semicolon
multiline_comment|/* Don&squot;t do anything if a NCR interrupt is pending. Probably it&squot;s just&n;&t; * masked... */
r_if
c_cond
(paren
id|mac_irq_pending
c_func
(paren
id|IRQ_MAC_SCSI
)paren
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Bad SCSI DMA interrupt! dma_addr=0x%08lx dma_stat=%02x dma_cnt=%08lx&bslash;n&quot;
comma
id|SCSI_DMA_READ_P
c_func
(paren
id|dma_addr
)paren
comma
id|dma_stat
comma
id|SCSI_DMA_READ_P
c_func
(paren
id|dma_cnt
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_stat
op_amp
l_int|0x80
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|scsi_dma_is_ignored_buserr
c_func
(paren
id|dma_stat
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;SCSI DMA bus error -- bad DMA programming!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Under normal circumstances we never should get to this point,&n;&t;&t; * since both interrupts are triggered simultaneously and the 5380&n;&t;&t; * int has higher priority. When this irq is handled, that DMA&n;&t;&t; * interrupt is cleared. So a warning message is printed here.&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;SCSI DMA intr ?? -- this shouldn&squot;t happen!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#endif
DECL|function|restore_irq
r_void
id|restore_irq
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|flags
op_assign
(paren
id|flags
op_amp
op_complement
l_int|0x0700
)paren
op_or
(paren
id|regs-&gt;sr
op_amp
l_int|0x0700
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|polled_scsi_on
r_static
r_int
id|polled_scsi_on
op_assign
l_int|0
suffix:semicolon
DECL|variable|mac_scsi_regp
r_static
r_int
r_char
op_star
id|mac_scsi_regp
op_assign
l_int|NULL
suffix:semicolon
DECL|function|scsi_mac_polled
r_void
id|scsi_mac_polled
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|polled_scsi_on
)paren
(brace
r_if
c_cond
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
op_amp
id|BASR_IRQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI poll&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_mac_intr
c_func
(paren
id|IRQ_MAC_SCSI
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|scsi_mac_intr
r_static
r_void
id|scsi_mac_intr
(paren
r_int
id|irq
comma
r_void
op_star
id|dummy
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef REAL_DMA
r_int
id|dma_stat
suffix:semicolon
id|dma_stat
op_assign
id|mac_scsi_dma.dma_ctrl
suffix:semicolon
id|INT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: NCR5380 interrupt, DMA status = %02x&bslash;n&quot;
comma
id|mac_scsi_host-&gt;host_no
comma
id|dma_stat
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* Look if it was the DMA that has interrupted: First possibility&n;&t; * is that a bus error occurred...&n;&t; */
r_if
c_cond
(paren
id|dma_stat
op_amp
l_int|0x80
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|scsi_dma_is_ignored_buserr
c_func
(paren
id|dma_stat
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SCSI DMA caused bus error near 0x%08lx&bslash;n&quot;
comma
id|SCSI_DMA_READ_P
c_func
(paren
id|dma_addr
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;SCSI DMA bus error -- bad DMA programming!&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If the DMA is active but not finished, we have the the case&n;&t; * that some other 5380 interrupt occurred within the DMA transfer.&n;&t; * This means we have residual bytes, if the desired end address&n;&t; * is not yet reached. Maybe we have to fetch some bytes from the&n;&t; * rest data register, too. The residual must be calculated from&n;&t; * the address pointer, not the counter register, because only the&n;&t; * addr reg counts bytes not yet written and pending in the rest&n;&t; * data reg!&n;&t; */
r_if
c_cond
(paren
(paren
id|dma_stat
op_amp
l_int|0x02
)paren
op_logical_and
op_logical_neg
(paren
id|dma_stat
op_amp
l_int|0x40
)paren
)paren
(brace
id|mac_dma_residual
op_assign
id|HOSTDATA_DMALEN
op_minus
(paren
id|SCSI_DMA_READ_P
c_func
(paren
id|dma_addr
)paren
op_minus
id|mac_dma_startaddr
)paren
suffix:semicolon
id|DMA_PRINTK
c_func
(paren
l_string|&quot;SCSI DMA: There are %ld residual bytes.&bslash;n&quot;
comma
id|mac_dma_residual
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|mac_dma_residual
OL
l_int|0
)paren
id|mac_dma_residual
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dma_stat
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* After read operations, we maybe have to&n;&t;&t;&t;   transport some rest bytes */
id|mac_scsi_fetch_restbytes
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There seems to be a nasty bug in some SCSI-DMA/NCR&n;&t;&t;&t;   combinations: If a target disconnects while a write&n;&t;&t;&t;   operation is going on, the address register of the&n;&t;&t;&t;   DMA may be a few bytes farer than it actually read.&n;&t;&t;&t;   This is probably due to DMA prefetching and a delay&n;&t;&t;&t;   between DMA and NCR.  Experiments showed that the&n;&t;&t;&t;   dma_addr is 9 bytes to high, but this could vary.&n;&t;&t;&t;   The problem is, that the residual is thus calculated&n;&t;&t;&t;   wrong and the next transfer will start behind where&n;&t;&t;&t;   it should.  So we round up the residual to the next&n;&t;&t;&t;   multiple of a sector size, if it isn&squot;t already a&n;&t;&t;&t;   multiple and the originally expected transfer size&n;&t;&t;&t;   was.  The latter condition is there to ensure that&n;&t;&t;&t;   the correction is taken only for &quot;real&quot; data&n;&t;&t;&t;   transfers and not for, e.g., the parameters of some&n;&t;&t;&t;   other command.  These shouldn&squot;t disconnect anyway.&n;&t;&t;&t;   */
r_if
c_cond
(paren
id|mac_dma_residual
op_amp
l_int|0x1ff
)paren
(brace
id|DMA_PRINTK
c_func
(paren
l_string|&quot;SCSI DMA: DMA bug corrected, &quot;
l_string|&quot;difference %ld bytes&bslash;n&quot;
comma
l_int|512
op_minus
(paren
id|mac_dma_residual
op_amp
l_int|0x1ff
)paren
)paren
suffix:semicolon
id|mac_dma_residual
op_assign
(paren
id|mac_dma_residual
op_plus
l_int|511
)paren
op_amp
op_complement
l_int|0x1ff
suffix:semicolon
)brace
)brace
id|mac_scsi_dma.dma_ctrl
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If the DMA is finished, fetch the rest bytes and turn it off */
r_if
c_cond
(paren
id|dma_stat
op_amp
l_int|0x40
)paren
(brace
id|atari_dma_residual
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dma_stat
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
id|atari_scsi_fetch_restbytes
c_func
(paren
)paren
suffix:semicolon
id|tt_scsi_dma.dma_ctrl
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* REAL_DMA */
macro_line|#ifdef PSEUDO_DMA
multiline_comment|/* determine if there is any residual for the current transfer */
r_if
c_cond
(paren
id|mac_pdma_active
)paren
(brace
multiline_comment|/* probably EOP interrupt, signaling i.e. target disconnect.&n;&t;   * We must figure out the residual from the source/destination&n;&t;   * pointers here ... */
multiline_comment|/* Should check bus status here to make sure it wasn&squot;t reselect or reset */
id|mac_pdma_residual
op_assign
id|HOSTDATA_DMALEN
op_minus
(paren
id|mac_pdma_current
op_minus
id|mac_pdma_startaddr
)paren
suffix:semicolon
id|mac_pdma_active
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef RBV_HACK
id|mac_turnoff_irq
c_func
(paren
id|IRQ_MAC_SCSI
)paren
suffix:semicolon
macro_line|#else
id|mac_disable_irq
c_func
(paren
id|IRQ_MAC_SCSI
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifndef RBV_HACK&t;/* interferes with level triggered RBV IRQs ?? */
id|restore_irq
c_func
(paren
id|fp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|irq
op_eq
id|IRQ_IDX
c_func
(paren
id|IRQ_MAC_SCSI
)paren
)paren
id|NCR5380_intr
(paren
id|irq
comma
id|dummy
comma
id|fp
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* To be sure the int is not masked */
macro_line|#ifdef RBV_HACK
id|mac_turnon_irq
c_func
(paren
id|IRQ_MAC_SCSI
)paren
suffix:semicolon
macro_line|#else
id|mac_enable_irq
c_func
(paren
id|IRQ_MAC_SCSI
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Clear the IRQ */
id|via_scsi_clear
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef REAL_DMA
DECL|function|mac_scsi_fetch_restbytes
r_static
r_void
id|mac_scsi_fetch_restbytes
c_func
(paren
r_void
)paren
(brace
r_int
id|nr
suffix:semicolon
r_char
op_star
id|src
comma
op_star
id|dst
suffix:semicolon
multiline_comment|/* fetch rest bytes in the DMA register */
id|dst
op_assign
(paren
r_char
op_star
)paren
id|SCSI_DMA_READ_P
c_func
(paren
id|dma_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nr
op_assign
(paren
(paren
r_int
)paren
id|dst
op_amp
l_int|3
)paren
)paren
)paren
(brace
multiline_comment|/* there are &squot;nr&squot; bytes left for the last long address before the&n;&t;&t;   DMA pointer */
id|dst
op_assign
(paren
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|dst
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
id|DMA_PRINTK
c_func
(paren
l_string|&quot;SCSI DMA: there are %d rest bytes for phys addr 0x%08lx&quot;
comma
id|nr
comma
(paren
r_int
)paren
id|dst
)paren
suffix:semicolon
id|dst
op_assign
(paren
r_char
op_star
)paren
id|PTOV
c_func
(paren
id|dst
)paren
suffix:semicolon
multiline_comment|/* The content of the DMA pointer&n;&t;&t;&t;&t;&t;   * is a physical address! */
id|DMA_PRINTK
c_func
(paren
l_string|&quot; = virt addr 0x%08lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|dst
)paren
suffix:semicolon
r_for
c_loop
(paren
id|src
op_assign
(paren
r_char
op_star
)paren
op_amp
id|mac_scsi_dma.dma_restdata
suffix:semicolon
id|nr
OG
l_int|0
suffix:semicolon
op_decrement
id|nr
)paren
(brace
op_star
id|dst
op_increment
op_assign
op_star
id|src
op_increment
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* REAL_DMA */
macro_line|#if 0  /* FIXME : how is the host ID determined on a Mac? */
mdefine_line|#define&t;RTC_READ(reg)&t;&t;&t;&t;&bslash;&n;    ({&t;unsigned char&t;__val;&t;&t;&t;&bslash;&n;&t;&t;outb(reg,&amp;tt_rtc.regsel);&t;&bslash;&n;&t;&t;__val = tt_rtc.data;&t;&t;&bslash;&n;&t;&t;__val;&t;&t;&t;&t;&bslash;&n;&t;})
mdefine_line|#define&t;RTC_WRITE(reg,val)&t;&t;&t;&bslash;&n;    do {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;outb(reg,&amp;tt_rtc.regsel);&t;&bslash;&n;&t;&t;tt_rtc.data = (val);&t;&t;&bslash;&n;&t;} while(0)
macro_line|#endif
DECL|function|mac_scsi_detect
r_int
id|mac_scsi_detect
(paren
id|Scsi_Host_Template
op_star
id|host
)paren
(brace
r_static
r_int
id|called
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MACH_IS_MAC
op_logical_or
id|called
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|macintosh_config-&gt;scsi_type
op_ne
id|MAC_SCSI_OLD
)paren
r_return
l_int|0
suffix:semicolon
id|host-&gt;proc_dir
op_assign
op_amp
id|proc_scsi_mac
suffix:semicolon
multiline_comment|/* testing: IIfx SCSI without IOP ?? */
r_if
c_cond
(paren
id|macintosh_config-&gt;ident
op_eq
id|MAC_MODEL_IIFX
)paren
id|mac_scsi_regp
op_assign
id|via1_regp
op_plus
l_int|0x8000
suffix:semicolon
r_else
id|mac_scsi_regp
op_assign
id|via1_regp
op_plus
l_int|0x10000
suffix:semicolon
macro_line|#if 0  /* maybe if different SCSI versions show up ? */
id|mac_scsi_reg_read
op_assign
id|IS_A_TT
c_func
(paren
)paren
ques
c_cond
id|atari_scsi_tt_reg_read
suffix:colon
id|atari_scsi_falcon_reg_read
suffix:semicolon
id|mac_scsi_reg_write
op_assign
id|IS_A_TT
c_func
(paren
)paren
ques
c_cond
id|atari_scsi_tt_reg_write
suffix:colon
macro_line|#endif&t;&t;&t;&t;&t;   atari_scsi_falcon_reg_write;
multiline_comment|/* setup variables */
id|host-&gt;can_queue
op_assign
(paren
id|setup_can_queue
OG
l_int|0
)paren
ques
c_cond
id|setup_can_queue
suffix:colon
id|MAC_SCSI_CAN_QUEUE
suffix:semicolon
id|host-&gt;cmd_per_lun
op_assign
(paren
id|setup_cmd_per_lun
OG
l_int|0
)paren
ques
c_cond
id|setup_cmd_per_lun
suffix:colon
id|MAC_SCSI_CMD_PER_LUN
suffix:semicolon
id|host-&gt;sg_tablesize
op_assign
(paren
id|setup_sg_tablesize
op_ge
l_int|0
)paren
ques
c_cond
id|setup_sg_tablesize
suffix:colon
id|MAC_SCSI_SG_TABLESIZE
suffix:semicolon
r_if
c_cond
(paren
id|setup_hostid
op_ge
l_int|0
)paren
id|host-&gt;this_id
op_assign
id|setup_hostid
suffix:semicolon
r_else
(brace
multiline_comment|/* use 7 as default */
id|host-&gt;this_id
op_assign
l_int|7
suffix:semicolon
)brace
macro_line|#ifdef SUPPORT_TAGS
r_if
c_cond
(paren
id|setup_use_tagged_queuing
OL
l_int|0
)paren
id|setup_use_tagged_queuing
op_assign
id|DEFAULT_USE_TAGGED_QUEUING
suffix:semicolon
macro_line|#endif
id|instance
op_assign
id|scsi_register
(paren
id|host
comma
r_sizeof
(paren
r_struct
id|NCR5380_hostdata
)paren
)paren
suffix:semicolon
id|mac_scsi_host
op_assign
id|instance
suffix:semicolon
multiline_comment|/* truncation of machspec bit not critical as instance-&gt;irq never used */
macro_line|#if 0&t;/* Might work; problem was only with Falcon lock */
id|instance-&gt;irq
op_assign
id|IRQ_MAC_SCSI
suffix:semicolon
macro_line|#else
id|instance-&gt;irq
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|mac_scsi_reset_boot
c_func
(paren
)paren
suffix:semicolon
id|NCR5380_init
(paren
id|instance
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* This int is actually &quot;pseudo-slow&quot;, i.e. it acts like a slow&n;&t; * interrupt after having cleared the pending flag for the DMA&n;&t; * interrupt. */
id|request_irq
c_func
(paren
id|IRQ_MAC_SCSI
comma
id|scsi_mac_intr
comma
id|IRQ_TYPE_SLOW
comma
l_string|&quot;SCSI NCR5380&quot;
comma
id|scsi_mac_intr
)paren
suffix:semicolon
macro_line|#ifdef REAL_DMA
id|tt_scsi_dma.dma_ctrl
op_assign
l_int|0
suffix:semicolon
id|atari_dma_residual
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_brokenscsi
)paren
(brace
multiline_comment|/* While the read overruns (described by Drew Eckhardt in&n;&t;&t; * NCR5380.c) never happened on TTs, they do in fact on the Medusa&n;&t;&t; * (This was the cause why SCSI didn&squot;t work right for so long&n;&t;&t; * there.) Since handling the overruns slows down a bit, I turned&n;&t;&t; * the #ifdef&squot;s into a runtime condition.&n;&t;&t; *&n;&t;&t; * In principle it should be sufficient to do max. 1 byte with&n;&t;&t; * PIO, but there is another problem on the Medusa with the DMA&n;&t;&t; * rest data register. So &squot;atari_read_overruns&squot; is currently set&n;&t;&t; * to 4 to avoid having transfers that aren&squot;t a multiple of 4. If&n;&t;&t; * the rest data bug is fixed, this can be lowered to 1.&n;&t;&t; */
id|mac_read_overruns
op_assign
l_int|4
suffix:semicolon
)brace
macro_line|#endif /* REAL_DMA */
macro_line|#ifdef PSEUDO_DMA
id|mac_pdma_residual
op_assign
l_int|0
suffix:semicolon
id|mac_pdma_active
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi%d: options CAN_QUEUE=%d CMD_PER_LUN=%d SCAT-GAT=%d &quot;
macro_line|#ifdef SUPPORT_TAGS
l_string|&quot;TAGGED-QUEUING=%s &quot;
macro_line|#endif
l_string|&quot;HOSTID=%d&quot;
comma
id|instance-&gt;host_no
comma
id|instance-&gt;hostt-&gt;can_queue
comma
id|instance-&gt;hostt-&gt;cmd_per_lun
comma
id|instance-&gt;hostt-&gt;sg_tablesize
comma
macro_line|#ifdef SUPPORT_TAGS
id|setup_use_tagged_queuing
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
macro_line|#endif
id|instance-&gt;hostt-&gt;this_id
)paren
suffix:semicolon
id|NCR5380_print_options
(paren
id|instance
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|called
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|mac_scsi_release
r_int
id|mac_scsi_release
(paren
r_struct
id|Scsi_Host
op_star
id|sh
)paren
(brace
id|free_irq
c_func
(paren
id|IRQ_MAC_SCSI
comma
id|scsi_mac_intr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mac_dma_buffer
)paren
id|scsi_init_free
(paren
id|mac_dma_buffer
comma
id|MAC_BUFFER_SIZE
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
DECL|function|mac_scsi_setup
r_void
id|mac_scsi_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
multiline_comment|/* Format of mac5380 parameter is:&n;&t; *   mac5380=&lt;can_queue&gt;,&lt;cmd_per_lun&gt;,&lt;sg_tablesize&gt;,&lt;hostid&gt;,&lt;use_tags&gt;&n;&t; * Negative values mean don&squot;t change.&n;&t; */
multiline_comment|/* Grmbl... the standard parameter parsing can&squot;t handle negative numbers&n;&t; * :-( So let&squot;s do it ourselves!&n;&t; */
r_int
id|i
op_assign
id|ints
(braket
l_int|0
)braket
op_plus
l_int|1
comma
id|fact
suffix:semicolon
r_while
c_loop
(paren
id|str
op_logical_and
(paren
id|isdigit
c_func
(paren
op_star
id|str
)paren
op_logical_or
op_star
id|str
op_eq
l_char|&squot;-&squot;
)paren
op_logical_and
id|i
op_le
l_int|10
)paren
(brace
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;-&squot;
)paren
id|fact
op_assign
op_minus
l_int|1
comma
op_increment
id|str
suffix:semicolon
r_else
id|fact
op_assign
l_int|1
suffix:semicolon
id|ints
(braket
id|i
op_increment
)braket
op_assign
id|simple_strtoul
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
op_star
id|fact
suffix:semicolon
r_if
c_cond
(paren
(paren
id|str
op_assign
id|strchr
c_func
(paren
id|str
comma
l_char|&squot;,&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
op_increment
id|str
suffix:semicolon
)brace
id|ints
(braket
l_int|0
)braket
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OL
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mac_scsi_setup: no arguments!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|1
)braket
OG
l_int|0
)paren
multiline_comment|/* no limits on this, just &gt; 0 */
id|setup_can_queue
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|2
)braket
OG
l_int|0
)paren
id|setup_cmd_per_lun
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|3
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|3
)braket
op_ge
l_int|0
)paren
(brace
id|setup_sg_tablesize
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Must be &lt;= SG_ALL (255) */
r_if
c_cond
(paren
id|setup_sg_tablesize
OG
id|SG_ALL
)paren
id|setup_sg_tablesize
op_assign
id|SG_ALL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|4
)paren
(brace
multiline_comment|/* Must be between 0 and 7 */
r_if
c_cond
(paren
id|ints
(braket
l_int|4
)braket
op_ge
l_int|0
op_logical_and
id|ints
(braket
l_int|4
)braket
op_le
l_int|7
)paren
id|setup_hostid
op_assign
id|ints
(braket
l_int|4
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ints
(braket
l_int|4
)braket
OG
l_int|7
)paren
id|printk
c_func
(paren
l_string|&quot;mac_scsi_setup: invalid host ID %d !&bslash;n&quot;
comma
id|ints
(braket
l_int|4
)braket
)paren
suffix:semicolon
)brace
macro_line|#ifdef SUPPORT_TAGS
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|5
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|5
)braket
op_ge
l_int|0
)paren
id|setup_use_tagged_queuing
op_assign
op_logical_neg
op_logical_neg
id|ints
(braket
l_int|5
)braket
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|function|mac_scsi_reset
r_int
id|mac_scsi_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_int
id|reset_flags
)paren
(brace
r_int
id|rv
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
multiline_comment|/* For doing the reset, SCSI interrupts must be disabled first,&n;&t; * since the 5380 raises its IRQ line while _RST is active and we&n;&t; * can&squot;t disable interrupts completely, since we need the timer.&n;&t; */
multiline_comment|/* And abort a maybe active DMA transfer */
id|mac_turnoff_irq
c_func
(paren
id|IRQ_MAC_SCSI
)paren
suffix:semicolon
macro_line|#ifdef REAL_DMA
id|mac_scsi_dma.dma_ctrl
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* REAL_DMA */
macro_line|#ifdef PSEUDO_DMA
id|mac_pdma_active
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|rv
op_assign
id|NCR5380_reset
c_func
(paren
id|cmd
comma
id|reset_flags
)paren
suffix:semicolon
multiline_comment|/* Re-enable ints */
id|mac_turnon_irq
c_func
(paren
id|IRQ_MAC_SCSI
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|mac_scsi_reset_boot
r_static
r_void
id|mac_scsi_reset_boot
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|end
suffix:semicolon
multiline_comment|/*&n;&t; * Do a SCSI reset to clean up the bus during initialization. No messing&n;&t; * with the queues, interrupts, or locks necessary here.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;Macintosh SCSI: resetting the SCSI bus...&quot;
)paren
suffix:semicolon
multiline_comment|/* switch off SCSI IRQ - catch an interrupt without IRQ bit set else */
id|mac_turnoff_irq
c_func
(paren
id|IRQ_MAC_SCSI
)paren
suffix:semicolon
multiline_comment|/* get in phase */
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* assert RST */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_RST
)paren
suffix:semicolon
multiline_comment|/* The min. reset hold time is 25us, so 40us should be enough */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/* reset RST and interrupt */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
r_for
c_loop
(paren
id|end
op_assign
id|jiffies
op_plus
id|AFTER_RESET_DELAY
suffix:semicolon
id|time_before
c_func
(paren
id|jiffies
comma
id|end
)paren
suffix:semicolon
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* switch on SCSI IRQ again */
id|mac_turnon_irq
c_func
(paren
id|IRQ_MAC_SCSI
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; done&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|mac_scsi_info
r_const
r_char
op_star
id|mac_scsi_info
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
multiline_comment|/* mac_scsi_detect() is verbose enough... */
r_static
r_const
r_char
id|string
(braket
)braket
op_assign
l_string|&quot;Macintosh NCR5380 SCSI&quot;
suffix:semicolon
r_return
id|string
suffix:semicolon
)brace
macro_line|#if defined(REAL_DMA)
DECL|function|mac_scsi_dma_setup
r_int
r_int
id|mac_scsi_dma_setup
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_void
op_star
id|data
comma
r_int
r_int
id|count
comma
r_int
id|dir
)paren
(brace
r_int
r_int
id|addr
op_assign
id|VTOP
c_func
(paren
id|data
)paren
suffix:semicolon
id|DMA_PRINTK
c_func
(paren
l_string|&quot;scsi%d: setting up dma, data = %p, phys = %lx, count = %ld, &quot;
l_string|&quot;dir = %d&bslash;n&quot;
comma
id|instance-&gt;host_no
comma
id|data
comma
id|addr
comma
id|count
comma
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|STRAM_ADDR
c_func
(paren
id|addr
)paren
)paren
(brace
multiline_comment|/* If we have a non-DMAable address on a Falcon, use the dribble&n;&t;&t; * buffer; &squot;orig_addr&squot; != 0 in the read case tells the interrupt&n;&t;&t; * handler to copy data from the dribble buffer to the originally&n;&t;&t; * wanted address.&n;&t;&t; */
r_if
c_cond
(paren
id|dir
)paren
id|memcpy
c_func
(paren
id|mac_dma_buffer
comma
id|data
comma
id|count
)paren
suffix:semicolon
r_else
id|mac_dma_orig_addr
op_assign
id|data
suffix:semicolon
id|addr
op_assign
id|mac_dma_phys_buffer
suffix:semicolon
)brace
id|mac_dma_startaddr
op_assign
id|addr
suffix:semicolon
multiline_comment|/* Needed for calculating residual later. */
multiline_comment|/* Cache cleanup stuff: On writes, push any dirty cache out before sending&n;&t; * it to the peripheral. (Must be done before DMA setup, since at least&n;&t; * the ST-DMA begins to fill internal buffers right after setup. For&n;&t; * reads, invalidate any cache, may be altered after DMA without CPU&n;&t; * knowledge.&n;&t; * &n;&t; * ++roman: For the Medusa, there&squot;s no need at all for that cache stuff,&n;&t; * because the hardware does bus snooping (fine!).&n;&t; */
id|dma_cache_maintenance
c_func
(paren
id|addr
comma
id|count
comma
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;SCSI warning: DMA programmed for 0 bytes !&bslash;n&quot;
)paren
suffix:semicolon
id|mac_scsi_dma.dma_ctrl
op_assign
id|dir
suffix:semicolon
id|SCSI_DMA_WRITE_P
c_func
(paren
id|dma_addr
comma
id|addr
)paren
suffix:semicolon
id|SCSI_DMA_WRITE_P
c_func
(paren
id|dma_cnt
comma
id|count
)paren
suffix:semicolon
id|mac_scsi_dma.dma_ctrl
op_assign
id|dir
op_or
l_int|2
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|mac_scsi_dma_residual
r_static
r_int
id|mac_scsi_dma_residual
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
r_return
id|mac_dma_residual
suffix:semicolon
)brace
DECL|macro|CMD_SURELY_BLOCK_MODE
mdefine_line|#define&t;CMD_SURELY_BLOCK_MODE&t;0
DECL|macro|CMD_SURELY_BYTE_MODE
mdefine_line|#define&t;CMD_SURELY_BYTE_MODE&t;1
DECL|macro|CMD_MODE_UNKNOWN
mdefine_line|#define&t;CMD_MODE_UNKNOWN&t;&t;2
DECL|function|mac_classify_cmd
r_static
r_int
id|mac_classify_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
r_char
id|opcode
op_assign
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|opcode
op_eq
id|READ_DEFECT_DATA
op_logical_or
id|opcode
op_eq
id|READ_LONG
op_logical_or
id|opcode
op_eq
id|READ_BUFFER
)paren
r_return
id|CMD_SURELY_BYTE_MODE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|opcode
op_eq
id|READ_6
op_logical_or
id|opcode
op_eq
id|READ_10
op_logical_or
id|opcode
op_eq
l_int|0xa8
multiline_comment|/* READ_12 */
op_logical_or
id|opcode
op_eq
id|READ_REVERSE
op_logical_or
id|opcode
op_eq
id|RECOVER_BUFFERED_DATA
)paren
(brace
multiline_comment|/* In case of a sequential-access target (tape), special care is&n;&t;&t; * needed here: The transfer is block-mode only if the &squot;fixed&squot; bit is&n;&t;&t; * set! */
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;type
op_eq
id|TYPE_TAPE
op_logical_and
op_logical_neg
(paren
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
op_amp
l_int|1
)paren
)paren
r_return
id|CMD_SURELY_BYTE_MODE
suffix:semicolon
r_else
r_return
id|CMD_SURELY_BLOCK_MODE
suffix:semicolon
)brace
r_else
r_return
id|CMD_MODE_UNKNOWN
suffix:semicolon
)brace
macro_line|#endif&t;/* REAL_DMA */
macro_line|#if defined(REAL_DMA) || defined(PSEUDO_DMA)
multiline_comment|/* This function calculates the number of bytes that can be transferred via&n; * DMA. On the TT, this is arbitrary, but on the Falcon we have to use the&n; * ST-DMA chip. There are only multiples of 512 bytes possible and max.&n; * 255*512 bytes :-( This means also, that defining READ_OVERRUNS is not&n; * possible on the Falcon, since that would require to program the DMA for&n; * n*512 - atari_read_overrun bytes. But it seems that the Falcon doesn&squot;t have&n; * the overrun problem, so this question is academic :-)&n; */
DECL|function|mac_dma_xfer_len
r_static
r_int
r_int
id|mac_dma_xfer_len
c_func
(paren
r_int
r_int
id|wanted_len
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|write_flag
)paren
(brace
r_int
r_int
id|possible_len
comma
id|limit
suffix:semicolon
macro_line|#if defined(REAL_DMA)
r_if
c_cond
(paren
id|IS_A_TT
c_func
(paren
)paren
)paren
multiline_comment|/* TT SCSI DMA can transfer arbitrary #bytes */
r_return
id|wanted_len
suffix:semicolon
multiline_comment|/* ST DMA chip is stupid -- only multiples of 512 bytes! (and max.&n;&t; * 255*512 bytes, but this should be enough)&n;&t; *&n;&t; * ++roman: Aaargl! Another Falcon-SCSI problem... There are some commands&n;&t; * that return a number of bytes which cannot be known beforehand. In this&n;&t; * case, the given transfer length is an &quot;allocation length&quot;. Now it&n;&t; * can happen that this allocation length is a multiple of 512 bytes and&n;&t; * the DMA is used. But if not n*512 bytes really arrive, some input data&n;&t; * will be lost in the ST-DMA&squot;s FIFO :-( Thus, we have to distinguish&n;&t; * between commands that do block transfers and those that do byte&n;&t; * transfers. But this isn&squot;t easy... there are lots of vendor specific&n;&t; * commands, and the user can issue any command via the&n;&t; * SCSI_IOCTL_SEND_COMMAND.&n;&t; *&n;&t; * The solution: We classify SCSI commands in 1) surely block-mode cmd.s,&n;&t; * 2) surely byte-mode cmd.s and 3) cmd.s with unknown mode. In case 1)&n;&t; * and 3), the thing to do is obvious: allow any number of blocks via DMA&n;&t; * or none. In case 2), we apply some heuristic: Byte mode is assumed if&n;&t; * the transfer (allocation) length is &lt; 1024, hoping that no cmd. not&n;&t; * explicitly known as byte mode have such big allocation lengths...&n;&t; * BTW, all the discussion above applies only to reads. DMA writes are&n;&t; * unproblematic anyways, since the targets aborts the transfer after&n;&t; * receiving a sufficient number of bytes.&n;&t; *&n;&t; * Another point: If the transfer is from/to an non-ST-RAM address, we&n;&t; * use the dribble buffer and thus can do only STRAM_BUFFER_SIZE bytes.&n;&t; */
r_if
c_cond
(paren
id|write_flag
)paren
(brace
multiline_comment|/* Write operation can always use the DMA, but the transfer size must&n;&t;&t; * be rounded up to the next multiple of 512 (atari_dma_setup() does&n;&t;&t; * this).&n;&t;&t; */
id|possible_len
op_assign
id|wanted_len
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Read operations: if the wanted transfer length is not a multiple of&n;&t;&t; * 512, we cannot use DMA, since the ST-DMA cannot split transfers&n;&t;&t; * (no interrupt on DMA finished!)&n;&t;&t; */
r_if
c_cond
(paren
id|wanted_len
op_amp
l_int|0x1ff
)paren
id|possible_len
op_assign
l_int|0
suffix:semicolon
r_else
(brace
multiline_comment|/* Now classify the command (see above) and decide whether it is&n;&t;&t;&t; * allowed to do DMA at all */
r_switch
c_cond
(paren
id|falcon_classify_cmd
c_func
(paren
id|cmd
)paren
)paren
(brace
r_case
id|CMD_SURELY_BLOCK_MODE
suffix:colon
id|possible_len
op_assign
id|wanted_len
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_SURELY_BYTE_MODE
suffix:colon
id|possible_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* DMA prohibited */
r_break
suffix:semicolon
r_case
id|CMD_MODE_UNKNOWN
suffix:colon
r_default
suffix:colon
multiline_comment|/* For unknown commands assume block transfers if the transfer&n;&t;&t;&t;&t; * size/allocation length is &gt;= 1024 */
id|possible_len
op_assign
(paren
id|wanted_len
OL
l_int|1024
)paren
ques
c_cond
l_int|0
suffix:colon
id|wanted_len
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Last step: apply the hard limit on DMA transfers */
id|limit
op_assign
(paren
id|atari_dma_buffer
op_logical_and
op_logical_neg
id|STRAM_ADDR
c_func
(paren
id|VTOP
c_func
(paren
id|cmd-&gt;SCp.ptr
)paren
)paren
)paren
ques
c_cond
id|STRAM_BUFFER_SIZE
suffix:colon
l_int|255
op_star
l_int|512
suffix:semicolon
r_if
c_cond
(paren
id|possible_len
OG
id|limit
)paren
id|possible_len
op_assign
id|limit
suffix:semicolon
r_if
c_cond
(paren
id|possible_len
op_ne
id|wanted_len
)paren
id|DMA_PRINTK
c_func
(paren
l_string|&quot;Sorry, must cut DMA transfer size to %ld bytes &quot;
l_string|&quot;instead of %ld&bslash;n&quot;
comma
id|possible_len
comma
id|wanted_len
)paren
suffix:semicolon
macro_line|#else /* REAL_DMA */
id|possible_len
op_assign
id|wanted_len
suffix:semicolon
macro_line|#endif
r_return
id|possible_len
suffix:semicolon
)brace
macro_line|#endif&t;/* REAL_DMA || PSEUDO_DMA */
multiline_comment|/* &n; * FIXME !!!&n; */
multiline_comment|/* NCR5380 register access functions&n; */
DECL|function|mac_scsi_reg_read
r_static
r_int
r_char
id|mac_scsi_reg_read
c_func
(paren
r_int
r_char
id|reg
)paren
(brace
r_return
id|mac_scsi_regp
(braket
id|reg
op_lshift
l_int|4
)braket
suffix:semicolon
)brace
DECL|function|mac_scsi_reg_write
r_static
r_void
id|mac_scsi_reg_write
c_func
(paren
r_int
r_char
id|reg
comma
r_int
r_char
id|value
)paren
(brace
id|mac_scsi_regp
(braket
id|reg
op_lshift
l_int|4
)braket
op_assign
id|value
suffix:semicolon
)brace
macro_line|#include &quot;mac_NCR5380.c&quot;
macro_line|#ifdef PSEUDO_DMA
multiline_comment|/*&n; * slightly optimized PIO transfer routines, experimental!&n; * command may time out if interrupts are left enabled&n; */
DECL|function|mac_pdma_read
r_static
r_inline
r_int
id|mac_pdma_read
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
r_char
op_star
id|dst
comma
r_int
id|len
)paren
(brace
r_register
r_int
r_char
op_star
id|d
op_assign
id|dst
suffix:semicolon
r_register
id|i
op_assign
id|len
suffix:semicolon
r_register
r_int
r_char
id|p
comma
id|tmp
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_PSEUDO_DMA)
id|printk
c_func
(paren
l_string|&quot;pdma_read: reading %d bytes to %p&bslash;n&quot;
comma
id|len
comma
id|dst
)paren
suffix:semicolon
macro_line|#endif
id|mac_pdma_residual
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|mac_pdma_active
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pseudo-DMA already active in pread!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|mac_pdma_active
op_assign
l_int|1
suffix:semicolon
id|mac_pdma_startaddr
op_assign
(paren
r_int
r_int
)paren
id|dst
suffix:semicolon
id|mac_pdma_current
op_assign
(paren
r_int
r_int
)paren
id|dst
suffix:semicolon
multiline_comment|/* &n;     * Get the phase from the bus (sanity check) &n;     * Hopefully, the phase bits are valid here ...&n;     */
id|p
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|PHASE_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_amp
id|SR_IO
)paren
)paren
(brace
id|PDMA_PRINTK
c_func
(paren
l_string|&quot;NCR5380_pread: initial phase mismatch!&bslash;n&quot;
)paren
suffix:semicolon
id|NCR_PRINT_PHASE
c_func
(paren
id|NDEBUG_ANY
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;     * The NCR5380 chip will only drive the SCSI bus when the &n;     * phase specified in the appropriate bits of the TARGET COMMAND&n;     * REGISTER match the STATUS REGISTER&n;     */
macro_line|#if 0&t;/* done in transfer_dma */
id|p
op_assign
id|PHASE_DATAIN
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
suffix:semicolon
id|i
suffix:semicolon
op_decrement
id|i
)paren
(brace
id|HSH_PRINTK
c_func
(paren
l_string|&quot; read %d ..&quot;
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* check if we were interrupted ... */
r_if
c_cond
(paren
op_logical_neg
id|mac_pdma_active
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pwrite: interrupt detected!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Wait for assertion of REQ, after which the phase bits will be &n;&t; * valid &n;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
op_amp
id|SR_REQ
)paren
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|HSH_PRINTK
c_func
(paren
l_string|&quot; REQ ..&quot;
)paren
suffix:semicolon
multiline_comment|/* Check for phase mismatch */
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|PHASE_MASK
)paren
op_ne
id|p
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mac_pdma_active
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase mismatch after interrupt&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase mismatch w/o interrupt&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|NCR_PRINT_PHASE
c_func
(paren
id|NDEBUG_ANY
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Do actual transfer from SCSI bus to memory */
op_star
id|d
op_assign
id|NCR5380_read
c_func
(paren
id|CURRENT_SCSI_DATA_REG
)paren
suffix:semicolon
id|d
op_increment
suffix:semicolon
multiline_comment|/* Handshake ... */
multiline_comment|/* Assert ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ACK
)paren
suffix:semicolon
id|HSH_PRINTK
c_func
(paren
l_string|&quot; ACK ..&quot;
)paren
suffix:semicolon
multiline_comment|/* Wait for REQ to be dropped */
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|HSH_PRINTK
c_func
(paren
l_string|&quot; /REQ ..&quot;
)paren
suffix:semicolon
multiline_comment|/* Drop ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|HSH_PRINTK
c_func
(paren
l_string|&quot; /ACK !&bslash;n&quot;
)paren
suffix:semicolon
id|mac_pdma_current
op_assign
(paren
r_int
r_int
)paren
id|d
suffix:semicolon
id|mac_pdma_residual
op_decrement
suffix:semicolon
)brace
macro_line|#if (NDEBUG &amp; NDEBUG_PSEUDO_DMA)
id|printk
c_func
(paren
l_string|&quot;pdma_read: read at %d bytes to %p&bslash;n&quot;
comma
id|i
comma
id|dst
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|mac_pdma_residual
)paren
id|printk
c_func
(paren
l_string|&quot;pread: leaving with residual %ld of %ld&bslash;n&quot;
comma
id|mac_pdma_residual
comma
id|len
)paren
suffix:semicolon
id|mac_pdma_active
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ?? */
macro_line|#if 0
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mac_pdma_write
r_static
r_inline
r_int
id|mac_pdma_write
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
r_char
op_star
id|src
comma
r_int
id|len
)paren
(brace
r_register
r_int
r_char
op_star
id|s
op_assign
id|src
suffix:semicolon
r_register
id|i
op_assign
id|len
suffix:semicolon
r_register
r_int
r_char
id|p
comma
id|tmp
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_PSEUDO_DMA)
id|printk
c_func
(paren
l_string|&quot;pdma_write: writing %d bytes from %p&bslash;n&quot;
comma
id|len
comma
id|src
)paren
suffix:semicolon
macro_line|#endif
id|mac_pdma_residual
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|mac_pdma_active
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pseudo-DMA already active in pwrite!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|mac_pdma_active
op_assign
l_int|1
suffix:semicolon
id|mac_pdma_startaddr
op_assign
(paren
r_int
r_int
)paren
id|src
suffix:semicolon
id|mac_pdma_current
op_assign
(paren
r_int
r_int
)paren
id|src
suffix:semicolon
multiline_comment|/* &n;     * Get the phase from the bus (sanity check) &n;     */
id|p
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|PHASE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|p
op_amp
id|SR_IO
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NCR5380_pwrite: initial phase mismatch!&bslash;n&quot;
)paren
suffix:semicolon
id|NCR_PRINT_PHASE
c_func
(paren
id|NDEBUG_ANY
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;     * The NCR5380 chip will only drive the SCSI bus when the &n;     * phase specified in the appropriate bits of the TARGET COMMAND&n;     * REGISTER match the STATUS REGISTER&n;     */
macro_line|#if 0&t;/* already done in transfer_dma */ 
id|p
op_assign
id|PHASE_DATAOUT
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
suffix:semicolon
id|i
suffix:semicolon
op_decrement
id|i
)paren
(brace
multiline_comment|/* check if we were interrupted ... */
r_if
c_cond
(paren
op_logical_neg
id|mac_pdma_active
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pwrite: interrupt detected!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Wait for assertion of REQ, after which the phase bits will be &n;&t; * valid &n;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
op_amp
id|SR_REQ
)paren
)paren
suffix:semicolon
multiline_comment|/* Check for phase mismatch */
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|PHASE_MASK
)paren
op_ne
id|p
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mac_pdma_active
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase mismatch after interrupt&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase mismatch w/o interrupt&bslash;n&quot;
comma
id|instance-&gt;host_no
)paren
suffix:semicolon
id|NCR_PRINT_PHASE
c_func
(paren
id|NDEBUG_ANY
)paren
suffix:semicolon
multiline_comment|/* should we signal an error here?? */
r_break
suffix:semicolon
)brace
multiline_comment|/* Do actual transfer to SCSI bus from memory */
id|NCR5380_write
c_func
(paren
id|OUTPUT_DATA_REG
comma
op_star
id|s
)paren
suffix:semicolon
id|s
op_increment
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
)paren
suffix:semicolon
multiline_comment|/* Handshake ... assert ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_ACK
)paren
suffix:semicolon
multiline_comment|/* ... wait for REQ to be dropped */
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
suffix:semicolon
multiline_comment|/* and drop ACK (and DATA) ! */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|mac_pdma_current
op_assign
(paren
r_int
r_int
)paren
id|s
suffix:semicolon
id|mac_pdma_residual
op_decrement
suffix:semicolon
)brace
macro_line|#if (NDEBUG &amp; NDEBUG_PSEUDO_DMA)
id|printk
c_func
(paren
l_string|&quot;pdma_write: write at %d bytes from %p&bslash;n&quot;
comma
id|i
comma
id|src
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|mac_pdma_residual
)paren
id|printk
c_func
(paren
l_string|&quot;pwrite: leaving with residual %ld of len %ld &bslash;n&quot;
comma
id|mac_pdma_residual
comma
id|len
)paren
suffix:semicolon
id|mac_pdma_active
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* PSEUDO_DMA */
macro_line|#ifdef MODULE
DECL|variable|driver_template
id|Scsi_Host_Template
id|driver_template
op_assign
id|MAC_SCSI
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
macro_line|#endif
eof
