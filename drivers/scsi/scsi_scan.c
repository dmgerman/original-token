multiline_comment|/*&n; *  scsi_scan.c Copyright (C) 2000 Eric Youngdale&n; *&n; *  Bus scan logic.&n; *&n; *  This used to live in scsi.c, but that file was just a laundry basket&n; *  full of misc stuff.  This got separated out in order to make things&n; *  clearer.&n; */
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#ifdef CONFIG_KMOD
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#endif
multiline_comment|/* The following devices are known not to tolerate a lun != 0 scan for&n; * one reason or another.  Some will respond to all luns, others will&n; * lock up.&n; */
DECL|macro|BLIST_NOLUN
mdefine_line|#define BLIST_NOLUN     &t;0x001
DECL|macro|BLIST_FORCELUN
mdefine_line|#define BLIST_FORCELUN  &t;0x002
DECL|macro|BLIST_BORKEN
mdefine_line|#define BLIST_BORKEN    &t;0x004
DECL|macro|BLIST_KEY
mdefine_line|#define BLIST_KEY       &t;0x008
DECL|macro|BLIST_SINGLELUN
mdefine_line|#define BLIST_SINGLELUN &t;0x010
DECL|macro|BLIST_NOTQ
mdefine_line|#define BLIST_NOTQ&t;&t;0x020
DECL|macro|BLIST_SPARSELUN
mdefine_line|#define BLIST_SPARSELUN &t;0x040
DECL|macro|BLIST_MAX5LUN
mdefine_line|#define BLIST_MAX5LUN&t;&t;0x080
DECL|macro|BLIST_ISDISK
mdefine_line|#define BLIST_ISDISK    &t;0x100
DECL|macro|BLIST_ISROM
mdefine_line|#define BLIST_ISROM     &t;0x200
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|data
)paren
suffix:semicolon
r_static
r_int
id|scan_scsis_single
c_func
(paren
r_int
id|channel
comma
r_int
id|dev
comma
r_int
id|lun
comma
r_int
op_star
id|max_scsi_dev
comma
r_int
op_star
id|sparse_lun
comma
id|Scsi_Device
op_star
op_star
id|SDpnt
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_char
op_star
id|scsi_result
)paren
suffix:semicolon
DECL|struct|dev_info
r_struct
id|dev_info
(brace
DECL|member|vendor
r_const
r_char
op_star
id|vendor
suffix:semicolon
DECL|member|model
r_const
r_char
op_star
id|model
suffix:semicolon
DECL|member|revision
r_const
r_char
op_star
id|revision
suffix:semicolon
multiline_comment|/* Latest revision known to be bad.  Not used yet */
DECL|member|flags
r_int
id|flags
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * This is what was previously known as the blacklist.  The concept&n; * has been expanded so that we can specify other types of things we&n; * need to be aware of.&n; */
DECL|variable|device_list
r_static
r_struct
id|dev_info
id|device_list
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;Aashima&quot;
comma
l_string|&quot;IMAGERY 2400SP&quot;
comma
l_string|&quot;1.03&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;CHINON&quot;
comma
l_string|&quot;CD-ROM CDS-431&quot;
comma
l_string|&quot;H42&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;CHINON&quot;
comma
l_string|&quot;CD-ROM CDS-535&quot;
comma
l_string|&quot;Q14&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;DENON&quot;
comma
l_string|&quot;DRD-25X&quot;
comma
l_string|&quot;V&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if probed for lun != 0 */
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;DK312C&quot;
comma
l_string|&quot;CM81&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun - dtg */
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;DK314C&quot;
comma
l_string|&quot;CR21&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;IMS&quot;
comma
l_string|&quot;CDD521/10&quot;
comma
l_string|&quot;2.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-3280&quot;
comma
l_string|&quot;PR02&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-4380S&quot;
comma
l_string|&quot;B3C&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;MXT-1240S&quot;
comma
l_string|&quot;I1.2&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up when LUN&gt;0 polled */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-4170S&quot;
comma
l_string|&quot;B5A&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up sometimes when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-8760S&quot;
comma
l_string|&quot;B7B&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* guess what? */
(brace
l_string|&quot;MEDIAVIS&quot;
comma
l_string|&quot;RENO CD-ROMX2A&quot;
comma
l_string|&quot;2.03&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/*Responds to all lun */
(brace
l_string|&quot;MICROP&quot;
comma
l_string|&quot;4110&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_NOTQ
)brace
comma
multiline_comment|/* Buggy Tagged Queuing */
(brace
l_string|&quot;NEC&quot;
comma
l_string|&quot;CD-ROM DRIVE:841&quot;
comma
l_string|&quot;1.0&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;PHILIPS&quot;
comma
l_string|&quot;PCA80SC&quot;
comma
l_string|&quot;V4-2&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;RODIME&quot;
comma
l_string|&quot;RO3000S&quot;
comma
l_string|&quot;2.33&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;SANYO&quot;
comma
l_string|&quot;CRD-250S&quot;
comma
l_string|&quot;1.20&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1&n;&t;&t;&t;&t;&t;&t;&t;&t; * for aha152x controller, which causes&n;&t;&t;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST157N&quot;
comma
l_string|&quot;&bslash;004|j&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1&n;&t;&t;&t;&t;&t;&t;&t;&t; * for aha152x controller, which causes&n;&t;&t;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST296&quot;
comma
l_string|&quot;921&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST1581&quot;
comma
l_string|&quot;6538&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-541&quot;
comma
l_string|&quot;4.3d&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-55S&quot;
comma
l_string|&quot;1.0i&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-561&quot;
comma
l_string|&quot;1.7x&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-8012&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;TANDBERG&quot;
comma
l_string|&quot;TDC 3600&quot;
comma
l_string|&quot;U07&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;CD-R55S&quot;
comma
l_string|&quot;1.0H&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1&n;&t;&t;&t;&t;&t;&t;&t;&t; * for seagate controller, which causes&n;&t;&t;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;MT-2ST/45S2-27&quot;
comma
l_string|&quot;RV M&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;TEXEL&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1&n;&t;&t;&t;&t;&t;&t;&t;&t; * for seagate controller, which causes&n;&t;&t;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;LPS525S&quot;
comma
l_string|&quot;3110&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks sometimes if polled for lun != 0 */
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;PD1225S&quot;
comma
l_string|&quot;3110&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks sometimes if polled for lun != 0 */
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;FIREBALL ST4.3S&quot;
comma
l_string|&quot;0F0C&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up when polled for lun != 0 */
(brace
l_string|&quot;MEDIAVIS&quot;
comma
l_string|&quot;CDR-H93MV&quot;
comma
l_string|&quot;1.31&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;SANKYO&quot;
comma
l_string|&quot;CP525&quot;
comma
l_string|&quot;6.64&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQ SENSE, extra reset */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C1750A&quot;
comma
l_string|&quot;3226&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iic */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C1790A&quot;
comma
l_string|&quot;&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iip */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C2500A&quot;
comma
l_string|&quot;&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iicx */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CDR100&quot;
comma
l_string|&quot;1.00&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CDR102&quot;
comma
l_string|&quot;1.00&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0  &n;&t;&t;&t;&t;&t;&t;&t;&t; * extra reset */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CRW8424S&quot;
comma
l_string|&quot;1.0&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CRW6416S&quot;
comma
l_string|&quot;1.0c&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;MITSUMI&quot;
comma
l_string|&quot;CD-R CR-2201CS&quot;
comma
l_string|&quot;6119&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;RELISYS&quot;
comma
l_string|&quot;Scorpio&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all LUN */
(brace
l_string|&quot;MICROTEK&quot;
comma
l_string|&quot;ScanMaker II&quot;
comma
l_string|&quot;5.61&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all LUN */
multiline_comment|/*&n; * Other types of devices that have special flags.&n; */
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-8001&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_BORKEN
)brace
comma
(brace
l_string|&quot;TEXEL&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_BORKEN
)brace
comma
(brace
l_string|&quot;IOMEGA&quot;
comma
l_string|&quot;Io20S         *F&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;INSITE&quot;
comma
l_string|&quot;Floptical   F*8I&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;INSITE&quot;
comma
l_string|&quot;I325VM&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;LASOUND&quot;
comma
l_string|&quot;CDX7405&quot;
comma
l_string|&quot;3.10&quot;
comma
id|BLIST_MAX5LUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NRC&quot;
comma
l_string|&quot;MBR-7&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NRC&quot;
comma
l_string|&quot;MBR-7.4&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;REGAL&quot;
comma
l_string|&quot;CDC-4X&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_MAX5LUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NAKAMICH&quot;
comma
l_string|&quot;MJ-4.8S&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NAKAMICH&quot;
comma
l_string|&quot;MJ-5.16S&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-600&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-602X&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-604X&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;EMULEX&quot;
comma
l_string|&quot;MD21/S2     ESDI&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;CANON&quot;
comma
l_string|&quot;IPUBJD&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;nCipher&quot;
comma
l_string|&quot;Fastness Crypto&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;DEC&quot;
comma
l_string|&quot;HSG80&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;COMPAQ&quot;
comma
l_string|&quot;LOGICAL VOLUME&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;NEC&quot;
comma
l_string|&quot;PD-1 ODX654P&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;MATSHITA&quot;
comma
l_string|&quot;PD-1&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;iomega&quot;
comma
l_string|&quot;jaz 1GB&quot;
comma
l_string|&quot;J.86&quot;
comma
id|BLIST_NOTQ
op_or
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;TOSHIBA&quot;
comma
l_string|&quot;CDROM&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_ISROM
)brace
comma
(brace
l_string|&quot;MegaRAID&quot;
comma
l_string|&quot;LD&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;DGC&quot;
comma
l_string|&quot;RAID&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
singleline_comment|// Dell PV 650F (tgt @ LUN 0)
(brace
l_string|&quot;DGC&quot;
comma
l_string|&quot;DISK&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
singleline_comment|// Dell PV 650F (no tgt @ LUN 0) 
(brace
l_string|&quot;DELL&quot;
comma
l_string|&quot;PV530F&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
singleline_comment|// Dell PV 530F
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;TSL&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
singleline_comment|// DDS3 &amp; DDS4 autoloaders
(brace
l_string|&quot;DELL&quot;
comma
l_string|&quot;PERCRAID&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;NetRAID-4M&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
multiline_comment|/*&n;&t; * Must be at end of list...&n;&t; */
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI_MULTI_LUN
DECL|variable|max_scsi_luns
r_static
r_int
id|max_scsi_luns
op_assign
l_int|8
suffix:semicolon
macro_line|#else
DECL|variable|max_scsi_luns
r_static
r_int
id|max_scsi_luns
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|max_scsi_luns
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_scsi_luns
comma
l_string|&quot;last scsi LUN (should be between 1 and 8)&quot;
)paren
suffix:semicolon
macro_line|#else
DECL|function|scsi_luns_setup
r_static
r_int
id|__init
id|scsi_luns_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|tmp
)paren
op_eq
l_int|1
)paren
(brace
id|max_scsi_luns
op_assign
id|tmp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi_luns_setup : usage max_scsi_luns=n &quot;
l_string|&quot;(n should be between 1 and 8)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|__setup
c_func
(paren
l_string|&quot;max_scsi_luns=&quot;
comma
id|scsi_luns_setup
)paren
suffix:semicolon
macro_line|#endif
DECL|function|print_inquiry
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|data
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Vendor: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Model: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Rev: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
OL
l_int|36
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Type:   %s &quot;
comma
id|i
OL
id|MAX_SCSI_DEVICE_CODE
ques
c_cond
id|scsi_device_types
(braket
id|i
)braket
suffix:colon
l_string|&quot;Unknown          &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                 ANSI SCSI revision: %02x&quot;
comma
id|data
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|data
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot; CCS&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|get_device_flags
r_static
r_int
id|get_device_flags
c_func
(paren
r_int
r_char
op_star
id|response_data
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|pnt
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|device_list
(braket
id|i
)braket
dot
id|vendor
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|pnt
op_assign
op_amp
id|response_data
(braket
l_int|8
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_eq
l_char|&squot; &squot;
)paren
id|pnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|vendor
comma
id|pnt
comma
id|strlen
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|vendor
)paren
)paren
)paren
r_continue
suffix:semicolon
id|pnt
op_assign
op_amp
id|response_data
(braket
l_int|16
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_eq
l_char|&squot; &squot;
)paren
id|pnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|model
comma
id|pnt
comma
id|strlen
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|model
)paren
)paren
)paren
r_continue
suffix:semicolon
r_return
id|device_list
(braket
id|i
)braket
dot
id|flags
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Detecting SCSI devices :&n; *  We scan all present host adapter&squot;s busses,  from ID 0 to ID (max_id).&n; *  We use the INQUIRY command, determine device type, and pass the ID /&n; *  lun address of all sequential devices to the tape driver, all random&n; *  devices to the disk driver.&n; */
DECL|function|scan_scsis
r_void
id|scan_scsis
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
id|uint
id|hardcoded
comma
id|uint
id|hchannel
comma
id|uint
id|hid
comma
id|uint
id|hlun
)paren
(brace
id|uint
id|channel
suffix:semicolon
r_int
id|dev
suffix:semicolon
r_int
id|lun
suffix:semicolon
r_int
id|max_dev_lun
suffix:semicolon
r_int
r_char
op_star
id|scsi_result
suffix:semicolon
r_int
r_char
id|scsi_result0
(braket
l_int|256
)braket
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDtail
suffix:semicolon
r_int
id|sparse_lun
suffix:semicolon
id|scsi_result
op_assign
l_int|NULL
suffix:semicolon
id|SDpnt
op_assign
(paren
id|Scsi_Device
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Device
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt
)paren
(brace
id|memset
c_func
(paren
id|SDpnt
comma
l_int|0
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Register the queue for the device.  All I/O requests will&n;&t;&t; * come in through here.  We also need to register a pointer to&n;&t;&t; * ourselves, since the queue handler won&squot;t know what device&n;&t;&t; * the queue actually represents.   We could look it up, but it&n;&t;&t; * is pointless work.&n;&t;&t; */
id|scsi_initialize_queue
c_func
(paren
id|SDpnt
comma
id|shpnt
)paren
suffix:semicolon
id|SDpnt-&gt;request_queue.queuedata
op_assign
(paren
r_void
op_star
)paren
id|SDpnt
suffix:semicolon
multiline_comment|/* Make sure we have something that is valid for DMA purposes */
id|scsi_result
op_assign
(paren
(paren
op_logical_neg
id|shpnt-&gt;unchecked_isa_dma
)paren
ques
c_cond
op_amp
id|scsi_result0
(braket
l_int|0
)braket
suffix:colon
id|kmalloc
c_func
(paren
l_int|512
comma
id|GFP_DMA
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsi_result
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to obtain scsi_result buffer&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We must chain ourself in the host_queue, so commands can time out &n;&t; */
id|SDpnt-&gt;queue_depth
op_assign
l_int|1
suffix:semicolon
id|SDpnt-&gt;host
op_assign
id|shpnt
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
id|initialize_merge_fn
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/*&n;         * Initialize the object that we will use to wait for command blocks.&n;         */
id|init_waitqueue_head
c_func
(paren
op_amp
id|SDpnt-&gt;scpnt_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Next, hook the device to the host in question.&n;&t; */
id|SDpnt-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|SDpnt-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;host_queue
op_ne
l_int|NULL
)paren
(brace
id|SDtail
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SDtail-&gt;next
op_ne
l_int|NULL
)paren
id|SDtail
op_assign
id|SDtail-&gt;next
suffix:semicolon
id|SDtail-&gt;next
op_assign
id|SDpnt
suffix:semicolon
id|SDpnt-&gt;prev
op_assign
id|SDtail
suffix:semicolon
)brace
r_else
(brace
id|shpnt-&gt;host_queue
op_assign
id|SDpnt
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We need to increment the counter for this one device so we can track when&n;&t; * things are quiet.&n;&t; */
r_if
c_cond
(paren
id|hardcoded
op_eq
l_int|1
)paren
(brace
id|Scsi_Device
op_star
id|oldSDpnt
op_assign
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
id|channel
op_assign
id|hchannel
suffix:semicolon
r_if
c_cond
(paren
id|channel
OG
id|shpnt-&gt;max_channel
)paren
r_goto
id|leave
suffix:semicolon
id|dev
op_assign
id|hid
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ge
id|shpnt-&gt;max_id
)paren
r_goto
id|leave
suffix:semicolon
id|lun
op_assign
id|hlun
suffix:semicolon
r_if
c_cond
(paren
id|lun
op_ge
id|shpnt-&gt;max_lun
)paren
r_goto
id|leave
suffix:semicolon
id|scan_scsis_single
c_func
(paren
id|channel
comma
id|dev
comma
id|lun
comma
op_amp
id|max_dev_lun
comma
op_amp
id|sparse_lun
comma
op_amp
id|SDpnt
comma
id|shpnt
comma
id|scsi_result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt
op_ne
id|oldSDpnt
)paren
(brace
multiline_comment|/* it could happen the blockdevice hasn&squot;t yet been inited */
multiline_comment|/* queue_depth() moved from scsi_proc_info() so that&n;&t;&t;&t;   it is called before scsi_build_commandblocks() */
r_if
c_cond
(paren
id|shpnt-&gt;select_queue_depths
op_ne
l_int|NULL
)paren
(paren
id|shpnt-&gt;select_queue_depths
)paren
(paren
id|shpnt
comma
id|shpnt-&gt;host_queue
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;init
op_logical_and
id|sdtpnt-&gt;dev_noticed
)paren
(paren
op_star
id|sdtpnt-&gt;init
)paren
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|sdtpnt-&gt;attach
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;attach
)paren
(paren
id|oldSDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldSDpnt-&gt;attached
)paren
(brace
id|scsi_build_commandblocks
c_func
(paren
id|oldSDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|oldSDpnt-&gt;has_cmdblocks
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scan_scsis: DANGER, no command blocks&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* What to do now ?? */
)brace
)brace
)brace
)brace
id|scsi_resize_dma_pool
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|sdtpnt-&gt;finish
op_logical_and
id|sdtpnt-&gt;nr_dev
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;finish
)paren
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Actual LUN. PC ordering is 0-&gt;n IBM/spec ordering is n-&gt;0 */
r_int
id|order_dev
suffix:semicolon
r_for
c_loop
(paren
id|channel
op_assign
l_int|0
suffix:semicolon
id|channel
op_le
id|shpnt-&gt;max_channel
suffix:semicolon
id|channel
op_increment
)paren
(brace
r_for
c_loop
(paren
id|dev
op_assign
l_int|0
suffix:semicolon
id|dev
OL
id|shpnt-&gt;max_id
suffix:semicolon
op_increment
id|dev
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;reverse_ordering
)paren
multiline_comment|/* Shift to scanning 15,14,13... or 7,6,5,4, */
id|order_dev
op_assign
id|shpnt-&gt;max_id
op_minus
id|dev
op_minus
l_int|1
suffix:semicolon
r_else
id|order_dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;this_id
op_ne
id|order_dev
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * We need the for so our continue, etc. work fine. We put this in&n;&t;&t;&t;&t;&t; * a variable so that we can override it during the scan if we&n;&t;&t;&t;&t;&t; * detect a device *KNOWN* to have multiple logical units.&n;&t;&t;&t;&t;&t; */
id|max_dev_lun
op_assign
(paren
id|max_scsi_luns
OL
id|shpnt-&gt;max_lun
ques
c_cond
id|max_scsi_luns
suffix:colon
id|shpnt-&gt;max_lun
)paren
suffix:semicolon
id|sparse_lun
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
id|max_dev_lun
suffix:semicolon
op_increment
id|lun
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|scan_scsis_single
c_func
(paren
id|channel
comma
id|order_dev
comma
id|lun
comma
op_amp
id|max_dev_lun
comma
op_amp
id|sparse_lun
comma
op_amp
id|SDpnt
comma
id|shpnt
comma
id|scsi_result
)paren
op_logical_and
op_logical_neg
id|sparse_lun
)paren
r_break
suffix:semicolon
multiline_comment|/* break means don&squot;t probe further for luns!=0 */
)brace
multiline_comment|/* for lun ends */
)brace
multiline_comment|/* if this_id != id ends */
)brace
multiline_comment|/* for dev ends */
)brace
multiline_comment|/* for channel ends */
)brace
multiline_comment|/* if/else hardcoded */
id|leave
suffix:colon
(brace
multiline_comment|/* Unchain SRpnt from host_queue */
id|Scsi_Device
op_star
id|prev
comma
op_star
id|next
suffix:semicolon
id|Scsi_Device
op_star
id|dqptr
suffix:semicolon
r_for
c_loop
(paren
id|dqptr
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|dqptr
op_ne
id|SDpnt
suffix:semicolon
id|dqptr
op_assign
id|dqptr-&gt;next
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dqptr
)paren
(brace
id|prev
op_assign
id|dqptr-&gt;prev
suffix:semicolon
id|next
op_assign
id|dqptr-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;next
op_assign
id|next
suffix:semicolon
r_else
id|shpnt-&gt;host_queue
op_assign
id|next
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
id|next-&gt;prev
op_assign
id|prev
suffix:semicolon
)brace
)brace
multiline_comment|/* Last device block does not exist.  Free memory. */
r_if
c_cond
(paren
id|SDpnt
op_ne
l_int|NULL
)paren
(brace
id|blk_cleanup_queue
c_func
(paren
op_amp
id|SDpnt-&gt;request_queue
)paren
suffix:semicolon
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|SDpnt
)paren
suffix:semicolon
)brace
multiline_comment|/* If we allocated a buffer so we could do DMA, free it now */
r_if
c_cond
(paren
id|scsi_result
op_ne
op_amp
id|scsi_result0
(braket
l_int|0
)braket
op_logical_and
id|scsi_result
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|scsi_result
)paren
suffix:semicolon
)brace
(brace
id|Scsi_Device
op_star
id|sdev
suffix:semicolon
id|Scsi_Cmnd
op_star
id|scmd
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;Host status for host %p:&bslash;n&quot;
comma
id|shpnt
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdev
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|sdev
suffix:semicolon
id|sdev
op_assign
id|sdev-&gt;next
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;Device %d %p: &quot;
comma
id|sdev-&gt;id
comma
id|sdev
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|scmd
op_assign
id|sdev-&gt;device_queue
suffix:semicolon
id|scmd
suffix:semicolon
id|scmd
op_assign
id|scmd-&gt;next
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;%p &quot;
comma
id|scmd
)paren
)paren
suffix:semicolon
)brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * The worker for scan_scsis.&n; * Returning 0 means Please don&squot;t ask further for lun!=0, 1 means OK go on.&n; * Global variables used : scsi_devices(linked list)&n; */
DECL|function|scan_scsis_single
r_static
r_int
id|scan_scsis_single
c_func
(paren
r_int
id|channel
comma
r_int
id|dev
comma
r_int
id|lun
comma
r_int
op_star
id|max_dev_lun
comma
r_int
op_star
id|sparse_lun
comma
id|Scsi_Device
op_star
op_star
id|SDpnt2
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_char
op_star
id|scsi_result
)paren
(brace
r_char
id|devname
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDtail
comma
op_star
id|SDpnt
op_assign
op_star
id|SDpnt2
suffix:semicolon
id|Scsi_Request
op_star
id|SRpnt
suffix:semicolon
r_int
id|bflags
comma
id|type
op_assign
op_minus
l_int|1
suffix:semicolon
r_extern
id|devfs_handle_t
id|scsi_devfs_handle
suffix:semicolon
id|SDpnt-&gt;host
op_assign
id|shpnt
suffix:semicolon
id|SDpnt-&gt;id
op_assign
id|dev
suffix:semicolon
id|SDpnt-&gt;lun
op_assign
id|lun
suffix:semicolon
id|SDpnt-&gt;channel
op_assign
id|channel
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
id|scsi_build_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/* Some low level driver could use device-&gt;type (DB) */
id|SDpnt-&gt;type
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Assume that the device will have handshaking problems, and then fix this&n;&t; * field later if it turns out it doesn&squot;t&n;&t; */
id|SDpnt-&gt;borken
op_assign
l_int|1
suffix:semicolon
id|SDpnt-&gt;was_reset
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;expecting_cc_ua
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;starved
op_assign
l_int|0
suffix:semicolon
id|SRpnt
op_assign
id|scsi_allocate_request
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We used to do a TEST_UNIT_READY before the INQUIRY but that was &n;&t; * not really necessary.  Spec recommends using INQUIRY to scan for&n;&t; * devices (and TEST_UNIT_READY to poll for media change). - Paul G.&n;&t; */
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi: performing INQUIRY&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Build an INQUIRY command block.&n;&t; */
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|255
suffix:semicolon
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|SRpnt-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|SRpnt-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|scsi_wait_req
(paren
id|SRpnt
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|256
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi: INQUIRY %s with code 0x%x&bslash;n&quot;
comma
id|SRpnt-&gt;sr_result
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;successful&quot;
comma
id|SRpnt-&gt;sr_result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SRpnt-&gt;sr_result
)paren
(brace
id|scsi_release_request
c_func
(paren
id|SRpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* assume no peripheral if any sort of error */
)brace
multiline_comment|/*&n;&t; * Check the peripheral qualifier field - this tells us whether LUNS&n;&t; * are supported here or not.&n;&t; */
r_if
c_cond
(paren
(paren
id|scsi_result
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
op_eq
l_int|3
)paren
(brace
id|scsi_release_request
c_func
(paren
id|SRpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* assume no peripheral if any sort of error */
)brace
multiline_comment|/*&n;&t; * Get any flags for this device.  &n;&t; */
id|bflags
op_assign
id|get_device_flags
(paren
id|scsi_result
)paren
suffix:semicolon
multiline_comment|/*   The Toshiba ROM was &quot;gender-changed&quot; here as an inline hack.&n;&t;      This is now much more generic.&n;&t;      This is a mess: What we really want is to leave the scsi_result&n;&t;      alone, and just change the SDpnt structure. And the SDpnt is what&n;&t;      we want print_inquiry to print.  -- REW&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_ISDISK
)paren
(brace
id|scsi_result
(braket
l_int|0
)braket
op_assign
id|TYPE_DISK
suffix:semicolon
id|scsi_result
(braket
l_int|1
)braket
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* removable */
)brace
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_ISROM
)paren
(brace
id|scsi_result
(braket
l_int|0
)braket
op_assign
id|TYPE_ROM
suffix:semicolon
id|scsi_result
(braket
l_int|1
)braket
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* removable */
)brace
id|memcpy
c_func
(paren
id|SDpnt-&gt;vendor
comma
id|scsi_result
op_plus
l_int|8
comma
l_int|8
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|SDpnt-&gt;model
comma
id|scsi_result
op_plus
l_int|16
comma
l_int|16
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|SDpnt-&gt;rev
comma
id|scsi_result
op_plus
l_int|32
comma
l_int|4
)paren
suffix:semicolon
id|SDpnt-&gt;removable
op_assign
(paren
l_int|0x80
op_amp
id|scsi_result
(braket
l_int|1
)braket
)paren
op_rshift
l_int|7
suffix:semicolon
multiline_comment|/* Use the peripheral qualifier field to determine online/offline */
r_if
c_cond
(paren
(paren
(paren
id|scsi_result
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
op_amp
l_int|7
)paren
op_eq
l_int|1
)paren
id|SDpnt-&gt;online
op_assign
id|FALSE
suffix:semicolon
r_else
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
id|SDpnt-&gt;lockable
op_assign
id|SDpnt-&gt;removable
suffix:semicolon
id|SDpnt-&gt;changed
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;access_count
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;has_cmdblocks
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Currently, all sequential devices are assumed to be tapes, all random&n;&t; * devices disk, with the appropriate read only flags set for ROM / WORM&n;&t; * treated as RO.&n;&t; */
r_switch
c_cond
(paren
id|type
op_assign
(paren
id|scsi_result
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
)paren
(brace
r_case
id|TYPE_TAPE
suffix:colon
r_case
id|TYPE_DISK
suffix:colon
r_case
id|TYPE_MOD
suffix:colon
r_case
id|TYPE_PROCESSOR
suffix:colon
r_case
id|TYPE_SCANNER
suffix:colon
r_case
id|TYPE_MEDIUM_CHANGER
suffix:colon
r_case
id|TYPE_ENCLOSURE
suffix:colon
r_case
id|TYPE_COMM
suffix:colon
id|SDpnt-&gt;writeable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_WORM
suffix:colon
r_case
id|TYPE_ROM
suffix:colon
id|SDpnt-&gt;writeable
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi: unknown type %d&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
)brace
id|SDpnt-&gt;device_blocked
op_assign
id|FALSE
suffix:semicolon
id|SDpnt-&gt;device_busy
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;single_lun
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;soft_reset
op_assign
(paren
id|scsi_result
(braket
l_int|7
)braket
op_amp
l_int|1
)paren
op_logical_and
(paren
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|7
)paren
op_eq
l_int|2
)paren
suffix:semicolon
id|SDpnt-&gt;random
op_assign
(paren
id|type
op_eq
id|TYPE_TAPE
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|SDpnt-&gt;type
op_assign
(paren
id|type
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|print_inquiry
c_func
(paren
id|scsi_result
)paren
suffix:semicolon
id|sprintf
(paren
id|devname
comma
l_string|&quot;host%d/bus%d/target%d/lun%d&quot;
comma
id|SDpnt-&gt;host-&gt;host_no
comma
id|SDpnt-&gt;channel
comma
id|SDpnt-&gt;id
comma
id|SDpnt-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;de
)paren
id|printk
(paren
l_string|&quot;DEBUG: dir: &bslash;&quot;%s&bslash;&quot; already exists&bslash;n&quot;
comma
id|devname
)paren
suffix:semicolon
r_else
id|SDpnt-&gt;de
op_assign
id|devfs_mk_dir
(paren
id|scsi_devfs_handle
comma
id|devname
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;detect
)paren
id|SDpnt-&gt;attached
op_add_assign
(paren
op_star
id|sdtpnt-&gt;detect
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
id|SDpnt-&gt;scsi_level
op_assign
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;scsi_level
op_ge
l_int|2
op_logical_or
(paren
id|SDpnt-&gt;scsi_level
op_eq
l_int|1
op_logical_and
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
)paren
id|SDpnt-&gt;scsi_level
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Accommodate drivers that want to sleep when they should be in a polling&n;&t; * loop.&n;&t; */
id|SDpnt-&gt;disconnect
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Set the tagged_queue flag for SCSI-II devices that purport to support&n;&t; * tagged queuing in the INQUIRY data.&n;&t; */
id|SDpnt-&gt;tagged_queue
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|SDpnt-&gt;scsi_level
op_ge
id|SCSI_2
)paren
op_logical_and
(paren
id|scsi_result
(braket
l_int|7
)braket
op_amp
l_int|2
)paren
op_logical_and
op_logical_neg
(paren
id|bflags
op_amp
id|BLIST_NOTQ
)paren
)paren
(brace
id|SDpnt-&gt;tagged_supported
op_assign
l_int|1
suffix:semicolon
id|SDpnt-&gt;current_tag
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Some revisions of the Texel CD ROM drives have handshaking problems when&n;&t; * used with the Seagate controllers.  Before we know what type of device&n;&t; * we&squot;re talking to, we assume it&squot;s borken and then change it here if it&n;&t; * turns out that it isn&squot;t a TEXEL drive.&n;&t; */
r_if
c_cond
(paren
(paren
id|bflags
op_amp
id|BLIST_BORKEN
)paren
op_eq
l_int|0
)paren
id|SDpnt-&gt;borken
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we want to only allow I/O to one of the luns attached to this device&n;&t; * at a time, then we set this flag.&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_SINGLELUN
)paren
id|SDpnt-&gt;single_lun
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * These devices need this &quot;key&quot; to unlock the devices so we can use it&n;&t; */
r_if
c_cond
(paren
(paren
id|bflags
op_amp
id|BLIST_KEY
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unlocked floptical drive.&bslash;n&quot;
)paren
suffix:semicolon
id|SDpnt-&gt;lockable
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x2e
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|0x2a
suffix:semicolon
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|SRpnt-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|SRpnt-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|scsi_wait_req
(paren
id|SRpnt
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|0x2a
comma
id|SCSI_TIMEOUT
comma
l_int|3
)paren
suffix:semicolon
)brace
id|scsi_release_request
c_func
(paren
id|SRpnt
)paren
suffix:semicolon
id|SRpnt
op_assign
l_int|NULL
suffix:semicolon
id|scsi_release_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This device was already hooked up to the host in question,&n;&t; * so at this point we just let go of it and it should be fine.  We do need to&n;&t; * allocate a new one and attach it to the host so that we can further scan the bus.&n;&t; */
id|SDpnt
op_assign
(paren
id|Scsi_Device
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Device
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SDpnt
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: scan_scsis_single: Cannot malloc&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|SDpnt
comma
l_int|0
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
op_star
id|SDpnt2
op_assign
id|SDpnt
suffix:semicolon
id|SDpnt-&gt;queue_depth
op_assign
l_int|1
suffix:semicolon
id|SDpnt-&gt;host
op_assign
id|shpnt
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t; * Register the queue for the device.  All I/O requests will come&n;&t; * in through here.  We also need to register a pointer to&n;&t; * ourselves, since the queue handler won&squot;t know what device&n;&t; * the queue actually represents.   We could look it up, but it&n;&t; * is pointless work.&n;&t; */
id|scsi_initialize_queue
c_func
(paren
id|SDpnt
comma
id|shpnt
)paren
suffix:semicolon
id|SDpnt-&gt;host
op_assign
id|shpnt
suffix:semicolon
id|initialize_merge_fn
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark this device as online, or otherwise we won&squot;t be able to do much with it.&n;&t; */
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;         * Initialize the object that we will use to wait for command blocks.&n;         */
id|init_waitqueue_head
c_func
(paren
op_amp
id|SDpnt-&gt;scpnt_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since we just found one device, there had damn well better be one in the list&n;&t; * already.&n;&t; */
r_if
c_cond
(paren
id|shpnt-&gt;host_queue
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;scan_scsis_single: Host queue == NULL&bslash;n&quot;
)paren
suffix:semicolon
id|SDtail
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SDtail-&gt;next
)paren
(brace
id|SDtail
op_assign
id|SDtail-&gt;next
suffix:semicolon
)brace
multiline_comment|/* Add this device to the linked list at the end */
id|SDtail-&gt;next
op_assign
id|SDpnt
suffix:semicolon
id|SDpnt-&gt;prev
op_assign
id|SDtail
suffix:semicolon
id|SDpnt-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Some scsi devices cannot be polled for lun != 0 due to firmware bugs&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_NOLUN
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* break; */
multiline_comment|/*&n;&t; * If this device is known to support sparse multiple units, override the&n;&t; * other settings, and scan all of them.&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_SPARSELUN
)paren
(brace
op_star
id|max_dev_lun
op_assign
l_int|8
suffix:semicolon
op_star
id|sparse_lun
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If this device is known to support multiple units, override the other&n;&t; * settings, and scan all of them.&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_FORCELUN
)paren
(brace
op_star
id|max_dev_lun
op_assign
l_int|8
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * REGAL CDC-4X: avoid hang after LUN 4&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_MAX5LUN
)paren
(brace
op_star
id|max_dev_lun
op_assign
l_int|5
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We assume the device can&squot;t handle lun!=0 if: - it reports scsi-0&n;&t; * (ANSI SCSI Revision 0) (old drives like MAXTOR XT-3280) or - it&n;&t; * reports scsi-1 (ANSI SCSI Revision 1) and Response Data Format 0&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
eof
