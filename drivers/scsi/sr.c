multiline_comment|/*&n; *  sr.c Copyright (C) 1992 David Giller&n; *&t;     Copyright (C) 1993, 1994, 1995 Eric Youngdale&n; *&n; *  adapted from:&n; *&t;sd.c Copyright (C) 1992 Drew Eckhardt &n; *&t;Linux scsi disk driver by&n; *&t;&t;Drew Eckhardt &lt;drew@colorado.edu&gt;&n; *&n; *      Modified by Eric Youngdale ericy@cais.com to&n; *      add scatter-gather, multiple outstanding request, and other&n; *      enhancements.&n; *&n; *&t;    Modified by Eric Youngdale eric@aib.com to support loadable&n; *&t;    low-level scsi drivers.&n; *&n; *&t; Modified by Thomas Quinot thomas@melchior.frmug.fr.net to&n; *&t; provide auto-eject.&n; *&n; */
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/autoconf.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#endif /* MODULE */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;asm/system.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR SCSI_CDROM_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;sr.h&quot;
macro_line|#include &quot;scsi_ioctl.h&quot;   /* For the door lock/unlock commands */
macro_line|#include &quot;constants.h&quot;
DECL|macro|MAX_RETRIES
mdefine_line|#define MAX_RETRIES 3
DECL|macro|SR_TIMEOUT
mdefine_line|#define SR_TIMEOUT (150 * HZ)
r_static
r_int
id|sr_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|sr_finish
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|sr_attach
c_func
(paren
id|Scsi_Device
op_star
)paren
suffix:semicolon
r_static
r_int
id|sr_detect
c_func
(paren
id|Scsi_Device
op_star
)paren
suffix:semicolon
r_static
r_void
id|sr_detach
c_func
(paren
id|Scsi_Device
op_star
)paren
suffix:semicolon
DECL|variable|sr_template
r_struct
id|Scsi_Device_Template
id|sr_template
op_assign
(brace
l_int|NULL
comma
l_string|&quot;cdrom&quot;
comma
l_string|&quot;sr&quot;
comma
l_int|NULL
comma
id|TYPE_ROM
comma
id|SCSI_CDROM_MAJOR
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
id|sr_detect
comma
id|sr_init
comma
id|sr_finish
comma
id|sr_attach
comma
id|sr_detach
)brace
suffix:semicolon
DECL|variable|scsi_CDs
id|Scsi_CD
op_star
id|scsi_CDs
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|sr_sizes
r_static
r_int
op_star
id|sr_sizes
suffix:semicolon
DECL|variable|sr_blocksizes
r_static
r_int
op_star
id|sr_blocksizes
suffix:semicolon
r_static
r_int
id|sr_open
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_void
id|get_sectorsize
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sr_ioctl
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_void
id|requeue_sr_request
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_static
r_int
id|check_cdrom_media_change
c_func
(paren
id|kdev_t
)paren
suffix:semicolon
DECL|function|sr_release
r_static
r_void
id|sr_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|sync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|device-&gt;access_count
)paren
(brace
id|sr_ioctl
c_func
(paren
id|inode
comma
l_int|NULL
comma
id|SCSI_IOCTL_DOORUNLOCK
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|auto_eject
)paren
id|sr_ioctl
c_func
(paren
id|inode
comma
l_int|NULL
comma
id|CDROMEJECT
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|device-&gt;host-&gt;hostt-&gt;usage_count
)paren
(paren
op_star
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|device-&gt;host-&gt;hostt-&gt;usage_count
)paren
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|sr_template.usage_count
)paren
(brace
(paren
op_star
id|sr_template.usage_count
)paren
op_decrement
suffix:semicolon
)brace
)brace
DECL|variable|sr_fops
r_static
r_struct
id|file_operations
id|sr_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|sr_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|sr_open
comma
multiline_comment|/* special open code */
id|sr_release
comma
multiline_comment|/* release */
l_int|NULL
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
id|check_cdrom_media_change
comma
multiline_comment|/* Disk change */
l_int|NULL
multiline_comment|/* revalidate */
)brace
suffix:semicolon
multiline_comment|/*&n; * This function checks to see if the media has been changed in the&n; * CDROM drive.  It is possible that we have already sensed a change,&n; * or the drive may have sensed one and not yet reported it.  We must&n; * be ready for either case. This function always reports the current&n; * value of the changed bit.  If flag is 0, then the changed bit is reset.&n; * This function could be done as an ioctl, but we would need to have&n; * an inode for that to work, and we do not always have one.&n; */
DECL|function|check_cdrom_media_change
r_int
(def_block
id|check_cdrom_media_change
c_func
(paren
id|kdev_t
id|full_dev
)paren
(brace
r_int
id|retval
comma
id|target
suffix:semicolon
r_struct
id|inode
id|inode
suffix:semicolon
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
id|target
op_assign
id|MINOR
c_func
(paren
id|full_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
op_ge
id|sr_template.nr_dev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CD-ROM request error: invalid device.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
id|inode.i_rdev
op_assign
id|full_dev
suffix:semicolon
multiline_comment|/* This is all we really need here */
id|retval
op_assign
id|sr_ioctl
c_func
(paren
op_amp
id|inode
comma
l_int|NULL
comma
id|SCSI_IOCTL_TEST_UNIT_READY
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
multiline_comment|/* Unable to test, unit probably not ready.  This usually&n;&t;&t; * means there is no disc in the drive.  Mark as changed,&n;&t;&t; * and we will figure it out later once the drive is&n;&t;&t; * available again.  */
id|scsi_CDs
(braket
id|target
)braket
dot
id|device-&gt;changed
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* This will force a flush, if called from&n;&t;&t;   * check_disk_change */
)brace
suffix:semicolon
id|retval
op_assign
id|scsi_CDs
(braket
id|target
)braket
dot
id|device-&gt;changed
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
id|scsi_CDs
(braket
id|target
)braket
dot
id|device-&gt;changed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If the disk changed, the capacity will now be different,&n;&t; * so we force a re-read of this information */
r_if
c_cond
(paren
id|retval
)paren
id|scsi_CDs
(braket
id|target
)braket
dot
id|needs_sector_size
op_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * rw_intr is the interrupt routine for the device driver.  It will be notified on the &n; * end of a SCSI read / write, and will take on of several actions based on success or failure.&n; */
DECL|function|rw_intr
r_static
r_void
id|rw_intr
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|result
op_assign
id|SCpnt-&gt;result
suffix:semicolon
r_int
id|this_count
op_assign
id|SCpnt-&gt;this_count
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sr.c done: %x %x&bslash;n&quot;
comma
id|result
comma
id|SCpnt-&gt;request.bh-&gt;b_data
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
multiline_comment|/* No error */
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;buffer
op_ne
id|SCpnt-&gt;request.buffer
)paren
(brace
r_int
id|offset
suffix:semicolon
id|offset
op_assign
(paren
id|SCpnt-&gt;request.sector
op_mod
l_int|4
)paren
op_lshift
l_int|9
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|SCpnt-&gt;request.buffer
comma
(paren
r_char
op_star
)paren
id|SCpnt-&gt;buffer
op_plus
id|offset
comma
id|this_count
op_lshift
l_int|9
)paren
suffix:semicolon
multiline_comment|/* Even though we are not using scatter-gather, we look&n;&t;&t; * ahead and see if there is a linked request for the&n;&t;&t; * other half of this buffer.  If there is, then satisfy&n;&t;&t; * it. */
r_if
c_cond
(paren
(paren
id|offset
op_eq
l_int|0
)paren
op_logical_and
id|this_count
op_eq
l_int|2
op_logical_and
id|SCpnt-&gt;request.nr_sectors
OG
id|this_count
op_logical_and
id|SCpnt-&gt;request.bh
op_logical_and
id|SCpnt-&gt;request.bh-&gt;b_reqnext
op_logical_and
id|SCpnt-&gt;request.bh-&gt;b_reqnext-&gt;b_size
op_eq
l_int|1024
)paren
(brace
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|SCpnt-&gt;request.bh-&gt;b_reqnext-&gt;b_data
comma
(paren
r_char
op_star
)paren
id|SCpnt-&gt;buffer
op_plus
l_int|1024
comma
l_int|1024
)paren
suffix:semicolon
id|this_count
op_add_assign
l_int|2
suffix:semicolon
)brace
suffix:semicolon
id|scsi_free
c_func
(paren
id|SCpnt-&gt;buffer
comma
l_int|2048
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|scatterlist
op_star
id|sgpnt
suffix:semicolon
r_int
id|i
suffix:semicolon
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sgpnt
(braket
id|i
)braket
dot
id|alt_address
)paren
(brace
r_if
c_cond
(paren
id|sgpnt
(braket
id|i
)braket
dot
id|alt_address
op_ne
id|sgpnt
(braket
id|i
)braket
dot
id|address
)paren
(brace
id|memcpy
c_func
(paren
id|sgpnt
(braket
id|i
)braket
dot
id|alt_address
comma
id|sgpnt
(braket
id|i
)braket
dot
id|address
comma
id|sgpnt
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
)brace
suffix:semicolon
id|scsi_free
c_func
(paren
id|sgpnt
(braket
id|i
)braket
dot
id|address
comma
id|sgpnt
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
id|scsi_free
c_func
(paren
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;sglist_len
)paren
suffix:semicolon
multiline_comment|/* Free list of scatter-gather pointers */
r_if
c_cond
(paren
id|SCpnt-&gt;request.sector
op_mod
l_int|4
)paren
(brace
id|this_count
op_sub_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* See   if there is a padding record at the end that needs to be removed */
r_if
c_cond
(paren
id|this_count
OG
id|SCpnt-&gt;request.nr_sectors
)paren
(brace
id|this_count
op_sub_assign
l_int|2
suffix:semicolon
)brace
)brace
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;(%x %x %x) &quot;
comma
id|SCpnt-&gt;request.bh
comma
id|SCpnt-&gt;request.nr_sectors
comma
id|this_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SCpnt-&gt;request.nr_sectors
OG
id|this_count
)paren
(brace
id|SCpnt-&gt;request.errors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCpnt-&gt;request.bh
)paren
id|panic
c_func
(paren
l_string|&quot;sr.c: linked page request (%lx %x)&quot;
comma
id|SCpnt-&gt;request.sector
comma
id|this_count
)paren
suffix:semicolon
)brace
id|SCpnt
op_assign
id|end_scsi_request
c_func
(paren
id|SCpnt
comma
l_int|1
comma
id|this_count
)paren
suffix:semicolon
multiline_comment|/* All done */
id|requeue_sr_request
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Normal completion */
multiline_comment|/* We only come through here if we have an error of some kind */
multiline_comment|/* Free up any indirection buffers we allocated for DMA purposes. */
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
r_struct
id|scatterlist
op_star
id|sgpnt
suffix:semicolon
r_int
id|i
suffix:semicolon
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sgpnt
(braket
id|i
)braket
dot
id|alt_address
)paren
(brace
id|scsi_free
c_func
(paren
id|sgpnt
(braket
id|i
)braket
dot
id|address
comma
id|sgpnt
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
id|scsi_free
c_func
(paren
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;sglist_len
)paren
suffix:semicolon
multiline_comment|/* Free list of scatter-gather pointers */
)brace
r_else
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;buffer
op_ne
id|SCpnt-&gt;request.buffer
)paren
id|scsi_free
c_func
(paren
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;bufflen
)paren
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|driver_byte
c_func
(paren
id|result
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x7f
)paren
op_eq
l_int|0x70
)paren
(brace
r_if
c_cond
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
id|UNIT_ATTENTION
)paren
(brace
multiline_comment|/* detected disc change.  set a bit and quietly refuse &n;&t;&t;&t;&t; * further access.&t;*/
id|scsi_CDs
(braket
id|DEVICE_NR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)braket
dot
id|device-&gt;changed
op_assign
l_int|1
suffix:semicolon
id|SCpnt
op_assign
id|end_scsi_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|this_count
)paren
suffix:semicolon
id|requeue_sr_request
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_eq
id|ILLEGAL_REQUEST
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CD-ROM error: &quot;
)paren
suffix:semicolon
id|print_sense
c_func
(paren
l_string|&quot;sr&quot;
comma
id|SCpnt
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;command was: &quot;
)paren
suffix:semicolon
id|print_command
c_func
(paren
id|SCpnt-&gt;cmnd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_CDs
(braket
id|DEVICE_NR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)braket
dot
id|ten
)paren
(brace
id|scsi_CDs
(braket
id|DEVICE_NR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)braket
dot
id|ten
op_assign
l_int|0
suffix:semicolon
id|requeue_sr_request
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|SCpnt
op_assign
id|end_scsi_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|this_count
)paren
suffix:semicolon
id|requeue_sr_request
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/* Do next request */
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_eq
id|NOT_READY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CDROM not ready.  Make sure you have a disc in the drive.&bslash;n&quot;
)paren
suffix:semicolon
id|SCpnt
op_assign
id|end_scsi_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|this_count
)paren
suffix:semicolon
id|requeue_sr_request
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/* Do next request */
r_return
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/* We only get this far if we have an error we have not recognized */
r_if
c_cond
(paren
id|result
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI CD error : host %d id %d lun %d return code = %03x&bslash;n&quot;
comma
id|scsi_CDs
(braket
id|DEVICE_NR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)braket
dot
id|device-&gt;host-&gt;host_no
comma
id|scsi_CDs
(braket
id|DEVICE_NR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)braket
dot
id|device-&gt;id
comma
id|scsi_CDs
(braket
id|DEVICE_NR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)braket
dot
id|device-&gt;lun
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status_byte
c_func
(paren
id|result
)paren
op_eq
id|CHECK_CONDITION
)paren
id|print_sense
c_func
(paren
l_string|&quot;sr&quot;
comma
id|SCpnt
)paren
suffix:semicolon
id|SCpnt
op_assign
id|end_scsi_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|SCpnt-&gt;request.current_nr_sectors
)paren
suffix:semicolon
id|requeue_sr_request
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Here I tried to implement better support for PhotoCD&squot;s.&n; * &n; * Much of this has do be done with vendor-specific SCSI-commands.&n; * So I have to complete it step by step. Useful information is welcome.&n; *&n; * Actually works:&n; *   - NEC:     Detection and support of multisession CD&squot;s. Special handling&n; *              for XA-disks is not necessary.&n; *     &n; *   - TOSHIBA: setting density is done here now, mounting PhotoCD&squot;s should&n; *              work now without running the program &quot;set_density&quot;&n; *              Multisession CD&squot;s are supported too.&n; *&n; *   kraxel@cs.tu-berlin.de (Gerd Knorr)&n; */
multiline_comment|/*&n; * 19950704 operator@melchior.frmug.fr.net (Thomas Quinot)&n; *&n; *   - SONY:&t;Same as Nec.&n; *&n; *   - PIONEER: works with SONY code&n; */
DECL|function|sr_photocd
r_static
r_void
id|sr_photocd
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
r_int
id|sector
comma
id|min
comma
id|sec
comma
id|frame
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|40
)braket
suffix:semicolon
multiline_comment|/* the buffer for the ioctl */
r_int
r_char
op_star
id|cmd
suffix:semicolon
multiline_comment|/* the scsi-command */
r_int
r_char
op_star
id|send
suffix:semicolon
multiline_comment|/* the data we send to the drive ... */
r_int
r_char
op_star
id|rec
suffix:semicolon
multiline_comment|/* ... and get back */
r_int
id|rc
comma
id|is_xa
comma
id|no_multi
suffix:semicolon
r_if
c_cond
(paren
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|xa_flags
op_amp
l_int|0x02
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sr_photocd: CDROM and/or the driver does not support multisession CD&squot;s&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* I&squot;m not the superuser, so SCSI_IOCTL_SEND_COMMAND isn&squot;t allowed for me.&n;&t; * That&squot;s why mpcd_sector will be initialized with zero, because I&squot;m not&n;&t; * able to get the right value. Necessary only if access_count is 1, else&n;&t; * no disk change happened since the last call of this function and we can&n;&t; * keep the old value.&n;&t; */
r_if
c_cond
(paren
l_int|1
op_eq
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|device-&gt;access_count
)paren
(brace
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|mpcd_sector
op_assign
l_int|0
suffix:semicolon
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|xa_flags
op_and_assign
op_complement
l_int|0x01
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|sector
op_assign
l_int|0
suffix:semicolon
id|is_xa
op_assign
l_int|0
suffix:semicolon
id|no_multi
op_assign
l_int|0
suffix:semicolon
id|cmd
op_assign
id|rec
op_assign
op_amp
id|buf
(braket
l_int|8
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|device-&gt;manufacturer
)paren
(brace
r_case
id|SCSI_MAN_NEC
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sr_photocd: use NEC code&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
l_int|40
)paren
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
op_assign
l_int|0x0
suffix:semicolon
multiline_comment|/* we send nothing...     */
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|buf
op_plus
l_int|1
)paren
op_assign
l_int|0x16
suffix:semicolon
multiline_comment|/* and receive 0x16 bytes */
id|cmd
(braket
l_int|0
)braket
op_assign
l_int|0xde
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
l_int|0x03
suffix:semicolon
id|cmd
(braket
l_int|2
)braket
op_assign
l_int|0xb0
suffix:semicolon
id|rc
op_assign
id|kernel_scsi_ioctl
c_func
(paren
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|device
comma
id|SCSI_IOCTL_SEND_COMMAND
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sr_photocd: ioctl error (NEC): 0x%x&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rec
(braket
l_int|14
)braket
op_ne
l_int|0
op_logical_and
id|rec
(braket
l_int|14
)braket
op_ne
l_int|0xb0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sr_photocd: Hmm, seems the CDROM doesn&squot;t support multisession CD&squot;s&bslash;n&quot;
)paren
suffix:semicolon
id|no_multi
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|min
op_assign
(paren
r_int
r_int
)paren
id|rec
(braket
l_int|15
)braket
op_div
l_int|16
op_star
l_int|10
op_plus
(paren
r_int
r_int
)paren
id|rec
(braket
l_int|15
)braket
op_mod
l_int|16
suffix:semicolon
id|sec
op_assign
(paren
r_int
r_int
)paren
id|rec
(braket
l_int|16
)braket
op_div
l_int|16
op_star
l_int|10
op_plus
(paren
r_int
r_int
)paren
id|rec
(braket
l_int|16
)braket
op_mod
l_int|16
suffix:semicolon
id|frame
op_assign
(paren
r_int
r_int
)paren
id|rec
(braket
l_int|17
)braket
op_div
l_int|16
op_star
l_int|10
op_plus
(paren
r_int
r_int
)paren
id|rec
(braket
l_int|17
)braket
op_mod
l_int|16
suffix:semicolon
id|sector
op_assign
id|min
op_star
id|CD_SECS
op_star
id|CD_FRAMES
op_plus
id|sec
op_star
id|CD_FRAMES
op_plus
id|frame
suffix:semicolon
id|is_xa
op_assign
(paren
id|rec
(braket
l_int|14
)braket
op_eq
l_int|0xb0
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|sector
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sr_photocd: multisession CD detected. start: %lu&bslash;n&quot;
comma
id|sector
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
r_case
id|SCSI_MAN_TOSHIBA
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sr_photocd: use TOSHIBA code&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* we request some disc information (is it a XA-CD ?,&n;&t; * where starts the last session ?) */
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
l_int|40
)paren
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
op_assign
l_int|0
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|buf
op_plus
l_int|1
)paren
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* we receive 4 bytes from the drive */
id|cmd
(braket
l_int|0
)braket
op_assign
l_int|0xc7
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
l_int|3
suffix:semicolon
id|rc
op_assign
id|kernel_scsi_ioctl
c_func
(paren
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|device
comma
id|SCSI_IOCTL_SEND_COMMAND
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|rc
op_eq
l_int|0x28000002
)paren
(brace
multiline_comment|/* Got a &quot;not ready&quot; - error. No chance to find out if this is&n;&t;&t; * because there is no CD in the drive or because the drive&n;&t;&t; * don&squot;t knows multisession CD&squot;s. So I need to do an extra check... */
r_if
c_cond
(paren
id|kernel_scsi_ioctl
c_func
(paren
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|device
comma
id|SCSI_IOCTL_TEST_UNIT_READY
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sr_photocd: drive not ready&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;sr_photocd: Hmm, seems the CDROM doesn&squot;t support multisession CD&squot;s&bslash;n&quot;
)paren
suffix:semicolon
id|no_multi
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;sr_photocd: ioctl error (TOSHIBA #1): 0x%x&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* if the first ioctl fails, we don&squot;t call the second one */
)brace
id|is_xa
op_assign
(paren
id|rec
(braket
l_int|0
)braket
op_eq
l_int|0x20
)paren
suffix:semicolon
id|min
op_assign
(paren
r_int
r_int
)paren
id|rec
(braket
l_int|1
)braket
op_div
l_int|16
op_star
l_int|10
op_plus
(paren
r_int
r_int
)paren
id|rec
(braket
l_int|1
)braket
op_mod
l_int|16
suffix:semicolon
id|sec
op_assign
(paren
r_int
r_int
)paren
id|rec
(braket
l_int|2
)braket
op_div
l_int|16
op_star
l_int|10
op_plus
(paren
r_int
r_int
)paren
id|rec
(braket
l_int|2
)braket
op_mod
l_int|16
suffix:semicolon
id|frame
op_assign
(paren
r_int
r_int
)paren
id|rec
(braket
l_int|3
)braket
op_div
l_int|16
op_star
l_int|10
op_plus
(paren
r_int
r_int
)paren
id|rec
(braket
l_int|3
)braket
op_mod
l_int|16
suffix:semicolon
id|sector
op_assign
id|min
op_star
id|CD_SECS
op_star
id|CD_FRAMES
op_plus
id|sec
op_star
id|CD_FRAMES
op_plus
id|frame
suffix:semicolon
r_if
c_cond
(paren
id|sector
)paren
(brace
id|sector
op_sub_assign
id|CD_BLOCK_OFFSET
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sr_photocd: multisession CD detected: start: %lu&bslash;n&quot;
comma
id|sector
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* now we do a get_density... */
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
l_int|40
)paren
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
op_assign
l_int|0
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|buf
op_plus
l_int|1
)paren
op_assign
l_int|12
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
l_int|0x1a
suffix:semicolon
id|cmd
(braket
l_int|2
)braket
op_assign
l_int|1
suffix:semicolon
id|cmd
(braket
l_int|4
)braket
op_assign
l_int|12
suffix:semicolon
id|rc
op_assign
id|kernel_scsi_ioctl
c_func
(paren
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|device
comma
id|SCSI_IOCTL_SEND_COMMAND
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sr_photocd: ioctl error (TOSHIBA #2): 0x%x&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sr_photocd: get_density: 0x%x&bslash;n&quot;
comma
id|rec
(braket
l_int|4
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* ...and only if necessary a set_density */
r_if
c_cond
(paren
(paren
id|rec
(braket
l_int|4
)braket
op_ne
l_int|0x81
op_logical_and
id|is_xa
)paren
op_logical_or
(paren
id|rec
(braket
l_int|4
)braket
op_ne
l_int|0
op_logical_and
op_logical_neg
id|is_xa
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sr_photocd: doing set_density&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
l_int|40
)paren
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
op_assign
l_int|12
suffix:semicolon
multiline_comment|/* sending 12 bytes... */
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|buf
op_plus
l_int|1
)paren
op_assign
l_int|0
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
l_int|0x15
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
(paren
l_int|1
op_lshift
l_int|4
)paren
suffix:semicolon
id|cmd
(braket
l_int|4
)braket
op_assign
l_int|12
suffix:semicolon
id|send
op_assign
op_amp
id|cmd
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* this is a 6-Byte command          */
id|send
(braket
l_int|3
)braket
op_assign
l_int|0x08
suffix:semicolon
multiline_comment|/* the data for the command          */
id|send
(braket
l_int|4
)braket
op_assign
(paren
id|is_xa
)paren
ques
c_cond
l_int|0x81
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* density 0x81 for XA-CD&squot;s, 0 else  */
id|send
(braket
l_int|10
)braket
op_assign
l_int|0x08
suffix:semicolon
id|rc
op_assign
id|kernel_scsi_ioctl
c_func
(paren
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|device
comma
id|SCSI_IOCTL_SEND_COMMAND
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sr_photocd: ioctl error (TOSHIBA #3): 0x%x&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* The set_density command may have changed the sector size or capacity. */
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|needs_sector_size
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SCSI_MAN_SONY
suffix:colon
multiline_comment|/* Thomas QUINOT &lt;thomas@melchior.frmug.fr.net&gt; */
r_case
id|SCSI_MAN_PIONEER
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sr_photocd: use SONY/PIONEER code&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
l_int|40
)paren
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
op_assign
l_int|0x0
suffix:semicolon
multiline_comment|/* we send nothing...     */
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|buf
op_plus
l_int|1
)paren
op_assign
l_int|0x0c
suffix:semicolon
multiline_comment|/* and receive 0x0c bytes */
id|cmd
(braket
l_int|0
)braket
op_assign
l_int|0x43
suffix:semicolon
multiline_comment|/* Read TOC */
id|cmd
(braket
l_int|8
)braket
op_assign
l_int|0x0c
suffix:semicolon
id|cmd
(braket
l_int|9
)braket
op_assign
l_int|0x40
suffix:semicolon
id|rc
op_assign
id|kernel_scsi_ioctl
c_func
(paren
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|device
comma
id|SCSI_IOCTL_SEND_COMMAND
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_ne
l_int|0
)paren
op_logical_or
(paren
(paren
id|rec
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_plus
id|rec
(braket
l_int|1
)braket
op_ne
l_int|0x0a
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sr_photocd: ioctl error (SONY): 0x%x&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sector
op_assign
id|rec
(braket
l_int|11
)braket
op_plus
(paren
id|rec
(braket
l_int|10
)braket
op_lshift
l_int|8
)paren
op_plus
(paren
id|rec
(braket
l_int|9
)braket
op_lshift
l_int|16
)paren
op_plus
(paren
id|rec
(braket
l_int|8
)braket
op_lshift
l_int|24
)paren
suffix:semicolon
id|is_xa
op_assign
op_logical_neg
op_logical_neg
id|sector
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|sector
)paren
id|printk
(paren
l_string|&quot;sr_photocd: multisession CD detected. start: %lu&bslash;n&quot;
comma
id|sector
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|SCSI_MAN_NEC_OLDCDR
suffix:colon
r_case
id|SCSI_MAN_UNKNOWN
suffix:colon
r_default
suffix:colon
id|sector
op_assign
l_int|0
suffix:semicolon
id|no_multi
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|mpcd_sector
op_assign
id|sector
suffix:semicolon
r_if
c_cond
(paren
id|is_xa
)paren
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|xa_flags
op_or_assign
l_int|0x01
suffix:semicolon
r_else
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|xa_flags
op_and_assign
op_complement
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
id|no_multi
)paren
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|xa_flags
op_or_assign
l_int|0x02
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|sr_open
r_static
r_int
id|sr_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_ge
id|sr_template.nr_dev
op_logical_or
op_logical_neg
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|device
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* No such device */
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|device-&gt;access_count
op_increment
)paren
(brace
id|sr_ioctl
c_func
(paren
id|inode
comma
l_int|NULL
comma
id|SCSI_IOCTL_DOORLOCK
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|device-&gt;host-&gt;hostt-&gt;usage_count
)paren
(paren
op_star
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|device-&gt;host-&gt;hostt-&gt;usage_count
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sr_template.usage_count
)paren
(brace
(paren
op_star
id|sr_template.usage_count
)paren
op_increment
suffix:semicolon
)brace
id|sr_photocd
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* If this device did not have media in the drive at boot time, then&n;&t; * we would have been unable to get the sector size.  Check to see if&n;&t; * this is the case, and try again.&n;&t; */
r_if
c_cond
(paren
id|scsi_CDs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|needs_sector_size
)paren
(brace
id|get_sectorsize
c_func
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * do_sr_request() is the request handler function for the sr driver.&n; * Its function in life is to take block device requests, and&n; * translate them to SCSI commands.  &n; */
DECL|function|do_sr_request
r_static
r_void
id|do_sr_request
(paren
r_void
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|request
op_star
id|req
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Device
op_star
id|SDev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
op_eq
l_int|1
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_ne
l_int|NULL
op_logical_and
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
id|INIT_SCSI_REQUEST
suffix:semicolon
id|SDev
op_assign
id|scsi_CDs
(braket
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
)braket
dot
id|device
suffix:semicolon
multiline_comment|/*&n;         * I am not sure where the best place to do this is.  We need&n;         * to hook in a place where we are likely to come if in user&n;         * space.&n;         */
r_if
c_cond
(paren
id|SDev-&gt;was_reset
)paren
(brace
multiline_comment|/*&n; &t;     * We need to relock the door, but we might&n; &t;     * be in an interrupt handler.  Only do this&n; &t;     * from user space, since we do not want to&n; &t;     * sleep from an interrupt.&n; &t;     */
r_if
c_cond
(paren
id|SDev-&gt;removable
op_logical_and
op_logical_neg
id|intr_count
)paren
(brace
id|scsi_ioctl
c_func
(paren
id|SDev
comma
id|SCSI_IOCTL_DOORLOCK
comma
l_int|0
)paren
suffix:semicolon
)brace
id|SDev-&gt;was_reset
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flag
op_increment
op_eq
l_int|0
)paren
id|SCpnt
op_assign
id|allocate_device
c_func
(paren
op_amp
id|CURRENT
comma
id|scsi_CDs
(braket
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
)braket
dot
id|device
comma
l_int|0
)paren
suffix:semicolon
r_else
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* This is a performance enhancement.  We dig down into the request list and&n;&t; * try and find a queueable request (i.e. device not busy, and host able to&n;&t; * accept another command.  If we find one, then we queue it. This can&n;&t; * make a big difference on systems with more than one disk drive.  We want&n;&t; * to have the interrupts off when monkeying with the request list, because&n;&t; * otherwise the kernel might try and slip in a request in between somewhere. */
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
op_logical_and
id|sr_template.nr_dev
OG
l_int|1
)paren
(brace
r_struct
id|request
op_star
id|req1
suffix:semicolon
id|req1
op_assign
l_int|NULL
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|req
op_assign
id|CURRENT
suffix:semicolon
r_while
c_loop
(paren
id|req
)paren
(brace
id|SCpnt
op_assign
id|request_queueable
c_func
(paren
id|req
comma
id|scsi_CDs
(braket
id|DEVICE_NR
c_func
(paren
id|req-&gt;rq_dev
)paren
)braket
dot
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
)paren
(brace
r_break
suffix:semicolon
)brace
id|req1
op_assign
id|req
suffix:semicolon
id|req
op_assign
id|req-&gt;next
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_logical_and
id|req-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_if
c_cond
(paren
id|req
op_eq
id|CURRENT
)paren
id|CURRENT
op_assign
id|CURRENT-&gt;next
suffix:semicolon
r_else
id|req1-&gt;next
op_assign
id|req-&gt;next
suffix:semicolon
)brace
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
)paren
r_return
suffix:semicolon
multiline_comment|/* Could not find anything to do */
id|wake_up
c_func
(paren
op_amp
id|wait_for_request
)paren
suffix:semicolon
multiline_comment|/* Queue command */
id|requeue_sr_request
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* While */
)brace
DECL|function|requeue_sr_request
r_void
id|requeue_sr_request
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|dev
comma
id|block
comma
id|realcount
suffix:semicolon
r_int
r_char
id|cmd
(braket
l_int|10
)braket
comma
op_star
id|buffer
comma
id|tries
suffix:semicolon
r_int
id|this_count
comma
id|start
comma
id|end_rec
suffix:semicolon
id|tries
op_assign
l_int|2
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
op_logical_or
id|SCpnt-&gt;request.rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
id|do_sr_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev
op_assign
id|MINOR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
suffix:semicolon
id|block
op_assign
id|SCpnt-&gt;request.sector
suffix:semicolon
id|buffer
op_assign
l_int|NULL
suffix:semicolon
id|this_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ge
id|sr_template.nr_dev
)paren
(brace
multiline_comment|/* printk(&quot;CD-ROM request error: invalid device.&bslash;n&quot;);&t;&t;&t;*/
id|SCpnt
op_assign
id|end_scsi_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|SCpnt-&gt;request.nr_sectors
)paren
suffix:semicolon
id|tries
op_assign
l_int|2
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|scsi_CDs
(braket
id|dev
)braket
dot
id|use
)paren
(brace
multiline_comment|/* printk(&quot;CD-ROM request error: device marked not in use.&bslash;n&quot;);&t;&t;*/
id|SCpnt
op_assign
id|end_scsi_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|SCpnt-&gt;request.nr_sectors
)paren
suffix:semicolon
id|tries
op_assign
l_int|2
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsi_CDs
(braket
id|dev
)braket
dot
id|device-&gt;changed
)paren
(brace
multiline_comment|/* &n;&t; * quietly refuse to do anything to a changed disc &n;&t; * until the changed bit has been reset&n;&t; */
multiline_comment|/* printk(&quot;CD-ROM has been changed.  Prohibiting further I/O.&bslash;n&quot;);&t;*/
id|SCpnt
op_assign
id|end_scsi_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|SCpnt-&gt;request.nr_sectors
)paren
suffix:semicolon
id|tries
op_assign
l_int|2
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|SCpnt-&gt;request.cmd
)paren
(brace
r_case
id|WRITE
suffix:colon
id|SCpnt
op_assign
id|end_scsi_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|SCpnt-&gt;request.nr_sectors
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ
suffix:colon
id|cmd
(braket
l_int|0
)braket
op_assign
id|READ_6
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
(paren
l_string|&quot;Unknown sr command %d&bslash;n&quot;
comma
id|SCpnt-&gt;request.cmd
)paren
suffix:semicolon
)brace
id|cmd
(braket
l_int|1
)braket
op_assign
(paren
id|SCpnt-&gt;lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
multiline_comment|/*&n;     * Now do the grungy work of figuring out which sectors we need, and&n;     * where in memory we are going to put them.&n;     * &n;     * The variables we need are:&n;     * &n;     * this_count= number of 512 byte sectors being read &n;     * block     = starting cdrom sector to read.&n;     * realcount = # of cdrom sectors to read&n;     * &n;     * The major difference between a scsi disk and a scsi cdrom&n;     * is that we will always use scatter-gather if we can, because we can&n;     * work around the fact that the buffer cache has a block size of 1024,&n;     * and we have 2048 byte sectors.  This code should work for buffers that&n;     * are any multiple of 512 bytes long.&n;     */
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;sg_tablesize
OG
l_int|0
op_logical_and
(paren
op_logical_neg
id|need_isa_buffer
op_logical_or
id|dma_free_sectors
op_ge
l_int|10
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sgpnt
suffix:semicolon
r_int
id|count
comma
id|this_count_max
suffix:semicolon
id|bh
op_assign
id|SCpnt-&gt;request.bh
suffix:semicolon
id|this_count
op_assign
l_int|0
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
id|this_count_max
op_assign
(paren
id|scsi_CDs
(braket
id|dev
)braket
dot
id|ten
ques
c_cond
l_int|0xffff
suffix:colon
l_int|0xff
)paren
op_lshift
l_int|4
suffix:semicolon
multiline_comment|/* Calculate how many links we can use.  First see if we need&n;&t; * a padding record at the start */
id|this_count
op_assign
id|SCpnt-&gt;request.sector
op_mod
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|this_count
)paren
(brace
id|count
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_logical_and
id|count
OL
id|SCpnt-&gt;host-&gt;sg_tablesize
)paren
(brace
r_if
c_cond
(paren
(paren
id|this_count
op_plus
(paren
id|bh-&gt;b_size
op_rshift
l_int|9
)paren
)paren
OG
id|this_count_max
)paren
r_break
suffix:semicolon
id|this_count
op_add_assign
(paren
id|bh-&gt;b_size
op_rshift
l_int|9
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Fix up in case of an odd record at the end */
id|end_rec
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|this_count
op_mod
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|count
OL
id|SCpnt-&gt;host-&gt;sg_tablesize
)paren
(brace
id|count
op_increment
suffix:semicolon
id|end_rec
op_assign
(paren
l_int|4
op_minus
(paren
id|this_count
op_mod
l_int|4
)paren
)paren
op_lshift
l_int|9
suffix:semicolon
id|this_count
op_add_assign
l_int|4
op_minus
(paren
id|this_count
op_mod
l_int|4
)paren
suffix:semicolon
)brace
r_else
(brace
id|count
op_decrement
suffix:semicolon
id|this_count
op_sub_assign
(paren
id|this_count
op_mod
l_int|4
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|count
suffix:semicolon
multiline_comment|/* Number of chains */
id|count
op_assign
l_int|512
suffix:semicolon
multiline_comment|/* scsi_malloc can only allocate in chunks of 512 bytes*/
r_while
c_loop
(paren
id|count
OL
(paren
id|SCpnt-&gt;use_sg
op_star
r_sizeof
(paren
r_struct
id|scatterlist
)paren
)paren
)paren
(brace
id|count
op_assign
id|count
op_lshift
l_int|1
suffix:semicolon
)brace
id|SCpnt-&gt;sglist_len
op_assign
id|count
suffix:semicolon
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|scsi_malloc
c_func
(paren
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sgpnt
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning - running *really* short on DMA buffers&bslash;n&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No memory left - bail out */
)brace
r_else
(brace
id|buffer
op_assign
(paren
r_int
r_char
op_star
)paren
id|sgpnt
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
id|bh
op_assign
id|SCpnt-&gt;request.bh
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request.sector
op_mod
l_int|4
)paren
(brace
id|sgpnt
(braket
id|count
)braket
dot
id|length
op_assign
(paren
id|SCpnt-&gt;request.sector
op_mod
l_int|4
)paren
op_lshift
l_int|9
suffix:semicolon
id|sgpnt
(braket
id|count
)braket
dot
id|address
op_assign
(paren
r_char
op_star
)paren
id|scsi_malloc
c_func
(paren
id|sgpnt
(braket
id|count
)braket
dot
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sgpnt
(braket
id|count
)braket
dot
id|address
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;SCSI DMA pool exhausted.&quot;
)paren
suffix:semicolon
)brace
id|sgpnt
(braket
id|count
)braket
dot
id|alt_address
op_assign
id|sgpnt
(braket
id|count
)braket
dot
id|address
suffix:semicolon
multiline_comment|/* Flag to delete&n;&t;&t;&t;&t;&t;&t;&t;&t;    if needed */
id|count
op_increment
suffix:semicolon
)brace
suffix:semicolon
r_for
c_loop
(paren
id|bh
op_assign
id|SCpnt-&gt;request.bh
suffix:semicolon
id|count
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|count
op_increment
comma
id|bh
op_assign
id|bh-&gt;b_reqnext
)paren
(brace
r_if
c_cond
(paren
id|bh
)paren
(brace
multiline_comment|/* Need a placeholder at the end of the record? */
id|sgpnt
(braket
id|count
)braket
dot
id|address
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|sgpnt
(braket
id|count
)braket
dot
id|length
op_assign
id|bh-&gt;b_size
suffix:semicolon
id|sgpnt
(braket
id|count
)braket
dot
id|alt_address
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|sgpnt
(braket
id|count
)braket
dot
id|address
op_assign
(paren
r_char
op_star
)paren
id|scsi_malloc
c_func
(paren
id|end_rec
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sgpnt
(braket
id|count
)braket
dot
id|address
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;SCSI DMA pool exhausted.&quot;
)paren
suffix:semicolon
)brace
id|sgpnt
(braket
id|count
)braket
dot
id|length
op_assign
id|end_rec
suffix:semicolon
id|sgpnt
(braket
id|count
)braket
dot
id|alt_address
op_assign
id|sgpnt
(braket
id|count
)braket
dot
id|address
suffix:semicolon
r_if
c_cond
(paren
id|count
op_plus
l_int|1
op_ne
id|SCpnt-&gt;use_sg
)paren
id|panic
c_func
(paren
l_string|&quot;Bad sr request list&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|sgpnt
(braket
id|count
)braket
dot
id|address
)paren
op_plus
id|sgpnt
(braket
id|count
)braket
dot
id|length
OG
id|ISA_DMA_THRESHOLD
op_logical_and
id|SCpnt-&gt;host-&gt;unchecked_isa_dma
)paren
(brace
id|sgpnt
(braket
id|count
)braket
dot
id|alt_address
op_assign
id|sgpnt
(braket
id|count
)braket
dot
id|address
suffix:semicolon
multiline_comment|/* We try and avoid exhausting the DMA pool, since it is easier&n;&t;&t;     * to control usage here.  In other places we might have a more&n;&t;&t;     * pressing need, and we would be screwed if we ran out */
r_if
c_cond
(paren
id|dma_free_sectors
OL
(paren
id|sgpnt
(braket
id|count
)braket
dot
id|length
op_rshift
l_int|9
)paren
op_plus
l_int|5
)paren
(brace
id|sgpnt
(braket
id|count
)braket
dot
id|address
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|sgpnt
(braket
id|count
)braket
dot
id|address
op_assign
(paren
r_char
op_star
)paren
id|scsi_malloc
c_func
(paren
id|sgpnt
(braket
id|count
)braket
dot
id|length
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* If we start running low on DMA buffers, we abort the scatter-gather&n;&t;&t;     * operation, and free all of the memory we have allocated.  We want to&n;&t;&t;     * ensure that all scsi operations are able to do at least a non-scatter/gather&n;&t;&t;     * operation */
r_if
c_cond
(paren
id|sgpnt
(braket
id|count
)braket
dot
id|address
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Out of dma memory */
id|printk
c_func
(paren
l_string|&quot;Warning: Running low on SCSI DMA buffers&quot;
)paren
suffix:semicolon
multiline_comment|/* Try switching back to a non scatter-gather operation. */
r_while
c_loop
(paren
op_decrement
id|count
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sgpnt
(braket
id|count
)braket
dot
id|alt_address
)paren
(brace
id|scsi_free
c_func
(paren
id|sgpnt
(braket
id|count
)braket
dot
id|address
comma
id|sgpnt
(braket
id|count
)braket
dot
id|length
)paren
suffix:semicolon
)brace
)brace
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|scsi_free
c_func
(paren
id|buffer
comma
id|SCpnt-&gt;sglist_len
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* if address == NULL */
)brace
suffix:semicolon
multiline_comment|/* if need DMA fixup */
)brace
suffix:semicolon
multiline_comment|/* for loop to fill list */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SR: %d %d %d %d %d *** &quot;
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;request.sector
comma
id|this_count
comma
id|SCpnt-&gt;request.current_nr_sectors
comma
id|SCpnt-&gt;request.nr_sectors
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|count
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SGlist: %d %x %x %x&bslash;n&quot;
comma
id|count
comma
id|sgpnt
(braket
id|count
)braket
dot
id|address
comma
id|sgpnt
(braket
id|count
)braket
dot
id|alt_address
comma
id|sgpnt
(braket
id|count
)braket
dot
id|length
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* Able to allocate scatter-gather list */
)brace
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We cannot use scatter-gather.  Do this the old fashion way */
r_if
c_cond
(paren
op_logical_neg
id|SCpnt-&gt;request.bh
)paren
id|this_count
op_assign
id|SCpnt-&gt;request.nr_sectors
suffix:semicolon
r_else
id|this_count
op_assign
(paren
id|SCpnt-&gt;request.bh-&gt;b_size
op_rshift
l_int|9
)paren
suffix:semicolon
id|start
op_assign
id|block
op_mod
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|start
)paren
(brace
id|this_count
op_assign
(paren
(paren
id|this_count
OG
l_int|4
op_minus
id|start
)paren
ques
c_cond
(paren
l_int|4
op_minus
id|start
)paren
suffix:colon
(paren
id|this_count
)paren
)paren
suffix:semicolon
id|buffer
op_assign
(paren
r_int
r_char
op_star
)paren
id|scsi_malloc
c_func
(paren
l_int|2048
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this_count
OL
l_int|4
)paren
(brace
id|buffer
op_assign
(paren
r_int
r_char
op_star
)paren
id|scsi_malloc
c_func
(paren
l_int|2048
)paren
suffix:semicolon
)brace
r_else
(brace
id|this_count
op_sub_assign
id|this_count
op_mod
l_int|4
suffix:semicolon
id|buffer
op_assign
(paren
r_int
r_char
op_star
)paren
id|SCpnt-&gt;request.buffer
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|buffer
)paren
op_plus
(paren
id|this_count
op_lshift
l_int|9
)paren
OG
id|ISA_DMA_THRESHOLD
op_logical_and
id|SCpnt-&gt;host-&gt;unchecked_isa_dma
)paren
id|buffer
op_assign
(paren
r_int
r_char
op_star
)paren
id|scsi_malloc
c_func
(paren
id|this_count
op_lshift
l_int|9
)paren
suffix:semicolon
)brace
)brace
suffix:semicolon
r_if
c_cond
(paren
id|scsi_CDs
(braket
id|dev
)braket
dot
id|sector_size
op_eq
l_int|2048
)paren
id|block
op_assign
id|block
op_rshift
l_int|2
suffix:semicolon
multiline_comment|/* These are the sectors that the cdrom uses */
r_else
id|block
op_assign
id|block
op_amp
l_int|0xfffffffc
suffix:semicolon
id|realcount
op_assign
(paren
id|this_count
op_plus
l_int|3
)paren
op_div
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|scsi_CDs
(braket
id|dev
)braket
dot
id|sector_size
op_eq
l_int|512
)paren
id|realcount
op_assign
id|realcount
op_lshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|realcount
OG
l_int|0xff
)paren
op_logical_or
(paren
id|block
OG
l_int|0x1fffff
)paren
)paren
op_logical_and
id|scsi_CDs
(braket
id|dev
)braket
dot
id|ten
)paren
(brace
r_if
c_cond
(paren
id|realcount
OG
l_int|0xffff
)paren
(brace
id|realcount
op_assign
l_int|0xffff
suffix:semicolon
id|this_count
op_assign
id|realcount
op_star
(paren
id|scsi_CDs
(braket
id|dev
)braket
dot
id|sector_size
op_rshift
l_int|9
)paren
suffix:semicolon
)brace
id|cmd
(braket
l_int|0
)braket
op_add_assign
id|READ_10
op_minus
id|READ_6
suffix:semicolon
id|cmd
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|block
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|3
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|block
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|4
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|block
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|5
)braket
op_assign
(paren
r_int
r_char
)paren
id|block
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|6
)braket
op_assign
id|cmd
(braket
l_int|9
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd
(braket
l_int|7
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|realcount
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|8
)braket
op_assign
(paren
r_int
r_char
)paren
id|realcount
op_amp
l_int|0xff
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|realcount
OG
l_int|0xff
)paren
(brace
id|realcount
op_assign
l_int|0xff
suffix:semicolon
id|this_count
op_assign
id|realcount
op_star
(paren
id|scsi_CDs
(braket
id|dev
)braket
dot
id|sector_size
op_rshift
l_int|9
)paren
suffix:semicolon
)brace
id|cmd
(braket
l_int|1
)braket
op_or_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|block
op_rshift
l_int|16
)paren
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|cmd
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|block
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|cmd
(braket
l_int|3
)braket
op_assign
(paren
r_int
r_char
)paren
id|block
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|4
)braket
op_assign
(paren
r_int
r_char
)paren
id|realcount
suffix:semicolon
id|cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ReadCD: %d %d %d %d&bslash;n&quot;
comma
id|block
comma
id|realcount
comma
id|buffer
comma
id|this_count
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Use sg: %d&bslash;n&quot;
comma
id|SCpnt-&gt;use_sg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Dumping command: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|12
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2.2x &quot;
comma
id|cmd
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/* Some dumb host adapters can speed transfers by knowing the&n;     * minimum transfersize in advance.&n;     *&n;     * We shouldn&squot;t disconnect in the middle of a sector, but the cdrom&n;     * sector size can be larger than the size of a buffer and the&n;     * transfer may be split to the size of a buffer.  So it&squot;s safe to&n;     * assume that we can at least transfer the minimum of the buffer&n;     * size (1024) and the sector size between each connect / disconnect.&n;     */
id|SCpnt-&gt;transfersize
op_assign
(paren
id|scsi_CDs
(braket
id|dev
)braket
dot
id|sector_size
OG
l_int|1024
)paren
ques
c_cond
l_int|1024
suffix:colon
id|scsi_CDs
(braket
id|dev
)braket
dot
id|sector_size
suffix:semicolon
id|SCpnt-&gt;this_count
op_assign
id|this_count
suffix:semicolon
id|scsi_do_cmd
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|cmd
comma
id|buffer
comma
id|realcount
op_star
id|scsi_CDs
(braket
id|dev
)braket
dot
id|sector_size
comma
id|rw_intr
comma
id|SR_TIMEOUT
comma
id|MAX_RETRIES
)paren
suffix:semicolon
)brace
DECL|function|sr_detect
r_static
r_int
(def_block
id|sr_detect
c_func
(paren
id|Scsi_Device
op_star
id|SDp
)paren
(brace
r_if
c_cond
(paren
id|SDp-&gt;type
op_ne
id|TYPE_ROM
op_logical_and
id|SDp-&gt;type
op_ne
id|TYPE_WORM
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Detected scsi CD-ROM sr%d at scsi%d, channel %d, id %d, lun %d&bslash;n&quot;
comma
id|sr_template.dev_noticed
op_increment
comma
id|SDp-&gt;host-&gt;host_no
comma
id|SDp-&gt;channel
comma
id|SDp-&gt;id
comma
id|SDp-&gt;lun
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)def_block
DECL|function|sr_attach
r_static
r_int
(def_block
id|sr_attach
c_func
(paren
id|Scsi_Device
op_star
id|SDp
)paren
(brace
id|Scsi_CD
op_star
id|cpnt
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|SDp-&gt;type
op_ne
id|TYPE_ROM
op_logical_and
id|SDp-&gt;type
op_ne
id|TYPE_WORM
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sr_template.nr_dev
op_ge
id|sr_template.dev_max
)paren
(brace
id|SDp-&gt;attached
op_decrement
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cpnt
op_assign
id|scsi_CDs
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sr_template.dev_max
suffix:semicolon
id|i
op_increment
comma
id|cpnt
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|cpnt-&gt;device
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ge
id|sr_template.dev_max
)paren
(brace
id|panic
(paren
l_string|&quot;scsi_devices corrupt (sr)&quot;
)paren
suffix:semicolon
)brace
id|SDp-&gt;scsi_request_fn
op_assign
id|do_sr_request
suffix:semicolon
id|scsi_CDs
(braket
id|i
)braket
dot
id|device
op_assign
id|SDp
suffix:semicolon
id|sr_template.nr_dev
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sr_template.nr_dev
OG
id|sr_template.dev_max
)paren
(brace
id|panic
(paren
l_string|&quot;scsi_devices corrupt (sr)&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)def_block
DECL|function|sr_init_done
r_static
r_void
id|sr_init_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
id|req
op_assign
op_amp
id|SCpnt-&gt;request
suffix:semicolon
id|req-&gt;rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
multiline_comment|/* Busy, but indicate request done */
r_if
c_cond
(paren
id|req-&gt;sem
op_ne
l_int|NULL
)paren
(brace
id|up
c_func
(paren
id|req-&gt;sem
)paren
suffix:semicolon
)brace
)brace
DECL|function|get_sectorsize
r_static
r_void
(def_block
id|get_sectorsize
c_func
(paren
r_int
id|i
)paren
(brace
r_int
r_char
id|cmd
(braket
l_int|10
)braket
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
r_int
id|the_result
comma
id|retries
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|buffer
op_assign
(paren
r_int
r_char
op_star
)paren
id|scsi_malloc
c_func
(paren
l_int|512
)paren
suffix:semicolon
id|SCpnt
op_assign
id|allocate_device
c_func
(paren
l_int|NULL
comma
id|scsi_CDs
(braket
id|i
)braket
dot
id|device
comma
l_int|1
)paren
suffix:semicolon
id|retries
op_assign
l_int|3
suffix:semicolon
r_do
(brace
id|cmd
(braket
l_int|0
)braket
op_assign
id|READ_CAPACITY
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
(paren
id|scsi_CDs
(braket
id|i
)braket
dot
id|device-&gt;lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|memset
(paren
(paren
r_void
op_star
)paren
op_amp
id|cmd
(braket
l_int|2
)braket
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
multiline_comment|/* Mark as really busy */
id|SCpnt-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|buffer
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Do the command and wait.. */
(brace
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
op_amp
id|sem
suffix:semicolon
id|scsi_do_cmd
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|buffer
comma
l_int|512
comma
id|sr_init_done
comma
id|SR_TIMEOUT
comma
id|MAX_RETRIES
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
)brace
id|the_result
op_assign
id|SCpnt-&gt;result
suffix:semicolon
id|retries
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|the_result
op_logical_and
id|retries
)paren
(brace
suffix:semicolon
)brace
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
multiline_comment|/* Mark as not busy */
id|wake_up
c_func
(paren
op_amp
id|SCpnt-&gt;device-&gt;device_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|the_result
)paren
(brace
id|scsi_CDs
(braket
id|i
)braket
dot
id|capacity
op_assign
l_int|0x1fffff
suffix:semicolon
id|scsi_CDs
(braket
id|i
)braket
dot
id|sector_size
op_assign
l_int|2048
suffix:semicolon
multiline_comment|/* A guess, just in case */
id|scsi_CDs
(braket
id|i
)braket
dot
id|needs_sector_size
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|scsi_CDs
(braket
id|i
)braket
dot
id|capacity
op_assign
(paren
id|buffer
(braket
l_int|0
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buffer
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buffer
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
id|buffer
(braket
l_int|3
)braket
suffix:semicolon
id|scsi_CDs
(braket
id|i
)braket
dot
id|sector_size
op_assign
(paren
id|buffer
(braket
l_int|4
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buffer
(braket
l_int|5
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buffer
(braket
l_int|6
)braket
op_lshift
l_int|8
)paren
op_or
id|buffer
(braket
l_int|7
)braket
suffix:semicolon
r_if
c_cond
(paren
id|scsi_CDs
(braket
id|i
)braket
dot
id|sector_size
op_eq
l_int|0
)paren
(brace
id|scsi_CDs
(braket
id|i
)braket
dot
id|sector_size
op_assign
l_int|2048
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsi_CDs
(braket
id|i
)braket
dot
id|sector_size
op_ne
l_int|2048
op_logical_and
id|scsi_CDs
(braket
id|i
)braket
dot
id|sector_size
op_ne
l_int|512
)paren
(brace
id|printk
(paren
l_string|&quot;scd%d : unsupported sector size %d.&bslash;n&quot;
comma
id|i
comma
id|scsi_CDs
(braket
id|i
)braket
dot
id|sector_size
)paren
suffix:semicolon
id|scsi_CDs
(braket
id|i
)braket
dot
id|capacity
op_assign
l_int|0
suffix:semicolon
id|scsi_CDs
(braket
id|i
)braket
dot
id|needs_sector_size
op_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|scsi_CDs
(braket
id|i
)braket
dot
id|sector_size
op_eq
l_int|2048
)paren
(brace
id|scsi_CDs
(braket
id|i
)braket
dot
id|capacity
op_mul_assign
l_int|4
suffix:semicolon
)brace
id|scsi_CDs
(braket
id|i
)braket
dot
id|needs_sector_size
op_assign
l_int|0
suffix:semicolon
id|sr_sizes
(braket
id|i
)braket
op_assign
id|scsi_CDs
(braket
id|i
)braket
dot
id|capacity
suffix:semicolon
)brace
suffix:semicolon
id|scsi_free
c_func
(paren
id|buffer
comma
l_int|512
)paren
suffix:semicolon
)brace
)def_block
DECL|variable|sr_registered
r_static
r_int
id|sr_registered
op_assign
l_int|0
suffix:semicolon
DECL|function|sr_init
r_static
r_int
id|sr_init
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|sr_template.dev_noticed
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sr_registered
)paren
(brace
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;sr&quot;
comma
op_amp
id|sr_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to get major %d for SCSI-CD&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|sr_registered
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsi_CDs
)paren
r_return
l_int|0
suffix:semicolon
id|sr_template.dev_max
op_assign
id|sr_template.dev_noticed
op_plus
id|SR_EXTRA_DEVS
suffix:semicolon
id|scsi_CDs
op_assign
(paren
id|Scsi_CD
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|sr_template.dev_max
op_star
r_sizeof
(paren
id|Scsi_CD
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|memset
c_func
(paren
id|scsi_CDs
comma
l_int|0
comma
id|sr_template.dev_max
op_star
r_sizeof
(paren
id|Scsi_CD
)paren
)paren
suffix:semicolon
id|sr_sizes
op_assign
(paren
r_int
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|sr_template.dev_max
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|memset
c_func
(paren
id|sr_sizes
comma
l_int|0
comma
id|sr_template.dev_max
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|sr_blocksizes
op_assign
(paren
r_int
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|sr_template.dev_max
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sr_template.dev_max
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sr_blocksizes
(braket
id|i
)braket
op_assign
l_int|2048
suffix:semicolon
)brace
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|sr_blocksizes
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sr_finish
r_void
id|sr_finish
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
id|sr_sizes
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sr_template.nr_dev
suffix:semicolon
op_increment
id|i
)paren
(brace
multiline_comment|/* If we have already seen this, then skip it.  Comes up&n;&t; * with loadable modules. */
r_if
c_cond
(paren
id|scsi_CDs
(braket
id|i
)braket
dot
id|capacity
)paren
r_continue
suffix:semicolon
id|scsi_CDs
(braket
id|i
)braket
dot
id|capacity
op_assign
l_int|0x1fffff
suffix:semicolon
id|scsi_CDs
(braket
id|i
)braket
dot
id|sector_size
op_assign
l_int|2048
suffix:semicolon
multiline_comment|/* A guess, just in case */
id|scsi_CDs
(braket
id|i
)braket
dot
id|needs_sector_size
op_assign
l_int|1
suffix:semicolon
macro_line|#if 0
multiline_comment|/* seems better to leave this for later */
id|get_sectorsize
c_func
(paren
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Scd sectorsize = %d bytes.&bslash;n&quot;
comma
id|scsi_CDs
(braket
id|i
)braket
dot
id|sector_size
)paren
suffix:semicolon
macro_line|#endif
id|scsi_CDs
(braket
id|i
)braket
dot
id|use
op_assign
l_int|1
suffix:semicolon
id|scsi_CDs
(braket
id|i
)braket
dot
id|ten
op_assign
l_int|1
suffix:semicolon
id|scsi_CDs
(braket
id|i
)braket
dot
id|remap
op_assign
l_int|1
suffix:semicolon
id|scsi_CDs
(braket
id|i
)braket
dot
id|auto_eject
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Default is not to eject upon unmount. */
id|sr_sizes
(braket
id|i
)braket
op_assign
id|scsi_CDs
(braket
id|i
)braket
dot
id|capacity
suffix:semicolon
)brace
multiline_comment|/* If our host adapter is capable of scatter-gather, then we increase&n;&t; * the read-ahead to 16 blocks (32 sectors).  If not, we use&n;&t; * a two block (4 sector) read ahead. */
r_if
c_cond
(paren
id|scsi_CDs
(braket
l_int|0
)braket
dot
id|device
op_logical_and
id|scsi_CDs
(braket
l_int|0
)braket
dot
id|device-&gt;host-&gt;sg_tablesize
)paren
(brace
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|32
suffix:semicolon
)brace
multiline_comment|/* 32 sector read-ahead.  Always removable. */
r_else
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* 4 sector read-ahead */
r_return
suffix:semicolon
)brace
DECL|function|sr_detach
r_static
r_void
id|sr_detach
c_func
(paren
id|Scsi_Device
op_star
id|SDp
)paren
(brace
id|Scsi_CD
op_star
id|cpnt
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|cpnt
op_assign
id|scsi_CDs
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sr_template.dev_max
suffix:semicolon
id|i
op_increment
comma
id|cpnt
op_increment
)paren
r_if
c_cond
(paren
id|cpnt-&gt;device
op_eq
id|SDp
)paren
(brace
id|kdev_t
id|devi
op_assign
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|i
)paren
suffix:semicolon
multiline_comment|/*&n;&t;     * Since the cdrom is read-only, no need to sync the device.&n;&t;     * We should be kind to our buffer cache, however.&n;&t;     */
id|invalidate_inodes
c_func
(paren
id|devi
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|devi
)paren
suffix:semicolon
multiline_comment|/*&n;&t;     * Reset things back to a sane state so that one can re-load a new&n;&t;     * driver (perhaps the same one).&n;&t;     */
id|cpnt-&gt;device
op_assign
l_int|NULL
suffix:semicolon
id|cpnt-&gt;capacity
op_assign
l_int|0
suffix:semicolon
id|SDp-&gt;attached
op_decrement
suffix:semicolon
id|sr_template.nr_dev
op_decrement
suffix:semicolon
id|sr_template.dev_noticed
op_decrement
suffix:semicolon
id|sr_sizes
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
DECL|variable|kernel_version
r_char
id|kernel_version
(braket
)braket
op_assign
id|UTS_RELEASE
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
id|sr_template.usage_count
op_assign
op_amp
id|mod_use_count_
suffix:semicolon
r_return
id|scsi_register_module
c_func
(paren
id|MODULE_SCSI_DEV
comma
op_amp
id|sr_template
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|MOD_IN_USE
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|__FILE__
l_string|&quot;: module is in use, remove rejected&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|scsi_unregister_module
c_func
(paren
id|MODULE_SCSI_DEV
comma
op_amp
id|sr_template
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|SCSI_CDROM_MAJOR
comma
l_string|&quot;sr&quot;
)paren
suffix:semicolon
id|sr_registered
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|scsi_CDs
op_ne
l_int|NULL
)paren
(brace
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|scsi_CDs
comma
(paren
id|sr_template.dev_noticed
op_plus
id|SR_EXTRA_DEVS
)paren
op_star
r_sizeof
(paren
id|Scsi_CD
)paren
)paren
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|sr_sizes
comma
id|sr_template.dev_max
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|sr_blocksizes
comma
id|sr_template.dev_max
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
)brace
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
l_int|NULL
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
l_int|NULL
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
l_int|NULL
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|0
suffix:semicolon
id|sr_template.dev_max
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: nil&n; * tab-width: 8&n; * End:&n; */
eof
