multiline_comment|/* Copyright(c) 2000, Compaq Computer Corporation &n; * Fibre Channel Host Bus Adapter &n; * 64-bit, 66MHz PCI &n; * Originally developed and tested on:&n; * (front): [chip] Tachyon TS HPFC-5166A/1.2  L2C1090 ...&n; *          SP# P225CXCBFIEL6T, Rev XC&n; *          SP# 161290-001, Rev XD&n; * (back): Board No. 010008-001 A/W Rev X5, FAB REV X5&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; * Written by Don Zimmerman&n;*/
singleline_comment|// These functions control the NVRAM I2C hardware on 
singleline_comment|// non-intelligent Fibre Host Adapters.
singleline_comment|// The primary purpose is to read the HBA&squot;s NVRAM to get adapter&squot;s 
singleline_comment|// manufactured WWN to copy into Tachyon chip registers
singleline_comment|// Orignal source author unknown
macro_line|#include &lt;linux/types.h&gt;
DECL|enum|boolean
DECL|enumerator|FALSE
DECL|enumerator|TRUE
r_enum
id|boolean
(brace
id|FALSE
comma
id|TRUE
)brace
suffix:semicolon
macro_line|#ifndef UCHAR
DECL|typedef|UCHAR
r_typedef
id|__u8
id|UCHAR
suffix:semicolon
macro_line|#endif
macro_line|#ifndef BOOLEAN
DECL|typedef|BOOLEAN
r_typedef
id|__u8
id|BOOLEAN
suffix:semicolon
macro_line|#endif
macro_line|#ifndef USHORT
DECL|typedef|USHORT
r_typedef
id|__u16
id|USHORT
suffix:semicolon
macro_line|#endif
macro_line|#ifndef ULONG
DECL|typedef|ULONG
r_typedef
id|__u32
id|ULONG
suffix:semicolon
macro_line|#endif
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/io.h&gt;  
singleline_comment|// struct pt_regs for IRQ handler &amp; Port I/O
macro_line|#include &quot;cpqfcTSchip.h&quot;
r_static
r_void
id|tl_i2c_tx_byte
c_func
(paren
r_void
op_star
id|GPIOout
comma
id|UCHAR
id|data
)paren
suffix:semicolon
multiline_comment|/*static BOOLEAN tl_write_i2c_page_portion( void* GPIOin, void* GPIOout,&n;  USHORT startOffset,  // e.g. 0x2f for WWN start&n;  USHORT count,&n;  UCHAR *buf );&n;*/
singleline_comment|//
singleline_comment|// Tachlite GPIO2, GPIO3 (I2C) DEFINES
singleline_comment|// The NVRAM chip NM24C03 defines SCL (serial clock) and SDA (serial data)
singleline_comment|// GPIO2 drives SDA, and GPIO3 drives SCL
singleline_comment|// 
singleline_comment|// Since Tachlite inverts the state of the GPIO 0-3 outputs, SET writes 0
singleline_comment|// and clear writes 1. The input lines (read in TL status) is NOT inverted
singleline_comment|// This really helps confuse the code and debugging.
DECL|macro|SET_DATA_HI
mdefine_line|#define SET_DATA_HI  0x0
DECL|macro|SET_DATA_LO
mdefine_line|#define SET_DATA_LO  0x8
DECL|macro|SET_CLOCK_HI
mdefine_line|#define SET_CLOCK_HI 0x0
DECL|macro|SET_CLOCK_LO
mdefine_line|#define SET_CLOCK_LO 0x4
DECL|macro|SENSE_DATA_HI
mdefine_line|#define SENSE_DATA_HI  0x8
DECL|macro|SENSE_DATA_LO
mdefine_line|#define SENSE_DATA_LO  0x0
DECL|macro|SENSE_CLOCK_HI
mdefine_line|#define SENSE_CLOCK_HI 0x4
DECL|macro|SENSE_CLOCK_LO
mdefine_line|#define SENSE_CLOCK_LO 0x0
DECL|macro|SLAVE_READ_ADDRESS
mdefine_line|#define SLAVE_READ_ADDRESS    0xA1
DECL|macro|SLAVE_WRITE_ADDRESS
mdefine_line|#define SLAVE_WRITE_ADDRESS   0xA0
r_static
r_void
id|i2c_delay
c_func
(paren
id|ULONG
id|mstime
)paren
suffix:semicolon
r_static
r_void
id|tl_i2c_clock_pulse
c_func
(paren
id|UCHAR
comma
r_void
op_star
id|GPIOout
)paren
suffix:semicolon
r_static
id|UCHAR
id|tl_read_i2c_data
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
singleline_comment|//-----------------------------------------------------------------------------
singleline_comment|//
singleline_comment|//      Name:   I2C_RX_ACK
singleline_comment|//
singleline_comment|//      This routine receives an acknowledge over the I2C bus.
singleline_comment|//
singleline_comment|//-----------------------------------------------------------------------------
DECL|function|tl_i2c_rx_ack
r_static
r_int
r_int
id|tl_i2c_rx_ack
c_func
(paren
r_void
op_star
id|GPIOin
comma
r_void
op_star
id|GPIOout
)paren
(brace
r_int
r_int
id|value
suffix:semicolon
singleline_comment|// do clock pulse, let data line float high
id|tl_i2c_clock_pulse
c_func
(paren
id|SET_DATA_HI
comma
id|GPIOout
)paren
suffix:semicolon
singleline_comment|// slave must drive data low for acknowledge
id|value
op_assign
id|tl_read_i2c_data
c_func
(paren
id|GPIOin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_amp
id|SENSE_DATA_HI
)paren
r_return
id|FALSE
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
singleline_comment|//-----------------------------------------------------------------------------
singleline_comment|//
singleline_comment|//      Name:   READ_I2C_REG
singleline_comment|//
singleline_comment|//      This routine reads the I2C control register using the global
singleline_comment|//      IO address stored in gpioreg.
singleline_comment|//
singleline_comment|//-----------------------------------------------------------------------------
DECL|function|tl_read_i2c_data
r_static
id|UCHAR
id|tl_read_i2c_data
c_func
(paren
r_void
op_star
id|gpioreg
)paren
(brace
r_return
(paren
id|UCHAR
)paren
(paren
id|readl
c_func
(paren
id|gpioreg
)paren
op_amp
l_int|0x08L
)paren
suffix:semicolon
singleline_comment|// GPIO3
)brace
singleline_comment|//-----------------------------------------------------------------------------
singleline_comment|//
singleline_comment|//      Name:   WRITE_I2C_REG
singleline_comment|//
singleline_comment|//      This routine writes the I2C control register using the global
singleline_comment|//      IO address stored in gpioreg.
singleline_comment|//      In Tachlite, we don&squot;t want to modify other bits in TL Control reg.
singleline_comment|//
singleline_comment|//-----------------------------------------------------------------------------
DECL|function|tl_write_i2c_reg
r_static
r_void
id|tl_write_i2c_reg
c_func
(paren
r_void
op_star
id|gpioregOUT
comma
id|UCHAR
id|value
)paren
(brace
id|ULONG
id|temp
suffix:semicolon
singleline_comment|// First read the register and clear out the old bits
id|temp
op_assign
id|readl
c_func
(paren
id|gpioregOUT
)paren
op_amp
l_int|0xfffffff3L
suffix:semicolon
singleline_comment|// Now or in the new data and send it back out
id|writel
c_func
(paren
id|temp
op_or
id|value
comma
id|gpioregOUT
)paren
suffix:semicolon
)brace
singleline_comment|//-----------------------------------------------------------------------------
singleline_comment|//
singleline_comment|//      Name:   I2C_TX_START
singleline_comment|//
singleline_comment|//      This routine transmits a start condition over the I2C bus.
singleline_comment|//      1. Set SCL (clock, GPIO2) HIGH, set SDA (data, GPIO3) HIGH,
singleline_comment|//      wait 5us to stabilize.
singleline_comment|//      2. With SCL still HIGH, drive SDA low.  The low transition marks
singleline_comment|//         the start condition to NM24Cxx (the chip)
singleline_comment|//      NOTE! In TL control reg., output 1 means chip sees LOW
singleline_comment|//
singleline_comment|//-----------------------------------------------------------------------------
DECL|function|tl_i2c_tx_start
r_static
r_int
r_int
id|tl_i2c_tx_start
c_func
(paren
r_void
op_star
id|GPIOin
comma
r_void
op_star
id|GPIOout
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|ULONG
id|value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tl_read_i2c_data
c_func
(paren
id|GPIOin
)paren
op_amp
id|SENSE_DATA_HI
)paren
)paren
(brace
singleline_comment|// start with clock high, let data float high
id|tl_write_i2c_reg
c_func
(paren
id|GPIOout
comma
id|SET_DATA_HI
op_or
id|SET_CLOCK_HI
)paren
suffix:semicolon
singleline_comment|// keep sending clock pulses if slave is driving data line
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tl_i2c_clock_pulse
c_func
(paren
id|SET_DATA_HI
comma
id|GPIOout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tl_read_i2c_data
c_func
(paren
id|GPIOin
)paren
op_amp
id|SENSE_DATA_HI
)paren
r_break
suffix:semicolon
)brace
singleline_comment|// if he&squot;s still driving data low after 10 clocks, abort
id|value
op_assign
id|tl_read_i2c_data
c_func
(paren
id|GPIOin
)paren
suffix:semicolon
singleline_comment|// read status
r_if
c_cond
(paren
op_logical_neg
(paren
id|value
op_amp
l_int|0x08
)paren
)paren
r_return
id|FALSE
suffix:semicolon
)brace
singleline_comment|// To START, bring data low while clock high
id|tl_write_i2c_reg
c_func
(paren
id|GPIOout
comma
id|SET_CLOCK_HI
op_or
id|SET_DATA_LO
)paren
suffix:semicolon
id|i2c_delay
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
singleline_comment|// TX start successful
)brace
singleline_comment|//-----------------------------------------------------------------------------
singleline_comment|//
singleline_comment|//      Name:   I2C_TX_STOP
singleline_comment|//
singleline_comment|//      This routine transmits a stop condition over the I2C bus.
singleline_comment|//
singleline_comment|//-----------------------------------------------------------------------------
DECL|function|tl_i2c_tx_stop
r_static
r_int
r_int
id|tl_i2c_tx_stop
c_func
(paren
r_void
op_star
id|GPIOin
comma
r_void
op_star
id|GPIOout
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
singleline_comment|// Send clock pulse, drive data line low
id|tl_i2c_clock_pulse
c_func
(paren
id|SET_DATA_LO
comma
id|GPIOout
)paren
suffix:semicolon
singleline_comment|// To STOP, bring data high while clock high
id|tl_write_i2c_reg
c_func
(paren
id|GPIOout
comma
id|SET_DATA_HI
op_or
id|SET_CLOCK_HI
)paren
suffix:semicolon
singleline_comment|// Give the data line time to float high
id|i2c_delay
c_func
(paren
l_int|0
)paren
suffix:semicolon
singleline_comment|// If slave is driving data line low, there&squot;s a problem; retry
r_if
c_cond
(paren
id|tl_read_i2c_data
c_func
(paren
id|GPIOin
)paren
op_amp
id|SENSE_DATA_HI
)paren
r_return
id|TRUE
suffix:semicolon
singleline_comment|// TX STOP successful!
)brace
r_return
id|FALSE
suffix:semicolon
singleline_comment|// error
)brace
singleline_comment|//-----------------------------------------------------------------------------
singleline_comment|//
singleline_comment|//      Name:   I2C_TX_uchar
singleline_comment|//
singleline_comment|//      This routine transmits a byte across the I2C bus.
singleline_comment|//
singleline_comment|//-----------------------------------------------------------------------------
DECL|function|tl_i2c_tx_byte
r_static
r_void
id|tl_i2c_tx_byte
c_func
(paren
r_void
op_star
id|GPIOout
comma
id|UCHAR
id|data
)paren
(brace
id|UCHAR
id|bit
suffix:semicolon
r_for
c_loop
(paren
id|bit
op_assign
l_int|0x80
suffix:semicolon
id|bit
suffix:semicolon
id|bit
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|data
op_amp
id|bit
)paren
(brace
id|tl_i2c_clock_pulse
c_func
(paren
(paren
id|UCHAR
)paren
id|SET_DATA_HI
comma
id|GPIOout
)paren
suffix:semicolon
)brace
r_else
id|tl_i2c_clock_pulse
c_func
(paren
(paren
id|UCHAR
)paren
id|SET_DATA_LO
comma
id|GPIOout
)paren
suffix:semicolon
)brace
)brace
singleline_comment|//-----------------------------------------------------------------------------
singleline_comment|//
singleline_comment|//      Name:   I2C_RX_uchar
singleline_comment|//
singleline_comment|//      This routine receives a byte across the I2C bus.
singleline_comment|//
singleline_comment|//-----------------------------------------------------------------------------
DECL|function|tl_i2c_rx_byte
r_static
id|UCHAR
id|tl_i2c_rx_byte
c_func
(paren
r_void
op_star
id|GPIOin
comma
r_void
op_star
id|GPIOout
)paren
(brace
id|UCHAR
id|bit
suffix:semicolon
id|UCHAR
id|data
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|bit
op_assign
l_int|0x80
suffix:semicolon
id|bit
suffix:semicolon
id|bit
op_rshift_assign
l_int|1
)paren
(brace
singleline_comment|// do clock pulse, let data line float high
id|tl_i2c_clock_pulse
c_func
(paren
id|SET_DATA_HI
comma
id|GPIOout
)paren
suffix:semicolon
singleline_comment|// read data line
r_if
c_cond
(paren
id|tl_read_i2c_data
c_func
(paren
id|GPIOin
)paren
op_amp
l_int|0x08
)paren
id|data
op_or_assign
id|bit
suffix:semicolon
)brace
r_return
(paren
id|data
)paren
suffix:semicolon
)brace
singleline_comment|//*****************************************************************************
singleline_comment|//*****************************************************************************
singleline_comment|// Function:   read_i2c_nvram
singleline_comment|// Arguments:  UCHAR count     number of bytes to read
singleline_comment|//             UCHAR *buf      area to store the bytes read
singleline_comment|// Returns:    0 - failed
singleline_comment|//             1 - success
singleline_comment|//*****************************************************************************
singleline_comment|//*****************************************************************************
DECL|function|cpqfcTS_ReadNVRAM
r_int
r_int
id|cpqfcTS_ReadNVRAM
c_func
(paren
r_void
op_star
id|GPIOin
comma
r_void
op_star
id|GPIOout
comma
id|USHORT
id|count
comma
id|UCHAR
op_star
id|buf
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tl_i2c_tx_start
c_func
(paren
id|GPIOin
comma
id|GPIOout
)paren
)paren
)paren
(brace
r_return
id|FALSE
suffix:semicolon
)brace
singleline_comment|// Select the NVRAM for &quot;dummy&quot; write, to set the address
id|tl_i2c_tx_byte
c_func
(paren
id|GPIOout
comma
id|SLAVE_WRITE_ADDRESS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tl_i2c_rx_ack
c_func
(paren
id|GPIOin
comma
id|GPIOout
)paren
)paren
r_return
id|FALSE
suffix:semicolon
singleline_comment|// Now send the address where we want to start reading  
id|tl_i2c_tx_byte
c_func
(paren
id|GPIOout
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tl_i2c_rx_ack
c_func
(paren
id|GPIOin
comma
id|GPIOout
)paren
)paren
r_return
id|FALSE
suffix:semicolon
singleline_comment|// Send a repeated start condition and select the
singleline_comment|//  slave for reading now.
r_if
c_cond
(paren
id|tl_i2c_tx_start
c_func
(paren
id|GPIOin
comma
id|GPIOout
)paren
)paren
(brace
id|tl_i2c_tx_byte
c_func
(paren
id|GPIOout
comma
id|SLAVE_READ_ADDRESS
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tl_i2c_rx_ack
c_func
(paren
id|GPIOin
comma
id|GPIOout
)paren
)paren
r_return
id|FALSE
suffix:semicolon
singleline_comment|// this loop will now read out the data and store it
singleline_comment|//  in the buffer pointed to by buf
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|buf
op_increment
op_assign
id|tl_i2c_rx_byte
c_func
(paren
id|GPIOin
comma
id|GPIOout
)paren
suffix:semicolon
singleline_comment|// Send ACK by holding data line low for 1 clock
r_if
c_cond
(paren
id|i
OL
(paren
id|count
op_minus
l_int|1
)paren
)paren
id|tl_i2c_clock_pulse
c_func
(paren
l_int|0x08
comma
id|GPIOout
)paren
suffix:semicolon
r_else
(brace
singleline_comment|// Don&squot;t send ack for final byte
id|tl_i2c_clock_pulse
c_func
(paren
id|SET_DATA_HI
comma
id|GPIOout
)paren
suffix:semicolon
)brace
)brace
id|tl_i2c_tx_stop
c_func
(paren
id|GPIOin
comma
id|GPIOout
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
singleline_comment|//****************************************************************
singleline_comment|//
singleline_comment|//
singleline_comment|//
singleline_comment|// routines to set and clear the data and clock bits
singleline_comment|//
singleline_comment|//
singleline_comment|//
singleline_comment|//****************************************************************
DECL|function|tl_set_clock
r_static
r_void
id|tl_set_clock
c_func
(paren
r_void
op_star
id|gpioreg
)paren
(brace
id|ULONG
id|ret_val
suffix:semicolon
id|ret_val
op_assign
id|readl
c_func
(paren
id|gpioreg
)paren
suffix:semicolon
id|ret_val
op_and_assign
l_int|0xffffffFBL
suffix:semicolon
singleline_comment|// clear GPIO2 (SCL)
id|writel
c_func
(paren
id|ret_val
comma
id|gpioreg
)paren
suffix:semicolon
)brace
DECL|function|tl_clr_clock
r_static
r_void
id|tl_clr_clock
c_func
(paren
r_void
op_star
id|gpioreg
)paren
(brace
id|ULONG
id|ret_val
suffix:semicolon
id|ret_val
op_assign
id|readl
c_func
(paren
id|gpioreg
)paren
suffix:semicolon
id|ret_val
op_or_assign
id|SET_CLOCK_LO
suffix:semicolon
id|writel
c_func
(paren
id|ret_val
comma
id|gpioreg
)paren
suffix:semicolon
)brace
singleline_comment|//*****************************************************************
singleline_comment|//
singleline_comment|//
singleline_comment|// This routine will advance the clock by one period
singleline_comment|//
singleline_comment|//
singleline_comment|//*****************************************************************
DECL|function|tl_i2c_clock_pulse
r_static
r_void
id|tl_i2c_clock_pulse
c_func
(paren
id|UCHAR
id|value
comma
r_void
op_star
id|GPIOout
)paren
(brace
id|ULONG
id|ret_val
suffix:semicolon
singleline_comment|// clear the clock bit
id|tl_clr_clock
c_func
(paren
id|GPIOout
)paren
suffix:semicolon
id|i2c_delay
c_func
(paren
l_int|0
)paren
suffix:semicolon
singleline_comment|// read the port to preserve non-I2C bits
id|ret_val
op_assign
id|readl
c_func
(paren
id|GPIOout
)paren
suffix:semicolon
singleline_comment|// clear the data &amp; clock bits
id|ret_val
op_and_assign
l_int|0xFFFFFFf3
suffix:semicolon
singleline_comment|// write the value passed in...
singleline_comment|// data can only change while clock is LOW!
id|ret_val
op_or_assign
id|value
suffix:semicolon
singleline_comment|// the data
id|ret_val
op_or_assign
id|SET_CLOCK_LO
suffix:semicolon
singleline_comment|// the clock
id|writel
c_func
(paren
id|ret_val
comma
id|GPIOout
)paren
suffix:semicolon
id|i2c_delay
c_func
(paren
l_int|0
)paren
suffix:semicolon
singleline_comment|//set clock bit
id|tl_set_clock
c_func
(paren
id|GPIOout
)paren
suffix:semicolon
)brace
singleline_comment|//*****************************************************************
singleline_comment|//
singleline_comment|//
singleline_comment|// This routine returns the 64-bit WWN
singleline_comment|//
singleline_comment|//
singleline_comment|//*****************************************************************
DECL|function|cpqfcTS_GetNVRAM_data
r_int
id|cpqfcTS_GetNVRAM_data
c_func
(paren
id|UCHAR
op_star
id|wwnbuf
comma
id|UCHAR
op_star
id|buf
)paren
(brace
id|ULONG
id|len
suffix:semicolon
id|ULONG
id|sub_len
suffix:semicolon
id|ULONG
id|ptr_inc
suffix:semicolon
id|ULONG
id|i
suffix:semicolon
id|ULONG
id|j
suffix:semicolon
id|UCHAR
op_star
id|data_ptr
suffix:semicolon
id|UCHAR
id|z
suffix:semicolon
id|UCHAR
id|name
suffix:semicolon
id|UCHAR
id|sub_name
suffix:semicolon
id|UCHAR
id|done
suffix:semicolon
r_int
id|iReturn
op_assign
l_int|0
suffix:semicolon
singleline_comment|// def. 0 offset is failure to find WWN field
id|data_ptr
op_assign
(paren
id|UCHAR
op_star
)paren
id|buf
suffix:semicolon
id|done
op_assign
id|FALSE
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i
OL
l_int|128
)paren
op_logical_and
(paren
op_logical_neg
id|done
)paren
)paren
(brace
id|z
op_assign
id|data_ptr
(braket
id|i
)braket
suffix:semicolon
"&bslash;"
r_if
c_cond
(paren
op_logical_neg
(paren
id|z
op_amp
l_int|0x80
)paren
)paren
(brace
id|len
op_assign
l_int|1
op_plus
(paren
id|z
op_amp
l_int|0x07
)paren
suffix:semicolon
id|name
op_assign
(paren
id|z
op_amp
l_int|0x78
)paren
op_rshift
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|name
op_eq
l_int|0x0F
)paren
id|done
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
id|name
op_assign
id|z
op_amp
l_int|0x7F
suffix:semicolon
id|len
op_assign
l_int|3
op_plus
id|data_ptr
(braket
id|i
op_plus
l_int|1
)braket
op_plus
(paren
id|data_ptr
(braket
id|i
op_plus
l_int|2
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|name
)paren
(brace
r_case
l_int|0x0D
suffix:colon
singleline_comment|//
id|j
op_assign
id|i
op_plus
l_int|3
suffix:semicolon
singleline_comment|//
r_if
c_cond
(paren
id|data_ptr
(braket
id|j
)braket
op_eq
l_int|0x3b
)paren
(brace
id|len
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|j
OL
(paren
id|i
op_plus
id|len
)paren
)paren
(brace
id|sub_name
op_assign
(paren
id|data_ptr
(braket
id|j
)braket
op_amp
l_int|0x3f
)paren
suffix:semicolon
id|sub_len
op_assign
id|data_ptr
(braket
id|j
op_plus
l_int|1
)braket
op_plus
(paren
id|data_ptr
(braket
id|j
op_plus
l_int|2
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
id|ptr_inc
op_assign
id|sub_len
op_plus
l_int|3
suffix:semicolon
r_switch
c_cond
(paren
id|sub_name
)paren
(brace
r_case
l_int|0x3C
suffix:colon
id|memcpy
c_func
(paren
id|wwnbuf
comma
op_amp
id|data_ptr
(braket
id|j
op_plus
l_int|3
)braket
comma
l_int|8
)paren
suffix:semicolon
id|iReturn
op_assign
id|j
op_plus
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|j
op_add_assign
id|ptr_inc
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
singleline_comment|//
id|i
op_add_assign
id|len
suffix:semicolon
)brace
singleline_comment|// end while 
r_return
id|iReturn
suffix:semicolon
)brace
singleline_comment|// define a short 5 micro sec delay, and longer (ms) delay
DECL|function|i2c_delay
r_static
r_void
id|i2c_delay
c_func
(paren
id|ULONG
id|mstime
)paren
(brace
id|ULONG
id|i
suffix:semicolon
singleline_comment|// NOTE: we only expect to use these delays when reading
singleline_comment|// our adapter&squot;s NVRAM, which happens only during adapter reset.
singleline_comment|// Delay technique from &quot;Linux Device Drivers&quot;, A. Rubini 
singleline_comment|// (1st Ed.) pg 137.
singleline_comment|//  printk(&quot; delay %lx  &quot;, mstime);
r_if
c_cond
(paren
id|mstime
)paren
singleline_comment|// ms delay?
(brace
singleline_comment|// delay technique
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mstime
suffix:semicolon
id|i
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
singleline_comment|// 1ms per loop
)brace
r_else
singleline_comment|// 5 micro sec delay
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
singleline_comment|// micro secs
singleline_comment|//  printk(&quot;done&bslash;n&quot;);
)brace
eof
