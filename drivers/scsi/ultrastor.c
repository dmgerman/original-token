multiline_comment|/*&n; *&t;ultrastor.c&t;Copyright (C) 1992 David B. Gentzel&n; *&t;Low-level SCSI driver for UltraStor 14F, 24F, and 34F&n; *&t;by David B. Gentzel, Whitfield Software Services, Carnegie, PA&n; *&t;    (gentzel@nova.enet.dec.com)&n; *  scatter/gather added by Scott Taylor (n217cg@tamuts.tamu.edu)&n; *  24F and multiple command support by John F. Carr (jfc@athena.mit.edu)&n; *    John&squot;s work modified by Caleb Epstein (cae@jpmorgan.com) and &n; *    Eric Youngdale (ericy@cais.com).&n; *&t;Thanks to UltraStor for providing the necessary documentation&n; */
multiline_comment|/*&n; * TODO:&n; *&t;1. Find out why scatter/gather is limited to 16 requests per command.&n; *         This is fixed, at least on the 24F, as of version 1.12 - CAE.&n; *&t;2. Look at command linking (mscp.command_link and&n; *&t;   mscp.command_link_id).  (Does not work with many disks, &n; *&t;&t;&t;&t;and no performance increase.  ERY).&n; *&t;3. Allow multiple adapters.&n; */
multiline_comment|/*&n; * NOTES:&n; *    The UltraStor 14F, 24F, and 34F are a family of intelligent, high&n; *    performance SCSI-2 host adapters.  They all support command queueing&n; *    and scatter/gather I/O.  Some of them can also emulate the standard&n; *    WD1003 interface for use with OS&squot;s which don&squot;t support SCSI.  Here&n; *    is the scoop on the various models:&n; *&t;14F - ISA first-party DMA HA with floppy support and WD1003 emulation.&n; *&t;14N - ISA HA with floppy support.  I think that this is a non-DMA&n; *&t;      HA.  Nothing further known.&n; *&t;24F - EISA Bus Master HA with floppy support and WD1003 emulation.&n; *&t;34F - VL-Bus Bus Master HA with floppy support (no WD1003 emulation).&n; *&n; *    The 14F, 24F, and 34F are supported by this driver.&n; *&n; *    Places flagged with a triple question-mark are things which are either&n; *    unfinished, questionable, or wrong.&n; */
multiline_comment|/* Changes from version 1.11 alpha to 1.12&n; *&n; * Increased the size of the scatter-gather list to 33 entries for&n; * the 24F adapter (it was 16).  I don&squot;t have the specs for the 14F&n; * or the 34F, so they may support larger s-g lists as well.&n; *&n; * Caleb Epstein &lt;cae@jpmorgan.com&gt;&n; */
multiline_comment|/* Changes from version 1.9 to 1.11&n; *&n; * Patches to bring this driver up to speed with the default kernel&n; * driver which supports only the 14F and 34F adapters.  This version&n; * should compile cleanly into 0.99.13, 0.99.12 and probably 0.99.11.&n; *&n; * Fixes from Eric Youngdale to fix a few possible race conditions and&n; * several problems with bit testing operations (insufficient&n; * parentheses).&n; *&n; * Removed the ultrastor_abort() and ultrastor_reset() functions&n; * (enclosed them in #if 0 / #endif).  These functions, at least on&n; * the 24F, cause the SCSI bus to do odd things and generally lead to&n; * kernel panics and machine hangs.  This is like the Adaptec code.&n; *&n; * Use check/snarf_region for 14f, 34f to avoid I/O space address conflicts.&n; */
multiline_comment|/* Changes from version 1.8 to version 1.9&n; *&n; *  0.99.11 patches (cae@jpmorgan.com) */
multiline_comment|/* Changes from version 1.7 to version 1.8&n; *&n; * Better error reporting.&n; */
multiline_comment|/* Changes from version 1.6 to version 1.7&n; *&n; * Removed CSIR command code.&n; *&n; * Better race condition avoidance (xchgb function added).&n; *&n; * Set ICM and OGM status to zero at probe (24F)&n; *&n; * reset sends soft reset to UltraStor adapter&n; *&n; * reset adapter if adapter interrupts with an invalid MSCP address&n; *&n; * handle aborted command interrupt (24F)&n; *&n; */
multiline_comment|/* Changes from version 1.5 to version 1.6:&n; *&n; * Read MSCP address from ICM _before_ clearing the interrupt flag.&n; * This fixes a race condition.&n; */
multiline_comment|/* Changes from version 1.4 to version 1.5:&n; *&n; * Abort now calls done when multiple commands are enabled.&n; *&n; * Clear busy when aborted command finishes, not when abort is called.&n; *&n; * More debugging messages for aborts.&n; */
multiline_comment|/* Changes from version 1.3 to version 1.4:&n; *&n; * Enable automatic request of sense data on error (requires newer version&n; * of scsi.c to be useful).&n; *&n; * Fix PORT_OVERRIDE for 14F.&n; *&n; * Fix abort and reset to work properly (config.aborted wasn&squot;t cleared&n; * after it was tested, so after a command abort no further commands would&n; * work).&n; *&n; * Boot time test to enable SCSI bus reset (defaults to not allowing reset).&n; *&n; * Fix test for OGM busy -- the busy bit is in different places on the 24F.&n; *&n; * Release ICM slot by clearing first byte on 24F.&n; */
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
DECL|macro|ULTRASTOR_PRIVATE
mdefine_line|#define ULTRASTOR_PRIVATE&t;/* Get the private stuff from ultrastor.h */
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;ultrastor.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include&lt;linux/stat.h&gt;
DECL|macro|FALSE
mdefine_line|#define FALSE 0
DECL|macro|TRUE
mdefine_line|#define TRUE 1
macro_line|#ifndef ULTRASTOR_DEBUG
DECL|macro|ULTRASTOR_DEBUG
mdefine_line|#define ULTRASTOR_DEBUG (UD_ABORT|UD_CSIR|UD_RESET)
macro_line|#endif
DECL|macro|VERSION
mdefine_line|#define VERSION &quot;1.12&quot;
DECL|macro|PACKED
mdefine_line|#define PACKED&t;&t;__attribute__((packed))
DECL|macro|ALIGNED
mdefine_line|#define ALIGNED(x)&t;__attribute__((aligned(x)))
multiline_comment|/* The 14F uses an array of 4-byte ints for its scatter/gather list.&n;   The data can be unaligned, but need not be.  It&squot;s easier to give&n;   the list normal alignment since it doesn&squot;t need to fit into a&n;   packed structure.  */
r_typedef
r_struct
(brace
DECL|member|address
r_int
r_int
id|address
suffix:semicolon
DECL|member|num_bytes
r_int
r_int
id|num_bytes
suffix:semicolon
DECL|typedef|ultrastor_sg_list
)brace
id|ultrastor_sg_list
suffix:semicolon
multiline_comment|/* MailBox SCSI Command Packet.  Basic command structure for communicating&n;   with controller. */
DECL|struct|mscp
r_struct
id|mscp
(brace
DECL|member|opcode
r_int
r_char
id|opcode
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* type of command */
DECL|member|xdir
r_int
r_char
id|xdir
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* data transfer direction */
DECL|member|dcn
r_int
r_char
id|dcn
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* disable disconnect */
DECL|member|ca
r_int
r_char
id|ca
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* use cache (if available) */
DECL|member|sg
r_int
r_char
id|sg
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* scatter/gather operation */
DECL|member|target_id
r_int
r_char
id|target_id
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* target SCSI id */
DECL|member|ch_no
r_int
r_char
id|ch_no
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* SCSI channel (always 0 for 14f) */
DECL|member|lun
r_int
r_char
id|lun
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* logical unit number */
DECL|member|PACKED
r_int
r_int
id|transfer_data
id|PACKED
suffix:semicolon
multiline_comment|/* transfer data pointer */
DECL|member|PACKED
r_int
r_int
id|transfer_data_length
id|PACKED
suffix:semicolon
multiline_comment|/* length in bytes */
DECL|member|PACKED
r_int
r_int
id|command_link
id|PACKED
suffix:semicolon
multiline_comment|/* for linking command chains */
DECL|member|scsi_command_link_id
r_int
r_char
id|scsi_command_link_id
suffix:semicolon
multiline_comment|/* identifies command in chain */
DECL|member|number_of_sg_list
r_int
r_char
id|number_of_sg_list
suffix:semicolon
multiline_comment|/* (if sg is set) 8 bytes per list */
DECL|member|length_of_sense_byte
r_int
r_char
id|length_of_sense_byte
suffix:semicolon
DECL|member|length_of_scsi_cdbs
r_int
r_char
id|length_of_scsi_cdbs
suffix:semicolon
multiline_comment|/* 6, 10, or 12 */
DECL|member|scsi_cdbs
r_int
r_char
id|scsi_cdbs
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* SCSI commands */
DECL|member|adapter_status
r_int
r_char
id|adapter_status
suffix:semicolon
multiline_comment|/* non-zero indicates HA error */
DECL|member|target_status
r_int
r_char
id|target_status
suffix:semicolon
multiline_comment|/* non-zero indicates target error */
DECL|member|PACKED
r_int
r_int
id|sense_data
id|PACKED
suffix:semicolon
multiline_comment|/* The following fields are for software only.  They are included in&n;     the MSCP structure because they are associated with SCSI requests.  */
DECL|member|done
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
DECL|member|SCint
id|Scsi_Cmnd
op_star
id|SCint
suffix:semicolon
DECL|member|sglist
id|ultrastor_sg_list
id|sglist
(braket
id|ULTRASTOR_24F_MAX_SG
)braket
suffix:semicolon
multiline_comment|/* use larger size for 24F */
)brace
suffix:semicolon
multiline_comment|/* Port addresses (relative to the base address) */
DECL|macro|U14F_PRODUCT_ID
mdefine_line|#define U14F_PRODUCT_ID(port) ((port) + 0x4)
DECL|macro|CONFIG
mdefine_line|#define CONFIG(port) ((port) + 0x6)
multiline_comment|/* Port addresses relative to the doorbell base address.  */
DECL|macro|LCL_DOORBELL_MASK
mdefine_line|#define LCL_DOORBELL_MASK(port) ((port) + 0x0)
DECL|macro|LCL_DOORBELL_INTR
mdefine_line|#define LCL_DOORBELL_INTR(port) ((port) + 0x1)
DECL|macro|SYS_DOORBELL_MASK
mdefine_line|#define SYS_DOORBELL_MASK(port) ((port) + 0x2)
DECL|macro|SYS_DOORBELL_INTR
mdefine_line|#define SYS_DOORBELL_INTR(port) ((port) + 0x3)
multiline_comment|/* Used to store configuration info read from config i/o registers.  Most of&n;   this is not used yet, but might as well save it.&n;   &n;   This structure also holds port addresses that are not at the same offset&n;   on the 14F and 24F.&n;   &n;   This structure holds all data that must be duplicated to support multiple&n;   adapters.  */
DECL|struct|ultrastor_config
r_static
r_struct
id|ultrastor_config
(brace
DECL|member|port_address
r_int
r_int
id|port_address
suffix:semicolon
multiline_comment|/* base address of card */
DECL|member|doorbell_address
r_int
r_int
id|doorbell_address
suffix:semicolon
multiline_comment|/* base address of doorbell CSRs */
DECL|member|ogm_address
r_int
r_int
id|ogm_address
suffix:semicolon
multiline_comment|/* base address of OGM */
DECL|member|icm_address
r_int
r_int
id|icm_address
suffix:semicolon
multiline_comment|/* base address of ICM */
DECL|member|bios_segment
r_const
r_void
op_star
id|bios_segment
suffix:semicolon
DECL|member|interrupt
r_int
r_char
id|interrupt
suffix:colon
l_int|4
suffix:semicolon
DECL|member|dma_channel
r_int
r_char
id|dma_channel
suffix:colon
l_int|3
suffix:semicolon
DECL|member|bios_drive_number
r_int
r_char
id|bios_drive_number
suffix:colon
l_int|1
suffix:semicolon
DECL|member|heads
r_int
r_char
id|heads
suffix:semicolon
DECL|member|sectors
r_int
r_char
id|sectors
suffix:semicolon
DECL|member|ha_scsi_id
r_int
r_char
id|ha_scsi_id
suffix:colon
l_int|3
suffix:semicolon
DECL|member|subversion
r_int
r_char
id|subversion
suffix:colon
l_int|4
suffix:semicolon
DECL|member|revision
r_int
r_char
id|revision
suffix:semicolon
multiline_comment|/* The slot number is used to distinguish the 24F (slot != 0) from&n;     the 14F and 34F (slot == 0). */
DECL|member|slot
r_int
r_char
id|slot
suffix:semicolon
macro_line|#ifdef PRINT_U24F_VERSION
DECL|member|csir_done
r_volatile
r_int
id|csir_done
suffix:semicolon
macro_line|#endif
multiline_comment|/* A pool of MSCP structures for this adapter, and a bitmask of&n;     busy structures.  (If ULTRASTOR_14F_MAX_CMDS == 1, a 1 byte&n;     busy flag is used instead.)  */
macro_line|#if ULTRASTOR_MAX_CMDS == 1
DECL|member|mscp_busy
r_int
r_char
id|mscp_busy
suffix:semicolon
macro_line|#else
DECL|member|mscp_free
r_int
r_int
id|mscp_free
suffix:semicolon
macro_line|#endif
DECL|member|aborted
r_volatile
r_int
r_char
id|aborted
(braket
id|ULTRASTOR_MAX_CMDS
)braket
suffix:semicolon
DECL|member|mscp
r_struct
id|mscp
id|mscp
(braket
id|ULTRASTOR_MAX_CMDS
)braket
suffix:semicolon
DECL|variable|config
)brace
id|config
op_assign
(brace
l_int|0
)brace
suffix:semicolon
multiline_comment|/* Set this to 1 to reset the SCSI bus on error.  */
DECL|variable|ultrastor_bus_reset
r_int
id|ultrastor_bus_reset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Allowed BIOS base addresses (NULL indicates reserved) */
DECL|variable|bios_segment_table
r_static
r_const
r_void
op_star
r_const
id|bios_segment_table
(braket
l_int|8
)braket
op_assign
(brace
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|0xC4000
comma
(paren
r_void
op_star
)paren
l_int|0xC8000
comma
(paren
r_void
op_star
)paren
l_int|0xCC000
comma
(paren
r_void
op_star
)paren
l_int|0xD0000
comma
(paren
r_void
op_star
)paren
l_int|0xD4000
comma
(paren
r_void
op_star
)paren
l_int|0xD8000
comma
(paren
r_void
op_star
)paren
l_int|0xDC000
comma
)brace
suffix:semicolon
multiline_comment|/* Allowed IRQs for 14f */
DECL|variable|interrupt_table_14f
r_static
r_const
r_int
r_char
id|interrupt_table_14f
(braket
l_int|4
)braket
op_assign
(brace
l_int|15
comma
l_int|14
comma
l_int|11
comma
l_int|10
)brace
suffix:semicolon
multiline_comment|/* Allowed DMA channels for 14f (0 indicates reserved) */
DECL|variable|dma_channel_table_14f
r_static
r_const
r_int
r_char
id|dma_channel_table_14f
(braket
l_int|4
)braket
op_assign
(brace
l_int|5
comma
l_int|6
comma
l_int|7
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* Head/sector mappings allowed by 14f */
r_static
r_const
r_struct
(brace
DECL|member|heads
r_int
r_char
id|heads
suffix:semicolon
DECL|member|sectors
r_int
r_char
id|sectors
suffix:semicolon
DECL|variable|mapping_table
)brace
id|mapping_table
(braket
l_int|4
)braket
op_assign
(brace
(brace
l_int|16
comma
l_int|63
)brace
comma
(brace
l_int|64
comma
l_int|32
)brace
comma
(brace
l_int|64
comma
l_int|63
)brace
comma
(brace
l_int|64
comma
l_int|32
)brace
)brace
suffix:semicolon
macro_line|#ifndef PORT_OVERRIDE
multiline_comment|/* ??? A probe of address 0x310 screws up NE2000 cards */
DECL|variable|ultrastor_ports_14f
r_static
r_const
r_int
r_int
id|ultrastor_ports_14f
(braket
)braket
op_assign
(brace
l_int|0x330
comma
l_int|0x340
comma
multiline_comment|/*0x310,*/
l_int|0x230
comma
l_int|0x240
comma
l_int|0x210
comma
l_int|0x130
comma
l_int|0x140
comma
)brace
suffix:semicolon
macro_line|#endif
r_static
r_void
id|ultrastor_interrupt
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|do_ultrastor_interrupt
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_inline
r_void
id|build_sg_list
c_func
(paren
r_struct
id|mscp
op_star
comma
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
DECL|function|find_and_clear_bit_16
r_static
r_inline
r_int
id|find_and_clear_bit_16
c_func
(paren
r_int
r_int
op_star
id|field
)paren
(brace
r_int
id|rv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|field
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;No free mscp&quot;
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;xorl %0,%0&bslash;n0:&bslash;tbsfw %1,%w0&bslash;n&bslash;tbtr %0,%1&bslash;n&bslash;tjnc 0b&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|rv
)paren
comma
l_string|&quot;=m&quot;
(paren
op_star
id|field
)paren
suffix:colon
l_string|&quot;1&quot;
(paren
op_star
id|field
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/* This has been re-implemented with the help of Richard Earnshaw,&n;   &lt;rwe@pegasus.esprit.ec.org&gt; and works with gcc-2.5.8 and gcc-2.6.0.&n;   The instability noted by jfc below appears to be a bug in&n;   gcc-2.5.x when compiling w/o optimization.  --Caleb&n;&n;   This asm is fragile: it doesn&squot;t work without the casts and it may&n;   not work without optimization.  Maybe I should add a swap builtin&n;   to gcc.  --jfc  */
DECL|function|xchgb
r_static
r_inline
r_int
r_char
id|xchgb
c_func
(paren
r_int
r_char
id|reg
comma
r_volatile
r_int
r_char
op_star
id|mem
)paren
(brace
id|__asm__
(paren
l_string|&quot;xchgb %0,%1&quot;
suffix:colon
l_string|&quot;=q&quot;
(paren
id|reg
)paren
comma
l_string|&quot;=m&quot;
(paren
op_star
id|mem
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|reg
)paren
)paren
suffix:semicolon
r_return
id|reg
suffix:semicolon
)brace
macro_line|#if ULTRASTOR_DEBUG &amp; (UD_COMMAND | UD_ABORT)
DECL|function|log_ultrastor_abort
r_static
r_void
id|log_ultrastor_abort
c_func
(paren
r_register
r_struct
id|ultrastor_config
op_star
id|config
comma
r_int
id|command
)paren
(brace
r_static
r_char
id|fmt
(braket
l_int|80
)braket
op_assign
l_string|&quot;abort %d (%x); MSCP free pool: %x;&quot;
suffix:semicolon
r_register
r_int
id|i
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ULTRASTOR_MAX_CMDS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|fmt
(braket
l_int|20
op_plus
id|i
op_star
l_int|2
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|config-&gt;mscp_free
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
id|fmt
(braket
l_int|21
op_plus
id|i
op_star
l_int|2
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|config-&gt;mscp
(braket
id|i
)braket
dot
id|target_id
suffix:semicolon
r_else
id|fmt
(braket
l_int|21
op_plus
id|i
op_star
l_int|2
)braket
op_assign
l_char|&squot;-&squot;
suffix:semicolon
)brace
id|fmt
(braket
l_int|20
op_plus
id|ULTRASTOR_MAX_CMDS
op_star
l_int|2
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|fmt
(braket
l_int|21
op_plus
id|ULTRASTOR_MAX_CMDS
op_star
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|fmt
comma
id|command
comma
op_amp
id|config-&gt;mscp
(braket
id|command
)braket
comma
id|config-&gt;mscp_free
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|ultrastor_14f_detect
r_static
r_int
id|ultrastor_14f_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|in_byte
comma
id|version_byte
op_assign
l_int|0
suffix:semicolon
r_struct
id|config_1
(brace
r_int
r_char
id|bios_segment
suffix:colon
l_int|3
suffix:semicolon
r_int
r_char
id|removable_disks_as_fixed
suffix:colon
l_int|1
suffix:semicolon
r_int
r_char
id|interrupt
suffix:colon
l_int|2
suffix:semicolon
r_int
r_char
id|dma_channel
suffix:colon
l_int|2
suffix:semicolon
)brace
id|config_1
suffix:semicolon
r_struct
id|config_2
(brace
r_int
r_char
id|ha_scsi_id
suffix:colon
l_int|3
suffix:semicolon
r_int
r_char
id|mapping_mode
suffix:colon
l_int|2
suffix:semicolon
r_int
r_char
id|bios_drive_number
suffix:colon
l_int|1
suffix:semicolon
r_int
r_char
id|tfr_port
suffix:colon
l_int|2
suffix:semicolon
)brace
id|config_2
suffix:semicolon
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: called&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* If a 24F has already been configured, don&squot;t look for a 14F.  */
r_if
c_cond
(paren
id|config.bios_segment
)paren
r_return
id|FALSE
suffix:semicolon
macro_line|#ifdef PORT_OVERRIDE
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|PORT_OVERRIDE
comma
l_int|0xc
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Ultrastor I/O space already in use&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
suffix:semicolon
id|config.port_address
op_assign
id|PORT_OVERRIDE
suffix:semicolon
macro_line|#else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|ultrastor_ports_14f
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|ultrastor_ports_14f
(braket
id|i
)braket
comma
l_int|0x0c
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|config.port_address
op_assign
id|ultrastor_ports_14f
(braket
id|i
)braket
suffix:semicolon
macro_line|#endif
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: testing port address %03X&bslash;n&quot;
comma
id|config.port_address
)paren
suffix:semicolon
macro_line|#endif
id|in_byte
op_assign
id|inb
c_func
(paren
id|U14F_PRODUCT_ID
c_func
(paren
id|config.port_address
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_byte
op_ne
id|US14F_PRODUCT_ID_0
)paren
(brace
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
macro_line|# ifdef PORT_OVERRIDE
id|printk
c_func
(paren
l_string|&quot;US14F: detect: wrong product ID 0 - %02X&bslash;n&quot;
comma
id|in_byte
)paren
suffix:semicolon
macro_line|# else
id|printk
c_func
(paren
l_string|&quot;US14F: detect: no adapter at port %03X&bslash;n&quot;
comma
id|config.port_address
)paren
suffix:semicolon
macro_line|# endif
macro_line|#endif
macro_line|#ifdef PORT_OVERRIDE
r_return
id|FALSE
suffix:semicolon
macro_line|#else
r_continue
suffix:semicolon
macro_line|#endif
)brace
id|in_byte
op_assign
id|inb
c_func
(paren
id|U14F_PRODUCT_ID
c_func
(paren
id|config.port_address
)paren
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Only upper nibble is significant for Product ID 1 */
r_if
c_cond
(paren
(paren
id|in_byte
op_amp
l_int|0xF0
)paren
op_ne
id|US14F_PRODUCT_ID_1
)paren
(brace
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
macro_line|# ifdef PORT_OVERRIDE
id|printk
c_func
(paren
l_string|&quot;US14F: detect: wrong product ID 1 - %02X&bslash;n&quot;
comma
id|in_byte
)paren
suffix:semicolon
macro_line|# else
id|printk
c_func
(paren
l_string|&quot;US14F: detect: no adapter at port %03X&bslash;n&quot;
comma
id|config.port_address
)paren
suffix:semicolon
macro_line|# endif
macro_line|#endif
macro_line|#ifdef PORT_OVERRIDE
r_return
id|FALSE
suffix:semicolon
macro_line|#else
r_continue
suffix:semicolon
macro_line|#endif
)brace
id|version_byte
op_assign
id|in_byte
suffix:semicolon
macro_line|#ifndef PORT_OVERRIDE
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|ARRAY_SIZE
c_func
(paren
id|ultrastor_ports_14f
)paren
)paren
(brace
macro_line|# if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: no port address found!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|# endif
r_return
id|FALSE
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: adapter found at port address %03X&bslash;n&quot;
comma
id|config.port_address
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Set local doorbell mask to disallow bus reset unless&n;       ultrastor_bus_reset is true.  */
id|outb
c_func
(paren
id|ultrastor_bus_reset
ques
c_cond
l_int|0xc2
suffix:colon
l_int|0x82
comma
id|LCL_DOORBELL_MASK
c_func
(paren
id|config.port_address
)paren
)paren
suffix:semicolon
multiline_comment|/* All above tests passed, must be the right thing.  Get some useful&n;       info. */
id|request_region
c_func
(paren
id|config.port_address
comma
l_int|0x0c
comma
l_string|&quot;ultrastor&quot;
)paren
suffix:semicolon
multiline_comment|/* Register the I/O space that we use */
op_star
(paren
r_char
op_star
)paren
op_amp
id|config_1
op_assign
id|inb
c_func
(paren
id|CONFIG
c_func
(paren
id|config.port_address
op_plus
l_int|0
)paren
)paren
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
op_amp
id|config_2
op_assign
id|inb
c_func
(paren
id|CONFIG
c_func
(paren
id|config.port_address
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|config.bios_segment
op_assign
id|bios_segment_table
(braket
id|config_1.bios_segment
)braket
suffix:semicolon
id|config.doorbell_address
op_assign
id|config.port_address
suffix:semicolon
id|config.ogm_address
op_assign
id|config.port_address
op_plus
l_int|0x8
suffix:semicolon
id|config.icm_address
op_assign
id|config.port_address
op_plus
l_int|0xC
suffix:semicolon
id|config.interrupt
op_assign
id|interrupt_table_14f
(braket
id|config_1.interrupt
)braket
suffix:semicolon
id|config.ha_scsi_id
op_assign
id|config_2.ha_scsi_id
suffix:semicolon
id|config.heads
op_assign
id|mapping_table
(braket
id|config_2.mapping_mode
)braket
dot
id|heads
suffix:semicolon
id|config.sectors
op_assign
id|mapping_table
(braket
id|config_2.mapping_mode
)braket
dot
id|sectors
suffix:semicolon
id|config.bios_drive_number
op_assign
id|config_2.bios_drive_number
suffix:semicolon
id|config.subversion
op_assign
(paren
id|version_byte
op_amp
l_int|0x0F
)paren
suffix:semicolon
r_if
c_cond
(paren
id|config.subversion
op_eq
id|U34F
)paren
id|config.dma_channel
op_assign
l_int|0
suffix:semicolon
r_else
id|config.dma_channel
op_assign
id|dma_channel_table_14f
(braket
id|config_1.dma_channel
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|config.bios_segment
)paren
(brace
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: not detected.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Final consistency check, verify previous info. */
r_if
c_cond
(paren
id|config.subversion
op_ne
id|U34F
)paren
r_if
c_cond
(paren
op_logical_neg
id|config.dma_channel
op_logical_or
op_logical_neg
(paren
id|config_2.tfr_port
op_amp
l_int|0x2
)paren
)paren
(brace
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: consistency check failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* If we were TRULY paranoid, we could issue a host adapter inquiry&n;       command here and verify the data returned.  But frankly, I&squot;m&n;       exhausted! */
multiline_comment|/* Finally!  Now I&squot;m satisfied... */
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: detect succeeded&bslash;n&quot;
l_string|&quot;  Port address: %03X&bslash;n&quot;
l_string|&quot;  BIOS segment: %05X&bslash;n&quot;
l_string|&quot;  Interrupt: %u&bslash;n&quot;
l_string|&quot;  DMA channel: %u&bslash;n&quot;
l_string|&quot;  H/A SCSI ID: %u&bslash;n&quot;
l_string|&quot;  Subversion: %u&bslash;n&quot;
comma
id|config.port_address
comma
id|config.bios_segment
comma
id|config.interrupt
comma
id|config.dma_channel
comma
id|config.ha_scsi_id
comma
id|config.subversion
)paren
suffix:semicolon
macro_line|#endif
id|tpnt-&gt;this_id
op_assign
id|config.ha_scsi_id
suffix:semicolon
id|tpnt-&gt;unchecked_isa_dma
op_assign
(paren
id|config.subversion
op_ne
id|U34F
)paren
suffix:semicolon
macro_line|#if ULTRASTOR_MAX_CMDS &gt; 1
id|config.mscp_free
op_assign
op_complement
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|config.interrupt
comma
id|do_ultrastor_interrupt
comma
l_int|0
comma
l_string|&quot;Ultrastor&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to allocate IRQ%u for UltraStor controller.&bslash;n&quot;
comma
id|config.interrupt
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|config.dma_channel
op_logical_and
id|request_dma
c_func
(paren
id|config.dma_channel
comma
l_string|&quot;Ultrastor&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to allocate DMA channel %u for UltraStor controller.&bslash;n&quot;
comma
id|config.dma_channel
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|config.interrupt
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|tpnt-&gt;sg_tablesize
op_assign
id|ULTRASTOR_14F_MAX_SG
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;UltraStor driver version&quot;
id|VERSION
l_string|&quot;.  Using %d SG lists.&bslash;n&quot;
comma
id|ULTRASTOR_14F_MAX_SG
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
DECL|function|ultrastor_24f_detect
r_static
r_int
id|ultrastor_24f_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_register
r_int
id|i
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US24F: detect&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* probe each EISA slot at slot address C80 */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|config_1
comma
id|config_2
suffix:semicolon
r_int
r_int
id|addr
op_assign
(paren
id|i
op_lshift
l_int|12
)paren
op_or
id|ULTRASTOR_24F_PORT
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|addr
)paren
op_ne
id|US24F_PRODUCT_ID_0
op_logical_and
id|inb
c_func
(paren
id|addr
op_plus
l_int|1
)paren
op_ne
id|US24F_PRODUCT_ID_1
op_logical_and
id|inb
c_func
(paren
id|addr
op_plus
l_int|2
)paren
op_ne
id|US24F_PRODUCT_ID_2
)paren
r_continue
suffix:semicolon
id|config.revision
op_assign
id|inb
c_func
(paren
id|addr
op_plus
l_int|3
)paren
suffix:semicolon
id|config.slot
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|addr
op_plus
l_int|4
)paren
op_amp
l_int|1
)paren
)paren
(brace
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;U24F: found disabled card in slot %u&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
)brace
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;U24F: found card in slot %u&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#endif
id|config_1
op_assign
id|inb
c_func
(paren
id|addr
op_plus
l_int|5
)paren
suffix:semicolon
id|config.bios_segment
op_assign
id|bios_segment_table
(braket
id|config_1
op_amp
l_int|7
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|config_1
op_rshift
l_int|4
)paren
(brace
r_case
l_int|1
suffix:colon
id|config.interrupt
op_assign
l_int|15
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|config.interrupt
op_assign
l_int|14
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|config.interrupt
op_assign
l_int|11
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
id|config.interrupt
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;U24F: invalid IRQ&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|config.interrupt
comma
id|do_ultrastor_interrupt
comma
l_int|0
comma
l_string|&quot;Ultrastor&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to allocate IRQ%u for UltraStor controller.&bslash;n&quot;
comma
id|config.interrupt
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* BIOS addr set */
multiline_comment|/* base port set */
id|config.port_address
op_assign
id|addr
suffix:semicolon
id|config.doorbell_address
op_assign
id|addr
op_plus
l_int|12
suffix:semicolon
id|config.ogm_address
op_assign
id|addr
op_plus
l_int|0x17
suffix:semicolon
id|config.icm_address
op_assign
id|addr
op_plus
l_int|0x1C
suffix:semicolon
id|config_2
op_assign
id|inb
c_func
(paren
id|addr
op_plus
l_int|7
)paren
suffix:semicolon
id|config.ha_scsi_id
op_assign
id|config_2
op_amp
l_int|7
suffix:semicolon
id|config.heads
op_assign
id|mapping_table
(braket
(paren
id|config_2
op_rshift
l_int|3
)paren
op_amp
l_int|3
)braket
dot
id|heads
suffix:semicolon
id|config.sectors
op_assign
id|mapping_table
(braket
(paren
id|config_2
op_rshift
l_int|3
)paren
op_amp
l_int|3
)braket
dot
id|sectors
suffix:semicolon
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US24F: detect: detect succeeded&bslash;n&quot;
l_string|&quot;  Port address: %03X&bslash;n&quot;
l_string|&quot;  BIOS segment: %05X&bslash;n&quot;
l_string|&quot;  Interrupt: %u&bslash;n&quot;
l_string|&quot;  H/A SCSI ID: %u&bslash;n&quot;
comma
id|config.port_address
comma
id|config.bios_segment
comma
id|config.interrupt
comma
id|config.ha_scsi_id
)paren
suffix:semicolon
macro_line|#endif
id|tpnt-&gt;this_id
op_assign
id|config.ha_scsi_id
suffix:semicolon
id|tpnt-&gt;unchecked_isa_dma
op_assign
l_int|0
suffix:semicolon
id|tpnt-&gt;sg_tablesize
op_assign
id|ULTRASTOR_24F_MAX_SG
suffix:semicolon
id|shpnt
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
l_int|0
)paren
suffix:semicolon
id|shpnt-&gt;irq
op_assign
id|config.interrupt
suffix:semicolon
id|shpnt-&gt;dma_channel
op_assign
id|config.dma_channel
suffix:semicolon
id|shpnt-&gt;io_port
op_assign
id|config.port_address
suffix:semicolon
macro_line|#if ULTRASTOR_MAX_CMDS &gt; 1
id|config.mscp_free
op_assign
op_complement
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* Mark ICM and OGM free */
id|outb
c_func
(paren
l_int|0
comma
id|addr
op_plus
l_int|0x16
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|addr
op_plus
l_int|0x1B
)paren
suffix:semicolon
multiline_comment|/* Set local doorbell mask to disallow bus reset unless&n;&t; ultrastor_bus_reset is true.  */
id|outb
c_func
(paren
id|ultrastor_bus_reset
ques
c_cond
l_int|0xc2
suffix:colon
l_int|0x82
comma
id|LCL_DOORBELL_MASK
c_func
(paren
id|addr
op_plus
l_int|12
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x02
comma
id|SYS_DOORBELL_MASK
c_func
(paren
id|addr
op_plus
l_int|12
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;UltraStor driver version &quot;
id|VERSION
l_string|&quot;.  Using %d SG lists.&bslash;n&quot;
comma
id|tpnt-&gt;sg_tablesize
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
r_return
id|FALSE
suffix:semicolon
)brace
DECL|function|ultrastor_detect
r_int
id|ultrastor_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
id|tpnt-&gt;proc_name
op_assign
l_string|&quot;ultrastor&quot;
suffix:semicolon
r_return
id|ultrastor_14f_detect
c_func
(paren
id|tpnt
)paren
op_logical_or
id|ultrastor_24f_detect
c_func
(paren
id|tpnt
)paren
suffix:semicolon
)brace
DECL|function|ultrastor_info
r_const
r_char
op_star
id|ultrastor_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_static
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
r_if
c_cond
(paren
id|config.slot
)paren
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;UltraStor 24F SCSI @ Slot %u IRQ%u&quot;
comma
id|config.slot
comma
id|config.interrupt
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|config.subversion
)paren
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;UltraStor 34F SCSI @ Port %03X BIOS %05X IRQ%u&quot;
comma
id|config.port_address
comma
(paren
r_int
)paren
id|config.bios_segment
comma
id|config.interrupt
)paren
suffix:semicolon
r_else
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;UltraStor 14F SCSI @ Port %03X BIOS %05X IRQ%u DMA%u&quot;
comma
id|config.port_address
comma
(paren
r_int
)paren
id|config.bios_segment
comma
id|config.interrupt
comma
id|config.dma_channel
)paren
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
DECL|function|build_sg_list
r_static
r_inline
r_void
id|build_sg_list
c_func
(paren
r_register
r_struct
id|mscp
op_star
id|mscp
comma
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|scatterlist
op_star
id|sl
suffix:semicolon
r_int
id|transfer_length
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|max
suffix:semicolon
id|sl
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;request_buffer
suffix:semicolon
id|max
op_assign
id|SCpnt-&gt;use_sg
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mscp-&gt;sglist
(braket
id|i
)braket
dot
id|address
op_assign
id|virt_to_bus
c_func
(paren
id|sl
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|mscp-&gt;sglist
(braket
id|i
)braket
dot
id|num_bytes
op_assign
id|sl
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|transfer_length
op_add_assign
id|sl
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
id|mscp-&gt;number_of_sg_list
op_assign
id|max
suffix:semicolon
id|mscp-&gt;transfer_data
op_assign
id|virt_to_bus
c_func
(paren
id|mscp-&gt;sglist
)paren
suffix:semicolon
multiline_comment|/* ??? May not be necessary.  Docs are unclear as to whether transfer&n;&t;   length field is ignored or whether it should be set to the total&n;&t;   number of bytes of the transfer.  */
id|mscp-&gt;transfer_data_length
op_assign
id|transfer_length
suffix:semicolon
)brace
DECL|function|ultrastor_queuecommand
r_int
id|ultrastor_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_register
r_struct
id|mscp
op_star
id|my_mscp
suffix:semicolon
macro_line|#if ULTRASTOR_MAX_CMDS &gt; 1
r_int
id|mscp_index
suffix:semicolon
macro_line|#endif
r_int
r_int
id|status
suffix:semicolon
r_int
id|flags
suffix:semicolon
multiline_comment|/* Next test is for debugging; &quot;can&squot;t happen&quot; */
r_if
c_cond
(paren
(paren
id|config.mscp_free
op_amp
(paren
(paren
l_int|1U
op_lshift
id|ULTRASTOR_MAX_CMDS
)paren
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;ultrastor_queuecommand: no free MSCP&bslash;n&quot;
)paren
suffix:semicolon
id|mscp_index
op_assign
id|find_and_clear_bit_16
c_func
(paren
op_amp
id|config.mscp_free
)paren
suffix:semicolon
multiline_comment|/* Has the command been aborted?  */
r_if
c_cond
(paren
id|xchgb
c_func
(paren
l_int|0xff
comma
op_amp
id|config.aborted
(braket
id|mscp_index
)braket
)paren
op_ne
l_int|0
)paren
(brace
id|status
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
r_goto
id|aborted
suffix:semicolon
)brace
id|my_mscp
op_assign
op_amp
id|config.mscp
(braket
id|mscp_index
)braket
suffix:semicolon
macro_line|#if 1
multiline_comment|/* This way is faster.  */
op_star
(paren
r_int
r_char
op_star
)paren
id|my_mscp
op_assign
id|OP_SCSI
op_or
(paren
id|DTD_SCSI
op_lshift
l_int|3
)paren
suffix:semicolon
macro_line|#else
id|my_mscp-&gt;opcode
op_assign
id|OP_SCSI
suffix:semicolon
id|my_mscp-&gt;xdir
op_assign
id|DTD_SCSI
suffix:semicolon
id|my_mscp-&gt;dcn
op_assign
id|FALSE
suffix:semicolon
macro_line|#endif
multiline_comment|/* Tape drives don&squot;t work properly if the cache is used.  The SCSI&n;       READ command for a tape doesn&squot;t have a block offset, and the adapter&n;       incorrectly assumes that all reads from the tape read the same&n;       blocks.  Results will depend on read buffer size and other disk&n;       activity. &n;&n;       ???  Which other device types should never use the cache?   */
id|my_mscp-&gt;ca
op_assign
id|SCpnt-&gt;device-&gt;type
op_ne
id|TYPE_TAPE
suffix:semicolon
id|my_mscp-&gt;target_id
op_assign
id|SCpnt-&gt;target
suffix:semicolon
id|my_mscp-&gt;ch_no
op_assign
l_int|0
suffix:semicolon
id|my_mscp-&gt;lun
op_assign
id|SCpnt-&gt;lun
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
multiline_comment|/* Set scatter/gather flag in SCSI command packet */
id|my_mscp-&gt;sg
op_assign
id|TRUE
suffix:semicolon
id|build_sg_list
c_func
(paren
id|my_mscp
comma
id|SCpnt
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Unset scatter/gather flag in SCSI command packet */
id|my_mscp-&gt;sg
op_assign
id|FALSE
suffix:semicolon
id|my_mscp-&gt;transfer_data
op_assign
id|virt_to_bus
c_func
(paren
id|SCpnt-&gt;request_buffer
)paren
suffix:semicolon
id|my_mscp-&gt;transfer_data_length
op_assign
id|SCpnt-&gt;request_bufflen
suffix:semicolon
)brace
id|my_mscp-&gt;command_link
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*???*/
id|my_mscp-&gt;scsi_command_link_id
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*???*/
id|my_mscp-&gt;length_of_sense_byte
op_assign
r_sizeof
id|SCpnt-&gt;sense_buffer
suffix:semicolon
id|my_mscp-&gt;length_of_scsi_cdbs
op_assign
id|SCpnt-&gt;cmd_len
suffix:semicolon
id|memcpy
c_func
(paren
id|my_mscp-&gt;scsi_cdbs
comma
id|SCpnt-&gt;cmnd
comma
id|my_mscp-&gt;length_of_scsi_cdbs
)paren
suffix:semicolon
id|my_mscp-&gt;adapter_status
op_assign
l_int|0
suffix:semicolon
id|my_mscp-&gt;target_status
op_assign
l_int|0
suffix:semicolon
id|my_mscp-&gt;sense_data
op_assign
id|virt_to_bus
c_func
(paren
op_amp
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|my_mscp-&gt;done
op_assign
id|done
suffix:semicolon
id|my_mscp-&gt;SCint
op_assign
id|SCpnt
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|my_mscp
suffix:semicolon
multiline_comment|/* Find free OGM slot.  On 24F, look for OGM status byte == 0.&n;       On 14F and 34F, wait for local interrupt pending flag to clear.  */
id|retry
suffix:colon
r_if
c_cond
(paren
id|config.slot
)paren
r_while
c_loop
(paren
id|inb
c_func
(paren
id|config.ogm_address
op_minus
l_int|1
)paren
op_ne
l_int|0
op_logical_and
id|config.aborted
(braket
id|mscp_index
)braket
op_eq
l_int|0xff
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* else??? */
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|LCL_DOORBELL_INTR
c_func
(paren
id|config.doorbell_address
)paren
)paren
op_amp
(paren
id|config.slot
ques
c_cond
l_int|2
suffix:colon
l_int|1
)paren
)paren
op_logical_and
id|config.aborted
(braket
id|mscp_index
)braket
op_eq
l_int|0xff
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* To avoid race conditions, make the code to write to the adapter&n;       atomic.  This simplifies the abort code.  */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|LCL_DOORBELL_INTR
c_func
(paren
id|config.doorbell_address
)paren
)paren
op_amp
(paren
id|config.slot
ques
c_cond
l_int|2
suffix:colon
l_int|1
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
id|status
op_assign
id|xchgb
c_func
(paren
l_int|0
comma
op_amp
id|config.aborted
(braket
id|mscp_index
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0xff
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if ULTRASTOR_DEBUG &amp; (UD_COMMAND | UD_ABORT)
id|printk
c_func
(paren
l_string|&quot;USx4F: queuecommand: aborted&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if ULTRASTOR_MAX_CMDS &gt; 1
id|log_ultrastor_abort
c_func
(paren
op_amp
id|config
comma
id|mscp_index
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|status
op_lshift_assign
l_int|16
suffix:semicolon
id|aborted
suffix:colon
id|set_bit
c_func
(paren
id|mscp_index
comma
op_amp
id|config.mscp_free
)paren
suffix:semicolon
multiline_comment|/* If the driver queues commands, call the done proc here.  Otherwise&n;&t;   return an error.  */
macro_line|#if ULTRASTOR_MAX_CMDS &gt; 1
id|SCpnt-&gt;result
op_assign
id|status
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#else
r_return
id|status
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Store pointer in OGM address bytes */
id|outl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|my_mscp
)paren
comma
id|config.ogm_address
)paren
suffix:semicolon
multiline_comment|/* Issue OGM interrupt */
r_if
c_cond
(paren
id|config.slot
)paren
(brace
multiline_comment|/* Write OGM command register on 24F */
id|outb
c_func
(paren
l_int|1
comma
id|config.ogm_address
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x2
comma
id|LCL_DOORBELL_INTR
c_func
(paren
id|config.doorbell_address
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
l_int|0x1
comma
id|LCL_DOORBELL_INTR
c_func
(paren
id|config.doorbell_address
)paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_COMMAND)
id|printk
c_func
(paren
l_string|&quot;USx4F: queuecommand: returning&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This code must deal with 2 cases:&n;&n;   1. The command has not been written to the OGM.  In this case, set&n;   the abort flag and return.&n;&n;   2. The command has been written to the OGM and is stuck somewhere in&n;   the adapter.&n;&n;   2a.  On a 24F, ask the adapter to abort the command.  It will interrupt&n;   when it does.&n;&n;   2b.  Call the command&squot;s done procedure.&n;&n; */
DECL|function|ultrastor_abort
r_int
id|ultrastor_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
macro_line|#if ULTRASTOR_DEBUG &amp; UD_ABORT
r_char
id|out
(braket
l_int|108
)braket
suffix:semicolon
r_int
r_char
id|icm_status
op_assign
l_int|0
comma
id|ogm_status
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|icm_addr
op_assign
l_int|0
comma
id|ogm_addr
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_int
r_int
id|mscp_index
suffix:semicolon
r_int
r_char
id|old_aborted
suffix:semicolon
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
id|config.slot
)paren
(brace
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
multiline_comment|/* Do not attempt an abort for the 24f */
multiline_comment|/* Simple consistency checking */
r_if
c_cond
(paren
op_logical_neg
id|SCpnt-&gt;host_scribble
)paren
(brace
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
id|mscp_index
op_assign
(paren
(paren
r_struct
id|mscp
op_star
)paren
id|SCpnt-&gt;host_scribble
)paren
op_minus
id|config.mscp
suffix:semicolon
r_if
c_cond
(paren
id|mscp_index
op_ge
id|ULTRASTOR_MAX_CMDS
)paren
id|panic
c_func
(paren
l_string|&quot;Ux4F aborting invalid MSCP&quot;
)paren
suffix:semicolon
macro_line|#if ULTRASTOR_DEBUG &amp; UD_ABORT
r_if
c_cond
(paren
id|config.slot
)paren
(brace
r_int
id|port0
op_assign
(paren
id|config.slot
op_lshift
l_int|12
)paren
op_or
l_int|0xc80
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|out
comma
l_string|&quot;OGM %d:%x ICM %d:%x ports:  &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|p
op_assign
id|inb
c_func
(paren
id|port0
op_plus
id|i
)paren
suffix:semicolon
id|out
(braket
l_int|28
op_plus
id|i
op_star
l_int|3
)braket
op_assign
l_string|&quot;0123456789abcdef&quot;
(braket
id|p
op_rshift
l_int|4
)braket
suffix:semicolon
id|out
(braket
l_int|29
op_plus
id|i
op_star
l_int|3
)braket
op_assign
l_string|&quot;0123456789abcdef&quot;
(braket
id|p
op_amp
l_int|15
)braket
suffix:semicolon
id|out
(braket
l_int|30
op_plus
id|i
op_star
l_int|3
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
)brace
id|out
(braket
l_int|28
op_plus
id|i
op_star
l_int|3
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|out
(braket
l_int|29
op_plus
id|i
op_star
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|ogm_status
op_assign
id|inb
c_func
(paren
id|port0
op_plus
l_int|22
)paren
suffix:semicolon
id|ogm_addr
op_assign
(paren
r_int
r_int
)paren
id|bus_to_virt
c_func
(paren
id|inl
c_func
(paren
id|port0
op_plus
l_int|23
)paren
)paren
suffix:semicolon
id|icm_status
op_assign
id|inb
c_func
(paren
id|port0
op_plus
l_int|27
)paren
suffix:semicolon
id|icm_addr
op_assign
(paren
r_int
r_int
)paren
id|bus_to_virt
c_func
(paren
id|inl
c_func
(paren
id|port0
op_plus
l_int|28
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* First check to see if an interrupt is pending.  I suspect the SiS&n;       chipset loses interrupts.  (I also suspect is mangles data, but&n;       one bug at a time... */
r_if
c_cond
(paren
id|config.slot
ques
c_cond
id|inb
c_func
(paren
id|config.icm_address
op_minus
l_int|1
)paren
op_eq
l_int|2
suffix:colon
(paren
id|inb
c_func
(paren
id|SYS_DOORBELL_INTR
c_func
(paren
id|config.doorbell_address
)paren
)paren
op_amp
l_int|1
)paren
)paren
(brace
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Ux4F: abort while completed command pending&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ultrastor_interrupt
c_func
(paren
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
multiline_comment|/* FIXME - is this correct? -ERY */
)brace
macro_line|#endif
id|old_aborted
op_assign
id|xchgb
c_func
(paren
id|DID_ABORT
comma
op_amp
id|config.aborted
(braket
id|mscp_index
)braket
)paren
suffix:semicolon
multiline_comment|/* aborted == 0xff is the signal that queuecommand has not yet sent&n;       the command.  It will notice the new abort flag and fail.  */
r_if
c_cond
(paren
id|old_aborted
op_eq
l_int|0xff
)paren
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
multiline_comment|/* On 24F, send an abort MSCP request.  The adapter will interrupt&n;       and the interrupt handler will call done.  */
r_if
c_cond
(paren
id|config.slot
op_logical_and
id|inb
c_func
(paren
id|config.ogm_address
op_minus
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outl
c_func
(paren
id|virt_to_bus
c_func
(paren
op_amp
id|config.mscp
(braket
id|mscp_index
)braket
)paren
comma
id|config.ogm_address
)paren
suffix:semicolon
id|inb
c_func
(paren
l_int|0xc80
)paren
suffix:semicolon
multiline_comment|/* delay */
id|outb
c_func
(paren
l_int|0x80
comma
id|config.ogm_address
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x2
comma
id|LCL_DOORBELL_INTR
c_func
(paren
id|config.doorbell_address
)paren
)paren
suffix:semicolon
macro_line|#if ULTRASTOR_DEBUG &amp; UD_ABORT
id|log_ultrastor_abort
c_func
(paren
op_amp
id|config
comma
id|mscp_index
)paren
suffix:semicolon
id|printk
c_func
(paren
id|out
comma
id|ogm_status
comma
id|ogm_addr
comma
id|icm_status
comma
id|icm_addr
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_PENDING
suffix:semicolon
)brace
macro_line|#if ULTRASTOR_DEBUG &amp; UD_ABORT
id|log_ultrastor_abort
c_func
(paren
op_amp
id|config
comma
id|mscp_index
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Can&squot;t request a graceful abort.  Either this is not a 24F or&n;       the OGM is busy.  Don&squot;t free the command -- the adapter might&n;       still be using it.  Setting SCint = 0 causes the interrupt&n;       handler to ignore the command.  */
multiline_comment|/* FIXME - devices that implement soft resets will still be running&n;       the command after a bus reset.  We would probably rather leave&n;       the command in the queue.  The upper level code will automatically&n;       leave the command in the active state instead of requeueing it. ERY */
macro_line|#if ULTRASTOR_DEBUG &amp; UD_ABORT
r_if
c_cond
(paren
id|config.mscp
(braket
id|mscp_index
)braket
dot
id|SCint
op_ne
id|SCpnt
)paren
id|printk
c_func
(paren
l_string|&quot;abort: command mismatch, %p != %p&bslash;n&quot;
comma
id|config.mscp
(braket
id|mscp_index
)braket
dot
id|SCint
comma
id|SCpnt
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|config.mscp
(braket
id|mscp_index
)braket
dot
id|SCint
op_eq
l_int|0
)paren
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|config.mscp
(braket
id|mscp_index
)braket
dot
id|SCint
op_ne
id|SCpnt
)paren
id|panic
c_func
(paren
l_string|&quot;Bad abort&quot;
)paren
suffix:semicolon
id|config.mscp
(braket
id|mscp_index
)braket
dot
id|SCint
op_assign
l_int|0
suffix:semicolon
id|done
op_assign
id|config.mscp
(braket
id|mscp_index
)braket
dot
id|done
suffix:semicolon
id|config.mscp
(braket
id|mscp_index
)braket
dot
id|done
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* I worry about reentrancy in scsi.c  */
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/* Need to set a timeout here in case command never completes.  */
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
DECL|function|ultrastor_reset
r_int
id|ultrastor_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_int
id|reset_flags
)paren
(brace
r_int
id|flags
suffix:semicolon
r_register
r_int
id|i
suffix:semicolon
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_RESET)
id|printk
c_func
(paren
l_string|&quot;US14F: reset: called&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|config.slot
)paren
(brace
r_return
id|SCSI_RESET_PUNT
suffix:semicolon
)brace
multiline_comment|/* Do not attempt a reset for the 24f */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Reset the adapter and SCSI bus.  The SCSI bus reset can be&n;       inhibited by clearing ultrastor_bus_reset before probe.  */
id|outb
c_func
(paren
l_int|0xc0
comma
id|LCL_DOORBELL_INTR
c_func
(paren
id|config.doorbell_address
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|config.slot
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|config.ogm_address
op_minus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|config.icm_address
op_minus
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#if ULTRASTOR_MAX_CMDS == 1
r_if
c_cond
(paren
id|config.mscp_busy
op_logical_and
id|config.mscp-&gt;done
op_logical_and
id|config.mscp-&gt;SCint
)paren
(brace
id|config.mscp-&gt;SCint-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|config.mscp
op_member_access_from_pointer
id|done
c_func
(paren
id|config.mscp-&gt;SCint
)paren
suffix:semicolon
)brace
id|config.mscp-&gt;SCint
op_assign
l_int|0
suffix:semicolon
macro_line|#else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ULTRASTOR_MAX_CMDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|config.mscp_free
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_logical_and
id|config.mscp
(braket
id|i
)braket
dot
id|done
op_logical_and
id|config.mscp
(braket
id|i
)braket
dot
id|SCint
)paren
(brace
id|config.mscp
(braket
id|i
)braket
dot
id|SCint-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|config.mscp
(braket
id|i
)braket
dot
id|done
c_func
(paren
id|config.mscp
(braket
id|i
)braket
dot
id|SCint
)paren
suffix:semicolon
id|config.mscp
(braket
id|i
)braket
dot
id|done
op_assign
l_int|0
suffix:semicolon
)brace
id|config.mscp
(braket
id|i
)braket
dot
id|SCint
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* FIXME - if the device implements soft resets, then the command&n;       will still be running.  ERY */
id|memset
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|config.aborted
comma
l_int|0
comma
r_sizeof
id|config.aborted
)paren
suffix:semicolon
macro_line|#if ULTRASTOR_MAX_CMDS == 1
id|config.mscp_busy
op_assign
l_int|0
suffix:semicolon
macro_line|#else
id|config.mscp_free
op_assign
op_complement
l_int|0
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_RESET_SUCCESS
suffix:semicolon
)brace
DECL|function|ultrastor_biosparam
r_int
id|ultrastor_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
op_star
id|dkinfo
)paren
(brace
r_int
id|size
op_assign
id|disk-&gt;capacity
suffix:semicolon
r_int
r_int
id|s
op_assign
id|config.heads
op_star
id|config.sectors
suffix:semicolon
id|dkinfo
(braket
l_int|0
)braket
op_assign
id|config.heads
suffix:semicolon
id|dkinfo
(braket
l_int|1
)braket
op_assign
id|config.sectors
suffix:semicolon
id|dkinfo
(braket
l_int|2
)braket
op_assign
id|size
op_div
id|s
suffix:semicolon
multiline_comment|/* Ignore partial cylinders */
macro_line|#if 0
r_if
c_cond
(paren
id|dkinfo
(braket
l_int|2
)braket
OG
l_int|1024
)paren
id|dkinfo
(braket
l_int|2
)braket
op_assign
l_int|1024
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ultrastor_interrupt
r_static
r_void
id|ultrastor_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|status
suffix:semicolon
macro_line|#if ULTRASTOR_MAX_CMDS &gt; 1
r_int
r_int
id|mscp_index
suffix:semicolon
macro_line|#endif
r_register
r_struct
id|mscp
op_star
id|mscp
suffix:semicolon
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCtmp
suffix:semicolon
macro_line|#if ULTRASTOR_MAX_CMDS == 1
id|mscp
op_assign
op_amp
id|config.mscp
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#else
id|mscp
op_assign
(paren
r_struct
id|mscp
op_star
)paren
id|bus_to_virt
c_func
(paren
id|inl
c_func
(paren
id|config.icm_address
)paren
)paren
suffix:semicolon
id|mscp_index
op_assign
id|mscp
op_minus
id|config.mscp
suffix:semicolon
r_if
c_cond
(paren
id|mscp_index
op_ge
id|ULTRASTOR_MAX_CMDS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Ux4F interrupt: bad MSCP address %x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|mscp
)paren
suffix:semicolon
multiline_comment|/* A command has been lost.  Reset and report an error&n;&t;   for all commands.  */
id|ultrastor_reset
c_func
(paren
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Clean ICM slot (set ICMINT bit to 0) */
r_if
c_cond
(paren
id|config.slot
)paren
(brace
r_int
r_char
id|icm_status
op_assign
id|inb
c_func
(paren
id|config.icm_address
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#if ULTRASTOR_DEBUG &amp; (UD_INTERRUPT|UD_ERROR|UD_ABORT)
r_if
c_cond
(paren
id|icm_status
op_ne
l_int|1
op_logical_and
id|icm_status
op_ne
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;US24F: ICM status %x for MSCP %d (%x)&bslash;n&quot;
comma
id|icm_status
comma
id|mscp_index
comma
(paren
r_int
r_int
)paren
id|mscp
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* The manual says clear interrupt then write 0 to ICM status.&n;&t;   This seems backwards, but I&squot;ll do it anyway.  --jfc */
id|outb
c_func
(paren
l_int|2
comma
id|SYS_DOORBELL_INTR
c_func
(paren
id|config.doorbell_address
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|config.icm_address
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|icm_status
op_eq
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;UltraStor abort command failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|icm_status
op_eq
l_int|3
)paren
(brace
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
op_assign
id|mscp-&gt;done
suffix:semicolon
r_if
c_cond
(paren
id|done
)paren
(brace
id|mscp-&gt;done
op_assign
l_int|0
suffix:semicolon
id|mscp-&gt;SCint-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|mscp-&gt;SCint
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
id|outb
c_func
(paren
l_int|1
comma
id|SYS_DOORBELL_INTR
c_func
(paren
id|config.doorbell_address
)paren
)paren
suffix:semicolon
)brace
id|SCtmp
op_assign
id|mscp-&gt;SCint
suffix:semicolon
id|mscp-&gt;SCint
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|SCtmp
op_eq
l_int|0
)paren
(brace
macro_line|#if ULTRASTOR_DEBUG &amp; (UD_ABORT|UD_INTERRUPT)
id|printk
c_func
(paren
l_string|&quot;MSCP %d (%x): no command&bslash;n&quot;
comma
id|mscp_index
comma
(paren
r_int
r_int
)paren
id|mscp
)paren
suffix:semicolon
macro_line|#endif&t;
macro_line|#if ULTRASTOR_MAX_CMDS == 1
id|config.mscp_busy
op_assign
id|FALSE
suffix:semicolon
macro_line|#else
id|set_bit
c_func
(paren
id|mscp_index
comma
op_amp
id|config.mscp_free
)paren
suffix:semicolon
macro_line|#endif
id|config.aborted
(braket
id|mscp_index
)braket
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Save done locally and zero before calling.  This is needed as&n;       once we call done, we may get another command queued before this&n;       interrupt service routine can return. */
id|done
op_assign
id|mscp-&gt;done
suffix:semicolon
id|mscp-&gt;done
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Let the higher levels know that we&squot;re done */
r_switch
c_cond
(paren
id|mscp-&gt;adapter_status
)paren
(brace
r_case
l_int|0
suffix:colon
id|status
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
multiline_comment|/* invalid command */
r_case
l_int|0x02
suffix:colon
multiline_comment|/* invalid parameters */
r_case
l_int|0x03
suffix:colon
multiline_comment|/* invalid data list */
r_default
suffix:colon
id|status
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x84
suffix:colon
multiline_comment|/* SCSI bus abort */
id|status
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x91
suffix:colon
id|status
op_assign
id|DID_TIME_OUT
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
)brace
id|SCtmp-&gt;result
op_assign
id|status
op_or
id|mscp-&gt;target_status
suffix:semicolon
id|SCtmp-&gt;host_scribble
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Free up mscp block for next command */
macro_line|#if ULTRASTOR_MAX_CMDS == 1
id|config.mscp_busy
op_assign
id|FALSE
suffix:semicolon
macro_line|#else
id|set_bit
c_func
(paren
id|mscp_index
comma
op_amp
id|config.mscp_free
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ULTRASTOR_DEBUG &amp; (UD_ABORT|UD_INTERRUPT)
r_if
c_cond
(paren
id|config.aborted
(braket
id|mscp_index
)braket
)paren
id|printk
c_func
(paren
l_string|&quot;Ux4 interrupt: MSCP %d (%x) aborted = %d&bslash;n&quot;
comma
id|mscp_index
comma
(paren
r_int
r_int
)paren
id|mscp
comma
id|config.aborted
(braket
id|mscp_index
)braket
)paren
suffix:semicolon
macro_line|#endif
id|config.aborted
(braket
id|mscp_index
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|done
)paren
id|done
c_func
(paren
id|SCtmp
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;US14F: interrupt: unexpected interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|config.slot
ques
c_cond
id|inb
c_func
(paren
id|config.icm_address
op_minus
l_int|1
)paren
suffix:colon
(paren
id|inb
c_func
(paren
id|SYS_DOORBELL_INTR
c_func
(paren
id|config.doorbell_address
)paren
)paren
op_amp
l_int|1
)paren
)paren
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_MULTI_CMD)
id|printk
c_func
(paren
l_string|&quot;Ux4F: multiple commands completed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
suffix:semicolon
macro_line|#endif
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_INTERRUPT)
id|printk
c_func
(paren
l_string|&quot;USx4F: interrupt: returning&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|do_ultrastor_interrupt
r_static
r_void
id|do_ultrastor_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|ultrastor_interrupt
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Eventually this will go into an include file, but this will be later */
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|ULTRASTOR_14F
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
eof
