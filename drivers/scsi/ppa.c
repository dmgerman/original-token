multiline_comment|/* ppa.c   --  low level driver for the IOMEGA PPA3 &n; * parallel port SCSI host adapter.&n; * &n; * (The PPA3 is the embedded controller in the ZIP drive.)&n; * &n; * (c) 1995,1996 Grant R. Guenther, grant@torque.net,&n; * under the terms of the GNU Public License.&n; * &n; * Current Maintainer: David Campbell (Perth, Western Australia, GMT+0800)&n; *                     campbell@torque.net&n; */
macro_line|#include &lt;linux/config.h&gt;
multiline_comment|/* The following #define is to avoid a clash with hosts.c */
DECL|macro|PPA_CODE
mdefine_line|#define PPA_CODE 1
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &quot;hosts.h&quot;
r_int
id|ppa_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
)paren
suffix:semicolon
r_static
r_void
id|ppa_reset_pulse
c_func
(paren
r_int
r_int
id|base
)paren
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|dev
r_struct
id|pardevice
op_star
id|dev
suffix:semicolon
multiline_comment|/* Parport device entry         */
DECL|member|base
r_int
id|base
suffix:semicolon
multiline_comment|/* Actual port address          */
DECL|member|mode
r_int
id|mode
suffix:semicolon
multiline_comment|/* Transfer mode                */
DECL|member|host
r_int
id|host
suffix:semicolon
multiline_comment|/* Host number (for proc)       */
DECL|member|cur_cmd
id|Scsi_Cmnd
op_star
id|cur_cmd
suffix:semicolon
multiline_comment|/* Current queued command       */
DECL|member|ppa_tq
r_struct
id|tq_struct
id|ppa_tq
suffix:semicolon
multiline_comment|/* Polling interupt stuff       */
DECL|member|jstart
r_int
r_int
id|jstart
suffix:semicolon
multiline_comment|/* Jiffies at start             */
DECL|member|recon_tmo
r_int
r_int
id|recon_tmo
suffix:semicolon
multiline_comment|/* How many usecs to wait for reconnection (6th bit) */
DECL|member|failed
r_int
r_int
id|failed
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Failure flag                 */
DECL|member|p_busy
r_int
r_int
id|p_busy
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Parport sharing busy flag    */
DECL|typedef|ppa_struct
)brace
id|ppa_struct
suffix:semicolon
DECL|macro|PPA_EMPTY
mdefine_line|#define PPA_EMPTY&t;&bslash;&n;{&t;dev:&t;&t;NULL,&t;&t;&bslash;&n;&t;base:&t;&t;-1,&t;&t;&bslash;&n;&t;mode:&t;&t;PPA_AUTODETECT,&t;&bslash;&n;&t;host:&t;&t;-1,&t;&t;&bslash;&n;&t;cur_cmd:&t;NULL,&t;&t;&bslash;&n;&t;ppa_tq:&t;&t;{ routine: ppa_interrupt },&t;&bslash;&n;&t;jstart:&t;&t;0,&t;&t;&bslash;&n;&t;recon_tmo:      PPA_RECON_TMO,&t;&bslash;&n;&t;failed:&t;&t;0,&t;&t;&bslash;&n;&t;p_busy:&t;&t;0&t;&t;&bslash;&n;}
macro_line|#include  &quot;ppa.h&quot;
DECL|macro|NO_HOSTS
mdefine_line|#define NO_HOSTS 4
DECL|variable|ppa_hosts
r_static
id|ppa_struct
id|ppa_hosts
(braket
id|NO_HOSTS
)braket
op_assign
(brace
id|PPA_EMPTY
comma
id|PPA_EMPTY
comma
id|PPA_EMPTY
comma
id|PPA_EMPTY
)brace
suffix:semicolon
DECL|macro|PPA_BASE
mdefine_line|#define PPA_BASE(x)&t;ppa_hosts[(x)].base
DECL|function|ppa_wakeup
r_void
id|ppa_wakeup
c_func
(paren
r_void
op_star
id|ref
)paren
(brace
id|ppa_struct
op_star
id|ppa_dev
op_assign
(paren
id|ppa_struct
op_star
)paren
id|ref
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppa_dev-&gt;p_busy
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|parport_claim
c_func
(paren
id|ppa_dev-&gt;dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppa: bug in ppa_wakeup&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ppa_dev-&gt;p_busy
op_assign
l_int|0
suffix:semicolon
id|ppa_dev-&gt;base
op_assign
id|ppa_dev-&gt;dev-&gt;port-&gt;base
suffix:semicolon
r_if
c_cond
(paren
id|ppa_dev-&gt;cur_cmd
)paren
id|ppa_dev-&gt;cur_cmd-&gt;SCp.phase
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|ppa_release
r_int
id|ppa_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_int
id|host_no
op_assign
id|host-&gt;unique_id
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Releasing ppa%i&bslash;n&quot;
comma
id|host_no
)paren
suffix:semicolon
id|parport_unregister_device
c_func
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ppa_pb_claim
r_static
r_int
id|ppa_pb_claim
c_func
(paren
r_int
id|host_no
)paren
(brace
r_if
c_cond
(paren
id|parport_claim
c_func
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|dev
)paren
)paren
(brace
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|p_busy
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
)paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd-&gt;SCp.phase
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|ppa_pb_release
mdefine_line|#define ppa_pb_release(x) parport_release(ppa_hosts[(x)].dev)
multiline_comment|/***************************************************************************&n; *                   Parallel port probing routines                        *&n; ***************************************************************************/
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|PPA
suffix:semicolon
macro_line|#include  &quot;scsi_module.c&quot;
multiline_comment|/*&n; * Start of Chipset kludges&n; */
DECL|function|ppa_detect
r_int
id|ppa_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|host
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|hreg
suffix:semicolon
r_int
id|ports
suffix:semicolon
r_int
id|i
comma
id|nhosts
comma
id|try_again
suffix:semicolon
r_struct
id|parport
op_star
id|pb
suffix:semicolon
multiline_comment|/*&n;     * unlock to allow the lowlevel parport driver to probe&n;     * the irqs&n;     */
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|pb
op_assign
id|parport_enumerate
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ppa: Version %s&bslash;n&quot;
comma
id|PPA_VERSION
)paren
suffix:semicolon
id|nhosts
op_assign
l_int|0
suffix:semicolon
id|try_again
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pb
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppa: parport reports no devices.&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|retry_entry
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|pb
suffix:semicolon
id|i
op_increment
comma
id|pb
op_assign
id|pb-&gt;next
)paren
(brace
r_int
id|modes
comma
id|ppb
comma
id|ppb_hi
suffix:semicolon
id|ppa_hosts
(braket
id|i
)braket
dot
id|dev
op_assign
id|parport_register_device
c_func
(paren
id|pb
comma
l_string|&quot;ppa&quot;
comma
l_int|NULL
comma
id|ppa_wakeup
comma
l_int|NULL
comma
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|ppa_hosts
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppa_hosts
(braket
id|i
)braket
dot
id|dev
)paren
r_continue
suffix:semicolon
multiline_comment|/* Claim the bus so it remembers what we do to the control&n;&t; * registers. [ CTR and ECP ]&n;&t; */
r_if
c_cond
(paren
id|ppa_pb_claim
c_func
(paren
id|i
)paren
)paren
(brace
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|ppa_hosts
(braket
id|i
)braket
dot
id|p_busy
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We are safe to schedule here */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|now
op_plus
l_int|3
op_star
id|HZ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppa%d: failed to claim parport because a &quot;
l_string|&quot;pardevice is owning the port for too longtime!&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|ppb
op_assign
id|PPA_BASE
c_func
(paren
id|i
)paren
op_assign
id|ppa_hosts
(braket
id|i
)braket
dot
id|dev-&gt;port-&gt;base
suffix:semicolon
id|ppb_hi
op_assign
id|ppa_hosts
(braket
id|i
)braket
dot
id|dev-&gt;port-&gt;base_hi
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|modes
op_assign
id|ppa_hosts
(braket
id|i
)braket
dot
id|dev-&gt;port-&gt;modes
suffix:semicolon
multiline_comment|/* Mode detection works up the chain of speed&n;&t; * This avoids a nasty if-then-else-if-... tree&n;&t; */
id|ppa_hosts
(braket
id|i
)braket
dot
id|mode
op_assign
id|PPA_NIBBLE
suffix:semicolon
r_if
c_cond
(paren
id|modes
op_amp
id|PARPORT_MODE_TRISTATE
)paren
id|ppa_hosts
(braket
id|i
)braket
dot
id|mode
op_assign
id|PPA_PS2
suffix:semicolon
r_if
c_cond
(paren
id|modes
op_amp
id|PARPORT_MODE_ECP
)paren
(brace
id|w_ecr
c_func
(paren
id|ppb_hi
comma
l_int|0x20
)paren
suffix:semicolon
id|ppa_hosts
(braket
id|i
)braket
dot
id|mode
op_assign
id|PPA_PS2
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|modes
op_amp
id|PARPORT_MODE_EPP
)paren
op_logical_and
(paren
id|modes
op_amp
id|PARPORT_MODE_ECP
)paren
)paren
id|w_ecr
c_func
(paren
id|ppb_hi
comma
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/* Done configuration */
id|ppa_pb_release
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppa_init
c_func
(paren
id|i
)paren
)paren
(brace
id|parport_unregister_device
c_func
(paren
id|ppa_hosts
(braket
id|i
)braket
dot
id|dev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* now the glue ... */
r_switch
c_cond
(paren
id|ppa_hosts
(braket
id|i
)braket
dot
id|mode
)paren
(brace
r_case
id|PPA_NIBBLE
suffix:colon
id|ports
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPA_PS2
suffix:colon
id|ports
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPA_EPP_8
suffix:colon
r_case
id|PPA_EPP_16
suffix:colon
r_case
id|PPA_EPP_32
suffix:colon
id|ports
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Never gets here */
r_continue
suffix:semicolon
)brace
id|host-&gt;can_queue
op_assign
id|PPA_CAN_QUEUE
suffix:semicolon
id|host-&gt;sg_tablesize
op_assign
id|ppa_sg
suffix:semicolon
id|hreg
op_assign
id|scsi_register
c_func
(paren
id|host
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hreg
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
id|hreg-&gt;io_port
op_assign
id|pb-&gt;base
suffix:semicolon
id|hreg-&gt;n_io_port
op_assign
id|ports
suffix:semicolon
id|hreg-&gt;dma_channel
op_assign
op_minus
l_int|1
suffix:semicolon
id|hreg-&gt;unique_id
op_assign
id|i
suffix:semicolon
id|ppa_hosts
(braket
id|i
)braket
dot
id|host
op_assign
id|hreg-&gt;host_no
suffix:semicolon
id|nhosts
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nhosts
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|try_again
op_eq
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;WARNING - no ppa compatible devices found.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  As of 31/Aug/1998 Iomega started shipping parallel&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  port ZIP drives with a different interface which is&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  supported by the imm (ZIP Plus) driver. If the&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  cable is marked with &bslash;&quot;AutoDetect&bslash;&quot;, this is what has&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  happened.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
)brace
id|try_again
op_assign
l_int|1
suffix:semicolon
r_goto
id|retry_entry
suffix:semicolon
)brace
r_else
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* return number of hosts detected */
)brace
)brace
multiline_comment|/* This is to give the ppa driver a way to modify the timings (and other&n; * parameters) by writing to the /proc/scsi/ppa/0 file.&n; * Very simple method really... (To simple, no error checking :( )&n; * Reason: Kernel hackers HATE having to unload and reload modules for&n; * testing...&n; * Also gives a method to use a script to obtain optimum timings (TODO)&n; */
DECL|function|ppa_proc_write
r_static
r_inline
r_int
id|ppa_proc_write
c_func
(paren
r_int
id|hostno
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_int
r_int
id|x
suffix:semicolon
r_if
c_cond
(paren
(paren
id|length
OG
l_int|5
)paren
op_logical_and
(paren
id|strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;mode=&quot;
comma
l_int|5
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|x
op_assign
id|simple_strtoul
c_func
(paren
id|buffer
op_plus
l_int|5
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|ppa_hosts
(braket
id|hostno
)braket
dot
id|mode
op_assign
id|x
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|length
OG
l_int|10
)paren
op_logical_and
(paren
id|strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;recon_tmo=&quot;
comma
l_int|10
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|x
op_assign
id|simple_strtoul
c_func
(paren
id|buffer
op_plus
l_int|10
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|ppa_hosts
(braket
id|hostno
)braket
dot
id|recon_tmo
op_assign
id|x
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ppa: recon_tmo set to %ld&bslash;n&quot;
comma
id|x
)paren
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ppa /proc: invalid variable&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
DECL|function|ppa_proc_info
r_int
id|ppa_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ppa_hosts
(braket
id|i
)braket
dot
id|host
op_eq
id|hostno
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|inout
)paren
r_return
id|ppa_proc_write
c_func
(paren
id|i
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Version : %s&bslash;n&quot;
comma
id|PPA_VERSION
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Parport : %s&bslash;n&quot;
comma
id|ppa_hosts
(braket
id|i
)braket
dot
id|dev-&gt;port-&gt;name
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Mode    : %s&bslash;n&quot;
comma
id|PPA_MODE_STRING
(braket
id|ppa_hosts
(braket
id|i
)braket
dot
id|mode
)braket
)paren
suffix:semicolon
macro_line|#if PPA_DEBUG &gt; 0
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;recon_tmo : %lu&bslash;n&quot;
comma
id|ppa_hosts
(braket
id|i
)braket
dot
id|recon_tmo
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Request for beyond end of buffer */
r_if
c_cond
(paren
id|offset
OG
id|length
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
id|len
op_sub_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_static
r_int
id|device_check
c_func
(paren
r_int
id|host_no
)paren
suffix:semicolon
macro_line|#if PPA_DEBUG &gt; 0
DECL|macro|ppa_fail
mdefine_line|#define ppa_fail(x,y) printk(&quot;ppa: ppa_fail(%i) from %s at line %d&bslash;n&quot;,&bslash;&n;&t;   y, __FUNCTION__, __LINE__); ppa_fail_func(x,y);
DECL|function|ppa_fail_func
r_static
r_inline
r_void
id|ppa_fail_func
c_func
(paren
r_int
id|host_no
comma
r_int
id|error_code
)paren
macro_line|#else
r_static
r_inline
r_void
id|ppa_fail
c_func
(paren
r_int
id|host_no
comma
r_int
id|error_code
)paren
macro_line|#endif
(brace
multiline_comment|/* If we fail a device then we trash status / message bytes */
r_if
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
)paren
(brace
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd-&gt;result
op_assign
id|error_code
op_lshift
l_int|16
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|failed
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Wait for the high bit to be set.&n; * &n; * In principle, this could be tied to an interrupt, but the adapter&n; * doesn&squot;t appear to be designed to support interrupts.  We spin on&n; * the 0x80 ready bit. &n; */
DECL|function|ppa_wait
r_static
r_int
r_char
id|ppa_wait
c_func
(paren
r_int
id|host_no
)paren
(brace
r_int
id|k
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|PPA_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_int
r_char
id|r
suffix:semicolon
id|k
op_assign
id|PPA_SPIN_TMO
suffix:semicolon
multiline_comment|/* Wait for bit 6 and 7 - PJC */
r_for
c_loop
(paren
id|r
op_assign
id|r_str
(paren
id|ppb
)paren
suffix:semicolon
(paren
(paren
id|r
op_amp
l_int|0xc0
)paren
op_ne
l_int|0xc0
)paren
op_logical_and
(paren
id|k
)paren
suffix:semicolon
id|k
op_decrement
)paren
(brace
id|udelay
(paren
l_int|1
)paren
suffix:semicolon
id|r
op_assign
id|r_str
(paren
id|ppb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * return some status information.&n;     * Semantics: 0xc0 = ZIP wants more data&n;     *            0xd0 = ZIP wants to send more data&n;     *            0xe0 = ZIP is expecting SCSI command data&n;     *            0xf0 = end of transfer, ZIP is sending status&n;     */
r_if
c_cond
(paren
id|k
)paren
r_return
(paren
id|r
op_amp
l_int|0xf0
)paren
suffix:semicolon
multiline_comment|/* Counter expired - Time out occurred */
id|ppa_fail
c_func
(paren
id|host_no
comma
id|DID_TIME_OUT
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ppa timeout in ppa_wait&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* command timed out */
)brace
multiline_comment|/*&n; * Clear EPP Timeout Bit &n; */
DECL|function|epp_reset
r_static
r_inline
r_void
id|epp_reset
c_func
(paren
r_int
r_int
id|ppb
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|w_str
c_func
(paren
id|ppb
comma
id|i
)paren
suffix:semicolon
id|w_str
c_func
(paren
id|ppb
comma
id|i
op_amp
l_int|0xfe
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Wait for empty ECP fifo (if we are in ECP fifo mode only)&n; */
DECL|function|ecp_sync
r_static
r_inline
r_void
id|ecp_sync
c_func
(paren
r_int
r_int
id|hostno
)paren
(brace
r_int
id|i
comma
id|ppb_hi
op_assign
id|ppa_hosts
(braket
id|hostno
)braket
dot
id|dev-&gt;port-&gt;base_hi
suffix:semicolon
r_if
c_cond
(paren
id|ppb_hi
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r_ecr
c_func
(paren
id|ppb_hi
)paren
op_amp
l_int|0xe0
)paren
op_eq
l_int|0x60
)paren
(brace
multiline_comment|/* mode 011 == ECP fifo mode */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|r_ecr
c_func
(paren
id|ppb_hi
)paren
op_amp
l_int|0x01
)paren
r_return
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ppa: ECP sync failed as data still present in FIFO.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|ppa_byte_out
r_static
r_int
id|ppa_byte_out
c_func
(paren
r_int
r_int
id|base
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|len
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|w_dtr
c_func
(paren
id|base
comma
op_star
id|buffer
op_increment
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0xe
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0xc
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* All went well - we hope! */
)brace
DECL|function|ppa_byte_in
r_static
r_int
id|ppa_byte_in
c_func
(paren
r_int
r_int
id|base
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|len
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
op_star
id|buffer
op_increment
op_assign
id|r_dtr
c_func
(paren
id|base
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x27
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x25
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* All went well - we hope! */
)brace
DECL|function|ppa_nibble_in
r_static
r_int
id|ppa_nibble_in
c_func
(paren
r_int
r_int
id|base
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|len
suffix:semicolon
id|len
op_decrement
)paren
(brace
r_int
r_char
id|h
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x4
)paren
suffix:semicolon
id|h
op_assign
id|r_str
c_func
(paren
id|base
)paren
op_amp
l_int|0xf0
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x6
)paren
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
id|h
op_or
(paren
(paren
id|r_str
c_func
(paren
id|base
)paren
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* All went well - we hope! */
)brace
DECL|function|ppa_out
r_static
r_int
id|ppa_out
c_func
(paren
r_int
id|host_no
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|r
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|PPA_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|r
op_assign
id|ppa_wait
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|0x50
)paren
op_ne
l_int|0x40
)paren
(brace
id|ppa_fail
c_func
(paren
id|host_no
comma
id|DID_ERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
)paren
(brace
r_case
id|PPA_NIBBLE
suffix:colon
r_case
id|PPA_PS2
suffix:colon
multiline_comment|/* 8 bit output, with a loop */
id|r
op_assign
id|ppa_byte_out
c_func
(paren
id|ppb
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPA_EPP_32
suffix:colon
r_case
id|PPA_EPP_16
suffix:colon
r_case
id|PPA_EPP_8
suffix:colon
id|epp_reset
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI_IZIP_EPP16
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
r_int
)paren
id|buffer
op_or
id|len
)paren
op_amp
l_int|0x01
)paren
)paren
id|outsw
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
op_rshift
l_int|1
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
r_int
)paren
id|buffer
op_or
id|len
)paren
op_amp
l_int|0x03
)paren
)paren
id|outsl
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
op_rshift
l_int|2
)paren
suffix:semicolon
macro_line|#endif
r_else
id|outsb
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|r
op_assign
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x01
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;PPA: bug in ppa_out()&bslash;n&quot;
)paren
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
DECL|function|ppa_in
r_static
r_int
id|ppa_in
c_func
(paren
r_int
id|host_no
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|r
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|PPA_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|r
op_assign
id|ppa_wait
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|0x50
)paren
op_ne
l_int|0x50
)paren
(brace
id|ppa_fail
c_func
(paren
id|host_no
comma
id|DID_ERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
)paren
(brace
r_case
id|PPA_NIBBLE
suffix:colon
multiline_comment|/* 4 bit input, with a loop */
id|r
op_assign
id|ppa_nibble_in
c_func
(paren
id|ppb
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPA_PS2
suffix:colon
multiline_comment|/* 8 bit input, with a loop */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x25
)paren
suffix:semicolon
id|r
op_assign
id|ppa_byte_in
c_func
(paren
id|ppb
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPA_EPP_32
suffix:colon
r_case
id|PPA_EPP_16
suffix:colon
r_case
id|PPA_EPP_8
suffix:colon
id|epp_reset
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x24
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI_IZIP_EPP16
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
r_int
)paren
id|buffer
op_or
id|len
)paren
op_amp
l_int|0x01
)paren
)paren
id|insw
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
op_rshift
l_int|1
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
r_int
)paren
id|buffer
op_or
id|len
)paren
op_amp
l_int|0x03
)paren
)paren
id|insl
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
op_rshift
l_int|2
)paren
suffix:semicolon
macro_line|#endif
r_else
id|insb
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x2c
)paren
suffix:semicolon
id|r
op_assign
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x01
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x2c
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;PPA: bug in ppa_ins()&bslash;n&quot;
)paren
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/* end of ppa_io.h */
DECL|function|ppa_d_pulse
r_static
r_inline
r_void
id|ppa_d_pulse
c_func
(paren
r_int
r_int
id|ppb
comma
r_int
r_char
id|b
)paren
(brace
id|w_dtr
c_func
(paren
id|ppb
comma
id|b
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xe
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
)brace
DECL|function|ppa_disconnect
r_static
r_void
id|ppa_disconnect
c_func
(paren
r_int
id|host_no
)paren
(brace
r_int
r_int
id|ppb
op_assign
id|PPA_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|ppa_d_pulse
c_func
(paren
id|ppb
comma
l_int|0
)paren
suffix:semicolon
id|ppa_d_pulse
c_func
(paren
id|ppb
comma
l_int|0x3c
)paren
suffix:semicolon
id|ppa_d_pulse
c_func
(paren
id|ppb
comma
l_int|0x20
)paren
suffix:semicolon
id|ppa_d_pulse
c_func
(paren
id|ppb
comma
l_int|0xf
)paren
suffix:semicolon
)brace
DECL|function|ppa_c_pulse
r_static
r_inline
r_void
id|ppa_c_pulse
c_func
(paren
r_int
r_int
id|ppb
comma
r_int
r_char
id|b
)paren
(brace
id|w_dtr
c_func
(paren
id|ppb
comma
id|b
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x6
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
)brace
DECL|function|ppa_connect
r_static
r_inline
r_void
id|ppa_connect
c_func
(paren
r_int
id|host_no
comma
r_int
id|flag
)paren
(brace
r_int
r_int
id|ppb
op_assign
id|PPA_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|ppa_c_pulse
c_func
(paren
id|ppb
comma
l_int|0
)paren
suffix:semicolon
id|ppa_c_pulse
c_func
(paren
id|ppb
comma
l_int|0x3c
)paren
suffix:semicolon
id|ppa_c_pulse
c_func
(paren
id|ppb
comma
l_int|0x20
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flag
op_eq
id|CONNECT_EPP_MAYBE
)paren
op_logical_and
id|IN_EPP_MODE
c_func
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
)paren
)paren
id|ppa_c_pulse
c_func
(paren
id|ppb
comma
l_int|0xcf
)paren
suffix:semicolon
r_else
id|ppa_c_pulse
c_func
(paren
id|ppb
comma
l_int|0x8f
)paren
suffix:semicolon
)brace
DECL|function|ppa_select
r_static
r_int
id|ppa_select
c_func
(paren
r_int
id|host_no
comma
r_int
id|target
)paren
(brace
r_int
id|k
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|PPA_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
multiline_comment|/*&n;     * Bit 6 (0x40) is the device selected bit.&n;     * First we must wait till the current device goes off line...&n;     */
id|k
op_assign
id|PPA_SELECT_TMO
suffix:semicolon
r_do
(brace
id|k
op_decrement
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x40
)paren
op_logical_and
(paren
id|k
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|k
)paren
r_return
l_int|0
suffix:semicolon
id|w_dtr
c_func
(paren
id|ppb
comma
(paren
l_int|1
op_lshift
id|target
)paren
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xe
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/* This is NOT the initator */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x8
)paren
suffix:semicolon
id|k
op_assign
id|PPA_SELECT_TMO
suffix:semicolon
r_do
(brace
id|k
op_decrement
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x40
)paren
op_logical_and
(paren
id|k
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|k
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n; * This is based on a trace of what the Iomega DOS &squot;guest&squot; driver does.&n; * I&squot;ve tried several different kinds of parallel ports with guest and&n; * coded this to react in the same ways that it does.&n; * &n; * The return value from this function is just a hint about where the&n; * handshaking failed.&n; * &n; */
DECL|function|ppa_init
r_static
r_int
id|ppa_init
c_func
(paren
r_int
id|host_no
)paren
(brace
r_int
id|retv
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|PPA_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_PARPORT) || defined(CONFIG_PARPORT_MODULE)
r_if
c_cond
(paren
id|ppa_pb_claim
c_func
(paren
id|host_no
)paren
)paren
r_while
c_loop
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|p_busy
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We can safe schedule here */
macro_line|#endif
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|ppa_connect
c_func
(paren
id|host_no
comma
id|CONNECT_NORMAL
)paren
suffix:semicolon
id|retv
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Failed */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xe
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x08
)paren
op_eq
l_int|0x08
)paren
id|retv
op_decrement
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x08
)paren
op_eq
l_int|0x00
)paren
id|retv
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retv
)paren
id|ppa_reset_pulse
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* Allow devices to settle down */
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* Another delay to allow devices to settle */
r_if
c_cond
(paren
op_logical_neg
id|retv
)paren
id|retv
op_assign
id|device_check
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|ppa_pb_release
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
DECL|function|ppa_send_command
r_static
r_inline
r_int
id|ppa_send_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_int
id|k
suffix:semicolon
id|w_ctr
c_func
(paren
id|PPA_BASE
c_func
(paren
id|host_no
)paren
comma
l_int|0x0c
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|cmd-&gt;cmd_len
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|ppa_out
c_func
(paren
id|host_no
comma
op_amp
id|cmd-&gt;cmnd
(braket
id|k
)braket
comma
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * The bulk flag enables some optimisations in the data transfer loops,&n; * it should be true for any command that transfers data in integral&n; * numbers of sectors.&n; * &n; * The driver appears to remain stable if we speed up the parallel port&n; * i/o in this function, but not elsewhere.&n; */
DECL|function|ppa_completion
r_static
r_int
id|ppa_completion
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/* Return codes:&n;     * -1     Error&n;     *  0     Told to schedule&n;     *  1     Finished data transfer&n;     */
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|PPA_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_int
r_int
id|start_jiffies
op_assign
id|jiffies
suffix:semicolon
r_int
r_char
id|r
comma
id|v
suffix:semicolon
r_int
id|fast
comma
id|bulk
comma
id|status
suffix:semicolon
id|v
op_assign
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
id|bulk
op_assign
(paren
(paren
id|v
op_eq
id|READ_6
)paren
op_logical_or
(paren
id|v
op_eq
id|READ_10
)paren
op_logical_or
(paren
id|v
op_eq
id|WRITE_6
)paren
op_logical_or
(paren
id|v
op_eq
id|WRITE_10
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * We only get here if the drive is ready to comunicate,&n;     * hence no need for a full ppa_wait.&n;     */
id|r
op_assign
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0xf0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|r
op_ne
(paren
r_int
r_char
)paren
l_int|0xf0
)paren
(brace
multiline_comment|/*&n;&t; * If we have been running for more than a full timer tick&n;&t; * then take a rest.&n;&t; */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|start_jiffies
op_plus
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd-&gt;SCp.this_residual
op_le
l_int|0
)paren
)paren
(brace
id|ppa_fail
c_func
(paren
id|host_no
comma
id|DID_ERROR
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ERROR_RETURN */
)brace
multiline_comment|/* On some hardware we have SCSI disconnected (6th bit low)&n;&t; * for about 100usecs. It is too expensive to wait a &n;&t; * tick on every loop so we busy wait for no more than&n;&t; * 500usecs to give the drive a chance first. We do not &n;&t; * change things for &quot;normal&quot; hardware since generally &n;&t; * the 6th bit is always high.&n;&t; * This makes the CPU load higher on some hardware &n;&t; * but otherwise we can not get more then 50K/secs &n;&t; * on this problem hardware.&n;&t; */
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|0xc0
)paren
op_ne
l_int|0xc0
)paren
(brace
multiline_comment|/* Wait for reconnection should be no more than &n;&t;    * jiffy/2 = 5ms = 5000 loops&n;&t;    */
r_int
r_int
id|k
op_assign
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|recon_tmo
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|k
op_logical_and
(paren
(paren
id|r
op_assign
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0xf0
)paren
)paren
op_amp
l_int|0xc0
)paren
op_ne
l_int|0xc0
suffix:semicolon
id|k
op_decrement
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|k
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* determine if we should use burst I/O */
id|fast
op_assign
(paren
id|bulk
op_logical_and
(paren
id|cmd-&gt;SCp.this_residual
op_ge
id|PPA_BURST_SIZE
)paren
)paren
ques
c_cond
id|PPA_BURST_SIZE
suffix:colon
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
(paren
r_int
r_char
)paren
l_int|0xc0
)paren
id|status
op_assign
id|ppa_out
c_func
(paren
id|host_no
comma
id|cmd-&gt;SCp.ptr
comma
id|fast
)paren
suffix:semicolon
r_else
id|status
op_assign
id|ppa_in
c_func
(paren
id|host_no
comma
id|cmd-&gt;SCp.ptr
comma
id|fast
)paren
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_add_assign
id|fast
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_sub_assign
id|fast
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
id|ppa_fail
c_func
(paren
id|host_no
comma
id|DID_BUS_BUSY
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ERROR_RETURN */
)brace
r_if
c_cond
(paren
id|cmd-&gt;SCp.buffer
op_logical_and
op_logical_neg
id|cmd-&gt;SCp.this_residual
)paren
(brace
multiline_comment|/* if scatter/gather, advance to the next segment */
r_if
c_cond
(paren
id|cmd-&gt;SCp.buffers_residual
op_decrement
)paren
(brace
id|cmd-&gt;SCp.buffer
op_increment
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|cmd-&gt;SCp.buffer-&gt;address
suffix:semicolon
)brace
)brace
multiline_comment|/* Now check to see if the drive is ready to comunicate */
id|r
op_assign
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0xf0
)paren
suffix:semicolon
multiline_comment|/* If not, drop back down to the scheduler and wait a timer tick */
r_if
c_cond
(paren
op_logical_neg
(paren
id|r
op_amp
l_int|0x80
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* FINISH_RETURN */
)brace
multiline_comment|/* deprecated synchronous interface */
DECL|function|ppa_command
r_int
id|ppa_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_static
r_int
id|first_pass
op_assign
l_int|1
suffix:semicolon
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_if
c_cond
(paren
id|first_pass
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppa: using non-queuing interface&bslash;n&quot;
)paren
suffix:semicolon
id|first_pass
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PPA: bug in ppa_command&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|failed
op_assign
l_int|0
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|jstart
op_assign
id|jiffies
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
op_assign
id|cmd
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* default return code */
id|cmd-&gt;SCp.phase
op_assign
l_int|0
suffix:semicolon
id|ppa_pb_claim
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ppa_engine
c_func
(paren
op_amp
id|ppa_hosts
(braket
id|host_no
)braket
comma
id|cmd
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;SCp.phase
)paren
multiline_comment|/* Only disconnect if we have connected */
id|ppa_disconnect
c_func
(paren
id|cmd-&gt;host-&gt;unique_id
)paren
suffix:semicolon
id|ppa_pb_release
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
op_assign
l_int|0
suffix:semicolon
r_return
id|cmd-&gt;result
suffix:semicolon
)brace
multiline_comment|/*&n; * Since the PPA itself doesn&squot;t generate interrupts, we use&n; * the scheduler&squot;s task queue to generate a stream of call-backs and&n; * complete the request when the drive is ready.&n; */
DECL|function|ppa_interrupt
r_static
r_void
id|ppa_interrupt
c_func
(paren
r_void
op_star
id|data
)paren
(brace
id|ppa_struct
op_star
id|tmp
op_assign
(paren
id|ppa_struct
op_star
)paren
id|data
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
op_assign
id|tmp-&gt;cur_cmd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PPA: bug in ppa_interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppa_engine
c_func
(paren
id|tmp
comma
id|cmd
)paren
)paren
(brace
id|tmp-&gt;ppa_tq.data
op_assign
(paren
r_void
op_star
)paren
id|tmp
suffix:semicolon
id|tmp-&gt;ppa_tq.sync
op_assign
l_int|0
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|tmp-&gt;ppa_tq
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Command must of completed hence it is safe to let go... */
macro_line|#if PPA_DEBUG &gt; 0
r_switch
c_cond
(paren
(paren
id|cmd-&gt;result
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
(brace
r_case
id|DID_OK
suffix:colon
r_break
suffix:semicolon
r_case
id|DID_NO_CONNECT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: no device at SCSI ID %i&bslash;n&quot;
comma
id|cmd-&gt;target
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_BUS_BUSY
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: BUS BUSY - EPP timeout detected&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_TIME_OUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: unknown timeout&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_ABORT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: told to abort&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_PARITY
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: parity error (???)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_ERROR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: internal driver error&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_RESET
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: told to reset device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_BAD_INTR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: bad interrupt (???)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: bad return code (%02x)&bslash;n&quot;
comma
(paren
id|cmd-&gt;result
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|cmd-&gt;SCp.phase
OG
l_int|1
)paren
id|ppa_disconnect
c_func
(paren
id|cmd-&gt;host-&gt;unique_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;SCp.phase
OG
l_int|0
)paren
id|ppa_pb_release
c_func
(paren
id|cmd-&gt;host-&gt;unique_id
)paren
suffix:semicolon
id|tmp-&gt;cur_cmd
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|ppa_engine
r_static
r_int
id|ppa_engine
c_func
(paren
id|ppa_struct
op_star
id|tmp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|PPA_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_int
r_char
id|l
op_assign
l_int|0
comma
id|h
op_assign
l_int|0
suffix:semicolon
r_int
id|retv
suffix:semicolon
multiline_comment|/* First check for any errors that may of occurred&n;     * Here we check for internal errors&n;     */
r_if
c_cond
(paren
id|tmp-&gt;failed
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;SCp.phase
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Phase 0 - Waiting for parport */
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|tmp-&gt;jstart
)paren
OG
id|HZ
)paren
(brace
multiline_comment|/*&n;&t;     * We waited more than a second&n;&t;     * for parport to call us&n;&t;     */
id|ppa_fail
c_func
(paren
id|host_no
comma
id|DID_BUS_BUSY
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* wait until ppa_wakeup claims parport */
r_case
l_int|1
suffix:colon
multiline_comment|/* Phase 1 - Connected */
(brace
multiline_comment|/* Perform a sanity check for cable unplugged */
r_int
id|retv
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Failed */
id|ppa_connect
c_func
(paren
id|host_no
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xe
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x08
)paren
op_eq
l_int|0x08
)paren
id|retv
op_decrement
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x08
)paren
op_eq
l_int|0x00
)paren
id|retv
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|retv
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|tmp-&gt;jstart
)paren
OG
(paren
l_int|1
op_star
id|HZ
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppa: Parallel port cable is unplugged!!&bslash;n&quot;
)paren
suffix:semicolon
id|ppa_fail
c_func
(paren
id|host_no
comma
id|DID_BUS_BUSY
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Try again in a jiffy */
)brace
)brace
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
)brace
r_case
l_int|2
suffix:colon
multiline_comment|/* Phase 2 - We are now talking to the scsi bus */
r_if
c_cond
(paren
op_logical_neg
id|ppa_select
c_func
(paren
id|host_no
comma
id|cmd-&gt;target
)paren
)paren
(brace
id|ppa_fail
c_func
(paren
id|host_no
comma
id|DID_NO_CONNECT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* Phase 3 - Ready to accept a command */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x80
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppa_send_command
c_func
(paren
id|cmd
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* Phase 4 - Setup scatter/gather buffers */
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
multiline_comment|/* if many buffers are available, start filling the first */
id|cmd-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|cmd-&gt;SCp.buffer-&gt;address
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* else fill the only available buffer */
id|cmd-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|cmd-&gt;request_buffer
suffix:semicolon
)brace
id|cmd-&gt;SCp.buffers_residual
op_assign
id|cmd-&gt;use_sg
suffix:semicolon
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
r_case
l_int|5
suffix:colon
multiline_comment|/* Phase 5 - Data transfer stage */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x80
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|retv
op_assign
id|ppa_completion
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retv
op_eq
op_minus
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|retv
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* Phase 6 - Read status/message */
id|cmd-&gt;result
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* Check for data overrun */
r_if
c_cond
(paren
id|ppa_wait
c_func
(paren
id|host_no
)paren
op_ne
(paren
r_int
r_char
)paren
l_int|0xf0
)paren
(brace
id|ppa_fail
c_func
(paren
id|host_no
comma
id|DID_ERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppa_in
c_func
(paren
id|host_no
comma
op_amp
id|l
comma
l_int|1
)paren
)paren
(brace
multiline_comment|/* read status byte */
multiline_comment|/* Check for optional message byte */
r_if
c_cond
(paren
id|ppa_wait
c_func
(paren
id|host_no
)paren
op_eq
(paren
r_int
r_char
)paren
l_int|0xf0
)paren
id|ppa_in
c_func
(paren
id|host_no
comma
op_amp
id|h
comma
l_int|1
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_OK
op_lshift
l_int|16
)paren
op_plus
(paren
id|h
op_lshift
l_int|8
)paren
op_plus
(paren
id|l
op_amp
id|STATUS_MASK
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Finished */
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: Invalid scsi phase&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ppa_queuecommand
r_int
id|ppa_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_if
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PPA: bug in ppa_queuecommand&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|failed
op_assign
l_int|0
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|jstart
op_assign
id|jiffies
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
op_assign
id|cmd
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* default return code */
id|cmd-&gt;SCp.phase
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bus free */
id|ppa_pb_claim
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|ppa_tq.data
op_assign
id|ppa_hosts
op_plus
id|host_no
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|ppa_tq.sync
op_assign
l_int|0
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|ppa_tq
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Apparently the the disk-&gt;capacity attribute is off by 1 sector &n; * for all disk drives.  We add the one here, but it should really&n; * be done in sd.c.  Even if it gets fixed there, this will still&n; * work.&n; */
DECL|function|ppa_biosparam
r_int
id|ppa_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
id|ip
(braket
)braket
)paren
(brace
id|ip
(braket
l_int|0
)braket
op_assign
l_int|0x40
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|0x20
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
(paren
id|disk-&gt;capacity
op_plus
l_int|1
)paren
op_div
(paren
id|ip
(braket
l_int|0
)braket
op_star
id|ip
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
(braket
l_int|2
)braket
OG
l_int|1024
)paren
(brace
id|ip
(braket
l_int|0
)braket
op_assign
l_int|0xff
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|0x3f
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
(paren
id|disk-&gt;capacity
op_plus
l_int|1
)paren
op_div
(paren
id|ip
(braket
l_int|0
)braket
op_star
id|ip
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
(braket
l_int|2
)braket
OG
l_int|1023
)paren
id|ip
(braket
l_int|2
)braket
op_assign
l_int|1023
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ppa_abort
r_int
id|ppa_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
multiline_comment|/*&n;     * There is no method for aborting commands since Iomega&n;     * have tied the SCSI_MESSAGE line high in the interface&n;     */
r_switch
c_cond
(paren
id|cmd-&gt;SCp.phase
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Do not have access to parport */
r_case
l_int|1
suffix:colon
multiline_comment|/* Have not connected to interface */
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Forget the problem */
r_return
id|SUCCESS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* SCSI command sent, can not abort */
r_return
id|FAILED
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|ppa_reset_pulse
r_static
r_void
id|ppa_reset_pulse
c_func
(paren
r_int
r_int
id|base
)paren
(brace
id|w_dtr
c_func
(paren
id|base
comma
l_int|0x40
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x8
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|30
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0xc
)paren
suffix:semicolon
)brace
DECL|function|ppa_reset
r_int
id|ppa_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;SCp.phase
)paren
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Forget the problem */
id|ppa_connect
c_func
(paren
id|host_no
comma
id|CONNECT_NORMAL
)paren
suffix:semicolon
id|ppa_reset_pulse
c_func
(paren
id|PPA_BASE
c_func
(paren
id|host_no
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* device settle delay */
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* device settle delay */
r_return
id|SUCCESS
suffix:semicolon
)brace
DECL|function|device_check
r_static
r_int
id|device_check
c_func
(paren
r_int
id|host_no
)paren
(brace
multiline_comment|/* This routine looks for a device and then attempts to use EPP&n;       to send a command. If all goes as planned then EPP is available. */
r_static
r_char
id|cmd
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_int
id|loop
comma
id|old_mode
comma
id|status
comma
id|k
comma
id|ppb
op_assign
id|PPA_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_int
r_char
id|l
suffix:semicolon
id|old_mode
op_assign
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
l_int|8
suffix:semicolon
id|loop
op_increment
)paren
(brace
multiline_comment|/* Attempt to use EPP for Test Unit Ready */
r_if
c_cond
(paren
(paren
id|ppb
op_amp
l_int|0x0007
)paren
op_eq
l_int|0x0000
)paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
op_assign
id|PPA_EPP_32
suffix:semicolon
id|second_pass
suffix:colon
id|ppa_connect
c_func
(paren
id|host_no
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
multiline_comment|/* Select SCSI device */
r_if
c_cond
(paren
op_logical_neg
id|ppa_select
c_func
(paren
id|host_no
comma
id|loop
)paren
)paren
(brace
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ppa: Found device at ID %i, Attempting to use %s&bslash;n&quot;
comma
id|loop
comma
id|PPA_MODE_STRING
(braket
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
)braket
)paren
suffix:semicolon
multiline_comment|/* Send SCSI command */
id|status
op_assign
l_int|1
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
(paren
id|l
OL
l_int|6
)paren
op_logical_and
(paren
id|status
)paren
suffix:semicolon
id|l
op_increment
)paren
id|status
op_assign
id|ppa_out
c_func
(paren
id|host_no
comma
id|cmd
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|ppa_connect
c_func
(paren
id|host_no
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0x40
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x08
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|30
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
op_eq
id|PPA_EPP_32
)paren
(brace
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
op_assign
id|old_mode
suffix:semicolon
r_goto
id|second_pass
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ppa: Unable to establish communication, aborting driver load.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|k
op_assign
l_int|1000000
suffix:semicolon
multiline_comment|/* 1 Second */
r_do
(brace
id|l
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|k
op_decrement
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|l
op_amp
l_int|0x80
)paren
op_logical_and
(paren
id|k
)paren
)paren
suffix:semicolon
id|l
op_and_assign
l_int|0xf0
suffix:semicolon
r_if
c_cond
(paren
id|l
op_ne
l_int|0xf0
)paren
(brace
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|ppa_connect
c_func
(paren
id|host_no
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
id|ppa_reset_pulse
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
op_eq
id|PPA_EPP_32
)paren
(brace
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
op_assign
id|old_mode
suffix:semicolon
r_goto
id|second_pass
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ppa: Unable to establish communication, aborting driver load.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ppa: Communication established with ID %i using %s&bslash;n&quot;
comma
id|loop
comma
id|PPA_MODE_STRING
(braket
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
)braket
)paren
suffix:semicolon
id|ppa_connect
c_func
(paren
id|host_no
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
id|ppa_reset_pulse
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ppa: No devices found, aborting driver load.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
eof
