multiline_comment|/* ppa.c   --  low level driver for the IOMEGA PPA3 &n; * parallel port SCSI host adapter.&n; * &n; * (The PPA3 is the embedded controller in the ZIP drive.)&n; * &n; * (c) 1995,1996 Grant R. Guenther, grant@torque.net,&n; * under the terms of the GNU Public License.&n; * &n; */
multiline_comment|/*      This driver was developed without the benefit of any technical&n; * specifications for the interface.  Instead, a modified version of&n; * DOSemu was used to monitor the protocol used by the DOS driver&n; * for this adapter.  I have no idea how my programming model relates&n; * to IOMEGA&squot;s design.&n; * &n; * IOMEGA&squot;s driver does not generate linked commands.  I&squot;ve never&n; * observed a SCSI message byte in the protocol transactions, so&n; * I am assuming that as long as linked commands are not used&n; * we won&squot;t see any.  &n; * &n; * For more information, see the file drivers/scsi/README.ppa.&n; * &n; */
multiline_comment|/* &n; * this driver has been hacked by Matteo Frigo (athena@theory.lcs.mit.edu)&n; * to support EPP and scatter-gather.                        [0.26-athena]&n; *&n; * additional hacks by David Campbell (campbell@tirian.che.curtin.edu.au)&n; * in response to this driver &quot;mis-behaving&quot; on his machine.&n; *      Fixed EPP to handle &quot;software&quot; changing of EPP port data direction.&n; *      Chased down EPP timeouts&n; *      Made this driver &quot;kernel version friendly&quot;           [0.28-athena]&n; *&n; * Really hacked it out of existance (David Campbell)&n; *      EPP timeouts no longer occur (yet better handling)&n; *      Probes known parallel ports&n; *      Autodetects EPP / ECP / PS2 / NIBBLE&n; *      Support for multiple devices (does anyone need this??)&n; *                                                           [0.29-Curtin]&n; * [ Stuff removed ]&n; *&n; *      Modified PEDANTIC for less PEDANTIC drivers as people&n; *      were complaining about speed (I received a report indicating&n; *      that PEDANTIC is necessary for WinBond chipsets.&n; *      Updated config_ppa and Makefile&n; *                                                           [0.36b-Curtin]&n; *&n; * First round of cleanups&n; *      Remove prior 1.3.34 kernel support&n; *      SMC support changed&n; *              ECP+EPP detection always invoked.&n; *              If compat mode =&gt; PS/2&n; *              else ecp_sync() called (ECP+EPP uses FIFO).&n; *      Added routine to detect interrupt channel for ECP (not used)&n; *      Changed version numbering&n; *              1       Major number&n; *              00      Minor revision number&n; *              ALPHA   Expected stability (alpha, beta, stable)&n; *                                              [Curtin-1-00-ALPHA]&n; * Second round of cleanups&n; *      Clean up timer queues&n; *      Fixed problem with non-detection of PS/2 ports&n; *      SMC ECP+EPP confirmed to work, remove option from config_ppa&n; *                                              [Curtin-1-01-ALPHA]&n; *&n; * Parport hits with a vengance!!&n; *      Several internal revisions have been made with huge amounts of&n; *      fixes including:&n; *              ioport_2_hostno removed (unique_id is quicker)&n; *              SMC compat option is history&n; *              Driver name / info hardwired&n; *              Played with inlines and saved 4k on module&n; *      Parport support&n; *              Using PnP Parport allows use of printer attached to&n; *              ZIP drive.&n; *              Numerous fixups for device registration and to allow&n; *              proper aborts.&n; *      Version jumps a few numbers here - considered BETA&n; *      Shipping Parport with monolithic driver :)&n; *                                              [Curtin-1-05-BETA]&n; *&n; * Fixed code to ensure SCSI abort will release the SCSI command&n; *      if the driver is STILL trying to claim the parport (PNP ver)&n; *      Now I have to fix the lp driver then there will NEVER be a&n; *      problem.&n; *      Got around to doing the ppa_queuecommand() clean up&n; *      Fixed bug relating to SMC EPP+ECP and monolithic driver&n; *                                              [Curtin-1-06-BETA]&n; *&n; * Where did the ppa_setup() code disappear to ??&n; *      Back in now...&n; *      Distribution of ppa now independent of parport (less work for me).&n; *      Also cleaned up the port detection to allow for variations on&n; *      IO aliasing (in an attempt to fix a few problems with some&n; *      machines...)&n; *                                              [Curtin-1-07-BETA]&n; *&n; * Rewrote detection code for monolithic driver and ported changes to&n; *      parport driver. Result is more stable detection of hardware and&n; *      better immunity to port aliasing (old XT cards).&n; *      Parport 0.16 (or better) is required for parport operation and&n; *      ECP+EPP modes, otherwise the latest parport edition is recommended.&n; *&n; *      When using EPP and writing to disk CPU usage &gt; 40%, while reading &lt;10%.&n; *      This is due to ZIP drive IO scheduling, the drive does a verify after&n; *      write to ensure data integrity (removable media is ALWAYS questionable&n; *      since you never know where it has been).&n; *      Some fancy programing *MAY* fix the problem but at 30 Mb/min is just&n; *      over 10 sectors per jiffy.&n; *&n; *      Hmm... I think I know a way but it will send the driver into&n; *      ALPHA state again.&n; *                                              [Curtin-1-08-STABLE]&n; */
macro_line|#include &lt;linux/config.h&gt;
multiline_comment|/* The following #define is to avoid a clash with hosts.c */
DECL|macro|PPA_CODE
mdefine_line|#define PPA_CODE 1
macro_line|#include  &quot;ppa.h&quot;
multiline_comment|/* batteries not included :-) */
multiline_comment|/*&n; * modes in which the driver can operate &n; */
DECL|macro|PPA_AUTODETECT
mdefine_line|#define   PPA_AUTODETECT        0&t;/* Autodetect mode                */
DECL|macro|PPA_NIBBLE
mdefine_line|#define   PPA_NIBBLE            1&t;/* work in standard 4 bit mode    */
DECL|macro|PPA_PS2
mdefine_line|#define   PPA_PS2               2&t;/* PS/2 byte mode         */
DECL|macro|PPA_EPP_8
mdefine_line|#define   PPA_EPP_8             3&t;/* EPP mode, 8 bit                */
DECL|macro|PPA_EPP_16
mdefine_line|#define   PPA_EPP_16            4&t;/* EPP mode, 16 bit               */
DECL|macro|PPA_EPP_32
mdefine_line|#define   PPA_EPP_32            5&t;/* EPP mode, 32 bit               */
DECL|macro|PPA_UNKNOWN
mdefine_line|#define   PPA_UNKNOWN           6&t;/* Just in case...                */
DECL|variable|PPA_MODE_STRING
r_static
r_char
op_star
id|PPA_MODE_STRING
(braket
)braket
op_assign
(brace
l_string|&quot;Autodetect&quot;
comma
l_string|&quot;SPP&quot;
comma
l_string|&quot;PS/2&quot;
comma
l_string|&quot;EPP 8 bit&quot;
comma
l_string|&quot;EPP 16 bit&quot;
comma
l_string|&quot;EPP 32 bit&quot;
comma
l_string|&quot;Unknown&quot;
)brace
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|dev
r_struct
id|pardevice
op_star
id|dev
suffix:semicolon
multiline_comment|/* Parport device entry          */
DECL|member|speed
r_int
id|speed
suffix:semicolon
multiline_comment|/* General PPA delay constant   */
DECL|member|speed_fast
r_int
id|speed_fast
suffix:semicolon
multiline_comment|/* Const for nibble/byte modes  */
DECL|member|epp_speed
r_int
id|epp_speed
suffix:semicolon
multiline_comment|/* Reset time period            */
DECL|member|mode
r_int
id|mode
suffix:semicolon
multiline_comment|/* Transfer mode                */
DECL|member|timeout
r_int
id|timeout
suffix:semicolon
multiline_comment|/* Number of timeouts           */
DECL|member|host
r_int
id|host
suffix:semicolon
multiline_comment|/* Host number (for proc)       */
DECL|member|abort_flag
r_int
id|abort_flag
suffix:semicolon
multiline_comment|/* Abort flag                   */
DECL|member|error_code
r_int
id|error_code
suffix:semicolon
multiline_comment|/* Error code                   */
DECL|member|ppa_failed
r_int
id|ppa_failed
suffix:semicolon
multiline_comment|/* Failure flag                 */
DECL|member|cur_cmd
id|Scsi_Cmnd
op_star
id|cur_cmd
suffix:semicolon
multiline_comment|/* Current queued command       */
DECL|member|done
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
multiline_comment|/* Done func for queuecommand   */
DECL|member|ppa_tq
r_struct
id|tq_struct
id|ppa_tq
suffix:semicolon
multiline_comment|/* Polling interupt stuff       */
DECL|member|ppa_wait_q
r_struct
id|wait_queue
op_star
id|ppa_wait_q
suffix:semicolon
multiline_comment|/* Used for PnP stuff           */
DECL|typedef|ppa_struct
)brace
id|ppa_struct
suffix:semicolon
r_static
r_void
id|ppa_interrupt
c_func
(paren
r_void
op_star
id|data
)paren
suffix:semicolon
multiline_comment|/* I know that this is a mess but it works!! */
DECL|macro|NO_HOSTS
mdefine_line|#define NO_HOSTS 4
DECL|variable|ppa_hosts
r_static
id|ppa_struct
id|ppa_hosts
(braket
id|NO_HOSTS
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|6
comma
l_int|1
comma
id|CONFIG_SCSI_PPA_EPP_TIME
comma
id|PPA_AUTODETECT
comma
l_int|0
comma
op_minus
l_int|1
comma
l_int|0
comma
id|DID_ERROR
comma
l_int|1
comma
l_int|NULL
comma
l_int|NULL
comma
(brace
l_int|0
comma
l_int|0
comma
id|ppa_interrupt
comma
l_int|NULL
)brace
comma
l_int|NULL
)brace
comma
(brace
l_int|0
comma
l_int|6
comma
l_int|1
comma
id|CONFIG_SCSI_PPA_EPP_TIME
comma
id|PPA_AUTODETECT
comma
l_int|0
comma
op_minus
l_int|1
comma
l_int|0
comma
id|DID_ERROR
comma
l_int|1
comma
l_int|NULL
comma
l_int|NULL
comma
(brace
l_int|0
comma
l_int|0
comma
id|ppa_interrupt
comma
l_int|NULL
)brace
comma
l_int|NULL
)brace
comma
(brace
l_int|0
comma
l_int|6
comma
l_int|1
comma
id|CONFIG_SCSI_PPA_EPP_TIME
comma
id|PPA_AUTODETECT
comma
l_int|0
comma
op_minus
l_int|1
comma
l_int|0
comma
id|DID_ERROR
comma
l_int|1
comma
l_int|NULL
comma
l_int|NULL
comma
(brace
l_int|0
comma
l_int|0
comma
id|ppa_interrupt
comma
l_int|NULL
)brace
comma
l_int|NULL
)brace
comma
(brace
l_int|0
comma
l_int|6
comma
l_int|1
comma
id|CONFIG_SCSI_PPA_EPP_TIME
comma
id|PPA_AUTODETECT
comma
l_int|0
comma
op_minus
l_int|1
comma
l_int|0
comma
id|DID_ERROR
comma
l_int|1
comma
l_int|NULL
comma
l_int|NULL
comma
(brace
l_int|0
comma
l_int|0
comma
id|ppa_interrupt
comma
l_int|NULL
)brace
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/* This is a global option */
DECL|variable|ppa_speed
r_static
r_int
id|ppa_speed
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Set to &gt;0 to act as a global value */
DECL|variable|ppa_speed_fast
r_static
r_int
id|ppa_speed_fast
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ditto.. */
DECL|variable|ppa_sg
r_static
r_int
id|ppa_sg
op_assign
id|SG_ALL
suffix:semicolon
multiline_comment|/* enable/disable scatter-gather. */
multiline_comment|/* other options */
DECL|macro|PPA_CAN_QUEUE
mdefine_line|#define   PPA_CAN_QUEUE         1&t;/* use &quot;queueing&quot; interface */
DECL|macro|PPA_BURST_SIZE
mdefine_line|#define   PPA_BURST_SIZE        512&t;/* block size for bulk transfers */
DECL|macro|PPA_SELECT_TMO
mdefine_line|#define   PPA_SELECT_TMO        5000&t;/* how long to wait for target ? */
DECL|macro|PPA_SPIN_TMO
mdefine_line|#define   PPA_SPIN_TMO          500000&t;/* ppa_wait loop limiter */
DECL|macro|IN_EPP_MODE
mdefine_line|#define IN_EPP_MODE(x) (x == PPA_EPP_8 || x == PPA_EPP_16 || x == PPA_EPP_32)
multiline_comment|/* args to ppa_connect */
DECL|macro|CONNECT_EPP_MAYBE
mdefine_line|#define CONNECT_EPP_MAYBE 1
DECL|macro|CONNECT_NORMAL
mdefine_line|#define CONNECT_NORMAL  0
DECL|macro|PPA_BASE
mdefine_line|#define PPA_BASE(x)&t;ppa_hosts[(x)].dev-&gt;port-&gt;base
multiline_comment|/* Port IO - Sorry Grant but I prefer the following symbols */
DECL|macro|r_dtr
mdefine_line|#define r_dtr(x)        inb(PPA_BASE(x))
DECL|macro|r_str
mdefine_line|#define r_str(x)        inb(PPA_BASE(x)+1)
DECL|macro|r_ctr
mdefine_line|#define r_ctr(x)        inb(PPA_BASE(x)+2)
DECL|macro|r_epp
mdefine_line|#define r_epp(x)        inb(PPA_BASE(x)+4)
DECL|macro|r_fifo
mdefine_line|#define r_fifo(x)       inb(PPA_BASE(x)+0x400)
DECL|macro|r_ecr
mdefine_line|#define r_ecr(x)        inb(PPA_BASE(x)+0x402)
DECL|macro|w_dtr
mdefine_line|#define w_dtr(x,y)      outb(y, PPA_BASE(x))
DECL|macro|w_str
mdefine_line|#define w_str(x,y)      outb(y, PPA_BASE(x)+1)
DECL|macro|w_ctr
mdefine_line|#define w_ctr(x,y)      outb(y, PPA_BASE(x)+2);&bslash;&n;&t;&t;&t;udelay( ppa_hosts[(x)].speed)
DECL|macro|w_epp
mdefine_line|#define w_epp(x,y)      outb(y, PPA_BASE(x)+4)
DECL|macro|w_fifo
mdefine_line|#define w_fifo(x,y)     outb(y, PPA_BASE(x)+0x400)
DECL|macro|w_ecr
mdefine_line|#define w_ecr(x,y)      outb(y, PPA_BASE(x)+0x402)
DECL|function|ppa_wakeup
r_int
id|ppa_wakeup
c_func
(paren
r_void
op_star
id|ref
)paren
(brace
id|ppa_struct
op_star
id|ppa_dev
op_assign
(paren
id|ppa_struct
op_star
)paren
id|ref
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppa_dev-&gt;ppa_wait_q
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Wake up whom ? */
multiline_comment|/* Claim the Parport */
r_if
c_cond
(paren
id|parport_claim
c_func
(paren
id|ppa_dev-&gt;dev
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Shouldn&squot;t happen */
id|wake_up
c_func
(paren
op_amp
id|ppa_dev-&gt;ppa_wait_q
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ppa_release
r_int
id|ppa_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_int
id|host_no
op_assign
id|host-&gt;unique_id
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Releasing ppa%i&bslash;n&quot;
comma
id|host_no
)paren
suffix:semicolon
id|parport_unregister_device
c_func
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ppa_pb_claim
r_static
r_int
id|ppa_pb_claim
c_func
(paren
r_int
id|host_no
)paren
(brace
r_if
c_cond
(paren
id|parport_claim
c_func
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|dev
)paren
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|ppa_wait_q
)paren
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|ppa_wait_q
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Check to see if we were aborted or reset */
r_if
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|dev-&gt;port-&gt;cad
op_ne
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|dev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Abort detected on ppa%i&bslash;n&quot;
comma
id|host_no
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ppa_pb_release
r_static
r_void
id|ppa_pb_release
c_func
(paren
r_int
id|host_no
)paren
(brace
id|parport_release
c_func
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Placed here so everyone knows what ecp_sync does.. */
DECL|function|ecp_sync
r_static
r_void
id|ecp_sync
c_func
(paren
r_int
id|host_no
)paren
(brace
r_int
id|i
comma
id|r
suffix:semicolon
id|r
op_assign
id|r_ecr
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|0xe0
)paren
op_ne
l_int|0x80
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
id|r
op_assign
id|r_ecr
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_amp
l_int|0x01
)paren
r_return
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ppa: ECP sync failed as data still present in FIFO.&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|ppa_d_pulse
r_static
r_inline
r_void
id|ppa_d_pulse
c_func
(paren
r_int
id|host_no
comma
r_char
id|b
)paren
(brace
id|w_dtr
c_func
(paren
id|host_no
comma
id|b
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xe
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x4
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
)brace
DECL|function|ppa_disconnect
r_static
r_void
id|ppa_disconnect
c_func
(paren
r_int
id|host_no
)paren
(brace
id|ppa_d_pulse
c_func
(paren
id|host_no
comma
l_int|0
)paren
suffix:semicolon
id|ppa_d_pulse
c_func
(paren
id|host_no
comma
l_int|0x3c
)paren
suffix:semicolon
id|ppa_d_pulse
c_func
(paren
id|host_no
comma
l_int|0x20
)paren
suffix:semicolon
id|ppa_d_pulse
c_func
(paren
id|host_no
comma
l_int|0xf
)paren
suffix:semicolon
id|ppa_pb_release
c_func
(paren
id|host_no
)paren
suffix:semicolon
)brace
DECL|function|ppa_c_pulse
r_static
r_inline
r_void
id|ppa_c_pulse
c_func
(paren
r_int
id|host_no
comma
r_char
id|b
)paren
(brace
id|w_dtr
c_func
(paren
id|host_no
comma
id|b
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x4
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x6
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x4
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
)brace
DECL|function|ppa_connect
r_static
r_int
id|ppa_connect
c_func
(paren
r_int
id|host_no
comma
r_int
id|flag
)paren
(brace
r_int
id|retv
op_assign
id|ppa_pb_claim
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|ppa_c_pulse
c_func
(paren
id|host_no
comma
l_int|0
)paren
suffix:semicolon
id|ppa_c_pulse
c_func
(paren
id|host_no
comma
l_int|0x3c
)paren
suffix:semicolon
id|ppa_c_pulse
c_func
(paren
id|host_no
comma
l_int|0x20
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flag
op_eq
id|CONNECT_EPP_MAYBE
)paren
op_logical_and
id|IN_EPP_MODE
c_func
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
)paren
)paren
id|ppa_c_pulse
c_func
(paren
id|host_no
comma
l_int|0xcf
)paren
suffix:semicolon
r_else
id|ppa_c_pulse
c_func
(paren
id|host_no
comma
l_int|0x8f
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
DECL|function|ppa_do_reset
r_static
r_void
id|ppa_do_reset
c_func
(paren
r_int
id|host_no
)paren
(brace
multiline_comment|/*&n;&t; * SCSI reset taken from ppa_init and checked with&n;&t; * Iomega document that Grant has (via email :(&n;&t; */
id|ppa_pb_claim
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|ppa_connect
c_func
(paren
id|host_no
comma
id|CONNECT_NORMAL
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x6
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x4
)paren
suffix:semicolon
id|w_dtr
c_func
(paren
id|host_no
comma
l_int|0x40
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x8
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
)brace
DECL|function|ppa_select
r_static
r_char
id|ppa_select
c_func
(paren
r_int
id|host_no
comma
r_int
id|initiator
comma
r_int
id|target
)paren
(brace
r_char
id|r
suffix:semicolon
r_int
id|k
suffix:semicolon
id|r
op_assign
id|r_str
c_func
(paren
id|host_no
)paren
suffix:semicolon
multiline_comment|/* TODO */
id|w_dtr
c_func
(paren
id|host_no
comma
(paren
l_int|1
op_lshift
id|target
)paren
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xe
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
id|w_dtr
c_func
(paren
id|host_no
comma
(paren
l_int|1
op_lshift
id|initiator
)paren
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x8
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|r
op_assign
(paren
id|r_str
c_func
(paren
id|host_no
)paren
op_amp
l_int|0xf0
)paren
)paren
op_logical_and
(paren
id|k
op_increment
OL
id|PPA_SELECT_TMO
)paren
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
op_ge
id|PPA_SELECT_TMO
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|ppa_fail
r_static
r_void
id|ppa_fail
c_func
(paren
r_int
id|host_no
comma
r_int
id|error_code
)paren
(brace
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|error_code
op_assign
id|error_code
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|ppa_failed
op_assign
l_int|1
suffix:semicolon
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for the high bit to be set.&n; * &n; * In principle, this could be tied to an interrupt, but the adapter&n; * doesn&squot;t appear to be designed to support interrupts.  We spin on&n; * the 0x80 ready bit. &n; */
DECL|function|ppa_wait
r_static
r_char
id|ppa_wait
c_func
(paren
r_int
id|host_no
)paren
(brace
r_int
id|k
suffix:semicolon
r_char
id|r
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|r
op_assign
id|r_str
c_func
(paren
id|host_no
)paren
)paren
op_amp
l_int|0x80
)paren
op_logical_and
(paren
id|k
op_increment
OL
id|PPA_SPIN_TMO
)paren
op_logical_and
op_logical_neg
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|abort_flag
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* check if we were interrupted */
r_if
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|abort_flag
)paren
(brace
r_if
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|abort_flag
op_eq
l_int|1
)paren
id|ppa_fail
c_func
(paren
id|host_no
comma
id|DID_ABORT
)paren
suffix:semicolon
r_else
(brace
id|ppa_do_reset
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|ppa_fail
c_func
(paren
id|host_no
comma
id|DID_RESET
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* check if timed out */
r_if
c_cond
(paren
id|k
op_ge
id|PPA_SPIN_TMO
)paren
(brace
id|ppa_fail
c_func
(paren
id|host_no
comma
id|DID_TIME_OUT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* command timed out */
)brace
multiline_comment|/* &n;&t; * return some status information.&n;&t; * Semantics: 0xc0 = ZIP wants more data&n;&t; *            0xd0 = ZIP wants to send more data&n;&t; *            0xf0 = end of transfer, ZIP is sending status&n;&t; */
r_return
(paren
id|r
op_amp
l_int|0xf0
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * This is based on a trace of what the Iomega DOS &squot;guest&squot; driver does.&n; * I&squot;ve tried several different kinds of parallel ports with guest and&n; * coded this to react in the same ways that it does.&n; * &n; * The return value from this function is just a hint about where the&n; * handshaking failed.&n; * &n; */
DECL|function|ppa_init
r_static
r_int
id|ppa_init
c_func
(paren
r_int
id|host_no
)paren
(brace
r_if
c_cond
(paren
id|ppa_pb_claim
c_func
(paren
id|host_no
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|ppa_connect
c_func
(paren
id|host_no
comma
id|CONNECT_NORMAL
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x6
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r_str
c_func
(paren
id|host_no
)paren
op_amp
l_int|0xf0
)paren
op_ne
l_int|0xf0
)paren
(brace
id|ppa_pb_release
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x4
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r_str
c_func
(paren
id|host_no
)paren
op_amp
l_int|0xf0
)paren
op_ne
l_int|0x80
)paren
(brace
id|ppa_pb_release
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
l_int|3
suffix:semicolon
)brace
multiline_comment|/* This is a SCSI reset signal */
id|w_dtr
c_func
(paren
id|host_no
comma
l_int|0x40
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x8
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * check the epp status. After a EPP transfer, it should be true that&n; * 1) the TIMEOUT bit (SPP_STR.0) is clear&n; * 2) the READY bit (SPP_STR.7) is set&n; */
DECL|function|ppa_check_epp_status
r_static
r_int
id|ppa_check_epp_status
c_func
(paren
r_int
id|host_no
)paren
(brace
r_char
id|r
suffix:semicolon
id|r
op_assign
id|r_str
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_amp
l_int|1
)paren
(brace
multiline_comment|/* EPP timeout, according to the PC87332 manual */
multiline_comment|/* Semantics of clearing EPP timeout bit.&n;&t;&t; * PC87332 - reading SPP_STR does it...&n;&t;&t; * SMC     - write 1 to EPP timeout bit&n;&t;&t; * Others  - (???) write 0 to EPP timeout bit&n;&t;&t; */
id|w_str
c_func
(paren
id|host_no
comma
id|r
)paren
suffix:semicolon
id|w_str
c_func
(paren
id|host_no
comma
id|r
op_amp
l_int|0xfe
)paren
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|timeout
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PPA: EPP timeout on port 0x%04x&bslash;n&quot;
comma
id|PPA_BASE
c_func
(paren
id|host_no
)paren
)paren
suffix:semicolon
id|ppa_fail
c_func
(paren
id|host_no
comma
id|DID_BUS_BUSY
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|r
op_amp
l_int|0x80
)paren
)paren
(brace
id|ppa_fail
c_func
(paren
id|host_no
comma
id|DID_ERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ppa_force_epp_byte
r_static
r_inline
r_int
id|ppa_force_epp_byte
c_func
(paren
r_int
id|host_no
comma
r_char
id|x
)paren
(brace
multiline_comment|/* This routine forces a byte down the EPP data port whether the&n; * device is ready or not...&n; */
r_char
id|r
suffix:semicolon
id|w_epp
c_func
(paren
id|host_no
comma
id|x
)paren
suffix:semicolon
id|r
op_assign
id|r_str
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r
op_amp
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|epp_speed
OG
l_int|0
)paren
(brace
multiline_comment|/* EPP timeout, according to the PC87332 manual */
multiline_comment|/* Semantics of clearing EPP timeout bit.&n;&t;&t; * PC87332 - reading SPP_STR does it...&n;&t;&t; * SMC     - write 1 to EPP timeout bit&n;&t;&t; * Others  - (???) write 0 to EPP timeout bit&n;&t;&t; */
id|w_str
c_func
(paren
id|host_no
comma
id|r
)paren
suffix:semicolon
id|w_str
c_func
(paren
id|host_no
comma
id|r
op_amp
l_int|0xfe
)paren
suffix:semicolon
multiline_comment|/* Take a deep breath, count to 10 and then... */
id|udelay
c_func
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|epp_speed
)paren
suffix:semicolon
multiline_comment|/* Second time around */
id|w_epp
c_func
(paren
id|host_no
comma
id|x
)paren
suffix:semicolon
id|r
op_assign
id|r_str
c_func
(paren
id|host_no
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r
op_amp
l_int|1
)paren
(brace
id|w_str
c_func
(paren
id|host_no
comma
id|r
)paren
suffix:semicolon
id|w_str
c_func
(paren
id|host_no
comma
id|r
op_amp
l_int|0xfe
)paren
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|timeout
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PPA: warning: EPP timeout&bslash;n&quot;
)paren
suffix:semicolon
id|ppa_fail
c_func
(paren
id|host_no
comma
id|DID_BUS_BUSY
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ppa_send_command_epp
r_static
r_inline
r_int
id|ppa_send_command_epp
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_int
id|k
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|cmd-&gt;cmd_len
suffix:semicolon
id|k
op_increment
)paren
(brace
multiline_comment|/* send the command */
r_if
c_cond
(paren
op_logical_neg
id|ppa_force_epp_byte
c_func
(paren
id|host_no
comma
id|cmd-&gt;cmnd
(braket
id|k
)braket
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ppa_send_command_normal
r_static
r_inline
r_int
id|ppa_send_command_normal
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_int
id|k
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|cmd-&gt;cmd_len
suffix:semicolon
id|k
op_increment
)paren
(brace
multiline_comment|/* send the command */
r_if
c_cond
(paren
op_logical_neg
id|ppa_wait
c_func
(paren
id|host_no
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|w_dtr
c_func
(paren
id|host_no
comma
id|cmd-&gt;cmnd
(braket
id|k
)braket
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xe
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ppa_start
r_static
r_int
id|ppa_start
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
multiline_comment|/* &n;&t; * by default, the command failed,&n;&t; * unless explicitly completed in ppa_completion().&n;&t; */
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|error_code
op_assign
id|DID_ERROR
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|abort_flag
op_assign
l_int|0
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|ppa_failed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;target
op_eq
id|PPA_INITIATOR
)paren
(brace
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|error_code
op_assign
id|DID_BAD_TARGET
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|ppa_failed
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppa_connect
c_func
(paren
id|host_no
comma
id|CONNECT_EPP_MAYBE
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppa_select
c_func
(paren
id|host_no
comma
id|PPA_INITIATOR
comma
id|cmd-&gt;target
)paren
)paren
(brace
id|ppa_fail
c_func
(paren
id|host_no
comma
id|DID_NO_CONNECT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IN_EPP_MODE
c_func
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
)paren
)paren
r_return
id|ppa_send_command_epp
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_else
r_return
id|ppa_send_command_normal
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * output a string, in whatever mode is available, according to the&n; * PPA protocol. &n; */
DECL|function|ppa_outs
r_static
r_inline
r_int
id|ppa_outs
c_func
(paren
r_int
id|host_no
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|k
suffix:semicolon
macro_line|#if CONFIG_SCSI_PPA_HAVE_PEDANTIC &gt; 0
r_int
id|r
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
)paren
(brace
r_case
id|PPA_NIBBLE
suffix:colon
r_case
id|PPA_PS2
suffix:colon
multiline_comment|/* 8 bit output, with a loop */
r_for
c_loop
(paren
id|k
op_assign
id|len
suffix:semicolon
id|k
suffix:semicolon
id|k
op_decrement
)paren
(brace
id|w_dtr
c_func
(paren
id|host_no
comma
op_star
id|buffer
op_increment
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xe
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* assume transfer went OK */
macro_line|#if CONFIG_SCSI_PPA_HAVE_PEDANTIC &gt; 0
r_case
id|PPA_EPP_32
suffix:colon
macro_line|#if CONFIG_SCSI_PPA_HAVE_PEDANTIC &lt; 2
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|len
suffix:semicolon
id|k
suffix:semicolon
id|k
op_sub_assign
l_int|4
)paren
(brace
id|w_epp
c_func
(paren
id|host_no
comma
op_star
id|buffer
op_increment
)paren
suffix:semicolon
id|w_epp
c_func
(paren
id|host_no
comma
op_star
id|buffer
op_increment
)paren
suffix:semicolon
id|w_epp
c_func
(paren
id|host_no
comma
op_star
id|buffer
op_increment
)paren
suffix:semicolon
id|w_epp
c_func
(paren
id|host_no
comma
op_star
id|buffer
op_increment
)paren
suffix:semicolon
id|r
op_assign
id|ppa_check_epp_status
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
r_return
id|r
suffix:semicolon
)brace
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
macro_line|#endif
r_case
id|PPA_EPP_16
suffix:colon
macro_line|#if CONFIG_SCSI_PPA_HAVE_PEDANTIC &lt; 3
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|len
suffix:semicolon
id|k
suffix:semicolon
id|k
op_sub_assign
l_int|2
)paren
(brace
id|w_epp
c_func
(paren
id|host_no
comma
op_star
id|buffer
op_increment
)paren
suffix:semicolon
id|w_epp
c_func
(paren
id|host_no
comma
op_star
id|buffer
op_increment
)paren
suffix:semicolon
id|r
op_assign
id|ppa_check_epp_status
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
r_return
id|r
suffix:semicolon
)brace
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
macro_line|#endif
r_case
id|PPA_EPP_8
suffix:colon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|len
suffix:semicolon
id|k
suffix:semicolon
id|k
op_decrement
)paren
(brace
id|w_epp
c_func
(paren
id|host_no
comma
op_star
id|buffer
op_increment
)paren
suffix:semicolon
id|r
op_assign
id|ppa_check_epp_status
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
r_return
id|r
suffix:semicolon
)brace
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
macro_line|#else
r_case
id|PPA_EPP_32
suffix:colon
r_case
id|PPA_EPP_16
suffix:colon
r_case
id|PPA_EPP_8
suffix:colon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x4
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
)paren
(brace
r_case
id|PPA_EPP_8
suffix:colon
id|outsb
c_func
(paren
id|PPA_BASE
c_func
(paren
id|host_no
)paren
op_plus
l_int|0x04
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPA_EPP_16
suffix:colon
id|outsw
c_func
(paren
id|PPA_BASE
c_func
(paren
id|host_no
)paren
op_plus
l_int|0x04
comma
id|buffer
comma
id|len
op_div
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPA_EPP_32
suffix:colon
id|outsl
c_func
(paren
id|PPA_BASE
c_func
(paren
id|host_no
)paren
op_plus
l_int|0x04
comma
id|buffer
comma
id|len
op_div
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|k
op_assign
id|ppa_check_epp_status
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
id|k
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;PPA: bug in ppa_outs()&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ppa_outb
r_static
r_inline
r_int
id|ppa_outb
c_func
(paren
r_int
id|host_no
comma
r_char
id|d
)paren
(brace
r_int
id|k
suffix:semicolon
r_switch
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
)paren
(brace
r_case
id|PPA_NIBBLE
suffix:colon
r_case
id|PPA_PS2
suffix:colon
id|w_dtr
c_func
(paren
id|host_no
comma
id|d
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xe
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* assume transfer went OK */
r_case
id|PPA_EPP_8
suffix:colon
r_case
id|PPA_EPP_16
suffix:colon
r_case
id|PPA_EPP_32
suffix:colon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x4
)paren
suffix:semicolon
id|w_epp
c_func
(paren
id|host_no
comma
id|d
)paren
suffix:semicolon
id|k
op_assign
id|ppa_check_epp_status
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
id|k
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;PPA: bug in ppa_outb()&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ppa_ins
r_static
r_inline
r_int
id|ppa_ins
c_func
(paren
r_int
id|host_no
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|k
comma
id|h
comma
id|l
suffix:semicolon
macro_line|#if CONFIG_SCSI_PPA_HAVE_PEDANTIC &gt; 0
r_int
id|r
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
)paren
(brace
r_case
id|PPA_NIBBLE
suffix:colon
multiline_comment|/* 4 bit input, with a loop */
r_for
c_loop
(paren
id|k
op_assign
id|len
suffix:semicolon
id|k
suffix:semicolon
id|k
op_decrement
)paren
(brace
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x4
)paren
suffix:semicolon
id|h
op_assign
id|r_str
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x6
)paren
suffix:semicolon
id|l
op_assign
id|r_str
c_func
(paren
id|host_no
)paren
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
(paren
(paren
id|l
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_plus
(paren
id|h
op_amp
l_int|0xf0
)paren
suffix:semicolon
)brace
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* assume transfer went OK */
r_case
id|PPA_PS2
suffix:colon
multiline_comment|/* 8 bit input, with a loop */
r_for
c_loop
(paren
id|k
op_assign
id|len
suffix:semicolon
id|k
suffix:semicolon
id|k
op_decrement
)paren
(brace
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x25
)paren
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
id|r_dtr
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x27
)paren
suffix:semicolon
)brace
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x5
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x4
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* assume transfer went OK */
macro_line|#if CONFIG_SCSI_PPA_HAVE_PEDANTIC &gt; 0
r_case
id|PPA_EPP_32
suffix:colon
macro_line|#if CONFIG_SCSI_PPA_HAVE_PEDANTIC &lt; 2
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x24
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|len
suffix:semicolon
id|k
suffix:semicolon
id|k
op_sub_assign
l_int|4
)paren
(brace
op_star
id|buffer
op_increment
op_assign
id|r_epp
c_func
(paren
id|host_no
)paren
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
id|r_epp
c_func
(paren
id|host_no
)paren
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
id|r_epp
c_func
(paren
id|host_no
)paren
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
id|r_epp
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|r
op_assign
id|ppa_check_epp_status
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
r_return
id|r
suffix:semicolon
)brace
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x2c
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
macro_line|#endif
r_case
id|PPA_EPP_16
suffix:colon
macro_line|#if CONFIG_SCSI_PPA_HAVE_PEDANTIC &lt; 3
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x24
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|len
suffix:semicolon
id|k
suffix:semicolon
id|k
op_sub_assign
l_int|2
)paren
(brace
op_star
id|buffer
op_increment
op_assign
id|r_epp
c_func
(paren
id|host_no
)paren
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
id|r_epp
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|r
op_assign
id|ppa_check_epp_status
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
r_return
id|r
suffix:semicolon
)brace
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x2c
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
macro_line|#endif
r_case
id|PPA_EPP_8
suffix:colon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x24
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|len
suffix:semicolon
id|k
suffix:semicolon
id|k
op_decrement
)paren
(brace
op_star
id|buffer
op_increment
op_assign
id|r_epp
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|r
op_assign
id|ppa_check_epp_status
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
r_return
id|r
suffix:semicolon
)brace
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x2c
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#else
r_case
id|PPA_EPP_8
suffix:colon
r_case
id|PPA_EPP_16
suffix:colon
r_case
id|PPA_EPP_32
suffix:colon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x24
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
)paren
(brace
r_case
id|PPA_EPP_8
suffix:colon
id|insb
c_func
(paren
id|PPA_BASE
c_func
(paren
id|host_no
)paren
op_plus
l_int|0x04
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPA_EPP_16
suffix:colon
id|insw
c_func
(paren
id|PPA_BASE
c_func
(paren
id|host_no
)paren
op_plus
l_int|0x04
comma
id|buffer
comma
id|len
op_div
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPA_EPP_32
suffix:colon
id|insl
c_func
(paren
id|PPA_BASE
c_func
(paren
id|host_no
)paren
op_plus
l_int|0x04
comma
id|buffer
comma
id|len
op_div
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|k
op_assign
id|ppa_check_epp_status
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x2c
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
id|k
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;PPA: bug in ppa_ins()&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ppa_inb
r_static
r_int
id|ppa_inb
c_func
(paren
r_int
id|host_no
comma
r_char
op_star
id|buffer
)paren
(brace
r_int
id|h
comma
id|l
comma
id|k
suffix:semicolon
r_switch
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|mode
)paren
(brace
r_case
id|PPA_NIBBLE
suffix:colon
multiline_comment|/* 4 bit input */
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x4
)paren
suffix:semicolon
id|h
op_assign
id|r_str
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x6
)paren
suffix:semicolon
id|l
op_assign
id|r_str
c_func
(paren
id|host_no
)paren
suffix:semicolon
op_star
id|buffer
op_assign
(paren
(paren
id|l
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_plus
(paren
id|h
op_amp
l_int|0xf0
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* assume transfer went OK */
r_case
id|PPA_PS2
suffix:colon
multiline_comment|/* 8 bit input */
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x25
)paren
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
id|r_dtr
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x27
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x5
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x4
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* assume transfer went OK */
r_case
id|PPA_EPP_8
suffix:colon
r_case
id|PPA_EPP_16
suffix:colon
r_case
id|PPA_EPP_32
suffix:colon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0x24
)paren
suffix:semicolon
op_star
id|buffer
op_assign
id|r_epp
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|k
op_assign
id|ppa_check_epp_status
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|host_no
comma
l_int|0xc
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
id|k
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;PPA: bug in ppa_inb()&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The bulk flag enables some optimisations in the data transfer loops,&n; * it should be true for any command that transfers data in integral&n; * numbers of sectors.&n; * &n; * The driver appears to remain stable if we speed up the parallel port&n; * i/o in this function, but not elsewhere.&n; */
DECL|function|ppa_completion
r_static
r_int
id|ppa_completion
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_char
id|r
comma
id|l
comma
id|h
comma
id|v
suffix:semicolon
r_int
id|dir
comma
id|cnt
comma
id|blen
comma
id|fast
comma
id|bulk
comma
id|status
suffix:semicolon
r_char
op_star
id|buffer
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sl
suffix:semicolon
r_int
id|current_segment
comma
id|nsegment
suffix:semicolon
id|v
op_assign
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
id|bulk
op_assign
(paren
(paren
id|v
op_eq
id|READ_6
)paren
op_logical_or
(paren
id|v
op_eq
id|READ_10
)paren
op_logical_or
(paren
id|v
op_eq
id|WRITE_6
)paren
op_logical_or
(paren
id|v
op_eq
id|WRITE_10
)paren
)paren
suffix:semicolon
multiline_comment|/* code for scatter/gather: */
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
multiline_comment|/* if many buffers are available, start filling the first */
id|sl
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|blen
op_assign
id|sl-&gt;length
suffix:semicolon
id|buffer
op_assign
id|sl-&gt;address
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* else fill the only available buffer */
id|sl
op_assign
l_int|NULL
suffix:semicolon
id|buffer
op_assign
id|cmd-&gt;request_buffer
suffix:semicolon
id|blen
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
)brace
id|current_segment
op_assign
l_int|0
suffix:semicolon
id|nsegment
op_assign
id|cmd-&gt;use_sg
suffix:semicolon
id|cnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* detect transfer direction */
id|dir
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r
op_assign
id|ppa_wait
c_func
(paren
id|host_no
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
(paren
r_char
)paren
l_int|0xc0
)paren
id|dir
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* d0 = read c0 = write f0 = status */
r_while
c_loop
(paren
id|r
op_ne
(paren
r_char
)paren
l_int|0xf0
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|r
op_amp
l_int|0xc0
)paren
op_ne
l_int|0xc0
)paren
op_logical_or
(paren
id|cnt
op_ge
id|blen
)paren
)paren
(brace
id|ppa_fail
c_func
(paren
id|host_no
comma
id|DID_ERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* determine if we should use burst I/O */
id|fast
op_assign
(paren
id|bulk
op_logical_and
(paren
(paren
id|blen
op_minus
id|cnt
)paren
op_ge
id|PPA_BURST_SIZE
)paren
op_logical_and
(paren
(paren
(paren
(paren
r_int
)paren
id|buffer
op_plus
id|cnt
)paren
)paren
op_amp
l_int|0x3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fast
)paren
(brace
r_if
c_cond
(paren
id|dir
)paren
id|status
op_assign
id|ppa_outs
c_func
(paren
id|host_no
comma
op_amp
id|buffer
(braket
id|cnt
)braket
comma
id|PPA_BURST_SIZE
)paren
suffix:semicolon
r_else
id|status
op_assign
id|ppa_ins
c_func
(paren
id|host_no
comma
op_amp
id|buffer
(braket
id|cnt
)braket
comma
id|PPA_BURST_SIZE
)paren
suffix:semicolon
id|cnt
op_add_assign
id|PPA_BURST_SIZE
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dir
)paren
id|status
op_assign
id|ppa_outb
c_func
(paren
id|host_no
comma
id|buffer
(braket
id|cnt
)braket
)paren
suffix:semicolon
r_else
id|status
op_assign
id|ppa_inb
c_func
(paren
id|host_no
comma
op_amp
id|buffer
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|status
op_logical_or
op_logical_neg
(paren
id|r
op_assign
id|ppa_wait
c_func
(paren
id|host_no
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sl
op_logical_and
id|cnt
op_eq
id|blen
)paren
(brace
multiline_comment|/* if scatter/gather, advance to the next segment */
r_if
c_cond
(paren
op_increment
id|current_segment
OL
id|nsegment
)paren
(brace
op_increment
id|sl
suffix:semicolon
id|blen
op_assign
id|sl-&gt;length
suffix:semicolon
id|buffer
op_assign
id|sl-&gt;address
suffix:semicolon
id|cnt
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * the else case will be captured by the (cnt &gt;= blen)&n;&t;&t;&t; * test above.&n;&t;&t;&t; */
)brace
)brace
multiline_comment|/* read status and message bytes */
r_if
c_cond
(paren
op_logical_neg
id|ppa_inb
c_func
(paren
id|host_no
comma
op_amp
id|l
)paren
)paren
multiline_comment|/* read status byte */
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ppa_wait
c_func
(paren
id|host_no
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppa_inb
c_func
(paren
id|host_no
comma
op_amp
id|h
)paren
)paren
multiline_comment|/* read message byte */
r_return
l_int|0
suffix:semicolon
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|error_code
op_assign
id|DID_OK
suffix:semicolon
r_return
(paren
id|h
op_lshift
l_int|8
)paren
op_or
(paren
id|l
op_amp
id|STATUS_MASK
)paren
suffix:semicolon
)brace
multiline_comment|/* deprecated synchronous interface */
DECL|function|ppa_command
r_int
id|ppa_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_int
id|s
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|s
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ppa_start
c_func
(paren
id|cmd
)paren
)paren
r_if
c_cond
(paren
id|ppa_wait
c_func
(paren
id|host_no
)paren
)paren
id|s
op_assign
id|ppa_completion
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
id|s
op_plus
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|error_code
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
multiline_comment|/* pseudo-interrupt queueing interface */
multiline_comment|/*&n; * Since the PPA itself doesn&squot;t generate interrupts, we use&n; * the scheduler&squot;s task queue to generate a stream of call-backs and&n; * complete the request when the drive is ready.&n; */
DECL|function|ppa_interrupt
r_static
r_void
id|ppa_interrupt
c_func
(paren
r_void
op_star
id|data
)paren
(brace
id|ppa_struct
op_star
id|tmp
op_assign
(paren
id|ppa_struct
op_star
)paren
id|data
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
op_assign
id|tmp-&gt;cur_cmd
suffix:semicolon
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
op_assign
id|tmp-&gt;done
suffix:semicolon
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PPA: bug in ppa_interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* First check for any errors that may of occured&n;&t; * Here we check for internal errors&n;&t; */
r_if
c_cond
(paren
id|tmp-&gt;ppa_failed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PPA: ppa_failed bug: ppa_error_code = %d&bslash;n&quot;
comma
id|tmp-&gt;error_code
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|tmp-&gt;cur_cmd
op_assign
l_int|0
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Occasionally the mid level driver will abort a SCSI&n;&t; * command because we are taking to long, if this occurs&n;&t; * we should abort the command.&n;&t; */
r_if
c_cond
(paren
id|tmp-&gt;abort_flag
)paren
(brace
id|ppa_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;abort_flag
op_eq
l_int|1
)paren
id|cmd-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
r_else
(brace
id|ppa_do_reset
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
)brace
id|tmp-&gt;cur_cmd
op_assign
l_int|0
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check to see if the device is now free, if not&n;&t; * then throw this function onto the scheduler queue&n;&t; * to be called back in a jiffy.&n;&t; * (i386: 1 jiffy = 0.01 seconds)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|r_str
c_func
(paren
id|host_no
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
id|tmp-&gt;ppa_tq.data
op_assign
(paren
r_void
op_star
)paren
id|tmp
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|tmp-&gt;ppa_tq
comma
op_amp
id|tq_scheduler
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Device is now free and no errors have occured so&n;&t; * it is safe to do the data phase&n;&t; */
id|cmd-&gt;result
op_assign
id|ppa_completion
c_func
(paren
id|cmd
)paren
op_plus
(paren
id|tmp-&gt;error_code
op_lshift
l_int|16
)paren
suffix:semicolon
id|tmp-&gt;cur_cmd
op_assign
l_int|0
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|ppa_queuecommand
r_int
id|ppa_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_if
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PPA: bug in ppa_queuecommand&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
op_assign
id|cmd
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|done
op_assign
id|done
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppa_start
c_func
(paren
id|cmd
)paren
)paren
(brace
id|cmd-&gt;result
op_assign
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|error_code
op_lshift
l_int|16
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
op_assign
l_int|0
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ppa_interrupt
c_func
(paren
id|ppa_hosts
op_plus
id|host_no
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Apparently the the disk-&gt;capacity attribute is off by 1 sector &n; * for all disk drives.  We add the one here, but it should really&n; * be done in sd.c.  Even if it gets fixed there, this will still&n; * work.&n; */
DECL|function|ppa_biosparam
r_int
id|ppa_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
id|ip
(braket
)braket
)paren
(brace
id|ip
(braket
l_int|0
)braket
op_assign
l_int|0x40
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|0x20
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
(paren
id|disk-&gt;capacity
op_plus
l_int|1
)paren
op_div
(paren
id|ip
(braket
l_int|0
)braket
op_star
id|ip
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
(braket
l_int|2
)braket
OG
l_int|1024
)paren
(brace
id|ip
(braket
l_int|0
)braket
op_assign
l_int|0xff
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|0x3f
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
(paren
id|disk-&gt;capacity
op_plus
l_int|1
)paren
op_div
(paren
id|ip
(braket
l_int|0
)braket
op_star
id|ip
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
(braket
l_int|2
)braket
OG
l_int|1023
)paren
id|ip
(braket
l_int|2
)braket
op_assign
l_int|1023
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ppa_abort
r_int
id|ppa_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|abort_flag
op_assign
l_int|1
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|error_code
op_assign
id|DID_ABORT
suffix:semicolon
r_if
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|ppa_wait_q
)paren
id|wake_up
c_func
(paren
op_amp
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|ppa_wait_q
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
DECL|function|ppa_reset
r_int
id|ppa_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_int
id|x
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|abort_flag
op_assign
l_int|2
suffix:semicolon
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|error_code
op_assign
id|DID_RESET
suffix:semicolon
r_if
c_cond
(paren
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|ppa_wait_q
)paren
id|wake_up
c_func
(paren
op_amp
id|ppa_hosts
(braket
id|host_no
)braket
dot
id|ppa_wait_q
)paren
suffix:semicolon
r_return
id|SCSI_RESET_PUNT
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; *                   Parallel port probing routines                        *&n; ***************************************************************************/
macro_line|#ifdef MODULE
DECL|variable|driver_template
id|Scsi_Host_Template
id|driver_template
op_assign
id|PPA
suffix:semicolon
macro_line|#include  &quot;scsi_module.c&quot;
macro_line|#endif
multiline_comment|/*&n; * Start of Chipset kludges&n; */
DECL|function|ppa_detect
r_int
id|ppa_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|host
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|hreg
suffix:semicolon
r_int
id|rs
suffix:semicolon
r_int
id|ports
suffix:semicolon
r_int
id|i
comma
id|nhosts
suffix:semicolon
r_struct
id|parport
op_star
id|pb
op_assign
id|parport_enumerate
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PPA driver version: %s&bslash;n&quot;
comma
id|PPA_VERSION
)paren
suffix:semicolon
id|nhosts
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|pb
suffix:semicolon
id|i
op_increment
comma
id|pb
op_assign
id|pb-&gt;next
)paren
(brace
r_int
id|modes
op_assign
id|pb-&gt;modes
suffix:semicolon
multiline_comment|/* We only understand PC-style ports */
r_if
c_cond
(paren
id|modes
op_amp
id|PARPORT_MODE_PCSPP
)paren
(brace
multiline_comment|/* transfer global values here */
r_if
c_cond
(paren
id|ppa_speed
op_ge
l_int|0
)paren
id|ppa_hosts
(braket
id|i
)braket
dot
id|speed
op_assign
id|ppa_speed
suffix:semicolon
r_if
c_cond
(paren
id|ppa_speed_fast
op_ge
l_int|0
)paren
id|ppa_hosts
(braket
id|i
)braket
dot
id|speed_fast
op_assign
id|ppa_speed_fast
suffix:semicolon
id|ppa_hosts
(braket
id|i
)braket
dot
id|dev
op_assign
id|parport_register_device
c_func
(paren
id|pb
comma
l_string|&quot;ppa&quot;
comma
l_int|NULL
comma
id|ppa_wakeup
comma
l_int|NULL
comma
id|PARPORT_DEV_TRAN
comma
(paren
r_void
op_star
)paren
op_amp
id|ppa_hosts
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Claim the bus so it remembers what we do to the&n;&t;&t;&t; * control registers. [ CTR and ECP ]&n;&t;&t;&t; */
id|ppa_pb_claim
c_func
(paren
id|i
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|i
comma
l_int|0x0c
)paren
suffix:semicolon
id|ppa_hosts
(braket
id|i
)braket
dot
id|mode
op_assign
id|PPA_NIBBLE
suffix:semicolon
r_if
c_cond
(paren
id|modes
op_amp
(paren
id|PARPORT_MODE_PCEPP
op_or
id|PARPORT_MODE_PCECPEPP
)paren
)paren
(brace
id|ppa_hosts
(braket
id|i
)braket
dot
id|mode
op_assign
id|PPA_EPP_32
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PPA: Parport [ PCEPP ]&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|modes
op_amp
id|PARPORT_MODE_PCECP
)paren
(brace
id|w_ecr
c_func
(paren
id|i
comma
l_int|0x20
)paren
suffix:semicolon
id|ppa_hosts
(braket
id|i
)braket
dot
id|mode
op_assign
id|PPA_PS2
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PPA: Parport [ PCECP in PS2 submode ]&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|modes
op_amp
id|PARPORT_MODE_PCPS2
)paren
(brace
id|ppa_hosts
(braket
id|i
)braket
dot
id|mode
op_assign
id|PPA_PS2
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PPA: Parport [ PCPS2 ]&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Done configuration */
id|ppa_pb_release
c_func
(paren
id|i
)paren
suffix:semicolon
id|rs
op_assign
id|ppa_init
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rs
)paren
(brace
id|parport_unregister_device
c_func
(paren
id|ppa_hosts
(braket
id|i
)braket
dot
id|dev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* now the glue ... */
r_switch
c_cond
(paren
id|ppa_hosts
(braket
id|i
)braket
dot
id|mode
)paren
(brace
r_case
id|PPA_NIBBLE
suffix:colon
r_case
id|PPA_PS2
suffix:colon
id|ports
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPA_EPP_8
suffix:colon
r_case
id|PPA_EPP_16
suffix:colon
r_case
id|PPA_EPP_32
suffix:colon
id|ports
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Never gets here */
r_continue
suffix:semicolon
)brace
id|host-&gt;can_queue
op_assign
id|PPA_CAN_QUEUE
suffix:semicolon
id|host-&gt;sg_tablesize
op_assign
id|ppa_sg
suffix:semicolon
id|hreg
op_assign
id|scsi_register
c_func
(paren
id|host
comma
l_int|0
)paren
suffix:semicolon
id|hreg-&gt;io_port
op_assign
id|pb-&gt;base
suffix:semicolon
id|hreg-&gt;n_io_port
op_assign
id|ports
suffix:semicolon
id|hreg-&gt;dma_channel
op_assign
op_minus
l_int|1
suffix:semicolon
id|hreg-&gt;unique_id
op_assign
id|i
suffix:semicolon
id|ppa_hosts
(braket
id|i
)braket
dot
id|host
op_assign
id|hreg-&gt;host_no
suffix:semicolon
id|nhosts
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nhosts
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
multiline_comment|/* return number of hosts detected */
)brace
multiline_comment|/* This is to give the ppa driver a way to modify the timings (and other&n; * parameters) by writing to the /proc/scsi/ppa/0 file.&n; * Very simple method really... (To simple, no error checking :( )&n; * Reason: Kernel hackers HATE having to unload and reload modules for&n; * testing...&n; * Also gives a method to use a script to obtain optimum timings (TODO)&n; */
DECL|function|ppa_strncmp
r_static
r_int
id|ppa_strncmp
c_func
(paren
r_const
r_char
op_star
id|a
comma
r_const
r_char
op_star
id|b
comma
r_int
id|len
)paren
(brace
r_int
id|loop
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|len
suffix:semicolon
id|loop
op_increment
)paren
r_if
c_cond
(paren
id|a
(braket
id|loop
)braket
op_ne
id|b
(braket
id|loop
)braket
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ppa_proc_write
r_static
r_int
id|ppa_proc_write
c_func
(paren
r_int
id|hostno
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_int
r_int
id|x
suffix:semicolon
r_const
r_char
op_star
id|inv_num
op_assign
l_string|&quot;ppa /proc entry passed invalid number&bslash;n&quot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|length
OG
l_int|15
)paren
op_logical_and
(paren
id|ppa_strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;ppa_speed_fast=&quot;
comma
l_int|15
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|x
op_assign
id|simple_strtoul
c_func
(paren
id|buffer
op_plus
l_int|15
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
op_le
id|ppa_hosts
(braket
id|hostno
)braket
dot
id|speed
)paren
id|ppa_hosts
(braket
id|hostno
)braket
dot
id|speed_fast
op_assign
id|x
suffix:semicolon
r_else
id|printk
c_func
(paren
id|inv_num
)paren
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|length
OG
l_int|10
)paren
op_logical_and
(paren
id|ppa_strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;ppa_speed=&quot;
comma
l_int|10
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|x
op_assign
id|simple_strtoul
c_func
(paren
id|buffer
op_plus
l_int|10
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
op_ge
id|ppa_hosts
(braket
id|hostno
)braket
dot
id|speed_fast
)paren
id|ppa_hosts
(braket
id|hostno
)braket
dot
id|speed
op_assign
id|x
suffix:semicolon
r_else
id|printk
c_func
(paren
id|inv_num
)paren
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|length
OG
l_int|10
)paren
op_logical_and
(paren
id|ppa_strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;epp_speed=&quot;
comma
l_int|10
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|x
op_assign
id|simple_strtoul
c_func
(paren
id|buffer
op_plus
l_int|10
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|ppa_hosts
(braket
id|hostno
)braket
dot
id|epp_speed
op_assign
id|x
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|length
OG
l_int|12
)paren
op_logical_and
(paren
id|ppa_strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;epp_timeout=&quot;
comma
l_int|12
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|x
op_assign
id|simple_strtoul
c_func
(paren
id|buffer
op_plus
l_int|12
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|ppa_hosts
(braket
id|hostno
)braket
dot
id|timeout
op_assign
id|x
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|length
OG
l_int|5
)paren
op_logical_and
(paren
id|ppa_strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;mode=&quot;
comma
l_int|5
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|x
op_assign
id|simple_strtoul
c_func
(paren
id|buffer
op_plus
l_int|5
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|ppa_hosts
(braket
id|hostno
)braket
dot
id|mode
op_assign
id|x
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ppa /proc: invalid variable&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
DECL|function|ppa_proc_info
r_int
id|ppa_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|size
comma
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ppa_hosts
(braket
id|i
)braket
dot
id|host
op_eq
id|hostno
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|inout
)paren
r_return
id|ppa_proc_write
c_func
(paren
id|i
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Version : %s&bslash;n&quot;
comma
id|PPA_VERSION
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Parport  : %s&bslash;n&quot;
comma
id|ppa_hosts
(braket
id|i
)braket
dot
id|dev-&gt;port-&gt;name
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Mode    : %s&bslash;n&quot;
comma
id|PPA_MODE_STRING
(braket
id|ppa_hosts
(braket
id|i
)braket
dot
id|mode
)braket
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;nTiming Parameters&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;ppa_speed       %i&bslash;n&quot;
comma
id|ppa_hosts
(braket
id|i
)braket
dot
id|speed
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;ppa_speed_fast  %i&bslash;n&quot;
comma
id|ppa_hosts
(braket
id|i
)braket
dot
id|speed_fast
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|IN_EPP_MODE
c_func
(paren
id|ppa_hosts
(braket
id|i
)braket
dot
id|mode
)paren
)paren
(brace
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;epp_speed       %i&bslash;n&quot;
comma
id|ppa_hosts
(braket
id|i
)braket
dot
id|epp_speed
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;nInternal Counters&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;epp_timeout     %i&bslash;n&quot;
comma
id|ppa_hosts
(braket
id|i
)braket
dot
id|timeout
)paren
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
)brace
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_plus
id|begin
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* end of ppa.c */
eof
