multiline_comment|/******************************************************************************&n;**  High Performance device driver for the Symbios 53C896 controller.&n;**&n;**  Copyright (C) 1998-2000  Gerard Roudier &lt;groudier@club-internet.fr&gt;&n;**&n;**  This driver also supports all the Symbios 53C8XX controller family, &n;**  except 53C810 revisions &lt; 16, 53C825 revisions &lt; 16 and all &n;**  revisions of 53C815 controllers.&n;**&n;**  This driver is based on the Linux port of the FreeBSD ncr driver.&n;** &n;**  Copyright (C) 1994  Wolfgang Stanglmeier&n;**  &n;**-----------------------------------------------------------------------------&n;**  &n;**  This program is free software; you can redistribute it and/or modify&n;**  it under the terms of the GNU General Public License as published by&n;**  the Free Software Foundation; either version 2 of the License, or&n;**  (at your option) any later version.&n;**&n;**  This program is distributed in the hope that it will be useful,&n;**  but WITHOUT ANY WARRANTY; without even the implied warranty of&n;**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;**  GNU General Public License for more details.&n;**&n;**  You should have received a copy of the GNU General Public License&n;**  along with this program; if not, write to the Free Software&n;**  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;**&n;**-----------------------------------------------------------------------------&n;**&n;**  The Linux port of the FreeBSD ncr driver has been achieved in &n;**  november 1995 by:&n;**&n;**          Gerard Roudier              &lt;groudier@club-internet.fr&gt;&n;**&n;**  Being given that this driver originates from the FreeBSD version, and&n;**  in order to keep synergy on both, any suggested enhancements and corrections&n;**  received on Linux are automatically a potential candidate for the FreeBSD &n;**  version.&n;**&n;**  The original driver has been written for 386bsd and FreeBSD by&n;**          Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;&n;**          Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;&n;**&n;**-----------------------------------------------------------------------------&n;**&n;**  Major contributions:&n;**  --------------------&n;**&n;**  NVRAM detection and reading.&n;**    Copyright (C) 1997 Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;&n;**&n;*******************************************************************************&n;*/
multiline_comment|/*&n;**&t;This file contains definitions and code that the &n;**&t;sym53c8xx and ncr53c8xx drivers should share.&n;**&t;The sharing will be achieved in a further version  &n;**&t;of the driver bundle. For now, only the ncr53c8xx &n;**&t;driver includes&t;this file.&n;*/
DECL|macro|MIN
mdefine_line|#define MIN(a,b)        (((a) &lt; (b)) ? (a) : (b))
DECL|macro|MAX
mdefine_line|#define MAX(a,b)        (((a) &gt; (b)) ? (a) : (b))
multiline_comment|/*==========================================================&n;**&n;**&t;Hmmm... What complex some PCI-HOST bridges actually &n;**&t;are, despite the fact that the PCI specifications &n;**&t;are looking so smart and simple! ;-)&n;**&n;**==========================================================&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,3,47)
DECL|macro|SCSI_NCR_DYNAMIC_DMA_MAPPING
mdefine_line|#define SCSI_NCR_DYNAMIC_DMA_MAPPING
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**    Io mapped versus memory mapped.&n;**&n;**==========================================================&n;*/
macro_line|#if defined(SCSI_NCR_IOMAPPED) || defined(SCSI_NCR_PCI_MEM_NOT_SUPPORTED)
DECL|macro|NCR_IOMAPPED
mdefine_line|#define NCR_IOMAPPED
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;Miscallaneous defines.&n;**&n;**==========================================================&n;*/
DECL|macro|u_char
mdefine_line|#define u_char&t;&t;unsigned char
DECL|macro|u_short
mdefine_line|#define u_short&t;&t;unsigned short
DECL|macro|u_int
mdefine_line|#define u_int&t;&t;unsigned int
DECL|macro|u_long
mdefine_line|#define u_long&t;&t;unsigned long
macro_line|#ifndef bcopy
DECL|macro|bcopy
mdefine_line|#define bcopy(s, d, n)&t;memcpy((d), (s), (n))
macro_line|#endif
macro_line|#ifndef bcmp
DECL|macro|bcmp
mdefine_line|#define bcmp(s, d, n)&t;memcmp((d), (s), (n))
macro_line|#endif
macro_line|#ifndef bzero
DECL|macro|bzero
mdefine_line|#define bzero(d, n)&t;memset((d), 0, (n))
macro_line|#endif
macro_line|#ifndef offsetof
DECL|macro|offsetof
mdefine_line|#define offsetof(t, m)&t;((size_t) (&amp;((t *)0)-&gt;m))
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;assert ()&n;**&n;**==========================================================&n;**&n;**&t;modified copy from 386bsd:/usr/include/sys/assert.h&n;**&n;**----------------------------------------------------------&n;*/
DECL|macro|assert
mdefine_line|#define&t;assert(expression) { &bslash;&n;&t;if (!(expression)) { &bslash;&n;&t;&t;(void)panic( &bslash;&n;&t;&t;&t;&quot;assertion &bslash;&quot;%s&bslash;&quot; failed: file &bslash;&quot;%s&bslash;&quot;, line %d&bslash;n&quot;, &bslash;&n;&t;&t;&t;#expression, &bslash;&n;&t;&t;&t;__FILE__, __LINE__); &bslash;&n;&t;} &bslash;&n;}
multiline_comment|/*==========================================================&n;**&n;**&t;Debugging tags&n;**&n;**==========================================================&n;*/
DECL|macro|DEBUG_ALLOC
mdefine_line|#define DEBUG_ALLOC    (0x0001)
DECL|macro|DEBUG_PHASE
mdefine_line|#define DEBUG_PHASE    (0x0002)
DECL|macro|DEBUG_QUEUE
mdefine_line|#define DEBUG_QUEUE    (0x0008)
DECL|macro|DEBUG_RESULT
mdefine_line|#define DEBUG_RESULT   (0x0010)
DECL|macro|DEBUG_POINTER
mdefine_line|#define DEBUG_POINTER  (0x0020)
DECL|macro|DEBUG_SCRIPT
mdefine_line|#define DEBUG_SCRIPT   (0x0040)
DECL|macro|DEBUG_TINY
mdefine_line|#define DEBUG_TINY     (0x0080)
DECL|macro|DEBUG_TIMING
mdefine_line|#define DEBUG_TIMING   (0x0100)
DECL|macro|DEBUG_NEGO
mdefine_line|#define DEBUG_NEGO     (0x0200)
DECL|macro|DEBUG_TAGS
mdefine_line|#define DEBUG_TAGS     (0x0400)
DECL|macro|DEBUG_SCATTER
mdefine_line|#define DEBUG_SCATTER  (0x0800)
DECL|macro|DEBUG_IC
mdefine_line|#define DEBUG_IC        (0x1000)
multiline_comment|/*&n;**    Enable/Disable debug messages.&n;**    Can be changed at runtime too.&n;*/
macro_line|#ifdef SCSI_NCR_DEBUG_INFO_SUPPORT
DECL|variable|ncr_debug
r_static
r_int
id|ncr_debug
op_assign
id|SCSI_NCR_DEBUG_FLAGS
suffix:semicolon
DECL|macro|DEBUG_FLAGS
mdefine_line|#define DEBUG_FLAGS ncr_debug
macro_line|#else
DECL|macro|DEBUG_FLAGS
mdefine_line|#define DEBUG_FLAGS&t;SCSI_NCR_DEBUG_FLAGS
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;A la VMS/CAM-3 queue management.&n;**&t;Implemented from linux list management.&n;**&n;**==========================================================&n;*/
DECL|struct|xpt_quehead
r_typedef
r_struct
id|xpt_quehead
(brace
DECL|member|flink
r_struct
id|xpt_quehead
op_star
id|flink
suffix:semicolon
multiline_comment|/* Forward  pointer */
DECL|member|blink
r_struct
id|xpt_quehead
op_star
id|blink
suffix:semicolon
multiline_comment|/* Backward pointer */
DECL|typedef|XPT_QUEHEAD
)brace
id|XPT_QUEHEAD
suffix:semicolon
DECL|macro|xpt_que_init
mdefine_line|#define xpt_que_init(ptr) do { &bslash;&n;&t;(ptr)-&gt;flink = (ptr); (ptr)-&gt;blink = (ptr); &bslash;&n;} while (0)
DECL|function|__xpt_que_add
r_static
r_inline
r_void
id|__xpt_que_add
c_func
(paren
r_struct
id|xpt_quehead
op_star
r_new
comma
r_struct
id|xpt_quehead
op_star
id|blink
comma
r_struct
id|xpt_quehead
op_star
id|flink
)paren
(brace
id|flink-&gt;blink
op_assign
r_new
suffix:semicolon
r_new
op_member_access_from_pointer
id|flink
op_assign
id|flink
suffix:semicolon
r_new
op_member_access_from_pointer
id|blink
op_assign
id|blink
suffix:semicolon
id|blink-&gt;flink
op_assign
r_new
suffix:semicolon
)brace
DECL|function|__xpt_que_del
r_static
r_inline
r_void
id|__xpt_que_del
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|blink
comma
r_struct
id|xpt_quehead
op_star
id|flink
)paren
(brace
id|flink-&gt;blink
op_assign
id|blink
suffix:semicolon
id|blink-&gt;flink
op_assign
id|flink
suffix:semicolon
)brace
DECL|function|xpt_que_empty
r_static
r_inline
r_int
id|xpt_que_empty
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|head
)paren
(brace
r_return
id|head-&gt;flink
op_eq
id|head
suffix:semicolon
)brace
DECL|function|xpt_que_splice
r_static
r_inline
r_void
id|xpt_que_splice
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|list
comma
r_struct
id|xpt_quehead
op_star
id|head
)paren
(brace
r_struct
id|xpt_quehead
op_star
id|first
op_assign
id|list-&gt;flink
suffix:semicolon
r_if
c_cond
(paren
id|first
op_ne
id|list
)paren
(brace
r_struct
id|xpt_quehead
op_star
id|last
op_assign
id|list-&gt;blink
suffix:semicolon
r_struct
id|xpt_quehead
op_star
id|at
op_assign
id|head-&gt;flink
suffix:semicolon
id|first-&gt;blink
op_assign
id|head
suffix:semicolon
id|head-&gt;flink
op_assign
id|first
suffix:semicolon
id|last-&gt;flink
op_assign
id|at
suffix:semicolon
id|at-&gt;blink
op_assign
id|last
suffix:semicolon
)brace
)brace
DECL|macro|xpt_que_entry
mdefine_line|#define xpt_que_entry(ptr, type, member) &bslash;&n;&t;((type *)((char *)(ptr)-(unsigned long)(&amp;((type *)0)-&gt;member)))
DECL|macro|xpt_insque
mdefine_line|#define xpt_insque(new, pos)&t;&t;__xpt_que_add(new, pos, (pos)-&gt;flink)
DECL|macro|xpt_remque
mdefine_line|#define xpt_remque(el)&t;&t;&t;__xpt_que_del((el)-&gt;blink, (el)-&gt;flink)
DECL|macro|xpt_insque_head
mdefine_line|#define xpt_insque_head(new, head)&t;__xpt_que_add(new, head, (head)-&gt;flink)
DECL|function|xpt_remque_head
r_static
r_inline
r_struct
id|xpt_quehead
op_star
id|xpt_remque_head
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|head
)paren
(brace
r_struct
id|xpt_quehead
op_star
id|elem
op_assign
id|head-&gt;flink
suffix:semicolon
r_if
c_cond
(paren
id|elem
op_ne
id|head
)paren
id|__xpt_que_del
c_func
(paren
id|head
comma
id|elem-&gt;flink
)paren
suffix:semicolon
r_else
id|elem
op_assign
l_int|0
suffix:semicolon
r_return
id|elem
suffix:semicolon
)brace
DECL|macro|xpt_insque_tail
mdefine_line|#define xpt_insque_tail(new, head)&t;__xpt_que_add(new, (head)-&gt;blink, head)
DECL|function|xpt_remque_tail
r_static
r_inline
r_struct
id|xpt_quehead
op_star
id|xpt_remque_tail
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|head
)paren
(brace
r_struct
id|xpt_quehead
op_star
id|elem
op_assign
id|head-&gt;blink
suffix:semicolon
r_if
c_cond
(paren
id|elem
op_ne
id|head
)paren
id|__xpt_que_del
c_func
(paren
id|elem-&gt;blink
comma
id|head
)paren
suffix:semicolon
r_else
id|elem
op_assign
l_int|0
suffix:semicolon
r_return
id|elem
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;On x86 architecture, write buffers management does &n;**&t;not reorder writes to memory. So, using compiler &n;**&t;optimization barriers is enough to guarantee some &n;**&t;ordering when the CPU is writing data accessed by &n;**&t;the NCR.&n;**&t;On Alpha architecture, explicit memory barriers have &n;**&t;to be used.&n;**&t;Other architectures are defaulted to mb() macro if  &n;**&t;defined, otherwise use compiler barrier.&n;**&n;**==========================================================&n;*/
macro_line|#if defined(__i386__)
DECL|macro|MEMORY_BARRIER
mdefine_line|#define MEMORY_BARRIER()&t;barrier()
macro_line|#elif defined(__alpha__)
DECL|macro|MEMORY_BARRIER
mdefine_line|#define MEMORY_BARRIER()&t;mb()
macro_line|#else
macro_line|#  ifdef mb
DECL|macro|MEMORY_BARRIER
macro_line|#  define MEMORY_BARRIER()&t;mb()
macro_line|#  else
DECL|macro|MEMORY_BARRIER
macro_line|#  define MEMORY_BARRIER()&t;barrier()
macro_line|#  endif
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;Simple Wrapper to kernel PCI bus interface.&n;**&n;**&t;This wrapper allows to get rid of old kernel PCI &n;**&t;interface and still allows to preserve linux-2.0 &n;**&t;compatibilty. In fact, it is mostly an incomplete &n;**&t;emulation of the new PCI code for pre-2.2 kernels.&n;**&t;When kernel-2.0 support will be dropped, we will &n;**&t;just have to remove most of this code.&n;**&n;**==========================================================&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,2,0)
DECL|typedef|pcidev_t
r_typedef
r_struct
id|pci_dev
op_star
id|pcidev_t
suffix:semicolon
DECL|macro|PCIDEV_NULL
mdefine_line|#define PCIDEV_NULL&t;&t;(0)
DECL|macro|PciBusNumber
mdefine_line|#define PciBusNumber(d)&t;&t;(d)-&gt;bus-&gt;number
DECL|macro|PciDeviceFn
mdefine_line|#define PciDeviceFn(d)&t;&t;(d)-&gt;devfn
DECL|macro|PciVendorId
mdefine_line|#define PciVendorId(d)&t;&t;(d)-&gt;vendor
DECL|macro|PciDeviceId
mdefine_line|#define PciDeviceId(d)&t;&t;(d)-&gt;device
DECL|macro|PciIrqLine
mdefine_line|#define PciIrqLine(d)&t;&t;(d)-&gt;irq
macro_line|#if LINUX_VERSION_CODE &gt; LinuxVersionCode(2,3,12)
r_static
r_int
id|__init
DECL|function|pci_get_base_address
id|pci_get_base_address
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_int
id|index
comma
id|u_long
op_star
id|base
)paren
(brace
op_star
id|base
op_assign
id|pdev-&gt;resource
(braket
id|index
)braket
dot
id|start
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pdev-&gt;resource
(braket
id|index
)braket
dot
id|flags
op_amp
l_int|0x7
)paren
op_eq
l_int|0x4
)paren
op_increment
id|index
suffix:semicolon
r_return
op_increment
id|index
suffix:semicolon
)brace
macro_line|#else
r_static
r_int
id|__init
DECL|function|pci_get_base_address
id|pci_get_base_address
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_int
id|index
comma
id|u_long
op_star
id|base
)paren
(brace
op_star
id|base
op_assign
id|pdev-&gt;base_address
(braket
id|index
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|base
op_amp
l_int|0x7
)paren
op_eq
l_int|0x4
)paren
(brace
macro_line|#if BITS_PER_LONG &gt; 32
op_star
id|base
op_or_assign
(paren
(paren
(paren
id|u_long
)paren
id|pdev-&gt;base_address
(braket
id|index
)braket
)paren
op_lshift
l_int|32
)paren
suffix:semicolon
macro_line|#endif
op_increment
id|index
suffix:semicolon
)brace
r_return
id|index
suffix:semicolon
)brace
macro_line|#endif
macro_line|#else&t;/* Incomplete emulation of current PCI code for pre-2.2 kernels */
DECL|typedef|pcidev_t
r_typedef
r_int
r_int
id|pcidev_t
suffix:semicolon
DECL|macro|PCIDEV_NULL
mdefine_line|#define PCIDEV_NULL&t;&t;(~0u)
DECL|macro|PciBusNumber
mdefine_line|#define PciBusNumber(d)&t;&t;((d)&gt;&gt;8)
DECL|macro|PciDeviceFn
mdefine_line|#define PciDeviceFn(d)&t;&t;((d)&amp;0xff)
DECL|macro|__PciDev
mdefine_line|#define __PciDev(busn, devfn)&t;(((busn)&lt;&lt;8)+(devfn))
DECL|macro|pci_present
mdefine_line|#define pci_present pcibios_present
DECL|macro|pci_read_config_byte
mdefine_line|#define pci_read_config_byte(d, w, v) &bslash;&n;&t;pcibios_read_config_byte(PciBusNumber(d), PciDeviceFn(d), w, v)
DECL|macro|pci_read_config_word
mdefine_line|#define pci_read_config_word(d, w, v) &bslash;&n;&t;pcibios_read_config_word(PciBusNumber(d), PciDeviceFn(d), w, v)
DECL|macro|pci_read_config_dword
mdefine_line|#define pci_read_config_dword(d, w, v) &bslash;&n;&t;pcibios_read_config_dword(PciBusNumber(d), PciDeviceFn(d), w, v)
DECL|macro|pci_write_config_byte
mdefine_line|#define pci_write_config_byte(d, w, v) &bslash;&n;&t;pcibios_write_config_byte(PciBusNumber(d), PciDeviceFn(d), w, v)
DECL|macro|pci_write_config_word
mdefine_line|#define pci_write_config_word(d, w, v) &bslash;&n;&t;pcibios_write_config_word(PciBusNumber(d), PciDeviceFn(d), w, v)
DECL|macro|pci_write_config_dword
mdefine_line|#define pci_write_config_dword(d, w, v) &bslash;&n;&t;pcibios_write_config_dword(PciBusNumber(d), PciDeviceFn(d), w, v)
r_static
id|pcidev_t
id|__init
DECL|function|pci_find_device
id|pci_find_device
c_func
(paren
r_int
r_int
id|vendor
comma
r_int
r_int
id|device
comma
id|pcidev_t
id|prev
)paren
(brace
r_static
r_int
r_int
id|pci_index
suffix:semicolon
r_int
id|retv
suffix:semicolon
r_int
r_char
id|bus_number
comma
id|device_fn
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_eq
id|PCIDEV_NULL
)paren
id|pci_index
op_assign
l_int|0
suffix:semicolon
r_else
op_increment
id|pci_index
suffix:semicolon
id|retv
op_assign
id|pcibios_find_device
(paren
id|vendor
comma
id|device
comma
id|pci_index
comma
op_amp
id|bus_number
comma
op_amp
id|device_fn
)paren
suffix:semicolon
r_return
id|retv
ques
c_cond
id|PCIDEV_NULL
suffix:colon
id|__PciDev
c_func
(paren
id|bus_number
comma
id|device_fn
)paren
suffix:semicolon
)brace
DECL|function|PciVendorId
r_static
id|u_short
id|__init
id|PciVendorId
c_func
(paren
id|pcidev_t
id|dev
)paren
(brace
id|u_short
id|vendor_id
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_VENDOR_ID
comma
op_amp
id|vendor_id
)paren
suffix:semicolon
r_return
id|vendor_id
suffix:semicolon
)brace
DECL|function|PciDeviceId
r_static
id|u_short
id|__init
id|PciDeviceId
c_func
(paren
id|pcidev_t
id|dev
)paren
(brace
id|u_short
id|device_id
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_DEVICE_ID
comma
op_amp
id|device_id
)paren
suffix:semicolon
r_return
id|device_id
suffix:semicolon
)brace
DECL|function|PciIrqLine
r_static
id|u_int
id|__init
id|PciIrqLine
c_func
(paren
id|pcidev_t
id|dev
)paren
(brace
id|u_char
id|irq
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_INTERRUPT_LINE
comma
op_amp
id|irq
)paren
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|pci_get_base_address
id|pci_get_base_address
c_func
(paren
id|pcidev_t
id|dev
comma
r_int
id|offset
comma
id|u_long
op_star
id|base
)paren
(brace
id|u_int32
id|tmp
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PCI_BASE_ADDRESS_0
op_plus
id|offset
comma
op_amp
id|tmp
)paren
suffix:semicolon
op_star
id|base
op_assign
id|tmp
suffix:semicolon
id|offset
op_add_assign
r_sizeof
(paren
id|u_int32
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
l_int|0x7
)paren
op_eq
l_int|0x4
)paren
(brace
macro_line|#if BITS_PER_LONG &gt; 32
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PCI_BASE_ADDRESS_0
op_plus
id|offset
comma
op_amp
id|tmp
)paren
suffix:semicolon
op_star
id|base
op_or_assign
(paren
(paren
(paren
id|u_long
)paren
id|tmp
)paren
op_lshift
l_int|32
)paren
suffix:semicolon
macro_line|#endif
id|offset
op_add_assign
r_sizeof
(paren
id|u_int32
)paren
suffix:semicolon
)brace
r_return
id|offset
suffix:semicolon
)brace
macro_line|#endif&t;/* LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,2,0) */
multiline_comment|/*==========================================================&n;**&n;**&t;SMP threading.&n;**&n;**&t;Assuming that SMP systems are generally high end &n;**&t;systems and may use several SCSI adapters, we are &n;**&t;using one lock per controller instead of some global &n;**&t;one. For the moment (linux-2.1.95), driver&squot;s entry &n;**&t;points are called with the &squot;io_request_lock&squot; lock &n;**&t;held, so:&n;**&t;- We are uselessly loosing a couple of micro-seconds &n;**&t;  to lock the controller data structure.&n;**&t;- But the driver is not broken by design for SMP and &n;**&t;  so can be more resistant to bugs or bad changes in &n;**&t;  the IO sub-system code.&n;**&t;- A small advantage could be that the interrupt code &n;**&t;  is grained as wished (e.g.: by controller).&n;**&n;**==========================================================&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,93)
DECL|variable|DRIVER_SMP_LOCK
id|spinlock_t
id|DRIVER_SMP_LOCK
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|macro|NCR_LOCK_DRIVER
mdefine_line|#define&t;NCR_LOCK_DRIVER(flags)     spin_lock_irqsave(&amp;DRIVER_SMP_LOCK, flags)
DECL|macro|NCR_UNLOCK_DRIVER
mdefine_line|#define&t;NCR_UNLOCK_DRIVER(flags)   &bslash;&n;&t;&t;spin_unlock_irqrestore(&amp;DRIVER_SMP_LOCK, flags)
DECL|macro|NCR_INIT_LOCK_NCB
mdefine_line|#define NCR_INIT_LOCK_NCB(np)      spin_lock_init(&amp;np-&gt;smp_lock)
DECL|macro|NCR_LOCK_NCB
mdefine_line|#define&t;NCR_LOCK_NCB(np, flags)    spin_lock_irqsave(&amp;np-&gt;smp_lock, flags)
DECL|macro|NCR_UNLOCK_NCB
mdefine_line|#define&t;NCR_UNLOCK_NCB(np, flags)  spin_unlock_irqrestore(&amp;np-&gt;smp_lock, flags)
DECL|macro|NCR_LOCK_SCSI_DONE
mdefine_line|#define&t;NCR_LOCK_SCSI_DONE(np, flags) &bslash;&n;&t;&t;spin_lock_irqsave(&amp;io_request_lock, flags)
DECL|macro|NCR_UNLOCK_SCSI_DONE
mdefine_line|#define&t;NCR_UNLOCK_SCSI_DONE(np, flags) &bslash;&n;&t;&t;spin_unlock_irqrestore(&amp;io_request_lock, flags)
macro_line|#else
DECL|macro|NCR_LOCK_DRIVER
mdefine_line|#define&t;NCR_LOCK_DRIVER(flags)     do { save_flags(flags); cli(); } while (0)
DECL|macro|NCR_UNLOCK_DRIVER
mdefine_line|#define&t;NCR_UNLOCK_DRIVER(flags)   do { restore_flags(flags); } while (0)
DECL|macro|NCR_INIT_LOCK_NCB
mdefine_line|#define&t;NCR_INIT_LOCK_NCB(np)      do { } while (0)
DECL|macro|NCR_LOCK_NCB
mdefine_line|#define&t;NCR_LOCK_NCB(np, flags)    do { save_flags(flags); cli(); } while (0)
DECL|macro|NCR_UNLOCK_NCB
mdefine_line|#define&t;NCR_UNLOCK_NCB(np, flags)  do { restore_flags(flags); } while (0)
DECL|macro|NCR_LOCK_SCSI_DONE
mdefine_line|#define&t;NCR_LOCK_SCSI_DONE(np, flags)    do {;} while (0)
DECL|macro|NCR_UNLOCK_SCSI_DONE
mdefine_line|#define&t;NCR_UNLOCK_SCSI_DONE(np, flags)  do {;} while (0)
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;Memory mapped IO&n;**&n;**&t;Since linux-2.1, we must use ioremap() to map the io &n;**&t;memory space and iounmap() to unmap it. This allows &n;**&t;portability. Linux 1.3.X and 2.0.X allow to remap &n;**&t;physical pages addresses greater than the highest &n;**&t;physical memory address to kernel virtual pages with &n;**&t;vremap() / vfree(). That was not portable but worked &n;**&t;with i386 architecture.&n;**&n;**==========================================================&n;*/
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,1,0)
DECL|macro|ioremap
mdefine_line|#define ioremap vremap
DECL|macro|iounmap
mdefine_line|#define iounmap vfree
macro_line|#endif
macro_line|#ifdef __sparc__
macro_line|#  include &lt;asm/irq.h&gt;
DECL|macro|pcivtobus
macro_line|#  define pcivtobus(p)&t;&t;&t;bus_dvma_to_mem(p)
DECL|macro|memcpy_to_pci
macro_line|#  define memcpy_to_pci(a, b, c)&t;memcpy_toio((a), (b), (c))
macro_line|#elif defined(__alpha__)
DECL|macro|pcivtobus
macro_line|#  define pcivtobus(p)&t;&t;&t;((p) &amp; 0xfffffffful)
DECL|macro|memcpy_to_pci
macro_line|#  define memcpy_to_pci(a, b, c)&t;memcpy_toio((a), (b), (c))
macro_line|#else&t;/* others */
DECL|macro|pcivtobus
macro_line|#  define pcivtobus(p)&t;&t;&t;(p)
DECL|macro|memcpy_to_pci
macro_line|#  define memcpy_to_pci(a, b, c)&t;memcpy_toio((a), (b), (c))
macro_line|#endif
macro_line|#if (defined(SCSI_NCR_NVRAM_SUPPORT) &amp;&amp; !defined(NCR_IOMAPPED)) || &bslash;&n;&t;(defined(__i386__) &amp;&amp; !defined(SCSI_NCR_PCI_MEM_NOT_SUPPORTED))
DECL|function|remap_pci_mem
r_static
id|u_long
id|__init
id|remap_pci_mem
c_func
(paren
id|u_long
id|base
comma
id|u_long
id|size
)paren
(brace
id|u_long
id|page_base
op_assign
(paren
(paren
id|u_long
)paren
id|base
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|u_long
id|page_offs
op_assign
(paren
(paren
id|u_long
)paren
id|base
)paren
op_minus
id|page_base
suffix:semicolon
id|u_long
id|page_remapped
op_assign
(paren
id|u_long
)paren
id|ioremap
c_func
(paren
id|page_base
comma
id|page_offs
op_plus
id|size
)paren
suffix:semicolon
r_return
id|page_remapped
ques
c_cond
(paren
id|page_remapped
op_plus
id|page_offs
)paren
suffix:colon
l_int|0UL
suffix:semicolon
)brace
DECL|function|unmap_pci_mem
r_static
r_void
id|__init
id|unmap_pci_mem
c_func
(paren
id|u_long
id|vaddr
comma
id|u_long
id|size
)paren
(brace
r_if
c_cond
(paren
id|vaddr
)paren
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|vaddr
op_amp
id|PAGE_MASK
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* not def SCSI_NCR_PCI_MEM_NOT_SUPPORTED */
multiline_comment|/*==========================================================&n;**&n;**&t;Insert a delay in micro-seconds and milli-seconds.&n;**&n;**&t;Under Linux, udelay() is restricted to delay &lt; &n;**&t;1 milli-second. In fact, it generally works for up &n;**&t;to 1 second delay. Since 2.1.105, the mdelay() function &n;**&t;is provided for delays in milli-seconds.&n;**&t;Under 2.0 kernels, udelay() is an inline function &n;**&t;that is very inaccurate on Pentium processors.&n;**&n;**==========================================================&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,105)
DECL|macro|UDELAY
mdefine_line|#define UDELAY udelay
DECL|macro|MDELAY
mdefine_line|#define MDELAY mdelay
macro_line|#else
DECL|function|UDELAY
r_static
r_void
id|UDELAY
c_func
(paren
r_int
id|us
)paren
(brace
id|udelay
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
DECL|function|MDELAY
r_static
r_void
id|MDELAY
c_func
(paren
r_int
id|ms
)paren
(brace
r_while
c_loop
(paren
id|ms
op_decrement
)paren
id|UDELAY
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;Simple power of two buddy-like allocator.&n;**&n;**&t;This simple code is not intended to be fast, but to &n;**&t;provide power of 2 aligned memory allocations.&n;**&t;Since the SCRIPTS processor only supplies 8 bit &n;**&t;arithmetic, this allocator allows simple and fast &n;**&t;address calculations  from the SCRIPTS code.&n;**&t;In addition, cache line alignment is guaranteed for &n;**&t;power of 2 cache line size.&n;**&t;Enhanced in linux-2.3.44 to provide a memory pool &n;**&t;per pcidev to support dynamic dma mapping. (I would &n;**&t;have preferred a real bus astraction, btw).&n;**&n;**==========================================================&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,0)
DECL|macro|__GetFreePages
mdefine_line|#define __GetFreePages(flags, order) __get_free_pages(flags, order)
macro_line|#else
DECL|macro|__GetFreePages
mdefine_line|#define __GetFreePages(flags, order) __get_free_pages(flags, order, 0)
macro_line|#endif
DECL|macro|MEMO_SHIFT
mdefine_line|#define MEMO_SHIFT&t;4&t;/* 16 bytes minimum memory chunk */
macro_line|#if PAGE_SIZE &gt;= 8192
DECL|macro|MEMO_PAGE_ORDER
mdefine_line|#define MEMO_PAGE_ORDER&t;0&t;/* 1 PAGE  maximum */
macro_line|#else
DECL|macro|MEMO_PAGE_ORDER
mdefine_line|#define MEMO_PAGE_ORDER&t;1&t;/* 2 PAGES maximum */
macro_line|#endif
DECL|macro|MEMO_FREE_UNUSED
mdefine_line|#define MEMO_FREE_UNUSED&t;/* Free unused pages immediately */
DECL|macro|MEMO_WARN
mdefine_line|#define MEMO_WARN&t;1
DECL|macro|MEMO_GFP_FLAGS
mdefine_line|#define MEMO_GFP_FLAGS&t;GFP_ATOMIC
DECL|macro|MEMO_CLUSTER_SHIFT
mdefine_line|#define MEMO_CLUSTER_SHIFT&t;(PAGE_SHIFT+MEMO_PAGE_ORDER)
DECL|macro|MEMO_CLUSTER_SIZE
mdefine_line|#define MEMO_CLUSTER_SIZE&t;(1UL &lt;&lt; MEMO_CLUSTER_SHIFT)
DECL|macro|MEMO_CLUSTER_MASK
mdefine_line|#define MEMO_CLUSTER_MASK&t;(MEMO_CLUSTER_SIZE-1)
DECL|typedef|m_addr_t
r_typedef
id|u_long
id|m_addr_t
suffix:semicolon
multiline_comment|/* Enough bits to bit-hack addresses */
DECL|typedef|m_bush_t
r_typedef
id|pcidev_t
id|m_bush_t
suffix:semicolon
multiline_comment|/* Something that addresses DMAable */
DECL|struct|m_link
r_typedef
r_struct
id|m_link
(brace
multiline_comment|/* Link between free memory chunks */
DECL|member|next
r_struct
id|m_link
op_star
id|next
suffix:semicolon
DECL|typedef|m_link_s
)brace
id|m_link_s
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_DYNAMIC_DMA_MAPPING
DECL|struct|m_vtob
r_typedef
r_struct
id|m_vtob
(brace
multiline_comment|/* Virtual to Bus address translation */
DECL|member|next
r_struct
id|m_vtob
op_star
id|next
suffix:semicolon
DECL|member|vaddr
id|m_addr_t
id|vaddr
suffix:semicolon
DECL|member|baddr
id|m_addr_t
id|baddr
suffix:semicolon
DECL|typedef|m_vtob_s
)brace
id|m_vtob_s
suffix:semicolon
DECL|macro|VTOB_HASH_SHIFT
mdefine_line|#define VTOB_HASH_SHIFT&t;&t;5
DECL|macro|VTOB_HASH_SIZE
mdefine_line|#define VTOB_HASH_SIZE&t;&t;(1UL &lt;&lt; VTOB_HASH_SHIFT)
DECL|macro|VTOB_HASH_MASK
mdefine_line|#define VTOB_HASH_MASK&t;&t;(VTOB_HASH_SIZE-1)
DECL|macro|VTOB_HASH_CODE
mdefine_line|#define VTOB_HASH_CODE(m)&t;&bslash;&n;&t;((((m_addr_t) (m)) &gt;&gt; MEMO_CLUSTER_SHIFT) &amp; VTOB_HASH_MASK)
macro_line|#endif
DECL|struct|m_pool
r_typedef
r_struct
id|m_pool
(brace
multiline_comment|/* Memory pool of a given kind */
macro_line|#ifdef&t;SCSI_NCR_DYNAMIC_DMA_MAPPING
DECL|member|bush
id|m_bush_t
id|bush
suffix:semicolon
DECL|member|getp
id|m_addr_t
(paren
op_star
id|getp
)paren
(paren
r_struct
id|m_pool
op_star
)paren
suffix:semicolon
DECL|member|freep
r_void
(paren
op_star
id|freep
)paren
(paren
r_struct
id|m_pool
op_star
comma
id|m_addr_t
)paren
suffix:semicolon
DECL|macro|M_GETP
mdefine_line|#define M_GETP()&t;&t;mp-&gt;getp(mp)
DECL|macro|M_FREEP
mdefine_line|#define M_FREEP(p)&t;&t;mp-&gt;freep(mp, p)
DECL|macro|GetPages
mdefine_line|#define GetPages()&t;&t;__GetFreePages(MEMO_GFP_FLAGS, MEMO_PAGE_ORDER)
DECL|macro|FreePages
mdefine_line|#define FreePages(p)&t;&t;free_pages(p, MEMO_PAGE_ORDER)
DECL|member|nump
r_int
id|nump
suffix:semicolon
DECL|member|vtob
id|m_vtob_s
op_star
(paren
id|vtob
(braket
id|VTOB_HASH_SIZE
)braket
)paren
suffix:semicolon
DECL|member|next
r_struct
id|m_pool
op_star
id|next
suffix:semicolon
macro_line|#else
mdefine_line|#define M_GETP()&t;&t;__GetFreePages(MEMO_GFP_FLAGS, MEMO_PAGE_ORDER)
mdefine_line|#define M_FREEP(p)&t;&t;free_pages(p, MEMO_PAGE_ORDER)
macro_line|#endif&t;/* SCSI_NCR_DYNAMIC_DMA_MAPPING */
DECL|member|h
r_struct
id|m_link
id|h
(braket
id|PAGE_SHIFT
op_minus
id|MEMO_SHIFT
op_plus
id|MEMO_PAGE_ORDER
op_plus
l_int|1
)braket
suffix:semicolon
DECL|typedef|m_pool_s
)brace
id|m_pool_s
suffix:semicolon
DECL|function|___m_alloc
r_static
r_void
op_star
id|___m_alloc
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
r_int
id|size
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|s
op_assign
(paren
l_int|1
op_lshift
id|MEMO_SHIFT
)paren
suffix:semicolon
r_int
id|j
suffix:semicolon
id|m_addr_t
id|a
suffix:semicolon
id|m_link_s
op_star
id|h
op_assign
id|mp-&gt;h
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
(paren
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
id|s
)paren
(brace
id|s
op_lshift_assign
l_int|1
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|j
op_assign
id|i
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|h
(braket
id|j
)braket
dot
id|next
)paren
(brace
r_if
c_cond
(paren
id|s
op_eq
(paren
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
)paren
)paren
(brace
id|h
(braket
id|j
)braket
dot
id|next
op_assign
(paren
id|m_link_s
op_star
)paren
id|M_GETP
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|h
(braket
id|j
)braket
dot
id|next
)paren
id|h
(braket
id|j
)braket
dot
id|next-&gt;next
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
op_increment
id|j
suffix:semicolon
id|s
op_lshift_assign
l_int|1
suffix:semicolon
)brace
id|a
op_assign
(paren
id|m_addr_t
)paren
id|h
(braket
id|j
)braket
dot
id|next
suffix:semicolon
r_if
c_cond
(paren
id|a
)paren
(brace
id|h
(braket
id|j
)braket
dot
id|next
op_assign
id|h
(braket
id|j
)braket
dot
id|next-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|j
OG
id|i
)paren
(brace
id|j
op_sub_assign
l_int|1
suffix:semicolon
id|s
op_rshift_assign
l_int|1
suffix:semicolon
id|h
(braket
id|j
)braket
dot
id|next
op_assign
(paren
id|m_link_s
op_star
)paren
(paren
id|a
op_plus
id|s
)paren
suffix:semicolon
id|h
(braket
id|j
)braket
dot
id|next-&gt;next
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;___m_alloc(%d) = %p&bslash;n&quot;
comma
id|size
comma
(paren
r_void
op_star
)paren
id|a
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
r_void
op_star
)paren
id|a
suffix:semicolon
)brace
DECL|function|___m_free
r_static
r_void
id|___m_free
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
r_void
op_star
id|ptr
comma
r_int
id|size
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|s
op_assign
(paren
l_int|1
op_lshift
id|MEMO_SHIFT
)paren
suffix:semicolon
id|m_link_s
op_star
id|q
suffix:semicolon
id|m_addr_t
id|a
comma
id|b
suffix:semicolon
id|m_link_s
op_star
id|h
op_assign
id|mp-&gt;h
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;___m_free(%p, %d)&bslash;n&quot;
comma
id|ptr
comma
id|size
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|size
OG
(paren
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
)paren
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
id|s
)paren
(brace
id|s
op_lshift_assign
l_int|1
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|a
op_assign
(paren
id|m_addr_t
)paren
id|ptr
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
macro_line|#ifdef MEMO_FREE_UNUSED
r_if
c_cond
(paren
id|s
op_eq
(paren
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
)paren
)paren
(brace
id|M_FREEP
c_func
(paren
id|a
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
id|b
op_assign
id|a
op_xor
id|s
suffix:semicolon
id|q
op_assign
op_amp
id|h
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
id|q-&gt;next
op_logical_and
id|q-&gt;next
op_ne
(paren
id|m_link_s
op_star
)paren
id|b
)paren
(brace
id|q
op_assign
id|q-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;next
)paren
(brace
(paren
(paren
id|m_link_s
op_star
)paren
id|a
)paren
op_member_access_from_pointer
id|next
op_assign
id|h
(braket
id|i
)braket
dot
id|next
suffix:semicolon
id|h
(braket
id|i
)braket
dot
id|next
op_assign
(paren
id|m_link_s
op_star
)paren
id|a
suffix:semicolon
r_break
suffix:semicolon
)brace
id|q-&gt;next
op_assign
id|q-&gt;next-&gt;next
suffix:semicolon
id|a
op_assign
id|a
op_amp
id|b
suffix:semicolon
id|s
op_lshift_assign
l_int|1
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
)brace
DECL|function|__m_calloc2
r_static
r_void
op_star
id|__m_calloc2
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
r_int
id|size
comma
r_char
op_star
id|name
comma
r_int
id|uflags
)paren
(brace
r_void
op_star
id|p
suffix:semicolon
id|p
op_assign
id|___m_alloc
c_func
(paren
id|mp
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_ALLOC
)paren
id|printk
(paren
l_string|&quot;new %-10s[%4d] @%p.&bslash;n&quot;
comma
id|name
comma
id|size
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|bzero
c_func
(paren
id|p
comma
id|size
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|uflags
op_amp
id|MEMO_WARN
)paren
id|printk
(paren
id|NAME53C8XX
l_string|&quot;: failed to allocate %s[%d]&bslash;n&quot;
comma
id|name
comma
id|size
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|macro|__m_calloc
mdefine_line|#define __m_calloc(mp, s, n)&t;__m_calloc2(mp, s, n, MEMO_WARN)
DECL|function|__m_free
r_static
r_void
id|__m_free
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
r_void
op_star
id|ptr
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_ALLOC
)paren
id|printk
(paren
l_string|&quot;freeing %-10s[%4d] @%p.&bslash;n&quot;
comma
id|name
comma
id|size
comma
id|ptr
)paren
suffix:semicolon
id|___m_free
c_func
(paren
id|mp
comma
id|ptr
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * With pci bus iommu support, we use a default pool of unmapped memory &n; * for memory we donnot need to DMA from/to and one pool per pcidev for &n; * memory accessed by the PCI chip. `mp0&squot; is the default not DMAable pool.&n; */
macro_line|#ifndef&t;SCSI_NCR_DYNAMIC_DMA_MAPPING
DECL|variable|mp0
r_static
id|m_pool_s
id|mp0
suffix:semicolon
macro_line|#else
DECL|function|___mp0_getp
r_static
id|m_addr_t
id|___mp0_getp
c_func
(paren
id|m_pool_s
op_star
id|mp
)paren
(brace
id|m_addr_t
id|m
op_assign
id|GetPages
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
)paren
op_increment
id|mp-&gt;nump
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
DECL|function|___mp0_freep
r_static
r_void
id|___mp0_freep
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
id|m_addr_t
id|m
)paren
(brace
id|FreePages
c_func
(paren
id|m
)paren
suffix:semicolon
op_decrement
id|mp-&gt;nump
suffix:semicolon
)brace
DECL|variable|mp0
r_static
id|m_pool_s
id|mp0
op_assign
(brace
l_int|0
comma
id|___mp0_getp
comma
id|___mp0_freep
)brace
suffix:semicolon
macro_line|#endif&t;/* SCSI_NCR_DYNAMIC_DMA_MAPPING */
DECL|function|m_calloc
r_static
r_void
op_star
id|m_calloc
c_func
(paren
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
id|u_long
id|flags
suffix:semicolon
r_void
op_star
id|m
suffix:semicolon
id|NCR_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|m
op_assign
id|__m_calloc
c_func
(paren
op_amp
id|mp0
comma
id|size
comma
id|name
)paren
suffix:semicolon
id|NCR_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
DECL|function|m_free
r_static
r_void
id|m_free
c_func
(paren
r_void
op_star
id|ptr
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
id|u_long
id|flags
suffix:semicolon
id|NCR_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__m_free
c_func
(paren
op_amp
id|mp0
comma
id|ptr
comma
id|size
comma
id|name
)paren
suffix:semicolon
id|NCR_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * DMAable pools.&n; */
macro_line|#ifndef&t;SCSI_NCR_DYNAMIC_DMA_MAPPING
multiline_comment|/* Without pci bus iommu support, all the memory is assumed DMAable */
DECL|macro|__m_calloc_dma
mdefine_line|#define __m_calloc_dma(b, s, n)&t;&t;m_calloc(s, n)
DECL|macro|__m_free_dma
mdefine_line|#define __m_free_dma(b, p, s, n)&t;m_free(p, s, n)
DECL|macro|__vtobus
mdefine_line|#define __vtobus(b, p)&t;&t;&t;virt_to_bus(p)
macro_line|#else
multiline_comment|/*&n; * With pci bus iommu support, we maintain one pool per pcidev and a &n; * hashed reverse table for virtual to bus physical address translations.&n; */
DECL|function|___dma_getp
r_static
id|m_addr_t
id|___dma_getp
c_func
(paren
id|m_pool_s
op_star
id|mp
)paren
(brace
id|m_addr_t
id|vp
suffix:semicolon
id|m_vtob_s
op_star
id|vbp
suffix:semicolon
id|vbp
op_assign
id|__m_calloc
c_func
(paren
op_amp
id|mp0
comma
r_sizeof
(paren
op_star
id|vbp
)paren
comma
l_string|&quot;VTOB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vbp
)paren
(brace
id|dma_addr_t
id|daddr
suffix:semicolon
id|vp
op_assign
(paren
id|m_addr_t
)paren
id|pci_alloc_consistent
c_func
(paren
id|mp-&gt;bush
comma
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
comma
op_amp
id|daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vp
)paren
(brace
r_int
id|hc
op_assign
id|VTOB_HASH_CODE
c_func
(paren
id|vp
)paren
suffix:semicolon
id|vbp-&gt;vaddr
op_assign
id|vp
suffix:semicolon
id|vbp-&gt;baddr
op_assign
id|daddr
suffix:semicolon
id|vbp-&gt;next
op_assign
id|mp-&gt;vtob
(braket
id|hc
)braket
suffix:semicolon
id|mp-&gt;vtob
(braket
id|hc
)braket
op_assign
id|vbp
suffix:semicolon
op_increment
id|mp-&gt;nump
suffix:semicolon
r_return
id|vp
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|vbp
)paren
id|__m_free
c_func
(paren
op_amp
id|mp0
comma
id|vbp
comma
r_sizeof
(paren
op_star
id|vbp
)paren
comma
l_string|&quot;VTOB&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|___dma_freep
r_static
r_void
id|___dma_freep
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
id|m_addr_t
id|m
)paren
(brace
id|m_vtob_s
op_star
op_star
id|vbpp
comma
op_star
id|vbp
suffix:semicolon
r_int
id|hc
op_assign
id|VTOB_HASH_CODE
c_func
(paren
id|m
)paren
suffix:semicolon
id|vbpp
op_assign
op_amp
id|mp-&gt;vtob
(braket
id|hc
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|vbpp
op_logical_and
(paren
op_star
id|vbpp
)paren
op_member_access_from_pointer
id|vaddr
op_ne
id|m
)paren
id|vbpp
op_assign
op_amp
(paren
op_star
id|vbpp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
op_star
id|vbpp
)paren
(brace
id|vbp
op_assign
op_star
id|vbpp
suffix:semicolon
op_star
id|vbpp
op_assign
(paren
op_star
id|vbpp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|mp-&gt;bush
comma
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
comma
(paren
r_void
op_star
)paren
id|vbp-&gt;vaddr
comma
(paren
id|dma_addr_t
)paren
id|vbp-&gt;baddr
)paren
suffix:semicolon
id|__m_free
c_func
(paren
op_amp
id|mp0
comma
id|vbp
comma
r_sizeof
(paren
op_star
id|vbp
)paren
comma
l_string|&quot;VTOB&quot;
)paren
suffix:semicolon
op_decrement
id|mp-&gt;nump
suffix:semicolon
)brace
)brace
DECL|function|___get_dma_pool
r_static
r_inline
id|m_pool_s
op_star
id|___get_dma_pool
c_func
(paren
id|m_bush_t
id|bush
)paren
(brace
id|m_pool_s
op_star
id|mp
suffix:semicolon
r_for
c_loop
(paren
id|mp
op_assign
id|mp0.next
suffix:semicolon
id|mp
op_logical_and
id|mp-&gt;bush
op_ne
id|bush
suffix:semicolon
id|mp
op_assign
id|mp-&gt;next
)paren
suffix:semicolon
r_return
id|mp
suffix:semicolon
)brace
DECL|function|___cre_dma_pool
r_static
id|m_pool_s
op_star
id|___cre_dma_pool
c_func
(paren
id|m_bush_t
id|bush
)paren
(brace
id|m_pool_s
op_star
id|mp
suffix:semicolon
id|mp
op_assign
id|__m_calloc
c_func
(paren
op_amp
id|mp0
comma
r_sizeof
(paren
op_star
id|mp
)paren
comma
l_string|&quot;MPOOL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
(brace
id|bzero
c_func
(paren
id|mp
comma
r_sizeof
(paren
op_star
id|mp
)paren
)paren
suffix:semicolon
id|mp-&gt;bush
op_assign
id|bush
suffix:semicolon
id|mp-&gt;getp
op_assign
id|___dma_getp
suffix:semicolon
id|mp-&gt;freep
op_assign
id|___dma_freep
suffix:semicolon
id|mp-&gt;next
op_assign
id|mp0.next
suffix:semicolon
id|mp0.next
op_assign
id|mp
suffix:semicolon
)brace
r_return
id|mp
suffix:semicolon
)brace
DECL|function|___del_dma_pool
r_static
r_void
id|___del_dma_pool
c_func
(paren
id|m_pool_s
op_star
id|p
)paren
(brace
r_struct
id|m_pool
op_star
op_star
id|pp
op_assign
op_amp
id|mp0.next
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pp
op_logical_and
op_star
id|pp
op_ne
id|p
)paren
id|pp
op_assign
op_amp
(paren
op_star
id|pp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pp
)paren
(brace
op_star
id|pp
op_assign
(paren
op_star
id|pp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|__m_free
c_func
(paren
op_amp
id|mp0
comma
id|p
comma
r_sizeof
(paren
op_star
id|p
)paren
comma
l_string|&quot;MPOOL&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|__m_calloc_dma
r_static
r_void
op_star
id|__m_calloc_dma
c_func
(paren
id|m_bush_t
id|bush
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
id|u_long
id|flags
suffix:semicolon
r_struct
id|m_pool
op_star
id|mp
suffix:semicolon
r_void
op_star
id|m
op_assign
l_int|0
suffix:semicolon
id|NCR_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|mp
op_assign
id|___get_dma_pool
c_func
(paren
id|bush
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mp
)paren
id|mp
op_assign
id|___cre_dma_pool
c_func
(paren
id|bush
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
id|m
op_assign
id|__m_calloc
c_func
(paren
id|mp
comma
id|size
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_logical_and
op_logical_neg
id|mp-&gt;nump
)paren
id|___del_dma_pool
c_func
(paren
id|mp
)paren
suffix:semicolon
id|NCR_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
DECL|function|__m_free_dma
r_static
r_void
id|__m_free_dma
c_func
(paren
id|m_bush_t
id|bush
comma
r_void
op_star
id|m
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
id|u_long
id|flags
suffix:semicolon
r_struct
id|m_pool
op_star
id|mp
suffix:semicolon
id|NCR_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|mp
op_assign
id|___get_dma_pool
c_func
(paren
id|bush
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
id|__m_free
c_func
(paren
id|mp
comma
id|m
comma
id|size
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_logical_and
op_logical_neg
id|mp-&gt;nump
)paren
id|___del_dma_pool
c_func
(paren
id|mp
)paren
suffix:semicolon
id|NCR_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__vtobus
r_static
id|m_addr_t
id|__vtobus
c_func
(paren
id|m_bush_t
id|bush
comma
r_void
op_star
id|m
)paren
(brace
id|u_long
id|flags
suffix:semicolon
id|m_pool_s
op_star
id|mp
suffix:semicolon
r_int
id|hc
op_assign
id|VTOB_HASH_CODE
c_func
(paren
id|m
)paren
suffix:semicolon
id|m_vtob_s
op_star
id|vp
op_assign
l_int|0
suffix:semicolon
id|m_addr_t
id|a
op_assign
(paren
(paren
id|m_addr_t
)paren
id|m
)paren
op_amp
op_complement
id|MEMO_CLUSTER_MASK
suffix:semicolon
id|NCR_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|mp
op_assign
id|___get_dma_pool
c_func
(paren
id|bush
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
(brace
id|vp
op_assign
id|mp-&gt;vtob
(braket
id|hc
)braket
suffix:semicolon
r_while
c_loop
(paren
id|vp
op_logical_and
(paren
id|m_addr_t
)paren
id|vp-&gt;vaddr
op_ne
id|a
)paren
id|vp
op_assign
id|vp-&gt;next
suffix:semicolon
)brace
id|NCR_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|vp
ques
c_cond
id|vp-&gt;baddr
op_plus
(paren
(paren
(paren
id|m_addr_t
)paren
id|m
)paren
op_minus
id|a
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_NCR_DYNAMIC_DMA_MAPPING */
DECL|macro|_m_calloc_dma
mdefine_line|#define _m_calloc_dma(np, s, n)&t;&t;__m_calloc_dma(np-&gt;pdev, s, n)
DECL|macro|_m_free_dma
mdefine_line|#define _m_free_dma(np, p, s, n)&t;__m_free_dma(np-&gt;pdev, p, s, n)
DECL|macro|m_calloc_dma
mdefine_line|#define m_calloc_dma(s, n)&t;&t;_m_calloc_dma(np, s, n)
DECL|macro|m_free_dma
mdefine_line|#define m_free_dma(p, s, n)&t;&t;_m_free_dma(np, p, s, n)
DECL|macro|_vtobus
mdefine_line|#define _vtobus(np, p)&t;&t;&t;__vtobus(np-&gt;pdev, p)
DECL|macro|vtobus
mdefine_line|#define vtobus(p)&t;&t;&t;_vtobus(np, p)
multiline_comment|/*&n; *  Deal with DMA mapping/unmapping.&n; */
macro_line|#ifndef SCSI_NCR_DYNAMIC_DMA_MAPPING
multiline_comment|/* Linux versions prior to pci bus iommu kernel interface */
DECL|macro|__unmap_scsi_data
mdefine_line|#define __unmap_scsi_data(pdev, cmd)&t;do {; } while (0)
DECL|macro|__map_scsi_single_data
mdefine_line|#define __map_scsi_single_data(pdev, cmd) (__vtobus(pdev,(cmd)-&gt;request_buffer))
DECL|macro|__map_scsi_sg_data
mdefine_line|#define __map_scsi_sg_data(pdev, cmd)&t;((cmd)-&gt;use_sg)
DECL|macro|__sync_scsi_data
mdefine_line|#define __sync_scsi_data(pdev, cmd)&t;do {; } while (0)
DECL|macro|scsi_sg_dma_address
mdefine_line|#define scsi_sg_dma_address(sc)&t;&t;vtobus((sc)-&gt;address)
DECL|macro|scsi_sg_dma_len
mdefine_line|#define scsi_sg_dma_len(sc)&t;&t;((sc)-&gt;length)
macro_line|#else
multiline_comment|/* Linux version with pci bus iommu kernel interface */
multiline_comment|/* To keep track of the dma mapping (sg/single) that has been set */
DECL|macro|__data_mapped
mdefine_line|#define __data_mapped&t;SCp.phase
DECL|macro|__data_mapping
mdefine_line|#define __data_mapping&t;SCp.have_data_in
DECL|function|__unmap_scsi_data
r_static
r_void
id|__unmap_scsi_data
c_func
(paren
id|pcidev_t
id|pdev
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|dma_dir
op_assign
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;__data_mapped
)paren
(brace
r_case
l_int|2
suffix:colon
id|pci_unmap_sg
c_func
(paren
id|pdev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|pci_unmap_single
c_func
(paren
id|pdev
comma
id|cmd-&gt;__data_mapping
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cmd-&gt;__data_mapped
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|__map_scsi_single_data
r_static
id|u_long
id|__map_scsi_single_data
c_func
(paren
id|pcidev_t
id|pdev
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|dma_addr_t
id|mapping
suffix:semicolon
r_int
id|dma_dir
op_assign
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|mapping
op_assign
id|pci_map_single
c_func
(paren
id|pdev
comma
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
id|cmd-&gt;__data_mapped
op_assign
l_int|1
suffix:semicolon
id|cmd-&gt;__data_mapping
op_assign
id|mapping
suffix:semicolon
r_return
id|mapping
suffix:semicolon
)brace
DECL|function|__map_scsi_sg_data
r_static
r_int
id|__map_scsi_sg_data
c_func
(paren
id|pcidev_t
id|pdev
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|use_sg
suffix:semicolon
r_int
id|dma_dir
op_assign
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|use_sg
op_assign
id|pci_map_sg
c_func
(paren
id|pdev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
id|cmd-&gt;__data_mapped
op_assign
l_int|2
suffix:semicolon
id|cmd-&gt;__data_mapping
op_assign
id|use_sg
suffix:semicolon
r_return
id|use_sg
suffix:semicolon
)brace
DECL|function|__sync_scsi_data
r_static
r_void
id|__sync_scsi_data
c_func
(paren
id|pcidev_t
id|pdev
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|dma_dir
op_assign
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;__data_mapped
)paren
(brace
r_case
l_int|2
suffix:colon
id|pci_dma_sync_sg
c_func
(paren
id|pdev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|pci_dma_sync_single
c_func
(paren
id|pdev
comma
id|cmd-&gt;__data_mapping
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|macro|scsi_sg_dma_address
mdefine_line|#define scsi_sg_dma_address(sc)&t;&t;sg_dma_address(sc)
DECL|macro|scsi_sg_dma_len
mdefine_line|#define scsi_sg_dma_len(sc)&t;&t;sg_dma_len(sc)
macro_line|#endif&t;/* SCSI_NCR_DYNAMIC_DMA_MAPPING */
DECL|macro|unmap_scsi_data
mdefine_line|#define unmap_scsi_data(np, cmd)&t;__unmap_scsi_data(np-&gt;pdev, cmd)
DECL|macro|map_scsi_single_data
mdefine_line|#define map_scsi_single_data(np, cmd)&t;__map_scsi_single_data(np-&gt;pdev, cmd)
DECL|macro|map_scsi_sg_data
mdefine_line|#define map_scsi_sg_data(np, cmd)&t;__map_scsi_sg_data(np-&gt;pdev, cmd)
DECL|macro|sync_scsi_data
mdefine_line|#define sync_scsi_data(np, cmd)&t;&t;__sync_scsi_data(np-&gt;pdev, cmd)
multiline_comment|/*==========================================================&n;**&n;**&t;SCSI data transfer direction&n;**&n;**&t;Until some linux kernel version near 2.3.40, &n;**&t;low-level scsi drivers were not told about data &n;**&t;transfer direction. We check the existence of this &n;**&t;feature that has been expected for a _long_ time by &n;**&t;all SCSI driver developers by just testing against &n;**&t;the definition of SCSI_DATA_UNKNOWN. Indeed this is &n;**&t;a hack, but testing against a kernel version would &n;**&t;have been a shame. ;-)&n;**&n;**==========================================================&n;*/
macro_line|#ifdef&t;SCSI_DATA_UNKNOWN
DECL|macro|scsi_data_direction
mdefine_line|#define scsi_data_direction(cmd)&t;(cmd-&gt;sc_data_direction)
macro_line|#else
DECL|macro|SCSI_DATA_UNKNOWN
mdefine_line|#define&t;SCSI_DATA_UNKNOWN&t;0
DECL|macro|SCSI_DATA_WRITE
mdefine_line|#define&t;SCSI_DATA_WRITE&t;&t;1
DECL|macro|SCSI_DATA_READ
mdefine_line|#define&t;SCSI_DATA_READ&t;&t;2
DECL|macro|SCSI_DATA_NONE
mdefine_line|#define&t;SCSI_DATA_NONE&t;&t;3
DECL|function|scsi_data_direction
r_static
id|__inline__
r_int
id|scsi_data_direction
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|direction
suffix:semicolon
r_switch
c_cond
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/*&t;READ(6)&t;&t;&t;&t;08 */
r_case
l_int|0x28
suffix:colon
multiline_comment|/*&t;READ(10)&t;&t;&t;28 */
r_case
l_int|0xA8
suffix:colon
multiline_comment|/*&t;READ(12)&t;&t;&t;A8 */
id|direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0A
suffix:colon
multiline_comment|/*&t;WRITE(6)&t;&t;&t;0A */
r_case
l_int|0x2A
suffix:colon
multiline_comment|/*&t;WRITE(10)&t;&t;&t;2A */
r_case
l_int|0xAA
suffix:colon
multiline_comment|/*&t;WRITE(12)&t;&t;&t;AA */
id|direction
op_assign
id|SCSI_DATA_WRITE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|direction
op_assign
id|SCSI_DATA_UNKNOWN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|direction
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_DATA_UNKNOWN */
multiline_comment|/*==========================================================&n;**&n;**&t;Driver setup.&n;**&n;**&t;This structure is initialized from linux config &n;**&t;options. It can be overridden at boot-up by the boot &n;**&t;command line.&n;**&n;**==========================================================&n;*/
r_static
r_struct
id|ncr_driver_setup
DECL|variable|driver_setup
id|driver_setup
op_assign
id|SCSI_NCR_DRIVER_SETUP
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT
r_static
r_struct
id|ncr_driver_setup
DECL|variable|__initdata
id|driver_safe_setup
id|__initdata
op_assign
id|SCSI_NCR_DRIVER_SAFE_SETUP
suffix:semicolon
macro_line|#endif
DECL|macro|initverbose
mdefine_line|#define initverbose (driver_setup.verbose)
DECL|macro|bootverbose
mdefine_line|#define bootverbose (np-&gt;verbose)
multiline_comment|/*==========================================================&n;**&n;**&t;Big/Little endian support.&n;**&n;**&t;If the NCR uses big endian addressing mode over the &n;**&t;PCI, actual io register addresses for byte and word &n;**&t;accesses must be changed according to lane routing.&n;**&t;Btw, ncr_offb() and ncr_offw() macros only apply to &n;**&t;constants and so donnot generate bloated code.&n;**&n;**&t;If the CPU and the NCR use same endian-ness adressing,&n;**&t;no byte reordering is needed for script patching.&n;**&t;Macro cpu_to_scr() is to be used for script patching.&n;**&t;Macro scr_to_cpu() is to be used for getting a DWORD &n;**&t;from the script.&n;**&n;**==========================================================&n;*/
macro_line|#if&t;defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|ncr_offb
mdefine_line|#define ncr_offb(o)&t;(((o)&amp;~3)+((~((o)&amp;3))&amp;3))
DECL|macro|ncr_offw
mdefine_line|#define ncr_offw(o)&t;(((o)&amp;~3)+((~((o)&amp;3))&amp;2))
macro_line|#else
DECL|macro|ncr_offb
mdefine_line|#define ncr_offb(o)&t;(o)
DECL|macro|ncr_offw
mdefine_line|#define ncr_offw(o)&t;(o)
macro_line|#endif
macro_line|#if&t;defined(__BIG_ENDIAN) &amp;&amp; !defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|cpu_to_scr
mdefine_line|#define cpu_to_scr(dw)&t;cpu_to_le32(dw)
DECL|macro|scr_to_cpu
mdefine_line|#define scr_to_cpu(dw)&t;le32_to_cpu(dw)
macro_line|#elif&t;defined(__LITTLE_ENDIAN) &amp;&amp; defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|cpu_to_scr
mdefine_line|#define cpu_to_scr(dw)&t;cpu_to_be32(dw)
DECL|macro|scr_to_cpu
mdefine_line|#define scr_to_cpu(dw)&t;be32_to_cpu(dw)
macro_line|#else
DECL|macro|cpu_to_scr
mdefine_line|#define cpu_to_scr(dw)&t;(dw)
DECL|macro|scr_to_cpu
mdefine_line|#define scr_to_cpu(dw)&t;(dw)
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;Access to the controller chip.&n;**&n;**&t;If NCR_IOMAPPED is defined, the driver will use &n;**&t;normal IOs instead of the MEMORY MAPPED IO method  &n;**&t;recommended by PCI specifications.&n;**&t;If all PCI bridges, host brigdes and architectures &n;**&t;would have been correctly designed for PCI, this &n;**&t;option would be useless.&n;**&n;**&t;If the CPU and the NCR use same endian-ness adressing,&n;**&t;no byte reordering is needed for accessing chip io &n;**&t;registers. Functions suffixed by &squot;_raw&squot; are assumed &n;**&t;to access the chip over the PCI without doing byte &n;**&t;reordering. Functions suffixed by &squot;_l2b&squot; are &n;**&t;assumed to perform little-endian to big-endian byte &n;**&t;reordering, those suffixed by &squot;_b2l&squot; blah, blah,&n;**&t;blah, ...&n;**&n;**==========================================================&n;*/
macro_line|#if defined(NCR_IOMAPPED)
multiline_comment|/*&n;**&t;IO mapped only input / ouput&n;*/
DECL|macro|INB_OFF
mdefine_line|#define&t;INB_OFF(o)&t;&t;inb (np-&gt;base_io + ncr_offb(o))
DECL|macro|OUTB_OFF
mdefine_line|#define&t;OUTB_OFF(o, val)&t;outb ((val), np-&gt;base_io + ncr_offb(o))
macro_line|#if&t;defined(__BIG_ENDIAN) &amp;&amp; !defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|INW_OFF
mdefine_line|#define&t;INW_OFF(o)&t;&t;inw_l2b (np-&gt;base_io + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define&t;INL_OFF(o)&t;&t;inl_l2b (np-&gt;base_io + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define&t;OUTW_OFF(o, val)&t;outw_b2l ((val), np-&gt;base_io + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define&t;OUTL_OFF(o, val)&t;outl_b2l ((val), np-&gt;base_io + (o))
macro_line|#elif&t;defined(__LITTLE_ENDIAN) &amp;&amp; defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|INW_OFF
mdefine_line|#define&t;INW_OFF(o)&t;&t;inw_b2l (np-&gt;base_io + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define&t;INL_OFF(o)&t;&t;inl_b2l (np-&gt;base_io + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define&t;OUTW_OFF(o, val)&t;outw_l2b ((val), np-&gt;base_io + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define&t;OUTL_OFF(o, val)&t;outl_l2b ((val), np-&gt;base_io + (o))
macro_line|#else
DECL|macro|INW_OFF
mdefine_line|#define&t;INW_OFF(o)&t;&t;inw_raw (np-&gt;base_io + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define&t;INL_OFF(o)&t;&t;inl_raw (np-&gt;base_io + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define&t;OUTW_OFF(o, val)&t;outw_raw ((val), np-&gt;base_io + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define&t;OUTL_OFF(o, val)&t;outl_raw ((val), np-&gt;base_io + (o))
macro_line|#endif&t;/* ENDIANs */
macro_line|#else&t;/* defined NCR_IOMAPPED */
multiline_comment|/*&n;**&t;MEMORY mapped IO input / output&n;*/
DECL|macro|INB_OFF
mdefine_line|#define INB_OFF(o)&t;&t;readb((char *)np-&gt;reg + ncr_offb(o))
DECL|macro|OUTB_OFF
mdefine_line|#define OUTB_OFF(o, val)&t;writeb((val), (char *)np-&gt;reg + ncr_offb(o))
macro_line|#if&t;defined(__BIG_ENDIAN) &amp;&amp; !defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|INW_OFF
mdefine_line|#define INW_OFF(o)&t;&t;readw_l2b((char *)np-&gt;reg + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define INL_OFF(o)&t;&t;readl_l2b((char *)np-&gt;reg + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define OUTW_OFF(o, val)&t;writew_b2l((val), (char *)np-&gt;reg + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define OUTL_OFF(o, val)&t;writel_b2l((val), (char *)np-&gt;reg + (o))
macro_line|#elif&t;defined(__LITTLE_ENDIAN) &amp;&amp; defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|INW_OFF
mdefine_line|#define INW_OFF(o)&t;&t;readw_b2l((char *)np-&gt;reg + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define INL_OFF(o)&t;&t;readl_b2l((char *)np-&gt;reg + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define OUTW_OFF(o, val)&t;writew_l2b((val), (char *)np-&gt;reg + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define OUTL_OFF(o, val)&t;writel_l2b((val), (char *)np-&gt;reg + (o))
macro_line|#else
DECL|macro|INW_OFF
mdefine_line|#define INW_OFF(o)&t;&t;readw_raw((char *)np-&gt;reg + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define INL_OFF(o)&t;&t;readl_raw((char *)np-&gt;reg + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define OUTW_OFF(o, val)&t;writew_raw((val), (char *)np-&gt;reg + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define OUTL_OFF(o, val)&t;writel_raw((val), (char *)np-&gt;reg + (o))
macro_line|#endif
macro_line|#endif&t;/* defined NCR_IOMAPPED */
DECL|macro|INB
mdefine_line|#define INB(r)&t;&t;INB_OFF (offsetof(struct ncr_reg,r))
DECL|macro|INW
mdefine_line|#define INW(r)&t;&t;INW_OFF (offsetof(struct ncr_reg,r))
DECL|macro|INL
mdefine_line|#define INL(r)&t;&t;INL_OFF (offsetof(struct ncr_reg,r))
DECL|macro|OUTB
mdefine_line|#define OUTB(r, val)&t;OUTB_OFF (offsetof(struct ncr_reg,r), (val))
DECL|macro|OUTW
mdefine_line|#define OUTW(r, val)&t;OUTW_OFF (offsetof(struct ncr_reg,r), (val))
DECL|macro|OUTL
mdefine_line|#define OUTL(r, val)&t;OUTL_OFF (offsetof(struct ncr_reg,r), (val))
multiline_comment|/*&n;**&t;Set bit field ON, OFF &n;*/
DECL|macro|OUTONB
mdefine_line|#define OUTONB(r, m)&t;OUTB(r, INB(r) | (m))
DECL|macro|OUTOFFB
mdefine_line|#define OUTOFFB(r, m)&t;OUTB(r, INB(r) &amp; ~(m))
DECL|macro|OUTONW
mdefine_line|#define OUTONW(r, m)&t;OUTW(r, INW(r) | (m))
DECL|macro|OUTOFFW
mdefine_line|#define OUTOFFW(r, m)&t;OUTW(r, INW(r) &amp; ~(m))
DECL|macro|OUTONL
mdefine_line|#define OUTONL(r, m)&t;OUTL(r, INL(r) | (m))
DECL|macro|OUTOFFL
mdefine_line|#define OUTOFFL(r, m)&t;OUTL(r, INL(r) &amp; ~(m))
multiline_comment|/*==========================================================&n;**&n;**&t;Structures used by the detection routine to transmit &n;**&t;device configuration to the attach function.&n;**&n;**==========================================================&n;*/
r_typedef
r_struct
(brace
DECL|member|bus
r_int
id|bus
suffix:semicolon
DECL|member|device_fn
id|u_char
id|device_fn
suffix:semicolon
DECL|member|base
id|u_long
id|base
suffix:semicolon
DECL|member|base_2
id|u_long
id|base_2
suffix:semicolon
DECL|member|io_port
id|u_long
id|io_port
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* port and reg fields to use INB, OUTB macros */
DECL|member|base_io
id|u_long
id|base_io
suffix:semicolon
DECL|member|reg
r_volatile
r_struct
id|ncr_reg
op_star
id|reg
suffix:semicolon
DECL|typedef|ncr_slot
)brace
id|ncr_slot
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&t;Structure used to store the NVRAM content.&n;**&n;**==========================================================&n;*/
r_typedef
r_struct
(brace
DECL|member|type
r_int
id|type
suffix:semicolon
DECL|macro|SCSI_NCR_SYMBIOS_NVRAM
mdefine_line|#define&t;SCSI_NCR_SYMBIOS_NVRAM&t;(1)
DECL|macro|SCSI_NCR_TEKRAM_NVRAM
mdefine_line|#define&t;SCSI_NCR_TEKRAM_NVRAM&t;(2)
macro_line|#ifdef&t;SCSI_NCR_NVRAM_SUPPORT
r_union
(brace
DECL|member|Symbios
id|Symbios_nvram
id|Symbios
suffix:semicolon
DECL|member|Tekram
id|Tekram_nvram
id|Tekram
suffix:semicolon
DECL|member|data
)brace
id|data
suffix:semicolon
macro_line|#endif
DECL|typedef|ncr_nvram
)brace
id|ncr_nvram
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&t;Structure used by detection routine to save data on &n;**&t;each detected board for attach.&n;**&n;**==========================================================&n;*/
r_typedef
r_struct
(brace
DECL|member|pdev
id|pcidev_t
id|pdev
suffix:semicolon
DECL|member|slot
id|ncr_slot
id|slot
suffix:semicolon
DECL|member|chip
id|ncr_chip
id|chip
suffix:semicolon
DECL|member|nvram
id|ncr_nvram
op_star
id|nvram
suffix:semicolon
DECL|member|host_id
id|u_char
id|host_id
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_PQS_PDS_SUPPORT
DECL|member|pqs_pds
id|u_char
id|pqs_pds
suffix:semicolon
macro_line|#endif
DECL|member|attach_done
r_int
id|attach_done
suffix:semicolon
DECL|typedef|ncr_device
)brace
id|ncr_device
suffix:semicolon
r_static
r_int
id|ncr_attach
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|unit
comma
id|ncr_device
op_star
id|device
)paren
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&t;NVRAM detection and reading.&n;**&t; &n;**&t;Currently supported:&n;**&t;- 24C16 EEPROM with both Symbios and Tekram layout.&n;**&t;- 93C46 EEPROM with Tekram layout.&n;**&n;**==========================================================&n;*/
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
multiline_comment|/*&n; *  24C16 EEPROM reading.&n; *&n; *  GPOI0 - data in/data out&n; *  GPIO1 - clock&n; *  Symbios NVRAM wiring now also used by Tekram.&n; */
DECL|macro|SET_BIT
mdefine_line|#define SET_BIT 0
DECL|macro|CLR_BIT
mdefine_line|#define CLR_BIT 1
DECL|macro|SET_CLK
mdefine_line|#define SET_CLK 2
DECL|macro|CLR_CLK
mdefine_line|#define CLR_CLK 3
multiline_comment|/*&n; *  Set/clear data/clock bit in GPIO0&n; */
r_static
r_void
id|__init
DECL|function|S24C16_set_bit
id|S24C16_set_bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
comma
r_int
id|bit_mode
)paren
(brace
id|UDELAY
(paren
l_int|5
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bit_mode
)paren
(brace
r_case
id|SET_BIT
suffix:colon
op_star
id|gpreg
op_or_assign
id|write_bit
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLR_BIT
suffix:colon
op_star
id|gpreg
op_and_assign
l_int|0xfe
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SET_CLK
suffix:colon
op_star
id|gpreg
op_or_assign
l_int|0x02
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLR_CLK
suffix:colon
op_star
id|gpreg
op_and_assign
l_int|0xfd
suffix:semicolon
r_break
suffix:semicolon
)brace
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|5
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Send START condition to NVRAM to wake it up.&n; */
DECL|function|S24C16_start
r_static
r_void
id|__init
id|S24C16_start
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|1
comma
id|gpreg
comma
id|SET_BIT
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|SET_CLK
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_BIT
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_CLK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Send STOP condition to NVRAM - puts NVRAM to sleep... ZZzzzz!!&n; */
DECL|function|S24C16_stop
r_static
r_void
id|__init
id|S24C16_stop
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|SET_CLK
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|1
comma
id|gpreg
comma
id|SET_BIT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Read or write a bit to the NVRAM,&n; *  read if GPIO0 input else write if GPIO0 output&n; */
r_static
r_void
id|__init
DECL|function|S24C16_do_bit
id|S24C16_do_bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|S24C16_set_bit
c_func
(paren
id|np
comma
id|write_bit
comma
id|gpreg
comma
id|SET_BIT
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|SET_CLK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_bit
)paren
op_star
id|read_bit
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_CLK
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_BIT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Output an ACK to the NVRAM after reading,&n; *  change GPIO0 to output and when done back to an input&n; */
r_static
r_void
id|__init
DECL|function|S24C16_write_ack
id|S24C16_write_ack
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
(brace
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
op_amp
l_int|0xfe
)paren
suffix:semicolon
id|S24C16_do_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|write_bit
comma
id|gpreg
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Input an ACK from NVRAM after writing,&n; *  change GPIO0 to input and when done back to an output&n; */
r_static
r_void
id|__init
DECL|function|S24C16_read_ack
id|S24C16_read_ack
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
(brace
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
op_or
l_int|0x01
)paren
suffix:semicolon
id|S24C16_do_bit
c_func
(paren
id|np
comma
id|read_bit
comma
l_int|1
comma
id|gpreg
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  WRITE a byte to the NVRAM and then get an ACK to see it was accepted OK,&n; *  GPIO0 must already be set as an output&n; */
r_static
r_void
id|__init
DECL|function|S24C16_write_byte
id|S24C16_write_byte
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|ack_data
comma
id|u_char
id|write_data
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
(brace
r_int
id|x
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|8
suffix:semicolon
id|x
op_increment
)paren
id|S24C16_do_bit
c_func
(paren
id|np
comma
l_int|0
comma
(paren
id|write_data
op_rshift
(paren
l_int|7
op_minus
id|x
)paren
)paren
op_amp
l_int|0x01
comma
id|gpreg
)paren
suffix:semicolon
id|S24C16_read_ack
c_func
(paren
id|np
comma
id|ack_data
comma
id|gpreg
comma
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  READ a byte from the NVRAM and then send an ACK to say we have got it,&n; *  GPIO0 must already be set as an input&n; */
r_static
r_void
id|__init
DECL|function|S24C16_read_byte
id|S24C16_read_byte
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_data
comma
id|u_char
id|ack_data
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
(brace
r_int
id|x
suffix:semicolon
id|u_char
id|read_bit
suffix:semicolon
op_star
id|read_data
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|8
suffix:semicolon
id|x
op_increment
)paren
(brace
id|S24C16_do_bit
c_func
(paren
id|np
comma
op_amp
id|read_bit
comma
l_int|1
comma
id|gpreg
)paren
suffix:semicolon
op_star
id|read_data
op_or_assign
(paren
(paren
id|read_bit
op_amp
l_int|0x01
)paren
op_lshift
(paren
l_int|7
op_minus
id|x
)paren
)paren
suffix:semicolon
)brace
id|S24C16_write_ack
c_func
(paren
id|np
comma
id|ack_data
comma
id|gpreg
comma
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Read &squot;len&squot; bytes starting at &squot;offset&squot;.&n; */
r_static
r_int
id|__init
DECL|function|sym_read_S24C16_nvram
id|sym_read_S24C16_nvram
(paren
id|ncr_slot
op_star
id|np
comma
r_int
id|offset
comma
id|u_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
id|u_char
id|gpcntl
comma
id|gpreg
suffix:semicolon
id|u_char
id|old_gpcntl
comma
id|old_gpreg
suffix:semicolon
id|u_char
id|ack_data
suffix:semicolon
r_int
id|retv
op_assign
l_int|1
suffix:semicolon
r_int
id|x
suffix:semicolon
multiline_comment|/* save current state of GPCNTL and GPREG */
id|old_gpreg
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
id|old_gpcntl
op_assign
id|INB
(paren
id|nc_gpcntl
)paren
suffix:semicolon
id|gpcntl
op_assign
id|old_gpcntl
op_amp
l_int|0xfc
suffix:semicolon
multiline_comment|/* set up GPREG &amp; GPCNTL to set GPIO0 and GPIO1 in to known state */
id|OUTB
(paren
id|nc_gpreg
comma
id|old_gpreg
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* this is to set NVRAM into a known state with GPIO0/1 both low */
id|gpreg
op_assign
id|old_gpreg
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
op_amp
id|gpreg
comma
id|CLR_CLK
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
op_amp
id|gpreg
comma
id|CLR_BIT
)paren
suffix:semicolon
multiline_comment|/* now set NVRAM inactive with GPIO0/1 both high */
id|S24C16_stop
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* activate NVRAM */
id|S24C16_start
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* write device code and random address MSB */
id|S24C16_write_byte
c_func
(paren
id|np
comma
op_amp
id|ack_data
comma
l_int|0xa0
op_or
(paren
(paren
id|offset
op_rshift
l_int|7
)paren
op_amp
l_int|0x0e
)paren
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack_data
op_amp
l_int|0x01
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* write random address LSB */
id|S24C16_write_byte
c_func
(paren
id|np
comma
op_amp
id|ack_data
comma
id|offset
op_amp
l_int|0xff
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack_data
op_amp
l_int|0x01
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* regenerate START state to set up for reading */
id|S24C16_start
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* rewrite device code and address MSB with read bit set (lsb = 0x01) */
id|S24C16_write_byte
c_func
(paren
id|np
comma
op_amp
id|ack_data
comma
l_int|0xa1
op_or
(paren
(paren
id|offset
op_rshift
l_int|7
)paren
op_amp
l_int|0x0e
)paren
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack_data
op_amp
l_int|0x01
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* now set up GPIO0 for inputting data */
id|gpcntl
op_or_assign
l_int|0x01
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* input all requested data - only part of total NVRAM */
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
suffix:semicolon
id|x
op_increment
)paren
id|S24C16_read_byte
c_func
(paren
id|np
comma
op_amp
id|data
(braket
id|x
)braket
comma
(paren
id|x
op_eq
(paren
id|len
op_minus
l_int|1
)paren
)paren
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* finally put NVRAM back in inactive mode */
id|gpcntl
op_and_assign
l_int|0xfe
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
id|S24C16_stop
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
id|retv
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* return GPIO0/1 to original states after having accessed NVRAM */
id|OUTB
(paren
id|nc_gpcntl
comma
id|old_gpcntl
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
id|old_gpreg
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
DECL|macro|SET_BIT
macro_line|#undef SET_BIT 
DECL|macro|CLR_BIT
macro_line|#undef CLR_BIT 
DECL|macro|SET_CLK
macro_line|#undef SET_CLK 
DECL|macro|CLR_CLK
macro_line|#undef CLR_CLK 
multiline_comment|/*&n; *  Try reading Symbios NVRAM.&n; *  Return 0 if OK.&n; */
DECL|function|sym_read_Symbios_nvram
r_static
r_int
id|__init
id|sym_read_Symbios_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|Symbios_nvram
op_star
id|nvram
)paren
(brace
r_static
id|u_char
id|Symbios_trailer
(braket
l_int|6
)braket
op_assign
(brace
l_int|0xfe
comma
l_int|0xfe
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|u_char
op_star
id|data
op_assign
(paren
id|u_char
op_star
)paren
id|nvram
suffix:semicolon
r_int
id|len
op_assign
r_sizeof
(paren
op_star
id|nvram
)paren
suffix:semicolon
id|u_short
id|csum
suffix:semicolon
r_int
id|x
suffix:semicolon
multiline_comment|/* probe the 24c16 and read the SYMBIOS 24c16 area */
r_if
c_cond
(paren
id|sym_read_S24C16_nvram
(paren
id|np
comma
id|SYMBIOS_NVRAM_ADDRESS
comma
id|data
comma
id|len
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* check valid NVRAM signature, verify byte count and checksum */
r_if
c_cond
(paren
id|nvram-&gt;type
op_ne
l_int|0
op_logical_or
id|memcmp
c_func
(paren
id|nvram-&gt;trailer
comma
id|Symbios_trailer
comma
l_int|6
)paren
op_logical_or
id|nvram-&gt;byte_count
op_ne
id|len
op_minus
l_int|12
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* verify checksum */
r_for
c_loop
(paren
id|x
op_assign
l_int|6
comma
id|csum
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
op_minus
l_int|6
suffix:semicolon
id|x
op_increment
)paren
id|csum
op_add_assign
id|data
(braket
id|x
)braket
suffix:semicolon
r_if
c_cond
(paren
id|csum
op_ne
id|nvram-&gt;checksum
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  93C46 EEPROM reading.&n; *&n; *  GPOI0 - data in&n; *  GPIO1 - data out&n; *  GPIO2 - clock&n; *  GPIO4 - chip select&n; *&n; *  Used by Tekram.&n; */
multiline_comment|/*&n; *  Pulse clock bit in GPIO0&n; */
DECL|function|T93C46_Clk
r_static
r_void
id|__init
id|T93C46_Clk
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
op_or
l_int|0x04
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|2
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; *  Read bit from NVRAM&n; */
DECL|function|T93C46_Read_Bit
r_static
r_void
id|__init
id|T93C46_Read_Bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|UDELAY
(paren
l_int|2
)paren
suffix:semicolon
id|T93C46_Clk
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
op_star
id|read_bit
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Write bit to GPIO0&n; */
DECL|function|T93C46_Write_Bit
r_static
r_void
id|__init
id|T93C46_Write_Bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
)paren
(brace
r_if
c_cond
(paren
id|write_bit
op_amp
l_int|0x01
)paren
op_star
id|gpreg
op_or_assign
l_int|0x02
suffix:semicolon
r_else
op_star
id|gpreg
op_and_assign
l_int|0xfd
suffix:semicolon
op_star
id|gpreg
op_or_assign
l_int|0x10
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|2
)paren
suffix:semicolon
id|T93C46_Clk
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Send STOP condition to NVRAM - puts NVRAM to sleep... ZZZzzz!!&n; */
DECL|function|T93C46_Stop
r_static
r_void
id|__init
id|T93C46_Stop
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
(brace
op_star
id|gpreg
op_and_assign
l_int|0xef
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|2
)paren
suffix:semicolon
id|T93C46_Clk
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Send read command and address to NVRAM&n; */
r_static
r_void
id|__init
DECL|function|T93C46_Send_Command
id|T93C46_Send_Command
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
id|write_data
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
)paren
(brace
r_int
id|x
suffix:semicolon
multiline_comment|/* send 9 bits, start bit (1), command (2), address (6)  */
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|9
suffix:semicolon
id|x
op_increment
)paren
id|T93C46_Write_Bit
c_func
(paren
id|np
comma
(paren
id|u_char
)paren
(paren
id|write_data
op_rshift
(paren
l_int|8
op_minus
id|x
)paren
)paren
comma
id|gpreg
)paren
suffix:semicolon
op_star
id|read_bit
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  READ 2 bytes from the NVRAM&n; */
r_static
r_void
id|__init
DECL|function|T93C46_Read_Word
id|T93C46_Read_Word
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
op_star
id|nvram_data
comma
id|u_char
op_star
id|gpreg
)paren
(brace
r_int
id|x
suffix:semicolon
id|u_char
id|read_bit
suffix:semicolon
op_star
id|nvram_data
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|16
suffix:semicolon
id|x
op_increment
)paren
(brace
id|T93C46_Read_Bit
c_func
(paren
id|np
comma
op_amp
id|read_bit
comma
id|gpreg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_bit
op_amp
l_int|0x01
)paren
op_star
id|nvram_data
op_or_assign
(paren
l_int|0x01
op_lshift
(paren
l_int|15
op_minus
id|x
)paren
)paren
suffix:semicolon
r_else
op_star
id|nvram_data
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
(paren
l_int|15
op_minus
id|x
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  Read Tekram NvRAM data.&n; */
r_static
r_int
id|__init
DECL|function|T93C46_Read_Data
id|T93C46_Read_Data
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
op_star
id|data
comma
r_int
id|len
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|u_char
id|read_bit
suffix:semicolon
r_int
id|x
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
suffix:semicolon
id|x
op_increment
)paren
(brace
multiline_comment|/* output read command and address */
id|T93C46_Send_Command
c_func
(paren
id|np
comma
l_int|0x180
op_or
id|x
comma
op_amp
id|read_bit
comma
id|gpreg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_bit
op_amp
l_int|0x01
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Bad */
id|T93C46_Read_Word
c_func
(paren
id|np
comma
op_amp
id|data
(braket
id|x
)braket
comma
id|gpreg
)paren
suffix:semicolon
id|T93C46_Stop
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Try reading 93C46 Tekram NVRAM.&n; */
r_static
r_int
id|__init
DECL|function|sym_read_T93C46_nvram
id|sym_read_T93C46_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|Tekram_nvram
op_star
id|nvram
)paren
(brace
id|u_char
id|gpcntl
comma
id|gpreg
suffix:semicolon
id|u_char
id|old_gpcntl
comma
id|old_gpreg
suffix:semicolon
r_int
id|retv
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* save current state of GPCNTL and GPREG */
id|old_gpreg
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
id|old_gpcntl
op_assign
id|INB
(paren
id|nc_gpcntl
)paren
suffix:semicolon
multiline_comment|/* set up GPREG &amp; GPCNTL to set GPIO0/1/2/4 in to known state, 0 in,&n;&t;   1/2/4 out */
id|gpreg
op_assign
id|old_gpreg
op_amp
l_int|0xe9
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
id|gpreg
)paren
suffix:semicolon
id|gpcntl
op_assign
(paren
id|old_gpcntl
op_amp
l_int|0xe9
)paren
op_or
l_int|0x09
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* input all of NVRAM, 64 words */
id|retv
op_assign
id|T93C46_Read_Data
c_func
(paren
id|np
comma
(paren
id|u_short
op_star
)paren
id|nvram
comma
r_sizeof
(paren
op_star
id|nvram
)paren
op_div
r_sizeof
(paren
r_int
)paren
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* return GPIO0/1/2/4 to original states after having accessed NVRAM */
id|OUTB
(paren
id|nc_gpcntl
comma
id|old_gpcntl
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
id|old_gpreg
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*&n; *  Try reading Tekram NVRAM.&n; *  Return 0 if OK.&n; */
r_static
r_int
id|__init
DECL|function|sym_read_Tekram_nvram
id|sym_read_Tekram_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
id|device_id
comma
id|Tekram_nvram
op_star
id|nvram
)paren
(brace
id|u_char
op_star
id|data
op_assign
(paren
id|u_char
op_star
)paren
id|nvram
suffix:semicolon
r_int
id|len
op_assign
r_sizeof
(paren
op_star
id|nvram
)paren
suffix:semicolon
id|u_short
id|csum
suffix:semicolon
r_int
id|x
suffix:semicolon
r_switch
c_cond
(paren
id|device_id
)paren
(brace
r_case
id|PCI_DEVICE_ID_NCR_53C885
suffix:colon
r_case
id|PCI_DEVICE_ID_NCR_53C895
suffix:colon
r_case
id|PCI_DEVICE_ID_NCR_53C896
suffix:colon
id|x
op_assign
id|sym_read_S24C16_nvram
c_func
(paren
id|np
comma
id|TEKRAM_24C16_NVRAM_ADDRESS
comma
id|data
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCI_DEVICE_ID_NCR_53C875
suffix:colon
id|x
op_assign
id|sym_read_S24C16_nvram
c_func
(paren
id|np
comma
id|TEKRAM_24C16_NVRAM_ADDRESS
comma
id|data
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|x
)paren
r_break
suffix:semicolon
r_default
suffix:colon
id|x
op_assign
id|sym_read_T93C46_nvram
c_func
(paren
id|np
comma
id|nvram
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* verify checksum */
r_for
c_loop
(paren
id|x
op_assign
l_int|0
comma
id|csum
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
op_minus
l_int|1
suffix:semicolon
id|x
op_add_assign
l_int|2
)paren
id|csum
op_add_assign
id|data
(braket
id|x
)braket
op_plus
(paren
id|data
(braket
id|x
op_plus
l_int|1
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csum
op_ne
l_int|0x1234
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_NCR_NVRAM_SUPPORT */
multiline_comment|/*===================================================================&n;**&n;**    Detect and try to read SYMBIOS and TEKRAM NVRAM.&n;**&n;**    Data can be used to order booting of boards.&n;**&n;**    Data is saved in ncr_device structure if NVRAM found. This&n;**    is then used to find drive boot order for ncr_attach().&n;**&n;**    NVRAM data is passed to Scsi_Host_Template later during &n;**    ncr_attach() for any device set up.&n;**&n;**===================================================================&n;*/
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
DECL|function|ncr_get_nvram
r_static
r_void
id|__init
id|ncr_get_nvram
c_func
(paren
id|ncr_device
op_star
id|devp
comma
id|ncr_nvram
op_star
id|nvp
)paren
(brace
id|devp-&gt;nvram
op_assign
id|nvp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nvp
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**    Get access to chip IO registers&n;&t;*/
macro_line|#ifdef NCR_IOMAPPED
id|request_region
c_func
(paren
id|devp-&gt;slot.io_port
comma
l_int|128
comma
id|NAME53C8XX
)paren
suffix:semicolon
id|devp-&gt;slot.base_io
op_assign
id|devp-&gt;slot.io_port
suffix:semicolon
macro_line|#else
id|devp-&gt;slot.reg
op_assign
(paren
r_struct
id|ncr_reg
op_star
)paren
id|remap_pci_mem
c_func
(paren
id|devp-&gt;slot.base
comma
l_int|128
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devp-&gt;slot.reg
)paren
r_return
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**    Try to read SYMBIOS nvram.&n;&t;**    Try to read TEKRAM nvram if Symbios nvram not found.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|sym_read_Symbios_nvram
c_func
(paren
op_amp
id|devp-&gt;slot
comma
op_amp
id|nvp-&gt;data.Symbios
)paren
)paren
id|nvp-&gt;type
op_assign
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|sym_read_Tekram_nvram
c_func
(paren
op_amp
id|devp-&gt;slot
comma
id|devp-&gt;chip.device_id
comma
op_amp
id|nvp-&gt;data.Tekram
)paren
)paren
id|nvp-&gt;type
op_assign
id|SCSI_NCR_TEKRAM_NVRAM
suffix:semicolon
r_else
(brace
id|nvp-&gt;type
op_assign
l_int|0
suffix:semicolon
id|devp-&gt;nvram
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Release access to chip IO registers&n;&t;*/
macro_line|#ifdef NCR_IOMAPPED
id|release_region
c_func
(paren
id|devp-&gt;slot.base_io
comma
l_int|128
)paren
suffix:semicolon
macro_line|#else
id|unmap_pci_mem
c_func
(paren
(paren
id|u_long
)paren
id|devp-&gt;slot.reg
comma
l_int|128ul
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*===================================================================&n;**&n;**&t;Display the content of NVRAM for debugging purpose.&n;**&n;**===================================================================&n;*/
macro_line|#ifdef&t;SCSI_NCR_DEBUG_NVRAM
DECL|function|ncr_display_Symbios_nvram
r_static
r_void
id|__init
id|ncr_display_Symbios_nvram
c_func
(paren
id|Symbios_nvram
op_star
id|nvram
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* display Symbios nvram host data */
id|printk
c_func
(paren
id|KERN_DEBUG
id|NAME53C8XX
l_string|&quot;: HOST ID=%d%s%s%s%s%s&bslash;n&quot;
comma
id|nvram-&gt;host_id
op_amp
l_int|0x0f
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_SCAM_ENABLE
)paren
ques
c_cond
l_string|&quot; SCAM&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_PARITY_ENABLE
)paren
ques
c_cond
l_string|&quot; PARITY&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_VERBOSE_MSGS
)paren
ques
c_cond
l_string|&quot; VERBOSE&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_CHS_MAPPING
)paren
ques
c_cond
l_string|&quot; CHS_ALT&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags1
op_amp
id|SYMBIOS_SCAN_HI_LO
)paren
ques
c_cond
l_string|&quot; HI_LO&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
multiline_comment|/* display Symbios nvram drive data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|Symbios_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
id|NAME53C8XX
l_string|&quot;-%d:%s%s%s%s WIDTH=%d SYNC=%d TMO=%d&bslash;n&quot;
comma
id|i
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_DISCONNECT_ENABLE
)paren
ques
c_cond
l_string|&quot; DISC&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_SCAN_AT_BOOT_TIME
)paren
ques
c_cond
l_string|&quot; SCAN_BOOT&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_SCAN_LUNS
)paren
ques
c_cond
l_string|&quot; SCAN_LUNS&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_QUEUE_TAGS_ENABLED
)paren
ques
c_cond
l_string|&quot; TCQ&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|tn-&gt;bus_width
comma
id|tn-&gt;sync_period
op_div
l_int|4
comma
id|tn-&gt;timeout
)paren
suffix:semicolon
)brace
)brace
DECL|variable|__initdata
r_static
id|u_char
id|Tekram_boot_delay
(braket
l_int|7
)braket
id|__initdata
op_assign
(brace
l_int|3
comma
l_int|5
comma
l_int|10
comma
l_int|20
comma
l_int|30
comma
l_int|60
comma
l_int|120
)brace
suffix:semicolon
DECL|function|ncr_display_Tekram_nvram
r_static
r_void
id|__init
id|ncr_display_Tekram_nvram
c_func
(paren
id|Tekram_nvram
op_star
id|nvram
)paren
(brace
r_int
id|i
comma
id|tags
comma
id|boot_delay
suffix:semicolon
r_char
op_star
id|rem
suffix:semicolon
multiline_comment|/* display Tekram nvram host data */
id|tags
op_assign
l_int|2
op_lshift
id|nvram-&gt;max_tags_index
suffix:semicolon
id|boot_delay
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nvram-&gt;boot_delay_index
OL
l_int|6
)paren
id|boot_delay
op_assign
id|Tekram_boot_delay
(braket
id|nvram-&gt;boot_delay_index
)braket
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_REMOVABLE_FLAGS
)paren
op_rshift
l_int|6
)paren
(brace
r_default
suffix:colon
r_case
l_int|0
suffix:colon
id|rem
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|rem
op_assign
l_string|&quot; REMOVABLE=boot device&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|rem
op_assign
l_string|&quot; REMOVABLE=all&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
id|NAME53C8XX
l_string|&quot;: HOST ID=%d%s%s%s%s%s%s%s%s%s BOOT DELAY=%d tags=%d&bslash;n&quot;
comma
id|nvram-&gt;host_id
op_amp
l_int|0x0f
comma
(paren
id|nvram-&gt;flags1
op_amp
id|SYMBIOS_SCAM_ENABLE
)paren
ques
c_cond
l_string|&quot; SCAM&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_MORE_THAN_2_DRIVES
)paren
ques
c_cond
l_string|&quot; &gt;2DRIVES&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_DRIVES_SUP_1GB
)paren
ques
c_cond
l_string|&quot; &gt;1GB&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_RESET_ON_POWER_ON
)paren
ques
c_cond
l_string|&quot; RESET&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_ACTIVE_NEGATION
)paren
ques
c_cond
l_string|&quot; ACT_NEG&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_IMMEDIATE_SEEK
)paren
ques
c_cond
l_string|&quot; IMM_SEEK&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_SCAN_LUNS
)paren
ques
c_cond
l_string|&quot; SCAN_LUNS&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags1
op_amp
id|TEKRAM_F2_F6_ENABLED
)paren
ques
c_cond
l_string|&quot; F2_F6&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|rem
comma
id|boot_delay
comma
id|tags
)paren
suffix:semicolon
multiline_comment|/* display Tekram nvram drive data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|sync
comma
id|j
suffix:semicolon
r_struct
id|Tekram_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|j
op_assign
id|tn-&gt;sync_index
op_amp
l_int|0xf
suffix:semicolon
id|sync
op_assign
id|Tekram_sync
(braket
id|j
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
id|NAME53C8XX
l_string|&quot;-%d:%s%s%s%s%s%s PERIOD=%d&bslash;n&quot;
comma
id|i
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_PARITY_CHECK
)paren
ques
c_cond
l_string|&quot; PARITY&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_SYNC_NEGO
)paren
ques
c_cond
l_string|&quot; SYNC&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_DISCONNECT_ENABLE
)paren
ques
c_cond
l_string|&quot; DISC&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_START_CMD
)paren
ques
c_cond
l_string|&quot; START&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_TAGGED_COMMANDS
)paren
ques
c_cond
l_string|&quot; TCQ&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_WIDE_NEGO
)paren
ques
c_cond
l_string|&quot; WIDE&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|sync
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* SCSI_NCR_DEBUG_NVRAM */
macro_line|#endif&t;/* SCSI_NCR_NVRAM_SUPPORT */
multiline_comment|/*===================================================================&n;**&n;**&t;Utility routines that protperly return data through /proc FS.&n;**&n;**===================================================================&n;*/
macro_line|#ifdef SCSI_NCR_USER_INFO_SUPPORT
DECL|struct|info_str
r_struct
id|info_str
(brace
DECL|member|buffer
r_char
op_star
id|buffer
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|pos
r_int
id|pos
suffix:semicolon
)brace
suffix:semicolon
DECL|function|copy_mem_info
r_static
r_void
id|copy_mem_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OG
id|info-&gt;length
)paren
id|len
op_assign
id|info-&gt;length
op_minus
id|info-&gt;pos
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OL
id|info-&gt;offset
)paren
(brace
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;pos
OL
id|info-&gt;offset
)paren
(brace
id|data
op_add_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|info-&gt;buffer
op_plus
id|info-&gt;pos
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
)brace
)brace
DECL|function|copy_info
r_static
r_int
id|copy_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
l_int|81
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|len
op_assign
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
id|copy_mem_info
c_func
(paren
id|info
comma
id|buf
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*===================================================================&n;**&n;**&t;Driver setup from the boot command line&n;**&n;**===================================================================&n;*/
macro_line|#ifdef MODULE
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot; &squot;
macro_line|#else
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot;,&squot;
macro_line|#endif
DECL|macro|OPT_TAGS
mdefine_line|#define OPT_TAGS&t;&t;1
DECL|macro|OPT_MASTER_PARITY
mdefine_line|#define OPT_MASTER_PARITY&t;2
DECL|macro|OPT_SCSI_PARITY
mdefine_line|#define OPT_SCSI_PARITY&t;&t;3
DECL|macro|OPT_DISCONNECTION
mdefine_line|#define OPT_DISCONNECTION&t;4
DECL|macro|OPT_SPECIAL_FEATURES
mdefine_line|#define OPT_SPECIAL_FEATURES&t;5
DECL|macro|OPT_ULTRA_SCSI
mdefine_line|#define OPT_ULTRA_SCSI&t;&t;6
DECL|macro|OPT_FORCE_SYNC_NEGO
mdefine_line|#define OPT_FORCE_SYNC_NEGO&t;7
DECL|macro|OPT_REVERSE_PROBE
mdefine_line|#define OPT_REVERSE_PROBE&t;8
DECL|macro|OPT_DEFAULT_SYNC
mdefine_line|#define OPT_DEFAULT_SYNC&t;9
DECL|macro|OPT_VERBOSE
mdefine_line|#define OPT_VERBOSE&t;&t;10
DECL|macro|OPT_DEBUG
mdefine_line|#define OPT_DEBUG&t;&t;11
DECL|macro|OPT_BURST_MAX
mdefine_line|#define OPT_BURST_MAX&t;&t;12
DECL|macro|OPT_LED_PIN
mdefine_line|#define OPT_LED_PIN&t;&t;13
DECL|macro|OPT_MAX_WIDE
mdefine_line|#define OPT_MAX_WIDE&t;&t;14
DECL|macro|OPT_SETTLE_DELAY
mdefine_line|#define OPT_SETTLE_DELAY&t;15
DECL|macro|OPT_DIFF_SUPPORT
mdefine_line|#define OPT_DIFF_SUPPORT&t;16
DECL|macro|OPT_IRQM
mdefine_line|#define OPT_IRQM&t;&t;17
DECL|macro|OPT_PCI_FIX_UP
mdefine_line|#define OPT_PCI_FIX_UP&t;&t;18
DECL|macro|OPT_BUS_CHECK
mdefine_line|#define OPT_BUS_CHECK&t;&t;19
DECL|macro|OPT_OPTIMIZE
mdefine_line|#define OPT_OPTIMIZE&t;&t;20
DECL|macro|OPT_RECOVERY
mdefine_line|#define OPT_RECOVERY&t;&t;21
DECL|macro|OPT_SAFE_SETUP
mdefine_line|#define OPT_SAFE_SETUP&t;&t;22
DECL|macro|OPT_USE_NVRAM
mdefine_line|#define OPT_USE_NVRAM&t;&t;23
DECL|macro|OPT_EXCLUDE
mdefine_line|#define OPT_EXCLUDE&t;&t;24
DECL|macro|OPT_HOST_ID
mdefine_line|#define OPT_HOST_ID&t;&t;25
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
DECL|macro|OPT_IARB
mdefine_line|#define OPT_IARB&t;&t;26
macro_line|#endif
DECL|variable|__initdata
r_static
r_char
id|setup_token
(braket
)braket
id|__initdata
op_assign
l_string|&quot;tags:&quot;
l_string|&quot;mpar:&quot;
l_string|&quot;spar:&quot;
l_string|&quot;disc:&quot;
l_string|&quot;specf:&quot;
l_string|&quot;ultra:&quot;
l_string|&quot;fsn:&quot;
l_string|&quot;revprob:&quot;
l_string|&quot;sync:&quot;
l_string|&quot;verb:&quot;
l_string|&quot;debug:&quot;
l_string|&quot;burst:&quot;
l_string|&quot;led:&quot;
l_string|&quot;wide:&quot;
l_string|&quot;settle:&quot;
l_string|&quot;diff:&quot;
l_string|&quot;irqm:&quot;
l_string|&quot;pcifix:&quot;
l_string|&quot;buschk:&quot;
l_string|&quot;optim:&quot;
l_string|&quot;recovery:&quot;
l_string|&quot;safe:&quot;
l_string|&quot;nvram:&quot;
l_string|&quot;excl:&quot;
l_string|&quot;hostid:&quot;
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
l_string|&quot;iarb:&quot;
macro_line|#endif
suffix:semicolon
multiline_comment|/* DONNOT REMOVE THIS &squot;;&squot; */
macro_line|#ifdef MODULE
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot; &squot;
macro_line|#else
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot;,&squot;
macro_line|#endif
DECL|function|get_setup_token
r_static
r_int
id|__init
id|get_setup_token
c_func
(paren
r_char
op_star
id|p
)paren
(brace
r_char
op_star
id|cur
op_assign
id|setup_token
suffix:semicolon
r_char
op_star
id|pc
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_ne
l_int|NULL
op_logical_and
(paren
id|pc
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;:&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
op_increment
id|pc
suffix:semicolon
op_increment
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|p
comma
id|cur
comma
id|pc
op_minus
id|cur
)paren
)paren
r_return
id|i
suffix:semicolon
id|cur
op_assign
id|pc
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sym53c8xx__setup
r_static
r_int
id|__init
id|sym53c8xx__setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
macro_line|#ifdef SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT
r_char
op_star
id|cur
op_assign
id|str
suffix:semicolon
r_char
op_star
id|pc
comma
op_star
id|pv
suffix:semicolon
r_int
id|i
comma
id|val
comma
id|c
suffix:semicolon
r_int
id|xi
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_ne
l_int|NULL
op_logical_and
(paren
id|pc
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;:&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_char
op_star
id|pe
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
id|pv
op_assign
id|pc
suffix:semicolon
id|c
op_assign
op_star
op_increment
id|pv
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;n&squot;
)paren
id|val
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;y&squot;
)paren
id|val
op_assign
l_int|1
suffix:semicolon
r_else
id|val
op_assign
(paren
r_int
)paren
id|simple_strtoul
c_func
(paren
id|pv
comma
op_amp
id|pe
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|get_setup_token
c_func
(paren
id|cur
)paren
)paren
(brace
r_case
id|OPT_TAGS
suffix:colon
id|driver_setup.default_tags
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|pe
op_logical_and
op_star
id|pe
op_eq
l_char|&squot;/&squot;
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pe
op_logical_and
op_star
id|pe
op_ne
id|ARG_SEP
op_logical_and
id|i
OL
r_sizeof
(paren
id|driver_setup.tag_ctrl
)paren
op_minus
l_int|1
)paren
(brace
id|driver_setup.tag_ctrl
(braket
id|i
op_increment
)braket
op_assign
op_star
id|pe
op_increment
suffix:semicolon
)brace
id|driver_setup.tag_ctrl
(braket
id|i
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OPT_MASTER_PARITY
suffix:colon
id|driver_setup.master_parity
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SCSI_PARITY
suffix:colon
id|driver_setup.scsi_parity
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_DISCONNECTION
suffix:colon
id|driver_setup.disconnection
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SPECIAL_FEATURES
suffix:colon
id|driver_setup.special_features
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_ULTRA_SCSI
suffix:colon
id|driver_setup.ultra_scsi
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_FORCE_SYNC_NEGO
suffix:colon
id|driver_setup.force_sync_nego
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_REVERSE_PROBE
suffix:colon
id|driver_setup.reverse_probe
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_DEFAULT_SYNC
suffix:colon
id|driver_setup.default_sync
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_VERBOSE
suffix:colon
id|driver_setup.verbose
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_DEBUG
suffix:colon
id|driver_setup.debug
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_BURST_MAX
suffix:colon
id|driver_setup.burst_max
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_LED_PIN
suffix:colon
id|driver_setup.led_pin
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_MAX_WIDE
suffix:colon
id|driver_setup.max_wide
op_assign
id|val
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SETTLE_DELAY
suffix:colon
id|driver_setup.settle_delay
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_DIFF_SUPPORT
suffix:colon
id|driver_setup.diff_support
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_IRQM
suffix:colon
id|driver_setup.irqm
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_PCI_FIX_UP
suffix:colon
id|driver_setup.pci_fix_up
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_BUS_CHECK
suffix:colon
id|driver_setup.bus_check
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_OPTIMIZE
suffix:colon
id|driver_setup.optimize
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_RECOVERY
suffix:colon
id|driver_setup.recovery
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_USE_NVRAM
suffix:colon
id|driver_setup.use_nvram
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SAFE_SETUP
suffix:colon
id|memcpy
c_func
(paren
op_amp
id|driver_setup
comma
op_amp
id|driver_safe_setup
comma
r_sizeof
(paren
id|driver_setup
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_EXCLUDE
suffix:colon
r_if
c_cond
(paren
id|xi
OL
id|SCSI_NCR_MAX_EXCLUDES
)paren
id|driver_setup.excludes
(braket
id|xi
op_increment
)braket
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_HOST_ID
suffix:colon
id|driver_setup.host_id
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
r_case
id|OPT_IARB
suffix:colon
id|driver_setup.iarb
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_setup: unexpected boot option &squot;%.*s&squot; ignored&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|pc
op_minus
id|cur
op_plus
l_int|1
)paren
comma
id|cur
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cur
op_assign
id|strchr
c_func
(paren
id|cur
comma
id|ARG_SEP
)paren
)paren
op_ne
l_int|NULL
)paren
op_increment
id|cur
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*===================================================================&n;**&n;**&t;Get device queue depth from boot command line.&n;**&n;**===================================================================&n;*/
DECL|macro|DEF_DEPTH
mdefine_line|#define DEF_DEPTH&t;(driver_setup.default_tags)
DECL|macro|ALL_TARGETS
mdefine_line|#define ALL_TARGETS&t;-2
DECL|macro|NO_TARGET
mdefine_line|#define NO_TARGET&t;-1
DECL|macro|ALL_LUNS
mdefine_line|#define ALL_LUNS&t;-2
DECL|macro|NO_LUN
mdefine_line|#define NO_LUN&t;&t;-1
DECL|function|device_queue_depth
r_static
r_int
id|device_queue_depth
c_func
(paren
r_int
id|unit
comma
r_int
id|target
comma
r_int
id|lun
)paren
(brace
r_int
id|c
comma
id|h
comma
id|t
comma
id|u
comma
id|v
suffix:semicolon
r_char
op_star
id|p
op_assign
id|driver_setup.tag_ctrl
suffix:semicolon
r_char
op_star
id|ep
suffix:semicolon
id|h
op_assign
op_minus
l_int|1
suffix:semicolon
id|t
op_assign
id|NO_TARGET
suffix:semicolon
id|u
op_assign
id|NO_LUN
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|p
op_increment
)paren
op_ne
l_int|0
)paren
(brace
id|v
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|ep
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;/&squot;
suffix:colon
op_increment
id|h
suffix:semicolon
id|t
op_assign
id|ALL_TARGETS
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
r_if
c_cond
(paren
id|t
op_ne
id|target
)paren
id|t
op_assign
(paren
id|target
op_eq
id|v
)paren
ques
c_cond
id|v
suffix:colon
id|NO_TARGET
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;u&squot;
suffix:colon
r_if
c_cond
(paren
id|u
op_ne
id|lun
)paren
id|u
op_assign
(paren
id|lun
op_eq
id|v
)paren
ques
c_cond
id|v
suffix:colon
id|NO_LUN
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;q&squot;
suffix:colon
r_if
c_cond
(paren
id|h
op_eq
id|unit
op_logical_and
(paren
id|t
op_eq
id|ALL_TARGETS
op_logical_or
id|t
op_eq
id|target
)paren
op_logical_and
(paren
id|u
op_eq
id|ALL_LUNS
op_logical_or
id|u
op_eq
id|lun
)paren
)paren
r_return
id|v
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;-&squot;
suffix:colon
id|t
op_assign
id|ALL_TARGETS
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|p
op_assign
id|ep
suffix:semicolon
)brace
r_return
id|DEF_DEPTH
suffix:semicolon
)brace
multiline_comment|/*===================================================================&n;**&n;**&t;Print out information about driver configuration.&n;**&n;**===================================================================&n;*/
DECL|function|ncr_print_driver_setup
r_static
r_void
id|__init
id|ncr_print_driver_setup
c_func
(paren
r_void
)paren
(brace
DECL|macro|YesNo
mdefine_line|#define YesNo(y)&t;y ? &squot;y&squot; : &squot;n&squot;
id|printk
(paren
id|NAME53C8XX
l_string|&quot;: setup=disc:%c,specf:%d,ultra:%d,tags:%d,sync:%d,&quot;
l_string|&quot;burst:%d,wide:%c,diff:%d,revprob:%c,buschk:0x%x&bslash;n&quot;
comma
id|YesNo
c_func
(paren
id|driver_setup.disconnection
)paren
comma
id|driver_setup.special_features
comma
id|driver_setup.ultra_scsi
comma
id|driver_setup.default_tags
comma
id|driver_setup.default_sync
comma
id|driver_setup.burst_max
comma
id|YesNo
c_func
(paren
id|driver_setup.max_wide
)paren
comma
id|driver_setup.diff_support
comma
id|YesNo
c_func
(paren
id|driver_setup.reverse_probe
)paren
comma
id|driver_setup.bus_check
)paren
suffix:semicolon
id|printk
(paren
id|NAME53C8XX
l_string|&quot;: setup=mpar:%c,spar:%c,fsn=%c,verb:%d,debug:0x%x,&quot;
l_string|&quot;led:%c,settle:%d,irqm:0x%x,nvram:0x%x,pcifix:0x%x&bslash;n&quot;
comma
id|YesNo
c_func
(paren
id|driver_setup.master_parity
)paren
comma
id|YesNo
c_func
(paren
id|driver_setup.scsi_parity
)paren
comma
id|YesNo
c_func
(paren
id|driver_setup.force_sync_nego
)paren
comma
id|driver_setup.verbose
comma
id|driver_setup.debug
comma
id|YesNo
c_func
(paren
id|driver_setup.led_pin
)paren
comma
id|driver_setup.settle_delay
comma
id|driver_setup.irqm
comma
id|driver_setup.use_nvram
comma
id|driver_setup.pci_fix_up
)paren
suffix:semicolon
DECL|macro|YesNo
macro_line|#undef YesNo
)brace
multiline_comment|/*===================================================================&n;**&n;**   SYM53C8XX devices description table.&n;**&n;**===================================================================&n;*/
DECL|variable|__initdata
r_static
id|ncr_chip
id|ncr_chip_table
(braket
)braket
id|__initdata
op_assign
id|SCSI_NCR_CHIP_TABLE
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_PQS_PDS_SUPPORT
multiline_comment|/*===================================================================&n;**&n;**    Detect all NCR PQS/PDS boards and keep track of their bus nr.&n;**&n;**    The NCR PQS or PDS card is constructed as a DEC bridge&n;**    behind which sit a proprietary NCR memory controller and&n;**    four or two 53c875s as separate devices.  In its usual mode&n;**    of operation, the 875s are slaved to the memory controller&n;**    for all transfers.  We can tell if an 875 is part of a&n;**    PQS/PDS or not since if it is, it will be on the same bus&n;**    as the memory controller.  To operate with the Linux&n;**    driver, the memory controller is disabled and the 875s&n;**    freed to function independently.  The only wrinkle is that&n;**    the preset SCSI ID (which may be zero) must be read in from&n;**    a special configuration space register of the 875.&n;**&n;**===================================================================&n;*/
DECL|macro|SCSI_NCR_MAX_PQS_BUS
mdefine_line|#define&t;SCSI_NCR_MAX_PQS_BUS&t;16
DECL|variable|__initdata
r_static
r_int
id|pqs_bus
(braket
id|SCSI_NCR_MAX_PQS_BUS
)braket
id|__initdata
op_assign
(brace
l_int|0
)brace
suffix:semicolon
DECL|function|ncr_detect_pqs_pds
r_static
r_void
id|__init
id|ncr_detect_pqs_pds
c_func
(paren
r_void
)paren
(brace
r_int
id|index
suffix:semicolon
id|pcidev_t
id|dev
op_assign
id|PCIDEV_NULL
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|SCSI_NCR_MAX_PQS_BUS
suffix:semicolon
id|index
op_increment
)paren
(brace
id|u_char
id|tmp
suffix:semicolon
id|dev
op_assign
id|pci_find_device
c_func
(paren
l_int|0x101a
comma
l_int|0x0009
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
id|PCIDEV_NULL
)paren
(brace
id|pqs_bus
(braket
id|index
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
id|NAME53C8XX
l_string|&quot;: NCR PQS/PDS memory controller detected on bus %d&bslash;n&quot;
comma
id|PciBusNumber
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
l_int|0x44
comma
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* bit 1: allow individual 875 configuration */
id|tmp
op_or_assign
l_int|0x2
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|dev
comma
l_int|0x44
comma
id|tmp
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
l_int|0x45
comma
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* bit 2: drive individual 875 interrupts to the bus */
id|tmp
op_or_assign
l_int|0x4
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|dev
comma
l_int|0x45
comma
id|tmp
)paren
suffix:semicolon
id|pqs_bus
(braket
id|index
)braket
op_assign
id|PciBusNumber
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* SCSI_NCR_PQS_PDS_SUPPORT */
multiline_comment|/*===================================================================&n;**&n;**   Read and check the PCI configuration for any detected NCR &n;**   boards and save data for attaching after all boards have &n;**   been detected.&n;**&n;**===================================================================&n;*/
r_static
r_int
id|__init
DECL|function|sym53c8xx_pci_init
id|sym53c8xx_pci_init
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
id|pcidev_t
id|pdev
comma
id|ncr_device
op_star
id|device
)paren
(brace
id|u_short
id|vendor_id
comma
id|device_id
comma
id|command
suffix:semicolon
id|u_char
id|cache_line_size
comma
id|latency_timer
suffix:semicolon
id|u_char
id|suggested_cache_line_size
op_assign
l_int|0
suffix:semicolon
id|u_char
id|pci_fix_up
op_assign
id|driver_setup.pci_fix_up
suffix:semicolon
id|u_char
id|revision
suffix:semicolon
id|u_int
id|irq
suffix:semicolon
id|u_long
id|base
comma
id|base_2
comma
id|io_port
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ncr_chip
op_star
id|chip
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|NAME53C8XX
l_string|&quot;: at PCI bus %d, device %d, function %d&bslash;n&quot;
comma
id|PciBusNumber
c_func
(paren
id|pdev
)paren
comma
(paren
r_int
)paren
(paren
id|PciDeviceFn
c_func
(paren
id|pdev
)paren
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
comma
(paren
r_int
)paren
(paren
id|PciDeviceFn
c_func
(paren
id|pdev
)paren
op_amp
l_int|7
)paren
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_DYNAMIC_DMA_MAPPING
r_if
c_cond
(paren
op_logical_neg
id|pci_dma_supported
c_func
(paren
id|pdev
comma
(paren
id|dma_addr_t
)paren
(paren
l_int|0xffffffffUL
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|NAME53C8XX
l_string|&quot;32 BIT PCI BUS DMA ADDRESSING NOT SUPPORTED&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**    Read info from the PCI config space.&n;&t;**    pci_read_config_xxx() functions are assumed to be used for &n;&t;**    successfully detected PCI devices.&n;&t;*/
id|vendor_id
op_assign
id|PciVendorId
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|device_id
op_assign
id|PciDeviceId
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|irq
op_assign
id|PciIrqLine
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|pci_get_base_address
c_func
(paren
id|pdev
comma
id|i
comma
op_amp
id|io_port
)paren
suffix:semicolon
id|i
op_assign
id|pci_get_base_address
c_func
(paren
id|pdev
comma
id|i
comma
op_amp
id|base
)paren
suffix:semicolon
(paren
r_void
)paren
id|pci_get_base_address
c_func
(paren
id|pdev
comma
id|i
comma
op_amp
id|base_2
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
op_amp
id|command
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|revision
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CACHE_LINE_SIZE
comma
op_amp
id|cache_line_size
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|latency_timer
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PQS_PDS_SUPPORT
multiline_comment|/*&n;&t;**    Match the BUS number for PQS/PDS devices.&n;&t;**    Read the SCSI ID from a special register mapped&n;&t;**    into the configuration space of the individual&n;&t;**    875s.  This register is set up by the PQS bios&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCSI_NCR_MAX_PQS_BUS
op_logical_and
id|pqs_bus
(braket
id|i
)braket
op_ne
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u_char
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|pqs_bus
(braket
id|i
)braket
op_eq
id|PciBusNumber
c_func
(paren
id|pdev
)paren
)paren
(brace
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
l_int|0x84
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|device-&gt;pqs_pds
op_assign
l_int|1
suffix:semicolon
id|device-&gt;host_id
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif /* SCSI_NCR_PQS_PDS_SUPPORT */
multiline_comment|/*&n;&t;**&t;If user excludes this chip, donnot initialize it.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCSI_NCR_MAX_EXCLUDES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|driver_setup.excludes
(braket
id|i
)braket
op_eq
(paren
id|io_port
op_amp
id|PCI_BASE_ADDRESS_IO_MASK
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    Check if the chip is supported&n;&t;*/
r_if
c_cond
(paren
(paren
id|device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_or
(paren
id|device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: not initializing, device not supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|chip
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|ncr_chip_table
)paren
op_div
r_sizeof
(paren
id|ncr_chip_table
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|device_id
op_ne
id|ncr_chip_table
(braket
id|i
)braket
dot
id|device_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|revision
OG
id|ncr_chip_table
(braket
id|i
)braket
dot
id|revision_id
)paren
r_continue
suffix:semicolon
id|chip
op_assign
op_amp
id|device-&gt;chip
suffix:semicolon
id|memcpy
c_func
(paren
id|chip
comma
op_amp
id|ncr_chip_table
(braket
id|i
)braket
comma
r_sizeof
(paren
op_star
id|chip
)paren
)paren
suffix:semicolon
id|chip-&gt;revision_id
op_assign
id|revision
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Ignore Symbios chips controlled by SISL RAID controller.&n;&t;**&t;This controller sets value 0x52414944 at RAM end - 16.&n;&t;*/
macro_line|#if defined(__i386__) &amp;&amp; !defined(SCSI_NCR_PCI_MEM_NOT_SUPPORTED)
r_if
c_cond
(paren
id|chip
op_logical_and
(paren
id|base_2
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
)paren
(brace
r_int
r_int
id|ram_size
comma
id|ram_val
suffix:semicolon
id|u_long
id|ram_ptr
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;features
op_amp
id|FE_RAM8K
)paren
id|ram_size
op_assign
l_int|8192
suffix:semicolon
r_else
id|ram_size
op_assign
l_int|4096
suffix:semicolon
id|ram_ptr
op_assign
id|remap_pci_mem
c_func
(paren
id|base_2
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
comma
id|ram_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ram_ptr
)paren
(brace
id|ram_val
op_assign
id|readl_raw
c_func
(paren
id|ram_ptr
op_plus
id|ram_size
op_minus
l_int|16
)paren
suffix:semicolon
id|unmap_pci_mem
c_func
(paren
id|ram_ptr
comma
id|ram_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ram_val
op_eq
l_int|0x52414944
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: not initializing, &quot;
l_string|&quot;driven by SISL RAID controller.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* i386 and PCI MEMORY accessible */
r_if
c_cond
(paren
op_logical_neg
id|chip
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: not initializing, device not supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef __powerpc__
multiline_comment|/*&n;&t;**&t;Fix-up for power/pc.&n;&t;**&t;Should not be performed by the driver.&n;&t;*/
r_if
c_cond
(paren
(paren
id|command
op_amp
(paren
id|PCI_COMMAND_IO
op_or
id|PCI_COMMAND_MEMORY
)paren
)paren
op_ne
(paren
id|PCI_COMMAND_IO
op_or
id|PCI_COMMAND_MEMORY
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: setting%s%s...&bslash;n&quot;
comma
(paren
id|command
op_amp
id|PCI_COMMAND_IO
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; PCI_COMMAND_IO&quot;
comma
(paren
id|command
op_amp
id|PCI_COMMAND_MEMORY
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; PCI_COMMAND_MEMORY&quot;
)paren
suffix:semicolon
id|command
op_or_assign
(paren
id|PCI_COMMAND_IO
op_or
id|PCI_COMMAND_MEMORY
)paren
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,2,0)
r_if
c_cond
(paren
id|is_prep
)paren
(brace
r_if
c_cond
(paren
id|io_port
op_ge
l_int|0x10000000
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: reallocating io_port (Wacky IBM)&quot;
)paren
suffix:semicolon
id|io_port
op_assign
(paren
id|io_port
op_amp
l_int|0x00FFFFFF
)paren
op_or
l_int|0x01000000
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|pdev
comma
id|PCI_BASE_ADDRESS_0
comma
id|io_port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base
op_ge
l_int|0x10000000
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: reallocating base (Wacky IBM)&quot;
)paren
suffix:semicolon
id|base
op_assign
(paren
id|base
op_amp
l_int|0x00FFFFFF
)paren
op_or
l_int|0x01000000
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|pdev
comma
id|PCI_BASE_ADDRESS_1
comma
id|base
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base_2
op_ge
l_int|0x10000000
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: reallocating base2 (Wacky IBM)&quot;
)paren
suffix:semicolon
id|base_2
op_assign
(paren
id|base_2
op_amp
l_int|0x00FFFFFF
)paren
op_or
l_int|0x01000000
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|pdev
comma
id|PCI_BASE_ADDRESS_2
comma
id|base_2
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#endif&t;/* __powerpc__ */
macro_line|#if defined(__i386__) &amp;&amp; !defined(MODULE)
r_if
c_cond
(paren
op_logical_neg
id|cache_line_size
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,1,75)
r_extern
r_char
id|x86
suffix:semicolon
r_switch
c_cond
(paren
id|x86
)paren
(brace
macro_line|#else
r_switch
c_cond
(paren
id|boot_cpu_data.x86
)paren
(brace
macro_line|#endif
r_case
l_int|4
suffix:colon
id|suggested_cache_line_size
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
r_case
l_int|5
suffix:colon
id|suggested_cache_line_size
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* __i386__ */
multiline_comment|/*&n;&t;**    Check availability of IO space, memory space.&n;&t;**    Enable master capability if not yet.&n;&t;**&n;&t;**    We shouldn&squot;t have to care about the IO region when &n;&t;**    we are using MMIO. But calling check_region() from &n;&t;**    both the ncr53c8xx and the sym53c8xx drivers prevents &n;&t;**    from attaching devices from the both drivers.&n;&t;**    If you have a better idea, let me know.&n;&t;*/
multiline_comment|/* #ifdef NCR_IOMAPPED */
macro_line|#if 1
r_if
c_cond
(paren
op_logical_neg
(paren
id|command
op_amp
id|PCI_COMMAND_IO
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: I/O base address (0x%lx) disabled.&bslash;n&quot;
comma
(paren
r_int
)paren
id|io_port
)paren
suffix:semicolon
id|io_port
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|command
op_amp
id|PCI_COMMAND_MEMORY
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: PCI_COMMAND_MEMORY not set.&bslash;n&quot;
)paren
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
id|base_2
op_assign
l_int|0
suffix:semicolon
)brace
id|io_port
op_and_assign
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
id|base
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|base_2
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
multiline_comment|/* #ifdef NCR_IOMAPPED */
macro_line|#if 1
r_if
c_cond
(paren
id|io_port
op_logical_and
id|check_region
(paren
id|io_port
comma
l_int|128
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: IO region 0x%lx[0..127] is in use&bslash;n&quot;
comma
(paren
r_int
)paren
id|io_port
)paren
suffix:semicolon
id|io_port
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|io_port
)paren
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifndef NCR_IOMAPPED
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: MMIO base address disabled.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* The ncr53c8xx driver never did set the PCI parity bit.&t;*/
multiline_comment|/* Since setting this bit is known to trigger spurious MDPE&t;*/
multiline_comment|/* errors on some 895 controllers when noise on power lines is&t;*/
multiline_comment|/* too high, I donnot want to change previous ncr53c8xx driver&t;*/
multiline_comment|/* behaviour on that point (the sym53c8xx driver set this bit).&t;*/
macro_line|#if 0
multiline_comment|/*&n;&t;**    Set MASTER capable and PARITY bit, if not yet.&n;&t;*/
r_if
c_cond
(paren
(paren
id|command
op_amp
(paren
id|PCI_COMMAND_MASTER
op_or
id|PCI_COMMAND_PARITY
)paren
)paren
op_ne
(paren
id|PCI_COMMAND_MASTER
op_or
id|PCI_COMMAND_PARITY
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: setting%s%s...(fix-up)&bslash;n&quot;
comma
(paren
id|command
op_amp
id|PCI_COMMAND_MASTER
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; PCI_COMMAND_MASTER&quot;
comma
(paren
id|command
op_amp
id|PCI_COMMAND_PARITY
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; PCI_COMMAND_PARITY&quot;
)paren
suffix:semicolon
id|command
op_or_assign
(paren
id|PCI_COMMAND_MASTER
op_or
id|PCI_COMMAND_PARITY
)paren
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/*&n;&t;**    Set MASTER capable if not yet.&n;&t;*/
r_if
c_cond
(paren
(paren
id|command
op_amp
id|PCI_COMMAND_MASTER
)paren
op_ne
id|PCI_COMMAND_MASTER
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: setting PCI_COMMAND_MASTER...(fix-up)&bslash;n&quot;
)paren
suffix:semicolon
id|command
op_or_assign
id|PCI_COMMAND_MASTER
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**    Fix some features according to driver setup.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver_setup.special_features
op_amp
l_int|1
)paren
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_SPECIAL_SET
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|driver_setup.special_features
op_amp
l_int|2
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_WRIE
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.special_features
op_amp
l_int|4
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_NOPM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver_setup.ultra_scsi
OL
l_int|2
op_logical_and
(paren
id|chip-&gt;features
op_amp
id|FE_ULTRA2
)paren
)paren
(brace
id|chip-&gt;features
op_or_assign
id|FE_ULTRA
suffix:semicolon
id|chip-&gt;features
op_and_assign
op_complement
id|FE_ULTRA2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver_setup.ultra_scsi
OL
l_int|1
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_ULTRA
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver_setup.max_wide
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_WIDE
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Some features are required to be enabled in order to &n;&t;**&t;work around some chip problems. :) ;)&n;&t;**&t;(ITEM 12 of a DEL about the 896 I haven&squot;t yet).&n;&t;**&t;We must ensure the chip will use WRITE AND INVALIDATE.&n;&t;**&t;The revision number limit is for now arbitrary.&n;&t;*/
r_if
c_cond
(paren
id|device_id
op_eq
id|PCI_DEVICE_ID_NCR_53C896
op_logical_and
id|revision
op_le
l_int|0x10
)paren
(brace
id|chip-&gt;features
op_or_assign
(paren
id|FE_WRIE
op_or
id|FE_CLSE
)paren
suffix:semicolon
id|pci_fix_up
op_or_assign
l_int|3
suffix:semicolon
multiline_comment|/* Force appropriate PCI fix-up */
)brace
macro_line|#ifdef&t;SCSI_NCR_PCI_FIX_UP_SUPPORT
multiline_comment|/*&n;&t;**    Try to fix up PCI config according to wished features.&n;&t;*/
r_if
c_cond
(paren
(paren
id|pci_fix_up
op_amp
l_int|1
)paren
op_logical_and
(paren
id|chip-&gt;features
op_amp
id|FE_CLSE
)paren
op_logical_and
op_logical_neg
id|cache_line_size
op_logical_and
id|suggested_cache_line_size
)paren
(brace
id|cache_line_size
op_assign
id|suggested_cache_line_size
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CACHE_LINE_SIZE
comma
id|cache_line_size
)paren
suffix:semicolon
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: PCI_CACHE_LINE_SIZE set to %d (fix-up).&bslash;n&quot;
comma
id|cache_line_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pci_fix_up
op_amp
l_int|2
)paren
op_logical_and
id|cache_line_size
op_logical_and
(paren
id|chip-&gt;features
op_amp
id|FE_WRIE
)paren
op_logical_and
op_logical_neg
(paren
id|command
op_amp
id|PCI_COMMAND_INVALIDATE
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: setting PCI_COMMAND_INVALIDATE (fix-up)&bslash;n&quot;
)paren
suffix:semicolon
id|command
op_or_assign
id|PCI_COMMAND_INVALIDATE
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    Tune PCI LATENCY TIMER according to burst max length transfer.&n;&t;**    (latency timer &gt;= burst length + 6, we add 10 to be quite sure)&n;&t;*/
r_if
c_cond
(paren
id|chip-&gt;burst_max
op_logical_and
(paren
id|latency_timer
op_eq
l_int|0
op_logical_or
(paren
id|pci_fix_up
op_amp
l_int|4
)paren
)paren
)paren
(brace
id|u_char
id|lt
op_assign
(paren
l_int|1
op_lshift
id|chip-&gt;burst_max
)paren
op_plus
l_int|6
op_plus
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|latency_timer
OL
id|lt
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: changing PCI_LATENCY_TIMER from %d to %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|latency_timer
comma
(paren
r_int
)paren
id|lt
)paren
suffix:semicolon
id|latency_timer
op_assign
id|lt
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|pdev
comma
id|PCI_LATENCY_TIMER
comma
id|latency_timer
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* SCSI_NCR_PCI_FIX_UP_SUPPORT */
multiline_comment|/*&n;&t;**    Initialise ncr_device structure with items required by ncr_attach.&n;&t;*/
id|device-&gt;pdev
op_assign
id|pdev
suffix:semicolon
id|device-&gt;slot.bus
op_assign
id|PciBusNumber
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|device-&gt;slot.device_fn
op_assign
id|PciDeviceFn
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|device-&gt;slot.base
op_assign
id|base
suffix:semicolon
id|device-&gt;slot.base_2
op_assign
id|base_2
suffix:semicolon
id|device-&gt;slot.io_port
op_assign
id|io_port
suffix:semicolon
id|device-&gt;slot.irq
op_assign
id|irq
suffix:semicolon
id|device-&gt;attach_done
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*===================================================================&n;**&n;**    Detect all 53c8xx hosts and then attach them.&n;**&n;**    If we are using NVRAM, once all hosts are detected, we need to &n;**    check any NVRAM for boot order in case detect and boot order &n;**    differ and attach them using the order in the NVRAM.&n;**&n;**    If no NVRAM is found or data appears invalid attach boards in &n;**    the the order they are detected.&n;**&n;**===================================================================&n;*/
r_static
r_int
id|__init
DECL|function|sym53c8xx__detect
id|sym53c8xx__detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
id|u_short
id|ncr_chip_ids
(braket
)braket
comma
r_int
id|chips
)paren
(brace
id|pcidev_t
id|pcidev
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|hosts
comma
id|count
suffix:semicolon
r_int
id|attach_count
op_assign
l_int|0
suffix:semicolon
id|ncr_device
op_star
id|devtbl
comma
op_star
id|devp
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
id|ncr_nvram
id|nvram0
comma
id|nvram
comma
op_star
id|nvp
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**    PCI is required.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef SCSI_NCR_DEBUG_INFO_SUPPORT
id|ncr_debug
op_assign
id|driver_setup.debug
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|initverbose
op_ge
l_int|2
)paren
id|ncr_print_driver_setup
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate the device table since we donnot want to &n;&t;**&t;overflow the kernel stack.&n;&t;**&t;1 x 4K PAGE is enough for more than 40 devices for i386.&n;&t;*/
id|devtbl
op_assign
id|m_calloc
c_func
(paren
id|PAGE_SIZE
comma
l_string|&quot;devtbl&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devtbl
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**    Detect all NCR PQS/PDS memory controllers.&n;&t;*/
macro_line|#ifdef&t;SCSI_NCR_PQS_PDS_SUPPORT
id|ncr_detect_pqs_pds
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t;**    Detect all 53c8xx hosts.&n;&t;**    Save the first Symbios NVRAM content if any &n;&t;**    for the boot order.&n;&t;*/
id|hosts
op_assign
id|PAGE_SIZE
op_div
r_sizeof
(paren
op_star
id|devtbl
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
id|nvp
op_assign
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x1
)paren
ques
c_cond
op_amp
id|nvram0
suffix:colon
l_int|0
suffix:semicolon
macro_line|#endif
id|j
op_assign
l_int|0
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
id|pcidev
op_assign
id|PCIDEV_NULL
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_char
op_star
id|msg
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
id|hosts
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|j
op_ge
id|chips
)paren
r_break
suffix:semicolon
id|i
op_assign
id|driver_setup.reverse_probe
ques
c_cond
id|chips
op_minus
l_int|1
op_minus
id|j
suffix:colon
id|j
suffix:semicolon
id|pcidev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_NCR
comma
id|ncr_chip_ids
(braket
id|i
)braket
comma
id|pcidev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcidev
op_eq
id|PCIDEV_NULL
)paren
(brace
op_increment
id|j
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Some HW as the HP LH4 may report twice PCI devices */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|devtbl
(braket
id|i
)braket
dot
id|slot.bus
op_eq
id|PciBusNumber
c_func
(paren
id|pcidev
)paren
op_logical_and
id|devtbl
(braket
id|i
)braket
dot
id|slot.device_fn
op_eq
id|PciDeviceFn
c_func
(paren
id|pcidev
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
id|count
)paren
multiline_comment|/* Ignore this device if we already have it */
r_continue
suffix:semicolon
id|devp
op_assign
op_amp
id|devtbl
(braket
id|count
)braket
suffix:semicolon
id|devp-&gt;host_id
op_assign
id|driver_setup.host_id
suffix:semicolon
id|devp-&gt;attach_done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sym53c8xx_pci_init
c_func
(paren
id|tpnt
comma
id|pcidev
comma
id|devp
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
op_increment
id|count
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_if
c_cond
(paren
id|nvp
)paren
(brace
id|ncr_get_nvram
c_func
(paren
id|devp
comma
id|nvp
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|nvp-&gt;type
)paren
(brace
r_case
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; *   Switch to the other nvram buffer, so that &n;&t;&t;&t;&t; *   nvram0 will contain the first Symbios &n;&t;&t;&t;&t; *   format NVRAM content with boot order.&n;&t;&t;&t;&t; */
id|nvp
op_assign
op_amp
id|nvram
suffix:semicolon
id|msg
op_assign
l_string|&quot;with Symbios NVRAM&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCSI_NCR_TEKRAM_NVRAM
suffix:colon
id|msg
op_assign
l_string|&quot;with Tekram NVRAM&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef&t;SCSI_NCR_PQS_PDS_SUPPORT
r_if
c_cond
(paren
id|devp-&gt;pqs_pds
)paren
id|msg
op_assign
l_string|&quot;(NCR PQS/PDS)&quot;
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
id|NAME53C8XX
l_string|&quot;: 53c%s detected %s&bslash;n&quot;
comma
id|devp-&gt;chip.name
comma
id|msg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    If we have found a SYMBIOS NVRAM, use first the NVRAM boot &n;&t;**    sequence as device boot order.&n;&t;**    check devices in the boot record against devices detected. &n;&t;**    attach devices if we find a match. boot table records that &n;&t;**    do not match any detected devices will be ignored. &n;&t;**    devices that do not match any boot table will not be attached&n;&t;**    here but will attempt to be attached during the device table &n;&t;**    rescan.&n;&t;*/
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_if
c_cond
(paren
op_logical_neg
id|nvp
op_logical_or
id|nvram0.type
op_ne
id|SCSI_NCR_SYMBIOS_NVRAM
)paren
r_goto
id|next
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Symbios_host
op_star
id|h
op_assign
op_amp
id|nvram0.data.Symbios.host
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|count
suffix:semicolon
id|j
op_increment
)paren
(brace
id|devp
op_assign
op_amp
id|devtbl
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|h-&gt;device_fn
op_ne
id|devp-&gt;slot.device_fn
op_logical_or
id|h-&gt;bus_nr
op_ne
id|devp-&gt;slot.bus
op_logical_or
id|h-&gt;device_id
op_ne
id|devp-&gt;chip.device_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|devp-&gt;attach_done
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|h-&gt;flags
op_amp
id|SYMBIOS_INIT_SCAN_AT_BOOT
)paren
(brace
id|ncr_get_nvram
c_func
(paren
id|devp
comma
id|nvp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ncr_attach
(paren
id|tpnt
comma
id|attach_count
comma
id|devp
)paren
)paren
id|attach_count
op_increment
suffix:semicolon
)brace
macro_line|#if 0&t;/* Restore previous behaviour of ncr53c8xx driver */
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x80
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
id|NAME53C8XX
l_string|&quot;: 53c%s state OFF thus not attached&bslash;n&quot;
comma
id|devp-&gt;chip.name
)paren
suffix:semicolon
macro_line|#endif
r_else
r_continue
suffix:semicolon
id|devp-&gt;attach_done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|next
suffix:colon
macro_line|#endif
multiline_comment|/* &n;&t;**    Rescan device list to make sure all boards attached.&n;&t;**    Devices without boot records will not be attached yet&n;&t;**    so try to attach them here.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|devp
op_assign
op_amp
id|devtbl
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devp-&gt;attach_done
)paren
(brace
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
id|ncr_get_nvram
c_func
(paren
id|devp
comma
id|nvp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|ncr_attach
(paren
id|tpnt
comma
id|attach_count
comma
id|devp
)paren
)paren
id|attach_count
op_increment
suffix:semicolon
)brace
)brace
id|m_free
c_func
(paren
id|devtbl
comma
id|PAGE_SIZE
comma
l_string|&quot;devtbl&quot;
)paren
suffix:semicolon
r_return
id|attach_count
suffix:semicolon
)brace
eof
