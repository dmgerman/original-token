multiline_comment|/* NCR53C9x.c:  Generic SCSI driver code for NCR53C9x chips.&n; *&n; * Originally esp.c : EnhancedScsiProcessor Sun SCSI driver code.&n; *&n; * Copyright (C) 1995, 1998 David S. Miller (davem@caip.rutgers.edu)&n; *&n; * Most DMA dependencies put in driver specific files by &n; * Jesper Skov (jskov@cygnus.co.uk)&n; *&n; * Set up to use esp_read/esp_write (preprocessor macros in NCR53c9x.h) by&n; * Tymm Twillman (tymm@coe.missouri.edu)&n; */
multiline_comment|/* TODO:&n; *&n; * 1) Maybe disable parity checking in config register one for SCSI1&n; *    targets.  (Gilmore says parity error on the SBus can lock up&n; *    old sun4c&squot;s)&n; * 2) Add support for DMA2 pipelining.&n; * 3) Add tagged queueing.&n; * 4) Maybe change use of &quot;esp&quot; to something more &quot;NCR&quot;&squot;ish.&n; */
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;NCR53C9x.h&quot;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
multiline_comment|/* Command phase enumeration. */
r_enum
(brace
DECL|enumerator|not_issued
id|not_issued
op_assign
l_int|0x00
comma
multiline_comment|/* Still in the issue_SC queue.          */
multiline_comment|/* Various forms of selecting a target. */
DECL|macro|in_slct_mask
mdefine_line|#define in_slct_mask    0x10
DECL|enumerator|in_slct_norm
id|in_slct_norm
op_assign
l_int|0x10
comma
multiline_comment|/* ESP is arbitrating, normal selection  */
DECL|enumerator|in_slct_stop
id|in_slct_stop
op_assign
l_int|0x11
comma
multiline_comment|/* ESP will select, then stop with IRQ   */
DECL|enumerator|in_slct_msg
id|in_slct_msg
op_assign
l_int|0x12
comma
multiline_comment|/* select, then send a message           */
DECL|enumerator|in_slct_tag
id|in_slct_tag
op_assign
l_int|0x13
comma
multiline_comment|/* select and send tagged queue msg      */
DECL|enumerator|in_slct_sneg
id|in_slct_sneg
op_assign
l_int|0x14
comma
multiline_comment|/* select and acquire sync capabilities  */
multiline_comment|/* Any post selection activity. */
DECL|macro|in_phases_mask
mdefine_line|#define in_phases_mask  0x20
DECL|enumerator|in_datain
id|in_datain
op_assign
l_int|0x20
comma
multiline_comment|/* Data is transferring from the bus     */
DECL|enumerator|in_dataout
id|in_dataout
op_assign
l_int|0x21
comma
multiline_comment|/* Data is transferring to the bus       */
DECL|enumerator|in_data_done
id|in_data_done
op_assign
l_int|0x22
comma
multiline_comment|/* Last DMA data operation done (maybe)  */
DECL|enumerator|in_msgin
id|in_msgin
op_assign
l_int|0x23
comma
multiline_comment|/* Eating message from target            */
DECL|enumerator|in_msgincont
id|in_msgincont
op_assign
l_int|0x24
comma
multiline_comment|/* Eating more msg bytes from target     */
DECL|enumerator|in_msgindone
id|in_msgindone
op_assign
l_int|0x25
comma
multiline_comment|/* Decide what to do with what we got    */
DECL|enumerator|in_msgout
id|in_msgout
op_assign
l_int|0x26
comma
multiline_comment|/* Sending message to target             */
DECL|enumerator|in_msgoutdone
id|in_msgoutdone
op_assign
l_int|0x27
comma
multiline_comment|/* Done sending msg out                  */
DECL|enumerator|in_cmdbegin
id|in_cmdbegin
op_assign
l_int|0x28
comma
multiline_comment|/* Sending cmd after abnormal selection  */
DECL|enumerator|in_cmdend
id|in_cmdend
op_assign
l_int|0x29
comma
multiline_comment|/* Done sending slow cmd                 */
DECL|enumerator|in_status
id|in_status
op_assign
l_int|0x2a
comma
multiline_comment|/* Was in status phase, finishing cmd    */
DECL|enumerator|in_freeing
id|in_freeing
op_assign
l_int|0x2b
comma
multiline_comment|/* freeing the bus for cmd cmplt or disc */
DECL|enumerator|in_the_dark
id|in_the_dark
op_assign
l_int|0x2c
comma
multiline_comment|/* Don&squot;t know what bus phase we are in   */
multiline_comment|/* Special states, ie. not normal bus transitions... */
DECL|macro|in_spec_mask
mdefine_line|#define in_spec_mask    0x80
DECL|enumerator|in_abortone
id|in_abortone
op_assign
l_int|0x80
comma
multiline_comment|/* Aborting one command currently        */
DECL|enumerator|in_abortall
id|in_abortall
op_assign
l_int|0x81
comma
multiline_comment|/* Blowing away all commands we have     */
DECL|enumerator|in_resetdev
id|in_resetdev
op_assign
l_int|0x82
comma
multiline_comment|/* SCSI target reset in progress         */
DECL|enumerator|in_resetbus
id|in_resetbus
op_assign
l_int|0x83
comma
multiline_comment|/* SCSI bus reset in progress            */
DECL|enumerator|in_tgterror
id|in_tgterror
op_assign
l_int|0x84
comma
multiline_comment|/* Target did something stupid           */
)brace
suffix:semicolon
r_enum
(brace
multiline_comment|/* Zero has special meaning, see skipahead[12]. */
DECL|enumerator|do_never
multiline_comment|/*0*/
id|do_never
comma
DECL|enumerator|do_phase_determine
multiline_comment|/*1*/
id|do_phase_determine
comma
DECL|enumerator|do_reset_bus
multiline_comment|/*2*/
id|do_reset_bus
comma
DECL|enumerator|do_reset_complete
multiline_comment|/*3*/
id|do_reset_complete
comma
DECL|enumerator|do_work_bus
multiline_comment|/*4*/
id|do_work_bus
comma
DECL|enumerator|do_intr_end
multiline_comment|/*5*/
id|do_intr_end
)brace
suffix:semicolon
multiline_comment|/* The master ring of all esp hosts we are managing in this driver. */
DECL|variable|espchain
r_struct
id|NCR_ESP
op_star
id|espchain
op_assign
l_int|0
suffix:semicolon
DECL|variable|nesps
DECL|variable|esps_in_use
DECL|variable|esps_running
r_int
id|nesps
op_assign
l_int|0
comma
id|esps_in_use
op_assign
l_int|0
comma
id|esps_running
op_assign
l_int|0
suffix:semicolon
r_void
id|esp_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|pregs
)paren
suffix:semicolon
multiline_comment|/* Debugging routines */
DECL|struct|esp_cmdstrings
r_struct
id|esp_cmdstrings
(brace
DECL|member|cmdchar
id|unchar
id|cmdchar
suffix:semicolon
DECL|member|text
r_char
op_star
id|text
suffix:semicolon
DECL|variable|esp_cmd_strings
)brace
id|esp_cmd_strings
(braket
)braket
op_assign
(brace
multiline_comment|/* Miscellaneous */
(brace
id|ESP_CMD_NULL
comma
l_string|&quot;ESP_NOP&quot;
comma
)brace
comma
(brace
id|ESP_CMD_FLUSH
comma
l_string|&quot;FIFO_FLUSH&quot;
comma
)brace
comma
(brace
id|ESP_CMD_RC
comma
l_string|&quot;RSTESP&quot;
comma
)brace
comma
(brace
id|ESP_CMD_RS
comma
l_string|&quot;RSTSCSI&quot;
comma
)brace
comma
multiline_comment|/* Disconnected State Group */
(brace
id|ESP_CMD_RSEL
comma
l_string|&quot;RESLCTSEQ&quot;
comma
)brace
comma
(brace
id|ESP_CMD_SEL
comma
l_string|&quot;SLCTNATN&quot;
comma
)brace
comma
(brace
id|ESP_CMD_SELA
comma
l_string|&quot;SLCTATN&quot;
comma
)brace
comma
(brace
id|ESP_CMD_SELAS
comma
l_string|&quot;SLCTATNSTOP&quot;
comma
)brace
comma
(brace
id|ESP_CMD_ESEL
comma
l_string|&quot;ENSLCTRESEL&quot;
comma
)brace
comma
(brace
id|ESP_CMD_DSEL
comma
l_string|&quot;DISSELRESEL&quot;
comma
)brace
comma
(brace
id|ESP_CMD_SA3
comma
l_string|&quot;SLCTATN3&quot;
comma
)brace
comma
(brace
id|ESP_CMD_RSEL3
comma
l_string|&quot;RESLCTSEQ&quot;
comma
)brace
comma
multiline_comment|/* Target State Group */
(brace
id|ESP_CMD_SMSG
comma
l_string|&quot;SNDMSG&quot;
comma
)brace
comma
(brace
id|ESP_CMD_SSTAT
comma
l_string|&quot;SNDSTATUS&quot;
comma
)brace
comma
(brace
id|ESP_CMD_SDATA
comma
l_string|&quot;SNDDATA&quot;
comma
)brace
comma
(brace
id|ESP_CMD_DSEQ
comma
l_string|&quot;DISCSEQ&quot;
comma
)brace
comma
(brace
id|ESP_CMD_TSEQ
comma
l_string|&quot;TERMSEQ&quot;
comma
)brace
comma
(brace
id|ESP_CMD_TCCSEQ
comma
l_string|&quot;TRGTCMDCOMPSEQ&quot;
comma
)brace
comma
(brace
id|ESP_CMD_DCNCT
comma
l_string|&quot;DISC&quot;
comma
)brace
comma
(brace
id|ESP_CMD_RMSG
comma
l_string|&quot;RCVMSG&quot;
comma
)brace
comma
(brace
id|ESP_CMD_RCMD
comma
l_string|&quot;RCVCMD&quot;
comma
)brace
comma
(brace
id|ESP_CMD_RDATA
comma
l_string|&quot;RCVDATA&quot;
comma
)brace
comma
(brace
id|ESP_CMD_RCSEQ
comma
l_string|&quot;RCVCMDSEQ&quot;
comma
)brace
comma
multiline_comment|/* Initiator State Group */
(brace
id|ESP_CMD_TI
comma
l_string|&quot;TRANSINFO&quot;
comma
)brace
comma
(brace
id|ESP_CMD_ICCSEQ
comma
l_string|&quot;INICMDSEQCOMP&quot;
comma
)brace
comma
(brace
id|ESP_CMD_MOK
comma
l_string|&quot;MSGACCEPTED&quot;
comma
)brace
comma
(brace
id|ESP_CMD_TPAD
comma
l_string|&quot;TPAD&quot;
comma
)brace
comma
(brace
id|ESP_CMD_SATN
comma
l_string|&quot;SATN&quot;
comma
)brace
comma
(brace
id|ESP_CMD_RATN
comma
l_string|&quot;RATN&quot;
comma
)brace
comma
)brace
suffix:semicolon
DECL|macro|NUM_ESP_COMMANDS
mdefine_line|#define NUM_ESP_COMMANDS  ((sizeof(esp_cmd_strings)) / (sizeof(struct esp_cmdstrings)))
multiline_comment|/* Print textual representation of an ESP command */
DECL|function|esp_print_cmd
r_static
r_inline
r_void
id|esp_print_cmd
c_func
(paren
id|unchar
id|espcmd
)paren
(brace
id|unchar
id|dma_bit
op_assign
id|espcmd
op_amp
id|ESP_CMD_DMA
suffix:semicolon
r_int
id|i
suffix:semicolon
id|espcmd
op_and_assign
op_complement
id|dma_bit
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_ESP_COMMANDS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|esp_cmd_strings
(braket
id|i
)braket
dot
id|cmdchar
op_eq
id|espcmd
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|NUM_ESP_COMMANDS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ESP_Unknown&quot;
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;%s%s&quot;
comma
id|esp_cmd_strings
(braket
id|i
)braket
dot
id|text
comma
(paren
(paren
id|dma_bit
)paren
ques
c_cond
l_string|&quot;+DMA&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Print the status register&squot;s value */
DECL|function|esp_print_statreg
r_static
r_inline
r_void
id|esp_print_statreg
c_func
(paren
id|unchar
id|statreg
)paren
(brace
id|unchar
id|phase
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;STATUS&lt;&quot;
)paren
suffix:semicolon
id|phase
op_assign
id|statreg
op_amp
id|ESP_STAT_PMASK
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s,&quot;
comma
(paren
id|phase
op_eq
id|ESP_DOP
ques
c_cond
l_string|&quot;DATA-OUT&quot;
suffix:colon
(paren
id|phase
op_eq
id|ESP_DIP
ques
c_cond
l_string|&quot;DATA-IN&quot;
suffix:colon
(paren
id|phase
op_eq
id|ESP_CMDP
ques
c_cond
l_string|&quot;COMMAND&quot;
suffix:colon
(paren
id|phase
op_eq
id|ESP_STATP
ques
c_cond
l_string|&quot;STATUS&quot;
suffix:colon
(paren
id|phase
op_eq
id|ESP_MOP
ques
c_cond
l_string|&quot;MSG-OUT&quot;
suffix:colon
(paren
id|phase
op_eq
id|ESP_MIP
ques
c_cond
l_string|&quot;MSG_IN&quot;
suffix:colon
l_string|&quot;unknown&quot;
)paren
)paren
)paren
)paren
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|statreg
op_amp
id|ESP_STAT_TDONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TRANS_DONE,&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|statreg
op_amp
id|ESP_STAT_TCNT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TCOUNT_ZERO,&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|statreg
op_amp
id|ESP_STAT_PERR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;P_ERROR,&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|statreg
op_amp
id|ESP_STAT_SPAM
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SPAM,&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|statreg
op_amp
id|ESP_STAT_INTR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IRQ,&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Print the interrupt register&squot;s value */
DECL|function|esp_print_ireg
r_static
r_inline
r_void
id|esp_print_ireg
c_func
(paren
id|unchar
id|intreg
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;INTREG&lt; &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intreg
op_amp
id|ESP_INTR_S
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SLCT_NATN &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intreg
op_amp
id|ESP_INTR_SATN
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SLCT_ATN &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intreg
op_amp
id|ESP_INTR_RSEL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RSLCT &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intreg
op_amp
id|ESP_INTR_FDONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FDONE &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intreg
op_amp
id|ESP_INTR_BSERV
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BSERV &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intreg
op_amp
id|ESP_INTR_DC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DISCNCT &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intreg
op_amp
id|ESP_INTR_IC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ILL_CMD &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intreg
op_amp
id|ESP_INTR_SR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI_BUS_RESET &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Print the sequence step registers contents */
DECL|function|esp_print_seqreg
r_static
r_inline
r_void
id|esp_print_seqreg
c_func
(paren
id|unchar
id|stepreg
)paren
(brace
id|stepreg
op_and_assign
id|ESP_STEP_VBITS
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;STEP&lt;%s&gt;&quot;
comma
(paren
id|stepreg
op_eq
id|ESP_STEP_ASEL
ques
c_cond
l_string|&quot;SLCT_ARB_CMPLT&quot;
suffix:colon
(paren
id|stepreg
op_eq
id|ESP_STEP_SID
ques
c_cond
l_string|&quot;1BYTE_MSG_SENT&quot;
suffix:colon
(paren
id|stepreg
op_eq
id|ESP_STEP_NCMD
ques
c_cond
l_string|&quot;NOT_IN_CMD_PHASE&quot;
suffix:colon
(paren
id|stepreg
op_eq
id|ESP_STEP_PPC
ques
c_cond
l_string|&quot;CMD_BYTES_LOST&quot;
suffix:colon
(paren
id|stepreg
op_eq
id|ESP_STEP_FINI4
ques
c_cond
l_string|&quot;CMD_SENT_OK&quot;
suffix:colon
l_string|&quot;UNKNOWN&quot;
)paren
)paren
)paren
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|phase_string
r_static
r_char
op_star
id|phase_string
c_func
(paren
r_int
id|phase
)paren
(brace
r_switch
c_cond
(paren
id|phase
)paren
(brace
r_case
id|not_issued
suffix:colon
r_return
l_string|&quot;UNISSUED&quot;
suffix:semicolon
r_case
id|in_slct_norm
suffix:colon
r_return
l_string|&quot;SLCTNORM&quot;
suffix:semicolon
r_case
id|in_slct_stop
suffix:colon
r_return
l_string|&quot;SLCTSTOP&quot;
suffix:semicolon
r_case
id|in_slct_msg
suffix:colon
r_return
l_string|&quot;SLCTMSG&quot;
suffix:semicolon
r_case
id|in_slct_tag
suffix:colon
r_return
l_string|&quot;SLCTTAG&quot;
suffix:semicolon
r_case
id|in_slct_sneg
suffix:colon
r_return
l_string|&quot;SLCTSNEG&quot;
suffix:semicolon
r_case
id|in_datain
suffix:colon
r_return
l_string|&quot;DATAIN&quot;
suffix:semicolon
r_case
id|in_dataout
suffix:colon
r_return
l_string|&quot;DATAOUT&quot;
suffix:semicolon
r_case
id|in_data_done
suffix:colon
r_return
l_string|&quot;DATADONE&quot;
suffix:semicolon
r_case
id|in_msgin
suffix:colon
r_return
l_string|&quot;MSGIN&quot;
suffix:semicolon
r_case
id|in_msgincont
suffix:colon
r_return
l_string|&quot;MSGINCONT&quot;
suffix:semicolon
r_case
id|in_msgindone
suffix:colon
r_return
l_string|&quot;MSGINDONE&quot;
suffix:semicolon
r_case
id|in_msgout
suffix:colon
r_return
l_string|&quot;MSGOUT&quot;
suffix:semicolon
r_case
id|in_msgoutdone
suffix:colon
r_return
l_string|&quot;MSGOUTDONE&quot;
suffix:semicolon
r_case
id|in_cmdbegin
suffix:colon
r_return
l_string|&quot;CMDBEGIN&quot;
suffix:semicolon
r_case
id|in_cmdend
suffix:colon
r_return
l_string|&quot;CMDEND&quot;
suffix:semicolon
r_case
id|in_status
suffix:colon
r_return
l_string|&quot;STATUS&quot;
suffix:semicolon
r_case
id|in_freeing
suffix:colon
r_return
l_string|&quot;FREEING&quot;
suffix:semicolon
r_case
id|in_the_dark
suffix:colon
r_return
l_string|&quot;CLUELESS&quot;
suffix:semicolon
r_case
id|in_abortone
suffix:colon
r_return
l_string|&quot;ABORTONE&quot;
suffix:semicolon
r_case
id|in_abortall
suffix:colon
r_return
l_string|&quot;ABORTALL&quot;
suffix:semicolon
r_case
id|in_resetdev
suffix:colon
r_return
l_string|&quot;RESETDEV&quot;
suffix:semicolon
r_case
id|in_resetbus
suffix:colon
r_return
l_string|&quot;RESETBUS&quot;
suffix:semicolon
r_case
id|in_tgterror
suffix:colon
r_return
l_string|&quot;TGTERROR&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;UNKNOWN&quot;
suffix:semicolon
)brace
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_STATE_MACHINE
DECL|function|esp_advance_phase
r_static
r_inline
r_void
id|esp_advance_phase
c_func
(paren
id|Scsi_Cmnd
op_star
id|s
comma
r_int
id|newphase
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;&lt;%s&gt;&quot;
comma
id|phase_string
c_func
(paren
id|newphase
)paren
)paren
)paren
suffix:semicolon
id|s-&gt;SCp.sent_command
op_assign
id|s-&gt;SCp.phase
suffix:semicolon
id|s-&gt;SCp.phase
op_assign
id|newphase
suffix:semicolon
)brace
macro_line|#else
DECL|macro|esp_advance_phase
mdefine_line|#define esp_advance_phase(__s, __newphase) &bslash;&n;&t;(__s)-&gt;SCp.sent_command = (__s)-&gt;SCp.phase; &bslash;&n;&t;(__s)-&gt;SCp.phase = (__newphase);
macro_line|#endif
macro_line|#ifdef DEBUG_ESP_CMDS
DECL|function|esp_cmd
r_extern
r_inline
r_void
id|esp_cmd
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
comma
id|unchar
id|cmd
)paren
(brace
id|esp-&gt;espcmdlog
(braket
id|esp-&gt;espcmdent
)braket
op_assign
id|cmd
suffix:semicolon
id|esp-&gt;espcmdent
op_assign
(paren
id|esp-&gt;espcmdent
op_plus
l_int|1
)paren
op_amp
l_int|31
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cmnd
comma
id|cmd
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|esp_cmd
mdefine_line|#define esp_cmd(__esp, __eregs, __cmd)&t;esp_write((__eregs)-&gt;esp_cmnd, (__cmd))
macro_line|#endif
multiline_comment|/* How we use the various Linux SCSI data structures for operation.&n; *&n; * struct scsi_cmnd:&n; *&n; *   We keep track of the syncronous capabilities of a target&n; *   in the device member, using sync_min_period and&n; *   sync_max_offset.  These are the values we directly write&n; *   into the ESP registers while running a command.  If offset&n; *   is zero the ESP will use asynchronous transfers.&n; *   If the borken flag is set we assume we shouldn&squot;t even bother&n; *   trying to negotiate for synchronous transfer as this target&n; *   is really stupid.  If we notice the target is dropping the&n; *   bus, and we have been allowing it to disconnect, we clear&n; *   the disconnect flag.&n; */
multiline_comment|/* Manipulation of the ESP command queues.  Thanks to the aha152x driver&n; * and its author, Juergen E. Fischer, for the methods used here.&n; * Note that these are per-ESP queues, not global queues like&n; * the aha152x driver uses.&n; */
DECL|function|append_SC
r_static
r_inline
r_void
id|append_SC
c_func
(paren
id|Scsi_Cmnd
op_star
op_star
id|SC
comma
id|Scsi_Cmnd
op_star
id|new_SC
)paren
(brace
id|Scsi_Cmnd
op_star
id|end
suffix:semicolon
id|new_SC-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|SC
)paren
(brace
op_star
id|SC
op_assign
id|new_SC
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|end
op_assign
op_star
id|SC
suffix:semicolon
id|end-&gt;host_scribble
suffix:semicolon
id|end
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|end-&gt;host_scribble
)paren
(brace
suffix:semicolon
)brace
id|end-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|new_SC
suffix:semicolon
)brace
)brace
DECL|function|prepend_SC
r_static
r_inline
r_void
id|prepend_SC
c_func
(paren
id|Scsi_Cmnd
op_star
op_star
id|SC
comma
id|Scsi_Cmnd
op_star
id|new_SC
)paren
(brace
id|new_SC-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
op_star
id|SC
suffix:semicolon
op_star
id|SC
op_assign
id|new_SC
suffix:semicolon
)brace
DECL|function|remove_first_SC
r_static
r_inline
id|Scsi_Cmnd
op_star
id|remove_first_SC
c_func
(paren
id|Scsi_Cmnd
op_star
op_star
id|SC
)paren
(brace
id|Scsi_Cmnd
op_star
id|ptr
suffix:semicolon
id|ptr
op_assign
op_star
id|SC
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
(brace
op_star
id|SC
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
(paren
op_star
id|SC
)paren
op_member_access_from_pointer
id|host_scribble
suffix:semicolon
)brace
r_return
id|ptr
suffix:semicolon
)brace
DECL|function|remove_SC
r_static
r_inline
id|Scsi_Cmnd
op_star
id|remove_SC
c_func
(paren
id|Scsi_Cmnd
op_star
op_star
id|SC
comma
r_int
id|target
comma
r_int
id|lun
)paren
(brace
id|Scsi_Cmnd
op_star
id|ptr
comma
op_star
id|prev
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
op_star
id|SC
comma
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|ptr
op_logical_and
(paren
(paren
id|ptr-&gt;target
op_ne
id|target
)paren
op_logical_or
(paren
id|ptr-&gt;lun
op_ne
id|lun
)paren
)paren
suffix:semicolon
id|prev
op_assign
id|ptr
comma
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
(brace
id|prev-&gt;host_scribble
op_assign
id|ptr-&gt;host_scribble
suffix:semicolon
)brace
r_else
op_star
id|SC
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
suffix:semicolon
)brace
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/* Resetting various pieces of the ESP scsi driver chipset */
multiline_comment|/* Reset the ESP chip, _not_ the SCSI bus. */
DECL|function|esp_reset_esp
r_static
r_void
id|esp_reset_esp
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
r_int
id|family_code
comma
id|version
comma
id|i
suffix:semicolon
r_volatile
r_int
id|trash
suffix:semicolon
multiline_comment|/* Now reset the ESP chip */
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_RC
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_NULL
op_or
id|ESP_CMD_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fast
)paren
(brace
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg2
comma
id|ESP_CONFIG2_FENAB
)paren
suffix:semicolon
)brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_NULL
op_or
id|ESP_CMD_DMA
)paren
suffix:semicolon
multiline_comment|/* This is the only point at which it is reliable to read&n;&t; * the ID-code for a fast ESP chip variant.&n;&t; */
id|esp-&gt;max_period
op_assign
(paren
(paren
l_int|35
op_star
id|esp-&gt;ccycle
)paren
op_div
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fast
)paren
(brace
r_char
op_star
id|erev2string
(braket
)braket
op_assign
(brace
l_string|&quot;Emulex FAS236&quot;
comma
l_string|&quot;Emulex FPESP100A&quot;
comma
l_string|&quot;fast&quot;
comma
l_string|&quot;QLogic FAS366&quot;
comma
l_string|&quot;Emulex FAS216&quot;
comma
l_string|&quot;Symbios Logic 53CF9x-2&quot;
comma
l_string|&quot;unknown!&quot;
)brace
suffix:semicolon
id|version
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_uid
)paren
suffix:semicolon
id|family_code
op_assign
(paren
id|version
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|family_code
op_eq
l_int|0x02
)paren
(brace
r_if
c_cond
(paren
(paren
id|version
op_amp
l_int|7
)paren
op_eq
l_int|2
)paren
id|esp-&gt;erev
op_assign
id|fas216
suffix:semicolon
r_else
id|esp-&gt;erev
op_assign
id|fas236
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|family_code
op_eq
l_int|0x0a
)paren
(brace
id|esp-&gt;erev
op_assign
id|fas366
suffix:semicolon
)brace
multiline_comment|/* Version is usually &squot;5&squot;. */
r_else
r_if
c_cond
(paren
id|family_code
op_eq
l_int|0x00
)paren
(brace
r_if
c_cond
(paren
(paren
id|version
op_amp
l_int|7
)paren
op_eq
l_int|2
)paren
id|esp-&gt;erev
op_assign
id|fas100a
suffix:semicolon
multiline_comment|/* NCR53C9X */
r_else
id|esp-&gt;erev
op_assign
id|espunknown
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|family_code
op_eq
l_int|0x14
)paren
(brace
r_if
c_cond
(paren
(paren
id|version
op_amp
l_int|7
)paren
op_eq
l_int|2
)paren
id|esp-&gt;erev
op_assign
id|fsc
suffix:semicolon
r_else
id|esp-&gt;erev
op_assign
id|espunknown
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|family_code
op_eq
l_int|0x00
)paren
(brace
r_if
c_cond
(paren
(paren
id|version
op_amp
l_int|7
)paren
op_eq
l_int|2
)paren
id|esp-&gt;erev
op_assign
id|fas100a
suffix:semicolon
multiline_comment|/* NCR53C9X */
r_else
id|esp-&gt;erev
op_assign
id|espunknown
suffix:semicolon
)brace
r_else
id|esp-&gt;erev
op_assign
id|espunknown
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: FAST chip is %s (family=%d, version=%d)&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|erev2string
(braket
id|esp-&gt;erev
op_minus
id|fas236
)braket
comma
id|family_code
comma
(paren
id|version
op_amp
l_int|7
)paren
)paren
)paren
suffix:semicolon
id|esp-&gt;min_period
op_assign
(paren
(paren
l_int|4
op_star
id|esp-&gt;ccycle
)paren
op_div
l_int|1000
)paren
suffix:semicolon
)brace
r_else
(brace
id|esp-&gt;min_period
op_assign
(paren
(paren
l_int|5
op_star
id|esp-&gt;ccycle
)paren
op_div
l_int|1000
)paren
suffix:semicolon
)brace
multiline_comment|/* Reload the configuration registers */
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfact
comma
id|esp-&gt;cfact
)paren
suffix:semicolon
id|esp-&gt;prev_stp
op_assign
l_int|0
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_stp
comma
l_int|0
)paren
suffix:semicolon
id|esp-&gt;prev_soff
op_assign
l_int|0
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_soff
comma
l_int|0
)paren
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_timeo
comma
id|esp-&gt;neg_defp
)paren
suffix:semicolon
id|esp-&gt;max_period
op_assign
(paren
id|esp-&gt;max_period
op_plus
l_int|3
)paren
op_rshift
l_int|2
suffix:semicolon
id|esp-&gt;min_period
op_assign
(paren
id|esp-&gt;min_period
op_plus
l_int|3
)paren
op_rshift
l_int|2
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg1
comma
id|esp-&gt;config1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|esp-&gt;erev
)paren
(brace
r_case
id|esp100
suffix:colon
multiline_comment|/* nothing to do */
r_break
suffix:semicolon
r_case
id|esp100a
suffix:colon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg2
comma
id|esp-&gt;config2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|esp236
suffix:colon
multiline_comment|/* Slow 236 */
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg2
comma
id|esp-&gt;config2
)paren
suffix:semicolon
id|esp-&gt;prev_cfg3
op_assign
id|esp-&gt;config3
(braket
l_int|0
)braket
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg3
comma
id|esp-&gt;prev_cfg3
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fas366
suffix:colon
id|panic
c_func
(paren
l_string|&quot;esp: FAS366 support not present, please notify &quot;
l_string|&quot;jongk@cs.utwente.nl&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fas216
suffix:colon
r_case
id|fas236
suffix:colon
r_case
id|fsc
suffix:colon
multiline_comment|/* Fast ESP variants */
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg2
comma
id|esp-&gt;config2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|esp-&gt;config3
(braket
id|i
)braket
op_or_assign
id|ESP_CONFIG3_FCLK
suffix:semicolon
)brace
id|esp-&gt;prev_cfg3
op_assign
id|esp-&gt;config3
(braket
l_int|0
)braket
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg3
comma
id|esp-&gt;prev_cfg3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;diff
)paren
(brace
id|esp-&gt;radelay
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|esp-&gt;radelay
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* Different timeout constant for these chips */
id|esp-&gt;neg_defp
op_assign
id|FSC_NEG_DEFP
c_func
(paren
id|esp-&gt;cfreq
comma
(paren
id|esp-&gt;cfact
op_eq
id|ESP_CCF_F0
ques
c_cond
id|ESP_CCF_F7
op_plus
l_int|1
suffix:colon
id|esp-&gt;cfact
)paren
)paren
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_timeo
comma
id|esp-&gt;neg_defp
)paren
suffix:semicolon
multiline_comment|/* Enable Active Negotiation if possible */
r_if
c_cond
(paren
(paren
id|esp-&gt;erev
op_eq
id|fsc
)paren
op_logical_and
op_logical_neg
id|esp-&gt;diff
)paren
(brace
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg4
comma
id|ESP_CONFIG4_EAN
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|fas100a
suffix:colon
multiline_comment|/* Fast 100a */
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg2
comma
id|esp-&gt;config2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|esp-&gt;config3
(braket
id|i
)braket
op_or_assign
id|ESP_CONFIG3_FCLOCK
suffix:semicolon
)brace
id|esp-&gt;prev_cfg3
op_assign
id|esp-&gt;config3
(braket
l_int|0
)braket
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg3
comma
id|esp-&gt;prev_cfg3
)paren
suffix:semicolon
id|esp-&gt;radelay
op_assign
l_int|32
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;esp: what could it be... I wonder...&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Eat any bitrot in the chip */
id|trash
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_intrpt
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
multiline_comment|/* This places the ESP into a known state at boot time. */
DECL|function|esp_bootup_reset
r_void
id|esp_bootup_reset
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
r_volatile
id|unchar
id|trash
suffix:semicolon
multiline_comment|/* Reset the DMA */
r_if
c_cond
(paren
id|esp-&gt;dma_reset
)paren
(brace
id|esp
op_member_access_from_pointer
id|dma_reset
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset the ESP */
id|esp_reset_esp
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
multiline_comment|/* Reset the SCSI bus, but tell ESP not to generate an irq */
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg1
comma
(paren
id|esp_read
c_func
(paren
id|eregs-&gt;esp_cfg1
)paren
op_or
id|ESP_CONFIG1_SRRDISAB
)paren
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_RS
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|400
)paren
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg1
comma
id|esp-&gt;config1
)paren
suffix:semicolon
multiline_comment|/* Eat any bitrot in the chip and we are done... */
id|trash
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_intrpt
)paren
suffix:semicolon
)brace
multiline_comment|/* Allocate structure and insert basic data such as SCSI chip frequency&n; * data and a pointer to the device&n; */
DECL|function|esp_allocate
r_struct
id|NCR_ESP
op_star
id|esp_allocate
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_void
op_star
id|esp_dev
)paren
(brace
r_struct
id|NCR_ESP
op_star
id|esp
comma
op_star
id|elink
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|esp_host
suffix:semicolon
id|esp_host
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
r_sizeof
(paren
r_struct
id|NCR_ESP
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|esp_host
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Cannot register ESP SCSI host&quot;
)paren
suffix:semicolon
)brace
id|esp
op_assign
(paren
r_struct
id|NCR_ESP
op_star
)paren
id|esp_host-&gt;hostdata
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|esp
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;No esp in hostdata&quot;
)paren
suffix:semicolon
)brace
id|esp-&gt;ehost
op_assign
id|esp_host
suffix:semicolon
id|esp-&gt;edev
op_assign
id|esp_dev
suffix:semicolon
id|esp-&gt;esp_id
op_assign
id|nesps
op_increment
suffix:semicolon
multiline_comment|/* Set bitshift value (only used on Amiga with multiple ESPs) */
id|esp-&gt;shift
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Put into the chain of esp chips detected */
r_if
c_cond
(paren
id|espchain
)paren
(brace
id|elink
op_assign
id|espchain
suffix:semicolon
r_while
c_loop
(paren
id|elink-&gt;next
)paren
(brace
id|elink
op_assign
id|elink-&gt;next
suffix:semicolon
)brace
id|elink-&gt;next
op_assign
id|esp
suffix:semicolon
)brace
r_else
(brace
id|espchain
op_assign
id|esp
suffix:semicolon
)brace
id|esp-&gt;next
op_assign
l_int|0
suffix:semicolon
r_return
id|esp
suffix:semicolon
)brace
DECL|function|esp_deallocate
r_void
id|esp_deallocate
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
(brace
r_struct
id|NCR_ESP
op_star
id|elink
suffix:semicolon
r_if
c_cond
(paren
id|espchain
op_eq
id|esp
)paren
(brace
id|espchain
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|elink
op_assign
id|espchain
suffix:semicolon
id|elink
op_logical_and
(paren
id|elink-&gt;next
op_ne
id|esp
)paren
suffix:semicolon
id|elink
op_assign
id|elink-&gt;next
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|elink
)paren
(brace
id|elink-&gt;next
op_assign
id|esp-&gt;next
suffix:semicolon
)brace
)brace
id|nesps
op_decrement
suffix:semicolon
)brace
multiline_comment|/* Complete initialization of ESP structure and device&n; * Caller must have initialized appropriate parts of the ESP structure&n; * between the call to esp_allocate and this function.&n; */
DECL|function|esp_initialize
r_void
id|esp_initialize
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
(brace
r_struct
id|ESP_regs
op_star
id|eregs
op_assign
id|esp-&gt;eregs
suffix:semicolon
r_int
r_int
id|fmhz
suffix:semicolon
id|unchar
id|ccf
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Check out the clock properties of the chip. */
multiline_comment|/* This is getting messy but it has to be done&n;&t; * correctly or else you get weird behavior all&n;&t; * over the place.  We are trying to basically&n;&t; * figure out three pieces of information.&n;&t; *&n;&t; * a) Clock Conversion Factor&n;&t; *&n;&t; *    This is a representation of the input&n;&t; *    crystal clock frequency going into the&n;&t; *    ESP on this machine.  Any operation whose&n;&t; *    timing is longer than 400ns depends on this&n;&t; *    value being correct.  For example, you&squot;ll&n;&t; *    get blips for arbitration/selection during&n;&t; *    high load or with multiple targets if this&n;&t; *    is not set correctly.&n;&t; *&n;&t; * b) Selection Time-Out&n;&t; *&n;&t; *    The ESP isn&squot;t very bright and will arbitrate&n;&t; *    for the bus and try to select a target&n;&t; *    forever if you let it.  This value tells&n;&t; *    the ESP when it has taken too long to&n;&t; *    negotiate and that it should interrupt&n;&t; *    the CPU so we can see what happened.&n;&t; *    The value is computed as follows (from&n;&t; *    NCR/Symbios chip docs).&n;&t; *&n;&t; *          (Time Out Period) *  (Input Clock)&n;&t; *    STO = ----------------------------------&n;&t; *          (8192) * (Clock Conversion Factor)&n;&t; *&n;&t; *    You usually want the time out period to be&n;&t; *    around 250ms, I think we&squot;ll set it a little&n;&t; *    bit higher to account for fully loaded SCSI&n;&t; *    bus&squot;s and slow devices that don&squot;t respond so&n;&t; *    quickly to selection attempts. (yeah, I know&n;&t; *    this is out of spec. but there is a lot of&n;&t; *    buggy pieces of firmware out there so bite me)&n;&t; *&n;&t; * c) Imperical constants for synchronous offset&n;&t; *    and transfer period register values&n;&t; *&n;&t; *    This entails the smallest and largest sync&n;&t; *    period we could ever handle on this ESP.&n;&t; */
id|fmhz
op_assign
id|esp-&gt;cfreq
suffix:semicolon
r_if
c_cond
(paren
id|fmhz
op_le
(paren
l_int|5000000
)paren
)paren
(brace
id|ccf
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|ccf
op_assign
(paren
(paren
(paren
l_int|5000000
op_minus
l_int|1
)paren
op_plus
(paren
id|fmhz
)paren
)paren
op_div
(paren
l_int|5000000
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ccf
op_logical_or
id|ccf
OG
l_int|8
)paren
(brace
multiline_comment|/* If we can&squot;t find anything reasonable,&n;&t;&t; * just assume 20MHZ.  This is the clock&n;&t;&t; * frequency of the older sun4c&squot;s where I&squot;ve&n;&t;&t; * been unable to find the clock-frequency&n;&t;&t; * PROM property.  All other machines provide&n;&t;&t; * useful values it seems.&n;&t;&t; */
id|ccf
op_assign
id|ESP_CCF_F4
suffix:semicolon
id|fmhz
op_assign
(paren
l_int|20000000
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ccf
op_eq
(paren
id|ESP_CCF_F7
op_plus
l_int|1
)paren
)paren
(brace
id|esp-&gt;cfact
op_assign
id|ESP_CCF_F0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ccf
op_eq
id|ESP_CCF_NEVER
)paren
(brace
id|esp-&gt;cfact
op_assign
id|ESP_CCF_F2
suffix:semicolon
)brace
r_else
id|esp-&gt;cfact
op_assign
id|ccf
suffix:semicolon
id|esp-&gt;cfreq
op_assign
id|fmhz
suffix:semicolon
id|esp-&gt;ccycle
op_assign
id|ESP_MHZ_TO_CYCLE
c_func
(paren
id|fmhz
)paren
suffix:semicolon
id|esp-&gt;ctick
op_assign
id|ESP_TICK
c_func
(paren
id|ccf
comma
id|esp-&gt;ccycle
)paren
suffix:semicolon
id|esp-&gt;neg_defp
op_assign
id|ESP_NEG_DEFP
c_func
(paren
id|fmhz
comma
id|ccf
)paren
suffix:semicolon
id|esp-&gt;sync_defp
op_assign
id|SYNC_DEFP_SLOW
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SCSI ID %d Clk %dMHz CCF=%d TOut %d &quot;
comma
id|esp-&gt;scsi_id
comma
(paren
id|esp-&gt;cfreq
op_div
l_int|1000000
)paren
comma
id|ccf
comma
(paren
r_int
)paren
id|esp-&gt;neg_defp
)paren
suffix:semicolon
multiline_comment|/* Fill in ehost data */
id|esp-&gt;ehost-&gt;base
op_assign
(paren
r_int
r_int
)paren
id|eregs
suffix:semicolon
id|esp-&gt;ehost-&gt;this_id
op_assign
id|esp-&gt;scsi_id
suffix:semicolon
id|esp-&gt;ehost-&gt;irq
op_assign
id|esp-&gt;irq
suffix:semicolon
multiline_comment|/* SCSI id mask */
id|esp-&gt;scsi_id_mask
op_assign
(paren
l_int|1
op_lshift
id|esp-&gt;scsi_id
)paren
suffix:semicolon
multiline_comment|/* Probe the revision of this esp */
id|esp-&gt;config1
op_assign
(paren
id|ESP_CONFIG1_PENABLE
op_or
(paren
id|esp-&gt;scsi_id
op_amp
l_int|7
)paren
)paren
suffix:semicolon
id|esp-&gt;config2
op_assign
(paren
id|ESP_CONFIG2_SCSI2ENAB
op_or
id|ESP_CONFIG2_REGPARITY
)paren
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg2
comma
id|esp-&gt;config2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|esp_read
c_func
(paren
id|eregs-&gt;esp_cfg2
)paren
op_amp
op_complement
(paren
id|ESP_CONFIG2_MAGIC
)paren
)paren
op_ne
(paren
id|ESP_CONFIG2_SCSI2ENAB
op_or
id|ESP_CONFIG2_REGPARITY
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NCR53C90(esp100)&bslash;n&quot;
)paren
suffix:semicolon
id|esp-&gt;erev
op_assign
id|esp100
suffix:semicolon
)brace
r_else
(brace
id|esp-&gt;config2
op_assign
l_int|0
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg2
comma
l_int|0
)paren
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg3
comma
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp_read
c_func
(paren
id|eregs-&gt;esp_cfg3
)paren
op_ne
l_int|5
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NCR53C90A(esp100a)&bslash;n&quot;
)paren
suffix:semicolon
id|esp-&gt;erev
op_assign
id|esp100a
suffix:semicolon
)brace
r_else
(brace
r_int
id|target
suffix:semicolon
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
OL
l_int|8
suffix:semicolon
id|target
op_increment
)paren
(brace
id|esp-&gt;config3
(braket
id|target
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|esp-&gt;prev_cfg3
op_assign
l_int|0
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg3
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccf
OG
id|ESP_CCF_F5
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NCR53C9XF(espfast)&bslash;n&quot;
)paren
suffix:semicolon
id|esp-&gt;erev
op_assign
id|fast
suffix:semicolon
id|esp-&gt;sync_defp
op_assign
id|SYNC_DEFP_FAST
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;NCR53C9x(esp236)&bslash;n&quot;
)paren
suffix:semicolon
id|esp-&gt;erev
op_assign
id|esp236
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Initialize the command queues */
id|esp-&gt;current_SC
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;disconnected_SC
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;issue_SC
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear the state machines. */
id|esp-&gt;targets_present
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;resetting_bus
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;fas_premature_intr_workaround
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|esp-&gt;espcmdlog
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|esp-&gt;espcmdent
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|esp-&gt;cur_msgout
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;cur_msgin
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|esp-&gt;prevmsgout
op_assign
id|esp-&gt;prevmsgin
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;msgout_len
op_assign
id|esp-&gt;msgin_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear the one behind caches to hold unmatchable values. */
id|esp-&gt;prev_soff
op_assign
id|esp-&gt;prev_stp
op_assign
id|esp-&gt;prev_cfg3
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* Reset the thing before we try anything... */
id|esp_bootup_reset
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
id|esps_in_use
op_increment
suffix:semicolon
)brace
multiline_comment|/* The info function will return whatever useful&n; * information the developer sees fit.  If not provided, then&n; * the name field will be used instead.&n; */
DECL|function|esp_info
r_const
r_char
op_star
id|esp_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_struct
id|NCR_ESP
op_star
id|esp
suffix:semicolon
id|esp
op_assign
(paren
r_struct
id|NCR_ESP
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_switch
c_cond
(paren
id|esp-&gt;erev
)paren
(brace
r_case
id|esp100
suffix:colon
r_return
l_string|&quot;ESP100 (NCR53C90)&quot;
suffix:semicolon
r_case
id|esp100a
suffix:colon
r_return
l_string|&quot;ESP100A (NCR53C90A)&quot;
suffix:semicolon
r_case
id|esp236
suffix:colon
r_return
l_string|&quot;ESP236 (NCR53C9x)&quot;
suffix:semicolon
r_case
id|fas216
suffix:colon
r_return
l_string|&quot;Emulex FAS216&quot;
suffix:semicolon
r_case
id|fas236
suffix:colon
r_return
l_string|&quot;Emulex FAS236&quot;
suffix:semicolon
r_case
id|fas366
suffix:colon
r_return
l_string|&quot;QLogic FAS366&quot;
suffix:semicolon
r_case
id|fas100a
suffix:colon
r_return
l_string|&quot;FPESP100A&quot;
suffix:semicolon
r_case
id|fsc
suffix:colon
r_return
l_string|&quot;Symbios Logic 53CF9x-2&quot;
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;Bogon ESP revision&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/* From Wolfgang Stanglmeier&squot;s NCR scsi driver. */
DECL|struct|info_str
r_struct
id|info_str
(brace
DECL|member|buffer
r_char
op_star
id|buffer
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|pos
r_int
id|pos
suffix:semicolon
)brace
suffix:semicolon
DECL|function|copy_mem_info
r_static
r_void
id|copy_mem_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OG
id|info-&gt;length
)paren
id|len
op_assign
id|info-&gt;length
op_minus
id|info-&gt;pos
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OL
id|info-&gt;offset
)paren
(brace
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;pos
OL
id|info-&gt;offset
)paren
(brace
id|data
op_add_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|info-&gt;buffer
op_plus
id|info-&gt;pos
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
)brace
)brace
DECL|function|copy_info
r_static
r_int
id|copy_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
l_int|81
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|len
op_assign
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
id|copy_mem_info
c_func
(paren
id|info
comma
id|buf
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|esp_host_info
r_static
r_int
id|esp_host_info
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_char
op_star
id|ptr
comma
id|off_t
id|offset
comma
r_int
id|len
)paren
(brace
r_struct
id|info_str
id|info
suffix:semicolon
r_int
id|i
suffix:semicolon
id|info.buffer
op_assign
id|ptr
suffix:semicolon
id|info.length
op_assign
id|len
suffix:semicolon
id|info.offset
op_assign
id|offset
suffix:semicolon
id|info.pos
op_assign
l_int|0
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;ESP Host Adapter:&bslash;n&quot;
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;&bslash;tESP Model&bslash;t&bslash;t&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|esp-&gt;erev
)paren
(brace
r_case
id|esp100
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;ESP100 (NCR53C90)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|esp100a
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;ESP100A (NCR53C90A)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|esp236
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;ESP236 (NCR53C9x)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fas216
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Emulex FAS216&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fas236
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Emulex FAS236&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fas100a
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;FPESP100A&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fast
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Generic FAST&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fas366
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;QLogic FAS366&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fsc
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Symbios Logic 53C9x-2&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|espunknown
suffix:colon
r_default
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Unknown!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;&bslash;tLive Targets&bslash;t&bslash;t[ &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;targets_present
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;%d &quot;
comma
id|i
)paren
suffix:semicolon
)brace
)brace
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;]&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Now describe the state of each existing target. */
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Target #&bslash;tconfig3&bslash;t&bslash;tSync Capabilities&bslash;tDisconnect&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;targets_present
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|Scsi_Device
op_star
id|SDptr
op_assign
id|esp-&gt;ehost-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
(paren
id|SDptr-&gt;host
op_ne
id|esp-&gt;ehost
)paren
op_logical_and
(paren
id|SDptr-&gt;id
op_ne
id|i
)paren
op_logical_and
(paren
id|SDptr-&gt;next
)paren
)paren
(brace
id|SDptr
op_assign
id|SDptr-&gt;next
suffix:semicolon
)brace
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;%d&bslash;t&bslash;t&quot;
comma
id|i
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;%08lx&bslash;t&quot;
comma
id|esp-&gt;config3
(braket
id|i
)braket
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;[%02lx,%02lx]&bslash;t&bslash;t&bslash;t&quot;
comma
id|SDptr-&gt;sync_max_offset
comma
id|SDptr-&gt;sync_min_period
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|SDptr-&gt;disconnect
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
id|info.pos
OG
id|info.offset
ques
c_cond
id|info.pos
op_minus
id|info.offset
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ESP proc filesystem code. */
DECL|function|esp_proc_info
r_int
id|esp_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
r_struct
id|NCR_ESP
op_star
id|esp
suffix:semicolon
r_if
c_cond
(paren
id|inout
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* not yet */
id|for_each_esp
c_func
(paren
id|esp
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;ehost-&gt;host_no
op_eq
id|hostno
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|esp
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start
)paren
(brace
op_star
id|start
op_assign
id|buffer
suffix:semicolon
)brace
r_return
id|esp_host_info
c_func
(paren
id|esp
comma
id|buffer
comma
id|offset
comma
id|length
)paren
suffix:semicolon
)brace
DECL|function|esp_get_dmabufs
r_static
r_void
id|esp_get_dmabufs
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
r_if
c_cond
(paren
id|sp-&gt;use_sg
op_eq
l_int|0
)paren
(brace
id|sp-&gt;SCp.this_residual
op_assign
id|sp-&gt;request_bufflen
suffix:semicolon
id|sp-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|sp-&gt;request_buffer
suffix:semicolon
id|sp-&gt;SCp.buffers_residual
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;dma_mmu_get_scsi_one
)paren
id|esp
op_member_access_from_pointer
id|dma_mmu_get_scsi_one
c_func
(paren
id|esp
comma
id|sp
)paren
suffix:semicolon
r_else
id|sp-&gt;SCp.have_data_in
op_assign
(paren
r_int
)paren
id|sp-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|virt_to_phys
c_func
(paren
id|sp-&gt;request_buffer
)paren
suffix:semicolon
)brace
r_else
(brace
id|sp-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|sp-&gt;buffer
suffix:semicolon
id|sp-&gt;SCp.buffers_residual
op_assign
id|sp-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
id|sp-&gt;SCp.this_residual
op_assign
id|sp-&gt;SCp.buffer-&gt;length
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;dma_mmu_get_scsi_sgl
)paren
id|esp
op_member_access_from_pointer
id|dma_mmu_get_scsi_sgl
c_func
(paren
id|esp
comma
id|sp
)paren
suffix:semicolon
r_else
id|sp-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|virt_to_phys
c_func
(paren
id|sp-&gt;SCp.buffer-&gt;address
)paren
suffix:semicolon
)brace
)brace
DECL|function|esp_release_dmabufs
r_static
r_void
id|esp_release_dmabufs
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
r_if
c_cond
(paren
id|sp-&gt;use_sg
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;dma_mmu_release_scsi_one
)paren
id|esp
op_member_access_from_pointer
id|dma_mmu_release_scsi_one
c_func
(paren
id|esp
comma
id|sp
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|esp-&gt;dma_mmu_release_scsi_sgl
)paren
id|esp
op_member_access_from_pointer
id|dma_mmu_release_scsi_sgl
c_func
(paren
id|esp
comma
id|sp
)paren
suffix:semicolon
)brace
)brace
DECL|function|esp_restore_pointers
r_static
r_void
id|esp_restore_pointers
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
r_struct
id|esp_pointers
op_star
id|ep
op_assign
op_amp
id|esp-&gt;data_pointers
(braket
id|sp-&gt;target
)braket
suffix:semicolon
id|sp-&gt;SCp.ptr
op_assign
id|ep-&gt;saved_ptr
suffix:semicolon
id|sp-&gt;SCp.buffer
op_assign
id|ep-&gt;saved_buffer
suffix:semicolon
id|sp-&gt;SCp.this_residual
op_assign
id|ep-&gt;saved_this_residual
suffix:semicolon
id|sp-&gt;SCp.buffers_residual
op_assign
id|ep-&gt;saved_buffers_residual
suffix:semicolon
)brace
DECL|function|esp_save_pointers
r_static
r_void
id|esp_save_pointers
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
r_struct
id|esp_pointers
op_star
id|ep
op_assign
op_amp
id|esp-&gt;data_pointers
(braket
id|sp-&gt;target
)braket
suffix:semicolon
id|ep-&gt;saved_ptr
op_assign
id|sp-&gt;SCp.ptr
suffix:semicolon
id|ep-&gt;saved_buffer
op_assign
id|sp-&gt;SCp.buffer
suffix:semicolon
id|ep-&gt;saved_this_residual
op_assign
id|sp-&gt;SCp.this_residual
suffix:semicolon
id|ep-&gt;saved_buffers_residual
op_assign
id|sp-&gt;SCp.buffers_residual
suffix:semicolon
)brace
multiline_comment|/* Some rules:&n; *&n; *   1) Never ever panic while something is live on the bus.&n; *      If there is to be any chance of syncing the disks this&n; *      rule is to be obeyed.&n; *&n; *   2) Any target that causes a foul condition will no longer&n; *      have synchronous transfers done to it, no questions&n; *      asked.&n; *&n; *   3) Keep register accesses to a minimum.  Think about some&n; *      day when we have Xbus machines this is running on and&n; *      the ESP chip is on the other end of the machine on a&n; *      different board from the cpu where this is running.&n; */
multiline_comment|/* Fire off a command.  We assume the bus is free and that the only&n; * case where we could see an interrupt is where we have disconnected&n; * commands active and they are trying to reselect us.&n; */
DECL|function|esp_check_cmd
r_static
r_inline
r_void
id|esp_check_cmd
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
r_switch
c_cond
(paren
id|sp-&gt;cmd_len
)paren
(brace
r_case
l_int|6
suffix:colon
r_case
l_int|10
suffix:colon
r_case
l_int|12
suffix:colon
id|esp-&gt;esp_slowcmd
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|esp-&gt;esp_slowcmd
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;esp_scmdleft
op_assign
id|sp-&gt;cmd_len
suffix:semicolon
id|esp-&gt;esp_scmdp
op_assign
op_amp
id|sp-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
DECL|function|build_sync_nego_msg
r_static
r_inline
r_void
id|build_sync_nego_msg
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_int
id|period
comma
r_int
id|offset
)paren
(brace
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|1
)braket
op_assign
l_int|3
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|2
)braket
op_assign
id|EXTENDED_SDTR
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|3
)braket
op_assign
id|period
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|4
)braket
op_assign
id|offset
suffix:semicolon
id|esp-&gt;msgout_len
op_assign
l_int|5
suffix:semicolon
)brace
DECL|function|esp_exec_cmd
r_static
r_void
id|esp_exec_cmd
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
(brace
r_struct
id|ESP_regs
op_star
id|eregs
op_assign
id|esp-&gt;eregs
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCptr
suffix:semicolon
id|Scsi_Device
op_star
id|SDptr
suffix:semicolon
r_volatile
id|unchar
op_star
id|cmdp
op_assign
id|esp-&gt;esp_command
suffix:semicolon
r_int
r_char
id|the_esp_command
suffix:semicolon
r_int
id|lun
comma
id|target
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Hold off if we have disconnected commands and&n;&t; * an IRQ is showing...&n;&t; */
r_if
c_cond
(paren
id|esp-&gt;disconnected_SC
op_logical_and
id|esp
op_member_access_from_pointer
id|dma_irq_p
c_func
(paren
id|esp
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Grab first member of the issue queue. */
id|SCptr
op_assign
id|esp-&gt;current_SC
op_assign
id|remove_first_SC
c_func
(paren
op_amp
id|esp-&gt;issue_SC
)paren
suffix:semicolon
multiline_comment|/* Safe to panic here because current_SC is null. */
r_if
c_cond
(paren
op_logical_neg
id|SCptr
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;esp: esp_exec_cmd and issue queue is NULL&quot;
)paren
suffix:semicolon
)brace
id|SDptr
op_assign
id|SCptr-&gt;device
suffix:semicolon
id|lun
op_assign
id|SCptr-&gt;lun
suffix:semicolon
id|target
op_assign
id|SCptr-&gt;target
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Send it out whole, or piece by piece?   The ESP&n;&t; * only knows how to automatically send out 6, 10,&n;&t; * and 12 byte commands.  I used to think that the&n;&t; * Linux SCSI code would never throw anything other&n;&t; * than that to us, but then again there is the&n;&t; * SCSI generic driver which can send us anything.&n;&t; */
id|esp_check_cmd
c_func
(paren
id|esp
comma
id|SCptr
)paren
suffix:semicolon
multiline_comment|/* If arbitration/selection is successful, the ESP will leave&n;&t; * ATN asserted, causing the target to go into message out&n;&t; * phase.  The ESP will feed the target the identify and then&n;&t; * the target can only legally go to one of command,&n;&t; * datain/out, status, or message in phase, or stay in message&n;&t; * out phase (should we be trying to send a sync negotiation&n;&t; * message after the identify).  It is not allowed to drop&n;&t; * BSY, but some buggy targets do and we check for this&n;&t; * condition in the selection complete code.  Most of the time&n;&t; * we&squot;ll make the command bytes available to the ESP and it&n;&t; * will not interrupt us until it finishes command phase, we&n;&t; * cannot do this for command sizes the ESP does not&n;&t; * understand and in this case we&squot;ll get interrupted right&n;&t; * when the target goes into command phase.&n;&t; *&n;&t; * It is absolutely _illegal_ in the presence of SCSI-2 devices&n;&t; * to use the ESP select w/o ATN command.  When SCSI-2 devices are&n;&t; * present on the bus we _must_ always go straight to message out&n;&t; * phase with an identify message for the target.  Being that&n;&t; * selection attempts in SCSI-1 w/o ATN was an option, doing SCSI-2&n;&t; * selections should not confuse SCSI-1 we hope.&n;&t; */
r_if
c_cond
(paren
id|SDptr-&gt;sync
)paren
(brace
multiline_comment|/* this targets sync is known */
macro_line|#ifdef CONFIG_SCSI_MAC_ESP
id|do_sync_known
suffix:colon
macro_line|#endif
r_if
c_cond
(paren
id|SDptr-&gt;disconnect
)paren
(brace
op_star
id|cmdp
op_increment
op_assign
id|IDENTIFY
c_func
(paren
l_int|1
comma
id|lun
)paren
suffix:semicolon
)brace
r_else
op_star
id|cmdp
op_increment
op_assign
id|IDENTIFY
c_func
(paren
l_int|0
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;esp_slowcmd
)paren
(brace
id|the_esp_command
op_assign
(paren
id|ESP_CMD_SELAS
op_or
id|ESP_CMD_DMA
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_slct_stop
)paren
suffix:semicolon
)brace
r_else
(brace
id|the_esp_command
op_assign
(paren
id|ESP_CMD_SELA
op_or
id|ESP_CMD_DMA
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_slct_norm
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;targets_present
op_amp
(paren
l_int|1
op_lshift
id|target
)paren
)paren
op_logical_or
op_logical_neg
(paren
id|SDptr-&gt;disconnect
)paren
)paren
(brace
multiline_comment|/* After the bootup SCSI code sends both the&n;&t;&t; * TEST_UNIT_READY and INQUIRY commands we want&n;&t;&t; * to at least attempt allowing the device to&n;&t;&t; * disconnect.&n;&t;&t; */
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;esp: Selecting device for first time. target=%d &quot;
l_string|&quot;lun=%d&bslash;n&quot;
comma
id|target
comma
id|SCptr-&gt;lun
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SDptr-&gt;borken
op_logical_and
op_logical_neg
id|SDptr-&gt;disconnect
)paren
(brace
id|SDptr-&gt;disconnect
op_assign
l_int|1
suffix:semicolon
)brace
op_star
id|cmdp
op_increment
op_assign
id|IDENTIFY
c_func
(paren
l_int|0
comma
id|lun
)paren
suffix:semicolon
id|esp-&gt;prevmsgout
op_assign
id|NOP
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_slct_norm
)paren
suffix:semicolon
id|the_esp_command
op_assign
(paren
id|ESP_CMD_SELA
op_or
id|ESP_CMD_DMA
)paren
suffix:semicolon
multiline_comment|/* Take no chances... */
id|SDptr-&gt;sync_max_offset
op_assign
l_int|0
suffix:semicolon
id|SDptr-&gt;sync_min_period
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_int
id|toshiba_cdrom_hwbug_wkaround
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI_MAC_ESP
multiline_comment|/* Never allow synchronous transfers (disconnect OK) on&n;&t;&t; * Macintosh. Well, maybe later when we figured out how to &n;&t;&t; * do DMA on the machines that support it ...&n;&t;&t; */
id|SDptr-&gt;disconnect
op_assign
l_int|1
suffix:semicolon
id|SDptr-&gt;sync_max_offset
op_assign
l_int|0
suffix:semicolon
id|SDptr-&gt;sync_min_period
op_assign
l_int|0
suffix:semicolon
id|SDptr-&gt;sync
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|0
suffix:semicolon
r_goto
id|do_sync_known
suffix:semicolon
macro_line|#endif
multiline_comment|/* We&squot;ve talked to this guy before,&n;&t;&t; * but never negotiated.  Let&squot;s try&n;&t;&t; * sync negotiation.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|SDptr-&gt;borken
)paren
(brace
r_if
c_cond
(paren
(paren
id|SDptr-&gt;type
op_eq
id|TYPE_ROM
)paren
op_logical_and
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|SDptr-&gt;vendor
comma
l_string|&quot;TOSHIBA&quot;
comma
l_int|7
)paren
)paren
)paren
(brace
multiline_comment|/* Nice try sucker... */
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;esp%d: Disabling sync for buggy &quot;
l_string|&quot;Toshiba CDROM.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|toshiba_cdrom_hwbug_wkaround
op_assign
l_int|1
suffix:semicolon
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
id|esp-&gt;sync_defp
comma
l_int|15
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|SDptr-&gt;sync
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* A fix for broken SCSI1 targets, when they disconnect&n;&t;&t; * they lock up the bus and confuse ESP.  So disallow&n;&t;&t; * disconnects for SCSI1 targets for now until we&n;&t;&t; * find a better fix.&n;&t;&t; *&n;&t;&t; * Addendum: This is funny, I figured out what was going&n;&t;&t; *           on.  The blotzed SCSI1 target would disconnect,&n;&t;&t; *           one of the other SCSI2 targets or both would be&n;&t;&t; *           disconnected as well.  The SCSI1 target would&n;&t;&t; *           stay disconnected long enough that we start&n;&t;&t; *           up a command on one of the SCSI2 targets.  As&n;&t;&t; *           the ESP is arbitrating for the bus the SCSI1&n;&t;&t; *           target begins to arbitrate as well to reselect&n;&t;&t; *           the ESP.  The SCSI1 target refuses to drop it&squot;s&n;&t;&t; *           ID bit on the data bus even though the ESP is&n;&t;&t; *           at ID 7 and is the obvious winner for any&n;&t;&t; *           arbitration.  The ESP is a poor sport and refuses&n;&t;&t; *           to lose arbitration, it will continue indefinately&n;&t;&t; *           trying to arbitrate for the bus and can only be&n;&t;&t; *           stopped via a chip reset or SCSI bus reset.&n;&t;&t; *           Therefore _no_ disconnects for SCSI1 targets&n;&t;&t; *           thank you very much. ;-)&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|SDptr-&gt;scsi_level
OL
l_int|3
)paren
op_logical_and
(paren
id|SDptr-&gt;type
op_ne
id|TYPE_TAPE
)paren
)paren
op_logical_or
id|toshiba_cdrom_hwbug_wkaround
op_logical_or
id|SDptr-&gt;borken
)paren
(brace
id|ESPMISC
c_func
(paren
(paren
id|KERN_INFO
l_string|&quot;esp%d: Disabling DISCONNECT for target %d &quot;
l_string|&quot;lun %d&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|SCptr-&gt;target
comma
id|SCptr-&gt;lun
)paren
)paren
suffix:semicolon
id|SDptr-&gt;disconnect
op_assign
l_int|0
suffix:semicolon
op_star
id|cmdp
op_increment
op_assign
id|IDENTIFY
c_func
(paren
l_int|0
comma
id|lun
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|cmdp
op_increment
op_assign
id|IDENTIFY
c_func
(paren
l_int|1
comma
id|lun
)paren
suffix:semicolon
)brace
multiline_comment|/* ESP fifo is only so big...&n;&t;&t; * Make this look like a slow command.&n;&t;&t; */
id|esp-&gt;esp_slowcmd
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;esp_scmdleft
op_assign
id|SCptr-&gt;cmd_len
suffix:semicolon
id|esp-&gt;esp_scmdp
op_assign
op_amp
id|SCptr-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
id|the_esp_command
op_assign
(paren
id|ESP_CMD_SELAS
op_or
id|ESP_CMD_DMA
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_slct_msg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|esp-&gt;esp_slowcmd
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCptr-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|cmdp
op_increment
op_assign
id|SCptr-&gt;cmnd
(braket
id|i
)braket
suffix:semicolon
)brace
id|esp_write
c_func
(paren
id|eregs-&gt;esp_busid
comma
(paren
id|target
op_amp
l_int|7
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;prev_soff
op_ne
id|SDptr-&gt;sync_max_offset
op_logical_or
id|esp-&gt;prev_stp
op_ne
id|SDptr-&gt;sync_min_period
op_logical_or
(paren
id|esp-&gt;erev
OG
id|esp100a
op_logical_and
id|esp-&gt;prev_cfg3
op_ne
id|esp-&gt;config3
(braket
id|target
)braket
)paren
)paren
(brace
id|esp-&gt;prev_soff
op_assign
id|SDptr-&gt;sync_max_offset
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_soff
comma
id|esp-&gt;prev_soff
)paren
suffix:semicolon
id|esp-&gt;prev_stp
op_assign
id|SDptr-&gt;sync_min_period
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_stp
comma
id|esp-&gt;prev_stp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
OG
id|esp100a
)paren
(brace
id|esp-&gt;prev_cfg3
op_assign
id|esp-&gt;config3
(braket
id|target
)braket
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg3
comma
id|esp-&gt;prev_cfg3
)paren
suffix:semicolon
)brace
)brace
id|i
op_assign
(paren
id|cmdp
op_minus
id|esp-&gt;esp_command
)paren
suffix:semicolon
multiline_comment|/* Set up the DMA and ESP counters */
r_if
c_cond
(paren
id|esp-&gt;do_pio_cmds
)paren
(brace
r_int
id|j
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t;&t; * XXX MSch:&n;&t;&t; *&n;&t;&t; * It seems this is required, at least to clean up&n;&t;&t; * after failed commands when using PIO mode ...&n;&t;&t; */
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
(brace
id|esp_write
c_func
(paren
id|eregs-&gt;esp_fdata
comma
id|esp-&gt;esp_command
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
id|the_esp_command
op_and_assign
op_complement
id|ESP_CMD_DMA
suffix:semicolon
multiline_comment|/* Tell ESP to &quot;go&quot;. */
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|the_esp_command
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Set up the ESP counters */
id|esp_write
c_func
(paren
id|eregs-&gt;esp_tclow
comma
id|i
)paren
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_tcmed
comma
l_int|0
)paren
suffix:semicolon
id|esp
op_member_access_from_pointer
id|dma_init_write
c_func
(paren
id|esp
comma
id|esp-&gt;esp_command_dvma
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* Tell ESP to &quot;go&quot;. */
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|the_esp_command
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Queue a SCSI command delivered from the mid-level Linux SCSI code. */
DECL|function|esp_queue
r_int
id|esp_queue
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|NCR_ESP
op_star
id|esp
suffix:semicolon
multiline_comment|/* Set up func ptr and initial driver cmd-phase. */
id|SCpnt-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|SCpnt-&gt;SCp.phase
op_assign
id|not_issued
suffix:semicolon
id|esp
op_assign
(paren
r_struct
id|NCR_ESP
op_star
)paren
id|SCpnt-&gt;host-&gt;hostdata
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;dma_led_on
)paren
(brace
id|esp
op_member_access_from_pointer
id|dma_led_on
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
multiline_comment|/* We use the scratch area. */
id|ESPQUEUE
c_func
(paren
(paren
l_string|&quot;esp_queue: target=%d lun=%d &quot;
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
)paren
)paren
suffix:semicolon
id|ESPDISC
c_func
(paren
(paren
l_string|&quot;N&lt;%02x,%02x&gt;&quot;
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
)paren
)paren
suffix:semicolon
id|esp_get_dmabufs
c_func
(paren
id|esp
comma
id|SCpnt
)paren
suffix:semicolon
id|esp_save_pointers
c_func
(paren
id|esp
comma
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/* FIXME for tag queueing */
id|SCpnt-&gt;SCp.Status
op_assign
id|CHECK_CONDITION
suffix:semicolon
id|SCpnt-&gt;SCp.Message
op_assign
l_int|0xff
suffix:semicolon
id|SCpnt-&gt;SCp.sent_command
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Place into our queue. */
r_if
c_cond
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
(brace
id|ESPQUEUE
c_func
(paren
(paren
l_string|&quot;RQSENSE&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|prepend_SC
c_func
(paren
op_amp
id|esp-&gt;issue_SC
comma
id|SCpnt
)paren
suffix:semicolon
)brace
r_else
(brace
id|ESPQUEUE
c_func
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|append_SC
c_func
(paren
op_amp
id|esp-&gt;issue_SC
comma
id|SCpnt
)paren
suffix:semicolon
)brace
multiline_comment|/* Run it now if we can. */
r_if
c_cond
(paren
op_logical_neg
id|esp-&gt;current_SC
op_logical_and
op_logical_neg
id|esp-&gt;resetting_bus
)paren
(brace
id|esp_exec_cmd
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Only queuing supported in this ESP driver. */
DECL|function|esp_command
r_int
id|esp_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
macro_line|#ifdef DEBUG_ESP
r_struct
id|NCR_ESP
op_star
id|esp
op_assign
(paren
r_struct
id|NCR_ESP
op_star
)paren
id|SCpnt-&gt;host-&gt;hostdata
suffix:semicolon
macro_line|#endif
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: esp_command() called...&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Dump driver state. */
DECL|function|esp_dump_cmd
r_static
r_void
id|esp_dump_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCptr
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;[tgt&lt;%02x&gt; lun&lt;%02x&gt; &quot;
l_string|&quot;pphase&lt;%s&gt; cphase&lt;%s&gt;]&quot;
comma
id|SCptr-&gt;target
comma
id|SCptr-&gt;lun
comma
id|phase_string
c_func
(paren
id|SCptr-&gt;SCp.sent_command
)paren
comma
id|phase_string
c_func
(paren
id|SCptr-&gt;SCp.phase
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|esp_dump_state
r_static
r_void
id|esp_dump_state
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
macro_line|#ifdef DEBUG_ESP_CMDS
r_int
id|i
suffix:semicolon
macro_line|#endif
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: dumping state&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
multiline_comment|/* Print DMA status */
id|esp
op_member_access_from_pointer
id|dma_dump_state
c_func
(paren
id|esp
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: SW [sreg&lt;%02x&gt; sstep&lt;%02x&gt; ireg&lt;%02x&gt;]&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;sreg
comma
id|esp-&gt;seqreg
comma
id|esp-&gt;ireg
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: HW reread [sreg&lt;%02x&gt; sstep&lt;%02x&gt; ireg&lt;%02x&gt;]&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|esp_read
c_func
(paren
id|eregs-&gt;esp_status
)paren
comma
id|esp_read
c_func
(paren
id|eregs-&gt;esp_sstep
)paren
comma
id|esp_read
c_func
(paren
id|eregs-&gt;esp_intrpt
)paren
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_ESP_CMDS
id|printk
c_func
(paren
l_string|&quot;esp%d: last ESP cmds [&quot;
comma
id|esp-&gt;esp_id
)paren
suffix:semicolon
id|i
op_assign
(paren
id|esp-&gt;espcmdent
op_minus
l_int|1
)paren
op_amp
l_int|31
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&lt;&quot;
)paren
suffix:semicolon
id|esp_print_cmd
c_func
(paren
id|esp-&gt;espcmdlog
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
id|i
op_assign
(paren
id|i
op_minus
l_int|1
)paren
op_amp
l_int|31
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&lt;&quot;
)paren
suffix:semicolon
id|esp_print_cmd
c_func
(paren
id|esp-&gt;espcmdlog
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
id|i
op_assign
(paren
id|i
op_minus
l_int|1
)paren
op_amp
l_int|31
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&lt;&quot;
)paren
suffix:semicolon
id|esp_print_cmd
c_func
(paren
id|esp-&gt;espcmdlog
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
id|i
op_assign
(paren
id|i
op_minus
l_int|1
)paren
op_amp
l_int|31
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&lt;&quot;
)paren
suffix:semicolon
id|esp_print_cmd
c_func
(paren
id|esp-&gt;espcmdlog
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* (DEBUG_ESP_CMDS) */
r_if
c_cond
(paren
id|SCptr
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: current command &quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp_dump_cmd
c_func
(paren
id|SCptr
)paren
suffix:semicolon
)brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|SCptr
op_assign
id|esp-&gt;disconnected_SC
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: disconnected &quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|SCptr
)paren
(brace
id|esp_dump_cmd
c_func
(paren
id|SCptr
)paren
suffix:semicolon
id|SCptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|SCptr-&gt;host_scribble
suffix:semicolon
)brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Abort a command. */
DECL|function|esp_abort
r_int
id|esp_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCptr
)paren
(brace
r_struct
id|NCR_ESP
op_star
id|esp
op_assign
(paren
r_struct
id|NCR_ESP
op_star
)paren
id|SCptr-&gt;host-&gt;hostdata
suffix:semicolon
r_struct
id|ESP_regs
op_star
id|eregs
op_assign
id|esp-&gt;eregs
suffix:semicolon
r_int
id|don
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Aborting command&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp_dump_state
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
multiline_comment|/* Wheee, if this is the current command on the bus, the&n;&t; * best we can do is assert ATN and wait for msgout phase.&n;&t; * This should even fix a hung SCSI bus when we lose state&n;&t; * in the driver and timeout because the eventual phase change&n;&t; * will cause the ESP to (eventually) give an interrupt.&n;&t; */
r_if
c_cond
(paren
id|esp-&gt;current_SC
op_eq
id|SCptr
)paren
(brace
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
op_assign
id|ABORT
suffix:semicolon
id|esp-&gt;msgout_len
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;msgout_ctr
op_assign
l_int|0
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_SATN
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_PENDING
suffix:semicolon
)brace
multiline_comment|/* If it is still in the issue queue then we can safely&n;&t; * call the completion routine and report abort success.&n;&t; */
id|don
op_assign
id|esp
op_member_access_from_pointer
id|dma_ports_p
c_func
(paren
id|esp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|don
)paren
(brace
id|esp
op_member_access_from_pointer
id|dma_ints_off
c_func
(paren
id|esp
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|esp-&gt;issue_SC
)paren
(brace
id|Scsi_Cmnd
op_star
op_star
id|prev
comma
op_star
id|this
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
(paren
op_amp
id|esp-&gt;issue_SC
)paren
comma
id|this
op_assign
id|esp-&gt;issue_SC
suffix:semicolon
id|this
suffix:semicolon
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
id|this-&gt;host_scribble
)paren
comma
id|this
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|this-&gt;host_scribble
)paren
(brace
r_if
c_cond
(paren
id|this
op_eq
id|SCptr
)paren
(brace
op_star
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|this-&gt;host_scribble
suffix:semicolon
id|this-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|esp_release_dmabufs
c_func
(paren
id|esp
comma
id|this
)paren
suffix:semicolon
id|this-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|this
op_member_access_from_pointer
id|done
c_func
(paren
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
id|don
)paren
(brace
id|esp
op_member_access_from_pointer
id|dma_ints_on
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Yuck, the command to abort is disconnected, it is not&n;&t; * worth trying to abort it now if something else is live&n;&t; * on the bus at this time.  So, we let the SCSI code wait&n;&t; * a little bit and try again later.&n;&t; */
r_if
c_cond
(paren
id|esp-&gt;current_SC
)paren
(brace
r_if
c_cond
(paren
id|don
)paren
(brace
id|esp
op_member_access_from_pointer
id|dma_ints_on
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_return
id|SCSI_ABORT_BUSY
suffix:semicolon
)brace
multiline_comment|/* It&squot;s disconnected, we have to reconnect to re-establish&n;&t; * the nexus and tell the device to abort.  However, we really&n;&t; * cannot &squot;reconnect&squot; per se, therefore we tell the upper layer&n;&t; * the safest thing we can.  This is, wait a bit, if nothing&n;&t; * happens, we are really hung so reset the bus.&n;&t; */
r_if
c_cond
(paren
id|don
)paren
(brace
id|esp
op_member_access_from_pointer
id|dma_ints_on
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
multiline_comment|/* We&squot;ve sent ESP_CMD_RS to the ESP, the interrupt had just&n; * arrived indicating the end of the SCSI bus reset.  Our job&n; * is to clean out the command queues and begin re-execution&n; * of SCSI commands once more.&n; */
DECL|function|esp_finish_reset
r_static
r_int
id|esp_finish_reset
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|Scsi_Cmnd
op_star
id|sp
op_assign
id|esp-&gt;current_SC
suffix:semicolon
multiline_comment|/* Clean up currently executing command, if any. */
r_if
c_cond
(paren
id|sp
op_ne
l_int|NULL
)paren
(brace
id|esp_release_dmabufs
c_func
(paren
id|esp
comma
id|sp
)paren
suffix:semicolon
id|sp-&gt;result
op_assign
(paren
id|DID_RESET
op_lshift
l_int|16
)paren
suffix:semicolon
id|sp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|sp
)paren
suffix:semicolon
id|esp-&gt;current_SC
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Clean up disconnected queue, they have been invalidated&n;&t; * by the bus reset.&n;&t; */
r_if
c_cond
(paren
id|esp-&gt;disconnected_SC
)paren
(brace
r_while
c_loop
(paren
(paren
id|sp
op_assign
id|remove_first_SC
c_func
(paren
op_amp
id|esp-&gt;disconnected_SC
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|esp_release_dmabufs
c_func
(paren
id|esp
comma
id|sp
)paren
suffix:semicolon
id|sp-&gt;result
op_assign
(paren
id|DID_RESET
op_lshift
l_int|16
)paren
suffix:semicolon
id|sp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|sp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* SCSI bus reset is complete. */
id|esp-&gt;resetting_bus
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Ok, now it is safe to get commands going once more. */
r_if
c_cond
(paren
id|esp-&gt;issue_SC
)paren
(brace
id|esp_exec_cmd
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_return
id|do_intr_end
suffix:semicolon
)brace
DECL|function|esp_do_resetbus
r_static
r_int
id|esp_do_resetbus
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Resetting scsi bus&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp-&gt;resetting_bus
op_assign
l_int|1
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_RS
)paren
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
multiline_comment|/* Reset ESP chip, reset hanging bus, then kill active and&n; * disconnected commands for targets without soft reset.&n; */
DECL|function|esp_reset
r_int
id|esp_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCptr
comma
r_int
r_int
id|how
)paren
(brace
r_struct
id|NCR_ESP
op_star
id|esp
op_assign
(paren
r_struct
id|NCR_ESP
op_star
)paren
id|SCptr-&gt;host-&gt;hostdata
suffix:semicolon
(paren
r_void
)paren
id|esp_do_resetbus
c_func
(paren
id|esp
comma
id|esp-&gt;eregs
)paren
suffix:semicolon
r_return
id|SCSI_RESET_PENDING
suffix:semicolon
)brace
multiline_comment|/* Internal ESP done function. */
DECL|function|esp_done
r_static
r_void
id|esp_done
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_int
id|error
)paren
(brace
id|Scsi_Cmnd
op_star
id|done_SC
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;current_SC
)paren
(brace
id|done_SC
op_assign
id|esp-&gt;current_SC
suffix:semicolon
id|esp-&gt;current_SC
op_assign
l_int|NULL
suffix:semicolon
id|esp_release_dmabufs
c_func
(paren
id|esp
comma
id|done_SC
)paren
suffix:semicolon
id|done_SC-&gt;result
op_assign
id|error
suffix:semicolon
id|done_SC
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|done_SC
)paren
suffix:semicolon
multiline_comment|/* Bus is free, issue any commands in the queue. */
r_if
c_cond
(paren
id|esp-&gt;issue_SC
op_logical_and
op_logical_neg
id|esp-&gt;current_SC
)paren
(brace
id|esp_exec_cmd
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Panic is safe as current_SC is null so we may still&n;&t;&t; * be able to accept more commands to sync disk buffers.&n;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;panicing&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;esp: done() called with NULL esp-&gt;current_SC&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Wheee, ESP interrupt engine. */
multiline_comment|/* Forward declarations. */
r_static
r_int
id|esp_do_phase_determine
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
suffix:semicolon
r_static
r_int
id|esp_do_data_finale
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
suffix:semicolon
r_static
r_int
id|esp_select_complete
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
suffix:semicolon
r_static
r_int
id|esp_do_status
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
suffix:semicolon
r_static
r_int
id|esp_do_msgin
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
suffix:semicolon
r_static
r_int
id|esp_do_msgindone
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
suffix:semicolon
r_static
r_int
id|esp_do_msgout
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
suffix:semicolon
r_static
r_int
id|esp_do_cmdbegin
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
suffix:semicolon
DECL|macro|sreg_datainp
mdefine_line|#define sreg_datainp(__sreg)  (((__sreg) &amp; ESP_STAT_PMASK) == ESP_DIP)
DECL|macro|sreg_dataoutp
mdefine_line|#define sreg_dataoutp(__sreg) (((__sreg) &amp; ESP_STAT_PMASK) == ESP_DOP)
multiline_comment|/* We try to avoid some interrupts by jumping ahead and see if the ESP&n; * has gotten far enough yet.  Hence the following.&n; */
DECL|function|skipahead1
r_static
r_inline
r_int
id|skipahead1
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
comma
id|Scsi_Cmnd
op_star
id|scp
comma
r_int
id|prev_phase
comma
r_int
id|new_phase
)paren
(brace
r_if
c_cond
(paren
id|scp-&gt;SCp.sent_command
op_ne
id|prev_phase
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|esp
op_member_access_from_pointer
id|dma_irq_p
c_func
(paren
id|esp
)paren
)paren
(brace
multiline_comment|/* Yes, we are able to save an interrupt. */
id|esp-&gt;sreg
op_assign
(paren
id|esp_read
c_func
(paren
id|eregs-&gt;esp_status
)paren
op_amp
op_complement
(paren
id|ESP_STAT_INTR
)paren
)paren
suffix:semicolon
id|esp-&gt;ireg
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_intrpt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_SR
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
id|do_reset_complete
suffix:semicolon
)brace
multiline_comment|/* Ho hum, target is taking forever... */
id|scp-&gt;SCp.sent_command
op_assign
id|new_phase
suffix:semicolon
multiline_comment|/* so we don&squot;t recurse... */
r_return
id|do_intr_end
suffix:semicolon
)brace
DECL|function|skipahead2
r_static
r_inline
r_int
id|skipahead2
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
comma
id|Scsi_Cmnd
op_star
id|scp
comma
r_int
id|prev_phase1
comma
r_int
id|prev_phase2
comma
r_int
id|new_phase
)paren
(brace
r_if
c_cond
(paren
id|scp-&gt;SCp.sent_command
op_ne
id|prev_phase1
op_logical_and
id|scp-&gt;SCp.sent_command
op_ne
id|prev_phase2
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|esp
op_member_access_from_pointer
id|dma_irq_p
c_func
(paren
id|esp
)paren
)paren
(brace
multiline_comment|/* Yes, we are able to save an interrupt. */
id|esp-&gt;sreg
op_assign
(paren
id|esp_read
c_func
(paren
id|eregs-&gt;esp_status
)paren
op_amp
op_complement
(paren
id|ESP_STAT_INTR
)paren
)paren
suffix:semicolon
id|esp-&gt;ireg
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_intrpt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_SR
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
id|do_reset_complete
suffix:semicolon
)brace
multiline_comment|/* Ho hum, target is taking forever... */
id|scp-&gt;SCp.sent_command
op_assign
id|new_phase
suffix:semicolon
multiline_comment|/* so we don&squot;t recurse... */
r_return
id|do_intr_end
suffix:semicolon
)brace
multiline_comment|/* Misc. esp helper macros. */
DECL|macro|esp_setcount
mdefine_line|#define esp_setcount(__eregs, __cnt) &bslash;&n;&t;esp_write((__eregs)-&gt;esp_tclow, ((__cnt) &amp; 0xff)); &bslash;&n;&t;esp_write((__eregs)-&gt;esp_tcmed, (((__cnt) &gt;&gt; 8) &amp; 0xff))
DECL|macro|esp_getcount
mdefine_line|#define esp_getcount(__eregs) &bslash;&n;&t;((esp_read((__eregs)-&gt;esp_tclow)&amp;0xff) | &bslash;&n;&t; ((esp_read((__eregs)-&gt;esp_tcmed)&amp;0xff) &lt;&lt; 8))
DECL|macro|fcount
mdefine_line|#define fcount(__esp, __eregs) &bslash;&n;&t;(esp_read((__eregs)-&gt;esp_fflags) &amp; ESP_FF_FBYTES)
DECL|macro|fnzero
mdefine_line|#define fnzero(__esp, __eregs) &bslash;&n;&t;(esp_read((__eregs)-&gt;esp_fflags) &amp; ESP_FF_ONOTZERO)
multiline_comment|/* XXX speculative nops unnecessary when continuing amidst a data phase&n; * XXX even on esp100!!!  another case of flooding the bus with I/O reg&n; * XXX writes...&n; */
DECL|macro|esp_maybe_nop
mdefine_line|#define esp_maybe_nop(__esp, __eregs) &bslash;&n;&t;if((__esp)-&gt;erev == esp100) &bslash;&n;&t;&t;esp_cmd((__esp), (__eregs), ESP_CMD_NULL)
DECL|macro|sreg_to_dataphase
mdefine_line|#define sreg_to_dataphase(__sreg) &bslash;&n;&t;((((__sreg) &amp; ESP_STAT_PMASK) == ESP_DOP) ? in_dataout : in_datain)
multiline_comment|/* The ESP100 when in synchronous data phase, can mistake a long final&n; * REQ pulse from the target as an extra byte, it places whatever is on&n; * the data lines into the fifo.  For now, we will assume when this&n; * happens that the target is a bit quirky and we don&squot;t want to&n; * be talking synchronously to it anyways.  Regardless, we need to&n; * tell the ESP to eat the extraneous byte so that we can proceed&n; * to the next phase.&n; */
DECL|function|esp100_sync_hwbug
r_static
r_inline
r_int
id|esp100_sync_hwbug
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
comma
id|Scsi_Cmnd
op_star
id|sp
comma
r_int
id|fifocnt
)paren
(brace
multiline_comment|/* Do not touch this piece of code. */
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|esp-&gt;erev
op_eq
id|esp100
)paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|sreg_datainp
c_func
(paren
(paren
id|esp-&gt;sreg
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_status
)paren
)paren
)paren
op_logical_and
op_logical_neg
id|fifocnt
)paren
op_logical_and
op_logical_neg
(paren
id|sreg_dataoutp
c_func
(paren
id|esp-&gt;sreg
)paren
op_logical_and
op_logical_neg
id|fnzero
c_func
(paren
id|esp
comma
id|eregs
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|sp-&gt;SCp.phase
op_eq
id|in_dataout
)paren
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Async mode for this guy. */
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Ack the bogus byte, but set ATN first. */
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_SATN
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_MOK
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* This closes the window during a selection with a reselect pending, because&n; * we use DMA for the selection process the FIFO should hold the correct&n; * contents if we get reselected during this process.  So we just need to&n; * ack the possible illegal cmd interrupt pending on the esp100.&n; */
DECL|function|esp100_reconnect_hwbug
r_static
r_inline
r_int
id|esp100_reconnect_hwbug
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
r_volatile
id|unchar
id|junk
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_ne
id|esp100
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|junk
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_intrpt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|junk
op_amp
id|ESP_INTR_SR
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This verifies the BUSID bits during a reselection so that we know which&n; * target is talking to us.&n; */
DECL|function|reconnect_target
r_static
r_inline
r_int
id|reconnect_target
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
r_int
id|it
comma
id|me
op_assign
id|esp-&gt;scsi_id_mask
comma
id|targ
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
l_int|2
op_ne
id|fcount
c_func
(paren
id|esp
comma
id|eregs
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|it
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_fdata
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|it
op_amp
id|me
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|it
op_and_assign
op_complement
id|me
suffix:semicolon
r_if
c_cond
(paren
id|it
op_amp
(paren
id|it
op_minus
l_int|1
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|it
op_amp
l_int|1
)paren
)paren
(brace
id|targ
op_increment
comma
id|it
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_return
id|targ
suffix:semicolon
)brace
multiline_comment|/* This verifies the identify from the target so that we know which lun is&n; * being reconnected.&n; */
DECL|function|reconnect_lun
r_static
r_inline
r_int
id|reconnect_lun
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
r_int
id|lun
suffix:semicolon
r_if
c_cond
(paren
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PMASK
)paren
op_ne
id|ESP_MIP
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|lun
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_fdata
)paren
suffix:semicolon
multiline_comment|/* Yes, you read this correctly.  We report lun of zero&n;&t; * if we see parity error.  ESP reports parity error for&n;&t; * the lun byte, and this is the only way to hope to recover&n;&t; * because the target is connected.&n;&t; */
r_if
c_cond
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PERR
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Check for illegal bits being set in the lun. */
r_if
c_cond
(paren
(paren
id|lun
op_amp
l_int|0x40
)paren
op_logical_or
op_logical_neg
(paren
id|lun
op_amp
l_int|0x80
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|lun
op_amp
l_int|7
suffix:semicolon
)brace
multiline_comment|/* This puts the driver in a state where it can revitalize a command that&n; * is being continued due to reselection.&n; */
DECL|function|esp_connect
r_static
r_inline
r_void
id|esp_connect
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
id|Scsi_Device
op_star
id|dp
op_assign
id|sp-&gt;device
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;prev_soff
op_ne
id|dp-&gt;sync_max_offset
op_logical_or
id|esp-&gt;prev_stp
op_ne
id|dp-&gt;sync_min_period
op_logical_or
(paren
id|esp-&gt;erev
OG
id|esp100a
op_logical_and
id|esp-&gt;prev_cfg3
op_ne
id|esp-&gt;config3
(braket
id|sp-&gt;target
)braket
)paren
)paren
(brace
id|esp-&gt;prev_soff
op_assign
id|dp-&gt;sync_max_offset
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_soff
comma
id|esp-&gt;prev_soff
)paren
suffix:semicolon
id|esp-&gt;prev_stp
op_assign
id|dp-&gt;sync_min_period
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_stp
comma
id|esp-&gt;prev_stp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
OG
id|esp100a
)paren
(brace
id|esp-&gt;prev_cfg3
op_assign
id|esp-&gt;config3
(braket
id|sp-&gt;target
)braket
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg3
comma
id|esp-&gt;prev_cfg3
)paren
suffix:semicolon
)brace
)brace
id|esp-&gt;current_SC
op_assign
id|sp
suffix:semicolon
)brace
multiline_comment|/* This will place the current working command back into the issue queue&n; * if we are to receive a reselection amidst a selection attempt.&n; */
DECL|function|esp_reconnect
r_static
r_inline
r_void
id|esp_reconnect
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|esp-&gt;disconnected_SC
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Weird, being reselected but disconnected &quot;
l_string|&quot;command queue is empty.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
)brace
id|esp-&gt;snip
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;current_SC
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;SCp.phase
op_assign
id|not_issued
suffix:semicolon
id|append_SC
c_func
(paren
op_amp
id|esp-&gt;issue_SC
comma
id|sp
)paren
suffix:semicolon
)brace
multiline_comment|/* Begin message in phase. */
DECL|function|esp_do_msgin
r_static
r_int
id|esp_do_msgin
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
id|esp_maybe_nop
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
id|esp-&gt;msgin_len
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;msgin_ctr
op_assign
l_int|0
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_msgindone
)paren
suffix:semicolon
r_return
id|do_work_bus
suffix:semicolon
)brace
DECL|function|advance_sg
r_static
r_inline
r_void
id|advance_sg
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
op_increment
id|sp-&gt;SCp.buffer
suffix:semicolon
op_decrement
id|sp-&gt;SCp.buffers_residual
suffix:semicolon
id|sp-&gt;SCp.this_residual
op_assign
id|sp-&gt;SCp.buffer-&gt;length
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;dma_advance_sg
)paren
id|esp-&gt;dma_advance_sg
(paren
id|sp
)paren
suffix:semicolon
r_else
id|sp-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|virt_to_phys
c_func
(paren
id|sp-&gt;SCp.buffer-&gt;address
)paren
suffix:semicolon
)brace
multiline_comment|/* Please note that the way I&squot;ve coded these routines is that I _always_&n; * check for a disconnect during any and all information transfer&n; * phases.  The SCSI standard states that the target _can_ cause a BUS&n; * FREE condition by dropping all MSG/CD/IO/BSY signals.  Also note&n; * that during information transfer phases the target controls every&n; * change in phase, the only thing the initiator can do is &quot;ask&quot; for&n; * a message out phase by driving ATN true.  The target can, and sometimes&n; * will, completely ignore this request so we cannot assume anything when&n; * we try to force a message out phase to abort/reset a target.  Most of&n; * the time the target will eventually be nice and go to message out, so&n; * we may have to hold on to our state about what we want to tell the target&n; * for some period of time.&n; */
multiline_comment|/* I think I have things working here correctly.  Even partial transfers&n; * within a buffer or sub-buffer should not upset us at all no matter&n; * how bad the target and/or ESP fucks things up.&n; */
DECL|function|esp_do_data
r_static
r_int
id|esp_do_data
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
r_int
id|thisphase
comma
id|hmuch
suffix:semicolon
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;esp_do_data: &quot;
)paren
)paren
suffix:semicolon
id|esp_maybe_nop
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
id|thisphase
op_assign
id|sreg_to_dataphase
c_func
(paren
id|esp-&gt;sreg
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|thisphase
)paren
suffix:semicolon
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;newphase&lt;%s&gt; &quot;
comma
(paren
id|thisphase
op_eq
id|in_datain
)paren
ques
c_cond
l_string|&quot;DATAIN&quot;
suffix:colon
l_string|&quot;DATAOUT&quot;
)paren
)paren
suffix:semicolon
id|hmuch
op_assign
id|esp
op_member_access_from_pointer
id|dma_can_transfer
c_func
(paren
id|esp
comma
id|SCptr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX MSch: cater for PIO transfer here; PIO used if hmuch == 0&n;&t; */
r_if
c_cond
(paren
id|hmuch
)paren
(brace
multiline_comment|/* DMA */
multiline_comment|/*&n;&t;&t; * DMA&n;&t;&t; */
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;hmuch&lt;%d&gt; &quot;
comma
id|hmuch
)paren
)paren
suffix:semicolon
id|esp-&gt;current_transfer_size
op_assign
id|hmuch
suffix:semicolon
id|esp_setcount
c_func
(paren
id|eregs
comma
(paren
id|esp-&gt;fas_premature_intr_workaround
ques
c_cond
(paren
id|hmuch
op_plus
l_int|0x40
)paren
suffix:colon
id|hmuch
)paren
)paren
suffix:semicolon
id|esp
op_member_access_from_pointer
id|dma_setup
c_func
(paren
id|esp
comma
(paren
id|__u32
)paren
(paren
(paren
r_int
r_int
)paren
id|SCptr-&gt;SCp.ptr
)paren
comma
id|hmuch
comma
(paren
id|thisphase
op_eq
id|in_datain
)paren
)paren
suffix:semicolon
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;DMA|TI --&gt; do_intr_end&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_DMA
op_or
id|ESP_CMD_TI
)paren
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
multiline_comment|/*&n;&t;&t; * end DMA&n;&t;&t; */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * PIO&n;&t;&t; */
r_int
id|oldphase
comma
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* or where we left off last time ?? esp-&gt;current_data ?? */
r_int
id|fifocnt
op_assign
l_int|0
suffix:semicolon
id|oldphase
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_status
)paren
op_amp
id|ESP_STAT_PMASK
suffix:semicolon
multiline_comment|/*&n;&t;&t; * polled transfer; ugly, can we make this happen in a DRQ &n;&t;&t; * interrupt handler ??&n;&t;&t; * requires keeping track of state information in host or &n;&t;&t; * command struct!&n;&t;&t; * Problem: I&squot;ve never seen a DRQ happen on Mac, not even&n;&t;&t; * with ESP_CMD_DMA ...&n;&t;&t; */
multiline_comment|/* figure out how much needs to be transfered */
id|hmuch
op_assign
id|SCptr-&gt;SCp.this_residual
suffix:semicolon
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;hmuch&lt;%d&gt; pio &quot;
comma
id|hmuch
)paren
)paren
suffix:semicolon
id|esp-&gt;current_transfer_size
op_assign
id|hmuch
suffix:semicolon
multiline_comment|/* tell the ESP ... */
id|esp_setcount
c_func
(paren
id|eregs
comma
id|hmuch
)paren
suffix:semicolon
multiline_comment|/* loop */
r_while
c_loop
(paren
id|hmuch
)paren
(brace
r_int
id|j
comma
id|fifo_stuck
op_assign
l_int|0
comma
id|newphase
suffix:semicolon
r_int
r_int
id|flags
comma
id|timeout
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|i
op_mod
l_int|10
)paren
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;&bslash;r&quot;
)paren
)paren
suffix:semicolon
r_else
id|ESPDATA
c_func
(paren
(paren
multiline_comment|/*&quot;&bslash;n&quot;*/
l_string|&quot;&bslash;r&quot;
)paren
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if 0
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|thisphase
op_eq
id|in_datain
)paren
(brace
multiline_comment|/* &squot;go&squot; ... */
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
multiline_comment|/* wait for data */
id|timeout
op_assign
l_int|1000000
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|esp-&gt;sreg
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_status
)paren
)paren
op_amp
id|ESP_STAT_INTR
)paren
op_logical_and
op_decrement
id|timeout
)paren
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;DRQ datain timeout! &bslash;n&quot;
)paren
suffix:semicolon
id|newphase
op_assign
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PMASK
suffix:semicolon
multiline_comment|/* see how much we got ... */
id|fifocnt
op_assign
(paren
id|esp_read
c_func
(paren
id|eregs-&gt;esp_fflags
)paren
op_amp
id|ESP_FF_FBYTES
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fifocnt
)paren
id|fifo_stuck
op_increment
suffix:semicolon
r_else
id|fifo_stuck
op_assign
l_int|0
suffix:semicolon
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;&bslash;rgot %d st %x ph %x&quot;
comma
id|fifocnt
comma
id|esp-&gt;sreg
comma
id|newphase
)paren
)paren
suffix:semicolon
multiline_comment|/* read fifo */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|fifocnt
suffix:semicolon
id|j
op_increment
)paren
(brace
id|SCptr-&gt;SCp.ptr
(braket
id|i
op_increment
)braket
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_fdata
)paren
suffix:semicolon
)brace
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;(%d) &quot;
comma
id|i
)paren
)paren
suffix:semicolon
multiline_comment|/* how many to go ?? */
id|hmuch
op_sub_assign
id|fifocnt
suffix:semicolon
multiline_comment|/* break if status phase !! */
r_if
c_cond
(paren
id|newphase
op_eq
id|ESP_STATP
)paren
(brace
multiline_comment|/* clear int. */
id|esp-&gt;ireg
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_intrpt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
DECL|macro|MAX_FIFO
mdefine_line|#define MAX_FIFO 8
multiline_comment|/* how much will fit ? */
r_int
id|this_count
op_assign
id|MAX_FIFO
op_minus
id|fifocnt
suffix:semicolon
r_if
c_cond
(paren
id|this_count
OG
id|hmuch
)paren
id|this_count
op_assign
id|hmuch
suffix:semicolon
multiline_comment|/* fill fifo */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|this_count
suffix:semicolon
id|j
op_increment
)paren
(brace
id|esp_write
c_func
(paren
id|eregs-&gt;esp_fdata
comma
id|SCptr-&gt;SCp.ptr
(braket
id|i
op_increment
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* how many left if this goes out ?? */
id|hmuch
op_sub_assign
id|this_count
suffix:semicolon
multiline_comment|/* &squot;go&squot; ... */
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
multiline_comment|/* wait for &squot;got it&squot; */
id|timeout
op_assign
l_int|1000000
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|esp-&gt;sreg
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_status
)paren
)paren
op_amp
id|ESP_STAT_INTR
)paren
op_logical_and
op_decrement
id|timeout
)paren
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;DRQ dataout timeout!  &bslash;n&quot;
)paren
suffix:semicolon
id|newphase
op_assign
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PMASK
suffix:semicolon
multiline_comment|/* need to check how much was sent ?? */
id|fifocnt
op_assign
(paren
id|esp_read
c_func
(paren
id|eregs-&gt;esp_fflags
)paren
op_amp
id|ESP_FF_FBYTES
)paren
suffix:semicolon
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;&bslash;rsent %d st %x ph %x&quot;
comma
id|this_count
op_minus
id|fifocnt
comma
id|esp-&gt;sreg
comma
id|newphase
)paren
)paren
suffix:semicolon
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;(%d) &quot;
comma
id|i
)paren
)paren
suffix:semicolon
multiline_comment|/* break if status phase !! */
r_if
c_cond
(paren
id|newphase
op_eq
id|ESP_STATP
)paren
(brace
multiline_comment|/* clear int. */
id|esp-&gt;ireg
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_intrpt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* clear int. */
id|esp-&gt;ireg
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_intrpt
)paren
suffix:semicolon
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;ir %x ... &quot;
comma
id|esp-&gt;ireg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hmuch
op_eq
l_int|0
)paren
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;done! &bslash;n&quot;
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* check new bus phase */
r_if
c_cond
(paren
id|newphase
op_ne
id|oldphase
op_logical_and
id|i
OL
id|esp-&gt;current_transfer_size
)paren
(brace
multiline_comment|/* something happened; disconnect ?? */
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;phase change, dropped out with %d done ... &quot;
comma
id|i
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* check int. status */
r_if
c_cond
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_DC
)paren
(brace
multiline_comment|/* disconnect */
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;disconnect; %d transfered ... &quot;
comma
id|i
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_FDONE
)paren
(brace
multiline_comment|/* function done */
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;function done; %d transfered ... &quot;
comma
id|i
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* XXX fixme: bail out on stall */
r_if
c_cond
(paren
id|fifo_stuck
OG
l_int|10
)paren
(brace
multiline_comment|/* we&squot;re stuck */
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;fifo stall; %d transfered ... &quot;
comma
id|i
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* check successful completion ?? */
r_if
c_cond
(paren
id|thisphase
op_eq
id|in_dataout
)paren
id|hmuch
op_add_assign
id|fifocnt
suffix:semicolon
multiline_comment|/* stuck?? adjust data pointer ...*/
multiline_comment|/* tell do_data_finale how much was transfered */
id|esp-&gt;current_transfer_size
op_sub_assign
id|hmuch
suffix:semicolon
multiline_comment|/* still not completely sure on this one ... */
r_return
multiline_comment|/*do_intr_end*/
id|do_work_bus
multiline_comment|/*do_phase_determine*/
suffix:semicolon
multiline_comment|/*&n;&t;&t; * end PIO&n;&t;&t; */
)brace
r_return
id|do_intr_end
suffix:semicolon
)brace
multiline_comment|/* See how successful the data transfer was. */
DECL|function|esp_do_data_finale
r_static
r_int
id|esp_do_data_finale
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
r_int
id|bogus_data
op_assign
l_int|0
comma
id|bytes_sent
op_assign
l_int|0
comma
id|fifocnt
comma
id|ecount
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;dma_led_off
)paren
(brace
id|esp
op_member_access_from_pointer
id|dma_led_off
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;esp_do_data_finale: &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCptr-&gt;SCp.phase
op_eq
id|in_datain
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PERR
)paren
(brace
multiline_comment|/* Yuck, parity error.  The ESP asserts ATN&n;&t;&t;&t; * so that we can go to message out phase&n;&t;&t;&t; * immediately and inform the target that&n;&t;&t;&t; * something bad happened.&n;&t;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: data bad parity detected.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
op_assign
id|INITIATOR_ERROR
suffix:semicolon
id|esp-&gt;msgout_len
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|esp-&gt;dma_drain
)paren
(brace
id|esp
op_member_access_from_pointer
id|dma_drain
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|esp-&gt;dma_invalidate
)paren
(brace
id|esp
op_member_access_from_pointer
id|dma_invalidate
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
multiline_comment|/* This could happen for the above parity error case. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;ireg
op_eq
id|ESP_INTR_BSERV
)paren
)paren
(brace
multiline_comment|/* Please go to msgout phase, please please please... */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: !BSERV after data, probably to msgout&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_return
id|esp_do_phase_determine
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for partial transfers and other horrible events. */
id|fifocnt
op_assign
(paren
id|esp_read
c_func
(paren
id|eregs-&gt;esp_fflags
)paren
op_amp
id|ESP_FF_FBYTES
)paren
suffix:semicolon
id|ecount
op_assign
id|esp_getcount
c_func
(paren
id|eregs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;fas_premature_intr_workaround
)paren
(brace
id|ecount
op_sub_assign
l_int|0x40
suffix:semicolon
)brace
id|bytes_sent
op_assign
id|esp-&gt;current_transfer_size
suffix:semicolon
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;trans_sz=%d, &quot;
comma
id|bytes_sent
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_TCNT
)paren
)paren
(brace
id|bytes_sent
op_sub_assign
id|ecount
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCptr-&gt;SCp.phase
op_eq
id|in_dataout
)paren
(brace
id|bytes_sent
op_sub_assign
id|fifocnt
suffix:semicolon
)brace
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;bytes_sent=%d (ecount=%d, fifocnt=%d), &quot;
comma
id|bytes_sent
comma
id|ecount
comma
id|fifocnt
)paren
)paren
suffix:semicolon
multiline_comment|/* If we were in synchronous mode, check for peculiarities. */
r_if
c_cond
(paren
id|SCptr-&gt;device-&gt;sync_max_offset
)paren
(brace
id|bogus_data
op_assign
id|esp100_sync_hwbug
c_func
(paren
id|esp
comma
id|eregs
comma
id|SCptr
comma
id|fifocnt
)paren
suffix:semicolon
)brace
r_else
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
multiline_comment|/* Until we are sure of what has happened, we are certainly&n;&t; * in the dark.&n;&t; */
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
multiline_comment|/* Check for premature interrupt condition. Can happen on FAS2x6&n;&t; * chips. QLogic recommends a workaround by overprogramming the&n;&t; * transfer counters, but this makes doing scatter-gather impossible.&n;&t; * Until there is a way to disable scatter-gather for a single target,&n;&t; * and not only for the entire host adapter as it is now, the workaround&n;&t; * is way to expensive performance wise.&n;&t; * Instead, it turns out that when this happens the target has disconnected&n;&t; * allready but it doesn&squot;t show in the interrupt register. Compensate for&n;&t; * that here to try and avoid a SCSI bus reset.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|esp-&gt;fas_premature_intr_workaround
op_logical_and
(paren
id|fifocnt
op_eq
l_int|1
)paren
op_logical_and
id|sreg_dataoutp
c_func
(paren
id|esp-&gt;sreg
)paren
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Premature interrupt, enabling workaround&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Disable scatter-gather operations, they are not possible&n;&t;&t; * when using this workaround.&n;&t;&t; */
id|esp-&gt;ehost-&gt;sg_tablesize
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;ehost-&gt;use_clustering
op_assign
id|ENABLE_CLUSTERING
suffix:semicolon
id|esp-&gt;fas_premature_intr_workaround
op_assign
l_int|1
suffix:semicolon
id|bytes_sent
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|SCptr-&gt;use_sg
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Aborting scatter-gather operation&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
op_assign
id|ABORT
suffix:semicolon
id|esp-&gt;msgout_len
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;msgout_ctr
op_assign
l_int|0
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_SATN
)paren
suffix:semicolon
id|esp_setcount
c_func
(paren
id|eregs
comma
l_int|0xffff
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_NULL
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_TPAD
op_or
id|ESP_CMD_DMA
)paren
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/* Just set the disconnected bit. That&squot;s what appears to&n;&t;&t; * happen anyway. The state machine will pick it up when&n;&t;&t; * we return.&n;&t;&t; */
id|esp-&gt;ireg
op_or_assign
id|ESP_INTR_DC
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|bytes_sent
OL
l_int|0
)paren
(brace
multiline_comment|/* I&squot;ve seen this happen due to lost state in this&n;&t;&t; * driver.  No idea why it happened, but allowing&n;&t;&t; * this value to be negative caused things to&n;&t;&t; * lock up.  This allows greater chance of recovery.&n;&t;&t; * In fact every time I&squot;ve seen this, it has been&n;&t;&t; * a driver bug without question.&n;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: yieee, bytes_sent &lt; 0!&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: csz=%d fifocount=%d ecount=%d&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;current_transfer_size
comma
id|fifocnt
comma
id|ecount
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: use_sg=%d ptr=%p this_residual=%d&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|SCptr-&gt;use_sg
comma
id|SCptr-&gt;SCp.ptr
comma
id|SCptr-&gt;SCp.this_residual
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Forcing async for target %d&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|SCptr-&gt;target
)paren
)paren
suffix:semicolon
id|SCptr-&gt;device-&gt;borken
op_assign
l_int|1
suffix:semicolon
id|SCptr-&gt;device-&gt;sync
op_assign
l_int|0
suffix:semicolon
id|bytes_sent
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Update the state of our transfer. */
id|SCptr-&gt;SCp.ptr
op_add_assign
id|bytes_sent
suffix:semicolon
id|SCptr-&gt;SCp.this_residual
op_sub_assign
id|bytes_sent
suffix:semicolon
r_if
c_cond
(paren
id|SCptr-&gt;SCp.this_residual
OL
l_int|0
)paren
(brace
multiline_comment|/* shit */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Data transfer overrun.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|SCptr-&gt;SCp.this_residual
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Maybe continue. */
r_if
c_cond
(paren
op_logical_neg
id|bogus_data
)paren
(brace
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;!bogus_data, &quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* NO MATTER WHAT, we advance the scatterlist,&n;&t;&t; * if the target should decide to disconnect&n;&t;&t; * in between scatter chunks (which is common)&n;&t;&t; * we could die horribly!  I used to have the sg&n;&t;&t; * advance occur only if we are going back into&n;&t;&t; * (or are staying in) a data phase, you can&n;&t;&t; * imagine the hell I went through trying to&n;&t;&t; * figure this out.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|SCptr-&gt;SCp.this_residual
op_logical_and
id|SCptr-&gt;SCp.buffers_residual
)paren
(brace
id|advance_sg
c_func
(paren
id|esp
comma
id|SCptr
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_ESP_DATA
r_if
c_cond
(paren
id|sreg_datainp
c_func
(paren
id|esp-&gt;sreg
)paren
op_logical_or
id|sreg_dataoutp
c_func
(paren
id|esp-&gt;sreg
)paren
)paren
(brace
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;to more data&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;to new phase&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|esp_do_phase_determine
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
multiline_comment|/* Bogus data, just wait for next interrupt. */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: bogus_data during end of data phase&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
multiline_comment|/* We received a non-good status return at the end of&n; * running a SCSI command.  This is used to decide if&n; * we should clear our synchronous transfer state for&n; * such a device when that happens.&n; *&n; * The idea is that when spinning up a disk or rewinding&n; * a tape, we don&squot;t want to go into a loop re-negotiating&n; * synchronous capabilities over and over.&n; */
DECL|function|esp_should_clear_sync
r_static
r_int
id|esp_should_clear_sync
c_func
(paren
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
id|unchar
id|cmd1
op_assign
id|sp-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
id|unchar
id|cmd2
op_assign
id|sp-&gt;data_cmnd
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* These cases are for spinning up a disk and&n;&t; * waiting for that spinup to complete.&n;&t; */
r_if
c_cond
(paren
id|cmd1
op_eq
id|START_STOP
op_logical_or
id|cmd2
op_eq
id|START_STOP
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd1
op_eq
id|TEST_UNIT_READY
op_logical_or
id|cmd2
op_eq
id|TEST_UNIT_READY
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* One more special case for SCSI tape drives,&n;&t; * this is what is used to probe the device for&n;&t; * completion of a rewind or tape load operation.&n;&t; */
r_if
c_cond
(paren
id|sp-&gt;device-&gt;type
op_eq
id|TYPE_TAPE
)paren
(brace
r_if
c_cond
(paren
id|cmd1
op_eq
id|MODE_SENSE
op_logical_or
id|cmd2
op_eq
id|MODE_SENSE
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Either a command is completing or a target is dropping off the bus&n; * to continue the command in the background so we can do other work.&n; */
DECL|function|esp_do_freebus
r_static
r_int
id|esp_do_freebus
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
r_int
id|rval
suffix:semicolon
id|rval
op_assign
id|skipahead2
c_func
(paren
id|esp
comma
id|eregs
comma
id|SCptr
comma
id|in_status
comma
id|in_msgindone
comma
id|in_freeing
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
r_if
c_cond
(paren
id|esp-&gt;ireg
op_ne
id|ESP_INTR_DC
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Target will not disconnect&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
multiline_comment|/* target will not drop BSY... */
)brace
id|esp-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;prevmsgout
op_assign
id|NOP
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;prevmsgin
op_eq
id|COMMAND_COMPLETE
)paren
(brace
multiline_comment|/* Normal end of nexus. */
r_if
c_cond
(paren
id|esp-&gt;disconnected_SC
)paren
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_ESEL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCptr-&gt;SCp.Status
op_ne
id|GOOD
op_logical_and
id|SCptr-&gt;SCp.Status
op_ne
id|CONDITION_GOOD
op_logical_and
(paren
(paren
l_int|1
op_lshift
id|SCptr-&gt;target
)paren
op_amp
id|esp-&gt;targets_present
)paren
op_logical_and
id|SCptr-&gt;device-&gt;sync
op_logical_and
id|SCptr-&gt;device-&gt;sync_max_offset
)paren
(brace
multiline_comment|/* SCSI standard says that the synchronous capabilities&n;&t;&t;&t; * should be renegotiated at this point.  Most likely&n;&t;&t;&t; * we are about to request sense from this target&n;&t;&t;&t; * in which case we want to avoid using sync&n;&t;&t;&t; * transfers until we are sure of the current target&n;&t;&t;&t; * state.&n;&t;&t;&t; */
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;esp: Status &lt;%d&gt; for target %d lun %d&bslash;n&quot;
comma
id|SCptr-&gt;SCp.Status
comma
id|SCptr-&gt;target
comma
id|SCptr-&gt;lun
)paren
)paren
suffix:semicolon
multiline_comment|/* But don&squot;t do this when spinning up a disk at&n;&t;&t;&t; * boot time while we poll for completion as it&n;&t;&t;&t; * fills up the console with messages.  Also, tapes&n;&t;&t;&t; * can report not ready many times right after&n;&t;&t;&t; * loading up a tape.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|esp_should_clear_sync
c_func
(paren
id|SCptr
)paren
op_ne
l_int|0
)paren
(brace
id|SCptr-&gt;device-&gt;sync
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|ESPDISC
c_func
(paren
(paren
l_string|&quot;F&lt;%02x,%02x&gt;&quot;
comma
id|SCptr-&gt;target
comma
id|SCptr-&gt;lun
)paren
)paren
suffix:semicolon
id|esp_done
c_func
(paren
id|esp
comma
(paren
(paren
id|SCptr-&gt;SCp.Status
op_amp
l_int|0xff
)paren
op_or
(paren
(paren
id|SCptr-&gt;SCp.Message
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|DID_OK
op_lshift
l_int|16
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;prevmsgin
op_eq
id|DISCONNECT
)paren
(brace
multiline_comment|/* Normal disconnect. */
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_ESEL
)paren
suffix:semicolon
id|ESPDISC
c_func
(paren
(paren
l_string|&quot;D&lt;%02x,%02x&gt;&quot;
comma
id|SCptr-&gt;target
comma
id|SCptr-&gt;lun
)paren
)paren
suffix:semicolon
id|append_SC
c_func
(paren
op_amp
id|esp-&gt;disconnected_SC
comma
id|SCptr
)paren
suffix:semicolon
id|esp-&gt;current_SC
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;issue_SC
)paren
(brace
id|esp_exec_cmd
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Driver bug, we do not expect a disconnect here&n;&t;&t; * and should not have advanced the state engine&n;&t;&t; * to in_freeing.&n;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: last msg not disc and not cmd cmplt.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
)brace
r_return
id|do_intr_end
suffix:semicolon
)brace
multiline_comment|/* When a reselect occurs, and we cannot find the command to&n; * reconnect to in our queues, we do this.&n; */
DECL|function|esp_bad_reconnect
r_static
r_int
id|esp_bad_reconnect
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
(brace
id|Scsi_Cmnd
op_star
id|sp
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Eieeee, reconnecting unknown command!&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;QUEUE DUMP&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sp
op_assign
id|esp-&gt;issue_SC
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: issue_SC[&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sp
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;&lt;%02x,%02x&gt;&quot;
comma
id|sp-&gt;target
comma
id|sp-&gt;lun
)paren
)paren
suffix:semicolon
id|sp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|sp-&gt;host_scribble
suffix:semicolon
)brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;]&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sp
op_assign
id|esp-&gt;current_SC
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: current_SC[&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sp
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;&lt;%02x,%02x&gt;&quot;
comma
id|sp-&gt;target
comma
id|sp-&gt;lun
)paren
)paren
suffix:semicolon
id|sp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|sp-&gt;host_scribble
suffix:semicolon
)brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;]&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sp
op_assign
id|esp-&gt;disconnected_SC
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: disconnected_SC[&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sp
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;&lt;%02x,%02x&gt;&quot;
comma
id|sp-&gt;target
comma
id|sp-&gt;lun
)paren
)paren
suffix:semicolon
id|sp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|sp-&gt;host_scribble
suffix:semicolon
)brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;]&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
)brace
multiline_comment|/* Do the needy when a target tries to reconnect to us. */
DECL|function|esp_do_reconnect
r_static
r_int
id|esp_do_reconnect
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
r_int
id|lun
comma
id|target
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCptr
suffix:semicolon
multiline_comment|/* Check for all bogus conditions first. */
id|target
op_assign
id|reconnect_target
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
OL
l_int|0
)paren
(brace
id|ESPDISC
c_func
(paren
(paren
l_string|&quot;bad bus bits&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
)brace
id|lun
op_assign
id|reconnect_lun
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lun
OL
l_int|0
)paren
(brace
id|ESPDISC
c_func
(paren
(paren
l_string|&quot;target=%2x, bad identify msg&bslash;n&quot;
comma
id|target
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
)brace
multiline_comment|/* Things look ok... */
id|ESPDISC
c_func
(paren
(paren
l_string|&quot;R&lt;%02x,%02x&gt;&quot;
comma
id|target
comma
id|lun
)paren
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp100_reconnect_hwbug
c_func
(paren
id|esp
comma
id|eregs
)paren
)paren
(brace
r_return
id|do_reset_bus
suffix:semicolon
)brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_NULL
)paren
suffix:semicolon
id|SCptr
op_assign
id|remove_SC
c_func
(paren
op_amp
id|esp-&gt;disconnected_SC
comma
(paren
id|unchar
)paren
id|target
comma
(paren
id|unchar
)paren
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCptr
)paren
(brace
r_return
id|esp_bad_reconnect
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
id|esp_connect
c_func
(paren
id|esp
comma
id|eregs
comma
id|SCptr
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_MOK
)paren
suffix:semicolon
multiline_comment|/* Reconnect implies a restore pointers operation. */
id|esp_restore_pointers
c_func
(paren
id|esp
comma
id|SCptr
)paren
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|0
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
multiline_comment|/* End of NEXUS (hopefully), pick up status + message byte then leave if&n; * all goes well.&n; */
DECL|function|esp_do_status
r_static
r_int
id|esp_do_status
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
r_int
id|intr
comma
id|rval
suffix:semicolon
id|rval
op_assign
id|skipahead1
c_func
(paren
id|esp
comma
id|eregs
comma
id|SCptr
comma
id|in_the_dark
comma
id|in_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
id|intr
op_assign
id|esp-&gt;ireg
suffix:semicolon
id|ESPSTAT
c_func
(paren
(paren
l_string|&quot;esp_do_status: &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr
op_ne
id|ESP_INTR_DC
)paren
(brace
r_int
id|message_out
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* for parity problems */
multiline_comment|/* Ack the message. */
id|ESPSTAT
c_func
(paren
(paren
l_string|&quot;ack msg, &quot;
)paren
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_MOK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;dma_poll
)paren
(brace
id|esp
op_member_access_from_pointer
id|dma_poll
c_func
(paren
id|esp
comma
(paren
r_int
r_char
op_star
)paren
id|esp-&gt;esp_command
)paren
suffix:semicolon
)brace
id|ESPSTAT
c_func
(paren
(paren
l_string|&quot;got something, &quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* ESP chimes in with one of&n;&t;&t; *&n;&t;&t; * 1) function done interrupt:&n;&t;&t; *&t;both status and message in bytes&n;&t;&t; *&t;are available&n;&t;&t; *&n;&t;&t; * 2) bus service interrupt:&n;&t;&t; *&t;only status byte was acquired&n;&t;&t; *&n;&t;&t; * 3) Anything else:&n;&t;&t; *&t;can&squot;t happen, but we test for it&n;&t;&t; *&t;anyways&n;&t;&t; *&n;&t;&t; * ALSO: If bad parity was detected on either&n;&t;&t; *       the status _or_ the message byte then&n;&t;&t; *       the ESP has asserted ATN on the bus&n;&t;&t; *       and we must therefore wait for the&n;&t;&t; *       next phase change.&n;&t;&t; */
r_if
c_cond
(paren
id|intr
op_amp
id|ESP_INTR_FDONE
)paren
(brace
multiline_comment|/* We got it all, hallejulia. */
id|ESPSTAT
c_func
(paren
(paren
l_string|&quot;got both, &quot;
)paren
)paren
suffix:semicolon
id|SCptr-&gt;SCp.Status
op_assign
id|esp-&gt;esp_command
(braket
l_int|0
)braket
suffix:semicolon
id|SCptr-&gt;SCp.Message
op_assign
id|esp-&gt;esp_command
(braket
l_int|1
)braket
suffix:semicolon
id|esp-&gt;prevmsgin
op_assign
id|SCptr-&gt;SCp.Message
suffix:semicolon
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
op_assign
id|SCptr-&gt;SCp.Message
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PERR
)paren
(brace
multiline_comment|/* There was bad parity for the&n;&t;&t;&t;&t; * message byte, the status byte&n;&t;&t;&t;&t; * was ok.&n;&t;&t;&t;&t; */
id|message_out
op_assign
id|MSG_PARITY_ERROR
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|intr
op_eq
id|ESP_INTR_BSERV
)paren
(brace
multiline_comment|/* Only got status byte. */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: got status only, &quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PERR
)paren
)paren
(brace
id|SCptr-&gt;SCp.Status
op_assign
id|esp-&gt;esp_command
(braket
l_int|0
)braket
suffix:semicolon
id|SCptr-&gt;SCp.Message
op_assign
l_int|0xff
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The status byte had bad parity.&n;&t;&t;&t;&t; * we leave the scsi_pointer Status&n;&t;&t;&t;&t; * field alone as we set it to a default&n;&t;&t;&t;&t; * of CHECK_CONDITION in esp_queue.&n;&t;&t;&t;&t; */
id|message_out
op_assign
id|INITIATOR_ERROR
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* This shouldn&squot;t happen ever. */
id|ESPSTAT
c_func
(paren
(paren
l_string|&quot;got bolixed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|esp_do_phase_determine
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|message_out
)paren
(brace
id|ESPSTAT
c_func
(paren
(paren
l_string|&quot;status=%2x msg=%2x, &quot;
comma
id|SCptr-&gt;SCp.Status
comma
id|SCptr-&gt;SCp.Message
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCptr-&gt;SCp.Message
op_eq
id|COMMAND_COMPLETE
)paren
(brace
id|ESPSTAT
c_func
(paren
(paren
l_string|&quot;and was COMMAND_COMPLETE&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_freeing
)paren
suffix:semicolon
r_return
id|esp_do_freebus
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
r_else
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: and _not_ COMMAND_COMPLETE&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp-&gt;msgin_len
op_assign
id|esp-&gt;msgin_ctr
op_assign
l_int|1
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_msgindone
)paren
suffix:semicolon
r_return
id|esp_do_msgindone
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* With luck we&squot;ll be able to let the target&n;&t;&t;&t; * know that bad parity happened, it will know&n;&t;&t;&t; * which byte caused the problems and send it&n;&t;&t;&t; * again.  For the case where the status byte&n;&t;&t;&t; * receives bad parity, I do not believe most&n;&t;&t;&t; * targets recover very well.  We&squot;ll see.&n;&t;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: bad parity somewhere mout=%2x&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|message_out
)paren
)paren
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
op_assign
id|message_out
suffix:semicolon
id|esp-&gt;msgout_len
op_assign
id|esp-&gt;msgout_ctr
op_assign
l_int|1
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|esp_do_phase_determine
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* If we disconnect now, all hell breaks loose. */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: whoops, disconnect&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|esp_do_phase_determine
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
)brace
DECL|function|esp_enter_status
r_static
r_int
id|esp_enter_status
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|unchar
id|thecmd
op_assign
id|ESP_CMD_ICCSEQ
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;do_pio_cmds
)paren
(brace
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_status
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|thecmd
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|esp_read
c_func
(paren
id|esp-&gt;eregs-&gt;esp_status
)paren
op_amp
id|ESP_STAT_INTR
)paren
)paren
(brace
suffix:semicolon
)brace
id|esp-&gt;esp_command
(braket
l_int|0
)braket
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_fdata
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|esp_read
c_func
(paren
id|esp-&gt;eregs-&gt;esp_status
)paren
op_amp
id|ESP_STAT_INTR
)paren
)paren
(brace
suffix:semicolon
)brace
id|esp-&gt;esp_command
(braket
l_int|1
)braket
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_fdata
)paren
suffix:semicolon
)brace
r_else
(brace
id|esp-&gt;esp_command
(braket
l_int|0
)braket
op_assign
id|esp-&gt;esp_command
(braket
l_int|1
)braket
op_assign
l_int|0xff
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_tclow
comma
l_int|2
)paren
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_tcmed
comma
l_int|0
)paren
suffix:semicolon
id|esp
op_member_access_from_pointer
id|dma_init_read
c_func
(paren
id|esp
comma
id|esp-&gt;esp_command_dvma
comma
l_int|2
)paren
suffix:semicolon
id|thecmd
op_or_assign
id|ESP_CMD_DMA
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|thecmd
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_status
)paren
suffix:semicolon
)brace
r_return
id|esp_do_status
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
DECL|function|esp_disconnect_amidst_phases
r_static
r_int
id|esp_disconnect_amidst_phases
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|Scsi_Cmnd
op_star
id|sp
op_assign
id|esp-&gt;current_SC
suffix:semicolon
id|Scsi_Device
op_star
id|dp
op_assign
id|sp-&gt;device
suffix:semicolon
multiline_comment|/* This means real problems if we see this&n;&t; * here.  Unless we were actually trying&n;&t; * to force the device to abort/reset.&n;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Disconnect amidst phases, &quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;pphase&lt;%s&gt; cphase&lt;%s&gt;, &quot;
comma
id|phase_string
c_func
(paren
id|sp-&gt;SCp.phase
)paren
comma
id|phase_string
c_func
(paren
id|sp-&gt;SCp.sent_command
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;disconnected_SC
)paren
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_ESEL
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
)paren
(brace
r_default
suffix:colon
multiline_comment|/* We didn&squot;t expect this to happen at all. */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;device is bolixed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|sp
comma
id|in_tgterror
)paren
suffix:semicolon
id|esp_done
c_func
(paren
id|esp
comma
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BUS_DEVICE_RESET
suffix:colon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;device reset successful&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|dp-&gt;sync_max_offset
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;sync_min_period
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;sync
op_assign
l_int|0
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|sp
comma
id|in_resetdev
)paren
suffix:semicolon
id|esp_done
c_func
(paren
id|esp
comma
(paren
id|DID_RESET
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ABORT
suffix:colon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;device abort successful&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|sp
comma
id|in_abortone
)paren
suffix:semicolon
id|esp_done
c_func
(paren
id|esp
comma
(paren
id|DID_ABORT
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
DECL|function|esp_enter_msgout
r_static
r_int
id|esp_enter_msgout
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_msgout
)paren
suffix:semicolon
r_return
id|esp_do_msgout
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
DECL|function|esp_enter_msgin
r_static
r_int
id|esp_enter_msgin
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_msgin
)paren
suffix:semicolon
r_return
id|esp_do_msgin
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
DECL|function|esp_enter_cmd
r_static
r_int
id|esp_enter_cmd
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_cmdbegin
)paren
suffix:semicolon
r_return
id|esp_do_cmdbegin
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
DECL|function|esp_enter_badphase
r_static
r_int
id|esp_enter_badphase
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Bizarre bus phase %2x.&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PMASK
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
)brace
DECL|typedef|espfunc_t
r_typedef
r_int
(paren
op_star
id|espfunc_t
)paren
(paren
r_struct
id|NCR_ESP
op_star
comma
r_struct
id|ESP_regs
op_star
)paren
suffix:semicolon
DECL|variable|phase_vector
r_static
id|espfunc_t
id|phase_vector
(braket
)braket
op_assign
(brace
id|esp_do_data
comma
multiline_comment|/* ESP_DOP */
id|esp_do_data
comma
multiline_comment|/* ESP_DIP */
id|esp_enter_cmd
comma
multiline_comment|/* ESP_CMDP */
id|esp_enter_status
comma
multiline_comment|/* ESP_STATP */
id|esp_enter_badphase
comma
multiline_comment|/* ESP_STAT_PMSG */
id|esp_enter_badphase
comma
multiline_comment|/* ESP_STAT_PMSG | ESP_STAT_PIO */
id|esp_enter_msgout
comma
multiline_comment|/* ESP_MOP */
id|esp_enter_msgin
comma
multiline_comment|/* ESP_MIP */
)brace
suffix:semicolon
multiline_comment|/* The target has control of the bus and we have to see where it has&n; * taken us.&n; */
DECL|function|esp_do_phase_determine
r_static
r_int
id|esp_do_phase_determine
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
r_if
c_cond
(paren
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_DC
)paren
op_ne
l_int|0
)paren
r_return
id|esp_disconnect_amidst_phases
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
r_return
id|phase_vector
(braket
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PMASK
)braket
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
multiline_comment|/* First interrupt after exec&squot;ing a cmd comes here. */
DECL|function|esp_select_complete
r_static
r_int
id|esp_select_complete
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
id|Scsi_Device
op_star
id|SDptr
op_assign
id|SCptr-&gt;device
suffix:semicolon
r_int
id|cmd_bytes_sent
comma
id|fcnt
suffix:semicolon
id|fcnt
op_assign
(paren
id|esp_read
c_func
(paren
id|eregs-&gt;esp_fflags
)paren
op_amp
id|ESP_FF_FBYTES
)paren
suffix:semicolon
id|cmd_bytes_sent
op_assign
id|esp
op_member_access_from_pointer
id|dma_bytes_sent
c_func
(paren
id|esp
comma
id|fcnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;dma_invalidate
)paren
(brace
id|esp
op_member_access_from_pointer
id|dma_invalidate
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
multiline_comment|/* Let&squot;s check to see if a reselect happened&n;&t; * while we we&squot;re trying to select.  This must&n;&t; * be checked first.&n;&t; */
r_if
c_cond
(paren
id|esp-&gt;ireg
op_eq
(paren
id|ESP_INTR_RSEL
op_or
id|ESP_INTR_FDONE
)paren
)paren
(brace
id|esp_reconnect
c_func
(paren
id|esp
comma
id|SCptr
)paren
suffix:semicolon
r_return
id|esp_do_reconnect
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
multiline_comment|/* Looks like things worked, we should see a bus service &amp;&n;&t; * a function complete interrupt at this point.  Note we&n;&t; * are doing a direct comparison because we don&squot;t want to&n;&t; * be fooled into thinking selection was successful if&n;&t; * ESP_INTR_DC is set, see below.&n;&t; */
r_if
c_cond
(paren
id|esp-&gt;ireg
op_eq
(paren
id|ESP_INTR_FDONE
op_or
id|ESP_INTR_BSERV
)paren
)paren
(brace
multiline_comment|/* target speaks... */
id|esp-&gt;targets_present
op_or_assign
(paren
l_int|1
op_lshift
id|SCptr-&gt;target
)paren
suffix:semicolon
multiline_comment|/* What if the target ignores the sdtr? */
r_if
c_cond
(paren
id|esp-&gt;snip
)paren
(brace
id|SDptr-&gt;sync
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* See how far, if at all, we got in getting&n;&t;&t; * the information out to the target.&n;&t;&t; */
r_switch
c_cond
(paren
id|esp-&gt;seqreg
)paren
(brace
r_default
suffix:colon
r_case
id|ESP_STEP_ASEL
suffix:colon
multiline_comment|/* Arbitration won, target selected, but&n;&t;&t;&t; * we are in some phase which is not command&n;&t;&t;&t; * phase nor is it message out phase.&n;&t;&t;&t; *&n;&t;&t;&t; * XXX We&squot;ve confused the target, obviously.&n;&t;&t;&t; * XXX So clear it&squot;s state, but we also end&n;&t;&t;&t; * XXX up clearing everyone elses.  That isn&squot;t&n;&t;&t;&t; * XXX so nice.  I&squot;d like to just reset this&n;&t;&t;&t; * XXX target, but if I cannot even get it&squot;s&n;&t;&t;&t; * XXX attention and finish selection to talk&n;&t;&t;&t; * XXX to it, there is not much more I can do.&n;&t;&t;&t; * XXX If we have a loaded bus we&squot;re going to&n;&t;&t;&t; * XXX spend the next second or so renegotiating&n;&t;&t;&t; * XXX for synchronous transfers.&n;&t;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: STEP_ASEL for tgt %d&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|SCptr-&gt;target
)paren
)paren
suffix:semicolon
r_case
id|ESP_STEP_SID
suffix:colon
multiline_comment|/* Arbitration won, target selected, went&n;&t;&t;&t; * to message out phase, sent one message&n;&t;&t;&t; * byte, then we stopped.  ATN is asserted&n;&t;&t;&t; * on the SCSI bus and the target is still&n;&t;&t;&t; * there hanging on.  This is a legal&n;&t;&t;&t; * sequence step if we gave the ESP a select&n;&t;&t;&t; * and stop command.&n;&t;&t;&t; *&n;&t;&t;&t; * XXX See above, I could set the borken flag&n;&t;&t;&t; * XXX in the device struct and retry the&n;&t;&t;&t; * XXX command.  But would that help for&n;&t;&t;&t; * XXX tagged capable targets?&n;&t;&t;&t; */
r_case
id|ESP_STEP_NCMD
suffix:colon
multiline_comment|/* Arbitration won, target selected, maybe&n;&t;&t;&t; * sent the one message byte in message out&n;&t;&t;&t; * phase, but we did not go to command phase&n;&t;&t;&t; * in the end.  Actually, we could have sent&n;&t;&t;&t; * only some of the message bytes if we tried&n;&t;&t;&t; * to send out the entire identify and tag&n;&t;&t;&t; * message using ESP_CMD_SA3.&n;&t;&t;&t; */
id|cmd_bytes_sent
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ESP_STEP_PPC
suffix:colon
multiline_comment|/* No, not the powerPC pinhead.  Arbitration&n;&t;&t;&t; * won, all message bytes sent if we went to&n;&t;&t;&t; * message out phase, went to command phase&n;&t;&t;&t; * but only part of the command was sent.&n;&t;&t;&t; *&n;&t;&t;&t; * XXX I&squot;ve seen this, but usually in conjunction&n;&t;&t;&t; * XXX with a gross error which appears to have&n;&t;&t;&t; * XXX occurred between the time I told the&n;&t;&t;&t; * XXX ESP to arbitrate and when I got the&n;&t;&t;&t; * XXX interrupt.  Could I have misloaded the&n;&t;&t;&t; * XXX command bytes into the fifo?  Actually,&n;&t;&t;&t; * XXX I most likely missed a phase, and therefore&n;&t;&t;&t; * XXX went into never never land and didn&squot;t even&n;&t;&t;&t; * XXX know it.  That was the old driver though.&n;&t;&t;&t; * XXX What is even more peculiar is that the ESP&n;&t;&t;&t; * XXX showed the proper function complete and&n;&t;&t;&t; * XXX bus service bits in the interrupt register.&n;&t;&t;&t; */
r_case
id|ESP_STEP_FINI4
suffix:colon
r_case
id|ESP_STEP_FINI5
suffix:colon
r_case
id|ESP_STEP_FINI6
suffix:colon
r_case
id|ESP_STEP_FINI7
suffix:colon
multiline_comment|/* Account for the identify message */
r_if
c_cond
(paren
id|SCptr-&gt;SCp.phase
op_eq
id|in_slct_norm
)paren
(brace
id|cmd_bytes_sent
op_sub_assign
l_int|1
suffix:semicolon
)brace
)brace
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_NULL
)paren
suffix:semicolon
multiline_comment|/* Be careful, we could really get fucked during synchronous&n;&t;&t; * data transfers if we try to flush the fifo now.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|fcnt
op_logical_and
multiline_comment|/* Fifo is empty and... */
multiline_comment|/* either we are not doing synchronous transfers or... */
(paren
op_logical_neg
id|SDptr-&gt;sync_max_offset
op_logical_or
multiline_comment|/* We are not going into data in phase. */
(paren
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PMASK
)paren
op_ne
id|ESP_DIP
)paren
)paren
)paren
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
)brace
multiline_comment|/* flush is safe */
multiline_comment|/* See how far we got if this is not a slow command. */
r_if
c_cond
(paren
op_logical_neg
id|esp-&gt;esp_slowcmd
)paren
(brace
r_if
c_cond
(paren
id|cmd_bytes_sent
OL
l_int|0
)paren
(brace
id|cmd_bytes_sent
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd_bytes_sent
op_ne
id|SCptr-&gt;cmd_len
)paren
(brace
multiline_comment|/* Crapola, mark it as a slowcmd&n;&t;&t;&t;&t; * so that we have some chance of&n;&t;&t;&t;&t; * keeping the command alive with&n;&t;&t;&t;&t; * good luck.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * XXX Actually, if we didn&squot;t send it all&n;&t;&t;&t;&t; * XXX this means either we didn&squot;t set things&n;&t;&t;&t;&t; * XXX up properly (driver bug) or the target&n;&t;&t;&t;&t; * XXX or the ESP detected parity on one of&n;&t;&t;&t;&t; * XXX the command bytes.  This makes much&n;&t;&t;&t;&t; * XXX more sense, and therefore this code&n;&t;&t;&t;&t; * XXX should be changed to send out a&n;&t;&t;&t;&t; * XXX parity error message or if the status&n;&t;&t;&t;&t; * XXX register shows no parity error then&n;&t;&t;&t;&t; * XXX just expect the target to bring the&n;&t;&t;&t;&t; * XXX bus into message in phase so that it&n;&t;&t;&t;&t; * XXX can send us the parity error message.&n;&t;&t;&t;&t; * XXX SCSI sucks...&n;&t;&t;&t;&t; */
id|esp-&gt;esp_slowcmd
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;esp_scmdp
op_assign
op_amp
(paren
id|SCptr-&gt;cmnd
(braket
id|cmd_bytes_sent
)braket
)paren
suffix:semicolon
id|esp-&gt;esp_scmdleft
op_assign
(paren
id|SCptr-&gt;cmd_len
op_minus
id|cmd_bytes_sent
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Now figure out where we went. */
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|esp_do_phase_determine
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
multiline_comment|/* Did the target even make it? */
r_if
c_cond
(paren
id|esp-&gt;ireg
op_eq
id|ESP_INTR_DC
)paren
(brace
multiline_comment|/* wheee... nobody there or they didn&squot;t like&n;&t;&t; * what we told it to do, clean up.&n;&t;&t; */
multiline_comment|/* If anyone is off the bus, but working on&n;&t;&t; * a command in the background for us, tell&n;&t;&t; * the ESP to listen for them.&n;&t;&t; */
r_if
c_cond
(paren
id|esp-&gt;disconnected_SC
)paren
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_ESEL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
l_int|1
op_lshift
id|SCptr-&gt;target
)paren
op_amp
id|esp-&gt;targets_present
)paren
op_logical_and
id|esp-&gt;seqreg
op_logical_and
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
op_eq
id|EXTENDED_MESSAGE
op_logical_and
(paren
id|SCptr-&gt;SCp.phase
op_eq
id|in_slct_msg
op_logical_or
id|SCptr-&gt;SCp.phase
op_eq
id|in_slct_stop
)paren
)paren
(brace
multiline_comment|/* shit */
id|esp-&gt;snip
op_assign
l_int|0
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Failed synchronous negotiation for target %d &quot;
l_string|&quot;lun %d&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|SCptr-&gt;target
comma
id|SCptr-&gt;lun
)paren
)paren
suffix:semicolon
id|SDptr-&gt;sync_max_offset
op_assign
l_int|0
suffix:semicolon
id|SDptr-&gt;sync_min_period
op_assign
l_int|0
suffix:semicolon
id|SDptr-&gt;sync
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* so we don&squot;t negotiate again */
multiline_comment|/* Run the command again, this time though we&n;&t;&t;&t; * won&squot;t try to negotiate for synchronous transfers.&n;&t;&t;&t; *&n;&t;&t;&t; * XXX I&squot;d like to do something like send an&n;&t;&t;&t; * XXX INITIATOR_ERROR or ABORT message to the&n;&t;&t;&t; * XXX target to tell it, &quot;Sorry I confused you,&n;&t;&t;&t; * XXX please come back and I will be nicer next&n;&t;&t;&t; * XXX time&quot;.  But that requires having the target&n;&t;&t;&t; * XXX on the bus, and it has dropped BSY on us.&n;&t;&t;&t; */
id|esp-&gt;current_SC
op_assign
l_int|NULL
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|not_issued
)paren
suffix:semicolon
id|prepend_SC
c_func
(paren
op_amp
id|esp-&gt;issue_SC
comma
id|SCptr
)paren
suffix:semicolon
id|esp_exec_cmd
c_func
(paren
id|esp
)paren
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
multiline_comment|/* Ok, this is normal, this is what we see during boot&n;&t;&t; * or whenever when we are scanning the bus for targets.&n;&t;&t; * But first make sure that is really what is happening.&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
l_int|1
op_lshift
id|SCptr-&gt;target
)paren
op_amp
id|esp-&gt;targets_present
)paren
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Warning, live target %d not responding to &quot;
l_string|&quot;selection.&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|SCptr-&gt;target
)paren
)paren
suffix:semicolon
multiline_comment|/* This _CAN_ happen.  The SCSI standard states that&n;&t;&t;&t; * the target is to _not_ respond to selection if&n;&t;&t;&t; * _it_ detects bad parity on the bus for any reason.&n;&t;&t;&t; * Therefore, we assume that if we&squot;ve talked successfully&n;&t;&t;&t; * to this target before, bad parity is the problem.&n;&t;&t;&t; */
id|esp_done
c_func
(paren
id|esp
comma
(paren
id|DID_PARITY
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Else, there really isn&squot;t anyone there. */
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;esp: selection failure, maybe nobody there?&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;esp: target %d lun %d&bslash;n&quot;
comma
id|SCptr-&gt;target
comma
id|SCptr-&gt;lun
)paren
)paren
suffix:semicolon
id|esp_done
c_func
(paren
id|esp
comma
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
)brace
r_return
id|do_intr_end
suffix:semicolon
)brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Selection failure.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;esp%d: Currently -- &quot;
comma
id|esp-&gt;esp_id
)paren
suffix:semicolon
id|esp_print_ireg
c_func
(paren
id|esp-&gt;ireg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|esp_print_statreg
c_func
(paren
id|esp-&gt;sreg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|esp_print_seqreg
c_func
(paren
id|esp-&gt;seqreg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;esp%d: New -- &quot;
comma
id|esp-&gt;esp_id
)paren
suffix:semicolon
id|esp-&gt;sreg
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_status
)paren
suffix:semicolon
id|esp-&gt;seqreg
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_sstep
)paren
suffix:semicolon
id|esp-&gt;ireg
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_intrpt
)paren
suffix:semicolon
id|esp_print_ireg
c_func
(paren
id|esp-&gt;ireg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|esp_print_statreg
c_func
(paren
id|esp-&gt;sreg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|esp_print_seqreg
c_func
(paren
id|esp-&gt;seqreg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: resetting bus&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
multiline_comment|/* ugh... */
)brace
multiline_comment|/* Continue reading bytes for msgin phase. */
DECL|function|esp_do_msgincont
r_static
r_int
id|esp_do_msgincont
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_BSERV
)paren
(brace
multiline_comment|/* in the right phase too? */
r_if
c_cond
(paren
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PMASK
)paren
op_eq
id|ESP_MIP
)paren
(brace
multiline_comment|/* phew... */
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_msgindone
)paren
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
multiline_comment|/* We changed phase but ESP shows bus service,&n;&t;&t; * in this case it is most likely that we, the&n;&t;&t; * hacker who has been up for 20hrs straight&n;&t;&t; * staring at the screen, drowned in coffee&n;&t;&t; * smelling like retched cigarette ashes&n;&t;&t; * have miscoded something..... so, try to&n;&t;&t; * recover as best we can.&n;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: message in mis-carriage.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
)brace
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|do_phase_determine
suffix:semicolon
)brace
DECL|function|check_singlebyte_msg
r_static
r_int
id|check_singlebyte_msg
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|esp-&gt;prevmsgin
op_assign
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
(brace
multiline_comment|/* wheee... */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: target sends identify amidst phases&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
op_logical_or
(paren
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
op_eq
id|EXTENDED_MESSAGE
)paren
)paren
(brace
id|esp-&gt;msgin_len
op_assign
l_int|2
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_msgincont
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_the_dark
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
)paren
(brace
r_default
suffix:colon
multiline_comment|/* We don&squot;t want to hear about it. */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: msg %02x which we don&squot;t know about&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_return
id|MESSAGE_REJECT
suffix:semicolon
r_case
id|NOP
suffix:colon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: target %d sends a nop&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;current_SC-&gt;target
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|RESTORE_POINTERS
suffix:colon
multiline_comment|/* In this case we might also have to backup the&n;&t;&t; * &quot;slow command&quot; pointer.  It is rare to get such&n;&t;&t; * a save/restore pointer sequence so early in the&n;&t;&t; * bus transition sequences, but cover it.&n;&t;&t; */
r_if
c_cond
(paren
id|esp-&gt;esp_slowcmd
)paren
(brace
id|esp-&gt;esp_scmdleft
op_assign
id|esp-&gt;current_SC-&gt;cmd_len
suffix:semicolon
id|esp-&gt;esp_scmdp
op_assign
op_amp
id|esp-&gt;current_SC-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|esp_restore_pointers
c_func
(paren
id|esp
comma
id|esp-&gt;current_SC
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SAVE_POINTERS
suffix:colon
id|esp_save_pointers
c_func
(paren
id|esp
comma
id|esp-&gt;current_SC
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|COMMAND_COMPLETE
suffix:colon
r_case
id|DISCONNECT
suffix:colon
multiline_comment|/* Freeing the bus, let it go. */
id|esp-&gt;current_SC-&gt;SCp.phase
op_assign
id|in_freeing
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|MESSAGE_REJECT
suffix:colon
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;msg reject, &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;prevmsgout
op_eq
id|EXTENDED_MESSAGE
)paren
(brace
id|Scsi_Device
op_star
id|SDptr
op_assign
id|esp-&gt;current_SC-&gt;device
suffix:semicolon
multiline_comment|/* Doesn&squot;t look like this target can&n;&t;&t;&t; * do synchronous or WIDE transfers.&n;&t;&t;&t; */
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;got reject, was trying nego, clearing sync/WIDE&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|SDptr-&gt;sync
op_assign
l_int|1
suffix:semicolon
id|SDptr-&gt;wide
op_assign
l_int|1
suffix:semicolon
id|SDptr-&gt;sync_min_period
op_assign
l_int|0
suffix:semicolon
id|SDptr-&gt;sync_max_offset
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;not sync nego, sending ABORT&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|ABORT
suffix:semicolon
)brace
)brace
suffix:semicolon
)brace
multiline_comment|/* Target negotiates for synchronous transfers before we do, this&n; * is legal although very strange.  What is even funnier is that&n; * the SCSI2 standard specifically recommends against targets doing&n; * this because so many initiators cannot cope with this occuring.&n; */
DECL|function|target_with_ants_in_pants
r_static
r_int
id|target_with_ants_in_pants
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|SCptr
comma
id|Scsi_Device
op_star
id|SDptr
)paren
(brace
r_if
c_cond
(paren
id|SDptr-&gt;sync
op_logical_or
id|SDptr-&gt;borken
)paren
(brace
multiline_comment|/* sorry, no can do */
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;forcing to async, &quot;
)paren
)paren
suffix:semicolon
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|SDptr-&gt;sync
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|1
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: hoping for msgout&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|EXTENDED_MESSAGE
suffix:semicolon
)brace
multiline_comment|/* Ok, we&squot;ll check them out... */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sync_report
r_static
r_void
id|sync_report
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
(brace
r_int
id|msg3
comma
id|msg4
suffix:semicolon
r_char
op_star
id|type
suffix:semicolon
id|msg3
op_assign
id|esp-&gt;cur_msgin
(braket
l_int|3
)braket
suffix:semicolon
id|msg4
op_assign
id|esp-&gt;cur_msgin
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|msg4
)paren
(brace
r_int
id|hz
op_assign
l_int|1000000000
op_div
(paren
id|msg3
op_star
l_int|4
)paren
suffix:semicolon
r_int
id|integer
op_assign
id|hz
op_div
l_int|1000000
suffix:semicolon
r_int
id|fraction
op_assign
(paren
id|hz
op_minus
(paren
id|integer
op_star
l_int|1000000
)paren
)paren
op_div
l_int|10000
suffix:semicolon
r_if
c_cond
(paren
(paren
id|msg3
op_star
l_int|4
)paren
OL
l_int|200
)paren
(brace
id|type
op_assign
l_string|&quot;FAST&quot;
suffix:semicolon
)brace
r_else
(brace
id|type
op_assign
l_string|&quot;synchronous&quot;
suffix:semicolon
)brace
multiline_comment|/* Do not transform this back into one big printk&n;&t;&t; * again, it triggers a bug in our sparc64-gcc272&n;&t;&t; * sibling call optimization.  -DaveM&n;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
id|KERN_INFO
l_string|&quot;esp%d: target %d &quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;current_SC-&gt;target
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;[period %dns offset %d %d.%02dMHz &quot;
comma
(paren
r_int
)paren
id|msg3
op_star
l_int|4
comma
(paren
r_int
)paren
id|msg4
comma
id|integer
comma
id|fraction
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;%s SCSI%s]&bslash;n&quot;
comma
id|type
comma
(paren
(paren
(paren
id|msg3
op_star
l_int|4
)paren
OL
l_int|200
)paren
ques
c_cond
l_string|&quot;-II&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ESPLOG
c_func
(paren
(paren
id|KERN_INFO
l_string|&quot;esp%d: target %d asynchronous&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;current_SC-&gt;target
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|check_multibyte_msg
r_static
r_int
id|check_multibyte_msg
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
id|Scsi_Device
op_star
id|SDptr
op_assign
id|SCptr-&gt;device
suffix:semicolon
id|unchar
id|regval
op_assign
l_int|0
suffix:semicolon
r_int
id|message_out
op_assign
l_int|0
suffix:semicolon
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;chk multibyte msg: &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;cur_msgin
(braket
l_int|2
)braket
op_eq
id|EXTENDED_SDTR
)paren
(brace
r_int
id|period
op_assign
id|esp-&gt;cur_msgin
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|offset
op_assign
id|esp-&gt;cur_msgin
(braket
l_int|4
)braket
suffix:semicolon
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;is sync nego response, &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|esp-&gt;snip
)paren
(brace
r_int
id|rval
suffix:semicolon
multiline_comment|/* Target negotiates first! */
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;target jumps the gun, &quot;
)paren
)paren
suffix:semicolon
id|message_out
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
multiline_comment|/* we must respond */
id|rval
op_assign
id|target_with_ants_in_pants
c_func
(paren
id|esp
comma
id|SCptr
comma
id|SDptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
)brace
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;examining sdtr, &quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Offset cannot be larger than ESP fifo size. */
r_if
c_cond
(paren
id|offset
OG
l_int|15
)paren
(brace
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;offset too big %2x, &quot;
comma
id|offset
)paren
)paren
suffix:semicolon
id|offset
op_assign
l_int|15
suffix:semicolon
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;sending back new offset&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
id|period
comma
id|offset
)paren
suffix:semicolon
r_return
id|EXTENDED_MESSAGE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
op_logical_and
id|period
OG
id|esp-&gt;max_period
)paren
(brace
multiline_comment|/* Yeee, async for this slow device. */
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;period too long %2x, &quot;
comma
id|period
)paren
)paren
suffix:semicolon
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;hoping for msgout&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|EXTENDED_MESSAGE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|offset
op_logical_and
id|period
OL
id|esp-&gt;min_period
)paren
(brace
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;period too short %2x, &quot;
comma
id|period
)paren
)paren
suffix:semicolon
id|period
op_assign
id|esp-&gt;min_period
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
OG
id|esp236
)paren
(brace
id|regval
op_assign
l_int|4
suffix:semicolon
)brace
r_else
id|regval
op_assign
l_int|5
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|offset
)paren
(brace
r_int
id|tmp
suffix:semicolon
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;period is ok, &quot;
)paren
)paren
suffix:semicolon
id|tmp
op_assign
id|esp-&gt;ccycle
op_div
l_int|1000
suffix:semicolon
id|regval
op_assign
(paren
(paren
(paren
id|period
op_lshift
l_int|2
)paren
op_plus
id|tmp
op_minus
l_int|1
)paren
op_div
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regval
op_logical_and
(paren
id|esp-&gt;erev
OG
id|esp236
)paren
)paren
(brace
r_if
c_cond
(paren
id|period
op_ge
l_int|50
)paren
(brace
id|regval
op_decrement
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|offset
)paren
(brace
id|unchar
id|bit
suffix:semicolon
id|SDptr-&gt;sync_min_period
op_assign
(paren
id|regval
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|SDptr-&gt;sync_max_offset
op_assign
(paren
id|offset
op_or
id|esp-&gt;radelay
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
OG
id|esp236
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fas100a
)paren
(brace
id|bit
op_assign
id|ESP_CONFIG3_FAST
suffix:semicolon
)brace
r_else
id|bit
op_assign
id|ESP_CONFIG3_FSCSI
suffix:semicolon
r_if
c_cond
(paren
id|period
OL
l_int|50
)paren
(brace
id|esp-&gt;config3
(braket
id|SCptr-&gt;target
)braket
op_or_assign
id|bit
suffix:semicolon
)brace
r_else
id|esp-&gt;config3
(braket
id|SCptr-&gt;target
)braket
op_and_assign
op_complement
id|bit
suffix:semicolon
id|esp-&gt;prev_cfg3
op_assign
id|esp-&gt;config3
(braket
id|SCptr-&gt;target
)braket
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg3
comma
id|esp-&gt;prev_cfg3
)paren
suffix:semicolon
)brace
id|esp-&gt;prev_soff
op_assign
id|SDptr-&gt;sync_min_period
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_soff
comma
id|esp-&gt;prev_soff
)paren
suffix:semicolon
id|esp-&gt;prev_stp
op_assign
id|SDptr-&gt;sync_max_offset
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_stp
comma
id|esp-&gt;prev_stp
)paren
suffix:semicolon
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;soff=%2x stp=%2x cfg3=%2x&bslash;n&quot;
comma
id|SDptr-&gt;sync_max_offset
comma
id|SDptr-&gt;sync_min_period
comma
id|esp-&gt;config3
(braket
id|SCptr-&gt;target
)braket
)paren
)paren
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SDptr-&gt;sync_max_offset
)paren
(brace
id|unchar
id|bit
suffix:semicolon
multiline_comment|/* back to async mode */
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;unaccaptable sync nego, forcing async&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|SDptr-&gt;sync_max_offset
op_assign
l_int|0
suffix:semicolon
id|SDptr-&gt;sync_min_period
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;prev_soff
op_assign
l_int|0
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_soff
comma
l_int|0
)paren
suffix:semicolon
id|esp-&gt;prev_stp
op_assign
l_int|0
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_stp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
OG
id|esp236
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fas100a
)paren
(brace
id|bit
op_assign
id|ESP_CONFIG3_FAST
suffix:semicolon
)brace
r_else
id|bit
op_assign
id|ESP_CONFIG3_FSCSI
suffix:semicolon
id|esp-&gt;config3
(braket
id|SCptr-&gt;target
)braket
op_and_assign
op_complement
id|bit
suffix:semicolon
id|esp-&gt;prev_cfg3
op_assign
id|esp-&gt;config3
(braket
id|SCptr-&gt;target
)braket
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_cfg3
comma
id|esp-&gt;prev_cfg3
)paren
suffix:semicolon
)brace
)brace
id|sync_report
c_func
(paren
id|esp
)paren
suffix:semicolon
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;chk multibyte msg: sync is known, &quot;
)paren
)paren
suffix:semicolon
id|SDptr-&gt;sync
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|message_out
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: sending sdtr back, hoping for msgout&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
id|period
comma
id|offset
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|EXTENDED_MESSAGE
suffix:semicolon
)brace
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;returning zero&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
multiline_comment|/* ...or else! */
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;cur_msgin
(braket
l_int|2
)braket
op_eq
id|EXTENDED_WDTR
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: AIEEE wide msg received&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|message_out
op_assign
id|MESSAGE_REJECT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;cur_msgin
(braket
l_int|2
)braket
op_eq
id|EXTENDED_MODIFY_DATA_POINTER
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: rejecting modify data ptr msg&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|message_out
op_assign
id|MESSAGE_REJECT
suffix:semicolon
)brace
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|message_out
suffix:semicolon
)brace
DECL|function|esp_do_msgindone
r_static
r_int
id|esp_do_msgindone
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
r_int
id|message_out
op_assign
l_int|0
comma
id|it
op_assign
l_int|0
comma
id|rval
suffix:semicolon
id|rval
op_assign
id|skipahead1
c_func
(paren
id|esp
comma
id|eregs
comma
id|SCptr
comma
id|in_msgin
comma
id|in_msgindone
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCptr-&gt;SCp.sent_command
op_ne
id|in_status
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_DC
)paren
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;msgin_len
op_logical_and
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PERR
)paren
)paren
(brace
id|message_out
op_assign
id|MSG_PARITY_ERROR
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|it
op_assign
(paren
id|esp_read
c_func
(paren
id|eregs-&gt;esp_fflags
)paren
op_amp
id|ESP_FF_FBYTES
)paren
)paren
op_ne
l_int|1
)paren
(brace
multiline_comment|/* We certainly dropped the ball somewhere. */
id|message_out
op_assign
id|INITIATOR_ERROR
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|esp-&gt;msgin_len
)paren
(brace
id|it
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_fdata
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_msgincont
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* it is ok and we want it */
id|it
op_assign
id|esp-&gt;cur_msgin
(braket
id|esp-&gt;msgin_ctr
)braket
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_fdata
)paren
suffix:semicolon
id|esp-&gt;msgin_ctr
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|do_work_bus
suffix:semicolon
)brace
)brace
r_else
(brace
id|it
op_assign
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|message_out
op_logical_and
id|esp-&gt;msgin_len
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;msgin_ctr
OL
id|esp-&gt;msgin_len
)paren
(brace
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_msgincont
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;msgin_len
op_eq
l_int|1
)paren
(brace
id|message_out
op_assign
id|check_singlebyte_msg
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;msgin_len
op_eq
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
op_eq
id|EXTENDED_MESSAGE
)paren
(brace
r_if
c_cond
(paren
(paren
id|it
op_plus
l_int|2
)paren
op_ge
l_int|15
)paren
(brace
id|message_out
op_assign
id|MESSAGE_REJECT
suffix:semicolon
)brace
r_else
(brace
id|esp-&gt;msgin_len
op_assign
(paren
id|it
op_plus
l_int|2
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_msgincont
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|message_out
op_assign
id|MESSAGE_REJECT
suffix:semicolon
multiline_comment|/* foo on you */
)brace
)brace
r_else
(brace
id|message_out
op_assign
id|check_multibyte_msg
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|message_out
OL
l_int|0
)paren
(brace
r_return
op_minus
id|message_out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|message_out
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|message_out
op_ne
l_int|1
)paren
op_logical_and
(paren
(paren
id|message_out
OL
l_int|0x20
)paren
op_logical_or
(paren
id|message_out
op_amp
l_int|0x80
)paren
)paren
)paren
)paren
(brace
id|esp-&gt;msgout_len
op_assign
l_int|1
suffix:semicolon
)brace
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
op_assign
id|message_out
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_SATN
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
id|esp-&gt;msgin_len
op_assign
l_int|0
suffix:semicolon
)brace
id|esp-&gt;sreg
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_status
)paren
suffix:semicolon
id|esp-&gt;sreg
op_and_assign
op_complement
(paren
id|ESP_STAT_INTR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|esp-&gt;sreg
op_amp
(paren
id|ESP_STAT_PMSG
op_or
id|ESP_STAT_PCD
)paren
)paren
op_eq
(paren
id|ESP_STAT_PMSG
op_or
id|ESP_STAT_PCD
)paren
)paren
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_MOK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|SCptr-&gt;SCp.sent_command
op_eq
id|in_msgindone
)paren
op_logical_and
(paren
id|SCptr-&gt;SCp.phase
op_eq
id|in_freeing
)paren
)paren
(brace
r_return
id|esp_do_freebus
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
r_return
id|do_intr_end
suffix:semicolon
)brace
DECL|function|esp_do_cmdbegin
r_static
r_int
id|esp_do_cmdbegin
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
r_int
r_char
id|tmp
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_cmdend
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
id|tmp
op_assign
op_star
id|esp-&gt;esp_scmdp
op_increment
suffix:semicolon
id|esp-&gt;esp_scmdleft
op_decrement
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_fdata
comma
id|tmp
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
DECL|function|esp_do_cmddone
r_static
r_int
id|esp_do_cmddone
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_BSERV
)paren
(brace
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|esp_do_phase_determine
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: in do_cmddone() but didn&squot;t get BSERV interrupt.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
)brace
DECL|function|esp_do_msgout
r_static
r_int
id|esp_do_msgout
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|esp-&gt;msgout_len
)paren
(brace
r_case
l_int|1
suffix:colon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_fdata
comma
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|esp-&gt;do_pio_cmds
)paren
(brace
id|esp_write
c_func
(paren
id|eregs-&gt;esp_fdata
comma
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_fdata
comma
id|esp-&gt;cur_msgout
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
)brace
r_else
(brace
id|esp-&gt;esp_command
(braket
l_int|0
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|1
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|1
)braket
suffix:semicolon
id|esp
op_member_access_from_pointer
id|dma_setup
c_func
(paren
id|esp
comma
id|esp-&gt;esp_command_dvma
comma
l_int|2
comma
l_int|0
)paren
suffix:semicolon
id|esp_setcount
c_func
(paren
id|eregs
comma
l_int|2
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_DMA
op_or
id|ESP_CMD_TI
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|esp-&gt;snip
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;do_pio_cmds
)paren
(brace
id|esp_write
c_func
(paren
id|eregs-&gt;esp_fdata
comma
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_fdata
comma
id|esp-&gt;cur_msgout
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_fdata
comma
id|esp-&gt;cur_msgout
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_fdata
comma
id|esp-&gt;cur_msgout
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
)brace
r_else
(brace
id|esp-&gt;esp_command
(braket
l_int|0
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|1
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|1
)braket
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|2
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|2
)braket
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|3
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|3
)braket
suffix:semicolon
id|esp
op_member_access_from_pointer
id|dma_setup
c_func
(paren
id|esp
comma
id|esp-&gt;esp_command_dvma
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|esp_setcount
c_func
(paren
id|eregs
comma
l_int|4
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_DMA
op_or
id|ESP_CMD_TI
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|esp-&gt;snip
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;do_pio_cmds
)paren
(brace
id|esp_write
c_func
(paren
id|eregs-&gt;esp_fdata
comma
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_fdata
comma
id|esp-&gt;cur_msgout
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_fdata
comma
id|esp-&gt;cur_msgout
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_fdata
comma
id|esp-&gt;cur_msgout
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_fdata
comma
id|esp-&gt;cur_msgout
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
)brace
r_else
(brace
id|esp-&gt;esp_command
(braket
l_int|0
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|1
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|1
)braket
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|2
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|2
)braket
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|3
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|3
)braket
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|4
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|4
)braket
suffix:semicolon
id|esp
op_member_access_from_pointer
id|dma_setup
c_func
(paren
id|esp
comma
id|esp-&gt;esp_command_dvma
comma
l_int|5
comma
l_int|0
)paren
suffix:semicolon
id|esp_setcount
c_func
(paren
id|eregs
comma
l_int|5
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_DMA
op_or
id|ESP_CMD_TI
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* whoops */
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;bogus msgout sending NOP&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
op_assign
id|NOP
suffix:semicolon
id|esp_write
c_func
(paren
id|eregs-&gt;esp_fdata
comma
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|esp-&gt;msgout_len
op_assign
l_int|1
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_msgoutdone
)paren
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
DECL|function|esp_do_msgoutdone
r_static
r_int
id|esp_do_msgoutdone
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
r_if
c_cond
(paren
(paren
id|esp-&gt;msgout_len
OG
l_int|1
)paren
op_logical_and
id|esp-&gt;dma_barrier
)paren
(brace
id|esp
op_member_access_from_pointer
id|dma_barrier
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_DC
)paren
)paren
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_NULL
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PMASK
)paren
(brace
r_case
id|ESP_MOP
suffix:colon
multiline_comment|/* whoops, parity error */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: still in msgout, parity error assumed&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;msgout_len
OG
l_int|1
)paren
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_SATN
)paren
suffix:semicolon
)brace
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_msgout
)paren
suffix:semicolon
r_return
id|do_work_bus
suffix:semicolon
r_case
id|ESP_DIP
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|fcount
c_func
(paren
id|esp
comma
id|eregs
)paren
op_logical_and
op_logical_neg
(paren
id|esp-&gt;current_SC-&gt;device-&gt;sync_max_offset
)paren
)paren
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|eregs
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/* If we sent out a synchronous negotiation message, update&n;&t; * our state.&n;&t; */
r_if
c_cond
(paren
id|esp-&gt;cur_msgout
(braket
l_int|2
)braket
op_eq
id|EXTENDED_MESSAGE
op_logical_and
id|esp-&gt;cur_msgout
(braket
l_int|4
)braket
op_eq
id|EXTENDED_SDTR
)paren
(brace
id|esp-&gt;snip
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* anal retentiveness... */
)brace
id|esp-&gt;prevmsgout
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
suffix:semicolon
id|esp-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|esp_do_phase_determine
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
DECL|function|esp_bus_unexpected
r_static
r_int
id|esp_bus_unexpected
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: command in weird state %2x&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;current_SC-&gt;SCp.phase
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
)brace
DECL|variable|bus_vector
r_static
id|espfunc_t
id|bus_vector
(braket
)braket
op_assign
(brace
id|esp_do_data_finale
comma
id|esp_do_data_finale
comma
id|esp_bus_unexpected
comma
id|esp_do_msgin
comma
id|esp_do_msgincont
comma
id|esp_do_msgindone
comma
id|esp_do_msgout
comma
id|esp_do_msgoutdone
comma
id|esp_do_cmdbegin
comma
id|esp_do_cmddone
comma
id|esp_do_status
comma
id|esp_do_freebus
comma
id|esp_do_phase_determine
comma
id|esp_bus_unexpected
comma
id|esp_bus_unexpected
comma
id|esp_bus_unexpected
comma
)brace
suffix:semicolon
multiline_comment|/* This is the second tier in our dual-level SCSI state machine. */
DECL|function|esp_work_bus
r_static
r_int
id|esp_work_bus
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
comma
r_struct
id|ESP_regs
op_star
id|eregs
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
r_int
r_int
id|phase
suffix:semicolon
id|ESPBUS
c_func
(paren
(paren
l_string|&quot;esp_work_bus: &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCptr
)paren
(brace
id|ESPBUS
c_func
(paren
(paren
l_string|&quot;reconnect&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|esp_do_reconnect
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
id|phase
op_assign
id|SCptr-&gt;SCp.phase
suffix:semicolon
r_if
c_cond
(paren
(paren
id|phase
op_amp
l_int|0xf0
)paren
op_eq
id|in_phases_mask
)paren
r_return
id|bus_vector
(braket
(paren
id|phase
op_amp
l_int|0x0f
)paren
)braket
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|phase
op_amp
l_int|0xf0
)paren
op_eq
id|in_slct_mask
)paren
(brace
r_return
id|esp_select_complete
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
r_else
r_return
id|esp_bus_unexpected
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
DECL|variable|isvc_vector
r_static
id|espfunc_t
id|isvc_vector
(braket
)braket
op_assign
(brace
l_int|0
comma
id|esp_do_phase_determine
comma
id|esp_do_resetbus
comma
id|esp_finish_reset
comma
id|esp_work_bus
)brace
suffix:semicolon
multiline_comment|/* Main interrupt handler for an esp adapter. */
DECL|function|esp_handle
r_void
id|esp_handle
c_func
(paren
r_struct
id|NCR_ESP
op_star
id|esp
)paren
(brace
r_struct
id|ESP_regs
op_star
id|eregs
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCptr
suffix:semicolon
r_int
id|what_next
op_assign
id|do_intr_end
suffix:semicolon
id|eregs
op_assign
id|esp-&gt;eregs
suffix:semicolon
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;dma_irq_entry
)paren
(brace
id|esp
op_member_access_from_pointer
id|dma_irq_entry
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for errors. */
id|esp-&gt;sreg
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_status
)paren
suffix:semicolon
id|esp-&gt;sreg
op_and_assign
(paren
op_complement
id|ESP_STAT_INTR
)paren
suffix:semicolon
id|esp-&gt;seqreg
op_assign
(paren
id|esp_read
c_func
(paren
id|eregs-&gt;esp_sstep
)paren
op_amp
id|ESP_STEP_VBITS
)paren
suffix:semicolon
id|esp-&gt;ireg
op_assign
id|esp_read
c_func
(paren
id|eregs-&gt;esp_intrpt
)paren
suffix:semicolon
multiline_comment|/* Unlatch intr and stat regs */
id|ESPIRQ
c_func
(paren
(paren
l_string|&quot;handle_irq: [sreg&lt;%02x&gt; sstep&lt;%02x&gt; ireg&lt;%02x&gt;]&bslash;n&quot;
comma
id|esp-&gt;sreg
comma
id|esp-&gt;seqreg
comma
id|esp-&gt;ireg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;sreg
op_amp
(paren
id|ESP_STAT_SPAM
)paren
)paren
(brace
multiline_comment|/* Gross error, could be due to one of:&n;&t;&t; *&n;&t;&t; * - top of fifo overwritten, could be because&n;&t;&t; *   we tried to do a synchronous transfer with&n;&t;&t; *   an offset greater than ESP fifo size&n;&t;&t; *&n;&t;&t; * - top of command register overwritten&n;&t;&t; *&n;&t;&t; * - DMA setup to go in one direction, SCSI&n;&t;&t; *   bus points in the other, whoops&n;&t;&t; *&n;&t;&t; * - weird phase change during asynchronous&n;&t;&t; *   data phase while we are initiator&n;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Gross error sreg=%2x&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;sreg
)paren
)paren
suffix:semicolon
multiline_comment|/* If a command is live on the bus we cannot safely&n;&t;&t; * reset the bus, so we&squot;ll just let the pieces fall&n;&t;&t; * where they may.  Here we are hoping that the&n;&t;&t; * target will be able to cleanly go away soon&n;&t;&t; * so we can safely reset things.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|SCptr
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: No current cmd during gross error, &quot;
l_string|&quot;resetting bus&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|what_next
op_assign
id|do_reset_bus
suffix:semicolon
r_goto
id|state_machine
suffix:semicolon
)brace
)brace
multiline_comment|/* No current cmd is only valid at this point when there are&n;&t; * commands off the bus or we are trying a reset.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|SCptr
op_logical_and
op_logical_neg
id|esp-&gt;disconnected_SC
op_logical_and
op_logical_neg
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_SR
)paren
)paren
(brace
multiline_comment|/* Panic is safe, since current_SC is null. */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: no command in esp_handle()&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;esp_handle: current_SC == penguin within interrupt!&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|esp-&gt;ireg
op_amp
(paren
id|ESP_INTR_IC
)paren
)paren
(brace
multiline_comment|/* Illegal command fed to ESP.  Outside of obvious&n;&t;&t; * software bugs that could cause this, there is&n;&t;&t; * a condition with ESP100 where we can confuse the&n;&t;&t; * ESP into an erroneous illegal command interrupt&n;&t;&t; * because it does not scrape the FIFO properly&n;&t;&t; * for reselection.  See esp100_reconnect_hwbug()&n;&t;&t; * to see how we try very hard to avoid this.&n;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: illegal command&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp_dump_state
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCptr
)paren
(brace
multiline_comment|/* Devices with very buggy firmware can drop BSY&n;&t;&t;&t; * during a scatter list interrupt when using sync&n;&t;&t;&t; * mode transfers.  We continue the transfer as&n;&t;&t;&t; * expected, the target drops the bus, the ESP&n;&t;&t;&t; * gets confused, and we get a illegal command&n;&t;&t;&t; * interrupt because the bus is in the disconnected&n;&t;&t;&t; * state now and ESP_CMD_TI is only allowed when&n;&t;&t;&t; * a nexus is alive on the bus.&n;&t;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Forcing async and disabling disconnect for &quot;
l_string|&quot;target %d&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|SCptr-&gt;target
)paren
)paren
suffix:semicolon
id|SCptr-&gt;device-&gt;borken
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* foo on you */
)brace
id|what_next
op_assign
id|do_reset_bus
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;ireg
op_amp
op_complement
(paren
id|ESP_INTR_FDONE
op_or
id|ESP_INTR_BSERV
op_or
id|ESP_INTR_DC
)paren
)paren
)paren
(brace
r_int
id|phase
suffix:semicolon
r_if
c_cond
(paren
id|SCptr
)paren
(brace
id|phase
op_assign
id|SCptr-&gt;SCp.phase
suffix:semicolon
r_if
c_cond
(paren
id|phase
op_amp
id|in_phases_mask
)paren
(brace
id|what_next
op_assign
id|esp_work_bus
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|phase
op_amp
id|in_slct_mask
)paren
(brace
id|what_next
op_assign
id|esp_select_complete
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
r_else
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: interrupt for no good reason...&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|what_next
op_assign
id|do_intr_end
suffix:semicolon
)brace
)brace
r_else
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: BSERV or FDONE or DC while SCptr==NULL&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|what_next
op_assign
id|do_reset_bus
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_SR
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: SCSI bus reset interrupt&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|what_next
op_assign
id|do_reset_complete
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;ireg
op_amp
(paren
id|ESP_INTR_S
op_or
id|ESP_INTR_SATN
)paren
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: AIEEE we have been selected by another initiator!&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|what_next
op_assign
id|do_reset_bus
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_RSEL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|SCptr
)paren
(brace
multiline_comment|/* This is ok. */
id|what_next
op_assign
id|esp_do_reconnect
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SCptr-&gt;SCp.phase
op_amp
id|in_slct_mask
)paren
(brace
multiline_comment|/* Only selection code knows how to clean&n;&t;&t;&t; * up properly.&n;&t;&t;&t; */
id|ESPDISC
c_func
(paren
(paren
l_string|&quot;Reselected during selection attempt&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|what_next
op_assign
id|esp_select_complete
c_func
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
)brace
r_else
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Reselected while bus is busy&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|what_next
op_assign
id|do_reset_bus
suffix:semicolon
)brace
)brace
multiline_comment|/* This is tier-one in our dual level SCSI state machine. */
id|state_machine
suffix:colon
r_while
c_loop
(paren
id|what_next
op_ne
id|do_intr_end
)paren
(brace
r_if
c_cond
(paren
id|what_next
op_ge
id|do_phase_determine
op_logical_and
id|what_next
OL
id|do_intr_end
)paren
id|what_next
op_assign
id|isvc_vector
(braket
id|what_next
)braket
(paren
id|esp
comma
id|eregs
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* state is completely lost ;-( */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: interrupt engine loses state, resetting bus&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|what_next
op_assign
id|do_reset_bus
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|esp-&gt;dma_irq_exit
)paren
(brace
id|esp
op_member_access_from_pointer
id|dma_irq_exit
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifndef CONFIG_SMP
DECL|function|esp_intr
r_void
id|esp_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|pregs
)paren
(brace
r_struct
id|NCR_ESP
op_star
id|esp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|again
suffix:semicolon
multiline_comment|/* Handle all ESP interrupts showing at this IRQ level. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|repeat
suffix:colon
id|again
op_assign
l_int|0
suffix:semicolon
id|for_each_esp
c_func
(paren
id|esp
)paren
(brace
macro_line|#ifndef __mips__&t;    
r_if
c_cond
(paren
(paren
(paren
id|esp
)paren
op_member_access_from_pointer
id|irq
op_amp
l_int|0xff
)paren
op_eq
id|irq
)paren
(brace
macro_line|#endif&t;&t;    
r_if
c_cond
(paren
id|esp
op_member_access_from_pointer
id|dma_irq_p
c_func
(paren
id|esp
)paren
)paren
(brace
id|again
op_assign
l_int|1
suffix:semicolon
id|esp
op_member_access_from_pointer
id|dma_ints_off
c_func
(paren
id|esp
)paren
suffix:semicolon
id|ESPIRQ
c_func
(paren
(paren
l_string|&quot;I%d(&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp_handle
c_func
(paren
id|esp
)paren
suffix:semicolon
id|ESPIRQ
c_func
(paren
(paren
l_string|&quot;)&quot;
)paren
)paren
suffix:semicolon
id|esp
op_member_access_from_pointer
id|dma_ints_on
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
macro_line|#ifndef __mips__&t;&t;    
)brace
macro_line|#endif&t;    
)brace
r_if
c_cond
(paren
id|again
)paren
(brace
r_goto
id|repeat
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/* For SMP we only service one ESP on the list list at our IRQ level! */
DECL|function|esp_intr
r_void
id|esp_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|pregs
)paren
(brace
r_struct
id|NCR_ESP
op_star
id|esp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Handle all ESP interrupts showing at this IRQ level. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|for_each_esp
c_func
(paren
id|esp
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|esp
)paren
op_member_access_from_pointer
id|irq
op_amp
l_int|0xf
)paren
op_eq
id|irq
)paren
(brace
r_if
c_cond
(paren
id|esp
op_member_access_from_pointer
id|dma_irq_p
c_func
(paren
id|esp
)paren
)paren
(brace
id|esp
op_member_access_from_pointer
id|dma_ints_off
c_func
(paren
id|esp
)paren
suffix:semicolon
id|ESPIRQ
c_func
(paren
(paren
l_string|&quot;I[%d:%d](&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp_handle
c_func
(paren
id|esp
)paren
suffix:semicolon
id|ESPIRQ
c_func
(paren
(paren
l_string|&quot;)&quot;
)paren
)paren
suffix:semicolon
id|esp
op_member_access_from_pointer
id|dma_ints_on
c_func
(paren
id|esp
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
)brace
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
)brace
DECL|function|esp_release
r_void
id|esp_release
c_func
(paren
r_void
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|esps_in_use
op_decrement
suffix:semicolon
id|esps_running
op_assign
id|esps_in_use
suffix:semicolon
)brace
macro_line|#endif
eof
