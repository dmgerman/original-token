multiline_comment|/*+M*************************************************************************&n; * Adaptec AIC7xxx device driver for Linux.&n; *&n; * Copyright (c) 1994 John Aycock&n; *   The University of Calgary Department of Computer Science.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Sources include the Adaptec 1740 driver (aha1740.c), the Ultrastor 24F&n; * driver (ultrastor.c), various Linux kernel source, the Adaptec EISA&n; * config file (!adp7771.cfg), the Adaptec AHA-2740A Series User&squot;s Guide,&n; * the Linux Kernel Hacker&squot;s Guide, Writing a SCSI Device Driver for Linux,&n; * the Adaptec 1542 driver (aha1542.c), the Adaptec EISA overlay file&n; * (adp7770.ovl), the Adaptec AHA-2740 Series Technical Reference Manual,&n; * the Adaptec AIC-7770 Data Book, the ANSI SCSI specification, the&n; * ANSI SCSI-2 specification (draft 10c), ...&n; *&n; * --------------------------------------------------------------------------&n; *&n; *  Modifications by Daniel M. Eischen (deischen@iworks.InterWorks.org):&n; *&n; *  Substantially modified to include support for wide and twin bus&n; *  adapters, DMAing of SCBs, tagged queueing, IRQ sharing, bug fixes,&n; *  SCB paging, and other rework of the code.&n; *&n; *  Parts of this driver were also based on the FreeBSD driver by&n; *  Justin T. Gibbs.  His copyright follows:&n; *&n; * --------------------------------------------------------------------------&n; * Copyright (c) 1994-1997 Justin Gibbs.&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification, immediately at the beginning of the file.&n; * 2. Redistributions in binary form must reproduce the above copyright&n; *    notice, this list of conditions and the following disclaimer in the&n; *    documentation and/or other materials provided with the distribution.&n; * 3. The name of the author may not be used to endorse or promote products&n; *    derived from this software without specific prior written permission.&n; *&n; * Where this Software is combined with software released under the terms of &n; * the GNU Public License (&quot;GPL&quot;) and the terms of the GPL would require the &n; * combined work to also be released under the terms of the GPL, the terms&n; * and conditions of this License will apply in addition to those of the&n; * GPL with the exception of any terms or conditions of this License that&n; * conflict with, or are expressly prohibited by, the GPL.&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR&n; * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; *&n; *      $Id: aic7xxx.c,v 1.119 1997/06/27 19:39:18 gibbs Exp $&n; *---------------------------------------------------------------------------&n; *&n; *  Thanks also go to (in alphabetical order) the following:&n; *&n; *    Rory Bolt     - Sequencer bug fixes&n; *    Jay Estabrook - Initial DEC Alpha support&n; *    Doug Ledford  - Much needed abort/reset bug fixes&n; *    Kai Makisara  - DMAing of SCBs&n; *&n; *  A Boot time option was also added for not resetting the scsi bus.&n; *&n; *    Form:  aic7xxx=extended&n; *           aic7xxx=no_reset&n; *           aic7xxx=ultra&n; *           aic7xxx=irq_trigger:[0,1]  # 0 edge, 1 level&n; *           aic7xxx=verbose&n; *&n; *  Daniel M. Eischen, deischen@iworks.InterWorks.org, 1/23/97&n; *&n; *  $Id: aic7xxx.c,v 4.1 1997/06/12 08:23:42 deang Exp $&n; *-M*************************************************************************/
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#endif
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;aic7xxx.h&quot;
macro_line|#include &quot;aic7xxx/sequencer.h&quot;
macro_line|#include &quot;aic7xxx/scsi_message.h&quot;
macro_line|#include &quot;aic7xxx_reg.h&quot;
macro_line|#include &quot;aic7xxx_seq.h&quot;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;&t;/* for kmalloc() */
macro_line|#include &lt;linux/config.h&gt;&t;/* for CONFIG_PCI */
multiline_comment|/*&n; * To generate the correct addresses for the controller to issue&n; * on the bus.  Originally added for DEC Alpha support.&n; */
DECL|macro|VIRT_TO_BUS
mdefine_line|#define VIRT_TO_BUS(a) (unsigned int)virt_to_bus((void *)(a))
DECL|variable|proc_scsi_aic7xxx
r_struct
id|proc_dir_entry
id|proc_scsi_aic7xxx
op_assign
(brace
id|PROC_SCSI_AIC7XXX
comma
l_int|7
comma
l_string|&quot;aic7xxx&quot;
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
l_int|2
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|macro|AIC7XXX_C_VERSION
mdefine_line|#define AIC7XXX_C_VERSION  &quot;$Revision: 4.1 $&quot;
DECL|macro|NUMBER
mdefine_line|#define NUMBER(arr)     (sizeof(arr) / sizeof(arr[0]))
DECL|macro|MIN
mdefine_line|#define MIN(a,b)        (((a) &lt; (b)) ? (a) : (b))
DECL|macro|MAX
mdefine_line|#define MAX(a,b)        (((a) &gt; (b)) ? (a) : (b))
DECL|macro|ALL_TARGETS
mdefine_line|#define ALL_TARGETS -1
DECL|macro|ALL_CHANNELS
mdefine_line|#define ALL_CHANNELS &squot;&bslash;0&squot;
DECL|macro|ALL_LUNS
mdefine_line|#define ALL_LUNS -1
macro_line|#ifndef TRUE
DECL|macro|TRUE
macro_line|#  define TRUE 1
macro_line|#endif
macro_line|#ifndef FALSE
DECL|macro|FALSE
macro_line|#  define FALSE 0
macro_line|#endif
multiline_comment|/*&n; * Defines for PCI bus support, testing twin bus support, DMAing of&n; * SCBs, tagged queueing, commands (SCBs) per lun, and SCSI bus reset&n; * delay time.&n; *&n; *   o PCI bus support - this has been implemented and working since&n; *     the December 1, 1994 release of this driver. If you don&squot;t have&n; *     a PCI bus, then you can configure your kernel without PCI&n; *     support because all PCI dependent code is bracketed with&n; *     &quot;#ifdef CONFIG_PCI ... #endif CONFIG_PCI&quot;.&n; *&n; *   o Twin bus support - this has been tested and does work.  It is&n; *     not an option anymore.&n; *&n; *   o Tagged queueing - this driver is capable of tagged queueing&n; *     but I am unsure as to how well the higher level driver implements&n; *     tagged queueing. Therefore, the maximum commands per lun is&n; *     set to 2. If you want to implement tagged queueing, ensure&n; *     this define is not commented out.&n; *&n; *   o Commands per lun - If tagged queueing is enabled, then you&n; *     may want to try increasing AIC7XXX_CMDS_PER_LUN to more&n; *     than 2.  By default, we limit the SCBs per LUN to 2 with&n; *     or without tagged queueing enabled.  If tagged queueing is&n; *     disabled, the sequencer will keep the 2nd SCB in the input&n; *     queue until the first one completes - so it is OK to to have&n; *     more than 1 SCB queued.  If tagged queueing is enabled, then&n; *     the sequencer will attempt to send the 2nd SCB to the device&n; *     while the first SCB is executing and the device is disconnected.&n; *     For adapters limited to 4 SCBs, you may want to actually&n; *     decrease the commands per LUN to 1, if you often have more&n; *     than 2 devices active at the same time.  This will allocate&n; *     1 SCB for each device and ensure that there will always be&n; *     a free SCB for up to 4 devices active at the same time.&n; *     When SCB paging is enabled, set the commands per LUN to 8&n; *     or higher (see SCB paging support below).  Note that if&n; *     AIC7XXX_CMDS_PER_LUN is not defined and tagged queueing is&n; *     enabled, the driver will attempt to set the commands per&n; *     LUN using its own heuristic based on the number of available&n; *     SCBs.&n; *&n; *   o 3985 support - The 3985 adapter is much like the 3940, but has&n; *     three 7870 controllers as opposed to two for the 3940.  It will&n; *     be probed and recognized as three different adapters, but all&n; *     three controllers can share the same external bank of 255 SCBs.&n; *     If you enable AIC7XXX_USE_EXT_SCBRAM, then the driver will attempt&n; *     to use and share the common bank of SCBs between the three&n; *     controllers of the 3985.  This is experimental and hasn&squot;t been&n; *     been tested.  By default, we do not use external SCB RAM, and&n; *     force the controllers to use their own internal bank of 16 SCBs.&n; *     Please let us know if using the external SCB array works.&n; *&n; *   o SCB paging support - SCB paging is enabled by defining&n; *     AIC7XXX_PAGE_ENABLE.  Support for this was taken from the&n; *     FreeBSD driver (by Justin Gibbs) and allows for up to 255&n; *     active SCBs.  This will increase performance when tagged&n; *     queueing is enabled.  Note that you should increase the&n; *     AIC7XXX_CMDS_PER_LUN to 8 as most tagged queueing devices&n; *     allow at least this many.&n; *&n; *  Note that sharing of IRQs is not an option any longer.  Linux supports&n; *  it so we support it.&n; *&n; *  Daniel M. Eischen, deischen@iworks.InterWorks.org, 01/26/96&n; */
multiline_comment|/* Uncomment this for tagged queueing. */
macro_line|#ifdef CONFIG_AIC7XXX_TAGGED_QUEUEING
DECL|macro|AIC7XXX_TAGGED_QUEUEING
mdefine_line|#define AIC7XXX_TAGGED_QUEUEING
macro_line|#endif
multiline_comment|/*&n; * You can try raising me if tagged queueing is enabled, or lowering&n; * me if you only have 4 SCBs.&n; */
macro_line|#ifdef CONFIG_AIC7XXX_CMDS_PER_LUN
DECL|macro|AIC7XXX_CMDS_PER_LUN
mdefine_line|#define AIC7XXX_CMDS_PER_LUN CONFIG_AIC7XXX_CMDS_PER_LUN
macro_line|#endif
multiline_comment|/* Set this to the delay in seconds after SCSI bus reset. */
macro_line|#ifdef CONFIG_AIC7XXX_RESET_DELAY
DECL|macro|AIC7XXX_RESET_DELAY
mdefine_line|#define AIC7XXX_RESET_DELAY CONFIG_AIC7XXX_RESET_DELAY
macro_line|#else
DECL|macro|AIC7XXX_RESET_DELAY
mdefine_line|#define AIC7XXX_RESET_DELAY 15
macro_line|#endif
multiline_comment|/*&n; * Control collection of SCSI transfer statistics for the /proc filesystem.&n; *&n; * NOTE: Do NOT enable this when running on kernels version 1.2.x and below.&n; * NOTE: This does affect performance since it has to maintain statistics.&n; */
macro_line|#ifdef CONFIG_AIC7XXX_PROC_STATS
DECL|macro|AIC7XXX_PROC_STATS
mdefine_line|#define AIC7XXX_PROC_STATS
macro_line|#endif
multiline_comment|/*&n; * Enable SCB paging.&n; */
macro_line|#ifdef CONFIG_AIC7XXX_PAGE_ENABLE
DECL|macro|AIC7XXX_PAGE_ENABLE
mdefine_line|#define AIC7XXX_PAGE_ENABLE
macro_line|#endif
multiline_comment|/*&n; * Uncomment the following to enable use of the external bank&n; * of 255 SCBs.  For 3985 adapters, this will also enable sharing&n; * of the SCB array across all three controllers.&n; */
macro_line|#ifdef CONFIG_AIC7XXX_USE_EXT_SCBRAM
DECL|macro|AIC7XXX_USE_EXT_SCBRAM
mdefine_line|#define AIC7XXX_USE_EXT_SCBRAM
macro_line|#endif
multiline_comment|/*&n; * For debugging the abort/reset code.&n; */
DECL|macro|AIC7XXX_DEBUG_ABORT
mdefine_line|#define AIC7XXX_DEBUG_ABORT
multiline_comment|/*&n; * For general debug messages&n; */
DECL|macro|AIC7XXX_DEBUG
mdefine_line|#define AIC7XXX_DEBUG
multiline_comment|/*&n; * Set this for defining the number of tagged commands on a device&n; * by device, and controller by controller basis.  The first set&n; * of tagged commands will be used for the first detected aic7xxx&n; * controller, the second set will be used for the second detected&n; * aic7xxx controller, and so on.  These values will *only* be used&n; * for targets that are tagged queueing capable; these values will&n; * be ignored in all other cases.  The tag_commands is an array of&n; * 16 to allow for wide and twin adapters.  Twin adapters will use&n; * indexes 0-7 for channel 0, and indexes 8-15 for channel 1.&n; *&n; * *** Determining commands per LUN ***&n; * &n; * When AIC7XXX_CMDS_PER_LUN is not defined, the driver will use its&n; * own algorithm to determine the commands/LUN.  If SCB paging is&n; * enabled, the commands/LUN is 8.  When SCB paging is not enabled,&n; * then commands/LUN is 8 for adapters with 16 or more hardware SCBs&n; * and 4 commands/LUN for adapters with 3 or 4 SCBs.&n; *&n; */
multiline_comment|/* #define AIC7XXX_TAGGED_QUEUEING_BY_DEVICE */
macro_line|#ifdef AIC7XXX_TAGGED_QUEUEING_BY_DEVICE
r_typedef
r_struct
(brace
DECL|member|tag_commands
r_char
id|tag_commands
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Allow for wide/twin channel adapters. */
DECL|typedef|adapter_tag_info_t
)brace
id|adapter_tag_info_t
suffix:semicolon
multiline_comment|/*&n; * Make a define that will tell the driver to use it&squot;s own algorithm&n; * for determining commands/LUN (see Determining commands per LUN&n; * above).&n; */
DECL|macro|DEFAULT_TAG_COMMANDS
mdefine_line|#define DEFAULT_TAG_COMMANDS {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
multiline_comment|/*&n; * Modify this as you see fit for your system.  By setting tag_commands&n; * to 0, the driver will use it&squot;s own algorithm for determining the&n; * number of commands to use (see above).  When -1, the driver will&n; * not enable tagged queueing for that particular device.  When positive&n; * (&gt; 0) the values in the array are used for the queue_depth.  Note&n; * that the maximum value for an entry is 127.&n; *&n; * In this example, the first line will enable tagged queueing for all&n; * the devices on the first probed aic7xxx adapter and tells the driver&n; * to use it&squot;s own algorithm for determining commands/LUN.&n; *&n; * The second line enables tagged queueing with 4 commands/LUN for IDs&n; * (1, 2-11, 13-15), disables tagged queueing for ID 12, and tells the&n; * driver to use its own algorithm for ID 1.&n; *&n; * The third line is the same as the first line.&n; *&n; * The fourth line disables tagged queueing for devices 0 and 3.  It&n; * enables tagged queueing for the other IDs, with 16 commands/LUN&n; * for IDs 1 and 4, 127 commands/LUN for ID 8, and 4 commands/LUN for&n; * IDs 2, 5-7, and 9-15.&n; */
DECL|variable|aic7xxx_tag_info
id|adapter_tag_info_t
id|aic7xxx_tag_info
(braket
)braket
op_assign
(brace
(brace
id|DEFAULT_TAG_COMMANDS
)brace
comma
(brace
(brace
l_int|4
comma
l_int|0
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
op_minus
l_int|1
comma
l_int|4
comma
l_int|4
comma
l_int|4
)brace
)brace
comma
(brace
id|DEFAULT_TAG_COMMANDS
)brace
comma
(brace
(brace
op_minus
l_int|1
comma
l_int|16
comma
l_int|4
comma
op_minus
l_int|1
comma
l_int|16
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|127
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
)brace
)brace
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Don&squot;t define this unless you have problems with the driver&n; * interrupt handler.  The old method would register the drivers&n; * interrupt handler as a &quot;fast&quot; type interrupt handler that would&n; * lock out other interrupts.  Since this driver can spend a lot&n; * of time in the interrupt handler, this is _not_ a good idea.&n; * It also conflicts with some of the more common ethernet drivers&n; * that don&squot;t use fast interrupts.  Currently, Linux does not allow&n; * IRQ sharing unless both drivers can agree on the type of interrupt&n; * handler.&n; */
multiline_comment|/* #define AIC7XXX_OLD_ISR_TYPE */
multiline_comment|/*&n; * Controller type and options&n; */
r_typedef
r_enum
(brace
DECL|enumerator|AIC_NONE
id|AIC_NONE
comma
DECL|enumerator|AIC_7770
id|AIC_7770
comma
multiline_comment|/* EISA aic7770 on motherboard */
DECL|enumerator|AIC_7771
id|AIC_7771
comma
multiline_comment|/* EISA aic7771 on 274x */
DECL|enumerator|AIC_284x
id|AIC_284x
comma
multiline_comment|/* VLB  aic7770 on 284x, BIOS disabled */
DECL|enumerator|AIC_7850
id|AIC_7850
comma
multiline_comment|/* PCI  aic7850 */
DECL|enumerator|AIC_7855
id|AIC_7855
comma
multiline_comment|/* PCI  aic7855 */
DECL|enumerator|AIC_7860
id|AIC_7860
comma
multiline_comment|/* PCI  aic7860 (7850 Ultra) */
DECL|enumerator|AIC_7861
id|AIC_7861
comma
multiline_comment|/* PCI  aic7861 on 2940AU */
DECL|enumerator|AIC_7870
id|AIC_7870
comma
multiline_comment|/* PCI  aic7870 on motherboard */
DECL|enumerator|AIC_7871
id|AIC_7871
comma
multiline_comment|/* PCI  aic7871 on 294x */
DECL|enumerator|AIC_7872
id|AIC_7872
comma
multiline_comment|/* PCI  aic7872 on 3940 */
DECL|enumerator|AIC_7873
id|AIC_7873
comma
multiline_comment|/* PCI  aic7873 on 3985 */
DECL|enumerator|AIC_7874
id|AIC_7874
comma
multiline_comment|/* PCI  aic7874 on 294x Differential */
DECL|enumerator|AIC_7880
id|AIC_7880
comma
multiline_comment|/* PCI  aic7880 on motherboard */
DECL|enumerator|AIC_7881
id|AIC_7881
comma
multiline_comment|/* PCI  aic7881 on 294x Ultra */
DECL|enumerator|AIC_7882
id|AIC_7882
comma
multiline_comment|/* PCI  aic7882 on 3940 Ultra */
DECL|enumerator|AIC_7883
id|AIC_7883
comma
multiline_comment|/* PCI  aic7883 on 3985 Ultra */
DECL|enumerator|AIC_7884
id|AIC_7884
multiline_comment|/* PCI  aic7884 on 294x Ultra Differential */
DECL|typedef|aha_chip_type
)brace
id|aha_chip_type
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|AIC_777x
id|AIC_777x
comma
multiline_comment|/* AIC-7770 based */
DECL|enumerator|AIC_785x
id|AIC_785x
comma
multiline_comment|/* AIC-7850 based (3 SCBs)*/
DECL|enumerator|AIC_786x
id|AIC_786x
comma
multiline_comment|/* AIC-7860 based (7850 ultra) */
DECL|enumerator|AIC_787x
id|AIC_787x
comma
multiline_comment|/* AIC-7870 based */
DECL|enumerator|AIC_788x
id|AIC_788x
multiline_comment|/* AIC-7880 based (ultra) */
DECL|typedef|aha_chip_class_type
)brace
id|aha_chip_class_type
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|AIC_SINGLE
id|AIC_SINGLE
comma
multiline_comment|/* Single Channel */
DECL|enumerator|AIC_TWIN
id|AIC_TWIN
comma
multiline_comment|/* Twin Channel */
DECL|enumerator|AIC_WIDE
id|AIC_WIDE
multiline_comment|/* Wide Channel */
DECL|typedef|aha_bus_type
)brace
id|aha_bus_type
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|AIC_UNKNOWN
id|AIC_UNKNOWN
comma
DECL|enumerator|AIC_ENABLED
id|AIC_ENABLED
comma
DECL|enumerator|AIC_DISABLED
id|AIC_DISABLED
DECL|typedef|aha_status_type
)brace
id|aha_status_type
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|LIST_HEAD
id|LIST_HEAD
comma
DECL|enumerator|LIST_SECOND
id|LIST_SECOND
DECL|typedef|insert_type
)brace
id|insert_type
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|ABORT_RESET_INACTIVE
id|ABORT_RESET_INACTIVE
comma
DECL|enumerator|ABORT_RESET_PENDING
id|ABORT_RESET_PENDING
comma
DECL|enumerator|ABORT_RESET_SUCCESS
id|ABORT_RESET_SUCCESS
DECL|typedef|aha_abort_reset_type
)brace
id|aha_abort_reset_type
suffix:semicolon
multiline_comment|/*&n; * Define an array of board names that can be indexed by aha_type.&n; * Don&squot;t forget to change this when changing the types!&n; */
DECL|variable|board_names
r_static
r_const
r_char
op_star
id|board_names
(braket
)braket
op_assign
(brace
l_string|&quot;AIC-7xxx Unknown&quot;
comma
multiline_comment|/* AIC_NONE */
l_string|&quot;Adaptec AIC-7770 SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7770 */
l_string|&quot;Adaptec AHA-274X SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7771 */
l_string|&quot;Adaptec AHA-284X SCSI host adapter&quot;
comma
multiline_comment|/* AIC_284x */
l_string|&quot;Adaptec AIC-7850 SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7850 */
l_string|&quot;Adaptec AIC-7855 SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7855 */
l_string|&quot;Adaptec AIC-7860 Ultra SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7860 */
l_string|&quot;Adaptec AHA-2940A Ultra SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7861 */
l_string|&quot;Adaptec AIC-7870 SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7870 */
l_string|&quot;Adaptec AHA-294X SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7871 */
l_string|&quot;Adaptec AHA-394X SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7872 */
l_string|&quot;Adaptec AHA-398X SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7873 */
l_string|&quot;Adaptec AHA-2944 SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7874 */
l_string|&quot;Adaptec AIC-7880 Ultra SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7880 */
l_string|&quot;Adaptec AHA-294X Ultra SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7881 */
l_string|&quot;Adaptec AHA-394X Ultra SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7882 */
l_string|&quot;Adaptec AHA-398X Ultra SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7883 */
l_string|&quot;Adaptec AHA-2944 Ultra SCSI host adapter&quot;
multiline_comment|/* AIC_7884 */
)brace
suffix:semicolon
multiline_comment|/*&n; * There should be a specific return value for this in scsi.h, but&n; * it seems that most drivers ignore it.&n; */
DECL|macro|DID_UNDERFLOW
mdefine_line|#define DID_UNDERFLOW   DID_ERROR
multiline_comment|/*&n; *  What we want to do is have the higher level scsi driver requeue&n; *  the command to us. There is no specific driver status for this&n; *  condition, but the higher level scsi driver will requeue the&n; *  command on a DID_BUS_BUSY error.&n; *&n; *  Upon further inspection and testing, it seems that DID_BUS_BUSY&n; *  will *always* retry the command.  We can get into an infinite loop&n; *  if this happens when we really want some sort of counter that&n; *  will automatically abort/reset the command after so many retries.&n; *  Using DID_ERROR will do just that.  (Made by a suggestion by&n; *  Doug Ledford 8/1/96)&n; */
DECL|macro|DID_RETRY_COMMAND
mdefine_line|#define DID_RETRY_COMMAND DID_ERROR
DECL|macro|HSCSIID
mdefine_line|#define HSCSIID        0x07
DECL|macro|HWSCSIID
mdefine_line|#define HWSCSIID       0x0F
DECL|macro|SCSI_RESET
mdefine_line|#define SCSI_RESET     0x040
multiline_comment|/*&n; * EISA/VL-bus stuff&n; */
DECL|macro|MINSLOT
mdefine_line|#define MINSLOT&t;&t;1
DECL|macro|MAXSLOT
mdefine_line|#define MAXSLOT&t;&t;15
DECL|macro|SLOTBASE
mdefine_line|#define SLOTBASE(x)&t;((x) &lt;&lt; 12)
DECL|macro|BASE_TO_SLOT
mdefine_line|#define BASE_TO_SLOT(x) ((x) &gt;&gt; 12)
multiline_comment|/*&n; * Standard EISA Host ID regs  (Offset from slot base)&n; */
DECL|macro|HID0
mdefine_line|#define HID0&t;&t;0x80   /* 0,1: msb of ID2, 2-7: ID1      */
DECL|macro|HID1
mdefine_line|#define HID1&t;&t;0x81   /* 0-4: ID3, 5-7: LSB ID2         */
DECL|macro|HID2
mdefine_line|#define HID2&t;&t;0x82   /* product                        */
DECL|macro|HID3
mdefine_line|#define HID3&t;&t;0x83   /* firmware revision              */
multiline_comment|/*&n; * AIC-7770 I/O range to reserve for a card&n; */
DECL|macro|MINREG
mdefine_line|#define MINREG&t;&t;0xC00
DECL|macro|MAXREG
mdefine_line|#define MAXREG&t;&t;0xCBF
DECL|macro|INTDEF
mdefine_line|#define INTDEF&t;&t;0x5C&t;&t;/* Interrupt Definition Register */
multiline_comment|/*&n; * AIC-78X0 PCI registers&n; */
DECL|macro|CLASS_PROGIF_REVID
mdefine_line|#define&t;CLASS_PROGIF_REVID&t;0x08
DECL|macro|DEVREVID
mdefine_line|#define&t;&t;DEVREVID&t;0x000000FFul
DECL|macro|PROGINFC
mdefine_line|#define&t;&t;PROGINFC&t;0x0000FF00ul
DECL|macro|SUBCLASS
mdefine_line|#define&t;&t;SUBCLASS&t;0x00FF0000ul
DECL|macro|BASECLASS
mdefine_line|#define&t;&t;BASECLASS&t;0xFF000000ul
DECL|macro|CSIZE_LATTIME
mdefine_line|#define&t;CSIZE_LATTIME&t;&t;0x0C
DECL|macro|CACHESIZE
mdefine_line|#define&t;&t;CACHESIZE&t;0x0000003Ful&t;/* only 5 bits */
DECL|macro|LATTIME
mdefine_line|#define&t;&t;LATTIME&t;&t;0x0000FF00ul
DECL|macro|DEVCONFIG
mdefine_line|#define&t;DEVCONFIG&t;&t;0x40
DECL|macro|MPORTMODE
mdefine_line|#define&t;&t;MPORTMODE&t;0x00000400ul&t;/* aic7870 only */
DECL|macro|RAMPSM
mdefine_line|#define&t;&t;RAMPSM&t;&t;0x00000200ul&t;/* aic7870 only */
DECL|macro|VOLSENSE
mdefine_line|#define&t;&t;VOLSENSE&t;0x00000100ul
DECL|macro|SCBRAMSEL
mdefine_line|#define&t;&t;SCBRAMSEL&t;0x00000080ul
DECL|macro|MRDCEN
mdefine_line|#define&t;&t;MRDCEN&t;&t;0x00000040ul
DECL|macro|EXTSCBTIME
mdefine_line|#define&t;&t;EXTSCBTIME&t;0x00000020ul&t;/* aic7870 only */
DECL|macro|EXTSCBPEN
mdefine_line|#define&t;&t;EXTSCBPEN&t;0x00000010ul&t;/* aic7870 only */
DECL|macro|BERREN
mdefine_line|#define&t;&t;BERREN&t;&t;0x00000008ul
DECL|macro|DACEN
mdefine_line|#define&t;&t;DACEN&t;&t;0x00000004ul
DECL|macro|STPWLEVEL
mdefine_line|#define&t;&t;STPWLEVEL&t;0x00000002ul
DECL|macro|DIFACTNEGEN
mdefine_line|#define&t;&t;DIFACTNEGEN&t;0x00000001ul&t;/* aic7870 only */
multiline_comment|/*&n; * Define the different types of SEEPROMs on aic7xxx adapters&n; * and make it also represent the address size used in accessing&n; * its registers.  The 93C46 chips have 1024 bits organized into&n; * 64 16-bit words, while the 93C56 chips have 2048 bits organized&n; * into 128 16-bit words.  The C46 chips use 6 bits to address&n; * each word, while the C56 and C66 (4096 bits) use 8 bits to&n; * address each word.&n; */
DECL|enumerator|C46
DECL|enumerator|C56_66
DECL|typedef|seeprom_chip_type
r_typedef
r_enum
(brace
id|C46
op_assign
l_int|6
comma
id|C56_66
op_assign
l_int|8
)brace
id|seeprom_chip_type
suffix:semicolon
multiline_comment|/*&n; *&n; * Define the format of the SEEPROM registers (16 bits).&n; *&n; */
DECL|struct|seeprom_config
r_struct
id|seeprom_config
(brace
multiline_comment|/*&n; * SCSI ID Configuration Flags&n; */
DECL|macro|CFXFER
mdefine_line|#define CFXFER&t;&t;0x0007&t;&t;/* synchronous transfer rate */
DECL|macro|CFSYNCH
mdefine_line|#define CFSYNCH&t;&t;0x0008&t;&t;/* enable synchronous transfer */
DECL|macro|CFDISC
mdefine_line|#define CFDISC&t;&t;0x0010&t;&t;/* enable disconnection */
DECL|macro|CFWIDEB
mdefine_line|#define CFWIDEB&t;&t;0x0020&t;&t;/* wide bus device (wide card) */
multiline_comment|/* UNUSED&t;&t;0x00C0 */
DECL|macro|CFSTART
mdefine_line|#define CFSTART&t;&t;0x0100&t;&t;/* send start unit SCSI command */
DECL|macro|CFINCBIOS
mdefine_line|#define CFINCBIOS&t;0x0200&t;&t;/* include in BIOS scan */
DECL|macro|CFRNFOUND
mdefine_line|#define CFRNFOUND&t;0x0400&t;&t;/* report even if not found */
multiline_comment|/* UNUSED&t;&t;0xF800 */
DECL|member|device_flags
r_int
r_int
id|device_flags
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* words 0-15 */
multiline_comment|/*&n; * BIOS Control Bits&n; */
DECL|macro|CFSUPREM
mdefine_line|#define CFSUPREM&t;0x0001&t;&t;/* support all removable drives */
DECL|macro|CFSUPREMB
mdefine_line|#define CFSUPREMB&t;0x0002&t;&t;/* support removable drives for boot only */
DECL|macro|CFBIOSEN
mdefine_line|#define CFBIOSEN&t;0x0004&t;&t;/* BIOS enabled */
multiline_comment|/* UNUSED&t;&t;0x0008 */
DECL|macro|CFSM2DRV
mdefine_line|#define CFSM2DRV&t;0x0010&t;&t;/* support more than two drives */
DECL|macro|CF284XEXTEND
mdefine_line|#define CF284XEXTEND&t;0x0020&t;&t;/* extended translation (284x cards) */
multiline_comment|/* UNUSED&t;&t;0x0040 */
DECL|macro|CFEXTEND
mdefine_line|#define CFEXTEND&t;0x0080&t;&t;/* extended translation enabled */
multiline_comment|/* UNUSED&t;&t;0xFF00 */
DECL|member|bios_control
r_int
r_int
id|bios_control
suffix:semicolon
multiline_comment|/* word 16 */
multiline_comment|/*&n; * Host Adapter Control Bits&n; */
DECL|macro|CFAUTOTERM
mdefine_line|#define CFAUTOTERM      0x0001          /* Perform Auto termination */
DECL|macro|CFULTRAEN
mdefine_line|#define CFULTRAEN       0x0002          /* Ultra SCSI speed enable (Ultra cards) */
DECL|macro|CF284XSELTO
mdefine_line|#define CF284XSELTO     0x0003          /* Selection timeout (284x cards) */
DECL|macro|CF284XFIFO
mdefine_line|#define CF284XFIFO      0x000C          /* FIFO Threshold (284x cards) */
DECL|macro|CFSTERM
mdefine_line|#define CFSTERM         0x0004          /* SCSI low byte termination */
DECL|macro|CFWSTERM
mdefine_line|#define CFWSTERM        0x0008          /* SCSI high byte termination (wide card) */
DECL|macro|CFSPARITY
mdefine_line|#define CFSPARITY&t;0x0010&t;&t;/* SCSI parity */
DECL|macro|CF284XSTERM
mdefine_line|#define CF284XSTERM&t;0x0020&t;&t;/* SCSI low byte termination (284x cards) */
DECL|macro|CFRESETB
mdefine_line|#define CFRESETB&t;0x0040&t;&t;/* reset SCSI bus at boot */
multiline_comment|/* UNUSED&t;&t;0xFF80 */
DECL|member|adapter_control
r_int
r_int
id|adapter_control
suffix:semicolon
multiline_comment|/* word 17 */
multiline_comment|/*&n; * Bus Release, Host Adapter ID&n; */
DECL|macro|CFSCSIID
mdefine_line|#define CFSCSIID&t;0x000F&t;&t;/* host adapter SCSI ID */
multiline_comment|/* UNUSED&t;&t;0x00F0 */
DECL|macro|CFBRTIME
mdefine_line|#define CFBRTIME&t;0xFF00&t;&t;/* bus release time */
DECL|member|brtime_id
r_int
r_int
id|brtime_id
suffix:semicolon
multiline_comment|/* word 18 */
multiline_comment|/*&n; * Maximum targets&n; */
DECL|macro|CFMAXTARG
mdefine_line|#define CFMAXTARG&t;0x00FF&t;/* maximum targets */
multiline_comment|/* UNUSED&t;&t;0xFF00 */
DECL|member|max_targets
r_int
r_int
id|max_targets
suffix:semicolon
multiline_comment|/* word 19 */
DECL|member|res_1
r_int
r_int
id|res_1
(braket
l_int|11
)braket
suffix:semicolon
multiline_comment|/* words 20-30 */
DECL|member|checksum
r_int
r_int
id|checksum
suffix:semicolon
multiline_comment|/* word 31 */
)brace
suffix:semicolon
DECL|macro|SELBUS_MASK
mdefine_line|#define SELBUS_MASK&t;&t;0x0a
DECL|macro|SELNARROW
mdefine_line|#define &t;SELNARROW&t;0x00
DECL|macro|SELBUSB
mdefine_line|#define &t;SELBUSB&t;&t;0x08
DECL|macro|SINGLE_BUS
mdefine_line|#define SINGLE_BUS&t;&t;0x00
DECL|macro|SCB_TARGET
mdefine_line|#define SCB_TARGET(scb)         &bslash;&n;       (((scb)-&gt;hscb-&gt;target_channel_lun &amp; TID) &gt;&gt; 4)
DECL|macro|SCB_LUN
mdefine_line|#define SCB_LUN(scb)            &bslash;&n;       ((scb)-&gt;hscb-&gt;target_channel_lun &amp; LID)
DECL|macro|SCB_IS_SCSIBUS_B
mdefine_line|#define SCB_IS_SCSIBUS_B(scb)   &bslash;&n;       (((scb)-&gt;hscb-&gt;target_channel_lun &amp; SELBUSB) != 0)
multiline_comment|/*&n; * If an error occurs during a data transfer phase, run the command&n; * to completion - it&squot;s easier that way - making a note of the error&n; * condition in this location. This then will modify a DID_OK status&n; * into an appropriate error for the higher-level SCSI code.&n; */
DECL|macro|aic7xxx_error
mdefine_line|#define aic7xxx_error(cmd)&t;((cmd)-&gt;SCp.Status)
multiline_comment|/*&n; * Keep track of the targets returned status.&n; */
DECL|macro|aic7xxx_status
mdefine_line|#define aic7xxx_status(cmd)&t;((cmd)-&gt;SCp.sent_command)
multiline_comment|/*&n; * The position of the SCSI commands scb within the scb array.&n; */
DECL|macro|aic7xxx_position
mdefine_line|#define aic7xxx_position(cmd)&t;((cmd)-&gt;SCp.have_data_in)
multiline_comment|/*&n; * &quot;Static&quot; structures. Note that these are NOT initialized&n; * to zero inside the kernel - we have to initialize them all&n; * explicitly.&n; *&n; * We support multiple adapter cards per interrupt, but keep a&n; * linked list of Scsi_Host structures for each IRQ.  On an interrupt,&n; * use the IRQ as an index into aic7xxx_boards[] to locate the card&n; * information.&n; */
DECL|variable|aic7xxx_boards
r_static
r_struct
id|Scsi_Host
op_star
id|aic7xxx_boards
(braket
id|NR_IRQS
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/*&n; * When we detect and register the card, it is possible to&n; * have the card raise a spurious interrupt.  Because we need&n; * to support multiple cards, we cannot tell which card caused&n; * the spurious interrupt.  And, we might not even have added&n; * the card info to the linked list at the time the spurious&n; * interrupt gets raised.  This variable is suppose to keep track&n; * of when we are registering a card and how many spurious&n; * interrupts we have encountered.&n; *&n; *   0 - do not allow spurious interrupts.&n; *   1 - allow 1 spurious interrupt&n; *   2 - have 1 spurious interrupt, do not allow any more.&n; *&n; * I&squot;ve made it an integer instead of a boolean in case we&n; * want to allow more than one spurious interrupt for debugging&n; * purposes.  Otherwise, it could just go from true to false to&n; * true (or something like that).&n; *&n; * When the driver detects the cards, we&squot;ll set the count to 1&n; * for each card detection and registration.  After the registration&n; * of a card completes, we&squot;ll set the count back to 0.  So far, it&n; * seems to be enough to allow a spurious interrupt only during&n; * card registration; if a spurious interrupt is going to occur,&n; * this is where it happens.&n; *&n; * We should be able to find a way to avoid getting the spurious&n; * interrupt.  But until we do, we have to keep this ugly code.&n; */
DECL|variable|aic7xxx_spurious_count
r_static
r_int
id|aic7xxx_spurious_count
suffix:semicolon
multiline_comment|/*&n; * As of Linux 2.1, the mid-level SCSI code uses virtual addresses&n; * in the scatter-gather lists.  We need to convert the virtual&n; * addresses to physical addresses.&n; */
DECL|struct|hw_scatterlist
r_struct
id|hw_scatterlist
(brace
DECL|member|address
r_int
r_int
id|address
suffix:semicolon
DECL|member|length
r_int
r_int
id|length
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Maximum number of SG segments these cards can support.&n; */
DECL|macro|AIC7XXX_MAX_SG
mdefine_line|#define&t;AIC7XXX_MAX_SG 27
multiline_comment|/*&n; * The maximum number of SCBs we could have for ANY type&n; * of card. DON&squot;T FORGET TO CHANGE THE SCB MASK IN THE&n; * SEQUENCER CODE IF THIS IS MODIFIED!&n; */
DECL|macro|AIC7XXX_MAXSCB
mdefine_line|#define AIC7XXX_MAXSCB&t;255
DECL|struct|aic7xxx_hwscb
r_struct
id|aic7xxx_hwscb
(brace
multiline_comment|/* ------------    Begin hardware supported fields    ---------------- */
DECL|member|control
multiline_comment|/* 0*/
r_int
r_char
id|control
suffix:semicolon
DECL|member|target_channel_lun
multiline_comment|/* 1*/
r_int
r_char
id|target_channel_lun
suffix:semicolon
multiline_comment|/* 4/1/3 bits */
DECL|member|target_status
multiline_comment|/* 2*/
r_int
r_char
id|target_status
suffix:semicolon
DECL|member|SG_segment_count
multiline_comment|/* 3*/
r_int
r_char
id|SG_segment_count
suffix:semicolon
DECL|member|SG_list_pointer
multiline_comment|/* 4*/
r_int
r_int
id|SG_list_pointer
suffix:semicolon
DECL|member|residual_SG_segment_count
multiline_comment|/* 8*/
r_int
r_char
id|residual_SG_segment_count
suffix:semicolon
DECL|member|residual_data_count
multiline_comment|/* 9*/
r_int
r_char
id|residual_data_count
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|data_pointer
multiline_comment|/*12*/
r_int
r_int
id|data_pointer
suffix:semicolon
DECL|member|data_count
multiline_comment|/*16*/
r_int
r_int
id|data_count
suffix:semicolon
DECL|member|SCSI_cmd_pointer
multiline_comment|/*20*/
r_int
r_int
id|SCSI_cmd_pointer
suffix:semicolon
DECL|member|SCSI_cmd_length
multiline_comment|/*24*/
r_int
r_char
id|SCSI_cmd_length
suffix:semicolon
DECL|member|tag
multiline_comment|/*25*/
id|u_char
id|tag
suffix:semicolon
multiline_comment|/* Index into our kernel SCB array.&n;&t;&t;&t;&t;&t; * Also used as the tag for tagged I/O&n;&t;&t;&t;&t;&t; */
DECL|macro|SCB_PIO_TRANSFER_SIZE
mdefine_line|#define SCB_PIO_TRANSFER_SIZE&t;26 &t;/* amount we need to upload/download&n;&t;&t;&t;&t;&t; * via PIO to initialize a transaction.&n;&t;&t;&t;&t;&t; */
DECL|member|next
multiline_comment|/*26*/
r_int
r_char
id|next
suffix:semicolon
multiline_comment|/* Used to thread SCBs awaiting selection&n;                                         * or disconnected down in the sequencer.&n;                                         */
DECL|member|prev
multiline_comment|/*27*/
r_int
r_char
id|prev
suffix:semicolon
DECL|member|pad
multiline_comment|/*28*/
r_int
r_int
id|pad
suffix:semicolon
multiline_comment|/*&n;                                         * Unused by the kernel, but we require&n;                                         * the padding so that the array of&n;                                         * hardware SCBs is alligned on 32 byte&n;                                         * boundaries so the sequencer can index&n;                                         */
)brace
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|SCB_FREE
id|SCB_FREE
op_assign
l_int|0x0000
comma
DECL|enumerator|SCB_ACTIVE
id|SCB_ACTIVE
op_assign
l_int|0x0001
comma
DECL|enumerator|SCB_ABORTED
id|SCB_ABORTED
op_assign
l_int|0x0002
comma
DECL|enumerator|SCB_DEVICE_RESET
id|SCB_DEVICE_RESET
op_assign
l_int|0x0004
comma
DECL|enumerator|SCB_SENSE
id|SCB_SENSE
op_assign
l_int|0x0008
comma
DECL|enumerator|SCB_TIMEDOUT
id|SCB_TIMEDOUT
op_assign
l_int|0x0010
comma
DECL|enumerator|SCB_QUEUED_FOR_DONE
id|SCB_QUEUED_FOR_DONE
op_assign
l_int|0x0020
comma
DECL|enumerator|SCB_RECOVERY_SCB
id|SCB_RECOVERY_SCB
op_assign
l_int|0x0040
comma
DECL|enumerator|SCB_WAITINGQ
id|SCB_WAITINGQ
op_assign
l_int|0x0080
comma
DECL|enumerator|SCB_ASSIGNEDQ
id|SCB_ASSIGNEDQ
op_assign
l_int|0x0100
comma
DECL|enumerator|SCB_SENTORDEREDTAG
id|SCB_SENTORDEREDTAG
op_assign
l_int|0x0200
comma
DECL|enumerator|SCB_MSGOUT_SDTR
id|SCB_MSGOUT_SDTR
op_assign
l_int|0x0400
comma
DECL|enumerator|SCB_MSGOUT_WDTR
id|SCB_MSGOUT_WDTR
op_assign
l_int|0x0800
comma
DECL|enumerator|SCB_ABORT
id|SCB_ABORT
op_assign
l_int|0x1000
comma
DECL|enumerator|SCB_QUEUED_ABORT
id|SCB_QUEUED_ABORT
op_assign
l_int|0x2000
DECL|typedef|scb_flag_type
)brace
id|scb_flag_type
suffix:semicolon
DECL|struct|aic7xxx_scb
r_struct
id|aic7xxx_scb
(brace
DECL|member|hscb
r_struct
id|aic7xxx_hwscb
op_star
id|hscb
suffix:semicolon
multiline_comment|/* corresponding hardware scb */
DECL|member|cmd
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
multiline_comment|/* Scsi_Cmnd for this scb */
DECL|member|q_next
r_struct
id|aic7xxx_scb
op_star
id|q_next
suffix:semicolon
multiline_comment|/* next scb in queue */
DECL|member|flags
id|scb_flag_type
id|flags
suffix:semicolon
multiline_comment|/* current state of scb */
DECL|member|sg_list
r_struct
id|hw_scatterlist
op_star
id|sg_list
suffix:semicolon
multiline_comment|/* SG list in adapter format */
DECL|member|sg_count
r_int
r_char
id|sg_count
suffix:semicolon
DECL|member|sense_cmd
r_int
r_char
id|sense_cmd
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/*&n;                                               * Allocate 6 characters for&n;                                               * sense command.&n;                                               */
)brace
suffix:semicolon
multiline_comment|/*&n; * Define a linked list of SCBs.&n; */
r_typedef
r_struct
(brace
DECL|member|head
r_struct
id|aic7xxx_scb
op_star
id|head
suffix:semicolon
DECL|member|tail
r_struct
id|aic7xxx_scb
op_star
id|tail
suffix:semicolon
DECL|typedef|scb_queue_type
)brace
id|scb_queue_type
suffix:semicolon
r_static
r_struct
(brace
DECL|member|errno
r_int
r_char
id|errno
suffix:semicolon
DECL|member|errmesg
r_const
r_char
op_star
id|errmesg
suffix:semicolon
DECL|variable|hard_error
)brace
id|hard_error
(braket
)braket
op_assign
(brace
(brace
id|ILLHADDR
comma
l_string|&quot;Illegal Host Access&quot;
)brace
comma
(brace
id|ILLSADDR
comma
l_string|&quot;Illegal Sequencer Address referenced&quot;
)brace
comma
(brace
id|ILLOPCODE
comma
l_string|&quot;Illegal Opcode in sequencer program&quot;
)brace
comma
(brace
id|PARERR
comma
l_string|&quot;Sequencer Ram Parity Error&quot;
)brace
)brace
suffix:semicolon
r_static
r_int
r_char
DECL|variable|generic_sense
id|generic_sense
(braket
)braket
op_assign
(brace
id|REQUEST_SENSE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|255
comma
l_int|0
)brace
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|hscbs
r_struct
id|aic7xxx_hwscb
op_star
id|hscbs
suffix:semicolon
DECL|member|free_scbs
id|scb_queue_type
id|free_scbs
suffix:semicolon
multiline_comment|/*&n;                                    * SCBs assigned to free slot on&n;                                    * card (no paging required)&n;                                    */
DECL|member|numscbs
r_int
r_char
id|numscbs
suffix:semicolon
multiline_comment|/* current number of scbs */
DECL|member|maxhscbs
r_int
r_char
id|maxhscbs
suffix:semicolon
multiline_comment|/* hardware scbs */
DECL|member|maxscbs
r_int
r_char
id|maxscbs
suffix:semicolon
multiline_comment|/* max scbs including pageable scbs */
DECL|member|scb_array
r_struct
id|aic7xxx_scb
op_star
id|scb_array
(braket
id|AIC7XXX_MAXSCB
)braket
suffix:semicolon
DECL|member|reserve
r_int
r_int
id|reserve
(braket
l_int|100
)braket
suffix:semicolon
DECL|typedef|scb_data_type
)brace
id|scb_data_type
suffix:semicolon
multiline_comment|/*&n; * Define a structure used for each host adapter, only one per IRQ.&n; */
DECL|struct|aic7xxx_host
r_struct
id|aic7xxx_host
(brace
DECL|member|host
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
multiline_comment|/* pointer to scsi host */
DECL|member|host_no
r_int
id|host_no
suffix:semicolon
multiline_comment|/* SCSI host number */
DECL|member|instance
r_int
id|instance
suffix:semicolon
multiline_comment|/* aic7xxx instance number */
DECL|member|scsi_id
r_int
id|scsi_id
suffix:semicolon
multiline_comment|/* host adapter SCSI ID */
DECL|member|scsi_id_b
r_int
id|scsi_id_b
suffix:semicolon
multiline_comment|/*   channel B for twin adapters */
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* IRQ for this adapter */
DECL|member|base
r_int
id|base
suffix:semicolon
multiline_comment|/* card base address */
DECL|member|mbase
r_int
r_int
id|mbase
suffix:semicolon
multiline_comment|/* I/O memory address */
DECL|member|maddr
r_volatile
r_int
r_char
op_star
id|maddr
suffix:semicolon
multiline_comment|/* memory mapped address */
DECL|macro|A_SCANNED
mdefine_line|#define A_SCANNED               0x0001
DECL|macro|B_SCANNED
mdefine_line|#define B_SCANNED               0x0002
DECL|macro|EXTENDED_TRANSLATION
mdefine_line|#define EXTENDED_TRANSLATION    0x0004
DECL|macro|FLAGS_CHANNEL_B_PRIMARY
mdefine_line|#define FLAGS_CHANNEL_B_PRIMARY 0x0008
DECL|macro|MULTI_CHANNEL
mdefine_line|#define MULTI_CHANNEL           0x0010
DECL|macro|ULTRA_ENABLED
mdefine_line|#define ULTRA_ENABLED           0x0020
DECL|macro|PAGE_ENABLED
mdefine_line|#define PAGE_ENABLED            0x0040
DECL|macro|USE_DEFAULTS
mdefine_line|#define USE_DEFAULTS            0x0080
DECL|macro|BIOS_ENABLED
mdefine_line|#define BIOS_ENABLED            0x0100
DECL|macro|IN_ISR
mdefine_line|#define IN_ISR                  0x0200
DECL|macro|IN_TIMEOUT
mdefine_line|#define IN_TIMEOUT              0x0400
DECL|macro|SHARED_SCBDATA
mdefine_line|#define SHARED_SCBDATA          0x0800
DECL|macro|HAVE_SEEPROM
mdefine_line|#define HAVE_SEEPROM            0x1000
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|isr_count
r_int
r_int
id|isr_count
suffix:semicolon
multiline_comment|/* Interrupt count */
DECL|member|needsdtr_copy
r_int
r_int
id|needsdtr_copy
suffix:semicolon
multiline_comment|/* default config */
DECL|member|needsdtr
r_int
r_int
id|needsdtr
suffix:semicolon
DECL|member|sdtr_pending
r_int
r_int
id|sdtr_pending
suffix:semicolon
DECL|member|needwdtr_copy
r_int
r_int
id|needwdtr_copy
suffix:semicolon
multiline_comment|/* default config */
DECL|member|needwdtr
r_int
r_int
id|needwdtr
suffix:semicolon
DECL|member|wdtr_pending
r_int
r_int
id|wdtr_pending
suffix:semicolon
DECL|member|orderedtag
r_int
r_int
id|orderedtag
suffix:semicolon
DECL|member|discenable
r_int
r_int
id|discenable
suffix:semicolon
multiline_comment|/* Targets allowed to disconnect */
DECL|member|chip_type
id|aha_chip_type
id|chip_type
suffix:semicolon
multiline_comment|/* card type */
DECL|member|chip_class
id|aha_chip_class_type
id|chip_class
suffix:semicolon
DECL|member|bus_type
id|aha_bus_type
id|bus_type
suffix:semicolon
multiline_comment|/* normal/twin/wide bus */
DECL|member|chan_num
r_int
r_char
id|chan_num
suffix:semicolon
multiline_comment|/* for 39xx, channel number */
DECL|member|unpause
r_int
r_char
id|unpause
suffix:semicolon
multiline_comment|/* unpause value for HCNTRL */
DECL|member|pause
r_int
r_char
id|pause
suffix:semicolon
multiline_comment|/* pause value for HCNTRL */
DECL|member|qcntmask
r_int
r_char
id|qcntmask
suffix:semicolon
DECL|member|qfullcount
r_int
r_char
id|qfullcount
suffix:semicolon
DECL|member|curqincnt
r_int
r_char
id|curqincnt
suffix:semicolon
DECL|member|next
r_struct
id|Scsi_Host
op_star
id|next
suffix:semicolon
multiline_comment|/* allow for multiple IRQs */
DECL|member|activescbs
r_int
r_char
id|activescbs
suffix:semicolon
multiline_comment|/* active scbs */
DECL|member|waiting_scbs
id|scb_queue_type
id|waiting_scbs
suffix:semicolon
multiline_comment|/*&n;                                              * SCBs waiting for space in&n;                                              * the QINFIFO.&n;                                              */
DECL|member|scb_data
id|scb_data_type
op_star
id|scb_data
suffix:semicolon
DECL|struct|aic7xxx_cmd_queue
r_struct
id|aic7xxx_cmd_queue
(brace
DECL|member|head
id|Scsi_Cmnd
op_star
id|head
suffix:semicolon
DECL|member|tail
id|Scsi_Cmnd
op_star
id|tail
suffix:semicolon
DECL|member|completeq
)brace
id|completeq
suffix:semicolon
DECL|struct|aic7xxx_device_status
r_struct
id|aic7xxx_device_status
(brace
DECL|member|last_reset
r_int
id|last_reset
suffix:semicolon
DECL|macro|DEVICE_SUCCESS
mdefine_line|#define  DEVICE_SUCCESS                 0x01
DECL|macro|BUS_DEVICE_RESET_PENDING
mdefine_line|#define  BUS_DEVICE_RESET_PENDING       0x02
DECL|member|flags
r_int
id|flags
suffix:semicolon
DECL|member|commands_sent
r_int
id|commands_sent
suffix:semicolon
DECL|member|active_cmds
r_int
id|active_cmds
suffix:semicolon
DECL|member|device_status
)brace
id|device_status
(braket
l_int|16
)braket
suffix:semicolon
macro_line|#ifdef AIC7XXX_PROC_STATS
multiline_comment|/*&n;   * Statistics Kept:&n;   *&n;   * Total Xfers (count for each command that has a data xfer),&n;   * broken down further by reads &amp;&amp; writes.&n;   *&n;   * Binned sizes, writes &amp;&amp; reads:&n;   *    &lt; 512, 512, 1-2K, 2-4K, 4-8K, 8-16K, 16-32K, 32-64K, 64K-128K, &gt; 128K&n;   *&n;   * Total amounts read/written above 512 bytes (amts under ignored)&n;   */
DECL|struct|aic7xxx_xferstats
r_struct
id|aic7xxx_xferstats
(brace
DECL|member|xfers
r_int
id|xfers
suffix:semicolon
multiline_comment|/* total xfer count */
DECL|member|w_total
r_int
id|w_total
suffix:semicolon
multiline_comment|/* total writes */
DECL|member|w_total512
r_int
id|w_total512
suffix:semicolon
multiline_comment|/* 512 byte blocks written */
DECL|member|w_bins
r_int
id|w_bins
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/* binned write */
DECL|member|r_total
r_int
id|r_total
suffix:semicolon
multiline_comment|/* total reads */
DECL|member|r_total512
r_int
id|r_total512
suffix:semicolon
multiline_comment|/* 512 byte blocks read */
DECL|member|r_bins
r_int
id|r_bins
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/* binned reads */
DECL|member|stats
)brace
id|stats
(braket
l_int|2
)braket
(braket
l_int|16
)braket
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* channel, target, lun */
macro_line|#endif /* AIC7XXX_PROC_STATS */
)brace
suffix:semicolon
multiline_comment|/*&n; * Valid SCSIRATE values. (p. 3-17)&n; * Provides a mapping of transfer periods in ns/4 to the proper value to&n; * stick in the SCSIRATE reg to use that transfer rate.&n; */
r_static
r_struct
(brace
DECL|member|period
r_int
id|period
suffix:semicolon
multiline_comment|/* Rates in Ultra mode have bit 8 of sxfr set */
DECL|macro|ULTRA_SXFR
mdefine_line|#define&t;&t;ULTRA_SXFR 0x100
DECL|member|rate
r_int
id|rate
suffix:semicolon
DECL|member|english
r_const
r_char
op_star
id|english
suffix:semicolon
DECL|variable|aic7xxx_syncrates
)brace
id|aic7xxx_syncrates
(braket
)braket
op_assign
(brace
(brace
l_int|12
comma
l_int|0x100
comma
l_string|&quot;20.0&quot;
)brace
comma
(brace
l_int|15
comma
l_int|0x110
comma
l_string|&quot;16.0&quot;
)brace
comma
(brace
l_int|18
comma
l_int|0x120
comma
l_string|&quot;13.4&quot;
)brace
comma
(brace
l_int|25
comma
l_int|0x000
comma
l_string|&quot;10.0&quot;
)brace
comma
(brace
l_int|31
comma
l_int|0x010
comma
l_string|&quot;8.0&quot;
)brace
comma
(brace
l_int|37
comma
l_int|0x020
comma
l_string|&quot;6.67&quot;
)brace
comma
(brace
l_int|43
comma
l_int|0x030
comma
l_string|&quot;5.7&quot;
)brace
comma
(brace
l_int|50
comma
l_int|0x040
comma
l_string|&quot;5.0&quot;
)brace
comma
(brace
l_int|56
comma
l_int|0x050
comma
l_string|&quot;4.4&quot;
)brace
comma
(brace
l_int|62
comma
l_int|0x060
comma
l_string|&quot;4.0&quot;
)brace
comma
(brace
l_int|68
comma
l_int|0x070
comma
l_string|&quot;3.6&quot;
)brace
)brace
suffix:semicolon
DECL|variable|num_aic7xxx_syncrates
r_static
r_int
id|num_aic7xxx_syncrates
op_assign
r_sizeof
(paren
id|aic7xxx_syncrates
)paren
op_div
r_sizeof
(paren
id|aic7xxx_syncrates
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
DECL|variable|number_of_3940s
r_static
r_int
id|number_of_3940s
op_assign
l_int|0
suffix:semicolon
DECL|variable|number_of_3985s
r_static
r_int
id|number_of_3985s
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* CONFIG_PCI */
macro_line|#ifdef AIC7XXX_DEBUG
macro_line|#if 0
r_static
r_void
id|debug_scb
c_func
(paren
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
r_struct
id|aic7xxx_hwscb
op_star
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scb:%p control:0x%x tcl:0x%x cmdlen:%d cmdpointer:0x%lx&bslash;n&quot;
comma
id|scb
comma
id|hscb-&gt;control
comma
id|hscb-&gt;target_channel_lun
comma
id|hscb-&gt;SCSI_cmd_length
comma
id|hscb-&gt;SCSI_cmd_pointer
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        datlen:%d data:0x%lx segs:0x%x segp:0x%lx&bslash;n&quot;
comma
id|hscb-&gt;data_count
comma
id|hscb-&gt;data_pointer
comma
id|hscb-&gt;SG_segment_count
comma
id|hscb-&gt;SG_list_pointer
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        sg_addr:%lx sg_len:%ld&bslash;n&quot;
comma
id|hscb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|address
comma
id|hscb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|length
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#else
DECL|macro|debug_scb
macro_line|#  define debug_scb(x)
macro_line|#endif AIC7XXX_DEBUG
DECL|macro|TCL_OF_SCB
mdefine_line|#define TCL_OF_SCB(scb) (((scb-&gt;hscb)-&gt;target_channel_lun &gt;&gt; 4) &amp; 0xf),  &bslash;&n;                        (((scb-&gt;hscb)-&gt;target_channel_lun &gt;&gt; 3) &amp; 0x01), &bslash;&n;                        ((scb-&gt;hscb)-&gt;target_channel_lun &amp; 0x07)
DECL|macro|TC_OF_SCB
mdefine_line|#define TC_OF_SCB(scb) (((scb-&gt;hscb)-&gt;target_channel_lun &gt;&gt; 4) &amp; 0xf),  &bslash;&n;                       (((scb-&gt;hscb)-&gt;target_channel_lun &gt;&gt; 3) &amp; 0x01)
DECL|macro|CHAN_TO_INT
mdefine_line|#define CHAN_TO_INT(chan) ((chan) == &squot;A&squot; ? 0 : 1)
DECL|macro|TARGET_INDEX
mdefine_line|#define TARGET_INDEX(cmd)  ((cmd)-&gt;target | ((cmd)-&gt;channel &lt;&lt; 3))
multiline_comment|/*&n; * XXX - these options apply unilaterally to _all_ 274x/284x/294x&n; *       cards in the system.  This should be fixed.&n; */
DECL|variable|aic7xxx_extended
r_static
r_int
r_int
id|aic7xxx_extended
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* extended translation on? */
DECL|variable|aic7xxx_no_reset
r_static
r_int
r_int
id|aic7xxx_no_reset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no resetting of SCSI bus */
DECL|variable|aic7xxx_irq_trigger
r_static
r_int
id|aic7xxx_irq_trigger
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;                                              * -1 use board setting&n;                                              *  0 use edge triggered&n;                                              *  1 use level triggered&n;                                              */
DECL|variable|aic7xxx_enable_ultra
r_static
r_int
id|aic7xxx_enable_ultra
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* enable ultra SCSI speeds */
DECL|variable|aic7xxx_verbose
r_static
r_int
id|aic7xxx_verbose
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* verbose messages */
multiline_comment|/****************************************************************************&n; *&n; * These functions are not used yet, but when we do memory mapped&n; * IO, we&squot;ll use them then.&n; *&n; ***************************************************************************/
r_static
r_inline
r_int
r_char
DECL|function|aic_inb
id|aic_inb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|port
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;maddr
op_ne
l_int|NULL
)paren
r_return
(paren
id|p-&gt;maddr
(braket
id|port
)braket
)paren
suffix:semicolon
r_else
r_return
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|port
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|aic_outb
id|aic_outb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
id|val
comma
r_int
id|port
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;maddr
op_ne
l_int|NULL
)paren
id|p-&gt;maddr
(braket
id|port
)braket
op_assign
id|val
suffix:semicolon
r_else
id|outb
c_func
(paren
id|val
comma
id|p-&gt;base
op_plus
id|port
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|aic_outsb
id|aic_outsb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|port
comma
r_int
r_char
op_star
id|valp
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;maddr
op_ne
l_int|NULL
)paren
(brace
id|__asm
id|__volatile
c_func
(paren
"&quot;"
id|cld
suffix:semicolon
l_int|1
suffix:colon
id|lodsb
suffix:semicolon
id|movb
op_mod
op_mod
id|al
comma
(paren
op_mod
l_int|0
)paren
suffix:semicolon
id|loop
l_int|1
id|b
"&quot;"
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
(paren
id|p
)paren
op_member_access_from_pointer
id|maddr
op_plus
(paren
id|port
)paren
)paren
comma
l_string|&quot;S&quot;
(paren
(paren
id|valp
)paren
)paren
comma
l_string|&quot;c&quot;
(paren
(paren
id|size
)paren
)paren
suffix:colon
l_string|&quot;%esi&quot;
comma
l_string|&quot;%ecx&quot;
comma
l_string|&quot;%eax&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|outsb
c_func
(paren
id|p-&gt;base
op_plus
id|port
comma
id|valp
comma
id|size
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_setup&n; *&n; * Description:&n; *   Handle Linux boot parameters. This routine allows for assigning a value&n; *   to a parameter with a &squot;:&squot; between the parameter and the value.&n; *   ie. aic7xxx=unpause:0x0A,extended&n; *-F*************************************************************************/
r_void
DECL|function|aic7xxx_setup
id|aic7xxx_setup
c_func
(paren
r_char
op_star
id|s
comma
r_int
op_star
id|dummy
)paren
(brace
r_int
id|i
comma
id|n
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_static
r_struct
(brace
r_const
r_char
op_star
id|name
suffix:semicolon
r_int
r_int
op_star
id|flag
suffix:semicolon
)brace
id|options
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;extended&quot;
comma
op_amp
id|aic7xxx_extended
)brace
comma
(brace
l_string|&quot;no_reset&quot;
comma
op_amp
id|aic7xxx_no_reset
)brace
comma
(brace
l_string|&quot;irq_trigger&quot;
comma
op_amp
id|aic7xxx_irq_trigger
)brace
comma
(brace
l_string|&quot;ultra&quot;
comma
op_amp
id|aic7xxx_enable_ultra
)brace
comma
(brace
l_string|&quot;verbose&quot;
comma
op_amp
id|aic7xxx_verbose
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|strtok
c_func
(paren
id|s
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|strtok
c_func
(paren
l_int|NULL
comma
l_string|&quot;,&quot;
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|options
(braket
id|i
)braket
dot
id|name
suffix:semicolon
id|i
op_increment
)paren
(brace
id|n
op_assign
id|strlen
c_func
(paren
id|options
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|options
(braket
id|i
)braket
dot
id|name
comma
id|p
comma
id|n
)paren
)paren
(brace
r_if
c_cond
(paren
id|p
(braket
id|n
)braket
op_eq
l_char|&squot;:&squot;
)paren
(brace
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
id|n
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
op_assign
op_logical_neg
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   pause_sequencer&n; *&n; * Description:&n; *   Pause the sequencer and wait for it to actually stop - this&n; *   is important since the sequencer can disable pausing for critical&n; *   sections.&n; *-F*************************************************************************/
r_static
r_inline
r_void
DECL|function|pause_sequencer
id|pause_sequencer
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
id|outb
c_func
(paren
id|p-&gt;pause
comma
id|p-&gt;base
op_plus
id|HCNTRL
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|HCNTRL
)paren
op_amp
id|PAUSE
)paren
op_eq
l_int|0
)paren
(brace
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   unpause_sequencer&n; *&n; * Description:&n; *   Unpause the sequencer. Unremarkable, yet done often enough to&n; *   warrant an easy way to do it.&n; *-F*************************************************************************/
r_static
r_inline
r_void
DECL|function|unpause_sequencer
id|unpause_sequencer
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|unpause_always
)paren
(brace
r_if
c_cond
(paren
id|unpause_always
op_logical_or
(paren
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|INTSTAT
)paren
op_amp
(paren
id|SCSIINT
op_or
id|SEQINT
op_or
id|BRKADRINT
)paren
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|outb
c_func
(paren
id|p-&gt;unpause
comma
id|p-&gt;base
op_plus
id|HCNTRL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   restart_sequencer&n; *&n; * Description:&n; *   Restart the sequencer program from address zero.  This assumes&n; *   that the sequencer is already paused.&n; *-F*************************************************************************/
r_static
r_inline
r_void
DECL|function|restart_sequencer
id|restart_sequencer
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
multiline_comment|/* Set the sequencer address to 0. */
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SEQADDR0
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SEQADDR1
)paren
suffix:semicolon
multiline_comment|/*&n;   * Reset and unpause the sequencer.  The reset is suppose to&n;   * start the sequencer running, but we do an unpause to make&n;   * sure.&n;   */
id|outb
c_func
(paren
id|SEQRESET
op_or
id|FASTMODE
comma
id|p-&gt;base
op_plus
id|SEQCTL
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/*unpause_always*/
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_next_patch&n; *&n; * Description:&n; *   Find the next patch to download.&n; *-F*************************************************************************/
r_static
r_struct
id|patch
op_star
DECL|function|aic7xxx_next_patch
id|aic7xxx_next_patch
c_func
(paren
r_struct
id|patch
op_star
id|cur_patch
comma
r_int
id|options
comma
r_int
id|instrptr
)paren
(brace
r_while
c_loop
(paren
id|cur_patch
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
(paren
id|cur_patch-&gt;options
op_amp
id|options
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
id|cur_patch-&gt;negative
op_eq
id|FALSE
)paren
)paren
op_logical_or
(paren
(paren
(paren
id|cur_patch-&gt;options
op_amp
id|options
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|cur_patch-&gt;negative
op_eq
id|TRUE
)paren
)paren
op_logical_or
(paren
id|instrptr
op_ge
id|cur_patch-&gt;end
)paren
)paren
(brace
multiline_comment|/*&n;       * Either we want to keep this section of code, or we have consumed&n;       * this patch.  Skip to the next patch.&n;       */
id|cur_patch
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cur_patch-&gt;options
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Out of patches. */
id|cur_patch
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Found an OK patch. */
r_break
suffix:semicolon
)brace
)brace
r_return
(paren
id|cur_patch
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_download_instr&n; *&n; * Description:&n; *   Find the next patch to download.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_download_instr
id|aic7xxx_download_instr
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|options
comma
r_int
id|instrptr
)paren
(brace
r_int
r_char
id|opcode
suffix:semicolon
r_struct
id|ins_format3
op_star
id|instr
suffix:semicolon
id|instr
op_assign
(paren
r_struct
id|ins_format3
op_star
)paren
op_amp
id|seqprog
(braket
id|instrptr
op_star
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Pull the opcode */
id|opcode
op_assign
id|instr-&gt;opcode_addr
op_rshift
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|AIC_OP_JMP
suffix:colon
r_case
id|AIC_OP_JC
suffix:colon
r_case
id|AIC_OP_JNC
suffix:colon
r_case
id|AIC_OP_CALL
suffix:colon
r_case
id|AIC_OP_JNE
suffix:colon
r_case
id|AIC_OP_JNZ
suffix:colon
r_case
id|AIC_OP_JE
suffix:colon
r_case
id|AIC_OP_JZ
suffix:colon
(brace
r_int
id|address_offset
suffix:semicolon
r_struct
id|ins_format3
id|new_instr
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_struct
id|patch
op_star
id|patch
suffix:semicolon
r_int
id|i
suffix:semicolon
id|address_offset
op_assign
l_int|0
suffix:semicolon
id|new_instr
op_assign
op_star
id|instr
suffix:semicolon
multiline_comment|/* Strucure copy */
id|address
op_assign
id|new_instr.address
suffix:semicolon
id|address
op_or_assign
(paren
id|new_instr.opcode_addr
op_amp
id|ADDR_HIGH_BIT
)paren
op_lshift
l_int|8
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMBER
c_func
(paren
id|patches
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|patch
op_assign
op_amp
id|patches
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
(paren
id|patch-&gt;options
op_amp
id|options
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|patch-&gt;negative
op_eq
id|FALSE
)paren
)paren
op_logical_or
(paren
(paren
(paren
id|patch-&gt;options
op_amp
id|options
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
id|patch-&gt;negative
op_eq
id|TRUE
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|address
op_ge
id|patch-&gt;end
)paren
(brace
id|address_offset
op_add_assign
id|patch-&gt;end
op_minus
id|patch-&gt;begin
suffix:semicolon
)brace
)brace
)brace
id|address
op_sub_assign
id|address_offset
suffix:semicolon
id|new_instr.address
op_assign
id|address
op_amp
l_int|0xFF
suffix:semicolon
id|new_instr.opcode_addr
op_and_assign
op_complement
id|ADDR_HIGH_BIT
suffix:semicolon
id|new_instr.opcode_addr
op_or_assign
(paren
id|address
op_rshift
l_int|8
)paren
op_amp
id|ADDR_HIGH_BIT
suffix:semicolon
id|outsb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQRAM
comma
op_amp
id|new_instr.immediate
comma
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|AIC_OP_OR
suffix:colon
r_case
id|AIC_OP_AND
suffix:colon
r_case
id|AIC_OP_XOR
suffix:colon
r_case
id|AIC_OP_ADD
suffix:colon
r_case
id|AIC_OP_ADC
suffix:colon
r_case
id|AIC_OP_ROL
suffix:colon
id|outsb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQRAM
comma
op_amp
id|instr-&gt;immediate
comma
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;aic7xxx: Unknown opcode encountered in sequencer program.&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_loadseq&n; *&n; * Description:&n; *   Load the sequencer code into the controller memory.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_loadseq
id|aic7xxx_loadseq
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_int
id|options
suffix:semicolon
r_struct
id|patch
op_star
id|cur_patch
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|downloaded
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Downloading sequencer code...&quot;
)paren
suffix:semicolon
)brace
id|options
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Code for all options. */
id|downloaded
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|ULTRA_ENABLED
)paren
op_ne
l_int|0
)paren
id|options
op_or_assign
id|ULTRA
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;bus_type
op_eq
id|AIC_TWIN
)paren
id|options
op_or_assign
id|TWIN_CHANNEL
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;maxscbs
OG
id|p-&gt;scb_data-&gt;maxhscbs
)paren
id|options
op_or_assign
id|SCB_PAGING
suffix:semicolon
id|cur_patch
op_assign
id|patches
suffix:semicolon
id|outb
c_func
(paren
id|PERRORDIS
op_or
id|LOADRAM
comma
id|p-&gt;base
op_plus
id|SEQCTL
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SEQADDR0
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SEQADDR1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|seqprog
)paren
op_div
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cur_patch
op_assign
id|aic7xxx_next_patch
c_func
(paren
id|cur_patch
comma
id|options
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_patch
op_logical_and
(paren
id|cur_patch-&gt;begin
op_le
id|i
)paren
op_logical_and
(paren
id|cur_patch-&gt;end
OG
id|i
)paren
)paren
(brace
multiline_comment|/* Skip this instruction for this configuration. */
r_continue
suffix:semicolon
)brace
id|aic7xxx_download_instr
c_func
(paren
id|p
comma
id|options
comma
id|i
)paren
suffix:semicolon
id|downloaded
op_increment
suffix:semicolon
)brace
id|outb
c_func
(paren
id|FASTMODE
comma
id|p-&gt;base
op_plus
id|SEQCTL
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SEQADDR0
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SEQADDR1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %d instructions downloaded&bslash;n&quot;
comma
id|downloaded
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_delay&n; *&n; * Description:&n; *   Delay for specified amount of time.  We use udelay because the timer&n; *   interrupt is not guaranteed to be enabled.  This will cause an&n; *   infinite loop since jiffies (clock ticks) is not updated.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_delay
id|aic7xxx_delay
c_func
(paren
r_int
id|seconds
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*                        &n;   * Call udelay() for 1 millisecond inside a loop for  &n;   * the requested amount of seconds.&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|seconds
op_star
l_int|1000
suffix:semicolon
id|i
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* Delay for 1 millisecond. */
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   rcs_version&n; *&n; * Description:&n; *   Return a string containing just the RCS version number from either&n; *   an Id or Revision RCS clause.&n; *-F*************************************************************************/
r_const
r_char
op_star
DECL|function|rcs_version
id|rcs_version
c_func
(paren
r_const
r_char
op_star
id|version_info
)paren
(brace
r_static
r_char
id|buf
(braket
l_int|10
)braket
suffix:semicolon
r_char
op_star
id|bp
comma
op_star
id|ep
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|strcpy
c_func
(paren
id|buf
comma
l_string|&quot;????&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|version_info
comma
l_string|&quot;$Id: &quot;
comma
l_int|5
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|bp
op_assign
id|strchr
c_func
(paren
id|version_info
comma
l_char|&squot; &squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|bp
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bp
op_assign
id|strchr
c_func
(paren
id|bp
comma
l_char|&squot; &squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|bp
op_increment
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|version_info
comma
l_string|&quot;$Revision: &quot;
comma
l_int|11
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|bp
op_assign
id|strchr
c_func
(paren
id|version_info
comma
l_char|&squot; &squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|bp
op_increment
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|bp
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|ep
op_assign
id|strchr
c_func
(paren
id|bp
comma
l_char|&squot; &squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_register
r_int
id|len
op_assign
id|ep
op_minus
id|bp
suffix:semicolon
id|strncpy
c_func
(paren
id|buf
comma
id|bp
comma
id|len
)paren
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
r_return
id|buf
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_info&n; *&n; * Description:&n; *   Return a string describing the driver.&n; *-F*************************************************************************/
r_const
r_char
op_star
DECL|function|aic7xxx_info
id|aic7xxx_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|notused
)paren
(brace
r_static
r_char
id|buffer
(braket
l_int|128
)braket
suffix:semicolon
id|strcpy
c_func
(paren
id|buffer
comma
l_string|&quot;Adaptec AHA274x/284x/294x (EISA/VLB/PCI-Fast SCSI) &quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|buffer
comma
id|rcs_version
c_func
(paren
id|AIC7XXX_C_VERSION
)paren
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|buffer
comma
l_string|&quot;/&quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|buffer
comma
id|rcs_version
c_func
(paren
id|AIC7XXX_H_VERSION
)paren
)paren
suffix:semicolon
macro_line|#if 0
id|strcat
c_func
(paren
id|buffer
comma
l_string|&quot;/&quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|buffer
comma
id|rcs_version
c_func
(paren
id|AIC7XXX_SEQ_VER
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|buffer
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_length&n; *&n; * Description:&n; *   How much data should be transferred for this SCSI command?  Assume&n; *   all segments are to be transferred except for the last sg_last&n; *   segments.  This will allow us to compute underflow easily.  To&n; *   calculate the total length of the command, use sg_last = 0.  To&n; *   calculate the length of all but the last 2 SG segments, use&n; *   sg_last = 2.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_length
id|aic7xxx_length
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|sg_last
)paren
(brace
r_int
id|i
comma
id|segments
suffix:semicolon
r_int
id|length
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
id|segments
op_assign
id|cmd-&gt;use_sg
op_minus
id|sg_last
suffix:semicolon
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|length
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|segments
suffix:semicolon
id|i
op_increment
)paren
(brace
id|length
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
)brace
r_else
(brace
id|length
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
)brace
r_return
(paren
id|length
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_scsirate&n; *&n; * Description:&n; *   Look up the valid period to SCSIRATE conversion in our table&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_scsirate
id|aic7xxx_scsirate
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
op_star
id|scsirate
comma
r_int
r_char
op_star
id|period
comma
r_int
r_char
op_star
id|offset
comma
r_int
id|target
comma
r_char
id|channel
)paren
(brace
r_int
id|i
op_assign
id|num_aic7xxx_syncrates
suffix:semicolon
r_int
r_int
id|ultra_enb_addr
suffix:semicolon
r_int
r_char
id|ultra_enb
comma
id|sxfrctl0
suffix:semicolon
multiline_comment|/*&n;   * If the offset is 0, then the device is requesting asynchronous&n;   * transfers.&n;   */
r_if
c_cond
(paren
(paren
op_star
id|period
op_ge
id|aic7xxx_syncrates
(braket
id|i
)braket
dot
id|period
)paren
op_logical_and
op_star
id|offset
op_ne
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_aic7xxx_syncrates
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|period
op_le
id|aic7xxx_syncrates
(braket
id|i
)braket
dot
id|period
)paren
(brace
multiline_comment|/*&n;         * Watch out for Ultra speeds when ultra is not enabled and&n;         * vice-versa.&n;         */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|ULTRA_ENABLED
)paren
op_logical_and
(paren
id|aic7xxx_syncrates
(braket
id|i
)braket
dot
id|rate
op_amp
id|ULTRA_SXFR
)paren
)paren
(brace
multiline_comment|/*&n;           * This should only happen if the drive is the first to negotiate&n;           * and chooses a high rate.   We&squot;ll just move down the table until&n;           * we hit a non ultra speed.&n;           */
r_continue
suffix:semicolon
)brace
op_star
id|scsirate
op_assign
(paren
id|aic7xxx_syncrates
(braket
id|i
)braket
dot
id|rate
op_amp
l_int|0xF0
)paren
op_or
(paren
op_star
id|offset
op_amp
l_int|0x0F
)paren
suffix:semicolon
op_star
id|period
op_assign
id|aic7xxx_syncrates
(braket
id|i
)braket
dot
id|period
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Target %d, channel %c, now synchronous at %sMHz, &quot;
l_string|&quot;offset %d.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|target
comma
id|channel
comma
id|aic7xxx_syncrates
(braket
id|i
)braket
dot
id|english
comma
op_star
id|offset
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|i
op_ge
id|num_aic7xxx_syncrates
)paren
(brace
multiline_comment|/*&n;     * Use asynchronous transfers.&n;     */
op_star
id|scsirate
op_assign
l_int|0
suffix:semicolon
op_star
id|period
op_assign
l_int|0
suffix:semicolon
op_star
id|offset
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: Target %d, channel %c, using asynchronous transfers.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|target
comma
id|channel
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Ensure Ultra mode is set properly for this target.&n;   */
id|ultra_enb_addr
op_assign
id|ULTRA_ENB
suffix:semicolon
r_if
c_cond
(paren
(paren
id|channel
op_eq
l_char|&squot;B&squot;
)paren
op_logical_or
(paren
id|target
OG
l_int|7
)paren
)paren
(brace
id|ultra_enb_addr
op_increment
suffix:semicolon
)brace
id|ultra_enb
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|ultra_enb_addr
)paren
suffix:semicolon
id|sxfrctl0
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SXFRCTL0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|scsirate
op_ne
l_int|0
)paren
op_logical_and
(paren
id|aic7xxx_syncrates
(braket
id|i
)braket
dot
id|rate
op_amp
id|ULTRA_SXFR
)paren
)paren
(brace
id|ultra_enb
op_or_assign
l_int|0x01
op_lshift
(paren
id|target
op_amp
l_int|0x07
)paren
suffix:semicolon
id|sxfrctl0
op_or_assign
id|FAST20
suffix:semicolon
)brace
r_else
(brace
id|ultra_enb
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
(paren
id|target
op_amp
l_int|0x07
)paren
)paren
suffix:semicolon
id|sxfrctl0
op_and_assign
op_complement
id|FAST20
suffix:semicolon
)brace
id|outb
c_func
(paren
id|ultra_enb
comma
id|p-&gt;base
op_plus
id|ultra_enb_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|sxfrctl0
comma
id|p-&gt;base
op_plus
id|SXFRCTL0
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   scbq_init&n; *&n; * Description:&n; *   SCB queue initialization.&n; *&n; *-F*************************************************************************/
r_static
r_inline
r_void
DECL|function|scbq_init
id|scbq_init
c_func
(paren
id|scb_queue_type
op_star
id|queue
)paren
(brace
id|queue-&gt;head
op_assign
l_int|NULL
suffix:semicolon
id|queue-&gt;tail
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   scbq_insert_head&n; *&n; * Description:&n; *   Add an SCB to the head of the list.&n; *&n; *-F*************************************************************************/
r_static
r_inline
r_void
DECL|function|scbq_insert_head
id|scbq_insert_head
c_func
(paren
id|scb_queue_type
op_star
id|queue
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
id|scb-&gt;q_next
op_assign
id|queue-&gt;head
suffix:semicolon
id|queue-&gt;head
op_assign
id|scb
suffix:semicolon
r_if
c_cond
(paren
id|queue-&gt;tail
op_eq
l_int|NULL
)paren
multiline_comment|/* If list was empty, update tail. */
id|queue-&gt;tail
op_assign
id|queue-&gt;head
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   scbq_remove_head&n; *&n; * Description:&n; *   Remove an SCB from the head of the list.&n; *&n; *-F*************************************************************************/
r_static
r_inline
r_void
DECL|function|scbq_remove_head
id|scbq_remove_head
c_func
(paren
id|scb_queue_type
op_star
id|queue
)paren
(brace
r_if
c_cond
(paren
id|queue-&gt;head
op_ne
l_int|NULL
)paren
id|queue-&gt;head
op_assign
id|queue-&gt;head-&gt;q_next
suffix:semicolon
r_if
c_cond
(paren
id|queue-&gt;head
op_eq
l_int|NULL
)paren
multiline_comment|/* If list is now empty, update tail. */
id|queue-&gt;tail
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   scbq_remove&n; *&n; * Description:&n; *   Removes an SCB from the list.&n; *&n; *-F*************************************************************************/
r_static
r_inline
r_void
DECL|function|scbq_remove
id|scbq_remove
c_func
(paren
id|scb_queue_type
op_star
id|queue
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
r_if
c_cond
(paren
id|queue-&gt;head
op_eq
id|scb
)paren
(brace
multiline_comment|/* At beginning of queue, remove from head. */
id|scbq_remove_head
c_func
(paren
id|queue
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|aic7xxx_scb
op_star
id|curscb
op_assign
id|queue-&gt;head
suffix:semicolon
multiline_comment|/*&n;     * Search until the next scb is the one we&squot;re looking for, or&n;     * we run out of queue.&n;     */
r_while
c_loop
(paren
(paren
id|curscb
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|curscb-&gt;q_next
op_ne
id|scb
)paren
)paren
(brace
id|curscb
op_assign
id|curscb-&gt;q_next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|curscb
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Found it. */
id|curscb-&gt;q_next
op_assign
id|scb-&gt;q_next
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;q_next
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Update the tail when removing the tail. */
id|queue-&gt;tail
op_assign
id|curscb
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   scbq_insert_tail&n; *&n; * Description:&n; *   Add an SCB at the tail of the list.&n; *&n; *-F*************************************************************************/
r_static
r_inline
r_void
DECL|function|scbq_insert_tail
id|scbq_insert_tail
c_func
(paren
id|scb_queue_type
op_star
id|queue
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
id|scb-&gt;q_next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|queue-&gt;tail
op_ne
l_int|NULL
)paren
multiline_comment|/* Add the scb at the end of the list. */
id|queue-&gt;tail-&gt;q_next
op_assign
id|scb
suffix:semicolon
id|queue-&gt;tail
op_assign
id|scb
suffix:semicolon
multiline_comment|/* Update the tail. */
r_if
c_cond
(paren
id|queue-&gt;head
op_eq
l_int|NULL
)paren
multiline_comment|/* If list was empty, update head. */
id|queue-&gt;head
op_assign
id|queue-&gt;tail
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_match_scb&n; *&n; * Description:&n; *   Checks to see if an scb matches the target/channel as specified.&n; *   If target is ALL_TARGETS (-1), then we&squot;re looking for any device&n; *   on the specified channel; this happens when a channel is going&n; *   to be reset and all devices on that channel must be aborted.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_match_scb
id|aic7xxx_match_scb
c_func
(paren
r_struct
id|aic7xxx_scb
op_star
id|scb
comma
r_int
id|target
comma
r_char
id|channel
comma
r_int
id|lun
comma
r_int
r_char
id|tag
)paren
(brace
r_int
id|targ
op_assign
(paren
id|scb-&gt;hscb-&gt;target_channel_lun
op_rshift
l_int|4
)paren
op_amp
l_int|0x0F
suffix:semicolon
r_char
id|chan
op_assign
(paren
id|scb-&gt;hscb-&gt;target_channel_lun
op_amp
id|SELBUSB
)paren
ques
c_cond
l_char|&squot;B&squot;
suffix:colon
l_char|&squot;A&squot;
suffix:semicolon
r_int
id|slun
op_assign
id|scb-&gt;hscb-&gt;target_channel_lun
op_amp
l_int|0x07
suffix:semicolon
r_int
id|match
suffix:semicolon
macro_line|#ifdef AIC7XXX_DEBUG_ABORT
id|printk
c_func
(paren
l_string|&quot;scsi%d: (targ %d/chan %c) matching scb to (targ %d/chan %c)&bslash;n&quot;
comma
id|scb-&gt;cmd-&gt;device-&gt;host-&gt;host_no
comma
id|target
comma
id|channel
comma
id|targ
comma
id|chan
)paren
suffix:semicolon
macro_line|#endif
id|match
op_assign
(paren
(paren
id|chan
op_eq
id|channel
)paren
op_logical_or
(paren
id|channel
op_eq
id|ALL_CHANNELS
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
op_ne
l_int|0
)paren
id|match
op_assign
(paren
(paren
id|targ
op_eq
id|target
)paren
op_logical_or
(paren
id|target
op_eq
id|ALL_TARGETS
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
op_ne
l_int|0
)paren
id|match
op_assign
(paren
(paren
id|lun
op_eq
id|slun
)paren
op_logical_or
(paren
id|lun
op_eq
id|ALL_LUNS
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
op_ne
l_int|0
)paren
id|match
op_assign
(paren
(paren
id|tag
op_eq
id|scb-&gt;hscb-&gt;tag
)paren
op_logical_or
(paren
id|tag
op_eq
id|SCB_LIST_NULL
)paren
)paren
suffix:semicolon
r_return
(paren
id|match
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_add_curscb_to_free_list&n; *&n; * Description:&n; *   Adds the current scb (in SCBPTR) to the list of free SCBs.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_add_curscb_to_free_list
id|aic7xxx_add_curscb_to_free_list
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
multiline_comment|/*&n;   * Invalidate the tag so that aic7xxx_find_scb doesn&squot;t think&n;   * it&squot;s active&n;   */
id|outb
c_func
(paren
id|SCB_LIST_NULL
comma
id|p-&gt;base
op_plus
id|SCB_TAG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|FREE_SCBH
)paren
comma
id|p-&gt;base
op_plus
id|SCB_NEXT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCBPTR
)paren
comma
id|p-&gt;base
op_plus
id|FREE_SCBH
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_rem_scb_from_disc_list&n; *&n; * Description:&n; *   Removes the current SCB from the disconnected list and adds it&n; *   to the free list.&n; *-F*************************************************************************/
r_static
r_int
r_char
DECL|function|aic7xxx_rem_scb_from_disc_list
id|aic7xxx_rem_scb_from_disc_list
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
id|scbptr
)paren
(brace
r_int
r_char
id|next
suffix:semicolon
r_int
r_char
id|prev
suffix:semicolon
id|outb
c_func
(paren
id|scbptr
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|next
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_NEXT
)paren
suffix:semicolon
id|prev
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_PREV
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SCB_CONTROL
)paren
suffix:semicolon
id|aic7xxx_add_curscb_to_free_list
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_ne
id|SCB_LIST_NULL
)paren
(brace
id|outb
c_func
(paren
id|prev
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|next
comma
id|p-&gt;base
op_plus
id|SCB_NEXT
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
id|next
comma
id|p-&gt;base
op_plus
id|DISCONNECTED_SCBH
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|next
op_ne
id|SCB_LIST_NULL
)paren
(brace
id|outb
c_func
(paren
id|next
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|prev
comma
id|p-&gt;base
op_plus
id|SCB_PREV
)paren
suffix:semicolon
)brace
r_return
id|next
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_busy_target&n; *&n; * Description:&n; *   Set the specified target busy.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_busy_target
id|aic7xxx_busy_target
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
id|target
comma
r_char
id|channel
comma
r_int
r_char
id|scbid
)paren
(brace
r_int
r_char
id|active_scb
suffix:semicolon
r_int
r_char
id|info_scb
suffix:semicolon
r_int
r_int
id|scb_offset
suffix:semicolon
id|info_scb
op_assign
id|target
op_div
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
l_char|&squot;B&squot;
)paren
id|info_scb
op_assign
id|info_scb
op_plus
l_int|2
suffix:semicolon
id|active_scb
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|info_scb
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|scb_offset
op_assign
id|SCB_BUSYTARGETS
op_plus
(paren
id|target
op_amp
l_int|0x03
)paren
suffix:semicolon
id|outb
c_func
(paren
id|scbid
comma
id|p-&gt;base
op_plus
id|scb_offset
)paren
suffix:semicolon
id|outb
c_func
(paren
id|active_scb
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_index_busy_target&n; *&n; * Description:&n; *   Returns the index of the busy target, and optionally sets the&n; *   target inactive.&n; *-F*************************************************************************/
r_static
r_int
r_char
DECL|function|aic7xxx_index_busy_target
id|aic7xxx_index_busy_target
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
id|target
comma
r_char
id|channel
comma
r_int
id|unbusy
)paren
(brace
r_int
r_char
id|active_scb
suffix:semicolon
r_int
r_char
id|info_scb
suffix:semicolon
r_int
r_char
id|busy_scbid
suffix:semicolon
r_int
r_int
id|scb_offset
suffix:semicolon
id|info_scb
op_assign
id|target
op_div
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
l_char|&squot;B&squot;
)paren
id|info_scb
op_assign
id|info_scb
op_plus
l_int|2
suffix:semicolon
id|active_scb
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|info_scb
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|scb_offset
op_assign
id|SCB_BUSYTARGETS
op_plus
(paren
id|target
op_amp
l_int|0x03
)paren
suffix:semicolon
id|busy_scbid
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|scb_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unbusy
)paren
(brace
id|outb
c_func
(paren
id|SCB_LIST_NULL
comma
id|p-&gt;base
op_plus
id|scb_offset
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|active_scb
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
r_return
(paren
id|busy_scbid
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_find_scb&n; *&n; * Description:&n; *   Look through the SCB array of the card and attempt to find the&n; *   hardware SCB that corresponds to the passed in SCB.  Return&n; *   SCB_LIST_NULL if unsuccessful.  This routine assumes that the&n; *   card is already paused.&n; *-F*************************************************************************/
r_static
r_int
r_char
DECL|function|aic7xxx_find_scb
id|aic7xxx_find_scb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
r_int
r_char
id|saved_scbptr
suffix:semicolon
r_int
r_char
id|curindex
suffix:semicolon
id|saved_scbptr
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|curindex
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|curindex
op_assign
l_int|0
suffix:semicolon
id|curindex
OL
id|p-&gt;scb_data-&gt;maxhscbs
suffix:semicolon
id|curindex
op_increment
)paren
(brace
id|outb
c_func
(paren
id|curindex
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_TAG
)paren
op_eq
id|scb-&gt;hscb-&gt;tag
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|outb
c_func
(paren
id|saved_scbptr
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curindex
op_ge
id|p-&gt;scb_data-&gt;maxhscbs
)paren
(brace
id|curindex
op_assign
id|SCB_LIST_NULL
suffix:semicolon
)brace
r_return
(paren
id|curindex
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_allocate_scb&n; *&n; * Description:&n; *   Get an SCB from the free list or by allocating a new one.&n; *-F*************************************************************************/
r_static
r_struct
id|aic7xxx_scb
op_star
DECL|function|aic7xxx_allocate_scb
id|aic7xxx_allocate_scb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scbp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|aic7xxx_hwscb
op_star
id|hscbp
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef AGRESSIVE
r_int
id|processor_flags
suffix:semicolon
id|save_flags
c_func
(paren
id|processor_flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|scbp
op_assign
id|p-&gt;scb_data-&gt;free_scbs.head
suffix:semicolon
r_if
c_cond
(paren
id|scbp
op_ne
l_int|NULL
)paren
(brace
id|scbq_remove_head
c_func
(paren
op_amp
id|p-&gt;scb_data-&gt;free_scbs
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;numscbs
OL
id|p-&gt;scb_data-&gt;maxscbs
)paren
(brace
r_int
id|scb_index
op_assign
id|p-&gt;scb_data-&gt;numscbs
suffix:semicolon
r_int
id|scb_size
op_assign
r_sizeof
(paren
r_struct
id|aic7xxx_scb
)paren
op_plus
r_sizeof
(paren
r_struct
id|hw_scatterlist
)paren
op_star
id|AIC7XXX_MAX_SG
suffix:semicolon
id|scbp
op_assign
id|kmalloc
c_func
(paren
id|scb_size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scbp
op_ne
l_int|NULL
)paren
(brace
id|memset
c_func
(paren
id|scbp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|aic7xxx_scb
)paren
)paren
suffix:semicolon
id|hscbp
op_assign
op_amp
id|p-&gt;scb_data-&gt;hscbs
(braket
id|scb_index
)braket
suffix:semicolon
id|scbp-&gt;hscb
op_assign
id|hscbp
suffix:semicolon
id|scbp-&gt;sg_list
op_assign
(paren
r_struct
id|hw_scatterlist
op_star
)paren
op_amp
id|scbp
(braket
l_int|1
)braket
suffix:semicolon
id|memset
c_func
(paren
id|hscbp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|aic7xxx_hwscb
)paren
)paren
suffix:semicolon
id|hscbp-&gt;tag
op_assign
id|scb_index
suffix:semicolon
id|p-&gt;scb_data-&gt;numscbs
op_increment
suffix:semicolon
multiline_comment|/*&n;         * Place in the scb array; never is removed&n;         */
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
op_assign
id|scbp
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef AIC7XXX_DEBUG
r_if
c_cond
(paren
id|scbp
op_ne
l_int|NULL
)paren
(brace
id|p-&gt;activescbs
op_increment
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef AGRESSIVE
id|restore_flags
c_func
(paren
id|processor_flags
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|scbp
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_queue_cmd_complete&n; *&n; * Description:&n; *   Due to race conditions present in the SCSI subsystem, it is easier&n; *   to queue completed commands, then call scsi_done() on them when&n; *   we&squot;re finished.  This function queues the completed commands.&n; *-F*************************************************************************/
r_static
r_inline
r_void
DECL|function|aic7xxx_queue_cmd_complete
id|aic7xxx_queue_cmd_complete
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;completeq.tail
op_eq
l_int|NULL
)paren
id|p-&gt;completeq.head
op_assign
id|cmd
suffix:semicolon
r_else
id|p-&gt;completeq.tail-&gt;host_scribble
op_assign
(paren
r_char
op_star
)paren
id|cmd
suffix:semicolon
id|p-&gt;completeq.tail
op_assign
id|cmd
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_done_cmds_complete&n; *&n; * Description:&n; *   Process the completed command queue.&n; *-F*************************************************************************/
r_static
r_inline
r_void
DECL|function|aic7xxx_done_cmds_complete
id|aic7xxx_done_cmds_complete
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_while
c_loop
(paren
id|p-&gt;completeq.head
op_ne
l_int|NULL
)paren
(brace
id|cmd
op_assign
id|p-&gt;completeq.head
suffix:semicolon
id|p-&gt;completeq.head
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;device_status
(braket
id|TARGET_INDEX
c_func
(paren
id|cmd
)paren
)braket
dot
id|active_cmds
op_decrement
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
id|p-&gt;completeq.tail
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_free_scb&n; *&n; * Description:&n; *   Free the scb and insert into the free scb list.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_free_scb
id|aic7xxx_free_scb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
r_struct
id|aic7xxx_hwscb
op_star
id|hscb
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|scb-&gt;flags
op_assign
id|SCB_FREE
suffix:semicolon
id|scb-&gt;cmd
op_assign
l_int|NULL
suffix:semicolon
id|hscb-&gt;control
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;target_status
op_assign
l_int|0
suffix:semicolon
id|scbq_insert_head
c_func
(paren
op_amp
id|p-&gt;scb_data-&gt;free_scbs
comma
id|scb
)paren
suffix:semicolon
macro_line|#ifdef AIC7XXX_DEBUG
id|p-&gt;activescbs
op_decrement
suffix:semicolon
multiline_comment|/* For debugging purposes. */
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_done&n; *&n; * Description:&n; *   Calls the higher level scsi done function and frees the scb.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_done
id|aic7xxx_done
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_RECOVERY_SCB
)paren
(brace
id|p-&gt;flags
op_and_assign
op_complement
id|IN_TIMEOUT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd-&gt;result
op_eq
id|DID_OK
)paren
(brace
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_ABORTED
)paren
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_RESET
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
(paren
id|SCB_MSGOUT_WDTR
op_or
id|SCB_MSGOUT_SDTR
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
id|mask
op_assign
l_int|0x01
op_lshift
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_WDTR
)paren
(brace
id|p-&gt;wdtr_pending
op_and_assign
op_complement
id|mask
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_SDTR
)paren
(brace
id|p-&gt;sdtr_pending
op_and_assign
op_complement
id|mask
suffix:semicolon
)brace
)brace
id|aic7xxx_free_scb
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
id|aic7xxx_queue_cmd_complete
c_func
(paren
id|p
comma
id|cmd
)paren
suffix:semicolon
macro_line|#ifdef AIC7XXX_PROC_STATS
(brace
r_int
id|actual
suffix:semicolon
multiline_comment|/*&n;     * XXX: we should actually know how much actually transferred&n;     * XXX: for each command, but apparently that&squot;s too difficult.&n;     */
id|actual
op_assign
id|aic7xxx_length
c_func
(paren
id|cmd
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;flags
op_amp
(paren
id|SCB_ABORTED
op_or
id|SCB_SENSE
)paren
)paren
op_logical_and
(paren
id|actual
OG
l_int|0
)paren
op_logical_and
(paren
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_struct
id|aic7xxx_xferstats
op_star
id|sp
suffix:semicolon
r_int
op_star
id|ptr
suffix:semicolon
r_int
id|x
suffix:semicolon
id|sp
op_assign
op_amp
id|p-&gt;stats
(braket
id|cmd-&gt;channel
op_amp
l_int|0x01
)braket
(braket
id|cmd-&gt;target
op_amp
l_int|0x0F
)braket
(braket
id|cmd-&gt;lun
op_amp
l_int|0x07
)braket
suffix:semicolon
id|sp-&gt;xfers
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;request.cmd
op_eq
id|WRITE
)paren
(brace
id|sp-&gt;w_total
op_increment
suffix:semicolon
id|sp-&gt;w_total512
op_add_assign
(paren
id|actual
op_rshift
l_int|9
)paren
suffix:semicolon
id|ptr
op_assign
id|sp-&gt;w_bins
suffix:semicolon
)brace
r_else
(brace
id|sp-&gt;r_total
op_increment
suffix:semicolon
id|sp-&gt;r_total512
op_add_assign
(paren
id|actual
op_rshift
l_int|9
)paren
suffix:semicolon
id|ptr
op_assign
id|sp-&gt;r_bins
suffix:semicolon
)brace
r_for
c_loop
(paren
id|x
op_assign
l_int|9
suffix:semicolon
id|x
op_le
l_int|17
suffix:semicolon
id|x
op_increment
)paren
(brace
r_if
c_cond
(paren
id|actual
OL
(paren
l_int|1
op_lshift
id|x
)paren
)paren
(brace
id|ptr
(braket
id|x
op_minus
l_int|9
)braket
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|x
OG
l_int|17
)paren
(brace
id|ptr
(braket
id|x
op_minus
l_int|9
)braket
op_increment
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* AIC7XXX_PROC_STATS */
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_run_done_queue&n; *&n; * Description:&n; *   Calls the aic7xxx_done() for the Scsi_Cmnd of each scb in the&n; *   aborted list, and adds each scb to the free list.  If complete&n; *   is TRUE, we also process the commands complete list.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_run_done_queue
id|aic7xxx_run_done_queue
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
multiline_comment|/*complete*/
r_int
id|complete
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scb
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;scb_data-&gt;numscbs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_QUEUED_FOR_DONE
)paren
(brace
macro_line|#ifdef AIC7XXX_DEBUG_ABORT
id|printk
c_func
(paren
l_string|&quot;(scsi%d:%d:%d) Aborting scb %d&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
macro_line|#endif
id|aic7xxx_done
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|complete
)paren
(brace
id|aic7xxx_done_cmds_complete
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_abort_waiting_scb&n; *&n; * Description:&n; *   Manipulate the waiting for selection list and return the&n; *   scb that follows the one that we remove.&n; *-F*************************************************************************/
r_static
r_int
r_char
DECL|function|aic7xxx_abort_waiting_scb
id|aic7xxx_abort_waiting_scb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
comma
r_int
r_char
id|scbpos
comma
r_int
r_char
id|prev
)paren
(brace
r_int
r_char
id|curscb
comma
id|next
suffix:semicolon
multiline_comment|/*&n;   * Select the SCB we want to abort and pull the next pointer out of it.&n;   */
id|curscb
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|scbpos
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|next
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_NEXT
)paren
suffix:semicolon
multiline_comment|/*&n;   * Clear the necessary fields&n;   */
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SCB_CONTROL
)paren
suffix:semicolon
id|aic7xxx_add_curscb_to_free_list
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;   * Update the waiting list&n;   */
r_if
c_cond
(paren
id|prev
op_eq
id|SCB_LIST_NULL
)paren
(brace
multiline_comment|/*&n;     * First in the list&n;     */
id|outb
c_func
(paren
id|next
comma
id|p-&gt;base
op_plus
id|WAITING_SCBH
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;     * Select the scb that pointed to us and update its next pointer.&n;     */
id|outb
c_func
(paren
id|prev
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|next
comma
id|p-&gt;base
op_plus
id|SCB_NEXT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * Point us back at the original scb position and inform the SCSI&n;   * system that the command has been aborted.&n;   */
id|outb
c_func
(paren
id|curscb
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_ABORTED
op_or
id|SCB_QUEUED_FOR_DONE
suffix:semicolon
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_ACTIVE
suffix:semicolon
id|scb-&gt;cmd-&gt;result
op_assign
(paren
id|DID_RESET
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
(paren
id|next
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_search_qinfifo&n; *&n; * Description:&n; *   Search the queue-in FIFO for matching SCBs and conditionally&n; *   requeue.  Returns the number of matching SCBs.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_search_qinfifo
id|aic7xxx_search_qinfifo
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|target
comma
r_char
id|channel
comma
r_int
id|lun
comma
r_int
r_char
id|tag
comma
r_int
id|flags
comma
r_int
id|requeue
)paren
(brace
r_int
r_char
id|saved_queue
(braket
id|AIC7XXX_MAXSCB
)braket
suffix:semicolon
r_int
id|queued
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|QINCNT
)paren
op_amp
id|p-&gt;qcntmask
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|found
suffix:semicolon
r_struct
id|aic7xxx_scb
op_star
id|scbp
suffix:semicolon
id|scb_queue_type
id|removed_scbs
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
id|scbq_init
(paren
op_amp
id|removed_scbs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|queued
op_minus
id|found
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|saved_queue
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|QINFIFO
)paren
suffix:semicolon
id|scbp
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|saved_queue
(braket
id|i
)braket
)braket
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_match_scb
c_func
(paren
id|scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
)paren
)paren
(brace
multiline_comment|/*&n;        * We found an scb that needs to be removed.&n;        */
r_if
c_cond
(paren
id|requeue
)paren
(brace
id|scbq_insert_head
c_func
(paren
op_amp
id|removed_scbs
comma
id|scbp
)paren
suffix:semicolon
)brace
r_else
(brace
id|scbp-&gt;flags
op_assign
id|flags
suffix:semicolon
id|scbp-&gt;flags
op_and_assign
op_complement
id|SCB_ACTIVE
suffix:semicolon
multiline_comment|/*&n;          * XXX - Don&squot;t know what error to use here.&n;          */
id|aic7xxx_error
c_func
(paren
id|scbp-&gt;cmd
)paren
op_assign
id|DID_RESET
suffix:semicolon
)brace
id|i
op_decrement
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Now put the saved scbs back. */
r_for
c_loop
(paren
id|queued
op_assign
l_int|0
suffix:semicolon
id|queued
OL
id|i
suffix:semicolon
id|queued
op_increment
)paren
id|outb
c_func
(paren
id|saved_queue
(braket
id|queued
)braket
comma
id|p-&gt;base
op_plus
id|QINFIFO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|requeue
)paren
(brace
id|scbp
op_assign
id|removed_scbs.head
suffix:semicolon
r_while
c_loop
(paren
id|scbp
op_ne
l_int|NULL
)paren
(brace
id|scbq_remove_head
c_func
(paren
op_amp
id|removed_scbs
)paren
suffix:semicolon
multiline_comment|/*&n;       * XXX - Shouldn&squot;t we be adding this to the free list?&n;       */
id|scbq_insert_head
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|scbp
)paren
suffix:semicolon
id|scbp-&gt;flags
op_or_assign
id|SCB_WAITINGQ
suffix:semicolon
id|scbp
op_assign
id|removed_scbs.head
suffix:semicolon
)brace
)brace
r_return
(paren
id|found
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_reset_device&n; *&n; * Description:&n; *   The device at the given target/channel has been reset.  Abort&n; *   all active and queued scbs for that target/channel.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_reset_device
id|aic7xxx_reset_device
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|target
comma
r_char
id|channel
comma
r_int
id|lun
comma
r_int
r_char
id|tag
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scbp
suffix:semicolon
r_int
r_char
id|active_scb
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|found
suffix:semicolon
multiline_comment|/*&n;   * Restore this when we&squot;re done&n;   */
id|active_scb
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
macro_line|#ifdef AIC7XXX_DEBUG_ABORT
id|printk
c_func
(paren
l_string|&quot;(scsi%d:%d:%d) Reset device, active_scb %d&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|target
comma
id|CHAN_TO_INT
c_func
(paren
id|channel
)paren
comma
id|active_scb
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;   * Deal with the busy target and linked next issues.&n;   */
(brace
r_int
id|min_target
comma
id|max_target
suffix:semicolon
r_int
r_char
id|busy_scbid
suffix:semicolon
multiline_comment|/* Make all targets &squot;relative&squot; to bus A. */
r_if
c_cond
(paren
id|target
op_eq
id|ALL_TARGETS
)paren
(brace
r_switch
c_cond
(paren
id|channel
)paren
(brace
r_case
l_char|&squot;A&squot;
suffix:colon
id|min_target
op_assign
l_int|0
suffix:semicolon
id|max_target
op_assign
(paren
id|p-&gt;bus_type
op_eq
id|AIC_SINGLE
)paren
ques
c_cond
l_int|7
suffix:colon
l_int|15
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;B&squot;
suffix:colon
id|min_target
op_assign
l_int|8
suffix:semicolon
id|max_target
op_assign
l_int|15
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ALL_CHANNELS
suffix:colon
r_default
suffix:colon
id|min_target
op_assign
l_int|0
suffix:semicolon
id|max_target
op_assign
(paren
id|p-&gt;bus_type
op_eq
id|AIC_SINGLE
)paren
ques
c_cond
l_int|7
suffix:colon
l_int|15
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|min_target
op_assign
id|target
op_plus
id|channel
op_eq
l_char|&squot;B&squot;
ques
c_cond
l_int|8
suffix:colon
l_int|0
suffix:semicolon
id|max_target
op_assign
id|min_target
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|min_target
suffix:semicolon
id|i
op_le
id|max_target
suffix:semicolon
id|i
op_increment
)paren
(brace
id|busy_scbid
op_assign
id|aic7xxx_index_busy_target
c_func
(paren
id|p
comma
id|i
comma
l_char|&squot;A&squot;
comma
multiline_comment|/*unbusy*/
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|busy_scbid
OL
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|busy_scb
suffix:semicolon
r_struct
id|aic7xxx_scb
op_star
id|next_scb
suffix:semicolon
r_int
r_char
id|next_scbid
suffix:semicolon
id|busy_scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|busy_scbid
)braket
suffix:semicolon
id|next_scbid
op_assign
id|busy_scb-&gt;hscb-&gt;data_count
op_rshift
l_int|24
suffix:semicolon
r_if
c_cond
(paren
id|next_scbid
op_eq
id|SCB_LIST_NULL
)paren
(brace
id|busy_scbid
op_assign
id|aic7xxx_find_scb
c_func
(paren
id|p
comma
id|busy_scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|busy_scbid
op_ne
id|SCB_LIST_NULL
)paren
(brace
id|outb
c_func
(paren
id|busy_scbid
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|next_scbid
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_LINKED_NEXT
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|aic7xxx_match_scb
c_func
(paren
id|busy_scb
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
)paren
)paren
(brace
id|aic7xxx_index_busy_target
c_func
(paren
id|p
comma
id|i
comma
l_char|&squot;A&squot;
comma
multiline_comment|/*unbusy*/
id|TRUE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|next_scbid
op_ne
id|SCB_LIST_NULL
)paren
(brace
id|next_scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|next_scbid
)braket
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_match_scb
c_func
(paren
id|next_scb
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* Requeue for later processing */
id|scbq_insert_head
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|next_scb
)paren
suffix:semicolon
id|next_scb-&gt;flags
op_or_assign
id|SCB_WAITINGQ
suffix:semicolon
)brace
)brace
)brace
)brace
id|found
op_assign
id|aic7xxx_search_qinfifo
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
comma
id|SCB_ABORTED
op_or
id|SCB_QUEUED_FOR_DONE
comma
multiline_comment|/* requeue */
id|FALSE
)paren
suffix:semicolon
multiline_comment|/*&n;   * Search waiting for selection list.&n;   */
(brace
r_int
r_char
id|next
comma
id|prev
comma
id|scb_index
suffix:semicolon
id|next
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|WAITING_SCBH
)paren
suffix:semicolon
multiline_comment|/* Start at head of list. */
id|prev
op_assign
id|SCB_LIST_NULL
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ne
id|SCB_LIST_NULL
)paren
(brace
id|outb
c_func
(paren
id|next
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|scb_index
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_TAG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_index
op_ge
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;aic7xxx: Waiting List inconsistency; SCB index=%d, numscbs=%d&bslash;n&quot;
comma
id|scb_index
comma
id|p-&gt;scb_data-&gt;numscbs
)paren
suffix:semicolon
)brace
id|scbp
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_match_scb
c_func
(paren
id|scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
)paren
)paren
(brace
r_int
r_char
id|linked_next
suffix:semicolon
id|next
op_assign
id|aic7xxx_abort_waiting_scb
c_func
(paren
id|p
comma
id|scbp
comma
id|next
comma
id|prev
)paren
suffix:semicolon
id|linked_next
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_LINKED_NEXT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|linked_next
op_ne
id|SCB_LIST_NULL
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|next_scb
suffix:semicolon
multiline_comment|/*&n;           * Requeue the waiting SCB via the waiting list.&n;           */
id|next_scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|linked_next
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aic7xxx_match_scb
c_func
(paren
id|next_scb
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
)paren
)paren
(brace
id|scbq_insert_head
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|next_scb
)paren
suffix:semicolon
id|next_scb-&gt;flags
op_or_assign
id|SCB_WAITINGQ
suffix:semicolon
)brace
)brace
id|found
op_increment
suffix:semicolon
)brace
r_else
(brace
id|prev
op_assign
id|next
suffix:semicolon
id|next
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_NEXT
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;   * Go through disconnected list and remove any entries we have queued&n;   * for completion, zeroing their control byte too.&n;   */
(brace
r_int
r_char
id|next
comma
id|prev
comma
id|scb_index
suffix:semicolon
id|next
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|DISCONNECTED_SCBH
)paren
suffix:semicolon
id|prev
op_assign
id|SCB_LIST_NULL
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ne
id|SCB_LIST_NULL
)paren
(brace
id|outb
c_func
(paren
id|next
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|scb_index
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_TAG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_index
OG
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;aic7xxx: Disconnected List inconsistency, SCB index = %d, &quot;
l_string|&quot;num scbs = %d.&bslash;n&quot;
comma
id|scb_index
comma
id|p-&gt;scb_data-&gt;numscbs
)paren
suffix:semicolon
)brace
id|scbp
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_match_scb
c_func
(paren
id|scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
)paren
)paren
(brace
id|next
op_assign
id|aic7xxx_rem_scb_from_disc_list
c_func
(paren
id|p
comma
id|next
)paren
suffix:semicolon
)brace
r_else
(brace
id|prev
op_assign
id|next
suffix:semicolon
id|next
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_NEXT
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;   * Go through the hardware SCB array looking for commands that&n;   * were active but not on any list.&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;scb_data-&gt;maxhscbs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|scbid
suffix:semicolon
id|outb
c_func
(paren
id|i
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|scbid
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_TAG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scbid
OL
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
id|scbp
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scbid
)braket
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_match_scb
c_func
(paren
id|scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
)paren
)paren
(brace
id|aic7xxx_add_curscb_to_free_list
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;   * Go through the entire SCB array now and look for commands for&n;   * for this target that are stillactive.  These are other (most likely&n;   * tagged) commands that were disconnected when the reset occurred.&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;scb_data-&gt;numscbs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scbp
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|scbp-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_ne
l_int|0
)paren
op_logical_and
id|aic7xxx_match_scb
c_func
(paren
id|scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
)paren
)paren
(brace
id|scbp-&gt;flags
op_or_assign
id|SCB_ABORTED
op_or
id|SCB_QUEUED_FOR_DONE
suffix:semicolon
id|scbp-&gt;flags
op_and_assign
op_complement
id|SCB_ACTIVE
suffix:semicolon
id|aic7xxx_error
c_func
(paren
id|scbp-&gt;cmd
)paren
op_assign
id|DID_RESET
suffix:semicolon
id|found
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scbp-&gt;flags
op_amp
id|SCB_WAITINGQ
)paren
op_ne
l_int|0
)paren
(brace
id|scbq_remove
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|scbp
)paren
suffix:semicolon
id|scbp-&gt;flags
op_and_assign
op_complement
id|SCB_WAITINGQ
suffix:semicolon
)brace
)brace
)brace
id|outb
c_func
(paren
id|active_scb
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
r_return
(paren
id|found
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_clear_intstat&n; *&n; * Description:&n; *   Clears the interrupt status.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_clear_intstat
id|aic7xxx_clear_intstat
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
multiline_comment|/* Clear any interrupt conditions this may have caused. */
id|outb
c_func
(paren
id|CLRSELDO
op_or
id|CLRSELDI
op_or
id|CLRSELINGO
comma
id|p-&gt;base
op_plus
id|CLRSINT0
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CLRSELTIMEO
op_or
id|CLRATNO
op_or
id|CLRSCSIRSTI
op_or
id|CLRBUSFREE
op_or
id|CLRSCSIPERR
op_or
id|CLRPHASECHG
op_or
id|CLRREQINIT
comma
id|p-&gt;base
op_plus
id|CLRSINT1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CLRSCSIINT
comma
id|p-&gt;base
op_plus
id|CLRINT
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_reset_current_bus&n; *&n; * Description:&n; *   Reset the current SCSI bus.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_reset_current_bus
id|aic7xxx_reset_current_bus
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_int
r_char
id|scsiseq
suffix:semicolon
multiline_comment|/* Disable reset interrupts. */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SIMODE1
)paren
op_amp
op_complement
id|ENSCSIRST
comma
id|p-&gt;base
op_plus
id|SIMODE1
)paren
suffix:semicolon
multiline_comment|/* Turn on the bus reset. */
id|scsiseq
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCSISEQ
)paren
suffix:semicolon
id|outb
c_func
(paren
id|scsiseq
op_or
id|SCSIRSTO
comma
id|p-&gt;base
op_plus
id|SCSISEQ
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* Turn off the bus reset. */
id|outb
c_func
(paren
id|scsiseq
op_amp
op_complement
id|SCSIRSTO
comma
id|p-&gt;base
op_plus
id|SCSISEQ
)paren
suffix:semicolon
id|aic7xxx_clear_intstat
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* Re-enable reset interrupts. */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SIMODE1
)paren
op_or
id|ENSCSIRST
comma
id|p-&gt;base
op_plus
id|SIMODE1
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_reset_channel&n; *&n; * Description:&n; *   Reset the channel.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_reset_channel
id|aic7xxx_reset_channel
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_char
id|channel
comma
r_int
id|initiate_reset
)paren
(brace
r_int
r_int
id|offset
comma
id|offset_max
suffix:semicolon
r_int
id|found
suffix:semicolon
r_int
r_char
id|sblkctl
suffix:semicolon
r_char
id|cur_channel
suffix:semicolon
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;   * Clean up all the state information for the pending transactions&n;   * on this bus.&n;   */
id|found
op_assign
id|aic7xxx_reset_device
c_func
(paren
id|p
comma
id|ALL_TARGETS
comma
id|channel
comma
id|ALL_LUNS
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
l_char|&squot;B&squot;
)paren
(brace
id|p-&gt;needsdtr
op_or_assign
(paren
id|p-&gt;needsdtr_copy
op_amp
l_int|0xFF00
)paren
suffix:semicolon
id|p-&gt;sdtr_pending
op_and_assign
l_int|0x00FF
suffix:semicolon
id|offset
op_assign
id|TARG_SCRATCH
op_plus
l_int|8
suffix:semicolon
id|offset_max
op_assign
id|TARG_SCRATCH
op_plus
l_int|16
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|p-&gt;bus_type
op_eq
id|AIC_WIDE
)paren
(brace
id|p-&gt;needsdtr
op_assign
id|p-&gt;needsdtr_copy
suffix:semicolon
id|p-&gt;needwdtr
op_assign
id|p-&gt;needwdtr_copy
suffix:semicolon
id|p-&gt;sdtr_pending
op_assign
l_int|0x0
suffix:semicolon
id|p-&gt;wdtr_pending
op_assign
l_int|0x0
suffix:semicolon
id|offset
op_assign
id|TARG_SCRATCH
suffix:semicolon
id|offset_max
op_assign
id|TARG_SCRATCH
op_plus
l_int|16
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Channel A */
id|p-&gt;needsdtr
op_or_assign
(paren
id|p-&gt;needsdtr_copy
op_amp
l_int|0x00FF
)paren
suffix:semicolon
id|p-&gt;sdtr_pending
op_and_assign
l_int|0xFF00
suffix:semicolon
id|offset
op_assign
id|TARG_SCRATCH
suffix:semicolon
id|offset_max
op_assign
id|TARG_SCRATCH
op_plus
l_int|8
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|offset
OL
id|offset_max
)paren
(brace
multiline_comment|/*&n;     * Revert to async/narrow transfers until we renegotiate.&n;     */
id|u_char
id|targ_scratch
suffix:semicolon
id|targ_scratch
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|offset
)paren
suffix:semicolon
id|targ_scratch
op_and_assign
id|SXFR
suffix:semicolon
id|outb
c_func
(paren
id|targ_scratch
comma
id|p-&gt;base
op_plus
id|offset
)paren
suffix:semicolon
id|offset
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;   * Reset the bus and unpause/restart the controller&n;   */
id|sblkctl
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SBLKCTL
)paren
suffix:semicolon
id|cur_channel
op_assign
(paren
id|sblkctl
op_amp
id|SELBUSB
)paren
ques
c_cond
l_char|&squot;B&squot;
suffix:colon
l_char|&squot;A&squot;
suffix:semicolon
r_if
c_cond
(paren
id|cur_channel
op_ne
id|channel
)paren
(brace
multiline_comment|/*&n;     * Case 1: Command for another bus is active&n;     */
macro_line|#ifdef AIC7XXX_DEBUG_ABORT
id|printk
c_func
(paren
l_string|&quot;scsi%d: Stealthily resetting channel %c&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;     * Stealthily reset the other bus without upsetting the current bus.&n;     */
id|outb
c_func
(paren
id|sblkctl
op_xor
id|SELBUSB
comma
id|p-&gt;base
op_plus
id|SBLKCTL
)paren
suffix:semicolon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SIMODE1
)paren
op_amp
op_complement
id|ENBUSFREE
comma
id|p-&gt;base
op_plus
id|SIMODE1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|initiate_reset
)paren
(brace
id|aic7xxx_reset_current_bus
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;       * Cause the mid-level SCSI code to delay any further &n;       * queueing by the bus settle time for us.&n;       */
id|p-&gt;host-&gt;last_reset
op_assign
(paren
id|jiffies
op_plus
(paren
id|AIC7XXX_RESET_DELAY
op_star
id|HZ
)paren
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SCSISEQ
)paren
suffix:semicolon
id|aic7xxx_clear_intstat
c_func
(paren
id|p
)paren
suffix:semicolon
id|outb
c_func
(paren
id|sblkctl
comma
id|p-&gt;base
op_plus
id|SBLKCTL
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/* unpause_always */
id|FALSE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;     * Case 2: A command from this bus is active or we&squot;re idle.&n;     */
macro_line|#ifdef AIC7XXX_DEBUG_ABORT
id|printk
c_func
(paren
l_string|&quot;scsi%d: Resetting current channel %c&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SIMODE1
)paren
op_amp
op_complement
id|ENBUSFREE
comma
id|p-&gt;base
op_plus
id|SIMODE1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|initiate_reset
)paren
(brace
id|aic7xxx_reset_current_bus
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;       * Cause the mid-level SCSI code to delay any further &n;       * queueing by the bus settle time for us.&n;       */
macro_line|#if 0
id|p-&gt;host-&gt;last_reset
op_assign
(paren
id|jiffies
op_plus
(paren
id|AIC7XXX_RESET_DELAY
op_star
id|HZ
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SCSISEQ
)paren
suffix:semicolon
id|aic7xxx_clear_intstat
c_func
(paren
id|p
)paren
suffix:semicolon
id|restart_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
macro_line|#ifdef AIC7XXX_DEBUG_ABORT
id|printk
c_func
(paren
l_string|&quot;scsi%d: Channel reset, sequencer restarted&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;   * Now loop through all the SCBs that have been marked for abortion,&n;   * and call the scsi_done routines.&n;   */
id|aic7xxx_run_done_queue
c_func
(paren
id|p
comma
multiline_comment|/*complete*/
id|TRUE
)paren
suffix:semicolon
r_return
(paren
id|found
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_run_waiting_queues&n; *&n; * Description:&n; *   Scan the awaiting_scbs queue downloading and starting as many&n; *   scbs as we can.&n; *-F*************************************************************************/
r_static
r_inline
r_void
DECL|function|aic7xxx_run_waiting_queues
id|aic7xxx_run_waiting_queues
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scb
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;waiting_scbs.head
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;   * First handle SCBs that are waiting but have been assigned a slot.&n;   */
id|scb
op_assign
id|p-&gt;waiting_scbs.head
suffix:semicolon
r_while
c_loop
(paren
id|scb
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;curqincnt
op_ge
id|p-&gt;qfullcount
)paren
(brace
id|p-&gt;curqincnt
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|QINCNT
)paren
op_amp
id|p-&gt;qcntmask
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;curqincnt
op_ge
id|p-&gt;qfullcount
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * We have some space.&n;     */
id|scbq_remove_head
c_func
(paren
op_amp
(paren
id|p-&gt;waiting_scbs
)paren
)paren
suffix:semicolon
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_WAITINGQ
suffix:semicolon
id|outb
c_func
(paren
id|scb-&gt;hscb-&gt;tag
comma
id|p-&gt;base
op_plus
id|QINFIFO
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|PAGE_ENABLED
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;       * We only care about this statistic when paging&n;       * since it&squot;s impossible to overflow the qinfifo&n;       * in the non-paging case.&n;       */
id|p-&gt;curqincnt
op_increment
suffix:semicolon
)brace
id|scb
op_assign
id|p-&gt;waiting_scbs.head
suffix:semicolon
)brace
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_construct_sdtr&n; *&n; * Description:&n; *   Constucts a synchronous data transfer message in the message&n; *   buffer on the sequencer.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_construct_sdtr
id|aic7xxx_construct_sdtr
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|start_byte
comma
r_int
r_char
id|period
comma
r_int
r_char
id|offset
)paren
(brace
id|outb
c_func
(paren
id|MSG_EXTENDED
comma
id|p-&gt;base
op_plus
id|MSG_OUT
op_plus
id|start_byte
)paren
suffix:semicolon
id|outb
c_func
(paren
id|MSG_EXT_SDTR_LEN
comma
id|p-&gt;base
op_plus
id|MSG_OUT
op_plus
l_int|1
op_plus
id|start_byte
)paren
suffix:semicolon
id|outb
c_func
(paren
id|MSG_EXT_SDTR
comma
id|p-&gt;base
op_plus
id|MSG_OUT
op_plus
l_int|2
op_plus
id|start_byte
)paren
suffix:semicolon
id|outb
c_func
(paren
id|period
comma
id|p-&gt;base
op_plus
id|MSG_OUT
op_plus
l_int|3
op_plus
id|start_byte
)paren
suffix:semicolon
id|outb
c_func
(paren
id|offset
comma
id|p-&gt;base
op_plus
id|MSG_OUT
op_plus
l_int|4
op_plus
id|start_byte
)paren
suffix:semicolon
id|outb
c_func
(paren
id|start_byte
op_plus
l_int|5
comma
id|p-&gt;base
op_plus
id|MSG_LEN
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_construct_wdtr&n; *&n; * Description:&n; *   Constucts a wide data transfer message in the message buffer&n; *   on the sequencer.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_construct_wdtr
id|aic7xxx_construct_wdtr
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|start_byte
comma
r_int
r_char
id|bus_width
)paren
(brace
id|outb
c_func
(paren
id|MSG_EXTENDED
comma
id|p-&gt;base
op_plus
id|MSG_OUT
op_plus
id|start_byte
)paren
suffix:semicolon
id|outb
c_func
(paren
id|MSG_EXT_WDTR_LEN
comma
id|p-&gt;base
op_plus
id|MSG_OUT
op_plus
l_int|1
op_plus
id|start_byte
)paren
suffix:semicolon
id|outb
c_func
(paren
id|MSG_EXT_WDTR
comma
id|p-&gt;base
op_plus
id|MSG_OUT
op_plus
l_int|2
op_plus
id|start_byte
)paren
suffix:semicolon
id|outb
c_func
(paren
id|bus_width
comma
id|p-&gt;base
op_plus
id|MSG_OUT
op_plus
l_int|3
op_plus
id|start_byte
)paren
suffix:semicolon
id|outb
c_func
(paren
id|start_byte
op_plus
l_int|4
comma
id|p-&gt;base
op_plus
id|MSG_LEN
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_calc_residual&n; *&n; * Description:&n; *   Calculate the residual data not yet transferred.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_calculate_residual
id|aic7xxx_calculate_residual
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
r_struct
id|aic7xxx_hwscb
op_star
id|hscb
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_int
id|actual
suffix:semicolon
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
multiline_comment|/*&n;   *  Don&squot;t destroy valid residual information with&n;   *  residual coming from a check sense operation.&n;   */
r_if
c_cond
(paren
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|DISCONNECTED
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|scb-&gt;flags
op_amp
id|SCB_SENSE
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;     *  We had an underflow. At this time, there&squot;s only&n;     *  one other driver that bothers to check for this,&n;     *  and cmd-&gt;underflow seems to be set rather half-&n;     *  heartedly in the higher-level SCSI code.&n;     */
id|actual
op_assign
id|aic7xxx_length
c_func
(paren
id|cmd
comma
id|hscb-&gt;residual_SG_segment_count
)paren
suffix:semicolon
id|actual
op_sub_assign
(paren
id|hscb-&gt;residual_data_count
(braket
l_int|2
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|hscb-&gt;residual_data_count
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_or
id|hscb-&gt;residual_data_count
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|actual
OL
id|cmd-&gt;underflow
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d) Underflow - &quot;
l_string|&quot;Wanted at least %u, got %u, residual SG count %d.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|cmd-&gt;underflow
comma
id|actual
comma
id|hscb-&gt;residual_SG_segment_count
)paren
suffix:semicolon
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_assign
id|DID_RETRY_COMMAND
suffix:semicolon
id|aic7xxx_status
c_func
(paren
id|cmd
)paren
op_assign
id|hscb-&gt;target_status
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Clean out the residual information in the SCB for the&n;   * next consumer.&n;   */
id|hscb-&gt;residual_data_count
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;residual_data_count
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;residual_data_count
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;residual_SG_segment_count
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_handle_device_reset&n; *&n; * Description:&n; *   Interrupt handler for sequencer interrupts (SEQINT).&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_handle_device_reset
id|aic7xxx_handle_device_reset
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|target
comma
r_char
id|channel
)paren
(brace
r_int
r_int
id|targ_mask
suffix:semicolon
r_int
r_char
id|targ_scratch
suffix:semicolon
r_int
id|scratch_offset
op_assign
id|target
suffix:semicolon
r_int
id|found
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
l_char|&squot;B&squot;
)paren
(brace
id|scratch_offset
op_add_assign
l_int|8
suffix:semicolon
)brace
id|targ_mask
op_assign
(paren
l_int|0x01
op_lshift
id|scratch_offset
)paren
suffix:semicolon
multiline_comment|/*&n;   * Go back to async/narrow transfers and renegotiate.&n;   */
id|p-&gt;needsdtr
op_or_assign
id|p-&gt;needsdtr_copy
op_amp
id|targ_mask
suffix:semicolon
id|p-&gt;needwdtr
op_or_assign
id|p-&gt;needwdtr_copy
op_amp
id|targ_mask
suffix:semicolon
id|p-&gt;sdtr_pending
op_and_assign
op_complement
id|targ_mask
suffix:semicolon
id|p-&gt;wdtr_pending
op_and_assign
op_complement
id|targ_mask
suffix:semicolon
id|targ_scratch
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|TARG_SCRATCH
op_plus
id|scratch_offset
)paren
suffix:semicolon
id|targ_scratch
op_and_assign
id|SXFR
suffix:semicolon
id|outb
c_func
(paren
id|targ_scratch
comma
id|p-&gt;base
op_plus
id|TARG_SCRATCH
op_plus
id|scratch_offset
)paren
suffix:semicolon
id|found
op_assign
id|aic7xxx_reset_device
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|ALL_LUNS
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d) Bus Device Reset delivered, &quot;
l_string|&quot;%d SCBs aborted.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|target
comma
id|CHAN_TO_INT
c_func
(paren
id|channel
)paren
comma
id|found
)paren
suffix:semicolon
id|aic7xxx_run_done_queue
c_func
(paren
id|p
comma
multiline_comment|/*complete*/
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_handle_seqint&n; *&n; * Description:&n; *   Interrupt handler for sequencer interrupts (SEQINT).&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_handle_seqint
id|aic7xxx_handle_seqint
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
id|intstat
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scb
suffix:semicolon
r_int
r_int
id|target_mask
suffix:semicolon
r_int
r_char
id|target
comma
id|scratch_offset
suffix:semicolon
r_char
id|channel
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQ_FLAGS
)paren
op_amp
id|RESELECTED
)paren
op_ne
l_int|0
)paren
(brace
id|target
op_assign
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SELID
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0x0F
suffix:semicolon
)brace
r_else
(brace
id|target
op_assign
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCSIID
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0x0F
suffix:semicolon
)brace
id|scratch_offset
op_assign
id|target
suffix:semicolon
id|channel
op_assign
l_char|&squot;A&squot;
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SBLKCTL
)paren
op_amp
id|SELBUSB
)paren
(brace
id|channel
op_assign
l_char|&squot;B&squot;
suffix:semicolon
id|scratch_offset
op_add_assign
l_int|8
suffix:semicolon
)brace
id|target_mask
op_assign
(paren
l_int|0x01
op_lshift
id|scratch_offset
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|intstat
op_amp
id|SEQINT_MASK
)paren
(brace
r_case
id|NO_MATCH
suffix:colon
(brace
multiline_comment|/*&n;         * This could be for a normal abort request.  Figure out&n;         * which SCB we were trying to find and only give an error&n;         * if we didn&squot;t ask for this to happen.&n;         */
r_int
r_char
id|scb_index
suffix:semicolon
r_int
r_char
id|busy_scbid
suffix:semicolon
r_int
r_char
id|arg1
suffix:semicolon
id|busy_scbid
op_assign
id|aic7xxx_index_busy_target
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
multiline_comment|/*unbusy*/
id|FALSE
)paren
suffix:semicolon
id|arg1
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|ARG_1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg1
op_eq
id|SCB_LIST_NULL
)paren
(brace
multiline_comment|/* untagged request */
id|scb_index
op_assign
id|busy_scbid
suffix:semicolon
)brace
r_else
(brace
id|scb_index
op_assign
id|arg1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb_index
OL
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|ABORT_SCB
)paren
(brace
multiline_comment|/*&n;             * We expected this.  Let the busfree handler take care&n;             * of this when we the abort is finially sent.  Set&n;             * IDENTIFY_SEEN so that the busfree handler knows that&n;             * there is an SCB to cleanup.&n;             */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQ_FLAGS
)paren
op_or
id|IDENTIFY_SEEN
comma
id|p-&gt;base
op_plus
id|SEQ_FLAGS
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d:%d:%d) reconnect SCB abort successful&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d) No active SCB for reconnecting &quot;
l_string|&quot;target - Issuing BUS DEVICE RESET.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|target
comma
id|CHAN_TO_INT
c_func
(paren
id|channel
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;      SAVED_TCL=0x%x, ARG_1=0x%x, SEQADDR=0x%x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SAVED_TCL
)paren
comma
id|arg1
comma
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQADDR1
)paren
op_lshift
l_int|8
)paren
op_or
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQADDR0
)paren
)paren
suffix:semicolon
id|aic7xxx_handle_device_reset
c_func
(paren
id|p
comma
id|target
comma
id|channel
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|NO_MATCH_BUSY
suffix:colon
(brace
multiline_comment|/*&n;         * XXX - Leave this as a panic for the time being since it&n;         * indicates a bug in the timeout code for this to happen.&n;         */
r_int
r_char
id|scb_index
suffix:semicolon
id|scb_index
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|CUR_SCBID
)paren
suffix:semicolon
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;scsi%d:  Target %d, channel %c, Target busy link failure, &quot;
l_string|&quot;but busy SCB exists!&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|target
comma
id|channel
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SEND_REJECT
suffix:colon
(brace
r_int
r_char
id|rej_byte
suffix:semicolon
id|rej_byte
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|REJBYTE
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d) Rejecting unknown message (0x%x) &quot;
l_string|&quot;received from target, SEQ_FLAGS=0x%x&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|target
comma
id|CHAN_TO_INT
c_func
(paren
id|channel
)paren
comma
id|rej_byte
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQ_FLAGS
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|NO_IDENT
suffix:colon
(brace
multiline_comment|/*&n;         * The reconnecting target either did not send an identify&n;         * message, or did, but we didn&squot;t find and SCB to match and&n;         * before it could respond to our ATN/abort, it hit a dataphase.&n;         * The only safe thing to do is to blow it away with a bus&n;         * reset.&n;         */
r_int
id|found
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d): Target did not send an IDENTIFY &quot;
l_string|&quot;message; LASTPHASE 0x%x, SAVED_TCL 0x%x&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|target
comma
id|CHAN_TO_INT
c_func
(paren
id|channel
)paren
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|LASTPHASE
)paren
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SAVED_TCL
)paren
)paren
suffix:semicolon
id|found
op_assign
id|aic7xxx_reset_channel
c_func
(paren
id|p
comma
id|channel
comma
multiline_comment|/*initiate reset*/
id|TRUE
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: Issued channel %c bus reset; &quot;
l_string|&quot;%d SCBs aborted&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|found
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BAD_PHASE
suffix:colon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|LASTPHASE
)paren
op_eq
id|P_BUSFREE
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d): Missed busfree.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CHAN_TO_INT
c_func
(paren
id|channel
)paren
comma
id|target
)paren
suffix:semicolon
id|restart_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d): Unknown scsi bus phase, attempting &quot;
l_string|&quot;to continue&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CHAN_TO_INT
c_func
(paren
id|channel
)paren
comma
id|target
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EXTENDED_MSG
suffix:colon
(brace
r_int
r_char
id|message_length
suffix:semicolon
r_int
r_char
id|message_code
suffix:semicolon
r_int
r_char
id|scb_index
suffix:semicolon
id|message_length
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|MSGIN_EXT_LEN
)paren
suffix:semicolon
id|message_code
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|MSGIN_EXT_OPCODE
)paren
suffix:semicolon
id|scb_index
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_TAG
)paren
suffix:semicolon
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|message_code
)paren
(brace
r_case
id|MSG_EXT_SDTR
suffix:colon
(brace
r_int
r_char
id|period
suffix:semicolon
r_int
r_char
id|offset
suffix:semicolon
r_int
r_char
id|saved_offset
suffix:semicolon
r_int
r_char
id|targ_scratch
suffix:semicolon
r_int
r_char
id|max_offset
suffix:semicolon
r_int
r_char
id|rate
suffix:semicolon
r_if
c_cond
(paren
id|message_length
op_ne
id|MSG_EXT_SDTR_LEN
)paren
(brace
id|outb
c_func
(paren
id|SEND_REJ
comma
id|p-&gt;base
op_plus
id|RETURN_1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|period
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|MSGIN_EXT_BYTES
)paren
suffix:semicolon
id|saved_offset
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|MSGIN_EXT_BYTES
op_plus
l_int|1
)paren
suffix:semicolon
id|targ_scratch
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|TARG_SCRATCH
op_plus
id|scratch_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|targ_scratch
op_amp
id|WIDEXFER
)paren
id|max_offset
op_assign
id|MAX_OFFSET_16BIT
suffix:semicolon
r_else
id|max_offset
op_assign
id|MAX_OFFSET_8BIT
suffix:semicolon
id|offset
op_assign
id|MIN
c_func
(paren
id|saved_offset
comma
id|max_offset
)paren
suffix:semicolon
id|aic7xxx_scsirate
c_func
(paren
id|p
comma
op_amp
id|rate
comma
op_amp
id|period
comma
op_amp
id|offset
comma
id|target
comma
id|channel
)paren
suffix:semicolon
multiline_comment|/*&n;             * Preserve the WideXfer flag.&n;             */
id|targ_scratch
op_assign
id|rate
op_or
(paren
id|targ_scratch
op_amp
id|WIDEXFER
)paren
suffix:semicolon
multiline_comment|/*&n;             * Update both the target scratch area and current SCSIRATE.&n;             */
id|outb
c_func
(paren
id|targ_scratch
comma
id|p-&gt;base
op_plus
id|TARG_SCRATCH
op_plus
id|scratch_offset
)paren
suffix:semicolon
id|outb
c_func
(paren
id|targ_scratch
comma
id|p-&gt;base
op_plus
id|SCSIRATE
)paren
suffix:semicolon
multiline_comment|/*&n;             * See if we initiated Sync Negotiation and didn&squot;t have&n;             * have to fall down to async transfers.&n;             */
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_SDTR
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* We started it. */
r_if
c_cond
(paren
id|saved_offset
op_eq
id|offset
)paren
(brace
multiline_comment|/*&n;        &t; * Don&squot;t send an SDTR back to the target.&n;        &t; */
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|RETURN_1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We went too low - force async. */
id|outb
c_func
(paren
id|SEND_REJ
comma
id|p-&gt;base
op_plus
id|RETURN_1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;               * Send our own SDTR in reply.&n;               *&n;               * We want to see this message as we don&squot;t expect a target&n;               * to send us a SDTR request first.&n;               */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: Sending SDTR!!&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
id|aic7xxx_construct_sdtr
c_func
(paren
id|p
comma
multiline_comment|/* start byte */
l_int|0
comma
id|period
comma
id|offset
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SEND_MSG
comma
id|p-&gt;base
op_plus
id|RETURN_1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;             * Clear the flags.&n;             */
id|p-&gt;needsdtr
op_and_assign
op_complement
id|target_mask
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MSG_EXT_WDTR
suffix:colon
(brace
r_int
r_char
id|scratch
comma
id|bus_width
suffix:semicolon
r_if
c_cond
(paren
id|message_length
op_ne
id|MSG_EXT_WDTR_LEN
)paren
(brace
id|outb
c_func
(paren
id|SEND_REJ
comma
id|p-&gt;base
op_plus
id|RETURN_1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bus_width
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|MSGIN_EXT_BYTES
)paren
suffix:semicolon
id|scratch
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|TARG_SCRATCH
op_plus
id|scratch_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_WDTR
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;               * Don&squot;t send an WDTR back to the target, since we asked first.&n;               */
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|RETURN_1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bus_width
)paren
(brace
r_case
id|BUS_8_BIT
suffix:colon
id|scratch
op_and_assign
l_int|0x7F
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BUS_16_BIT
suffix:colon
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi%d: Target %d, channel %c, using 16 &quot;
l_string|&quot;bit transfers.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|target
comma
id|channel
)paren
suffix:semicolon
)brace
id|scratch
op_or_assign
id|WIDEXFER
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BUS_32_BIT
suffix:colon
id|outb
c_func
(paren
id|SEND_REJ
comma
id|p-&gt;base
op_plus
id|RETURN_1
)paren
suffix:semicolon
multiline_comment|/* No verbose here!  We want to see this condition. */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: Target %d, channel %c, &quot;
l_string|&quot;requesting 32 bit transfers, rejecting...&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|target
comma
id|channel
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;               * Send our own WDTR in reply.&n;               */
r_switch
c_cond
(paren
id|bus_width
)paren
(brace
r_case
id|BUS_8_BIT
suffix:colon
id|scratch
op_and_assign
l_int|0x7F
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BUS_32_BIT
suffix:colon
r_case
id|BUS_16_BIT
suffix:colon
r_if
c_cond
(paren
id|p-&gt;bus_type
op_eq
id|AIC_WIDE
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi%d: Target %d, channel %c, using 16 &quot;
l_string|&quot;bit transfers.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|target
comma
id|channel
)paren
suffix:semicolon
id|bus_width
op_assign
id|BUS_16_BIT
suffix:semicolon
id|scratch
op_or_assign
id|WIDEXFER
suffix:semicolon
)brace
r_else
(brace
id|bus_width
op_assign
id|BUS_8_BIT
suffix:semicolon
id|scratch
op_and_assign
l_int|0x7F
suffix:semicolon
multiline_comment|/* XXX - FreeBSD doesn&squot;t do this. */
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|aic7xxx_construct_wdtr
c_func
(paren
id|p
comma
multiline_comment|/* start byte */
l_int|0
comma
id|bus_width
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SEND_MSG
comma
id|p-&gt;base
op_plus
id|RETURN_1
)paren
suffix:semicolon
)brace
id|p-&gt;needwdtr
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|outb
c_func
(paren
id|scratch
comma
id|p-&gt;base
op_plus
id|TARG_SCRATCH
op_plus
id|scratch_offset
)paren
suffix:semicolon
id|outb
c_func
(paren
id|scratch
comma
id|p-&gt;base
op_plus
id|SCSIRATE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* case MSG_EXT_WDTR */
r_default
suffix:colon
multiline_comment|/*&n;             * Unknown extended message - reject it.&n;             */
id|outb
c_func
(paren
id|SEND_REJ
comma
id|p-&gt;base
op_plus
id|RETURN_1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* switch (message_code) */
)brace
multiline_comment|/* case EXTENDED_MSG */
r_break
suffix:semicolon
r_case
id|REJECT_MSG
suffix:colon
(brace
multiline_comment|/*&n;&t; * What we care about here is if we had an outstanding SDTR&n;&t; * or WDTR message for this target. If we did, this is a&n;&t; * signal that the target is refusing negotiation.&n;&t; */
r_int
r_char
id|targ_scratch
suffix:semicolon
r_int
r_char
id|scb_index
suffix:semicolon
id|scb_index
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_TAG
)paren
suffix:semicolon
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
id|targ_scratch
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|TARG_SCRATCH
op_plus
id|scratch_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_WDTR
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;           * note 8bit xfers and clear flag&n;           */
id|targ_scratch
op_and_assign
l_int|0x7F
suffix:semicolon
id|p-&gt;needwdtr
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: Target %d, channel %c, refusing WIDE &quot;
l_string|&quot;negotiation; using 8 bit transfers.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|target
comma
id|channel
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_SDTR
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;             * note asynch xfers and clear flag&n;             */
id|targ_scratch
op_and_assign
l_int|0xF0
suffix:semicolon
id|p-&gt;needsdtr
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: Target %d, channel %c, refusing &quot;
l_string|&quot;synchronous negotiation; using asynchronous transfers.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|target
comma
id|channel
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;           * Otherwise, we ignore it.&n;           */
)brace
id|outb
c_func
(paren
id|targ_scratch
comma
id|p-&gt;base
op_plus
id|TARG_SCRATCH
op_plus
id|scratch_offset
)paren
suffix:semicolon
id|outb
c_func
(paren
id|targ_scratch
comma
id|p-&gt;base
op_plus
id|SCSIRATE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BAD_STATUS
suffix:colon
(brace
r_int
r_char
id|scb_index
suffix:semicolon
r_struct
id|aic7xxx_hwscb
op_star
id|hscb
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
multiline_comment|/* The sequencer will notify us when a command has an error that&n;&t; * would be of interest to the kernel.  This allows us to leave&n;&t; * the sequencer running in the common case of command completes&n;&t; * without error.  The sequencer will have DMA&squot;d the SCB back&n;&t; * up to us, so we can reference the drivers SCB array.&n;&t; */
id|scb_index
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_TAG
)paren
suffix:semicolon
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
multiline_comment|/*&n;&t; * Set the default return value to 0 indicating not to send&n;&t; * sense.  The sense code will change this if needed and this&n;&t; * reduces code duplication.&n;&t; */
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|RETURN_1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_logical_or
(paren
id|scb-&gt;cmd
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: Referenced SCB not valid during &quot;
l_string|&quot;SEQINT 0x%x, scb %d, flags 0x%x, cmd 0x%x.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|intstat
comma
id|scb_index
comma
id|scb-&gt;flags
comma
(paren
r_int
r_int
)paren
id|scb-&gt;cmd
)paren
suffix:semicolon
)brace
r_else
(brace
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
id|hscb-&gt;target_status
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_TARGET_STATUS
)paren
suffix:semicolon
id|aic7xxx_status
c_func
(paren
id|cmd
)paren
op_assign
id|hscb-&gt;target_status
suffix:semicolon
id|cmd-&gt;result
op_or_assign
id|hscb-&gt;target_status
suffix:semicolon
r_switch
c_cond
(paren
id|status_byte
c_func
(paren
id|hscb-&gt;target_status
)paren
)paren
(brace
r_case
id|GOOD
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d) Interrupted for status of &quot;
l_string|&quot;GOOD???&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CHECK_CONDITION
suffix:colon
r_if
c_cond
(paren
(paren
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_eq
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
id|scb-&gt;flags
op_amp
id|SCB_SENSE
)paren
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
multiline_comment|/* must be 32 bits */
multiline_comment|/*&n;        &t; * XXX - How do we save the residual (if there is one).&n;        &t; */
id|aic7xxx_calculate_residual
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
multiline_comment|/*&n;  &t;&t; * Send a sense command to the requesting target.&n;        &t; * XXX - revisit this and get rid of the memcopys.&n;  &t;&t; */
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|scb-&gt;sense_cmd
comma
(paren
r_void
op_star
)paren
id|generic_sense
comma
r_sizeof
(paren
id|generic_sense
)paren
)paren
suffix:semicolon
id|scb-&gt;sense_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|cmd-&gt;lun
op_lshift
l_int|5
)paren
suffix:semicolon
id|scb-&gt;sense_cmd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|address
op_assign
id|VIRT_TO_BUS
c_func
(paren
op_amp
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|length
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
id|cmd-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;                 * XXX - We should allow disconnection, but can&squot;t as it&n;                 * might allow overlapped tagged commands.&n;                 */
multiline_comment|/* hscb-&gt;control &amp;= DISCENB; */
id|hscb-&gt;control
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;target_status
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;SG_segment_count
op_assign
l_int|1
suffix:semicolon
id|addr
op_assign
id|VIRT_TO_BUS
c_func
(paren
op_amp
id|scb-&gt;sg_list
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|hscb-&gt;SG_list_pointer
comma
op_amp
id|addr
comma
r_sizeof
(paren
id|hscb-&gt;SG_list_pointer
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|hscb-&gt;data_pointer
comma
op_amp
(paren
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|address
)paren
comma
r_sizeof
(paren
id|hscb-&gt;data_pointer
)paren
)paren
suffix:semicolon
multiline_comment|/* Maintain SCB_LINKED_NEXT */
id|hscb-&gt;data_count
op_and_assign
l_int|0xFF000000
suffix:semicolon
id|hscb-&gt;data_count
op_or_assign
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|length
suffix:semicolon
id|addr
op_assign
id|VIRT_TO_BUS
c_func
(paren
id|scb-&gt;sense_cmd
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|hscb-&gt;SCSI_cmd_pointer
comma
op_amp
id|addr
comma
r_sizeof
(paren
id|hscb-&gt;SCSI_cmd_pointer
)paren
)paren
suffix:semicolon
id|hscb-&gt;SCSI_cmd_length
op_assign
id|COMMAND_SIZE
c_func
(paren
id|scb-&gt;sense_cmd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|scb-&gt;sg_count
op_assign
id|hscb-&gt;SG_segment_count
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_SENSE
suffix:semicolon
multiline_comment|/*&n;                 * Ensure the target is busy since this will be an&n;                 * an untagged request.&n;                 */
id|aic7xxx_busy_target
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|hscb-&gt;tag
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SEND_SENSE
comma
id|p-&gt;base
op_plus
id|RETURN_1
)paren
suffix:semicolon
)brace
multiline_comment|/* first time sense, no errors */
r_else
(brace
r_if
c_cond
(paren
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_eq
l_int|0
)paren
(brace
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_assign
id|DID_RETRY_COMMAND
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|QUEUE_FULL
suffix:colon
macro_line|#ifdef NOT_YET
r_if
c_cond
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|TAG_ENB
)paren
(brace
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;queue_depth
OG
l_int|2
)paren
(brace
id|cmd-&gt;device-&gt;queue_depth
op_decrement
suffix:semicolon
multiline_comment|/* Not correct */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d) Tagged queue depth &quot;
l_string|&quot;reduced to %d&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|cmd-&gt;device-&gt;queue_depth
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;        &t; * XXX - Requeue this unconditionally?&n;        &t; */
multiline_comment|/*&n;        &t; * We&squot;d like to be able to give the SCB some more time&n;        &t; * (untimeout, then timeout).&n;        &t; */
r_break
suffix:semicolon
)brace
macro_line|#endif
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d) Queue full received; &quot;
l_string|&quot;queue depth %d, active %d&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|cmd-&gt;device-&gt;queue_depth
comma
id|p-&gt;device_status
(braket
id|TARGET_INDEX
c_func
(paren
id|cmd
)paren
)braket
dot
id|active_cmds
)paren
suffix:semicolon
multiline_comment|/* Else treat this as if it was a BUSY condition. */
id|scb-&gt;hscb-&gt;target_status
op_assign
(paren
id|BUSY
op_lshift
l_int|1
)paren
op_or
(paren
id|scb-&gt;hscb-&gt;target_status
op_amp
l_int|0x01
)paren
suffix:semicolon
multiline_comment|/* Fall through to the BUSY case. */
r_case
id|BUSY
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d) Target busy&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
)paren
(brace
multiline_comment|/*&n;        &t; * The mid-level SCSI code should be fixed to&n;        &t; * retry the command at a later time instead of&n;        &t; * trying right away.&n;        &t; */
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_assign
id|DID_BUS_BUSY
op_or
(paren
id|SUGGEST_RETRY
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/*  A small pause (1ms) to help the drive */
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d) Unexpected target &quot;
l_string|&quot;status 0x%x.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;hscb-&gt;target_status
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
)paren
(brace
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_assign
id|DID_RETRY_COMMAND
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* end switch */
)brace
multiline_comment|/* end else of */
)brace
r_break
suffix:semicolon
r_case
id|AWAITING_MSG
suffix:colon
(brace
r_int
r_char
id|scb_index
suffix:semicolon
r_int
r_char
id|message_offset
suffix:semicolon
id|scb_index
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_TAG
)paren
suffix:semicolon
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * This SCB had a MK_MESSAGE set in its control byte informing&n;&t; * the sequencer that we wanted to send a special message to&n;&t; * this target.&n;&t; */
id|message_offset
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|MSG_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_DEVICE_RESET
)paren
(brace
id|outb
c_func
(paren
id|MSG_BUS_DEV_RESET
comma
id|p-&gt;base
op_plus
id|MSG_OUT
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|p-&gt;base
op_plus
id|MSG_LEN
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d:%d:%d) Bus device reset sent&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_ABORT
)paren
(brace
r_if
c_cond
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|TAG_ENB
)paren
op_ne
l_int|0
)paren
(brace
id|outb
c_func
(paren
id|MSG_ABORT_TAG
comma
id|p-&gt;base
op_plus
id|MSG_OUT
op_plus
id|message_offset
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
id|MSG_ABORT
comma
id|p-&gt;base
op_plus
id|MSG_OUT
op_plus
id|message_offset
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|message_offset
op_plus
l_int|1
comma
id|p-&gt;base
op_plus
id|MSG_LEN
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d): Abort message sent.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_WDTR
)paren
(brace
id|aic7xxx_construct_wdtr
c_func
(paren
id|p
comma
id|message_offset
comma
id|BUS_16_BIT
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_SDTR
)paren
(brace
r_int
r_char
id|target_scratch
suffix:semicolon
r_int
r_int
id|ultra_enable
suffix:semicolon
r_int
id|i
comma
id|sxfr
suffix:semicolon
multiline_comment|/*&n;           * Pull the user defined setting from scratch RAM.&n;           */
id|target_scratch
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|TARG_SCRATCH
op_plus
id|scratch_offset
)paren
suffix:semicolon
id|sxfr
op_assign
id|target_scratch
op_amp
id|SXFR
suffix:semicolon
id|ultra_enable
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|ULTRA_ENB
)paren
op_or
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|ULTRA_ENB
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ultra_enable
op_amp
id|target_mask
)paren
(brace
id|sxfr
op_or_assign
l_int|0x100
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_aic7xxx_syncrates
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sxfr
op_eq
id|aic7xxx_syncrates
(braket
id|i
)braket
dot
id|rate
)paren
r_break
suffix:semicolon
)brace
id|aic7xxx_construct_sdtr
c_func
(paren
id|p
comma
id|message_offset
comma
id|aic7xxx_syncrates
(braket
id|i
)braket
dot
id|period
comma
id|target_scratch
op_amp
id|WIDEXFER
ques
c_cond
id|MAX_OFFSET_16BIT
suffix:colon
id|MAX_OFFSET_8BIT
)paren
suffix:semicolon
)brace
r_else
(brace
id|panic
c_func
(paren
l_string|&quot;aic7xxx: AWAITING_MSG for an SCB that does &quot;
l_string|&quot;not have a waiting message.&quot;
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|DATA_OVERRUN
suffix:colon
(brace
r_int
r_char
id|scb_index
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_TAG
)paren
suffix:semicolon
r_int
r_char
id|lastphase
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|LASTPHASE
)paren
suffix:semicolon
r_int
r_int
id|i
comma
id|overrun
suffix:semicolon
id|scb
op_assign
(paren
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
)paren
suffix:semicolon
id|overrun
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|STCNT
)paren
op_or
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|STCNT
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|STCNT
op_plus
l_int|2
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|overrun
op_assign
l_int|0x00FFFFFF
op_minus
id|overrun
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d) Data overrun of %d bytes detected &quot;
l_string|&quot;in %s phase, tag %d; forcing a retry.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|overrun
comma
id|lastphase
op_eq
id|P_DATAIN
ques
c_cond
l_string|&quot;Data-In&quot;
suffix:colon
l_string|&quot;Data-Out&quot;
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s seen Data Phase.  Length = %d, NumSGs = %d.&bslash;n&quot;
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQ_FLAGS
)paren
op_amp
id|DPHASE
ques
c_cond
l_string|&quot;Have&quot;
suffix:colon
l_string|&quot;Haven&squot;t&quot;
comma
id|aic7xxx_length
c_func
(paren
id|scb-&gt;cmd
comma
l_int|0
)paren
comma
id|scb-&gt;sg_count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|scb-&gt;sg_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;     sg[%d] - Addr 0x%x : Length %d&bslash;n&quot;
comma
id|i
comma
id|scb-&gt;sg_list
(braket
id|i
)braket
dot
id|address
comma
id|scb-&gt;sg_list
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * XXX - What do we really want to do on an overrun?  The&n;&t; *       mid-level SCSI code should handle this, but for now,&n;&t; *       we&squot;ll just indicate that the command should retried.&n;&t; */
id|aic7xxx_error
c_func
(paren
id|scb-&gt;cmd
)paren
op_assign
id|DID_RETRY_COMMAND
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* #if AIC7XXX_NOT_YET */
multiline_comment|/* XXX Fill these in later */
r_case
id|MSG_BUFFER_BUSY
suffix:colon
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Message buffer busy.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MSGIN_PHASEMIS
suffix:colon
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Message-in phasemis.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*#endif */
r_case
id|ABORT_CMDCMPLT
suffix:colon
multiline_comment|/* This interrupt serves to pause the sequencer until we can clean&n;       * up the QOUTFIFO allowing us to handle any abort SCBs that may&n;       * completed yet still have an SCB in the QINFIFO or waiting for&n;       * selection queue.  By the time we get here, we should have&n;       * already cleaned up the queues, so all we need to do is unpause&n;       * the sequencer.&n;       */
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* unknown */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: SEQINT, INTSTAT 0x%x, SCSISIGI 0x%x.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|intstat
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCSISIGI
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;   * Clear the sequencer interrupt and unpause the sequencer.&n;   */
id|outb
c_func
(paren
id|CLRSEQINT
comma
id|p-&gt;base
op_plus
id|CLRINT
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/* unpause always */
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_handle_scsiint&n; *&n; * Description:&n; *   Interrupt handler for SCSI interrupts (SCSIINT).&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_handle_scsiint
id|aic7xxx_handle_scsiint
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
id|intstat
)paren
(brace
r_int
r_char
id|scb_index
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_struct
id|aic7xxx_scb
op_star
id|scb
suffix:semicolon
id|scb_index
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_TAG
)paren
suffix:semicolon
id|status
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SSTAT1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_index
OL
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
(brace
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SCSIRSTI
)paren
op_ne
l_int|0
)paren
(brace
r_char
id|channel
suffix:semicolon
id|channel
op_assign
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SBLKCTL
)paren
op_amp
id|SELBUSB
)paren
ques
c_cond
l_char|&squot;B&squot;
suffix:colon
l_char|&squot;A&squot;
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: SCSIINT - Someone reset channel %c.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
)paren
suffix:semicolon
multiline_comment|/*&n;     * Go through and abort all commands for the channel, but do not&n;     * reset the channel again.&n;     */
id|aic7xxx_reset_channel
c_func
(paren
id|p
comma
id|channel
comma
multiline_comment|/* Initiate Reset */
id|FALSE
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|status
op_amp
id|BUSFREE
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
(paren
id|status
op_amp
id|SELTO
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;     * First look at what phase we were last in.  If it&squot;s message-out,&n;     * chances are pretty good that the bus free was in response to&n;     * one of our abort requests.&n;     */
r_int
r_char
id|lastphase
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|LASTPHASE
)paren
suffix:semicolon
r_int
r_char
id|target
op_assign
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SAVED_TCL
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0x0F
suffix:semicolon
r_char
id|channel
op_assign
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SBLKCTL
)paren
op_amp
id|SELBUSB
)paren
ques
c_cond
l_char|&squot;B&squot;
suffix:colon
l_char|&squot;A&squot;
suffix:semicolon
r_int
id|printerror
op_assign
id|TRUE
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SCSISEQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lastphase
op_eq
id|P_MESGOUT
)paren
(brace
r_int
r_char
id|sindex
suffix:semicolon
r_int
r_char
id|message
suffix:semicolon
id|sindex
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SINDEX
)paren
suffix:semicolon
id|message
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|sindex
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|message
op_eq
id|MSG_ABORT
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d) SCB %d abort completed.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|aic7xxx_reset_device
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|SCB_LUN
c_func
(paren
id|scb
)paren
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
id|aic7xxx_run_done_queue
c_func
(paren
id|p
comma
multiline_comment|/* complete */
id|TRUE
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
id|printerror
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|message
op_eq
id|MSG_ABORT_TAG
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d) SCB %d abort Tag completed.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|aic7xxx_reset_device
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|SCB_LUN
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|aic7xxx_run_done_queue
c_func
(paren
id|p
comma
multiline_comment|/* complete */
id|TRUE
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
id|printerror
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|message
op_eq
id|MSG_BUS_DEV_RESET
)paren
(brace
id|aic7xxx_handle_device_reset
c_func
(paren
id|p
comma
id|target
comma
id|channel
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
id|printerror
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|printerror
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
)paren
(brace
r_int
r_char
id|tag
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|TAG_ENB
)paren
op_ne
l_int|0
)paren
(brace
id|tag
op_assign
id|scb-&gt;hscb-&gt;tag
suffix:semicolon
)brace
r_else
(brace
id|tag
op_assign
id|SCB_LIST_NULL
suffix:semicolon
)brace
id|aic7xxx_reset_device
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|SCB_LUN
c_func
(paren
id|scb
)paren
comma
id|tag
)paren
suffix:semicolon
)brace
r_else
(brace
id|aic7xxx_reset_device
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|ALL_LUNS
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: Unexpected busfree, LASTPHASE = 0x%x, &quot;
l_string|&quot;SEQADDR = 0x%x&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|lastphase
comma
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQADDR1
)paren
op_lshift
l_int|8
)paren
op_or
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQADDR0
)paren
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SIMODE1
)paren
op_amp
op_complement
id|ENBUSFREE
comma
id|p-&gt;base
op_plus
id|SIMODE1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CLRBUSFREE
comma
id|p-&gt;base
op_plus
id|CLRSINT1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CLRSCSIINT
comma
id|p-&gt;base
op_plus
id|CLRINT
)paren
suffix:semicolon
id|restart_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SELTO
)paren
op_ne
l_int|0
)paren
(brace
r_int
r_char
id|scbptr
suffix:semicolon
r_int
r_char
id|nextscb
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|scbptr
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|WAITING_SCBH
)paren
suffix:semicolon
id|outb
c_func
(paren
id|scbptr
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|scb_index
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_TAG
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|scb_index
OL
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
(brace
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: Referenced SCB %d not valid during SELTO.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|scb_index
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;        SCSISEQ = 0x%x SEQADDR = 0x%x SSTAT0 = 0x%x &quot;
l_string|&quot;SSTAT1 = 0x%x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCSISEQ
)paren
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQADDR0
)paren
op_or
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQADDR1
)paren
op_lshift
l_int|8
)paren
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SSTAT0
)paren
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SSTAT1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;       * XXX - If we queued an abort tag, go clean up the disconnected list.&n;       */
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_TIME_OUT
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/*&n;       * Clear an pending messages for the timed out&n;       * target and mark the target as free.&n;       */
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|MSG_LEN
)paren
suffix:semicolon
id|aic7xxx_index_busy_target
c_func
(paren
id|p
comma
id|cmd-&gt;target
comma
id|cmd-&gt;channel
ques
c_cond
l_char|&squot;B&squot;
suffix:colon
l_char|&squot;A&squot;
comma
multiline_comment|/*unbusy*/
id|TRUE
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SCB_CONTROL
)paren
suffix:semicolon
multiline_comment|/*&n;       * Shift the waiting for selection queue forward&n;       */
id|nextscb
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_NEXT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|nextscb
comma
id|p-&gt;base
op_plus
id|WAITING_SCBH
)paren
suffix:semicolon
multiline_comment|/*&n;       * Put this SCB back on the free list.&n;       */
id|aic7xxx_add_curscb_to_free_list
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Stop the selection.&n;     */
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SCSISEQ
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CLRSELTIMEO
op_or
id|CLRBUSFREE
comma
id|p-&gt;base
op_plus
id|CLRSINT1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CLRSCSIINT
comma
id|p-&gt;base
op_plus
id|CLRINT
)paren
suffix:semicolon
id|restart_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: aic7xxx_isr - referenced scb not valid &quot;
l_string|&quot;during scsiint 0x%x scb(%d)&bslash;n&quot;
l_string|&quot;      SIMODE0 0x%x, SIMODE1 0x%x, SSTAT0 0x%x, SEQADDR 0x%x&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|status
comma
id|scb_index
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SIMODE0
)paren
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SIMODE1
)paren
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SSTAT0
)paren
comma
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQADDR1
)paren
op_lshift
l_int|8
)paren
op_or
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQADDR0
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * Turn off the interrupt and set status to zero, so that it&n;     * falls through the rest of the SCSIINT code.&n;     */
id|outb
c_func
(paren
id|status
comma
id|p-&gt;base
op_plus
id|CLRSINT1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CLRSCSIINT
comma
id|p-&gt;base
op_plus
id|CLRINT
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/* unpause always */
id|TRUE
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|SCSIPERR
)paren
(brace
multiline_comment|/*&n;     * Determine the bus phase and queue an appropriate message.&n;     */
r_char
op_star
id|phase
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_int
r_char
id|mesg_out
op_assign
id|MSG_NOOP
suffix:semicolon
r_int
r_char
id|lastphase
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|LASTPHASE
)paren
suffix:semicolon
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
r_switch
c_cond
(paren
id|lastphase
)paren
(brace
r_case
id|P_DATAOUT
suffix:colon
id|phase
op_assign
l_string|&quot;Data-Out&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_DATAIN
suffix:colon
id|phase
op_assign
l_string|&quot;Data-In&quot;
suffix:semicolon
id|mesg_out
op_assign
id|MSG_INITIATOR_DET_ERR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_COMMAND
suffix:colon
id|phase
op_assign
l_string|&quot;Command&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_MESGOUT
suffix:colon
id|phase
op_assign
l_string|&quot;Message-Out&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_STATUS
suffix:colon
id|phase
op_assign
l_string|&quot;Status&quot;
suffix:semicolon
id|mesg_out
op_assign
id|MSG_INITIATOR_DET_ERR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_MESGIN
suffix:colon
id|phase
op_assign
l_string|&quot;Message-In&quot;
suffix:semicolon
id|mesg_out
op_assign
id|MSG_PARITY_ERROR
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|phase
op_assign
l_string|&quot;unknown&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;     * A parity error has occurred during a data&n;     * transfer phase. Flag it and continue.&n;     */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d) Parity error during phase %s.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|phase
)paren
suffix:semicolon
multiline_comment|/*&n;     * We&squot;ve set the hardware to assert ATN if we get a parity&n;     * error on &quot;in&quot; phases, so all we need to do is stuff the&n;     * message buffer with the appropriate message.  &quot;In&quot; phases&n;     * have set mesg_out to something other than MSG_NOP.&n;     */
r_if
c_cond
(paren
id|mesg_out
op_ne
id|MSG_NOOP
)paren
(brace
id|outb
c_func
(paren
id|mesg_out
comma
id|p-&gt;base
op_plus
id|MSG_OUT
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|p-&gt;base
op_plus
id|MSG_LEN
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;       * Should we allow the target to make this decision for us?&n;       */
id|cmd-&gt;result
op_assign
id|DID_RETRY_COMMAND
op_lshift
l_int|16
suffix:semicolon
)brace
id|outb
c_func
(paren
id|CLRSCSIPERR
comma
id|p-&gt;base
op_plus
id|CLRSINT1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CLRSCSIINT
comma
id|p-&gt;base
op_plus
id|CLRINT
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/* unpause_always */
id|TRUE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;     * We don&squot;t know what&squot;s going on. Turn off the&n;     * interrupt source and try to continue.&n;     */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: SSTAT1(0x%x).&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|outb
c_func
(paren
id|status
comma
id|p-&gt;base
op_plus
id|CLRSINT1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CLRSCSIINT
comma
id|p-&gt;base
op_plus
id|CLRINT
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/* unpause always */
id|TRUE
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
)paren
(brace
id|aic7xxx_done
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
id|aic7xxx_done_cmds_complete
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_isr&n; *&n; * Description:&n; *   SCSI controller interrupt handler.&n; *&n; *   NOTE: Since we declared this using SA_INTERRUPT, interrupts should&n; *         be disabled all through this function unless we say otherwise.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_isr
id|aic7xxx_isr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
r_int
r_char
id|intstat
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|aic7xxx_boards
(braket
id|irq
)braket
op_member_access_from_pointer
id|hostdata
suffix:semicolon
multiline_comment|/*&n;   * Search for the host with a pending interrupt.  If we can&squot;t find&n;   * one, then we&squot;ve encountered a spurious interrupt.&n;   */
r_while
c_loop
(paren
(paren
id|p
op_ne
l_int|NULL
)paren
op_logical_and
op_logical_neg
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|INTSTAT
)paren
op_amp
id|INT_PEND
)paren
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;next
op_eq
l_int|NULL
)paren
(brace
id|p
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|p-&gt;next-&gt;hostdata
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;   * Handle all the interrupt sources - especially for SCSI&n;   * interrupts, we won&squot;t get a second chance at them.&n;   */
id|intstat
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|INTSTAT
)paren
suffix:semicolon
multiline_comment|/*&n;   * Keep track of interrupts for /proc/scsi&n;   */
id|p-&gt;isr_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|A_SCANNED
)paren
op_logical_and
(paren
id|p-&gt;isr_count
op_eq
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;     * We must only have one card at this IRQ and it must have been&n;     * added to the board data before the spurious interrupt occurred.&n;     * It is sufficient that we check isr_count and not the spurious&n;     * interrupt count.&n;     */
id|printk
c_func
(paren
l_string|&quot;scsi%d: Encountered spurious interrupt.&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intstat
)paren
(brace
multiline_comment|/* Try clearing all interrupts. */
id|outb
c_func
(paren
id|CLRBRKADRINT
op_or
id|CLRSCSIINT
op_or
id|CLRCMDINT
op_or
id|CLRSEQINT
comma
id|p-&gt;base
op_plus
id|CLRINT
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|IN_ISR
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: Warning!! Interrupt routine called reentrantly!&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;   * Indicate that we&squot;re in the interrupt handler.&n;   */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|IN_ISR
suffix:semicolon
r_if
c_cond
(paren
id|intstat
op_amp
id|CMDCMPLT
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scb
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_int
r_char
id|qoutcnt
suffix:semicolon
r_int
r_char
id|scb_index
suffix:semicolon
r_int
id|i
comma
id|interrupts_cleared
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * The sequencer will continue running when it&n;     * issues this interrupt. There may be &gt;1 commands&n;     * finished, so loop until we&squot;ve processed them all.&n;     */
id|qoutcnt
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|QOUTCNT
)paren
op_amp
id|p-&gt;qcntmask
suffix:semicolon
macro_line|#if 1
r_if
c_cond
(paren
id|qoutcnt
op_ge
id|p-&gt;qfullcount
op_minus
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: Command complete near Qfull count, &quot;
l_string|&quot;qoutcnt = %d.&bslash;n&quot;
comma
id|qoutcnt
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|qoutcnt
OG
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|qoutcnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scb_index
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|QOUTFIFO
)paren
suffix:semicolon
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: CMDCMPLT with invalid SCB index %d, &quot;
l_string|&quot;QOUTCNT %d, QINCNT %d&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|scb_index
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|QOUTCNT
)paren
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|QINCNT
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_logical_or
(paren
id|scb-&gt;cmd
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: CMDCMPLT without command for SCB %d, &quot;
l_string|&quot;QOUTCNT %d, QINCNT %d, SCB flags 0x%x, cmd 0x%lx&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|scb_index
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|QOUTCNT
)paren
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|QINCNT
)paren
comma
id|scb-&gt;flags
comma
(paren
r_int
r_int
)paren
id|scb-&gt;cmd
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;hscb-&gt;residual_SG_segment_count
op_ne
l_int|0
)paren
(brace
id|aic7xxx_calculate_residual
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_QUEUED_ABORT
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;           * Have to clean up any possible entries in the&n;           * waiting queue and the QINFIFO.&n;           */
r_int
id|target
suffix:semicolon
r_char
id|channel
suffix:semicolon
r_int
id|lun
suffix:semicolon
r_int
r_char
id|tag
suffix:semicolon
id|tag
op_assign
id|SCB_LIST_NULL
suffix:semicolon
id|target
op_assign
id|cmd-&gt;target
suffix:semicolon
id|lun
op_assign
id|cmd-&gt;lun
suffix:semicolon
id|channel
op_assign
(paren
id|scb-&gt;hscb-&gt;target_channel_lun
op_amp
id|SELBUSB
)paren
ques
c_cond
l_char|&squot;B&squot;
suffix:colon
l_char|&squot;A&squot;
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|TAG_ENB
)paren
(brace
id|tag
op_assign
id|scb-&gt;hscb-&gt;tag
suffix:semicolon
)brace
id|aic7xxx_reset_device
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
)paren
suffix:semicolon
multiline_comment|/*&n;           * Run the done queue, but don&squot;t complete the commands; we&n;           * do this once at the end of the loop.&n;           */
id|aic7xxx_run_done_queue
c_func
(paren
id|p
comma
multiline_comment|/*complete*/
id|FALSE
)paren
suffix:semicolon
)brace
id|cmd-&gt;result
op_or_assign
(paren
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|p-&gt;device_status
(braket
id|TARGET_INDEX
c_func
(paren
id|cmd
)paren
)braket
dot
id|flags
op_or_assign
id|DEVICE_SUCCESS
suffix:semicolon
id|aic7xxx_done
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;       * Clear interrupt status before checking the output queue again.&n;       * This eliminates a race condition whereby a command could&n;       * complete between the queue poll and the interrupt clearing,&n;       * so notification of the command being complete never made it&n;       * back up to the kernel.&n;       */
id|outb
c_func
(paren
id|CLRCMDINT
comma
id|p-&gt;base
op_plus
id|CLRINT
)paren
suffix:semicolon
id|interrupts_cleared
op_increment
suffix:semicolon
id|qoutcnt
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|QOUTCNT
)paren
op_amp
id|p-&gt;qcntmask
suffix:semicolon
)brace
r_if
c_cond
(paren
id|interrupts_cleared
op_eq
l_int|0
)paren
(brace
id|outb
c_func
(paren
id|CLRCMDINT
comma
id|p-&gt;base
op_plus
id|CLRINT
)paren
suffix:semicolon
)brace
id|aic7xxx_done_cmds_complete
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intstat
op_amp
id|BRKADRINT
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|errno
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|ERROR
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi%d: BRKADRINT error(0x%x):&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|errno
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMBER
c_func
(paren
id|hard_error
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|errno
op_amp
id|hard_error
(braket
id|i
)braket
dot
id|errno
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;  %s&bslash;n&quot;
comma
id|hard_error
(braket
id|i
)braket
dot
id|errmesg
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: BRKADRINT, error 0x%x, seqaddr 0x%x.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|ERROR
)paren
comma
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQADDR1
)paren
op_lshift
l_int|8
)paren
op_or
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQADDR0
)paren
)paren
suffix:semicolon
id|aic7xxx_reset_device
c_func
(paren
id|p
comma
id|ALL_TARGETS
comma
id|ALL_CHANNELS
comma
id|ALL_LUNS
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
id|aic7xxx_run_done_queue
c_func
(paren
id|p
comma
multiline_comment|/*complete*/
id|TRUE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intstat
op_amp
id|SEQINT
)paren
(brace
id|aic7xxx_handle_seqint
c_func
(paren
id|p
comma
id|intstat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intstat
op_amp
id|SCSIINT
)paren
(brace
id|aic7xxx_handle_scsiint
c_func
(paren
id|p
comma
id|intstat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;waiting_scbs.head
op_ne
l_int|NULL
)paren
(brace
id|aic7xxx_run_waiting_queues
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|p-&gt;flags
op_and_assign
op_complement
id|IN_ISR
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_device_queue_depth&n; *&n; * Description:&n; *   Determines the queue depth for a given device.  There are two ways&n; *   a queue depth can be obtained for a tagged queueing device.  One&n; *   way is the default queue depth which is determined by whether&n; *   AIC7XXX_CMDS_PER_LUN is defined.  If it is defined, then it is used&n; *   as the default queue depth.  Otherwise, we use either 4 or 8 as the&n; *   default queue depth (dependent on the number of hardware SCBs).&n; *   The other way we determine queue depth is through the use of the&n; *   aic7xxx_tag_info array which is enabled by defining&n; *   AIC7XXX_TAGGED_QUEUEING_BY_DEVICE.  This array can be initialized&n; *   with queue depths for individual devices.  It also allows tagged&n; *   queueing to be [en|dis]abled for a specific adapter.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_device_queue_depth
id|aic7xxx_device_queue_depth
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
id|Scsi_Device
op_star
id|device
)paren
(brace
r_int
id|default_depth
op_assign
l_int|2
suffix:semicolon
id|device-&gt;queue_depth
op_assign
id|default_depth
suffix:semicolon
macro_line|#ifdef AIC7XXX_TAGGED_QUEUEING
r_if
c_cond
(paren
id|device-&gt;tagged_supported
)paren
(brace
r_int
r_int
id|target_mask
suffix:semicolon
r_int
id|tag_enabled
op_assign
id|TRUE
suffix:semicolon
id|target_mask
op_assign
(paren
l_int|1
op_lshift
(paren
id|device-&gt;id
op_or
(paren
id|device-&gt;channel
op_lshift
l_int|3
)paren
)paren
)paren
suffix:semicolon
macro_line|#ifdef AIC7XXX_CMDS_PER_LUN
id|default_depth
op_assign
id|AIC7XXX_CMDS_PER_LUN
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;maxhscbs
op_le
l_int|4
)paren
(brace
id|default_depth
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* Not many SCBs to work with. */
)brace
r_else
(brace
id|default_depth
op_assign
l_int|8
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;discenable
op_amp
id|target_mask
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d:%d:%d) Disconnection disabled, unable to &quot;
l_string|&quot;enable tagged queueing.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|device-&gt;id
comma
id|device-&gt;channel
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifndef AIC7XXX_TAGGED_QUEUEING_BY_DEVICE
id|device-&gt;queue_depth
op_assign
id|default_depth
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|p-&gt;instance
OG
id|NUMBER
c_func
(paren
id|aic7xxx_tag_info
)paren
)paren
(brace
id|device-&gt;queue_depth
op_assign
id|default_depth
suffix:semicolon
)brace
r_else
(brace
r_int
r_char
id|tindex
suffix:semicolon
id|tindex
op_assign
id|device-&gt;id
op_or
(paren
id|device-&gt;channel
op_lshift
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_tag_info
(braket
id|p-&gt;instance
)braket
dot
id|tag_commands
(braket
id|tindex
)braket
OL
l_int|0
)paren
(brace
id|tag_enabled
op_assign
id|FALSE
suffix:semicolon
id|device-&gt;queue_depth
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Tagged queueing is disabled. */
)brace
r_else
r_if
c_cond
(paren
id|aic7xxx_tag_info
(braket
id|p-&gt;instance
)braket
dot
id|tag_commands
(braket
id|tindex
)braket
op_eq
l_int|0
)paren
(brace
id|device-&gt;queue_depth
op_assign
id|default_depth
suffix:semicolon
)brace
r_else
(brace
id|device-&gt;queue_depth
op_assign
id|aic7xxx_tag_info
(braket
id|p-&gt;instance
)braket
dot
id|tag_commands
(braket
id|tindex
)braket
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|device-&gt;tagged_queue
op_eq
l_int|0
)paren
op_logical_and
id|tag_enabled
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d:%d:%d) Enabled tagged queuing, &quot;
l_string|&quot;queue depth %d.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|device-&gt;id
comma
id|device-&gt;channel
comma
id|device-&gt;queue_depth
)paren
suffix:semicolon
)brace
id|device-&gt;tagged_queue
op_assign
l_int|1
suffix:semicolon
id|device-&gt;current_tag
op_assign
id|SCB_LIST_NULL
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_select_queue_depth&n; *&n; * Description:&n; *   Sets the queue depth for each SCSI device hanging off the input&n; *   host adapter.  We use a queue depth of 2 for devices that do not&n; *   support tagged queueing.  If AIC7XXX_CMDS_PER_LUN is defined, we&n; *   use that for tagged queueing devices; otherwise we use our own&n; *   algorithm for determining the queue depth based on the maximum&n; *   SCBs for the controller.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_select_queue_depth
id|aic7xxx_select_queue_depth
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
id|Scsi_Device
op_star
id|scsi_devs
)paren
(brace
id|Scsi_Device
op_star
id|device
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_for
c_loop
(paren
id|device
op_assign
id|scsi_devs
suffix:semicolon
id|device
op_ne
l_int|NULL
suffix:semicolon
id|device
op_assign
id|device-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;host
op_eq
id|host
)paren
(brace
id|aic7xxx_device_queue_depth
c_func
(paren
id|p
comma
id|device
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_probe&n; *&n; * Description:&n; *   Probing for EISA boards: it looks like the first two bytes&n; *   are a manufacturer code - three characters, five bits each:&n; *&n; *               BYTE 0   BYTE 1   BYTE 2   BYTE 3&n; *              ?1111122 22233333 PPPPPPPP RRRRRRRR&n; *&n; *   The characters are baselined off ASCII &squot;@&squot;, so add that value&n; *   to each to get the real ASCII code for it. The next two bytes&n; *   appear to be a product and revision number, probably vendor-&n; *   specific. This is what is being searched for at each port,&n; *   and what should probably correspond to the ID= field in the&n; *   ECU&squot;s .cfg file for the card - if your card is not detected,&n; *   make sure your signature is listed in the array.&n; *&n; *   The fourth byte&squot;s lowest bit seems to be an enabled/disabled&n; *   flag (rest of the bits are reserved?).&n; *-F*************************************************************************/
r_static
id|aha_chip_type
DECL|function|aic7xxx_probe
id|aic7xxx_probe
c_func
(paren
r_int
id|slot
comma
r_int
id|base
comma
id|aha_status_type
op_star
id|bios
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|4
)braket
suffix:semicolon
r_static
r_struct
(brace
r_int
id|n
suffix:semicolon
r_int
r_char
id|signature
(braket
r_sizeof
(paren
id|buf
)paren
)braket
suffix:semicolon
id|aha_chip_type
id|type
suffix:semicolon
r_int
id|bios_disabled
suffix:semicolon
)brace
id|AIC7xxx
(braket
)braket
op_assign
(brace
(brace
l_int|4
comma
(brace
l_int|0x04
comma
l_int|0x90
comma
l_int|0x77
comma
l_int|0x71
)brace
comma
id|AIC_7771
comma
id|FALSE
)brace
comma
multiline_comment|/* host adapter 274x */
(brace
l_int|4
comma
(brace
l_int|0x04
comma
l_int|0x90
comma
l_int|0x77
comma
l_int|0x70
)brace
comma
id|AIC_7770
comma
id|FALSE
)brace
comma
multiline_comment|/* motherboard 7770  */
(brace
l_int|4
comma
(brace
l_int|0x04
comma
l_int|0x90
comma
l_int|0x77
comma
l_int|0x56
)brace
comma
id|AIC_284x
comma
id|FALSE
)brace
comma
multiline_comment|/* 284x BIOS enabled */
(brace
l_int|4
comma
(brace
l_int|0x04
comma
l_int|0x90
comma
l_int|0x77
comma
l_int|0x57
)brace
comma
id|AIC_284x
comma
id|TRUE
)brace
multiline_comment|/* 284x BIOS disabled */
)brace
suffix:semicolon
multiline_comment|/*&n;   * The VL-bus cards need to be primed by&n;   * writing before a signature check.&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|buf
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
l_int|0x80
op_plus
id|i
comma
id|base
)paren
suffix:semicolon
id|buf
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|base
op_plus
id|i
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMBER
c_func
(paren
id|AIC7xxx
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;     * Signature match on enabled card?&n;     */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|buf
comma
id|AIC7xxx
(braket
id|i
)braket
dot
id|signature
comma
id|AIC7xxx
(braket
id|i
)braket
dot
id|n
)paren
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|base
op_plus
l_int|4
)paren
op_amp
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|AIC7xxx
(braket
id|i
)braket
dot
id|bios_disabled
)paren
(brace
op_star
id|bios
op_assign
id|AIC_DISABLED
suffix:semicolon
)brace
r_else
(brace
op_star
id|bios
op_assign
id|AIC_ENABLED
suffix:semicolon
)brace
r_return
(paren
id|AIC7xxx
(braket
id|i
)braket
dot
id|type
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: &lt;Adaptec 7770 SCSI Host Adapter&gt; &quot;
l_string|&quot;disabled at slot %d, ignored.&bslash;n&quot;
comma
id|slot
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|AIC_NONE
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   read_2840_seeprom&n; *&n; * Description:&n; *   Reads the 2840 serial EEPROM and returns 1 if successful and 0 if&n; *   not successful.&n; *&n; *   See read_seeprom (for the 2940) for the instruction set of the 93C46&n; *   chip.&n; *&n; *   The 2840 interface to the 93C46 serial EEPROM is through the&n; *   STATUS_2840 and SEECTL_2840 registers.  The CS_2840, CK_2840, and&n; *   DO_2840 bits of the SEECTL_2840 register are connected to the chip&n; *   select, clock, and data out lines respectively of the serial EEPROM.&n; *   The DI_2840 bit of the STATUS_2840 is connected to the data in line&n; *   of the serial EEPROM.  The EEPROM_TF bit of STATUS_2840 register is&n; *   useful in that it gives us an 800 nsec timer.  After a read from the&n; *   SEECTL_2840 register the timing flag is cleared and goes high 800 nsec&n; *   later.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|read_284x_seeprom
id|read_284x_seeprom
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|seeprom_config
op_star
id|sc
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|k
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|temp
suffix:semicolon
r_int
r_int
id|checksum
op_assign
l_int|0
suffix:semicolon
r_int
r_int
op_star
id|seeprom
op_assign
(paren
r_int
r_int
op_star
)paren
id|sc
suffix:semicolon
r_struct
id|seeprom_cmd
(brace
r_int
r_char
id|len
suffix:semicolon
r_int
r_char
id|bits
(braket
l_int|3
)braket
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|seeprom_cmd
id|seeprom_read
op_assign
(brace
l_int|3
comma
(brace
l_int|1
comma
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|macro|CLOCK_PULSE
mdefine_line|#define CLOCK_PULSE(p) &bslash;&n;  while ((inb(p-&gt;base + STATUS_2840) &amp; EEPROM_TF) == 0)&t;&bslash;&n;  {&t;&t;&t;&t;&t;&t;&bslash;&n;    ;  /* Do nothing */&t;&t;&t;&t;&bslash;&n;  }&t;&t;&t;&t;&t;&t;&bslash;&n;  (void) inb(p-&gt;base + SEECTL_2840);
multiline_comment|/*&n;   * Read the first 32 registers of the seeprom.  For the 2840,&n;   * the 93C46 SEEPROM is a 1024-bit device with 64 16-bit registers&n;   * but only the first 32 are used by Adaptec BIOS.  The loop&n;   * will range from 0 to 31.&n;   */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
(paren
r_sizeof
(paren
op_star
id|sc
)paren
op_div
l_int|2
)paren
suffix:semicolon
id|k
op_increment
)paren
(brace
multiline_comment|/*&n;     * Send chip select for one clock cycle.&n;     */
id|outb
c_func
(paren
id|CK_2840
op_or
id|CS_2840
comma
id|p-&gt;base
op_plus
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;     * Now we&squot;re ready to send the read command followed by the&n;     * address of the 16-bit register we want to read.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|seeprom_read.len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|temp
op_assign
id|CS_2840
op_or
id|seeprom_read.bits
(braket
id|i
)braket
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|p-&gt;base
op_plus
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|temp
op_assign
id|temp
op_xor
id|CK_2840
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|p-&gt;base
op_plus
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Send the 6 bit address (MSB first, LSB last).&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|5
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|temp
op_assign
id|k
suffix:semicolon
id|temp
op_assign
(paren
id|temp
op_rshift
id|i
)paren
op_amp
l_int|1
suffix:semicolon
multiline_comment|/* Mask out all but lower bit. */
id|temp
op_assign
id|CS_2840
op_or
id|temp
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|p-&gt;base
op_plus
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|temp
op_assign
id|temp
op_xor
id|CK_2840
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|p-&gt;base
op_plus
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Now read the 16 bit register.  An initial 0 precedes the&n;     * register contents which begins with bit 15 (MSB) and ends&n;     * with bit 0 (LSB).  The initial 0 will be shifted off the&n;     * top of our word as we let the loop run from 0 to 16.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|temp
op_assign
id|CS_2840
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|p-&gt;base
op_plus
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|temp
op_assign
id|temp
op_xor
id|CK_2840
suffix:semicolon
id|seeprom
(braket
id|k
)braket
op_assign
(paren
id|seeprom
(braket
id|k
)braket
op_lshift
l_int|1
)paren
op_or
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|STATUS_2840
)paren
op_amp
id|DI_2840
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|p-&gt;base
op_plus
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * The serial EEPROM has a checksum in the last word.  Keep a&n;     * running checksum for all words read except for the last&n;     * word.  We&squot;ll verify the checksum after all words have been&n;     * read.&n;     */
r_if
c_cond
(paren
id|k
OL
(paren
r_sizeof
(paren
op_star
id|sc
)paren
op_div
l_int|2
)paren
op_minus
l_int|1
)paren
(brace
id|checksum
op_assign
id|checksum
op_plus
id|seeprom
(braket
id|k
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;     * Reset the chip select for the next command cycle.&n;     */
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CK_2840
comma
id|p-&gt;base
op_plus
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;Computed checksum 0x%x, checksum read 0x%x&bslash;n&quot;
comma
id|checksum
comma
id|sc-&gt;checksum
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Serial EEPROM:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
(paren
r_sizeof
(paren
op_star
id|sc
)paren
op_div
l_int|2
)paren
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|k
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|k
op_ne
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n              &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; 0x%x&quot;
comma
id|seeprom
(braket
id|k
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|checksum
op_ne
id|sc-&gt;checksum
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: SEEPROM checksum error, ignoring SEEPROM settings.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
DECL|macro|CLOCK_PULSE
macro_line|#undef CLOCK_PULSE
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   acquire_seeprom&n; *&n; * Description:&n; *   Acquires access to the memory port on PCI controllers.&n; *-F*************************************************************************/
r_static
r_inline
r_int
DECL|function|acquire_seeprom
id|acquire_seeprom
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_int
id|wait
suffix:semicolon
multiline_comment|/*&n;   * Request access of the memory port.  When access is&n;   * granted, SEERDY will go high.  We use a 1 second&n;   * timeout which should be near 1 second more than&n;   * is needed.  Reason: after the 7870 chip reset, there&n;   * should be no contention.&n;   */
id|outb
c_func
(paren
id|SEEMS
comma
id|p-&gt;base
op_plus
id|SEECTL
)paren
suffix:semicolon
id|wait
op_assign
l_int|1000
suffix:semicolon
multiline_comment|/* 1000 msec = 1 second */
r_while
c_loop
(paren
(paren
id|wait
OG
l_int|0
)paren
op_logical_and
(paren
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEECTL
)paren
op_amp
id|SEERDY
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|wait
op_decrement
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* 1 msec */
)brace
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEECTL
)paren
op_amp
id|SEERDY
)paren
op_eq
l_int|0
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SEECTL
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   release_seeprom&n; *&n; * Description:&n; *   Releases access to the memory port on PCI controllers.&n; *-F*************************************************************************/
r_static
r_inline
r_void
DECL|function|release_seeprom
id|release_seeprom
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SEECTL
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   read_seeprom&n; *&n; * Description:&n; *   Reads the serial EEPROM and returns 1 if successful and 0 if&n; *   not successful.&n; *&n; *   The instruction set of the 93C46/56/66 chips is as follows:&n; *&n; *               Start  OP&n; *     Function   Bit  Code  Address    Data     Description&n; *     -------------------------------------------------------------------&n; *     READ        1    10   A5 - A0             Reads data stored in memory,&n; *                                               starting at specified address&n; *     EWEN        1    00   11XXXX              Write enable must precede&n; *                                               all programming modes&n; *     ERASE       1    11   A5 - A0             Erase register A5A4A3A2A1A0&n; *     WRITE       1    01   A5 - A0   D15 - D0  Writes register&n; *     ERAL        1    00   10XXXX              Erase all registers&n; *     WRAL        1    00   01XXXX    D15 - D0  Writes to all registers&n; *     EWDS        1    00   00XXXX              Disables all programming&n; *                                               instructions&n; *     *Note: A value of X for address is a don&squot;t care condition.&n; *     *Note: The 93C56 and 93C66 have 8 address bits.&n; * &n; *&n; *   The 93C46 has a four wire interface: clock, chip select, data in, and&n; *   data out.  In order to perform one of the above functions, you need&n; *   to enable the chip select for a clock period (typically a minimum of&n; *   1 usec, with the clock high and low a minimum of 750 and 250 nsec&n; *   respectively.  While the chip select remains high, you can clock in&n; *   the instructions (above) starting with the start bit, followed by the&n; *   OP code, Address, and Data (if needed).  For the READ instruction, the&n; *   requested 16-bit register contents is read from the data out line but&n; *   is preceded by an initial zero (leading 0, followed by 16-bits, MSB&n; *   first).  The clock cycling from low to high initiates the next data&n; *   bit to be sent from the chip.&n; *&n; *   The 78xx interface to the 93C46 serial EEPROM is through the SEECTL&n; *   register.  After successful arbitration for the memory port, the&n; *   SEECS bit of the SEECTL register is connected to the chip select.&n; *   The SEECK, SEEDO, and SEEDI are connected to the clock, data out,&n; *   and data in lines respectively.  The SEERDY bit of SEECTL is useful&n; *   in that it gives us an 800 nsec timer.  After a write to the SEECTL&n; *   register, the SEERDY goes high 800 nsec later.  The one exception&n; *   to this is when we first request access to the memory port.  The&n; *   SEERDY goes high to signify that access has been granted and, for&n; *   this case, has no implied timing.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|read_seeprom
id|read_seeprom
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|offset
comma
r_int
r_int
op_star
id|scarray
comma
r_int
r_int
id|len
comma
id|seeprom_chip_type
id|chip
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|k
suffix:semicolon
r_int
r_char
id|temp
suffix:semicolon
r_int
r_int
id|checksum
op_assign
l_int|0
suffix:semicolon
r_struct
id|seeprom_cmd
(brace
r_int
r_char
id|len
suffix:semicolon
r_int
r_char
id|bits
(braket
l_int|3
)braket
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|seeprom_cmd
id|seeprom_read
op_assign
(brace
l_int|3
comma
(brace
l_int|1
comma
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|macro|CLOCK_PULSE
mdefine_line|#define CLOCK_PULSE(p) &bslash;&n;  while ((inb(p-&gt;base + SEECTL) &amp; SEERDY) == 0)&t;&bslash;&n;  {&t;&t;&t;&t;&t;&t;&bslash;&n;    ;  /* Do nothing */&t;&t;&t;&t;&bslash;&n;  }
multiline_comment|/*&n;   * Request access of the memory port.&n;   */
r_if
c_cond
(paren
id|acquire_seeprom
c_func
(paren
id|p
)paren
op_eq
l_int|0
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * Read &squot;len&squot; registers of the seeprom.  For the 7870, the 93C46&n;   * SEEPROM is a 1024-bit device with 64 16-bit registers but only&n;   * the first 32 are used by Adaptec BIOS.  Some adapters use the&n;   * 93C56 SEEPROM which is a 2048-bit device.  The loop will range&n;   * from 0 to &squot;len&squot; - 1.&n;   */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|len
suffix:semicolon
id|k
op_increment
)paren
(brace
multiline_comment|/*&n;     * Send chip select for one clock cycle.&n;     */
id|outb
c_func
(paren
id|SEEMS
op_or
id|SEECK
op_or
id|SEECS
comma
id|p-&gt;base
op_plus
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;     * Now we&squot;re ready to send the read command followed by the&n;     * address of the 16-bit register we want to read.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|seeprom_read.len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|temp
op_assign
id|SEEMS
op_or
id|SEECS
op_or
(paren
id|seeprom_read.bits
(braket
id|i
)braket
op_lshift
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|p-&gt;base
op_plus
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|temp
op_assign
id|temp
op_xor
id|SEECK
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|p-&gt;base
op_plus
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Send the 6 or 8 bit address (MSB first, LSB last).&n;     */
r_for
c_loop
(paren
id|i
op_assign
(paren
(paren
r_int
)paren
id|chip
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|temp
op_assign
id|k
op_plus
id|offset
suffix:semicolon
id|temp
op_assign
(paren
id|temp
op_rshift
id|i
)paren
op_amp
l_int|1
suffix:semicolon
multiline_comment|/* Mask out all but lower bit. */
id|temp
op_assign
id|SEEMS
op_or
id|SEECS
op_or
(paren
id|temp
op_lshift
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|p-&gt;base
op_plus
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|temp
op_assign
id|temp
op_xor
id|SEECK
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|p-&gt;base
op_plus
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Now read the 16 bit register.  An initial 0 precedes the&n;     * register contents which begins with bit 15 (MSB) and ends&n;     * with bit 0 (LSB).  The initial 0 will be shifted off the&n;     * top of our word as we let the loop run from 0 to 16.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|temp
op_assign
id|SEEMS
op_or
id|SEECS
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|p-&gt;base
op_plus
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|temp
op_assign
id|temp
op_xor
id|SEECK
suffix:semicolon
id|scarray
(braket
id|k
)braket
op_assign
(paren
id|scarray
(braket
id|k
)braket
op_lshift
l_int|1
)paren
op_or
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEECTL
)paren
op_amp
id|SEEDI
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|p-&gt;base
op_plus
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * The serial EEPROM should have a checksum in the last word.&n;     * Keep a running checksum for all words read except for the&n;     * last word.  We&squot;ll verify the checksum after all words have&n;     * been read.&n;     */
r_if
c_cond
(paren
id|k
OL
(paren
id|len
op_minus
l_int|1
)paren
)paren
(brace
id|checksum
op_assign
id|checksum
op_plus
id|scarray
(braket
id|k
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;     * Reset the chip select for the next command cycle.&n;     */
id|outb
c_func
(paren
id|SEEMS
comma
id|p-&gt;base
op_plus
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SEEMS
op_or
id|SEECK
comma
id|p-&gt;base
op_plus
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SEEMS
comma
id|p-&gt;base
op_plus
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * Release access to the memory port and the serial EEPROM.&n;   */
id|release_seeprom
c_func
(paren
id|p
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;Computed checksum 0x%x, checksum read 0x%x&bslash;n&quot;
comma
id|checksum
comma
id|scarray
(braket
id|len
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Serial EEPROM:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|len
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|k
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|k
op_ne
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n              &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; 0x%x&quot;
comma
id|scarray
(braket
id|k
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|checksum
op_ne
id|scarray
(braket
id|len
op_minus
l_int|1
)braket
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
DECL|macro|CLOCK_PULSE
macro_line|#undef CLOCK_PULSE
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   write_brdctl&n; *&n; * Description:&n; *   Writes a value to the BRDCTL register.&n; *-F*************************************************************************/
r_static
r_inline
r_void
DECL|function|write_brdctl
id|write_brdctl
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
id|value
)paren
(brace
r_int
r_char
id|brdctl
suffix:semicolon
id|brdctl
op_assign
id|BRDCS
op_or
id|BRDSTB
suffix:semicolon
id|outb
c_func
(paren
id|brdctl
comma
id|p-&gt;base
op_plus
id|BRDCTL
)paren
suffix:semicolon
id|brdctl
op_or_assign
id|value
suffix:semicolon
id|outb
c_func
(paren
id|brdctl
comma
id|p-&gt;base
op_plus
id|BRDCTL
)paren
suffix:semicolon
id|brdctl
op_and_assign
op_complement
id|BRDSTB
suffix:semicolon
id|outb
c_func
(paren
id|brdctl
comma
id|p-&gt;base
op_plus
id|BRDCTL
)paren
suffix:semicolon
id|brdctl
op_and_assign
op_complement
id|BRDCS
suffix:semicolon
id|outb
c_func
(paren
id|brdctl
comma
id|p-&gt;base
op_plus
id|BRDCTL
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   read_brdctl&n; *&n; * Description:&n; *   Reads the BRDCTL register.&n; *-F*************************************************************************/
r_static
r_inline
r_int
r_char
DECL|function|read_brdctl
id|read_brdctl
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
id|outb
c_func
(paren
id|BRDRW
op_or
id|BRDCS
comma
id|p-&gt;base
op_plus
id|BRDCTL
)paren
suffix:semicolon
r_return
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|BRDCTL
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   configure_termination&n; *&n; * Description:&n; *   Configures the termination settings on PCI adapters that have&n; *   SEEPROMs available.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|configure_termination
id|configure_termination
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
op_star
id|sxfrctl1
comma
r_int
r_int
id|adapter_control
comma
r_int
r_char
id|max_targ
)paren
(brace
r_int
r_char
id|brdctl_int
comma
id|brdctl_ext
suffix:semicolon
r_int
id|internal50_present
suffix:semicolon
r_int
id|internal68_present
op_assign
l_int|0
suffix:semicolon
r_int
id|external_present
op_assign
l_int|0
suffix:semicolon
r_int
id|eprom_present
suffix:semicolon
r_int
id|high_on
suffix:semicolon
r_int
id|low_on
suffix:semicolon
r_int
id|old_verbose
suffix:semicolon
r_if
c_cond
(paren
id|acquire_seeprom
c_func
(paren
id|p
)paren
)paren
(brace
r_if
c_cond
(paren
id|adapter_control
op_amp
id|CFAUTOTERM
)paren
(brace
id|old_verbose
op_assign
id|aic7xxx_verbose
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Warning - detected auto-termination.  Please &quot;
l_string|&quot;verify driver&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;         detected settings and use manual termination &quot;
l_string|&quot;if necessary.&quot;
)paren
suffix:semicolon
multiline_comment|/* Configure auto termination. */
id|outb
c_func
(paren
id|SEECS
op_or
id|SEEMS
comma
id|p-&gt;base
op_plus
id|SEECTL
)paren
suffix:semicolon
multiline_comment|/*&n;       * First read the status of our cables.  Set the rom bank to&n;       * 0 since the bank setting serves as a multiplexor for the&n;       * cable detection logic.  BRDDAT5 controls the bank switch.&n;       */
id|write_brdctl
c_func
(paren
id|p
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;       * Now read the state of the internal connectors.  The&n;       * bits BRDDAT6 and BRDDAT7 are 0 when cables are present&n;       * set when cables are not present (BRDDAT6 is INT50 and&n;       * BRDDAT7 is INT68).&n;       */
id|brdctl_int
op_assign
id|read_brdctl
c_func
(paren
id|p
)paren
suffix:semicolon
id|internal50_present
op_assign
(paren
id|brdctl_int
op_amp
id|BRDDAT6
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|max_targ
OG
l_int|8
)paren
(brace
id|internal68_present
op_assign
(paren
id|brdctl_int
op_amp
id|BRDDAT7
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;       * Set the rom bank to 1 and determine&n;       * the other signals.&n;       */
id|write_brdctl
c_func
(paren
id|p
comma
id|BRDDAT5
)paren
suffix:semicolon
multiline_comment|/*&n;       * Now read the state of the external connectors.  BRDDAT6 is&n;       * 0 when an external cable is present, and BRDDAT7 (EPROMPS) is&n;       * set when the eprom is present.&n;       */
id|brdctl_ext
op_assign
id|read_brdctl
c_func
(paren
id|p
)paren
suffix:semicolon
id|external_present
op_assign
(paren
id|brdctl_ext
op_amp
id|BRDDAT6
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|eprom_present
op_assign
id|brdctl_ext
op_amp
id|BRDDAT7
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
(brace
r_if
c_cond
(paren
id|max_targ
OG
l_int|8
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Cables present (Int-50 %s, Int-68 %s, &quot;
l_string|&quot;Ext-68 %s)&bslash;n&quot;
comma
id|internal50_present
ques
c_cond
l_string|&quot;YES&quot;
suffix:colon
l_string|&quot;NO&quot;
comma
id|internal68_present
ques
c_cond
l_string|&quot;YES&quot;
suffix:colon
l_string|&quot;NO&quot;
comma
id|external_present
ques
c_cond
l_string|&quot;YES&quot;
suffix:colon
l_string|&quot;NO&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Cables present (Int-50 %s, Ext-50 %s)&bslash;n&quot;
comma
id|internal50_present
ques
c_cond
l_string|&quot;YES&quot;
suffix:colon
l_string|&quot;NO&quot;
comma
id|external_present
ques
c_cond
l_string|&quot;YES&quot;
suffix:colon
l_string|&quot;NO&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: eprom %s present, brdctl_int=0x%x, &quot;
l_string|&quot;brdctl_ext=0x%x&bslash;n&quot;
comma
id|eprom_present
ques
c_cond
l_string|&quot;is&quot;
suffix:colon
l_string|&quot;not&quot;
comma
id|brdctl_int
comma
id|brdctl_ext
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;       * Now set the termination based on what we found.  BRDDAT6&n;       * controls wide termination enable.&n;       */
id|high_on
op_assign
id|FALSE
suffix:semicolon
id|low_on
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|max_targ
OG
l_int|8
)paren
op_logical_and
(paren
(paren
id|external_present
op_eq
l_int|0
)paren
op_logical_or
(paren
id|internal68_present
op_eq
l_int|0
)paren
)paren
)paren
(brace
id|high_on
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|internal50_present
op_plus
id|internal68_present
op_plus
id|external_present
)paren
op_le
l_int|1
)paren
(brace
id|low_on
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|internal50_present
op_logical_and
id|internal68_present
op_logical_and
id|external_present
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: Illegal cable configuration!!&bslash;n&quot;
l_string|&quot;         Only two connectors on the adapter may be &quot;
l_string|&quot;used at a time!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|high_on
op_eq
id|TRUE
)paren
id|write_brdctl
c_func
(paren
id|p
comma
id|BRDDAT6
)paren
suffix:semicolon
r_else
id|write_brdctl
c_func
(paren
id|p
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|low_on
op_eq
id|TRUE
)paren
op_star
id|sxfrctl1
op_or_assign
id|STPWEN
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
(brace
r_if
c_cond
(paren
id|max_targ
OG
l_int|8
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Termination (Low %s, High %s)&bslash;n&quot;
comma
id|low_on
ques
c_cond
l_string|&quot;ON&quot;
suffix:colon
l_string|&quot;OFF&quot;
comma
id|high_on
ques
c_cond
l_string|&quot;ON&quot;
suffix:colon
l_string|&quot;OFF&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Termination %s&bslash;n&quot;
comma
id|low_on
ques
c_cond
l_string|&quot;ON&quot;
suffix:colon
l_string|&quot;OFF&quot;
)paren
suffix:semicolon
)brace
)brace
id|aic7xxx_verbose
op_assign
id|old_verbose
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|adapter_control
op_amp
id|CFSTERM
)paren
(brace
op_star
id|sxfrctl1
op_or_assign
id|STPWEN
suffix:semicolon
)brace
id|outb
c_func
(paren
id|SEEMS
op_or
id|SEECS
comma
id|p-&gt;base
op_plus
id|SEECTL
)paren
suffix:semicolon
multiline_comment|/*&n;       * Configure high byte termination.&n;       */
r_if
c_cond
(paren
id|adapter_control
op_amp
id|CFWSTERM
)paren
(brace
id|write_brdctl
c_func
(paren
id|p
comma
id|BRDDAT6
)paren
suffix:semicolon
)brace
r_else
(brace
id|write_brdctl
c_func
(paren
id|p
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Termination (Low %s, High %s)&bslash;n&quot;
comma
(paren
id|adapter_control
op_amp
id|CFSTERM
)paren
ques
c_cond
l_string|&quot;ON&quot;
suffix:colon
l_string|&quot;OFF&quot;
comma
(paren
id|adapter_control
op_amp
id|CFWSTERM
)paren
ques
c_cond
l_string|&quot;ON&quot;
suffix:colon
l_string|&quot;OFF&quot;
)paren
suffix:semicolon
)brace
)brace
id|release_seeprom
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   detect_maxscb&n; *&n; * Description:&n; *   Detects the maximum number of SCBs for the controller and returns&n; *   the count and a mask in p (p-&gt;maxscbs, p-&gt;qcntmask).&n; *-F*************************************************************************/
r_static
r_void
DECL|function|detect_maxscb
id|detect_maxscb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|max_scbid
op_assign
l_int|255
suffix:semicolon
multiline_comment|/*&n;   * It&squot;s possible that we&squot;ve already done this for multichannel&n;   * adapters.&n;   */
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;maxhscbs
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;     * We haven&squot;t initialized the SCB settings yet.  Walk the SCBs to&n;     * determince how many there are.&n;     */
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|FREE_SCBH
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AIC7XXX_MAXSCB
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
id|i
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|i
comma
id|p-&gt;base
op_plus
id|SCB_CONTROL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_CONTROL
)paren
op_ne
id|i
)paren
r_break
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_CONTROL
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|outb
c_func
(paren
id|i
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SCB_CONTROL
)paren
suffix:semicolon
multiline_comment|/* Clear the control byte. */
id|outb
c_func
(paren
id|i
op_plus
l_int|1
comma
id|p-&gt;base
op_plus
id|SCB_NEXT
)paren
suffix:semicolon
multiline_comment|/* Set the next pointer. */
id|outb
c_func
(paren
id|SCB_LIST_NULL
comma
id|p-&gt;base
op_plus
id|SCB_TAG
)paren
suffix:semicolon
multiline_comment|/* Make the tag invalid. */
multiline_comment|/* Make the non-tagged targets not busy. */
id|outb
c_func
(paren
id|SCB_LIST_NULL
comma
id|p-&gt;base
op_plus
id|SCB_BUSYTARGETS
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SCB_LIST_NULL
comma
id|p-&gt;base
op_plus
id|SCB_BUSYTARGETS
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SCB_LIST_NULL
comma
id|p-&gt;base
op_plus
id|SCB_BUSYTARGETS
op_plus
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SCB_LIST_NULL
comma
id|p-&gt;base
op_plus
id|SCB_BUSYTARGETS
op_plus
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/* Make sure the last SCB terminates the free list. */
id|outb
c_func
(paren
id|i
op_minus
l_int|1
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SCB_LIST_NULL
comma
id|p-&gt;base
op_plus
id|SCB_NEXT
)paren
suffix:semicolon
multiline_comment|/* Ensure we clear the first (0) SCBs control byte. */
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SCB_CONTROL
)paren
suffix:semicolon
id|p-&gt;scb_data-&gt;maxhscbs
op_assign
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|PAGE_ENABLED
)paren
op_logical_and
(paren
id|p-&gt;scb_data-&gt;maxhscbs
OL
id|AIC7XXX_MAXSCB
)paren
)paren
(brace
multiline_comment|/* Determine the number of valid bits in the FIFOs. */
id|outb
c_func
(paren
id|max_scbid
comma
id|p-&gt;base
op_plus
id|QINFIFO
)paren
suffix:semicolon
id|max_scbid
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|QINFIFO
)paren
suffix:semicolon
id|p-&gt;scb_data-&gt;maxscbs
op_assign
id|MIN
c_func
(paren
id|AIC7XXX_MAXSCB
comma
id|max_scbid
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;scb_data-&gt;maxscbs
op_assign
id|p-&gt;scb_data-&gt;maxhscbs
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;maxscbs
op_eq
id|p-&gt;scb_data-&gt;maxhscbs
)paren
(brace
multiline_comment|/*&n;     * Disable paging if the QINFIFO doesn&squot;t allow more SCBs than&n;     * we have in hardware.&n;     */
id|p-&gt;flags
op_and_assign
op_complement
id|PAGE_ENABLED
suffix:semicolon
)brace
multiline_comment|/*&n;   * Set the Queue Full Count.  Some cards have more queue space than&n;   * SCBs.&n;   */
r_switch
c_cond
(paren
id|p-&gt;chip_class
)paren
(brace
r_case
id|AIC_777x
suffix:colon
id|p-&gt;qfullcount
op_assign
l_int|4
suffix:semicolon
id|p-&gt;qcntmask
op_assign
l_int|0x07
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AIC_785x
suffix:colon
r_case
id|AIC_786x
suffix:colon
id|p-&gt;qfullcount
op_assign
l_int|8
suffix:semicolon
id|p-&gt;qcntmask
op_assign
l_int|0x0f
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AIC_787x
suffix:colon
r_case
id|AIC_788x
suffix:colon
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;maxhscbs
op_eq
id|AIC7XXX_MAXSCB
)paren
(brace
id|p-&gt;qfullcount
op_assign
id|AIC7XXX_MAXSCB
suffix:semicolon
id|p-&gt;qcntmask
op_assign
l_int|0xFF
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;qfullcount
op_assign
l_int|16
suffix:semicolon
id|p-&gt;qcntmask
op_assign
l_int|0x1F
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_register&n; *&n; * Description:&n; *   Register a Adaptec aic7xxx chip SCSI controller with the kernel.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_register
id|aic7xxx_register
c_func
(paren
id|Scsi_Host_Template
op_star
r_template
comma
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|sblkctl
comma
id|flags
op_assign
l_int|0
suffix:semicolon
r_int
id|max_targets
suffix:semicolon
r_int
id|found
op_assign
l_int|1
suffix:semicolon
r_char
id|channel_ids
(braket
)braket
op_assign
(brace
l_char|&squot;A&squot;
comma
l_char|&squot;B&squot;
comma
l_char|&squot;C&squot;
)brace
suffix:semicolon
r_int
r_char
id|target_settings
suffix:semicolon
r_int
r_char
id|scsi_conf
comma
id|sxfrctl1
suffix:semicolon
r_int
r_int
id|ultraenable
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
multiline_comment|/*&n;   * Lock out other contenders for our i/o space.&n;   */
id|request_region
c_func
(paren
id|p-&gt;base
comma
id|MAXREG
op_minus
id|MINREG
comma
l_string|&quot;aic7xxx&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;   * Read the bus type from the SBLKCTL register. Set the FLAGS&n;   * register in the sequencer for twin and wide bus cards.&n;   */
id|sblkctl
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SBLKCTL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|PAGE_ENABLED
)paren
id|flags
op_assign
id|PAGESCBS
suffix:semicolon
r_switch
c_cond
(paren
id|sblkctl
op_amp
id|SELBUS_MASK
)paren
(brace
r_case
id|SELNARROW
suffix:colon
multiline_comment|/* narrow/normal bus */
id|p-&gt;scsi_id
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCSICONF
)paren
op_amp
l_int|0x07
suffix:semicolon
id|p-&gt;bus_type
op_assign
id|AIC_SINGLE
suffix:semicolon
id|p-&gt;flags
op_and_assign
op_complement
id|FLAGS_CHANNEL_B_PRIMARY
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|MULTI_CHANNEL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Channel %c, SCSI ID %d, &quot;
comma
id|channel_ids
(braket
id|p-&gt;chan_num
)braket
comma
id|p-&gt;scsi_id
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Single Channel, SCSI ID %d, &quot;
comma
id|p-&gt;scsi_id
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|flags
op_or
id|SINGLE_BUS
comma
id|p-&gt;base
op_plus
id|SEQ_FLAGS
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SELWIDE
suffix:colon
multiline_comment|/* Wide bus */
id|p-&gt;scsi_id
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCSICONF
op_plus
l_int|1
)paren
op_amp
id|HWSCSIID
suffix:semicolon
id|p-&gt;bus_type
op_assign
id|AIC_WIDE
suffix:semicolon
id|p-&gt;flags
op_and_assign
op_complement
id|FLAGS_CHANNEL_B_PRIMARY
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|MULTI_CHANNEL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Wide Channel %c, SCSI ID %d, &quot;
comma
id|channel_ids
(braket
id|p-&gt;chan_num
)braket
comma
id|p-&gt;scsi_id
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Wide Channel, SCSI ID %d, &quot;
comma
id|p-&gt;scsi_id
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|flags
op_or
id|WIDE_BUS
comma
id|p-&gt;base
op_plus
id|SEQ_FLAGS
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SELBUSB
suffix:colon
multiline_comment|/* Twin bus */
id|p-&gt;scsi_id
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCSICONF
)paren
op_amp
id|HSCSIID
suffix:semicolon
id|p-&gt;scsi_id_b
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCSICONF
op_plus
l_int|1
)paren
op_amp
id|HSCSIID
suffix:semicolon
id|p-&gt;bus_type
op_assign
id|AIC_TWIN
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Twin Channel, A SCSI ID %d, B SCSI ID %d, &quot;
comma
id|p-&gt;scsi_id
comma
id|p-&gt;scsi_id_b
)paren
suffix:semicolon
id|outb
c_func
(paren
id|flags
op_or
id|TWIN_BUS
comma
id|p-&gt;base
op_plus
id|SEQ_FLAGS
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: Unsupported type 0x%x, please &quot;
l_string|&quot;mail deang@teleport.com&bslash;n&quot;
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SBLKCTL
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|SEQ_FLAGS
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * Detect SCB parameters and initialize the SCB array.&n;   */
id|detect_maxscb
c_func
(paren
id|p
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d/%d SCBs, QFull %d, QMask 0x%x&bslash;n&quot;
comma
id|p-&gt;scb_data-&gt;maxhscbs
comma
id|p-&gt;scb_data-&gt;maxscbs
comma
id|p-&gt;qfullcount
comma
id|p-&gt;qcntmask
)paren
suffix:semicolon
id|host
op_assign
id|p-&gt;host
suffix:semicolon
id|host-&gt;can_queue
op_assign
id|p-&gt;scb_data-&gt;maxscbs
suffix:semicolon
id|host-&gt;cmd_per_lun
op_assign
l_int|2
suffix:semicolon
id|host-&gt;sg_tablesize
op_assign
id|AIC7XXX_MAX_SG
suffix:semicolon
id|host-&gt;select_queue_depths
op_assign
id|aic7xxx_select_queue_depth
suffix:semicolon
id|host-&gt;this_id
op_assign
id|p-&gt;scsi_id
suffix:semicolon
id|host-&gt;io_port
op_assign
id|p-&gt;base
suffix:semicolon
id|host-&gt;n_io_port
op_assign
l_int|0xFF
suffix:semicolon
id|host-&gt;base
op_assign
(paren
r_int
r_char
op_star
)paren
id|p-&gt;mbase
suffix:semicolon
id|host-&gt;irq
op_assign
id|p-&gt;irq
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;bus_type
op_eq
id|AIC_WIDE
)paren
(brace
id|host-&gt;max_id
op_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;bus_type
op_eq
id|AIC_TWIN
)paren
(brace
id|host-&gt;max_channel
op_assign
l_int|1
suffix:semicolon
)brace
id|p-&gt;host
op_assign
id|host
suffix:semicolon
id|p-&gt;host_no
op_assign
id|host-&gt;host_no
suffix:semicolon
id|p-&gt;isr_count
op_assign
l_int|0
suffix:semicolon
id|p-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;completeq.head
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;completeq.tail
op_assign
l_int|NULL
suffix:semicolon
id|scbq_init
c_func
(paren
op_amp
id|p-&gt;scb_data-&gt;free_scbs
)paren
suffix:semicolon
id|scbq_init
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|NUMBER
c_func
(paren
id|p-&gt;device_status
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|p-&gt;device_status
(braket
id|i
)braket
dot
id|commands_sent
op_assign
l_int|0
suffix:semicolon
id|p-&gt;device_status
(braket
id|i
)braket
dot
id|flags
op_assign
l_int|0
suffix:semicolon
id|p-&gt;device_status
(braket
id|i
)braket
dot
id|active_cmds
op_assign
l_int|0
suffix:semicolon
id|p-&gt;device_status
(braket
id|i
)braket
dot
id|last_reset
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_boards
(braket
id|p-&gt;irq
)braket
op_eq
l_int|NULL
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|irq_flags
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef AIC7XXX_OLD_ISR_TYPE
id|irg_flags
op_assign
id|SA_INTERRUPT
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;     * Warning! This must be done before requesting the irq.  It is&n;     * possible for some boards to raise an interrupt as soon as&n;     * they are enabled.  So when we request the irq from the Linux&n;     * kernel, an interrupt is triggered immediately.  Therefore, we&n;     * must ensure the board data is correctly set before the request.&n;     */
id|aic7xxx_boards
(braket
id|p-&gt;irq
)braket
op_assign
id|host
suffix:semicolon
multiline_comment|/*&n;     * Register IRQ with the kernel.  Only allow sharing IRQs with&n;     * PCI devices.&n;     */
r_if
c_cond
(paren
id|p-&gt;chip_class
op_eq
id|AIC_777x
)paren
(brace
id|result
op_assign
(paren
id|request_irq
c_func
(paren
id|p-&gt;irq
comma
id|aic7xxx_isr
comma
id|irq_flags
comma
l_string|&quot;aic7xxx&quot;
comma
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
(paren
id|request_irq
c_func
(paren
id|p-&gt;irq
comma
id|aic7xxx_isr
comma
id|irq_flags
op_or
id|SA_SHIRQ
comma
l_string|&quot;aic7xxx&quot;
comma
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: Couldn&squot;t register IRQ %d, ignoring.&bslash;n&quot;
comma
id|p-&gt;irq
)paren
suffix:semicolon
id|aic7xxx_boards
(braket
id|p-&gt;irq
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;     * We have found a host adapter sharing an IRQ of a previously&n;     * registered host adapter. Add this host adapter&squot;s Scsi_Host&n;     * to the beginning of the linked list of hosts at the same IRQ.&n;     */
id|p-&gt;next
op_assign
id|aic7xxx_boards
(braket
id|p-&gt;irq
)braket
suffix:semicolon
id|aic7xxx_boards
(braket
id|p-&gt;irq
)braket
op_assign
id|host
suffix:semicolon
)brace
multiline_comment|/*&n;   * Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1, for both channels&n;   */
r_if
c_cond
(paren
id|p-&gt;bus_type
op_eq
id|AIC_TWIN
)paren
(brace
multiline_comment|/*&n;     * The controller is gated to channel B after a chip reset; set&n;     * bus B values first.&n;     */
id|outb
c_func
(paren
id|p-&gt;scsi_id_b
comma
id|p-&gt;base
op_plus
id|SCSIID
)paren
suffix:semicolon
id|scsi_conf
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCSICONF
op_plus
l_int|1
)paren
suffix:semicolon
id|sxfrctl1
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SXFRCTL1
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|scsi_conf
op_amp
(paren
id|ENSPCHK
op_or
id|STIMESEL
)paren
)paren
op_or
(paren
id|sxfrctl1
op_amp
id|STPWEN
)paren
op_or
id|ENSTIMER
op_or
id|ACTNEGEN
comma
id|p-&gt;base
op_plus
id|SXFRCTL1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ENSELTIMO
op_or
id|ENSCSIRST
op_or
id|ENSCSIPERR
comma
id|p-&gt;base
op_plus
id|SIMODE1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|ULTRA_ENABLED
)paren
(brace
id|outb
c_func
(paren
id|DFON
op_or
id|SPIOEN
op_or
id|FAST20
comma
id|p-&gt;base
op_plus
id|SXFRCTL0
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
id|DFON
op_or
id|SPIOEN
comma
id|p-&gt;base
op_plus
id|SXFRCTL0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|scsi_conf
op_amp
id|RESET_SCSI
)paren
op_logical_and
(paren
id|aic7xxx_no_reset
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* Reset SCSI bus B. */
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Resetting channel B&bslash;n&quot;
)paren
suffix:semicolon
id|aic7xxx_reset_current_bus
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/* Select channel A */
id|outb
c_func
(paren
id|SELNARROW
comma
id|p-&gt;base
op_plus
id|SBLKCTL
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|p-&gt;scsi_id
comma
id|p-&gt;base
op_plus
id|SCSIID
)paren
suffix:semicolon
id|scsi_conf
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCSICONF
)paren
suffix:semicolon
id|sxfrctl1
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SXFRCTL1
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|scsi_conf
op_amp
(paren
id|ENSPCHK
op_or
id|STIMESEL
)paren
)paren
op_or
(paren
id|sxfrctl1
op_amp
id|STPWEN
)paren
op_or
id|ENSTIMER
op_or
id|ACTNEGEN
comma
id|p-&gt;base
op_plus
id|SXFRCTL1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ENSELTIMO
op_or
id|ENSCSIRST
op_or
id|ENSCSIPERR
comma
id|p-&gt;base
op_plus
id|SIMODE1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|ULTRA_ENABLED
)paren
(brace
id|outb
c_func
(paren
id|DFON
op_or
id|SPIOEN
op_or
id|FAST20
comma
id|p-&gt;base
op_plus
id|SXFRCTL0
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
id|DFON
op_or
id|SPIOEN
comma
id|p-&gt;base
op_plus
id|SXFRCTL0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|scsi_conf
op_amp
id|RESET_SCSI
)paren
op_logical_and
(paren
id|aic7xxx_no_reset
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* Reset SCSI bus A. */
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Resetting channel A&bslash;n&quot;
)paren
suffix:semicolon
id|aic7xxx_reset_current_bus
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;     * Delay for the reset delay.&n;     */
id|aic7xxx_delay
c_func
(paren
id|AIC7XXX_RESET_DELAY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * Look at the information that board initialization or the board&n;   * BIOS has left us. In the lower four bits of each target&squot;s&n;   * scratch space any value other than 0 indicates that we should&n;   * initiate synchronous transfers. If it&squot;s zero, the user or the&n;   * BIOS has decided to disable synchronous negotiation to that&n;   * target so we don&squot;t activate the needsdtr flag.&n;   */
id|p-&gt;needsdtr_copy
op_assign
l_int|0x0
suffix:semicolon
id|p-&gt;sdtr_pending
op_assign
l_int|0x0
suffix:semicolon
id|p-&gt;needwdtr_copy
op_assign
l_int|0x0
suffix:semicolon
id|p-&gt;wdtr_pending
op_assign
l_int|0x0
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;bus_type
op_eq
id|AIC_SINGLE
)paren
(brace
id|max_targets
op_assign
l_int|8
suffix:semicolon
)brace
r_else
(brace
id|max_targets
op_assign
l_int|16
suffix:semicolon
)brace
multiline_comment|/*&n;   * Grab the disconnection disable table and invert it for our needs&n;   */
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|USE_DEFAULTS
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Host adapter BIOS disabled. Using default SCSI &quot;
l_string|&quot;device parameters.&bslash;n&quot;
)paren
suffix:semicolon
id|p-&gt;discenable
op_assign
l_int|0xFFFF
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;discenable
op_assign
op_complement
(paren
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|DISC_DSB
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|DISC_DSB
)paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_targets
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|USE_DEFAULTS
)paren
(brace
id|target_settings
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 10 or 20 MHz depending on Ultra enable */
id|p-&gt;needsdtr_copy
op_or_assign
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
id|p-&gt;needwdtr_copy
op_or_assign
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;chip_class
op_eq
id|AIC_786x
)paren
op_logical_or
(paren
id|p-&gt;chip_class
op_eq
id|AIC_788x
)paren
)paren
id|ultraenable
op_or_assign
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
)brace
r_else
(brace
id|target_settings
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|TARG_SCRATCH
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target_settings
op_amp
l_int|0x0F
)paren
(brace
id|p-&gt;needsdtr_copy
op_or_assign
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
multiline_comment|/*&n;         * Default to asynchronous transfers (0 offset)&n;         */
id|target_settings
op_and_assign
l_int|0xF0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|target_settings
op_amp
l_int|0x80
)paren
(brace
id|p-&gt;needwdtr_copy
op_or_assign
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
multiline_comment|/*&n;         * Clear the wide flag. When wide negotiation is successful,&n;         * we&squot;ll enable it.&n;         */
id|target_settings
op_and_assign
l_int|0x7F
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|ULTRA_ENABLED
)paren
(brace
r_switch
c_cond
(paren
id|target_settings
op_amp
l_int|0x70
)paren
(brace
r_case
l_int|0x00
suffix:colon
r_case
l_int|0x10
suffix:colon
r_case
l_int|0x20
suffix:colon
id|ultraenable
op_or_assign
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
multiline_comment|/* treat 10MHz as 10MHz without Ultra enabled */
id|target_settings
op_and_assign
op_complement
(paren
l_int|0x70
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
)brace
id|outb
c_func
(paren
id|target_settings
comma
id|p-&gt;base
op_plus
id|TARG_SCRATCH
op_plus
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * If we are not wide, forget WDTR. This makes the driver&n;   * work on some cards that don&squot;t leave these fields cleared&n;   * when BIOS is not installed.&n;   */
r_if
c_cond
(paren
id|p-&gt;bus_type
op_ne
id|AIC_WIDE
)paren
(brace
id|p-&gt;needwdtr_copy
op_assign
l_int|0
suffix:semicolon
)brace
id|p-&gt;needsdtr
op_assign
id|p-&gt;needsdtr_copy
suffix:semicolon
id|p-&gt;needwdtr
op_assign
id|p-&gt;needwdtr_copy
suffix:semicolon
id|p-&gt;orderedtag
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
id|ultraenable
op_amp
l_int|0xFF
comma
id|p-&gt;base
op_plus
id|ULTRA_ENB
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|ultraenable
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
comma
id|p-&gt;base
op_plus
id|ULTRA_ENB
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;   * Set the number of available hardware SCBs.&n;   */
id|outb
c_func
(paren
id|p-&gt;scb_data-&gt;maxhscbs
comma
id|p-&gt;base
op_plus
id|SCBCOUNT
)paren
suffix:semicolon
multiline_comment|/*&n;   * 2s compliment of maximum tag value.&n;   */
id|i
op_assign
id|p-&gt;scb_data-&gt;maxscbs
suffix:semicolon
id|outb
c_func
(paren
op_minus
id|i
op_amp
l_int|0xFF
comma
id|p-&gt;base
op_plus
id|COMP_SCBCOUNT
)paren
suffix:semicolon
multiline_comment|/*&n;   * Allocate enough hardware scbs to handle the maximum number of&n;   * concurrent transactions we can have.  We have to make sure that&n;   * the allocated memory is contiguous memory.  The Linux kmalloc&n;   * routine should only allocate contiguous memory, but note that&n;   * this could be a problem if kmalloc() is changed.&n;   */
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;hscbs
op_eq
l_int|NULL
)paren
(brace
r_int
id|array_size
suffix:semicolon
r_int
r_int
id|hscb_physaddr
suffix:semicolon
id|array_size
op_assign
id|p-&gt;scb_data-&gt;maxscbs
op_star
r_sizeof
(paren
r_struct
id|aic7xxx_hwscb
)paren
suffix:semicolon
id|p-&gt;scb_data-&gt;hscbs
op_assign
id|kmalloc
c_func
(paren
id|array_size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;hscbs
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Unable to allocate hardware SCB array; &quot;
l_string|&quot;failing detection.&bslash;n&quot;
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|p-&gt;base
comma
id|MAXREG
op_minus
id|MINREG
)paren
suffix:semicolon
multiline_comment|/*&n;       * Ensure that we only free the IRQ when there is _not_ another&n;       * aic7xxx adapter sharing this IRQ.  The adapters are always&n;       * added to the beginning of the list, so we can grab the next&n;       * pointer and place it back in the board array.&n;       */
r_if
c_cond
(paren
id|p-&gt;next
op_eq
l_int|NULL
)paren
(brace
id|free_irq
c_func
(paren
id|p-&gt;irq
comma
id|aic7xxx_isr
)paren
suffix:semicolon
)brace
id|aic7xxx_boards
(braket
id|p-&gt;irq
)braket
op_assign
id|p-&gt;next
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* At least the control byte of each SCB needs to be 0. */
id|memset
c_func
(paren
id|p-&gt;scb_data-&gt;hscbs
comma
l_int|0
comma
id|array_size
)paren
suffix:semicolon
multiline_comment|/* Tell the sequencer where it can find the hardware SCB array. */
id|hscb_physaddr
op_assign
id|VIRT_TO_BUS
c_func
(paren
id|p-&gt;scb_data-&gt;hscbs
)paren
suffix:semicolon
id|outb
c_func
(paren
id|hscb_physaddr
op_amp
l_int|0xFF
comma
id|p-&gt;base
op_plus
id|HSCB_ADDR
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|hscb_physaddr
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
comma
id|p-&gt;base
op_plus
id|HSCB_ADDR
op_plus
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|hscb_physaddr
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
comma
id|p-&gt;base
op_plus
id|HSCB_ADDR
op_plus
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|hscb_physaddr
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
comma
id|p-&gt;base
op_plus
id|HSCB_ADDR
op_plus
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * QCount mask to deal with broken aic7850s that sporadically get&n;   * garbage in the upper bits of their QCNT registers.&n;    */
id|outb
c_func
(paren
id|p-&gt;qcntmask
comma
id|p-&gt;base
op_plus
id|QCNTMASK
)paren
suffix:semicolon
multiline_comment|/*&n;   * We don&squot;t have any waiting selections or disconnected SCBs.&n;   */
id|outb
c_func
(paren
id|SCB_LIST_NULL
comma
id|p-&gt;base
op_plus
id|WAITING_SCBH
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SCB_LIST_NULL
comma
id|p-&gt;base
op_plus
id|DISCONNECTED_SCBH
)paren
suffix:semicolon
multiline_comment|/*&n;   * Message out buffer starts empty&n;   */
id|outb
c_func
(paren
l_int|0
comma
id|p-&gt;base
op_plus
id|MSG_LEN
)paren
suffix:semicolon
multiline_comment|/*&n;   * Load the sequencer program, then re-enable the board -&n;   * resetting the AIC-7770 disables it, leaving the lights&n;   * on with nobody home. On the PCI bus you *may* be home,&n;   * but then your mailing address is dynamically assigned&n;   * so no one can find you anyway :-)&n;   */
id|aic7xxx_loadseq
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;chip_class
op_eq
id|AIC_777x
)paren
(brace
id|outb
c_func
(paren
id|ENABLE
comma
id|p-&gt;base
op_plus
id|BCTL
)paren
suffix:semicolon
multiline_comment|/* Enable the boards BUS drivers. */
)brace
multiline_comment|/*&n;   * Unpause the sequencer before returning and enable&n;   * interrupts - we shouldn&squot;t get any until the first&n;   * command is sent to us by the high-level SCSI code.&n;   */
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/* unpause_always */
id|TRUE
)paren
suffix:semicolon
r_return
(paren
id|found
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_chip_reset&n; *&n; * Description:&n; *   Perform a chip reset on the aic7xxx SCSI controller.  The controller&n; *   is paused upon return.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_chip_reset
id|aic7xxx_chip_reset
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_int
r_char
id|hcntrl
suffix:semicolon
r_int
id|wait
suffix:semicolon
multiline_comment|/* Retain the IRQ type across the chip reset. */
id|hcntrl
op_assign
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|HCNTRL
)paren
op_amp
id|IRQMS
)paren
op_or
id|INTEN
suffix:semicolon
multiline_comment|/*&n;   * For some 274x boards, we must clear the CHIPRST bit and pause&n;   * the sequencer. For some reason, this makes the driver work.&n;   */
id|outb
c_func
(paren
id|PAUSE
op_or
id|CHIPRST
comma
id|p-&gt;base
op_plus
id|HCNTRL
)paren
suffix:semicolon
multiline_comment|/*&n;   * In the future, we may call this function as a last resort for&n;   * error handling.  Let&squot;s be nice and not do any unecessary delays.&n;   */
id|wait
op_assign
l_int|1000
suffix:semicolon
multiline_comment|/* 1 second (1000 * 1000 usec) */
r_while
c_loop
(paren
(paren
id|wait
OG
l_int|0
)paren
op_logical_and
(paren
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|HCNTRL
)paren
op_amp
id|CHIPRSTACK
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* 1 msec = 1000 usec */
id|wait
op_assign
id|wait
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|HCNTRL
)paren
op_amp
id|CHIPRSTACK
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Chip reset not cleared; clearing manually.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|hcntrl
op_or
id|PAUSE
comma
id|p-&gt;base
op_plus
id|HCNTRL
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_alloc&n; *&n; * Description:&n; *   Allocate and initialize a host structure.  Returns NULL upon error&n; *   and a pointer to a aic7xxx_host struct upon success.&n; *-F*************************************************************************/
r_static
r_struct
id|aic7xxx_host
op_star
DECL|function|aic7xxx_alloc
id|aic7xxx_alloc
c_func
(paren
id|Scsi_Host_Template
op_star
id|sht
comma
r_int
r_int
id|base
comma
r_int
r_int
id|mbase
comma
id|aha_chip_type
id|chip_type
comma
r_int
id|flags
comma
id|scb_data_type
op_star
id|scb_data
)paren
(brace
r_struct
id|aic7xxx_host
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
multiline_comment|/*&n;   * Allocate a storage area by registering us with the mid-level&n;   * SCSI layer.&n;   */
id|host
op_assign
id|scsi_register
c_func
(paren
id|sht
comma
r_sizeof
(paren
r_struct
id|aic7xxx_host
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host
op_ne
l_int|NULL
)paren
(brace
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|aic7xxx_host
)paren
)paren
suffix:semicolon
id|p-&gt;host
op_assign
id|host
suffix:semicolon
r_if
c_cond
(paren
id|scb_data
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;       * We are sharing SCB data areas; use the SCB data pointer&n;       * provided.&n;       */
id|p-&gt;scb_data
op_assign
id|scb_data
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|SHARED_SCBDATA
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;       * We are not sharing SCB data; allocate one.&n;       */
id|p-&gt;scb_data
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|scb_data_type
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;scb_data
op_ne
l_int|NULL
)paren
(brace
id|memset
c_func
(paren
id|p-&gt;scb_data
comma
l_int|0
comma
r_sizeof
(paren
id|scb_data_type
)paren
)paren
suffix:semicolon
id|scbq_init
(paren
op_amp
id|p-&gt;scb_data-&gt;free_scbs
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;         * For some reason we don&squot;t have enough memory.  Free the&n;         * allocated memory for the aic7xxx_host struct, and return NULL.&n;         */
id|scsi_unregister
c_func
(paren
id|host
)paren
suffix:semicolon
id|p
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|p
op_ne
l_int|NULL
)paren
(brace
id|p-&gt;host_no
op_assign
id|host-&gt;host_no
suffix:semicolon
id|p-&gt;base
op_assign
id|base
suffix:semicolon
id|p-&gt;mbase
op_assign
id|mbase
suffix:semicolon
id|p-&gt;maddr
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;flags
op_assign
id|flags
suffix:semicolon
id|p-&gt;chip_type
op_assign
id|chip_type
suffix:semicolon
id|p-&gt;unpause
op_assign
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|HCNTRL
)paren
op_amp
id|IRQMS
)paren
op_or
id|INTEN
suffix:semicolon
id|p-&gt;pause
op_assign
id|p-&gt;unpause
op_or
id|PAUSE
suffix:semicolon
)brace
)brace
r_return
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_free&n; *&n; * Description:&n; *   Frees and releases all resources associated with an instance of&n; *   the driver (struct aic7xxx_host *).&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_free
id|aic7xxx_free
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;   * We should be careful in freeing the scb_data area.  For those&n;   * adapters sharing external SCB RAM(398x), there will be only one&n;   * scb_data area allocated.  The flag SHARED_SCBDATA indicates if&n;   * one adapter is sharing anothers SCB RAM.&n;   */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|SHARED_SCBDATA
)paren
)paren
(brace
multiline_comment|/*&n;     * Free the allocated hardware SCB space.&n;     */
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;hscbs
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|p-&gt;scb_data-&gt;hscbs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Free the driver SCBs.  These were allocated on an as-need&n;     * basis.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;scb_data-&gt;numscbs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kfree
c_func
(paren
id|p-&gt;scb_data-&gt;scb_array
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Free the hardware SCBs.&n;     */
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;hscbs
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|p-&gt;scb_data-&gt;hscbs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Free the SCB data area.&n;     */
id|kfree
c_func
(paren
id|p-&gt;scb_data
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * Free the instance of the device structure.&n;   */
id|scsi_unregister
c_func
(paren
id|p-&gt;host
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_load_seeprom&n; *&n; * Description:&n; *   Load the seeprom and configure adapter and target settings.&n; *   Returns 1 if the load was successful and 0 otherwise.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|load_seeprom
id|load_seeprom
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
op_star
id|sxfrctl1
)paren
(brace
r_int
id|have_seeprom
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|max_targets
suffix:semicolon
r_int
r_char
id|target_settings
comma
id|scsi_conf
suffix:semicolon
r_int
r_int
id|scarray
(braket
l_int|128
)braket
suffix:semicolon
r_struct
id|seeprom_config
op_star
id|sc
op_assign
(paren
r_struct
id|seeprom_config
op_star
)paren
id|scarray
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Loading serial EEPROM...&quot;
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|p-&gt;chip_type
)paren
(brace
r_case
id|AIC_7770
suffix:colon
multiline_comment|/* None of these adapters have seeproms. */
r_case
id|AIC_7771
suffix:colon
r_case
id|AIC_7850
suffix:colon
r_case
id|AIC_7855
suffix:colon
r_break
suffix:semicolon
r_case
id|AIC_284x
suffix:colon
id|have_seeprom
op_assign
id|read_284x_seeprom
c_func
(paren
id|p
comma
(paren
r_struct
id|seeprom_config
op_star
)paren
id|scarray
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AIC_7861
suffix:colon
r_case
id|AIC_7870
suffix:colon
r_case
id|AIC_7871
suffix:colon
r_case
id|AIC_7872
suffix:colon
r_case
id|AIC_7874
suffix:colon
r_case
id|AIC_7881
suffix:colon
r_case
id|AIC_7882
suffix:colon
r_case
id|AIC_7884
suffix:colon
id|have_seeprom
op_assign
id|read_seeprom
c_func
(paren
id|p
comma
id|p-&gt;chan_num
op_star
(paren
r_sizeof
(paren
op_star
id|sc
)paren
op_div
l_int|2
)paren
comma
id|scarray
comma
r_sizeof
(paren
op_star
id|sc
)paren
op_div
l_int|2
comma
id|C46
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AIC_7860
suffix:colon
multiline_comment|/* Motherboard Ultra controllers might have RAID port. */
r_case
id|AIC_7880
suffix:colon
id|have_seeprom
op_assign
id|read_seeprom
c_func
(paren
id|p
comma
l_int|0
comma
id|scarray
comma
r_sizeof
(paren
op_star
id|sc
)paren
op_div
l_int|2
comma
id|C46
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|have_seeprom
)paren
(brace
id|have_seeprom
op_assign
id|read_seeprom
c_func
(paren
id|p
comma
l_int|0
comma
id|scarray
comma
r_sizeof
(paren
id|scarray
)paren
op_div
l_int|2
comma
id|C56_66
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AIC_7873
suffix:colon
multiline_comment|/* The 3985 adapters use the 93c56 serial EEPROM. */
r_case
id|AIC_7883
suffix:colon
id|have_seeprom
op_assign
id|read_seeprom
c_func
(paren
id|p
comma
id|p-&gt;chan_num
op_star
(paren
r_sizeof
(paren
op_star
id|sc
)paren
op_div
l_int|2
)paren
comma
id|scarray
comma
r_sizeof
(paren
id|scarray
)paren
op_div
l_int|2
comma
id|C56_66
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|have_seeprom
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;naic7xxx: No SEEPROM available; using defaults.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|p-&gt;flags
op_or_assign
id|USE_DEFAULTS
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;done&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|p-&gt;flags
op_or_assign
id|HAVE_SEEPROM
suffix:semicolon
multiline_comment|/*&n;     * Update the settings in sxfrctl1 to match the termination settings.&n;     */
op_star
id|sxfrctl1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * First process the settings that are different between the VLB&n;     * and PCI adapter seeproms.&n;     */
r_if
c_cond
(paren
id|p-&gt;chip_class
op_eq
id|AIC_777x
)paren
(brace
multiline_comment|/* VLB adapter seeproms */
r_if
c_cond
(paren
id|sc-&gt;bios_control
op_amp
id|CF284XEXTEND
)paren
id|p-&gt;flags
op_or_assign
id|EXTENDED_TRANSLATION
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;adapter_control
op_amp
id|CF284XSTERM
)paren
op_star
id|sxfrctl1
op_or_assign
id|STPWEN
suffix:semicolon
multiline_comment|/*&n;       * The 284x SEEPROM doesn&squot;t have a max targets field.  We&n;       * set it to 16 to make sure we take care of the 284x-wide&n;       * adapters.  For narrow adapters, going through the extra&n;       * 8 target entries will not cause any harm since they will&n;       * will not be used.&n;       *&n;       * XXX - We should probably break out the bus detection&n;       *       from the register function so we can use it here&n;       *       to tell us how many targets there really are.&n;       */
id|max_targets
op_assign
l_int|16
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* PCI adapter seeproms */
r_if
c_cond
(paren
id|sc-&gt;bios_control
op_amp
id|CFEXTEND
)paren
id|p-&gt;flags
op_or_assign
id|EXTENDED_TRANSLATION
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;adapter_control
op_amp
id|CFSTERM
)paren
op_star
id|sxfrctl1
op_or_assign
id|STPWEN
suffix:semicolon
multiline_comment|/* Limit to 16 targets just in case. */
id|max_targets
op_assign
id|MIN
c_func
(paren
id|sc-&gt;max_targets
op_amp
id|CFMAXTARG
comma
l_int|16
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_targets
suffix:semicolon
id|i
op_increment
)paren
(brace
id|target_settings
op_assign
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFXFER
)paren
op_lshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFSYNCH
)paren
id|target_settings
op_or_assign
id|SOFS
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFWIDEB
)paren
id|target_settings
op_or_assign
id|WIDEXFER
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFDISC
)paren
id|p-&gt;discenable
op_or_assign
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
id|outb
c_func
(paren
id|target_settings
comma
id|p-&gt;base
op_plus
id|TARG_SCRATCH
op_plus
id|i
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
op_complement
(paren
id|p-&gt;discenable
op_amp
l_int|0xFF
)paren
comma
id|p-&gt;base
op_plus
id|DISC_DSB
)paren
suffix:semicolon
id|outb
c_func
(paren
op_complement
(paren
(paren
id|p-&gt;discenable
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
)paren
comma
id|p-&gt;base
op_plus
id|DISC_DSB
op_plus
l_int|1
)paren
suffix:semicolon
id|p-&gt;scsi_id
op_assign
id|sc-&gt;brtime_id
op_amp
id|CFSCSIID
suffix:semicolon
id|scsi_conf
op_assign
(paren
id|p-&gt;scsi_id
op_amp
l_int|0x7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;adapter_control
op_amp
id|CFSPARITY
)paren
id|scsi_conf
op_or_assign
id|ENSPCHK
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;adapter_control
op_amp
id|CFRESETB
)paren
id|scsi_conf
op_or_assign
id|RESET_SCSI
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;chip_class
op_eq
id|AIC_786x
)paren
op_logical_or
(paren
id|p-&gt;chip_class
op_eq
id|AIC_788x
)paren
)paren
(brace
multiline_comment|/*&n;       * We allow the operator to override ultra enable through&n;       * the boot prompt.&n;       */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sc-&gt;adapter_control
op_amp
id|CFULTRAEN
)paren
op_logical_and
(paren
id|aic7xxx_enable_ultra
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* Treat us as a non-ultra card */
id|p-&gt;flags
op_and_assign
op_complement
id|ULTRA_ENABLED
suffix:semicolon
)brace
)brace
multiline_comment|/* Set the host ID */
id|outb
c_func
(paren
id|scsi_conf
comma
id|p-&gt;base
op_plus
id|SCSICONF
)paren
suffix:semicolon
multiline_comment|/* In case we are a wide card */
id|outb
c_func
(paren
id|p-&gt;scsi_id
comma
id|p-&gt;base
op_plus
id|SCSICONF
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;chip_class
op_ne
id|AIC_777x
)paren
(brace
multiline_comment|/*&n;       * Update the settings in sxfrctl1 to match the termination&n;       * settings.&n;       */
op_star
id|sxfrctl1
op_assign
l_int|0
suffix:semicolon
id|configure_termination
c_func
(paren
id|p
comma
id|sxfrctl1
comma
id|sc-&gt;adapter_control
comma
(paren
r_int
r_char
)paren
id|sc-&gt;max_targets
op_amp
id|CFMAXTARG
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|have_seeprom
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_detect&n; *&n; * Description:&n; *   Try to detect and register an Adaptec 7770 or 7870 SCSI controller.&n; *&n; * XXX - This should really be called aic7xxx_probe().  A sequence of&n; *       probe(), attach()/detach(), and init() makes more sense than&n; *       one do-it-all function.  This may be useful when (and if) the&n; *       mid-level SCSI code is overhauled.&n; *-F*************************************************************************/
r_int
DECL|function|aic7xxx_detect
id|aic7xxx_detect
c_func
(paren
id|Scsi_Host_Template
op_star
r_template
)paren
(brace
r_int
id|found
op_assign
l_int|0
suffix:semicolon
id|aha_status_type
id|adapter_bios
suffix:semicolon
id|aha_chip_class_type
id|chip_class
suffix:semicolon
id|aha_chip_type
id|chip_type
suffix:semicolon
r_int
id|slot
comma
id|base
suffix:semicolon
r_int
id|chan_num
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|hcntrl
comma
id|sxfrctl1
comma
id|sblkctl
comma
id|hostconf
comma
id|irq
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
multiline_comment|/*&n;   * Since we may allow sharing of IRQs, it is imperative&n;   * that we &quot;null-out&quot; the aic7xxx_boards array. It is&n;   * not guaranteed to be initialized to 0 (NULL). We use&n;   * a NULL entry to indicate that no prior hosts have&n;   * been found/registered for that IRQ.&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|NUMBER
c_func
(paren
id|aic7xxx_boards
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|aic7xxx_boards
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_template
op_member_access_from_pointer
id|proc_dir
op_assign
op_amp
id|proc_scsi_aic7xxx
suffix:semicolon
r_template
op_member_access_from_pointer
id|name
op_assign
id|aic7xxx_info
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_template
op_member_access_from_pointer
id|sg_tablesize
op_assign
id|AIC7XXX_MAX_SG
suffix:semicolon
multiline_comment|/*&n;   * Initialize the spurious count to 0.&n;   */
id|aic7xxx_spurious_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   * EISA/VL-bus card signature probe.&n;   */
r_for
c_loop
(paren
id|slot
op_assign
id|MINSLOT
suffix:semicolon
id|slot
op_le
id|MAXSLOT
suffix:semicolon
id|slot
op_increment
)paren
(brace
id|base
op_assign
id|SLOTBASE
c_func
(paren
id|slot
)paren
op_plus
id|MINREG
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|base
comma
id|MAXREG
op_minus
id|MINREG
)paren
)paren
(brace
multiline_comment|/*&n;       * Some other driver has staked a&n;       * claim to this i/o region already.&n;       */
r_continue
suffix:semicolon
)brace
id|chip_type
op_assign
id|aic7xxx_probe
c_func
(paren
id|slot
comma
id|base
op_plus
id|HID0
comma
op_amp
(paren
id|adapter_bios
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip_type
op_ne
id|AIC_NONE
)paren
(brace
r_switch
c_cond
(paren
id|chip_type
)paren
(brace
r_case
id|AIC_7770
suffix:colon
r_case
id|AIC_7771
suffix:colon
id|printk
c_func
(paren
l_string|&quot;aic7xxx: &lt;%s&gt; at EISA %d&bslash;n&quot;
comma
id|board_names
(braket
id|chip_type
)braket
comma
id|slot
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AIC_284x
suffix:colon
id|printk
c_func
(paren
l_string|&quot;aic7xxx: &lt;%s&gt; at VLB %d&bslash;n&quot;
comma
id|board_names
(braket
id|chip_type
)braket
comma
id|slot
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;       * We found a card, allow 1 spurious interrupt.&n;       */
id|aic7xxx_spurious_count
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;       * Pause the card preserving the IRQ type.  Allow the operator&n;       * to override the IRQ trigger.&n;       */
r_if
c_cond
(paren
id|aic7xxx_irq_trigger
op_eq
l_int|1
)paren
id|hcntrl
op_assign
id|IRQMS
suffix:semicolon
multiline_comment|/* Level */
r_else
r_if
c_cond
(paren
id|aic7xxx_irq_trigger
op_eq
l_int|0
)paren
id|hcntrl
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Edge */
r_else
id|hcntrl
op_assign
id|inb
c_func
(paren
id|base
op_plus
id|HCNTRL
)paren
op_amp
id|IRQMS
suffix:semicolon
multiline_comment|/* Default */
id|outb
c_func
(paren
id|hcntrl
op_or
id|PAUSE
comma
id|base
op_plus
id|HCNTRL
)paren
suffix:semicolon
id|irq
op_assign
id|inb
c_func
(paren
id|INTDEF
op_plus
id|base
)paren
op_amp
l_int|0x0F
suffix:semicolon
r_switch
c_cond
(paren
id|irq
)paren
(brace
r_case
l_int|9
suffix:colon
r_case
l_int|10
suffix:colon
r_case
l_int|11
suffix:colon
r_case
l_int|12
suffix:colon
r_case
l_int|14
suffix:colon
r_case
l_int|15
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: Host adapter uses unsupported IRQ &quot;
l_string|&quot;level, ignoring.&bslash;n&quot;
)paren
suffix:semicolon
id|irq
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq
op_ne
l_int|0
)paren
(brace
id|p
op_assign
id|aic7xxx_alloc
c_func
(paren
r_template
comma
id|base
comma
l_int|0
comma
id|chip_type
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: Unable to allocate device space.&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|p-&gt;irq
op_assign
id|irq
op_amp
l_int|0x0F
suffix:semicolon
id|p-&gt;chip_class
op_assign
id|AIC_777x
suffix:semicolon
macro_line|#ifdef AIC7XXX_PAGE_ENABLE
id|p-&gt;flags
op_or_assign
id|PAGE_ENABLED
suffix:semicolon
macro_line|#endif
id|p-&gt;instance
op_assign
id|found
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_extended
)paren
(brace
id|p-&gt;flags
op_or_assign
id|EXTENDED_TRANSLATION
suffix:semicolon
)brace
id|aic7xxx_chip_reset
c_func
(paren
id|p
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;chip_type
)paren
(brace
r_case
id|AIC_7770
suffix:colon
r_case
id|AIC_7771
suffix:colon
(brace
r_int
r_char
id|biosctrl
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|HA_274_BIOSCTRL
)paren
suffix:semicolon
multiline_comment|/*&n;             * Get the primary channel information.  Right now we don&squot;t&n;             * do anything with this, but someday we will be able to inform&n;             * the mid-level SCSI code which channel is primary.&n;             */
r_if
c_cond
(paren
id|biosctrl
op_amp
id|CHANNEL_B_PRIMARY
)paren
(brace
id|p-&gt;flags
op_or_assign
id|FLAGS_CHANNEL_B_PRIMARY
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|biosctrl
op_amp
id|BIOSMODE
)paren
op_eq
id|BIOSDISABLED
)paren
(brace
id|p-&gt;flags
op_or_assign
id|USE_DEFAULTS
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|AIC_284x
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|load_seeprom
c_func
(paren
id|p
comma
op_amp
id|sxfrctl1
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: SEEPROM not available.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Won&squot;t get here. */
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: BIOS %sabled, IO Port 0x%x, IRQ %d (%s), &quot;
comma
(paren
id|p-&gt;flags
op_amp
id|USE_DEFAULTS
)paren
ques
c_cond
l_string|&quot;dis&quot;
suffix:colon
l_string|&quot;en&quot;
comma
id|p-&gt;base
comma
id|p-&gt;irq
comma
(paren
id|p-&gt;pause
op_amp
id|IRQMS
)paren
ques
c_cond
l_string|&quot;level sensitive&quot;
suffix:colon
l_string|&quot;edge triggered&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;         * Check for Rev C or E boards. Rev E boards can supposedly have&n;         * more than 4 SCBs, while the Rev C boards are limited to 4 SCBs.&n;         * It&squot;s still not clear extactly what is different about the Rev E&n;         * boards, but we think it allows 8 bit entries in the QOUTFIFO to&n;         * support &quot;paging&quot; SCBs (more than 4 commands can be active at once).&n;         *&n;         * The Rev E boards have a read/write autoflush bit in the&n;         * SBLKCTL register, while in the Rev C boards it is read only.&n;         */
id|sblkctl
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SBLKCTL
)paren
op_xor
id|AUTOFLUSHDIS
suffix:semicolon
id|outb
c_func
(paren
id|sblkctl
comma
id|p-&gt;base
op_plus
id|SBLKCTL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SBLKCTL
)paren
op_eq
id|sblkctl
)paren
(brace
multiline_comment|/*&n;           * We detected a Rev E board, we allow paging on this board.&n;           */
id|printk
c_func
(paren
l_string|&quot;Revision &gt;= E&bslash;n&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
id|sblkctl
op_amp
op_complement
id|AUTOFLUSHDIS
comma
id|base
op_plus
id|SBLKCTL
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Do not allow paging. */
id|p-&gt;flags
op_and_assign
op_complement
id|PAGE_ENABLED
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Revision &lt;= C&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Extended translation %sabled.&bslash;n&quot;
comma
(paren
id|p-&gt;flags
op_amp
id|EXTENDED_TRANSLATION
)paren
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;         * Set the FIFO threshold and the bus off time.&n;         */
id|hostconf
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|HOSTCONF
)paren
suffix:semicolon
id|outb
c_func
(paren
id|hostconf
op_amp
id|DFTHRSH
comma
id|p-&gt;base
op_plus
id|BUSSPD
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|hostconf
op_lshift
l_int|2
)paren
op_amp
id|BOFF
comma
id|p-&gt;base
op_plus
id|BUSTIME
)paren
suffix:semicolon
multiline_comment|/*&n;         * Try to initialize the card and register it with the kernel.&n;         */
r_if
c_cond
(paren
id|aic7xxx_register
c_func
(paren
r_template
comma
id|p
)paren
)paren
(brace
multiline_comment|/*&n;           * We successfully found a board and registered it.&n;           */
id|found
op_assign
id|found
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;           * Something went wrong; release and free all resources.&n;           */
id|aic7xxx_free
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;       * Disallow spurious interrupts.&n;       */
id|aic7xxx_spurious_count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_PCI
multiline_comment|/*&n;   * PCI-bus probe.&n;   */
r_if
c_cond
(paren
id|pcibios_present
c_func
(paren
)paren
)paren
(brace
r_struct
(brace
r_int
r_int
id|vendor_id
suffix:semicolon
r_int
r_int
id|device_id
suffix:semicolon
id|aha_chip_type
id|chip_type
suffix:semicolon
id|aha_chip_class_type
id|chip_class
suffix:semicolon
)brace
r_const
id|aic7xxx_pci_devices
(braket
)braket
op_assign
(brace
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7850
comma
id|AIC_7850
comma
id|AIC_785x
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7855
comma
id|AIC_7855
comma
id|AIC_785x
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7860
comma
id|AIC_7860
comma
id|AIC_786x
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7861
comma
id|AIC_7861
comma
id|AIC_786x
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7870
comma
id|AIC_7870
comma
id|AIC_787x
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7871
comma
id|AIC_7871
comma
id|AIC_787x
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7872
comma
id|AIC_7872
comma
id|AIC_787x
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7873
comma
id|AIC_7873
comma
id|AIC_787x
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7874
comma
id|AIC_7874
comma
id|AIC_787x
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7880
comma
id|AIC_7880
comma
id|AIC_788x
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7881
comma
id|AIC_7881
comma
id|AIC_788x
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7882
comma
id|AIC_7882
comma
id|AIC_788x
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7883
comma
id|AIC_7883
comma
id|AIC_788x
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7884
comma
id|AIC_7884
comma
id|AIC_788x
)brace
)brace
suffix:semicolon
r_int
id|error
comma
id|flags
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|iobase
comma
id|mbase
suffix:semicolon
r_int
r_int
id|index
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|pci_bus
comma
id|pci_device_fn
suffix:semicolon
r_int
r_char
id|ultra_enb
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|devconfig
comma
id|class_revid
suffix:semicolon
id|scb_data_type
op_star
id|shared_scb_data
op_assign
l_int|NULL
suffix:semicolon
r_char
id|rev_id
(braket
)braket
op_assign
(brace
l_char|&squot;B&squot;
comma
l_char|&squot;C&squot;
comma
l_char|&squot;D&squot;
)brace
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMBER
c_func
(paren
id|aic7xxx_pci_devices
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|done
op_assign
id|FALSE
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
(brace
r_if
c_cond
(paren
id|pcibios_find_device
c_func
(paren
id|aic7xxx_pci_devices
(braket
id|i
)braket
dot
id|vendor_id
comma
id|aic7xxx_pci_devices
(braket
id|i
)braket
dot
id|device_id
comma
id|index
comma
op_amp
id|pci_bus
comma
op_amp
id|pci_device_fn
)paren
)paren
(brace
id|index
op_assign
l_int|0
suffix:semicolon
id|done
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
multiline_comment|/* Found an Adaptec PCI device. */
(brace
id|chip_class
op_assign
id|aic7xxx_pci_devices
(braket
id|i
)braket
dot
id|chip_class
suffix:semicolon
id|chip_type
op_assign
id|aic7xxx_pci_devices
(braket
id|i
)braket
dot
id|chip_type
suffix:semicolon
id|chan_num
op_assign
l_int|0
suffix:semicolon
id|flags
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|aic7xxx_pci_devices
(braket
id|i
)braket
dot
id|chip_type
)paren
(brace
r_case
id|AIC_7850
suffix:colon
r_case
id|AIC_7855
suffix:colon
id|flags
op_or_assign
id|USE_DEFAULTS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AIC_7872
suffix:colon
multiline_comment|/* 3940 */
r_case
id|AIC_7882
suffix:colon
multiline_comment|/* 3940-Ultra */
id|flags
op_or_assign
id|MULTI_CHANNEL
suffix:semicolon
id|chan_num
op_assign
id|number_of_3940s
op_amp
l_int|0x1
suffix:semicolon
multiline_comment|/* Has 2 controllers */
id|number_of_3940s
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AIC_7873
suffix:colon
multiline_comment|/* 3985 */
r_case
id|AIC_7883
suffix:colon
multiline_comment|/* 3985-Ultra */
id|chan_num
op_assign
id|number_of_3985s
suffix:semicolon
multiline_comment|/* Has 3 controllers */
id|flags
op_or_assign
id|MULTI_CHANNEL
suffix:semicolon
id|number_of_3985s
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|number_of_3985s
op_eq
l_int|3
)paren
(brace
id|number_of_3985s
op_assign
l_int|0
suffix:semicolon
id|shared_scb_data
op_assign
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;           * Read sundry information from PCI BIOS.&n;           */
id|error
op_assign
id|pcibios_read_config_dword
c_func
(paren
id|pci_bus
comma
id|pci_device_fn
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|iobase
)paren
suffix:semicolon
id|error
op_add_assign
id|pcibios_read_config_byte
c_func
(paren
id|pci_bus
comma
id|pci_device_fn
comma
id|PCI_INTERRUPT_LINE
comma
op_amp
id|irq
)paren
suffix:semicolon
id|error
op_add_assign
id|pcibios_read_config_dword
c_func
(paren
id|pci_bus
comma
id|pci_device_fn
comma
id|PCI_BASE_ADDRESS_1
comma
op_amp
id|mbase
)paren
suffix:semicolon
id|error
op_add_assign
id|pcibios_read_config_dword
c_func
(paren
id|pci_bus
comma
id|pci_device_fn
comma
id|DEVCONFIG
comma
op_amp
id|devconfig
)paren
suffix:semicolon
id|error
op_add_assign
id|pcibios_read_config_dword
c_func
(paren
id|pci_bus
comma
id|pci_device_fn
comma
id|CLASS_PROGIF_REVID
comma
op_amp
id|class_revid
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aic7xxx: &lt;%s&gt; at PCI %d&bslash;n&quot;
comma
id|board_names
(braket
id|chip_type
)braket
comma
id|PCI_SLOT
c_func
(paren
id|pci_device_fn
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;           * The first bit (LSB) of PCI_BASE_ADDRESS_0 is always set, so&n;           * we mask it off.&n;           */
id|iobase
op_and_assign
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
id|p
op_assign
id|aic7xxx_alloc
c_func
(paren
r_template
comma
id|iobase
comma
id|mbase
comma
id|chip_type
comma
id|flags
comma
id|shared_scb_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: Unable to allocate device space.&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Remember to set the channel number, irq, and chip class. */
id|p-&gt;chan_num
op_assign
id|chan_num
suffix:semicolon
id|p-&gt;irq
op_assign
id|irq
suffix:semicolon
id|p-&gt;chip_class
op_assign
id|chip_class
suffix:semicolon
macro_line|#ifdef AIC7XXX_PAGE_ENABLE
id|p-&gt;flags
op_or_assign
id|PAGE_ENABLED
suffix:semicolon
macro_line|#endif
id|p-&gt;instance
op_assign
id|found
suffix:semicolon
multiline_comment|/*&n;           * Remember how the card was setup in case there is no seeprom.&n;           */
id|p-&gt;scsi_id
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCSIID
)paren
op_amp
id|OID
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;chip_class
op_eq
id|AIC_786x
)paren
op_logical_or
(paren
id|p-&gt;chip_class
op_eq
id|AIC_788x
)paren
)paren
(brace
id|p-&gt;flags
op_or_assign
id|ULTRA_ENABLED
suffix:semicolon
id|ultra_enb
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SXFRCTL1
)paren
op_amp
id|FAST20
suffix:semicolon
)brace
id|sxfrctl1
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SXFRCTL1
)paren
op_amp
id|STPWEN
suffix:semicolon
id|aic7xxx_chip_reset
c_func
(paren
id|p
)paren
suffix:semicolon
macro_line|#ifdef AIC7XXX_USE_EXT_SCBRAM
r_if
c_cond
(paren
id|devconfig
op_amp
id|RAMPSM
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: External RAM detected; enabling RAM &quot;
l_string|&quot;access.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;             * XXX - Assume 9 bit SRAM and enable parity checking.&n;             */
id|devconfig
op_or_assign
id|EXTSCBPEN
suffix:semicolon
multiline_comment|/*&n;             * XXX - Assume fast SRAM and only enable 2 cycle access if we&n;             *       are sharing the SRAM across multiple adapters (398x).&n;             */
r_if
c_cond
(paren
(paren
id|devconfig
op_amp
id|MPORTMODE
)paren
op_eq
l_int|0
)paren
(brace
id|devconfig
op_or_assign
id|EXTSCBTIME
suffix:semicolon
)brace
id|devconfig
op_and_assign
op_complement
id|SCBRAMSEL
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|pci_bus
comma
id|pci_device_fn
comma
id|DEVCONFIG
comma
id|devconfig
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|USE_DEFAULTS
)paren
op_eq
l_int|0
)paren
(brace
id|load_seeprom
c_func
(paren
id|p
comma
op_amp
id|sxfrctl1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;           * Take the LED out of diagnostic mode&n;           */
id|sblkctl
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SBLKCTL
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|sblkctl
op_amp
op_complement
(paren
id|DIAGLEDEN
op_or
id|DIAGLEDON
)paren
)paren
comma
id|p-&gt;base
op_plus
id|SBLKCTL
)paren
suffix:semicolon
multiline_comment|/*&n;           * We don&squot;t know where this is set in the SEEPROM or by the&n;           * BIOS, so we default to 100%.&n;           */
id|outb
c_func
(paren
id|DFTHRSH_100
comma
id|p-&gt;base
op_plus
id|DSPCISTATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|USE_DEFAULTS
)paren
(brace
r_int
id|j
suffix:semicolon
multiline_comment|/*&n;             * Default setup; should only be used if the adapter does&n;             * not have a SEEPROM.&n;             */
multiline_comment|/*&n;             * Check the target scratch area to see if someone set us&n;             * up already.  We are previously set up if the scratch&n;             * area contains something other than all zeroes and ones.&n;             */
r_for
c_loop
(paren
id|j
op_assign
id|TARG_SCRATCH
suffix:semicolon
id|j
OL
l_int|0x60
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|j
)paren
op_ne
l_int|0x00
)paren
multiline_comment|/* Check for all zeroes. */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
op_eq
id|TARG_SCRATCH
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|TARG_SCRATCH
suffix:semicolon
id|j
OL
l_int|0x60
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
l_int|1
)paren
op_ne
l_int|0xFF
)paren
multiline_comment|/* Check for all ones. */
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|j
op_ne
l_int|0x60
)paren
op_logical_and
(paren
id|p-&gt;scsi_id
op_ne
l_int|0
)paren
)paren
(brace
id|p-&gt;flags
op_and_assign
op_complement
id|USE_DEFAULTS
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Using leftover BIOS values.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: No BIOS found; using default &quot;
l_string|&quot;settings.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;               * Assume only one connector and always turn on&n;               * termination.&n;               */
id|sxfrctl1
op_assign
id|STPWEN
suffix:semicolon
id|p-&gt;scsi_id
op_assign
l_int|7
suffix:semicolon
)brace
id|outb
c_func
(paren
(paren
id|p-&gt;scsi_id
op_amp
id|HSCSIID
)paren
op_or
id|ENSPCHK
op_or
id|RESET_SCSI
comma
id|p-&gt;base
op_plus
id|SCSICONF
)paren
suffix:semicolon
multiline_comment|/* In case we are a wide card. */
id|outb
c_func
(paren
id|p-&gt;scsi_id
comma
id|p-&gt;base
op_plus
id|SCSICONF
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ultra_enb
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|p-&gt;flags
op_amp
id|USE_DEFAULTS
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;               * If there wasn&squot;t a BIOS or the board wasn&squot;t in this mode&n;               * to begin with, turn off Ultra.&n;               */
id|p-&gt;flags
op_and_assign
op_complement
id|ULTRA_ENABLED
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;           * Print some additional information about the adapter.&n;           */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: BIOS %sabled, IO Port 0x%x, &quot;
l_string|&quot;IO Mem 0x%x, IRQ %d&quot;
comma
(paren
id|p-&gt;flags
op_amp
id|USE_DEFAULTS
)paren
ques
c_cond
l_string|&quot;dis&quot;
suffix:colon
l_string|&quot;en&quot;
comma
id|p-&gt;base
comma
id|p-&gt;mbase
comma
id|p-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|class_revid
op_amp
id|DEVREVID
)paren
OL
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, Revision %c&quot;
comma
id|rev_id
(braket
id|class_revid
op_amp
id|DEVREVID
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;           * I don&squot;t think we need to bother with allowing&n;           * spurious interrupts for the 787x/785x, but what&n;           * the hey.&n;           */
id|aic7xxx_spurious_count
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_extended
)paren
id|p-&gt;flags
op_or_assign
id|EXTENDED_TRANSLATION
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Extended translation %sabled.&bslash;n&quot;
comma
(paren
id|p-&gt;flags
op_amp
id|EXTENDED_TRANSLATION
)paren
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;           * Put our termination setting into sxfrctl1 now that the&n;           * generic initialization is complete.&n;           */
id|sxfrctl1
op_or_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SXFRCTL1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|sxfrctl1
comma
id|p-&gt;base
op_plus
id|SXFRCTL1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_register
c_func
(paren
r_template
comma
id|p
)paren
op_eq
l_int|0
)paren
(brace
id|aic7xxx_free
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
id|found
op_assign
id|found
op_plus
l_int|1
suffix:semicolon
macro_line|#ifdef AIC7XXX_USE_EXT_SCBRAM
multiline_comment|/*&n;             * Set the shared SCB data once we&squot;ve successfully probed a&n;             * 398x adapter.&n;             *&n;             * Note that we can only do this if the use of external&n;             * SCB RAM is enabled.&n;             */
r_if
c_cond
(paren
(paren
id|p-&gt;chip_type
op_eq
id|AIC_7873
)paren
op_logical_or
(paren
id|p-&gt;chip_type
op_eq
id|AIC_7883
)paren
)paren
(brace
r_if
c_cond
(paren
id|shared_scb_data
op_eq
l_int|NULL
)paren
(brace
id|shared_scb_data
op_assign
id|p-&gt;scb_data
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
id|index
op_increment
suffix:semicolon
multiline_comment|/*&n;           * Disable spurious interrupts.&n;           */
id|aic7xxx_spurious_count
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Found an Adaptec PCI device. */
)brace
)brace
)brace
macro_line|#endif CONFIG_PCI
r_return
(paren
id|found
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_buildscb&n; *&n; * Description:&n; *   Build a SCB.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_buildscb
id|aic7xxx_buildscb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_struct
id|aic7xxx_hwscb
op_star
id|hscb
suffix:semicolon
id|mask
op_assign
(paren
l_int|0x01
op_lshift
id|TARGET_INDEX
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
multiline_comment|/*&n;   * Setup the control byte if we need negotiation and have not&n;   * already requested it.&n;   */
r_if
c_cond
(paren
id|p-&gt;discenable
op_amp
id|mask
)paren
(brace
id|hscb-&gt;control
op_or_assign
id|DISCENB
suffix:semicolon
macro_line|#ifdef AIC7XXX_TAGGED_QUEUEING
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;tagged_queue
)paren
(brace
id|cmd-&gt;tag
op_assign
id|hscb-&gt;tag
suffix:semicolon
id|p-&gt;device_status
(braket
id|TARGET_INDEX
c_func
(paren
id|cmd
)paren
)braket
dot
id|commands_sent
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;device_status
(braket
id|TARGET_INDEX
c_func
(paren
id|cmd
)paren
)braket
dot
id|commands_sent
OL
l_int|75
)paren
(brace
id|hscb-&gt;control
op_or_assign
id|MSG_SIMPLE_Q_TAG
suffix:semicolon
)brace
r_else
(brace
id|hscb-&gt;control
op_or_assign
id|MSG_ORDERED_Q_TAG
suffix:semicolon
id|p-&gt;device_status
(braket
id|TARGET_INDEX
c_func
(paren
id|cmd
)paren
)braket
dot
id|commands_sent
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif  /* Tagged queueing */
)brace
r_if
c_cond
(paren
(paren
id|p-&gt;needwdtr
op_amp
id|mask
)paren
op_logical_and
op_logical_neg
(paren
id|p-&gt;wdtr_pending
op_amp
id|mask
)paren
)paren
(brace
id|p-&gt;wdtr_pending
op_or_assign
id|mask
suffix:semicolon
id|hscb-&gt;control
op_or_assign
id|MK_MESSAGE
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_MSGOUT_WDTR
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;scsi%d: Sending WDTR request to target %d.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|cmd-&gt;target
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;needsdtr
op_amp
id|mask
)paren
op_logical_and
op_logical_neg
(paren
id|p-&gt;sdtr_pending
op_amp
id|mask
)paren
)paren
(brace
id|p-&gt;sdtr_pending
op_or_assign
id|mask
suffix:semicolon
id|hscb-&gt;control
op_or_assign
id|MK_MESSAGE
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_MSGOUT_SDTR
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;scsi%d: Sending SDTR request to target %d.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|cmd-&gt;target
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;aic7xxx: (build_scb) Target %d, cmd(0x%x) size(%u) wdtr(0x%x) &quot;
l_string|&quot;mask(0x%x).&bslash;n&quot;
comma
id|cmd-&gt;target
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|cmd-&gt;cmd_len
comma
id|p-&gt;needwdtr
comma
id|mask
)paren
suffix:semicolon
macro_line|#endif
id|hscb-&gt;target_channel_lun
op_assign
(paren
(paren
id|cmd-&gt;target
op_lshift
l_int|4
)paren
op_amp
l_int|0xF0
)paren
op_or
(paren
(paren
id|cmd-&gt;channel
op_amp
l_int|0x01
)paren
op_lshift
l_int|3
)paren
op_or
(paren
id|cmd-&gt;lun
op_amp
l_int|0x07
)paren
suffix:semicolon
multiline_comment|/*&n;   * The interpretation of request_buffer and request_bufflen&n;   * changes depending on whether or not use_sg is zero; a&n;   * non-zero use_sg indicates the number of elements in the&n;   * scatter-gather array.&n;   */
multiline_comment|/*&n;   * XXX - this relies on the host data being stored in a&n;   *       little-endian format.&n;   */
id|hscb-&gt;SCSI_cmd_length
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|hscb-&gt;SCSI_cmd_pointer
op_assign
id|VIRT_TO_BUS
c_func
(paren
id|cmd-&gt;cmnd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
multiline_comment|/* Must be mid-level SCSI code scatterlist */
multiline_comment|/*&n;     * We must build an SG list in adapter format, as the kernel&squot;s SG list&n;     * cannot be used directly because of data field size (__alpha__)&n;     * differences and the kernel SG list uses virtual addresses where&n;     * we need physical addresses.&n;     */
r_int
id|i
suffix:semicolon
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scb-&gt;sg_list
(braket
id|i
)braket
dot
id|address
op_assign
id|VIRT_TO_BUS
c_func
(paren
id|sg
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|scb-&gt;sg_list
(braket
id|i
)braket
dot
id|length
op_assign
(paren
r_int
r_int
)paren
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
id|hscb-&gt;SG_list_pointer
op_assign
id|VIRT_TO_BUS
c_func
(paren
id|scb-&gt;sg_list
)paren
suffix:semicolon
id|hscb-&gt;SG_segment_count
op_assign
id|cmd-&gt;use_sg
suffix:semicolon
id|scb-&gt;sg_count
op_assign
id|hscb-&gt;SG_segment_count
suffix:semicolon
multiline_comment|/* Copy the first SG into the data pointer area. */
id|hscb-&gt;data_pointer
op_assign
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
id|hscb-&gt;data_count
op_assign
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|length
op_or
(paren
id|SCB_LIST_NULL
op_lshift
l_int|24
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;aic7xxx: (build_scb) SG segs(%d), length(%u), sg[0].length(%d).&bslash;n&quot;
comma
id|cmd-&gt;use_sg
comma
id|aic7xxx_length
c_func
(paren
id|cmd
comma
l_int|0
)paren
comma
id|hscb-&gt;data_count
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;aic7xxx: (build_scb) Creating scatterlist, addr(0x%lx) length(%d).&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
)paren
(brace
id|hscb-&gt;SG_segment_count
op_assign
l_int|1
suffix:semicolon
id|scb-&gt;sg_count
op_assign
l_int|1
suffix:semicolon
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|address
op_assign
id|VIRT_TO_BUS
c_func
(paren
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|length
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|hscb-&gt;SG_list_pointer
op_assign
id|VIRT_TO_BUS
c_func
(paren
op_amp
id|scb-&gt;sg_list
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|hscb-&gt;data_count
op_assign
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|length
op_or
(paren
id|SCB_LIST_NULL
op_lshift
l_int|24
)paren
suffix:semicolon
id|hscb-&gt;data_pointer
op_assign
id|VIRT_TO_BUS
c_func
(paren
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
)brace
r_else
(brace
id|hscb-&gt;SG_segment_count
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;sg_count
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;SG_list_pointer
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;data_pointer
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;data_count
op_assign
id|SCB_LIST_NULL
op_lshift
l_int|24
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_queue&n; *&n; * Description:&n; *   Queue a SCB to the controller.&n; *-F*************************************************************************/
r_int
DECL|function|aic7xxx_queue
id|aic7xxx_queue
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|fn
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
id|processor_flags
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
r_struct
id|aic7xxx_scb
op_star
id|scb
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;host
op_ne
id|cmd-&gt;host
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi%d: Internal host structure != scsi.c host &quot;
l_string|&quot;structure.&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * Check to see if channel was scanned.&n;   */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|A_SCANNED
)paren
op_logical_and
(paren
id|cmd-&gt;channel
op_eq
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi%d: Scanning channel A for devices.&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|A_SCANNED
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|B_SCANNED
)paren
op_logical_and
(paren
id|cmd-&gt;channel
op_eq
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi%d: Scanning channel B for devices.&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|B_SCANNED
suffix:semicolon
)brace
)brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;aic7xxx: (queue) cmd(0x%x) size(%u), target %d, channel %d, lun %d.&bslash;n&quot;
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|cmd-&gt;cmd_len
comma
id|cmd-&gt;target
comma
id|cmd-&gt;channel
comma
id|cmd-&gt;lun
op_amp
l_int|0x07
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|p-&gt;device_status
(braket
id|TARGET_INDEX
c_func
(paren
id|cmd
)paren
)braket
dot
id|active_cmds
OG
id|cmd-&gt;device-&gt;queue_depth
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d) Commands queued exceeds queue depth&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|cmd-&gt;target
comma
id|cmd-&gt;channel
)paren
suffix:semicolon
)brace
id|scb
op_assign
id|aic7xxx_allocate_scb
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;aic7xxx: (aic7xxx_queue) Couldn&squot;t find a free SCB.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|scb-&gt;cmd
op_assign
id|cmd
suffix:semicolon
id|aic7xxx_position
c_func
(paren
id|cmd
)paren
op_assign
id|scb-&gt;hscb-&gt;tag
suffix:semicolon
macro_line|#if 0
id|debug_scb
c_func
(paren
id|scb
)paren
suffix:semicolon
macro_line|#endif;
multiline_comment|/*&n;     * Construct the SCB beforehand, so the sequencer is&n;     * paused a minimal amount of time.&n;     */
id|aic7xxx_buildscb
c_func
(paren
id|p
comma
id|cmd
comma
id|scb
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|scb
op_ne
(paren
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb-&gt;hscb-&gt;tag
)braket
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: (queue) Address of SCB by position does not match SCB &quot;
l_string|&quot;address.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: (queue) SCB pos(%d) cmdptr(0x%x) state(%d) freescb(0x%x)&bslash;n&quot;
comma
id|scb-&gt;hscb-&gt;tag
comma
(paren
r_int
r_int
)paren
id|scb-&gt;cmd
comma
id|scb-&gt;flags
comma
(paren
r_int
r_int
)paren
id|p-&gt;free_scb
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;     * Make sure the Scsi_Cmnd pointer is saved, the struct it points to&n;     * is set up properly, and the parity error flag is reset, then send&n;     * the SCB to the sequencer and watch the fun begin.&n;     */
id|cmd-&gt;scsi_done
op_assign
id|fn
suffix:semicolon
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_assign
id|DID_OK
suffix:semicolon
id|aic7xxx_status
c_func
(paren
id|cmd
)paren
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;result
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|cmd-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_ACTIVE
op_or
id|SCB_WAITINGQ
suffix:semicolon
id|save_flags
c_func
(paren
id|processor_flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|scbq_insert_tail
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
(paren
id|IN_ISR
op_or
id|IN_TIMEOUT
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|aic7xxx_run_waiting_queues
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|processor_flags
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;aic7xxx: (queue) After - cmd(0x%lx) scb-&gt;cmd(0x%lx) pos(%d).&bslash;n&quot;
comma
(paren
r_int
)paren
id|cmd
comma
(paren
r_int
)paren
id|scb-&gt;cmd
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
macro_line|#endif;
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_bus_device_reset&n; *&n; * Description:&n; *   Abort or reset the current SCSI command(s).  If the scb has not&n; *   previously been aborted, then we attempt to send a BUS_DEVICE_RESET&n; *   message to the target.  If the scb has previously been unsuccessfully&n; *   aborted, then we will reset the channel and have all devices renegotiate.&n; *   Returns an enumerated type that indicates the status of the operation.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_bus_device_reset
id|aic7xxx_bus_device_reset
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scb
suffix:semicolon
r_struct
id|aic7xxx_hwscb
op_star
id|hscb
suffix:semicolon
r_int
r_char
id|bus_state
suffix:semicolon
r_int
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
r_char
id|channel
suffix:semicolon
id|scb
op_assign
(paren
id|p-&gt;scb_data-&gt;scb_array
(braket
id|aic7xxx_position
c_func
(paren
id|cmd
)paren
)braket
)paren
suffix:semicolon
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
multiline_comment|/*&n;   * Ensure that the card doesn&squot;t do anything behind our back.&n;   * Also make sure that we didn&squot;t just miss an interrupt that&n;   * could affect this abort/reset.&n;   */
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|INTSTAT
)paren
op_amp
id|INT_PEND
)paren
suffix:semicolon
(brace
id|aic7xxx_isr
c_func
(paren
id|p-&gt;irq
comma
(paren
r_void
op_star
)paren
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|NULL
)paren
suffix:semicolon
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cmd
op_ne
id|scb-&gt;cmd
)paren
op_logical_or
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/* unpause_always */
id|TRUE
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d) Abort_reset, scb flags 0x%x, &quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;flags
)paren
suffix:semicolon
id|bus_state
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|LASTPHASE
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bus_state
)paren
(brace
r_case
id|P_DATAOUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Data-Out phase, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_DATAIN
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Data-In phase, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_COMMAND
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Command phase, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_MESGOUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Message-Out phase, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_STATUS
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Status phase, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_MESGIN
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Message-In phase, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;       * We&squot;re not in a valid phase, so assume we&squot;re idle.&n;       */
id|printk
c_func
(paren
l_string|&quot;while idle, LASTPHASE = 0x%x, &quot;
comma
id|bus_state
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;SCSISIGI 0x%x, SEQADDR 0x%x, SSTAT0 0x%x, SSTAT1 0x%x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCSISIGI
)paren
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQADDR0
)paren
op_or
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SEQADDR1
)paren
op_lshift
l_int|8
)paren
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SSTAT0
)paren
comma
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SSTAT1
)paren
)paren
suffix:semicolon
id|channel
op_assign
id|hscb-&gt;target_channel_lun
op_amp
id|SELBUSB
ques
c_cond
l_char|&squot;B&squot;
suffix:colon
l_char|&squot;A&squot;
suffix:semicolon
multiline_comment|/*&n;   * Determine our course of action.&n;   */
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_ABORT
)paren
(brace
multiline_comment|/*&n;     * Been down this road before; do a full bus reset.&n;     */
id|scb-&gt;flags
op_or_assign
id|SCB_RECOVERY_SCB
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/* unpause_always */
id|TRUE
)paren
suffix:semicolon
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#if 0
r_else
r_if
c_cond
(paren
id|hscb-&gt;control
op_amp
id|TAG_ENB
)paren
(brace
multiline_comment|/*&n;       * We could be starving this command; try sending and ordered tag&n;       * command to the target we come from.&n;       */
id|scb-&gt;flags
op_or_assign
id|SCB_SENTORDEREDTAG
op_or
id|SCB_RECOVERY_SCB
suffix:semicolon
id|p-&gt;orderedtag
op_assign
id|p-&gt;orderedtag
op_or
l_int|0xFF
suffix:semicolon
id|result
op_assign
id|SCSI_RESET_PENDING
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/* unpause_always */
id|TRUE
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: Abort_reset, odered tag queued.&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
macro_line|#endif
r_else
(brace
r_int
r_char
id|active_scb_index
comma
id|saved_scbptr
suffix:semicolon
r_struct
id|aic7xxx_scb
op_star
id|active_scb
suffix:semicolon
multiline_comment|/*&n;     * Send an Abort Message:&n;     * The target that is holding up the bus may not be the same as&n;     * the one that triggered this timeout (different commands have&n;     * different timeout lengths).  Our strategy here is to queue an&n;     * abort message to the timed out target if it is disconnected.&n;     * Otherwise, if we have an active target we stuff the message buffer&n;     * with an abort message and assert ATN in the hopes that the target&n;     * will let go of the bus and go to the mesgout phase.  If this&n;     * fails, we&squot;ll get another timeout a few seconds later which will&n;     * attempt a bus reset.&n;     */
id|saved_scbptr
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
id|active_scb_index
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_TAG
)paren
suffix:semicolon
id|active_scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|active_scb_index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bus_state
op_ne
id|P_BUSFREE
)paren
(brace
r_if
c_cond
(paren
id|active_scb_index
op_ge
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
multiline_comment|/*&n;         * Perform a bus reset.&n;         *&n;         * XXX - We want to queue an abort for the timedout SCB&n;         *       instead.&n;         */
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: Invalid SCB ID %d is active, &quot;
l_string|&quot;SCB flags = 0x%x.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|scb-&gt;hscb-&gt;tag
comma
id|scb-&gt;flags
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Send the abort message to the active SCB. */
id|outb
c_func
(paren
l_int|1
comma
id|p-&gt;base
op_plus
id|MSG_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|active_scb-&gt;hscb-&gt;control
op_amp
id|TAG_ENB
)paren
(brace
id|outb
c_func
(paren
id|MSG_ABORT_TAG
comma
id|p-&gt;base
op_plus
id|MSG_OUT
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
id|MSG_ABORT
comma
id|p-&gt;base
op_plus
id|MSG_OUT
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|bus_state
op_or
id|ATNO
comma
id|p-&gt;base
op_plus
id|SCSISIGO
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: abort message in message buffer&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
id|active_scb-&gt;flags
op_or_assign
id|SCB_ABORT
op_or
id|SCB_RECOVERY_SCB
suffix:semicolon
r_if
c_cond
(paren
id|active_scb
op_ne
id|scb
)paren
(brace
multiline_comment|/*&n;           * XXX - We would like to increment the timeout on scb, but&n;           *       access to that routine is denied because it is hidden&n;           *       in scsi.c.  If we were able to do this, it would give&n;           *       scb a new lease on life.&n;           */
id|result
op_assign
id|SCSI_RESET_PENDING
suffix:semicolon
id|aic7xxx_error
c_func
(paren
id|active_scb-&gt;cmd
)paren
op_assign
id|DID_RESET
suffix:semicolon
)brace
r_else
(brace
id|aic7xxx_error
c_func
(paren
id|scb-&gt;cmd
)paren
op_assign
id|DID_RESET
suffix:semicolon
id|result
op_assign
id|SCSI_RESET_PENDING
suffix:semicolon
)brace
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/* unpause_always */
id|TRUE
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
r_char
id|hscb_index
comma
id|linked_next
suffix:semicolon
r_int
id|disconnected
suffix:semicolon
id|disconnected
op_assign
id|FALSE
suffix:semicolon
id|hscb_index
op_assign
id|aic7xxx_find_scb
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hscb_index
op_eq
id|SCB_LIST_NULL
)paren
(brace
id|disconnected
op_assign
id|TRUE
suffix:semicolon
id|linked_next
op_assign
(paren
id|scb-&gt;hscb-&gt;data_count
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
id|hscb_index
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_CONTROL
)paren
op_amp
id|DISCONNECTED
)paren
(brace
id|disconnected
op_assign
id|TRUE
suffix:semicolon
)brace
id|linked_next
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_LINKED_NEXT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|disconnected
)paren
(brace
multiline_comment|/*&n;         * Simply set the ABORT_SCB control bit and preserve the&n;         * linked next pointer.&n;         */
id|scb-&gt;hscb-&gt;control
op_or_assign
id|ABORT_SCB
op_or
id|MK_MESSAGE
suffix:semicolon
id|scb-&gt;hscb-&gt;data_count
op_and_assign
op_complement
l_int|0xFF000000
suffix:semicolon
id|scb-&gt;hscb-&gt;data_count
op_or_assign
id|linked_next
op_lshift
l_int|24
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|PAGE_ENABLED
)paren
op_eq
l_int|0
)paren
(brace
id|scb-&gt;hscb-&gt;control
op_and_assign
op_complement
id|DISCONNECTED
suffix:semicolon
)brace
id|scb-&gt;flags
op_or_assign
id|SCB_QUEUED_ABORT
op_or
id|SCB_ABORT
op_or
id|SCB_RECOVERY_SCB
suffix:semicolon
r_if
c_cond
(paren
id|hscb_index
op_ne
id|SCB_LIST_NULL
)paren
(brace
r_int
r_char
id|scb_control
suffix:semicolon
id|scb_control
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|SCB_CONTROL
)paren
suffix:semicolon
id|outb
c_func
(paren
id|scb_control
op_or
id|MK_MESSAGE
op_or
id|ABORT_SCB
comma
id|p-&gt;base
op_plus
id|SCB_CONTROL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;         * Actually requeue this SCB in case we can select the&n;         * device before it reconnects.  If the transaction we&n;         * want to abort is not tagged, unbusy it first so that&n;         * we don&squot;t get held back from sending the command.&n;         */
r_if
c_cond
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|TAG_ENB
)paren
op_eq
l_int|0
)paren
(brace
r_int
r_char
id|target
suffix:semicolon
r_int
id|lun
suffix:semicolon
id|target
op_assign
id|scb-&gt;cmd-&gt;target
suffix:semicolon
id|lun
op_assign
id|scb-&gt;cmd-&gt;lun
suffix:semicolon
id|aic7xxx_search_qinfifo
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|lun
comma
id|SCB_LIST_NULL
comma
l_int|0
comma
multiline_comment|/* requeue */
id|TRUE
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d) Queueing an Abort SCB.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|scbq_insert_head
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|scb
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_WAITINGQ
suffix:semicolon
id|outb
c_func
(paren
id|saved_scbptr
comma
id|p-&gt;base
op_plus
id|SCBPTR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|IN_ISR
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;           * Processing the waiting queue may unpause us.&n;           */
id|aic7xxx_run_waiting_queues
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;           * If we are using AAP, aic7xxx_run_waiting_queues() will not&n;           * unpause us, so ensure we are unpaused.&n;           */
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/*unpause_always*/
id|FALSE
)paren
suffix:semicolon
)brace
r_else
(brace
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/*unpause_always*/
id|TRUE
)paren
suffix:semicolon
)brace
id|result
op_assign
id|SCSI_RESET_PENDING
suffix:semicolon
)brace
r_else
(brace
id|scb-&gt;flags
op_or_assign
id|SCB_RECOVERY_SCB
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/* unpause_always */
id|TRUE
)paren
suffix:semicolon
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_return
(paren
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_abort&n; *&n; * Description:&n; *   Abort the current SCSI command(s).&n; *-F*************************************************************************/
r_int
DECL|function|aic7xxx_abort
id|aic7xxx_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scb
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
r_int
id|base
comma
id|result
suffix:semicolon
r_int
r_int
id|processor_flags
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|scb
op_assign
(paren
id|p-&gt;scb_data-&gt;scb_array
(braket
id|aic7xxx_position
c_func
(paren
id|cmd
)paren
)braket
)paren
suffix:semicolon
id|base
op_assign
id|p-&gt;base
suffix:semicolon
id|save_flags
c_func
(paren
id|processor_flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef AIC7XXX_DEBUG_ABORT
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(scsi%d:%d:%d) Aborting scb %d, flags 0x%x&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;hscb-&gt;tag
comma
id|scb-&gt;flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Abort called with no SCB for cmd.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|IN_TIMEOUT
)paren
(brace
multiline_comment|/*&n;     * We&squot;ve already started a recovery operation.&n;     */
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_RECOVERY_SCB
)paren
op_eq
l_int|0
)paren
(brace
id|restore_flags
c_func
(paren
id|processor_flags
)paren
suffix:semicolon
r_return
(paren
id|SCSI_ABORT_PENDING
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;       * This is the second time we&squot;ve tried to abort the recovery&n;       * SCB.  We want the mid-level SCSI code to call the reset&n;       * function to reset the SCSI bus.&n;       */
id|restore_flags
c_func
(paren
id|processor_flags
)paren
suffix:semicolon
r_return
(paren
id|SCSI_ABORT_NOT_RUNNING
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cmd-&gt;serial_number
op_ne
id|cmd-&gt;serial_number_at_timeout
)paren
(brace
id|result
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|result
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|scb-&gt;cmd
op_ne
id|cmd
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
)paren
)paren
(brace
id|result
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;     * XXX - Check use of IN_TIMEOUT to see if we&squot;re Doing the&n;     *       Right Thing with it.&n;     */
id|p-&gt;flags
op_or_assign
id|IN_TIMEOUT
suffix:semicolon
id|result
op_assign
id|aic7xxx_bus_device_reset
c_func
(paren
id|p
comma
id|scb-&gt;cmd
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|result
)paren
(brace
r_case
id|SCSI_RESET_NOT_RUNNING
suffix:colon
id|p-&gt;flags
op_and_assign
op_complement
id|IN_TIMEOUT
suffix:semicolon
id|result
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCSI_RESET_PENDING
suffix:colon
id|result
op_assign
id|SCSI_ABORT_PENDING
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|p-&gt;flags
op_and_assign
op_complement
id|IN_TIMEOUT
suffix:semicolon
id|result
op_assign
id|SCSI_ABORT_SNOOZE
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|processor_flags
)paren
suffix:semicolon
r_return
(paren
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_reset&n; *&n; * Description:&n; *   Resetting the bus always succeeds - is has to, otherwise the&n; *   kernel will panic! Try a surgical technique - sending a BUS&n; *   DEVICE RESET message - on the offending target before pulling&n; *   the SCSI bus reset line.&n; *-F*************************************************************************/
r_int
DECL|function|aic7xxx_reset
id|aic7xxx_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scb
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
r_int
id|base
comma
id|found
comma
id|tindex
comma
id|min_target
comma
id|max_target
suffix:semicolon
r_int
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
r_char
id|channel
op_assign
l_char|&squot;A&squot;
suffix:semicolon
r_int
r_int
id|processor_flags
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|scb
op_assign
(paren
id|p-&gt;scb_data-&gt;scb_array
(braket
id|aic7xxx_position
c_func
(paren
id|cmd
)paren
)braket
)paren
suffix:semicolon
id|base
op_assign
id|p-&gt;base
suffix:semicolon
id|channel
op_assign
id|cmd-&gt;channel
ques
c_cond
l_char|&squot;B&squot;
suffix:colon
l_char|&squot;A&squot;
suffix:semicolon
id|tindex
op_assign
(paren
id|cmd-&gt;channel
op_lshift
l_int|4
)paren
op_or
id|cmd-&gt;target
suffix:semicolon
macro_line|#ifdef 0   /* AIC7XXX_DEBUG_ABORT */
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(scsi%d:%d:%d) Reset called, scb %d, flags 0x%x&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|TC_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;hscb-&gt;tag
comma
id|scb-&gt;flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Reset called with no SCB for cmd.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* &n;   * This routine is called by scsi.c, in which case the interrupts&n;   * very well may be on when we are called.  As such, we need to save&n;   * the flags to be sure, then turn interrupts off, and then call our&n;   * various method funtions which all assume interrupts are off.&n;   */
id|save_flags
c_func
(paren
id|processor_flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;cmd
op_ne
id|cmd
)paren
id|scb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|IN_TIMEOUT
)paren
(brace
multiline_comment|/*&n;     * We&squot;ve already started a recovery operation.&n;     */
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_RECOVERY_SCB
)paren
op_eq
l_int|0
)paren
(brace
id|restore_flags
c_func
(paren
id|processor_flags
)paren
suffix:semicolon
r_return
(paren
id|SCSI_RESET_PENDING
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
(paren
id|SCSI_RESET_SUGGEST_HOST_RESET
op_or
id|SCSI_RESET_SUGGEST_BUS_RESET
)paren
)paren
op_logical_and
(paren
id|scb
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/*&n;       * Attempt a bus device reset if commands have completed successfully&n;       * since the last bus device reset, or it has been less than 100ms&n;       * since the last reset.&n;       */
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|DEVICE_SUCCESS
)paren
op_logical_or
(paren
(paren
id|jiffies
op_minus
id|p-&gt;device_status
(braket
id|tindex
)braket
dot
id|last_reset
)paren
OL
id|HZ
op_div
l_int|10
)paren
)paren
(brace
r_if
c_cond
(paren
id|cmd-&gt;serial_number
op_ne
id|cmd-&gt;serial_number_at_timeout
)paren
(brace
id|result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|SCSI_RESET_ASYNCHRONOUS
)paren
(brace
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_ABORTED
)paren
(brace
id|result
op_assign
id|SCSI_RESET_PENDING
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
)paren
(brace
id|result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SCSI_RESET_SYNCHRONOUS
)paren
op_logical_and
(paren
id|p-&gt;device_status
(braket
id|tindex
)braket
dot
id|flags
op_amp
id|BUS_DEVICE_RESET_PENDING
)paren
)paren
(brace
id|scb-&gt;flags
op_or_assign
id|SCB_ABORTED
suffix:semicolon
id|result
op_assign
id|SCSI_RESET_PENDING
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;flags
op_or_assign
id|IN_TIMEOUT
suffix:semicolon
id|result
op_assign
id|aic7xxx_bus_device_reset
c_func
(paren
id|p
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|p-&gt;flags
op_and_assign
op_complement
id|IN_TIMEOUT
suffix:semicolon
id|result
op_assign
id|SCSI_RESET_PENDING
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|result
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;     * The bus device reset failed; try resetting the channel.&n;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
(paren
id|SCSI_RESET_SUGGEST_BUS_RESET
op_or
id|SCSI_RESET_SUGGEST_HOST_RESET
)paren
)paren
op_logical_and
(paren
id|flags
op_amp
id|SCSI_RESET_ASYNCHRONOUS
)paren
)paren
(brace
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
)paren
(brace
id|result
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_ABORTED
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|p-&gt;device_status
(braket
id|tindex
)braket
dot
id|flags
op_amp
id|BUS_DEVICE_RESET_PENDING
)paren
)paren
)paren
(brace
id|result
op_assign
id|SCSI_RESET_PENDING
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;       * The reset channel function assumes that the sequencer is paused.&n;       */
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
id|found
op_assign
id|aic7xxx_reset_channel
c_func
(paren
id|p
comma
id|channel
comma
id|TRUE
)paren
suffix:semicolon
id|p-&gt;flags
op_assign
id|p-&gt;flags
op_amp
op_complement
id|IN_TIMEOUT
suffix:semicolon
multiline_comment|/*&n;       * If this is a synchronous reset and there is no SCB for this&n;       * command, perform completion processing.&n;       *&n;       */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SCSI_RESET_SYNCHRONOUS
)paren
op_logical_and
(paren
id|scb
op_eq
l_int|NULL
)paren
)paren
(brace
id|cmd-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|p-&gt;bus_type
)paren
(brace
r_case
id|AIC_TWIN
suffix:colon
r_if
c_cond
(paren
id|channel
op_eq
l_char|&squot;B&squot;
)paren
(brace
id|min_target
op_assign
l_int|8
suffix:semicolon
id|max_target
op_assign
l_int|15
suffix:semicolon
)brace
r_else
(brace
id|min_target
op_assign
l_int|0
suffix:semicolon
id|max_target
op_assign
l_int|7
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AIC_WIDE
suffix:colon
id|min_target
op_assign
l_int|0
suffix:semicolon
id|max_target
op_assign
l_int|15
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AIC_SINGLE
suffix:colon
r_default
suffix:colon
id|min_target
op_assign
l_int|0
suffix:semicolon
id|max_target
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|tindex
op_assign
id|min_target
suffix:semicolon
id|tindex
op_le
id|max_target
suffix:semicolon
id|tindex
op_increment
)paren
(brace
id|p-&gt;device_status
(braket
id|tindex
)braket
dot
id|last_reset
op_assign
id|jiffies
suffix:semicolon
)brace
id|result
op_assign
id|SCSI_RESET_SUCCESS
op_or
id|SCSI_RESET_HOST_RESET
suffix:semicolon
id|p-&gt;flags
op_and_assign
op_complement
id|IN_TIMEOUT
suffix:semicolon
)brace
)brace
id|aic7xxx_run_waiting_queues
c_func
(paren
id|p
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|processor_flags
)paren
suffix:semicolon
r_return
(paren
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_biosparam&n; *&n; * Description:&n; *   Return the disk geometry for the given SCSI device.&n; *-F*************************************************************************/
r_int
DECL|function|aic7xxx_biosparam
id|aic7xxx_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
id|geom
(braket
)braket
)paren
(brace
r_int
id|heads
comma
id|sectors
comma
id|cylinders
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|disk-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
multiline_comment|/*&n;   * XXX - if I could portably find the card&squot;s configuration&n;   *       information, then this could be autodetected instead&n;   *       of left to a boot-time switch.&n;   */
id|heads
op_assign
l_int|64
suffix:semicolon
id|sectors
op_assign
l_int|32
suffix:semicolon
id|cylinders
op_assign
id|disk-&gt;capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|EXTENDED_TRANSLATION
)paren
op_logical_and
(paren
id|cylinders
OG
l_int|1024
)paren
)paren
(brace
id|heads
op_assign
l_int|255
suffix:semicolon
id|sectors
op_assign
l_int|63
suffix:semicolon
id|cylinders
op_assign
id|disk-&gt;capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
)brace
id|geom
(braket
l_int|0
)braket
op_assign
id|heads
suffix:semicolon
id|geom
(braket
l_int|1
)braket
op_assign
id|sectors
suffix:semicolon
id|geom
(braket
l_int|2
)braket
op_assign
id|cylinders
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#include &quot;aic7xxx_proc.c&quot;
macro_line|#ifdef MODULE
multiline_comment|/* Eventually this will go into an include file, but this will be later */
DECL|variable|driver_template
id|Scsi_Host_Template
id|driver_template
op_assign
id|AIC7XXX
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
macro_line|#endif
multiline_comment|/*&n; * Overrides for Emacs so that we almost follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 2&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -2&n; * c-argdecl-indent: 2&n; * c-label-offset: -2&n; * c-continued-statement-offset: 2&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: nil&n; * tab-width: 8&n; * End:&n; */
eof
