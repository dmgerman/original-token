multiline_comment|/*+M*************************************************************************&n; * Adaptec 274x/284x/294x device driver for Linux.&n; *&n; * Copyright (c) 1994 John Aycock&n; *   The University of Calgary Department of Computer Science.&n; *   All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer.&n; * 2. Redistributions in binary form must reproduce the above copyright&n; *    notice, this list of conditions and the following disclaimer in the&n; *    documentation and/or other materials provided with the distribution.&n; * 3. All advertising materials mentioning features or use of this software&n; *    must display the following acknowledgement:&n; *      This product includes software developed by the University of Calgary&n; *      Department of Computer Science and its contributors.&n; * 4. Neither the name of the University nor the names of its contributors&n; *    may be used to endorse or promote products derived from this software&n; *    without specific prior written permission.&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE&n; * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; * &n; * Sources include the Adaptec 1740 driver (aha1740.c), the Ultrastor 24F&n; * driver (ultrastor.c), various Linux kernel source, the Adaptec EISA&n; * config file (!adp7771.cfg), the Adaptec AHA-2740A Series User&squot;s Guide,&n; * the Linux Kernel Hacker&squot;s Guide, Writing a SCSI Device Driver for Linux,&n; * the Adaptec 1542 driver (aha1542.c), the Adaptec EISA overlay file&n; * (adp7770.ovl), the Adaptec AHA-2740 Series Technical Reference Manual,&n; * the Adaptec AIC-7770 Data Book, the ANSI SCSI specification, the&n; * ANSI SCSI-2 specification (draft 10c), ...&n; *&n; * ----------------------------------------------------------------&n; *  Modified to include support for wide and twin bus adapters,&n; *  DMAing of SCBs, tagged queueing, IRQ sharing, bug fixes,&n; *  and other rework of the code.&n; *&n; *  Parts of this driver are based on the FreeBSD driver by Justin&n; *  T. Gibbs.&n; *&n; *  A Boot time option was also added for not resetting the scsi bus.&n; *&n; *    Form:  aic7xxx=extended,no_reset&n; *&n; *    -- Daniel M. Eischen, deischen@iworks.InterWorks.org, 04/03/95&n; *&n; *  $Id: aic7xxx.c,v 1.49 1995/06/28 05:41:09 deang Exp $&n; *-M*************************************************************************/
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#endif
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &quot;../block/blk.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;aic7xxx.h&quot;
DECL|macro|AIC7XXX_C_VERSION
mdefine_line|#define AIC7XXX_C_VERSION  &quot;$Revision: 1.49 $&quot;
DECL|macro|NUMBER
mdefine_line|#define NUMBER(arr)     (sizeof(arr) / sizeof(arr[0]))
DECL|macro|MIN
mdefine_line|#define MIN(a,b) ((a &lt; b) ? a : b)
multiline_comment|/*&n; * Defines for PCI bus support, testing twin bus support, DMAing of&n; * SCBs, and tagged queueing.&n; *&n; *   o PCI bus support - this has been implemented and working since&n; *     the December 1, 1994 release of this driver. If you don&squot;t have&n; *     a PCI bus and do not wish to configure your kernel with PCI&n; *     support, then make sure this define is set to the cprrect&n; *     define for PCI support (CONFIG_PCI) and configure your kernel&n; *     without PCI support (make config).&n; *&n; *   o Twin bus support - this has been tested and does work.&n; *&n; *   o DMAing of SCBs - thanks to Kai Makisara, this now works&n; *&n; *   o Tagged queueing - this driver is capable of tagged queueing&n; *     but I am unsure as to how well the higher level driver implements&n; *     tagged queueing. Therefore, the maximum commands per lun is&n; *     set to 2. If you want to implement tagged queueing, ensure&n; *     this define is not commented out.&n; *&n; *   o Sharing IRQs - allowed for sharing of IRQs. This will allow&n; *     for multiple aic7xxx host adapters sharing the same IRQ, but&n; *     not for sharing IRQs with other devices. The higher level&n; *     PCI code and interrupt handling needs to be modified to&n; *     support this.&n; *&n; *  Daniel M. Eischen, deischen@iworks.InterWorks.org, 03/11/95&n; */
multiline_comment|/* Uncomment this for testing twin bus support. */
DECL|macro|AIC7XXX_TWIN_SUPPORT
mdefine_line|#define AIC7XXX_TWIN_SUPPORT
multiline_comment|/* Uncomment this for DMAing of SCBs. */
DECL|macro|AIC7XXX_USE_DMA
mdefine_line|#define AIC7XXX_USE_DMA
multiline_comment|/* Uncomment this for tagged queueing. */
multiline_comment|/* #define AIC7XXX_TAGGED_QUEUEING */
multiline_comment|/* Uncomment this for allowing sharing of IRQs. */
DECL|macro|AIC7XXX_SHARE_IRQS
mdefine_line|#define AIC7XXX_SHARE_IRQS
multiline_comment|/* Set this to the delay in seconds after SCSI bus reset. */
DECL|macro|AIC7XXX_RESET_DELAY
mdefine_line|#define AIC7XXX_RESET_DELAY 15
multiline_comment|/*&n; * Uncomment this to always use scatter/gather lists.&n; * *NOTE: The sequencer must be changed also!&n; */
DECL|macro|AIC7XXX_USE_SG
mdefine_line|#define AIC7XXX_USE_SG
multiline_comment|/*&n; * Controller type and options&n; */
r_typedef
r_enum
(brace
DECL|enumerator|AIC_NONE
id|AIC_NONE
comma
DECL|enumerator|AIC_274x
id|AIC_274x
comma
multiline_comment|/* EISA aic7770 */
DECL|enumerator|AIC_284x
id|AIC_284x
comma
multiline_comment|/* VLB  aic7770 */
DECL|enumerator|AIC_7870
id|AIC_7870
comma
multiline_comment|/* PCI  aic7870 */
DECL|enumerator|AIC_7850
id|AIC_7850
comma
multiline_comment|/* PCI  aic7850 */
DECL|enumerator|AIC_7872
id|AIC_7872
multiline_comment|/* PCI  aic7870 on 394x */
DECL|typedef|aha_type
)brace
id|aha_type
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|AIC_SINGLE
id|AIC_SINGLE
comma
multiline_comment|/* Single Channel */
DECL|enumerator|AIC_TWIN
id|AIC_TWIN
comma
multiline_comment|/* Twin Channel */
DECL|enumerator|AIC_WIDE
id|AIC_WIDE
multiline_comment|/* Wide Channel */
DECL|typedef|aha_bus_type
)brace
id|aha_bus_type
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|AIC_UNKNOWN
id|AIC_UNKNOWN
comma
DECL|enumerator|AIC_ENABLED
id|AIC_ENABLED
comma
DECL|enumerator|AIC_DISABLED
id|AIC_DISABLED
DECL|typedef|aha_status_type
)brace
id|aha_status_type
suffix:semicolon
multiline_comment|/*&n; * There should be a specific return value for this in scsi.h, but&n; * it seems that most drivers ignore it.&n; */
DECL|macro|DID_UNDERFLOW
mdefine_line|#define DID_UNDERFLOW   DID_ERROR
multiline_comment|/*&n; *  What we want to do is have the higher level scsi driver requeue&n; *  the command to us. There is no specific driver status for this&n; *  condition, but the higher level scsi driver will requeue the&n; *  command on a DID_BUS_BUSY error.&n; */
DECL|macro|DID_RETRY_COMMAND
mdefine_line|#define DID_RETRY_COMMAND DID_BUS_BUSY
multiline_comment|/*&n; * EISA/VL-bus stuff&n; */
DECL|macro|MINSLOT
mdefine_line|#define MINSLOT&t;&t;1
DECL|macro|MAXSLOT
mdefine_line|#define MAXSLOT&t;&t;15
DECL|macro|SLOTBASE
mdefine_line|#define SLOTBASE(x)&t;((x) &lt;&lt; 12)
DECL|macro|MAXIRQ
mdefine_line|#define MAXIRQ&t;&t;15
multiline_comment|/*&n; * Standard EISA Host ID regs  (Offset from slot base)&n; */
DECL|macro|HID0
mdefine_line|#define HID0(x)         ((x) + 0xC80)   /* 0,1: msb of ID2, 2-7: ID1      */
DECL|macro|HID1
mdefine_line|#define HID1(x)         ((x) + 0xC81)   /* 0-4: ID3, 5-7: LSB ID2         */
DECL|macro|HID2
mdefine_line|#define HID2(x)         ((x) + 0xC82)   /* product                        */
DECL|macro|HID3
mdefine_line|#define HID3(x)         ((x) + 0xC83)   /* firmware revision              */
multiline_comment|/*&n; * AIC-7770 I/O range to reserve for a card&n; */
DECL|macro|MINREG
mdefine_line|#define MINREG(x)&t;((x) + 0xC00ul)
DECL|macro|MAXREG
mdefine_line|#define MAXREG(x)&t;((x) + 0xCBFul)
multiline_comment|/* -------------------- AIC-7770 offset definitions ----------------------- */
multiline_comment|/*&n; * SCSI Sequence Control (p. 3-11).&n; * Each bit, when set starts a specific SCSI sequence on the bus&n; */
DECL|macro|SCSISEQ
mdefine_line|#define SCSISEQ(x)&t;&t;((x) + 0xC00ul)
DECL|macro|TEMODEO
mdefine_line|#define&t;&t;TEMODEO&t;&t;0x80
DECL|macro|ENSELO
mdefine_line|#define&t;&t;ENSELO&t;&t;0x40
DECL|macro|ENSELI
mdefine_line|#define&t;&t;ENSELI&t;&t;0x20
DECL|macro|ENRSELI
mdefine_line|#define&t;&t;ENRSELI&t;&t;0x10
DECL|macro|ENAUTOATNO
mdefine_line|#define&t;&t;ENAUTOATNO&t;0x08
DECL|macro|ENAUTOATNI
mdefine_line|#define&t;&t;ENAUTOATNI&t;0x04
DECL|macro|ENAUTOATNP
mdefine_line|#define&t;&t;ENAUTOATNP&t;0x02
DECL|macro|SCSIRSTO
mdefine_line|#define&t;&t;SCSIRSTO&t;0x01
multiline_comment|/*&n; * SCSI Transfer Control 1 Register (pp. 3-14,15).&n; * Controls the SCSI module data path.&n; */
DECL|macro|SXFRCTL1
mdefine_line|#define SXFRCTL1(x)&t;&t;((x) + 0xC02ul)
DECL|macro|BITBUCKET
mdefine_line|#define&t;&t;BITBUCKET&t;0x80
DECL|macro|SWRAPEN
mdefine_line|#define&t;&t;SWRAPEN&t;&t;0x40
DECL|macro|ENSPCHK
mdefine_line|#define&t;&t;ENSPCHK&t;&t;0x20
DECL|macro|STIMESEL
mdefine_line|#define&t;&t;STIMESEL&t;0x18
DECL|macro|ENSTIMER
mdefine_line|#define&t;&t;ENSTIMER&t;0x04
DECL|macro|ACTNEGEN
mdefine_line|#define&t;&t;ACTNEGEN&t;0x02
DECL|macro|STPWEN
mdefine_line|#define&t;&t;STPWEN&t;&t;0x01&t;&t;/* Powered Termination */
multiline_comment|/*&n; * SCSI Control Signal Read Register (p. 3-15).&n; * Reads the actual state of the SCSI bus pins&n; */
DECL|macro|SCSISIGI
mdefine_line|#define SCSISIGI(x)&t;&t;((x) + 0xC03ul)
DECL|macro|CDI
mdefine_line|#define&t;&t;CDI&t;&t;0x80
DECL|macro|IOI
mdefine_line|#define&t;&t;IOI&t;&t;0x40
DECL|macro|MSGI
mdefine_line|#define&t;&t;MSGI&t;&t;0x20
DECL|macro|ATNI
mdefine_line|#define&t;&t;ATNI&t;&t;0x10
DECL|macro|SELI
mdefine_line|#define&t;&t;SELI&t;&t;0x08
DECL|macro|BSYI
mdefine_line|#define&t;&t;BSYI&t;&t;0x04
DECL|macro|REQI
mdefine_line|#define&t;&t;REQI&t;&t;0x02
DECL|macro|ACKI
mdefine_line|#define&t;&t;ACKI&t;&t;0x01
multiline_comment|/*&n; * SCSI Contol Signal Write Register (p. 3-16).&n; * Writing to this register modifies the control signals on the bus. Only&n; * those signals that are allowed in the current mode (Initiator/Target) are&n; * asserted.&n; */
DECL|macro|SCSISIGO
mdefine_line|#define SCSISIGO(x)&t;&t;((x) + 0xC03ul)
DECL|macro|CDO
mdefine_line|#define&t;&t;CDO&t;&t;0x80
DECL|macro|IOO
mdefine_line|#define&t;&t;IOO&t;&t;0x40
DECL|macro|MSGO
mdefine_line|#define&t;&t;MSGO&t;&t;0x20
DECL|macro|ATNO
mdefine_line|#define&t;&t;ATNO&t;&t;0x10
DECL|macro|SELO
mdefine_line|#define&t;&t;SELO&t;&t;0x08
DECL|macro|BSYO
mdefine_line|#define&t;&t;BSYO&t;&t;0x04
DECL|macro|REQO
mdefine_line|#define&t;&t;REQO&t;&t;0x02
DECL|macro|ACKO
mdefine_line|#define&t;&t;ACKO&t;&t;0x01
multiline_comment|/*&n; * SCSI Rate&n; */
DECL|macro|SCSIRATE
mdefine_line|#define SCSIRATE(x)&t;&t;((x) + 0xC04ul)
multiline_comment|/*&n; * SCSI ID (p. 3-18).&n; * Contains the ID of the board and the current target on the&n; * selected channel&n; */
DECL|macro|SCSIID
mdefine_line|#define SCSIID(x)&t;&t;((x) + 0xC05ul)
DECL|macro|TID
mdefine_line|#define&t;&t;TID&t;&t;0xF0&t;&t;/* Target ID mask */
DECL|macro|OID
mdefine_line|#define&t;&t;OID&t;&t;0x0F&t;&t;/* Our ID mask */
multiline_comment|/*&n; * SCSI Status 0 (p. 3-21)&n; * Contains one set of SCSI Interrupt codes&n; * These are most likely of interest to the sequencer&n; */
DECL|macro|SSTAT0
mdefine_line|#define SSTAT0(x)&t;&t;((x) + 0xC0Bul)
DECL|macro|TARGET
mdefine_line|#define&t;&t;TARGET&t;&t;0x80&t;&t;/* Board is a target */
DECL|macro|SELDO
mdefine_line|#define&t;&t;SELDO&t;&t;0x40&t;&t;/* Selection Done */
DECL|macro|SELDI
mdefine_line|#define&t;&t;SELDI&t;&t;0x20&t;&t;/* Board has been selected */
DECL|macro|SELINGO
mdefine_line|#define&t;&t;SELINGO&t;&t;0x10&t;&t;/* Selection In Progress */
DECL|macro|SWRAP
mdefine_line|#define&t;&t;SWRAP&t;&t;0x08&t;&t;/* 24bit counter wrap */
DECL|macro|SDONE
mdefine_line|#define&t;&t;SDONE&t;&t;0x04&t;&t;/* STCNT = 0x000000 */
DECL|macro|SPIORDY
mdefine_line|#define&t;&t;SPIORDY&t;&t;0x02&t;&t;/* SCSI PIO Ready */
DECL|macro|DMADONE
mdefine_line|#define&t;&t;DMADONE&t;&t;0x01&t;&t;/* DMA transfer completed */
multiline_comment|/*&n; * Clear SCSI Interrupt 1 (p. 3-23)&n; * Writing a 1 to a bit clears the associated SCSI Interrupt in SSTAT1.&n; */
DECL|macro|CLRSINT1
mdefine_line|#define CLRSINT1(x)&t;&t;((x) + 0xC0Cul)
DECL|macro|CLRSELTIMEO
mdefine_line|#define&t;&t;CLRSELTIMEO&t;0x80
DECL|macro|CLRATNO
mdefine_line|#define&t;&t;CLRATNO&t;&t;0x40
DECL|macro|CLRSCSIRSTI
mdefine_line|#define&t;&t;CLRSCSIRSTI&t;0x20
multiline_comment|/*  UNUSED&t;&t;&t;0x10 */
DECL|macro|CLRBUSFREE
mdefine_line|#define&t;&t;CLRBUSFREE&t;0x08
DECL|macro|CLRSCSIPERR
mdefine_line|#define&t;&t;CLRSCSIPERR&t;0x04
DECL|macro|CLRPHASECHG
mdefine_line|#define&t;&t;CLRPHASECHG&t;0x02
DECL|macro|CLRREQINIT
mdefine_line|#define&t;&t;CLRREQINIT&t;0x01
multiline_comment|/*&n; * SCSI Status 1 (p. 3-24)&n; * These interrupt bits are of interest to the kernel driver&n; */
DECL|macro|SSTAT1
mdefine_line|#define SSTAT1(x)&t;&t;((x) + 0xC0Cul)
DECL|macro|SELTO
mdefine_line|#define&t;&t;SELTO&t;&t;0x80
DECL|macro|ATNTARG
mdefine_line|#define&t;&t;ATNTARG &t;0x40
DECL|macro|SCSIRSTI
mdefine_line|#define&t;&t;SCSIRSTI&t;0x20
DECL|macro|PHASEMIS
mdefine_line|#define&t;&t;PHASEMIS&t;0x10
DECL|macro|BUSFREE
mdefine_line|#define&t;&t;BUSFREE&t;&t;0x08
DECL|macro|SCSIPERR
mdefine_line|#define&t;&t;SCSIPERR&t;0x04
DECL|macro|PHASECHG
mdefine_line|#define&t;&t;PHASECHG&t;0x02
DECL|macro|REQINIT
mdefine_line|#define&t;&t;REQINIT&t;&t;0x01
multiline_comment|/*&n; * SCSI Interrrupt Mode 1 (pp. 3-28,29).&n; * Set bits in this register enable the corresponding&n; * interrupt source.&n; */
DECL|macro|SIMODE1
mdefine_line|#define&t;SIMODE1(x)&t;&t;((x) + 0xC11ul)
DECL|macro|ENSELTIMO
mdefine_line|#define&t;&t;ENSELTIMO&t;0x80
DECL|macro|ENATNTARG
mdefine_line|#define&t;&t;ENATNTARG&t;0x40
DECL|macro|ENSCSIRST
mdefine_line|#define&t;&t;ENSCSIRST&t;0x20
DECL|macro|ENPHASEMIS
mdefine_line|#define&t;&t;ENPHASEMIS&t;0x10
DECL|macro|ENBUSFREE
mdefine_line|#define&t;&t;ENBUSFREE&t;0x08
DECL|macro|ENSCSIPERR
mdefine_line|#define&t;&t;ENSCSIPERR&t;0x04
DECL|macro|ENPHASECHG
mdefine_line|#define&t;&t;ENPHASECHG&t;0x02
DECL|macro|ENREQINIT
mdefine_line|#define&t;&t;ENREQINIT&t;0x01
multiline_comment|/*&n; * Selection/Reselection ID (p. 3-31)&n; * Upper four bits are the device id. The ONEBIT is set when the re/selecting&n; * device did not set its own ID.&n; */
DECL|macro|SELID
mdefine_line|#define SELID(x)&t;&t;((x) + 0xC19ul)
DECL|macro|SELID_MASK
mdefine_line|#define&t;&t;SELID_MASK&t;0xF0
DECL|macro|ONEBIT
mdefine_line|#define&t;&t;ONEBIT&t;&t;0x08
multiline_comment|/*  UNUSED&t;&t;&t;0x07 */
multiline_comment|/*&n; * Serial EEPROM Control (p. 4-92 in 7870 Databook)&n; * Controls the reading and writing of an external serial 1-bit&n; * EEPROM Device.  In order to access the serial EEPROM, you must&n; * first set the SEEMS bit that generates a request to the memory&n; * port for access to the serial EEPROM device.  When the memory&n; * port is not busy servicing another request, it reconfigures&n; * to allow access to the serial EEPROM.  When this happens, SEERDY&n; * gets set high to verify that the memory port access has been&n; * granted.  See aic7xxx_read_eprom for detailed information on&n; * the protocol necessary to read the serial EEPROM.&n; */
DECL|macro|SEECTL
mdefine_line|#define SEECTL(x)&t;&t;((x) + 0xC1Eul)
DECL|macro|EXTARBACK
mdefine_line|#define&t;&t;EXTARBACK&t;0x80
DECL|macro|EXTARBREQ
mdefine_line|#define&t;&t;EXTARBREQ&t;0x40
DECL|macro|SEEMS
mdefine_line|#define&t;&t;SEEMS&t;&t;0x20
DECL|macro|SEERDY
mdefine_line|#define&t;&t;SEERDY&t;&t;0x10
DECL|macro|SEECS
mdefine_line|#define&t;&t;SEECS&t;&t;0x08
DECL|macro|SEECK
mdefine_line|#define&t;&t;SEECK&t;&t;0x04
DECL|macro|SEEDO
mdefine_line|#define&t;&t;SEEDO&t;&t;0x02
DECL|macro|SEEDI
mdefine_line|#define&t;&t;SEEDI&t;&t;0x01
multiline_comment|/*&n; * SCSI Block Control (p. 3-32)&n; * Controls Bus type and channel selection. In a twin channel configuration&n; * addresses 0x00-0x1E are gated to the appropriate channel based on this&n; * register. SELWIDE allows for the coexistence of 8bit and 16bit devices&n; * on a wide bus.&n; */
DECL|macro|SBLKCTL
mdefine_line|#define SBLKCTL(x)&t;&t;((x) + 0xC1Ful)
multiline_comment|/*  UNUSED&t;&t;&t;0xC0 */
DECL|macro|AUTOFLUSHDIS
mdefine_line|#define&t;&t;AUTOFLUSHDIS&t;0x20&t;&t;/* used for Rev C check */
multiline_comment|/*  UNUSED&t;&t;&t;0x10 */
DECL|macro|SELBUSB
mdefine_line|#define&t;&t;SELBUSB&t;&t;0x08
multiline_comment|/*  UNUSED&t;&t;&t;0x04 */
DECL|macro|SELWIDE
mdefine_line|#define&t;&t;SELWIDE&t;&t;0x02
multiline_comment|/*  UNUSED&t;&t;&t;0x01 */
DECL|macro|SELSINGLE
mdefine_line|#define&t;&t;SELSINGLE&t;0x00
multiline_comment|/*&n; * Sequencer Control (p. 3-33)&n; * Error detection mode and speed configuration&n; */
DECL|macro|SEQCTL
mdefine_line|#define SEQCTL(x)&t;&t;((x) + 0xC60ul)
DECL|macro|PERRORDIS
mdefine_line|#define&t;&t;PERRORDIS&t;0x80
DECL|macro|PAUSEDIS
mdefine_line|#define&t;&t;PAUSEDIS&t;0x40
DECL|macro|FAILDIS
mdefine_line|#define&t;&t;FAILDIS&t;&t;0x20
DECL|macro|FASTMODE
mdefine_line|#define &t;FASTMODE&t;0x10
DECL|macro|BRKADRINTEN
mdefine_line|#define&t;&t;BRKADRINTEN&t;0x08
DECL|macro|STEP
mdefine_line|#define&t;&t;STEP&t;&t;0x04
DECL|macro|SEQRESET
mdefine_line|#define&t;&t;SEQRESET&t;0x02
DECL|macro|LOADRAM
mdefine_line|#define&t;&t;LOADRAM&t;&t;0x01
multiline_comment|/*&n; * Sequencer RAM Data (p. 3-34)&n; * Single byte window into the Scratch Ram area starting at the address&n; * specified by SEQADDR0 and SEQADDR1. To write a full word, simply write&n; * four bytes in sucessesion. The SEQADDRs will increment after the most&n; * significant byte is written&n; */
DECL|macro|SEQRAM
mdefine_line|#define SEQRAM(x)&t;&t;((x) + 0xC61ul)
multiline_comment|/*&n; * Sequencer Address Registers (p. 3-35)&n; * Only the first bit of SEQADDR1 holds addressing information&n; */
DECL|macro|SEQADDR0
mdefine_line|#define SEQADDR0(x)&t;&t;((x) + 0xC62ul)
DECL|macro|SEQADDR1
mdefine_line|#define SEQADDR1(x)&t;&t;((x) + 0xC63ul)
DECL|macro|ACCUM
mdefine_line|#define ACCUM(x)&t;&t;((x) + 0xC64ul)&t;&t;/* accumulator */
multiline_comment|/*&n; * Board Control (p. 3-43)&n; */
DECL|macro|BCTL
mdefine_line|#define BCTL(x)&t;&t;((x) + 0xC84ul)
multiline_comment|/*   RSVD&t;&t;&t;0xF0 */
DECL|macro|ACE
mdefine_line|#define&t;&t;ACE&t;&t;0x08&t;/* Support for external processors */
multiline_comment|/*   RSVD&t;&t;&t;0x06 */
DECL|macro|ENABLE
mdefine_line|#define&t;&t;ENABLE&t;&t;0x01
DECL|macro|BUSSPD
mdefine_line|#define BUSSPD(x)&t;&t;((x) + 0xC86ul)&t;/* FIFO threshold bits ? */
multiline_comment|/*&n; * Host Control (p. 3-47) R/W&n; * Overal host control of the device.&n; */
DECL|macro|HCNTRL
mdefine_line|#define HCNTRL(x)&t;&t;((x) + 0xC87ul)
multiline_comment|/*    UNUSED&t;&t;&t;0x80 */
DECL|macro|POWRDN
mdefine_line|#define&t;&t;POWRDN&t;&t;0x40
multiline_comment|/*    UNUSED&t;&t;&t;0x20 */
DECL|macro|SWINT
mdefine_line|#define&t;&t;SWINT&t;&t;0x10
DECL|macro|IRQMS
mdefine_line|#define&t;&t;IRQMS&t;&t;0x08
DECL|macro|PAUSE
mdefine_line|#define&t;&t;PAUSE&t;&t;0x04
DECL|macro|INTEN
mdefine_line|#define&t;&t;INTEN&t;&t;0x02
DECL|macro|CHIPRST
mdefine_line|#define&t;&t;CHIPRST&t;&t;0x01
DECL|macro|REQ_PAUSE
mdefine_line|#define&t;&t;REQ_PAUSE&t;IRQMS | PAUSE | INTEN
DECL|macro|UNPAUSE_274X
mdefine_line|#define&t;&t;UNPAUSE_274X&t;IRQMS | INTEN
DECL|macro|UNPAUSE_284X
mdefine_line|#define&t;&t;UNPAUSE_284X&t;INTEN
DECL|macro|UNPAUSE_294X
mdefine_line|#define&t;&t;UNPAUSE_294X&t;IRQMS | INTEN
multiline_comment|/*&n; * SCB Pointer (p. 3-49)&n; * Gate one of the four SCBs into the SCBARRAY window.&n; */
DECL|macro|SCBPTR
mdefine_line|#define SCBPTR(x)&t;&t;((x) + 0xC90ul)
multiline_comment|/*&n; * Interrupt Status (p. 3-50)&n; * Status for system interrupts&n; */
DECL|macro|INTSTAT
mdefine_line|#define INTSTAT(x)&t;&t;((x) + 0xC91ul)
DECL|macro|SEQINT_MASK
mdefine_line|#define&t;&t;SEQINT_MASK&t;0xF0&t;&t;/* SEQINT Status Codes */
DECL|macro|BAD_PHASE
mdefine_line|#define&t;&t;&t;BAD_PHASE&t;0x00
DECL|macro|SEND_REJECT
mdefine_line|#define&t;&t;&t;SEND_REJECT&t;0x10
DECL|macro|NO_IDENT
mdefine_line|#define&t;&t;&t;NO_IDENT&t;0x20
DECL|macro|NO_MATCH
mdefine_line|#define&t;&t;&t;NO_MATCH&t;0x30
DECL|macro|MSG_SDTR
mdefine_line|#define&t;&t;&t;MSG_SDTR&t;0x40
DECL|macro|MSG_WDTR
mdefine_line|#define&t;&t;&t;MSG_WDTR&t;0x50
DECL|macro|MSG_REJECT
mdefine_line|#define&t;&t;&t;MSG_REJECT&t;0x60
DECL|macro|BAD_STATUS
mdefine_line|#define&t;&t;&t;BAD_STATUS&t;0x70
DECL|macro|RESIDUAL
mdefine_line|#define&t;&t;&t;RESIDUAL&t;0x80
DECL|macro|ABORT_TAG
mdefine_line|#define&t;&t;&t;ABORT_TAG&t;0x90
DECL|macro|AWAITING_MSG
mdefine_line|#define&t;&t;&t;AWAITING_MSG&t;0xa0
DECL|macro|BRKADRINT
mdefine_line|#define &t;BRKADRINT 0x08
DECL|macro|SCSIINT
mdefine_line|#define&t;&t;SCSIINT&t;  0x04
DECL|macro|CMDCMPLT
mdefine_line|#define&t;&t;CMDCMPLT  0x02
DECL|macro|SEQINT
mdefine_line|#define&t;&t;SEQINT    0x01
DECL|macro|INT_PEND
mdefine_line|#define&t;&t;INT_PEND  (BRKADRINT | SEQINT | SCSIINT | CMDCMPLT)
multiline_comment|/*&n; * Hard Error (p. 3-53)&n; * Reporting of catastrophic errors. You usually cannot recover from&n; * these without a full board reset.&n; */
DECL|macro|ERROR
mdefine_line|#define ERROR(x)&t;&t;((x) + 0xC92ul)
multiline_comment|/*    UNUSED&t;&t;&t;0xF0 */
DECL|macro|PARERR
mdefine_line|#define&t;&t;PARERR&t;&t;0x08
DECL|macro|ILLOPCODE
mdefine_line|#define&t;&t;ILLOPCODE&t;0x04
DECL|macro|ILLSADDR
mdefine_line|#define&t;&t;ILLSADDR&t;0x02
DECL|macro|ILLHADDR
mdefine_line|#define&t;&t;ILLHADDR&t;0x01
multiline_comment|/*&n; * Clear Interrupt Status (p. 3-52)&n; */
DECL|macro|CLRINT
mdefine_line|#define CLRINT(x)&t;&t;((x) + 0xC92ul)
DECL|macro|CLRBRKADRINT
mdefine_line|#define&t;&t;CLRBRKADRINT&t;0x08
DECL|macro|CLRSCSIINT
mdefine_line|#define&t;&t;CLRSCSIINT&t;0x04
DECL|macro|CLRCMDINT
mdefine_line|#define&t;&t;CLRCMDINT &t;0x02
DECL|macro|CLRSEQINT
mdefine_line|#define&t;&t;CLRSEQINT &t;0x01
multiline_comment|/*&n; * SCB Auto Increment (p. 3-59)&n; * Byte offset into the SCB Array and an optional bit to allow auto&n; * incrementing of the address during download and upload operations&n; */
DECL|macro|SCBCNT
mdefine_line|#define SCBCNT(x)&t;&t;((x) + 0xC9Aul)
DECL|macro|SCBAUTO
mdefine_line|#define&t;&t;SCBAUTO&t;&t;0x80
DECL|macro|SCBCNT_MASK
mdefine_line|#define&t;&t;SCBCNT_MASK&t;0x1F
multiline_comment|/*&n; * Queue In FIFO (p. 3-60)&n; * Input queue for queued SCBs (commands that the seqencer has yet to start)&n; */
DECL|macro|QINFIFO
mdefine_line|#define QINFIFO(x)&t;&t;((x) + 0xC9Bul)
multiline_comment|/*&n; * Queue In Count (p. 3-60)&n; * Number of queued SCBs&n; */
DECL|macro|QINCNT
mdefine_line|#define QINCNT(x)&t;&t;((x) + 0xC9Cul)
multiline_comment|/*&n; * Queue Out FIFO (p. 3-61)&n; * Queue of SCBs that have completed and await the host&n; */
DECL|macro|QOUTFIFO
mdefine_line|#define QOUTFIFO(x)&t;&t;((x) + 0xC9Dul)
multiline_comment|/*&n; * Queue Out Count (p. 3-61)&n; * Number of queued SCBs in the Out FIFO&n; */
DECL|macro|QOUTCNT
mdefine_line|#define QOUTCNT(x)&t;&t;((x) + 0xC9Eul)
DECL|macro|SCBARRAY
mdefine_line|#define SCBARRAY(x)&t;&t;((x) + 0xCA0ul)
multiline_comment|/* ---------------- END AIC-7770 Register Definitions ----------------- */
multiline_comment|/* --------------------- AIC-7870-only definitions -------------------- */
DECL|macro|DSPCISTATUS
mdefine_line|#define DSPCISTATUS(x)&t; &t;((x) + 0xC86ul)
DECL|macro|DFTHRESH
mdefine_line|#define &t;DFTHRESH        0xC0
multiline_comment|/* Scratch RAM offset definitions */
multiline_comment|/* ---------------------- Scratch RAM Offsets ------------------------- */
multiline_comment|/* These offsets are either to values that are initialized by the board&squot;s&n; * BIOS or are specified by the Linux sequencer code. If I can figure out&n; * how to read the EISA configuration info at probe time, the cards could&n; * be run without BIOS support installed&n; */
multiline_comment|/*&n; * 1 byte per target starting at this address for configuration values&n; */
DECL|macro|HA_TARG_SCRATCH
mdefine_line|#define HA_TARG_SCRATCH(x)&t;((x) + 0xC20ul)
multiline_comment|/*&n; * The sequencer will stick the first byte of any rejected message here so&n; * we can see what is getting thrown away.&n; */
DECL|macro|HA_REJBYTE
mdefine_line|#define HA_REJBYTE(x)&t;&t;((x) + 0xC31ul)
multiline_comment|/*&n; * Bit vector of targets that have disconnection disabled.&n; */
DECL|macro|HA_DISC_DSB
mdefine_line|#define&t;HA_DISC_DSB&t;&t;((x) + 0xc32ul)
multiline_comment|/*&n; * Length of pending message&n; */
DECL|macro|HA_MSG_LEN
mdefine_line|#define HA_MSG_LEN(x)&t;&t;((x) + 0xC34ul)
multiline_comment|/*&n; * Outgoing Message Body&n; */
DECL|macro|HA_MSG_START
mdefine_line|#define HA_MSG_START(x)&t;&t;((x) + 0xC35ul)
multiline_comment|/*&n; * These are offsets into the card&squot;s scratch ram. Some of the values are&n; * specified in the AHA2742 technical reference manual and are initialized&n; * by the BIOS at boot time.&n; */
DECL|macro|HA_ARG_1
mdefine_line|#define HA_ARG_1(x)&t;&t;((x) + 0xC4Aul)&t;/* sdtr &lt;-&gt; rate parameters */
DECL|macro|HA_RETURN_1
mdefine_line|#define HA_RETURN_1(x)&t;&t;((x) + 0xC4Aul)
DECL|macro|SEND_SENSE
mdefine_line|#define&t;&t;SEND_SENSE&t;0x80
DECL|macro|SEND_SDTR
mdefine_line|#define&t;&t;SEND_SDTR &t;0x80
DECL|macro|SEND_WDTR
mdefine_line|#define&t;&t;SEND_WDTR &t;0x80
DECL|macro|SEND_REJ
mdefine_line|#define&t;&t;SEND_REJ&t;0x40
DECL|macro|HA_SIGSTATE
mdefine_line|#define HA_SIGSTATE(x)&t;&t;((x) + 0xC4Bul)&t;/* value in SCSISIGO */
DECL|macro|HA_SCBCOUNT
mdefine_line|#define HA_SCBCOUNT(x)&t;&t;((x) + 0xC52ul)&t;/* number of hardware SCBs */
DECL|macro|HA_FLAGS
mdefine_line|#define HA_FLAGS(x)&t;&t;((x) + 0xC53ul)&t;/* TWIN and WIDE bus flags */
DECL|macro|SINGLE_BUS
mdefine_line|#define&t;&t;SINGLE_BUS&t;0x00
DECL|macro|TWIN_BUS
mdefine_line|#define&t;&t;TWIN_BUS&t;0x01
DECL|macro|WIDE_BUS
mdefine_line|#define&t;&t;WIDE_BUS&t;0x02
DECL|macro|ACTIVE_MSG
mdefine_line|#define&t;&t;ACTIVE_MSG&t;0x20
DECL|macro|IDENTIFY_SEEN
mdefine_line|#define&t;&t;IDENTIFY_SEEN&t;0x40
DECL|macro|RESELECTING
mdefine_line|#define&t;&t;RESELECTING&t;0x80
DECL|macro|HA_ACTIVE0
mdefine_line|#define HA_ACTIVE0(x)&t;&t;((x) + 0xC54ul)&t;/* Active bits; targets 0-7 */
DECL|macro|HA_ACTIVE1
mdefine_line|#define HA_ACTIVE1(x)&t;&t;((x) + 0xC55ul)&t;/* Active bits; targets 8-15 */
DECL|macro|SAVED_TCL
mdefine_line|#define&t;SAVED_TCL(x)&t;&t;((x) + 0xC56ul)&t;/* Saved target, channel, LUN */
DECL|macro|WAITING_SCBH
mdefine_line|#define WAITING_SCBH(x)&t;&t;((x) + 0xC57ul) /* Head of disconnected targets list. */
DECL|macro|WAITING_SCBT
mdefine_line|#define WAITING_SCBT(x)&t;&t;((x) + 0xC58ul) /* Tail of disconnected targets list. */
DECL|macro|HA_SCSICONF
mdefine_line|#define HA_SCSICONF(x)&t;&t;((x) + 0xC5Aul)&t;/* SCSI config register */
DECL|macro|HA_INTDEF
mdefine_line|#define HA_INTDEF(x)&t;&t;((x) + 0xC5Cul)&t;/* interrupt def&squot;n register */
DECL|macro|HA_HOSTCONF
mdefine_line|#define HA_HOSTCONF(x)&t;&t;((x) + 0xC5Dul)&t;/* host config def&squot;n register */
DECL|macro|MSG_ABORT
mdefine_line|#define MSG_ABORT&t;&t;0x06
DECL|macro|MSG_BUS_DEVICE_RESET
mdefine_line|#define&t;MSG_BUS_DEVICE_RESET&t;0x0c
DECL|macro|BUS_8_BIT
mdefine_line|#define BUS_8_BIT&t;&t;0x00
DECL|macro|BUS_16_BIT
mdefine_line|#define BUS_16_BIT&t;&t;0x01
DECL|macro|BUS_32_BIT
mdefine_line|#define BUS_32_BIT&t;&t;0x02
multiline_comment|/*&n; *&n; * Define the format of the SEEPROM registers (16 bits).&n; *&n; */
DECL|struct|seeprom_config
r_struct
id|seeprom_config
(brace
multiline_comment|/*&n; * SCSI ID Configuration Flags&n; */
DECL|macro|CFXFER
mdefine_line|#define CFXFER&t;&t;0x0007&t;&t;/* synchronous transfer rate */
DECL|macro|CFSYNCH
mdefine_line|#define CFSYNCH&t;&t;0x0008&t;&t;/* enable synchronous transfer */
DECL|macro|CFDISC
mdefine_line|#define CFDISC&t;&t;0x0010&t;&t;/* enable disconnection */
DECL|macro|CFWIDEB
mdefine_line|#define CFWIDEB&t;&t;0x0020&t;&t;/* wide bus device */
multiline_comment|/* UNUSED&t;&t;0x00C0 */
DECL|macro|CFSTART
mdefine_line|#define CFSTART&t;&t;0x0100&t;&t;/* send start unit SCSI command */
DECL|macro|CFINCBIOS
mdefine_line|#define CFINCBIOS&t;0x0200&t;&t;/* include in BIOS scan */
DECL|macro|CFRNFOUND
mdefine_line|#define CFRNFOUND&t;0x0400&t;&t;/* report even if not found */
multiline_comment|/* UNUSED&t;&t;0xF800 */
DECL|member|device_flags
r_int
r_int
id|device_flags
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* words 0-15 */
multiline_comment|/*&n; * BIOS Control Bits&n; */
DECL|macro|CFSUPREM
mdefine_line|#define CFSUPREM&t;0x0001&t;&t;/* support all removeable drives */
DECL|macro|CFSUPREMB
mdefine_line|#define CFSUPREMB&t;0x0002&t;&t;/* support removeable drives for boot only */
DECL|macro|CFBIOSEN
mdefine_line|#define CFBIOSEN&t;0x0004&t;&t;/* BIOS enabled */
multiline_comment|/* UNUSED&t;&t;0x0008 */
DECL|macro|CFSM2DRV
mdefine_line|#define CFSM2DRV&t;0x0010&t;&t;/* support more than two drives */
multiline_comment|/* UNUSED&t;&t;0x0060 */
DECL|macro|CFEXTEND
mdefine_line|#define CFEXTEND&t;0x0080&t;&t;/* extended translation enabled */
multiline_comment|/* UNUSED&t;&t;0xFF00 */
DECL|member|bios_control
r_int
r_int
id|bios_control
suffix:semicolon
multiline_comment|/* word 16 */
multiline_comment|/*&n; * Host Adapter Control Bits&n; */
multiline_comment|/* UNUSED&t;&t;0x0003 */
DECL|macro|CFWSTERM
mdefine_line|#define CFWSTERM&t;0x0008&t;&t;/* SCSI high byte termination (wide card) */
DECL|macro|CFSTERM
mdefine_line|#define CFSTERM&t;&t;0x0004&t;&t;/* SCSI low byte termination (non-wide cards) */
DECL|macro|CFSPARITY
mdefine_line|#define CFSPARITY&t;0x0010&t;&t;/* SCSI parity */
multiline_comment|/* UNUSED&t;&t;0x0020 */
DECL|macro|CFRESETB
mdefine_line|#define CFRESETB&t;0x0040&t;&t;/* reset SCSI bus at IC initialization */
multiline_comment|/* UNUSED&t;&t;0xFF80 */
DECL|member|adapter_control
r_int
r_int
id|adapter_control
suffix:semicolon
multiline_comment|/* word 17 */
multiline_comment|/*&n; * Bus Release, Host Adapter ID&n; */
DECL|macro|CFSCSIID
mdefine_line|#define CFSCSIID&t;0x000F&t;&t;/* host adapter SCSI ID */
multiline_comment|/* UNUSED&t;&t;0x00F0 */
DECL|macro|CFBRTIME
mdefine_line|#define CFBRTIME&t;0xFF00&t;&t;/* bus release time */
DECL|member|brtime_id
r_int
r_int
id|brtime_id
suffix:semicolon
multiline_comment|/* word 18 */
multiline_comment|/*&n; * Maximum targets&n; */
DECL|macro|CFMAXTARG
mdefine_line|#define CFMAXTARG&t;0x00FF&t;/* maximum targets */
multiline_comment|/* UNUSED&t;&t;0xFF00 */
DECL|member|max_targets
r_int
r_int
id|max_targets
suffix:semicolon
multiline_comment|/* word 19 */
DECL|member|res_1
r_int
r_int
id|res_1
(braket
l_int|11
)braket
suffix:semicolon
multiline_comment|/* words 20-30 */
DECL|member|checksum
r_int
r_int
id|checksum
suffix:semicolon
multiline_comment|/* word 31 */
)brace
suffix:semicolon
DECL|macro|AIC7XXX_DEBUG
mdefine_line|#define AIC7XXX_DEBUG
multiline_comment|/*&n; * Pause the sequencer and wait for it to actually stop - this&n; * is important since the sequencer can disable pausing for critical&n; * sections.&n; */
DECL|macro|PAUSE_SEQUENCER
mdefine_line|#define PAUSE_SEQUENCER(p) &bslash;&n;  outb(p-&gt;pause, HCNTRL(p-&gt;base));&t;&t;&t;&bslash;&n;  while ((inb(HCNTRL(p-&gt;base)) &amp; PAUSE) == 0)&t;&t;&bslash;&n;    ;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;
multiline_comment|/*&n; * Unpause the sequencer. Unremarkable, yet done often enough to&n; * warrant an easy way to do it.&n; */
DECL|macro|UNPAUSE_SEQUENCER
mdefine_line|#define UNPAUSE_SEQUENCER(p) &bslash;&n;  outb(p-&gt;unpause, HCNTRL(p-&gt;base))
multiline_comment|/*&n; * Restart the sequencer program from address zero&n; */
DECL|macro|RESTART_SEQUENCER
mdefine_line|#define RESTART_SEQUENCER(p) &bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    outb(SEQRESET | FASTMODE, SEQCTL(p-&gt;base));&t;&bslash;&n;  } while (inb(SEQADDR0(p-&gt;base)) != 0 &amp;&amp;&t;&t;&bslash;&n;&t;   inb(SEQADDR1(p-&gt;base)) != 0);&t;&t;&bslash;&n;  UNPAUSE_SEQUENCER(p);
multiline_comment|/*&n; * If an error occurs during a data transfer phase, run the comand&n; * to completion - it&squot;s easier that way - making a note of the error&n; * condition in this location. This then will modify a DID_OK status&n; * into an appropriate error for the higher-level SCSI code.&n; */
DECL|macro|aic7xxx_error
mdefine_line|#define aic7xxx_error(cmd)&t;((cmd)-&gt;SCp.Status)
multiline_comment|/*&n; * Keep track of the targets returned status.&n; */
DECL|macro|aic7xxx_status
mdefine_line|#define aic7xxx_status(cmd)&t;((cmd)-&gt;SCp.sent_command)
multiline_comment|/*&n; * The position of the SCSI commands scb within the scb array.&n; */
DECL|macro|aic7xxx_position
mdefine_line|#define aic7xxx_position(cmd)&t;((cmd)-&gt;SCp.have_data_in)
multiline_comment|/*&n; * Since the sequencer code DMAs the scatter-gather structures&n; * directly from memory, we use this macro to assert that the&n; * kernel structure hasn&squot;t changed.&n; */
DECL|macro|SG_STRUCT_CHECK
mdefine_line|#define SG_STRUCT_CHECK(sg) &bslash;&n;  ((char *)&amp;(sg).address - (char *)&amp;(sg) != 0 ||  &bslash;&n;   (char *)&amp;(sg).length  - (char *)&amp;(sg) != 8 ||  &bslash;&n;   sizeof((sg).address) != 4 ||                   &bslash;&n;   sizeof((sg).length)  != 4 ||                   &bslash;&n;   sizeof(sg)           != 12)
multiline_comment|/*&n; * &quot;Static&quot; structures. Note that these are NOT initialized&n; * to zero inside the kernel - we have to initialize them all&n; * explicitly.&n; *&n; * We support a maximum of one adapter card per IRQ level (see the&n; * rationale for this above). On an interrupt, use the IRQ as an&n; * index into aic7xxx_boards[] to locate the card information.&n; */
DECL|variable|aic7xxx_boards
r_static
r_struct
id|Scsi_Host
op_star
id|aic7xxx_boards
(braket
id|MAXIRQ
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/*&n; * The driver keeps up to four scb structures per card in memory. Only the&n; * first 26 bytes of the structure are valid for the hardware, the rest used&n; * for driver level bookeeping. The driver is further optimized&n; * so that we only have to download the first 19 bytes since as long&n; * as we always use S/G, the last fields should be zero anyway.&n; */
macro_line|#ifdef AIC7XXX_USE_SG
DECL|macro|SCB_DOWNLOAD_SIZE
mdefine_line|#define SCB_DOWNLOAD_SIZE&t;19&t;/* amount to actually download */
macro_line|#else
DECL|macro|SCB_DOWNLOAD_SIZE
mdefine_line|#define SCB_DOWNLOAD_SIZE&t;26
macro_line|#endif
DECL|macro|SCB_UPLOAD_SIZE
mdefine_line|#define SCB_UPLOAD_SIZE&t;&t;19&t;/* amount to actually upload */
DECL|struct|aic7xxx_scb
r_struct
id|aic7xxx_scb
(brace
multiline_comment|/* ------------    Begin hardware supported fields    ---------------- */
DECL|member|control
multiline_comment|/*1 */
r_int
r_char
id|control
suffix:semicolon
DECL|macro|SCB_NEEDWDTR
mdefine_line|#define SCB_NEEDWDTR 0x80                       /* Initiate Wide Negotiation */
DECL|macro|SCB_NEEDSDTR
mdefine_line|#define SCB_NEEDSDTR 0x40                       /* Initiate Sync Negotiation */
DECL|macro|SCB_NEEDDMA
mdefine_line|#define SCB_NEEDDMA  0x08                       /* SCB needs to be DMA&squot;d from&n;&t;&t;&t;&t;&t;&t; * from host memory&n;&t;&t;&t;&t;&t;&t; */
DECL|macro|SCB_REJ_MDP
mdefine_line|#define SCB_REJ_MDP      0x80                   /* Reject MDP message */
DECL|macro|SCB_DISEN
mdefine_line|#define SCB_DISEN        0x40                   /* SCB Disconnect enable */
DECL|macro|SCB_TE
mdefine_line|#define SCB_TE           0x20                   /* Tag enable */
multiline_comment|/*      RESERVED         0x10 */
DECL|macro|SCB_WAITING
mdefine_line|#define SCB_WAITING      0x08                   /* Waiting */
DECL|macro|SCB_DIS
mdefine_line|#define SCB_DIS          0x04                   /* Disconnected */
DECL|macro|SCB_TAG_TYPE
mdefine_line|#define SCB_TAG_TYPE     0x03
DECL|macro|SIMPLE_QUEUE
mdefine_line|#define         SIMPLE_QUEUE 0x00               /* Simple Queue */
DECL|macro|HEAD_QUEUE
mdefine_line|#define         HEAD_QUEUE   0x01               /* Head of Queue */
DECL|macro|ORD_QUEUE
mdefine_line|#define         ORD_QUEUE    0x02               /* Ordered Queue */
multiline_comment|/*              ILLEGAL      0x03 */
DECL|member|target_channel_lun
multiline_comment|/*2 */
r_int
r_char
id|target_channel_lun
suffix:semicolon
multiline_comment|/* 4/1/3 bits */
DECL|member|SG_segment_count
multiline_comment|/*3 */
r_int
r_char
id|SG_segment_count
suffix:semicolon
DECL|member|SG_list_pointer
multiline_comment|/*7 */
r_int
r_char
id|SG_list_pointer
(braket
l_int|4
)braket
id|__attribute__
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
DECL|member|SCSI_cmd_pointer
multiline_comment|/*11*/
r_int
r_char
id|SCSI_cmd_pointer
(braket
l_int|4
)braket
id|__attribute__
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
DECL|member|SCSI_cmd_length
multiline_comment|/*12*/
r_int
r_char
id|SCSI_cmd_length
suffix:semicolon
DECL|member|RESERVED
multiline_comment|/*14*/
r_int
r_char
id|RESERVED
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* must be zero */
DECL|member|target_status
multiline_comment|/*15*/
r_int
r_char
id|target_status
suffix:semicolon
DECL|member|residual_data_count
multiline_comment|/*18*/
r_int
r_char
id|residual_data_count
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|residual_SG_segment_count
multiline_comment|/*19*/
r_int
r_char
id|residual_SG_segment_count
suffix:semicolon
DECL|member|data_pointer
multiline_comment|/*23*/
r_int
r_char
id|data_pointer
(braket
l_int|4
)braket
id|__attribute__
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
DECL|member|data_count
multiline_comment|/*26*/
r_int
r_char
id|data_count
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|host_scb
multiline_comment|/*30*/
r_int
r_char
id|host_scb
(braket
l_int|4
)braket
id|__attribute__
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
DECL|member|next_waiting
multiline_comment|/*31*/
id|u_char
id|next_waiting
suffix:semicolon
multiline_comment|/* Used to thread SCBs awaiting selection. */
DECL|macro|SCB_LIST_NULL
mdefine_line|#define SCB_LIST_NULL 0x10              /* SCB list equivelent to NULL */
macro_line|#if 0
multiline_comment|/*&n;&t; *  No real point in transferring this to the&n;&t; *  SCB registers.&n;&t; */
r_int
r_char
id|RESERVED
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#endif
multiline_comment|/*-----------------end of hardware supported fields----------------*/
DECL|member|next
r_struct
id|aic7xxx_scb
op_star
id|next
suffix:semicolon
multiline_comment|/* next ptr when in free list */
DECL|member|cmd
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
multiline_comment|/* Scsi_Cmnd for this scb */
DECL|member|state
r_int
id|state
suffix:semicolon
multiline_comment|/* current state of scb */
DECL|macro|SCB_FREE
mdefine_line|#define SCB_FREE               0x00
DECL|macro|SCB_ACTIVE
mdefine_line|#define SCB_ACTIVE             0x01
DECL|macro|SCB_ABORTED
mdefine_line|#define SCB_ABORTED            0x02
DECL|macro|SCB_DEVICE_RESET
mdefine_line|#define SCB_DEVICE_RESET       0x04
DECL|macro|SCB_IMMED
mdefine_line|#define SCB_IMMED              0x08
DECL|macro|SCB_SENSE
mdefine_line|#define SCB_SENSE              0x10
DECL|member|position
r_int
r_int
id|position
suffix:semicolon
multiline_comment|/* Position in scb array */
macro_line|#ifdef AIC7XXX_USE_SG
DECL|member|sg
r_struct
id|scatterlist
id|sg
suffix:semicolon
DECL|member|sense_sg
r_struct
id|scatterlist
id|sense_sg
suffix:semicolon
macro_line|#endif
DECL|member|sense_cmd
r_int
r_char
id|sense_cmd
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* Allocate 6 characters for sense command */
)brace
suffix:semicolon
r_static
r_struct
(brace
DECL|member|errno
r_int
r_char
id|errno
suffix:semicolon
DECL|member|errmesg
r_char
op_star
id|errmesg
suffix:semicolon
DECL|variable|hard_error
)brace
id|hard_error
(braket
)braket
op_assign
(brace
(brace
id|ILLHADDR
comma
l_string|&quot;Illegal Host Access&quot;
)brace
comma
(brace
id|ILLSADDR
comma
l_string|&quot;Illegal Sequencer Address referrenced&quot;
)brace
comma
(brace
id|ILLOPCODE
comma
l_string|&quot;Illegal Opcode in sequencer program&quot;
)brace
comma
(brace
id|PARERR
comma
l_string|&quot;Sequencer Ram Parity Error&quot;
)brace
)brace
suffix:semicolon
r_static
r_int
r_char
DECL|variable|generic_sense
id|generic_sense
(braket
)braket
op_assign
(brace
id|REQUEST_SENSE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|255
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * The maximum number of SCBs we could have for ANY type&n; * of card. DON&squot;T FORGET TO CHANGE THE SCB MASK IN THE&n; * SEQUENCER CODE IF THIS IS MODIFIED!&n; */
DECL|macro|AIC7XXX_MAXSCB
mdefine_line|#define AIC7XXX_MAXSCB&t;16
multiline_comment|/*&n; * Define a structure used for each host adapter, only one per IRQ.&n; */
DECL|struct|aic7xxx_host
r_struct
id|aic7xxx_host
(brace
DECL|member|base
r_int
id|base
suffix:semicolon
multiline_comment|/* card base address */
DECL|member|maxscb
r_int
id|maxscb
suffix:semicolon
multiline_comment|/* hardware SCBs */
DECL|member|numscb
r_int
id|numscb
suffix:semicolon
multiline_comment|/* current number of scbs */
DECL|member|extended
r_int
id|extended
suffix:semicolon
multiline_comment|/* extended xlate? */
DECL|member|type
id|aha_type
id|type
suffix:semicolon
multiline_comment|/* card type */
DECL|member|bus_type
id|aha_bus_type
id|bus_type
suffix:semicolon
multiline_comment|/* normal/twin/wide bus */
DECL|member|a_scanned
r_int
r_char
id|a_scanned
suffix:semicolon
multiline_comment|/* 0 not scanned, 1 scanned */
DECL|member|b_scanned
r_int
r_char
id|b_scanned
suffix:semicolon
multiline_comment|/* 0 not scanned, 1 scanned */
DECL|member|isr_count
r_int
r_int
id|isr_count
suffix:semicolon
multiline_comment|/* Interrupt count */
DECL|member|unpause
r_volatile
r_int
r_char
id|unpause
suffix:semicolon
multiline_comment|/* unpause value for HCNTRL */
DECL|member|pause
r_volatile
r_int
r_char
id|pause
suffix:semicolon
multiline_comment|/* pause value for HCNTRL */
DECL|member|needsdtr_copy
r_volatile
r_int
r_int
id|needsdtr_copy
suffix:semicolon
multiline_comment|/* default config */
DECL|member|needsdtr
r_volatile
r_int
r_int
id|needsdtr
suffix:semicolon
DECL|member|sdtr_pending
r_volatile
r_int
r_int
id|sdtr_pending
suffix:semicolon
DECL|member|needwdtr_copy
r_volatile
r_int
r_int
id|needwdtr_copy
suffix:semicolon
multiline_comment|/* default config */
DECL|member|needwdtr
r_volatile
r_int
r_int
id|needwdtr
suffix:semicolon
DECL|member|wdtr_pending
r_volatile
r_int
r_int
id|wdtr_pending
suffix:semicolon
DECL|member|seeprom
r_struct
id|seeprom_config
id|seeprom
suffix:semicolon
DECL|member|have_seeprom
r_int
id|have_seeprom
suffix:semicolon
DECL|member|next
r_struct
id|Scsi_Host
op_star
id|next
suffix:semicolon
multiline_comment|/* allow for multiple IRQs */
DECL|member|scb_array
r_struct
id|aic7xxx_scb
id|scb_array
(braket
id|AIC7XXX_MAXSCB
)braket
suffix:semicolon
multiline_comment|/* active commands */
DECL|member|free_scb
r_struct
id|aic7xxx_scb
op_star
id|free_scb
suffix:semicolon
multiline_comment|/* list of free SCBs */
)brace
suffix:semicolon
DECL|struct|aic7xxx_host_config
r_struct
id|aic7xxx_host_config
(brace
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* IRQ number */
DECL|member|base
r_int
id|base
suffix:semicolon
multiline_comment|/* I/O base */
DECL|member|maxscb
r_int
id|maxscb
suffix:semicolon
multiline_comment|/* hardware SCBs */
DECL|member|unpause
r_int
id|unpause
suffix:semicolon
multiline_comment|/* unpause value for HCNTRL */
DECL|member|pause
r_int
id|pause
suffix:semicolon
multiline_comment|/* pause value for HCNTRL */
DECL|member|scsi_id
r_int
id|scsi_id
suffix:semicolon
multiline_comment|/* host SCSI ID */
DECL|member|scsi_id_b
r_int
id|scsi_id_b
suffix:semicolon
multiline_comment|/* host SCSI ID B channel for twin cards */
DECL|member|extended
r_int
id|extended
suffix:semicolon
multiline_comment|/* extended xlate? */
DECL|member|busrtime
r_int
id|busrtime
suffix:semicolon
multiline_comment|/* bus release time */
DECL|member|type
id|aha_type
id|type
suffix:semicolon
multiline_comment|/* card type */
DECL|member|bus_type
id|aha_bus_type
id|bus_type
suffix:semicolon
multiline_comment|/* normal/twin/wide bus */
DECL|member|parity
id|aha_status_type
id|parity
suffix:semicolon
multiline_comment|/* bus parity enabled/disabled */
DECL|member|low_term
id|aha_status_type
id|low_term
suffix:semicolon
multiline_comment|/* bus termination low byte */
DECL|member|high_term
id|aha_status_type
id|high_term
suffix:semicolon
multiline_comment|/* bus termination high byte (wide cards only) */
)brace
suffix:semicolon
multiline_comment|/*&n; * Valid SCSIRATE values. (p. 3-17)&n; * Provides a mapping of tranfer periods in ns to the proper value to&n; * stick in the scsiscfr reg to use that transfer rate.&n; */
r_static
r_struct
(brace
DECL|member|period
r_int
id|period
suffix:semicolon
DECL|member|rate
r_int
id|rate
suffix:semicolon
DECL|member|english
r_char
op_star
id|english
suffix:semicolon
DECL|variable|aic7xxx_syncrates
)brace
id|aic7xxx_syncrates
(braket
)braket
op_assign
(brace
(brace
l_int|100
comma
l_int|0
comma
l_string|&quot;10.0&quot;
)brace
comma
(brace
l_int|125
comma
l_int|1
comma
l_string|&quot;8.0&quot;
)brace
comma
(brace
l_int|150
comma
l_int|2
comma
l_string|&quot;6.67&quot;
)brace
comma
(brace
l_int|175
comma
l_int|3
comma
l_string|&quot;5.7&quot;
)brace
comma
(brace
l_int|200
comma
l_int|4
comma
l_string|&quot;5.0&quot;
)brace
comma
(brace
l_int|225
comma
l_int|5
comma
l_string|&quot;4.4&quot;
)brace
comma
(brace
l_int|250
comma
l_int|6
comma
l_string|&quot;4.0&quot;
)brace
comma
(brace
l_int|275
comma
l_int|7
comma
l_string|&quot;3.6&quot;
)brace
)brace
suffix:semicolon
DECL|variable|num_aic7xxx_syncrates
r_static
r_int
id|num_aic7xxx_syncrates
op_assign
r_sizeof
(paren
id|aic7xxx_syncrates
)paren
op_div
r_sizeof
(paren
id|aic7xxx_syncrates
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#ifdef AIC7XXX_DEBUG
r_extern
r_int
id|vsprintf
c_func
(paren
r_char
op_star
comma
r_const
r_char
op_star
comma
id|va_list
)paren
suffix:semicolon
r_static
r_void
DECL|function|debug
id|debug
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|ap
suffix:semicolon
r_char
id|buf
(braket
l_int|256
)braket
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|fmt
)paren
suffix:semicolon
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|ap
)paren
suffix:semicolon
id|printk
c_func
(paren
id|buf
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|debug_config
id|debug_config
c_func
(paren
r_struct
id|aic7xxx_host_config
op_star
id|p
)paren
(brace
r_int
id|host_conf
comma
id|scsi_conf
suffix:semicolon
r_int
r_char
id|brelease
suffix:semicolon
r_int
r_char
id|dfthresh
suffix:semicolon
r_static
r_int
id|DFT
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|50
comma
l_int|75
comma
l_int|100
)brace
suffix:semicolon
r_static
r_int
id|SST
(braket
)braket
op_assign
(brace
l_int|256
comma
l_int|128
comma
l_int|64
comma
l_int|32
)brace
suffix:semicolon
r_static
r_char
op_star
id|BUSW
(braket
)braket
op_assign
(brace
l_string|&quot;&quot;
comma
l_string|&quot;-TWIN&quot;
comma
l_string|&quot;-WIDE&quot;
)brace
suffix:semicolon
id|host_conf
op_assign
id|inb
c_func
(paren
id|HA_HOSTCONF
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|scsi_conf
op_assign
id|inb
c_func
(paren
id|HA_SCSICONF
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;   * The 7870 gets the bus release time and data FIFO threshold&n;   * from the serial EEPROM (stored in the config structure) and&n;   * scsi_conf register respectively.  The 7770 gets the bus&n;   * release time and data FIFO threshold from the scsi_conf and&n;   * host_conf registers respectively.&n;   */
r_if
c_cond
(paren
(paren
id|p-&gt;type
op_eq
id|AIC_274x
)paren
op_logical_or
(paren
id|p-&gt;type
op_eq
id|AIC_284x
)paren
)paren
(brace
id|brelease
op_assign
id|scsi_conf
op_amp
l_int|0x3F
suffix:semicolon
id|dfthresh
op_assign
id|host_conf
op_rshift
l_int|6
suffix:semicolon
)brace
r_else
(brace
id|brelease
op_assign
id|p-&gt;busrtime
suffix:semicolon
id|dfthresh
op_assign
id|scsi_conf
op_rshift
l_int|6
suffix:semicolon
)brace
r_if
c_cond
(paren
id|brelease
op_eq
l_int|0
)paren
(brace
id|brelease
op_assign
l_int|2
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|p-&gt;type
)paren
(brace
r_case
id|AIC_274x
suffix:colon
id|printk
c_func
(paren
l_string|&quot;AIC7770%s AT EISA SLOT %d:&bslash;n&quot;
comma
id|BUSW
(braket
id|p-&gt;bus_type
)braket
comma
id|p-&gt;base
op_rshift
l_int|12
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AIC_284x
suffix:colon
id|printk
c_func
(paren
l_string|&quot;AIC7770%s AT VLB SLOT %d:&bslash;n&quot;
comma
id|BUSW
(braket
id|p-&gt;bus_type
)braket
comma
id|p-&gt;base
op_rshift
l_int|12
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AIC_7870
suffix:colon
id|printk
c_func
(paren
l_string|&quot;AIC7870%s (PCI-bus):&bslash;n&quot;
comma
id|BUSW
(braket
id|p-&gt;bus_type
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AIC_7850
suffix:colon
id|printk
c_func
(paren
l_string|&quot;AIC7850%s (PCI-bus):&bslash;n&quot;
comma
id|BUSW
(braket
id|p-&gt;bus_type
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AIC_7872
suffix:colon
id|printk
c_func
(paren
l_string|&quot;AIC7872%s (PCI-bus):&bslash;n&quot;
comma
id|BUSW
(braket
id|p-&gt;bus_type
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;aic7xxx debug_config: internal error&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;    irq %d&bslash;n&quot;
l_string|&quot;    bus release time %d bclks&bslash;n&quot;
l_string|&quot;    data fifo threshold %d%%&bslash;n&quot;
comma
id|p-&gt;irq
comma
id|brelease
comma
id|DFT
(braket
id|dfthresh
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    SCSI CHANNEL A:&bslash;n&quot;
l_string|&quot;        scsi id %d&bslash;n&quot;
l_string|&quot;        scsi selection timeout %d ms&bslash;n&quot;
l_string|&quot;        scsi bus reset at power-on %sabled&bslash;n&quot;
comma
id|scsi_conf
op_amp
l_int|0x07
comma
id|SST
(braket
(paren
id|scsi_conf
op_rshift
l_int|3
)paren
op_amp
l_int|0x03
)braket
comma
(paren
id|scsi_conf
op_amp
l_int|0x40
)paren
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|p-&gt;type
op_eq
id|AIC_274x
)paren
op_logical_or
(paren
id|p-&gt;type
op_eq
id|AIC_284x
)paren
)paren
op_logical_and
id|p-&gt;parity
op_eq
id|AIC_UNKNOWN
)paren
(brace
multiline_comment|/* Set the parity for 7770 based cards. */
id|p-&gt;parity
op_assign
(paren
id|scsi_conf
op_amp
l_int|0x20
)paren
ques
c_cond
id|AIC_ENABLED
suffix:colon
id|AIC_DISABLED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;parity
op_ne
id|AIC_UNKNOWN
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;        scsi bus parity %sabled&bslash;n&quot;
comma
(paren
id|p-&gt;parity
op_eq
id|AIC_ENABLED
)paren
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;type
op_eq
id|AIC_274x
)paren
(brace
id|p-&gt;low_term
op_assign
(paren
id|scsi_conf
op_amp
l_int|0x80
)paren
ques
c_cond
id|AIC_ENABLED
suffix:colon
id|AIC_DISABLED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;low_term
op_ne
id|AIC_UNKNOWN
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;        scsi bus termination (low byte) %sabled&bslash;n&quot;
comma
(paren
id|p-&gt;low_term
op_eq
id|AIC_ENABLED
)paren
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|p-&gt;bus_type
op_eq
id|AIC_WIDE
)paren
op_logical_and
(paren
id|p-&gt;high_term
op_ne
id|AIC_UNKNOWN
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;        scsi bus termination (high byte) %sabled&bslash;n&quot;
comma
(paren
id|p-&gt;high_term
op_eq
id|AIC_ENABLED
)paren
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
DECL|macro|debug
macro_line|#  define debug(fmt, args...)
DECL|macro|debug_config
macro_line|#  define debug_config(x)
macro_line|#endif AIC7XXX_DEBUG
multiline_comment|/*&n; * XXX - these options apply unilaterally to _all_ 274x/284x/294x&n; *       cards in the system. This should be fixed, but then,&n; *       does anyone really have more than one in a machine?&n; */
DECL|variable|aic7xxx_extended
r_static
r_int
id|aic7xxx_extended
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* extended translation on? */
DECL|variable|aic7xxx_no_reset
r_static
r_int
id|aic7xxx_no_reset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no resetting of SCSI bus */
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_setup&n; *&n; * Description:&n; *   Handle Linux boot parameters.&n; *-F*************************************************************************/
r_void
DECL|function|aic7xxx_setup
id|aic7xxx_setup
c_func
(paren
r_char
op_star
id|s
comma
r_int
op_star
id|dummy
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_static
r_struct
(brace
r_char
op_star
id|name
suffix:semicolon
r_int
op_star
id|flag
suffix:semicolon
)brace
id|options
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;extended&quot;
comma
op_amp
id|aic7xxx_extended
)brace
comma
(brace
l_string|&quot;no_reset&quot;
comma
op_amp
id|aic7xxx_no_reset
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|strtok
c_func
(paren
id|s
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|strtok
c_func
(paren
l_int|NULL
comma
l_string|&quot;,&quot;
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|options
(braket
id|i
)braket
dot
id|name
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|options
(braket
id|i
)braket
dot
id|name
comma
id|p
)paren
)paren
(brace
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
op_assign
op_logical_neg
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_loadseq&n; *&n; * Description:&n; *   Load the sequencer code into the controller memory.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_loadseq
id|aic7xxx_loadseq
c_func
(paren
r_int
id|base
)paren
(brace
r_static
r_int
r_char
id|seqprog
(braket
)braket
op_assign
(brace
multiline_comment|/*&n;     * Each sequencer instruction is 29 bits&n;     * long (fill in the excess with zeroes)&n;     * and has to be loaded from least -&gt; most&n;     * significant byte, so this table has the&n;     * byte ordering reversed.&n;     */
macro_line|#   include &quot;aic7xxx_seq.h&quot;
)brace
suffix:semicolon
multiline_comment|/*&n;   * When the AIC-7770 is paused (as on chip reset), the&n;   * sequencer address can be altered and a sequencer&n;   * program can be loaded by writing it, byte by byte, to&n;   * the sequencer RAM port - the Adaptec documentation&n;   * recommends using REP OUTSB to do this, hence the inline&n;   * assembly. Since the address autoincrements as we load&n;   * the program, reset it back to zero afterward. Disable&n;   * sequencer RAM parity error detection while loading, and&n;   * make sure the LOADRAM bit is enabled for loading.&n;   */
id|outb
c_func
(paren
id|PERRORDIS
op_or
id|SEQRESET
op_or
id|LOADRAM
comma
id|SEQCTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;cld&bslash;n&bslash;t&quot;
l_string|&quot;rep&bslash;n&bslash;t&quot;
l_string|&quot;outsb&quot;
suffix:colon
multiline_comment|/* no output */
suffix:colon
l_string|&quot;S&quot;
(paren
id|seqprog
)paren
comma
l_string|&quot;c&quot;
(paren
r_sizeof
(paren
id|seqprog
)paren
)paren
comma
l_string|&quot;d&quot;
(paren
id|SEQRAM
c_func
(paren
id|base
)paren
)paren
suffix:colon
l_string|&quot;si&quot;
comma
l_string|&quot;cx&quot;
comma
l_string|&quot;dx&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;   * WARNING!  This is a magic sequence!  After extensive&n;   * experimentation, it seems that you MUST turn off the&n;   * LOADRAM bit before you play with SEQADDR again, else&n;   * you will end up with parity errors being flagged on&n;   * your sequencer program. (You would also think that&n;   * turning off LOADRAM and setting SEQRESET to reset the&n;   * address to zero would work, but you need to do it twice&n;   * for it to take effect on the address. Timing problem?)&n;   */
r_do
(brace
multiline_comment|/*&n;     * Actually, reset it until&n;     * the address shows up as&n;     * zero just to be safe..&n;     */
id|outb
c_func
(paren
id|SEQRESET
op_or
id|FASTMODE
comma
id|SEQCTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|SEQADDR0
c_func
(paren
id|base
)paren
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
id|inb
c_func
(paren
id|SEQADDR1
c_func
(paren
id|base
)paren
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_delay&n; *&n; * Description:&n; *   Delay for specified amount of time.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_delay
id|aic7xxx_delay
c_func
(paren
r_int
id|seconds
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|i
op_assign
id|jiffies
op_plus
(paren
id|seconds
op_star
l_int|100
)paren
suffix:semicolon
multiline_comment|/* compute time to stop */
r_while
c_loop
(paren
id|jiffies
OL
id|i
)paren
(brace
suffix:semicolon
multiline_comment|/* Do nothing! */
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   rcs_version&n; *&n; * Description:&n; *   Return a string containing just the RCS version number from either&n; *   an Id or Revison RCS clause.&n; *-F*************************************************************************/
r_const
r_char
op_star
DECL|function|rcs_version
id|rcs_version
c_func
(paren
r_const
r_char
op_star
id|version_info
)paren
(brace
r_static
r_char
id|buf
(braket
l_int|10
)braket
suffix:semicolon
r_char
op_star
id|bp
comma
op_star
id|ep
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|strcpy
c_func
(paren
id|buf
comma
l_string|&quot;????&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|version_info
comma
l_string|&quot;$Id: &quot;
comma
l_int|5
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|bp
op_assign
id|strchr
c_func
(paren
id|version_info
comma
l_char|&squot; &squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|bp
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bp
op_assign
id|strchr
c_func
(paren
id|bp
comma
l_char|&squot; &squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|bp
op_increment
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|version_info
comma
l_string|&quot;$Revision: &quot;
comma
l_int|11
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|bp
op_assign
id|strchr
c_func
(paren
id|version_info
comma
l_char|&squot; &squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|bp
op_increment
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|bp
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|ep
op_assign
id|strchr
c_func
(paren
id|bp
comma
l_char|&squot; &squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_register
r_int
id|len
op_assign
id|ep
op_minus
id|bp
suffix:semicolon
id|strncpy
c_func
(paren
id|buf
comma
id|bp
comma
id|len
)paren
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
r_return
id|buf
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_info&n; *&n; * Description:&n; *   Return a string describing the driver.&n; *-F*************************************************************************/
r_const
r_char
op_star
DECL|function|aic7xxx_info
id|aic7xxx_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|notused
)paren
(brace
r_static
r_char
id|buffer
(braket
l_int|128
)braket
suffix:semicolon
id|strcpy
c_func
(paren
id|buffer
comma
l_string|&quot;Adaptec AHA274x/284x/294x (EISA/VLB/PCI-Fast SCSI) &quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|buffer
comma
id|rcs_version
c_func
(paren
id|AIC7XXX_C_VERSION
)paren
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|buffer
comma
l_string|&quot;/&quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|buffer
comma
id|rcs_version
c_func
(paren
id|AIC7XXX_H_VERSION
)paren
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|buffer
comma
l_string|&quot;/&quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|buffer
comma
id|rcs_version
c_func
(paren
id|AIC7XXX_SEQ_VER
)paren
)paren
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_putscb&n; *&n; * Description:&n; *   Transfer a SCB to the controller.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_putscb
id|aic7xxx_putscb
c_func
(paren
r_int
id|base
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
macro_line|#ifdef AIC7XXX_USE_DMA
multiline_comment|/*&n;   * All we need to do, is to output the position&n;   * of the SCB in the SCBARRAY to the QINFIFO&n;   * of the host adapter.&n;   */
id|outb
c_func
(paren
id|scb-&gt;position
comma
id|QINFIFO
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;   * By turning on the SCB auto increment, any reference&n;   * to the SCB I/O space postincrements the SCB address&n;   * we&squot;re looking at. So turn this on and dump the relevant&n;   * portion of the SCB to the card.&n;   */
id|outb
c_func
(paren
id|SCBAUTO
comma
id|SCBCNT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;cld&bslash;n&bslash;t&quot;
l_string|&quot;rep&bslash;n&bslash;t&quot;
l_string|&quot;outsb&quot;
suffix:colon
multiline_comment|/* no output */
suffix:colon
l_string|&quot;S&quot;
(paren
id|scb
)paren
comma
l_string|&quot;c&quot;
(paren
id|SCB_DOWNLOAD_SIZE
)paren
comma
l_string|&quot;d&quot;
(paren
id|SCBARRAY
c_func
(paren
id|base
)paren
)paren
suffix:colon
l_string|&quot;si&quot;
comma
l_string|&quot;cx&quot;
comma
l_string|&quot;dx&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCBCNT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_putdmascb&n; *&n; * Description:&n; *   DMA a SCB to the controller.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_putdmascb
id|aic7xxx_putdmascb
c_func
(paren
r_int
id|base
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
multiline_comment|/*&n;   * By turning on the SCB auto increment, any reference&n;   * to the SCB I/O space postincrements the SCB address&n;   * we&squot;re looking at. So turn this on and dump the relevant&n;   * portion of the SCB to the card.&n;   */
id|outb
c_func
(paren
id|SCBAUTO
comma
id|SCBCNT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;cld&bslash;n&bslash;t&quot;
l_string|&quot;rep&bslash;n&bslash;t&quot;
l_string|&quot;outsb&quot;
suffix:colon
multiline_comment|/* no output */
suffix:colon
l_string|&quot;S&quot;
(paren
id|scb
)paren
comma
l_string|&quot;c&quot;
(paren
l_int|31
)paren
comma
l_string|&quot;d&quot;
(paren
id|SCBARRAY
c_func
(paren
id|base
)paren
)paren
suffix:colon
l_string|&quot;si&quot;
comma
l_string|&quot;cx&quot;
comma
l_string|&quot;dx&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCBCNT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_getscb&n; *&n; * Description:&n; *   Get a SCB from the controller.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_getscb
id|aic7xxx_getscb
c_func
(paren
r_int
id|base
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
multiline_comment|/*&n;   * This is almost identical to aic7xxx_putscb().&n;   */
id|outb
c_func
(paren
id|SCBAUTO
comma
id|SCBCNT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;cld&bslash;n&bslash;t&quot;
l_string|&quot;rep&bslash;n&bslash;t&quot;
l_string|&quot;insb&quot;
suffix:colon
multiline_comment|/* no output */
suffix:colon
l_string|&quot;D&quot;
(paren
id|scb
)paren
comma
l_string|&quot;c&quot;
(paren
id|SCB_UPLOAD_SIZE
)paren
comma
l_string|&quot;d&quot;
(paren
id|SCBARRAY
c_func
(paren
id|base
)paren
)paren
suffix:colon
l_string|&quot;di&quot;
comma
l_string|&quot;cx&quot;
comma
l_string|&quot;dx&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCBCNT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_length&n; *&n; * Description:&n; *   How much data should be transferred for this SCSI command? Stop&n; *   at segment sg_last if it&squot;s a scatter-gather command so we can&n; *   compute underflow easily.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_length
id|aic7xxx_length
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|sg_last
)paren
(brace
r_int
id|i
comma
id|segments
suffix:semicolon
r_int
id|length
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
id|segments
op_assign
id|cmd-&gt;use_sg
op_minus
id|sg_last
suffix:semicolon
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|length
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;use_sg
op_logical_and
id|i
OL
id|segments
suffix:semicolon
id|i
op_increment
)paren
(brace
id|length
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
)brace
r_else
(brace
id|length
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
)brace
r_return
id|length
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_scsirate&n; *&n; * Description:&n; *   Look up the valid period to SCSIRATE conversion in our table&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_scsirate
id|aic7xxx_scsirate
c_func
(paren
r_int
r_char
op_star
id|scsirate
comma
r_int
r_char
id|period
comma
r_int
r_char
id|offset
comma
r_int
id|target
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_aic7xxx_syncrates
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|aic7xxx_syncrates
(braket
id|i
)braket
dot
id|period
op_minus
id|period
)paren
op_ge
l_int|0
)paren
(brace
op_star
id|scsirate
op_assign
(paren
id|aic7xxx_syncrates
(braket
id|i
)braket
dot
id|rate
op_lshift
l_int|4
)paren
op_or
(paren
id|offset
op_amp
l_int|0x0F
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aic7xxx: target %d now synchronous at %sMb/s, offset = 0x%x&bslash;n&quot;
comma
id|target
comma
id|aic7xxx_syncrates
(braket
id|i
)braket
dot
id|english
comma
id|offset
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Default to asyncronous transfer&n;   */
op_star
id|scsirate
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aic7xxx: target %d using asynchronous transfers&bslash;n&quot;
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_isr&n; *&n; * Description:&n; *   SCSI controller interrupt handler.&n; *&n; *   NOTE: Since we declared this using SA_INTERRUPT, interrupts should&n; *         be disabled all through this function unless we say otherwise.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_isr
id|aic7xxx_isr
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|base
comma
id|intstat
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
r_struct
id|aic7xxx_scb
op_star
id|scb
suffix:semicolon
r_int
r_char
id|active
comma
id|ha_flags
comma
id|transfer
suffix:semicolon
r_int
r_char
id|scsi_id
comma
id|bus_width
suffix:semicolon
r_int
r_char
id|offset
comma
id|rate
comma
id|scratch
suffix:semicolon
r_int
r_char
id|max_offset
suffix:semicolon
r_int
r_char
id|head
comma
id|tail
suffix:semicolon
r_int
r_int
id|target_mask
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_void
op_star
id|addr
suffix:semicolon
r_int
id|actual
suffix:semicolon
r_int
id|target
comma
id|tcl
suffix:semicolon
r_int
id|scbptr
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
macro_line|#if 0
r_static
id|int_count
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|aic7xxx_boards
(braket
id|irq
)braket
op_member_access_from_pointer
id|hostdata
suffix:semicolon
macro_line|#ifdef AIC7XXX_SHARE_IRQS
multiline_comment|/*&n;   * Search for the host with a pending interrupt.&n;   */
r_while
c_loop
(paren
(paren
id|p
op_ne
l_int|NULL
)paren
op_logical_and
op_logical_neg
(paren
id|inb
c_func
(paren
id|INTSTAT
c_func
(paren
id|p-&gt;base
)paren
)paren
op_amp
id|INT_PEND
)paren
)paren
(brace
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|p-&gt;next-&gt;hostdata
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: Encountered spurious interrupt.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|base
op_assign
id|p-&gt;base
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;isr_count
op_eq
l_int|0xffffffff
)paren
(brace
id|p-&gt;isr_count
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;isr_count
op_assign
id|p-&gt;isr_count
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|p-&gt;a_scanned
op_eq
l_int|0
)paren
op_logical_and
(paren
id|p-&gt;isr_count
op_eq
l_int|1
)paren
)paren
(brace
multiline_comment|/* Allow for one interrupt when the card is enabled. */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;   * Handle all the interrupt sources - especially for SCSI&n;   * interrupts, we won&squot;t get a second chance at them.&n;   */
id|intstat
op_assign
id|inb
c_func
(paren
id|INTSTAT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intstat
op_amp
id|BRKADRINT
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|errno
op_assign
id|inb
c_func
(paren
id|ERROR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: brkadrint (0x%x):&bslash;n&quot;
comma
id|errno
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMBER
c_func
(paren
id|hard_error
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|errno
op_amp
id|hard_error
(braket
id|i
)braket
dot
id|errno
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  %s&bslash;n&quot;
comma
id|hard_error
(braket
id|i
)braket
dot
id|errmesg
)paren
suffix:semicolon
)brace
)brace
id|panic
c_func
(paren
l_string|&quot;aic7xxx_isr: brkadrint, error = 0x%x, seqaddr = 0x%x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|ERROR
c_func
(paren
id|base
)paren
)paren
comma
id|inb
c_func
(paren
id|SEQADDR1
c_func
(paren
id|base
)paren
)paren
op_lshift
l_int|8
op_or
id|inb
c_func
(paren
id|SEQADDR0
c_func
(paren
id|base
)paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intstat
op_amp
id|SEQINT
)paren
(brace
multiline_comment|/*&n;     * Although the sequencer is paused immediately on&n;     * a SEQINT, an interrupt for a SCSIINT or a CMDCMPLT&n;     * condition will have unpaused the sequencer before&n;     * this point.&n;     */
id|PAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|intstat
op_amp
id|SEQINT_MASK
)paren
(brace
r_case
id|BAD_PHASE
suffix:colon
id|panic
c_func
(paren
l_string|&quot;aic7xxx_isr: unknown scsi bus phase&bslash;n&quot;
)paren
suffix:semicolon
r_case
id|SEND_REJECT
suffix:colon
id|debug
c_func
(paren
l_string|&quot;aic7xxx_isr warning: issuing message reject, 1st byte 0x%x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|HA_REJBYTE
c_func
(paren
id|base
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NO_IDENT
suffix:colon
id|panic
c_func
(paren
l_string|&quot;aic7xxx_isr: reconnecting target %d at seqaddr 0x%x &quot;
l_string|&quot;didn&squot;t issue IDENTIFY message&bslash;n&quot;
comma
(paren
id|inb
c_func
(paren
id|SELID
c_func
(paren
id|base
)paren
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0x0F
comma
(paren
id|inb
c_func
(paren
id|SEQADDR1
c_func
(paren
id|base
)paren
)paren
op_lshift
l_int|8
)paren
op_or
id|inb
c_func
(paren
id|SEQADDR0
c_func
(paren
id|base
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NO_MATCH
suffix:colon
id|tcl
op_assign
id|inb
c_func
(paren
id|SCBARRAY
c_func
(paren
id|base
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|target
op_assign
(paren
id|tcl
op_rshift
l_int|4
)paren
op_amp
l_int|0x0F
suffix:semicolon
multiline_comment|/* Purposefully mask off the top bit of targets 8-15. */
id|target_mask
op_assign
l_int|0x01
op_lshift
(paren
id|target
op_amp
l_int|0x07
)paren
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;aic7xxx_isr: sequencer couldn&squot;t find match &quot;
l_string|&quot;for reconnecting target %d, channel %d, lun %d - &quot;
l_string|&quot;issuing ABORT&bslash;n&quot;
comma
id|target
comma
(paren
id|tcl
op_amp
l_int|0x08
)paren
op_rshift
l_int|3
comma
id|tcl
op_amp
l_int|0x07
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcl
op_amp
l_int|0x88
)paren
(brace
multiline_comment|/* Second channel stores its info in byte&n;&t;   * two of HA_ACTIVE&n;&t;   */
id|active
op_assign
id|inb
c_func
(paren
id|HA_ACTIVE1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|active
op_assign
id|active
op_amp
op_complement
(paren
id|target_mask
)paren
suffix:semicolon
id|outb
c_func
(paren
id|active
comma
id|HA_ACTIVE1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|active
op_assign
id|inb
c_func
(paren
id|HA_ACTIVE0
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|active
op_assign
id|active
op_amp
op_complement
(paren
id|target_mask
)paren
suffix:semicolon
id|outb
c_func
(paren
id|active
comma
id|HA_ACTIVE0
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef AIC7XXX_USE_DMA
id|outb
c_func
(paren
id|SCB_NEEDDMA
comma
id|SCBARRAY
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Check out why this use to be outb(0x80, CLRINT(base))&n;&t; * clear the timeout&n;&t; */
id|outb
c_func
(paren
id|CLRSELTIMEO
comma
id|CLRSINT1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|RESTART_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MSG_SDTR
suffix:colon
multiline_comment|/*&n;&t; * Help the sequencer to translate the negotiated&n;&t; * transfer rate. Transfer is 1/4 the period&n;&t; * in ns as is returned by the sync negotiation&n;&t; * message. So, we must multiply by four.&n;&t; */
id|transfer
op_assign
(paren
id|inb
c_func
(paren
id|HA_ARG_1
c_func
(paren
id|base
)paren
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
id|offset
op_assign
id|inb
c_func
(paren
id|ACCUM
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|scsi_id
op_assign
id|inb
c_func
(paren
id|SCSIID
c_func
(paren
id|base
)paren
)paren
op_rshift
l_int|0x04
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|SBLKCTL
c_func
(paren
id|base
)paren
)paren
op_amp
l_int|0x08
)paren
(brace
id|scsi_id
op_assign
id|scsi_id
op_plus
l_int|8
suffix:semicolon
multiline_comment|/* B channel */
)brace
id|target_mask
op_assign
(paren
l_int|0x01
op_lshift
id|scsi_id
)paren
suffix:semicolon
id|scratch
op_assign
id|inb
c_func
(paren
id|HA_TARG_SCRATCH
c_func
(paren
id|base
)paren
op_plus
id|scsi_id
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The maximum offset for a wide device is 0x08; for a&n;&t; * 8-bit bus device the maximum offset is 0x0f.&n;&t; */
r_if
c_cond
(paren
id|scratch
op_amp
l_int|0x80
)paren
(brace
id|max_offset
op_assign
l_int|0x08
suffix:semicolon
)brace
r_else
(brace
id|max_offset
op_assign
l_int|0x0f
suffix:semicolon
)brace
id|aic7xxx_scsirate
c_func
(paren
op_amp
id|rate
comma
id|transfer
comma
id|MIN
c_func
(paren
id|offset
comma
id|max_offset
)paren
comma
id|scsi_id
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Preserve the wide transfer flag.&n;&t; */
id|rate
op_assign
id|rate
op_or
(paren
id|scratch
op_amp
l_int|0x80
)paren
suffix:semicolon
id|outb
c_func
(paren
id|rate
comma
id|HA_TARG_SCRATCH
c_func
(paren
id|base
)paren
op_plus
id|scsi_id
)paren
suffix:semicolon
id|outb
c_func
(paren
id|rate
comma
id|SCSIRATE
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rate
op_amp
l_int|0xf
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;   * The requested rate was so low that asynchronous transfers&n;&t;   * are faster (not to mention the controller won&squot;t support&n;&t;   * them), so we issue a reject to ensure we go to asynchronous&n;&t;   * transfers.&n;&t;   */
id|outb
c_func
(paren
id|SEND_REJ
comma
id|HA_RETURN_1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;   * See if we initiated Sync Negotiation&n;&t;   */
r_if
c_cond
(paren
id|p-&gt;sdtr_pending
op_amp
id|target_mask
)paren
(brace
multiline_comment|/*&n;&t;     * Don&squot;t send an SDTR back to the target.&n;&t;     */
id|outb
c_func
(paren
l_int|0
comma
id|HA_RETURN_1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;     * Send our own SDTR in reply.&n;&t;     */
id|printk
c_func
(paren
l_string|&quot;Sending SDTR!!&bslash;n&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SEND_SDTR
comma
id|HA_RETURN_1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Clear the flags.&n;&t; */
id|p-&gt;needsdtr
op_assign
id|p-&gt;needsdtr
op_amp
op_complement
id|target_mask
suffix:semicolon
id|p-&gt;sdtr_pending
op_assign
id|p-&gt;sdtr_pending
op_amp
op_complement
id|target_mask
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MSG_WDTR
suffix:colon
(brace
id|bus_width
op_assign
id|inb
c_func
(paren
id|ACCUM
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|scsi_id
op_assign
id|inb
c_func
(paren
id|SCSIID
c_func
(paren
id|base
)paren
)paren
op_rshift
l_int|0x04
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|SBLKCTL
c_func
(paren
id|base
)paren
)paren
op_amp
l_int|0x08
)paren
(brace
id|scsi_id
op_assign
id|scsi_id
op_plus
l_int|8
suffix:semicolon
multiline_comment|/* B channel */
)brace
id|printk
c_func
(paren
l_string|&quot;Received MSG_WDTR, scsi_id = %d, &quot;
l_string|&quot;needwdtr = 0x%x&bslash;n&quot;
comma
id|scsi_id
comma
id|p-&gt;needwdtr
)paren
suffix:semicolon
id|scratch
op_assign
id|inb
c_func
(paren
id|HA_TARG_SCRATCH
c_func
(paren
id|base
)paren
op_plus
id|scsi_id
)paren
suffix:semicolon
id|target_mask
op_assign
(paren
l_int|0x01
op_lshift
id|scsi_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;wdtr_pending
op_amp
id|target_mask
)paren
(brace
multiline_comment|/*&n;&t;   * Don&squot;t send an WDTR back to the target, since we asked first.&n;&t;   */
id|outb
c_func
(paren
l_int|0
comma
id|HA_RETURN_1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bus_width
)paren
(brace
r_case
id|BUS_8_BIT
suffix:colon
id|scratch
op_assign
id|scratch
op_amp
l_int|0x7F
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BUS_16_BIT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: target %d using 16 bit transfers&bslash;n&quot;
comma
id|scsi_id
)paren
suffix:semicolon
id|scratch
op_assign
id|scratch
op_or
l_int|0x80
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;   * Send our own WDTR in reply.&n;&t;   */
id|printk
c_func
(paren
l_string|&quot;Will send WDTR!!&bslash;n&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bus_width
)paren
(brace
r_case
id|BUS_8_BIT
suffix:colon
id|scratch
op_assign
id|scratch
op_amp
l_int|0x7F
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BUS_32_BIT
suffix:colon
multiline_comment|/* Negotiate 16 bits. */
id|bus_width
op_assign
id|BUS_16_BIT
suffix:semicolon
multiline_comment|/* Yes, we mean to fall thru here */
r_case
id|BUS_16_BIT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: target %d using 16 bit transfers&bslash;n&quot;
comma
id|scsi_id
)paren
suffix:semicolon
id|scratch
op_assign
id|scratch
op_or
l_int|0x80
suffix:semicolon
r_break
suffix:semicolon
)brace
id|outb
c_func
(paren
id|bus_width
op_or
id|SEND_WDTR
comma
id|HA_RETURN_1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
id|p-&gt;needwdtr
op_assign
id|p-&gt;needwdtr
op_amp
op_complement
id|target_mask
suffix:semicolon
id|p-&gt;wdtr_pending
op_assign
id|p-&gt;wdtr_pending
op_amp
op_complement
id|target_mask
suffix:semicolon
id|outb
c_func
(paren
id|scratch
comma
id|HA_TARG_SCRATCH
c_func
(paren
id|base
)paren
op_plus
id|scsi_id
)paren
suffix:semicolon
id|outb
c_func
(paren
id|scratch
comma
id|SCSIRATE
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MSG_REJECT
suffix:colon
(brace
multiline_comment|/*&n;&t; * What we care about here is if we had an&n;&t; * outstanding SDTR or WDTR message for this&n;&t; * target. If we did, this is a signal that&n;&t; * the target is refusing negotiation.&n;&t; */
r_int
r_char
id|targ_scratch
comma
id|scsi_id
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
id|scsi_id
op_assign
id|inb
c_func
(paren
id|SCSIID
c_func
(paren
id|base
)paren
)paren
op_rshift
l_int|0x04
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|SBLKCTL
c_func
(paren
id|base
)paren
)paren
op_amp
l_int|0x08
)paren
(brace
id|scsi_id
op_assign
id|scsi_id
op_plus
l_int|8
suffix:semicolon
)brace
id|mask
op_assign
(paren
l_int|0x01
op_lshift
id|scsi_id
)paren
suffix:semicolon
id|targ_scratch
op_assign
id|inb
c_func
(paren
id|HA_TARG_SCRATCH
c_func
(paren
id|base
)paren
op_plus
id|scsi_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;wdtr_pending
op_amp
id|mask
)paren
(brace
multiline_comment|/*&n;&t;   * note 8bit xfers and clear flag&n;&t;   */
id|targ_scratch
op_assign
id|targ_scratch
op_amp
l_int|0x7F
suffix:semicolon
id|p-&gt;needwdtr
op_assign
id|p-&gt;needwdtr
op_amp
op_complement
id|mask
suffix:semicolon
id|p-&gt;wdtr_pending
op_assign
id|p-&gt;wdtr_pending
op_amp
op_complement
id|mask
suffix:semicolon
id|outb
c_func
(paren
id|targ_scratch
comma
id|HA_TARG_SCRATCH
c_func
(paren
id|base
)paren
op_plus
id|scsi_id
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aic7xxx: target %d refusing WIDE negotiation. Using &quot;
l_string|&quot;8 bit transfers&bslash;n&quot;
comma
id|scsi_id
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|p-&gt;sdtr_pending
op_amp
id|mask
)paren
(brace
multiline_comment|/*&n;&t;     * note asynch xfers and clear flag&n;&t;     */
id|targ_scratch
op_assign
id|targ_scratch
op_amp
l_int|0xF0
suffix:semicolon
id|p-&gt;needsdtr
op_assign
id|p-&gt;needsdtr
op_amp
op_complement
id|mask
suffix:semicolon
id|p-&gt;sdtr_pending
op_assign
id|p-&gt;sdtr_pending
op_amp
op_complement
id|mask
suffix:semicolon
id|outb
c_func
(paren
id|targ_scratch
comma
id|HA_TARG_SCRATCH
c_func
(paren
id|base
)paren
op_plus
id|scsi_id
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aic7xxx: target %d refusing syncronous negotiation. Using &quot;
l_string|&quot;asyncronous transfers&bslash;n&quot;
comma
id|scsi_id
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   * Otherwise, we ignore it.&n;&t;   */
)brace
id|outb
c_func
(paren
id|targ_scratch
comma
id|HA_TARG_SCRATCH
c_func
(paren
id|base
)paren
op_plus
id|scsi_id
)paren
suffix:semicolon
id|outb
c_func
(paren
id|targ_scratch
comma
id|SCSIRATE
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|BAD_STATUS
suffix:colon
id|scsi_id
op_assign
id|inb
c_func
(paren
id|SCSIID
c_func
(paren
id|base
)paren
)paren
op_rshift
l_int|0x04
suffix:semicolon
id|scbptr
op_assign
id|inb
c_func
(paren
id|SCBPTR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|scb
op_assign
op_amp
(paren
id|p-&gt;scb_array
(braket
id|scbptr
)braket
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|HA_RETURN_1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* CHECK_CONDITION may change this */
r_if
c_cond
(paren
(paren
id|scb-&gt;state
op_ne
id|SCB_ACTIVE
)paren
op_logical_or
(paren
id|scb-&gt;cmd
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: referenced scb not valid &quot;
l_string|&quot;during seqint 0x%x scb(%d) state(%x), cmd(%x)&bslash;n&quot;
comma
id|intstat
comma
id|scbptr
comma
id|scb-&gt;state
comma
(paren
r_int
r_int
)paren
id|scb-&gt;cmd
)paren
suffix:semicolon
)brace
r_else
(brace
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
id|aic7xxx_getscb
c_func
(paren
id|base
comma
id|scb
)paren
suffix:semicolon
id|aic7xxx_status
c_func
(paren
id|cmd
)paren
op_assign
id|scb-&gt;target_status
suffix:semicolon
id|cmd-&gt;result
op_assign
id|cmd-&gt;result
op_or
id|scb-&gt;target_status
suffix:semicolon
multiline_comment|/*&n;&t;   * This test is just here for debugging purposes.&n;&t;   * It will go away when the timeout problem is resolved.&n;&t;   */
r_switch
c_cond
(paren
id|status_byte
c_func
(paren
id|scb-&gt;target_status
)paren
)paren
(brace
r_case
id|GOOD
suffix:colon
r_break
suffix:semicolon
r_case
id|CHECK_CONDITION
suffix:colon
r_if
c_cond
(paren
(paren
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_eq
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
id|cmd-&gt;flags
op_amp
id|WAS_SENSE
)paren
)paren
(brace
r_void
op_star
id|req_buf
suffix:semicolon
macro_line|#ifndef AIC7XXX_USE_SG
r_int
r_int
id|req_buflen
suffix:semicolon
macro_line|#endif
multiline_comment|/* Update the timeout for the SCSI command. */
multiline_comment|/*                update_timeout(cmd, SENSE_TIMEOUT); */
multiline_comment|/* Send a sense command to the requesting target. */
id|cmd-&gt;flags
op_assign
id|cmd-&gt;flags
op_or
id|WAS_SENSE
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|scb-&gt;sense_cmd
comma
(paren
r_void
op_star
)paren
id|generic_sense
comma
r_sizeof
(paren
id|generic_sense
)paren
)paren
suffix:semicolon
id|scb-&gt;sense_cmd
(braket
l_int|1
)braket
op_assign
id|cmd-&gt;lun
op_lshift
l_int|5
suffix:semicolon
id|scb-&gt;sense_cmd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
macro_line|#ifdef AIC7XXX_USE_SG
id|scb-&gt;sense_sg.address
op_assign
(paren
r_char
op_star
)paren
op_amp
id|cmd-&gt;sense_buffer
suffix:semicolon
id|scb-&gt;sense_sg.length
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
id|req_buf
op_assign
op_amp
id|scb-&gt;sense_sg
suffix:semicolon
macro_line|#else
id|req_buf
op_assign
op_amp
id|cmd-&gt;sense_buffer
suffix:semicolon
id|req_buflen
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
macro_line|#endif
id|cmd-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|memset
c_func
(paren
id|scb
comma
l_int|0
comma
id|SCB_DOWNLOAD_SIZE
)paren
suffix:semicolon
id|scb-&gt;target_channel_lun
op_assign
(paren
(paren
id|cmd-&gt;target
op_lshift
l_int|4
)paren
op_amp
l_int|0xF0
)paren
op_or
(paren
(paren
id|cmd-&gt;channel
op_amp
l_int|0x01
)paren
op_lshift
l_int|3
)paren
op_or
(paren
id|cmd-&gt;lun
op_amp
l_int|0x07
)paren
suffix:semicolon
id|addr
op_assign
id|scb-&gt;sense_cmd
suffix:semicolon
id|scb-&gt;SCSI_cmd_length
op_assign
id|COMMAND_SIZE
c_func
(paren
id|scb-&gt;sense_cmd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|scb-&gt;SCSI_cmd_pointer
comma
op_amp
id|addr
comma
r_sizeof
(paren
id|scb-&gt;SCSI_cmd_pointer
)paren
)paren
suffix:semicolon
macro_line|#ifdef AIC7XXX_USE_SG
id|scb-&gt;SG_segment_count
op_assign
l_int|1
suffix:semicolon
id|memcpy
(paren
id|scb-&gt;SG_list_pointer
comma
op_amp
id|req_buf
comma
r_sizeof
(paren
id|scb-&gt;SG_list_pointer
)paren
)paren
suffix:semicolon
macro_line|#else
id|scb-&gt;SG_segment_count
op_assign
l_int|0
suffix:semicolon
id|memcpy
(paren
id|scb-&gt;data_pointer
comma
op_amp
id|req_buf
comma
r_sizeof
(paren
id|scb-&gt;data_pointer
)paren
)paren
suffix:semicolon
id|memcpy
(paren
id|scb-&gt;data_count
comma
op_amp
id|req_buflen
comma
l_int|3
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|SCBAUTO
comma
id|SCBCNT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;cld&bslash;n&bslash;t&quot;
l_string|&quot;rep&bslash;n&bslash;t&quot;
l_string|&quot;outsb&quot;
suffix:colon
multiline_comment|/* no output */
suffix:colon
l_string|&quot;S&quot;
(paren
id|scb
)paren
comma
l_string|&quot;c&quot;
(paren
id|SCB_DOWNLOAD_SIZE
)paren
comma
l_string|&quot;d&quot;
(paren
id|SCBARRAY
c_func
(paren
id|base
)paren
)paren
suffix:colon
l_string|&quot;si&quot;
comma
l_string|&quot;cx&quot;
comma
l_string|&quot;dx&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCBCNT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SCB_LIST_NULL
comma
(paren
id|SCBARRAY
c_func
(paren
id|base
)paren
op_plus
l_int|30
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Add this SCB to the &quot;waiting for selection&quot; list.&n;&t;&t; */
id|head
op_assign
id|inb
c_func
(paren
id|WAITING_SCBH
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|tail
op_assign
id|inb
c_func
(paren
id|WAITING_SCBT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head
op_amp
id|SCB_LIST_NULL
)paren
(brace
multiline_comment|/* list is empty */
id|head
op_assign
id|scb-&gt;position
suffix:semicolon
id|tail
op_assign
id|SCB_LIST_NULL
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|tail
op_amp
id|SCB_LIST_NULL
)paren
(brace
multiline_comment|/* list has one element */
id|tail
op_assign
id|scb-&gt;position
suffix:semicolon
id|outb
c_func
(paren
id|head
comma
id|SCBPTR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|tail
comma
(paren
id|SCBARRAY
c_func
(paren
id|base
)paren
op_plus
l_int|30
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* list has more than one element */
id|outb
c_func
(paren
id|tail
comma
id|SCBPTR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|tail
op_assign
id|scb-&gt;position
suffix:semicolon
id|outb
c_func
(paren
id|tail
comma
(paren
id|SCBARRAY
c_func
(paren
id|base
)paren
op_plus
l_int|30
)paren
)paren
suffix:semicolon
)brace
)brace
id|outb
c_func
(paren
id|head
comma
id|WAITING_SCBH
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|tail
comma
id|WAITING_SCBT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SEND_SENSE
comma
id|HA_RETURN_1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* first time sense, no errors */
r_else
(brace
multiline_comment|/*&n;&t;&t; * Indicate that we asked for sense, have the sequencer do&n;&t;&t; * a normal command complete, and have the scsi driver handle&n;&t;&t; * this condition.&n;&t;&t; */
id|cmd-&gt;flags
op_assign
id|cmd-&gt;flags
op_or
id|ASKED_FOR_SENSE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BUSY
suffix:colon
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: Target busy&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
)paren
(brace
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_assign
id|DID_BUS_BUSY
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|QUEUE_FULL
suffix:colon
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: Queue full&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
)paren
(brace
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_assign
id|DID_RETRY_COMMAND
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: Unexpected target status 0x%x&bslash;n&quot;
comma
id|scb-&gt;target_status
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
)paren
(brace
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_assign
id|DID_RETRY_COMMAND
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* end switch */
)brace
multiline_comment|/* end else of */
r_break
suffix:semicolon
r_case
id|RESIDUAL
suffix:colon
id|scbptr
op_assign
id|inb
c_func
(paren
id|SCBPTR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|scb
op_assign
op_amp
(paren
id|p-&gt;scb_array
(braket
id|scbptr
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;state
op_ne
id|SCB_ACTIVE
)paren
op_logical_or
(paren
id|scb-&gt;cmd
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: referenced scb not valid &quot;
l_string|&quot;during seqint 0x%x scb(%d) state(%x), cmd(%x)&bslash;n&quot;
comma
id|intstat
comma
id|scbptr
comma
id|scb-&gt;state
comma
(paren
r_int
r_int
)paren
id|scb-&gt;cmd
)paren
suffix:semicolon
)brace
r_else
(brace
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
multiline_comment|/*&n;&t;   *  Don&squot;t destroy valid residual information with&n;&t;   *  residual coming from a check sense operation.&n;&t;   */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cmd-&gt;flags
op_amp
id|WAS_SENSE
)paren
)paren
(brace
multiline_comment|/*&n;&t;     *  We had an underflow. At this time, there&squot;s only&n;&t;     *  one other driver that bothers to check for this,&n;&t;     *  and cmd-&gt;underflow seems to be set rather half-&n;&t;     *  heartedly in the higher-level SCSI code.&n;&t;     */
id|actual
op_assign
id|aic7xxx_length
c_func
(paren
id|cmd
comma
id|scb-&gt;residual_SG_segment_count
)paren
suffix:semicolon
id|actual
op_sub_assign
(paren
(paren
id|inb
c_func
(paren
id|SCBARRAY
c_func
(paren
id|base
op_plus
l_int|17
)paren
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|inb
c_func
(paren
id|SCBARRAY
c_func
(paren
id|base
op_plus
l_int|16
)paren
)paren
op_lshift
l_int|8
)paren
op_or
id|inb
c_func
(paren
id|SCBARRAY
c_func
(paren
id|base
op_plus
l_int|15
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|actual
OL
id|cmd-&gt;underflow
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: target %d underflow - &quot;
l_string|&quot;wanted (at least) %u, got %u&bslash;n&quot;
comma
id|cmd-&gt;target
comma
id|cmd-&gt;underflow
comma
id|actual
)paren
suffix:semicolon
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_assign
id|DID_RETRY_COMMAND
suffix:semicolon
id|aic7xxx_status
c_func
(paren
id|cmd
)paren
op_assign
id|scb-&gt;target_status
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
r_case
id|ABORT_TAG
suffix:colon
id|scbptr
op_assign
id|inb
c_func
(paren
id|SCBPTR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|scb
op_assign
op_amp
(paren
id|p-&gt;scb_array
(braket
id|scbptr
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;state
op_ne
id|SCB_ACTIVE
)paren
op_logical_or
(paren
id|scb-&gt;cmd
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: referenced scb not valid &quot;
l_string|&quot;during seqint 0x%x scb(%d) state(%x), cmd(%x)&bslash;n&quot;
comma
id|intstat
comma
id|scbptr
comma
id|scb-&gt;state
comma
(paren
r_int
r_int
)paren
id|scb-&gt;cmd
)paren
suffix:semicolon
)brace
r_else
(brace
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
multiline_comment|/*&n;&t;   * We didn&squot;t recieve a valid tag back from the target&n;&t;   * on a reconnect.&n;&t;   */
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: invalid tag recieved on channel %c &quot;
l_string|&quot;target %d, lun %d -- sending ABORT_TAG&bslash;n&quot;
comma
(paren
id|cmd-&gt;channel
op_amp
l_int|0x01
)paren
ques
c_cond
l_char|&squot;B&squot;
suffix:colon
l_char|&squot;A&squot;
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
op_amp
l_int|0x07
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   *  This is a critical section, since we don&squot;t want the&n;&t;   *  queue routine mucking with the host data.&n;&t;   */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   *  Process the command after marking the scb as free&n;&t;   *  and adding it to the free list.&n;&t;   */
id|scb-&gt;state
op_assign
id|SCB_FREE
suffix:semicolon
id|scb-&gt;cmd
op_assign
l_int|NULL
suffix:semicolon
id|scb-&gt;next
op_assign
id|p-&gt;free_scb
suffix:semicolon
multiline_comment|/* preserve next pointer */
id|p-&gt;free_scb
op_assign
id|scb
suffix:semicolon
multiline_comment|/* add at head of list */
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_RETRY_COMMAND
op_lshift
l_int|16
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AWAITING_MSG
suffix:colon
id|scbptr
op_assign
id|inb
c_func
(paren
id|SCBPTR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|scb
op_assign
op_amp
(paren
id|p-&gt;scb_array
(braket
id|scbptr
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;state
op_ne
id|SCB_ACTIVE
)paren
op_logical_or
(paren
id|scb-&gt;cmd
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: referenced scb not valid &quot;
l_string|&quot;during seqint 0x%x scb(%d) state(%x), cmd(%x)&bslash;n&quot;
comma
id|intstat
comma
id|scbptr
comma
id|scb-&gt;state
comma
(paren
r_int
r_int
)paren
id|scb-&gt;cmd
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;   * This SCB had a zero length command, informing the sequencer&n;&t;   * that we wanted to send a special message to this target.&n;&t;   * We only do this for BUS_DEVICE_RESET messages currently.&n;&t;   */
r_if
c_cond
(paren
id|scb-&gt;state
op_amp
id|SCB_DEVICE_RESET
)paren
(brace
id|outb
c_func
(paren
id|MSG_BUS_DEVICE_RESET
comma
id|HA_MSG_START
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|HA_MSG_LEN
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|panic
(paren
l_string|&quot;aic7xxx_isr: AWAITING_SCB for an SCB that does &quot;
l_string|&quot;not have a waiting message&quot;
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* unknown */
id|debug
c_func
(paren
l_string|&quot;aic7xxx_isr: seqint, intstat = 0x%x, scsisigi = 0x%x&bslash;n&quot;
comma
id|intstat
comma
id|inb
c_func
(paren
id|SCSISIGI
c_func
(paren
id|base
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|outb
c_func
(paren
id|CLRSEQINT
comma
id|CLRINT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intstat
op_amp
id|SCSIINT
)paren
(brace
r_int
id|status
op_assign
id|inb
c_func
(paren
id|SSTAT1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|scbptr
op_assign
id|inb
c_func
(paren
id|SCBPTR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|scb
op_assign
op_amp
id|p-&gt;scb_array
(braket
id|scbptr
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;state
op_ne
id|SCB_ACTIVE
)paren
op_logical_or
(paren
id|scb-&gt;cmd
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: no command for scb (scsiint)&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;       * Turn off the interrupt and set status&n;       * to zero, so that it falls through the&n;       * reset of the SCSIINT code.&n;       */
id|outb
c_func
(paren
id|status
comma
id|CLRSINT1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CLRSCSIINT
comma
id|CLRINT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
multiline_comment|/*&n;       * Only the SCSI Status 1 register has information&n;       * about exceptional conditions that we&squot;d have a&n;       * SCSIINT about; anything in SSTAT0 will be handled&n;       * by the sequencer. Note that there can be multiple&n;       * bits set.&n;       */
r_if
c_cond
(paren
id|status
op_amp
id|SELTO
)paren
(brace
r_int
r_char
id|target_mask
op_assign
(paren
l_int|1
op_lshift
(paren
id|cmd-&gt;target
op_amp
l_int|0x07
)paren
)paren
suffix:semicolon
r_int
r_char
id|waiting
suffix:semicolon
multiline_comment|/*&n;&t; * Hardware selection timer has expired. Turn&n;&t; * off SCSI selection sequence.&n;&t; */
id|outb
c_func
(paren
id|ENRSELI
comma
id|SCSISEQ
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_TIME_OUT
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear an pending messages for the timed out&n;&t; * target and mark the target as free.&n;&t; */
id|ha_flags
op_assign
id|inb
c_func
(paren
id|HA_FLAGS
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ha_flags
op_amp
op_complement
id|ACTIVE_MSG
comma
id|HA_FLAGS
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;target_channel_lun
op_amp
l_int|0x88
)paren
(brace
id|active
op_assign
id|inb
c_func
(paren
id|HA_ACTIVE1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|active
op_assign
id|active
op_amp
op_complement
(paren
id|target_mask
)paren
suffix:semicolon
id|outb
c_func
(paren
id|active
comma
id|HA_ACTIVE1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|active
op_assign
id|inb
c_func
(paren
id|HA_ACTIVE0
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|active
op_assign
id|active
op_amp
op_complement
(paren
id|target_mask
)paren
suffix:semicolon
id|outb
c_func
(paren
id|active
comma
id|HA_ACTIVE0
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef AIC7XXX_USE_DMA
id|outb
c_func
(paren
id|SCB_NEEDDMA
comma
id|SCBARRAY
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Shut off the offending interrupt sources, reset&n;&t; * the sequencer address to zero and unpause it,&n;&t; * then call the high-level SCSI completion routine.&n;&t; *&n;&t; * WARNING!  This is a magic sequence!  After many&n;&t; * hours of guesswork, turning off the SCSI interrupts&n;&t; * in CLRSINT? does NOT clear the SCSIINT bit in&n;&t; * INTSTAT. By writing to the (undocumented, unused&n;&t; * according to the AIC-7770 manual) third bit of&n;&t; * CLRINT, you can clear INTSTAT. But, if you do it&n;&t; * while the sequencer is paused, you get a BRKADRINT&n;&t; * with an Illegal Host Address status, so the&n;&t; * sequencer has to be restarted first.&n;&t; */
id|outb
c_func
(paren
id|CLRSELTIMEO
comma
id|CLRSINT1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CLRSCSIINT
comma
id|CLRINT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* Shift the waiting for selection queue forward */
id|waiting
op_assign
id|inb
c_func
(paren
id|WAITING_SCBH
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|waiting
comma
id|SCBPTR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|waiting
op_assign
id|inb
c_func
(paren
id|SCBARRAY
c_func
(paren
id|base
)paren
op_plus
l_int|30
)paren
suffix:semicolon
id|outb
c_func
(paren
id|waiting
comma
id|WAITING_SCBH
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|RESTART_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This is a critical section, since we don&squot;t want the&n;&t; * queue routine mucking with the host data.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Process the command after marking the scb as free&n;&t; * and adding it to the free list.&n;&t; */
id|scb-&gt;state
op_assign
id|SCB_FREE
suffix:semicolon
id|scb-&gt;cmd
op_assign
l_int|NULL
suffix:semicolon
id|scb-&gt;next
op_assign
id|p-&gt;free_scb
suffix:semicolon
multiline_comment|/* preserve next pointer */
id|p-&gt;free_scb
op_assign
id|scb
suffix:semicolon
multiline_comment|/* add at head of list */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: SELTO scb(%d) state(%x), cmd(%x)&bslash;n&quot;
comma
id|scb-&gt;position
comma
id|scb-&gt;state
comma
(paren
r_int
r_int
)paren
id|scb-&gt;cmd
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
id|status
op_amp
id|SCSIPERR
)paren
(brace
multiline_comment|/*&n;&t;   * A parity error has occurred during a data&n;&t;   * transfer phase. Flag it and continue.&n;&t;   */
id|printk
c_func
(paren
l_string|&quot;aic7xxx: parity error on target %d, &quot;
l_string|&quot;channel %d, lun %d&bslash;n&quot;
comma
id|cmd-&gt;target
comma
id|cmd-&gt;channel
op_amp
l_int|0x01
comma
id|cmd-&gt;lun
op_amp
l_int|0x07
)paren
suffix:semicolon
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_assign
id|DID_PARITY
suffix:semicolon
multiline_comment|/*&n;&t;   * Clear interrupt and resume as above.&n;&t;   */
id|outb
c_func
(paren
id|CLRSCSIPERR
comma
id|CLRSINT1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CLRSCSIINT
comma
id|CLRINT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|BUSFREE
)paren
)paren
(brace
multiline_comment|/*&n;&t;      * We don&squot;t know what&squot;s going on. Turn off the&n;&t;      * interrupt source and try to continue.&n;&t;      */
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: sstat1 = 0x%x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|outb
c_func
(paren
id|status
comma
id|CLRSINT1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CLRSCSIINT
comma
id|CLRINT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* else */
)brace
r_if
c_cond
(paren
id|intstat
op_amp
id|CMDCMPLT
)paren
(brace
r_int
id|complete
suffix:semicolon
multiline_comment|/*&n;     * The sequencer will continue running when it&n;     * issues this interrupt. There may be &gt;1 commands&n;     * finished, so loop until we&squot;ve processed them all.&n;     */
r_do
(brace
id|complete
op_assign
id|inb
c_func
(paren
id|QOUTFIFO
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|scb
op_assign
op_amp
(paren
id|p-&gt;scb_array
(braket
id|complete
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;state
op_ne
id|SCB_ACTIVE
)paren
op_logical_or
(paren
id|scb-&gt;cmd
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx warning: &quot;
l_string|&quot;no command for scb %d (cmdcmplt)&bslash;n&quot;
l_string|&quot;QOUTCNT = %d, SCB state = 0x%x, CMD = 0x%x&bslash;n&quot;
comma
id|complete
comma
id|inb
c_func
(paren
id|QOUTFIFO
c_func
(paren
id|base
)paren
)paren
comma
id|scb-&gt;state
comma
(paren
r_int
r_int
)paren
id|scb-&gt;cmd
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CLRCMDINT
comma
id|CLRINT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_lshift
l_int|16
)paren
op_or
id|aic7xxx_status
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd-&gt;flags
op_amp
id|WAS_SENSE
)paren
op_logical_and
op_logical_neg
(paren
id|cmd-&gt;flags
op_amp
id|ASKED_FOR_SENSE
)paren
)paren
(brace
multiline_comment|/* Got sense information. */
id|cmd-&gt;flags
op_assign
id|cmd-&gt;flags
op_amp
id|ASKED_FOR_SENSE
suffix:semicolon
)brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;aic7xxx_intr: (complete) state = %d, cmd = 0x%x, free = 0x%x&bslash;n&quot;
comma
id|scb-&gt;state
comma
(paren
r_int
r_int
)paren
id|scb-&gt;cmd
comma
(paren
r_int
r_int
)paren
id|p-&gt;free_scb
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;       * This is a critical section, since we don&squot;t want the&n;       * queue routine mucking with the host data.&n;       */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|scb-&gt;state
op_assign
id|SCB_FREE
suffix:semicolon
id|scb-&gt;next
op_assign
id|p-&gt;free_scb
suffix:semicolon
id|scb-&gt;cmd
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;free_scb
op_assign
op_amp
(paren
id|p-&gt;scb_array
(braket
id|scb-&gt;position
)braket
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|scb
op_ne
op_amp
id|p-&gt;scb_array
(braket
id|scb-&gt;position
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: (complete) address mismatch, pos %d&bslash;n&quot;
comma
id|scb-&gt;position
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: (complete) state = %d, cmd = 0x%x, free = 0x%x&bslash;n&quot;
comma
id|scb-&gt;state
comma
(paren
r_int
r_int
)paren
id|scb-&gt;cmd
comma
(paren
r_int
r_int
)paren
id|p-&gt;free_scb
)paren
suffix:semicolon
macro_line|#endif
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;       * Clear interrupt status before checking&n;       * the output queue again. This eliminates&n;       * a race condition whereby a command could&n;       * complete between the queue poll and the&n;       * interrupt clearing, so notification of the&n;       * command being complete never made it back&n;       * up to the kernel.&n;       */
id|outb
c_func
(paren
id|CLRCMDINT
comma
id|CLRINT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|inb
c_func
(paren
id|QOUTCNT
c_func
(paren
id|base
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_probe&n; *&n; * Description:&n; *   Probing for EISA boards: it looks like the first two bytes&n; *   are a manufacturer code - three characters, five bits each:&n; *&n; *               BYTE 0   BYTE 1   BYTE 2   BYTE 3&n; *              ?1111122 22233333 PPPPPPPP RRRRRRRR&n; *&n; *   The characters are baselined off ASCII &squot;@&squot;, so add that value&n; *   to each to get the real ASCII code for it. The next two bytes&n; *   appear to be a product and revision number, probably vendor-&n; *   specific. This is what is being searched for at each port,&n; *   and what should probably correspond to the ID= field in the&n; *   ECU&squot;s .cfg file for the card - if your card is not detected,&n; *   make sure your signature is listed in the array.&n; *&n; *   The fourth byte&squot;s lowest bit seems to be an enabled/disabled&n; *   flag (rest of the bits are reserved?).&n; *-F*************************************************************************/
r_static
id|aha_type
DECL|function|aic7xxx_probe
id|aic7xxx_probe
c_func
(paren
r_int
id|slot
comma
r_int
id|base
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|4
)braket
suffix:semicolon
r_static
r_struct
(brace
r_int
id|n
suffix:semicolon
r_int
r_char
id|signature
(braket
r_sizeof
(paren
id|buf
)paren
)braket
suffix:semicolon
id|aha_type
id|type
suffix:semicolon
)brace
id|AIC7xxx
(braket
)braket
op_assign
(brace
(brace
l_int|4
comma
(brace
l_int|0x04
comma
l_int|0x90
comma
l_int|0x77
comma
l_int|0x71
)brace
comma
id|AIC_274x
)brace
comma
multiline_comment|/* host adapter 274x */
(brace
l_int|4
comma
(brace
l_int|0x04
comma
l_int|0x90
comma
l_int|0x77
comma
l_int|0x70
)brace
comma
id|AIC_274x
)brace
comma
multiline_comment|/* motherboard 274x  */
(brace
l_int|4
comma
(brace
l_int|0x04
comma
l_int|0x90
comma
l_int|0x77
comma
l_int|0x56
)brace
comma
id|AIC_284x
)brace
comma
multiline_comment|/* 284x, BIOS enabled */
(brace
l_int|4
comma
(brace
l_int|0x04
comma
l_int|0x90
comma
l_int|0x77
comma
l_int|0x57
)brace
comma
id|AIC_284x
)brace
multiline_comment|/* 284x, BIOS disabled */
)brace
suffix:semicolon
multiline_comment|/*&n;   * The VL-bus cards need to be primed by&n;   * writing before a signature check.&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|buf
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
l_int|0x80
op_plus
id|i
comma
id|base
)paren
suffix:semicolon
id|buf
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|base
op_plus
id|i
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMBER
c_func
(paren
id|AIC7xxx
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;     * Signature match on enabled card?&n;     */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|buf
comma
id|AIC7xxx
(braket
id|i
)braket
dot
id|signature
comma
id|AIC7xxx
(braket
id|i
)braket
dot
id|n
)paren
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|base
op_plus
l_int|4
)paren
op_amp
l_int|1
)paren
(brace
r_return
id|AIC7xxx
(braket
id|i
)braket
dot
id|type
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx disabled at slot %d, ignored&bslash;n&quot;
comma
id|slot
)paren
suffix:semicolon
)brace
)brace
r_return
id|AIC_NONE
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   read_seeprom&n; *&n; * Description:&n; *   Reads the serial EEPROM and returns 1 if successful and 0 if&n; *   not successful.&n; *&n; *   The instruction set of the 93C46 chip is as follows:&n; *&n; *               Start  OP&n; *     Function   Bit  Code  Address    Data     Description&n; *     -------------------------------------------------------------------&n; *     READ        1    10   A5 - A0             Reads data stored in memory,&n; *                                               starting at specified address&n; *     EWEN        1    00   11XXXX              Write enable must preceed&n; *                                               all programming modes&n; *     ERASE       1    11   A5 - A0             Erase register A5A4A3A2A1A0&n; *     WRITE       1    01   A5 - A0   D15 - D0  Writes register&n; *     ERAL        1    00   10XXXX              Erase all registers&n; *     WRAL        1    00   01XXXX    D15 - D0  Writes to all registers&n; *     EWDS        1    00   00XXXX              Disables all programming&n; *                                               instructions&n; *     *Note: A value of X for address is a don&squot;t care condition.&n; *&n; *   The 93C46 has a four wire interface: clock, chip select, data in, and&n; *   data out.  In order to perform one of the above functions, you need&n; *   to enable the chip select for a clock period (typically a minimum of&n; *   1 usec, with the clock high and low a minimum of 750 and 250 nsec&n; *   respectively.  While the chip select remains high, you can clock in&n; *   the instructions (above) starting with the start bit, followed by the&n; *   OP code, Address, and Data (if needed).  For the READ instruction, the&n; *   requested 16-bit register contents is read from the data out line but&n; *   is preceded by an initial zero (leading 0, followed by 16-bits, MSB&n; *   first).  The clock cycling from low to high initiates the next data&n; *   bit to be sent from the chip.&n; *&n; *   The 7870 interface to the 93C46 serial EEPROM is through the SEECTL&n; *   register.  After successful arbitration for the memory port, the&n; *   SEECS bit of the SEECTL register is connected to the chip select.&n; *   The SEECK, SEEDO, and SEEDI are connected to the clock, data out,&n; *   and data in lines respectively.  The SEERDY bit of SEECTL is useful&n; *   in that it gives us an 800 nsec timer.  After a write to the SEECTL&n; *   register, the SEERDY goes high 800 nsec later.  The one exception&n; *   to this is when we first request access to the memory port.  The&n; *   SEERDY goes high to signify that access has been granted and, for&n; *   this case, has no implied timing.&n; *&n; *-F*************************************************************************/
r_static
r_int
DECL|function|read_seeprom
id|read_seeprom
c_func
(paren
r_int
id|base
comma
r_struct
id|seeprom_config
op_star
id|sc
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|k
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
r_char
id|temp
suffix:semicolon
r_int
r_int
id|checksum
op_assign
l_int|0
suffix:semicolon
r_int
r_int
op_star
id|seeprom
op_assign
(paren
r_int
r_int
op_star
)paren
id|sc
suffix:semicolon
r_struct
id|seeprom_cmd
(brace
r_int
r_char
id|len
suffix:semicolon
r_int
r_char
id|bits
(braket
l_int|3
)braket
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|seeprom_cmd
id|seeprom_read
op_assign
(brace
l_int|3
comma
(brace
l_int|1
comma
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|macro|CLOCK_PULSE
mdefine_line|#define CLOCK_PULSE(p) &bslash;&n;  while ((inb(SEECTL(base)) &amp; SEERDY) == 0)&t;&bslash;&n;  {&t;&t;&t;&t;&t;&t;&bslash;&n;    ;  /* Do nothing */&t;&t;&t;&t;&bslash;&n;  }
multiline_comment|/*&n;   * Request access of the memory port.  When access is&n;   * granted, SEERDY will go high.  We use a 1 second&n;   * timeout which should be near 1 second more than&n;   * is needed.  Reason: after the 7870 chip reset, there&n;   * should be no contention.&n;   */
id|outb
c_func
(paren
id|SEEMS
comma
id|SEECTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
l_int|100
suffix:semicolon
multiline_comment|/* 1 second timeout */
r_while
c_loop
(paren
(paren
id|jiffies
OL
id|timeout
)paren
op_logical_and
(paren
(paren
id|inb
c_func
(paren
id|SEECTL
c_func
(paren
id|base
)paren
)paren
op_amp
id|SEERDY
)paren
op_eq
l_int|0
)paren
)paren
(brace
suffix:semicolon
multiline_comment|/* Do nothing!  Wait for access to be granted. */
)brace
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|SEECTL
c_func
(paren
id|base
)paren
)paren
op_amp
id|SEERDY
)paren
op_eq
l_int|0
)paren
(brace
id|outb
(paren
l_int|0
comma
id|SEECTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * Read the first 32 registers of the seeprom.  For the 7870,&n;   * the 93C46 SEEPROM is a 1024-bit device with 64 16-bit registers&n;   * but only the first 32 are used by Adaptec BIOS.  The loop&n;   * will range from 0 to 31.&n;   */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
(paren
r_sizeof
(paren
op_star
id|sc
)paren
op_div
l_int|2
)paren
suffix:semicolon
id|k
op_assign
id|k
op_plus
l_int|1
)paren
(brace
multiline_comment|/* Send chip select for one clock cycle. */
id|outb
c_func
(paren
id|SEEMS
op_or
id|SEECK
op_or
id|SEECS
comma
id|SEECTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|base
)paren
suffix:semicolon
multiline_comment|/*&n;     * Now we&squot;re ready to send the read command followed by the&n;     * address of the 16-bit register we want to read.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|seeprom_read.len
suffix:semicolon
id|i
op_assign
id|i
op_plus
l_int|1
)paren
(brace
id|temp
op_assign
id|SEEMS
op_or
id|SEECS
op_or
(paren
id|seeprom_read.bits
(braket
id|i
)braket
op_lshift
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|SEECTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|base
)paren
suffix:semicolon
id|temp
op_assign
id|temp
op_xor
id|SEECK
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|SEECTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|base
)paren
suffix:semicolon
)brace
multiline_comment|/* Send the 6 bit address (MSB first, LSB last). */
r_for
c_loop
(paren
id|i
op_assign
l_int|5
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_assign
id|i
op_minus
l_int|1
)paren
(brace
id|temp
op_assign
id|k
suffix:semicolon
id|temp
op_assign
(paren
id|temp
op_rshift
id|i
)paren
op_amp
l_int|1
suffix:semicolon
multiline_comment|/* Mask out all but lower bit. */
id|temp
op_assign
id|SEEMS
op_or
id|SEECS
op_or
(paren
id|temp
op_lshift
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|SEECTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|base
)paren
suffix:semicolon
id|temp
op_assign
id|temp
op_xor
id|SEECK
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|SEECTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|base
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Now read the 16 bit register.  An initial 0 precedes the&n;     * register contents which begins with bit 15 (MSB) and ends&n;     * with bit 0 (LSB).  The initial 0 will be shifted off the&n;     * top of our word as we let the loop run from 0 to 16.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|16
suffix:semicolon
id|i
op_assign
id|i
op_plus
l_int|1
)paren
(brace
id|temp
op_assign
id|SEEMS
op_or
id|SEECS
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|SEECTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|base
)paren
suffix:semicolon
id|temp
op_assign
id|temp
op_xor
id|SEECK
suffix:semicolon
id|seeprom
(braket
id|k
)braket
op_assign
(paren
id|seeprom
(braket
id|k
)braket
op_lshift
l_int|1
)paren
op_or
(paren
id|inb
c_func
(paren
id|SEECTL
c_func
(paren
id|base
)paren
)paren
op_amp
id|SEEDI
)paren
suffix:semicolon
id|outb
c_func
(paren
id|temp
comma
id|SEECTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|base
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * The serial EEPROM has a checksum in the last word.  Keep a&n;     * running checksum for all words read except for the last&n;     * word.  We&squot;ll verify the checksum after all words have been&n;     * read.&n;     */
r_if
c_cond
(paren
id|k
OL
(paren
r_sizeof
(paren
op_star
id|sc
)paren
op_div
l_int|2
)paren
op_minus
l_int|1
)paren
(brace
id|checksum
op_assign
id|checksum
op_plus
id|seeprom
(braket
id|k
)braket
suffix:semicolon
)brace
multiline_comment|/* Reset the chip select for the next command cycle. */
id|outb
c_func
(paren
id|SEEMS
comma
id|SEECTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|base
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SEEMS
op_or
id|SEECK
comma
id|SEECTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|base
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SEEMS
comma
id|SEECTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|base
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|checksum
op_ne
id|sc-&gt;checksum
)paren
(brace
id|printk
(paren
l_string|&quot;aic7xxx : SEEPROM checksum error, ignoring SEEPROM settings.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#if 0
id|printk
(paren
l_string|&quot;Computed checksum 0x%x, checksum read 0x%x&bslash;n&quot;
comma
id|checksum
comma
id|sc-&gt;checksum
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Serial EEPROM:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
(paren
r_sizeof
(paren
op_star
id|sc
)paren
op_div
l_int|2
)paren
suffix:semicolon
id|k
op_assign
id|k
op_plus
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|k
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|k
op_ne
l_int|0
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;&bslash;n              &quot;
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot; 0x%x&quot;
comma
id|seeprom
(braket
id|k
)braket
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Release access to the memory port and the serial EEPROM. */
id|outb
c_func
(paren
l_int|0
comma
id|SEECTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   detect_maxscb&n; *&n; * Description:&n; *   Return the maximum number of SCB&squot;s allowed for a given controller.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|detect_maxscb
id|detect_maxscb
c_func
(paren
id|aha_type
id|type
comma
r_int
id|base
)paren
(brace
r_int
r_char
id|sblkctl_reg
suffix:semicolon
r_int
id|maxscb
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|AIC_274x
suffix:colon
r_case
id|AIC_284x
suffix:colon
multiline_comment|/*&n;       * Check for Rev C or E boards. Rev E boards can supposedly have&n;       * more than 4 SCBs, while the Rev C boards are limited to 4 SCBs.&n;       * Until we know how to access more than 4 SCBs for the Rev E chips,&n;       * we limit them, along with the Rev C chips, to 4 SCBs.&n;       *&n;       * The Rev E boards have a read/write autoflush bit in the&n;       * SBLKCTL registor, while in the Rev C boards it is read only.&n;       */
id|sblkctl_reg
op_assign
id|inb
c_func
(paren
id|SBLKCTL
c_func
(paren
id|base
)paren
)paren
op_xor
id|AUTOFLUSHDIS
suffix:semicolon
id|outb
c_func
(paren
id|sblkctl_reg
comma
id|SBLKCTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|SBLKCTL
c_func
(paren
id|base
)paren
)paren
op_eq
id|sblkctl_reg
)paren
(brace
multiline_comment|/* We detected a Rev E board. */
id|printk
c_func
(paren
l_string|&quot;aic7770: Rev E and subsequent; using 4 SCB&squot;s&bslash;n&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
id|sblkctl_reg
op_xor
id|AUTOFLUSHDIS
comma
id|SBLKCTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|maxscb
op_assign
l_int|4
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;aic7770: Rev C and previous; using 4 SCB&squot;s&bslash;n&quot;
)paren
suffix:semicolon
id|maxscb
op_assign
l_int|4
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AIC_7850
suffix:colon
id|maxscb
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AIC_7870
suffix:colon
id|maxscb
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AIC_7872
suffix:colon
multiline_comment|/*&n;       * Really has 255, but we&squot;ll wait to verify that we access&n;       * them the same way and do not have to set the card to&n;       * use the memory port to access external SCB RAM.&n;       */
id|maxscb
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AIC_NONE
suffix:colon
multiline_comment|/*&n;       * This should never happen... But just in case.&n;       */
r_break
suffix:semicolon
)brace
r_return
id|maxscb
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_register&n; *&n; * Description:&n; *   Register a Adaptec aic7xxx chip SCSI controller with the kernel.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_register
id|aic7xxx_register
c_func
(paren
id|Scsi_Host_Template
op_star
r_template
comma
id|aha_type
id|type
comma
r_int
id|base
comma
r_int
r_char
id|irq
)paren
(brace
r_static
r_char
op_star
id|board_name
(braket
)braket
op_assign
(brace
l_string|&quot;&quot;
comma
l_string|&quot;274x&quot;
comma
l_string|&quot;284x&quot;
comma
l_string|&quot;7870&quot;
comma
l_string|&quot;7850&quot;
comma
l_string|&quot;7872&quot;
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
id|sblkctl
suffix:semicolon
r_int
id|max_targets
suffix:semicolon
r_int
id|found
op_assign
l_int|1
suffix:semicolon
r_int
r_char
id|target_settings
suffix:semicolon
r_int
r_char
id|scsi_conf
suffix:semicolon
r_int
id|have_seeprom
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
r_struct
id|aic7xxx_host_config
id|config
suffix:semicolon
r_struct
id|seeprom_config
id|sc
suffix:semicolon
id|config.type
op_assign
id|type
suffix:semicolon
id|config.base
op_assign
id|base
suffix:semicolon
id|config.irq
op_assign
id|irq
suffix:semicolon
id|config.parity
op_assign
id|AIC_UNKNOWN
suffix:semicolon
id|config.low_term
op_assign
id|AIC_UNKNOWN
suffix:semicolon
id|config.high_term
op_assign
id|AIC_UNKNOWN
suffix:semicolon
id|config.busrtime
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   * Lock out other contenders for our i/o space.&n;   */
id|request_region
c_func
(paren
id|MINREG
c_func
(paren
id|base
)paren
comma
id|MAXREG
c_func
(paren
id|base
)paren
op_minus
id|MINREG
c_func
(paren
id|base
)paren
comma
l_string|&quot;aic7xxx&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|AIC_274x
suffix:colon
macro_line|#if 1
id|printk
c_func
(paren
l_string|&quot;aha274x: aic7770 hcntrl=0x%x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|HCNTRL
c_func
(paren
id|config.base
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;       * For some 274x boards, we must clear the CHIPRST bit&n;       * and pause the sequencer. For some reason, this makes&n;       * the driver work. For 284x boards, we give it a&n;       * CHIPRST just like the 294x boards.&n;       *&n;       * Use the BIOS settings to determine the interrupt&n;       * trigger type (level or edge) and use this value&n;       * for pausing and unpausing the sequencer.&n;       */
id|config.unpause
op_assign
(paren
id|inb
c_func
(paren
id|HCNTRL
c_func
(paren
id|config.base
)paren
)paren
op_amp
id|IRQMS
)paren
op_or
id|INTEN
suffix:semicolon
id|config.pause
op_assign
id|config.unpause
op_or
id|PAUSE
suffix:semicolon
id|config.extended
op_assign
id|aic7xxx_extended
suffix:semicolon
multiline_comment|/*&n;       * I don&squot;t think we need to kick the reset again, the initial probe&n;       * does a reset, it seems that this is kicking a dead horse here.&n;       * So... I will try to just verify that the chip has come out of the&n;       * reset state and continue the same as the 284x.&n;       * In the Calgary version of the driver:&n;       *   1) Chip Reset&n;       *   2) Set unpause to IRQMS | INTEN&n;       *   3) If an interrupt occured without any commands queued, the&n;       *      unpause was set to just INTEN&n;       * I changed the initial reset code to just mask in the CHIPRST bit&n;       * and try to leave the other settings alone.&n;       *&n;       * I don&squot;t think we need the warning about chip reset not being clear.&n;       * On both my test machines (2842 &amp; 2940), they work just fine with a&n;       * HCNTRL() of 0x5 (PAUSE | CHIPRST). Notice though, the 274x also&n;       * adds the INTEN flag, where neither the 284x or 294x do.&n;       */
id|outb
c_func
(paren
id|config.pause
op_or
id|CHIPRST
comma
id|HCNTRL
c_func
(paren
id|config.base
)paren
)paren
suffix:semicolon
id|aic7xxx_delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|HCNTRL
c_func
(paren
id|config.base
)paren
)paren
op_amp
id|CHIPRST
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx_register: Chip reset not cleared; clearing manually.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|config.pause
comma
id|HCNTRL
c_func
(paren
id|config.base
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;       * Just to be on the safe side with the 274x, we will re-read the irq&n;       * since there was some issue about reseting the board.&n;       */
id|config.irq
op_assign
id|inb
c_func
(paren
id|HA_INTDEF
c_func
(paren
id|config.base
)paren
)paren
op_amp
l_int|0x0F
suffix:semicolon
id|config.busrtime
op_assign
id|inb
c_func
(paren
id|HA_SCSICONF
c_func
(paren
id|config.base
)paren
)paren
op_amp
l_int|0x3C
suffix:semicolon
multiline_comment|/*&n;       * A reminder until this can be detected automatically.&n;       */
id|printk
c_func
(paren
l_string|&quot;aha274x: extended translation %sabled&bslash;n&quot;
comma
id|config.extended
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AIC_284x
suffix:colon
macro_line|#if 1
id|printk
c_func
(paren
l_string|&quot;aha284x: aic7770 hcntrl=0x%x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|HCNTRL
c_func
(paren
id|config.base
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|CHIPRST
comma
id|HCNTRL
c_func
(paren
id|config.base
)paren
)paren
suffix:semicolon
id|config.unpause
op_assign
id|UNPAUSE_284X
suffix:semicolon
id|config.pause
op_assign
id|REQ_PAUSE
suffix:semicolon
multiline_comment|/* DWG would like to be like the rest */
id|config.extended
op_assign
id|aic7xxx_extended
suffix:semicolon
id|config.irq
op_assign
id|inb
c_func
(paren
id|HA_INTDEF
c_func
(paren
id|config.base
)paren
)paren
op_amp
l_int|0x0F
suffix:semicolon
multiline_comment|/*&n;       * A reminder until this can be detected automatically.&n;       */
id|printk
c_func
(paren
l_string|&quot;aha284x: extended translation %sabled&bslash;n&quot;
comma
id|config.extended
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AIC_7850
suffix:colon
r_case
id|AIC_7870
suffix:colon
r_case
id|AIC_7872
suffix:colon
macro_line|#if 1
id|printk
c_func
(paren
l_string|&quot;aic%s hcntrl=0x%x&bslash;n&quot;
comma
id|board_name
(braket
id|type
)braket
comma
id|inb
c_func
(paren
id|HCNTRL
c_func
(paren
id|config.base
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|CHIPRST
comma
id|HCNTRL
c_func
(paren
id|config.base
)paren
)paren
suffix:semicolon
id|config.unpause
op_assign
id|UNPAUSE_294X
suffix:semicolon
id|config.pause
op_assign
id|config.unpause
op_or
id|PAUSE
suffix:semicolon
id|config.extended
op_assign
id|aic7xxx_extended
suffix:semicolon
id|config.scsi_id
op_assign
l_int|7
suffix:semicolon
id|printk
(paren
l_string|&quot;aic78xx: Reading SEEPROM... &quot;
)paren
suffix:semicolon
id|have_seeprom
op_assign
id|read_seeprom
c_func
(paren
id|base
comma
op_amp
id|sc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|have_seeprom
)paren
(brace
id|printk
(paren
l_string|&quot;Unable to read SEEPROM&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;done&bslash;n&quot;
)paren
suffix:semicolon
id|config.extended
op_assign
(paren
id|sc.bios_control
op_amp
id|CFEXTEND
)paren
op_rshift
l_int|7
suffix:semicolon
id|config.scsi_id
op_assign
(paren
id|sc.brtime_id
op_amp
id|CFSCSIID
)paren
suffix:semicolon
id|config.parity
op_assign
(paren
id|sc.adapter_control
op_amp
id|CFSPARITY
)paren
ques
c_cond
id|AIC_ENABLED
suffix:colon
id|AIC_DISABLED
suffix:semicolon
id|config.low_term
op_assign
(paren
id|sc.adapter_control
op_amp
id|CFSTERM
)paren
ques
c_cond
id|AIC_ENABLED
suffix:colon
id|AIC_DISABLED
suffix:semicolon
id|config.high_term
op_assign
(paren
id|sc.adapter_control
op_amp
id|CFWSTERM
)paren
ques
c_cond
id|AIC_ENABLED
suffix:colon
id|AIC_DISABLED
suffix:semicolon
id|config.busrtime
op_assign
(paren
id|sc.brtime_id
op_amp
id|CFBRTIME
)paren
op_rshift
l_int|8
suffix:semicolon
)brace
multiline_comment|/*&n;       * XXX - force data fifo threshold to 100%. Why does this&n;       *       need to be done?&n;       */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|DSPCISTATUS
c_func
(paren
id|config.base
)paren
)paren
op_or
id|DFTHRESH
comma
id|DSPCISTATUS
c_func
(paren
id|config.base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|config.scsi_id
op_or
id|DFTHRESH
comma
id|HA_SCSICONF
c_func
(paren
id|config.base
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;       * In case we are a wide card, place scsi ID in second conf byte.&n;       */
id|outb
c_func
(paren
id|config.scsi_id
comma
(paren
id|HA_SCSICONF
c_func
(paren
id|config.base
)paren
op_plus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;       * A reminder until this can be detected automatically.&n;       */
id|printk
c_func
(paren
l_string|&quot;aic%s: extended translation %sabled&bslash;n&quot;
comma
id|board_name
(braket
id|type
)braket
comma
id|config.extended
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;aic7xxx_register: internal error&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|config.maxscb
op_assign
id|detect_maxscb
c_func
(paren
id|type
comma
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|config.type
op_eq
id|AIC_274x
)paren
op_logical_or
(paren
id|config.type
op_eq
id|AIC_284x
)paren
)paren
(brace
r_if
c_cond
(paren
id|config.pause
op_amp
id|IRQMS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Using Level Sensitive Interrupts&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Using Edge Triggered Interrupts&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Read the bus type from the SBLKCTL register. Set the FLAGS&n;   * register in the sequencer for twin and wide bus cards.&n;   */
id|sblkctl
op_assign
id|inb
c_func
(paren
id|SBLKCTL
c_func
(paren
id|base
)paren
)paren
op_amp
l_int|0x0F
suffix:semicolon
multiline_comment|/* mask out upper two bits */
r_switch
c_cond
(paren
id|sblkctl
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* narrow/normal bus */
id|config.scsi_id
op_assign
id|inb
c_func
(paren
id|HA_SCSICONF
c_func
(paren
id|base
)paren
)paren
op_amp
l_int|0x07
suffix:semicolon
id|config.bus_type
op_assign
id|AIC_SINGLE
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|HA_FLAGS
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* Wide bus */
id|config.scsi_id
op_assign
id|inb
c_func
(paren
id|HA_SCSICONF
c_func
(paren
id|base
)paren
op_plus
l_int|1
)paren
op_amp
l_int|0x0F
suffix:semicolon
id|config.bus_type
op_assign
id|AIC_WIDE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aic7xxx : Enabling wide channel of %s-Wide&bslash;n&quot;
comma
id|board_name
(braket
id|config.type
)braket
)paren
suffix:semicolon
id|outb
c_func
(paren
id|WIDE_BUS
comma
id|HA_FLAGS
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
multiline_comment|/* Twin bus */
id|config.scsi_id
op_assign
id|inb
c_func
(paren
id|HA_SCSICONF
c_func
(paren
id|base
)paren
)paren
op_amp
l_int|0x07
suffix:semicolon
macro_line|#ifdef AIC7XXX_TWIN_SUPPORT
id|config.scsi_id_b
op_assign
id|inb
c_func
(paren
id|HA_SCSICONF
c_func
(paren
id|base
)paren
op_plus
l_int|1
)paren
op_amp
l_int|0x07
suffix:semicolon
id|config.bus_type
op_assign
id|AIC_TWIN
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aic7xxx : Enabled channel B of %s-Twin&bslash;n&quot;
comma
id|board_name
(braket
id|config.type
)braket
)paren
suffix:semicolon
id|outb
c_func
(paren
id|TWIN_BUS
comma
id|HA_FLAGS
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
macro_line|#else
id|config.bus_type
op_assign
id|AIC_SINGLE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aic7xxx : Channel B of %s-Twin will be ignored&bslash;n&quot;
comma
id|board_name
(braket
id|config.type
)braket
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|HA_FLAGS
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;aic7xxx is an unsupported type 0x%x, please &quot;
l_string|&quot;mail deang@ims.com&bslash;n&quot;
comma
id|inb
c_func
(paren
id|SBLKCTL
c_func
(paren
id|base
)paren
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|HA_FLAGS
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;   * Clear the upper two bits. For the 294x cards, clearing the&n;   * upper two bits, will take the card out of diagnostic mode&n;   * and make the host adatper LED follow bus activity (will not&n;   * always be on).&n;   */
id|outb
c_func
(paren
id|sblkctl
comma
id|SBLKCTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;   * The IRQ level in i/o port 4 maps directly onto the real&n;   * IRQ number. If it&squot;s ok, register it with the kernel.&n;   *&n;   * NB. the Adaptec documentation says the IRQ number is only&n;   *     in the lower four bits; the ECU information shows the&n;   *     high bit being used as well. Which is correct?&n;   *&n;   * The 294x cards (PCI) get their interrupt from PCI BIOS.&n;   */
r_if
c_cond
(paren
(paren
(paren
id|config.type
op_eq
id|AIC_274x
)paren
op_logical_or
(paren
id|config.type
op_eq
id|AIC_284x
)paren
)paren
op_logical_and
(paren
id|config.irq
template_param
l_int|15
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx uses unsupported IRQ level, ignoring&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;   * Check the IRQ to see if it is shared by another aic7xxx&n;   * controller. If it is and sharing of IRQs is not defined,&n;   * then return 0 hosts found. If sharing of IRQs is allowed&n;   * or the IRQ is not shared by another host adapter, then&n;   * proceed.&n;   */
macro_line|#ifndef AIC7XXX_SHARE_IRQS
r_if
c_cond
(paren
id|aic7xxx_boards
(braket
id|config.irq
)braket
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx_register: Sharing of IRQs is not configured.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;   * Print out debugging information before re-enabling&n;   * the card - a lot of registers on it can&squot;t be read&n;   * when the sequencer is active.&n;   */
id|debug_config
c_func
(paren
op_amp
id|config
)paren
suffix:semicolon
multiline_comment|/*&n;   * Before registry, make sure that the offsets of the&n;   * struct scatterlist are what the sequencer will expect,&n;   * otherwise disable scatter-gather altogether until someone&n;   * can fix it. This is important since the sequencer will&n;   * DMA elements of the SG array in while executing commands.&n;   */
r_if
c_cond
(paren
r_template
op_member_access_from_pointer
id|sg_tablesize
op_ne
id|SG_NONE
)paren
(brace
r_struct
id|scatterlist
id|sg
suffix:semicolon
r_if
c_cond
(paren
id|SG_STRUCT_CHECK
c_func
(paren
id|sg
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx warning: kernel scatter-gather &quot;
l_string|&quot;structures changed, disabling it&bslash;n&quot;
)paren
suffix:semicolon
r_template
op_member_access_from_pointer
id|sg_tablesize
op_assign
id|SG_NONE
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Register each &quot;host&quot; and fill in the returned Scsi_Host&n;   * structure as best we can. Some of the parameters aren&squot;t&n;   * really relevant for bus types beyond ISA, and none of the&n;   * high-level SCSI code looks at it anyway. Why are the fields&n;   * there? Also save the pointer so that we can find the&n;   * information when an IRQ is triggered.&n;   */
id|host
op_assign
id|scsi_register
c_func
(paren
r_template
comma
r_sizeof
(paren
r_struct
id|aic7xxx_host
)paren
)paren
suffix:semicolon
id|host-&gt;can_queue
op_assign
id|config.maxscb
suffix:semicolon
macro_line|#ifdef AIC7XXX_TAGGED_QUEUEING
id|host-&gt;cmd_per_lun
op_assign
l_int|2
suffix:semicolon
macro_line|#else
id|host-&gt;cmd_per_lun
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|host-&gt;this_id
op_assign
id|config.scsi_id
suffix:semicolon
id|host-&gt;irq
op_assign
id|config.irq
suffix:semicolon
r_if
c_cond
(paren
id|config.bus_type
op_eq
id|AIC_WIDE
)paren
(brace
id|host-&gt;max_id
op_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|config.bus_type
op_eq
id|AIC_TWIN
)paren
(brace
id|host-&gt;max_channel
op_assign
l_int|1
suffix:semicolon
)brace
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
multiline_comment|/* Initialize the scb array by setting the state to free. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AIC7XXX_MAXSCB
suffix:semicolon
id|i
op_assign
id|i
op_plus
l_int|1
)paren
(brace
id|p-&gt;scb_array
(braket
id|i
)braket
dot
id|state
op_assign
id|SCB_FREE
suffix:semicolon
id|p-&gt;scb_array
(braket
id|i
)braket
dot
id|next
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;scb_array
(braket
id|i
)braket
dot
id|cmd
op_assign
l_int|NULL
suffix:semicolon
)brace
id|p-&gt;isr_count
op_assign
l_int|0
suffix:semicolon
id|p-&gt;a_scanned
op_assign
l_int|0
suffix:semicolon
id|p-&gt;b_scanned
op_assign
l_int|0
suffix:semicolon
id|p-&gt;base
op_assign
id|config.base
suffix:semicolon
id|p-&gt;maxscb
op_assign
id|config.maxscb
suffix:semicolon
id|p-&gt;numscb
op_assign
l_int|0
suffix:semicolon
id|p-&gt;extended
op_assign
id|config.extended
suffix:semicolon
id|p-&gt;type
op_assign
id|config.type
suffix:semicolon
id|p-&gt;bus_type
op_assign
id|config.bus_type
suffix:semicolon
id|p-&gt;have_seeprom
op_assign
id|have_seeprom
suffix:semicolon
id|p-&gt;seeprom
op_assign
id|sc
suffix:semicolon
id|p-&gt;free_scb
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;unpause
op_assign
id|config.unpause
suffix:semicolon
id|p-&gt;pause
op_assign
id|config.pause
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_boards
(braket
id|config.irq
)braket
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;     * Register IRQ with the kernel.&n;     */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|config.irq
comma
id|aic7xxx_isr
comma
id|SA_INTERRUPT
comma
l_string|&quot;aic7xxx&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx couldn&squot;t register irq %d, ignoring&bslash;n&quot;
comma
id|config.irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|aic7xxx_boards
(braket
id|config.irq
)braket
op_assign
id|host
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;     * We have found a host adapter sharing an IRQ of a previously&n;     * registered host adapter. Add this host adapter&squot;s Scsi_Host&n;     * to the beginning of the linked list of hosts at the same IRQ.&n;     */
id|p-&gt;next
op_assign
id|aic7xxx_boards
(braket
id|config.irq
)braket
suffix:semicolon
id|aic7xxx_boards
(braket
id|config.irq
)braket
op_assign
id|host
suffix:semicolon
)brace
multiline_comment|/*&n;   * Load the sequencer program, then re-enable the board -&n;   * resetting the AIC-7770 disables it, leaving the lights&n;   * on with nobody home. On the PCI bus you *may* be home,&n;   * but then your mailing address is dynamically assigned&n;   * so no one can find you anyway :-)&n;   */
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Downloading sequencer code..&quot;
)paren
suffix:semicolon
id|aic7xxx_loadseq
c_func
(paren
id|base
)paren
suffix:semicolon
multiline_comment|/* Set Fast Mode and Enable the board */
id|outb
c_func
(paren
id|FASTMODE
comma
id|SEQCTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;type
op_eq
id|AIC_274x
op_logical_or
id|p-&gt;type
op_eq
id|AIC_284x
)paren
)paren
(brace
id|outb
c_func
(paren
id|ENABLE
comma
id|BCTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;done.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;   * Set the SCSI Id, SXFRCTL1, and SIMODE1, for both channels&n;   */
r_if
c_cond
(paren
id|p-&gt;bus_type
op_eq
id|AIC_TWIN
)paren
(brace
multiline_comment|/*&n;     * The device is gated to channel B after a chip reset,&n;     * so set those values first.&n;     */
id|outb
c_func
(paren
id|config.scsi_id_b
comma
id|SCSIID
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|scsi_conf
op_assign
id|inb
c_func
(paren
id|HA_SCSICONF
c_func
(paren
id|base
)paren
op_plus
l_int|1
)paren
op_amp
(paren
id|ENSPCHK
op_or
id|STIMESEL
)paren
suffix:semicolon
id|scsi_conf
op_assign
id|scsi_conf
op_or
id|ENSTIMER
op_or
id|ACTNEGEN
op_or
id|STPWEN
suffix:semicolon
id|outb
c_func
(paren
id|scsi_conf
comma
id|SXFRCTL1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ENSELTIMO
op_or
id|ENSCSIPERR
comma
id|SIMODE1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* Select Channel A */
id|outb
c_func
(paren
l_int|0
comma
id|SBLKCTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|config.scsi_id
comma
id|SCSIID
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|scsi_conf
op_assign
id|inb
c_func
(paren
id|HA_SCSICONF
c_func
(paren
id|base
)paren
)paren
op_amp
(paren
id|ENSPCHK
op_or
id|STIMESEL
)paren
suffix:semicolon
id|outb
c_func
(paren
id|scsi_conf
op_or
id|ENSTIMER
op_or
id|ACTNEGEN
op_or
id|STPWEN
comma
id|SXFRCTL1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ENSELTIMO
op_or
id|ENSCSIPERR
comma
id|SIMODE1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* Look at the information that board initialization or the board&n;   * BIOS has left us. In the lower four bits of each target&squot;s&n;   * scratch space any value other than 0 indicates that we should&n;   * initiate synchronous transfers. If it&squot;s zero, the user or the&n;   * BIOS has decided to disable synchronous negotiation to that&n;   * target so we don&squot;t activate the needsdtr flag.&n;   */
id|p-&gt;needsdtr_copy
op_assign
l_int|0
suffix:semicolon
id|p-&gt;sdtr_pending
op_assign
l_int|0
suffix:semicolon
id|p-&gt;needwdtr_copy
op_assign
l_int|0
suffix:semicolon
id|p-&gt;wdtr_pending
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;bus_type
op_eq
id|AIC_SINGLE
)paren
(brace
id|max_targets
op_assign
l_int|8
suffix:semicolon
)brace
r_else
(brace
id|max_targets
op_assign
l_int|16
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_targets
suffix:semicolon
id|i
op_assign
id|i
op_plus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|have_seeprom
)paren
(brace
id|target_settings
op_assign
(paren
id|sc.device_flags
(braket
id|i
)braket
op_amp
id|CFXFER
)paren
op_lshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|sc.device_flags
(braket
id|i
)braket
op_amp
id|CFSYNCH
)paren
(brace
id|p-&gt;needsdtr_copy
op_assign
id|p-&gt;needsdtr_copy
op_or
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sc.device_flags
(braket
id|i
)braket
op_amp
id|CFWIDEB
)paren
op_logical_and
(paren
id|p-&gt;bus_type
op_eq
id|AIC_WIDE
)paren
)paren
(brace
id|p-&gt;needwdtr_copy
op_assign
id|p-&gt;needwdtr_copy
op_or
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|target_settings
op_assign
id|inb
c_func
(paren
id|HA_TARG_SCRATCH
c_func
(paren
id|base
)paren
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target_settings
op_amp
l_int|0x0F
)paren
(brace
id|p-&gt;needsdtr_copy
op_assign
id|p-&gt;needsdtr_copy
op_or
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Default to asynchronous transfers (0 offset)&n;&t; */
id|target_settings
op_assign
id|target_settings
op_amp
l_int|0xF0
suffix:semicolon
)brace
multiline_comment|/*&n;       * If we are not wide, forget WDTR. This makes the driver&n;       * work on some cards that don&squot;t leave these fields cleared&n;       * when BIOS is not installed.&n;       */
r_if
c_cond
(paren
(paren
id|target_settings
op_amp
l_int|0x80
)paren
op_logical_and
(paren
id|p-&gt;bus_type
op_eq
id|AIC_WIDE
)paren
)paren
(brace
id|p-&gt;needwdtr_copy
op_assign
id|p-&gt;needwdtr_copy
op_or
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
id|target_settings
op_assign
id|target_settings
op_amp
l_int|0x7F
suffix:semicolon
)brace
)brace
id|outb
c_func
(paren
id|target_settings
comma
(paren
id|HA_TARG_SCRATCH
c_func
(paren
id|base
)paren
op_plus
id|i
)paren
)paren
suffix:semicolon
)brace
id|p-&gt;needsdtr
op_assign
id|p-&gt;needsdtr_copy
suffix:semicolon
id|p-&gt;needwdtr
op_assign
id|p-&gt;needwdtr_copy
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NeedSdtr = 0x%x, 0x%x&bslash;n&quot;
comma
id|p-&gt;needsdtr_copy
comma
id|p-&gt;needsdtr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NeedWdtr = 0x%x, 0x%x&bslash;n&quot;
comma
id|p-&gt;needwdtr_copy
comma
id|p-&gt;needwdtr
)paren
suffix:semicolon
multiline_comment|/* &n;   * Clear the control byte for every SCB so that the sequencer&n;   * doesn&squot;t get confused and think that one of them is valid&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|config.maxscb
suffix:semicolon
id|i
op_assign
id|i
op_plus
l_int|1
)paren
(brace
id|outb
c_func
(paren
id|i
comma
id|SCBPTR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCBARRAY
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * For reconnecting targets, the sequencer code needs to&n;   * know how many SCBs it has to search through.&n;   */
id|outb
c_func
(paren
id|config.maxscb
comma
id|HA_SCBCOUNT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;   * Clear the active flags - no targets are busy.&n;   */
id|outb
c_func
(paren
l_int|0
comma
id|HA_ACTIVE0
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|HA_ACTIVE1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t have any waiting selections */
id|outb
(paren
id|SCB_LIST_NULL
comma
id|WAITING_SCBH
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
(paren
id|SCB_LIST_NULL
comma
id|WAITING_SCBT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;   * Reset the SCSI bus. Is this necessary?&n;   *   There may be problems for a warm boot without resetting&n;   *   the SCSI bus. Either BIOS settings in scratch RAM&n;   *   will not get reinitialized, or devices may stay at&n;   *   previous negotiated settings (SDTR and WDTR) while&n;   *   the driver will think that no negotiations have been&n;   *   performed.&n;   *&n;   * Some devices need a long time to &quot;settle&quot; after a SCSI&n;   * bus reset.&n;   */
r_if
c_cond
(paren
op_logical_neg
id|aic7xxx_no_reset
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Resetting the SCSI bus...&bslash;n&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SCSIRSTO
comma
id|SCSISEQ
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCSISEQ
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|aic7xxx_delay
c_func
(paren
id|AIC7XXX_RESET_DELAY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * Unpause the sequencer before returning and enable&n;   * interrupts - we shouldn&squot;t get any until the first&n;   * command is sent to us by the high-level SCSI code.&n;   */
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
id|found
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_detect&n; *&n; * Description:&n; *   Try to detect and register an Adaptec 7770 or 7870 SCSI controller.&n; *-F*************************************************************************/
r_int
DECL|function|aic7xxx_detect
id|aic7xxx_detect
c_func
(paren
id|Scsi_Host_Template
op_star
r_template
)paren
(brace
id|aha_type
id|type
op_assign
id|AIC_NONE
suffix:semicolon
r_int
id|found
op_assign
l_int|0
comma
id|slot
comma
id|base
suffix:semicolon
r_int
r_char
id|irq
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;   * Since we may allow sharing of IRQs, it is imperative&n;   * that we &quot;null-out&quot; the aic7xxx_boards array. It is&n;   * not guaranteed to be initialized to 0 (NULL). We use&n;   * a NULL entry to indicate that no prior hosts have&n;   * been found/registered for that IRQ.&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|MAXIRQ
suffix:semicolon
id|i
op_increment
)paren
(brace
id|aic7xxx_boards
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;   * EISA/VL-bus card signature probe.&n;   */
r_for
c_loop
(paren
id|slot
op_assign
id|MINSLOT
suffix:semicolon
id|slot
op_le
id|MAXSLOT
suffix:semicolon
id|slot
op_increment
)paren
(brace
id|base
op_assign
id|SLOTBASE
c_func
(paren
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|MINREG
c_func
(paren
id|base
)paren
comma
id|MAXREG
c_func
(paren
id|base
)paren
op_minus
id|MINREG
c_func
(paren
id|base
)paren
)paren
)paren
(brace
multiline_comment|/*&n;       * Some other driver has staked a&n;       * claim to this i/o region already.&n;       */
r_continue
suffix:semicolon
)brace
id|type
op_assign
id|aic7xxx_probe
c_func
(paren
id|slot
comma
id|HID0
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|AIC_NONE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: hcntrl=0x%x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|HCNTRL
c_func
(paren
id|base
)paren
)paren
)paren
suffix:semicolon
macro_line|#if 0
id|outb
c_func
(paren
id|inb
c_func
(paren
id|HCNTRL
c_func
(paren
id|base
)paren
)paren
op_or
id|CHIPRST
comma
id|HCNTRL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|irq
op_assign
id|inb
c_func
(paren
id|HA_INTDEF
c_func
(paren
id|base
)paren
)paren
op_amp
l_int|0x0F
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;       * We &quot;find&quot; a AIC-7770 if we locate the card&n;       * signature and we can set it up and register&n;       * it with the kernel without incident.&n;       */
id|found
op_add_assign
id|aic7xxx_register
c_func
(paren
r_template
comma
id|type
comma
id|base
comma
id|irq
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_PCI
DECL|macro|DEVREVID
mdefine_line|#define DEVREVID  0x08
DECL|macro|DEVCONFIG
mdefine_line|#define DEVCONFIG 0x40
DECL|macro|DEVSTATUS
mdefine_line|#define DEVSTATUS 0x41
DECL|macro|RAMPSM
mdefine_line|#define RAMPSM    0x02
multiline_comment|/* This should be defined in pci.h */
DECL|macro|PCI_DEVICE_ID_ADAPTEC_7850
mdefine_line|#define PCI_DEVICE_ID_ADAPTEC_7850&t;0x5078
DECL|macro|PCI_DEVICE_ID_ADAPTEC_7872
mdefine_line|#define PCI_DEVICE_ID_ADAPTEC_7872&t;0x7278
multiline_comment|/*&n;   * PCI-bus probe.&n;   */
r_if
c_cond
(paren
id|pcibios_present
c_func
(paren
)paren
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|io_port
suffix:semicolon
r_int
r_int
id|index
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|pci_bus
comma
id|pci_device_fn
suffix:semicolon
r_int
r_char
id|devrevid
comma
id|devconfig
comma
id|devstatus
suffix:semicolon
r_char
id|rev_id
(braket
)braket
op_assign
(brace
l_char|&squot;B&squot;
comma
l_char|&squot;C&squot;
comma
l_char|&squot;D&squot;
)brace
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|pcibios_find_device
c_func
(paren
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_294x
comma
id|index
comma
op_amp
id|pci_bus
comma
op_amp
id|pci_device_fn
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|pcibios_find_device
c_func
(paren
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_2940
comma
id|index
comma
op_amp
id|pci_bus
comma
op_amp
id|pci_device_fn
)paren
)paren
)paren
(brace
id|type
op_assign
id|AIC_7870
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|pcibios_find_device
c_func
(paren
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7850
comma
id|index
comma
op_amp
id|pci_bus
comma
op_amp
id|pci_device_fn
)paren
)paren
(brace
id|type
op_assign
id|AIC_7850
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|pcibios_find_device
c_func
(paren
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7872
comma
id|index
comma
op_amp
id|pci_bus
comma
op_amp
id|pci_device_fn
)paren
)paren
(brace
id|type
op_assign
id|AIC_7872
suffix:semicolon
)brace
r_else
(brace
id|type
op_assign
id|AIC_NONE
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
(brace
multiline_comment|/*&n;&t; * Read esundry information from PCI BIOS.&n;&t; */
id|error
op_assign
id|pcibios_read_config_dword
c_func
(paren
id|pci_bus
comma
id|pci_device_fn
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|io_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;aic7xxx_detect: error 0x%x reading i/o port.&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
)brace
id|error
op_assign
id|pcibios_read_config_byte
c_func
(paren
id|pci_bus
comma
id|pci_device_fn
comma
id|PCI_INTERRUPT_LINE
comma
op_amp
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;aic7xxx_detect: error %d reading irq.&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Make the base I/O register look like EISA and VL-bus.&n;&t; */
id|base
op_assign
id|io_port
op_minus
l_int|0xC01
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aic7xxx: hcntrl=0x%x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|HCNTRL
c_func
(paren
id|base
)paren
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|HCNTRL
c_func
(paren
id|base
)paren
)paren
op_or
id|CHIPRST
comma
id|HCNTRL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|error
op_assign
id|pcibios_read_config_byte
c_func
(paren
id|pci_bus
comma
id|pci_device_fn
comma
id|DEVREVID
comma
op_amp
id|devrevid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devrevid
OL
l_int|3
)paren
(brace
id|printk
(paren
l_string|&quot;aic7xxx_detect: AIC-7870 Rev %c&bslash;n&quot;
comma
id|rev_id
(braket
id|devrevid
)braket
)paren
suffix:semicolon
)brace
id|error
op_assign
id|pcibios_read_config_byte
c_func
(paren
id|pci_bus
comma
id|pci_device_fn
comma
id|DEVCONFIG
comma
op_amp
id|devconfig
)paren
suffix:semicolon
id|error
op_assign
id|pcibios_read_config_byte
c_func
(paren
id|pci_bus
comma
id|pci_device_fn
comma
id|DEVSTATUS
comma
op_amp
id|devstatus
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;aic7xxx_detect: devconfig 0x%x, devstatus 0x%x&bslash;n&quot;
comma
id|devconfig
comma
id|devstatus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devstatus
op_amp
id|RAMPSM
)paren
(brace
id|printk
(paren
l_string|&quot;aic7xxx_detect: detected external SCB RAM, &quot;
l_string|&quot;mail deang@ims.com for test patch&quot;
)paren
suffix:semicolon
)brace
id|found
op_add_assign
id|aic7xxx_register
c_func
(paren
r_template
comma
id|type
comma
id|base
comma
id|irq
)paren
suffix:semicolon
id|index
op_add_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif CONFIG_PCI
r_template
op_member_access_from_pointer
id|name
op_assign
(paren
r_char
op_star
)paren
id|aic7xxx_info
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_return
id|found
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_buildscb&n; *&n; * Description:&n; *   Build a SCB.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_buildscb
id|aic7xxx_buildscb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
r_void
op_star
id|addr
suffix:semicolon
r_int
id|length
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
multiline_comment|/*&n;   * Setup the control byte if we need negotiation and have not&n;   * already requested it.&n;   */
macro_line|#ifdef AIC7XXX_TAGGED_QUEUEING
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;tagged_supported
)paren
(brace
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;tagged_queue
op_eq
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;aic7xxx_buildscb: Enabling tagged queuing for target %d, &quot;
l_string|&quot;channel %d&bslash;n&quot;
comma
id|cmd-&gt;target
comma
id|cmd-&gt;channel
)paren
suffix:semicolon
id|cmd-&gt;device-&gt;tagged_queue
op_assign
l_int|1
suffix:semicolon
id|cmd-&gt;device-&gt;current_tag
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* enable tagging */
)brace
id|cmd-&gt;tag
op_assign
id|cmd-&gt;device-&gt;current_tag
suffix:semicolon
id|cmd-&gt;device-&gt;current_tag
op_assign
id|cmd-&gt;device-&gt;current_tag
op_plus
l_int|1
suffix:semicolon
id|scb-&gt;control
op_assign
id|scb-&gt;control
op_or
id|SCB_TE
suffix:semicolon
)brace
macro_line|#endif
id|mask
op_assign
(paren
l_int|0x01
op_lshift
id|cmd-&gt;target
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;needwdtr
op_amp
id|mask
)paren
op_logical_and
op_logical_neg
(paren
id|p-&gt;wdtr_pending
op_amp
id|mask
)paren
)paren
(brace
id|p-&gt;wdtr_pending
op_assign
id|p-&gt;wdtr_pending
op_or
id|mask
suffix:semicolon
id|scb-&gt;control
op_assign
id|scb-&gt;control
op_or
id|SCB_NEEDWDTR
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;Sending WDTR request to target %d.&bslash;n&quot;
comma
id|cmd-&gt;target
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;needsdtr
op_amp
id|mask
)paren
op_logical_and
op_logical_neg
(paren
id|p-&gt;sdtr_pending
op_amp
id|mask
)paren
)paren
(brace
id|p-&gt;sdtr_pending
op_assign
id|p-&gt;sdtr_pending
op_or
id|mask
suffix:semicolon
id|scb-&gt;control
op_assign
id|scb-&gt;control
op_or
id|SCB_NEEDSDTR
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;Sending SDTR request to target %d.&bslash;n&quot;
comma
id|cmd-&gt;target
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;aic7xxx_queue: target %d, cmd 0x%x (size %u), wdtr 0x%x, mask 0x%x&bslash;n&quot;
comma
id|cmd-&gt;target
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|cmd-&gt;cmd_len
comma
id|p-&gt;needwdtr
comma
id|mask
)paren
suffix:semicolon
macro_line|#endif
id|scb-&gt;target_channel_lun
op_assign
(paren
(paren
id|cmd-&gt;target
op_lshift
l_int|4
)paren
op_amp
l_int|0xF0
)paren
op_or
(paren
(paren
id|cmd-&gt;channel
op_amp
l_int|0x01
)paren
op_lshift
l_int|3
)paren
op_or
(paren
id|cmd-&gt;lun
op_amp
l_int|0x07
)paren
suffix:semicolon
multiline_comment|/*&n;   * The interpretation of request_buffer and request_bufflen&n;   * changes depending on whether or not use_sg is zero; a&n;   * non-zero use_sg indicates the number of elements in the&n;   * scatter-gather array.&n;   *&n;   * The AIC-7770 can&squot;t support transfers of any sort larger&n;   * than 2^24 (three-byte count) without backflips. For what&n;   * the kernel is doing, this shouldn&squot;t occur. I hope.&n;   */
id|length
op_assign
id|aic7xxx_length
c_func
(paren
id|cmd
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
l_int|0xFFFFFF
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;aic7xxx_buildscb: can&squot;t transfer &gt; 2^24 - 1 bytes&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * XXX - this relies on the host data being stored in a&n;   *       little-endian format.&n;   */
id|addr
op_assign
id|cmd-&gt;cmnd
suffix:semicolon
id|scb-&gt;SCSI_cmd_length
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|memcpy
c_func
(paren
id|scb-&gt;SCSI_cmd_pointer
comma
op_amp
id|addr
comma
r_sizeof
(paren
id|scb-&gt;SCSI_cmd_pointer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
macro_line|#if 0
id|debug
c_func
(paren
l_string|&quot;aic7xxx_buildscb: SG used, %d segments, length %u&bslash;n&quot;
comma
id|cmd-&gt;use_sg
comma
id|length
)paren
suffix:semicolon
macro_line|#endif
id|scb-&gt;SG_segment_count
op_assign
id|cmd-&gt;use_sg
suffix:semicolon
id|memcpy
c_func
(paren
id|scb-&gt;SG_list_pointer
comma
op_amp
id|cmd-&gt;request_buffer
comma
r_sizeof
(paren
id|scb-&gt;SG_list_pointer
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if 0
id|debug
(paren
l_string|&quot;aic7xxx_buildscb: Creating scatterlist, addr=0x%lx, length=%d.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef AIC7XXX_USE_SG
id|scb-&gt;SG_segment_count
op_assign
l_int|1
suffix:semicolon
id|scb-&gt;sg.address
op_assign
(paren
r_char
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|scb-&gt;sg.length
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|addr
op_assign
op_amp
id|scb-&gt;sg
suffix:semicolon
id|memcpy
c_func
(paren
id|scb-&gt;SG_list_pointer
comma
op_amp
id|addr
comma
r_sizeof
(paren
id|scb-&gt;SG_list_pointer
)paren
)paren
suffix:semicolon
macro_line|#else
id|scb-&gt;SG_segment_count
op_assign
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|scb-&gt;data_pointer
comma
op_amp
id|cmd-&gt;request_buffer
comma
r_sizeof
(paren
id|scb-&gt;data_pointer
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|scb-&gt;data_count
comma
op_amp
id|cmd-&gt;request_bufflen
comma
l_int|3
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_queue&n; *&n; * Description:&n; *   Queue a SCB to the controller.&n; *-F*************************************************************************/
r_int
DECL|function|aic7xxx_queue
id|aic7xxx_queue
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|fn
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
id|flags
suffix:semicolon
macro_line|#ifndef AIC7XXX_USE_DMA
r_int
id|old_scbptr
suffix:semicolon
macro_line|#endif
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
r_struct
id|aic7xxx_scb
op_star
id|scb
suffix:semicolon
r_int
r_char
id|curscb
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
multiline_comment|/* Check to see if channel was scanned. */
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;a_scanned
op_logical_and
(paren
id|cmd-&gt;channel
op_eq
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Scanning channel A for devices.&bslash;n&quot;
)paren
suffix:semicolon
id|p-&gt;a_scanned
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;b_scanned
op_logical_and
(paren
id|cmd-&gt;channel
op_eq
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Scanning channel B for devices.&bslash;n&quot;
)paren
suffix:semicolon
id|p-&gt;b_scanned
op_assign
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#if 0
id|debug
c_func
(paren
l_string|&quot;aic7xxx_queue: cmd 0x%x (size %u), target %d, channel %d, lun %d&bslash;n&quot;
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|cmd-&gt;cmd_len
comma
id|cmd-&gt;target
comma
id|cmd-&gt;channel
comma
id|cmd-&gt;lun
op_amp
l_int|0x07
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;   * This is a critical section, since we don&squot;t want the&n;   * interrupt routine mucking with the host data or the&n;   * card. Since the kernel documentation is vague on&n;   * whether or not we are in a cli/sti pair already, save&n;   * the flags to be on the safe side.&n;   */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;   * Find a free slot in the SCB array to load this command&n;   * into. Since can_queue is set to the maximum number of&n;   * SCBs for the card, we should always find one.&n;   *&n;   * First try to find an scb in the free list. If there are&n;   * none in the free list, then check the current number of&n;   * of scbs and take an unused one from the scb array.&n;   */
id|scb
op_assign
id|p-&gt;free_scb
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* found one in the free list */
id|p-&gt;free_scb
op_assign
id|scb-&gt;next
suffix:semicolon
multiline_comment|/* remove and update head of list */
multiline_comment|/*&n;     * Warning! For some unknown reason, the scb at the head&n;     * of the free list is not the same address that it should&n;     * be. That&squot;s why we set the scb pointer taken by the&n;     * position in the array. The scb at the head of the list&n;     * should match this address, but it doesn&squot;t.&n;     */
id|scb
op_assign
op_amp
(paren
id|p-&gt;scb_array
(braket
id|scb-&gt;position
)braket
)paren
suffix:semicolon
id|scb-&gt;control
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;state
op_assign
id|SCB_ACTIVE
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|p-&gt;numscb
op_ge
id|p-&gt;maxscb
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;aic7xxx_queue: couldn&squot;t find a free scb&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;       * Initialize the scb within the scb array. The&n;       * position within the array is the position on&n;       * the board that it will be loaded.&n;       */
id|scb
op_assign
op_amp
(paren
id|p-&gt;scb_array
(braket
id|p-&gt;numscb
)braket
)paren
suffix:semicolon
id|memset
c_func
(paren
id|scb
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|scb
)paren
)paren
suffix:semicolon
id|scb-&gt;position
op_assign
id|p-&gt;numscb
suffix:semicolon
id|p-&gt;numscb
op_assign
id|p-&gt;numscb
op_plus
l_int|1
suffix:semicolon
id|scb-&gt;state
op_assign
id|SCB_ACTIVE
suffix:semicolon
id|scb-&gt;next_waiting
op_assign
id|SCB_LIST_NULL
suffix:semicolon
id|memcpy
c_func
(paren
id|scb-&gt;host_scb
comma
op_amp
id|scb
comma
r_sizeof
(paren
id|scb
)paren
)paren
suffix:semicolon
macro_line|#ifdef AIC7XXX_USE_DMA
id|scb-&gt;control
op_assign
id|SCB_NEEDDMA
suffix:semicolon
macro_line|#endif
id|PAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
id|curscb
op_assign
id|inb
c_func
(paren
id|SCBPTR
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|scb-&gt;position
comma
id|SCBPTR
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|aic7xxx_putdmascb
c_func
(paren
id|p-&gt;base
comma
id|scb
)paren
suffix:semicolon
id|outb
c_func
(paren
id|curscb
comma
id|SCBPTR
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
id|scb-&gt;control
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|scb-&gt;cmd
op_assign
id|cmd
suffix:semicolon
id|aic7xxx_position
c_func
(paren
id|cmd
)paren
op_assign
id|scb-&gt;position
suffix:semicolon
multiline_comment|/*&n;   * Construct the SCB beforehand, so the sequencer is&n;   * paused a minimal amount of time.&n;   */
id|aic7xxx_buildscb
c_func
(paren
id|p
comma
id|cmd
comma
id|scb
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|scb
op_ne
op_amp
id|p-&gt;scb_array
(braket
id|scb-&gt;position
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx_queue: address of scb by position does not match scb address&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx_queue: SCB pos=%d, cmdptr=0x%x, state=%d, freescb=0x%x&bslash;n&quot;
comma
id|scb-&gt;position
comma
(paren
r_int
r_int
)paren
id|scb-&gt;cmd
comma
id|scb-&gt;state
comma
(paren
r_int
r_int
)paren
id|p-&gt;free_scb
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;   * Pause the sequencer so we can play with its registers -&n;   * wait for it to acknowledge the pause.&n;   *&n;   * XXX - should the interrupts be left on while doing this?&n;   */
id|PAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;   * Save the SCB pointer and put our own pointer in - this&n;   * selects one of the four banks of SCB registers. Load&n;   * the SCB, then write its pointer into the queue in FIFO&n;   * and restore the saved SCB pointer.&n;   */
macro_line|#ifdef AIC7XXX_USE_DMA
id|aic7xxx_putscb
c_func
(paren
id|p-&gt;base
comma
id|scb
)paren
suffix:semicolon
macro_line|#else
id|old_scbptr
op_assign
id|inb
c_func
(paren
id|SCBPTR
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|scb-&gt;position
comma
id|SCBPTR
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|aic7xxx_putscb
c_func
(paren
id|p-&gt;base
comma
id|scb
)paren
suffix:semicolon
id|outb
c_func
(paren
id|scb-&gt;position
comma
id|QINFIFO
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|old_scbptr
comma
id|SCBPTR
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;   * Make sure the Scsi_Cmnd pointer is saved, the struct it&n;   * points to is set up properly, and the parity error flag&n;   * is reset, then unpause the sequencer and watch the fun&n;   * begin.&n;   */
id|cmd-&gt;scsi_done
op_assign
id|fn
suffix:semicolon
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_assign
id|DID_OK
suffix:semicolon
id|aic7xxx_status
c_func
(paren
id|cmd
)paren
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;result
op_assign
l_int|0
suffix:semicolon
id|memset
(paren
op_amp
id|cmd-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* return values from aic7xxx_kill */
r_typedef
r_enum
(brace
DECL|enumerator|k_ok
id|k_ok
comma
multiline_comment|/* scb found and message sent */
DECL|enumerator|k_busy
id|k_busy
comma
multiline_comment|/* message already present */
DECL|enumerator|k_absent
id|k_absent
comma
multiline_comment|/* couldn&squot;t locate scb */
DECL|enumerator|k_disconnect
id|k_disconnect
comma
multiline_comment|/* scb found, but disconnected */
DECL|typedef|k_state
)brace
id|k_state
suffix:semicolon
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_kill&n; *&n; * Description:&n; *   This must be called with interrupts disabled - it&squot;s going to&n; *   be messing around with the host data, and an interrupt being&n; *   fielded in the middle could get ugly.&n; *&n; *   Since so much of the abort and reset code is shared, this&n; *   function performs more magic than it really should. If the&n; *   command completes ok, then it will call scsi_done with the&n; *   result code passed in. The unpause parameter controls whether&n; *   or not the sequencer gets unpaused - the reset function, for&n; *   instance, may want to do something more aggressive.&n; *&n; *   Note that the command is checked for in our SCB_array first&n; *   before the sequencer is paused, so if k_absent is returned,&n; *   then the sequencer is NOT paused.&n; *-F*************************************************************************/
r_static
id|k_state
DECL|function|aic7xxx_kill
id|aic7xxx_kill
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_char
id|message
comma
r_int
r_int
id|result
comma
r_int
id|unpause
)paren
(brace
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
r_struct
id|aic7xxx_scb
op_star
id|scb
suffix:semicolon
r_int
id|i
comma
id|active_scb
comma
id|found
comma
id|queued
suffix:semicolon
r_int
r_char
id|scbsave
(braket
id|AIC7XXX_MAXSCB
)braket
suffix:semicolon
r_int
r_char
id|flags
suffix:semicolon
r_int
id|scb_control
suffix:semicolon
id|k_state
id|status
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|scb
op_assign
op_amp
id|p-&gt;scb_array
(braket
id|aic7xxx_position
c_func
(paren
id|cmd
)paren
)braket
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;aic7xxx_kill: In the kill function...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|PAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;   * Case 1: In the QINFIFO&n;   *&n;   * This is the best case, really. Check to see if the&n;   * command is still in the sequencer&squot;s input queue. If&n;   * so, simply remove it. Reload the queue afterward.&n;   */
id|queued
op_assign
id|inb
c_func
(paren
id|QINCNT
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|found
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|queued
op_minus
id|found
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scbsave
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|QINFIFO
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scbsave
(braket
id|i
)braket
op_eq
id|scb-&gt;position
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
id|i
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|queued
op_assign
l_int|0
suffix:semicolon
id|queued
OL
id|i
suffix:semicolon
id|queued
op_increment
)paren
(brace
id|outb
c_func
(paren
id|scbsave
(braket
id|queued
)braket
comma
id|QINFIFO
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|status
op_assign
id|k_ok
suffix:semicolon
r_goto
id|complete
suffix:semicolon
)brace
id|active_scb
op_assign
id|inb
c_func
(paren
id|SCBPTR
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;   * Case 2: Not the active command&n;   *&n;   * Check the current SCB bank. If it&squot;s not the one belonging&n;   * to the command we want to kill, select the scb we want to&n;   * abort and turn off the disconnected bit. The driver will&n;   * then abort the command and notify us of the abort.&n;   */
r_if
c_cond
(paren
id|active_scb
op_ne
id|scb-&gt;position
)paren
(brace
id|outb
c_func
(paren
id|scb-&gt;position
comma
id|SCBPTR
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|scb_control
op_assign
id|inb
c_func
(paren
id|SCBARRAY
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|scb_control
op_assign
id|scb_control
op_amp
op_complement
id|SCB_DIS
suffix:semicolon
id|outb
c_func
(paren
id|scb_control
comma
id|SCBARRAY
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|active_scb
comma
id|SCBPTR
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|status
op_assign
id|k_disconnect
suffix:semicolon
r_goto
id|complete
suffix:semicolon
)brace
id|scb_control
op_assign
id|inb
c_func
(paren
id|SCBARRAY
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_control
op_amp
id|SCB_DIS
)paren
(brace
id|scb_control
op_assign
id|scb_control
op_amp
op_complement
id|SCB_DIS
suffix:semicolon
id|outb
c_func
(paren
id|scb_control
comma
id|SCBARRAY
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|status
op_assign
id|k_disconnect
suffix:semicolon
r_goto
id|complete
suffix:semicolon
)brace
multiline_comment|/*&n;   * Presumably at this point our target command is active. Check&n;   * to see if there&squot;s a message already in effect. If not, place&n;   * our message in and assert ATN so the target goes into MESSAGE&n;   * OUT phase.&n;   */
id|flags
op_assign
id|inb
c_func
(paren
id|HA_FLAGS
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|ACTIVE_MSG
)paren
(brace
multiline_comment|/*&n;     * If there is a message in progress, reset the bus&n;     * and have all devices renegotiate.&n;     */
r_if
c_cond
(paren
id|cmd-&gt;channel
op_amp
l_int|0x01
)paren
(brace
id|p-&gt;needsdtr
op_assign
id|p-&gt;needsdtr_copy
op_amp
l_int|0xFF00
suffix:semicolon
id|p-&gt;sdtr_pending
op_assign
id|p-&gt;sdtr_pending
op_amp
l_int|0x00FF
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|HA_ACTIVE1
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|p-&gt;bus_type
op_eq
id|AIC_WIDE
)paren
(brace
id|p-&gt;needsdtr
op_assign
id|p-&gt;needsdtr_copy
suffix:semicolon
id|p-&gt;needwdtr
op_assign
id|p-&gt;needwdtr_copy
suffix:semicolon
id|p-&gt;sdtr_pending
op_assign
l_int|0
suffix:semicolon
id|p-&gt;wdtr_pending
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|HA_ACTIVE0
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|HA_ACTIVE1
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;needsdtr
op_assign
id|p-&gt;needsdtr_copy
op_amp
l_int|0x00FF
suffix:semicolon
id|p-&gt;sdtr_pending
op_assign
id|p-&gt;sdtr_pending
op_amp
l_int|0xFF00
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|HA_ACTIVE0
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Reset the bus. */
id|outb
c_func
(paren
id|SCSIRSTO
comma
id|SCSISEQ
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCSISEQ
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|aic7xxx_delay
c_func
(paren
id|AIC7XXX_RESET_DELAY
)paren
suffix:semicolon
id|status
op_assign
id|k_busy
suffix:semicolon
r_goto
id|complete
suffix:semicolon
)brace
id|outb
c_func
(paren
id|flags
op_or
id|ACTIVE_MSG
comma
id|HA_FLAGS
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
multiline_comment|/* active message */
id|outb
c_func
(paren
l_int|1
comma
id|HA_MSG_LEN
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
multiline_comment|/* length = 1 */
id|outb
c_func
(paren
id|message
comma
id|HA_MSG_START
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
multiline_comment|/* message body */
multiline_comment|/*&n;   * Assert ATN. Use the value of SCSISIGO saved by the&n;   * sequencer code so we don&squot;t alter its contents radically&n;   * in the middle of something critical.&n;   */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|HA_SIGSTATE
c_func
(paren
id|p-&gt;base
)paren
)paren
op_or
l_int|0x10
comma
id|SCSISIGO
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|status
op_assign
id|k_ok
suffix:semicolon
multiline_comment|/*&n;   * The command has been killed. Do the bookkeeping, unpause&n;   * the sequencer, and notify the higher-level SCSI code.&n;   */
id|complete
suffix:colon
r_if
c_cond
(paren
id|unpause
)paren
(brace
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * Mark the scb as free and clear the scbs command pointer.&n;   * Add the scb to the head of the free list being careful&n;   * to preserve the next pointers.&n;   */
id|scb-&gt;state
op_assign
id|SCB_FREE
suffix:semicolon
multiline_comment|/* mark the scb as free */
id|scb-&gt;cmd
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* clear the command pointer */
id|scb-&gt;next
op_assign
id|p-&gt;free_scb
suffix:semicolon
multiline_comment|/* preserve next pointer */
id|p-&gt;free_scb
op_assign
id|scb
suffix:semicolon
multiline_comment|/* add at head of free list */
id|cmd-&gt;result
op_assign
id|cmd-&gt;result
op_lshift
l_int|16
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_abort&n; *&n; * Description:&n; *   Abort the current SCSI command(s).&n; *-F*************************************************************************/
r_int
DECL|function|aic7xxx_abort
id|aic7xxx_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|rv
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|aic7xxx_kill
c_func
(paren
id|cmd
comma
id|ABORT
comma
id|DID_ABORT
comma
op_logical_neg
l_int|0
)paren
)paren
(brace
r_case
id|k_ok
suffix:colon
id|rv
op_assign
id|SCSI_ABORT_SUCCESS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|k_busy
suffix:colon
id|rv
op_assign
id|SCSI_ABORT_BUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|k_absent
suffix:colon
id|rv
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
r_break
suffix:semicolon
r_case
id|k_disconnect
suffix:colon
id|rv
op_assign
id|SCSI_ABORT_SNOOZE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;aic7xxx_abort: internal error&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_reset&n; *&n; * Description:&n; *   Resetting the bus always succeeds - is has to, otherwise the&n; *   kernel will panic! Try a surgical technique - sending a BUS&n; *   DEVICE RESET message - on the offending target before pulling&n; *   the SCSI bus reset line.&n; *-F*************************************************************************/
r_int
DECL|function|aic7xxx_reset
id|aic7xxx_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|flags
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|aic7xxx_kill
c_func
(paren
id|cmd
comma
id|BUS_DEVICE_RESET
comma
id|DID_RESET
comma
l_int|0
)paren
)paren
(brace
r_case
id|k_ok
suffix:colon
multiline_comment|/*&n;       * The RESET message was sent to the target&n;       * with no problems. Flag that target as&n;       * needing a SDTR negotiation on the next&n;       * connection and restart the sequencer.&n;       */
id|p-&gt;needsdtr
op_assign
id|p-&gt;needsdtr
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
suffix:semicolon
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|k_absent
suffix:colon
multiline_comment|/*&n;       * The sequencer will not be paused if aic7xxx_kill()&n;       * couldn&squot;t find the command.&n;       */
id|PAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* falls through */
r_case
id|k_busy
suffix:colon
id|cmd-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* return reset code */
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|k_disconnect
suffix:colon
multiline_comment|/*&n;       * Do a hard reset of the SCSI bus. According to the&n;       * SCSI-2 draft specification, reset has to be asserted&n;       * for at least 25us. I&squot;m invoking the kernel delay&n;       * function for 30us since I&squot;m not totally trusting of&n;       * the busy loop timing.&n;       *&n;       * XXX - I&squot;m not convinced this works. I tried resetting&n;       *       the bus before, trying to get the devices on the&n;       *       bus to revert to asynchronous transfer, and it&n;       *       never seemed to work.&n;       */
id|debug
c_func
(paren
l_string|&quot;aic7xxx: attempting to reset scsi bus and card&bslash;n&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SCSIRSTO
comma
id|SCSISEQ
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCSISEQ
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|aic7xxx_delay
c_func
(paren
id|AIC7XXX_RESET_DELAY
)paren
suffix:semicolon
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;       * Locate the command and return a &quot;reset&quot; status&n;       * for it. This is not completely correct and will&n;       * probably return to haunt me later.&n;       */
id|cmd-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* return reset code */
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;aic7xxx_reset: internal error&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_RESET_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_biosparam&n; *&n; * Description:&n; *   Return the disk geometry for the given SCSI device.&n; *-F*************************************************************************/
r_int
DECL|function|aic7xxx_biosparam
id|aic7xxx_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
r_int
id|devno
comma
r_int
id|geom
(braket
)braket
)paren
(brace
r_int
id|heads
comma
id|sectors
comma
id|cylinders
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|disk-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
multiline_comment|/*&n;   * XXX - if I could portably find the card&squot;s configuration&n;   *       information, then this could be autodetected instead&n;   *       of left to a boot-time switch.&n;   */
id|heads
op_assign
l_int|64
suffix:semicolon
id|sectors
op_assign
l_int|32
suffix:semicolon
id|cylinders
op_assign
id|disk-&gt;capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;extended
op_logical_and
id|cylinders
OG
l_int|1024
)paren
(brace
id|heads
op_assign
l_int|255
suffix:semicolon
id|sectors
op_assign
l_int|63
suffix:semicolon
id|cylinders
op_assign
id|disk-&gt;capacity
op_div
(paren
l_int|255
op_star
l_int|63
)paren
suffix:semicolon
)brace
id|geom
(braket
l_int|0
)braket
op_assign
id|heads
suffix:semicolon
id|geom
(braket
l_int|1
)braket
op_assign
id|sectors
suffix:semicolon
id|geom
(braket
l_int|2
)braket
op_assign
id|cylinders
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
multiline_comment|/* Eventually this will go into an include file, but this will be later */
DECL|variable|driver_template
id|Scsi_Host_Template
id|driver_template
op_assign
id|AIC7XXX
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
macro_line|#endif
eof
