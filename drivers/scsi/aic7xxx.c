multiline_comment|/*&n; *  @(#)aic7xxx.c 1.34 94/11/30 jda&n; *&n; *  Adaptec 274x/284x/294x device driver for Linux.&n; *  Copyright (c) 1994 The University of Calgary Department of Computer Science.&n; *  &n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *  &n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *  &n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *  Sources include the Adaptec 1740 driver (aha1740.c), the&n; *  Ultrastor 24F driver (ultrastor.c), various Linux kernel&n; *  source, the Adaptec EISA config file (!adp7771.cfg), the&n; *  Adaptec AHA-2740A Series User&squot;s Guide, the Linux Kernel&n; *  Hacker&squot;s Guide, Writing a SCSI Device Driver for Linux,&n; *  the Adaptec 1542 driver (aha1542.c), the Adaptec EISA&n; *  overlay file (adp7770.ovl), the Adaptec AHA-2740 Series&n; *  Technical Reference Manual, the Adaptec AIC-7770 Data&n; *  Book, the ANSI SCSI specification, the ANSI SCSI-2&n; *  specification (draft 10c), ...&n; *&n; *  On a twin-bus adapter card, channel B is ignored.  Rationale:&n; *  it would greatly complicate the sequencer and host driver code,&n; *  and both busses are multiplexed on to the EISA bus anyway.  So&n; *  I don&squot;t really see any technical advantage to supporting both.&n; *&n; *  As well, multiple adapter card using the same IRQ level are&n; *  not supported.  It doesn&squot;t make sense to configure the cards&n; *  this way from a performance standpoint.  Not to mention that&n; *  the kernel would have to support two devices per registered IRQ.&n; */
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &quot;../block/blk.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;aic7xxx.h&quot;
multiline_comment|/*&n; *  There should be a specific return value for this in scsi.h, but&n; *  it seems that most drivers ignore it.&n; */
DECL|macro|DID_UNDERFLOW
mdefine_line|#define DID_UNDERFLOW&t;DID_ERROR
multiline_comment|/* EISA/VL-bus stuff */
DECL|macro|MINSLOT
mdefine_line|#define MINSLOT&t;&t;1
DECL|macro|MAXSLOT
mdefine_line|#define MAXSLOT&t;&t;15
DECL|macro|SLOTBASE
mdefine_line|#define SLOTBASE(x)&t;((x) &lt;&lt; 12)
DECL|macro|MAXIRQ
mdefine_line|#define MAXIRQ&t;&t;15
multiline_comment|/* AIC-7770 offset definitions */
DECL|macro|O_MINREG
mdefine_line|#define O_MINREG(x)&t;((x) + 0xc00)&t;&t;/* i/o range to reserve */
DECL|macro|O_MAXREG
mdefine_line|#define O_MAXREG(x)&t;((x) + 0xcbf)
DECL|macro|O_SCSISEQ
mdefine_line|#define O_SCSISEQ(x)&t;((x) + 0xc00)&t;&t;/* scsi sequence control */
DECL|macro|O_SCSISIGI
mdefine_line|#define O_SCSISIGI(x)&t;((x) + 0xc03)&t;&t;/* scsi control signal read */
DECL|macro|O_SCSISIGO
mdefine_line|#define O_SCSISIGO(x)&t;((x) + 0xc03)&t;&t;/* scsi control signal write */
DECL|macro|O_SCSIID
mdefine_line|#define O_SCSIID(x)&t;((x) + 0xc05)&t;&t;/* scsi id */
DECL|macro|O_SSTAT0
mdefine_line|#define O_SSTAT0(x)&t;((x) + 0xc0b)&t;&t;/* scsi status register 0 */
DECL|macro|O_CLRSINT1
mdefine_line|#define O_CLRSINT1(x)&t;((x) + 0xc0c)&t;&t;/* clear scsi interrupt 1 */
DECL|macro|O_SSTAT1
mdefine_line|#define O_SSTAT1(x)&t;((x) + 0xc0c)&t;&t;/* scsi status register 1 */
DECL|macro|O_SELID
mdefine_line|#define O_SELID(x)&t;((x) + 0xc19)&t;&t;/* [re]selection id */
DECL|macro|O_SBLKCTL
mdefine_line|#define O_SBLKCTL(x)&t;((x) + 0xc1f)&t;&t;/* scsi block control */
DECL|macro|O_SEQCTL
mdefine_line|#define O_SEQCTL(x)&t;((x) + 0xc60)&t;&t;/* sequencer control */
DECL|macro|O_SEQRAM
mdefine_line|#define O_SEQRAM(x)&t;((x) + 0xc61)&t;&t;/* sequencer ram data */
DECL|macro|O_SEQADDR
mdefine_line|#define O_SEQADDR(x)&t;((x) + 0xc62)&t;&t;/* sequencer address (W) */
DECL|macro|O_BIDx
mdefine_line|#define O_BIDx(x)&t;((x) + 0xc80)&t;&t;/* board id */
DECL|macro|O_BCTL
mdefine_line|#define O_BCTL(x)&t;((x) + 0xc84)&t;&t;/* board control */
DECL|macro|O_HCNTRL
mdefine_line|#define O_HCNTRL(x)&t;((x) + 0xc87)&t;&t;/* host control */
DECL|macro|O_SCBPTR
mdefine_line|#define O_SCBPTR(x)&t;((x) + 0xc90)&t;&t;/* scb pointer */
DECL|macro|O_INTSTAT
mdefine_line|#define O_INTSTAT(x)&t;((x) + 0xc91)&t;&t;/* interrupt status */
DECL|macro|O_ERROR
mdefine_line|#define O_ERROR(x)&t;((x) + 0xc92)&t;&t;/* hard error */
DECL|macro|O_CLRINT
mdefine_line|#define O_CLRINT(x)&t;((x) + 0xc92)&t;&t;/* clear interrupt status */
DECL|macro|O_SCBCNT
mdefine_line|#define O_SCBCNT(x)&t;((x) + 0xc9a)&t;&t;/* scb auto increment */
DECL|macro|O_QINFIFO
mdefine_line|#define O_QINFIFO(x)&t;((x) + 0xc9b)&t;&t;/* queue in fifo */
DECL|macro|O_QINCNT
mdefine_line|#define O_QINCNT(x)&t;((x) + 0xc9c)&t;&t;/* queue in count */
DECL|macro|O_QOUTFIFO
mdefine_line|#define O_QOUTFIFO(x)&t;((x) + 0xc9d)&t;&t;/* queue out fifo */
DECL|macro|O_QOUTCNT
mdefine_line|#define O_QOUTCNT(x)&t;((x) + 0xc9e)&t;&t;/* queue out count */
DECL|macro|O_SCBARRAY
mdefine_line|#define O_SCBARRAY(x)&t;((x) + 0xca0)&t;&t;/* scb array start */
multiline_comment|/* AIC-7870-only definitions */
DECL|macro|O_DSPCISTATUS
mdefine_line|#define O_DSPCISTATUS(x) ((x) + 0xc86)&t;&t;/* ??? */
multiline_comment|/* host adapter offset definitions */
DECL|macro|HA_REJBYTE
mdefine_line|#define HA_REJBYTE(x)&t;((x) + 0xc31)&t;&t;/* 1st message in byte */
DECL|macro|HA_MSG_FLAGS
mdefine_line|#define HA_MSG_FLAGS(x)&t;((x) + 0xc35)&t;&t;/* outgoing message flag */
DECL|macro|HA_MSG_LEN
mdefine_line|#define HA_MSG_LEN(x)&t;((x) + 0xc36)&t;&t;/* outgoing message length */
DECL|macro|HA_MSG_START
mdefine_line|#define HA_MSG_START(x)&t;((x) + 0xc37)&t;&t;/* outgoing message body */
DECL|macro|HA_ARG_1
mdefine_line|#define HA_ARG_1(x)&t;((x) + 0xc4c)&t;&t;/* sdtr &lt;-&gt; rate parameters */
DECL|macro|HA_ARG_2
mdefine_line|#define HA_ARG_2(x)&t;((x) + 0xc4d)
DECL|macro|HA_RETURN_1
mdefine_line|#define HA_RETURN_1(x)&t;((x) + 0xc4c)
DECL|macro|HA_RETURN_2
mdefine_line|#define HA_RETURN_2(x)&t;((x) + 0xc4d)
DECL|macro|HA_SIGSTATE
mdefine_line|#define HA_SIGSTATE(x)&t;((x) + 0xc4e)&t;&t;/* value in SCSISIGO */
DECL|macro|HA_NEEDSDTR
mdefine_line|#define HA_NEEDSDTR(x)&t;((x) + 0xc4f)&t;&t;/* synchronous negotiation? */
DECL|macro|HA_SCBCOUNT
mdefine_line|#define HA_SCBCOUNT(x)&t;((x) + 0xc56)&t;&t;/* number of hardware SCBs */
DECL|macro|HA_SCSICONF
mdefine_line|#define HA_SCSICONF(x)&t;((x) + 0xc5a)&t;&t;/* SCSI config register */
DECL|macro|HA_INTDEF
mdefine_line|#define HA_INTDEF(x)&t;((x) + 0xc5c)&t;&t;/* interrupt def&squot;n register */
DECL|macro|HA_HOSTCONF
mdefine_line|#define HA_HOSTCONF(x)&t;((x) + 0xc5d)&t;&t;/* host config def&squot;n register */
multiline_comment|/* debugging code */
multiline_comment|/*&n;#define AIC7XXX_DEBUG&n;*/
multiline_comment|/*&n; *  If a parity error occurs during a data transfer phase, run the&n; *  command to completion - it&squot;s easier that way - making a note&n; *  of the error condition in this location.  This then will modify&n; *  a DID_OK status into a DID_PARITY one for the higher-level SCSI&n; *  code.&n; */
DECL|macro|aic7xxx_parity
mdefine_line|#define aic7xxx_parity(cmd)&t;((cmd)-&gt;SCp.Status)
multiline_comment|/*&n; *  Since the sequencer code DMAs the scatter-gather structures&n; *  directly from memory, we use this macro to assert that the&n; *  kernel structure hasn&squot;t changed.&n; */
DECL|macro|SG_STRUCT_CHECK
mdefine_line|#define SG_STRUCT_CHECK(sg) &bslash;&n;&t;((char *)&amp;(sg).address - (char *)&amp;(sg) != 0 ||&t;&bslash;&n;&t; (char *)&amp;(sg).length  - (char *)&amp;(sg) != 8 ||&t;&bslash;&n;&t; sizeof((sg).address) != 4 ||&t;&t;&t;&bslash;&n;&t; sizeof((sg).length)  != 4 ||&t;&t;&t;&bslash;&n;&t; sizeof(sg)&t;      != 12)
multiline_comment|/*&n; *  &quot;Static&quot; structures.  Note that these are NOT initialized&n; *  to zero inside the kernel - we have to initialize them all&n; *  explicitly.&n; *&n; *  We support a maximum of one adapter card per IRQ level (see the&n; *  rationale for this above).  On an interrupt, use the IRQ as an&n; *  index into aic7xxx_boards[] to locate the card information.&n; */
DECL|variable|aic7xxx_boards
r_static
r_struct
id|Scsi_Host
op_star
id|aic7xxx_boards
(braket
id|MAXIRQ
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/*&n; *  The maximum number of SCBs we could have for ANY type&n; *  of card.  DON&squot;T FORGET TO CHANGE THE SCB MASK IN THE&n; *  SEQUENCER CODE IF THIS IS MODIFIED!&n; */
DECL|macro|AIC7XXX_MAXSCB
mdefine_line|#define AIC7XXX_MAXSCB&t;16
DECL|struct|aic7xxx_host
r_struct
id|aic7xxx_host
(brace
DECL|member|base
r_int
id|base
suffix:semicolon
multiline_comment|/* card base address */
DECL|member|maxscb
r_int
id|maxscb
suffix:semicolon
multiline_comment|/* hardware SCBs */
DECL|member|startup
r_int
id|startup
suffix:semicolon
multiline_comment|/* intr type check */
DECL|member|extended
r_int
id|extended
suffix:semicolon
multiline_comment|/* extended xlate? */
DECL|member|unpause
r_volatile
r_int
id|unpause
suffix:semicolon
multiline_comment|/* value for HCNTRL */
DECL|member|SCB_array
r_volatile
id|Scsi_Cmnd
op_star
id|SCB_array
(braket
id|AIC7XXX_MAXSCB
)braket
suffix:semicolon
multiline_comment|/* active commands */
)brace
suffix:semicolon
DECL|struct|aic7xxx_host_config
r_struct
id|aic7xxx_host_config
(brace
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* IRQ number */
DECL|member|base
r_int
id|base
suffix:semicolon
multiline_comment|/* I/O base */
DECL|member|maxscb
r_int
id|maxscb
suffix:semicolon
multiline_comment|/* hardware SCBs */
DECL|member|unpause
r_int
id|unpause
suffix:semicolon
multiline_comment|/* value for HCNTRL */
DECL|member|scsi_id
r_int
id|scsi_id
suffix:semicolon
multiline_comment|/* host SCSI id */
DECL|member|extended
r_int
id|extended
suffix:semicolon
multiline_comment|/* extended xlate? */
)brace
suffix:semicolon
DECL|struct|aic7xxx_scb
r_struct
id|aic7xxx_scb
(brace
DECL|member|control
r_int
r_char
id|control
suffix:semicolon
DECL|member|target_channel_lun
r_int
r_char
id|target_channel_lun
suffix:semicolon
multiline_comment|/* 4/1/3 bits */
DECL|member|SG_segment_count
r_int
r_char
id|SG_segment_count
suffix:semicolon
DECL|member|SG_list_pointer
r_int
r_char
id|SG_list_pointer
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|SCSI_cmd_pointer
r_int
r_char
id|SCSI_cmd_pointer
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|SCSI_cmd_length
r_int
r_char
id|SCSI_cmd_length
suffix:semicolon
DECL|member|RESERVED
r_int
r_char
id|RESERVED
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* must be zero */
DECL|member|target_status
r_int
r_char
id|target_status
suffix:semicolon
DECL|member|residual_data_count
r_int
r_char
id|residual_data_count
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|residual_SG_segment_count
r_int
r_char
id|residual_SG_segment_count
suffix:semicolon
DECL|member|data_pointer
r_int
r_char
id|data_pointer
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|data_count
r_int
r_char
id|data_count
(braket
l_int|3
)braket
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t; *  No real point in transferring this to the&n;&t; *  SCB registers.&n;&t; */
r_int
r_char
id|RESERVED
(braket
l_int|6
)braket
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/*&n; *  NB.  This table MUST be ordered shortest period first.&n; */
r_static
r_struct
(brace
DECL|member|period
r_int
id|period
suffix:semicolon
DECL|member|rate
r_int
id|rate
suffix:semicolon
DECL|member|english
r_char
op_star
id|english
suffix:semicolon
DECL|variable|aic7xxx_synctab
)brace
id|aic7xxx_synctab
(braket
)braket
op_assign
(brace
l_int|100
comma
l_int|0
comma
l_string|&quot;10.0&quot;
comma
l_int|125
comma
l_int|1
comma
l_string|&quot;8.0&quot;
comma
l_int|150
comma
l_int|2
comma
l_string|&quot;6.67&quot;
comma
l_int|175
comma
l_int|3
comma
l_string|&quot;5.7&quot;
comma
l_int|200
comma
l_int|4
comma
l_string|&quot;5.0&quot;
comma
l_int|225
comma
l_int|5
comma
l_string|&quot;4.4&quot;
comma
l_int|250
comma
l_int|6
comma
l_string|&quot;4.0&quot;
comma
l_int|275
comma
l_int|7
comma
l_string|&quot;3.6&quot;
)brace
suffix:semicolon
DECL|variable|aic7xxx_synctab_max
r_static
r_int
id|aic7xxx_synctab_max
op_assign
r_sizeof
(paren
id|aic7xxx_synctab
)paren
op_div
r_sizeof
(paren
id|aic7xxx_synctab
(braket
l_int|0
)braket
)paren
suffix:semicolon
DECL|enum|aha_type
r_enum
id|aha_type
(brace
DECL|enumerator|T_NONE
id|T_NONE
comma
DECL|enumerator|T_274X
id|T_274X
comma
DECL|enumerator|T_284X
id|T_284X
comma
DECL|enumerator|T_294X
id|T_294X
comma
DECL|enumerator|T_MAX
id|T_MAX
)brace
suffix:semicolon
macro_line|#ifdef AIC7XXX_DEBUG
r_extern
r_int
id|vsprintf
c_func
(paren
r_char
op_star
comma
r_const
r_char
op_star
comma
id|va_list
)paren
suffix:semicolon
r_static
DECL|function|debug
r_void
id|debug
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|ap
suffix:semicolon
r_char
id|buf
(braket
l_int|256
)braket
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|fmt
)paren
suffix:semicolon
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|ap
)paren
suffix:semicolon
id|printk
c_func
(paren
id|buf
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
r_static
DECL|function|debug_config
r_void
id|debug_config
c_func
(paren
r_enum
id|aha_type
id|type
comma
r_struct
id|aic7xxx_host_config
op_star
id|p
)paren
(brace
r_int
id|ioport2
comma
id|ioport3
suffix:semicolon
r_static
r_char
op_star
id|BRT
(braket
id|T_MAX
)braket
(braket
l_int|16
)braket
op_assign
(brace
(brace
)brace
comma
multiline_comment|/* T_NONE */
(brace
l_string|&quot;2&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;12&quot;
comma
multiline_comment|/* T_274X */
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;28&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;44&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;60&quot;
)brace
comma
(brace
l_string|&quot;2&quot;
comma
l_string|&quot;4&quot;
comma
l_string|&quot;8&quot;
comma
l_string|&quot;12&quot;
comma
multiline_comment|/* T_284X */
l_string|&quot;16&quot;
comma
l_string|&quot;20&quot;
comma
l_string|&quot;24&quot;
comma
l_string|&quot;28&quot;
comma
l_string|&quot;32&quot;
comma
l_string|&quot;36&quot;
comma
l_string|&quot;40&quot;
comma
l_string|&quot;44&quot;
comma
l_string|&quot;48&quot;
comma
l_string|&quot;52&quot;
comma
l_string|&quot;56&quot;
comma
l_string|&quot;60&quot;
)brace
comma
(brace
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
multiline_comment|/* T_294X */
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;???&quot;
)brace
)brace
suffix:semicolon
r_static
r_int
id|DFT
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|50
comma
l_int|75
comma
l_int|100
)brace
suffix:semicolon
r_static
r_int
id|SST
(braket
l_int|4
)braket
op_assign
(brace
l_int|256
comma
l_int|128
comma
l_int|64
comma
l_int|32
)brace
suffix:semicolon
id|ioport2
op_assign
id|inb
c_func
(paren
id|HA_HOSTCONF
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|ioport3
op_assign
id|inb
c_func
(paren
id|HA_SCSICONF
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|T_274X
suffix:colon
id|printk
c_func
(paren
l_string|&quot;AHA274X AT EISA SLOT %d:&bslash;n&quot;
comma
id|p-&gt;base
op_rshift
l_int|12
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|T_284X
suffix:colon
id|printk
c_func
(paren
l_string|&quot;AHA284X AT SLOT %d:&bslash;n&quot;
comma
id|p-&gt;base
op_rshift
l_int|12
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|T_294X
suffix:colon
id|printk
c_func
(paren
l_string|&quot;AHA294X (PCI-bus):&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;aic7xxx debug_config: internal error&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;    irq %d&bslash;n&quot;
l_string|&quot;    bus release time %s bclks&bslash;n&quot;
l_string|&quot;    data fifo threshold %d%%&bslash;n&quot;
comma
id|p-&gt;irq
comma
id|BRT
(braket
id|type
)braket
(braket
(paren
id|ioport2
op_rshift
l_int|2
)paren
op_amp
l_int|0xf
)braket
comma
id|DFT
(braket
(paren
id|ioport2
op_rshift
l_int|6
)paren
op_amp
l_int|0x3
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    SCSI CHANNEL A:&bslash;n&quot;
l_string|&quot;        scsi id %d&bslash;n&quot;
l_string|&quot;        scsi bus parity check %sabled&bslash;n&quot;
l_string|&quot;        scsi selection timeout %d ms&bslash;n&quot;
l_string|&quot;        scsi bus reset at power-on %sabled&bslash;n&quot;
comma
id|ioport3
op_amp
l_int|0x7
comma
(paren
id|ioport3
op_amp
l_int|0x20
)paren
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
comma
id|SST
(braket
(paren
id|ioport3
op_rshift
l_int|3
)paren
op_amp
l_int|0x3
)braket
comma
(paren
id|ioport3
op_amp
l_int|0x40
)paren
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|T_274X
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;        scsi bus termination %sabled&bslash;n&quot;
comma
(paren
id|ioport3
op_amp
l_int|0x80
)paren
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
)brace
)brace
r_static
DECL|function|debug_rate
r_void
id|debug_rate
c_func
(paren
r_int
id|base
comma
r_int
id|rate
)paren
(brace
r_int
id|target
op_assign
id|inb
c_func
(paren
id|O_SCSIID
c_func
(paren
id|base
)paren
)paren
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|rate
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: target %d now synchronous at %sMb/s&bslash;n&quot;
comma
id|target
comma
id|aic7xxx_synctab
(braket
(paren
id|rate
op_rshift
l_int|4
)paren
op_amp
l_int|0x7
)braket
dot
id|english
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: target %d using asynchronous mode&bslash;n&quot;
comma
id|target
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
DECL|macro|debug
macro_line|#&t;define debug(fmt, args...)
DECL|macro|debug_config
macro_line|#&t;define debug_config(x)
DECL|macro|debug_rate
macro_line|#&t;define debug_rate(x,y)
macro_line|#endif AIC7XXX_DEBUG
multiline_comment|/*&n; *  XXX - these options apply unilaterally to _all_ 274x/284x/294x&n; *&t;  cards in the system.  This should be fixed, but then,&n; *&t;  does anyone really have more than one in a machine?&n; */
DECL|variable|aic7xxx_extended
r_static
r_int
id|aic7xxx_extended
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* extended translation on? */
DECL|function|aic7xxx_setup
r_void
id|aic7xxx_setup
c_func
(paren
r_char
op_star
id|s
comma
r_int
op_star
id|dummy
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_static
r_struct
(brace
r_char
op_star
id|name
suffix:semicolon
r_int
op_star
id|flag
suffix:semicolon
)brace
id|options
(braket
)braket
op_assign
(brace
l_string|&quot;extended&quot;
comma
op_amp
id|aic7xxx_extended
comma
l_int|NULL
)brace
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|strtok
c_func
(paren
id|s
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|strtok
c_func
(paren
l_int|NULL
comma
l_string|&quot;,&quot;
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|options
(braket
id|i
)braket
dot
id|name
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|options
(braket
id|i
)braket
dot
id|name
comma
id|p
)paren
)paren
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
op_assign
op_logical_neg
l_int|0
suffix:semicolon
)brace
)brace
r_static
DECL|function|aic7xxx_getscb
r_void
id|aic7xxx_getscb
c_func
(paren
r_int
id|base
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
multiline_comment|/*&n;&t; *  This is almost identical to aic7xxx_putscb().&n;&t; */
id|outb
c_func
(paren
l_int|0x80
comma
id|O_SCBCNT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* SCBAUTO */
id|asm
r_volatile
(paren
l_string|&quot;cld&bslash;n&bslash;t&quot;
l_string|&quot;rep&bslash;n&bslash;t&quot;
l_string|&quot;insb&quot;
suffix:colon
multiline_comment|/* no output */
suffix:colon
l_string|&quot;D&quot;
(paren
id|scb
)paren
comma
l_string|&quot;c&quot;
(paren
r_sizeof
(paren
op_star
id|scb
)paren
)paren
comma
l_string|&quot;d&quot;
(paren
id|O_SCBARRAY
c_func
(paren
id|base
)paren
)paren
suffix:colon
l_string|&quot;di&quot;
comma
l_string|&quot;cx&quot;
comma
l_string|&quot;dx&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|O_SCBCNT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  How much data should be transferred for this SCSI command?  Stop&n; *  at segment sg_last if it&squot;s a scatter-gather command so we can&n; *  compute underflow easily.&n; */
r_static
DECL|function|aic7xxx_length
r_int
id|aic7xxx_length
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|sg_last
)paren
(brace
r_int
id|i
comma
id|segments
suffix:semicolon
r_int
id|length
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
id|segments
op_assign
id|cmd-&gt;use_sg
op_minus
id|sg_last
suffix:semicolon
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|length
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;use_sg
op_logical_and
id|i
OL
id|segments
suffix:semicolon
id|i
op_increment
)paren
(brace
id|length
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
)brace
r_else
id|length
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
r_static
DECL|function|aic7xxx_sg_check
r_void
id|aic7xxx_sg_check
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
r_int
)paren
id|sg
(braket
id|i
)braket
dot
id|length
OG
l_int|0xffff
)paren
id|panic
c_func
(paren
l_string|&quot;aic7xxx_sg_check: s/g segment &gt; 64k&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_static
DECL|function|aic7xxx_to_scsirate
r_void
id|aic7xxx_to_scsirate
c_func
(paren
r_int
r_char
op_star
id|rate
comma
r_int
r_char
id|transfer
comma
r_int
r_char
id|offset
)paren
(brace
r_int
id|i
suffix:semicolon
id|transfer
op_mul_assign
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|aic7xxx_synctab_max
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|transfer
op_eq
id|aic7xxx_synctab
(braket
id|i
)braket
dot
id|period
)paren
(brace
op_star
id|rate
op_assign
(paren
id|aic7xxx_synctab
(braket
id|i
)braket
dot
id|rate
op_lshift
l_int|4
)paren
op_or
(paren
id|offset
op_amp
l_int|0xf
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|transfer
OG
id|aic7xxx_synctab
(braket
id|i
)braket
dot
id|period
op_logical_and
id|transfer
OL
id|aic7xxx_synctab
(braket
id|i
op_plus
l_int|1
)braket
dot
id|period
)paren
(brace
op_star
id|rate
op_assign
(paren
id|aic7xxx_synctab
(braket
id|i
op_plus
l_int|1
)braket
dot
id|rate
op_lshift
l_int|4
)paren
op_or
(paren
id|offset
op_amp
l_int|0xf
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
op_star
id|rate
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Pause the sequencer and wait for it to actually stop - this&n; *  is important since the sequencer can disable pausing for critical&n; *  sections.&n; */
DECL|macro|PAUSE_SEQUENCER
mdefine_line|#define PAUSE_SEQUENCER(p)&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;outb(0xe, O_HCNTRL(p-&gt;base));&t;/* IRQMS|PAUSE|INTEN */&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;while ((inb(O_HCNTRL(p-&gt;base)) &amp; 0x4) == 0)&t;&t;&bslash;&n;&t;&t;&t;;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;} while (0)
multiline_comment|/*&n; *  Unpause the sequencer.  Unremarkable, yet done often enough to&n; *  warrant an easy way to do it.&n; */
DECL|macro|UNPAUSE_SEQUENCER
mdefine_line|#define UNPAUSE_SEQUENCER(p)&t;&bslash;&n;&t;outb(p-&gt;unpause, O_HCNTRL(p-&gt;base))&t;/* IRQMS|INTEN */
multiline_comment|/*&n; *  See comments in aic7xxx_loadram() wrt this.&n; */
DECL|macro|RESTART_SEQUENCER
mdefine_line|#define RESTART_SEQUENCER(p)&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;outb(0x2, O_SEQCTL(p-&gt;base));&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;} while (inb(O_SEQADDR(p-&gt;base)) != 0 &amp;&amp;&t;&bslash;&n;&t;&t;&t; inb(O_SEQADDR(p-&gt;base) + 1) != 0);&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;UNPAUSE_SEQUENCER(p);&t;&t;&t;&t;&bslash;&n;&t;} while (0)
multiline_comment|/*&n; *  Since we declared this using SA_INTERRUPT, interrupts should&n; *  be disabled all through this function unless we say otherwise.&n; */
r_static
DECL|function|aic7xxx_isr
r_void
id|aic7xxx_isr
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|base
comma
id|intstat
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|aic7xxx_boards
(braket
id|irq
)braket
op_member_access_from_pointer
id|hostdata
suffix:semicolon
id|base
op_assign
id|p-&gt;base
suffix:semicolon
multiline_comment|/*&n;&t; *  Check the startup flag - if no commands have been queued,&n;&t; *  we probably have the interrupt type set wrong.  Reverse&n;&t; *  the stored value and the active one in the host control&n;&t; *  register.&n;&t; */
r_if
c_cond
(paren
id|p-&gt;startup
)paren
(brace
id|p-&gt;unpause
op_xor_assign
l_int|0x8
suffix:semicolon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|O_HCNTRL
c_func
(paren
id|p-&gt;base
)paren
)paren
op_xor
l_int|0x8
comma
id|O_HCNTRL
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Handle all the interrupt sources - especially for SCSI&n;&t; *  interrupts, we won&squot;t get a second chance at them.&n;&t; */
id|intstat
op_assign
id|inb
c_func
(paren
id|O_INTSTAT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intstat
op_amp
l_int|0x8
)paren
(brace
multiline_comment|/* BRKADRINT */
id|panic
c_func
(paren
l_string|&quot;aic7xxx_isr: brkadrint, error = 0x%x, seqaddr = 0x%x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|O_ERROR
c_func
(paren
id|base
)paren
)paren
comma
id|inw
c_func
(paren
id|O_SEQADDR
c_func
(paren
id|base
)paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intstat
op_amp
l_int|0x4
)paren
(brace
multiline_comment|/* SCSIINT */
r_int
id|scbptr
op_assign
id|inb
c_func
(paren
id|O_SCBPTR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_int
id|status
op_assign
id|inb
c_func
(paren
id|O_SSTAT1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|p-&gt;SCB_array
(braket
id|scbptr
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: no command for scb (scsiint)&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Turn off the interrupt and set status&n;&t;&t;&t; *  to zero, so that it falls through the&n;&t;&t;&t; *  reset of the SCSIINT code.&n;&t;&t;&t; */
id|outb
c_func
(paren
id|status
comma
id|O_CLRSINT1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x4
comma
id|O_CLRINT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* undocumented */
id|status
op_assign
l_int|0
suffix:semicolon
)brace
id|p-&gt;SCB_array
(braket
id|scbptr
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Only the SCSI Status 1 register has information&n;&t;&t; *  about exceptional conditions that we&squot;d have a&n;&t;&t; *  SCSIINT about; anything in SSTAT0 will be handled&n;&t;&t; *  by the sequencer.  Note that there can be multiple&n;&t;&t; *  bits set.&n;&t;&t; */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x80
)paren
(brace
multiline_comment|/* SELTO */
multiline_comment|/*&n;&t;&t;&t; *  Hardware selection timer has expired.  Turn&n;&t;&t;&t; *  off SCSI selection sequence.&n;&t;&t;&t; */
id|outb
c_func
(paren
l_int|0
comma
id|O_SCSISEQ
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_TIME_OUT
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  If there&squot;s an active message, it belongs to the&n;&t;&t;&t; *  command that is getting punted - remove it.&n;&t;&t;&t; */
id|outb
c_func
(paren
l_int|0
comma
id|HA_MSG_FLAGS
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Shut off the offending interrupt sources, reset&n;&t;&t;&t; *  the sequencer address to zero and unpause it,&n;&t;&t;&t; *  then call the high-level SCSI completion routine.&n;&t;&t;&t; *&n;&t;&t;&t; *  WARNING!  This is a magic sequence!  After many&n;&t;&t;&t; *  hours of guesswork, turning off the SCSI interrupts&n;&t;&t;&t; *  in CLRSINT? does NOT clear the SCSIINT bit in&n;&t;&t;&t; *  INTSTAT.  By writing to the (undocumented, unused&n;&t;&t;&t; *  according to the AIC-7770 manual) third bit of&n;&t;&t;&t; *  CLRINT, you can clear INTSTAT.  But, if you do it&n;&t;&t;&t; *  while the sequencer is paused, you get a BRKADRINT&n;&t;&t;&t; *  with an Illegal Host Address status, so the&n;&t;&t;&t; *  sequencer has to be restarted first.&n;&t;&t;&t; */
id|outb
c_func
(paren
l_int|0x80
comma
id|O_CLRSINT1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* CLRSELTIMO */
id|RESTART_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x4
comma
id|O_CLRINT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* undocumented */
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
l_int|0x4
)paren
(brace
multiline_comment|/* SCSIPERR */
multiline_comment|/*&n;&t;&t;&t; *  A parity error has occurred during a data&n;&t;&t;&t; *  transfer phase.  Flag it and continue.&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;aic7xxx: parity error on target %d, lun %d&bslash;n&quot;
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|aic7xxx_parity
c_func
(paren
id|cmd
)paren
op_assign
id|DID_PARITY
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Clear interrupt and resume as above.&n;&t;&t;&t; */
id|outb
c_func
(paren
l_int|0x4
comma
id|O_CLRSINT1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* CLRSCSIPERR */
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x4
comma
id|O_CLRINT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* undocumented */
)brace
r_if
c_cond
(paren
(paren
id|status
op_amp
(paren
l_int|0x8
op_or
l_int|0x4
)paren
)paren
op_eq
l_int|0
op_logical_and
id|status
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  We don&squot;t know what&squot;s going on.  Turn off the&n;&t;&t;&t; *  interrupt source and try to continue.&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;aic7xxx_isr: sstat1 = 0x%x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|outb
c_func
(paren
id|status
comma
id|O_CLRSINT1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x4
comma
id|O_CLRINT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* undocumented */
)brace
)brace
r_if
c_cond
(paren
id|intstat
op_amp
l_int|0x2
)paren
(brace
multiline_comment|/* CMDCMPLT */
r_int
id|complete
comma
id|old_scbptr
suffix:semicolon
r_struct
id|aic7xxx_scb
id|scb
suffix:semicolon
r_int
id|actual
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  The sequencer will continue running when it&n;&t;&t; *  issues this interrupt.  There may be &gt;1 commands&n;&t;&t; *  finished, so loop until we&squot;ve processed them all.&n;&t;&t; */
r_do
(brace
id|complete
op_assign
id|inb
c_func
(paren
id|O_QOUTFIFO
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|p-&gt;SCB_array
(braket
id|complete
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx warning: &quot;
l_string|&quot;no command for scb (cmdcmplt)&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|p-&gt;SCB_array
(braket
id|complete
)braket
op_assign
l_int|NULL
suffix:semicolon
id|PAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  After pausing the sequencer (and waiting&n;&t;&t;&t; *  for it to stop), save its SCB pointer, then&n;&t;&t;&t; *  write in our completed one and read the SCB&n;&t;&t;&t; *  registers.  Afterwards, restore the saved&n;&t;&t;&t; *  pointer, unpause the sequencer and call the&n;&t;&t;&t; *  higher-level completion function - unpause&n;&t;&t;&t; *  first since we have no idea how long done()&n;&t;&t;&t; *  will take.&n;&t;&t;&t; */
id|old_scbptr
op_assign
id|inb
c_func
(paren
id|O_SCBPTR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|complete
comma
id|O_SCBPTR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|aic7xxx_getscb
c_func
(paren
id|base
comma
op_amp
id|scb
)paren
suffix:semicolon
id|outb
c_func
(paren
id|old_scbptr
comma
id|O_SCBPTR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|scb.target_status
op_or
(paren
id|aic7xxx_parity
c_func
(paren
id|cmd
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Did we underflow?  At this time, there&squot;s only&n;&t;&t;&t; *  one other driver that bothers to check for this,&n;&t;&t;&t; *  and cmd-&gt;underflow seems to be set rather half-&n;&t;&t;&t; *  heartedly in the higher-level SCSI code.&n;&t;&t;&t; */
id|actual
op_assign
id|aic7xxx_length
c_func
(paren
id|cmd
comma
id|scb.residual_SG_segment_count
)paren
suffix:semicolon
id|actual
op_sub_assign
(paren
(paren
id|scb.residual_data_count
(braket
l_int|2
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|scb.residual_data_count
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|scb.residual_data_count
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|actual
OL
id|cmd-&gt;underflow
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: target %d underflow - &quot;
l_string|&quot;wanted (at least) %u, got %u&bslash;n&quot;
comma
id|cmd-&gt;target
comma
id|cmd-&gt;underflow
comma
id|actual
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|scb.target_status
op_or
(paren
id|DID_UNDERFLOW
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Clear interrupt status before checking&n;&t;&t;&t; *  the output queue again.  This eliminates&n;&t;&t;&t; *  a race condition whereby a command could&n;&t;&t;&t; *  complete between the queue poll and the&n;&t;&t;&t; *  interrupt clearing, so notification of the&n;&t;&t;&t; *  command being complete never made it back&n;&t;&t;&t; *  up to the kernel.&n;&t;&t;&t; */
id|outb
c_func
(paren
l_int|0x2
comma
id|O_CLRINT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* CLRCMDINT */
)brace
r_while
c_loop
(paren
id|inb
c_func
(paren
id|O_QOUTCNT
c_func
(paren
id|base
)paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intstat
op_amp
l_int|0x1
)paren
(brace
multiline_comment|/* SEQINT */
r_int
r_char
id|transfer
comma
id|offset
comma
id|rate
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Although the sequencer is paused immediately on&n;&t;&t; *  a SEQINT, an interrupt for a SCSIINT or a CMDCMPLT&n;&t;&t; *  condition will have unpaused the sequencer before&n;&t;&t; *  this point.&n;&t;&t; */
id|PAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|intstat
op_amp
l_int|0xf0
)paren
(brace
r_case
l_int|0x00
suffix:colon
id|panic
c_func
(paren
l_string|&quot;aic7xxx_isr: unknown scsi bus phase&bslash;n&quot;
)paren
suffix:semicolon
r_case
l_int|0x10
suffix:colon
id|debug
c_func
(paren
l_string|&quot;aic7xxx_isr warning: &quot;
l_string|&quot;issuing message reject, 1st byte 0x%x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|HA_REJBYTE
c_func
(paren
id|base
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x20
suffix:colon
id|panic
c_func
(paren
l_string|&quot;aic7xxx_isr: reconnecting target %d &quot;
l_string|&quot;didn&squot;t issue IDENTIFY message&bslash;n&quot;
comma
(paren
id|inb
c_func
(paren
id|O_SELID
c_func
(paren
id|base
)paren
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
r_case
l_int|0x30
suffix:colon
id|debug
c_func
(paren
l_string|&quot;aic7xxx_isr: sequencer couldn&squot;t find match &quot;
l_string|&quot;for reconnecting target %d - issuing ABORT&bslash;n&quot;
comma
(paren
id|inb
c_func
(paren
id|O_SELID
c_func
(paren
id|base
)paren
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
id|transfer
op_assign
id|inb
c_func
(paren
id|HA_ARG_1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|offset
op_assign
id|inb
c_func
(paren
id|HA_ARG_2
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|aic7xxx_to_scsirate
c_func
(paren
op_amp
id|rate
comma
id|transfer
comma
id|offset
)paren
suffix:semicolon
id|outb
c_func
(paren
id|rate
comma
id|HA_RETURN_1
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|debug_rate
c_func
(paren
id|base
comma
id|rate
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|debug
c_func
(paren
l_string|&quot;aic7xxx_isr: seqint, &quot;
l_string|&quot;intstat = 0x%x, scsisigi = 0x%x&bslash;n&quot;
comma
id|intstat
comma
id|inb
c_func
(paren
id|O_SCSISIGI
c_func
(paren
id|base
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0x1
comma
id|O_CLRINT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* CLRSEQINT */
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  Probing for EISA boards: it looks like the first two bytes&n; *  are a manufacturer code - three characters, five bits each:&n; *&n; *&t;&t; BYTE 0   BYTE 1   BYTE 2   BYTE 3&n; *&t;&t;?1111122 22233333 PPPPPPPP RRRRRRRR&n; *&n; *  The characters are baselined off ASCII &squot;@&squot;, so add that value&n; *  to each to get the real ASCII code for it.  The next two bytes&n; *  appear to be a product and revision number, probably vendor-&n; *  specific.  This is what is being searched for at each port,&n; *  and what should probably correspond to the ID= field in the&n; *  ECU&squot;s .cfg file for the card - if your card is not detected,&n; *  make sure your signature is listed in the array.&n; *&n; *  The fourth byte&squot;s lowest bit seems to be an enabled/disabled&n; *  flag (rest of the bits are reserved?).&n; */
r_static
DECL|function|aic7xxx_probe
r_enum
id|aha_type
id|aic7xxx_probe
c_func
(paren
r_int
id|slot
comma
r_int
id|s_base
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|4
)braket
suffix:semicolon
r_static
r_struct
(brace
r_int
id|n
suffix:semicolon
r_int
r_char
id|signature
(braket
r_sizeof
(paren
id|buf
)paren
)braket
suffix:semicolon
r_enum
id|aha_type
id|type
suffix:semicolon
)brace
id|S
(braket
)braket
op_assign
(brace
l_int|4
comma
(brace
l_int|0x04
comma
l_int|0x90
comma
l_int|0x77
comma
l_int|0x71
)brace
comma
id|T_274X
comma
multiline_comment|/* host adapter 274x */
l_int|4
comma
(brace
l_int|0x04
comma
l_int|0x90
comma
l_int|0x77
comma
l_int|0x70
)brace
comma
id|T_274X
comma
multiline_comment|/* motherboard 274x  */
l_int|4
comma
(brace
l_int|0x04
comma
l_int|0x90
comma
l_int|0x77
comma
l_int|0x56
)brace
comma
id|T_284X
comma
multiline_comment|/* 284x, BIOS enabled */
)brace
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|buf
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *  The VL-bus cards need to be primed by&n;&t;&t; *  writing before a signature check.&n;&t;&t; */
id|outb
c_func
(paren
l_int|0x80
op_plus
id|i
comma
id|s_base
)paren
suffix:semicolon
id|buf
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|s_base
op_plus
id|i
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|S
)paren
op_div
r_sizeof
(paren
id|S
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|buf
comma
id|S
(braket
id|i
)braket
dot
id|signature
comma
id|S
(braket
id|i
)braket
dot
id|n
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  Signature match on enabled card?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|s_base
op_plus
l_int|4
)paren
op_amp
l_int|1
)paren
r_return
id|S
(braket
id|i
)braket
dot
id|type
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aic7xxx disabled at slot %d, ignored&bslash;n&quot;
comma
id|slot
)paren
suffix:semicolon
)brace
)brace
r_return
id|T_NONE
suffix:semicolon
)brace
multiline_comment|/*&n; *  Return &squot; &squot; for plain 274x, &squot;T&squot; for twin-channel, &squot;W&squot; for&n; *  wide channel, &squot;?&squot; for anything else.&n; */
r_static
DECL|function|aic7xxx_type
r_char
id|aic7xxx_type
c_func
(paren
r_int
id|base
)paren
(brace
multiline_comment|/*&n;&t; *  AIC-7770/7870s can be wired so that, on chip reset,&n;&t; *  the SCSI Block Control register indicates how many&n;&t; *  busses the chip is configured for.  The two high bits&n;&t; *  set indicate a 294x.&n;&t; */
r_switch
c_cond
(paren
id|inb
c_func
(paren
id|O_SBLKCTL
c_func
(paren
id|base
)paren
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
l_int|0xc0
suffix:colon
r_return
l_char|&squot; &squot;
suffix:semicolon
r_case
l_int|2
suffix:colon
r_case
l_int|0xc2
suffix:colon
r_return
l_char|&squot;W&squot;
suffix:semicolon
r_case
l_int|8
suffix:colon
r_return
l_char|&squot;T&squot;
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;aic7xxx has unknown bus configuration&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_char|&squot;?&squot;
suffix:semicolon
)brace
)brace
r_static
DECL|function|aic7xxx_loadram
r_void
id|aic7xxx_loadram
c_func
(paren
r_int
id|base
)paren
(brace
r_static
r_int
r_char
id|seqprog
(braket
)braket
op_assign
(brace
multiline_comment|/*&n;&t;&t; *  Each sequencer instruction is 29 bits&n;&t;&t; *  long (fill in the excess with zeroes)&n;&t;&t; *  and has to be loaded from least -&gt; most&n;&t;&t; *  significant byte, so this table has the&n;&t;&t; *  byte ordering reversed.&n;&t;&t; */
macro_line|#&t;&t;include &quot;aic7xxx_seq.h&quot;
)brace
suffix:semicolon
multiline_comment|/*&n;&t; *  When the AIC-7770 is paused (as on chip reset), the&n;&t; *  sequencer address can be altered and a sequencer&n;&t; *  program can be loaded by writing it, byte by byte, to&n;&t; *  the sequencer RAM port - the Adaptec documentation&n;&t; *  recommends using REP OUTSB to do this, hence the inline&n;&t; *  assembly.  Since the address autoincrements as we load&n;&t; *  the program, reset it back to zero afterward.  Disable&n;&t; *  sequencer RAM parity error detection while loading, and&n;&t; *  make sure the LOADRAM bit is enabled for loading.&n;&t; */
id|outb
c_func
(paren
l_int|0x83
comma
id|O_SEQCTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* PERRORDIS|SEQRESET|LOADRAM */
id|asm
r_volatile
(paren
l_string|&quot;cld&bslash;n&bslash;t&quot;
l_string|&quot;rep&bslash;n&bslash;t&quot;
l_string|&quot;outsb&quot;
suffix:colon
multiline_comment|/* no output */
suffix:colon
l_string|&quot;S&quot;
(paren
id|seqprog
)paren
comma
l_string|&quot;c&quot;
(paren
r_sizeof
(paren
id|seqprog
)paren
)paren
comma
l_string|&quot;d&quot;
(paren
id|O_SEQRAM
c_func
(paren
id|base
)paren
)paren
suffix:colon
l_string|&quot;si&quot;
comma
l_string|&quot;cx&quot;
comma
l_string|&quot;dx&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  WARNING!  This is a magic sequence!  After extensive&n;&t; *  experimentation, it seems that you MUST turn off the&n;&t; *  LOADRAM bit before you play with SEQADDR again, else&n;&t; *  you will end up with parity errors being flagged on&n;&t; *  your sequencer program.  (You would also think that&n;&t; *  turning off LOADRAM and setting SEQRESET to reset the&n;&t; *  address to zero would work, but you need to do it twice&n;&t; *  for it to take effect on the address.  Timing problem?)&n;&t; */
id|outb
c_func
(paren
l_int|0
comma
id|O_SEQCTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; *  Actually, reset it until&n;&t;&t; *  the address shows up as&n;&t;&t; *  zero just to be safe..&n;&t;&t; */
id|outb
c_func
(paren
l_int|0x2
comma
id|O_SEQCTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* SEQRESET */
)brace
r_while
c_loop
(paren
id|inb
c_func
(paren
id|O_SEQADDR
c_func
(paren
id|base
)paren
)paren
op_ne
l_int|0
op_logical_and
id|inb
c_func
(paren
id|O_SEQADDR
c_func
(paren
id|base
)paren
op_plus
l_int|1
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_static
DECL|function|aha274x_config
r_void
id|aha274x_config
c_func
(paren
r_struct
id|aic7xxx_host_config
op_star
id|p
comma
id|va_list
id|ap
)paren
(brace
r_int
id|base
op_assign
id|va_arg
c_func
(paren
id|ap
comma
r_int
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Give the AIC-7770 a reset - reading the 274x&squot;s registers&n;&t; *  returns zeroes unless you do.  This forces a pause of the&n;&t; *  Sequencer.&n;&t; */
id|outb
c_func
(paren
l_int|1
comma
id|O_HCNTRL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* CHIPRST */
id|p-&gt;base
op_assign
id|base
suffix:semicolon
id|p-&gt;irq
op_assign
id|inb
c_func
(paren
id|HA_INTDEF
c_func
(paren
id|base
)paren
)paren
op_amp
l_int|0xf
suffix:semicolon
id|p-&gt;scsi_id
op_assign
id|inb
c_func
(paren
id|HA_SCSICONF
c_func
(paren
id|base
)paren
)paren
op_amp
l_int|0x7
suffix:semicolon
multiline_comment|/*&n;&t; *  This value for HCNTRL may be changed in the ISR if we&n;&t; *  catch a spurious interrupt right away.&n;&t; */
id|p-&gt;unpause
op_assign
l_int|0xa
suffix:semicolon
multiline_comment|/*&n;&t; *  XXX - these are values that I don&squot;t know how to query&n;&t; *&t;  the hardware for.  Apparently some revision E&n;&t; *&t;  &squot;7770s can have more SCBs, and I don&squot;t know how&n;&t; *&t;  to get the &quot;extended translation&quot; flag from the&n;&t; *&t;  EISA data area.&n;&t; */
id|p-&gt;maxscb
op_assign
l_int|4
suffix:semicolon
id|p-&gt;extended
op_assign
id|aic7xxx_extended
suffix:semicolon
multiline_comment|/*&n;&t; *  A reminder until this can be detected automatically.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;aha274x: extended translation %sabled&bslash;n&quot;
comma
id|p-&gt;extended
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
)brace
r_static
DECL|function|aha284x_config
r_void
id|aha284x_config
c_func
(paren
r_struct
id|aic7xxx_host_config
op_star
id|p
comma
id|va_list
id|ap
)paren
(brace
r_int
id|base
op_assign
id|va_arg
c_func
(paren
id|ap
comma
r_int
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Give the AIC-7770 a reset - this forces a pause of the&n;&t; *  Sequencer and returns everything to default values.&n;&t; */
id|outb
c_func
(paren
l_int|1
comma
id|O_HCNTRL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* CHIPRST */
id|p-&gt;base
op_assign
id|base
suffix:semicolon
id|p-&gt;unpause
op_assign
l_int|0x2
suffix:semicolon
id|p-&gt;irq
op_assign
id|inb
c_func
(paren
id|HA_INTDEF
c_func
(paren
id|base
)paren
)paren
op_amp
l_int|0xf
suffix:semicolon
id|p-&gt;scsi_id
op_assign
id|inb
c_func
(paren
id|HA_SCSICONF
c_func
(paren
id|base
)paren
)paren
op_amp
l_int|0x7
suffix:semicolon
multiline_comment|/*&n;&t; *  XXX - these are values that I don&squot;t know how to query&n;&t; *&t;  the hardware for.  Apparently some revision E&n;&t; *&t;  &squot;7770s can have more SCBs, and I don&squot;t know how&n;&t; *&t;  to get the &quot;extended translation&quot; flag from the&n;&t; *&t;  onboard memory.&n;&t; */
id|p-&gt;maxscb
op_assign
l_int|4
suffix:semicolon
id|p-&gt;extended
op_assign
id|aic7xxx_extended
suffix:semicolon
multiline_comment|/*&n;&t; *  A reminder until this can be detected automatically.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;aha284x: extended translation %sabled&bslash;n&quot;
comma
id|p-&gt;extended
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
)brace
r_static
DECL|function|aha294x_config
r_void
id|aha294x_config
c_func
(paren
r_struct
id|aic7xxx_host_config
op_star
id|p
comma
id|va_list
id|ap
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
r_int
id|io_port
suffix:semicolon
r_int
r_char
id|bus
comma
id|device_fn
comma
id|irq
suffix:semicolon
id|bus
op_assign
id|va_arg
c_func
(paren
id|ap
comma
r_int
r_char
)paren
suffix:semicolon
id|device_fn
op_assign
id|va_arg
c_func
(paren
id|ap
comma
r_int
r_char
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Read esundry information from PCI BIOS.&n;&t; */
id|error
op_assign
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|io_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;aha294x_config: error %s reading i/o port&bslash;n&quot;
comma
id|pcibios_strerror
c_func
(paren
id|error
)paren
)paren
suffix:semicolon
)brace
id|error
op_assign
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_INTERRUPT_LINE
comma
op_amp
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;aha294x_config: error %s reading irq&bslash;n&quot;
comma
id|pcibios_strerror
c_func
(paren
id|error
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Make the base I/O register look like EISA and VL-bus.&n;&t; */
id|p-&gt;base
op_assign
id|io_port
op_minus
l_int|0xc01
suffix:semicolon
multiline_comment|/*&n;&t; *  Give the AIC-7870 a reset - this forces a pause of the&n;&t; *  Sequencer and returns everything to default values.&n;&t; */
id|outb
c_func
(paren
l_int|1
comma
id|O_HCNTRL
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
multiline_comment|/* CHIPRST */
id|p-&gt;irq
op_assign
id|irq
suffix:semicolon
id|p-&gt;maxscb
op_assign
l_int|16
suffix:semicolon
id|p-&gt;unpause
op_assign
l_int|0xa
suffix:semicolon
multiline_comment|/*&n;&t; *  XXX - these are values that I don&squot;t know how to query&n;&t; *&t;  the hardware for, so for now the SCSI host ID is&n;&t; *&t;  hardwired to 7, and the &quot;extended translation&quot;&n;&t; *&t;  flag is taken from boot-time flags.&n;&t; */
id|p-&gt;scsi_id
op_assign
l_int|7
suffix:semicolon
id|p-&gt;extended
op_assign
id|aic7xxx_extended
suffix:semicolon
multiline_comment|/*&n;&t; *  XXX - force data fifo threshold to 100%.  Why does this&n;&t; *&t;  need to be done?&n;&t; */
DECL|macro|DFTHRESH
macro_line|#&t;define&t;DFTHRESH&t;3
id|outb
c_func
(paren
id|DFTHRESH
op_lshift
l_int|6
comma
id|O_DSPCISTATUS
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|p-&gt;scsi_id
op_or
(paren
id|DFTHRESH
op_lshift
l_int|6
)paren
comma
id|HA_SCSICONF
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  A reminder until this can be detected automatically.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;aha294x: extended translation %sabled&bslash;n&quot;
comma
id|p-&gt;extended
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
)brace
r_static
DECL|function|aic7xxx_register
r_int
id|aic7xxx_register
c_func
(paren
id|Scsi_Host_Template
op_star
r_template
comma
r_enum
id|aha_type
id|type
comma
dot
dot
dot
)paren
(brace
id|va_list
id|ap
suffix:semicolon
r_int
id|i
comma
id|base
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
r_struct
id|aic7xxx_host_config
id|config
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|type
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|T_274X
suffix:colon
id|aha274x_config
c_func
(paren
op_amp
id|config
comma
id|ap
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|T_284X
suffix:colon
id|aha284x_config
c_func
(paren
op_amp
id|config
comma
id|ap
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|T_294X
suffix:colon
id|aha294x_config
c_func
(paren
op_amp
id|config
comma
id|ap
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;aic7xxx_register: internal error&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
id|base
op_assign
id|config.base
suffix:semicolon
multiline_comment|/*&n;&t; *  The IRQ level in i/o port 4 maps directly onto the real&n;&t; *  IRQ number.  If it&squot;s ok, register it with the kernel.&n;&t; *&n;&t; *  NB. the Adaptec documentation says the IRQ number is only&n;&t; *&t;in the lower four bits; the ECU information shows the&n;&t; *&t;high bit being used as well.  Which is correct?&n;&t; */
r_if
c_cond
(paren
id|config.irq
template_param
l_int|15
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx uses unsupported IRQ level, ignoring&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Lock out other contenders for our i/o space.&n;&t; */
id|snarf_region
c_func
(paren
id|O_MINREG
c_func
(paren
id|base
)paren
comma
id|O_MAXREG
c_func
(paren
id|base
)paren
op_minus
id|O_MINREG
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Any card-type-specific adjustments before we register&n;&t; *  the scsi host(s).&n;&t; */
r_switch
c_cond
(paren
id|aic7xxx_type
c_func
(paren
id|base
)paren
)paren
(brace
r_case
l_char|&squot;T&squot;
suffix:colon
id|printk
c_func
(paren
l_string|&quot;aic7xxx warning: ignoring channel B of 274x-twin&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot; &squot;
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;aic7xxx is an unsupported type, ignoring&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Before registry, make sure that the offsets of the&n;&t; *  struct scatterlist are what the sequencer will expect,&n;&t; *  otherwise disable scatter-gather altogether until someone&n;&t; *  can fix it.  This is important since the sequencer will&n;&t; *  DMA elements of the SG array in while executing commands.&n;&t; */
r_if
c_cond
(paren
r_template
op_member_access_from_pointer
id|sg_tablesize
op_ne
id|SG_NONE
)paren
(brace
r_struct
id|scatterlist
id|sg
suffix:semicolon
r_if
c_cond
(paren
id|SG_STRUCT_CHECK
c_func
(paren
id|sg
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx warning: kernel scatter-gather &quot;
l_string|&quot;structures changed, disabling it&bslash;n&quot;
)paren
suffix:semicolon
r_template
op_member_access_from_pointer
id|sg_tablesize
op_assign
id|SG_NONE
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *  Register each &quot;host&quot; and fill in the returned Scsi_Host&n;&t; *  structure as best we can.  Some of the parameters aren&squot;t&n;&t; *  really relevant for bus types beyond ISA, and none of the&n;&t; *  high-level SCSI code looks at it anyway.. why are the fields&n;&t; *  there?  Also save the pointer so that we can find the&n;&t; *  information when an IRQ is triggered.&n;&t; */
id|host
op_assign
id|scsi_register
c_func
(paren
r_template
comma
r_sizeof
(paren
r_struct
id|aic7xxx_host
)paren
)paren
suffix:semicolon
id|host-&gt;can_queue
op_assign
id|config.maxscb
suffix:semicolon
id|host-&gt;this_id
op_assign
id|config.scsi_id
suffix:semicolon
id|host-&gt;irq
op_assign
id|config.irq
suffix:semicolon
id|aic7xxx_boards
(braket
id|config.irq
)braket
op_assign
id|host
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AIC7XXX_MAXSCB
suffix:semicolon
id|i
op_increment
)paren
id|p-&gt;SCB_array
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;base
op_assign
id|config.base
suffix:semicolon
id|p-&gt;maxscb
op_assign
id|config.maxscb
suffix:semicolon
id|p-&gt;extended
op_assign
id|config.extended
suffix:semicolon
multiline_comment|/*&n;&t; *  The interrupt trigger is different depending&n;&t; *  on whether the card is EISA or VL-bus - sometimes.&n;&t; *  The startup variable will be cleared once the first&n;&t; *  command is queued, and is checked in the isr to&n;&t; *  try and detect when the interrupt type is set&n;&t; *  incorrectly, triggering an interrupt immediately.&n;&t; *  This is now just set on a per-card-type basis.&n;&t; */
id|p-&gt;unpause
op_assign
id|config.unpause
suffix:semicolon
id|p-&gt;startup
op_assign
op_logical_neg
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Register IRQ with the kernel _after_ the host information&n;&t; *  is set up, in case we take an interrupt right away, due to&n;&t; *  the interrupt type being set wrong.&n;&t; */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|config.irq
comma
id|aic7xxx_isr
comma
id|SA_INTERRUPT
comma
l_string|&quot;aic7xxx&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx couldn&squot;t register irq %d, ignoring&bslash;n&quot;
comma
id|config.irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Print out debugging information before re-enabling&n;&t; *  the card - a lot of registers on it can&squot;t be read&n;&t; *  when the sequencer is active.&n;&t; */
macro_line|#ifdef AIC7XXX_DEBUG
id|debug_config
c_func
(paren
id|type
comma
op_amp
id|config
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Load the sequencer program, then re-enable the board -&n;&t; *  resetting the AIC-7770 disables it, leaving the lights&n;&t; *  on with nobody home.  On the PCI bus you *may* be home,&n;&t; *  but then your mailing address is dynamically assigned&n;&t; *  so no one can find you anyway :-)&n;&t; */
id|aic7xxx_loadram
c_func
(paren
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|T_294X
)paren
id|outb
c_func
(paren
l_int|1
comma
id|O_BCTL
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* ENABLE */
multiline_comment|/*&n;&t; *  Set the host adapter registers to indicate that synchronous&n;&t; *  negotiation should be attempted the first time the targets&n;&t; *  are communicated with.  Also initialize the active message&n;&t; *  flag to indicate that there is no message.&n;&t; */
id|outb
c_func
(paren
l_int|0xff
comma
id|HA_NEEDSDTR
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|HA_MSG_FLAGS
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  For reconnecting targets, the sequencer code needs to&n;&t; *  know how many SCBs it has to search through.&n;&t; */
id|outb
c_func
(paren
id|config.maxscb
comma
id|HA_SCBCOUNT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Unpause the sequencer before returning and enable&n;&t; *  interrupts - we shouldn&squot;t get any until the first&n;&t; *  command is sent to us by the high-level SCSI code.&n;&t; */
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|aic7xxx_detect
r_int
id|aic7xxx_detect
c_func
(paren
id|Scsi_Host_Template
op_star
r_template
)paren
(brace
r_enum
id|aha_type
id|type
suffix:semicolon
r_int
id|found
op_assign
l_int|0
comma
id|slot
comma
id|base
suffix:semicolon
multiline_comment|/*&n;&t; *  EISA/VL-bus card signature probe.&n;&t; */
r_for
c_loop
(paren
id|slot
op_assign
id|MINSLOT
suffix:semicolon
id|slot
op_le
id|MAXSLOT
suffix:semicolon
id|slot
op_increment
)paren
(brace
id|base
op_assign
id|SLOTBASE
c_func
(paren
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|O_MINREG
c_func
(paren
id|base
)paren
comma
id|O_MAXREG
c_func
(paren
id|base
)paren
op_minus
id|O_MINREG
c_func
(paren
id|base
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  Some other driver has staked a&n;&t;&t;&t; *  claim to this i/o region already.&n;&t;&t;&t; */
r_continue
suffix:semicolon
)brace
id|type
op_assign
id|aic7xxx_probe
c_func
(paren
id|slot
comma
id|O_BIDx
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|T_NONE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  We &quot;find&quot; a 274x if we locate the card&n;&t;&t;&t; *  signature and we can set it up and register&n;&t;&t;&t; *  it with the kernel without incident.&n;&t;&t;&t; */
id|found
op_add_assign
id|aic7xxx_register
c_func
(paren
r_template
comma
id|type
comma
id|base
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *  PCI-bus probe.&n;&t; */
r_if
c_cond
(paren
id|pcibios_present
c_func
(paren
)paren
)paren
(brace
r_int
id|index
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|bus
comma
id|device_fn
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|pcibios_find_device
c_func
(paren
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_2940
comma
id|index
comma
op_amp
id|bus
comma
op_amp
id|device_fn
)paren
)paren
(brace
id|found
op_add_assign
id|aic7xxx_register
c_func
(paren
r_template
comma
id|T_294X
comma
id|bus
comma
id|device_fn
)paren
suffix:semicolon
id|index
op_add_assign
l_int|1
suffix:semicolon
)brace
)brace
r_template
op_member_access_from_pointer
id|name
op_assign
(paren
r_char
op_star
)paren
id|aic7xxx_info
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_return
id|found
suffix:semicolon
)brace
DECL|function|aic7xxx_info
r_const
r_char
op_star
id|aic7xxx_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|notused
)paren
(brace
r_return
l_string|&quot;Adaptec AHA274x/284x/294x (EISA/VL-bus/PCI -&gt; Fast SCSI) &quot;
id|AIC7XXX_SEQ_VERSION
l_string|&quot;/&quot;
id|AIC7XXX_H_VERSION
l_string|&quot;/&quot;
l_string|&quot;1.34&quot;
suffix:semicolon
)brace
r_static
DECL|function|aic7xxx_buildscb
r_void
id|aic7xxx_buildscb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
r_void
op_star
id|addr
suffix:semicolon
r_int
id|length
suffix:semicolon
id|memset
c_func
(paren
id|scb
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|scb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  NB. channel selection (bit 3) is always zero.&n;&t; */
id|scb-&gt;target_channel_lun
op_assign
(paren
(paren
id|cmd-&gt;target
op_lshift
l_int|4
)paren
op_amp
l_int|0xf0
)paren
op_or
(paren
id|cmd-&gt;lun
op_amp
l_int|0x7
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  The interpretation of request_buffer and request_bufflen&n;&t; *  changes depending on whether or not use_sg is zero; a&n;&t; *  non-zero use_sg indicates the number of elements in the&n;&t; *  scatter-gather array.&n;&t; *&n;&t; *  The AIC-7770 can&squot;t support transfers of any sort larger&n;&t; *  than 2^24 (three-byte count) without backflips.  For what&n;&t; *  the kernel is doing, this shouldn&squot;t occur.  I hope.&n;&t; */
id|length
op_assign
id|aic7xxx_length
c_func
(paren
id|cmd
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  The sequencer code cannot yet handle scatter-gather segments&n;&t; *  larger than 64k (two-byte length).  The 1.1.x kernels, however,&n;&t; *  have a four-byte length field in the struct scatterlist, so&n;&t; *  make sure we don&squot;t exceed 64k on these kernels for now.&n;&t; */
id|aic7xxx_sg_check
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
l_int|0xffffff
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;aic7xxx_buildscb: can&squot;t transfer &gt; 2^24 - 1 bytes&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  XXX - this relies on the host data being stored in a&n;&t; *&t;  little-endian format.&n;&t; */
id|addr
op_assign
id|cmd-&gt;cmnd
suffix:semicolon
id|scb-&gt;SCSI_cmd_length
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|memcpy
c_func
(paren
id|scb-&gt;SCSI_cmd_pointer
comma
op_amp
id|addr
comma
r_sizeof
(paren
id|scb-&gt;SCSI_cmd_pointer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
macro_line|#if 0
id|debug
c_func
(paren
l_string|&quot;aic7xxx_buildscb: SG used, %d segments, length %u&bslash;n&quot;
comma
id|cmd-&gt;use_sg
comma
id|length
)paren
suffix:semicolon
macro_line|#endif
id|scb-&gt;SG_segment_count
op_assign
id|cmd-&gt;use_sg
suffix:semicolon
id|memcpy
c_func
(paren
id|scb-&gt;SG_list_pointer
comma
op_amp
id|cmd-&gt;request_buffer
comma
r_sizeof
(paren
id|scb-&gt;SG_list_pointer
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|scb-&gt;SG_segment_count
op_assign
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|scb-&gt;data_pointer
comma
op_amp
id|cmd-&gt;request_buffer
comma
r_sizeof
(paren
id|scb-&gt;data_pointer
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|scb-&gt;data_count
comma
op_amp
id|cmd-&gt;request_bufflen
comma
r_sizeof
(paren
id|scb-&gt;data_count
)paren
)paren
suffix:semicolon
)brace
)brace
r_static
DECL|function|aic7xxx_putscb
r_void
id|aic7xxx_putscb
c_func
(paren
r_int
id|base
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
multiline_comment|/*&n;&t; *  By turning on the SCB auto increment, any reference&n;&t; *  to the SCB I/O space postincrements the SCB address&n;&t; *  we&squot;re looking at.  So turn this on and dump the relevant&n;&t; *  portion of the SCB to the card.&n;&t; */
id|outb
c_func
(paren
l_int|0x80
comma
id|O_SCBCNT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/* SCBAUTO */
id|asm
r_volatile
(paren
l_string|&quot;cld&bslash;n&bslash;t&quot;
l_string|&quot;rep&bslash;n&bslash;t&quot;
l_string|&quot;outsb&quot;
suffix:colon
multiline_comment|/* no output */
suffix:colon
l_string|&quot;S&quot;
(paren
id|scb
)paren
comma
l_string|&quot;c&quot;
(paren
r_sizeof
(paren
op_star
id|scb
)paren
)paren
comma
l_string|&quot;d&quot;
(paren
id|O_SCBARRAY
c_func
(paren
id|base
)paren
)paren
suffix:colon
l_string|&quot;si&quot;
comma
l_string|&quot;cx&quot;
comma
l_string|&quot;dx&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|O_SCBCNT
c_func
(paren
id|base
)paren
)paren
suffix:semicolon
)brace
DECL|function|aic7xxx_queue
r_int
id|aic7xxx_queue
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|fn
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
id|flags
suffix:semicolon
r_int
id|empty
comma
id|old_scbptr
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
r_struct
id|aic7xxx_scb
id|scb
suffix:semicolon
macro_line|#if 0
id|debug
c_func
(paren
l_string|&quot;aic7xxx_queue: cmd 0x%x (size %u), target %d, lun %d&bslash;n&quot;
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|cmd-&gt;cmd_len
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
multiline_comment|/*&n;&t; *  Construct the SCB beforehand, so the sequencer is&n;&t; *  paused a minimal amount of time.&n;&t; */
id|aic7xxx_buildscb
c_func
(paren
id|p
comma
id|cmd
comma
op_amp
id|scb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Clear the startup flag - we can now legitimately&n;&t; *  expect interrupts.&n;&t; */
id|p-&gt;startup
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  This is a critical section, since we don&squot;t want the&n;&t; *  interrupt routine mucking with the host data or the&n;&t; *  card.  Since the kernel documentation is vague on&n;&t; *  whether or not we are in a cli/sti pair already, save&n;&t; *  the flags to be on the safe side.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Find a free slot in the SCB array to load this command&n;&t; *  into.  Since can_queue is set to the maximum number of&n;&t; *  SCBs for the card, we should always find one.&n;&t; */
r_for
c_loop
(paren
id|empty
op_assign
l_int|0
suffix:semicolon
id|empty
OL
id|p-&gt;maxscb
suffix:semicolon
id|empty
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;SCB_array
(braket
id|empty
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|empty
op_eq
id|p-&gt;maxscb
)paren
id|panic
c_func
(paren
l_string|&quot;aic7xxx_queue: couldn&squot;t find a free scb&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Pause the sequencer so we can play with its registers -&n;&t; *  wait for it to acknowledge the pause.&n;&t; *&n;&t; *  XXX - should the interrupts be left on while doing this?&n;&t; */
id|PAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Save the SCB pointer and put our own pointer in - this&n;&t; *  selects one of the four banks of SCB registers.  Load&n;&t; *  the SCB, then write its pointer into the queue in FIFO&n;&t; *  and restore the saved SCB pointer.&n;&t; */
id|old_scbptr
op_assign
id|inb
c_func
(paren
id|O_SCBPTR
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|empty
comma
id|O_SCBPTR
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|aic7xxx_putscb
c_func
(paren
id|p-&gt;base
comma
op_amp
id|scb
)paren
suffix:semicolon
id|outb
c_func
(paren
id|empty
comma
id|O_QINFIFO
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|old_scbptr
comma
id|O_SCBPTR
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Make sure the Scsi_Cmnd pointer is saved, the struct it&n;&t; *  points to is set up properly, and the parity error flag&n;&t; *  is reset, then unpause the sequencer and watch the fun&n;&t; *  begin.&n;&t; */
id|cmd-&gt;scsi_done
op_assign
id|fn
suffix:semicolon
id|p-&gt;SCB_array
(braket
id|empty
)braket
op_assign
id|cmd
suffix:semicolon
id|aic7xxx_parity
c_func
(paren
id|cmd
)paren
op_assign
id|DID_OK
suffix:semicolon
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* return values from aic7xxx_kill */
DECL|enum|k_state
r_enum
id|k_state
(brace
DECL|enumerator|k_ok
id|k_ok
comma
multiline_comment|/* scb found and message sent */
DECL|enumerator|k_busy
id|k_busy
comma
multiline_comment|/* message already present */
DECL|enumerator|k_absent
id|k_absent
comma
multiline_comment|/* couldn&squot;t locate scb */
DECL|enumerator|k_disconnect
id|k_disconnect
comma
multiline_comment|/* scb found, but disconnected */
)brace
suffix:semicolon
multiline_comment|/*&n; *  This must be called with interrupts disabled - it&squot;s going to&n; *  be messing around with the host data, and an interrupt being&n; *  fielded in the middle could get ugly.&n; *&n; *  Since so much of the abort and reset code is shared, this&n; *  function performs more magic than it really should.  If the&n; *  command completes ok, then it will call scsi_done with the&n; *  result code passed in.  The unpause parameter controls whether&n; *  or not the sequencer gets unpaused - the reset function, for&n; *  instance, may want to do something more aggressive.&n; *&n; *  Note that the command is checked for in our SCB_array first&n; *  before the sequencer is paused, so if k_absent is returned,&n; *  then the sequencer is NOT paused.&n; */
r_static
DECL|function|aic7xxx_kill
r_enum
id|k_state
id|aic7xxx_kill
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_char
id|message
comma
r_int
r_int
id|result
comma
r_int
id|unpause
)paren
(brace
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
r_int
id|i
comma
id|scb
comma
id|found
comma
id|queued
suffix:semicolon
r_int
r_char
id|scbsave
(braket
id|AIC7XXX_MAXSCB
)braket
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
multiline_comment|/*&n;&t; *  If we can&squot;t find the command, assume it just completed&n;&t; *  and shrug it away.&n;&t; */
r_for
c_loop
(paren
id|scb
op_assign
l_int|0
suffix:semicolon
id|scb
OL
id|p-&gt;maxscb
suffix:semicolon
id|scb
op_increment
)paren
r_if
c_cond
(paren
id|p-&gt;SCB_array
(braket
id|scb
)braket
op_eq
id|cmd
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
id|p-&gt;maxscb
)paren
r_return
id|k_absent
suffix:semicolon
id|PAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  This is the best case, really.  Check to see if the&n;&t; *  command is still in the sequencer&squot;s input queue.  If&n;&t; *  so, simply remove it.  Reload the queue afterward.&n;&t; */
id|queued
op_assign
id|inb
c_func
(paren
id|O_QINCNT
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|found
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|queued
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scbsave
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|O_QINFIFO
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scbsave
(braket
id|i
)braket
op_eq
id|scb
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
id|i
op_sub_assign
l_int|1
suffix:semicolon
)brace
)brace
id|queued
op_sub_assign
id|found
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|queued
suffix:semicolon
id|i
op_increment
)paren
id|outb
c_func
(paren
id|scbsave
(braket
id|i
)braket
comma
id|O_QINFIFO
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found
)paren
r_goto
id|complete
suffix:semicolon
multiline_comment|/*&n;&t; *  Check the current SCB bank.  If it&squot;s not the one belonging&n;&t; *  to the command we want to kill, assume that the command&n;&t; *  is disconnected.  It&squot;s rather a pain to force a reconnect&n;&t; *  and send a message to the target, so we abdicate responsibility&n;&t; *  in this case.&n;&t; */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|O_SCBPTR
c_func
(paren
id|p-&gt;base
)paren
)paren
op_ne
id|scb
)paren
(brace
r_if
c_cond
(paren
id|unpause
)paren
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
id|k_disconnect
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Presumably at this point our target command is active.  Check&n;&t; *  to see if there&squot;s a message already in effect.  If not, place&n;&t; *  our message in and assert ATN so the target goes into MESSAGE&n;&t; *  OUT phase.&n;&t; */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|HA_MSG_FLAGS
c_func
(paren
id|p-&gt;base
)paren
)paren
op_amp
l_int|0x80
)paren
(brace
r_if
c_cond
(paren
id|unpause
)paren
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
id|k_busy
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0x80
comma
id|HA_MSG_FLAGS
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
multiline_comment|/* active message */
id|outb
c_func
(paren
l_int|1
comma
id|HA_MSG_LEN
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
multiline_comment|/* length = 1 */
id|outb
c_func
(paren
id|message
comma
id|HA_MSG_START
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
multiline_comment|/* message body */
multiline_comment|/*&n;&t; *  Assert ATN.  Use the value of SCSISIGO saved by the&n;&t; *  sequencer code so we don&squot;t alter its contents radically&n;&t; *  in the middle of something critical.&n;&t; */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|HA_SIGSTATE
c_func
(paren
id|p-&gt;base
)paren
)paren
op_or
l_int|0x10
comma
id|O_SCSISIGO
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  The command has been killed.  Do the bookkeeping, unpause&n;&t; *  the sequencer, and notify the higher-level SCSI code.&n;&t; */
id|complete
suffix:colon
id|p-&gt;SCB_array
(braket
id|scb
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|unpause
)paren
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|result
op_lshift
l_int|16
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
id|k_ok
suffix:semicolon
)brace
DECL|function|aic7xxx_abort
r_int
id|aic7xxx_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|rv
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|aic7xxx_kill
c_func
(paren
id|cmd
comma
id|ABORT
comma
id|DID_ABORT
comma
op_logical_neg
l_int|0
)paren
)paren
(brace
r_case
id|k_ok
suffix:colon
id|rv
op_assign
id|SCSI_ABORT_SUCCESS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|k_busy
suffix:colon
id|rv
op_assign
id|SCSI_ABORT_BUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|k_absent
suffix:colon
id|rv
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
r_break
suffix:semicolon
r_case
id|k_disconnect
suffix:colon
id|rv
op_assign
id|SCSI_ABORT_SNOOZE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;aic7xxx_do_abort: internal error&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/*&n; *  Resetting the bus always succeeds - is has to, otherwise the&n; *  kernel will panic!  Try a surgical technique - sending a BUS&n; *  DEVICE RESET message - on the offending target before pulling&n; *  the SCSI bus reset line.&n; */
DECL|function|aic7xxx_reset
r_int
id|aic7xxx_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|Scsi_Cmnd
op_star
id|reset
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|aic7xxx_kill
c_func
(paren
id|cmd
comma
id|BUS_DEVICE_RESET
comma
id|DID_RESET
comma
l_int|0
)paren
)paren
(brace
r_case
id|k_ok
suffix:colon
multiline_comment|/*&n;&t;&t; *  The RESET message was sent to the target&n;&t;&t; *  with no problems.  Flag that target as&n;&t;&t; *  needing a SDTR negotiation on the next&n;&t;&t; *  connection and restart the sequencer.&n;&t;&t; */
id|outb
c_func
(paren
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
comma
id|HA_NEEDSDTR
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|k_absent
suffix:colon
multiline_comment|/*&n;&t;&t; *  The sequencer will not be paused if aic7xxx_kill()&n;&t;&t; *  couldn&squot;t find the command.&n;&t;&t; */
id|PAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* falls through */
r_case
id|k_busy
suffix:colon
r_case
id|k_disconnect
suffix:colon
multiline_comment|/*&n;&t;&t; *  Do a hard reset of the SCSI bus.  According to the&n;&t;&t; *  SCSI-2 draft specification, reset has to be asserted&n;&t;&t; *  for at least 25us.  I&squot;m invoking the kernel delay&n;&t;&t; *  function for 30us since I&squot;m not totally trusting of&n;&t;&t; *  the busy loop timing.&n;&t;&t; *&n;&t;&t; *  XXX - I&squot;m not convinced this works.  I tried resetting&n;&t;&t; *&t;  the bus before, trying to get the devices on the&n;&t;&t; *&t;  bus to revert to asynchronous transfer, and it&n;&t;&t; *&t;  never seemed to work.&n;&t;&t; */
id|debug
c_func
(paren
l_string|&quot;aic7xxx: attempting to reset scsi bus and card&bslash;n&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|O_SCSISEQ
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
multiline_comment|/* SCSIRSTO */
id|udelay
c_func
(paren
l_int|30
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|O_SCSISEQ
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
multiline_comment|/* !SCSIRSTO */
id|outb
c_func
(paren
l_int|0xff
comma
id|HA_NEEDSDTR
c_func
(paren
id|p-&gt;base
)paren
)paren
suffix:semicolon
id|UNPAUSE_SEQUENCER
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Locate the command and return a &quot;reset&quot; status&n;&t;&t; *  for it.  This is not completely correct and will&n;&t;&t; *  probably return to haunt me later.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;maxscb
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_eq
id|p-&gt;SCB_array
(braket
id|i
)braket
)paren
(brace
id|reset
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|p-&gt;SCB_array
(braket
id|i
)braket
suffix:semicolon
id|p-&gt;SCB_array
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|reset-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|reset
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|reset
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;aic7xxx_reset: internal error&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_RESET_SUCCESS
suffix:semicolon
)brace
DECL|function|aic7xxx_biosparam
r_int
id|aic7xxx_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
r_int
id|devno
comma
r_int
id|geom
(braket
)braket
)paren
(brace
r_int
id|heads
comma
id|sectors
comma
id|cylinders
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|disk-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
multiline_comment|/*&n;&t; *  XXX - if I could portably find the card&squot;s configuration&n;&t; *&t;  information, then this could be autodetected instead&n;&t; *&t;  of left to a boot-time switch.&n;&t; */
id|heads
op_assign
l_int|64
suffix:semicolon
id|sectors
op_assign
l_int|32
suffix:semicolon
id|cylinders
op_assign
id|disk-&gt;capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;extended
op_logical_and
id|cylinders
OG
l_int|1024
)paren
(brace
id|heads
op_assign
l_int|255
suffix:semicolon
id|sectors
op_assign
l_int|63
suffix:semicolon
id|cylinders
op_assign
id|disk-&gt;capacity
op_div
(paren
l_int|255
op_star
l_int|63
)paren
suffix:semicolon
)brace
id|geom
(braket
l_int|0
)braket
op_assign
id|heads
suffix:semicolon
id|geom
(braket
l_int|1
)braket
op_assign
id|sectors
suffix:semicolon
id|geom
(braket
l_int|2
)braket
op_assign
id|cylinders
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
