multiline_comment|/*+M*************************************************************************&n; * Adaptec AIC7xxx device driver for Linux.&n; *&n; * Copyright (c) 1994 John Aycock&n; *   The University of Calgary Department of Computer Science.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Sources include the Adaptec 1740 driver (aha1740.c), the Ultrastor 24F&n; * driver (ultrastor.c), various Linux kernel source, the Adaptec EISA&n; * config file (!adp7771.cfg), the Adaptec AHA-2740A Series User&squot;s Guide,&n; * the Linux Kernel Hacker&squot;s Guide, Writing a SCSI Device Driver for Linux,&n; * the Adaptec 1542 driver (aha1542.c), the Adaptec EISA overlay file&n; * (adp7770.ovl), the Adaptec AHA-2740 Series Technical Reference Manual,&n; * the Adaptec AIC-7770 Data Book, the ANSI SCSI specification, the&n; * ANSI SCSI-2 specification (draft 10c), ...&n; *&n; * --------------------------------------------------------------------------&n; *&n; *  Modifications by Daniel M. Eischen (deischen@iworks.InterWorks.org):&n; *&n; *  Substantially modified to include support for wide and twin bus&n; *  adapters, DMAing of SCBs, tagged queueing, IRQ sharing, bug fixes,&n; *  SCB paging, and other rework of the code.&n; *&n; *  Parts of this driver were also based on the FreeBSD driver by&n; *  Justin T. Gibbs.  His copyright follows:&n; *&n; * --------------------------------------------------------------------------  &n; * Copyright (c) 1994-1997 Justin Gibbs.&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification, immediately at the beginning of the file.&n; * 2. Redistributions in binary form must reproduce the above copyright&n; *    notice, this list of conditions and the following disclaimer in the&n; *    documentation and/or other materials provided with the distribution.&n; * 3. The name of the author may not be used to endorse or promote products&n; *    derived from this software without specific prior written permission.&n; *&n; * Where this Software is combined with software released under the terms of &n; * the GNU Public License (&quot;GPL&quot;) and the terms of the GPL would require the &n; * combined work to also be released under the terms of the GPL, the terms&n; * and conditions of this License will apply in addition to those of the&n; * GPL with the exception of any terms or conditions of this License that&n; * conflict with, or are expressly prohibited by, the GPL.&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR&n; * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; *&n; *      $Id: aic7xxx.c,v 1.119 1997/06/27 19:39:18 gibbs Exp $&n; *---------------------------------------------------------------------------&n; *&n; *  Thanks also go to (in alphabetical order) the following:&n; *&n; *    Rory Bolt     - Sequencer bug fixes&n; *    Jay Estabrook - Initial DEC Alpha support&n; *    Doug Ledford  - Much needed abort/reset bug fixes&n; *    Kai Makisara  - DMAing of SCBs&n; *&n; *  A Boot time option was also added for not resetting the scsi bus.&n; *&n; *    Form:  aic7xxx=extended&n; *           aic7xxx=no_reset&n; *           aic7xxx=ultra&n; *           aic7xxx=irq_trigger:[0,1]  # 0 edge, 1 level&n; *           aic7xxx=verbose&n; *&n; *  Daniel M. Eischen, deischen@iworks.InterWorks.org, 1/23/97&n; *&n; *  $Id: aic7xxx.c,v 4.1 1997/06/12 08:23:42 deang Exp $&n; *-M*************************************************************************/
multiline_comment|/*+M**************************************************************************&n; *&n; * Further driver modifications made by Doug Ledford &lt;dledford@redhat.com&gt;&n; *&n; * Copyright (c) 1997-1999 Doug Ledford&n; *&n; * These changes are released under the same licensing terms as the FreeBSD&n; * driver written by Justin Gibbs.  Please see his Copyright notice above&n; * for the exact terms and conditions covering my changes as well as the&n; * warranty statement.&n; *&n; * Modifications made to the aic7xxx.c,v 4.1 driver from Dan Eischen include&n; * but are not limited to:&n; *&n; *  1: Import of the latest FreeBSD sequencer code for this driver&n; *  2: Modification of kernel code to accomodate different sequencer semantics&n; *  3: Extensive changes throughout kernel portion of driver to improve&n; *     abort/reset processing and error hanndling&n; *  4: Other work contributed by various people on the Internet&n; *  5: Changes to printk information and verbosity selection code&n; *  6: General reliability related changes, especially in IRQ management&n; *  7: Modifications to the default probe/attach order for supported cards&n; *  8: SMP friendliness has been improved&n; *&n; * Overall, this driver represents a significant departure from the official&n; * aic7xxx driver released by Dan Eischen in two ways.  First, in the code&n; * itself.  A diff between the two version of the driver is now a several&n; * thousand line diff.  Second, in approach to solving the same problem.  The&n; * problem is importing the FreeBSD aic7xxx driver code to linux can be a&n; * difficult and time consuming process, that also can be error prone.  Dan&n; * Eischen&squot;s official driver uses the approach that the linux and FreeBSD&n; * drivers should be as identical as possible.  To that end, his next version&n; * of this driver will be using a mid-layer code library that he is developing&n; * to moderate communications between the linux mid-level SCSI code and the&n; * low level FreeBSD driver.  He intends to be able to essentially drop the&n; * FreeBSD driver into the linux kernel with only a few minor tweaks to some&n; * include files and the like and get things working, making for fast easy&n; * imports of the FreeBSD code into linux.&n; *&n; * I disagree with Dan&squot;s approach.  Not that I don&squot;t think his way of doing&n; * things would be nice, easy to maintain, and create a more uniform driver&n; * between FreeBSD and Linux.  I have no objection to those issues.  My&n; * disagreement is on the needed functionality.  There simply are certain&n; * things that are done differently in FreeBSD than linux that will cause&n; * problems for this driver regardless of any middle ware Dan implements.&n; * The biggest example of this at the moment is interrupt semantics.  Linux&n; * doesn&squot;t provide the same protection techniques as FreeBSD does, nor can&n; * they be easily implemented in any middle ware code since they would truly&n; * belong in the kernel proper and would effect all drivers.  For the time&n; * being, I see issues such as these as major stumbling blocks to the &n; * reliability of code based upon such middle ware.  Therefore, I choose to&n; * use a different approach to importing the FreeBSD code that doesn&squot;t&n; * involve any middle ware type code.  My approach is to import the sequencer&n; * code from FreeBSD wholesale.  Then, to only make changes in the kernel&n; * portion of the driver as they are needed for the new sequencer semantics.&n; * In this way, the portion of the driver that speaks to the rest of the&n; * linux kernel is fairly static and can be changed/modified to solve&n; * any problems one might encounter without concern for the FreeBSD driver.&n; *&n; * Note: If time and experience should prove me wrong that the middle ware&n; * code Dan writes is reliable in its operation, then I&squot;ll retract my above&n; * statements.  But, for those that don&squot;t know, I&squot;m from Missouri (in the US)&n; * and our state motto is &quot;The Show-Me State&quot;.  Well, before I will put&n; * faith into it, you&squot;ll have to show me that it works :)&n; *&n; *_M*************************************************************************/
multiline_comment|/*&n; * The next three defines are user configurable.  These should be the only&n; * defines a user might need to get in here and change.  There are other&n; * defines buried deeper in the code, but those really shouldn&squot;t need touched&n; * under normal conditions.&n; */
multiline_comment|/*&n; * AIC7XXX_STRICT_PCI_SETUP&n; *   Should we assume the PCI config options on our controllers are set with&n; *   sane and proper values, or should we be anal about our PCI config&n; *   registers and force them to what we want?  The main advantage to&n; *   defining this option is on non-Intel hardware where the BIOS may not&n; *   have been run to set things up, or if you have one of the BIOSless&n; *   Adaptec controllers, such as a 2910, that don&squot;t get set up by the&n; *   BIOS.  However, keep in mind that we really do set the most important&n; *   items in the driver regardless of this setting, this only controls some&n; *   of the more esoteric PCI options on these cards.  In that sense, I&n; *   would default to leaving this off.  However, if people wish to try&n; *   things both ways, that would also help me to know if there are some&n; *   machines where it works one way but not another.&n; *&n; *   -- July 7, 17:09&n; *     OK...I need this on my machine for testing, so the default is to&n; *     leave it defined.&n; *&n; *   -- July 7, 18:49&n; *     I needed it for testing, but it didn&squot;t make any difference, so back&n; *     off she goes.&n; *&n; *   -- July 16, 23:04&n; *     I turned it back on to try and compensate for the 2.1.x PCI code&n; *     which no longer relies solely on the BIOS and now tries to set&n; *     things itself.&n; */
DECL|macro|AIC7XXX_STRICT_PCI_SETUP
mdefine_line|#define AIC7XXX_STRICT_PCI_SETUP
multiline_comment|/*&n; * AIC7XXX_VERBOSE_DEBUGGING&n; *   This option enables a lot of extra printk();s in the code, surrounded&n; *   by if (aic7xxx_verbose ...) statements.  Executing all of those if&n; *   statements and the extra checks can get to where it actually does have&n; *   an impact on CPU usage and such, as well as code size.  Disabling this&n; *   define will keep some of those from becoming part of the code.&n; *&n; *   NOTE:  Currently, this option has no real effect, I will be adding the&n; *   various #ifdef&squot;s in the code later when I&squot;ve decided a section is&n; *   complete and no longer needs debugging.  OK...a lot of things are now&n; *   surrounded by this define, so turning this off does have an impact.&n; */
multiline_comment|/*&n; * #define AIC7XXX_VERBOSE_DEBUGGING&n; */
macro_line|#if defined(MODULE) || defined(PCMCIA)
macro_line|#include &lt;linux/module.h&gt;
macro_line|#endif
macro_line|#if defined(PCMCIA)
DECL|macro|MODULE
macro_line|#  undef MODULE
macro_line|#endif
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;aic7xxx.h&quot;
macro_line|#include &quot;aic7xxx/sequencer.h&quot;
macro_line|#include &quot;aic7xxx/scsi_message.h&quot;
macro_line|#include &quot;aic7xxx_reg.h&quot;
macro_line|#include &lt;scsi/scsicam.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;        /* for kmalloc() */
macro_line|#include &lt;linux/config.h&gt;        /* for CONFIG_PCI */
multiline_comment|/*&n; * To generate the correct addresses for the controller to issue&n; * on the bus.  Originally added for DEC Alpha support.&n; */
DECL|macro|VIRT_TO_BUS
mdefine_line|#define VIRT_TO_BUS(a) (unsigned int)virt_to_bus((void *)(a))
DECL|macro|AIC7XXX_C_VERSION
mdefine_line|#define AIC7XXX_C_VERSION  &quot;5.2.1&quot;
DECL|macro|NUMBER
mdefine_line|#define NUMBER(arr)     (sizeof(arr) / sizeof(arr[0]))
DECL|macro|MIN
mdefine_line|#define MIN(a,b)        (((a) &lt; (b)) ? (a) : (b))
DECL|macro|MAX
mdefine_line|#define MAX(a,b)        (((a) &gt; (b)) ? (a) : (b))
DECL|macro|ALL_TARGETS
mdefine_line|#define ALL_TARGETS -1
DECL|macro|ALL_CHANNELS
mdefine_line|#define ALL_CHANNELS -1
DECL|macro|ALL_LUNS
mdefine_line|#define ALL_LUNS -1
DECL|macro|MAX_TARGETS
mdefine_line|#define MAX_TARGETS  16
DECL|macro|MAX_LUNS
mdefine_line|#define MAX_LUNS     8
macro_line|#ifndef TRUE
DECL|macro|TRUE
macro_line|#  define TRUE 1
macro_line|#endif
macro_line|#ifndef FALSE
DECL|macro|FALSE
macro_line|#  define FALSE 0
macro_line|#endif
macro_line|#if defined(__powerpc__) || defined(__i386__)
DECL|macro|MMAPIO
macro_line|#  define MMAPIO
macro_line|#endif
macro_line|#  if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,1,95)
DECL|macro|cpuid
macro_line|#    define cpuid smp_processor_id()
DECL|macro|DRIVER_LOCK_INIT
macro_line|#    define DRIVER_LOCK_INIT &bslash;&n;       spin_lock_init(&amp;p-&gt;spin_lock);
DECL|macro|DRIVER_LOCK
macro_line|#    define DRIVER_LOCK &bslash;&n;       if(!p-&gt;cpu_lock_count[cpuid]) { &bslash;&n;         spin_lock_irqsave(&amp;p-&gt;spin_lock, cpu_flags); &bslash;&n;         p-&gt;cpu_lock_count[cpuid]++; &bslash;&n;       } else { &bslash;&n;         p-&gt;cpu_lock_count[cpuid]++; &bslash;&n;       }
DECL|macro|DRIVER_UNLOCK
macro_line|#    define DRIVER_UNLOCK &bslash;&n;       if(--p-&gt;cpu_lock_count[cpuid] == 0) &bslash;&n;         spin_unlock_irqrestore(&amp;p-&gt;spin_lock, cpu_flags);
macro_line|#  else
DECL|macro|DRIVER_LOCK_INIT
macro_line|#    define DRIVER_LOCK_INIT
DECL|macro|DRIVER_LOCK
macro_line|#    define DRIVER_LOCK
DECL|macro|DRIVER_UNLOCK
macro_line|#    define DRIVER_UNLOCK
macro_line|#  endif
multiline_comment|/*&n; * You can try raising me if tagged queueing is enabled, or lowering&n; * me if you only have 4 SCBs.&n; */
macro_line|#ifdef CONFIG_AIC7XXX_CMDS_PER_DEVICE
DECL|macro|AIC7XXX_CMDS_PER_DEVICE
mdefine_line|#define AIC7XXX_CMDS_PER_DEVICE CONFIG_AIC7XXX_CMDS_PER_DEVICE
macro_line|#else
DECL|macro|AIC7XXX_CMDS_PER_DEVICE
mdefine_line|#define AIC7XXX_CMDS_PER_DEVICE 8
macro_line|#endif
multiline_comment|/*&n; * Control collection of SCSI transfer statistics for the /proc filesystem.&n; *&n; * NOTE: Do NOT enable this when running on kernels version 1.2.x and below.&n; * NOTE: This does affect performance since it has to maintain statistics.&n; */
macro_line|#ifdef CONFIG_AIC7XXX_PROC_STATS
DECL|macro|AIC7XXX_PROC_STATS
mdefine_line|#define AIC7XXX_PROC_STATS
macro_line|#endif
multiline_comment|/*&n; * *** Determining commands per LUN ***&n; * &n; * When AIC7XXX_CMDS_PER_DEVICE is not defined, the driver will use its&n; * own algorithm to determine the commands/LUN.  If SCB paging is&n; * enabled, which is always now, the default is 8 commands per lun&n; * that indicates it supports tagged queueing.  All non-tagged devices&n; * use an internal queue depth of 3, with no more than one of those&n; * three commands active at one time.&n; */
r_typedef
r_struct
(brace
DECL|member|tag_commands
r_int
r_char
id|tag_commands
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Allow for wide/twin adapters. */
DECL|typedef|adapter_tag_info_t
)brace
id|adapter_tag_info_t
suffix:semicolon
multiline_comment|/*&n; * Make a define that will tell the driver not to use tagged queueing&n; * by default.&n; */
macro_line|#ifdef CONFIG_AIC7XXX_TCQ_ON_BY_DEFAULT
DECL|macro|DEFAULT_TAG_COMMANDS
mdefine_line|#define DEFAULT_TAG_COMMANDS {0, 0, 0, 0, 0, 0, 0, 0,&bslash;&n;                              0, 0, 0, 0, 0, 0, 0, 0}
macro_line|#else
DECL|macro|DEFAULT_TAG_COMMANDS
mdefine_line|#define DEFAULT_TAG_COMMANDS {255, 255, 255, 255, 255, 255, 255, 255,&bslash;&n;                              255, 255, 255, 255, 255, 255, 255, 255}
macro_line|#endif
multiline_comment|/*&n; * Modify this as you see fit for your system.  By setting tag_commands&n; * to 0, the driver will use it&squot;s own algorithm for determining the&n; * number of commands to use (see above).  When 255, the driver will&n; * not enable tagged queueing for that particular device.  When positive&n; * (&gt; 0) and (&lt; 255) the values in the array are used for the queue_depth.&n; * Note that the maximum value for an entry is 254, but you&squot;re insane if&n; * you try to use that many commands on one device.&n; *&n; * In this example, the first line will disable tagged queueing for all&n; * the devices on the first probed aic7xxx adapter.&n; *&n; * The second line enables tagged queueing with 4 commands/LUN for IDs&n; * (1, 2-11, 13-15), disables tagged queueing for ID 12, and tells the&n; * driver to use its own algorithm for ID 1.&n; *&n; * The third line is the same as the first line.&n; *&n; * The fourth line disables tagged queueing for devices 0 and 3.  It&n; * enables tagged queueing for the other IDs, with 16 commands/LUN&n; * for IDs 1 and 4, 127 commands/LUN for ID 8, and 4 commands/LUN for&n; * IDs 2, 5-7, and 9-15.&n; */
multiline_comment|/*&n; * NOTE: The below structure is for reference only, the actual structure&n; *       to modify in order to change things is found after this fake one.&n; *&n;adapter_tag_info_t aic7xxx_tag_info[] =&n;{&n;  {DEFAULT_TAG_COMMANDS},&n;  {{4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 255, 4, 4, 4}},&n;  {DEFAULT_TAG_COMMANDS},&n;  {{255, 16, 4, 255, 16, 4, 4, 4, 127, 4, 4, 4, 4, 4, 4, 4}}&n;};&n;*/
DECL|variable|aic7xxx_tag_info
r_static
id|adapter_tag_info_t
id|aic7xxx_tag_info
(braket
)braket
op_assign
(brace
(brace
id|DEFAULT_TAG_COMMANDS
)brace
comma
(brace
id|DEFAULT_TAG_COMMANDS
)brace
comma
(brace
id|DEFAULT_TAG_COMMANDS
)brace
comma
(brace
id|DEFAULT_TAG_COMMANDS
)brace
comma
(brace
id|DEFAULT_TAG_COMMANDS
)brace
comma
(brace
id|DEFAULT_TAG_COMMANDS
)brace
comma
(brace
id|DEFAULT_TAG_COMMANDS
)brace
comma
(brace
id|DEFAULT_TAG_COMMANDS
)brace
comma
(brace
id|DEFAULT_TAG_COMMANDS
)brace
comma
(brace
id|DEFAULT_TAG_COMMANDS
)brace
comma
(brace
id|DEFAULT_TAG_COMMANDS
)brace
comma
(brace
id|DEFAULT_TAG_COMMANDS
)brace
comma
(brace
id|DEFAULT_TAG_COMMANDS
)brace
comma
(brace
id|DEFAULT_TAG_COMMANDS
)brace
comma
(brace
id|DEFAULT_TAG_COMMANDS
)brace
comma
(brace
id|DEFAULT_TAG_COMMANDS
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Define an array of board names that can be indexed by aha_type.&n; * Don&squot;t forget to change this when changing the types!&n; */
DECL|variable|board_names
r_static
r_const
r_char
op_star
id|board_names
(braket
)braket
op_assign
(brace
l_string|&quot;AIC-7xxx Unknown&quot;
comma
multiline_comment|/* AIC_NONE */
l_string|&quot;Adaptec AIC-7810 Hardware RAID Controller&quot;
comma
multiline_comment|/* AIC_7810 */
l_string|&quot;Adaptec AIC-7770 SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7770 */
l_string|&quot;Adaptec AHA-274X SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7771 */
l_string|&quot;Adaptec AHA-284X SCSI host adapter&quot;
comma
multiline_comment|/* AIC_284x */
l_string|&quot;Adaptec AIC-7850 SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7850 */
l_string|&quot;Adaptec AIC-7855 SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7855 */
l_string|&quot;Adaptec AIC-7860 Ultra SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7860 */
l_string|&quot;Adaptec AHA-2940A Ultra SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7861 */
l_string|&quot;Adaptec AIC-7870 SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7870 */
l_string|&quot;Adaptec AHA-294X SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7871 */
l_string|&quot;Adaptec AHA-394X SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7872 */
l_string|&quot;Adaptec AHA-398X SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7873 */
l_string|&quot;Adaptec AHA-2944 SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7874 */
l_string|&quot;Adaptec AIC-7880 Ultra SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7880 */
l_string|&quot;Adaptec AHA-294X Ultra SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7881 */
l_string|&quot;Adaptec AHA-394X Ultra SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7882 */
l_string|&quot;Adaptec AHA-398X Ultra SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7883 */
l_string|&quot;Adaptec AHA-2944 Ultra SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7884 */
l_string|&quot;Adaptec AHA-2940UW Pro Ultra SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7887 */
l_string|&quot;Adaptec AIC-7895 Ultra SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7895 */
l_string|&quot;Adaptec AIC-7890/1 Ultra2 SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7890 */
l_string|&quot;Adaptec AHA-293X Ultra2 SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7890 */
l_string|&quot;Adaptec AHA-294X Ultra2 SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7890 */
l_string|&quot;Adaptec AIC-7896/7 Ultra2 SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7896 */
l_string|&quot;Adaptec AHA-394X Ultra2 SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7897 */
l_string|&quot;Adaptec AHA-395X Ultra2 SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7897 */
l_string|&quot;Adaptec PCMCIA SCSI controller&quot;
comma
multiline_comment|/* card bus stuff */
l_string|&quot;Adaptec AIC-7892 Ultra 160/m SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7892 */
l_string|&quot;Adaptec AIC-7899 Ultra 160/m SCSI host adapter&quot;
comma
multiline_comment|/* AIC_7899 */
)brace
suffix:semicolon
multiline_comment|/*&n; * There should be a specific return value for this in scsi.h, but&n; * it seems that most drivers ignore it.&n; */
DECL|macro|DID_UNDERFLOW
mdefine_line|#define DID_UNDERFLOW   DID_ERROR
multiline_comment|/*&n; *  What we want to do is have the higher level scsi driver requeue&n; *  the command to us. There is no specific driver status for this&n; *  condition, but the higher level scsi driver will requeue the&n; *  command on a DID_BUS_BUSY error.&n; *&n; *  Upon further inspection and testing, it seems that DID_BUS_BUSY&n; *  will *always* retry the command.  We can get into an infinite loop&n; *  if this happens when we really want some sort of counter that&n; *  will automatically abort/reset the command after so many retries.&n; *  Using DID_ERROR will do just that.  (Made by a suggestion by&n; *  Doug Ledford 8/1/96)&n; */
DECL|macro|DID_RETRY_COMMAND
mdefine_line|#define DID_RETRY_COMMAND DID_ERROR
DECL|macro|HSCSIID
mdefine_line|#define HSCSIID        0x07
DECL|macro|SCSI_RESET
mdefine_line|#define SCSI_RESET     0x040
multiline_comment|/*&n; * EISA/VL-bus stuff&n; */
DECL|macro|MINSLOT
mdefine_line|#define MINSLOT                1
DECL|macro|MAXSLOT
mdefine_line|#define MAXSLOT                15
DECL|macro|SLOTBASE
mdefine_line|#define SLOTBASE(x)        ((x) &lt;&lt; 12)
DECL|macro|BASE_TO_SLOT
mdefine_line|#define BASE_TO_SLOT(x) ((x) &gt;&gt; 12)
multiline_comment|/*&n; * Standard EISA Host ID regs  (Offset from slot base)&n; */
DECL|macro|AHC_HID0
mdefine_line|#define AHC_HID0              0x80   /* 0,1: msb of ID2, 2-7: ID1      */
DECL|macro|AHC_HID1
mdefine_line|#define AHC_HID1              0x81   /* 0-4: ID3, 5-7: LSB ID2         */
DECL|macro|AHC_HID2
mdefine_line|#define AHC_HID2              0x82   /* product                        */
DECL|macro|AHC_HID3
mdefine_line|#define AHC_HID3              0x83   /* firmware revision              */
multiline_comment|/*&n; * AIC-7770 I/O range to reserve for a card&n; */
DECL|macro|MINREG
mdefine_line|#define MINREG                0xC00
DECL|macro|MAXREG
mdefine_line|#define MAXREG                0xCFF
DECL|macro|INTDEF
mdefine_line|#define INTDEF                0x5C      /* Interrupt Definition Register */
multiline_comment|/*&n; * AIC-78X0 PCI registers&n; */
DECL|macro|CLASS_PROGIF_REVID
mdefine_line|#define        CLASS_PROGIF_REVID        0x08
DECL|macro|DEVREVID
mdefine_line|#define                DEVREVID        0x000000FFul
DECL|macro|PROGINFC
mdefine_line|#define                PROGINFC        0x0000FF00ul
DECL|macro|SUBCLASS
mdefine_line|#define                SUBCLASS        0x00FF0000ul
DECL|macro|BASECLASS
mdefine_line|#define                BASECLASS        0xFF000000ul
DECL|macro|CSIZE_LATTIME
mdefine_line|#define        CSIZE_LATTIME                0x0C
DECL|macro|CACHESIZE
mdefine_line|#define                CACHESIZE        0x0000003Ful        /* only 5 bits */
DECL|macro|LATTIME
mdefine_line|#define                LATTIME                0x0000FF00ul
DECL|macro|DEVCONFIG
mdefine_line|#define        DEVCONFIG                0x40
DECL|macro|SCBSIZE32
mdefine_line|#define                SCBSIZE32        0x00010000ul        /* aic789X only */
DECL|macro|MPORTMODE
mdefine_line|#define                MPORTMODE        0x00000400ul        /* aic7870 only */
DECL|macro|RAMPSM
mdefine_line|#define                RAMPSM           0x00000200ul        /* aic7870 only */
DECL|macro|RAMPSM_ULTRA2
mdefine_line|#define                RAMPSM_ULTRA2    0x00000004
DECL|macro|VOLSENSE
mdefine_line|#define                VOLSENSE         0x00000100ul
DECL|macro|SCBRAMSEL
mdefine_line|#define                SCBRAMSEL        0x00000080ul
DECL|macro|SCBRAMSEL_ULTRA2
mdefine_line|#define                SCBRAMSEL_ULTRA2 0x00000008
DECL|macro|MRDCEN
mdefine_line|#define                MRDCEN           0x00000040ul
DECL|macro|EXTSCBTIME
mdefine_line|#define                EXTSCBTIME       0x00000020ul        /* aic7870 only */
DECL|macro|EXTSCBPEN
mdefine_line|#define                EXTSCBPEN        0x00000010ul        /* aic7870 only */
DECL|macro|BERREN
mdefine_line|#define                BERREN           0x00000008ul
DECL|macro|DACEN
mdefine_line|#define                DACEN            0x00000004ul
DECL|macro|STPWLEVEL
mdefine_line|#define                STPWLEVEL        0x00000002ul
DECL|macro|DIFACTNEGEN
mdefine_line|#define                DIFACTNEGEN      0x00000001ul        /* aic7870 only */
DECL|macro|SCAMCTL
mdefine_line|#define        SCAMCTL                  0x1a                /* Ultra2 only  */
DECL|macro|CCSCBBADDR
mdefine_line|#define        CCSCBBADDR               0xf0                /* aic7895/6/7  */
multiline_comment|/*&n; * Define the different types of SEEPROMs on aic7xxx adapters&n; * and make it also represent the address size used in accessing&n; * its registers.  The 93C46 chips have 1024 bits organized into&n; * 64 16-bit words, while the 93C56 chips have 2048 bits organized&n; * into 128 16-bit words.  The C46 chips use 6 bits to address&n; * each word, while the C56 and C66 (4096 bits) use 8 bits to&n; * address each word.&n; */
DECL|enumerator|C46
DECL|enumerator|C56_66
DECL|typedef|seeprom_chip_type
r_typedef
r_enum
(brace
id|C46
op_assign
l_int|6
comma
id|C56_66
op_assign
l_int|8
)brace
id|seeprom_chip_type
suffix:semicolon
multiline_comment|/*&n; *&n; * Define the format of the SEEPROM registers (16 bits).&n; *&n; */
DECL|struct|seeprom_config
r_struct
id|seeprom_config
(brace
multiline_comment|/*&n; * SCSI ID Configuration Flags&n; */
DECL|macro|CFXFER
mdefine_line|#define CFXFER                0x0007      /* synchronous transfer rate */
DECL|macro|CFSYNCH
mdefine_line|#define CFSYNCH               0x0008      /* enable synchronous transfer */
DECL|macro|CFDISC
mdefine_line|#define CFDISC                0x0010      /* enable disconnection */
DECL|macro|CFWIDEB
mdefine_line|#define CFWIDEB               0x0020      /* wide bus device (wide card) */
DECL|macro|CFSYNCHISULTRA
mdefine_line|#define CFSYNCHISULTRA        0x0040      /* CFSYNC is an ultra offset */
DECL|macro|CFNEWULTRAFORMAT
mdefine_line|#define CFNEWULTRAFORMAT      0x0080      /* Use the Ultra2 SEEPROM format */
DECL|macro|CFSTART
mdefine_line|#define CFSTART               0x0100      /* send start unit SCSI command */
DECL|macro|CFINCBIOS
mdefine_line|#define CFINCBIOS             0x0200      /* include in BIOS scan */
DECL|macro|CFRNFOUND
mdefine_line|#define CFRNFOUND             0x0400      /* report even if not found */
DECL|macro|CFMULTILUN
mdefine_line|#define CFMULTILUN            0x0800      /* probe mult luns in BIOS scan */
DECL|macro|CFWBCACHEYES
mdefine_line|#define CFWBCACHEYES          0x4000      /* Enable W-Behind Cache on drive */
DECL|macro|CFWBCACHENC
mdefine_line|#define CFWBCACHENC           0xc000      /* Don&squot;t change W-Behind Cache */
multiline_comment|/* UNUSED                0x3000 */
DECL|member|device_flags
r_int
r_int
id|device_flags
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* words 0-15 */
multiline_comment|/*&n; * BIOS Control Bits&n; */
DECL|macro|CFSUPREM
mdefine_line|#define CFSUPREM        0x0001  /* support all removable drives */
DECL|macro|CFSUPREMB
mdefine_line|#define CFSUPREMB       0x0002  /* support removable drives for boot only */
DECL|macro|CFBIOSEN
mdefine_line|#define CFBIOSEN        0x0004  /* BIOS enabled */
multiline_comment|/* UNUSED                0x0008 */
DECL|macro|CFSM2DRV
mdefine_line|#define CFSM2DRV        0x0010  /* support more than two drives */
DECL|macro|CF284XEXTEND
mdefine_line|#define CF284XEXTEND    0x0020  /* extended translation (284x cards) */
multiline_comment|/* UNUSED                0x0040 */
DECL|macro|CFEXTEND
mdefine_line|#define CFEXTEND        0x0080  /* extended translation enabled */
multiline_comment|/* UNUSED                0xFF00 */
DECL|member|bios_control
r_int
r_int
id|bios_control
suffix:semicolon
multiline_comment|/* word 16 */
multiline_comment|/*&n; * Host Adapter Control Bits&n; */
DECL|macro|CFAUTOTERM
mdefine_line|#define CFAUTOTERM      0x0001  /* Perform Auto termination */
DECL|macro|CFULTRAEN
mdefine_line|#define CFULTRAEN       0x0002  /* Ultra SCSI speed enable (Ultra cards) */
DECL|macro|CF284XSELTO
mdefine_line|#define CF284XSELTO     0x0003  /* Selection timeout (284x cards) */
DECL|macro|CF284XFIFO
mdefine_line|#define CF284XFIFO      0x000C  /* FIFO Threshold (284x cards) */
DECL|macro|CFSTERM
mdefine_line|#define CFSTERM         0x0004  /* SCSI low byte termination */
DECL|macro|CFWSTERM
mdefine_line|#define CFWSTERM        0x0008  /* SCSI high byte termination (wide card) */
DECL|macro|CFSPARITY
mdefine_line|#define CFSPARITY       0x0010  /* SCSI parity */
DECL|macro|CF284XSTERM
mdefine_line|#define CF284XSTERM     0x0020  /* SCSI low byte termination (284x cards) */
DECL|macro|CFRESETB
mdefine_line|#define CFRESETB        0x0040  /* reset SCSI bus at boot */
DECL|macro|CFBPRIMARY
mdefine_line|#define CFBPRIMARY      0x0100  /* Channel B primary on 7895 chipsets */
DECL|macro|CFSEAUTOTERM
mdefine_line|#define CFSEAUTOTERM    0x0400  /* aic7890 Perform SE Auto Term */
DECL|macro|CFLVDSTERM
mdefine_line|#define CFLVDSTERM      0x0800  /* aic7890 LVD Termination */
multiline_comment|/* UNUSED                0xF280 */
DECL|member|adapter_control
r_int
r_int
id|adapter_control
suffix:semicolon
multiline_comment|/* word 17 */
multiline_comment|/*&n; * Bus Release, Host Adapter ID&n; */
DECL|macro|CFSCSIID
mdefine_line|#define CFSCSIID        0x000F                /* host adapter SCSI ID */
multiline_comment|/* UNUSED                0x00F0 */
DECL|macro|CFBRTIME
mdefine_line|#define CFBRTIME        0xFF00                /* bus release time */
DECL|member|brtime_id
r_int
r_int
id|brtime_id
suffix:semicolon
multiline_comment|/* word 18 */
multiline_comment|/*&n; * Maximum targets&n; */
DECL|macro|CFMAXTARG
mdefine_line|#define CFMAXTARG        0x00FF        /* maximum targets */
multiline_comment|/* UNUSED                0xFF00 */
DECL|member|max_targets
r_int
r_int
id|max_targets
suffix:semicolon
multiline_comment|/* word 19 */
DECL|member|res_1
r_int
r_int
id|res_1
(braket
l_int|11
)braket
suffix:semicolon
multiline_comment|/* words 20-30 */
DECL|member|checksum
r_int
r_int
id|checksum
suffix:semicolon
multiline_comment|/* word 31 */
)brace
suffix:semicolon
DECL|macro|SELBUS_MASK
mdefine_line|#define SELBUS_MASK                0x0a
DECL|macro|SELNARROW
mdefine_line|#define         SELNARROW        0x00
DECL|macro|SELBUSB
mdefine_line|#define         SELBUSB                0x08
DECL|macro|SINGLE_BUS
mdefine_line|#define SINGLE_BUS                0x00
DECL|macro|SCB_TARGET
mdefine_line|#define SCB_TARGET(scb)         &bslash;&n;       (((scb)-&gt;hscb-&gt;target_channel_lun &amp; TID) &gt;&gt; 4)
DECL|macro|SCB_LUN
mdefine_line|#define SCB_LUN(scb)            &bslash;&n;       ((scb)-&gt;hscb-&gt;target_channel_lun &amp; LID)
DECL|macro|SCB_IS_SCSIBUS_B
mdefine_line|#define SCB_IS_SCSIBUS_B(scb)   &bslash;&n;       (((scb)-&gt;hscb-&gt;target_channel_lun &amp; SELBUSB) != 0)
multiline_comment|/*&n; * If an error occurs during a data transfer phase, run the command&n; * to completion - it&squot;s easier that way - making a note of the error&n; * condition in this location. This then will modify a DID_OK status&n; * into an appropriate error for the higher-level SCSI code.&n; */
DECL|macro|aic7xxx_error
mdefine_line|#define aic7xxx_error(cmd)        ((cmd)-&gt;SCp.Status)
multiline_comment|/*&n; * Keep track of the targets returned status.&n; */
DECL|macro|aic7xxx_status
mdefine_line|#define aic7xxx_status(cmd)        ((cmd)-&gt;SCp.sent_command)
multiline_comment|/*&n; * The position of the SCSI commands scb within the scb array.&n; */
DECL|macro|aic7xxx_position
mdefine_line|#define aic7xxx_position(cmd)        ((cmd)-&gt;SCp.have_data_in)
multiline_comment|/*&n; * The stored DMA mapping for single-buffer data transfers.&n; */
DECL|macro|aic7xxx_mapping
mdefine_line|#define aic7xxx_mapping(cmd)&t;     ((cmd)-&gt;SCp.phase)
multiline_comment|/*&n; * So we can keep track of our host structs&n; */
DECL|variable|first_aic7xxx
r_static
r_struct
id|aic7xxx_host
op_star
id|first_aic7xxx
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * As of Linux 2.1, the mid-level SCSI code uses virtual addresses&n; * in the scatter-gather lists.  We need to convert the virtual&n; * addresses to physical addresses.&n; */
DECL|struct|hw_scatterlist
r_struct
id|hw_scatterlist
(brace
DECL|member|address
r_int
r_int
id|address
suffix:semicolon
DECL|member|length
r_int
r_int
id|length
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Maximum number of SG segments these cards can support.&n; */
DECL|macro|AIC7XXX_MAX_SG
mdefine_line|#define        AIC7XXX_MAX_SG 128
multiline_comment|/*&n; * The maximum number of SCBs we could have for ANY type&n; * of card. DON&squot;T FORGET TO CHANGE THE SCB MASK IN THE&n; * SEQUENCER CODE IF THIS IS MODIFIED!&n; */
DECL|macro|AIC7XXX_MAXSCB
mdefine_line|#define AIC7XXX_MAXSCB        255
DECL|struct|aic7xxx_hwscb
r_struct
id|aic7xxx_hwscb
(brace
multiline_comment|/* ------------    Begin hardware supported fields    ---------------- */
DECL|member|control
multiline_comment|/* 0*/
r_int
r_char
id|control
suffix:semicolon
DECL|member|target_channel_lun
multiline_comment|/* 1*/
r_int
r_char
id|target_channel_lun
suffix:semicolon
multiline_comment|/* 4/1/3 bits */
DECL|member|target_status
multiline_comment|/* 2*/
r_int
r_char
id|target_status
suffix:semicolon
DECL|member|SG_segment_count
multiline_comment|/* 3*/
r_int
r_char
id|SG_segment_count
suffix:semicolon
DECL|member|SG_list_pointer
multiline_comment|/* 4*/
r_int
r_int
id|SG_list_pointer
suffix:semicolon
DECL|member|residual_SG_segment_count
multiline_comment|/* 8*/
r_int
r_char
id|residual_SG_segment_count
suffix:semicolon
DECL|member|residual_data_count
multiline_comment|/* 9*/
r_int
r_char
id|residual_data_count
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|data_pointer
multiline_comment|/*12*/
r_int
r_int
id|data_pointer
suffix:semicolon
DECL|member|data_count
multiline_comment|/*16*/
r_int
r_int
id|data_count
suffix:semicolon
DECL|member|SCSI_cmd_pointer
multiline_comment|/*20*/
r_int
r_int
id|SCSI_cmd_pointer
suffix:semicolon
DECL|member|SCSI_cmd_length
multiline_comment|/*24*/
r_int
r_char
id|SCSI_cmd_length
suffix:semicolon
DECL|member|tag
multiline_comment|/*25*/
r_int
r_char
id|tag
suffix:semicolon
multiline_comment|/* Index into our kernel SCB array.&n;                                     * Also used as the tag for tagged I/O&n;                                     */
DECL|macro|SCB_PIO_TRANSFER_SIZE
mdefine_line|#define SCB_PIO_TRANSFER_SIZE  26   /* amount we need to upload/download&n;                                     * via PIO to initialize a transaction.&n;                                     */
DECL|member|next
multiline_comment|/*26*/
r_int
r_char
id|next
suffix:semicolon
multiline_comment|/* Used to thread SCBs awaiting selection&n;                                     * or disconnected down in the sequencer.&n;                                     */
DECL|member|prev
multiline_comment|/*27*/
r_int
r_char
id|prev
suffix:semicolon
DECL|member|pad
multiline_comment|/*28*/
r_int
r_int
id|pad
suffix:semicolon
multiline_comment|/*&n;                                     * Unused by the kernel, but we require&n;                                     * the padding so that the array of&n;                                     * hardware SCBs is alligned on 32 byte&n;                                     * boundaries so the sequencer can index&n;                                     */
)brace
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|SCB_FREE
id|SCB_FREE
op_assign
l_int|0x0000
comma
DECL|enumerator|SCB_WAITINGQ
id|SCB_WAITINGQ
op_assign
l_int|0x0002
comma
DECL|enumerator|SCB_ACTIVE
id|SCB_ACTIVE
op_assign
l_int|0x0004
comma
DECL|enumerator|SCB_SENSE
id|SCB_SENSE
op_assign
l_int|0x0008
comma
DECL|enumerator|SCB_ABORT
id|SCB_ABORT
op_assign
l_int|0x0010
comma
DECL|enumerator|SCB_DEVICE_RESET
id|SCB_DEVICE_RESET
op_assign
l_int|0x0020
comma
DECL|enumerator|SCB_RESET
id|SCB_RESET
op_assign
l_int|0x0040
comma
DECL|enumerator|SCB_RECOVERY_SCB
id|SCB_RECOVERY_SCB
op_assign
l_int|0x0080
comma
DECL|enumerator|SCB_MSGOUT_PPR
id|SCB_MSGOUT_PPR
op_assign
l_int|0x0100
comma
DECL|enumerator|SCB_MSGOUT_SENT
id|SCB_MSGOUT_SENT
op_assign
l_int|0x0200
comma
DECL|enumerator|SCB_MSGOUT_SDTR
id|SCB_MSGOUT_SDTR
op_assign
l_int|0x0400
comma
DECL|enumerator|SCB_MSGOUT_WDTR
id|SCB_MSGOUT_WDTR
op_assign
l_int|0x0800
comma
DECL|enumerator|SCB_MSGOUT_BITS
id|SCB_MSGOUT_BITS
op_assign
id|SCB_MSGOUT_PPR
op_or
id|SCB_MSGOUT_SENT
op_or
id|SCB_MSGOUT_SDTR
op_or
id|SCB_MSGOUT_WDTR
comma
DECL|enumerator|SCB_QUEUED_ABORT
id|SCB_QUEUED_ABORT
op_assign
l_int|0x1000
comma
DECL|enumerator|SCB_QUEUED_FOR_DONE
id|SCB_QUEUED_FOR_DONE
op_assign
l_int|0x2000
comma
DECL|enumerator|SCB_WAS_BUSY
id|SCB_WAS_BUSY
op_assign
l_int|0x4000
DECL|typedef|scb_flag_type
)brace
id|scb_flag_type
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|AHC_FNONE
id|AHC_FNONE
op_assign
l_int|0x00000000
comma
DECL|enumerator|AHC_PAGESCBS
id|AHC_PAGESCBS
op_assign
l_int|0x00000001
comma
DECL|enumerator|AHC_CHANNEL_B_PRIMARY
id|AHC_CHANNEL_B_PRIMARY
op_assign
l_int|0x00000002
comma
DECL|enumerator|AHC_USEDEFAULTS
id|AHC_USEDEFAULTS
op_assign
l_int|0x00000004
comma
DECL|enumerator|AHC_INDIRECT_PAGING
id|AHC_INDIRECT_PAGING
op_assign
l_int|0x00000008
comma
DECL|enumerator|AHC_CHNLB
id|AHC_CHNLB
op_assign
l_int|0x00000020
comma
DECL|enumerator|AHC_CHNLC
id|AHC_CHNLC
op_assign
l_int|0x00000040
comma
DECL|enumerator|AHC_EXTEND_TRANS_A
id|AHC_EXTEND_TRANS_A
op_assign
l_int|0x00000100
comma
DECL|enumerator|AHC_EXTEND_TRANS_B
id|AHC_EXTEND_TRANS_B
op_assign
l_int|0x00000200
comma
DECL|enumerator|AHC_TERM_ENB_A
id|AHC_TERM_ENB_A
op_assign
l_int|0x00000400
comma
DECL|enumerator|AHC_TERM_ENB_SE_LOW
id|AHC_TERM_ENB_SE_LOW
op_assign
l_int|0x00000400
comma
DECL|enumerator|AHC_TERM_ENB_B
id|AHC_TERM_ENB_B
op_assign
l_int|0x00000800
comma
DECL|enumerator|AHC_TERM_ENB_SE_HIGH
id|AHC_TERM_ENB_SE_HIGH
op_assign
l_int|0x00000800
comma
DECL|enumerator|AHC_HANDLING_REQINITS
id|AHC_HANDLING_REQINITS
op_assign
l_int|0x00001000
comma
DECL|enumerator|AHC_TARGETMODE
id|AHC_TARGETMODE
op_assign
l_int|0x00002000
comma
DECL|enumerator|AHC_NEWEEPROM_FMT
id|AHC_NEWEEPROM_FMT
op_assign
l_int|0x00004000
comma
multiline_comment|/*&n;  *  Here ends the FreeBSD defined flags and here begins the linux defined&n;  *  flags.  NOTE: I did not preserve the old flag name during this change&n;  *  specifically to force me to evaluate what flags were being used properly&n;  *  and what flags weren&squot;t.  This way, I could clean up the flag usage on&n;  *  a use by use basis.  Doug Ledford&n;  */
DECL|enumerator|AHC_MOTHERBOARD
id|AHC_MOTHERBOARD
op_assign
l_int|0x00020000
comma
DECL|enumerator|AHC_NO_STPWEN
id|AHC_NO_STPWEN
op_assign
l_int|0x00040000
comma
DECL|enumerator|AHC_RESET_DELAY
id|AHC_RESET_DELAY
op_assign
l_int|0x00080000
comma
DECL|enumerator|AHC_A_SCANNED
id|AHC_A_SCANNED
op_assign
l_int|0x00100000
comma
DECL|enumerator|AHC_B_SCANNED
id|AHC_B_SCANNED
op_assign
l_int|0x00200000
comma
DECL|enumerator|AHC_MULTI_CHANNEL
id|AHC_MULTI_CHANNEL
op_assign
l_int|0x00400000
comma
DECL|enumerator|AHC_BIOS_ENABLED
id|AHC_BIOS_ENABLED
op_assign
l_int|0x00800000
comma
DECL|enumerator|AHC_SEEPROM_FOUND
id|AHC_SEEPROM_FOUND
op_assign
l_int|0x01000000
comma
DECL|enumerator|AHC_TERM_ENB_LVD
id|AHC_TERM_ENB_LVD
op_assign
l_int|0x02000000
comma
DECL|enumerator|AHC_ABORT_PENDING
id|AHC_ABORT_PENDING
op_assign
l_int|0x04000000
comma
DECL|enumerator|AHC_RESET_PENDING
id|AHC_RESET_PENDING
op_assign
l_int|0x08000000
comma
DECL|macro|AHC_IN_ISR_BIT
mdefine_line|#define AHC_IN_ISR_BIT              28
DECL|enumerator|AHC_IN_ISR
id|AHC_IN_ISR
op_assign
l_int|0x10000000
comma
DECL|enumerator|AHC_IN_ABORT
id|AHC_IN_ABORT
op_assign
l_int|0x20000000
comma
DECL|enumerator|AHC_IN_RESET
id|AHC_IN_RESET
op_assign
l_int|0x40000000
comma
DECL|enumerator|AHC_EXTERNAL_SRAM
id|AHC_EXTERNAL_SRAM
op_assign
l_int|0x80000000
DECL|typedef|ahc_flag_type
)brace
id|ahc_flag_type
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|AHC_NONE
id|AHC_NONE
op_assign
l_int|0x0000
comma
DECL|enumerator|AHC_CHIPID_MASK
id|AHC_CHIPID_MASK
op_assign
l_int|0x00ff
comma
DECL|enumerator|AHC_AIC7770
id|AHC_AIC7770
op_assign
l_int|0x0001
comma
DECL|enumerator|AHC_AIC7850
id|AHC_AIC7850
op_assign
l_int|0x0002
comma
DECL|enumerator|AHC_AIC7860
id|AHC_AIC7860
op_assign
l_int|0x0003
comma
DECL|enumerator|AHC_AIC7870
id|AHC_AIC7870
op_assign
l_int|0x0004
comma
DECL|enumerator|AHC_AIC7880
id|AHC_AIC7880
op_assign
l_int|0x0005
comma
DECL|enumerator|AHC_AIC7890
id|AHC_AIC7890
op_assign
l_int|0x0006
comma
DECL|enumerator|AHC_AIC7895
id|AHC_AIC7895
op_assign
l_int|0x0007
comma
DECL|enumerator|AHC_AIC7896
id|AHC_AIC7896
op_assign
l_int|0x0008
comma
DECL|enumerator|AHC_AIC7892
id|AHC_AIC7892
op_assign
l_int|0x0009
comma
DECL|enumerator|AHC_AIC7899
id|AHC_AIC7899
op_assign
l_int|0x000a
comma
DECL|enumerator|AHC_VL
id|AHC_VL
op_assign
l_int|0x0100
comma
DECL|enumerator|AHC_EISA
id|AHC_EISA
op_assign
l_int|0x0200
comma
DECL|enumerator|AHC_PCI
id|AHC_PCI
op_assign
l_int|0x0400
comma
DECL|typedef|ahc_chip
)brace
id|ahc_chip
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|AHC_FENONE
id|AHC_FENONE
op_assign
l_int|0x0000
comma
DECL|enumerator|AHC_ULTRA
id|AHC_ULTRA
op_assign
l_int|0x0001
comma
DECL|enumerator|AHC_ULTRA2
id|AHC_ULTRA2
op_assign
l_int|0x0002
comma
DECL|enumerator|AHC_WIDE
id|AHC_WIDE
op_assign
l_int|0x0004
comma
DECL|enumerator|AHC_TWIN
id|AHC_TWIN
op_assign
l_int|0x0008
comma
DECL|enumerator|AHC_MORE_SRAM
id|AHC_MORE_SRAM
op_assign
l_int|0x0010
comma
DECL|enumerator|AHC_CMD_CHAN
id|AHC_CMD_CHAN
op_assign
l_int|0x0020
comma
DECL|enumerator|AHC_QUEUE_REGS
id|AHC_QUEUE_REGS
op_assign
l_int|0x0040
comma
DECL|enumerator|AHC_SG_PRELOAD
id|AHC_SG_PRELOAD
op_assign
l_int|0x0080
comma
DECL|enumerator|AHC_SPIOCAP
id|AHC_SPIOCAP
op_assign
l_int|0x0100
comma
DECL|enumerator|AHC_ULTRA3
id|AHC_ULTRA3
op_assign
l_int|0x0200
comma
DECL|enumerator|AHC_NEW_AUTOTERM
id|AHC_NEW_AUTOTERM
op_assign
l_int|0x0400
comma
DECL|enumerator|AHC_AIC7770_FE
id|AHC_AIC7770_FE
op_assign
id|AHC_FENONE
comma
DECL|enumerator|AHC_AIC7850_FE
id|AHC_AIC7850_FE
op_assign
id|AHC_SPIOCAP
comma
DECL|enumerator|AHC_AIC7860_FE
id|AHC_AIC7860_FE
op_assign
id|AHC_ULTRA
op_or
id|AHC_SPIOCAP
comma
DECL|enumerator|AHC_AIC7870_FE
id|AHC_AIC7870_FE
op_assign
id|AHC_FENONE
comma
DECL|enumerator|AHC_AIC7880_FE
id|AHC_AIC7880_FE
op_assign
id|AHC_ULTRA
comma
DECL|enumerator|AHC_AIC7890_FE
id|AHC_AIC7890_FE
op_assign
id|AHC_MORE_SRAM
op_or
id|AHC_CMD_CHAN
op_or
id|AHC_ULTRA2
op_or
id|AHC_QUEUE_REGS
op_or
id|AHC_SG_PRELOAD
op_or
id|AHC_NEW_AUTOTERM
comma
DECL|enumerator|AHC_AIC7895_FE
id|AHC_AIC7895_FE
op_assign
id|AHC_MORE_SRAM
op_or
id|AHC_CMD_CHAN
op_or
id|AHC_ULTRA
comma
DECL|enumerator|AHC_AIC7896_FE
id|AHC_AIC7896_FE
op_assign
id|AHC_AIC7890_FE
comma
DECL|enumerator|AHC_AIC7892_FE
id|AHC_AIC7892_FE
op_assign
id|AHC_AIC7890_FE
op_or
id|AHC_ULTRA3
comma
DECL|enumerator|AHC_AIC7899_FE
id|AHC_AIC7899_FE
op_assign
id|AHC_AIC7890_FE
op_or
id|AHC_ULTRA3
comma
DECL|typedef|ahc_feature
)brace
id|ahc_feature
suffix:semicolon
DECL|macro|SCB_DMA_ADDR
mdefine_line|#define SCB_DMA_ADDR(scb, addr) ((unsigned long)(addr) + (scb)-&gt;scb_dma-&gt;dma_offset)
DECL|struct|aic7xxx_scb_dma
r_struct
id|aic7xxx_scb_dma
(brace
DECL|member|dma_offset
r_int
r_int
id|dma_offset
suffix:semicolon
multiline_comment|/* Correction you have to add&n;&t;&t;&t;&t;&t;       * to virtual address to get&n;&t;&t;&t;&t;&t;       * dma handle in this region */
DECL|member|dma_address
id|dma_addr_t
id|dma_address
suffix:semicolon
multiline_comment|/* DMA handle of the start,&n;&t;&t;&t;&t;&t;       * for unmap */
DECL|member|dma_len
r_int
r_int
id|dma_len
suffix:semicolon
multiline_comment|/* DMA length */
)brace
suffix:semicolon
DECL|struct|aic7xxx_scb
r_struct
id|aic7xxx_scb
(brace
DECL|member|hscb
r_struct
id|aic7xxx_hwscb
op_star
id|hscb
suffix:semicolon
multiline_comment|/* corresponding hardware scb */
DECL|member|cmd
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
multiline_comment|/* Scsi_Cmnd for this scb */
DECL|member|q_next
r_struct
id|aic7xxx_scb
op_star
id|q_next
suffix:semicolon
multiline_comment|/* next scb in queue */
DECL|member|flags
r_volatile
id|scb_flag_type
id|flags
suffix:semicolon
multiline_comment|/* current state of scb */
DECL|member|sg_list
r_struct
id|hw_scatterlist
op_star
id|sg_list
suffix:semicolon
multiline_comment|/* SG list in adapter format */
DECL|member|tag_action
r_int
r_char
id|tag_action
suffix:semicolon
DECL|member|sg_count
r_int
r_char
id|sg_count
suffix:semicolon
DECL|member|sense_cmd
r_int
r_char
op_star
id|sense_cmd
suffix:semicolon
multiline_comment|/*&n;                                               * Allocate 6 characters for&n;                                               * sense command.&n;                                               */
DECL|member|cmnd
r_int
r_char
op_star
id|cmnd
suffix:semicolon
DECL|member|sg_length
r_int
r_int
id|sg_length
suffix:semicolon
multiline_comment|/* We init this during buildscb so we&n;                                           * don&squot;t have to calculate anything&n;                                           * during underflow/overflow/stat code&n;                                           */
DECL|member|kmalloc_ptr
r_void
op_star
id|kmalloc_ptr
suffix:semicolon
DECL|member|scb_dma
r_struct
id|aic7xxx_scb_dma
op_star
id|scb_dma
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Define a linked list of SCBs.&n; */
r_typedef
r_struct
(brace
DECL|member|head
r_struct
id|aic7xxx_scb
op_star
id|head
suffix:semicolon
DECL|member|tail
r_struct
id|aic7xxx_scb
op_star
id|tail
suffix:semicolon
DECL|typedef|scb_queue_type
)brace
id|scb_queue_type
suffix:semicolon
r_static
r_struct
(brace
DECL|member|errno
r_int
r_char
id|errno
suffix:semicolon
DECL|member|errmesg
r_const
r_char
op_star
id|errmesg
suffix:semicolon
DECL|variable|hard_error
)brace
id|hard_error
(braket
)braket
op_assign
(brace
(brace
id|ILLHADDR
comma
l_string|&quot;Illegal Host Access&quot;
)brace
comma
(brace
id|ILLSADDR
comma
l_string|&quot;Illegal Sequencer Address referenced&quot;
)brace
comma
(brace
id|ILLOPCODE
comma
l_string|&quot;Illegal Opcode in sequencer program&quot;
)brace
comma
(brace
id|SQPARERR
comma
l_string|&quot;Sequencer Ram Parity Error&quot;
)brace
comma
(brace
id|DPARERR
comma
l_string|&quot;Data-Path Ram Parity Error&quot;
)brace
comma
(brace
id|MPARERR
comma
l_string|&quot;Scratch Ram/SCB Array Ram Parity Error&quot;
)brace
comma
(brace
id|PCIERRSTAT
comma
l_string|&quot;PCI Error detected&quot;
)brace
comma
(brace
id|CIOPARERR
comma
l_string|&quot;CIOBUS Parity Error&quot;
)brace
)brace
suffix:semicolon
r_static
r_int
r_char
DECL|variable|generic_sense
id|generic_sense
(braket
)braket
op_assign
(brace
id|REQUEST_SENSE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|255
comma
l_int|0
)brace
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|free_scbs
id|scb_queue_type
id|free_scbs
suffix:semicolon
multiline_comment|/*&n;                                    * SCBs assigned to free slot on&n;                                    * card (no paging required)&n;                                    */
DECL|member|scb_array
r_struct
id|aic7xxx_scb
op_star
id|scb_array
(braket
id|AIC7XXX_MAXSCB
)braket
suffix:semicolon
DECL|member|hscbs
r_struct
id|aic7xxx_hwscb
op_star
id|hscbs
suffix:semicolon
DECL|member|numscbs
r_int
r_char
id|numscbs
suffix:semicolon
multiline_comment|/* current number of scbs */
DECL|member|maxhscbs
r_int
r_char
id|maxhscbs
suffix:semicolon
multiline_comment|/* hardware scbs */
DECL|member|maxscbs
r_int
r_char
id|maxscbs
suffix:semicolon
multiline_comment|/* max scbs including pageable scbs */
DECL|member|hscbs_dma
id|dma_addr_t
id|hscbs_dma
suffix:semicolon
multiline_comment|/* DMA handle to hscbs */
DECL|member|hscbs_dma_len
r_int
r_int
id|hscbs_dma_len
suffix:semicolon
multiline_comment|/* length of the above DMA area */
DECL|member|hscb_kmalloc_ptr
r_void
op_star
id|hscb_kmalloc_ptr
suffix:semicolon
DECL|typedef|scb_data_type
)brace
id|scb_data_type
suffix:semicolon
DECL|struct|target_cmd
r_struct
id|target_cmd
(brace
DECL|member|mesg_bytes
r_int
r_char
id|mesg_bytes
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|command
r_int
r_char
id|command
(braket
l_int|28
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|AHC_TRANS_CUR
mdefine_line|#define AHC_TRANS_CUR    0x0001
DECL|macro|AHC_TRANS_ACTIVE
mdefine_line|#define AHC_TRANS_ACTIVE 0x0002
DECL|macro|AHC_TRANS_GOAL
mdefine_line|#define AHC_TRANS_GOAL   0x0004
DECL|macro|AHC_TRANS_USER
mdefine_line|#define AHC_TRANS_USER   0x0008
DECL|macro|AHC_TRANS_QUITE
mdefine_line|#define AHC_TRANS_QUITE  0x0010
r_typedef
r_struct
(brace
DECL|member|cur_width
r_int
r_char
id|cur_width
suffix:semicolon
DECL|member|goal_width
r_int
r_char
id|goal_width
suffix:semicolon
DECL|member|cur_period
r_int
r_char
id|cur_period
suffix:semicolon
DECL|member|goal_period
r_int
r_char
id|goal_period
suffix:semicolon
DECL|member|cur_offset
r_int
r_char
id|cur_offset
suffix:semicolon
DECL|member|goal_offset
r_int
r_char
id|goal_offset
suffix:semicolon
DECL|member|cur_options
r_int
r_char
id|cur_options
suffix:semicolon
DECL|member|goal_options
r_int
r_char
id|goal_options
suffix:semicolon
DECL|member|user_width
r_int
r_char
id|user_width
suffix:semicolon
DECL|member|user_period
r_int
r_char
id|user_period
suffix:semicolon
DECL|member|user_offset
r_int
r_char
id|user_offset
suffix:semicolon
DECL|member|user_options
r_int
r_char
id|user_options
suffix:semicolon
DECL|typedef|transinfo_type
)brace
id|transinfo_type
suffix:semicolon
multiline_comment|/*&n; * Define a structure used for each host adapter.  Note, in order to avoid&n; * problems with architectures I can&squot;t test on (because I don&squot;t have one,&n; * such as the Alpha based systems) which happen to give faults for&n; * non-aligned memory accesses, care was taken to align this structure&n; * in a way that gauranteed all accesses larger than 8 bits were aligned&n; * on the appropriate boundary.  It&squot;s also organized to try and be more&n; * cache line efficient.  Be careful when changing this lest you might hurt&n; * overall performance and bring down the wrath of the masses.&n; */
DECL|struct|aic7xxx_host
r_struct
id|aic7xxx_host
(brace
multiline_comment|/*&n;   *  This is the first 64 bytes in the host struct&n;   */
multiline_comment|/*&n;   * We are grouping things here....first, items that get either read or&n;   * written with nearly every interrupt&n;   */
DECL|member|flags
r_volatile
id|ahc_flag_type
id|flags
suffix:semicolon
DECL|member|features
id|ahc_feature
id|features
suffix:semicolon
multiline_comment|/* chip features */
DECL|member|base
r_int
r_int
id|base
suffix:semicolon
multiline_comment|/* card base address */
DECL|member|maddr
r_volatile
r_int
r_char
op_star
id|maddr
suffix:semicolon
multiline_comment|/* memory mapped address */
DECL|member|isr_count
r_int
r_int
id|isr_count
suffix:semicolon
multiline_comment|/* Interrupt count */
DECL|member|spurious_int
r_int
r_int
id|spurious_int
suffix:semicolon
DECL|member|scb_data
id|scb_data_type
op_star
id|scb_data
suffix:semicolon
DECL|member|needdv
r_volatile
r_int
r_int
id|needdv
suffix:semicolon
DECL|member|needppr
r_volatile
r_int
r_int
id|needppr
suffix:semicolon
DECL|member|needsdtr
r_volatile
r_int
r_int
id|needsdtr
suffix:semicolon
DECL|member|needwdtr
r_volatile
r_int
r_int
id|needwdtr
suffix:semicolon
DECL|member|dtr_pending
r_volatile
r_int
r_int
id|dtr_pending
suffix:semicolon
DECL|struct|aic7xxx_cmd_queue
r_struct
id|aic7xxx_cmd_queue
(brace
DECL|member|head
id|Scsi_Cmnd
op_star
id|head
suffix:semicolon
DECL|member|tail
id|Scsi_Cmnd
op_star
id|tail
suffix:semicolon
DECL|member|completeq
)brace
id|completeq
suffix:semicolon
multiline_comment|/*&n;   * Things read/written on nearly every entry into aic7xxx_queue()&n;   */
DECL|member|waiting_scbs
r_volatile
id|scb_queue_type
id|waiting_scbs
suffix:semicolon
DECL|member|discenable
r_int
r_int
id|discenable
suffix:semicolon
multiline_comment|/* Targets allowed to disconnect */
DECL|member|tagenable
r_int
r_int
id|tagenable
suffix:semicolon
multiline_comment|/* Targets using tagged I/O */
DECL|member|orderedtag
r_int
r_int
id|orderedtag
suffix:semicolon
multiline_comment|/* Ordered Q tags allowed */
DECL|member|unpause
r_int
r_char
id|unpause
suffix:semicolon
multiline_comment|/* unpause value for HCNTRL */
DECL|member|pause
r_int
r_char
id|pause
suffix:semicolon
multiline_comment|/* pause value for HCNTRL */
DECL|member|qoutfifonext
r_volatile
r_int
r_char
id|qoutfifonext
suffix:semicolon
DECL|member|activescbs
r_volatile
r_int
r_char
id|activescbs
suffix:semicolon
multiline_comment|/* active scbs */
DECL|member|max_activescbs
r_volatile
r_int
r_char
id|max_activescbs
suffix:semicolon
DECL|member|qinfifonext
r_volatile
r_int
r_char
id|qinfifonext
suffix:semicolon
DECL|member|untagged_scbs
r_volatile
r_int
r_char
op_star
id|untagged_scbs
suffix:semicolon
DECL|member|qoutfifo
r_volatile
r_int
r_char
op_star
id|qoutfifo
suffix:semicolon
DECL|member|qinfifo
r_volatile
r_int
r_char
op_star
id|qinfifo
suffix:semicolon
DECL|macro|DEVICE_PRESENT
mdefine_line|#define  DEVICE_PRESENT                 0x01
DECL|macro|BUS_DEVICE_RESET_PENDING
mdefine_line|#define  BUS_DEVICE_RESET_PENDING       0x02
DECL|macro|DEVICE_RESET_DELAY
mdefine_line|#define  DEVICE_RESET_DELAY             0x04
DECL|macro|DEVICE_PRINT_DTR
mdefine_line|#define  DEVICE_PRINT_DTR               0x08
DECL|macro|DEVICE_PARITY_ERROR
mdefine_line|#define  DEVICE_PARITY_ERROR            0x10
DECL|macro|DEVICE_WAS_BUSY
mdefine_line|#define  DEVICE_WAS_BUSY                0x20
DECL|macro|DEVICE_SCSI_3
mdefine_line|#define  DEVICE_SCSI_3                  0x40
DECL|macro|DEVICE_SCANNED
mdefine_line|#define  DEVICE_SCANNED                 0x80
DECL|member|dev_flags
r_volatile
r_int
r_char
id|dev_flags
(braket
id|MAX_TARGETS
)braket
suffix:semicolon
DECL|member|dev_active_cmds
r_volatile
r_int
r_char
id|dev_active_cmds
(braket
id|MAX_TARGETS
)braket
suffix:semicolon
DECL|member|dev_temp_queue_depth
r_volatile
r_int
r_char
id|dev_temp_queue_depth
(braket
id|MAX_TARGETS
)braket
suffix:semicolon
DECL|member|dev_commands_sent
r_int
r_char
id|dev_commands_sent
(braket
id|MAX_TARGETS
)braket
suffix:semicolon
DECL|member|dev_timer_active
r_int
r_int
id|dev_timer_active
suffix:semicolon
multiline_comment|/* Which devs have a timer set */
DECL|member|dev_timer
r_struct
id|timer_list
id|dev_timer
suffix:semicolon
DECL|member|dev_expires
r_int
r_int
id|dev_expires
(braket
id|MAX_TARGETS
)braket
suffix:semicolon
DECL|member|spin_lock
id|spinlock_t
id|spin_lock
suffix:semicolon
DECL|member|cpu_lock_count
r_volatile
r_int
r_char
id|cpu_lock_count
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|member|dev_dtr_cmnd
id|Scsi_Cmnd
op_star
id|dev_dtr_cmnd
(braket
id|MAX_TARGETS
)braket
suffix:semicolon
DECL|member|dev_checksum
r_int
r_int
id|dev_checksum
(braket
id|MAX_TARGETS
)braket
suffix:semicolon
DECL|member|dev_last_queue_full
r_int
r_char
id|dev_last_queue_full
(braket
id|MAX_TARGETS
)braket
suffix:semicolon
DECL|member|dev_last_queue_full_count
r_int
r_char
id|dev_last_queue_full_count
(braket
id|MAX_TARGETS
)braket
suffix:semicolon
DECL|member|dev_max_queue_depth
r_int
r_char
id|dev_max_queue_depth
(braket
id|MAX_TARGETS
)braket
suffix:semicolon
DECL|member|delayed_scbs
r_volatile
id|scb_queue_type
id|delayed_scbs
(braket
id|MAX_TARGETS
)braket
suffix:semicolon
DECL|member|msg_buf
r_int
r_char
id|msg_buf
(braket
l_int|13
)braket
suffix:semicolon
multiline_comment|/* The message for the target */
DECL|member|msg_type
r_int
r_char
id|msg_type
suffix:semicolon
DECL|macro|MSG_TYPE_NONE
mdefine_line|#define MSG_TYPE_NONE              0x00
DECL|macro|MSG_TYPE_INITIATOR_MSGOUT
mdefine_line|#define MSG_TYPE_INITIATOR_MSGOUT  0x01
DECL|macro|MSG_TYPE_INITIATOR_MSGIN
mdefine_line|#define MSG_TYPE_INITIATOR_MSGIN   0x02
DECL|member|msg_len
r_int
r_char
id|msg_len
suffix:semicolon
multiline_comment|/* Length of message */
DECL|member|msg_index
r_int
r_char
id|msg_index
suffix:semicolon
multiline_comment|/* Index into msg_buf array */
DECL|member|transinfo
id|transinfo_type
id|transinfo
(braket
id|MAX_TARGETS
)braket
suffix:semicolon
multiline_comment|/*&n;   * We put the less frequently used host structure items after the more&n;   * frequently used items to try and ease the burden on the cache subsystem.&n;   * These entries are not *commonly* accessed, whereas the preceding entries&n;   * are accessed very often.&n;   */
DECL|member|irq
r_int
r_int
id|irq
suffix:semicolon
multiline_comment|/* IRQ for this adapter */
DECL|member|instance
r_int
id|instance
suffix:semicolon
multiline_comment|/* aic7xxx instance number */
DECL|member|scsi_id
r_int
id|scsi_id
suffix:semicolon
multiline_comment|/* host adapter SCSI ID */
DECL|member|scsi_id_b
r_int
id|scsi_id_b
suffix:semicolon
multiline_comment|/* channel B for twin adapters */
DECL|member|bios_address
r_int
r_int
id|bios_address
suffix:semicolon
DECL|member|board_name_index
r_int
id|board_name_index
suffix:semicolon
DECL|member|needppr_copy
r_int
r_int
id|needppr_copy
suffix:semicolon
multiline_comment|/* default config */
DECL|member|needsdtr_copy
r_int
r_int
id|needsdtr_copy
suffix:semicolon
multiline_comment|/* default config */
DECL|member|needwdtr_copy
r_int
r_int
id|needwdtr_copy
suffix:semicolon
multiline_comment|/* default config */
DECL|member|ultraenb
r_int
r_int
id|ultraenb
suffix:semicolon
multiline_comment|/* Ultra mode target list */
DECL|member|bios_control
r_int
r_int
id|bios_control
suffix:semicolon
multiline_comment|/* bios control - SEEPROM */
DECL|member|adapter_control
r_int
r_int
id|adapter_control
suffix:semicolon
multiline_comment|/* adapter control - SEEPROM */
DECL|member|pdev
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
DECL|member|pci_bus
r_int
r_char
id|pci_bus
suffix:semicolon
DECL|member|pci_device_fn
r_int
r_char
id|pci_device_fn
suffix:semicolon
DECL|member|sc
r_struct
id|seeprom_config
id|sc
suffix:semicolon
DECL|member|sc_type
r_int
r_int
id|sc_type
suffix:semicolon
DECL|member|sc_size
r_int
r_int
id|sc_size
suffix:semicolon
DECL|member|next
r_struct
id|aic7xxx_host
op_star
id|next
suffix:semicolon
multiline_comment|/* allow for multiple IRQs */
DECL|member|host
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
multiline_comment|/* pointer to scsi host */
DECL|member|host_no
r_int
id|host_no
suffix:semicolon
multiline_comment|/* SCSI host number */
DECL|member|mbase
r_int
r_int
id|mbase
suffix:semicolon
multiline_comment|/* I/O memory address */
DECL|member|chip
id|ahc_chip
id|chip
suffix:semicolon
multiline_comment|/* chip type */
DECL|member|fifo_dma
id|dma_addr_t
id|fifo_dma
suffix:semicolon
multiline_comment|/* DMA handle for fifo arrays */
multiline_comment|/*&n;   * Statistics Kept:&n;   *&n;   * Total Xfers (count for each command that has a data xfer),&n;   * broken down further by reads &amp;&amp; writes.&n;   *&n;   * Binned sizes, writes &amp;&amp; reads:&n;   *    &lt; 512, 512, 1-2K, 2-4K, 4-8K, 8-16K, 16-32K, 32-64K, 64K-128K, &gt; 128K&n;   *&n;   * Total amounts read/written above 512 bytes (amts under ignored)&n;   *&n;   * NOTE: Enabling this feature is likely to cause a noticeable performance&n;   * decrease as the accesses into the stats structures blows apart multiple&n;   * cache lines and is CPU time consuming.&n;   *&n;   * NOTE: Since it doesn&squot;t really buy us much, but consumes *tons* of RAM&n;   * and blows apart all sorts of cache lines, I modified this so that we&n;   * no longer look at the LUN.  All LUNs now go into the same bin on each&n;   * device for stats purposes.&n;   */
DECL|struct|aic7xxx_xferstats
r_struct
id|aic7xxx_xferstats
(brace
DECL|member|w_total
r_int
id|w_total
suffix:semicolon
multiline_comment|/* total writes */
DECL|member|r_total
r_int
id|r_total
suffix:semicolon
multiline_comment|/* total reads */
macro_line|#ifdef AIC7XXX_PROC_STATS
DECL|member|w_bins
r_int
id|w_bins
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* binned write */
DECL|member|r_bins
r_int
id|r_bins
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* binned reads */
macro_line|#endif /* AIC7XXX_PROC_STATS */
DECL|member|stats
)brace
id|stats
(braket
id|MAX_TARGETS
)braket
suffix:semicolon
multiline_comment|/* [(channel &lt;&lt; 3)|target] */
macro_line|#if 0
r_struct
id|target_cmd
op_star
id|targetcmds
suffix:semicolon
r_int
r_int
id|num_targetcmds
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/*&n; * Valid SCSIRATE values. (p. 3-17)&n; * Provides a mapping of transfer periods in ns/4 to the proper value to&n; * stick in the SCSIRATE reg to use that transfer rate.&n; */
DECL|macro|AHC_SYNCRATE_ULTRA3
mdefine_line|#define AHC_SYNCRATE_ULTRA3 0
DECL|macro|AHC_SYNCRATE_ULTRA2
mdefine_line|#define AHC_SYNCRATE_ULTRA2 1
DECL|macro|AHC_SYNCRATE_ULTRA
mdefine_line|#define AHC_SYNCRATE_ULTRA  3
DECL|macro|AHC_SYNCRATE_FAST
mdefine_line|#define AHC_SYNCRATE_FAST   6
DECL|macro|AHC_SYNCRATE_CRC
mdefine_line|#define AHC_SYNCRATE_CRC 0x40
DECL|macro|AHC_SYNCRATE_SE
mdefine_line|#define AHC_SYNCRATE_SE  0x10
DECL|struct|aic7xxx_syncrate
r_static
r_struct
id|aic7xxx_syncrate
(brace
multiline_comment|/* Rates in Ultra mode have bit 8 of sxfr set */
DECL|macro|ULTRA_SXFR
mdefine_line|#define                ULTRA_SXFR 0x100
DECL|member|sxfr_ultra2
r_int
id|sxfr_ultra2
suffix:semicolon
DECL|member|sxfr
r_int
id|sxfr
suffix:semicolon
DECL|member|period
r_int
r_char
id|period
suffix:semicolon
DECL|member|rate
r_const
r_char
op_star
id|rate
(braket
l_int|2
)braket
suffix:semicolon
DECL|variable|aic7xxx_syncrates
)brace
id|aic7xxx_syncrates
(braket
)braket
op_assign
(brace
(brace
l_int|0x42
comma
l_int|0x000
comma
l_int|9
comma
(brace
l_string|&quot;80.0&quot;
comma
l_string|&quot;160.0&quot;
)brace
)brace
comma
(brace
l_int|0x13
comma
l_int|0x000
comma
l_int|10
comma
(brace
l_string|&quot;40.0&quot;
comma
l_string|&quot;80.0&quot;
)brace
)brace
comma
(brace
l_int|0x14
comma
l_int|0x000
comma
l_int|11
comma
(brace
l_string|&quot;33.0&quot;
comma
l_string|&quot;66.6&quot;
)brace
)brace
comma
(brace
l_int|0x15
comma
l_int|0x100
comma
l_int|12
comma
(brace
l_string|&quot;20.0&quot;
comma
l_string|&quot;40.0&quot;
)brace
)brace
comma
(brace
l_int|0x16
comma
l_int|0x110
comma
l_int|15
comma
(brace
l_string|&quot;16.0&quot;
comma
l_string|&quot;32.0&quot;
)brace
)brace
comma
(brace
l_int|0x17
comma
l_int|0x120
comma
l_int|18
comma
(brace
l_string|&quot;13.4&quot;
comma
l_string|&quot;26.8&quot;
)brace
)brace
comma
(brace
l_int|0x18
comma
l_int|0x000
comma
l_int|25
comma
(brace
l_string|&quot;10.0&quot;
comma
l_string|&quot;20.0&quot;
)brace
)brace
comma
(brace
l_int|0x19
comma
l_int|0x010
comma
l_int|31
comma
(brace
l_string|&quot;8.0&quot;
comma
l_string|&quot;16.0&quot;
)brace
)brace
comma
(brace
l_int|0x1a
comma
l_int|0x020
comma
l_int|37
comma
(brace
l_string|&quot;6.67&quot;
comma
l_string|&quot;13.3&quot;
)brace
)brace
comma
(brace
l_int|0x1b
comma
l_int|0x030
comma
l_int|43
comma
(brace
l_string|&quot;5.7&quot;
comma
l_string|&quot;11.4&quot;
)brace
)brace
comma
(brace
l_int|0x10
comma
l_int|0x040
comma
l_int|50
comma
(brace
l_string|&quot;5.0&quot;
comma
l_string|&quot;10.0&quot;
)brace
)brace
comma
(brace
l_int|0x00
comma
l_int|0x050
comma
l_int|56
comma
(brace
l_string|&quot;4.4&quot;
comma
l_string|&quot;8.8&quot;
)brace
)brace
comma
(brace
l_int|0x00
comma
l_int|0x060
comma
l_int|62
comma
(brace
l_string|&quot;4.0&quot;
comma
l_string|&quot;8.0&quot;
)brace
)brace
comma
(brace
l_int|0x00
comma
l_int|0x070
comma
l_int|68
comma
(brace
l_string|&quot;3.6&quot;
comma
l_string|&quot;7.2&quot;
)brace
)brace
comma
(brace
l_int|0x00
comma
l_int|0x000
comma
l_int|0
comma
(brace
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
)brace
suffix:semicolon
DECL|macro|CTL_OF_SCB
mdefine_line|#define CTL_OF_SCB(scb) (((scb-&gt;hscb)-&gt;target_channel_lun &gt;&gt; 3) &amp; 0x1),  &bslash;&n;                        (((scb-&gt;hscb)-&gt;target_channel_lun &gt;&gt; 4) &amp; 0xf), &bslash;&n;                        ((scb-&gt;hscb)-&gt;target_channel_lun &amp; 0x07)
DECL|macro|CTL_OF_CMD
mdefine_line|#define CTL_OF_CMD(cmd) ((cmd-&gt;channel) &amp; 0x01),  &bslash;&n;                        ((cmd-&gt;target) &amp; 0x0f), &bslash;&n;                        ((cmd-&gt;lun) &amp; 0x07)
DECL|macro|TARGET_INDEX
mdefine_line|#define TARGET_INDEX(cmd)  ((cmd)-&gt;target | ((cmd)-&gt;channel &lt;&lt; 3))
multiline_comment|/*&n; * A nice little define to make doing our printks a little easier&n; */
DECL|macro|WARN_LEAD
mdefine_line|#define WARN_LEAD KERN_WARNING &quot;(scsi%d:%d:%d:%d) &quot;
DECL|macro|INFO_LEAD
mdefine_line|#define INFO_LEAD KERN_INFO &quot;(scsi%d:%d:%d:%d) &quot;
multiline_comment|/*&n; * XXX - these options apply unilaterally to _all_ 274x/284x/294x&n; *       cards in the system.  This should be fixed.  Exceptions to this&n; *       rule are noted in the comments.&n; */
multiline_comment|/*&n; * Skip the scsi bus reset.  Non 0 make us skip the reset at startup.  This&n; * has no effect on any later resets that might occur due to things like&n; * SCSI bus timeouts.&n; */
DECL|variable|aic7xxx_no_reset
r_static
r_int
r_int
id|aic7xxx_no_reset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Certain PCI motherboards will scan PCI devices from highest to lowest,&n; * others scan from lowest to highest, and they tend to do all kinds of&n; * strange things when they come into contact with PCI bridge chips.  The&n; * net result of all this is that the PCI card that is actually used to boot&n; * the machine is very hard to detect.  Most motherboards go from lowest&n; * PCI slot number to highest, and the first SCSI controller found is the&n; * one you boot from.  The only exceptions to this are when a controller&n; * has its BIOS disabled.  So, we by default sort all of our SCSI controllers&n; * from lowest PCI slot number to highest PCI slot number.  We also force&n; * all controllers with their BIOS disabled to the end of the list.  This&n; * works on *almost* all computers.  Where it doesn&squot;t work, we have this&n; * option.  Setting this option to non-0 will reverse the order of the sort&n; * to highest first, then lowest, but will still leave cards with their BIOS&n; * disabled at the very end.  That should fix everyone up unless there are&n; * really strange cirumstances.&n; */
DECL|variable|aic7xxx_reverse_scan
r_static
r_int
id|aic7xxx_reverse_scan
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Should we force EXTENDED translation on a controller.&n; *     0 == Use whatever is in the SEEPROM or default to off&n; *     1 == Use whatever is in the SEEPROM or default to on&n; */
DECL|variable|aic7xxx_extended
r_static
r_int
r_int
id|aic7xxx_extended
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * The IRQ trigger method used on EISA controllers. Does not effect PCI cards.&n; *   -1 = Use detected settings.&n; *    0 = Force Edge triggered mode.&n; *    1 = Force Level triggered mode.&n; */
DECL|variable|aic7xxx_irq_trigger
r_static
r_int
id|aic7xxx_irq_trigger
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n; * This variable is used to override the termination settings on a controller.&n; * This should not be used under normal conditions.  However, in the case&n; * that a controller does not have a readable SEEPROM (so that we can&squot;t&n; * read the SEEPROM settings directly) and that a controller has a buggered&n; * version of the cable detection logic, this can be used to force the &n; * correct termination.  It is preferable to use the manual termination&n; * settings in the BIOS if possible, but some motherboard controllers store&n; * those settings in a format we can&squot;t read.  In other cases, auto term&n; * should also work, but the chipset was put together with no auto term&n; * logic (common on motherboard controllers).  In those cases, we have&n; * 32 bits here to work with.  That&squot;s good for 8 controllers/channels.  The&n; * bits are organized as 4 bits per channel, with scsi0 getting the lowest&n; * 4 bits in the int.  A 1 in a bit position indicates the termination setting&n; * that corresponds to that bit should be enabled, a 0 is disabled.&n; * It looks something like this:&n; *&n; *    0x0f =  1111-Single Ended Low Byte Termination on/off&n; *            ||&bslash;-Single Ended High Byte Termination on/off&n; *            |&bslash;-LVD Low Byte Termination on/off&n; *            &bslash;-LVD High Byte Termination on/off&n; *&n; * For non-Ultra2 controllers, the upper 2 bits are not important.  So, to&n; * enable both high byte and low byte termination on scsi0, I would need to&n; * make sure that the override_term variable was set to 0x03 (bits 0011).&n; * To make sure that all termination is enabled on an Ultra2 controller at&n; * scsi2 and only high byte termination on scsi1 and high and low byte&n; * termination on scsi0, I would set override_term=0xf23 (bits 1111 0010 0011)&n; *&n; * For the most part, users should never have to use this, that&squot;s why I&n; * left it fairly cryptic instead of easy to understand.  If you need it,&n; * most likely someone will be telling you what your&squot;s needs to be set to.&n; */
DECL|variable|aic7xxx_override_term
r_static
r_int
id|aic7xxx_override_term
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Certain motherboard chipset controllers tend to screw&n; * up the polarity of the term enable output pin.  Use this variable&n; * to force the correct polarity for your system.  This is a bitfield variable&n; * similar to the previous one, but this one has one bit per channel instead&n; * of four.&n; *    0 = Force the setting to active low.&n; *    1 = Force setting to active high.&n; * Most Adaptec cards are active high, several motherboards are active low.&n; * To force a 2940 card at SCSI 0 to active high and a motherboard 7895&n; * controller at scsi1 and scsi2 to active low, and a 2910 card at scsi3&n; * to active high, you would need to set stpwlev=0x9 (bits 1001).&n; *&n; * People shouldn&squot;t need to use this, but if you are experiencing lots of&n; * SCSI timeout problems, this may help.  There is one sure way to test what&n; * this option needs to be.  Using a boot floppy to boot the system, configure&n; * your system to enable all SCSI termination (in the Adaptec SCSI BIOS) and&n; * if needed then also pass a value to override_term to make sure that the&n; * driver is enabling SCSI termination, then set this variable to either 0&n; * or 1.  When the driver boots, make sure there are *NO* SCSI cables&n; * connected to your controller.  If it finds and inits the controller&n; * without problem, then the setting you passed to stpwlev was correct.  If&n; * the driver goes into a reset loop and hangs the system, then you need the&n; * other setting for this variable.  If neither setting lets the machine&n; * boot then you have definite termination problems that may not be fixable.&n; */
DECL|variable|aic7xxx_stpwlev
r_static
r_int
id|aic7xxx_stpwlev
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Set this to non-0 in order to force the driver to panic the kernel&n; * and print out debugging info on a SCSI abort or reset cycle.&n; */
DECL|variable|aic7xxx_panic_on_abort
r_static
r_int
id|aic7xxx_panic_on_abort
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * PCI bus parity checking of the Adaptec controllers.  This is somewhat&n; * dubious at best.  To my knowledge, this option has never actually&n; * solved a PCI parity problem, but on certain machines with broken PCI&n; * chipset configurations, it can generate tons of false error messages.&n; * It&squot;s included in the driver for completeness.&n; *   0 = Shut off PCI parity check&n; *  -1 = Normal polarity pci parity checking&n; *   1 = reverse polarity pci parity checking&n; *&n; * NOTE: you can&squot;t actually pass -1 on the lilo prompt.  So, to set this&n; * variable to -1 you would actually want to simply pass the variable&n; * name without a number.  That will invert the 0 which will result in&n; * -1.&n; */
DECL|variable|aic7xxx_pci_parity
r_static
r_int
id|aic7xxx_pci_parity
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Set this to any non-0 value to cause us to dump the contents of all&n; * the card&squot;s registers in a hex dump format tailored to each model of&n; * controller.&n; * &n; * NOTE: THE CONTROLLER IS LEFT IN AN UNUSEABLE STATE BY THIS OPTION.&n; *       YOU CANNOT BOOT UP WITH THIS OPTION, IT IS FOR DEBUGGING PURPOSES&n; *       ONLY&n; */
DECL|variable|aic7xxx_dump_card
r_static
r_int
id|aic7xxx_dump_card
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Set this to a non-0 value to make us dump out the 32 bit instruction&n; * registers on the card after completing the sequencer download.  This&n; * allows the actual sequencer download to be verified.  It is possible&n; * to use this option and still boot up and run your system.  This is&n; * only intended for debugging purposes.&n; */
DECL|variable|aic7xxx_dump_sequencer
r_static
r_int
id|aic7xxx_dump_sequencer
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Certain newer motherboards have put new PCI based devices into the&n; * IO spaces that used to typically be occupied by VLB or EISA cards.&n; * This overlap can cause these newer motherboards to lock up when scanned&n; * for older EISA and VLB devices.  Setting this option to non-0 will&n; * cause the driver to skip scanning for any VLB or EISA controllers and&n; * only support the PCI controllers.  NOTE: this means that if the kernel&n; * os compiled with PCI support disabled, then setting this to non-0&n; * would result in never finding any devices :)&n; */
DECL|variable|aic7xxx_no_probe
r_static
r_int
id|aic7xxx_no_probe
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * On some machines, enabling the external SCB RAM isn&squot;t reliable yet.  I&n; * haven&squot;t had time to make test patches for things like changing the&n; * timing mode on that external RAM either.  Some of those changes may&n; * fix the problem.  Until then though, we default to external SCB RAM&n; * off and give a command line option to enable it.&n; */
DECL|variable|aic7xxx_scbram
r_static
r_int
id|aic7xxx_scbram
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * So that we can set how long each device is given as a selection timeout.&n; * The table of values goes like this:&n; *   0 - 256ms&n; *   1 - 128ms&n; *   2 - 64ms&n; *   3 - 32ms&n; * We default to 64ms because it&squot;s fast.  Some old SCSI-I devices need a&n; * longer time.  The final value has to be left shifted by 3, hence 0x10&n; * is the final value.&n; */
DECL|variable|aic7xxx_seltime
r_static
r_int
id|aic7xxx_seltime
op_assign
l_int|0x10
suffix:semicolon
multiline_comment|/*&n; * So that insmod can find the variable and make it point to something&n; */
macro_line|#ifdef MODULE
DECL|variable|aic7xxx
r_static
r_char
op_star
id|aic7xxx
op_assign
l_int|NULL
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|aic7xxx
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Just in case someone uses commas to separate items on the insmod&n; * command line, we define a dummy buffer here to avoid having insmod&n; * write wild stuff into our code segment&n; */
DECL|variable|dummy_buffer
r_static
r_char
id|dummy_buffer
(braket
l_int|60
)braket
op_assign
l_string|&quot;Please don&squot;t trounce on me insmod!!&bslash;n&quot;
suffix:semicolon
macro_line|#endif
DECL|macro|VERBOSE_NORMAL
mdefine_line|#define VERBOSE_NORMAL         0x0000
DECL|macro|VERBOSE_NEGOTIATION
mdefine_line|#define VERBOSE_NEGOTIATION    0x0001
DECL|macro|VERBOSE_SEQINT
mdefine_line|#define VERBOSE_SEQINT         0x0002
DECL|macro|VERBOSE_SCSIINT
mdefine_line|#define VERBOSE_SCSIINT        0x0004
DECL|macro|VERBOSE_PROBE
mdefine_line|#define VERBOSE_PROBE          0x0008
DECL|macro|VERBOSE_PROBE2
mdefine_line|#define VERBOSE_PROBE2         0x0010
DECL|macro|VERBOSE_NEGOTIATION2
mdefine_line|#define VERBOSE_NEGOTIATION2   0x0020
DECL|macro|VERBOSE_MINOR_ERROR
mdefine_line|#define VERBOSE_MINOR_ERROR    0x0040
DECL|macro|VERBOSE_TRACING
mdefine_line|#define VERBOSE_TRACING        0x0080
DECL|macro|VERBOSE_ABORT
mdefine_line|#define VERBOSE_ABORT          0x0f00
DECL|macro|VERBOSE_ABORT_MID
mdefine_line|#define VERBOSE_ABORT_MID      0x0100
DECL|macro|VERBOSE_ABORT_FIND
mdefine_line|#define VERBOSE_ABORT_FIND     0x0200
DECL|macro|VERBOSE_ABORT_PROCESS
mdefine_line|#define VERBOSE_ABORT_PROCESS  0x0400
DECL|macro|VERBOSE_ABORT_RETURN
mdefine_line|#define VERBOSE_ABORT_RETURN   0x0800
DECL|macro|VERBOSE_RESET
mdefine_line|#define VERBOSE_RESET          0xf000
DECL|macro|VERBOSE_RESET_MID
mdefine_line|#define VERBOSE_RESET_MID      0x1000
DECL|macro|VERBOSE_RESET_FIND
mdefine_line|#define VERBOSE_RESET_FIND     0x2000
DECL|macro|VERBOSE_RESET_PROCESS
mdefine_line|#define VERBOSE_RESET_PROCESS  0x4000
DECL|macro|VERBOSE_RESET_RETURN
mdefine_line|#define VERBOSE_RESET_RETURN   0x8000
DECL|variable|aic7xxx_verbose
r_static
r_int
id|aic7xxx_verbose
op_assign
id|VERBOSE_NORMAL
op_or
id|VERBOSE_NEGOTIATION
op_or
id|VERBOSE_PROBE
suffix:semicolon
multiline_comment|/* verbose messages */
multiline_comment|/****************************************************************************&n; *&n; * We&squot;re going to start putting in function declarations so that order of&n; * functions is no longer important.  As needed, they are added here.&n; *&n; ***************************************************************************/
r_static
r_void
id|aic7xxx_panic_abort
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|aic7xxx_print_card
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
suffix:semicolon
r_static
r_void
id|aic7xxx_print_scratch_ram
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
suffix:semicolon
r_static
r_void
id|aic7xxx_print_sequencer
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|downloaded
)paren
suffix:semicolon
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_static
r_void
id|aic7xxx_check_scbs
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_char
op_star
id|buffer
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/****************************************************************************&n; *&n; * These functions are now used.  They happen to be wrapped in useless&n; * inb/outb port read/writes around the real reads and writes because it&n; * seems that certain very fast CPUs have a problem dealing with us when&n; * going at full speed.&n; *&n; ***************************************************************************/
r_static
r_inline
r_int
r_char
DECL|function|aic_inb
id|aic_inb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|port
)paren
(brace
macro_line|#ifdef MMAPIO
r_int
r_char
id|x
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;maddr
)paren
(brace
id|x
op_assign
id|readb
c_func
(paren
id|p-&gt;maddr
op_plus
id|port
)paren
suffix:semicolon
)brace
r_else
(brace
id|x
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|port
)paren
suffix:semicolon
)brace
r_return
id|x
suffix:semicolon
macro_line|#else
r_return
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|port
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_inline
r_void
DECL|function|aic_outb
id|aic_outb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
id|val
comma
r_int
id|port
)paren
(brace
macro_line|#ifdef MMAPIO
r_if
c_cond
(paren
id|p-&gt;maddr
)paren
(brace
id|writeb
c_func
(paren
id|val
comma
id|p-&gt;maddr
op_plus
id|port
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* locked operation in order to force CPU ordering */
id|readb
c_func
(paren
id|p-&gt;maddr
op_plus
id|HCNTRL
)paren
suffix:semicolon
multiline_comment|/* dummy read to flush the PCI write */
)brace
r_else
(brace
id|outb
c_func
(paren
id|val
comma
id|p-&gt;base
op_plus
id|port
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* locked operation in order to force CPU ordering */
)brace
macro_line|#else
id|outb
c_func
(paren
id|val
comma
id|p-&gt;base
op_plus
id|port
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* locked operation in order to force CPU ordering */
macro_line|#endif
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_setup&n; *&n; * Description:&n; *   Handle Linux boot parameters. This routine allows for assigning a value&n; *   to a parameter with a &squot;:&squot; between the parameter and the value.&n; *   ie. aic7xxx=unpause:0x0A,extended&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_setup
id|aic7xxx_setup
c_func
(paren
r_char
op_star
id|s
)paren
(brace
r_int
id|i
comma
id|n
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_char
op_star
id|end
suffix:semicolon
r_static
r_struct
(brace
r_const
r_char
op_star
id|name
suffix:semicolon
r_int
r_int
op_star
id|flag
suffix:semicolon
)brace
id|options
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;extended&quot;
comma
op_amp
id|aic7xxx_extended
)brace
comma
(brace
l_string|&quot;no_reset&quot;
comma
op_amp
id|aic7xxx_no_reset
)brace
comma
(brace
l_string|&quot;irq_trigger&quot;
comma
op_amp
id|aic7xxx_irq_trigger
)brace
comma
(brace
l_string|&quot;verbose&quot;
comma
op_amp
id|aic7xxx_verbose
)brace
comma
(brace
l_string|&quot;reverse_scan&quot;
comma
op_amp
id|aic7xxx_reverse_scan
)brace
comma
(brace
l_string|&quot;override_term&quot;
comma
op_amp
id|aic7xxx_override_term
)brace
comma
(brace
l_string|&quot;stpwlev&quot;
comma
op_amp
id|aic7xxx_stpwlev
)brace
comma
(brace
l_string|&quot;no_probe&quot;
comma
op_amp
id|aic7xxx_no_probe
)brace
comma
(brace
l_string|&quot;panic_on_abort&quot;
comma
op_amp
id|aic7xxx_panic_on_abort
)brace
comma
(brace
l_string|&quot;pci_parity&quot;
comma
op_amp
id|aic7xxx_pci_parity
)brace
comma
(brace
l_string|&quot;dump_card&quot;
comma
op_amp
id|aic7xxx_dump_card
)brace
comma
(brace
l_string|&quot;dump_sequencer&quot;
comma
op_amp
id|aic7xxx_dump_sequencer
)brace
comma
(brace
l_string|&quot;scbram&quot;
comma
op_amp
id|aic7xxx_scbram
)brace
comma
(brace
l_string|&quot;seltime&quot;
comma
op_amp
id|aic7xxx_seltime
)brace
comma
(brace
l_string|&quot;tag_info&quot;
comma
l_int|NULL
)brace
)brace
suffix:semicolon
id|end
op_assign
id|strchr
c_func
(paren
id|s
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|strtok
c_func
(paren
id|s
comma
l_string|&quot;,.&quot;
)paren
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|strtok
c_func
(paren
l_int|NULL
comma
l_string|&quot;,.&quot;
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMBER
c_func
(paren
id|options
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|n
op_assign
id|strlen
c_func
(paren
id|options
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|options
(braket
id|i
)braket
dot
id|name
comma
id|p
comma
id|n
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|p
comma
l_string|&quot;tag_info&quot;
comma
id|n
)paren
)paren
(brace
r_if
c_cond
(paren
id|p
(braket
id|n
)braket
op_eq
l_char|&squot;:&squot;
)paren
(brace
r_char
op_star
id|base
suffix:semicolon
r_char
op_star
id|tok
comma
op_star
id|tok_end
comma
op_star
id|tok_end2
suffix:semicolon
r_char
id|tok_list
(braket
)braket
op_assign
(brace
l_char|&squot;.&squot;
comma
l_char|&squot;,&squot;
comma
l_char|&squot;{&squot;
comma
l_char|&squot;}&squot;
comma
l_char|&squot;&bslash;0&squot;
)brace
suffix:semicolon
r_int
id|i
comma
id|instance
op_assign
op_minus
l_int|1
comma
id|device
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
r_char
id|done
op_assign
id|FALSE
suffix:semicolon
id|base
op_assign
id|p
suffix:semicolon
id|tok
op_assign
id|base
op_plus
id|n
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Forward us just past the &squot;:&squot; */
id|tok_end
op_assign
id|strchr
c_func
(paren
id|tok
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tok_end
OL
id|end
)paren
op_star
id|tok_end
op_assign
l_char|&squot;,&squot;
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
(brace
r_switch
c_cond
(paren
op_star
id|tok
)paren
(brace
r_case
l_char|&squot;{&squot;
suffix:colon
r_if
c_cond
(paren
id|instance
op_eq
op_minus
l_int|1
)paren
id|instance
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|device
op_eq
op_minus
l_int|1
)paren
id|device
op_assign
l_int|0
suffix:semicolon
id|tok
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;}&squot;
suffix:colon
r_if
c_cond
(paren
id|device
op_ne
op_minus
l_int|1
)paren
id|device
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|instance
op_ne
op_minus
l_int|1
)paren
id|instance
op_assign
op_minus
l_int|1
suffix:semicolon
id|tok
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;,&squot;
suffix:colon
r_case
l_char|&squot;.&squot;
suffix:colon
r_if
c_cond
(paren
id|instance
op_eq
op_minus
l_int|1
)paren
id|done
op_assign
id|TRUE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|device
op_ge
l_int|0
)paren
id|device
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|instance
op_ge
l_int|0
)paren
id|instance
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|device
op_ge
id|MAX_TARGETS
)paren
op_logical_or
(paren
id|instance
op_ge
id|NUMBER
c_func
(paren
id|aic7xxx_tag_info
)paren
)paren
)paren
id|done
op_assign
id|TRUE
suffix:semicolon
id|tok
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
(brace
id|base
op_assign
id|tok
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;0&squot;
suffix:colon
id|done
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|done
op_assign
id|TRUE
suffix:semicolon
id|tok_end
op_assign
id|strchr
c_func
(paren
id|tok
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|tok_list
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tok_end2
op_assign
id|strchr
c_func
(paren
id|tok
comma
id|tok_list
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tok_end2
)paren
op_logical_and
(paren
id|tok_end2
OL
id|tok_end
)paren
)paren
(brace
id|tok_end
op_assign
id|tok_end2
suffix:semicolon
id|done
op_assign
id|FALSE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|instance
op_ge
l_int|0
)paren
op_logical_and
(paren
id|device
op_ge
l_int|0
)paren
op_logical_and
(paren
id|instance
OL
id|NUMBER
c_func
(paren
id|aic7xxx_tag_info
)paren
)paren
op_logical_and
(paren
id|device
OL
id|MAX_TARGETS
)paren
)paren
id|aic7xxx_tag_info
(braket
id|instance
)braket
dot
id|tag_commands
(braket
id|device
)braket
op_assign
id|simple_strtoul
c_func
(paren
id|tok
comma
l_int|NULL
comma
l_int|0
)paren
op_amp
l_int|0xff
suffix:semicolon
id|tok
op_assign
id|tok_end
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|p
op_ne
id|base
)paren
op_logical_and
(paren
id|p
op_ne
l_int|NULL
)paren
)paren
(brace
id|p
op_assign
id|strtok
c_func
(paren
l_int|NULL
comma
l_string|&quot;,.&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|p
(braket
id|n
)braket
op_eq
l_char|&squot;:&squot;
)paren
(brace
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
id|n
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|p
comma
l_string|&quot;seltime&quot;
comma
id|n
)paren
)paren
(brace
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
op_assign
(paren
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
op_mod
l_int|4
)paren
op_lshift
l_int|3
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|p
comma
l_string|&quot;verbose&quot;
comma
id|n
)paren
)paren
(brace
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
op_assign
l_int|0xff29
suffix:semicolon
)brace
r_else
(brace
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
op_assign
op_complement
(paren
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|p
comma
l_string|&quot;seltime&quot;
comma
id|n
)paren
)paren
(brace
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
op_assign
(paren
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
op_mod
l_int|4
)paren
op_lshift
l_int|3
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;aic7xxx=&quot;
comma
id|aic7xxx_setup
)paren
suffix:semicolon
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   pause_sequencer&n; *&n; * Description:&n; *   Pause the sequencer and wait for it to actually stop - this&n; *   is important since the sequencer can disable pausing for critical&n; *   sections.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|pause_sequencer
id|pause_sequencer
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|p-&gt;pause
comma
id|HCNTRL
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|HCNTRL
)paren
op_amp
id|PAUSE
)paren
op_eq
l_int|0
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
id|aic_inb
c_func
(paren
id|p
comma
id|CCSCBCTL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   unpause_sequencer&n; *&n; * Description:&n; *   Unpause the sequencer. Unremarkable, yet done often enough to&n; *   warrant an easy way to do it.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|unpause_sequencer
id|unpause_sequencer
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|unpause_always
)paren
(brace
r_if
c_cond
(paren
id|unpause_always
op_logical_or
(paren
op_logical_neg
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|INTSTAT
)paren
op_amp
(paren
id|SCSIINT
op_or
id|SEQINT
op_or
id|BRKADRINT
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|AHC_HANDLING_REQINITS
)paren
)paren
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|p-&gt;unpause
comma
id|HCNTRL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   restart_sequencer&n; *&n; * Description:&n; *   Restart the sequencer program from address zero.  This assumes&n; *   that the sequencer is already paused.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|restart_sequencer
id|restart_sequencer
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SEQADDR0
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SEQADDR1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|FASTMODE
comma
id|SEQCTL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We include the aic7xxx_seq.c file here so that the other defines have&n; * already been made, and so that it comes before the code that actually&n; * downloads the instructions (since we don&squot;t typically use function&n; * prototype, our code has to be ordered that way, it&squot;s a left-over from&n; * the original driver days.....I should fix it some time DL).&n; */
macro_line|#include &quot;aic7xxx_seq.c&quot;
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_check_patch&n; *&n; * Description:&n; *   See if the next patch to download should be downloaded.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_check_patch
id|aic7xxx_check_patch
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|sequencer_patch
op_star
op_star
id|start_patch
comma
r_int
id|start_instr
comma
r_int
op_star
id|skip_addr
)paren
(brace
r_struct
id|sequencer_patch
op_star
id|cur_patch
suffix:semicolon
r_struct
id|sequencer_patch
op_star
id|last_patch
suffix:semicolon
r_int
id|num_patches
suffix:semicolon
id|num_patches
op_assign
r_sizeof
(paren
id|sequencer_patches
)paren
op_div
r_sizeof
(paren
r_struct
id|sequencer_patch
)paren
suffix:semicolon
id|last_patch
op_assign
op_amp
id|sequencer_patches
(braket
id|num_patches
)braket
suffix:semicolon
id|cur_patch
op_assign
op_star
id|start_patch
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cur_patch
OL
id|last_patch
)paren
op_logical_and
(paren
id|start_instr
op_eq
id|cur_patch-&gt;begin
)paren
)paren
(brace
r_if
c_cond
(paren
id|cur_patch
op_member_access_from_pointer
id|patch_func
c_func
(paren
id|p
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;       * Start rejecting code.&n;       */
op_star
id|skip_addr
op_assign
id|start_instr
op_plus
id|cur_patch-&gt;skip_instr
suffix:semicolon
id|cur_patch
op_add_assign
id|cur_patch-&gt;skip_patch
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;       * Found an OK patch.  Advance the patch pointer to the next patch&n;       * and wait for our instruction pointer to get here.&n;       */
id|cur_patch
op_increment
suffix:semicolon
)brace
)brace
op_star
id|start_patch
op_assign
id|cur_patch
suffix:semicolon
r_if
c_cond
(paren
id|start_instr
OL
op_star
id|skip_addr
)paren
multiline_comment|/*&n;     * Still skipping&n;     */
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_download_instr&n; *&n; * Description:&n; *   Find the next patch to download.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_download_instr
id|aic7xxx_download_instr
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|instrptr
comma
r_int
r_char
op_star
id|dconsts
)paren
(brace
r_union
id|ins_formats
id|instr
suffix:semicolon
r_struct
id|ins_format1
op_star
id|fmt1_ins
suffix:semicolon
r_struct
id|ins_format3
op_star
id|fmt3_ins
suffix:semicolon
r_int
r_char
id|opcode
suffix:semicolon
id|instr
op_assign
op_star
(paren
r_union
id|ins_formats
op_star
)paren
op_amp
id|seqprog
(braket
id|instrptr
op_star
l_int|4
)braket
suffix:semicolon
id|instr.integer
op_assign
id|le32_to_cpu
c_func
(paren
id|instr.integer
)paren
suffix:semicolon
id|fmt1_ins
op_assign
op_amp
id|instr.format1
suffix:semicolon
id|fmt3_ins
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Pull the opcode */
id|opcode
op_assign
id|instr.format1.opcode
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|AIC_OP_JMP
suffix:colon
r_case
id|AIC_OP_JC
suffix:colon
r_case
id|AIC_OP_JNC
suffix:colon
r_case
id|AIC_OP_CALL
suffix:colon
r_case
id|AIC_OP_JNE
suffix:colon
r_case
id|AIC_OP_JNZ
suffix:colon
r_case
id|AIC_OP_JE
suffix:colon
r_case
id|AIC_OP_JZ
suffix:colon
(brace
r_struct
id|sequencer_patch
op_star
id|cur_patch
suffix:semicolon
r_int
id|address_offset
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_int
id|skip_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|fmt3_ins
op_assign
op_amp
id|instr.format3
suffix:semicolon
id|address_offset
op_assign
l_int|0
suffix:semicolon
id|address
op_assign
id|fmt3_ins-&gt;address
suffix:semicolon
id|cur_patch
op_assign
id|sequencer_patches
suffix:semicolon
id|skip_addr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|address
suffix:semicolon
)paren
(brace
id|aic7xxx_check_patch
c_func
(paren
id|p
comma
op_amp
id|cur_patch
comma
id|i
comma
op_amp
id|skip_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skip_addr
OG
id|i
)paren
(brace
r_int
id|end_addr
suffix:semicolon
id|end_addr
op_assign
id|MIN
c_func
(paren
id|address
comma
id|skip_addr
)paren
suffix:semicolon
id|address_offset
op_add_assign
id|end_addr
op_minus
id|i
suffix:semicolon
id|i
op_assign
id|skip_addr
suffix:semicolon
)brace
r_else
(brace
id|i
op_increment
suffix:semicolon
)brace
)brace
id|address
op_sub_assign
id|address_offset
suffix:semicolon
id|fmt3_ins-&gt;address
op_assign
id|address
suffix:semicolon
multiline_comment|/* Fall Through to the next code section */
)brace
r_case
id|AIC_OP_OR
suffix:colon
r_case
id|AIC_OP_AND
suffix:colon
r_case
id|AIC_OP_XOR
suffix:colon
r_case
id|AIC_OP_ADD
suffix:colon
r_case
id|AIC_OP_ADC
suffix:colon
r_case
id|AIC_OP_BMOV
suffix:colon
r_if
c_cond
(paren
id|fmt1_ins-&gt;parity
op_ne
l_int|0
)paren
(brace
id|fmt1_ins-&gt;immediate
op_assign
id|dconsts
(braket
id|fmt1_ins-&gt;immediate
)braket
suffix:semicolon
)brace
id|fmt1_ins-&gt;parity
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fall Through to the next code section */
r_case
id|AIC_OP_ROL
suffix:colon
r_if
c_cond
(paren
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|i
comma
id|count
suffix:semicolon
multiline_comment|/* Calculate odd parity for the instruction */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|count
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|31
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
id|mask
op_assign
l_int|0x01
op_lshift
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|instr.integer
op_amp
id|mask
)paren
op_ne
l_int|0
)paren
id|count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|count
op_amp
l_int|0x01
)paren
)paren
id|instr.format1.parity
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|fmt3_ins
op_ne
l_int|NULL
)paren
(brace
id|instr.integer
op_assign
id|fmt3_ins-&gt;immediate
op_or
(paren
id|fmt3_ins-&gt;source
op_lshift
l_int|8
)paren
op_or
(paren
id|fmt3_ins-&gt;address
op_lshift
l_int|16
)paren
op_or
(paren
id|fmt3_ins-&gt;opcode
op_lshift
l_int|25
)paren
suffix:semicolon
)brace
r_else
(brace
id|instr.integer
op_assign
id|fmt1_ins-&gt;immediate
op_or
(paren
id|fmt1_ins-&gt;source
op_lshift
l_int|8
)paren
op_or
(paren
id|fmt1_ins-&gt;destination
op_lshift
l_int|16
)paren
op_or
(paren
id|fmt1_ins-&gt;ret
op_lshift
l_int|24
)paren
op_or
(paren
id|fmt1_ins-&gt;opcode
op_lshift
l_int|25
)paren
suffix:semicolon
)brace
)brace
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|instr.integer
op_amp
l_int|0xff
)paren
comma
id|SEQRAM
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
(paren
id|instr.integer
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
comma
id|SEQRAM
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
(paren
id|instr.integer
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
comma
id|SEQRAM
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
(paren
id|instr.integer
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
)paren
comma
id|SEQRAM
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;aic7xxx: Unknown opcode encountered in sequencer program.&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_loadseq&n; *&n; * Description:&n; *   Load the sequencer code into the controller memory.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_loadseq
id|aic7xxx_loadseq
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_struct
id|sequencer_patch
op_star
id|cur_patch
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|downloaded
suffix:semicolon
r_int
id|skip_addr
suffix:semicolon
r_int
r_char
id|download_consts
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Downloading sequencer code...&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
macro_line|#if 0
id|download_consts
(braket
id|TMODE_NUMCMDS
)braket
op_assign
id|p-&gt;num_targetcmds
suffix:semicolon
macro_line|#endif
id|download_consts
(braket
id|TMODE_NUMCMDS
)braket
op_assign
l_int|0
suffix:semicolon
id|cur_patch
op_assign
op_amp
id|sequencer_patches
(braket
l_int|0
)braket
suffix:semicolon
id|downloaded
op_assign
l_int|0
suffix:semicolon
id|skip_addr
op_assign
l_int|0
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|PERRORDIS
op_or
id|LOADRAM
op_or
id|FAILDIS
op_or
id|FASTMODE
comma
id|SEQCTL
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SEQADDR0
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SEQADDR1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|seqprog
)paren
op_div
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_check_patch
c_func
(paren
id|p
comma
op_amp
id|cur_patch
comma
id|i
comma
op_amp
id|skip_addr
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Skip this instruction for this configuration. */
r_continue
suffix:semicolon
)brace
id|aic7xxx_download_instr
c_func
(paren
id|p
comma
id|i
comma
op_amp
id|download_consts
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|downloaded
op_increment
suffix:semicolon
)brace
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SEQADDR0
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SEQADDR1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|FASTMODE
op_or
id|FAILDIS
comma
id|SEQCTL
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|FASTMODE
comma
id|SEQCTL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %d instructions downloaded&bslash;n&quot;
comma
id|downloaded
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_dump_sequencer
)paren
id|aic7xxx_print_sequencer
c_func
(paren
id|p
comma
id|downloaded
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_print_sequencer&n; *&n; * Description:&n; *   Print the contents of the sequencer memory to the screen.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_print_sequencer
id|aic7xxx_print_sequencer
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|downloaded
)paren
(brace
r_int
id|i
comma
id|k
comma
id|temp
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|PERRORDIS
op_or
id|LOADRAM
op_or
id|FAILDIS
op_or
id|FASTMODE
comma
id|SEQCTL
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SEQADDR0
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SEQADDR1
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|downloaded
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|k
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%03x: &quot;
comma
id|i
)paren
suffix:semicolon
id|temp
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SEQRAM
)paren
suffix:semicolon
id|temp
op_or_assign
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SEQRAM
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|temp
op_or_assign
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SEQRAM
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|temp
op_or_assign
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SEQRAM
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08x&quot;
comma
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|k
op_eq
l_int|8
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SEQADDR0
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SEQADDR1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|FASTMODE
op_or
id|FAILDIS
comma
id|SEQCTL
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|FASTMODE
comma
id|SEQCTL
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_info&n; *&n; * Description:&n; *   Return a string describing the driver.&n; *-F*************************************************************************/
r_const
r_char
op_star
DECL|function|aic7xxx_info
id|aic7xxx_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|dooh
)paren
(brace
r_static
r_char
id|buffer
(braket
l_int|256
)braket
suffix:semicolon
r_char
op_star
id|bp
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
id|bp
op_assign
op_amp
id|buffer
(braket
l_int|0
)braket
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|dooh-&gt;hostdata
suffix:semicolon
id|memset
c_func
(paren
id|bp
comma
l_int|0
comma
r_sizeof
(paren
id|buffer
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|bp
comma
l_string|&quot;Adaptec AHA274x/284x/294x (EISA/VLB/PCI-Fast SCSI) &quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|AIC7XXX_C_VERSION
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;/&quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|AIC7XXX_H_VERSION
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;       &lt;&quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|board_names
(braket
id|p-&gt;board_name_index
)braket
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
r_return
id|bp
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_find_syncrate&n; *&n; * Description:&n; *   Look up the valid period to SCSIRATE conversion in our table&n; *-F*************************************************************************/
r_static
r_struct
id|aic7xxx_syncrate
op_star
DECL|function|aic7xxx_find_syncrate
id|aic7xxx_find_syncrate
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_int
op_star
id|period
comma
r_int
r_int
id|maxsync
comma
r_int
r_char
op_star
id|options
)paren
(brace
r_struct
id|aic7xxx_syncrate
op_star
id|syncrate
suffix:semicolon
r_int
id|done
op_assign
id|FALSE
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|options
)paren
(brace
r_case
id|MSG_EXT_PPR_OPTION_DT_CRC
suffix:colon
r_case
id|MSG_EXT_PPR_OPTION_DT_UNITS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA3
)paren
)paren
(brace
op_star
id|options
op_assign
l_int|0
suffix:semicolon
id|maxsync
op_assign
id|MAX
c_func
(paren
id|maxsync
comma
id|AHC_SYNCRATE_ULTRA2
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MSG_EXT_PPR_OPTION_DT_CRC_QUICK
suffix:colon
r_case
id|MSG_EXT_PPR_OPTION_DT_UNITS_QUICK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA3
)paren
)paren
(brace
op_star
id|options
op_assign
l_int|0
suffix:semicolon
id|maxsync
op_assign
id|MAX
c_func
(paren
id|maxsync
comma
id|AHC_SYNCRATE_ULTRA2
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;         * we don&squot;t support the Quick Arbitration variants of dual edge&n;         * clocking.  As it turns out, we want to send back the&n;         * same basic option, but without the QA attribute.&n;         * We know that we are responding because we would never set&n;         * these options ourself, we would only respond to them.&n;         */
r_switch
c_cond
(paren
op_star
id|options
)paren
(brace
r_case
id|MSG_EXT_PPR_OPTION_DT_CRC_QUICK
suffix:colon
op_star
id|options
op_assign
id|MSG_EXT_PPR_OPTION_DT_CRC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MSG_EXT_PPR_OPTION_DT_UNITS_QUICK
suffix:colon
op_star
id|options
op_assign
id|MSG_EXT_PPR_OPTION_DT_UNITS
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|options
op_assign
l_int|0
suffix:semicolon
id|maxsync
op_assign
id|MAX
c_func
(paren
id|maxsync
comma
id|AHC_SYNCRATE_ULTRA2
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|syncrate
op_assign
op_amp
id|aic7xxx_syncrates
(braket
id|maxsync
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|syncrate-&gt;rate
(braket
l_int|0
)braket
op_ne
l_int|NULL
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_logical_or
id|syncrate-&gt;sxfr_ultra2
)paren
)paren
(brace
r_if
c_cond
(paren
op_star
id|period
op_le
id|syncrate-&gt;period
)paren
(brace
r_switch
c_cond
(paren
op_star
id|options
)paren
(brace
r_case
id|MSG_EXT_PPR_OPTION_DT_CRC
suffix:colon
r_case
id|MSG_EXT_PPR_OPTION_DT_UNITS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syncrate-&gt;sxfr_ultra2
op_amp
id|AHC_SYNCRATE_CRC
)paren
)paren
(brace
id|done
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;             * oops, we went too low for the CRC/DualEdge signalling, so&n;             * clear the options byte&n;             */
op_star
id|options
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;             * We&squot;ll be sending a reply to this packet to set the options&n;             * properly, so unilaterally set the period as well.&n;             */
op_star
id|period
op_assign
id|syncrate-&gt;period
suffix:semicolon
)brace
r_else
(brace
id|done
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|syncrate
op_eq
op_amp
id|aic7xxx_syncrates
(braket
id|maxsync
)braket
)paren
(brace
op_star
id|period
op_assign
id|syncrate-&gt;period
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|syncrate-&gt;sxfr_ultra2
op_amp
id|AHC_SYNCRATE_CRC
)paren
)paren
(brace
id|done
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|syncrate
op_eq
op_amp
id|aic7xxx_syncrates
(braket
id|maxsync
)braket
)paren
(brace
op_star
id|period
op_assign
id|syncrate-&gt;period
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|done
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|syncrate
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_star
id|period
op_eq
l_int|0
)paren
op_logical_or
(paren
id|syncrate-&gt;rate
(braket
l_int|0
)braket
op_eq
l_int|NULL
)paren
op_logical_or
(paren
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_logical_and
(paren
id|syncrate-&gt;sxfr_ultra2
op_eq
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/*&n;     * Use async transfers for this target&n;     */
op_star
id|options
op_assign
l_int|0
suffix:semicolon
op_star
id|period
op_assign
l_int|255
suffix:semicolon
id|syncrate
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
id|syncrate
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_find_period&n; *&n; * Description:&n; *   Look up the valid SCSIRATE to period conversion in our table&n; *-F*************************************************************************/
r_static
r_int
r_int
DECL|function|aic7xxx_find_period
id|aic7xxx_find_period
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_int
id|scsirate
comma
r_int
r_int
id|maxsync
)paren
(brace
r_struct
id|aic7xxx_syncrate
op_star
id|syncrate
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
id|scsirate
op_and_assign
id|SXFR_ULTRA2
suffix:semicolon
)brace
r_else
(brace
id|scsirate
op_and_assign
id|SXFR
suffix:semicolon
)brace
id|syncrate
op_assign
op_amp
id|aic7xxx_syncrates
(braket
id|maxsync
)braket
suffix:semicolon
r_while
c_loop
(paren
id|syncrate-&gt;rate
(braket
l_int|0
)braket
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
r_if
c_cond
(paren
id|syncrate-&gt;sxfr_ultra2
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_else
r_if
c_cond
(paren
id|scsirate
op_eq
id|syncrate-&gt;sxfr_ultra2
)paren
r_return
(paren
id|syncrate-&gt;period
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|scsirate
op_eq
(paren
id|syncrate-&gt;sxfr_ultra2
op_amp
op_complement
id|AHC_SYNCRATE_CRC
)paren
)paren
r_return
(paren
id|syncrate-&gt;period
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scsirate
op_eq
(paren
id|syncrate-&gt;sxfr
op_amp
op_complement
id|ULTRA_SXFR
)paren
)paren
(brace
r_return
(paren
id|syncrate-&gt;period
)paren
suffix:semicolon
)brace
id|syncrate
op_increment
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* async */
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_validate_offset&n; *&n; * Description:&n; *   Set a valid offset value for a particular card in use and transfer&n; *   settings in use.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_validate_offset
id|aic7xxx_validate_offset
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_syncrate
op_star
id|syncrate
comma
r_int
r_int
op_star
id|offset
comma
r_int
id|wide
)paren
(brace
r_int
r_int
id|maxoffset
suffix:semicolon
multiline_comment|/* Limit offset to what the card (and device) can do */
r_if
c_cond
(paren
id|syncrate
op_eq
l_int|NULL
)paren
(brace
id|maxoffset
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
id|maxoffset
op_assign
id|MAX_OFFSET_ULTRA2
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|wide
)paren
id|maxoffset
op_assign
id|MAX_OFFSET_16BIT
suffix:semicolon
r_else
id|maxoffset
op_assign
id|MAX_OFFSET_8BIT
suffix:semicolon
)brace
op_star
id|offset
op_assign
id|MIN
c_func
(paren
op_star
id|offset
comma
id|maxoffset
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_set_syncrate&n; *&n; * Description:&n; *   Set the actual syncrate down in the card and in our host structs&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_set_syncrate
id|aic7xxx_set_syncrate
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_syncrate
op_star
id|syncrate
comma
r_int
id|target
comma
r_int
id|channel
comma
r_int
r_int
id|period
comma
r_int
r_int
id|offset
comma
r_int
r_char
id|options
comma
r_int
r_int
id|type
)paren
(brace
r_int
r_char
id|tindex
suffix:semicolon
r_int
r_int
id|target_mask
suffix:semicolon
r_int
r_char
id|lun
comma
id|old_options
suffix:semicolon
r_int
r_int
id|old_period
comma
id|old_offset
suffix:semicolon
id|tindex
op_assign
id|target
op_or
(paren
id|channel
op_lshift
l_int|3
)paren
suffix:semicolon
id|target_mask
op_assign
l_int|0x01
op_lshift
id|tindex
suffix:semicolon
id|lun
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TCL
)paren
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
id|syncrate
op_eq
l_int|NULL
)paren
(brace
id|period
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
)brace
id|old_period
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|cur_period
suffix:semicolon
id|old_offset
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|cur_offset
suffix:semicolon
id|old_options
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|cur_options
suffix:semicolon
r_if
c_cond
(paren
id|type
op_amp
id|AHC_TRANS_CUR
)paren
(brace
r_int
r_int
id|scsirate
suffix:semicolon
id|scsirate
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|TARG_SCSIRATE
op_plus
id|tindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
id|scsirate
op_and_assign
op_complement
id|SXFR_ULTRA2
suffix:semicolon
r_if
c_cond
(paren
id|syncrate
op_ne
l_int|NULL
)paren
(brace
r_switch
c_cond
(paren
id|options
)paren
(brace
r_case
id|MSG_EXT_PPR_OPTION_DT_UNITS
suffix:colon
multiline_comment|/*&n;             * mask off the CRC bit in the xfer settings&n;             */
id|scsirate
op_or_assign
(paren
id|syncrate-&gt;sxfr_ultra2
op_amp
op_complement
id|AHC_SYNCRATE_CRC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|scsirate
op_or_assign
id|syncrate-&gt;sxfr_ultra2
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|type
op_amp
id|AHC_TRANS_ACTIVE
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|offset
comma
id|SCSIOFFSET
)paren
suffix:semicolon
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|offset
comma
id|TARG_OFFSET
op_plus
id|tindex
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Not an Ultra2 controller */
(brace
id|scsirate
op_and_assign
op_complement
(paren
id|SXFR
op_or
id|SOFS
)paren
suffix:semicolon
id|p-&gt;ultraenb
op_and_assign
op_complement
id|target_mask
suffix:semicolon
r_if
c_cond
(paren
id|syncrate
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|syncrate-&gt;sxfr
op_amp
id|ULTRA_SXFR
)paren
(brace
id|p-&gt;ultraenb
op_or_assign
id|target_mask
suffix:semicolon
)brace
id|scsirate
op_or_assign
(paren
id|syncrate-&gt;sxfr
op_amp
id|SXFR
)paren
suffix:semicolon
id|scsirate
op_or_assign
(paren
id|offset
op_amp
id|SOFS
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_amp
id|AHC_TRANS_ACTIVE
)paren
(brace
r_int
r_char
id|sxfrctl0
suffix:semicolon
id|sxfrctl0
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SXFRCTL0
)paren
suffix:semicolon
id|sxfrctl0
op_and_assign
op_complement
id|FAST20
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;ultraenb
op_amp
id|target_mask
)paren
id|sxfrctl0
op_or_assign
id|FAST20
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|sxfrctl0
comma
id|SXFRCTL0
)paren
suffix:semicolon
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|p-&gt;ultraenb
op_amp
l_int|0xff
comma
id|ULTRA_ENB
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|p-&gt;ultraenb
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|ULTRA_ENB
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_amp
id|AHC_TRANS_ACTIVE
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|scsirate
comma
id|SCSIRATE
)paren
suffix:semicolon
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|scsirate
comma
id|TARG_SCSIRATE
op_plus
id|tindex
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|cur_period
op_assign
id|period
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|cur_offset
op_assign
id|offset
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|cur_options
op_assign
id|options
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|type
op_amp
id|AHC_TRANS_QUITE
)paren
op_logical_and
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION
)paren
op_logical_and
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
id|DEVICE_PRINT_DTR
)paren
)paren
(brace
r_if
c_cond
(paren
id|offset
)paren
(brace
r_int
id|rate_mod
op_assign
(paren
id|scsirate
op_amp
id|WIDEXFER
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Synchronous at %s Mbyte/sec, &quot;
l_string|&quot;offset %d.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
comma
id|syncrate-&gt;rate
(braket
id|rate_mod
)braket
comma
id|offset
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Using asynchronous transfers.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
)brace
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_and_assign
op_complement
id|DEVICE_PRINT_DTR
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|type
op_amp
id|AHC_TRANS_GOAL
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_assign
id|period
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|offset
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
op_assign
id|options
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_amp
id|AHC_TRANS_USER
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_period
op_assign
id|period
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_offset
op_assign
id|offset
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_options
op_assign
id|options
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_set_width&n; *&n; * Description:&n; *   Set the actual width down in the card and in our host structs&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_set_width
id|aic7xxx_set_width
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|target
comma
r_int
id|channel
comma
r_int
id|lun
comma
r_int
r_int
id|width
comma
r_int
r_int
id|type
)paren
(brace
r_int
r_char
id|tindex
suffix:semicolon
r_int
r_int
id|target_mask
suffix:semicolon
r_int
r_int
id|old_width
suffix:semicolon
id|tindex
op_assign
id|target
op_or
(paren
id|channel
op_lshift
l_int|3
)paren
suffix:semicolon
id|target_mask
op_assign
l_int|1
op_lshift
id|tindex
suffix:semicolon
id|old_width
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|cur_width
suffix:semicolon
r_if
c_cond
(paren
id|type
op_amp
id|AHC_TRANS_CUR
)paren
(brace
r_int
r_char
id|scsirate
suffix:semicolon
id|scsirate
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|TARG_SCSIRATE
op_plus
id|tindex
)paren
suffix:semicolon
id|scsirate
op_and_assign
op_complement
id|WIDEXFER
suffix:semicolon
r_if
c_cond
(paren
id|width
op_eq
id|MSG_EXT_WDTR_BUS_16_BIT
)paren
id|scsirate
op_or_assign
id|WIDEXFER
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|scsirate
comma
id|TARG_SCSIRATE
op_plus
id|tindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_amp
id|AHC_TRANS_ACTIVE
)paren
id|aic_outb
c_func
(paren
id|p
comma
id|scsirate
comma
id|SCSIRATE
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|cur_width
op_assign
id|width
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|type
op_amp
id|AHC_TRANS_QUITE
)paren
op_logical_and
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
op_logical_and
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
id|DEVICE_PRINT_DTR
)paren
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Using %s transfers&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
comma
(paren
id|scsirate
op_amp
id|WIDEXFER
)paren
ques
c_cond
l_string|&quot;Wide(16bit)&quot;
suffix:colon
l_string|&quot;Narrow(8bit)&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|type
op_amp
id|AHC_TRANS_GOAL
)paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
op_assign
id|width
suffix:semicolon
r_if
c_cond
(paren
id|type
op_amp
id|AHC_TRANS_USER
)paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_width
op_assign
id|width
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|MAX_OFFSET_ULTRA2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|width
op_eq
id|MSG_EXT_WDTR_BUS_16_BIT
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|MAX_OFFSET_16BIT
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|MAX_OFFSET_8BIT
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   scbq_init&n; *&n; * Description:&n; *   SCB queue initialization.&n; *&n; *-F*************************************************************************/
r_static
r_void
DECL|function|scbq_init
id|scbq_init
c_func
(paren
r_volatile
id|scb_queue_type
op_star
id|queue
)paren
(brace
id|queue-&gt;head
op_assign
l_int|NULL
suffix:semicolon
id|queue-&gt;tail
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   scbq_insert_head&n; *&n; * Description:&n; *   Add an SCB to the head of the list.&n; *&n; *-F*************************************************************************/
r_static
r_inline
r_void
DECL|function|scbq_insert_head
id|scbq_insert_head
c_func
(paren
r_volatile
id|scb_queue_type
op_star
id|queue
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,1,95)
r_int
r_int
id|cpu_flags
suffix:semicolon
macro_line|#endif
id|DRIVER_LOCK
id|scb-&gt;q_next
op_assign
id|queue-&gt;head
suffix:semicolon
id|queue-&gt;head
op_assign
id|scb
suffix:semicolon
r_if
c_cond
(paren
id|queue-&gt;tail
op_eq
l_int|NULL
)paren
multiline_comment|/* If list was empty, update tail. */
id|queue-&gt;tail
op_assign
id|queue-&gt;head
suffix:semicolon
id|DRIVER_UNLOCK
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   scbq_remove_head&n; *&n; * Description:&n; *   Remove an SCB from the head of the list.&n; *&n; *-F*************************************************************************/
r_static
r_inline
r_struct
id|aic7xxx_scb
op_star
DECL|function|scbq_remove_head
id|scbq_remove_head
c_func
(paren
r_volatile
id|scb_queue_type
op_star
id|queue
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scbp
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,1,95)
r_int
r_int
id|cpu_flags
suffix:semicolon
macro_line|#endif
id|DRIVER_LOCK
id|scbp
op_assign
id|queue-&gt;head
suffix:semicolon
r_if
c_cond
(paren
id|queue-&gt;head
op_ne
l_int|NULL
)paren
id|queue-&gt;head
op_assign
id|queue-&gt;head-&gt;q_next
suffix:semicolon
r_if
c_cond
(paren
id|queue-&gt;head
op_eq
l_int|NULL
)paren
multiline_comment|/* If list is now empty, update tail. */
id|queue-&gt;tail
op_assign
l_int|NULL
suffix:semicolon
id|DRIVER_UNLOCK
r_return
id|scbp
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   scbq_remove&n; *&n; * Description:&n; *   Removes an SCB from the list.&n; *&n; *-F*************************************************************************/
r_static
r_inline
r_void
DECL|function|scbq_remove
id|scbq_remove
c_func
(paren
r_volatile
id|scb_queue_type
op_star
id|queue
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,1,95)
r_int
r_int
id|cpu_flags
suffix:semicolon
macro_line|#endif
id|DRIVER_LOCK
r_if
c_cond
(paren
id|queue-&gt;head
op_eq
id|scb
)paren
(brace
multiline_comment|/* At beginning of queue, remove from head. */
id|scbq_remove_head
c_func
(paren
id|queue
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|aic7xxx_scb
op_star
id|curscb
op_assign
id|queue-&gt;head
suffix:semicolon
multiline_comment|/*&n;     * Search until the next scb is the one we&squot;re looking for, or&n;     * we run out of queue.&n;     */
r_while
c_loop
(paren
(paren
id|curscb
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|curscb-&gt;q_next
op_ne
id|scb
)paren
)paren
(brace
id|curscb
op_assign
id|curscb-&gt;q_next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|curscb
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Found it. */
id|curscb-&gt;q_next
op_assign
id|scb-&gt;q_next
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;q_next
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Update the tail when removing the tail. */
id|queue-&gt;tail
op_assign
id|curscb
suffix:semicolon
)brace
)brace
)brace
id|DRIVER_UNLOCK
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   scbq_insert_tail&n; *&n; * Description:&n; *   Add an SCB at the tail of the list.&n; *&n; *-F*************************************************************************/
r_static
r_inline
r_void
DECL|function|scbq_insert_tail
id|scbq_insert_tail
c_func
(paren
r_volatile
id|scb_queue_type
op_star
id|queue
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,1,95)
r_int
r_int
id|cpu_flags
suffix:semicolon
macro_line|#endif
id|DRIVER_LOCK
id|scb-&gt;q_next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|queue-&gt;tail
op_ne
l_int|NULL
)paren
multiline_comment|/* Add the scb at the end of the list. */
id|queue-&gt;tail-&gt;q_next
op_assign
id|scb
suffix:semicolon
id|queue-&gt;tail
op_assign
id|scb
suffix:semicolon
multiline_comment|/* Update the tail. */
r_if
c_cond
(paren
id|queue-&gt;head
op_eq
l_int|NULL
)paren
multiline_comment|/* If list was empty, update head. */
id|queue-&gt;head
op_assign
id|queue-&gt;tail
suffix:semicolon
id|DRIVER_UNLOCK
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_match_scb&n; *&n; * Description:&n; *   Checks to see if an scb matches the target/channel as specified.&n; *   If target is ALL_TARGETS (-1), then we&squot;re looking for any device&n; *   on the specified channel; this happens when a channel is going&n; *   to be reset and all devices on that channel must be aborted.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_match_scb
id|aic7xxx_match_scb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
comma
r_int
id|target
comma
r_int
id|channel
comma
r_int
id|lun
comma
r_int
r_char
id|tag
)paren
(brace
r_int
id|targ
op_assign
(paren
id|scb-&gt;hscb-&gt;target_channel_lun
op_rshift
l_int|4
)paren
op_amp
l_int|0x0F
suffix:semicolon
r_int
id|chan
op_assign
(paren
id|scb-&gt;hscb-&gt;target_channel_lun
op_rshift
l_int|3
)paren
op_amp
l_int|0x01
suffix:semicolon
r_int
id|slun
op_assign
id|scb-&gt;hscb-&gt;target_channel_lun
op_amp
l_int|0x07
suffix:semicolon
r_int
id|match
suffix:semicolon
id|match
op_assign
(paren
(paren
id|chan
op_eq
id|channel
)paren
op_logical_or
(paren
id|channel
op_eq
id|ALL_CHANNELS
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
op_ne
l_int|0
)paren
id|match
op_assign
(paren
(paren
id|targ
op_eq
id|target
)paren
op_logical_or
(paren
id|target
op_eq
id|ALL_TARGETS
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
op_ne
l_int|0
)paren
id|match
op_assign
(paren
(paren
id|lun
op_eq
id|slun
)paren
op_logical_or
(paren
id|lun
op_eq
id|ALL_LUNS
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
op_ne
l_int|0
)paren
id|match
op_assign
(paren
(paren
id|tag
op_eq
id|scb-&gt;hscb-&gt;tag
)paren
op_logical_or
(paren
id|tag
op_eq
id|SCB_LIST_NULL
)paren
)paren
suffix:semicolon
r_return
(paren
id|match
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_add_curscb_to_free_list&n; *&n; * Description:&n; *   Adds the current scb (in SCBPTR) to the list of free SCBs.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_add_curscb_to_free_list
id|aic7xxx_add_curscb_to_free_list
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
multiline_comment|/*&n;   * Invalidate the tag so that aic7xxx_find_scb doesn&squot;t think&n;   * it&squot;s active&n;   */
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|SCB_TAG
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCB_CONTROL
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|FREE_SCBH
)paren
comma
id|SCB_NEXT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCBPTR
)paren
comma
id|FREE_SCBH
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_rem_scb_from_disc_list&n; *&n; * Description:&n; *   Removes the current SCB from the disconnected list and adds it&n; *   to the free list.&n; *-F*************************************************************************/
r_static
r_int
r_char
DECL|function|aic7xxx_rem_scb_from_disc_list
id|aic7xxx_rem_scb_from_disc_list
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
id|scbptr
comma
r_int
r_char
id|prev
)paren
(brace
r_int
r_char
id|next
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|scbptr
comma
id|SCBPTR
)paren
suffix:semicolon
id|next
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_NEXT
)paren
suffix:semicolon
id|aic7xxx_add_curscb_to_free_list
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_ne
id|SCB_LIST_NULL
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|prev
comma
id|SCBPTR
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|next
comma
id|SCB_NEXT
)paren
suffix:semicolon
)brace
r_else
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|next
comma
id|DISCONNECTED_SCBH
)paren
suffix:semicolon
)brace
r_return
id|next
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_busy_target&n; *&n; * Description:&n; *   Set the specified target busy.&n; *-F*************************************************************************/
r_static
r_inline
r_void
DECL|function|aic7xxx_busy_target
id|aic7xxx_busy_target
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
id|p-&gt;untagged_scbs
(braket
id|scb-&gt;hscb-&gt;target_channel_lun
)braket
op_assign
id|scb-&gt;hscb-&gt;tag
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_index_busy_target&n; *&n; * Description:&n; *   Returns the index of the busy target, and optionally sets the&n; *   target inactive.&n; *-F*************************************************************************/
r_static
r_inline
r_int
r_char
DECL|function|aic7xxx_index_busy_target
id|aic7xxx_index_busy_target
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
id|tcl
comma
r_int
id|unbusy
)paren
(brace
r_int
r_char
id|busy_scbid
suffix:semicolon
id|busy_scbid
op_assign
id|p-&gt;untagged_scbs
(braket
id|tcl
)braket
suffix:semicolon
r_if
c_cond
(paren
id|unbusy
)paren
(brace
id|p-&gt;untagged_scbs
(braket
id|tcl
)braket
op_assign
id|SCB_LIST_NULL
suffix:semicolon
)brace
r_return
(paren
id|busy_scbid
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_find_scb&n; *&n; * Description:&n; *   Look through the SCB array of the card and attempt to find the&n; *   hardware SCB that corresponds to the passed in SCB.  Return&n; *   SCB_LIST_NULL if unsuccessful.  This routine assumes that the&n; *   card is already paused.&n; *-F*************************************************************************/
r_static
r_int
r_char
DECL|function|aic7xxx_find_scb
id|aic7xxx_find_scb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
r_int
r_char
id|saved_scbptr
suffix:semicolon
r_int
r_char
id|curindex
suffix:semicolon
id|saved_scbptr
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCBPTR
)paren
suffix:semicolon
id|curindex
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|curindex
op_assign
l_int|0
suffix:semicolon
id|curindex
OL
id|p-&gt;scb_data-&gt;maxhscbs
suffix:semicolon
id|curindex
op_increment
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|curindex
comma
id|SCBPTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
op_eq
id|scb-&gt;hscb-&gt;tag
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|saved_scbptr
comma
id|SCBPTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curindex
op_ge
id|p-&gt;scb_data-&gt;maxhscbs
)paren
(brace
id|curindex
op_assign
id|SCB_LIST_NULL
suffix:semicolon
)brace
r_return
(paren
id|curindex
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_allocate_scb&n; *&n; * Description:&n; *   Get an SCB from the free list or by allocating a new one.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_allocate_scb
id|aic7xxx_allocate_scb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scbp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|scb_size
op_assign
(paren
r_sizeof
(paren
r_struct
id|hw_scatterlist
)paren
op_star
id|AIC7XXX_MAX_SG
)paren
op_plus
l_int|12
op_plus
l_int|6
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|step
op_assign
id|PAGE_SIZE
op_div
l_int|1024
suffix:semicolon
r_int
r_int
id|scb_count
op_assign
l_int|0
suffix:semicolon
r_struct
id|hw_scatterlist
op_star
id|hsgp
suffix:semicolon
r_struct
id|aic7xxx_scb
op_star
id|scb_ap
suffix:semicolon
r_struct
id|aic7xxx_scb_dma
op_star
id|scb_dma
suffix:semicolon
r_int
r_char
op_star
id|bufs
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;numscbs
OL
id|p-&gt;scb_data-&gt;maxscbs
)paren
(brace
multiline_comment|/*&n;     * Calculate the optimal number of SCBs to allocate.&n;     *&n;     * NOTE: This formula works because the sizeof(sg_array) is always&n;     * 1024.  Therefore, scb_size * i would always be &gt; PAGE_SIZE *&n;     * (i/step).  The (i-1) allows the left hand side of the equation&n;     * to grow into the right hand side to a point of near perfect&n;     * efficiency since scb_size * (i -1) is growing slightly faster&n;     * than the right hand side.  If the number of SG array elements&n;     * is changed, this function may not be near so efficient any more.&n;     *&n;     * Since the DMA&squot;able buffers are now allocated in a seperate&n;     * chunk this algorithm has been modified to match.  The &squot;12&squot;&n;     * and &squot;6&squot; factors in scb_size are for the DMA&squot;able command byte&n;     * and sensebuffers respectively.  -DaveM&n;     */
r_for
c_loop
(paren
id|i
op_assign
id|step
suffix:semicolon
suffix:semicolon
id|i
op_mul_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
(paren
id|scb_size
op_star
(paren
id|i
op_minus
l_int|1
)paren
)paren
op_ge
(paren
(paren
id|PAGE_SIZE
op_star
(paren
id|i
op_div
id|step
)paren
)paren
op_minus
l_int|64
)paren
)paren
(brace
id|i
op_div_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|scb_count
op_assign
id|MIN
c_func
(paren
(paren
id|i
op_minus
l_int|1
)paren
comma
id|p-&gt;scb_data-&gt;maxscbs
op_minus
id|p-&gt;scb_data-&gt;numscbs
)paren
suffix:semicolon
id|scb_ap
op_assign
(paren
r_struct
id|aic7xxx_scb
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|aic7xxx_scb
)paren
op_star
id|scb_count
op_plus
r_sizeof
(paren
r_struct
id|aic7xxx_scb_dma
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_ap
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|scb_dma
op_assign
(paren
r_struct
id|aic7xxx_scb_dma
op_star
)paren
op_amp
id|scb_ap
(braket
id|scb_count
)braket
suffix:semicolon
id|hsgp
op_assign
(paren
r_struct
id|hw_scatterlist
op_star
)paren
id|pci_alloc_consistent
c_func
(paren
id|p-&gt;pdev
comma
id|scb_size
op_star
id|scb_count
comma
op_amp
id|scb_dma-&gt;dma_address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hsgp
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|scb_ap
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|bufs
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|hsgp
(braket
id|scb_count
op_star
id|AIC7XXX_MAX_SG
)braket
suffix:semicolon
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_if
c_cond
(paren
id|aic7xxx_verbose
OG
l_int|0xffff
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;numscbs
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Allocating initial %ld SCB structures.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|scb_count
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Allocating %ld additional SCB structures.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|scb_count
)paren
suffix:semicolon
)brace
macro_line|#endif
id|memset
c_func
(paren
id|scb_ap
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|aic7xxx_scb
)paren
op_star
id|scb_count
)paren
suffix:semicolon
id|scb_dma-&gt;dma_offset
op_assign
(paren
r_int
r_int
)paren
id|scb_dma-&gt;dma_address
op_minus
(paren
r_int
r_int
)paren
id|hsgp
suffix:semicolon
id|scb_dma-&gt;dma_len
op_assign
id|scb_size
op_star
id|scb_count
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|scb_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scbp
op_assign
op_amp
id|scb_ap
(braket
id|i
)braket
suffix:semicolon
id|scbp-&gt;hscb
op_assign
op_amp
id|p-&gt;scb_data-&gt;hscbs
(braket
id|p-&gt;scb_data-&gt;numscbs
)braket
suffix:semicolon
id|scbp-&gt;sg_list
op_assign
op_amp
id|hsgp
(braket
id|i
op_star
id|AIC7XXX_MAX_SG
)braket
suffix:semicolon
id|scbp-&gt;sense_cmd
op_assign
id|bufs
suffix:semicolon
id|scbp-&gt;cmnd
op_assign
id|bufs
op_plus
l_int|6
suffix:semicolon
id|bufs
op_add_assign
l_int|12
op_plus
l_int|6
suffix:semicolon
id|scbp-&gt;scb_dma
op_assign
id|scb_dma
suffix:semicolon
id|memset
c_func
(paren
id|scbp-&gt;hscb
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|aic7xxx_hwscb
)paren
)paren
suffix:semicolon
id|scbp-&gt;hscb-&gt;tag
op_assign
id|p-&gt;scb_data-&gt;numscbs
suffix:semicolon
multiline_comment|/*&n;       * Place in the scb array; never is removed&n;       */
id|p-&gt;scb_data-&gt;scb_array
(braket
id|p-&gt;scb_data-&gt;numscbs
op_increment
)braket
op_assign
id|scbp
suffix:semicolon
id|scbq_insert_tail
c_func
(paren
op_amp
id|p-&gt;scb_data-&gt;free_scbs
comma
id|scbp
)paren
suffix:semicolon
)brace
id|scbp-&gt;kmalloc_ptr
op_assign
id|scb_ap
suffix:semicolon
)brace
r_return
id|scb_count
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_queue_cmd_complete&n; *&n; * Description:&n; *   Due to race conditions present in the SCSI subsystem, it is easier&n; *   to queue completed commands, then call scsi_done() on them when&n; *   we&squot;re finished.  This function queues the completed commands.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_queue_cmd_complete
id|aic7xxx_queue_cmd_complete
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|cmd-&gt;host_scribble
op_assign
(paren
r_char
op_star
)paren
id|p-&gt;completeq.head
suffix:semicolon
id|p-&gt;completeq.head
op_assign
id|cmd
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_done_cmds_complete&n; *&n; * Description:&n; *   Process the completed command queue.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_done_cmds_complete
id|aic7xxx_done_cmds_complete
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,1,95)
r_int
r_int
id|cpu_flags
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|DRIVER_LOCK
r_while
c_loop
(paren
id|p-&gt;completeq.head
op_ne
l_int|NULL
)paren
(brace
id|cmd
op_assign
id|p-&gt;completeq.head
suffix:semicolon
id|p-&gt;completeq.head
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
id|DRIVER_UNLOCK
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_free_scb&n; *&n; * Description:&n; *   Free the scb and insert into the free scb list.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_free_scb
id|aic7xxx_free_scb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
id|scb-&gt;flags
op_assign
id|SCB_FREE
suffix:semicolon
id|scb-&gt;cmd
op_assign
l_int|NULL
suffix:semicolon
id|scb-&gt;sg_count
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;sg_length
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;tag_action
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;hscb-&gt;control
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;hscb-&gt;target_status
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;hscb-&gt;target_channel_lun
op_assign
id|SCB_LIST_NULL
suffix:semicolon
id|scbq_insert_head
c_func
(paren
op_amp
id|p-&gt;scb_data-&gt;free_scbs
comma
id|scb
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_done&n; *&n; * Description:&n; *   Calls the higher level scsi done function and frees the scb.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_done
id|aic7xxx_done
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
r_int
id|tindex
op_assign
id|TARGET_INDEX
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_struct
id|aic7xxx_scb
op_star
id|scbp
suffix:semicolon
r_int
r_char
id|queue_depth
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
OG
l_int|1
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|pci_unmap_sg
c_func
(paren
id|p-&gt;pdev
comma
id|sg
comma
id|cmd-&gt;use_sg
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
)paren
id|pci_unmap_single
c_func
(paren
id|p-&gt;pdev
comma
id|aic7xxx_mapping
c_func
(paren
id|cmd
)paren
comma
id|cmd-&gt;request_bufflen
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_SENSE
)paren
(brace
id|pci_unmap_single
c_func
(paren
id|p-&gt;pdev
comma
id|le32_to_cpu
c_func
(paren
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|address
)paren
comma
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_RECOVERY_SCB
)paren
(brace
id|p-&gt;flags
op_and_assign
op_complement
id|AHC_ABORT_PENDING
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_RESET
)paren
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_RESET
op_lshift
l_int|16
)paren
op_or
(paren
id|cmd-&gt;result
op_amp
l_int|0xffff
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_ABORT
)paren
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_RESET
op_lshift
l_int|16
)paren
op_or
(paren
id|cmd-&gt;result
op_amp
l_int|0xffff
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
id|DEVICE_SCANNED
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
op_logical_and
(paren
id|cmd-&gt;result
op_eq
id|DID_OK
)paren
)paren
(brace
r_char
op_star
id|buffer
suffix:semicolon
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_or_assign
id|DEVICE_PRESENT
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|buffer
op_assign
(paren
r_char
op_star
)paren
id|sg
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
)brace
r_else
(brace
id|buffer
op_assign
(paren
r_char
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
)brace
DECL|macro|WIDE_INQUIRY_BITS
mdefine_line|#define WIDE_INQUIRY_BITS 0x60
DECL|macro|SYNC_INQUIRY_BITS
mdefine_line|#define SYNC_INQUIRY_BITS 0x10
DECL|macro|SCSI_VERSION_BITS
mdefine_line|#define SCSI_VERSION_BITS 0x07
DECL|macro|SCSI_DT_BIT
mdefine_line|#define SCSI_DT_BIT       0x04
r_if
c_cond
(paren
(paren
id|buffer
(braket
l_int|7
)braket
op_amp
id|WIDE_INQUIRY_BITS
)paren
op_logical_and
(paren
id|p-&gt;features
op_amp
id|AHC_WIDE
)paren
)paren
(brace
id|p-&gt;needwdtr
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needwdtr_copy
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_width
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;needwdtr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needwdtr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic7xxx_set_width
c_func
(paren
id|p
comma
id|cmd-&gt;target
comma
id|cmd-&gt;channel
comma
id|cmd-&gt;lun
comma
id|MSG_EXT_WDTR_BUS_8_BIT
comma
(paren
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_GOAL
op_or
id|AHC_TRANS_CUR
)paren
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|buffer
(braket
l_int|7
)braket
op_amp
id|SYNC_INQUIRY_BITS
)paren
op_logical_and
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_offset
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_period
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_options
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|MAX_OFFSET_ULTRA2
suffix:semicolon
r_else
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
op_eq
id|MSG_EXT_WDTR_BUS_16_BIT
)paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|MAX_OFFSET_16BIT
suffix:semicolon
r_else
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|MAX_OFFSET_8BIT
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
(paren
id|buffer
(braket
l_int|2
)braket
op_amp
id|SCSI_VERSION_BITS
)paren
op_eq
l_int|3
)paren
op_logical_or
(paren
id|buffer
(braket
l_int|56
)braket
op_amp
id|SCSI_DT_BIT
)paren
op_logical_or
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
id|DEVICE_SCSI_3
)paren
)paren
op_logical_and
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_period
op_le
l_int|9
)paren
op_logical_and
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_options
)paren
)paren
(brace
id|p-&gt;needppr
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needppr_copy
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needwdtr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needwdtr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_or_assign
id|DEVICE_SCSI_3
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;needsdtr
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr_copy
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_assign
id|MAX
c_func
(paren
l_int|10
comma
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|p-&gt;needsdtr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_assign
l_int|255
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;       * This is needed to work around a sequencer bug for now.  Regardless&n;       * of the controller in use, if we have a Quantum drive, we need to&n;       * limit the speed to 80MByte/sec.  As soon as I get a fixed version&n;       * of the sequencer, this code will get yanked.&n;       */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|buffer
op_plus
l_int|8
comma
l_string|&quot;QUANTUM&quot;
comma
l_int|7
)paren
op_logical_and
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_assign
id|MAX
c_func
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
comma
l_int|10
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
op_assign
l_int|0
suffix:semicolon
id|p-&gt;needppr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needppr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr_copy
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needwdtr
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needwdtr_copy
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;       * Get the INQUIRY checksum.  We use this on Ultra 160/m&n;       * and older devices both.  It allows us to drop speed on any bus type&n;       * while at the same time giving us the needed domain validation for&n;       * Ultra 160/m&n;       *&n;       * Note: We only get the checksum and set the SCANNED bit if this is&n;       * one of our dtr commands.  If we don&squot;t do this, then we end up&n;       * getting bad checksum results on the mid-level SCSI code&squot;s INQUIRY&n;       * commands.&n;       */
r_if
c_cond
(paren
id|p-&gt;dev_dtr_cmnd
(braket
id|tindex
)braket
op_eq
id|cmd
)paren
(brace
r_int
r_int
id|checksum
op_assign
l_int|0
suffix:semicolon
r_int
op_star
id|ibuffer
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|ibuffer
op_assign
(paren
r_int
op_star
)paren
id|buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|cmd-&gt;request_bufflen
op_rshift
l_int|2
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|checksum
op_add_assign
id|ibuffer
(braket
id|i
)braket
suffix:semicolon
)brace
id|p-&gt;dev_checksum
(braket
id|tindex
)braket
op_assign
id|checksum
suffix:semicolon
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_or_assign
id|DEVICE_SCANNED
suffix:semicolon
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_or_assign
id|DEVICE_PRINT_DTR
suffix:semicolon
)brace
DECL|macro|WIDE_INQUIRY_BITS
macro_line|#undef WIDE_INQUIRY_BITS
DECL|macro|SYNC_INQUIRY_BITS
macro_line|#undef SYNC_INQUIRY_BITS
DECL|macro|SCSI_VERSION_BITS
macro_line|#undef SCSI_VERSION_BITS
DECL|macro|SCSI_DT_BIT
macro_line|#undef SCSI_DT_BIT
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_BITS
)paren
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_int
id|message_error
op_assign
id|FALSE
suffix:semicolon
id|mask
op_assign
l_int|0x01
op_lshift
id|tindex
suffix:semicolon
multiline_comment|/*&n;     * Check to see if we get an invalid message or a message error&n;     * after failing to negotiate a wide or sync transfer message.&n;     */
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_SENSE
)paren
op_logical_and
(paren
(paren
id|scb-&gt;cmd-&gt;sense_buffer
(braket
l_int|12
)braket
op_eq
l_int|0x43
)paren
op_logical_or
multiline_comment|/* INVALID_MESSAGE */
(paren
id|scb-&gt;cmd-&gt;sense_buffer
(braket
l_int|12
)braket
op_eq
l_int|0x49
)paren
)paren
)paren
multiline_comment|/* MESSAGE_ERROR  */
(brace
id|message_error
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_WDTR
)paren
(brace
id|p-&gt;dtr_pending
op_and_assign
op_complement
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|message_error
)paren
(brace
r_if
c_cond
(paren
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
op_logical_and
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
id|DEVICE_PRINT_DTR
)paren
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Device failed to complete Wide Negotiation &quot;
l_string|&quot;processing and&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;returned a sense error code for invalid message, &quot;
l_string|&quot;disabling future&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Wide negotiation to this device.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
id|p-&gt;needwdtr
op_and_assign
op_complement
id|mask
suffix:semicolon
id|p-&gt;needwdtr_copy
op_and_assign
op_complement
id|mask
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_SDTR
)paren
(brace
id|p-&gt;dtr_pending
op_and_assign
op_complement
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|message_error
)paren
(brace
r_if
c_cond
(paren
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
op_logical_and
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
id|DEVICE_PRINT_DTR
)paren
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Device failed to complete Sync Negotiation &quot;
l_string|&quot;processing and&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;returned a sense error code for invalid message, &quot;
l_string|&quot;disabling future&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Sync negotiation to this device.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_and_assign
op_complement
id|DEVICE_PRINT_DTR
suffix:semicolon
)brace
id|p-&gt;needsdtr
op_and_assign
op_complement
id|mask
suffix:semicolon
id|p-&gt;needsdtr_copy
op_and_assign
op_complement
id|mask
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_PPR
)paren
(brace
id|p-&gt;dtr_pending
op_and_assign
op_complement
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|message_error
)paren
(brace
r_if
c_cond
(paren
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
op_logical_and
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
id|DEVICE_PRINT_DTR
)paren
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Device failed to complete Parallel Protocol &quot;
l_string|&quot;Request processing and&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;returned a sense error code for invalid message, &quot;
l_string|&quot;disabling future&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Parallel Protocol Request negotiation to this &quot;
l_string|&quot;device.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;         * Disable PPR negotiation and revert back to WDTR and SDTR setup&n;         */
id|p-&gt;needppr
op_and_assign
op_complement
id|mask
suffix:semicolon
id|p-&gt;needppr_copy
op_and_assign
op_complement
id|mask
suffix:semicolon
id|p-&gt;needsdtr
op_or_assign
id|mask
suffix:semicolon
id|p-&gt;needsdtr_copy
op_or_assign
id|mask
suffix:semicolon
id|p-&gt;needwdtr
op_or_assign
id|mask
suffix:semicolon
id|p-&gt;needwdtr_copy
op_or_assign
id|mask
suffix:semicolon
)brace
)brace
)brace
id|queue_depth
op_assign
id|p-&gt;dev_temp_queue_depth
(braket
id|tindex
)braket
suffix:semicolon
r_if
c_cond
(paren
id|queue_depth
op_ge
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
)paren
(brace
id|scbp
op_assign
id|scbq_remove_head
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|tindex
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scbp
)paren
(brace
r_if
c_cond
(paren
id|queue_depth
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;         * Give extra preference to untagged devices, such as CD-R devices&n;         * This makes it more likely that a drive *won&squot;t* stuff up while&n;         * waiting on data at a critical time, such as CD-R writing and&n;         * audio CD ripping operations.  Should also benefit tape drives.&n;         */
id|scbq_insert_head
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|scbp
)paren
suffix:semicolon
)brace
r_else
(brace
id|scbq_insert_tail
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|scbp
)paren
suffix:semicolon
)brace
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_if
c_cond
(paren
id|aic7xxx_verbose
OG
l_int|0xffff
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Moving SCB from delayed to waiting queue.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scbp
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|queue_depth
OG
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
)paren
(brace
id|scbp
op_assign
id|scbq_remove_head
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|tindex
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scbp
)paren
id|scbq_insert_tail
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|scbp
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;tag_action
)paren
op_logical_and
(paren
id|p-&gt;tagenable
op_amp
(paren
l_int|1
op_lshift
id|tindex
)paren
)paren
)paren
(brace
id|p-&gt;dev_temp_queue_depth
(braket
id|tindex
)braket
op_assign
id|p-&gt;dev_max_queue_depth
(braket
id|tindex
)braket
suffix:semicolon
)brace
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
op_decrement
suffix:semicolon
id|p-&gt;activescbs
op_decrement
suffix:semicolon
(brace
r_int
id|actual
suffix:semicolon
multiline_comment|/*&n;     * XXX: we should actually know how much actually transferred&n;     * XXX: for each command, but apparently that&squot;s too difficult.&n;     * &n;     * We set a lower limit of 512 bytes on the transfer length.  We&n;     * ignore anything less than this because we don&squot;t have a real&n;     * reason to count it.  Read/Writes to tapes are usually about 20K&n;     * and disks are a minimum of 512 bytes unless you want to count&n;     * non-read/write commands (such as TEST_UNIT_READY) which we don&squot;t&n;     */
id|actual
op_assign
id|scb-&gt;sg_length
suffix:semicolon
r_if
c_cond
(paren
(paren
id|actual
op_ge
l_int|512
)paren
op_logical_and
(paren
(paren
(paren
id|cmd-&gt;result
op_rshift
l_int|16
)paren
op_amp
l_int|0xf
)paren
op_eq
id|DID_OK
)paren
)paren
(brace
r_struct
id|aic7xxx_xferstats
op_star
id|sp
suffix:semicolon
macro_line|#ifdef AIC7XXX_PROC_STATS
r_int
op_star
id|ptr
suffix:semicolon
r_int
id|x
suffix:semicolon
macro_line|#endif /* AIC7XXX_PROC_STATS */
id|sp
op_assign
op_amp
id|p-&gt;stats
(braket
id|TARGET_INDEX
c_func
(paren
id|cmd
)paren
)braket
suffix:semicolon
multiline_comment|/*&n;       * For block devices, cmd-&gt;request.cmd is always == either READ or&n;       * WRITE.  For character devices, this isn&squot;t always set properly, so&n;       * we check data_cmnd[0].  This catches the conditions for st.c, but&n;       * I&squot;m still not sure if request.cmd is valid for sg devices.&n;       */
r_if
c_cond
(paren
(paren
id|cmd-&gt;request.cmd
op_eq
id|WRITE
)paren
op_logical_or
(paren
id|cmd-&gt;data_cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_6
)paren
op_logical_or
(paren
id|cmd-&gt;data_cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_FILEMARKS
)paren
)paren
(brace
id|sp-&gt;w_total
op_increment
suffix:semicolon
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_if
c_cond
(paren
(paren
id|sp-&gt;w_total
OG
l_int|16
)paren
op_logical_and
(paren
id|aic7xxx_verbose
OG
l_int|0xffff
)paren
)paren
id|aic7xxx_verbose
op_and_assign
l_int|0xffff
suffix:semicolon
macro_line|#endif
macro_line|#ifdef AIC7XXX_PROC_STATS
id|ptr
op_assign
id|sp-&gt;w_bins
suffix:semicolon
macro_line|#endif /* AIC7XXX_PROC_STATS */
)brace
r_else
(brace
id|sp-&gt;r_total
op_increment
suffix:semicolon
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_if
c_cond
(paren
(paren
id|sp-&gt;r_total
OG
l_int|16
)paren
op_logical_and
(paren
id|aic7xxx_verbose
OG
l_int|0xffff
)paren
)paren
id|aic7xxx_verbose
op_and_assign
l_int|0xffff
suffix:semicolon
macro_line|#endif
macro_line|#ifdef AIC7XXX_PROC_STATS
id|ptr
op_assign
id|sp-&gt;r_bins
suffix:semicolon
macro_line|#endif /* AIC7XXX_PROC_STATS */
)brace
macro_line|#ifdef AIC7XXX_PROC_STATS
id|x
op_assign
op_minus
l_int|11
suffix:semicolon
r_while
c_loop
(paren
id|actual
)paren
(brace
id|actual
op_rshift_assign
l_int|1
suffix:semicolon
id|x
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
OL
l_int|0
)paren
(brace
id|ptr
(braket
l_int|0
)braket
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|x
OG
l_int|7
)paren
(brace
id|ptr
(braket
l_int|7
)braket
op_increment
suffix:semicolon
)brace
r_else
(brace
id|ptr
(braket
id|x
)braket
op_increment
suffix:semicolon
)brace
macro_line|#endif /* AIC7XXX_PROC_STATS */
)brace
)brace
id|aic7xxx_free_scb
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
id|aic7xxx_queue_cmd_complete
c_func
(paren
id|p
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_run_done_queue&n; *&n; * Description:&n; *   Calls the aic7xxx_done() for the Scsi_Cmnd of each scb in the&n; *   aborted list, and adds each scb to the free list.  If complete&n; *   is TRUE, we also process the commands complete list.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_run_done_queue
id|aic7xxx_run_done_queue
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
multiline_comment|/*complete*/
r_int
id|complete
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scb
suffix:semicolon
r_int
id|i
comma
id|found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;scb_data-&gt;numscbs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_QUEUED_FOR_DONE
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
(paren
id|VERBOSE_ABORT_PROCESS
op_or
id|VERBOSE_RESET_PROCESS
)paren
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Aborting scb %d&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|found
op_increment
suffix:semicolon
id|aic7xxx_done
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
(paren
id|VERBOSE_ABORT_RETURN
op_or
id|VERBOSE_RESET_RETURN
)paren
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;%d commands found and queued for &quot;
l_string|&quot;completion.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|found
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|complete
)paren
(brace
id|aic7xxx_done_cmds_complete
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_abort_waiting_scb&n; *&n; * Description:&n; *   Manipulate the waiting for selection list and return the&n; *   scb that follows the one that we remove.&n; *-F*************************************************************************/
r_static
r_int
r_char
DECL|function|aic7xxx_abort_waiting_scb
id|aic7xxx_abort_waiting_scb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
comma
r_int
r_char
id|scbpos
comma
r_int
r_char
id|prev
)paren
(brace
r_int
r_char
id|curscb
comma
id|next
suffix:semicolon
multiline_comment|/*&n;   * Select the SCB we want to abort and pull the next pointer out of it.&n;   */
id|curscb
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCBPTR
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|scbpos
comma
id|SCBPTR
)paren
suffix:semicolon
id|next
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_NEXT
)paren
suffix:semicolon
id|aic7xxx_add_curscb_to_free_list
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;   * Update the waiting list&n;   */
r_if
c_cond
(paren
id|prev
op_eq
id|SCB_LIST_NULL
)paren
(brace
multiline_comment|/*&n;     * First in the list&n;     */
id|aic_outb
c_func
(paren
id|p
comma
id|next
comma
id|WAITING_SCBH
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;     * Select the scb that pointed to us and update its next pointer.&n;     */
id|aic_outb
c_func
(paren
id|p
comma
id|prev
comma
id|SCBPTR
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|next
comma
id|SCB_NEXT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * Point us back at the original scb position and inform the SCSI&n;   * system that the command has been aborted.&n;   */
id|aic_outb
c_func
(paren
id|p
comma
id|curscb
comma
id|SCBPTR
)paren
suffix:semicolon
r_return
(paren
id|next
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_search_qinfifo&n; *&n; * Description:&n; *   Search the queue-in FIFO for matching SCBs and conditionally&n; *   requeue.  Returns the number of matching SCBs.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_search_qinfifo
id|aic7xxx_search_qinfifo
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|target
comma
r_int
id|channel
comma
r_int
id|lun
comma
r_int
r_char
id|tag
comma
r_int
id|flags
comma
r_int
id|requeue
comma
r_volatile
id|scb_queue_type
op_star
id|queue
)paren
(brace
r_int
id|found
suffix:semicolon
r_int
r_char
id|qinpos
comma
id|qintail
suffix:semicolon
r_struct
id|aic7xxx_scb
op_star
id|scbp
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
id|qinpos
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|QINPOS
)paren
suffix:semicolon
id|qintail
op_assign
id|p-&gt;qinfifonext
suffix:semicolon
id|p-&gt;qinfifonext
op_assign
id|qinpos
suffix:semicolon
r_while
c_loop
(paren
id|qinpos
op_ne
id|qintail
)paren
(brace
id|scbp
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|p-&gt;qinfifo
(braket
id|qinpos
op_increment
)braket
)braket
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_match_scb
c_func
(paren
id|p
comma
id|scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
)paren
)paren
(brace
multiline_comment|/*&n;        * We found an scb that needs to be removed.&n;        */
r_if
c_cond
(paren
id|requeue
op_logical_and
(paren
id|queue
op_ne
l_int|NULL
)paren
)paren
(brace
r_if
c_cond
(paren
id|scbp-&gt;flags
op_amp
id|SCB_WAITINGQ
)paren
(brace
id|scbq_remove
c_func
(paren
id|queue
comma
id|scbp
)paren
suffix:semicolon
id|scbq_remove
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|scbp
)paren
suffix:semicolon
id|scbq_remove
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|TARGET_INDEX
c_func
(paren
id|scbp-&gt;cmd
)paren
)braket
comma
id|scbp
)paren
suffix:semicolon
id|p-&gt;dev_active_cmds
(braket
id|TARGET_INDEX
c_func
(paren
id|scbp-&gt;cmd
)paren
)braket
op_increment
suffix:semicolon
id|p-&gt;activescbs
op_increment
suffix:semicolon
)brace
id|scbq_insert_tail
c_func
(paren
id|queue
comma
id|scbp
)paren
suffix:semicolon
id|p-&gt;dev_active_cmds
(braket
id|TARGET_INDEX
c_func
(paren
id|scbp-&gt;cmd
)paren
)braket
op_decrement
suffix:semicolon
id|p-&gt;activescbs
op_decrement
suffix:semicolon
id|scbp-&gt;flags
op_or_assign
id|SCB_WAITINGQ
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|scbp-&gt;tag_action
op_amp
id|TAG_ENB
)paren
)paren
(brace
id|aic7xxx_index_busy_target
c_func
(paren
id|p
comma
id|scbp-&gt;hscb-&gt;target_channel_lun
comma
id|TRUE
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|requeue
)paren
(brace
id|p-&gt;qinfifo
(braket
id|p-&gt;qinfifonext
op_increment
)braket
op_assign
id|scbp-&gt;hscb-&gt;tag
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;         * Preserve any SCB_RECOVERY_SCB flags on this scb then set the&n;         * flags we were called with, presumeably so aic7xxx_run_done_queue&n;         * can find this scb&n;         */
id|scbp-&gt;flags
op_assign
id|flags
op_or
(paren
id|scbp-&gt;flags
op_amp
id|SCB_RECOVERY_SCB
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_index_busy_target
c_func
(paren
id|p
comma
id|scbp-&gt;hscb-&gt;target_channel_lun
comma
id|FALSE
)paren
op_eq
id|scbp-&gt;hscb-&gt;tag
)paren
(brace
id|aic7xxx_index_busy_target
c_func
(paren
id|p
comma
id|scbp-&gt;hscb-&gt;target_channel_lun
comma
id|TRUE
)paren
suffix:semicolon
)brace
)brace
id|found
op_increment
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;qinfifo
(braket
id|p-&gt;qinfifonext
op_increment
)braket
op_assign
id|scbp-&gt;hscb-&gt;tag
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Now that we&squot;ve done the work, clear out any left over commands in the&n;   * qinfifo and update the KERNEL_QINPOS down on the card.&n;   *&n;   *  NOTE: This routine expect the sequencer to already be paused when&n;   *        it is run....make sure it&squot;s that way!&n;   */
id|qinpos
op_assign
id|p-&gt;qinfifonext
suffix:semicolon
r_while
c_loop
(paren
id|qinpos
op_ne
id|qintail
)paren
(brace
id|p-&gt;qinfifo
(braket
id|qinpos
op_increment
)braket
op_assign
id|SCB_LIST_NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_QUEUE_REGS
)paren
id|aic_outb
c_func
(paren
id|p
comma
id|p-&gt;qinfifonext
comma
id|HNSCB_QOFF
)paren
suffix:semicolon
r_else
id|aic_outb
c_func
(paren
id|p
comma
id|p-&gt;qinfifonext
comma
id|KERNEL_QINPOS
)paren
suffix:semicolon
r_return
(paren
id|found
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_scb_on_qoutfifo&n; *&n; * Description:&n; *   Is the scb that was passed to us currently on the qoutfifo?&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_scb_on_qoutfifo
id|aic7xxx_scb_on_qoutfifo
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|p-&gt;qoutfifo
(braket
(paren
id|p-&gt;qoutfifonext
op_plus
id|i
)paren
op_amp
l_int|0xff
)braket
op_ne
id|SCB_LIST_NULL
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;qoutfifo
(braket
(paren
id|p-&gt;qoutfifonext
op_plus
id|i
)paren
op_amp
l_int|0xff
)braket
op_eq
id|scb-&gt;hscb-&gt;tag
)paren
(brace
r_return
id|TRUE
suffix:semicolon
)brace
r_else
id|i
op_increment
suffix:semicolon
)brace
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_reset_device&n; *&n; * Description:&n; *   The device at the given target/channel has been reset.  Abort&n; *   all active and queued scbs for that target/channel.  This function&n; *   need not worry about linked next pointers because if was a MSG_ABORT_TAG&n; *   then we had a tagged command (no linked next), if it was MSG_ABORT or&n; *   MSG_BUS_DEV_RESET then the device won&squot;t know about any commands any more&n; *   and no busy commands will exist, and if it was a bus reset, then nothing&n; *   knows about any linked next commands any more.  In all cases, we don&squot;t&n; *   need to worry about the linked next or busy scb, we just need to clear&n; *   them.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_reset_device
id|aic7xxx_reset_device
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|target
comma
r_int
id|channel
comma
r_int
id|lun
comma
r_int
r_char
id|tag
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scbp
suffix:semicolon
r_int
r_char
id|active_scb
comma
id|tcl
suffix:semicolon
r_int
id|i
op_assign
l_int|0
comma
id|j
comma
id|init_lists
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/*&n;   * Restore this when we&squot;re done&n;   */
id|active_scb
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCBPTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
(paren
id|VERBOSE_RESET_PROCESS
op_or
id|VERBOSE_ABORT_PROCESS
)paren
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Reset device, active_scb %d&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
comma
id|active_scb
)paren
suffix:semicolon
multiline_comment|/*&n;   * Deal with the busy target and linked next issues.&n;   */
(brace
r_int
id|min_target
comma
id|max_target
suffix:semicolon
r_struct
id|aic7xxx_scb
op_star
id|scbp
comma
op_star
id|prev_scbp
suffix:semicolon
multiline_comment|/* Make all targets &squot;relative&squot; to bus A. */
r_if
c_cond
(paren
id|target
op_eq
id|ALL_TARGETS
)paren
(brace
r_switch
c_cond
(paren
id|channel
)paren
(brace
r_case
l_int|0
suffix:colon
id|min_target
op_assign
l_int|0
suffix:semicolon
id|max_target
op_assign
(paren
id|p-&gt;features
op_amp
id|AHC_WIDE
)paren
ques
c_cond
l_int|15
suffix:colon
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|min_target
op_assign
l_int|8
suffix:semicolon
id|max_target
op_assign
l_int|15
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ALL_CHANNELS
suffix:colon
r_default
suffix:colon
id|min_target
op_assign
l_int|0
suffix:semicolon
id|max_target
op_assign
(paren
id|p-&gt;features
op_amp
(paren
id|AHC_TWIN
op_or
id|AHC_WIDE
)paren
)paren
ques
c_cond
l_int|15
suffix:colon
l_int|7
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|min_target
op_assign
id|target
op_or
(paren
id|channel
op_lshift
l_int|3
)paren
suffix:semicolon
id|max_target
op_assign
id|min_target
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|min_target
suffix:semicolon
id|i
op_le
id|max_target
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|p-&gt;scsi_id
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
(paren
id|VERBOSE_ABORT_PROCESS
op_or
id|VERBOSE_RESET_PROCESS
)paren
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Cleaning up status information &quot;
l_string|&quot;and delayed_scbs.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|i
comma
id|lun
)paren
suffix:semicolon
id|p-&gt;dev_flags
(braket
id|i
)braket
op_and_assign
op_complement
(paren
id|BUS_DEVICE_RESET_PENDING
op_or
id|DEVICE_PARITY_ERROR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|SCB_LIST_NULL
)paren
(brace
id|p-&gt;dev_flags
(braket
id|i
)braket
op_or_assign
id|DEVICE_PRINT_DTR
op_or
id|DEVICE_RESET_DELAY
suffix:semicolon
id|p-&gt;dev_expires
(braket
id|i
)braket
op_assign
id|jiffies
op_plus
(paren
l_int|4
op_star
id|HZ
)paren
suffix:semicolon
id|p-&gt;dev_timer_active
op_or_assign
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
id|p-&gt;dev_last_queue_full_count
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|p-&gt;dev_last_queue_full
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|p-&gt;dev_temp_queue_depth
(braket
id|i
)braket
op_assign
id|p-&gt;dev_max_queue_depth
(braket
id|i
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|MAX_LUNS
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|channel
op_eq
l_int|1
)paren
id|tcl
op_assign
(paren
(paren
id|i
op_lshift
l_int|4
)paren
op_amp
l_int|0x70
)paren
op_or
(paren
id|channel
op_lshift
l_int|3
)paren
op_or
id|j
suffix:semicolon
r_else
id|tcl
op_assign
(paren
id|i
op_lshift
l_int|4
)paren
op_or
(paren
id|channel
op_lshift
l_int|3
)paren
op_or
id|j
suffix:semicolon
r_if
c_cond
(paren
(paren
id|aic7xxx_index_busy_target
c_func
(paren
id|p
comma
id|tcl
comma
id|FALSE
)paren
op_eq
id|tag
)paren
op_logical_or
(paren
id|tag
op_eq
id|SCB_LIST_NULL
)paren
)paren
id|aic7xxx_index_busy_target
c_func
(paren
id|p
comma
id|tcl
comma
multiline_comment|/* unbusy */
id|TRUE
)paren
suffix:semicolon
)brace
id|j
op_assign
l_int|0
suffix:semicolon
id|prev_scbp
op_assign
l_int|NULL
suffix:semicolon
id|scbp
op_assign
id|p-&gt;delayed_scbs
(braket
id|i
)braket
dot
id|head
suffix:semicolon
r_while
c_loop
(paren
(paren
id|scbp
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|j
op_increment
op_le
(paren
id|p-&gt;scb_data-&gt;numscbs
op_plus
l_int|1
)paren
)paren
)paren
(brace
id|prev_scbp
op_assign
id|scbp
suffix:semicolon
id|scbp
op_assign
id|scbp-&gt;q_next
suffix:semicolon
r_if
c_cond
(paren
id|prev_scbp
op_eq
id|scbp
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
(paren
id|VERBOSE_ABORT
op_or
id|VERBOSE_RESET
)paren
)paren
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Yikes!! scb-&gt;q_next == scb &quot;
l_string|&quot;in the delayed_scbs queue!&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|i
comma
id|lun
)paren
suffix:semicolon
id|scbp
op_assign
l_int|NULL
suffix:semicolon
id|prev_scbp-&gt;q_next
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;delayed_scbs
(braket
id|i
)braket
dot
id|tail
op_assign
id|prev_scbp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_match_scb
c_func
(paren
id|p
comma
id|prev_scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
)paren
)paren
(brace
id|scbq_remove
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|i
)braket
comma
id|prev_scbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev_scbp-&gt;flags
op_amp
id|SCB_WAITINGQ
)paren
(brace
id|p-&gt;dev_active_cmds
(braket
id|i
)braket
op_increment
suffix:semicolon
id|p-&gt;activescbs
op_increment
suffix:semicolon
)brace
id|prev_scbp-&gt;flags
op_and_assign
op_complement
(paren
id|SCB_ACTIVE
op_or
id|SCB_WAITINGQ
)paren
suffix:semicolon
id|prev_scbp-&gt;flags
op_or_assign
id|SCB_RESET
op_or
id|SCB_QUEUED_FOR_DONE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|j
OG
(paren
id|p-&gt;scb_data-&gt;maxscbs
op_plus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
(paren
id|VERBOSE_ABORT
op_or
id|VERBOSE_RESET
)paren
)paren
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Yikes!! There&squot;s a loop in the &quot;
l_string|&quot;delayed_scbs queue!&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|i
comma
id|lun
)paren
suffix:semicolon
id|scbq_init
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;dev_timer_active
op_amp
(paren
l_int|0x01
op_lshift
id|MAX_TARGETS
)paren
)paren
op_logical_or
id|time_after_eq
c_func
(paren
id|p-&gt;dev_timer.expires
comma
id|p-&gt;dev_expires
(braket
id|i
)braket
)paren
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|p-&gt;dev_timer
comma
id|p-&gt;dev_expires
(braket
id|i
)braket
)paren
suffix:semicolon
id|p-&gt;dev_timer_active
op_or_assign
(paren
l_int|0x01
op_lshift
id|MAX_TARGETS
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
(paren
id|VERBOSE_ABORT_PROCESS
op_or
id|VERBOSE_RESET_PROCESS
)paren
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Cleaning QINFIFO.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|aic7xxx_search_qinfifo
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
comma
id|SCB_RESET
op_or
id|SCB_QUEUED_FOR_DONE
comma
multiline_comment|/* requeue */
id|FALSE
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n; *  Search the waiting_scbs queue for matches, this catches any SCB_QUEUED&n; *  ABORT/RESET commands.&n; */
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
(paren
id|VERBOSE_ABORT_PROCESS
op_or
id|VERBOSE_RESET_PROCESS
)paren
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Cleaning waiting_scbs.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
(brace
r_struct
id|aic7xxx_scb
op_star
id|scbp
comma
op_star
id|prev_scbp
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
id|prev_scbp
op_assign
l_int|NULL
suffix:semicolon
id|scbp
op_assign
id|p-&gt;waiting_scbs.head
suffix:semicolon
r_while
c_loop
(paren
(paren
id|scbp
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|j
op_increment
op_le
(paren
id|p-&gt;scb_data-&gt;numscbs
op_plus
l_int|1
)paren
)paren
)paren
(brace
id|prev_scbp
op_assign
id|scbp
suffix:semicolon
id|scbp
op_assign
id|scbp-&gt;q_next
suffix:semicolon
r_if
c_cond
(paren
id|prev_scbp
op_eq
id|scbp
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
(paren
id|VERBOSE_ABORT
op_or
id|VERBOSE_RESET
)paren
)paren
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Yikes!! scb-&gt;q_next == scb &quot;
l_string|&quot;in the waiting_scbs queue!&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scbp
)paren
)paren
suffix:semicolon
id|scbp
op_assign
l_int|NULL
suffix:semicolon
id|prev_scbp-&gt;q_next
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;waiting_scbs.tail
op_assign
id|prev_scbp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_match_scb
c_func
(paren
id|p
comma
id|prev_scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
)paren
)paren
(brace
id|scbq_remove
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|prev_scbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev_scbp-&gt;flags
op_amp
id|SCB_WAITINGQ
)paren
(brace
id|p-&gt;dev_active_cmds
(braket
id|TARGET_INDEX
c_func
(paren
id|prev_scbp-&gt;cmd
)paren
)braket
op_increment
suffix:semicolon
id|p-&gt;activescbs
op_increment
suffix:semicolon
)brace
id|prev_scbp-&gt;flags
op_and_assign
op_complement
(paren
id|SCB_ACTIVE
op_or
id|SCB_WAITINGQ
)paren
suffix:semicolon
id|prev_scbp-&gt;flags
op_or_assign
id|SCB_RESET
op_or
id|SCB_QUEUED_FOR_DONE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|j
OG
(paren
id|p-&gt;scb_data-&gt;maxscbs
op_plus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
(paren
id|VERBOSE_ABORT
op_or
id|VERBOSE_RESET
)paren
)paren
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Yikes!! There&squot;s a loop in the &quot;
l_string|&quot;waiting_scbs queue!&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|scbq_init
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Search waiting for selection list.&n;   */
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
(paren
id|VERBOSE_ABORT_PROCESS
op_or
id|VERBOSE_RESET_PROCESS
)paren
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Cleaning waiting for selection &quot;
l_string|&quot;list.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
(brace
r_int
r_char
id|next
comma
id|prev
comma
id|scb_index
suffix:semicolon
id|next
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|WAITING_SCBH
)paren
suffix:semicolon
multiline_comment|/* Start at head of list. */
id|prev
op_assign
id|SCB_LIST_NULL
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|next
op_ne
id|SCB_LIST_NULL
)paren
op_logical_and
(paren
id|j
op_increment
op_le
(paren
id|p-&gt;scb_data-&gt;maxscbs
op_plus
l_int|1
)paren
)paren
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|next
comma
id|SCBPTR
)paren
suffix:semicolon
id|scb_index
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_index
op_ge
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
multiline_comment|/*&n;        * No aic7xxx_verbose check here.....we want to see this since it&n;        * means either the kernel driver or the sequencer screwed things up&n;        */
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Waiting List inconsistency; SCB index=%d, &quot;
l_string|&quot;numscbs=%d&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
comma
id|scb_index
comma
id|p-&gt;scb_data-&gt;numscbs
)paren
suffix:semicolon
id|next
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_NEXT
)paren
suffix:semicolon
id|aic7xxx_add_curscb_to_free_list
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
id|scbp
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_match_scb
c_func
(paren
id|p
comma
id|scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
)paren
)paren
(brace
id|next
op_assign
id|aic7xxx_abort_waiting_scb
c_func
(paren
id|p
comma
id|scbp
comma
id|next
comma
id|prev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scbp-&gt;flags
op_amp
id|SCB_WAITINGQ
)paren
(brace
id|p-&gt;dev_active_cmds
(braket
id|TARGET_INDEX
c_func
(paren
id|scbp-&gt;cmd
)paren
)braket
op_increment
suffix:semicolon
id|p-&gt;activescbs
op_increment
suffix:semicolon
)brace
id|scbp-&gt;flags
op_and_assign
op_complement
(paren
id|SCB_ACTIVE
op_or
id|SCB_WAITINGQ
)paren
suffix:semicolon
id|scbp-&gt;flags
op_or_assign
id|SCB_RESET
op_or
id|SCB_QUEUED_FOR_DONE
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_eq
id|SCB_LIST_NULL
)paren
(brace
multiline_comment|/*&n;             * This is either the first scb on the waiting list, or we&n;             * have already yanked the first and haven&squot;t left any behind.&n;             * Either way, we need to turn off the selection hardware if&n;             * it isn&squot;t already off.&n;             */
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISEQ
)paren
op_amp
op_complement
id|ENSELO
comma
id|SCSISEQ
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSELTIMEO
comma
id|CLRSINT1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|prev
op_assign
id|next
suffix:semicolon
id|next
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_NEXT
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|j
OG
(paren
id|p-&gt;scb_data-&gt;maxscbs
op_plus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Yikes!!  There is a loop in the waiting for &quot;
l_string|&quot;selection list!&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|init_lists
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Go through disconnected list and remove any entries we have queued&n;   * for completion, zeroing their control byte too.&n;   */
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
(paren
id|VERBOSE_ABORT_PROCESS
op_or
id|VERBOSE_RESET_PROCESS
)paren
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Cleaning disconnected scbs &quot;
l_string|&quot;list.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|AHC_PAGESCBS
)paren
(brace
r_int
r_char
id|next
comma
id|prev
comma
id|scb_index
suffix:semicolon
id|next
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|DISCONNECTED_SCBH
)paren
suffix:semicolon
id|prev
op_assign
id|SCB_LIST_NULL
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|next
op_ne
id|SCB_LIST_NULL
)paren
op_logical_and
(paren
id|j
op_increment
op_le
(paren
id|p-&gt;scb_data-&gt;maxscbs
op_plus
l_int|1
)paren
)paren
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|next
comma
id|SCBPTR
)paren
suffix:semicolon
id|scb_index
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_index
OG
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Disconnected List inconsistency; SCB index=%d, &quot;
l_string|&quot;numscbs=%d&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
comma
id|scb_index
comma
id|p-&gt;scb_data-&gt;numscbs
)paren
suffix:semicolon
id|next
op_assign
id|aic7xxx_rem_scb_from_disc_list
c_func
(paren
id|p
comma
id|next
comma
id|prev
)paren
suffix:semicolon
)brace
r_else
(brace
id|scbp
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_match_scb
c_func
(paren
id|p
comma
id|scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
)paren
)paren
(brace
id|next
op_assign
id|aic7xxx_rem_scb_from_disc_list
c_func
(paren
id|p
comma
id|next
comma
id|prev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scbp-&gt;flags
op_amp
id|SCB_WAITINGQ
)paren
(brace
id|p-&gt;dev_active_cmds
(braket
id|TARGET_INDEX
c_func
(paren
id|scbp-&gt;cmd
)paren
)braket
op_increment
suffix:semicolon
id|p-&gt;activescbs
op_increment
suffix:semicolon
)brace
id|scbp-&gt;flags
op_and_assign
op_complement
(paren
id|SCB_ACTIVE
op_or
id|SCB_WAITINGQ
)paren
suffix:semicolon
id|scbp-&gt;flags
op_or_assign
id|SCB_RESET
op_or
id|SCB_QUEUED_FOR_DONE
suffix:semicolon
id|scbp-&gt;hscb-&gt;control
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|prev
op_assign
id|next
suffix:semicolon
id|next
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_NEXT
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|j
OG
(paren
id|p-&gt;scb_data-&gt;maxscbs
op_plus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Yikes!!  There is a loop in the disconnected list!&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|init_lists
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Walk the free list making sure no entries on the free list have&n;   * a valid SCB_TAG value or SCB_CONTROL byte.&n;   */
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|AHC_PAGESCBS
)paren
(brace
r_int
r_char
id|next
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
id|next
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|FREE_SCBH
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|next
op_ge
id|p-&gt;scb_data-&gt;maxhscbs
)paren
op_logical_and
(paren
id|next
op_ne
id|SCB_LIST_NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Bogus FREE_SCBH!.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|init_lists
op_assign
id|TRUE
suffix:semicolon
id|next
op_assign
id|SCB_LIST_NULL
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|next
op_ne
id|SCB_LIST_NULL
)paren
op_logical_and
(paren
id|j
op_increment
op_le
(paren
id|p-&gt;scb_data-&gt;maxscbs
op_plus
l_int|1
)paren
)paren
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|next
comma
id|SCBPTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
OL
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Free list inconsistency!.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|init_lists
op_assign
id|TRUE
suffix:semicolon
id|next
op_assign
id|SCB_LIST_NULL
suffix:semicolon
)brace
r_else
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|SCB_TAG
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCB_CONTROL
)paren
suffix:semicolon
id|next
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_NEXT
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|j
OG
(paren
id|p-&gt;scb_data-&gt;maxscbs
op_plus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Yikes!!  There is a loop in the free list!&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|init_lists
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Go through the hardware SCB array looking for commands that&n;   * were active but not on any list.&n;   */
r_if
c_cond
(paren
id|init_lists
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|FREE_SCBH
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|WAITING_SCBH
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|DISCONNECTED_SCBH
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|p-&gt;scb_data-&gt;maxhscbs
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
r_char
id|scbid
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|i
comma
id|SCBPTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_lists
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|SCB_TAG
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|SCB_NEXT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCB_CONTROL
)paren
suffix:semicolon
id|aic7xxx_add_curscb_to_free_list
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
id|scbid
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scbid
OL
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
id|scbp
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scbid
)braket
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_match_scb
c_func
(paren
id|p
comma
id|scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
)paren
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCB_CONTROL
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|SCB_TAG
)paren
suffix:semicolon
id|aic7xxx_add_curscb_to_free_list
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n;   * Go through the entire SCB array now and look for commands for&n;   * for this target that are stillactive.  These are other (most likely&n;   * tagged) commands that were disconnected when the reset occurred.&n;   * Any commands we find here we know this about, it wasn&squot;t on any queue,&n;   * it wasn&squot;t in the qinfifo, it wasn&squot;t in the disconnected or waiting&n;   * lists, so it really must have been a paged out SCB.  In that case,&n;   * we shouldn&squot;t need to bother with updating any counters, just mark&n;   * the correct flags and go on.&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;scb_data-&gt;numscbs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scbp
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scbp-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_logical_and
id|aic7xxx_match_scb
c_func
(paren
id|p
comma
id|scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
)paren
op_logical_and
op_logical_neg
id|aic7xxx_scb_on_qoutfifo
c_func
(paren
id|p
comma
id|scbp
)paren
)paren
(brace
r_if
c_cond
(paren
id|scbp-&gt;flags
op_amp
id|SCB_WAITINGQ
)paren
(brace
id|scbq_remove
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|scbp
)paren
suffix:semicolon
id|scbq_remove
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|TARGET_INDEX
c_func
(paren
id|scbp-&gt;cmd
)paren
)braket
comma
id|scbp
)paren
suffix:semicolon
id|p-&gt;dev_active_cmds
(braket
id|TARGET_INDEX
c_func
(paren
id|scbp-&gt;cmd
)paren
)braket
op_increment
suffix:semicolon
id|p-&gt;activescbs
op_increment
suffix:semicolon
)brace
id|scbp-&gt;flags
op_or_assign
id|SCB_RESET
op_or
id|SCB_QUEUED_FOR_DONE
suffix:semicolon
id|scbp-&gt;flags
op_and_assign
op_complement
(paren
id|SCB_ACTIVE
op_or
id|SCB_WAITINGQ
)paren
suffix:semicolon
)brace
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|active_scb
comma
id|SCBPTR
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_clear_intstat&n; *&n; * Description:&n; *   Clears the interrupt status.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_clear_intstat
id|aic7xxx_clear_intstat
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
multiline_comment|/* Clear any interrupt conditions this may have caused. */
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSELDO
op_or
id|CLRSELDI
op_or
id|CLRSELINGO
comma
id|CLRSINT0
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSELTIMEO
op_or
id|CLRATNO
op_or
id|CLRSCSIRSTI
op_or
id|CLRBUSFREE
op_or
id|CLRSCSIPERR
op_or
id|CLRPHASECHG
op_or
id|CLRREQINIT
comma
id|CLRSINT1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSCSIINT
op_or
id|CLRSEQINT
op_or
id|CLRBRKADRINT
op_or
id|CLRPARERR
comma
id|CLRINT
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_reset_current_bus&n; *&n; * Description:&n; *   Reset the current SCSI bus.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_reset_current_bus
id|aic7xxx_reset_current_bus
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
multiline_comment|/* Disable reset interrupts. */
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SIMODE1
)paren
op_amp
op_complement
id|ENSCSIRST
comma
id|SIMODE1
)paren
suffix:semicolon
multiline_comment|/* Turn off the bus&squot; current operations, after all, we shouldn&squot;t have any&n;   * valid commands left to cause a RSELI and SELO once we&squot;ve tossed the&n;   * bus away with this reset, so we might as well shut down the sequencer&n;   * until the bus is restarted as oppossed to saving the current settings&n;   * and restoring them (which makes no sense to me). */
multiline_comment|/* Turn on the bus reset. */
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISEQ
)paren
op_or
id|SCSIRSTO
comma
id|SCSISEQ
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISEQ
)paren
op_amp
id|SCSIRSTO
)paren
op_eq
l_int|0
)paren
id|mdelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
multiline_comment|/*&n;   * Some of the new Ultra2 chipsets need a longer delay after a chip&n;   * reset than just the init setup creates, so we have to delay here&n;   * before we go into a reset in order to make the chips happy.&n;   */
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
id|mdelay
c_func
(paren
l_int|250
)paren
suffix:semicolon
r_else
id|mdelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/* Turn off the bus reset. */
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCSISEQ
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|aic7xxx_clear_intstat
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* Re-enable reset interrupts. */
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SIMODE1
)paren
op_or
id|ENSCSIRST
comma
id|SIMODE1
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_reset_channel&n; *&n; * Description:&n; *   Reset the channel.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_reset_channel
id|aic7xxx_reset_channel
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|channel
comma
r_int
id|initiate_reset
)paren
(brace
r_int
r_int
id|offset_min
comma
id|offset_max
suffix:semicolon
r_int
r_char
id|sblkctl
suffix:semicolon
r_int
id|cur_channel
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Reset channel called, %s initiate reset.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
(paren
id|initiate_reset
op_eq
id|TRUE
)paren
ques
c_cond
l_string|&quot;will&quot;
suffix:colon
l_string|&quot;won&squot;t&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
l_int|1
)paren
(brace
id|p-&gt;needsdtr
op_or_assign
(paren
id|p-&gt;needsdtr_copy
op_amp
l_int|0xFF00
)paren
suffix:semicolon
id|p-&gt;dtr_pending
op_and_assign
l_int|0x00FF
suffix:semicolon
id|offset_min
op_assign
l_int|8
suffix:semicolon
id|offset_max
op_assign
l_int|16
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_TWIN
)paren
(brace
multiline_comment|/* Channel A */
id|p-&gt;needsdtr
op_or_assign
(paren
id|p-&gt;needsdtr_copy
op_amp
l_int|0x00FF
)paren
suffix:semicolon
id|p-&gt;dtr_pending
op_and_assign
l_int|0xFF00
suffix:semicolon
id|offset_min
op_assign
l_int|0
suffix:semicolon
id|offset_max
op_assign
l_int|8
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;needppr
op_assign
id|p-&gt;needppr_copy
suffix:semicolon
id|p-&gt;needsdtr
op_assign
id|p-&gt;needsdtr_copy
suffix:semicolon
id|p-&gt;needwdtr
op_assign
id|p-&gt;needwdtr_copy
suffix:semicolon
id|p-&gt;dtr_pending
op_assign
l_int|0x0
suffix:semicolon
id|offset_min
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_WIDE
)paren
(brace
id|offset_max
op_assign
l_int|16
suffix:semicolon
)brace
r_else
(brace
id|offset_max
op_assign
l_int|8
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|offset_min
OL
id|offset_max
)paren
(brace
multiline_comment|/*&n;     * Revert to async/narrow transfers until we renegotiate.&n;     */
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|TARG_SCSIRATE
op_plus
id|offset_min
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|TARG_OFFSET
op_plus
id|offset_min
)paren
suffix:semicolon
)brace
id|offset_min
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;   * Reset the bus and unpause/restart the controller&n;   */
id|sblkctl
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SBLKCTL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)paren
op_eq
id|AHC_AIC7770
)paren
id|cur_channel
op_assign
(paren
id|sblkctl
op_amp
id|SELBUSB
)paren
op_rshift
l_int|3
suffix:semicolon
r_else
id|cur_channel
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cur_channel
op_ne
id|channel
)paren
op_logical_and
(paren
id|p-&gt;features
op_amp
id|AHC_TWIN
)paren
)paren
(brace
multiline_comment|/*&n;     * Case 1: Command for another bus is active&n;     */
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Stealthily resetting idle channel.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;     * Stealthily reset the other bus without upsetting the current bus.&n;     */
id|aic_outb
c_func
(paren
id|p
comma
id|sblkctl
op_xor
id|SELBUSB
comma
id|SBLKCTL
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SIMODE1
)paren
op_amp
op_complement
id|ENBUSFREE
comma
id|SIMODE1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|initiate_reset
)paren
(brace
id|aic7xxx_reset_current_bus
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISEQ
)paren
op_amp
(paren
id|ENSELI
op_or
id|ENRSELI
op_or
id|ENAUTOATNP
)paren
comma
id|SCSISEQ
)paren
suffix:semicolon
id|aic7xxx_clear_intstat
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|sblkctl
comma
id|SBLKCTL
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;     * Case 2: A command from this bus is active or we&squot;re idle.&n;     */
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Resetting currently active channel.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SIMODE1
)paren
op_amp
op_complement
(paren
id|ENBUSFREE
op_or
id|ENREQINIT
)paren
comma
id|SIMODE1
)paren
suffix:semicolon
id|p-&gt;flags
op_and_assign
op_complement
id|AHC_HANDLING_REQINITS
suffix:semicolon
id|p-&gt;msg_type
op_assign
id|MSG_TYPE_NONE
suffix:semicolon
id|p-&gt;msg_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|initiate_reset
)paren
(brace
id|aic7xxx_reset_current_bus
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISEQ
)paren
op_amp
(paren
id|ENSELI
op_or
id|ENRSELI
op_or
id|ENAUTOATNP
)paren
comma
id|SCSISEQ
)paren
suffix:semicolon
id|aic7xxx_clear_intstat
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_RETURN
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Channel reset&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;   * Clean up all the state information for the pending transactions&n;   * on this bus.&n;   */
id|aic7xxx_reset_device
c_func
(paren
id|p
comma
id|ALL_TARGETS
comma
id|channel
comma
id|ALL_LUNS
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;features
op_amp
id|AHC_TWIN
)paren
)paren
(brace
id|restart_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_run_waiting_queues&n; *&n; * Description:&n; *   Scan the awaiting_scbs queue downloading and starting as many&n; *   scbs as we can.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_run_waiting_queues
id|aic7xxx_run_waiting_queues
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scb
suffix:semicolon
r_int
id|tindex
suffix:semicolon
r_int
id|sent
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,1,95)
r_int
r_int
id|cpu_flags
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|p-&gt;waiting_scbs.head
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|sent
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   * First handle SCBs that are waiting but have been assigned a slot.&n;   */
id|DRIVER_LOCK
r_while
c_loop
(paren
(paren
id|scb
op_assign
id|scbq_remove_head
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|tindex
op_assign
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scb-&gt;tag_action
op_logical_and
(paren
id|p-&gt;tagenable
op_amp
(paren
l_int|1
op_lshift
id|tindex
)paren
)paren
)paren
(brace
id|p-&gt;dev_temp_queue_depth
(braket
id|tindex
)braket
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
op_ge
id|p-&gt;dev_temp_queue_depth
(braket
id|tindex
)braket
)paren
op_logical_or
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
(paren
id|DEVICE_RESET_DELAY
op_or
id|DEVICE_WAS_BUSY
)paren
)paren
op_logical_or
(paren
id|p-&gt;flags
op_amp
id|AHC_RESET_DELAY
)paren
)paren
(brace
id|scbq_insert_tail
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|tindex
)braket
comma
id|scb
)paren
suffix:semicolon
)brace
r_else
(brace
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_WAITINGQ
suffix:semicolon
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
op_increment
suffix:semicolon
id|p-&gt;activescbs
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;tag_action
)paren
)paren
(brace
id|aic7xxx_busy_target
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
)brace
id|p-&gt;qinfifo
(braket
id|p-&gt;qinfifonext
op_increment
)braket
op_assign
id|scb-&gt;hscb-&gt;tag
suffix:semicolon
id|sent
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sent
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_QUEUE_REGS
)paren
id|aic_outb
c_func
(paren
id|p
comma
id|p-&gt;qinfifonext
comma
id|HNSCB_QOFF
)paren
suffix:semicolon
r_else
(brace
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|p-&gt;qinfifonext
comma
id|KERNEL_QINPOS
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;activescbs
OG
id|p-&gt;max_activescbs
)paren
id|p-&gt;max_activescbs
op_assign
id|p-&gt;activescbs
suffix:semicolon
)brace
id|DRIVER_UNLOCK
)brace
macro_line|#ifdef CONFIG_PCI
DECL|macro|DPE
mdefine_line|#define  DPE 0x80
DECL|macro|SSE
mdefine_line|#define  SSE 0x40
DECL|macro|RMA
mdefine_line|#define  RMA 0x20
DECL|macro|RTA
mdefine_line|#define  RTA 0x10
DECL|macro|STA
mdefine_line|#define  STA 0x08
DECL|macro|DPR
mdefine_line|#define  DPR 0x01
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_pci_intr&n; *&n; * Description:&n; *   Check the scsi card for PCI errors and clear the interrupt&n; *&n; *   NOTE: If you don&squot;t have this function and a 2940 card encounters&n; *         a PCI error condition, the machine will end up locked as the&n; *         interrupt handler gets slammed with non-stop PCI error interrupts&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_pci_intr
id|aic7xxx_pci_intr
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_int
r_char
id|status1
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|p-&gt;pdev
comma
id|PCI_STATUS
op_plus
l_int|1
comma
op_amp
id|status1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status1
op_amp
id|DPE
)paren
op_logical_and
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_MINOR_ERROR
)paren
)paren
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Data Parity Error during PCI address or PCI write&quot;
l_string|&quot;phase.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status1
op_amp
id|SSE
)paren
op_logical_and
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_MINOR_ERROR
)paren
)paren
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Signal System Error Detected&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status1
op_amp
id|RMA
)paren
op_logical_and
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_MINOR_ERROR
)paren
)paren
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Received a PCI Master Abort&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status1
op_amp
id|RTA
)paren
op_logical_and
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_MINOR_ERROR
)paren
)paren
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Received a PCI Target Abort&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status1
op_amp
id|STA
)paren
op_logical_and
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_MINOR_ERROR
)paren
)paren
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Signaled a PCI Target Abort&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status1
op_amp
id|DPR
)paren
op_logical_and
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_MINOR_ERROR
)paren
)paren
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Data Parity Error has been reported via PCI pin &quot;
l_string|&quot;PERR#&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|p-&gt;pdev
comma
id|PCI_STATUS
op_plus
l_int|1
comma
id|status1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status1
op_amp
(paren
id|DPR
op_or
id|RMA
op_or
id|RTA
)paren
)paren
id|aic_outb
c_func
(paren
id|p
comma
id|CLRPARERR
comma
id|CLRINT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|aic7xxx_panic_on_abort
)paren
op_logical_and
(paren
id|p-&gt;spurious_int
OG
l_int|500
)paren
)paren
id|aic7xxx_panic_abort
c_func
(paren
id|p
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PCI */
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_timer&n; *&n; * Description:&n; *   Take expired extries off of delayed queues and place on waiting queue&n; *   then run waiting queue to start commands.&n; ***************************************************************************/
r_static
r_void
DECL|function|aic7xxx_timer
id|aic7xxx_timer
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
r_int
id|cpu_flags
op_assign
l_int|0
suffix:semicolon
r_struct
id|aic7xxx_scb
op_star
id|scb
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|cpu_flags
)paren
suffix:semicolon
id|p-&gt;dev_timer_active
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
id|MAX_TARGETS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;dev_timer_active
op_amp
(paren
l_int|0x01
op_lshift
id|p-&gt;scsi_id
)paren
)paren
op_logical_and
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|p-&gt;dev_expires
(braket
id|p-&gt;scsi_id
)braket
)paren
)paren
(brace
id|p-&gt;flags
op_and_assign
op_complement
id|AHC_RESET_DELAY
suffix:semicolon
id|p-&gt;dev_timer_active
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
id|p-&gt;scsi_id
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGETS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_ne
id|p-&gt;scsi_id
)paren
op_logical_and
(paren
id|p-&gt;dev_timer_active
op_amp
(paren
l_int|0x01
op_lshift
id|i
)paren
)paren
op_logical_and
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|p-&gt;dev_expires
(braket
id|i
)braket
)paren
)paren
(brace
id|p-&gt;dev_timer_active
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
id|p-&gt;dev_flags
(braket
id|i
)braket
op_and_assign
op_complement
(paren
id|DEVICE_RESET_DELAY
op_or
id|DEVICE_WAS_BUSY
)paren
suffix:semicolon
id|p-&gt;dev_temp_queue_depth
(braket
id|i
)braket
op_assign
id|p-&gt;dev_max_queue_depth
(braket
id|i
)braket
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|scb
op_assign
id|scbq_remove_head
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|i
)braket
)paren
)paren
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|j
op_increment
OL
id|p-&gt;scb_data-&gt;numscbs
)paren
)paren
(brace
id|scbq_insert_tail
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|scb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
op_eq
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;timer: Yikes, loop in delayed_scbs list.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
l_int|0
comma
id|i
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|scbq_init
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|i
)braket
)paren
suffix:semicolon
id|scbq_init
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
)paren
suffix:semicolon
multiline_comment|/*&n;         * Well, things are screwed now, wait for a reset to clean the junk&n;         * out.&n;         */
)brace
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;dev_timer_active
op_amp
(paren
l_int|0x01
op_lshift
id|i
)paren
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;dev_timer_active
op_amp
(paren
l_int|0x01
op_lshift
id|MAX_TARGETS
)paren
)paren
(brace
r_if
c_cond
(paren
id|time_after_eq
c_func
(paren
id|p-&gt;dev_timer.expires
comma
id|p-&gt;dev_expires
(braket
id|i
)braket
)paren
)paren
(brace
id|p-&gt;dev_timer.expires
op_assign
id|p-&gt;dev_expires
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
r_else
(brace
id|p-&gt;dev_timer.expires
op_assign
id|p-&gt;dev_expires
(braket
id|i
)braket
suffix:semicolon
id|p-&gt;dev_timer_active
op_or_assign
(paren
l_int|0x01
op_lshift
id|MAX_TARGETS
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|p-&gt;dev_timer_active
op_amp
(paren
l_int|0x01
op_lshift
id|MAX_TARGETS
)paren
)paren
(brace
id|add_timer
c_func
(paren
op_amp
id|p-&gt;dev_timer
)paren
suffix:semicolon
)brace
id|aic7xxx_run_waiting_queues
c_func
(paren
id|p
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|cpu_flags
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_construct_ppr&n; *&n; * Description:&n; *   Build up a Parallel Protocol Request message for use with SCSI-3&n; *   devices.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_construct_ppr
id|aic7xxx_construct_ppr
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
r_int
id|tindex
op_assign
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
suffix:semicolon
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|MSG_EXTENDED
suffix:semicolon
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|MSG_EXT_PPR_LEN
suffix:semicolon
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|MSG_EXT_PPR
suffix:semicolon
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
suffix:semicolon
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
suffix:semicolon
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
suffix:semicolon
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
suffix:semicolon
id|p-&gt;msg_len
op_add_assign
l_int|8
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_construct_sdtr&n; *&n; * Description:&n; *   Constucts a synchronous data transfer message in the message&n; *   buffer on the sequencer.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_construct_sdtr
id|aic7xxx_construct_sdtr
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
id|period
comma
r_int
r_char
id|offset
)paren
(brace
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|MSG_EXTENDED
suffix:semicolon
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|MSG_EXT_SDTR_LEN
suffix:semicolon
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|MSG_EXT_SDTR
suffix:semicolon
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|period
suffix:semicolon
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|offset
suffix:semicolon
id|p-&gt;msg_len
op_add_assign
l_int|5
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_construct_wdtr&n; *&n; * Description:&n; *   Constucts a wide data transfer message in the message buffer&n; *   on the sequencer.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_construct_wdtr
id|aic7xxx_construct_wdtr
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
id|bus_width
)paren
(brace
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|MSG_EXTENDED
suffix:semicolon
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|MSG_EXT_WDTR_LEN
suffix:semicolon
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|MSG_EXT_WDTR
suffix:semicolon
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|bus_width
suffix:semicolon
id|p-&gt;msg_len
op_add_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_calc_residual&n; *&n; * Description:&n; *   Calculate the residual data not yet transferred.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_calculate_residual
id|aic7xxx_calculate_residual
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
r_struct
id|aic7xxx_hwscb
op_star
id|hscb
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_int
id|actual
comma
id|i
suffix:semicolon
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
multiline_comment|/*&n;   *  Don&squot;t destroy valid residual information with&n;   *  residual coming from a check sense operation.&n;   */
r_if
c_cond
(paren
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|DISCONNECTED
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|scb-&gt;flags
op_amp
id|SCB_SENSE
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;     *  We had an underflow. At this time, there&squot;s only&n;     *  one other driver that bothers to check for this,&n;     *  and cmd-&gt;underflow seems to be set rather half-&n;     *  heartedly in the higher-level SCSI code.&n;     */
id|actual
op_assign
id|scb-&gt;sg_length
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|hscb-&gt;residual_SG_segment_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|actual
op_sub_assign
id|scb-&gt;sg_list
(braket
id|scb-&gt;sg_count
op_minus
id|i
)braket
dot
id|length
suffix:semicolon
)brace
id|actual
op_sub_assign
(paren
id|hscb-&gt;residual_data_count
(braket
l_int|2
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|hscb-&gt;residual_data_count
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_or
id|hscb-&gt;residual_data_count
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|actual
OL
id|cmd-&gt;underflow
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_MINOR_ERROR
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Underflow - Wanted %u, %s %u, residual SG &quot;
l_string|&quot;count %d.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|cmd-&gt;underflow
comma
(paren
id|cmd-&gt;request.cmd
op_eq
id|WRITE
)paren
ques
c_cond
l_string|&quot;wrote&quot;
suffix:colon
l_string|&quot;read&quot;
comma
id|actual
comma
id|hscb-&gt;residual_SG_segment_count
)paren
suffix:semicolon
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_assign
id|DID_RETRY_COMMAND
suffix:semicolon
id|aic7xxx_status
c_func
(paren
id|cmd
)paren
op_assign
id|hscb-&gt;target_status
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Clean out the residual information in the SCB for the&n;   * next consumer.&n;   */
id|hscb-&gt;residual_data_count
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;residual_data_count
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;residual_data_count
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;residual_SG_segment_count
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_handle_device_reset&n; *&n; * Description:&n; *   Interrupt handler for sequencer interrupts (SEQINT).&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_handle_device_reset
id|aic7xxx_handle_device_reset
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|target
comma
r_int
id|channel
)paren
(brace
r_int
r_int
id|targ_mask
suffix:semicolon
r_int
r_char
id|tindex
op_assign
id|target
suffix:semicolon
id|tindex
op_or_assign
(paren
(paren
id|channel
op_amp
l_int|0x01
)paren
op_lshift
l_int|3
)paren
suffix:semicolon
id|targ_mask
op_assign
(paren
l_int|0x01
op_lshift
id|tindex
)paren
suffix:semicolon
multiline_comment|/*&n;   * Go back to async/narrow transfers and renegotiate.&n;   */
id|p-&gt;needppr
op_or_assign
(paren
id|p-&gt;needppr_copy
op_amp
id|targ_mask
)paren
suffix:semicolon
id|p-&gt;needsdtr
op_or_assign
(paren
id|p-&gt;needsdtr_copy
op_amp
id|targ_mask
)paren
suffix:semicolon
id|p-&gt;needwdtr
op_or_assign
(paren
id|p-&gt;needwdtr_copy
op_amp
id|targ_mask
)paren
suffix:semicolon
id|p-&gt;dtr_pending
op_and_assign
op_complement
id|targ_mask
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|TARG_SCSIRATE
op_plus
id|tindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|TARG_OFFSET
op_plus
id|tindex
)paren
suffix:semicolon
id|aic7xxx_reset_device
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|ALL_LUNS
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Bus Device Reset delivered.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|aic7xxx_run_done_queue
c_func
(paren
id|p
comma
multiline_comment|/*complete*/
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_handle_seqint&n; *&n; * Description:&n; *   Interrupt handler for sequencer interrupts (SEQINT).&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_handle_seqint
id|aic7xxx_handle_seqint
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
id|intstat
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scb
suffix:semicolon
r_int
r_int
id|target_mask
suffix:semicolon
r_int
r_char
id|target
comma
id|lun
comma
id|tindex
suffix:semicolon
r_int
r_char
id|queue_flag
op_assign
id|FALSE
suffix:semicolon
r_char
id|channel
suffix:semicolon
id|target
op_assign
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SAVED_TCL
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)paren
op_eq
id|AHC_AIC7770
)paren
id|channel
op_assign
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SBLKCTL
)paren
op_amp
id|SELBUSB
)paren
op_rshift
l_int|3
suffix:semicolon
r_else
id|channel
op_assign
l_int|0
suffix:semicolon
id|tindex
op_assign
id|target
op_plus
(paren
id|channel
op_lshift
l_int|3
)paren
suffix:semicolon
id|lun
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SAVED_TCL
)paren
op_amp
l_int|0x07
suffix:semicolon
id|target_mask
op_assign
(paren
l_int|0x01
op_lshift
id|tindex
)paren
suffix:semicolon
multiline_comment|/*&n;   * Go ahead and clear the SEQINT now, that avoids any interrupt race&n;   * conditions later on in case we enable some other interrupt.&n;   */
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSEQINT
comma
id|CLRINT
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|intstat
op_amp
id|SEQINT_MASK
)paren
(brace
r_case
id|NO_MATCH
suffix:colon
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISEQ
)paren
op_amp
(paren
id|ENSELI
op_or
id|ENRSELI
op_or
id|ENAUTOATNP
)paren
comma
id|SCSISEQ
)paren
suffix:semicolon
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;No active SCB for reconnecting target - Issuing &quot;
l_string|&quot;BUS DEVICE RESET.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;      SAVED_TCL=0x%x, ARG_1=0x%x, SEQADDR=0x%x&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SAVED_TCL
)paren
comma
id|aic_inb
c_func
(paren
id|p
comma
id|ARG_1
)paren
comma
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SEQADDR1
)paren
op_lshift
l_int|8
)paren
op_or
id|aic_inb
c_func
(paren
id|p
comma
id|SEQADDR0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_panic_on_abort
)paren
id|aic7xxx_panic_abort
c_func
(paren
id|p
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SEND_REJECT
suffix:colon
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_MINOR_ERROR
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Rejecting unknown message (0x%x) received from &quot;
l_string|&quot;target, SEQ_FLAGS=0x%x&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
comma
id|aic_inb
c_func
(paren
id|p
comma
id|ACCUM
)paren
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SEQ_FLAGS
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|NO_IDENT
suffix:colon
(brace
multiline_comment|/*&n;         * The reconnecting target either did not send an identify&n;         * message, or did, but we didn&squot;t find an SCB to match and&n;         * before it could respond to our ATN/abort, it hit a dataphase.&n;         * The only safe thing to do is to blow it away with a bus&n;         * reset.&n;         */
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
(paren
id|VERBOSE_SEQINT
op_or
id|VERBOSE_RESET_MID
)paren
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Target did not send an IDENTIFY message; &quot;
l_string|&quot;LASTPHASE 0x%x, SAVED_TCL 0x%x&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
comma
id|aic_inb
c_func
(paren
id|p
comma
id|LASTPHASE
)paren
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SAVED_TCL
)paren
)paren
suffix:semicolon
id|aic7xxx_reset_channel
c_func
(paren
id|p
comma
id|channel
comma
multiline_comment|/*initiate reset*/
id|TRUE
)paren
suffix:semicolon
id|aic7xxx_run_done_queue
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BAD_PHASE
suffix:colon
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|LASTPHASE
)paren
op_eq
id|P_BUSFREE
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_SEQINT
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Missed busfree.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|restart_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_SEQINT
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Unknown scsi bus phase, continuing&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EXTENDED_MSG
suffix:colon
(brace
id|p-&gt;msg_type
op_assign
id|MSG_TYPE_INITIATOR_MSGIN
suffix:semicolon
id|p-&gt;msg_len
op_assign
l_int|0
suffix:semicolon
id|p-&gt;msg_index
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_if
c_cond
(paren
id|aic7xxx_verbose
OG
l_int|0xffff
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Enabling REQINITs for MSG_IN&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*      &n;        * To actually receive the message, simply turn on&n;        * REQINIT interrupts and let our interrupt handler&n;        * do the rest (REQINIT should already be true).&n;        */
id|p-&gt;flags
op_or_assign
id|AHC_HANDLING_REQINITS
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SIMODE1
)paren
op_or
id|ENREQINIT
comma
id|SIMODE1
)paren
suffix:semicolon
multiline_comment|/*&n;        * We don&squot;t want the sequencer unpaused yet so we return early&n;        */
r_return
suffix:semicolon
)brace
r_case
id|REJECT_MSG
suffix:colon
(brace
multiline_comment|/*&n;         * What we care about here is if we had an outstanding SDTR&n;         * or WDTR message for this target. If we did, this is a&n;         * signal that the target is refusing negotiation.&n;         */
r_int
r_char
id|scb_index
suffix:semicolon
r_int
r_char
id|last_msg
suffix:semicolon
id|scb_index
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
suffix:semicolon
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
id|last_msg
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|LAST_MSG
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|last_msg
op_eq
id|MSG_IDENTIFYFLAG
)paren
op_logical_and
(paren
id|scb-&gt;tag_action
)paren
op_logical_and
op_logical_neg
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_BITS
)paren
)paren
(brace
r_if
c_cond
(paren
id|scb-&gt;tag_action
op_eq
id|MSG_ORDERED_Q_TAG
)paren
(brace
multiline_comment|/*&n;             * OK...the device seems able to accept tagged commands, but&n;             * not ordered tag commands, only simple tag commands.  So, we&n;             * disable ordered tag commands and go on with life just like&n;             * normal.&n;             */
id|p-&gt;orderedtag
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|scb-&gt;tag_action
op_assign
id|MSG_SIMPLE_Q_TAG
suffix:semicolon
id|scb-&gt;hscb-&gt;control
op_and_assign
op_complement
id|SCB_TAG_TYPE
suffix:semicolon
id|scb-&gt;hscb-&gt;control
op_or_assign
id|MSG_SIMPLE_Q_TAG
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|scb-&gt;hscb-&gt;control
comma
id|SCB_CONTROL
)paren
suffix:semicolon
multiline_comment|/*&n;             * OK..we set the tag type to simple tag command, now we re-assert&n;             * ATNO and hope this will take us into the identify phase again&n;             * so we can resend the tag type and info to the device.&n;             */
id|aic_outb
c_func
(paren
id|p
comma
id|MSG_IDENTIFYFLAG
comma
id|MSG_OUT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISIGI
)paren
op_or
id|ATNO
comma
id|SCSISIGO
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb-&gt;tag_action
op_eq
id|MSG_SIMPLE_Q_TAG
)paren
(brace
r_int
r_char
id|i
comma
id|reset
op_assign
l_int|0
suffix:semicolon
r_struct
id|aic7xxx_scb
op_star
id|scbp
suffix:semicolon
r_int
id|old_verbose
suffix:semicolon
multiline_comment|/*&n;             * Hmmmm....the device is flaking out on tagged commands.  The&n;             * bad thing is that we already have tagged commands enabled in&n;             * the device struct in the mid level code.  We also have a queue&n;             * set according to the tagged queue depth.  Gonna have to live&n;             * with it by controlling our queue depth internally and making&n;             * sure we don&squot;t set the tagged command flag any more.&n;             */
id|p-&gt;tagenable
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|p-&gt;orderedtag
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|p-&gt;dev_max_queue_depth
(braket
id|tindex
)braket
op_assign
id|p-&gt;dev_temp_queue_depth
(braket
id|tindex
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;             * We set this command up as a bus device reset.  However, we have&n;             * to clear the tag type as it&squot;s causing us problems.  We shouldnt&n;             * have to worry about any other commands being active, since if&n;             * the device is refusing tagged commands, this should be the&n;             * first tagged command sent to the device, however, we do have&n;             * to worry about any other tagged commands that may already be&n;             * in the qinfifo.  The easiest way to do this, is to issue a BDR,&n;             * send all the commands back to the mid level code, then let them&n;             * come back and get rebuilt as untagged commands.&n;             */
id|scb-&gt;tag_action
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;hscb-&gt;control
op_and_assign
op_complement
(paren
id|TAG_ENB
op_or
id|SCB_TAG_TYPE
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|scb-&gt;hscb-&gt;control
comma
id|SCB_CONTROL
)paren
suffix:semicolon
id|old_verbose
op_assign
id|aic7xxx_verbose
suffix:semicolon
id|aic7xxx_verbose
op_and_assign
op_complement
(paren
id|VERBOSE_RESET
op_or
id|VERBOSE_ABORT
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_ne
id|p-&gt;scb_data-&gt;numscbs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scbp
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scbp-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_logical_and
(paren
id|scbp
op_ne
id|scb
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_match_scb
c_func
(paren
id|p
comma
id|scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|i
)paren
)paren
(brace
id|aic7xxx_reset_device
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|lun
comma
id|i
)paren
suffix:semicolon
id|reset
op_increment
suffix:semicolon
)brace
id|aic7xxx_run_done_queue
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
)brace
)brace
id|aic7xxx_verbose
op_assign
id|old_verbose
suffix:semicolon
multiline_comment|/*&n;             * Wait until after the for loop to set the busy index since&n;             * aic7xxx_reset_device will clear the busy index during its&n;             * operation.&n;             */
id|aic7xxx_busy_target
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Device is refusing tagged commands, using &quot;
l_string|&quot;untagged I/O.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|MSG_IDENTIFYFLAG
comma
id|MSG_OUT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISIGI
)paren
op_or
id|ATNO
comma
id|SCSISIGO
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_PPR
)paren
(brace
multiline_comment|/*&n;           * As per the draft specs, any device capable of supporting any of&n;           * the option values other than 0 are not allowed to reject the&n;           * PPR message.  Instead, they must negotiate out what they do&n;           * support instead of rejecting our offering or else they cause&n;           * a parity error during msg_out phase to signal that they don&squot;t&n;           * like our settings.&n;           */
id|p-&gt;needppr
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|p-&gt;needppr_copy
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|aic7xxx_set_width
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|lun
comma
id|MSG_EXT_WDTR_BUS_8_BIT
comma
(paren
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_CUR
op_or
id|AHC_TRANS_QUITE
)paren
)paren
suffix:semicolon
id|aic7xxx_set_syncrate
c_func
(paren
id|p
comma
l_int|NULL
comma
id|target
comma
id|channel
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_CUR
op_or
id|AHC_TRANS_QUITE
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
op_assign
l_int|0
suffix:semicolon
id|p-&gt;dtr_pending
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_MSGOUT_BITS
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Device is rejecting PPR messages, falling &quot;
l_string|&quot;back.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
)paren
(brace
id|p-&gt;needwdtr
op_or_assign
id|target_mask
suffix:semicolon
id|p-&gt;needwdtr_copy
op_or_assign
id|target_mask
suffix:semicolon
id|p-&gt;dtr_pending
op_or_assign
id|target_mask
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_MSGOUT_WDTR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
)paren
(brace
id|p-&gt;needsdtr
op_or_assign
id|target_mask
suffix:semicolon
id|p-&gt;needsdtr_copy
op_or_assign
id|target_mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;dtr_pending
op_amp
id|target_mask
)paren
)paren
(brace
id|p-&gt;dtr_pending
op_or_assign
id|target_mask
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_MSGOUT_SDTR
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|p-&gt;dtr_pending
op_amp
id|target_mask
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|HOST_MSG
comma
id|MSG_OUT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISIGI
)paren
op_or
id|ATNO
comma
id|SCSISIGO
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_WDTR
)paren
(brace
multiline_comment|/*&n;           * note 8bit xfers and clear flag&n;           */
id|p-&gt;needwdtr
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|p-&gt;needwdtr_copy
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|p-&gt;dtr_pending
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_MSGOUT_BITS
suffix:semicolon
id|aic7xxx_set_width
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|lun
comma
id|MSG_EXT_WDTR_BUS_8_BIT
comma
(paren
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_GOAL
op_or
id|AHC_TRANS_CUR
)paren
)paren
suffix:semicolon
id|aic7xxx_set_syncrate
c_func
(paren
id|p
comma
l_int|NULL
comma
id|target
comma
id|channel
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_CUR
op_or
id|AHC_TRANS_QUITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Device is rejecting WDTR messages, using &quot;
l_string|&quot;narrow transfers.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
)brace
id|p-&gt;needsdtr
op_or_assign
(paren
id|p-&gt;needsdtr_copy
op_amp
id|target_mask
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_SDTR
)paren
(brace
multiline_comment|/*&n;          * note asynch xfers and clear flag&n;          */
id|p-&gt;needsdtr
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|p-&gt;needsdtr_copy
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|p-&gt;dtr_pending
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_MSGOUT_SDTR
suffix:semicolon
id|aic7xxx_set_syncrate
c_func
(paren
id|p
comma
l_int|NULL
comma
id|target
comma
id|channel
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
(paren
id|AHC_TRANS_CUR
op_or
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_GOAL
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Device is rejecting SDTR messages, using &quot;
l_string|&quot;async transfers.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_SEQINT
)paren
(brace
multiline_comment|/*&n;           * Otherwise, we ignore it.&n;           */
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Received MESSAGE_REJECT for unknown cause.  &quot;
l_string|&quot;Ignoring.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|BAD_STATUS
suffix:colon
(brace
r_int
r_char
id|scb_index
suffix:semicolon
r_struct
id|aic7xxx_hwscb
op_star
id|hscb
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
multiline_comment|/* The sequencer will notify us when a command has an error that&n;         * would be of interest to the kernel.  This allows us to leave&n;         * the sequencer running in the common case of command completes&n;         * without error.  The sequencer will have DMA&squot;d the SCB back&n;         * up to us, so we can reference the drivers SCB array.&n;         *&n;         * Set the default return value to 0 indicating not to send&n;         * sense.  The sense code will change this if needed and this&n;         * reduces code duplication.&n;         */
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|RETURN_1
)paren
suffix:semicolon
id|scb_index
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_index
OG
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Invalid SCB during SEQINT 0x%02x, SCB_TAG %d.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
comma
id|intstat
comma
id|scb_index
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_logical_or
(paren
id|scb-&gt;cmd
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Invalid SCB during SEQINT 0x%x, scb %d, flags 0x%x,&quot;
l_string|&quot; cmd 0x%lx.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
comma
id|intstat
comma
id|scb_index
comma
id|scb-&gt;flags
comma
(paren
r_int
r_int
)paren
id|scb-&gt;cmd
)paren
suffix:semicolon
)brace
r_else
(brace
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
id|hscb-&gt;target_status
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TARGET_STATUS
)paren
suffix:semicolon
id|aic7xxx_status
c_func
(paren
id|cmd
)paren
op_assign
id|hscb-&gt;target_status
suffix:semicolon
id|cmd-&gt;result
op_assign
id|hscb-&gt;target_status
suffix:semicolon
r_switch
c_cond
(paren
id|status_byte
c_func
(paren
id|hscb-&gt;target_status
)paren
)paren
(brace
r_case
id|GOOD
suffix:colon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_SEQINT
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Interrupted for status of GOOD???&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMMAND_TERMINATED
suffix:colon
r_case
id|CHECK_CONDITION
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;flags
op_amp
id|SCB_SENSE
)paren
)paren
(brace
multiline_comment|/*&n;                 * Send a sense command to the requesting target.&n;                 * XXX - revisit this and get rid of the memcopys.&n;                 */
id|memcpy
c_func
(paren
id|scb-&gt;sense_cmd
comma
op_amp
id|generic_sense
(braket
l_int|0
)braket
comma
r_sizeof
(paren
id|generic_sense
)paren
)paren
suffix:semicolon
id|scb-&gt;sense_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|cmd-&gt;lun
op_lshift
l_int|5
)paren
suffix:semicolon
id|scb-&gt;sense_cmd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|length
op_assign
id|cpu_to_le32
c_func
(paren
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|address
op_assign
id|cpu_to_le32
c_func
(paren
id|pci_map_single
c_func
(paren
id|p-&gt;pdev
comma
id|cmd-&gt;sense_buffer
comma
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
comma
id|PCI_DMA_FROMDEVICE
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;                 * XXX - We should allow disconnection, but can&squot;t as it&n;                 * might allow overlapped tagged commands.&n;                 */
multiline_comment|/* hscb-&gt;control &amp;= DISCENB; */
id|hscb-&gt;control
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;target_status
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;SG_list_pointer
op_assign
id|cpu_to_le32
c_func
(paren
id|SCB_DMA_ADDR
c_func
(paren
id|scb
comma
id|scb-&gt;sg_list
)paren
)paren
suffix:semicolon
id|hscb-&gt;SCSI_cmd_pointer
op_assign
id|cpu_to_le32
c_func
(paren
id|SCB_DMA_ADDR
c_func
(paren
id|scb
comma
id|scb-&gt;sense_cmd
)paren
)paren
suffix:semicolon
id|hscb-&gt;data_count
op_assign
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|length
suffix:semicolon
id|hscb-&gt;data_pointer
op_assign
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
id|hscb-&gt;SCSI_cmd_length
op_assign
id|COMMAND_SIZE
c_func
(paren
id|scb-&gt;sense_cmd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|hscb-&gt;residual_SG_segment_count
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;residual_data_count
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;residual_data_count
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;residual_data_count
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;sg_count
op_assign
id|hscb-&gt;SG_segment_count
op_assign
l_int|1
suffix:semicolon
id|scb-&gt;sg_length
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
id|scb-&gt;tag_action
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_SENSE
suffix:semicolon
multiline_comment|/*&n;                 * Ensure the target is busy since this will be an&n;                 * an untagged request.&n;                 */
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
(brace
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_BITS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Requesting SENSE with %s&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_SDTR
)paren
ques
c_cond
l_string|&quot;SDTR&quot;
suffix:colon
l_string|&quot;WDTR&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Requesting SENSE, no MSG&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|aic7xxx_busy_target
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|SEND_SENSE
comma
id|RETURN_1
)paren
suffix:semicolon
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_assign
id|DID_OK
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* first time sense, no errors */
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_assign
id|DID_ERROR
suffix:semicolon
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_SENSE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QUEUE_FULL
suffix:colon
id|queue_flag
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Mark that this is a QUEUE_FULL and */
r_case
id|BUSY
suffix:colon
multiline_comment|/* drop through to here */
(brace
r_struct
id|aic7xxx_scb
op_star
id|next_scbp
comma
op_star
id|prev_scbp
suffix:semicolon
r_int
r_char
id|active_hscb
comma
id|next_hscb
comma
id|prev_hscb
comma
id|scb_index
suffix:semicolon
multiline_comment|/*&n;               * We have to look three places for queued commands:&n;               *  1: QINFIFO&n;               *  2: p-&gt;waiting_scbs queue&n;               *  3: WAITING_SCBS list on card (for commands that are started&n;               *     but haven&squot;t yet made it to the device)&n;               */
id|aic7xxx_search_qinfifo
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|lun
comma
id|SCB_LIST_NULL
comma
l_int|0
comma
id|TRUE
comma
op_amp
id|p-&gt;delayed_scbs
(braket
id|tindex
)braket
)paren
suffix:semicolon
id|next_scbp
op_assign
id|p-&gt;waiting_scbs.head
suffix:semicolon
r_while
c_loop
(paren
id|next_scbp
op_ne
l_int|NULL
)paren
(brace
id|prev_scbp
op_assign
id|next_scbp
suffix:semicolon
id|next_scbp
op_assign
id|next_scbp-&gt;q_next
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_match_scb
c_func
(paren
id|p
comma
id|prev_scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|SCB_LIST_NULL
)paren
)paren
(brace
id|scbq_remove
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|prev_scbp
)paren
suffix:semicolon
id|scbq_insert_tail
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|tindex
)braket
comma
id|prev_scbp
)paren
suffix:semicolon
)brace
)brace
id|next_scbp
op_assign
l_int|NULL
suffix:semicolon
id|active_hscb
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCBPTR
)paren
suffix:semicolon
id|prev_hscb
op_assign
id|next_hscb
op_assign
id|scb_index
op_assign
id|SCB_LIST_NULL
suffix:semicolon
id|next_hscb
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|WAITING_SCBH
)paren
suffix:semicolon
r_while
c_loop
(paren
id|next_hscb
op_ne
id|SCB_LIST_NULL
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|next_hscb
comma
id|SCBPTR
)paren
suffix:semicolon
id|scb_index
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_index
OL
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
id|next_scbp
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_match_scb
c_func
(paren
id|p
comma
id|next_scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|SCB_LIST_NULL
)paren
)paren
(brace
r_if
c_cond
(paren
id|next_scbp-&gt;flags
op_amp
id|SCB_WAITINGQ
)paren
(brace
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
op_increment
suffix:semicolon
id|p-&gt;activescbs
op_decrement
suffix:semicolon
id|scbq_remove
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|tindex
)braket
comma
id|next_scbp
)paren
suffix:semicolon
id|scbq_remove
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|next_scbp
)paren
suffix:semicolon
)brace
id|scbq_insert_head
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|tindex
)braket
comma
id|next_scbp
)paren
suffix:semicolon
id|next_scbp-&gt;flags
op_or_assign
id|SCB_WAITINGQ
suffix:semicolon
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
op_decrement
suffix:semicolon
id|p-&gt;activescbs
op_decrement
suffix:semicolon
id|next_hscb
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_NEXT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCB_CONTROL
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|SCB_TAG
)paren
suffix:semicolon
id|aic7xxx_add_curscb_to_free_list
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev_hscb
op_eq
id|SCB_LIST_NULL
)paren
(brace
multiline_comment|/* We were first on the list,&n;                       * so we kill the selection&n;                       * hardware.  Let the sequencer&n;                       * re-init the hardware itself&n;                       */
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISEQ
)paren
op_amp
op_complement
id|ENSELO
comma
id|SCSISEQ
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSELTIMEO
comma
id|CLRSINT1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|next_hscb
comma
id|WAITING_SCBH
)paren
suffix:semicolon
)brace
r_else
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|prev_hscb
comma
id|SCBPTR
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|next_hscb
comma
id|SCB_NEXT
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|prev_hscb
op_assign
id|next_hscb
suffix:semicolon
id|next_hscb
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_NEXT
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* scb_index &gt;= p-&gt;scb_data-&gt;numscbs */
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|active_hscb
comma
id|SCBPTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_WAITINGQ
)paren
(brace
id|scbq_remove
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|tindex
)braket
comma
id|scb
)paren
suffix:semicolon
id|scbq_remove
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|scb
)paren
suffix:semicolon
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
op_increment
suffix:semicolon
id|p-&gt;activescbs
op_increment
suffix:semicolon
)brace
id|scbq_insert_head
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|tindex
)braket
comma
id|scb
)paren
suffix:semicolon
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
op_decrement
suffix:semicolon
id|p-&gt;activescbs
op_decrement
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_WAITINGQ
op_or
id|SCB_WAS_BUSY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;dev_timer_active
op_amp
(paren
l_int|0x01
op_lshift
id|tindex
)paren
)paren
)paren
(brace
id|p-&gt;dev_timer_active
op_or_assign
(paren
l_int|0x01
op_lshift
id|tindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
)paren
(brace
id|p-&gt;dev_expires
(braket
id|tindex
)braket
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;dev_expires
(braket
id|tindex
)braket
op_assign
id|jiffies
op_plus
(paren
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;dev_timer_active
op_amp
(paren
l_int|0x01
op_lshift
id|MAX_TARGETS
)paren
)paren
)paren
(brace
id|p-&gt;dev_timer.expires
op_assign
id|p-&gt;dev_expires
(braket
id|tindex
)braket
suffix:semicolon
id|p-&gt;dev_timer_active
op_or_assign
(paren
l_int|0x01
op_lshift
id|MAX_TARGETS
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|p-&gt;dev_timer
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|time_after_eq
c_func
(paren
id|p-&gt;dev_timer.expires
comma
id|p-&gt;dev_expires
(braket
id|tindex
)braket
)paren
)paren
id|mod_timer
c_func
(paren
op_amp
id|p-&gt;dev_timer
comma
id|p-&gt;dev_expires
(braket
id|tindex
)braket
)paren
suffix:semicolon
)brace
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_if
c_cond
(paren
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_MINOR_ERROR
)paren
op_logical_or
(paren
id|aic7xxx_verbose
OG
l_int|0xffff
)paren
)paren
(brace
r_if
c_cond
(paren
id|queue_flag
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Queue full received; queue depth %d, &quot;
l_string|&quot;active %d&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|p-&gt;dev_max_queue_depth
(braket
id|tindex
)braket
comma
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Target busy&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|queue_flag
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;dev_last_queue_full
(braket
id|tindex
)braket
op_ne
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
)paren
(brace
id|p-&gt;dev_last_queue_full
(braket
id|tindex
)braket
op_assign
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
suffix:semicolon
id|p-&gt;dev_last_queue_full_count
(braket
id|tindex
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;dev_last_queue_full_count
(braket
id|tindex
)braket
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|p-&gt;dev_last_queue_full_count
(braket
id|tindex
)braket
OG
l_int|14
)paren
op_logical_and
(paren
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
OG
l_int|4
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Queue depth reduced to %d&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
)paren
suffix:semicolon
id|p-&gt;dev_max_queue_depth
(braket
id|tindex
)braket
op_assign
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
suffix:semicolon
id|p-&gt;dev_last_queue_full
(braket
id|tindex
)braket
op_assign
l_int|0
suffix:semicolon
id|p-&gt;dev_last_queue_full_count
(braket
id|tindex
)braket
op_assign
l_int|0
suffix:semicolon
id|p-&gt;dev_temp_queue_depth
(braket
id|tindex
)braket
op_assign
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;QUEUE_FULL status received with 0 &quot;
l_string|&quot;commands active.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Tagged Command Queueing disabled&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
id|p-&gt;dev_max_queue_depth
(braket
id|tindex
)braket
op_assign
l_int|1
suffix:semicolon
id|p-&gt;dev_temp_queue_depth
(braket
id|tindex
)braket
op_assign
l_int|1
suffix:semicolon
id|scb-&gt;tag_action
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;hscb-&gt;control
op_and_assign
op_complement
(paren
id|MSG_ORDERED_Q_TAG
op_or
id|MSG_SIMPLE_Q_TAG
)paren
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_or_assign
id|DEVICE_WAS_BUSY
suffix:semicolon
id|p-&gt;dev_temp_queue_depth
(braket
id|tindex
)braket
op_assign
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_SEQINT
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Unexpected target status 0x%x.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;hscb-&gt;target_status
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
)paren
(brace
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_assign
id|DID_RETRY_COMMAND
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* end switch */
)brace
multiline_comment|/* end else of */
)brace
r_break
suffix:semicolon
r_case
id|AWAITING_MSG
suffix:colon
(brace
r_int
r_char
id|scb_index
comma
id|msg_out
suffix:semicolon
id|scb_index
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
suffix:semicolon
id|msg_out
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|MSG_OUT
)paren
suffix:semicolon
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
id|p-&gt;msg_index
op_assign
id|p-&gt;msg_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;         * This SCB had a MK_MESSAGE set in its control byte informing&n;         * the sequencer that we wanted to send a special message to&n;         * this target.&n;         */
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;flags
op_amp
id|SCB_DEVICE_RESET
)paren
op_logical_and
(paren
id|msg_out
op_eq
id|MSG_IDENTIFYFLAG
)paren
op_logical_and
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|TAG_ENB
)paren
)paren
(brace
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|scb-&gt;tag_action
suffix:semicolon
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|scb-&gt;hscb-&gt;tag
suffix:semicolon
id|p-&gt;msg_len
op_add_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_DEVICE_RESET
)paren
(brace
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|MSG_BUS_DEV_RESET
suffix:semicolon
id|p-&gt;msg_len
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Bus device reset mailed.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_ABORT
)paren
(brace
r_if
c_cond
(paren
id|scb-&gt;tag_action
)paren
(brace
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|MSG_ABORT_TAG
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
op_assign
id|MSG_ABORT
suffix:semicolon
)brace
id|p-&gt;msg_len
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_ABORT_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Abort message mailed.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_PPR
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Sending PPR (%d/%d/%d/%d) message.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
comma
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
comma
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
comma
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
)paren
suffix:semicolon
)brace
id|aic7xxx_construct_ppr
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_WDTR
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Sending WDTR message.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
id|aic7xxx_construct_wdtr
c_func
(paren
id|p
comma
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_SDTR
)paren
(brace
r_int
r_int
id|max_sync
comma
id|period
suffix:semicolon
r_int
r_char
id|options
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;           * Now that the device is selected, use the bits in SBLKCTL and&n;           * SSTAT2 to determine the max sync rate for this device.&n;           */
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
r_if
c_cond
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SBLKCTL
)paren
op_amp
id|ENAB40
)paren
op_logical_and
op_logical_neg
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SSTAT2
)paren
op_amp
id|EXP_ACTIVE
)paren
)paren
(brace
id|max_sync
op_assign
id|AHC_SYNCRATE_ULTRA2
suffix:semicolon
)brace
r_else
(brace
id|max_sync
op_assign
id|AHC_SYNCRATE_ULTRA
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA
)paren
(brace
id|max_sync
op_assign
id|AHC_SYNCRATE_ULTRA
suffix:semicolon
)brace
r_else
(brace
id|max_sync
op_assign
id|AHC_SYNCRATE_FAST
suffix:semicolon
)brace
id|period
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
suffix:semicolon
id|aic7xxx_find_syncrate
c_func
(paren
id|p
comma
op_amp
id|period
comma
id|max_sync
comma
op_amp
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Sending SDTR %d/%d message.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|period
comma
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
)paren
suffix:semicolon
)brace
id|aic7xxx_construct_sdtr
c_func
(paren
id|p
comma
id|period
comma
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
)paren
suffix:semicolon
)brace
r_else
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;aic7xxx: AWAITING_MSG for an SCB that does &quot;
l_string|&quot;not have a waiting message.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;         * We&squot;ve set everything up to send our message, now to actually do&n;         * so we need to enable reqinit interrupts and let the interrupt&n;         * handler do the rest.  We don&squot;t want to unpause the sequencer yet&n;         * though so we&squot;ll return early.  We also have to make sure that&n;         * we clear the SEQINT *BEFORE* we set the REQINIT handler active&n;         * or else it&squot;s possible on VLB cards to loose the first REQINIT&n;         * interrupt.  Edge triggered EISA cards could also loose this&n;         * interrupt, although PCI and level triggered cards should not&n;         * have this problem since they continually interrupt the kernel&n;         * until we take care of the situation.&n;         */
id|scb-&gt;flags
op_or_assign
id|SCB_MSGOUT_SENT
suffix:semicolon
id|p-&gt;msg_index
op_assign
l_int|0
suffix:semicolon
id|p-&gt;msg_type
op_assign
id|MSG_TYPE_INITIATOR_MSGOUT
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|AHC_HANDLING_REQINITS
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SIMODE1
)paren
op_or
id|ENREQINIT
comma
id|SIMODE1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DATA_OVERRUN
suffix:colon
(brace
r_int
r_char
id|scb_index
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
suffix:semicolon
r_int
r_char
id|lastphase
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|LASTPHASE
)paren
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|scb
op_assign
(paren
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;         * XXX - What do we really want to do on an overrun?  The&n;         *       mid-level SCSI code should handle this, but for now,&n;         *       we&squot;ll just indicate that the command should retried.&n;         *    If we retrieved sense info on this target, then the &n;         *    base SENSE info should have been saved prior to the&n;         *    overrun error.  In that case, we return DID_OK and let&n;         *    the mid level code pick up on the sense info.  Otherwise&n;         *    we return DID_ERROR so the command will get retried.&n;         */
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;flags
op_amp
id|SCB_SENSE
)paren
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Data overrun detected in %s phase, tag %d;&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
(paren
id|lastphase
op_eq
id|P_DATAIN
)paren
ques
c_cond
l_string|&quot;Data-In&quot;
suffix:colon
l_string|&quot;Data-Out&quot;
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;  %s seen Data Phase. Length=%d, NumSGs=%d.&bslash;n&quot;
comma
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SEQ_FLAGS
)paren
op_amp
id|DPHASE
)paren
ques
c_cond
l_string|&quot;Have&quot;
suffix:colon
l_string|&quot;Haven&squot;t&quot;
comma
id|scb-&gt;sg_length
comma
id|scb-&gt;sg_count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|scb-&gt;sg_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;     sg[%d] - Addr 0x%x : Length %d&bslash;n&quot;
comma
id|i
comma
id|le32_to_cpu
c_func
(paren
id|scb-&gt;sg_list
(braket
id|i
)braket
dot
id|address
)paren
comma
id|le32_to_cpu
c_func
(paren
id|scb-&gt;sg_list
(braket
id|i
)braket
dot
id|length
)paren
)paren
suffix:semicolon
)brace
id|aic7xxx_error
c_func
(paren
id|scb-&gt;cmd
)paren
op_assign
id|DID_ERROR
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Data Overrun during SEND_SENSE operation.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|WIDE_RESIDUE
suffix:colon
(brace
r_int
r_char
id|resid_sgcnt
comma
id|index
suffix:semicolon
r_int
r_char
id|scb_index
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
suffix:semicolon
r_int
r_int
id|cur_addr
comma
id|resid_dcnt
suffix:semicolon
r_int
r_int
id|native_addr
comma
id|native_length
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|scb_index
OG
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;invalid scb_index during WIDE_RESIDUE.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;           * XXX: Add error handling here&n;           */
r_break
suffix:semicolon
)brace
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_logical_or
(paren
id|scb-&gt;cmd
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;invalid scb during WIDE_RESIDUE flags:0x%x &quot;
l_string|&quot;scb-&gt;cmd:0x%lx&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;flags
comma
(paren
r_int
r_int
)paren
id|scb-&gt;cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;         * We have a valid scb to use on this WIDE_RESIDUE message, so&n;         * we need to walk the sg list looking for this particular sg&n;         * segment, then see if we happen to be at the very beginning of&n;         * the segment.  If we are, then we have to back things up to&n;         * the previous segment.  If not, then we simply need to remove&n;         * one byte from this segments address and add one to the byte&n;         * count.&n;         */
id|cur_addr
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SHADDR
)paren
op_or
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SHADDR
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SHADDR
op_plus
l_int|2
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SHADDR
op_plus
l_int|3
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
id|resid_sgcnt
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_RESID_SGCNT
)paren
suffix:semicolon
id|resid_dcnt
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_RESID_DCNT
)paren
op_or
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_RESID_DCNT
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_RESID_DCNT
op_plus
l_int|2
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|index
op_assign
id|scb-&gt;sg_count
op_minus
(paren
id|resid_sgcnt
op_plus
l_int|1
)paren
suffix:semicolon
id|native_addr
op_assign
id|le32_to_cpu
c_func
(paren
id|scb-&gt;sg_list
(braket
id|index
)braket
dot
id|address
)paren
suffix:semicolon
id|native_length
op_assign
id|le32_to_cpu
c_func
(paren
id|scb-&gt;sg_list
(braket
id|index
)braket
dot
id|length
)paren
suffix:semicolon
multiline_comment|/*&n;         * Make sure this is a valid sg_seg for the given pointer&n;         */
r_if
c_cond
(paren
id|cur_addr
template_param
(paren
id|native_addr
op_plus
id|native_length
op_plus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;invalid cur_addr:0x%x during WIDE_RESIDUE&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|cur_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;  sg_address[-1]:0x%x sg_length[-1]:%d&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|le32_to_cpu
c_func
(paren
id|scb-&gt;sg_list
(braket
id|index
op_minus
l_int|1
)braket
dot
id|address
)paren
comma
id|le32_to_cpu
c_func
(paren
id|scb-&gt;sg_list
(braket
id|index
op_minus
l_int|1
)braket
dot
id|length
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;  sg_address:0x%x sg_length:%d&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|native_addr
comma
id|native_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resid_sgcnt
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;  sg_address[1]:0x%x sg_length[1]:%d&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|le32_to_cpu
c_func
(paren
id|scb-&gt;sg_list
(braket
id|index
op_plus
l_int|1
)braket
dot
id|address
)paren
comma
id|le32_to_cpu
c_func
(paren
id|scb-&gt;sg_list
(braket
id|index
op_plus
l_int|1
)braket
dot
id|length
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;  cur_address:0x%x resid_dcnt:0x%06x&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|cur_addr
comma
id|resid_dcnt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|resid_sgcnt
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|resid_dcnt
op_eq
l_int|0
)paren
op_logical_or
(paren
id|resid_dcnt
op_eq
l_int|0xffffff
)paren
)paren
)paren
(brace
multiline_comment|/*&n;           * We are at the end of the transfer and this is about a byte&n;           * we ignored already (because the sequencer knew this was&n;           * the last segment and set the adapter to ignore any wide&n;           * residue bytes that might come through, which is only done&n;           * on the last scatter gather segment of transfers).&n;           */
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cur_addr
op_eq
id|native_addr
)paren
(brace
multiline_comment|/*&n;           * If our current address matches the sg_seg-&gt;address then we&n;           * have to back up the sg array to the previous segment and set&n;           * it up to have only one byte of transfer left to go.&n;           */
r_if
c_cond
(paren
id|index
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;bogus WIDE_RESIDUE message, no data has been &quot;
l_string|&quot;transferred.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|resid_sgcnt
op_increment
suffix:semicolon
id|index
op_decrement
suffix:semicolon
id|cur_addr
op_assign
id|le32_to_cpu
c_func
(paren
id|scb-&gt;sg_list
(braket
id|index
)braket
dot
id|address
)paren
op_plus
id|le32_to_cpu
c_func
(paren
id|scb-&gt;sg_list
(braket
id|index
)braket
dot
id|length
)paren
op_minus
l_int|1
suffix:semicolon
id|native_addr
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SG_NEXT
)paren
op_or
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SG_NEXT
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SG_NEXT
op_plus
l_int|2
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SG_NEXT
op_plus
l_int|3
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
id|native_addr
op_sub_assign
id|SG_SIZEOF
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|resid_sgcnt
comma
id|SG_COUNT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|resid_sgcnt
comma
id|SCB_RESID_SGCNT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|native_addr
op_amp
l_int|0xff
comma
id|SG_NEXT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|native_addr
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|SG_NEXT
op_plus
l_int|1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|native_addr
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
comma
id|SG_NEXT
op_plus
l_int|2
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|native_addr
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
comma
id|SG_NEXT
op_plus
l_int|3
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|1
comma
id|SCB_RESID_DCNT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCB_RESID_DCNT
op_plus
l_int|1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCB_RESID_DCNT
op_plus
l_int|2
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|1
comma
id|HCNT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|HCNT
op_plus
l_int|1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|HCNT
op_plus
l_int|2
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|cur_addr
op_amp
l_int|0xff
comma
id|HADDR
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|cur_addr
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|HADDR
op_plus
l_int|1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|cur_addr
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
comma
id|HADDR
op_plus
l_int|2
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|cur_addr
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
comma
id|HADDR
op_plus
l_int|3
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;           * Back the data pointer up by one and add one to the remaining&n;           * byte count.  Then store that in the HCNT and HADDR registers.&n;           */
id|cur_addr
op_decrement
suffix:semicolon
id|resid_dcnt
op_increment
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|resid_dcnt
op_amp
l_int|0xff
comma
id|SCB_RESID_DCNT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|resid_dcnt
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|SCB_RESID_DCNT
op_plus
l_int|1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|resid_dcnt
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
comma
id|SCB_RESID_DCNT
op_plus
l_int|2
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|resid_dcnt
op_amp
l_int|0xff
comma
id|HCNT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|resid_dcnt
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|HCNT
op_plus
l_int|1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|resid_dcnt
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
comma
id|HCNT
op_plus
l_int|2
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|cur_addr
op_amp
l_int|0xff
comma
id|HADDR
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|cur_addr
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|HADDR
op_plus
l_int|1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|cur_addr
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
comma
id|HADDR
op_plus
l_int|2
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|cur_addr
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
comma
id|HADDR
op_plus
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;         * The sequencer actually wants to find the new address and byte&n;         * count in the SHCNT and SHADDR register sets.  These registers&n;         * are a shadow of the regular HCNT and HADDR registers.  On the&n;         * Ultra2 controllers, these registers are read only and the way&n;         * we have to set their values is to put the values we want into&n;         * the HCNT and HADDR registers and then output PRELOADEN into&n;         * the DFCNTRL register which causes the card to latch the current&n;         * values in the HADDR and HCNT registers and drop it through to&n;         * the shadow registers.  On older cards we copy them directly&n;         * across by hand.&n;         */
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|DMAPARAMS
)paren
comma
id|DFCNTRL
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SSTAT0
)paren
op_amp
id|SDONE
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
id|i
op_increment
OL
l_int|1000
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|DMAPARAMS
)paren
op_amp
op_complement
(paren
id|SCSIEN
op_or
id|HDMAEN
)paren
comma
id|DFCNTRL
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|DFCNTRL
)paren
op_amp
(paren
id|SCSIEN
op_or
id|HDMAEN
)paren
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
id|i
op_increment
OL
l_int|1000
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|resid_dcnt
op_amp
l_int|0xff
comma
id|STCNT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|resid_dcnt
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|STCNT
op_plus
l_int|1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|resid_dcnt
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
comma
id|STCNT
op_plus
l_int|2
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|cur_addr
op_amp
l_int|0xff
comma
id|SHADDR
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|cur_addr
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|SHADDR
op_plus
l_int|1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|cur_addr
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
comma
id|SHADDR
op_plus
l_int|2
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|cur_addr
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
comma
id|SHADDR
op_plus
l_int|3
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
macro_line|#if AIC7XXX_NOT_YET 
r_case
id|TRACEPOINT
suffix:colon
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Tracepoint #1 reached.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TRACEPOINT2
suffix:colon
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Tracepoint #2 reached.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* XXX Fill these in later */
r_case
id|MSG_BUFFER_BUSY
suffix:colon
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Message buffer busy.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MSGIN_PHASEMIS
suffix:colon
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Message-in phasemis.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
multiline_comment|/* unknown */
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Unknown SEQINT, INTSTAT 0x%x, SCSISIGI 0x%x.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
id|lun
comma
id|intstat
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISIGI
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;   * Clear the sequencer interrupt and unpause the sequencer.&n;   */
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/* unpause always */
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_parse_msg&n; *&n; * Description:&n; *   Parses incoming messages into actions on behalf of&n; *   aic7xxx_handle_reqinit&n; *_F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_parse_msg
id|aic7xxx_parse_msg
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
r_int
id|reject
comma
id|reply
comma
id|done
suffix:semicolon
r_int
r_char
id|target_scsirate
comma
id|tindex
suffix:semicolon
r_int
r_int
id|target_mask
suffix:semicolon
r_int
r_char
id|target
comma
id|channel
comma
id|lun
suffix:semicolon
id|target
op_assign
id|scb-&gt;cmd-&gt;target
suffix:semicolon
id|channel
op_assign
id|scb-&gt;cmd-&gt;channel
suffix:semicolon
id|lun
op_assign
id|scb-&gt;cmd-&gt;lun
suffix:semicolon
id|reply
op_assign
id|reject
op_assign
id|done
op_assign
id|FALSE
suffix:semicolon
id|tindex
op_assign
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
suffix:semicolon
id|target_scsirate
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|TARG_SCSIRATE
op_plus
id|tindex
)paren
suffix:semicolon
id|target_mask
op_assign
(paren
l_int|0x01
op_lshift
id|tindex
)paren
suffix:semicolon
multiline_comment|/*&n;   * Parse as much of the message as is availible,&n;   * rejecting it if we don&squot;t support it.  When&n;   * the entire message is availible and has been&n;   * handled, return TRUE indicating that we have&n;   * parsed an entire message.&n;   */
r_if
c_cond
(paren
id|p-&gt;msg_buf
(braket
l_int|0
)braket
op_ne
id|MSG_EXTENDED
)paren
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;   * Just accept the length byte outright and perform&n;   * more checking once we know the message type.&n;   */
r_if
c_cond
(paren
op_logical_neg
id|reject
op_logical_and
(paren
id|p-&gt;msg_len
OG
l_int|2
)paren
)paren
(brace
r_switch
c_cond
(paren
id|p-&gt;msg_buf
(braket
l_int|2
)braket
)paren
(brace
r_case
id|MSG_EXT_SDTR
suffix:colon
(brace
r_int
r_int
id|period
comma
id|offset
suffix:semicolon
r_int
r_char
id|maxsync
comma
id|saved_offset
comma
id|options
suffix:semicolon
r_struct
id|aic7xxx_syncrate
op_star
id|syncrate
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;msg_buf
(braket
l_int|1
)braket
op_ne
id|MSG_EXT_SDTR_LEN
)paren
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;msg_len
OL
(paren
id|MSG_EXT_SDTR_LEN
op_plus
l_int|2
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|period
op_assign
id|p-&gt;msg_buf
(braket
l_int|3
)braket
suffix:semicolon
id|saved_offset
op_assign
id|offset
op_assign
id|p-&gt;msg_buf
(braket
l_int|4
)braket
suffix:semicolon
id|options
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;         * Even if we are an Ultra3 card, don&squot;t allow Ultra3 sync rates when&n;         * using the SDTR messages.  We need the PPR messages to enable the&n;         * higher speeds that include things like Dual Edge clocking.&n;         */
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
r_if
c_cond
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SBLKCTL
)paren
op_amp
id|ENAB40
)paren
op_logical_and
op_logical_neg
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SSTAT2
)paren
op_amp
id|EXP_ACTIVE
)paren
)paren
(brace
id|maxsync
op_assign
id|AHC_SYNCRATE_ULTRA2
suffix:semicolon
)brace
r_else
(brace
id|maxsync
op_assign
id|AHC_SYNCRATE_ULTRA
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA
)paren
(brace
id|maxsync
op_assign
id|AHC_SYNCRATE_ULTRA
suffix:semicolon
)brace
r_else
(brace
id|maxsync
op_assign
id|AHC_SYNCRATE_FAST
suffix:semicolon
)brace
multiline_comment|/*&n;         * We might have a device that is starting negotiation with us&n;         * before we can start up negotiation with it....be prepared to&n;         * have a device ask for a higher speed then we want to give it&n;         * in that case&n;         */
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
(paren
id|SCB_MSGOUT_SENT
op_or
id|SCB_MSGOUT_SDTR
)paren
)paren
op_ne
(paren
id|SCB_MSGOUT_SENT
op_or
id|SCB_MSGOUT_SDTR
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
id|DEVICE_SCANNED
)paren
op_logical_and
op_logical_neg
(paren
id|p-&gt;needsdtr_copy
op_amp
id|target_mask
)paren
op_logical_and
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_offset
)paren
)paren
(brace
multiline_comment|/*&n;             * Not only is the device starting this up, but it also hasn&squot;t&n;             * been scanned yet, so this would likely be our TUR or our&n;             * INQUIRY command at scan time, so we need to use the&n;             * settings from the SEEPROM if they existed.  Of course, even&n;             * if we didn&squot;t find a SEEPROM, we stuffed default values into&n;             * the user settings anyway, so use those in all cases.&n;             */
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_period
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|MAX_OFFSET_ULTRA2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|cur_width
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|MAX_OFFSET_16BIT
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|MAX_OFFSET_8BIT
suffix:semicolon
)brace
id|p-&gt;needsdtr_copy
op_or_assign
id|target_mask
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Received pre-emptive SDTR message from &quot;
l_string|&quot;target.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
)paren
id|period
op_assign
l_int|255
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
OG
id|period
)paren
id|period
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
suffix:semicolon
)brace
id|syncrate
op_assign
id|aic7xxx_find_syncrate
c_func
(paren
id|p
comma
op_amp
id|period
comma
id|maxsync
comma
op_amp
id|options
)paren
suffix:semicolon
id|aic7xxx_validate_offset
c_func
(paren
id|p
comma
id|syncrate
comma
op_amp
id|offset
comma
id|target_scsirate
op_amp
id|WIDEXFER
)paren
suffix:semicolon
id|aic7xxx_set_syncrate
c_func
(paren
id|p
comma
id|syncrate
comma
id|target
comma
id|channel
comma
id|period
comma
id|offset
comma
id|options
comma
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_CUR
)paren
suffix:semicolon
multiline_comment|/*&n;         * Did we drop to async?  Or are we sending a reply?  If we are,&n;         * then we have to make sure that the reply value reflects the proper&n;         * settings so we need to set the goal values according to what&n;         * we need to send.&n;         */
r_if
c_cond
(paren
(paren
id|offset
op_ne
id|saved_offset
)paren
op_logical_or
(paren
(paren
id|scb-&gt;flags
op_amp
(paren
id|SCB_MSGOUT_SENT
op_or
id|SCB_MSGOUT_SDTR
)paren
)paren
op_ne
(paren
id|SCB_MSGOUT_SENT
op_or
id|SCB_MSGOUT_SDTR
)paren
)paren
)paren
(brace
id|aic7xxx_set_syncrate
c_func
(paren
id|p
comma
id|syncrate
comma
id|target
comma
id|channel
comma
id|period
comma
id|offset
comma
id|options
comma
id|AHC_TRANS_GOAL
op_or
id|AHC_TRANS_QUITE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;         * Did we start this, if not, or if we went to low and had to&n;         * go async, then send an SDTR back to the target&n;         */
id|p-&gt;needsdtr
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|p-&gt;dtr_pending
op_and_assign
op_complement
id|target_mask
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|scb-&gt;flags
op_amp
(paren
id|SCB_MSGOUT_SENT
op_or
id|SCB_MSGOUT_SDTR
)paren
)paren
op_ne
(paren
id|SCB_MSGOUT_SENT
op_or
id|SCB_MSGOUT_SDTR
)paren
)paren
op_logical_or
(paren
id|offset
op_ne
id|saved_offset
)paren
)paren
(brace
id|reply
op_assign
id|TRUE
suffix:semicolon
id|p-&gt;dtr_pending
op_or_assign
id|target_mask
suffix:semicolon
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_MSGOUT_BITS
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_MSGOUT_SDTR
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|HOST_MSG
comma
id|MSG_OUT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISIGO
)paren
op_or
id|ATNO
comma
id|SCSISIGO
)paren
suffix:semicolon
)brace
id|done
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MSG_EXT_WDTR
suffix:colon
(brace
r_int
r_char
id|bus_width
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;msg_buf
(braket
l_int|1
)braket
op_ne
id|MSG_EXT_WDTR_LEN
)paren
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;msg_len
OL
(paren
id|MSG_EXT_WDTR_LEN
op_plus
l_int|2
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|bus_width
op_assign
id|p-&gt;msg_buf
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
(paren
id|SCB_MSGOUT_SENT
op_or
id|SCB_MSGOUT_WDTR
)paren
)paren
op_eq
(paren
id|SCB_MSGOUT_SENT
op_or
id|SCB_MSGOUT_WDTR
)paren
)paren
(brace
r_switch
c_cond
(paren
id|bus_width
)paren
(brace
r_default
suffix:colon
(brace
)brace
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
op_logical_and
(paren
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
id|DEVICE_PRINT_DTR
)paren
op_logical_or
(paren
id|aic7xxx_verbose
OG
l_int|0xffff
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Requesting %d bit transfers, rejecting.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
l_int|8
op_star
(paren
l_int|0x01
op_lshift
id|bus_width
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* We fall through on purpose */
r_case
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:colon
(brace
id|bus_width
op_assign
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:semicolon
id|p-&gt;needwdtr_copy
op_and_assign
op_complement
id|target_mask
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MSG_EXT_WDTR_BUS_16_BIT
suffix:colon
(brace
r_break
suffix:semicolon
)brace
)brace
id|p-&gt;dtr_pending
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|p-&gt;needwdtr
op_and_assign
op_complement
id|target_mask
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
id|DEVICE_SCANNED
)paren
)paren
(brace
multiline_comment|/* &n;             * Well, we now know the WDTR and SYNC caps of this device since&n;             * it contacted us first, mark it as such and copy the user stuff&n;             * over to the goal stuff.&n;             */
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_period
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_offset
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|MAX_OFFSET_ULTRA2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_width
op_logical_and
(paren
id|bus_width
op_eq
id|MSG_EXT_WDTR_BUS_16_BIT
)paren
op_logical_and
id|p-&gt;features
op_amp
id|AHC_WIDE
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|MAX_OFFSET_16BIT
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|MAX_OFFSET_8BIT
suffix:semicolon
)brace
)brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_width
suffix:semicolon
id|p-&gt;needwdtr_copy
op_or_assign
id|target_mask
suffix:semicolon
id|p-&gt;needsdtr_copy
op_or_assign
id|target_mask
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Received pre-emptive WDTR message from &quot;
l_string|&quot;target.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|bus_width
)paren
(brace
r_default
suffix:colon
(brace
)brace
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;features
op_amp
id|AHC_WIDE
)paren
op_logical_and
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
op_eq
id|MSG_EXT_WDTR_BUS_16_BIT
)paren
)paren
(brace
id|bus_width
op_assign
id|MSG_EXT_WDTR_BUS_16_BIT
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Fall through if we aren&squot;t a wide card */
r_case
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:colon
(brace
id|p-&gt;needwdtr_copy
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|bus_width
op_assign
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:semicolon
id|aic7xxx_set_width
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|lun
comma
id|bus_width
comma
id|AHC_TRANS_GOAL
op_or
id|AHC_TRANS_QUITE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|reply
op_assign
id|TRUE
suffix:semicolon
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_MSGOUT_BITS
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_MSGOUT_WDTR
suffix:semicolon
id|p-&gt;needwdtr
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|p-&gt;dtr_pending
op_or_assign
id|target_mask
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|HOST_MSG
comma
id|MSG_OUT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISIGO
)paren
op_or
id|ATNO
comma
id|SCSISIGO
)paren
suffix:semicolon
)brace
id|aic7xxx_set_width
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|lun
comma
id|bus_width
comma
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_CUR
)paren
suffix:semicolon
multiline_comment|/*&n;         * By virtue of the SCSI spec, a WDTR message negates any existing&n;         * SDTR negotiations.  So, even if needsdtr isn&squot;t marked for this&n;         * device, we still have to do a new SDTR message if the device&n;         * supports SDTR at all.  Therefore, we check needsdtr_copy instead&n;         * of needstr.&n;         */
id|aic7xxx_set_syncrate
c_func
(paren
id|p
comma
l_int|NULL
comma
id|target
comma
id|channel
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_CUR
op_or
id|AHC_TRANS_QUITE
)paren
suffix:semicolon
id|p-&gt;needsdtr
op_or_assign
(paren
id|p-&gt;needsdtr_copy
op_amp
id|target_mask
)paren
suffix:semicolon
id|done
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MSG_EXT_PPR
suffix:colon
(brace
r_int
r_char
id|bus_width
comma
id|trans_options
comma
id|new_trans_options
suffix:semicolon
r_int
r_int
id|period
comma
id|offset
suffix:semicolon
r_int
r_char
id|maxsync
comma
id|saved_offset
suffix:semicolon
r_struct
id|aic7xxx_syncrate
op_star
id|syncrate
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;msg_buf
(braket
l_int|1
)braket
op_ne
id|MSG_EXT_PPR_LEN
)paren
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;msg_len
OL
(paren
id|MSG_EXT_PPR_LEN
op_plus
l_int|2
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|period
op_assign
id|p-&gt;msg_buf
(braket
l_int|3
)braket
suffix:semicolon
id|offset
op_assign
id|saved_offset
op_assign
id|p-&gt;msg_buf
(braket
l_int|5
)braket
suffix:semicolon
id|bus_width
op_assign
id|p-&gt;msg_buf
(braket
l_int|6
)braket
suffix:semicolon
id|trans_options
op_assign
id|new_trans_options
op_assign
id|p-&gt;msg_buf
(braket
l_int|7
)braket
op_amp
l_int|0xf
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Parsing PPR message (%d/%d/%d/%d)&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|period
comma
id|offset
comma
id|bus_width
comma
id|trans_options
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SBLKCTL
)paren
op_amp
id|ENAB40
)paren
op_logical_and
op_logical_neg
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SSTAT2
)paren
op_amp
id|EXP_ACTIVE
)paren
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA3
)paren
(brace
id|maxsync
op_assign
id|AHC_SYNCRATE_ULTRA3
suffix:semicolon
)brace
r_else
(brace
id|maxsync
op_assign
id|AHC_SYNCRATE_ULTRA2
suffix:semicolon
)brace
)brace
r_else
(brace
id|maxsync
op_assign
id|AHC_SYNCRATE_ULTRA
suffix:semicolon
)brace
multiline_comment|/*&n;         * We might have a device that is starting negotiation with us&n;         * before we can start up negotiation with it....be prepared to&n;         * have a device ask for a higher speed then we want to give it&n;         * in that case&n;         */
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
(paren
id|SCB_MSGOUT_SENT
op_or
id|SCB_MSGOUT_PPR
)paren
)paren
op_ne
(paren
id|SCB_MSGOUT_SENT
op_or
id|SCB_MSGOUT_PPR
)paren
)paren
(brace
id|reply
op_assign
id|TRUE
suffix:semicolon
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_MSGOUT_BITS
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_MSGOUT_PPR
suffix:semicolon
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_or_assign
id|DEVICE_SCSI_3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
id|DEVICE_SCANNED
)paren
)paren
(brace
multiline_comment|/*&n;             * Not only is the device starting this up, but it also hasn&squot;t&n;             * been scanned yet, so this would likely be our TUR or our&n;             * INQUIRY command at scan time, so we need to use the&n;             * settings from the SEEPROM if they existed.  Of course, even&n;             * if we didn&squot;t find a SEEPROM, we stuffed default values into&n;             * the user settings anyway, so use those in all cases.&n;             */
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_period
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_offset
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|MAX_OFFSET_ULTRA2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_width
op_logical_and
(paren
id|bus_width
op_eq
id|MSG_EXT_WDTR_BUS_16_BIT
)paren
op_logical_and
id|p-&gt;features
op_amp
id|AHC_WIDE
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|MAX_OFFSET_16BIT
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|MAX_OFFSET_8BIT
suffix:semicolon
)brace
)brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_width
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_options
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Received pre-emptive PPR message from &quot;
l_string|&quot;target.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
)paren
id|period
op_assign
l_int|255
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
OG
id|period
)paren
id|period
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
op_eq
l_int|0
)paren
id|new_trans_options
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|bus_width
)paren
(brace
r_default
suffix:colon
(brace
)brace
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;features
op_amp
id|AHC_WIDE
)paren
op_logical_and
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
op_eq
id|MSG_EXT_WDTR_BUS_16_BIT
)paren
)paren
(brace
id|bus_width
op_assign
id|MSG_EXT_WDTR_BUS_16_BIT
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Fall through if we aren&squot;t a wide card */
r_case
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:colon
(brace
id|p-&gt;needwdtr_copy
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|bus_width
op_assign
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:semicolon
id|aic7xxx_set_width
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|lun
comma
id|bus_width
comma
id|AHC_TRANS_GOAL
op_or
id|AHC_TRANS_QUITE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
OG
l_int|9
)paren
op_logical_or
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
op_eq
l_int|0
)paren
)paren
(brace
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_MSGOUT_BITS
suffix:semicolon
id|reject
op_assign
id|TRUE
suffix:semicolon
id|reply
op_assign
id|FALSE
suffix:semicolon
id|p-&gt;needppr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needppr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
)paren
(brace
id|p-&gt;needsdtr
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr_copy
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
)paren
(brace
id|p-&gt;needwdtr
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needwdtr_copy
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_switch
c_cond
(paren
id|bus_width
)paren
(brace
r_default
suffix:colon
(brace
)brace
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
op_logical_and
(paren
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
id|DEVICE_PRINT_DTR
)paren
op_logical_or
(paren
id|aic7xxx_verbose
OG
l_int|0xffff
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Requesting %d bit transfers, rejecting.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
l_int|8
op_star
(paren
l_int|0x01
op_lshift
id|bus_width
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* We fall through on purpose */
r_case
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:colon
(brace
multiline_comment|/*&n;               * According to the spec, if we aren&squot;t wide, we also can&squot;t be&n;               * Dual Edge so clear the options byte&n;               */
id|new_trans_options
op_assign
l_int|0
suffix:semicolon
id|bus_width
op_assign
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MSG_EXT_WDTR_BUS_16_BIT
suffix:colon
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|reject
)paren
(brace
id|aic7xxx_set_width
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|lun
comma
id|bus_width
comma
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_CUR
)paren
suffix:semicolon
id|syncrate
op_assign
id|aic7xxx_find_syncrate
c_func
(paren
id|p
comma
op_amp
id|period
comma
id|maxsync
comma
op_amp
id|new_trans_options
)paren
suffix:semicolon
id|aic7xxx_validate_offset
c_func
(paren
id|p
comma
id|syncrate
comma
op_amp
id|offset
comma
id|bus_width
)paren
suffix:semicolon
id|aic7xxx_set_syncrate
c_func
(paren
id|p
comma
id|syncrate
comma
id|target
comma
id|channel
comma
id|period
comma
id|offset
comma
id|new_trans_options
comma
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_CUR
)paren
suffix:semicolon
)brace
id|p-&gt;dtr_pending
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|p-&gt;needppr
op_and_assign
op_complement
id|target_mask
suffix:semicolon
r_if
c_cond
(paren
id|reply
)paren
(brace
id|p-&gt;dtr_pending
op_or_assign
id|target_mask
suffix:semicolon
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_MSGOUT_BITS
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_MSGOUT_PPR
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|HOST_MSG
comma
id|MSG_OUT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISIGO
)paren
op_or
id|ATNO
comma
id|SCSISIGO
)paren
suffix:semicolon
)brace
id|done
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
(brace
)brace
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* end of switch(p-&gt;msg_type) */
)brace
multiline_comment|/* end of if (!reject &amp;&amp; (p-&gt;msg_len &gt; 2)) */
r_if
c_cond
(paren
op_logical_neg
id|reply
op_logical_and
id|reject
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|MSG_MESSAGE_REJECT
comma
id|MSG_OUT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISIGO
)paren
op_or
id|ATNO
comma
id|SCSISIGO
)paren
suffix:semicolon
id|done
op_assign
id|TRUE
suffix:semicolon
)brace
r_return
id|done
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_handle_reqinit&n; *&n; * Description:&n; *   Interrupt handler for REQINIT interrupts (used to transfer messages to&n; *    and from devices).&n; *_F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_handle_reqinit
id|aic7xxx_handle_reqinit
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
r_int
r_char
id|lastbyte
suffix:semicolon
r_int
r_char
id|phasemis
suffix:semicolon
r_int
id|done
op_assign
id|FALSE
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;msg_type
)paren
(brace
r_case
id|MSG_TYPE_INITIATOR_MSGOUT
suffix:colon
(brace
r_if
c_cond
(paren
id|p-&gt;msg_len
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;aic7xxx: REQINIT with no active message!&bslash;n&quot;
)paren
suffix:semicolon
id|lastbyte
op_assign
(paren
id|p-&gt;msg_index
op_eq
(paren
id|p-&gt;msg_len
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|phasemis
op_assign
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISIGI
)paren
op_amp
id|PHASE_MASK
)paren
op_ne
id|P_MESGOUT
suffix:semicolon
r_if
c_cond
(paren
id|lastbyte
op_logical_or
id|phasemis
)paren
(brace
multiline_comment|/* Time to end the message */
id|p-&gt;msg_len
op_assign
l_int|0
suffix:semicolon
id|p-&gt;msg_type
op_assign
id|MSG_TYPE_NONE
suffix:semicolon
multiline_comment|/*&n;           * NOTE-TO-MYSELF: If you clear the REQINIT after you&n;           * disable REQINITs, then cases of REJECT_MSG stop working&n;           * and hang the bus&n;           */
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SIMODE1
)paren
op_amp
op_complement
id|ENREQINIT
comma
id|SIMODE1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSCSIINT
comma
id|CLRINT
)paren
suffix:semicolon
id|p-&gt;flags
op_and_assign
op_complement
id|AHC_HANDLING_REQINITS
suffix:semicolon
r_if
c_cond
(paren
id|phasemis
op_eq
l_int|0
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
)braket
comma
id|SINDEX
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|RETURN_1
)paren
suffix:semicolon
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_if
c_cond
(paren
id|aic7xxx_verbose
OG
l_int|0xffff
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Completed sending of REQINIT message.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|MSGOUT_PHASEMIS
comma
id|RETURN_1
)paren
suffix:semicolon
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_if
c_cond
(paren
id|aic7xxx_verbose
OG
l_int|0xffff
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;PHASEMIS while sending REQINIT message.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
id|unpause_sequencer
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;           * Present the byte on the bus (clearing REQINIT) but don&squot;t&n;           * unpause the sequencer.&n;           */
id|aic_outb
c_func
(paren
id|p
comma
id|CLRREQINIT
comma
id|CLRSINT1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSCSIINT
comma
id|CLRINT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
op_increment
)braket
comma
id|SCSIDATL
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|MSG_TYPE_INITIATOR_MSGIN
suffix:colon
(brace
id|phasemis
op_assign
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISIGI
)paren
op_amp
id|PHASE_MASK
)paren
op_ne
id|P_MESGIN
suffix:semicolon
r_if
c_cond
(paren
id|phasemis
op_eq
l_int|0
)paren
(brace
id|p-&gt;msg_len
op_increment
suffix:semicolon
multiline_comment|/* Pull the byte in without acking it */
id|p-&gt;msg_buf
(braket
id|p-&gt;msg_index
)braket
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCSIBUSL
)paren
suffix:semicolon
id|done
op_assign
id|aic7xxx_parse_msg
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
multiline_comment|/* Ack the byte */
id|aic_outb
c_func
(paren
id|p
comma
id|CLRREQINIT
comma
id|CLRSINT1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSCSIINT
comma
id|CLRINT
)paren
suffix:semicolon
id|aic_inb
c_func
(paren
id|p
comma
id|SCSIDATL
)paren
suffix:semicolon
id|p-&gt;msg_index
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|phasemis
op_logical_or
id|done
)paren
(brace
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_if
c_cond
(paren
id|aic7xxx_verbose
OG
l_int|0xffff
)paren
(brace
r_if
c_cond
(paren
id|phasemis
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;PHASEMIS while receiving REQINIT message.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Completed receipt of REQINIT message.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Time to end our message session */
id|p-&gt;msg_len
op_assign
l_int|0
suffix:semicolon
id|p-&gt;msg_type
op_assign
id|MSG_TYPE_NONE
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SIMODE1
)paren
op_amp
op_complement
id|ENREQINIT
comma
id|SIMODE1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSCSIINT
comma
id|CLRINT
)paren
suffix:semicolon
id|p-&gt;flags
op_and_assign
op_complement
id|AHC_HANDLING_REQINITS
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_default
suffix:colon
(brace
)brace
(brace
id|panic
c_func
(paren
l_string|&quot;aic7xxx: Unknown REQINIT message type.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* End of switch(p-&gt;msg_type) */
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_handle_scsiint&n; *&n; * Description:&n; *   Interrupt handler for SCSI interrupts (SCSIINT).&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_handle_scsiint
id|aic7xxx_handle_scsiint
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
id|intstat
)paren
(brace
r_int
r_char
id|scb_index
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_struct
id|aic7xxx_scb
op_star
id|scb
suffix:semicolon
id|scb_index
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
suffix:semicolon
id|status
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SSTAT1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_index
OL
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
(brace
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SCSIRSTI
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|channel
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)paren
op_eq
id|AHC_AIC7770
)paren
id|channel
op_assign
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SBLKCTL
)paren
op_amp
id|SELBUSB
)paren
op_rshift
l_int|3
suffix:semicolon
r_else
id|channel
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET
)paren
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Someone else reset the channel!!&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_panic_on_abort
)paren
id|aic7xxx_panic_abort
c_func
(paren
id|p
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;     * Go through and abort all commands for the channel, but do not&n;     * reset the channel again.&n;     */
id|aic7xxx_reset_channel
c_func
(paren
id|p
comma
id|channel
comma
multiline_comment|/* Initiate Reset */
id|FALSE
)paren
suffix:semicolon
id|aic7xxx_run_done_queue
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|status
op_amp
id|BUSFREE
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
(paren
id|status
op_amp
id|SELTO
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;     * First look at what phase we were last in.  If it&squot;s message-out,&n;     * chances are pretty good that the bus free was in response to&n;     * one of our abort requests.&n;     */
r_int
r_char
id|lastphase
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|LASTPHASE
)paren
suffix:semicolon
r_int
r_char
id|saved_tcl
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SAVED_TCL
)paren
suffix:semicolon
r_int
r_char
id|target
op_assign
(paren
id|saved_tcl
op_rshift
l_int|4
)paren
op_amp
l_int|0x0F
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_int
id|printerror
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)paren
op_eq
id|AHC_AIC7770
)paren
id|channel
op_assign
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SBLKCTL
)paren
op_amp
id|SELBUSB
)paren
op_rshift
l_int|3
suffix:semicolon
r_else
id|channel
op_assign
l_int|0
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISEQ
)paren
op_amp
(paren
id|ENSELI
op_or
id|ENRSELI
op_or
id|ENAUTOATNP
)paren
comma
id|SCSISEQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lastphase
op_eq
id|P_MESGOUT
)paren
(brace
r_int
r_char
id|message
suffix:semicolon
id|message
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SINDEX
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|message
op_eq
id|MSG_ABORT
)paren
op_logical_or
(paren
id|message
op_eq
id|MSG_ABORT_TAG
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_ABORT_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;SCB %d abort delivered.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|aic7xxx_reset_device
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|ALL_LUNS
comma
(paren
id|message
op_eq
id|MSG_ABORT
)paren
ques
c_cond
id|SCB_LIST_NULL
suffix:colon
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|aic7xxx_run_done_queue
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
id|printerror
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|message
op_eq
id|MSG_BUS_DEV_RESET
)paren
(brace
id|aic7xxx_handle_device_reset
c_func
(paren
id|p
comma
id|target
comma
id|channel
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
id|printerror
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|scb
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|scb-&gt;cmd
op_eq
id|p-&gt;dev_dtr_cmnd
(braket
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
)braket
)paren
)paren
(brace
multiline_comment|/*&n;       * This might be a SCSI-3 device that is dropping the bus due to&n;       * errors and signalling that we should reduce the transfer speed.&n;       * All we have to do is complete this command (since it&squot;s a negotiation&n;       * command already) and the checksum routine should flag an error and&n;       * reduce the speed setting and renegotiate.  We call the reset routing&n;       * just to clean out the hardware from this scb.&n;       */
id|printerror
op_assign
l_int|0
suffix:semicolon
id|aic7xxx_reset_device
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|ALL_LUNS
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|aic7xxx_run_done_queue
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|printerror
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
)paren
(brace
r_int
r_char
id|tag
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|TAG_ENB
)paren
op_ne
l_int|0
)paren
(brace
id|tag
op_assign
id|scb-&gt;hscb-&gt;tag
suffix:semicolon
)brace
r_else
(brace
id|tag
op_assign
id|SCB_LIST_NULL
suffix:semicolon
)brace
id|aic7xxx_reset_device
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|ALL_LUNS
comma
id|tag
)paren
suffix:semicolon
id|aic7xxx_run_done_queue
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
)brace
r_else
(brace
id|aic7xxx_reset_device
c_func
(paren
id|p
comma
id|target
comma
id|channel
comma
id|ALL_LUNS
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
id|aic7xxx_run_done_queue
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Unexpected busfree, LASTPHASE = 0x%x, &quot;
l_string|&quot;SEQADDR = 0x%x&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
comma
id|target
comma
op_minus
l_int|1
comma
id|lastphase
comma
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SEQADDR1
)paren
op_lshift
l_int|8
)paren
op_or
id|aic_inb
c_func
(paren
id|p
comma
id|SEQADDR0
)paren
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|MSG_NOOP
comma
id|MSG_OUT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SIMODE1
)paren
op_amp
op_complement
(paren
id|ENBUSFREE
op_or
id|ENREQINIT
)paren
comma
id|SIMODE1
)paren
suffix:semicolon
id|p-&gt;flags
op_and_assign
op_complement
id|AHC_HANDLING_REQINITS
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CLRBUSFREE
comma
id|CLRSINT1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSCSIINT
comma
id|CLRINT
)paren
suffix:semicolon
id|restart_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SELTO
)paren
op_ne
l_int|0
)paren
(brace
r_int
r_char
id|scbptr
suffix:semicolon
r_int
r_char
id|nextscb
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|scbptr
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|WAITING_SCBH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scbptr
OG
id|p-&gt;scb_data-&gt;maxhscbs
)paren
(brace
multiline_comment|/*&n;       * I&squot;m still trying to track down exactly how this happens, but until&n;       * I find it, this code will make sure we aren&squot;t passing bogus values&n;       * into the SCBPTR register, even if that register will just wrap&n;       * things around, we still don&squot;t like having out of range variables.&n;       *&n;       * NOTE: Don&squot;t check the aic7xxx_verbose variable, I want this message&n;       * to always be displayed.&n;       */
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Invalid WAITING_SCBH value %d, improvising.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|scbptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;maxhscbs
OG
l_int|4
)paren
id|scbptr
op_and_assign
(paren
id|p-&gt;scb_data-&gt;maxhscbs
op_minus
l_int|1
)paren
suffix:semicolon
r_else
id|scbptr
op_and_assign
l_int|0x03
suffix:semicolon
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|scbptr
comma
id|SCBPTR
)paren
suffix:semicolon
id|scb_index
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|scb_index
OL
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
(brace
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Referenced SCB %d not valid during SELTO.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|scb_index
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;        SCSISEQ = 0x%x SEQADDR = 0x%x SSTAT0 = 0x%x &quot;
l_string|&quot;SSTAT1 = 0x%x&bslash;n&quot;
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISEQ
)paren
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SEQADDR0
)paren
op_or
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SEQADDR1
)paren
op_lshift
l_int|8
)paren
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SSTAT0
)paren
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SSTAT1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_panic_on_abort
)paren
id|aic7xxx_panic_abort
c_func
(paren
id|p
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_TIME_OUT
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/*&n;       * Clear out this hardware SCB&n;       */
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCB_CONTROL
)paren
suffix:semicolon
multiline_comment|/*&n;       * Clear out a few values in the card that are in an undetermined&n;       * state.&n;       */
id|aic_outb
c_func
(paren
id|p
comma
id|MSG_NOOP
comma
id|MSG_OUT
)paren
suffix:semicolon
multiline_comment|/*&n;       * Shift the waiting for selection queue forward&n;       */
id|nextscb
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_NEXT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|nextscb
comma
id|WAITING_SCBH
)paren
suffix:semicolon
multiline_comment|/*&n;       * Put this SCB back on the free list.&n;       */
id|aic7xxx_add_curscb_to_free_list
c_func
(paren
id|p
)paren
suffix:semicolon
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_if
c_cond
(paren
id|aic7xxx_verbose
OG
l_int|0xffff
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Selection Timeout.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_QUEUED_ABORT
)paren
(brace
multiline_comment|/*&n;         * We know that this particular SCB had to be the queued abort since&n;         * the disconnected SCB would have gotten a reconnect instead.&n;         * What we need to do then is to let the command timeout again so&n;         * we get a reset since this abort just failed.&n;         */
id|cmd-&gt;result
op_assign
l_int|0
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb-&gt;cmd
op_eq
id|p-&gt;dev_dtr_cmnd
(braket
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
)braket
)paren
(brace
multiline_comment|/*&n;         * Turn off the needsdtr, needwdtr, and needppr bits since this device&n;         * doesn&squot;t seem to exist.&n;         */
id|p-&gt;needppr
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
)paren
suffix:semicolon
id|p-&gt;needppr_copy
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
)paren
suffix:semicolon
id|p-&gt;needsdtr
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
)paren
suffix:semicolon
id|p-&gt;needsdtr_copy
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
)paren
suffix:semicolon
id|p-&gt;needwdtr
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
)paren
suffix:semicolon
id|p-&gt;needwdtr_copy
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * Keep the sequencer from trying to restart any selections&n;     */
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISEQ
)paren
op_amp
op_complement
id|ENSELO
comma
id|SCSISEQ
)paren
suffix:semicolon
multiline_comment|/*&n;     * Make sure the data bits on the bus are released&n;     * Don&squot;t do this on 7770 chipsets, it makes them give us&n;     * a BRKADDRINT and kills the card.&n;     */
r_if
c_cond
(paren
(paren
id|p-&gt;chip
op_amp
op_complement
id|AHC_CHIPID_MASK
)paren
op_eq
id|AHC_PCI
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCSIBUSL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Delay for the selection timeout delay period then stop the selection&n;     */
id|udelay
c_func
(paren
l_int|301
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSELINGO
comma
id|CLRSINT0
)paren
suffix:semicolon
multiline_comment|/*&n;     * Clear out all the interrupt status bits&n;     */
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SIMODE1
)paren
op_amp
op_complement
(paren
id|ENREQINIT
op_or
id|ENBUSFREE
)paren
comma
id|SIMODE1
)paren
suffix:semicolon
id|p-&gt;flags
op_and_assign
op_complement
id|AHC_HANDLING_REQINITS
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSELTIMEO
op_or
id|CLRBUSFREE
comma
id|CLRSINT1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSCSIINT
comma
id|CLRINT
)paren
suffix:semicolon
multiline_comment|/*&n;     * Restarting the sequencer will stop the selection and make sure devices&n;     * are allowed to reselect in.&n;     */
id|restart_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;aic7xxx_isr - referenced scb not valid &quot;
l_string|&quot;during scsiint 0x%x scb(%d)&bslash;n&quot;
l_string|&quot;      SIMODE0 0x%x, SIMODE1 0x%x, SSTAT0 0x%x, SEQADDR 0x%x&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|status
comma
id|scb_index
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SIMODE0
)paren
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SIMODE1
)paren
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SSTAT0
)paren
comma
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SEQADDR1
)paren
op_lshift
l_int|8
)paren
op_or
id|aic_inb
c_func
(paren
id|p
comma
id|SEQADDR0
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * Turn off the interrupt and set status to zero, so that it&n;     * falls through the rest of the SCSIINT code.&n;     */
id|aic_outb
c_func
(paren
id|p
comma
id|status
comma
id|CLRSINT1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSCSIINT
comma
id|CLRINT
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/* unpause always */
id|TRUE
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|SCSIPERR
)paren
(brace
multiline_comment|/*&n;     * Determine the bus phase and queue an appropriate message.&n;     */
r_char
op_star
id|phase
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_int
r_char
id|mesg_out
op_assign
id|MSG_NOOP
suffix:semicolon
r_int
r_char
id|lastphase
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|LASTPHASE
)paren
suffix:semicolon
r_int
r_char
id|sstat2
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SSTAT2
)paren
suffix:semicolon
r_int
r_char
id|tindex
op_assign
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
suffix:semicolon
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
r_switch
c_cond
(paren
id|lastphase
)paren
(brace
r_case
id|P_DATAOUT
suffix:colon
id|phase
op_assign
l_string|&quot;Data-Out&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_DATAIN
suffix:colon
id|phase
op_assign
l_string|&quot;Data-In&quot;
suffix:semicolon
id|mesg_out
op_assign
id|MSG_INITIATOR_DET_ERR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_COMMAND
suffix:colon
id|phase
op_assign
l_string|&quot;Command&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_MESGOUT
suffix:colon
id|phase
op_assign
l_string|&quot;Message-Out&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_STATUS
suffix:colon
id|phase
op_assign
l_string|&quot;Status&quot;
suffix:semicolon
id|mesg_out
op_assign
id|MSG_INITIATOR_DET_ERR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_MESGIN
suffix:colon
id|phase
op_assign
l_string|&quot;Message-In&quot;
suffix:semicolon
id|mesg_out
op_assign
id|MSG_PARITY_ERROR
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|phase
op_assign
l_string|&quot;unknown&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;     * A parity error has occurred during a data&n;     * transfer phase. Flag it and continue.&n;     */
r_if
c_cond
(paren
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA3
)paren
op_logical_and
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SCSIRATE
)paren
op_amp
id|AHC_SYNCRATE_CRC
)paren
op_logical_and
(paren
id|lastphase
op_eq
id|P_DATAIN
)paren
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;CRC error during %s phase.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|phase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sstat2
op_amp
id|CRCVALERR
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;  CRC error in intermediate CRC packet.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sstat2
op_amp
id|CRCENDERR
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;  CRC error in ending CRC packet.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sstat2
op_amp
id|CRCREQERR
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;  Target incorrectly requested a CRC packet.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sstat2
op_amp
id|DUAL_EDGE_ERROR
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;  Dual Edge transmission error.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|lastphase
op_eq
id|P_MESGOUT
)paren
op_logical_and
(paren
id|cmd
op_eq
id|p-&gt;dev_dtr_cmnd
(braket
id|tindex
)braket
)paren
op_logical_and
(paren
id|scb-&gt;flags
op_amp
id|SCB_MSGOUT_PPR
)paren
)paren
(brace
multiline_comment|/*&n;       * As per the draft specs, any device capable of supporting any of&n;       * the option values other than 0 are not allowed to reject the&n;       * PPR message.  Instead, they must negotiate out what they do&n;       * support instead of rejecting our offering or else they cause&n;       * a parity error during msg_out phase to signal that they don&squot;t&n;       * like our settings.&n;       */
id|p-&gt;needppr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needppr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|aic7xxx_set_width
c_func
(paren
id|p
comma
id|scb-&gt;cmd-&gt;target
comma
id|scb-&gt;cmd-&gt;channel
comma
id|scb-&gt;cmd-&gt;lun
comma
id|MSG_EXT_WDTR_BUS_8_BIT
comma
(paren
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_CUR
op_or
id|AHC_TRANS_QUITE
)paren
)paren
suffix:semicolon
id|aic7xxx_set_syncrate
c_func
(paren
id|p
comma
l_int|NULL
comma
id|scb-&gt;cmd-&gt;target
comma
id|scb-&gt;cmd-&gt;channel
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_CUR
op_or
id|AHC_TRANS_QUITE
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
op_assign
l_int|0
suffix:semicolon
id|p-&gt;dtr_pending
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_MSGOUT_BITS
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;parity error during PPR message, reverting &quot;
l_string|&quot;to WDTR/SDTR&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
)paren
(brace
id|p-&gt;needwdtr
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needwdtr_copy
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_le
l_int|9
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_assign
l_int|10
suffix:semicolon
)brace
id|p-&gt;needsdtr
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr_copy
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
)brace
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
id|DEVICE_PARITY_ERROR
)paren
(brace
r_struct
id|aic7xxx_syncrate
op_star
id|syncrate
suffix:semicolon
r_int
r_int
id|period
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|cur_period
suffix:semicolon
r_int
r_char
id|options
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|cur_options
suffix:semicolon
multiline_comment|/*&n;       * oops, we had a failure, lower the transfer rate and try again.  It&squot;s&n;       * worth noting here that it might be wise to also check for typical&n;       * wide setting on narrow cable type problems and try disabling wide&n;       * instead of slowing down if those exist.  That&squot;s hard to do with simple&n;       * checksums though.&n;       */
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Parity error during %s phase.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|phase
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|syncrate
op_assign
id|aic7xxx_find_syncrate
c_func
(paren
id|p
comma
op_amp
id|period
comma
l_int|0
comma
op_amp
id|options
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|syncrate
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|syncrate-&gt;rate
(braket
l_int|0
)braket
op_ne
l_int|NULL
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_logical_or
(paren
id|syncrate-&gt;sxfr_ultra2
op_eq
l_int|0
)paren
)paren
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_assign
id|syncrate-&gt;period
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
OG
l_int|9
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
op_assign
l_int|0
suffix:semicolon
id|p-&gt;needppr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needppr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr_copy
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
)paren
(brace
id|p-&gt;needwdtr
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needwdtr_copy
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
op_assign
l_int|0
suffix:semicolon
id|p-&gt;needwdtr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needwdtr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_offset
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_period
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_options
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_le
l_int|9
)paren
(brace
id|p-&gt;needppr
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needppr_copy
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;needppr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needppr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr_copy
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_assign
l_int|255
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
op_assign
l_int|0
suffix:semicolon
id|p-&gt;needppr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needwdtr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needppr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needwdtr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
)brace
)brace
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_and_assign
op_complement
id|DEVICE_PARITY_ERROR
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_or_assign
id|DEVICE_PARITY_ERROR
suffix:semicolon
)brace
multiline_comment|/*&n;     * We&squot;ve set the hardware to assert ATN if we get a parity&n;     * error on &quot;in&quot; phases, so all we need to do is stuff the&n;     * message buffer with the appropriate message.  &quot;In&quot; phases&n;     * have set mesg_out to something other than MSG_NOP.&n;     */
r_if
c_cond
(paren
id|mesg_out
op_ne
id|MSG_NOOP
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|mesg_out
comma
id|MSG_OUT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISIGI
)paren
op_or
id|ATNO
comma
id|SCSISIGO
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSCSIPERR
comma
id|CLRSINT1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSCSIINT
comma
id|CLRINT
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/* unpause_always */
id|TRUE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|REQINIT
)paren
op_logical_and
(paren
id|p-&gt;flags
op_amp
id|AHC_HANDLING_REQINITS
)paren
)paren
(brace
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_if
c_cond
(paren
id|aic7xxx_verbose
OG
l_int|0xffff
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Handling REQINIT, SSTAT1=0x%x.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SSTAT1
)paren
)paren
suffix:semicolon
macro_line|#endif
id|aic7xxx_handle_reqinit
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;     * We don&squot;t know what&squot;s going on. Turn off the&n;     * interrupt source and try to continue.&n;     */
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_SCSIINT
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Unknown SCSIINT status, SSTAT1(0x%x).&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|status
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|status
comma
id|CLRSINT1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSCSIINT
comma
id|CLRINT
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/* unpause always */
id|TRUE
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
)paren
(brace
id|aic7xxx_done
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_static
r_void
DECL|function|aic7xxx_check_scbs
id|aic7xxx_check_scbs
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_char
op_star
id|buffer
)paren
(brace
r_int
r_char
id|saved_scbptr
comma
id|free_scbh
comma
id|dis_scbh
comma
id|wait_scbh
comma
id|temp
suffix:semicolon
r_int
id|i
comma
id|bogus
comma
id|lost
suffix:semicolon
r_static
r_int
r_char
id|scb_status
(braket
id|AIC7XXX_MAXSCB
)braket
suffix:semicolon
DECL|macro|SCB_NO_LIST
mdefine_line|#define SCB_NO_LIST 0
DECL|macro|SCB_FREE_LIST
mdefine_line|#define SCB_FREE_LIST 1
DECL|macro|SCB_WAITING_LIST
mdefine_line|#define SCB_WAITING_LIST 2
DECL|macro|SCB_DISCONNECTED_LIST
mdefine_line|#define SCB_DISCONNECTED_LIST 4
DECL|macro|SCB_CURRENTLY_ACTIVE
mdefine_line|#define SCB_CURRENTLY_ACTIVE 8
multiline_comment|/*&n;   * Note, these checks will fail on a regular basis once the machine moves&n;   * beyond the bus scan phase.  The problem is race conditions concerning&n;   * the scbs and where they are linked in.  When you have 30 or so commands&n;   * outstanding on the bus, and run this twice with every interrupt, the&n;   * chances get pretty good that you&squot;ll catch the sequencer with an SCB&n;   * only partially linked in.  Therefore, once we pass the scan phase&n;   * of the bus, we really should disable this function.&n;   */
id|bogus
op_assign
id|FALSE
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|scb_status
(braket
l_int|0
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|scb_status
)paren
)paren
suffix:semicolon
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
id|saved_scbptr
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCBPTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|saved_scbptr
op_ge
id|p-&gt;scb_data-&gt;maxhscbs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bogus SCBPTR %d&bslash;n&quot;
comma
id|saved_scbptr
)paren
suffix:semicolon
id|bogus
op_assign
id|TRUE
suffix:semicolon
)brace
id|scb_status
(braket
id|saved_scbptr
)braket
op_assign
id|SCB_CURRENTLY_ACTIVE
suffix:semicolon
id|free_scbh
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|FREE_SCBH
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|free_scbh
op_ne
id|SCB_LIST_NULL
)paren
op_logical_and
(paren
id|free_scbh
op_ge
id|p-&gt;scb_data-&gt;maxhscbs
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bogus FREE_SCBH %d&bslash;n&quot;
comma
id|free_scbh
)paren
suffix:semicolon
id|bogus
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
id|temp
op_assign
id|free_scbh
suffix:semicolon
r_while
c_loop
(paren
(paren
id|temp
op_ne
id|SCB_LIST_NULL
)paren
op_logical_and
(paren
id|temp
OL
id|p-&gt;scb_data-&gt;maxhscbs
)paren
)paren
(brace
r_if
c_cond
(paren
id|scb_status
(braket
id|temp
)braket
op_amp
l_int|0x07
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HSCB %d on multiple lists, status 0x%02x&quot;
comma
id|temp
comma
id|scb_status
(braket
id|temp
)braket
op_or
id|SCB_FREE_LIST
)paren
suffix:semicolon
id|bogus
op_assign
id|TRUE
suffix:semicolon
)brace
id|scb_status
(braket
id|temp
)braket
op_or_assign
id|SCB_FREE_LIST
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|temp
comma
id|SCBPTR
)paren
suffix:semicolon
id|temp
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_NEXT
)paren
suffix:semicolon
)brace
)brace
id|dis_scbh
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|DISCONNECTED_SCBH
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dis_scbh
op_ne
id|SCB_LIST_NULL
)paren
op_logical_and
(paren
id|dis_scbh
op_ge
id|p-&gt;scb_data-&gt;maxhscbs
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bogus DISCONNECTED_SCBH %d&bslash;n&quot;
comma
id|dis_scbh
)paren
suffix:semicolon
id|bogus
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
id|temp
op_assign
id|dis_scbh
suffix:semicolon
r_while
c_loop
(paren
(paren
id|temp
op_ne
id|SCB_LIST_NULL
)paren
op_logical_and
(paren
id|temp
OL
id|p-&gt;scb_data-&gt;maxhscbs
)paren
)paren
(brace
r_if
c_cond
(paren
id|scb_status
(braket
id|temp
)braket
op_amp
l_int|0x07
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HSCB %d on multiple lists, status 0x%02x&quot;
comma
id|temp
comma
id|scb_status
(braket
id|temp
)braket
op_or
id|SCB_DISCONNECTED_LIST
)paren
suffix:semicolon
id|bogus
op_assign
id|TRUE
suffix:semicolon
)brace
id|scb_status
(braket
id|temp
)braket
op_or_assign
id|SCB_DISCONNECTED_LIST
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|temp
comma
id|SCBPTR
)paren
suffix:semicolon
id|temp
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_NEXT
)paren
suffix:semicolon
)brace
)brace
id|wait_scbh
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|WAITING_SCBH
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|wait_scbh
op_ne
id|SCB_LIST_NULL
)paren
op_logical_and
(paren
id|wait_scbh
op_ge
id|p-&gt;scb_data-&gt;maxhscbs
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bogus WAITING_SCBH %d&bslash;n&quot;
comma
id|wait_scbh
)paren
suffix:semicolon
id|bogus
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
id|temp
op_assign
id|wait_scbh
suffix:semicolon
r_while
c_loop
(paren
(paren
id|temp
op_ne
id|SCB_LIST_NULL
)paren
op_logical_and
(paren
id|temp
OL
id|p-&gt;scb_data-&gt;maxhscbs
)paren
)paren
(brace
r_if
c_cond
(paren
id|scb_status
(braket
id|temp
)braket
op_amp
l_int|0x07
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HSCB %d on multiple lists, status 0x%02x&quot;
comma
id|temp
comma
id|scb_status
(braket
id|temp
)braket
op_or
id|SCB_WAITING_LIST
)paren
suffix:semicolon
id|bogus
op_assign
id|TRUE
suffix:semicolon
)brace
id|scb_status
(braket
id|temp
)braket
op_or_assign
id|SCB_WAITING_LIST
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|temp
comma
id|SCBPTR
)paren
suffix:semicolon
id|temp
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_NEXT
)paren
suffix:semicolon
)brace
)brace
id|lost
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;scb_data-&gt;maxhscbs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|i
comma
id|SCBPTR
)paren
suffix:semicolon
id|temp
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_NEXT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|temp
op_ne
id|SCB_LIST_NULL
)paren
op_logical_and
(paren
id|temp
op_ge
id|p-&gt;scb_data-&gt;maxhscbs
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HSCB %d bad, SCB_NEXT invalid(%d).&bslash;n&quot;
comma
id|i
comma
id|temp
)paren
suffix:semicolon
id|bogus
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|temp
op_eq
id|i
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HSCB %d bad, SCB_NEXT points to self.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|bogus
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb_status
(braket
id|i
)braket
op_eq
l_int|0
)paren
id|lost
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|lost
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Too many lost scbs.&bslash;n&quot;
)paren
suffix:semicolon
id|bogus
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|saved_scbptr
comma
id|SCBPTR
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bogus
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bogus parameters found in card SCB array structures.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
id|aic7xxx_panic_abort
c_func
(paren
id|p
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_handle_command_completion_intr&n; *&n; * Description:&n; *   SCSI command completion interrupt handler.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_handle_command_completion_intr
id|aic7xxx_handle_command_completion_intr
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scb
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_int
r_char
id|scb_index
comma
id|tindex
suffix:semicolon
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_if
c_cond
(paren
(paren
id|p-&gt;isr_count
OL
l_int|16
)paren
op_logical_and
(paren
id|aic7xxx_verbose
OG
l_int|0xffff
)paren
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Command Complete Int.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;   * Read the INTSTAT location after clearing the CMDINT bit.  This forces&n;   * any posted PCI writes to flush to memory.  Gerard Roudier suggested&n;   * this fix to the possible race of clearing the CMDINT bit but not&n;   * having all command bytes flushed onto the qoutfifo.&n;   */
id|aic_outb
c_func
(paren
id|p
comma
id|CLRCMDINT
comma
id|CLRINT
)paren
suffix:semicolon
id|aic_inb
c_func
(paren
id|p
comma
id|INTSTAT
)paren
suffix:semicolon
multiline_comment|/*&n;   * The sequencer will continue running when it&n;   * issues this interrupt. There may be &gt;1 commands&n;   * finished, so loop until we&squot;ve processed them all.&n;   */
r_while
c_loop
(paren
id|p-&gt;qoutfifo
(braket
id|p-&gt;qoutfifonext
)braket
op_ne
id|SCB_LIST_NULL
)paren
(brace
id|scb_index
op_assign
id|p-&gt;qoutfifo
(braket
id|p-&gt;qoutfifonext
)braket
suffix:semicolon
id|p-&gt;qoutfifo
(braket
id|p-&gt;qoutfifonext
op_increment
)braket
op_assign
id|SCB_LIST_NULL
suffix:semicolon
r_if
c_cond
(paren
id|scb_index
op_ge
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;CMDCMPLT with invalid SCB index %d&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|scb_index
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb_index
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_logical_or
(paren
id|scb-&gt;cmd
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;CMDCMPLT without command for SCB %d, SCB flags &quot;
l_string|&quot;0x%x, cmd 0x%lx&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|scb_index
comma
id|scb-&gt;flags
comma
(paren
r_int
r_int
)paren
id|scb-&gt;cmd
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|tindex
op_assign
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_QUEUED_ABORT
)paren
(brace
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|LASTPHASE
)paren
op_amp
id|PHASE_MASK
)paren
op_ne
id|P_BUSFREE
)paren
op_logical_and
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
op_eq
id|scb-&gt;hscb-&gt;tag
)paren
)paren
(brace
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|aic7xxx_reset_device
c_func
(paren
id|p
comma
id|scb-&gt;cmd-&gt;target
comma
id|scb-&gt;cmd-&gt;channel
comma
id|scb-&gt;cmd-&gt;lun
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|scb-&gt;flags
op_and_assign
op_complement
(paren
id|SCB_QUEUED_FOR_DONE
op_or
id|SCB_RESET
op_or
id|SCB_ABORT
op_or
id|SCB_QUEUED_ABORT
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_ABORT
)paren
(brace
multiline_comment|/*&n;       * We started to abort this, but it completed on us, let it&n;       * through as successful&n;       */
id|scb-&gt;flags
op_and_assign
op_complement
(paren
id|SCB_ABORT
op_or
id|SCB_RESET
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_SENSE
)paren
(brace
r_char
op_star
id|buffer
op_assign
op_amp
id|scb-&gt;cmd-&gt;sense_buffer
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;cmd
op_eq
id|p-&gt;dev_dtr_cmnd
(braket
id|tindex
)braket
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|old_scb
suffix:semicolon
multiline_comment|/*&n;         * We have valid sense data, send it back immediately.&n;         */
id|old_scb
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|scb-&gt;cmd-&gt;next-&gt;tag
)braket
suffix:semicolon
op_star
id|old_scb-&gt;cmd-&gt;sense_buffer
op_assign
op_star
id|scb-&gt;cmd-&gt;sense_buffer
suffix:semicolon
id|old_scb-&gt;hscb-&gt;target_status
op_assign
id|scb-&gt;hscb-&gt;target_status
suffix:semicolon
id|old_scb-&gt;cmd-&gt;result
op_assign
id|scb-&gt;hscb-&gt;target_status
suffix:semicolon
id|old_scb-&gt;cmd-&gt;result
op_or_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
id|aic7xxx_status
c_func
(paren
id|old_scb-&gt;cmd
)paren
op_assign
id|scb-&gt;hscb-&gt;target_status
suffix:semicolon
id|scbq_remove
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|old_scb
)paren
suffix:semicolon
id|scbq_remove
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|tindex
)braket
comma
id|old_scb
)paren
suffix:semicolon
id|scb-&gt;cmd-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|aic7xxx_done
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
id|aic7xxx_done
c_func
(paren
id|p
comma
id|old_scb
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|buffer
(braket
l_int|12
)braket
op_eq
l_int|0x47
op_logical_or
id|buffer
(braket
l_int|12
)braket
op_eq
l_int|0x54
)paren
(brace
multiline_comment|/*&n;         * SCSI errors, run domain validation and re-run negotiation&n;         */
id|p-&gt;needdv
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
multiline_comment|/*&n;         * Signal that we need to re-negotiate things, this also gets us our&n;         * INQUIRY command to re-checksum off of.&n;         */
id|p-&gt;needppr
op_or_assign
(paren
id|p-&gt;needppr_copy
op_amp
(paren
l_int|1
op_lshift
id|tindex
)paren
)paren
suffix:semicolon
id|p-&gt;needsdtr
op_or_assign
(paren
id|p-&gt;needsdtr_copy
op_amp
(paren
l_int|1
op_lshift
id|tindex
)paren
)paren
suffix:semicolon
id|p-&gt;needwdtr
op_or_assign
(paren
id|p-&gt;needwdtr_copy
op_amp
(paren
l_int|1
op_lshift
id|tindex
)paren
)paren
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|status_byte
c_func
(paren
id|scb-&gt;hscb-&gt;target_status
)paren
)paren
(brace
r_case
id|QUEUE_FULL
suffix:colon
r_case
id|BUSY
suffix:colon
id|scb-&gt;hscb-&gt;target_status
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;cmd-&gt;result
op_assign
l_int|0
suffix:semicolon
id|aic7xxx_error
c_func
(paren
id|scb-&gt;cmd
)paren
op_assign
id|DID_OK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;hscb-&gt;residual_SG_segment_count
op_ne
l_int|0
)paren
(brace
id|aic7xxx_calculate_residual
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
)brace
id|cmd-&gt;result
op_or_assign
(paren
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|aic7xxx_done
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_isr&n; *&n; * Description:&n; *   SCSI controller interrupt handler.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_isr
id|aic7xxx_isr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
r_int
r_char
id|intstat
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|dev_id
suffix:semicolon
multiline_comment|/*&n;   * Just a few sanity checks.  Make sure that we have an int pending.&n;   * Also, if PCI, then we are going to check for a PCI bus error status&n;   * should we get too many spurious interrupts.&n;   */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|intstat
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|INTSTAT
)paren
)paren
op_amp
id|INT_PEND
)paren
)paren
(brace
macro_line|#ifdef CONFIG_PCI
r_if
c_cond
(paren
(paren
id|p-&gt;chip
op_amp
id|AHC_PCI
)paren
op_logical_and
(paren
id|p-&gt;spurious_int
OG
l_int|500
)paren
op_logical_and
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|AHC_HANDLING_REQINITS
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|ERROR
)paren
op_amp
id|PCIERRSTAT
)paren
(brace
id|aic7xxx_pci_intr
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|p-&gt;spurious_int
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|AHC_HANDLING_REQINITS
)paren
)paren
(brace
id|p-&gt;spurious_int
op_increment
suffix:semicolon
)brace
macro_line|#endif
r_return
suffix:semicolon
)brace
id|p-&gt;spurious_int
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   * Keep track of interrupts for /proc/scsi&n;   */
id|p-&gt;isr_count
op_increment
suffix:semicolon
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_if
c_cond
(paren
(paren
id|p-&gt;isr_count
OL
l_int|16
)paren
op_logical_and
(paren
id|aic7xxx_verbose
OG
l_int|0xffff
)paren
op_logical_and
(paren
id|aic7xxx_panic_on_abort
)paren
op_logical_and
(paren
id|p-&gt;flags
op_amp
id|AHC_PAGESCBS
)paren
)paren
id|aic7xxx_check_scbs
c_func
(paren
id|p
comma
l_string|&quot;Bogus settings at start of interrupt.&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;   * Handle all the interrupt sources - especially for SCSI&n;   * interrupts, we won&squot;t get a second chance at them.&n;   */
r_if
c_cond
(paren
id|intstat
op_amp
id|CMDCMPLT
)paren
(brace
id|aic7xxx_handle_command_completion_intr
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intstat
op_amp
id|BRKADRINT
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|errno
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|ERROR
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;(scsi%d) BRKADRINT error(0x%x):&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|errno
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMBER
c_func
(paren
id|hard_error
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|errno
op_amp
id|hard_error
(braket
id|i
)braket
dot
id|errno
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;  %s&bslash;n&quot;
comma
id|hard_error
(braket
id|i
)braket
dot
id|errmesg
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;(scsi%d)   SEQADDR=0x%x&bslash;n&quot;
comma
id|p-&gt;host_no
comma
(paren
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SEQADDR1
)paren
op_lshift
l_int|8
)paren
op_amp
l_int|0x100
)paren
op_or
id|aic_inb
c_func
(paren
id|p
comma
id|SEQADDR0
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_panic_on_abort
)paren
id|aic7xxx_panic_abort
c_func
(paren
id|p
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
r_if
c_cond
(paren
id|errno
op_amp
id|PCIERRSTAT
)paren
id|aic7xxx_pci_intr
c_func
(paren
id|p
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|errno
op_amp
(paren
id|SQPARERR
op_or
id|ILLOPCODE
op_or
id|ILLSADDR
)paren
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;aic7xxx: unrecoverable BRKADRINT.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|errno
op_amp
id|ILLHADDR
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;(scsi%d) BUG! Driver accessed chip without first &quot;
l_string|&quot;pausing controller!&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_if
c_cond
(paren
id|errno
op_amp
id|DPARERR
)paren
(brace
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|DMAPARAMS
)paren
op_amp
id|DIRECTION
)paren
id|printk
c_func
(paren
l_string|&quot;(scsi%d) while DMAing SCB from host to card.&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;(scsi%d) while DMAing SCB from card to host.&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
macro_line|#endif
id|aic_outb
c_func
(paren
id|p
comma
id|CLRPARERR
op_or
id|CLRBRKADRINT
comma
id|CLRINT
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intstat
op_amp
id|SEQINT
)paren
(brace
multiline_comment|/*&n;     * Read the CCSCBCTL register to work around a bug in the Ultra2 cards&n;     */
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
id|aic_inb
c_func
(paren
id|p
comma
id|CCSCBCTL
)paren
suffix:semicolon
)brace
id|aic7xxx_handle_seqint
c_func
(paren
id|p
comma
id|intstat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intstat
op_amp
id|SCSIINT
)paren
(brace
id|aic7xxx_handle_scsiint
c_func
(paren
id|p
comma
id|intstat
)paren
suffix:semicolon
)brace
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_if
c_cond
(paren
(paren
id|p-&gt;isr_count
OL
l_int|16
)paren
op_logical_and
(paren
id|aic7xxx_verbose
OG
l_int|0xffff
)paren
op_logical_and
(paren
id|aic7xxx_panic_on_abort
)paren
op_logical_and
(paren
id|p-&gt;flags
op_amp
id|AHC_PAGESCBS
)paren
)paren
id|aic7xxx_check_scbs
c_func
(paren
id|p
comma
l_string|&quot;Bogus settings at end of interrupt.&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   do_aic7xxx_isr&n; *&n; * Description:&n; *   This is a gross hack to solve a problem in linux kernels 2.1.85 and&n; *   above.  Please, children, do not try this at home, and if you ever see&n; *   anything like it, please inform the Gross Hack Police immediately&n; *-F*************************************************************************/
r_static
r_void
DECL|function|do_aic7xxx_isr
id|do_aic7xxx_isr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|cpu_flags
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|dev_id
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|cpu_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|AHC_IN_ISR_BIT
comma
(paren
r_void
op_star
)paren
op_amp
id|p-&gt;flags
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|cpu_flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_do
(brace
id|aic7xxx_isr
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|INTSTAT
)paren
op_amp
id|INT_PEND
)paren
)paren
suffix:semicolon
id|aic7xxx_done_cmds_complete
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic7xxx_run_waiting_queues
c_func
(paren
id|p
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|AHC_IN_ISR_BIT
comma
(paren
r_void
op_star
)paren
op_amp
id|p-&gt;flags
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|cpu_flags
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_device_queue_depth&n; *&n; * Description:&n; *   Determines the queue depth for a given device.  There are two ways&n; *   a queue depth can be obtained for a tagged queueing device.  One&n; *   way is the default queue depth which is determined by whether&n; *   AIC7XXX_CMDS_PER_DEVICE is defined.  If it is defined, then it is used&n; *   as the default queue depth.  Otherwise, we use either 4 or 8 as the&n; *   default queue depth (dependent on the number of hardware SCBs).&n; *   The other way we determine queue depth is through the use of the&n; *   aic7xxx_tag_info array which is enabled by defining&n; *   AIC7XXX_TAGGED_QUEUEING_BY_DEVICE.  This array can be initialized&n; *   with queue depths for individual devices.  It also allows tagged&n; *   queueing to be [en|dis]abled for a specific adapter.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_device_queue_depth
id|aic7xxx_device_queue_depth
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
id|Scsi_Device
op_star
id|device
)paren
(brace
r_int
id|default_depth
op_assign
l_int|3
suffix:semicolon
r_int
r_char
id|tindex
suffix:semicolon
r_int
r_int
id|target_mask
suffix:semicolon
id|tindex
op_assign
id|device-&gt;id
op_or
(paren
id|device-&gt;channel
op_lshift
l_int|3
)paren
suffix:semicolon
id|target_mask
op_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;dev_max_queue_depth
(braket
id|tindex
)braket
OG
l_int|1
)paren
(brace
multiline_comment|/*&n;     * We&squot;ve already scanned this device, leave it alone&n;     */
r_return
id|p-&gt;dev_max_queue_depth
(braket
id|tindex
)braket
suffix:semicolon
)brace
id|device-&gt;queue_depth
op_assign
id|default_depth
suffix:semicolon
id|p-&gt;dev_temp_queue_depth
(braket
id|tindex
)braket
op_assign
l_int|1
suffix:semicolon
id|p-&gt;dev_max_queue_depth
(braket
id|tindex
)braket
op_assign
l_int|1
suffix:semicolon
id|p-&gt;tagenable
op_and_assign
op_complement
id|target_mask
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;tagged_supported
)paren
(brace
r_int
id|tag_enabled
op_assign
id|TRUE
suffix:semicolon
id|default_depth
op_assign
id|AIC7XXX_CMDS_PER_DEVICE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;discenable
op_amp
id|target_mask
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Disconnection disabled, unable to &quot;
l_string|&quot;enable tagged queueing.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|device-&gt;channel
comma
id|device-&gt;id
comma
id|device-&gt;lun
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|p-&gt;instance
op_ge
id|NUMBER
c_func
(paren
id|aic7xxx_tag_info
)paren
)paren
(brace
r_static
r_int
id|print_warning
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|print_warning
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: WARNING, insufficient tag_info instances for&quot;
l_string|&quot; installed controllers.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Please update the aic7xxx_tag_info array in&quot;
l_string|&quot; the aic7xxx.c source file.&bslash;n&quot;
)paren
suffix:semicolon
id|print_warning
op_assign
id|FALSE
suffix:semicolon
)brace
id|device-&gt;queue_depth
op_assign
id|default_depth
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|aic7xxx_tag_info
(braket
id|p-&gt;instance
)braket
dot
id|tag_commands
(braket
id|tindex
)braket
op_eq
l_int|255
)paren
(brace
id|tag_enabled
op_assign
id|FALSE
suffix:semicolon
id|device-&gt;queue_depth
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* Tagged queueing is disabled. */
)brace
r_else
r_if
c_cond
(paren
id|aic7xxx_tag_info
(braket
id|p-&gt;instance
)braket
dot
id|tag_commands
(braket
id|tindex
)braket
op_eq
l_int|0
)paren
(brace
id|device-&gt;queue_depth
op_assign
id|default_depth
suffix:semicolon
)brace
r_else
(brace
id|device-&gt;queue_depth
op_assign
id|aic7xxx_tag_info
(braket
id|p-&gt;instance
)braket
dot
id|tag_commands
(braket
id|tindex
)braket
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|device-&gt;tagged_queue
op_eq
l_int|0
)paren
op_logical_and
id|tag_enabled
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Enabled tagged queuing, queue depth %d.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|device-&gt;channel
comma
id|device-&gt;id
comma
id|device-&gt;lun
comma
id|device-&gt;queue_depth
)paren
suffix:semicolon
)brace
id|p-&gt;dev_max_queue_depth
(braket
id|tindex
)braket
op_assign
id|device-&gt;queue_depth
suffix:semicolon
id|p-&gt;dev_temp_queue_depth
(braket
id|tindex
)braket
op_assign
id|device-&gt;queue_depth
suffix:semicolon
id|p-&gt;tagenable
op_or_assign
id|target_mask
suffix:semicolon
id|p-&gt;orderedtag
op_or_assign
id|target_mask
suffix:semicolon
id|device-&gt;tagged_queue
op_assign
l_int|1
suffix:semicolon
id|device-&gt;current_tag
op_assign
id|SCB_LIST_NULL
suffix:semicolon
)brace
)brace
)brace
r_return
id|p-&gt;dev_max_queue_depth
(braket
id|tindex
)braket
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_select_queue_depth&n; *&n; * Description:&n; *   Sets the queue depth for each SCSI device hanging off the input&n; *   host adapter.  We use a queue depth of 2 for devices that do not&n; *   support tagged queueing.  If AIC7XXX_CMDS_PER_LUN is defined, we&n; *   use that for tagged queueing devices; otherwise we use our own&n; *   algorithm for determining the queue depth based on the maximum&n; *   SCBs for the controller.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_select_queue_depth
id|aic7xxx_select_queue_depth
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
id|Scsi_Device
op_star
id|scsi_devs
)paren
(brace
id|Scsi_Device
op_star
id|device
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
id|scbnum
suffix:semicolon
id|scbnum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|device
op_assign
id|scsi_devs
suffix:semicolon
id|device
op_ne
l_int|NULL
suffix:semicolon
id|device
op_assign
id|device-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;host
op_eq
id|host
)paren
(brace
id|scbnum
op_add_assign
id|aic7xxx_device_queue_depth
c_func
(paren
id|p
comma
id|device
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|scbnum
OG
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
multiline_comment|/*&n;     * Pre-allocate the needed SCBs to get around the possibility of having&n;     * to allocate some when memory is more or less exhausted and we need&n;     * the SCB in order to perform a swap operation (possible deadlock)&n;     */
r_if
c_cond
(paren
id|aic7xxx_allocate_scb
c_func
(paren
id|p
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_probe&n; *&n; * Description:&n; *   Probing for EISA boards: it looks like the first two bytes&n; *   are a manufacturer code - three characters, five bits each:&n; *&n; *               BYTE 0   BYTE 1   BYTE 2   BYTE 3&n; *              ?1111122 22233333 PPPPPPPP RRRRRRRR&n; *&n; *   The characters are baselined off ASCII &squot;@&squot;, so add that value&n; *   to each to get the real ASCII code for it. The next two bytes&n; *   appear to be a product and revision number, probably vendor-&n; *   specific. This is what is being searched for at each port,&n; *   and what should probably correspond to the ID= field in the&n; *   ECU&squot;s .cfg file for the card - if your card is not detected,&n; *   make sure your signature is listed in the array.&n; *&n; *   The fourth byte&squot;s lowest bit seems to be an enabled/disabled&n; *   flag (rest of the bits are reserved?).&n; *&n; * NOTE:  This function is only needed on Intel and Alpha platforms,&n; *   the other platforms we support don&squot;t have EISA/VLB busses.  So,&n; *   we #ifdef this entire function to avoid compiler warnings about&n; *   an unused function.&n; *-F*************************************************************************/
macro_line|#if defined(__i386__) || defined(__alpha__)
r_static
r_int
DECL|function|aic7xxx_probe
id|aic7xxx_probe
c_func
(paren
r_int
id|slot
comma
r_int
id|base
comma
id|ahc_flag_type
op_star
id|flags
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|4
)braket
suffix:semicolon
r_static
r_struct
(brace
r_int
id|n
suffix:semicolon
r_int
r_char
id|signature
(braket
r_sizeof
(paren
id|buf
)paren
)braket
suffix:semicolon
id|ahc_chip
id|type
suffix:semicolon
r_int
id|bios_disabled
suffix:semicolon
)brace
id|AIC7xxx
(braket
)braket
op_assign
(brace
(brace
l_int|4
comma
(brace
l_int|0x04
comma
l_int|0x90
comma
l_int|0x77
comma
l_int|0x70
)brace
comma
id|AHC_AIC7770
op_or
id|AHC_EISA
comma
id|FALSE
)brace
comma
multiline_comment|/* mb 7770  */
(brace
l_int|4
comma
(brace
l_int|0x04
comma
l_int|0x90
comma
l_int|0x77
comma
l_int|0x71
)brace
comma
id|AHC_AIC7770
op_or
id|AHC_EISA
comma
id|FALSE
)brace
comma
multiline_comment|/* host adapter 274x */
(brace
l_int|4
comma
(brace
l_int|0x04
comma
l_int|0x90
comma
l_int|0x77
comma
l_int|0x56
)brace
comma
id|AHC_AIC7770
op_or
id|AHC_VL
comma
id|FALSE
)brace
comma
multiline_comment|/* 284x BIOS enabled */
(brace
l_int|4
comma
(brace
l_int|0x04
comma
l_int|0x90
comma
l_int|0x77
comma
l_int|0x57
)brace
comma
id|AHC_AIC7770
op_or
id|AHC_VL
comma
id|TRUE
)brace
multiline_comment|/* 284x BIOS disabled */
)brace
suffix:semicolon
multiline_comment|/*&n;   * The VL-bus cards need to be primed by&n;   * writing before a signature check.&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|buf
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
l_int|0x80
op_plus
id|i
comma
id|base
)paren
suffix:semicolon
id|buf
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|base
op_plus
id|i
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMBER
c_func
(paren
id|AIC7xxx
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;     * Signature match on enabled card?&n;     */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|buf
comma
id|AIC7xxx
(braket
id|i
)braket
dot
id|signature
comma
id|AIC7xxx
(braket
id|i
)braket
dot
id|n
)paren
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|base
op_plus
l_int|4
)paren
op_amp
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|AIC7xxx
(braket
id|i
)braket
dot
id|bios_disabled
)paren
(brace
op_star
id|flags
op_or_assign
id|AHC_USEDEFAULTS
suffix:semicolon
)brace
r_else
(brace
op_star
id|flags
op_or_assign
id|AHC_BIOS_ENABLED
suffix:semicolon
)brace
r_return
(paren
id|i
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: &lt;Adaptec 7770 SCSI Host Adapter&gt; &quot;
l_string|&quot;disabled at slot %d, ignored.&bslash;n&quot;
comma
id|slot
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif /* (__i386__) || (__alpha__) */
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   read_2840_seeprom&n; *&n; * Description:&n; *   Reads the 2840 serial EEPROM and returns 1 if successful and 0 if&n; *   not successful.&n; *&n; *   See read_seeprom (for the 2940) for the instruction set of the 93C46&n; *   chip.&n; *&n; *   The 2840 interface to the 93C46 serial EEPROM is through the&n; *   STATUS_2840 and SEECTL_2840 registers.  The CS_2840, CK_2840, and&n; *   DO_2840 bits of the SEECTL_2840 register are connected to the chip&n; *   select, clock, and data out lines respectively of the serial EEPROM.&n; *   The DI_2840 bit of the STATUS_2840 is connected to the data in line&n; *   of the serial EEPROM.  The EEPROM_TF bit of STATUS_2840 register is&n; *   useful in that it gives us an 800 nsec timer.  After a read from the&n; *   SEECTL_2840 register the timing flag is cleared and goes high 800 nsec&n; *   later.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|read_284x_seeprom
id|read_284x_seeprom
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|seeprom_config
op_star
id|sc
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|k
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|temp
suffix:semicolon
r_int
r_int
id|checksum
op_assign
l_int|0
suffix:semicolon
r_int
r_int
op_star
id|seeprom
op_assign
(paren
r_int
r_int
op_star
)paren
id|sc
suffix:semicolon
r_struct
id|seeprom_cmd
(brace
r_int
r_char
id|len
suffix:semicolon
r_int
r_char
id|bits
(braket
l_int|3
)braket
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|seeprom_cmd
id|seeprom_read
op_assign
(brace
l_int|3
comma
(brace
l_int|1
comma
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|macro|CLOCK_PULSE
mdefine_line|#define CLOCK_PULSE(p) &bslash;&n;  while ((aic_inb(p, STATUS_2840) &amp; EEPROM_TF) == 0)        &bslash;&n;  {                                                &bslash;&n;    ;  /* Do nothing */                                &bslash;&n;  }                                                &bslash;&n;  (void) aic_inb(p, SEECTL_2840);
multiline_comment|/*&n;   * Read the first 32 registers of the seeprom.  For the 2840,&n;   * the 93C46 SEEPROM is a 1024-bit device with 64 16-bit registers&n;   * but only the first 32 are used by Adaptec BIOS.  The loop&n;   * will range from 0 to 31.&n;   */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
(paren
r_sizeof
(paren
op_star
id|sc
)paren
op_div
l_int|2
)paren
suffix:semicolon
id|k
op_increment
)paren
(brace
multiline_comment|/*&n;     * Send chip select for one clock cycle.&n;     */
id|aic_outb
c_func
(paren
id|p
comma
id|CK_2840
op_or
id|CS_2840
comma
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;     * Now we&squot;re ready to send the read command followed by the&n;     * address of the 16-bit register we want to read.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|seeprom_read.len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|temp
op_assign
id|CS_2840
op_or
id|seeprom_read.bits
(braket
id|i
)braket
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|temp
comma
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|temp
op_assign
id|temp
op_xor
id|CK_2840
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|temp
comma
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Send the 6 bit address (MSB first, LSB last).&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|5
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|temp
op_assign
id|k
suffix:semicolon
id|temp
op_assign
(paren
id|temp
op_rshift
id|i
)paren
op_amp
l_int|1
suffix:semicolon
multiline_comment|/* Mask out all but lower bit. */
id|temp
op_assign
id|CS_2840
op_or
id|temp
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|temp
comma
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|temp
op_assign
id|temp
op_xor
id|CK_2840
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|temp
comma
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Now read the 16 bit register.  An initial 0 precedes the&n;     * register contents which begins with bit 15 (MSB) and ends&n;     * with bit 0 (LSB).  The initial 0 will be shifted off the&n;     * top of our word as we let the loop run from 0 to 16.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|temp
op_assign
id|CS_2840
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|temp
comma
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|temp
op_assign
id|temp
op_xor
id|CK_2840
suffix:semicolon
id|seeprom
(braket
id|k
)braket
op_assign
(paren
id|seeprom
(braket
id|k
)braket
op_lshift
l_int|1
)paren
op_or
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|STATUS_2840
)paren
op_amp
id|DI_2840
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|temp
comma
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * The serial EEPROM has a checksum in the last word.  Keep a&n;     * running checksum for all words read except for the last&n;     * word.  We&squot;ll verify the checksum after all words have been&n;     * read.&n;     */
r_if
c_cond
(paren
id|k
OL
(paren
r_sizeof
(paren
op_star
id|sc
)paren
op_div
l_int|2
)paren
op_minus
l_int|1
)paren
(brace
id|checksum
op_assign
id|checksum
op_plus
id|seeprom
(braket
id|k
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;     * Reset the chip select for the next command cycle.&n;     */
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CK_2840
comma
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SEECTL_2840
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;Computed checksum 0x%x, checksum read 0x%x&bslash;n&quot;
comma
id|checksum
comma
id|sc-&gt;checksum
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Serial EEPROM:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
(paren
r_sizeof
(paren
op_star
id|sc
)paren
op_div
l_int|2
)paren
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|k
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|k
op_ne
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n              &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; 0x%x&quot;
comma
id|seeprom
(braket
id|k
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|checksum
op_ne
id|sc-&gt;checksum
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: SEEPROM checksum error, ignoring SEEPROM settings.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
DECL|macro|CLOCK_PULSE
macro_line|#undef CLOCK_PULSE
)brace
DECL|macro|CLOCK_PULSE
mdefine_line|#define CLOCK_PULSE(p)                                               &bslash;&n;  do {                                                               &bslash;&n;    int limit = 0;                                                   &bslash;&n;    do {                                                             &bslash;&n;      mb();                                                          &bslash;&n;      pause_sequencer(p);  /* This is just to generate some PCI */   &bslash;&n;                           /* traffic so the PCI read is flushed */  &bslash;&n;                           /* it shouldn&squot;t be needed, but some */    &bslash;&n;                           /* chipsets do indeed appear to need */   &bslash;&n;                           /* something to force PCI reads to get */ &bslash;&n;                           /* flushed */                             &bslash;&n;      udelay(1);           /* Do nothing */                          &bslash;&n;    } while (((aic_inb(p, SEECTL) &amp; SEERDY) == 0) &amp;&amp; (++limit &lt; 1000)); &bslash;&n;  } while(0)
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   acquire_seeprom&n; *&n; * Description:&n; *   Acquires access to the memory port on PCI controllers.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|acquire_seeprom
id|acquire_seeprom
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
multiline_comment|/*&n;   * Request access of the memory port.  When access is&n;   * granted, SEERDY will go high.  We use a 1 second&n;   * timeout which should be near 1 second more than&n;   * is needed.  Reason: after the 7870 chip reset, there&n;   * should be no contention.&n;   */
id|aic_outb
c_func
(paren
id|p
comma
id|SEEMS
comma
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SEECTL
)paren
op_amp
id|SEERDY
)paren
op_eq
l_int|0
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SEECTL
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   release_seeprom&n; *&n; * Description:&n; *   Releases access to the memory port on PCI controllers.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|release_seeprom
id|release_seeprom
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
multiline_comment|/*&n;   * Make sure the SEEPROM is ready before we release it.&n;   */
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SEECTL
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   read_seeprom&n; *&n; * Description:&n; *   Reads the serial EEPROM and returns 1 if successful and 0 if&n; *   not successful.&n; *&n; *   The instruction set of the 93C46/56/66 chips is as follows:&n; *&n; *               Start  OP&n; *     Function   Bit  Code  Address    Data     Description&n; *     -------------------------------------------------------------------&n; *     READ        1    10   A5 - A0             Reads data stored in memory,&n; *                                               starting at specified address&n; *     EWEN        1    00   11XXXX              Write enable must precede&n; *                                               all programming modes&n; *     ERASE       1    11   A5 - A0             Erase register A5A4A3A2A1A0&n; *     WRITE       1    01   A5 - A0   D15 - D0  Writes register&n; *     ERAL        1    00   10XXXX              Erase all registers&n; *     WRAL        1    00   01XXXX    D15 - D0  Writes to all registers&n; *     EWDS        1    00   00XXXX              Disables all programming&n; *                                               instructions&n; *     *Note: A value of X for address is a don&squot;t care condition.&n; *     *Note: The 93C56 and 93C66 have 8 address bits.&n; * &n; *&n; *   The 93C46 has a four wire interface: clock, chip select, data in, and&n; *   data out.  In order to perform one of the above functions, you need&n; *   to enable the chip select for a clock period (typically a minimum of&n; *   1 usec, with the clock high and low a minimum of 750 and 250 nsec&n; *   respectively.  While the chip select remains high, you can clock in&n; *   the instructions (above) starting with the start bit, followed by the&n; *   OP code, Address, and Data (if needed).  For the READ instruction, the&n; *   requested 16-bit register contents is read from the data out line but&n; *   is preceded by an initial zero (leading 0, followed by 16-bits, MSB&n; *   first).  The clock cycling from low to high initiates the next data&n; *   bit to be sent from the chip.&n; *&n; *   The 78xx interface to the 93C46 serial EEPROM is through the SEECTL&n; *   register.  After successful arbitration for the memory port, the&n; *   SEECS bit of the SEECTL register is connected to the chip select.&n; *   The SEECK, SEEDO, and SEEDI are connected to the clock, data out,&n; *   and data in lines respectively.  The SEERDY bit of SEECTL is useful&n; *   in that it gives us an 800 nsec timer.  After a write to the SEECTL&n; *   register, the SEERDY goes high 800 nsec later.  The one exception&n; *   to this is when we first request access to the memory port.  The&n; *   SEERDY goes high to signify that access has been granted and, for&n; *   this case, has no implied timing.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|read_seeprom
id|read_seeprom
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|offset
comma
r_int
r_int
op_star
id|scarray
comma
r_int
r_int
id|len
comma
id|seeprom_chip_type
id|chip
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|k
suffix:semicolon
r_int
r_char
id|temp
suffix:semicolon
r_int
r_int
id|checksum
op_assign
l_int|0
suffix:semicolon
r_struct
id|seeprom_cmd
(brace
r_int
r_char
id|len
suffix:semicolon
r_int
r_char
id|bits
(braket
l_int|3
)braket
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|seeprom_cmd
id|seeprom_read
op_assign
(brace
l_int|3
comma
(brace
l_int|1
comma
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/*&n;   * Request access of the memory port.&n;   */
r_if
c_cond
(paren
id|acquire_seeprom
c_func
(paren
id|p
)paren
op_eq
l_int|0
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * Read &squot;len&squot; registers of the seeprom.  For the 7870, the 93C46&n;   * SEEPROM is a 1024-bit device with 64 16-bit registers but only&n;   * the first 32 are used by Adaptec BIOS.  Some adapters use the&n;   * 93C56 SEEPROM which is a 2048-bit device.  The loop will range&n;   * from 0 to &squot;len&squot; - 1.&n;   */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|len
suffix:semicolon
id|k
op_increment
)paren
(brace
multiline_comment|/*&n;     * Send chip select for one clock cycle.&n;     */
id|aic_outb
c_func
(paren
id|p
comma
id|SEEMS
op_or
id|SEECK
op_or
id|SEECS
comma
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;     * Now we&squot;re ready to send the read command followed by the&n;     * address of the 16-bit register we want to read.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|seeprom_read.len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|temp
op_assign
id|SEEMS
op_or
id|SEECS
op_or
(paren
id|seeprom_read.bits
(braket
id|i
)braket
op_lshift
l_int|1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|temp
comma
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|temp
op_assign
id|temp
op_xor
id|SEECK
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|temp
comma
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Send the 6 or 8 bit address (MSB first, LSB last).&n;     */
r_for
c_loop
(paren
id|i
op_assign
(paren
(paren
r_int
)paren
id|chip
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|temp
op_assign
id|k
op_plus
id|offset
suffix:semicolon
id|temp
op_assign
(paren
id|temp
op_rshift
id|i
)paren
op_amp
l_int|1
suffix:semicolon
multiline_comment|/* Mask out all but lower bit. */
id|temp
op_assign
id|SEEMS
op_or
id|SEECS
op_or
(paren
id|temp
op_lshift
l_int|1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|temp
comma
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|temp
op_assign
id|temp
op_xor
id|SEECK
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|temp
comma
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Now read the 16 bit register.  An initial 0 precedes the&n;     * register contents which begins with bit 15 (MSB) and ends&n;     * with bit 0 (LSB).  The initial 0 will be shifted off the&n;     * top of our word as we let the loop run from 0 to 16.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|temp
op_assign
id|SEEMS
op_or
id|SEECS
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|temp
comma
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|temp
op_assign
id|temp
op_xor
id|SEECK
suffix:semicolon
id|scarray
(braket
id|k
)braket
op_assign
(paren
id|scarray
(braket
id|k
)braket
op_lshift
l_int|1
)paren
op_or
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SEECTL
)paren
op_amp
id|SEEDI
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|temp
comma
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * The serial EEPROM should have a checksum in the last word.&n;     * Keep a running checksum for all words read except for the&n;     * last word.  We&squot;ll verify the checksum after all words have&n;     * been read.&n;     */
r_if
c_cond
(paren
id|k
OL
(paren
id|len
op_minus
l_int|1
)paren
)paren
(brace
id|checksum
op_assign
id|checksum
op_plus
id|scarray
(braket
id|k
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;     * Reset the chip select for the next command cycle.&n;     */
id|aic_outb
c_func
(paren
id|p
comma
id|SEEMS
comma
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|SEEMS
op_or
id|SEECK
comma
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|SEEMS
comma
id|SEECTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * Release access to the memory port and the serial EEPROM.&n;   */
id|release_seeprom
c_func
(paren
id|p
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;Computed checksum 0x%x, checksum read 0x%x&bslash;n&quot;
comma
id|checksum
comma
id|scarray
(braket
id|len
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Serial EEPROM:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|len
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|k
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|k
op_ne
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n              &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; 0x%x&quot;
comma
id|scarray
(braket
id|k
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|checksum
op_ne
id|scarray
(braket
id|len
op_minus
l_int|1
)braket
)paren
op_logical_or
(paren
id|checksum
op_eq
l_int|0
)paren
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   read_brdctl&n; *&n; * Description:&n; *   Reads the BRDCTL register.&n; *-F*************************************************************************/
r_static
r_int
r_char
DECL|function|read_brdctl
id|read_brdctl
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_int
r_char
id|brdctl
comma
id|value
suffix:semicolon
multiline_comment|/*&n;   * Make sure the SEEPROM is ready before we access it&n;   */
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
id|brdctl
op_assign
id|BRDRW_ULTRA2
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|brdctl
comma
id|BRDCTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|value
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|BRDCTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
id|brdctl
op_assign
id|BRDRW
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|p-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)paren
op_eq
id|AHC_AIC7895
)paren
op_logical_or
(paren
id|p-&gt;flags
op_amp
id|AHC_CHNLB
)paren
)paren
(brace
id|brdctl
op_or_assign
id|BRDCS
suffix:semicolon
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|brdctl
comma
id|BRDCTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|value
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|BRDCTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|BRDCTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
(paren
id|value
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   write_brdctl&n; *&n; * Description:&n; *   Writes a value to the BRDCTL register.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|write_brdctl
id|write_brdctl
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
id|value
)paren
(brace
r_int
r_char
id|brdctl
suffix:semicolon
multiline_comment|/*&n;   * Make sure the SEEPROM is ready before we access it&n;   */
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
id|brdctl
op_assign
id|value
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|brdctl
comma
id|BRDCTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|brdctl
op_or_assign
id|BRDSTB_ULTRA2
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|brdctl
comma
id|BRDCTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|brdctl
op_and_assign
op_complement
id|BRDSTB_ULTRA2
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|brdctl
comma
id|BRDCTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|read_brdctl
c_func
(paren
id|p
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
id|brdctl
op_assign
id|BRDSTB
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|p-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)paren
op_eq
id|AHC_AIC7895
)paren
op_logical_or
(paren
id|p-&gt;flags
op_amp
id|AHC_CHNLB
)paren
)paren
(brace
id|brdctl
op_or_assign
id|BRDCS
suffix:semicolon
)brace
id|brdctl
op_assign
id|BRDSTB
op_or
id|BRDCS
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|brdctl
comma
id|BRDCTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|brdctl
op_or_assign
id|value
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|brdctl
comma
id|BRDCTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|brdctl
op_and_assign
op_complement
id|BRDSTB
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|brdctl
comma
id|BRDCTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|brdctl
op_and_assign
op_complement
id|BRDCS
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|brdctl
comma
id|BRDCTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic785x_cable_detect&n; *&n; * Description:&n; *   Detect the cables that are present on aic785x class controller chips&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic785x_cable_detect
id|aic785x_cable_detect
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
op_star
id|int_50
comma
r_int
op_star
id|ext_present
comma
r_int
op_star
id|eeprom
)paren
(brace
r_int
r_char
id|brdctl
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|BRDRW
op_or
id|BRDCS
comma
id|BRDCTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|BRDCTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
id|brdctl
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|BRDCTL
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|p
)paren
suffix:semicolon
op_star
id|int_50
op_assign
op_logical_neg
(paren
id|brdctl
op_amp
id|BRDDAT5
)paren
suffix:semicolon
op_star
id|ext_present
op_assign
op_logical_neg
(paren
id|brdctl
op_amp
id|BRDDAT6
)paren
suffix:semicolon
op_star
id|eeprom
op_assign
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SPIOCAP
)paren
op_amp
id|EEPROM
)paren
suffix:semicolon
)brace
DECL|macro|CLOCK_PULSE
macro_line|#undef CLOCK_PULSE
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic2940_uwpro_cable_detect&n; *&n; * Description:&n; *   Detect the cables that are present on the 2940-UWPro cards&n; *&n; * NOTE: This function assumes the SEEPROM will have already been acquired&n; *       prior to invocation of this function.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic2940_uwpro_wide_cable_detect
id|aic2940_uwpro_wide_cable_detect
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
op_star
id|int_68
comma
r_int
op_star
id|ext_68
comma
r_int
op_star
id|eeprom
)paren
(brace
r_int
r_char
id|brdctl
suffix:semicolon
multiline_comment|/*&n;   * First read the status of our cables.  Set the rom bank to&n;   * 0 since the bank setting serves as a multiplexor for the&n;   * cable detection logic.  BRDDAT5 controls the bank switch.&n;   */
id|write_brdctl
c_func
(paren
id|p
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;   * Now we read the state of the internal 68 connector.  BRDDAT6&n;   * is don&squot;t care, BRDDAT7 is internal 68.  The cable is&n;   * present if the bit is 0&n;   */
id|brdctl
op_assign
id|read_brdctl
c_func
(paren
id|p
)paren
suffix:semicolon
op_star
id|int_68
op_assign
op_logical_neg
(paren
id|brdctl
op_amp
id|BRDDAT7
)paren
suffix:semicolon
multiline_comment|/*&n;   * Set the bank bit in brdctl and then read the external cable state&n;   * and the EEPROM status&n;   */
id|write_brdctl
c_func
(paren
id|p
comma
id|BRDDAT5
)paren
suffix:semicolon
id|brdctl
op_assign
id|read_brdctl
c_func
(paren
id|p
)paren
suffix:semicolon
op_star
id|ext_68
op_assign
op_logical_neg
(paren
id|brdctl
op_amp
id|BRDDAT6
)paren
suffix:semicolon
op_star
id|eeprom
op_assign
op_logical_neg
(paren
id|brdctl
op_amp
id|BRDDAT7
)paren
suffix:semicolon
multiline_comment|/*&n;   * We&squot;re done, the calling function will release the SEEPROM for us&n;   */
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic787x_cable_detect&n; *&n; * Description:&n; *   Detect the cables that are present on aic787x class controller chips&n; *&n; * NOTE: This function assumes the SEEPROM will have already been acquired&n; *       prior to invocation of this function.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic787x_cable_detect
id|aic787x_cable_detect
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
op_star
id|int_50
comma
r_int
op_star
id|int_68
comma
r_int
op_star
id|ext_present
comma
r_int
op_star
id|eeprom
)paren
(brace
r_int
r_char
id|brdctl
suffix:semicolon
multiline_comment|/*&n;   * First read the status of our cables.  Set the rom bank to&n;   * 0 since the bank setting serves as a multiplexor for the&n;   * cable detection logic.  BRDDAT5 controls the bank switch.&n;   */
id|write_brdctl
c_func
(paren
id|p
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;   * Now we read the state of the two internal connectors.  BRDDAT6&n;   * is internal 50, BRDDAT7 is internal 68.  For each, the cable is&n;   * present if the bit is 0&n;   */
id|brdctl
op_assign
id|read_brdctl
c_func
(paren
id|p
)paren
suffix:semicolon
op_star
id|int_50
op_assign
op_logical_neg
(paren
id|brdctl
op_amp
id|BRDDAT6
)paren
suffix:semicolon
op_star
id|int_68
op_assign
op_logical_neg
(paren
id|brdctl
op_amp
id|BRDDAT7
)paren
suffix:semicolon
multiline_comment|/*&n;   * Set the bank bit in brdctl and then read the external cable state&n;   * and the EEPROM status&n;   */
id|write_brdctl
c_func
(paren
id|p
comma
id|BRDDAT5
)paren
suffix:semicolon
id|brdctl
op_assign
id|read_brdctl
c_func
(paren
id|p
)paren
suffix:semicolon
op_star
id|ext_present
op_assign
op_logical_neg
(paren
id|brdctl
op_amp
id|BRDDAT6
)paren
suffix:semicolon
op_star
id|eeprom
op_assign
op_logical_neg
(paren
id|brdctl
op_amp
id|BRDDAT7
)paren
suffix:semicolon
multiline_comment|/*&n;   * We&squot;re done, the calling function will release the SEEPROM for us&n;   */
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic787x_ultra2_term_detect&n; *&n; * Description:&n; *   Detect the termination settings present on ultra2 class controllers&n; *&n; * NOTE: This function assumes the SEEPROM will have already been acquired&n; *       prior to invocation of this function.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_ultra2_term_detect
id|aic7xxx_ultra2_term_detect
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
op_star
id|enableSE_low
comma
r_int
op_star
id|enableSE_high
comma
r_int
op_star
id|enableLVD_low
comma
r_int
op_star
id|enableLVD_high
comma
r_int
op_star
id|eprom_present
)paren
(brace
r_int
r_char
id|brdctl
suffix:semicolon
id|brdctl
op_assign
id|read_brdctl
c_func
(paren
id|p
)paren
suffix:semicolon
op_star
id|eprom_present
op_assign
(paren
id|brdctl
op_amp
id|BRDDAT7
)paren
suffix:semicolon
op_star
id|enableSE_high
op_assign
(paren
id|brdctl
op_amp
id|BRDDAT6
)paren
suffix:semicolon
op_star
id|enableSE_low
op_assign
(paren
id|brdctl
op_amp
id|BRDDAT5
)paren
suffix:semicolon
op_star
id|enableLVD_high
op_assign
(paren
id|brdctl
op_amp
id|BRDDAT4
)paren
suffix:semicolon
op_star
id|enableLVD_low
op_assign
(paren
id|brdctl
op_amp
id|BRDDAT3
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   configure_termination&n; *&n; * Description:&n; *   Configures the termination settings on PCI adapters that have&n; *   SEEPROMs available.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|configure_termination
id|configure_termination
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_int
id|internal50_present
op_assign
l_int|0
suffix:semicolon
r_int
id|internal68_present
op_assign
l_int|0
suffix:semicolon
r_int
id|external_present
op_assign
l_int|0
suffix:semicolon
r_int
id|eprom_present
op_assign
l_int|0
suffix:semicolon
r_int
id|enableSE_low
op_assign
l_int|0
suffix:semicolon
r_int
id|enableSE_high
op_assign
l_int|0
suffix:semicolon
r_int
id|enableLVD_low
op_assign
l_int|0
suffix:semicolon
r_int
id|enableLVD_high
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|brddat
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|max_target
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|sxfrctl1
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SXFRCTL1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acquire_seeprom
c_func
(paren
id|p
)paren
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
(paren
id|AHC_WIDE
op_or
id|AHC_TWIN
)paren
)paren
id|max_target
op_assign
l_int|16
suffix:semicolon
r_else
id|max_target
op_assign
l_int|8
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|SEEMS
op_or
id|SEECS
comma
id|SEECTL
)paren
suffix:semicolon
id|sxfrctl1
op_and_assign
op_complement
id|STPWEN
suffix:semicolon
multiline_comment|/*&n;     * The termination/cable detection logic is split into three distinct&n;     * groups.  Ultra2 and later controllers, 2940UW-Pro controllers, and&n;     * older 7850, 7860, 7870, 7880, and 7895 controllers.  Each has its&n;     * own unique way of detecting their cables and writing the results&n;     * back to the card.&n;     */
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
multiline_comment|/*&n;       * As long as user hasn&squot;t overridden term settings, always check the&n;       * cable detection logic&n;       */
r_if
c_cond
(paren
id|aic7xxx_override_term
op_eq
op_minus
l_int|1
)paren
(brace
id|aic7xxx_ultra2_term_detect
c_func
(paren
id|p
comma
op_amp
id|enableSE_low
comma
op_amp
id|enableSE_high
comma
op_amp
id|enableLVD_low
comma
op_amp
id|enableLVD_high
comma
op_amp
id|eprom_present
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;       * If the user is overriding settings, then they have been preserved&n;       * to here as fake adapter_control entries.  Parse them and allow&n;       * them to override the detected settings (if we even did detection).&n;       */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;adapter_control
op_amp
id|CFSEAUTOTERM
)paren
)paren
(brace
id|enableSE_low
op_assign
(paren
id|p-&gt;adapter_control
op_amp
id|CFSTERM
)paren
suffix:semicolon
id|enableSE_high
op_assign
(paren
id|p-&gt;adapter_control
op_amp
id|CFWSTERM
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;adapter_control
op_amp
id|CFAUTOTERM
)paren
)paren
(brace
id|enableLVD_low
op_assign
id|enableLVD_high
op_assign
(paren
id|p-&gt;adapter_control
op_amp
id|CFLVDSTERM
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;       * Now take those settings that we have and translate them into the&n;       * values that must be written into the registers.&n;       *&n;       * Flash Enable = BRDDAT7&n;       * Secondary High Term Enable = BRDDAT6&n;       * Secondary Low Term Enable = BRDDAT5&n;       * LVD/Primary High Term Enable = BRDDAT4&n;       * LVD/Primary Low Term Enable = STPWEN bit in SXFRCTL1&n;       */
r_if
c_cond
(paren
id|enableLVD_low
op_ne
l_int|0
)paren
(brace
id|sxfrctl1
op_or_assign
id|STPWEN
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|AHC_TERM_ENB_LVD
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) LVD/Primary Low byte termination &quot;
l_string|&quot;Enabled&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|enableLVD_high
op_ne
l_int|0
)paren
(brace
id|brddat
op_or_assign
id|BRDDAT4
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) LVD/Primary High byte termination &quot;
l_string|&quot;Enabled&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|enableSE_low
op_ne
l_int|0
)paren
(brace
id|brddat
op_or_assign
id|BRDDAT5
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Secondary Low byte termination &quot;
l_string|&quot;Enabled&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|enableSE_high
op_ne
l_int|0
)paren
(brace
id|brddat
op_or_assign
id|BRDDAT6
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Secondary High byte termination &quot;
l_string|&quot;Enabled&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_NEW_AUTOTERM
)paren
(brace
multiline_comment|/*&n;       * The 50 pin connector termination is controlled by STPWEN in the&n;       * SXFRCTL1 register.  Since the Adaptec docs typically say the&n;       * controller is not allowed to be in the middle of a cable and&n;       * this is the only connection on that stub of the bus, there is&n;       * no need to even check for narrow termination, it&squot;s simply&n;       * always on.&n;       */
id|sxfrctl1
op_or_assign
id|STPWEN
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Narrow channel termination Enabled&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;adapter_control
op_amp
id|CFAUTOTERM
)paren
(brace
id|aic2940_uwpro_wide_cable_detect
c_func
(paren
id|p
comma
op_amp
id|internal68_present
comma
op_amp
id|external_present
comma
op_amp
id|eprom_present
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Cables present (Int-50 %s, Int-68 %s, &quot;
l_string|&quot;Ext-68 %s)&bslash;n&quot;
comma
id|p-&gt;host_no
comma
l_string|&quot;Don&squot;t Care&quot;
comma
id|internal68_present
ques
c_cond
l_string|&quot;YES&quot;
suffix:colon
l_string|&quot;NO&quot;
comma
id|external_present
ques
c_cond
l_string|&quot;YES&quot;
suffix:colon
l_string|&quot;NO&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) EEPROM %s present.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|eprom_present
ques
c_cond
l_string|&quot;is&quot;
suffix:colon
l_string|&quot;is not&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|internal68_present
op_logical_and
id|external_present
)paren
(brace
id|brddat
op_assign
l_int|0
suffix:semicolon
id|p-&gt;flags
op_and_assign
op_complement
id|AHC_TERM_ENB_SE_HIGH
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Wide channel termination Disabled&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
r_else
(brace
id|brddat
op_assign
id|BRDDAT6
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|AHC_TERM_ENB_SE_HIGH
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Wide channel termination Enabled&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;         * The termination of the Wide channel is done more like normal&n;         * though, and the setting of this termination is done by writing&n;         * either a 0 or 1 to BRDDAT6 of the BRDDAT register&n;         */
r_if
c_cond
(paren
id|p-&gt;adapter_control
op_amp
id|CFWSTERM
)paren
(brace
id|brddat
op_assign
id|BRDDAT6
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|AHC_TERM_ENB_SE_HIGH
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Wide channel termination Enabled&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
r_else
(brace
id|brddat
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|p-&gt;adapter_control
op_amp
id|CFAUTOTERM
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|AHC_MOTHERBOARD
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Warning - detected auto-termination&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Please verify driver detected settings &quot;
l_string|&quot;are correct.&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) If not, then please properly set the &quot;
l_string|&quot;device termination&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) in the Adaptec SCSI BIOS by hitting &quot;
l_string|&quot;CTRL-A when prompted&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) during machine bootup.&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
multiline_comment|/* Configure auto termination. */
r_if
c_cond
(paren
(paren
id|p-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)paren
op_ge
id|AHC_AIC7870
)paren
(brace
id|aic787x_cable_detect
c_func
(paren
id|p
comma
op_amp
id|internal50_present
comma
op_amp
id|internal68_present
comma
op_amp
id|external_present
comma
op_amp
id|eprom_present
)paren
suffix:semicolon
)brace
r_else
(brace
id|aic785x_cable_detect
c_func
(paren
id|p
comma
op_amp
id|internal50_present
comma
op_amp
id|external_present
comma
op_amp
id|eprom_present
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|max_target
op_le
l_int|8
)paren
id|internal68_present
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|max_target
OG
l_int|8
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Cables present (Int-50 %s, Int-68 %s, &quot;
l_string|&quot;Ext-68 %s)&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|internal50_present
ques
c_cond
l_string|&quot;YES&quot;
suffix:colon
l_string|&quot;NO&quot;
comma
id|internal68_present
ques
c_cond
l_string|&quot;YES&quot;
suffix:colon
l_string|&quot;NO&quot;
comma
id|external_present
ques
c_cond
l_string|&quot;YES&quot;
suffix:colon
l_string|&quot;NO&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Cables present (Int-50 %s, Ext-50 %s)&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|internal50_present
ques
c_cond
l_string|&quot;YES&quot;
suffix:colon
l_string|&quot;NO&quot;
comma
id|external_present
ques
c_cond
l_string|&quot;YES&quot;
suffix:colon
l_string|&quot;NO&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) EEPROM %s present.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|eprom_present
ques
c_cond
l_string|&quot;is&quot;
suffix:colon
l_string|&quot;is not&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;         * Now set the termination based on what we found.  BRDDAT6&n;         * controls wide termination enable.&n;         * Flash Enable = BRDDAT7&n;         * SE High Term Enable = BRDDAT6&n;         */
r_if
c_cond
(paren
id|internal50_present
op_logical_and
id|internal68_present
op_logical_and
id|external_present
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Illegal cable configuration!!  Only two&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) connectors on the SCSI controller may be &quot;
l_string|&quot;in use at a time!&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
multiline_comment|/*&n;           * Force termination (low and high byte) on.  This is safer than&n;           * leaving it completely off, especially since this message comes&n;           * most often from motherboard controllers that don&squot;t even have 3&n;           * connectors, but instead are failing the cable detection.&n;           */
id|internal50_present
op_assign
id|external_present
op_assign
l_int|0
suffix:semicolon
id|enableSE_high
op_assign
id|enableSE_low
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|max_target
OG
l_int|8
)paren
op_logical_and
(paren
(paren
id|external_present
op_eq
l_int|0
)paren
op_logical_or
(paren
id|internal68_present
op_eq
l_int|0
)paren
)paren
)paren
(brace
id|brddat
op_or_assign
id|BRDDAT6
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|AHC_TERM_ENB_SE_HIGH
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) SE High byte termination Enabled&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|internal50_present
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
op_plus
(paren
id|internal68_present
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
op_plus
(paren
id|external_present
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
op_le
l_int|1
)paren
(brace
id|sxfrctl1
op_or_assign
id|STPWEN
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|AHC_TERM_ENB_SE_LOW
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) SE Low byte termination Enabled&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* p-&gt;adapter_control &amp; CFAUTOTERM */
(brace
r_if
c_cond
(paren
id|p-&gt;adapter_control
op_amp
id|CFSTERM
)paren
(brace
id|sxfrctl1
op_or_assign
id|STPWEN
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) SE Low byte termination Enabled&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;adapter_control
op_amp
id|CFWSTERM
)paren
(brace
id|brddat
op_or_assign
id|BRDDAT6
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) SE High byte termination Enabled&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
)brace
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|sxfrctl1
comma
id|SXFRCTL1
)paren
suffix:semicolon
id|write_brdctl
c_func
(paren
id|p
comma
id|brddat
)paren
suffix:semicolon
id|release_seeprom
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   detect_maxscb&n; *&n; * Description:&n; *   Detects the maximum number of SCBs for the controller and returns&n; *   the count and a mask in p (p-&gt;maxscbs, p-&gt;qcntmask).&n; *-F*************************************************************************/
r_static
r_void
DECL|function|detect_maxscb
id|detect_maxscb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;   * It&squot;s possible that we&squot;ve already done this for multichannel&n;   * adapters.&n;   */
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;maxhscbs
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;     * We haven&squot;t initialized the SCB settings yet.  Walk the SCBs to&n;     * determince how many there are.&n;     */
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|FREE_SCBH
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AIC7XXX_MAXSCB
suffix:semicolon
id|i
op_increment
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|i
comma
id|SCBPTR
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|i
comma
id|SCB_CONTROL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_CONTROL
)paren
op_ne
id|i
)paren
r_break
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCBPTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_CONTROL
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|i
comma
id|SCBPTR
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCB_CONTROL
)paren
suffix:semicolon
multiline_comment|/* Clear the control byte. */
id|aic_outb
c_func
(paren
id|p
comma
id|i
op_plus
l_int|1
comma
id|SCB_NEXT
)paren
suffix:semicolon
multiline_comment|/* Set the next pointer. */
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|SCB_TAG
)paren
suffix:semicolon
multiline_comment|/* Make the tag invalid. */
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|SCB_BUSYTARGETS
)paren
suffix:semicolon
multiline_comment|/* no busy untagged */
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|SCB_BUSYTARGETS
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* targets active yet */
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|SCB_BUSYTARGETS
op_plus
l_int|2
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|SCB_BUSYTARGETS
op_plus
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/* Make sure the last SCB terminates the free list. */
id|aic_outb
c_func
(paren
id|p
comma
id|i
op_minus
l_int|1
comma
id|SCBPTR
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|SCB_NEXT
)paren
suffix:semicolon
multiline_comment|/* Ensure we clear the first (0) SCBs control byte. */
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCBPTR
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCB_CONTROL
)paren
suffix:semicolon
id|p-&gt;scb_data-&gt;maxhscbs
op_assign
id|i
suffix:semicolon
multiline_comment|/*&n;     * Use direct indexing instead for speed&n;     */
r_if
c_cond
(paren
id|i
op_eq
id|AIC7XXX_MAXSCB
)paren
id|p-&gt;flags
op_and_assign
op_complement
id|AHC_PAGESCBS
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_register&n; *&n; * Description:&n; *   Register a Adaptec aic7xxx chip SCSI controller with the kernel.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_register
id|aic7xxx_register
c_func
(paren
id|Scsi_Host_Template
op_star
r_template
comma
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
id|reset_delay
)paren
(brace
r_int
id|i
comma
id|result
suffix:semicolon
r_int
id|max_targets
suffix:semicolon
r_int
id|found
op_assign
l_int|1
suffix:semicolon
r_int
r_char
id|term
comma
id|scsi_conf
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|host
op_assign
id|p-&gt;host
suffix:semicolon
id|p-&gt;scb_data-&gt;maxscbs
op_assign
id|AIC7XXX_MAXSCB
suffix:semicolon
id|host-&gt;can_queue
op_assign
id|AIC7XXX_MAXSCB
suffix:semicolon
id|host-&gt;cmd_per_lun
op_assign
l_int|3
suffix:semicolon
id|host-&gt;sg_tablesize
op_assign
id|AIC7XXX_MAX_SG
suffix:semicolon
id|host-&gt;select_queue_depths
op_assign
id|aic7xxx_select_queue_depth
suffix:semicolon
id|host-&gt;this_id
op_assign
id|p-&gt;scsi_id
suffix:semicolon
id|host-&gt;io_port
op_assign
id|p-&gt;base
suffix:semicolon
id|host-&gt;n_io_port
op_assign
l_int|0xFF
suffix:semicolon
id|host-&gt;base
op_assign
id|p-&gt;mbase
suffix:semicolon
id|host-&gt;irq
op_assign
id|p-&gt;irq
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_WIDE
)paren
(brace
id|host-&gt;max_id
op_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_TWIN
)paren
(brace
id|host-&gt;max_channel
op_assign
l_int|1
suffix:semicolon
)brace
id|p-&gt;host
op_assign
id|host
suffix:semicolon
id|p-&gt;host_no
op_assign
id|host-&gt;host_no
suffix:semicolon
id|host-&gt;unique_id
op_assign
id|p-&gt;instance
suffix:semicolon
id|p-&gt;isr_count
op_assign
l_int|0
suffix:semicolon
id|p-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;completeq.head
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;completeq.tail
op_assign
l_int|NULL
suffix:semicolon
id|scbq_init
c_func
(paren
op_amp
id|p-&gt;scb_data-&gt;free_scbs
)paren
suffix:semicolon
id|scbq_init
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|p-&gt;dev_timer
)paren
suffix:semicolon
id|p-&gt;dev_timer.data
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
id|p-&gt;dev_timer.function
op_assign
(paren
r_void
op_star
)paren
id|aic7xxx_timer
suffix:semicolon
id|p-&gt;dev_timer_active
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   * We currently have no commands of any type&n;   */
id|p-&gt;qinfifonext
op_assign
l_int|0
suffix:semicolon
id|p-&gt;qoutfifonext
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGETS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|p-&gt;dev_commands_sent
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|p-&gt;dev_flags
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|p-&gt;dev_active_cmds
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|p-&gt;dev_last_queue_full
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|p-&gt;dev_last_queue_full_count
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|p-&gt;dev_max_queue_depth
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
id|p-&gt;dev_temp_queue_depth
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
id|p-&gt;dev_expires
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|scbq_init
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) &lt;%s&gt; found at &quot;
comma
id|p-&gt;host_no
comma
id|board_names
(braket
id|p-&gt;board_name_index
)braket
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;chip
)paren
(brace
r_case
(paren
id|AHC_AIC7770
op_or
id|AHC_EISA
)paren
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EISA slot %d&bslash;n&quot;
comma
id|p-&gt;pci_device_fn
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
id|AHC_AIC7770
op_or
id|AHC_VL
)paren
suffix:colon
id|printk
c_func
(paren
l_string|&quot;VLB slot %d&bslash;n&quot;
comma
id|p-&gt;pci_device_fn
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;PCI %d/%d/%d&bslash;n&quot;
comma
id|p-&gt;pci_bus
comma
id|PCI_SLOT
c_func
(paren
id|p-&gt;pci_device_fn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|p-&gt;pci_device_fn
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_TWIN
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Twin Channel, A SCSI ID %d, B SCSI ID %d, &quot;
comma
id|p-&gt;host_no
comma
id|p-&gt;scsi_id
comma
id|p-&gt;scsi_id_b
)paren
suffix:semicolon
)brace
r_else
(brace
r_char
op_star
id|channel
suffix:semicolon
id|channel
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|AHC_MULTI_CHANNEL
)paren
op_ne
l_int|0
)paren
(brace
id|channel
op_assign
l_string|&quot; A&quot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
(paren
id|AHC_CHNLB
op_or
id|AHC_CHNLC
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|channel
op_assign
(paren
id|p-&gt;flags
op_amp
id|AHC_CHNLB
)paren
ques
c_cond
l_string|&quot; B&quot;
suffix:colon
l_string|&quot; C&quot;
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_WIDE
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Wide &quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Narrow &quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Channel%s, SCSI ID=%d, &quot;
comma
id|channel
comma
id|p-&gt;scsi_id
)paren
suffix:semicolon
)brace
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SEQ_FLAGS
)paren
suffix:semicolon
id|detect_maxscb
c_func
(paren
id|p
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d/%d SCBs&bslash;n&quot;
comma
id|p-&gt;scb_data-&gt;maxhscbs
comma
id|p-&gt;scb_data-&gt;maxscbs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) BIOS %sabled, IO Port 0x%lx, IRQ %d&bslash;n&quot;
comma
id|p-&gt;host_no
comma
(paren
id|p-&gt;flags
op_amp
id|AHC_BIOS_ENABLED
)paren
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
comma
id|p-&gt;base
comma
id|p-&gt;irq
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) IO Memory at 0x%lx, MMAP Memory at 0x%lx&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|p-&gt;mbase
comma
(paren
r_int
r_int
)paren
id|p-&gt;maddr
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PCI
multiline_comment|/*&n;   * Now that we know our instance number, we can set the flags we need to&n;   * force termination if need be.&n;   */
r_if
c_cond
(paren
id|aic7xxx_stpwlev
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;     * This option only applies to PCI controllers.&n;     */
r_if
c_cond
(paren
(paren
id|p-&gt;chip
op_amp
op_complement
id|AHC_CHIPID_MASK
)paren
op_eq
id|AHC_PCI
)paren
(brace
r_int
r_char
id|devconfig
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|p-&gt;pdev
comma
id|DEVCONFIG
comma
op_amp
id|devconfig
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|aic7xxx_stpwlev
op_rshift
id|p-&gt;instance
)paren
op_amp
l_int|0x01
)paren
(brace
id|devconfig
op_or_assign
id|STPWLEVEL
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
l_string|&quot;(scsi%d) Force setting STPWLEVEL bit&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
r_else
(brace
id|devconfig
op_and_assign
op_complement
id|STPWLEVEL
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
l_string|&quot;(scsi%d) Force clearing STPWLEVEL bit&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
id|pci_write_config_byte
c_func
(paren
id|p-&gt;pdev
comma
id|DEVCONFIG
comma
id|devconfig
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;   * That took care of devconfig and stpwlev, now for the actual termination&n;   * settings.&n;   */
r_if
c_cond
(paren
id|aic7xxx_override_term
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;     * Again, this only applies to PCI controllers.  We don&squot;t have problems&n;     * with the termination on 274x controllers to the best of my knowledge.&n;     */
r_if
c_cond
(paren
(paren
id|p-&gt;chip
op_amp
op_complement
id|AHC_CHIPID_MASK
)paren
op_eq
id|AHC_PCI
)paren
(brace
r_int
r_char
id|term_override
suffix:semicolon
id|term_override
op_assign
(paren
(paren
id|aic7xxx_override_term
op_rshift
(paren
id|p-&gt;instance
op_star
l_int|4
)paren
)paren
op_amp
l_int|0x0f
)paren
suffix:semicolon
id|p-&gt;adapter_control
op_and_assign
op_complement
(paren
id|CFSTERM
op_or
id|CFWSTERM
op_or
id|CFLVDSTERM
op_or
id|CFAUTOTERM
op_or
id|CFSEAUTOTERM
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_logical_and
(paren
id|term_override
op_amp
l_int|0x0c
)paren
)paren
(brace
id|p-&gt;adapter_control
op_or_assign
id|CFLVDSTERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|term_override
op_amp
l_int|0x02
)paren
(brace
id|p-&gt;adapter_control
op_or_assign
id|CFWSTERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|term_override
op_amp
l_int|0x01
)paren
(brace
id|p-&gt;adapter_control
op_or_assign
id|CFSTERM
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|AHC_SEEPROM_FOUND
)paren
op_logical_or
(paren
id|aic7xxx_override_term
op_ne
op_minus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_SPIOCAP
)paren
(brace
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SPIOCAP
)paren
op_amp
id|SSPIOCPS
)paren
multiline_comment|/*&n;       * Update the settings in sxfrctl1 to match the termination&n;       * settings.&n;       */
id|configure_termination
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|p-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)paren
op_ge
id|AHC_AIC7870
)paren
(brace
id|configure_termination
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1, for both channels&n;   */
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_TWIN
)paren
(brace
multiline_comment|/* Select channel B */
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SBLKCTL
)paren
op_or
id|SELBUSB
comma
id|SBLKCTL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|AHC_SEEPROM_FOUND
)paren
op_logical_or
(paren
id|aic7xxx_override_term
op_ne
op_minus
l_int|1
)paren
)paren
id|term
op_assign
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SXFRCTL1
)paren
op_amp
id|STPWEN
)paren
suffix:semicolon
r_else
id|term
op_assign
(paren
(paren
id|p-&gt;flags
op_amp
id|AHC_TERM_ENB_B
)paren
ques
c_cond
id|STPWEN
suffix:colon
l_int|0
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|p-&gt;scsi_id_b
comma
id|SCSIID
)paren
suffix:semicolon
id|scsi_conf
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCSICONF
op_plus
l_int|1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|DFON
op_or
id|SPIOEN
comma
id|SXFRCTL0
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|scsi_conf
op_amp
id|ENSPCHK
)paren
op_or
id|aic7xxx_seltime
op_or
id|term
op_or
id|ENSTIMER
op_or
id|ACTNEGEN
comma
id|SXFRCTL1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SIMODE0
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|ENSELTIMO
op_or
id|ENSCSIRST
op_or
id|ENSCSIPERR
comma
id|SIMODE1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCSIRATE
)paren
suffix:semicolon
multiline_comment|/* Select channel A */
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SBLKCTL
)paren
op_amp
op_complement
id|SELBUSB
comma
id|SBLKCTL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|p-&gt;scsi_id
comma
id|SCSIID_ULTRA2
)paren
suffix:semicolon
)brace
r_else
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|p-&gt;scsi_id
comma
id|SCSIID
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|AHC_SEEPROM_FOUND
)paren
op_logical_or
(paren
id|aic7xxx_override_term
op_ne
op_minus
l_int|1
)paren
)paren
id|term
op_assign
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SXFRCTL1
)paren
op_amp
id|STPWEN
)paren
suffix:semicolon
r_else
id|term
op_assign
(paren
(paren
id|p-&gt;flags
op_amp
(paren
id|AHC_TERM_ENB_A
op_or
id|AHC_TERM_ENB_LVD
)paren
)paren
ques
c_cond
id|STPWEN
suffix:colon
l_int|0
)paren
suffix:semicolon
id|scsi_conf
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCSICONF
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|DFON
op_or
id|SPIOEN
comma
id|SXFRCTL0
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|scsi_conf
op_amp
id|ENSPCHK
)paren
op_or
id|aic7xxx_seltime
op_or
id|term
op_or
id|ENSTIMER
op_or
id|ACTNEGEN
comma
id|SXFRCTL1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SIMODE0
)paren
suffix:semicolon
multiline_comment|/*&n;   * If we are a cardbus adapter then don&squot;t enable SCSI reset detection.&n;   * We shouldn&squot;t likely be sharing SCSI busses with someone else, and&n;   * if we don&squot;t have a cable currently plugged into the controller then&n;   * we won&squot;t have a power source for the SCSI termination, which means&n;   * we&squot;ll see infinite incoming bus resets.&n;   */
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|AHC_NO_STPWEN
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|ENSELTIMO
op_or
id|ENSCSIPERR
comma
id|SIMODE1
)paren
suffix:semicolon
)brace
r_else
id|aic_outb
c_func
(paren
id|p
comma
id|ENSELTIMO
op_or
id|ENSCSIRST
op_or
id|ENSCSIPERR
comma
id|SIMODE1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCSIRATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCSIOFFSET
)paren
suffix:semicolon
multiline_comment|/*&n;   * Look at the information that board initialization or the board&n;   * BIOS has left us. In the lower four bits of each target&squot;s&n;   * scratch space any value other than 0 indicates that we should&n;   * initiate synchronous transfers. If it&squot;s zero, the user or the&n;   * BIOS has decided to disable synchronous negotiation to that&n;   * target so we don&squot;t activate the needsdtr flag.&n;   */
r_if
c_cond
(paren
(paren
id|p-&gt;features
op_amp
(paren
id|AHC_TWIN
op_or
id|AHC_WIDE
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|max_targets
op_assign
l_int|8
suffix:semicolon
)brace
r_else
(brace
id|max_targets
op_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|aic7xxx_no_reset
)paren
)paren
(brace
multiline_comment|/*&n;     * If we reset the bus, then clear the transfer settings, else leave&n;     * them be&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_targets
suffix:semicolon
id|i
op_increment
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|TARG_SCSIRATE
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|TARG_OFFSET
op_plus
id|i
)paren
suffix:semicolon
)brace
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|cur_offset
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|cur_period
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|cur_width
op_assign
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:semicolon
)brace
multiline_comment|/*&n;     * If we reset the bus, then clear the transfer settings, else leave&n;     * them be.&n;     */
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|ULTRA_ENB
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|ULTRA_ENB
op_plus
l_int|1
)paren
suffix:semicolon
id|p-&gt;ultraenb
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;   * Allocate enough hardware scbs to handle the maximum number of&n;   * concurrent transactions we can have.  We have to make sure that&n;   * the allocated memory is contiguous memory.  The Linux kmalloc&n;   * routine should only allocate contiguous memory, but note that&n;   * this could be a problem if kmalloc() is changed.&n;   */
(brace
r_int
id|array_size
suffix:semicolon
r_int
r_int
id|hscb_physaddr
suffix:semicolon
id|array_size
op_assign
id|p-&gt;scb_data-&gt;maxscbs
op_star
r_sizeof
(paren
r_struct
id|aic7xxx_hwscb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;hscbs
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* pci_alloc_consistent enforces the alignment already and&n;       * clears the area as well.&n;       */
id|p-&gt;scb_data-&gt;hscbs
op_assign
id|pci_alloc_consistent
c_func
(paren
id|p-&gt;pdev
comma
id|array_size
comma
op_amp
id|p-&gt;scb_data-&gt;hscbs_dma
)paren
suffix:semicolon
multiline_comment|/* We have to use pci_free_consistent, not kfree */
id|p-&gt;scb_data-&gt;hscb_kmalloc_ptr
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;scb_data-&gt;hscbs_dma_len
op_assign
id|array_size
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;hscbs
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(scsi%d) Unable to allocate hardware SCB array; &quot;
l_string|&quot;failing detection.&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SIMODE1
)paren
suffix:semicolon
id|p-&gt;irq
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|hscb_physaddr
op_assign
id|p-&gt;scb_data-&gt;hscbs_dma
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|hscb_physaddr
op_amp
l_int|0xFF
comma
id|HSCB_ADDR
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|hscb_physaddr
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
comma
id|HSCB_ADDR
op_plus
l_int|1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|hscb_physaddr
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
comma
id|HSCB_ADDR
op_plus
l_int|2
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|hscb_physaddr
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
comma
id|HSCB_ADDR
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Set up the fifo areas at the same time */
id|p-&gt;untagged_scbs
op_assign
id|pci_alloc_consistent
c_func
(paren
id|p-&gt;pdev
comma
l_int|3
op_star
l_int|256
comma
op_amp
id|p-&gt;fifo_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;untagged_scbs
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(scsi%d) Unable to allocate hardware FIFO arrays; &quot;
l_string|&quot;failing detection.&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
id|p-&gt;irq
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|p-&gt;qoutfifo
op_assign
id|p-&gt;untagged_scbs
op_plus
l_int|256
suffix:semicolon
id|p-&gt;qinfifo
op_assign
id|p-&gt;qoutfifo
op_plus
l_int|256
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
id|p-&gt;untagged_scbs
(braket
id|i
)braket
op_assign
id|SCB_LIST_NULL
suffix:semicolon
id|p-&gt;qinfifo
(braket
id|i
)braket
op_assign
id|SCB_LIST_NULL
suffix:semicolon
id|p-&gt;qoutfifo
(braket
id|i
)braket
op_assign
id|SCB_LIST_NULL
suffix:semicolon
)brace
id|hscb_physaddr
op_assign
id|p-&gt;fifo_dma
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|hscb_physaddr
op_amp
l_int|0xFF
comma
id|SCBID_ADDR
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|hscb_physaddr
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
comma
id|SCBID_ADDR
op_plus
l_int|1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|hscb_physaddr
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
comma
id|SCBID_ADDR
op_plus
l_int|2
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
(paren
id|hscb_physaddr
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
comma
id|SCBID_ADDR
op_plus
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/* The Q-FIFOs we just set up are all empty */
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|QINPOS
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|KERNEL_QINPOS
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|QOUTPOS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_QUEUE_REGS
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_QSIZE_256
comma
id|QOFF_CTLSTA
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SDSCB_QOFF
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SNSCB_QOFF
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|HNSCB_QOFF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * We don&squot;t have any waiting selections or disconnected SCBs.&n;   */
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|WAITING_SCBH
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|DISCONNECTED_SCBH
)paren
suffix:semicolon
multiline_comment|/*&n;   * Message out buffer starts empty&n;   */
id|aic_outb
c_func
(paren
id|p
comma
id|MSG_NOOP
comma
id|MSG_OUT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|MSG_NOOP
comma
id|LAST_MSG
)paren
suffix:semicolon
multiline_comment|/*&n;   * Set all the other asundry items that haven&squot;t been set yet.&n;   * This includes just dumping init values to a lot of registers simply&n;   * to make sure they&squot;ve been touched and are ready for use parity wise&n;   * speaking.&n;   */
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|TMODE_CMDADDR
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|TMODE_CMDADDR
op_plus
l_int|1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|TMODE_CMDADDR
op_plus
l_int|2
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|TMODE_CMDADDR
op_plus
l_int|3
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|TMODE_CMDADDR_NEXT
)paren
suffix:semicolon
multiline_comment|/*&n;   * Link us into the list of valid hosts&n;   */
id|p-&gt;next
op_assign
id|first_aic7xxx
suffix:semicolon
id|first_aic7xxx
op_assign
id|p
suffix:semicolon
multiline_comment|/*&n;   * Allocate the first set of scbs for this controller.  This is to stream-&n;   * line code elsewhere in the driver.  If we have to check for the existence&n;   * of scbs in certain code sections, it slows things down.  However, as&n;   * soon as we register the IRQ for this card, we could get an interrupt that&n;   * includes possibly the SCSI_RSTI interrupt.  If we catch that interrupt&n;   * then we are likely to segfault if we don&squot;t have at least one chunk of&n;   * SCBs allocated or add checks all through the reset code to make sure&n;   * that the SCBs have been allocated which is an invalid running condition&n;   * and therefore I think it&squot;s preferable to simply pre-allocate the first&n;   * chunk of SCBs.&n;   */
id|aic7xxx_allocate_scb
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;   * Load the sequencer program, then re-enable the board -&n;   * resetting the AIC-7770 disables it, leaving the lights&n;   * on with nobody home.&n;   */
id|aic7xxx_loadseq
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;   * Make sure the AUTOFLUSHDIS bit is *not* set in the SBLKCTL register&n;   */
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SBLKCTL
)paren
op_amp
op_complement
id|AUTOFLUSHDIS
comma
id|SBLKCTL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)paren
op_eq
id|AHC_AIC7770
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|ENABLE
comma
id|BCTL
)paren
suffix:semicolon
multiline_comment|/* Enable the boards BUS drivers. */
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|aic7xxx_no_reset
)paren
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_TWIN
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Resetting channel B&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SBLKCTL
)paren
op_or
id|SELBUSB
comma
id|SBLKCTL
)paren
suffix:semicolon
id|aic7xxx_reset_current_bus
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SBLKCTL
)paren
op_amp
op_complement
id|SELBUSB
comma
id|SBLKCTL
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset SCSI bus A. */
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
(brace
multiline_comment|/* In case we are a 3940, 3985, or 7895, print the right channel */
r_char
op_star
id|channel
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|AHC_MULTI_CHANNEL
)paren
(brace
id|channel
op_assign
l_string|&quot; A&quot;
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
(paren
id|AHC_CHNLB
op_or
id|AHC_CHNLC
)paren
)paren
id|channel
op_assign
(paren
id|p-&gt;flags
op_amp
id|AHC_CHNLB
)paren
ques
c_cond
l_string|&quot; B&quot;
suffix:colon
l_string|&quot; C&quot;
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Resetting channel%s&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|channel
)paren
suffix:semicolon
)brace
id|aic7xxx_reset_current_bus
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;     * Delay for the reset delay by setting the timer, this will delay&n;     * future commands sent to any devices.&n;     */
id|p-&gt;flags
op_or_assign
id|AHC_RESET_DELAY
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGETS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|p-&gt;dev_expires
(braket
id|i
)braket
op_assign
id|jiffies
op_plus
(paren
l_int|4
op_star
id|HZ
)paren
suffix:semicolon
id|p-&gt;dev_timer_active
op_or_assign
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
)brace
id|p-&gt;dev_timer.expires
op_assign
id|p-&gt;dev_expires
(braket
id|p-&gt;scsi_id
)braket
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|p-&gt;dev_timer
)paren
suffix:semicolon
id|p-&gt;dev_timer_active
op_or_assign
(paren
l_int|0x01
op_lshift
id|MAX_TARGETS
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|reset_delay
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) Not resetting SCSI bus.  Note: Don&squot;t use &quot;
l_string|&quot;the no_reset&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(scsi%d) option unless you have a verifiable need &quot;
l_string|&quot;for it.&bslash;n&quot;
comma
id|p-&gt;host_no
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Register IRQ with the kernel.  Only allow sharing IRQs with&n;   * PCI devices.&n;   */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;chip
op_amp
id|AHC_PCI
)paren
)paren
(brace
id|result
op_assign
(paren
id|request_irq
c_func
(paren
id|p-&gt;irq
comma
id|do_aic7xxx_isr
comma
l_int|0
comma
l_string|&quot;aic7xxx&quot;
comma
id|p
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
(paren
id|request_irq
c_func
(paren
id|p-&gt;irq
comma
id|do_aic7xxx_isr
comma
id|SA_SHIRQ
comma
l_string|&quot;aic7xxx&quot;
comma
id|p
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|result
op_assign
(paren
id|request_irq
c_func
(paren
id|p-&gt;irq
comma
id|do_aic7xxx_isr
comma
id|SA_INTERRUPT
op_or
id|SA_SHIRQ
comma
l_string|&quot;aic7xxx&quot;
comma
id|p
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d) Couldn&squot;t register IRQ %d, ignoring &quot;
l_string|&quot;controller.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|p-&gt;irq
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SIMODE1
)paren
suffix:semicolon
id|p-&gt;irq
op_assign
l_int|0
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|INTSTAT
)paren
op_amp
id|INT_PEND
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;spurious interrupt during configuration, cleared.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|aic7xxx_clear_intstat
c_func
(paren
id|p
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
multiline_comment|/* unpause_always */
id|TRUE
)paren
suffix:semicolon
r_return
(paren
id|found
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_chip_reset&n; *&n; * Description:&n; *   Perform a chip reset on the aic7xxx SCSI controller.  The controller&n; *   is paused upon return.&n; *-F*************************************************************************/
r_int
DECL|function|aic7xxx_chip_reset
id|aic7xxx_chip_reset
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_int
r_char
id|sblkctl
suffix:semicolon
r_int
id|wait
suffix:semicolon
multiline_comment|/*&n;   * For some 274x boards, we must clear the CHIPRST bit and pause&n;   * the sequencer. For some reason, this makes the driver work.&n;   */
id|aic_outb
c_func
(paren
id|p
comma
id|PAUSE
op_or
id|CHIPRST
comma
id|HCNTRL
)paren
suffix:semicolon
multiline_comment|/*&n;   * In the future, we may call this function as a last resort for&n;   * error handling.  Let&squot;s be nice and not do any unecessary delays.&n;   */
id|wait
op_assign
l_int|1000
suffix:semicolon
multiline_comment|/* 1 msec (1000 * 1 msec) */
r_while
c_loop
(paren
op_decrement
id|wait
op_logical_and
op_logical_neg
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|HCNTRL
)paren
op_amp
id|CHIPRSTACK
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* 1 usec */
)brace
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
id|sblkctl
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SBLKCTL
)paren
op_amp
(paren
id|SELBUSB
op_or
id|SELWIDE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;chip
op_amp
id|AHC_PCI
)paren
id|sblkctl
op_and_assign
op_complement
id|SELBUSB
suffix:semicolon
r_switch
c_cond
(paren
id|sblkctl
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* normal narrow card */
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* Wide card */
id|p-&gt;features
op_or_assign
id|AHC_WIDE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
multiline_comment|/* Twin card */
id|p-&gt;features
op_or_assign
id|AHC_TWIN
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|AHC_MULTI_CHANNEL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* hmmm...we don&squot;t know what this is */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: Unsupported adapter type %d, ignoring.&bslash;n&quot;
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SBLKCTL
)paren
op_amp
l_int|0x0a
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_alloc&n; *&n; * Description:&n; *   Allocate and initialize a host structure.  Returns NULL upon error&n; *   and a pointer to a aic7xxx_host struct upon success.&n; *-F*************************************************************************/
r_static
r_struct
id|aic7xxx_host
op_star
DECL|function|aic7xxx_alloc
id|aic7xxx_alloc
c_func
(paren
id|Scsi_Host_Template
op_star
id|sht
comma
r_struct
id|aic7xxx_host
op_star
id|temp
)paren
(brace
r_struct
id|aic7xxx_host
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;   * Allocate a storage area by registering us with the mid-level&n;   * SCSI layer.&n;   */
id|host
op_assign
id|scsi_register
c_func
(paren
id|sht
comma
r_sizeof
(paren
r_struct
id|aic7xxx_host
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host
op_ne
l_int|NULL
)paren
(brace
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|aic7xxx_host
)paren
)paren
suffix:semicolon
op_star
id|p
op_assign
op_star
id|temp
suffix:semicolon
id|p-&gt;host
op_assign
id|host
suffix:semicolon
id|p-&gt;scb_data
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|scb_data_type
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;scb_data
op_ne
l_int|NULL
)paren
(brace
id|memset
c_func
(paren
id|p-&gt;scb_data
comma
l_int|0
comma
r_sizeof
(paren
id|scb_data_type
)paren
)paren
suffix:semicolon
id|scbq_init
(paren
op_amp
id|p-&gt;scb_data-&gt;free_scbs
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;       * For some reason we don&squot;t have enough memory.  Free the&n;       * allocated memory for the aic7xxx_host struct, and return NULL.&n;       */
id|release_region
c_func
(paren
id|p-&gt;base
comma
id|MAXREG
op_minus
id|MINREG
)paren
suffix:semicolon
id|scsi_unregister
c_func
(paren
id|host
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|p-&gt;host_no
op_assign
id|host-&gt;host_no
suffix:semicolon
id|p-&gt;tagenable
op_assign
l_int|0
suffix:semicolon
id|p-&gt;orderedtag
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGETS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|goal_period
op_assign
l_int|255
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|goal_offset
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|goal_options
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|goal_width
op_assign
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:semicolon
)brace
id|DRIVER_LOCK_INIT
)brace
r_return
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_free&n; *&n; * Description:&n; *   Frees and releases all resources associated with an instance of&n; *   the driver (struct aic7xxx_host *).&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_free
id|aic7xxx_free
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;   * Free the allocated hardware SCB space.&n;   */
r_if
c_cond
(paren
id|p-&gt;scb_data
op_ne
l_int|NULL
)paren
(brace
r_struct
id|aic7xxx_scb_dma
op_star
id|scb_dma
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;hscbs
op_ne
l_int|NULL
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|p-&gt;pdev
comma
id|p-&gt;scb_data-&gt;hscbs_dma_len
comma
id|p-&gt;scb_data-&gt;hscbs
comma
id|p-&gt;scb_data-&gt;hscbs_dma
)paren
suffix:semicolon
id|p-&gt;scb_data-&gt;hscbs
op_assign
id|p-&gt;scb_data-&gt;hscb_kmalloc_ptr
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;     * Free the driver SCBs.  These were allocated on an as-need&n;     * basis.  We allocated these in groups depending on how many&n;     * we could fit into a given amount of RAM.  The tail SCB for&n;     * these allocations has a pointer to the alloced area.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;scb_data-&gt;numscbs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;scb_array
(braket
id|i
)braket
op_member_access_from_pointer
id|scb_dma
op_ne
id|scb_dma
)paren
(brace
id|scb_dma
op_assign
id|p-&gt;scb_data-&gt;scb_array
(braket
id|i
)braket
op_member_access_from_pointer
id|scb_dma
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|p-&gt;pdev
comma
id|scb_dma-&gt;dma_len
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|scb_dma-&gt;dma_address
op_minus
id|scb_dma-&gt;dma_offset
)paren
comma
id|scb_dma-&gt;dma_address
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;scb_data-&gt;scb_array
(braket
id|i
)braket
op_member_access_from_pointer
id|kmalloc_ptr
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|p-&gt;scb_data-&gt;scb_array
(braket
id|i
)braket
op_member_access_from_pointer
id|kmalloc_ptr
)paren
suffix:semicolon
id|p-&gt;scb_data-&gt;scb_array
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;     * Free the SCB data area.&n;     */
id|kfree
c_func
(paren
id|p-&gt;scb_data
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * Free any alloced Scsi_Cmnd structures that might be around for&n;   * negotiation purposes....&n;   */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGETS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;dev_dtr_cmnd
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;dev_dtr_cmnd
(braket
id|i
)braket
op_member_access_from_pointer
id|request_buffer
)paren
(brace
id|kfree
c_func
(paren
id|p-&gt;dev_dtr_cmnd
(braket
id|i
)braket
op_member_access_from_pointer
id|request_buffer
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|p-&gt;dev_dtr_cmnd
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
id|pci_free_consistent
c_func
(paren
id|p-&gt;pdev
comma
l_int|3
op_star
l_int|256
comma
(paren
r_void
op_star
)paren
id|p-&gt;untagged_scbs
comma
id|p-&gt;fifo_dma
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_load_seeprom&n; *&n; * Description:&n; *   Load the seeprom and configure adapter and target settings.&n; *   Returns 1 if the load was successful and 0 otherwise.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_load_seeprom
id|aic7xxx_load_seeprom
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_int
r_char
op_star
id|sxfrctl1
)paren
(brace
r_int
id|have_seeprom
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|max_targets
comma
id|mask
suffix:semicolon
r_int
r_char
id|scsirate
comma
id|scsi_conf
suffix:semicolon
r_int
r_int
id|scarray
(braket
l_int|128
)braket
suffix:semicolon
r_struct
id|seeprom_config
op_star
id|sc
op_assign
(paren
r_struct
id|seeprom_config
op_star
)paren
id|scarray
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Loading serial EEPROM...&quot;
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|p-&gt;chip
)paren
(brace
r_case
(paren
id|AHC_AIC7770
op_or
id|AHC_EISA
)paren
suffix:colon
multiline_comment|/* None of these adapters have seeproms. */
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SCSICONF
)paren
op_amp
id|TERM_ENB
)paren
id|p-&gt;flags
op_or_assign
id|AHC_TERM_ENB_A
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;features
op_amp
id|AHC_TWIN
)paren
op_logical_and
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SCSICONF
op_plus
l_int|1
)paren
op_amp
id|TERM_ENB
)paren
)paren
id|p-&gt;flags
op_or_assign
id|AHC_TERM_ENB_B
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
id|AHC_AIC7770
op_or
id|AHC_VL
)paren
suffix:colon
id|have_seeprom
op_assign
id|read_284x_seeprom
c_func
(paren
id|p
comma
(paren
r_struct
id|seeprom_config
op_star
)paren
id|scarray
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|have_seeprom
op_assign
id|read_seeprom
c_func
(paren
id|p
comma
(paren
id|p-&gt;flags
op_amp
(paren
id|AHC_CHNLB
op_or
id|AHC_CHNLC
)paren
)paren
comma
id|scarray
comma
id|p-&gt;sc_size
comma
id|p-&gt;sc_type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|have_seeprom
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;sc_type
op_eq
id|C46
)paren
(brace
id|have_seeprom
op_assign
id|read_seeprom
c_func
(paren
id|p
comma
(paren
id|p-&gt;flags
op_amp
(paren
id|AHC_CHNLB
op_or
id|AHC_CHNLC
)paren
)paren
comma
id|scarray
comma
id|p-&gt;sc_size
comma
id|C56_66
)paren
suffix:semicolon
)brace
r_else
id|have_seeprom
op_assign
id|read_seeprom
c_func
(paren
id|p
comma
(paren
id|p-&gt;flags
op_amp
(paren
id|AHC_CHNLB
op_or
id|AHC_CHNLC
)paren
)paren
comma
id|scarray
comma
id|p-&gt;sc_size
comma
id|C46
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|have_seeprom
)paren
(brace
id|p-&gt;sc_size
op_assign
l_int|128
suffix:semicolon
id|have_seeprom
op_assign
id|read_seeprom
c_func
(paren
id|p
comma
l_int|4
op_star
(paren
id|p-&gt;flags
op_amp
(paren
id|AHC_CHNLB
op_or
id|AHC_CHNLC
)paren
)paren
comma
id|scarray
comma
id|p-&gt;sc_size
comma
id|p-&gt;sc_type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|have_seeprom
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;sc_type
op_eq
id|C46
)paren
(brace
id|have_seeprom
op_assign
id|read_seeprom
c_func
(paren
id|p
comma
l_int|4
op_star
(paren
id|p-&gt;flags
op_amp
(paren
id|AHC_CHNLB
op_or
id|AHC_CHNLC
)paren
)paren
comma
id|scarray
comma
id|p-&gt;sc_size
comma
id|C56_66
)paren
suffix:semicolon
)brace
r_else
id|have_seeprom
op_assign
id|read_seeprom
c_func
(paren
id|p
comma
l_int|4
op_star
(paren
id|p-&gt;flags
op_amp
(paren
id|AHC_CHNLB
op_or
id|AHC_CHNLC
)paren
)paren
comma
id|scarray
comma
id|p-&gt;sc_size
comma
id|C46
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|have_seeprom
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;naic7xxx: No SEEPROM available.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|p-&gt;flags
op_or_assign
id|AHC_NEWEEPROM_FMT
suffix:semicolon
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISEQ
)paren
op_eq
l_int|0
)paren
(brace
id|p-&gt;flags
op_or_assign
id|AHC_USEDEFAULTS
suffix:semicolon
id|p-&gt;flags
op_and_assign
op_complement
id|AHC_BIOS_ENABLED
suffix:semicolon
id|p-&gt;scsi_id
op_assign
id|p-&gt;scsi_id_b
op_assign
l_int|7
suffix:semicolon
op_star
id|sxfrctl1
op_or_assign
id|STPWEN
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Using default values.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Using leftover BIOS values.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|p-&gt;chip
op_amp
op_complement
id|AHC_CHIPID_MASK
)paren
op_eq
id|AHC_PCI
)paren
op_logical_and
(paren
op_star
id|sxfrctl1
op_amp
id|STPWEN
)paren
)paren
(brace
id|p-&gt;flags
op_or_assign
id|AHC_TERM_ENB_SE_LOW
op_or
id|AHC_TERM_ENB_SE_HIGH
suffix:semicolon
id|sc-&gt;adapter_control
op_and_assign
op_complement
id|CFAUTOTERM
suffix:semicolon
id|sc-&gt;adapter_control
op_or_assign
id|CFSTERM
op_or
id|CFWSTERM
op_or
id|CFLVDSTERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_extended
)paren
id|p-&gt;flags
op_or_assign
(paren
id|AHC_EXTEND_TRANS_A
op_or
id|AHC_EXTEND_TRANS_B
)paren
suffix:semicolon
r_else
id|p-&gt;flags
op_and_assign
op_complement
(paren
id|AHC_EXTEND_TRANS_A
op_or
id|AHC_EXTEND_TRANS_B
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;done&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Note things in our flags&n;     */
id|p-&gt;flags
op_or_assign
id|AHC_SEEPROM_FOUND
suffix:semicolon
multiline_comment|/*&n;     * Update the settings in sxfrctl1 to match the termination settings.&n;     */
op_star
id|sxfrctl1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * Get our SCSI ID from the SEEPROM setting...&n;     */
id|p-&gt;scsi_id
op_assign
(paren
id|sc-&gt;brtime_id
op_amp
id|CFSCSIID
)paren
suffix:semicolon
multiline_comment|/*&n;     * First process the settings that are different between the VLB&n;     * and PCI adapter seeproms.&n;     */
r_if
c_cond
(paren
(paren
id|p-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)paren
op_eq
id|AHC_AIC7770
)paren
(brace
multiline_comment|/* VLB adapter seeproms */
r_if
c_cond
(paren
id|sc-&gt;bios_control
op_amp
id|CF284XEXTEND
)paren
id|p-&gt;flags
op_or_assign
id|AHC_EXTEND_TRANS_A
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;adapter_control
op_amp
id|CF284XSTERM
)paren
(brace
op_star
id|sxfrctl1
op_or_assign
id|STPWEN
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|AHC_TERM_ENB_SE_LOW
op_or
id|AHC_TERM_ENB_SE_HIGH
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* PCI adapter seeproms */
r_if
c_cond
(paren
id|sc-&gt;bios_control
op_amp
id|CFEXTEND
)paren
id|p-&gt;flags
op_or_assign
id|AHC_EXTEND_TRANS_A
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;bios_control
op_amp
id|CFBIOSEN
)paren
id|p-&gt;flags
op_or_assign
id|AHC_BIOS_ENABLED
suffix:semicolon
r_else
id|p-&gt;flags
op_and_assign
op_complement
id|AHC_BIOS_ENABLED
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;adapter_control
op_amp
id|CFSTERM
)paren
(brace
op_star
id|sxfrctl1
op_or_assign
id|STPWEN
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|AHC_TERM_ENB_SE_LOW
op_or
id|AHC_TERM_ENB_SE_HIGH
suffix:semicolon
)brace
)brace
id|memcpy
c_func
(paren
op_amp
id|p-&gt;sc
comma
id|sc
comma
r_sizeof
(paren
r_struct
id|seeprom_config
)paren
)paren
suffix:semicolon
)brace
id|p-&gt;discenable
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   * Limit to 16 targets just in case.  The 2842 for one is known to&n;   * blow the max_targets setting, future cards might also.&n;   */
id|max_targets
op_assign
(paren
(paren
id|p-&gt;features
op_amp
(paren
id|AHC_TWIN
op_or
id|AHC_WIDE
)paren
)paren
ques
c_cond
l_int|16
suffix:colon
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|have_seeprom
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_targets
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA
)paren
op_logical_and
op_logical_neg
(paren
id|sc-&gt;adapter_control
op_amp
id|CFULTRAEN
)paren
op_logical_and
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFSYNCHISULTRA
)paren
)paren
op_logical_or
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFNEWULTRAFORMAT
)paren
)paren
(brace
id|p-&gt;flags
op_or_assign
id|AHC_NEWEEPROM_FMT
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_targets
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mask
op_assign
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|have_seeprom
)paren
(brace
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISEQ
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;         * OK...the BIOS set things up and left behind the settings we need.&n;         * Just make our sc-&gt;device_flags[i] entry match what the card has&n;         * set for this device.&n;         */
id|p-&gt;discenable
op_assign
op_complement
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|DISC_DSB
)paren
op_or
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|DISC_DSB
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
id|p-&gt;ultraenb
op_assign
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|ULTRA_ENB
)paren
op_or
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|ULTRA_ENB
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
id|sc-&gt;device_flags
(braket
id|i
)braket
op_assign
(paren
id|p-&gt;discenable
op_amp
id|mask
)paren
ques
c_cond
id|CFDISC
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|TARG_SCSIRATE
op_plus
id|i
)paren
op_amp
id|WIDEXFER
)paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_or_assign
id|CFWIDEB
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|TARG_OFFSET
op_plus
id|i
)paren
)paren
(brace
id|sc-&gt;device_flags
(braket
id|i
)braket
op_or_assign
id|CFSYNCH
suffix:semicolon
id|sc-&gt;device_flags
(braket
id|i
)braket
op_or_assign
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|TARG_SCSIRATE
op_plus
id|i
)paren
op_amp
l_int|0x07
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|TARG_SCSIRATE
op_plus
id|i
)paren
op_amp
l_int|0x18
)paren
op_eq
l_int|0x18
)paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_or_assign
id|CFSYNCHISULTRA
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|TARG_SCSIRATE
op_plus
id|i
)paren
op_amp
op_complement
id|WIDEXFER
)paren
(brace
id|sc-&gt;device_flags
(braket
id|i
)braket
op_or_assign
id|CFSYNCH
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA
)paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_or_assign
(paren
(paren
id|p-&gt;ultraenb
op_amp
id|mask
)paren
ques
c_cond
id|CFSYNCHISULTRA
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/*&n;         * Assume the BIOS has NOT been run on this card and nothing between&n;         * the card and the devices is configured yet.&n;         */
id|sc-&gt;device_flags
(braket
id|i
)braket
op_assign
id|CFDISC
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_WIDE
)paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_or_assign
id|CFWIDEB
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA3
)paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_or_assign
l_int|2
suffix:semicolon
r_else
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_or_assign
l_int|3
suffix:semicolon
r_else
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA
)paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_or_assign
id|CFSYNCHISULTRA
suffix:semicolon
id|sc-&gt;device_flags
(braket
id|i
)braket
op_or_assign
id|CFSYNCH
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|TARG_SCSIRATE
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|TARG_OFFSET
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFDISC
)paren
(brace
id|p-&gt;discenable
op_or_assign
id|mask
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|AHC_NEWEEPROM_FMT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
)paren
(brace
multiline_comment|/*&n;         * I know of two different Ultra BIOSes that do this differently.&n;         * One on the Gigabyte 6BXU mb that wants flags[i] &amp; CFXFER to&n;         * be == to 0x03 and SYNCHISULTRA to be true to mean 40MByte/s&n;         * while on the IBM Netfinity 5000 they want the same thing&n;         * to be something else, while flags[i] &amp; CFXFER == 0x03 and&n;         * SYNCHISULTRA false should be 40MByte/s.  So, we set both to&n;         * 40MByte/s and the lower speeds be damned.  People will have&n;         * to select around the conversely mapped lower speeds in order&n;         * to select lower speeds on these boards.&n;         */
r_if
c_cond
(paren
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFNEWULTRAFORMAT
)paren
op_logical_and
(paren
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFXFER
)paren
op_eq
l_int|0x03
)paren
)paren
(brace
id|sc-&gt;device_flags
(braket
id|i
)braket
op_and_assign
op_complement
id|CFXFER
suffix:semicolon
id|sc-&gt;device_flags
(braket
id|i
)braket
op_or_assign
id|CFSYNCHISULTRA
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFSYNCHISULTRA
)paren
(brace
id|p-&gt;ultraenb
op_or_assign
id|mask
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFNEWULTRAFORMAT
)paren
op_logical_and
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_logical_and
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFSYNCHISULTRA
)paren
)paren
(brace
id|p-&gt;ultraenb
op_or_assign
id|mask
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|sc-&gt;adapter_control
op_amp
id|CFULTRAEN
)paren
(brace
id|p-&gt;ultraenb
op_or_assign
id|mask
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFSYNCH
)paren
op_eq
l_int|0
)paren
(brace
id|sc-&gt;device_flags
(braket
id|i
)braket
op_and_assign
op_complement
id|CFXFER
suffix:semicolon
id|p-&gt;ultraenb
op_and_assign
op_complement
id|mask
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|user_offset
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|user_period
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|user_options
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|cur_offset
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|cur_period
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|cur_options
op_assign
l_int|0
suffix:semicolon
id|p-&gt;needsdtr_copy
op_and_assign
op_complement
id|mask
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA3
)paren
(brace
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|user_offset
op_assign
id|MAX_OFFSET_ULTRA2
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|cur_offset
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|TARG_OFFSET
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFXFER
)paren
OL
l_int|0x03
)paren
(brace
id|scsirate
op_assign
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFXFER
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|user_options
op_assign
id|MSG_EXT_PPR_OPTION_DT_CRC
suffix:semicolon
r_if
c_cond
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|TARG_SCSIRATE
op_plus
id|i
)paren
op_amp
id|CFXFER
)paren
OL
l_int|0x03
)paren
(brace
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|cur_options
op_assign
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|TARG_SCSIRATE
op_plus
id|i
)paren
op_amp
l_int|0x40
)paren
ques
c_cond
id|MSG_EXT_PPR_OPTION_DT_CRC
suffix:colon
id|MSG_EXT_PPR_OPTION_DT_UNITS
)paren
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|cur_options
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|scsirate
op_assign
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFXFER
)paren
op_or
(paren
(paren
id|p-&gt;ultraenb
op_amp
id|mask
)paren
ques
c_cond
l_int|0x18
suffix:colon
l_int|0x10
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|user_options
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|cur_options
op_assign
l_int|0
suffix:semicolon
)brace
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|user_period
op_assign
id|aic7xxx_find_period
c_func
(paren
id|p
comma
id|scsirate
comma
id|AHC_SYNCRATE_ULTRA3
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|cur_period
op_assign
id|aic7xxx_find_period
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|TARG_SCSIRATE
op_plus
id|i
)paren
comma
id|AHC_SYNCRATE_ULTRA3
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|user_offset
op_assign
id|MAX_OFFSET_ULTRA2
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|cur_offset
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|TARG_OFFSET
op_plus
id|i
)paren
suffix:semicolon
id|scsirate
op_assign
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFXFER
)paren
op_or
(paren
(paren
id|p-&gt;ultraenb
op_amp
id|mask
)paren
ques
c_cond
l_int|0x18
suffix:colon
l_int|0x10
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|user_options
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|cur_options
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|user_period
op_assign
id|aic7xxx_find_period
c_func
(paren
id|p
comma
id|scsirate
comma
id|AHC_SYNCRATE_ULTRA2
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|cur_period
op_assign
id|aic7xxx_find_period
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|TARG_SCSIRATE
op_plus
id|i
)paren
comma
id|AHC_SYNCRATE_ULTRA2
)paren
suffix:semicolon
)brace
r_else
(brace
id|scsirate
op_assign
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFXFER
)paren
op_lshift
l_int|4
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|user_options
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|cur_options
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|user_offset
op_assign
id|MAX_OFFSET_8BIT
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA
)paren
(brace
r_int
id|ultraenb
suffix:semicolon
id|ultraenb
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|ULTRA_ENB
)paren
op_or
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|ULTRA_ENB
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|user_period
op_assign
id|aic7xxx_find_period
c_func
(paren
id|p
comma
id|scsirate
comma
(paren
id|p-&gt;ultraenb
op_amp
id|mask
)paren
ques
c_cond
id|AHC_SYNCRATE_ULTRA
suffix:colon
id|AHC_SYNCRATE_FAST
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|cur_period
op_assign
id|aic7xxx_find_period
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|TARG_SCSIRATE
op_plus
id|i
)paren
comma
(paren
id|ultraenb
op_amp
id|mask
)paren
ques
c_cond
id|AHC_SYNCRATE_ULTRA
suffix:colon
id|AHC_SYNCRATE_FAST
)paren
suffix:semicolon
)brace
r_else
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|user_period
op_assign
id|aic7xxx_find_period
c_func
(paren
id|p
comma
id|scsirate
comma
id|AHC_SYNCRATE_FAST
)paren
suffix:semicolon
)brace
id|p-&gt;needsdtr_copy
op_or_assign
id|mask
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sc-&gt;device_flags
(braket
id|i
)braket
op_amp
id|CFWIDEB
)paren
op_logical_and
(paren
id|p-&gt;features
op_amp
id|AHC_WIDE
)paren
)paren
(brace
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|user_width
op_assign
id|MSG_EXT_WDTR_BUS_16_BIT
suffix:semicolon
id|p-&gt;needwdtr_copy
op_or_assign
id|mask
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|user_width
op_assign
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:semicolon
id|p-&gt;needwdtr_copy
op_and_assign
op_complement
id|mask
suffix:semicolon
)brace
id|p-&gt;transinfo
(braket
id|i
)braket
dot
id|cur_width
op_assign
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|TARG_SCSIRATE
op_plus
id|i
)paren
op_amp
id|WIDEXFER
)paren
ques
c_cond
id|MSG_EXT_WDTR_BUS_16_BIT
suffix:colon
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:semicolon
)brace
id|aic_outb
c_func
(paren
id|p
comma
op_complement
(paren
id|p-&gt;discenable
op_amp
l_int|0xFF
)paren
comma
id|DISC_DSB
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
op_complement
(paren
(paren
id|p-&gt;discenable
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
)paren
comma
id|DISC_DSB
op_plus
l_int|1
)paren
suffix:semicolon
id|p-&gt;needppr
op_assign
id|p-&gt;needppr_copy
op_assign
id|p-&gt;needdv
op_assign
l_int|0
suffix:semicolon
id|p-&gt;needwdtr
op_assign
id|p-&gt;needwdtr_copy
suffix:semicolon
id|p-&gt;needsdtr
op_assign
id|p-&gt;needsdtr_copy
suffix:semicolon
id|p-&gt;dtr_pending
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   * We set the p-&gt;ultraenb from the SEEPROM to begin with, but now we make&n;   * it match what is already down in the card.  If we are doing a reset&n;   * on the card then this will get put back to a default state anyway.&n;   * This allows us to not have to pre-emptively negotiate when using the&n;   * no_reset option.&n;   */
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA
)paren
id|p-&gt;ultraenb
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|ULTRA_ENB
)paren
op_or
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|ULTRA_ENB
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|scsi_conf
op_assign
(paren
id|p-&gt;scsi_id
op_amp
id|HSCSIID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|have_seeprom
)paren
(brace
id|p-&gt;adapter_control
op_assign
id|sc-&gt;adapter_control
suffix:semicolon
id|p-&gt;bios_control
op_assign
id|sc-&gt;bios_control
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)paren
(brace
r_case
id|AHC_AIC7895
suffix:colon
r_case
id|AHC_AIC7896
suffix:colon
r_case
id|AHC_AIC7899
suffix:colon
r_if
c_cond
(paren
id|p-&gt;adapter_control
op_amp
id|CFBPRIMARY
)paren
id|p-&gt;flags
op_or_assign
id|AHC_CHANNEL_B_PRIMARY
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sc-&gt;adapter_control
op_amp
id|CFSPARITY
)paren
id|scsi_conf
op_or_assign
id|ENSPCHK
suffix:semicolon
)brace
r_else
(brace
id|scsi_conf
op_or_assign
id|ENSPCHK
op_or
id|RESET_SCSI
suffix:semicolon
)brace
multiline_comment|/*&n;   * Only set the SCSICONF and SCSICONF + 1 registers if we are a PCI card.&n;   * The 2842 and 2742 cards already have these registers set and we don&squot;t&n;   * want to muck with them since we don&squot;t set all the bits they do.&n;   */
r_if
c_cond
(paren
(paren
id|p-&gt;chip
op_amp
op_complement
id|AHC_CHIPID_MASK
)paren
op_eq
id|AHC_PCI
)paren
(brace
multiline_comment|/* Set the host ID */
id|aic_outb
c_func
(paren
id|p
comma
id|scsi_conf
comma
id|SCSICONF
)paren
suffix:semicolon
multiline_comment|/* In case we are a wide card */
id|aic_outb
c_func
(paren
id|p
comma
id|p-&gt;scsi_id
comma
id|SCSICONF
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_detect&n; *&n; * Description:&n; *   Try to detect and register an Adaptec 7770 or 7870 SCSI controller.&n; *&n; * XXX - This should really be called aic7xxx_probe().  A sequence of&n; *       probe(), attach()/detach(), and init() makes more sense than&n; *       one do-it-all function.  This may be useful when (and if) the&n; *       mid-level SCSI code is overhauled.&n; *-F*************************************************************************/
r_int
DECL|function|aic7xxx_detect
id|aic7xxx_detect
c_func
(paren
id|Scsi_Host_Template
op_star
r_template
)paren
(brace
r_struct
id|aic7xxx_host
op_star
id|temp_p
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|current_p
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|list_p
op_assign
l_int|NULL
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined(__i386__) || defined(__alpha__)
id|ahc_flag_type
id|flags
op_assign
l_int|0
suffix:semicolon
r_int
id|type
suffix:semicolon
macro_line|#endif
r_int
r_char
id|sxfrctl1
suffix:semicolon
macro_line|#if defined(__i386__) || defined(__alpha__)
r_int
r_char
id|hcntrl
comma
id|hostconf
suffix:semicolon
r_int
r_int
id|slot
comma
id|base
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
multiline_comment|/*&n;   * If we are called as a module, the aic7xxx pointer may not be null&n;   * and it would point to our bootup string, just like on the lilo&n;   * command line.  IF not NULL, then process this config string with&n;   * aic7xxx_setup&n;   */
r_if
c_cond
(paren
id|aic7xxx
)paren
(brace
id|aic7xxx_setup
c_func
(paren
id|aic7xxx
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dummy_buffer
(braket
l_int|0
)braket
op_ne
l_char|&squot;P&squot;
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: Please read the file /usr/src/linux/drivers&quot;
l_string|&quot;/scsi/README.aic7xxx&bslash;n&quot;
l_string|&quot;aic7xxx: to see the proper way to specify options to the aic7xxx &quot;
l_string|&quot;module&bslash;n&quot;
l_string|&quot;aic7xxx: Specifically, don&squot;t use any commas when passing arguments to&bslash;n&quot;
l_string|&quot;aic7xxx: insmod or else it might trash certain memory areas.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_template
op_member_access_from_pointer
id|proc_name
op_assign
l_string|&quot;aic7xxx&quot;
suffix:semicolon
r_template
op_member_access_from_pointer
id|sg_tablesize
op_assign
id|AIC7XXX_MAX_SG
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
multiline_comment|/*&n;   * PCI-bus probe.&n;   */
r_if
c_cond
(paren
id|pci_present
c_func
(paren
)paren
)paren
(brace
r_struct
(brace
r_int
r_int
id|vendor_id
suffix:semicolon
r_int
r_int
id|device_id
suffix:semicolon
id|ahc_chip
id|chip
suffix:semicolon
id|ahc_flag_type
id|flags
suffix:semicolon
id|ahc_feature
id|features
suffix:semicolon
r_int
id|board_name_index
suffix:semicolon
r_int
r_int
id|seeprom_size
suffix:semicolon
r_int
r_int
id|seeprom_type
suffix:semicolon
)brace
r_const
id|aic_pdevs
(braket
)braket
op_assign
(brace
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7810
comma
id|AHC_NONE
comma
id|AHC_FNONE
comma
id|AHC_FENONE
comma
l_int|1
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7850
comma
id|AHC_AIC7850
comma
id|AHC_PAGESCBS
comma
id|AHC_AIC7850_FE
comma
l_int|5
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7855
comma
id|AHC_AIC7850
comma
id|AHC_PAGESCBS
comma
id|AHC_AIC7850_FE
comma
l_int|6
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7821
comma
id|AHC_AIC7860
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7860_FE
comma
l_int|7
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_3860
comma
id|AHC_AIC7860
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7860_FE
comma
l_int|7
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_38602
comma
id|AHC_AIC7860
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7860_FE
comma
l_int|7
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_38602
comma
id|AHC_AIC7860
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7860_FE
comma
l_int|7
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7860
comma
id|AHC_AIC7860
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
op_or
id|AHC_MOTHERBOARD
comma
id|AHC_AIC7860_FE
comma
l_int|7
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7861
comma
id|AHC_AIC7860
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7860_FE
comma
l_int|8
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7870
comma
id|AHC_AIC7870
comma
id|AHC_PAGESCBS
op_or
id|AHC_BIOS_ENABLED
op_or
id|AHC_MOTHERBOARD
comma
id|AHC_AIC7870_FE
comma
l_int|9
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7871
comma
id|AHC_AIC7870
comma
id|AHC_PAGESCBS
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7870_FE
comma
l_int|10
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7872
comma
id|AHC_AIC7870
comma
id|AHC_PAGESCBS
op_or
id|AHC_BIOS_ENABLED
op_or
id|AHC_MULTI_CHANNEL
comma
id|AHC_AIC7870_FE
comma
l_int|11
comma
l_int|32
comma
id|C56_66
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7873
comma
id|AHC_AIC7870
comma
id|AHC_PAGESCBS
op_or
id|AHC_BIOS_ENABLED
op_or
id|AHC_MULTI_CHANNEL
comma
id|AHC_AIC7870_FE
comma
l_int|12
comma
l_int|32
comma
id|C56_66
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7874
comma
id|AHC_AIC7870
comma
id|AHC_PAGESCBS
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7870_FE
comma
l_int|13
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7880
comma
id|AHC_AIC7880
comma
id|AHC_PAGESCBS
op_or
id|AHC_BIOS_ENABLED
op_or
id|AHC_MOTHERBOARD
comma
id|AHC_AIC7880_FE
comma
l_int|14
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7881
comma
id|AHC_AIC7880
comma
id|AHC_PAGESCBS
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7880_FE
comma
l_int|15
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7882
comma
id|AHC_AIC7880
comma
id|AHC_PAGESCBS
op_or
id|AHC_BIOS_ENABLED
op_or
id|AHC_MULTI_CHANNEL
comma
id|AHC_AIC7880_FE
comma
l_int|16
comma
l_int|32
comma
id|C56_66
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7883
comma
id|AHC_AIC7880
comma
id|AHC_PAGESCBS
op_or
id|AHC_BIOS_ENABLED
op_or
id|AHC_MULTI_CHANNEL
comma
id|AHC_AIC7880_FE
comma
l_int|17
comma
l_int|32
comma
id|C56_66
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7884
comma
id|AHC_AIC7880
comma
id|AHC_PAGESCBS
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7880_FE
comma
l_int|18
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7885
comma
id|AHC_AIC7880
comma
id|AHC_PAGESCBS
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7880_FE
comma
l_int|18
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7886
comma
id|AHC_AIC7880
comma
id|AHC_PAGESCBS
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7880_FE
comma
l_int|18
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7887
comma
id|AHC_AIC7880
comma
id|AHC_PAGESCBS
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7880_FE
op_or
id|AHC_NEW_AUTOTERM
comma
l_int|19
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7888
comma
id|AHC_AIC7880
comma
id|AHC_PAGESCBS
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7880_FE
comma
l_int|18
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_7895
comma
id|AHC_AIC7895
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
op_or
id|AHC_MULTI_CHANNEL
comma
id|AHC_AIC7895_FE
comma
l_int|20
comma
l_int|32
comma
id|C56_66
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC2
comma
id|PCI_DEVICE_ID_ADAPTEC2_7890
comma
id|AHC_AIC7890
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7890_FE
comma
l_int|21
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC2
comma
id|PCI_DEVICE_ID_ADAPTEC2_7890B
comma
id|AHC_AIC7890
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7890_FE
comma
l_int|21
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC2
comma
id|PCI_DEVICE_ID_ADAPTEC2_2930U2
comma
id|AHC_AIC7890
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7890_FE
comma
l_int|22
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC2
comma
id|PCI_DEVICE_ID_ADAPTEC2_2940U2
comma
id|AHC_AIC7890
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7890_FE
comma
l_int|23
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC2
comma
id|PCI_DEVICE_ID_ADAPTEC2_7896
comma
id|AHC_AIC7896
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
op_or
id|AHC_MULTI_CHANNEL
comma
id|AHC_AIC7896_FE
comma
l_int|24
comma
l_int|32
comma
id|C56_66
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC2
comma
id|PCI_DEVICE_ID_ADAPTEC2_3940U2
comma
id|AHC_AIC7896
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
op_or
id|AHC_MULTI_CHANNEL
comma
id|AHC_AIC7896_FE
comma
l_int|25
comma
l_int|32
comma
id|C56_66
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC2
comma
id|PCI_DEVICE_ID_ADAPTEC2_3950U2D
comma
id|AHC_AIC7896
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
op_or
id|AHC_MULTI_CHANNEL
comma
id|AHC_AIC7896_FE
comma
l_int|26
comma
l_int|32
comma
id|C56_66
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC
comma
id|PCI_DEVICE_ID_ADAPTEC_1480A
comma
id|AHC_AIC7860
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
op_or
id|AHC_NO_STPWEN
comma
id|AHC_AIC7860_FE
comma
l_int|27
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC2
comma
id|PCI_DEVICE_ID_ADAPTEC2_7892A
comma
id|AHC_AIC7892
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7892_FE
comma
l_int|28
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC2
comma
id|PCI_DEVICE_ID_ADAPTEC2_7892B
comma
id|AHC_AIC7892
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7892_FE
comma
l_int|28
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC2
comma
id|PCI_DEVICE_ID_ADAPTEC2_7892D
comma
id|AHC_AIC7892
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7892_FE
comma
l_int|28
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC2
comma
id|PCI_DEVICE_ID_ADAPTEC2_7892P
comma
id|AHC_AIC7892
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
comma
id|AHC_AIC7892_FE
comma
l_int|28
comma
l_int|32
comma
id|C46
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC2
comma
id|PCI_DEVICE_ID_ADAPTEC2_7899A
comma
id|AHC_AIC7899
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
op_or
id|AHC_MULTI_CHANNEL
comma
id|AHC_AIC7899_FE
comma
l_int|29
comma
l_int|32
comma
id|C56_66
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC2
comma
id|PCI_DEVICE_ID_ADAPTEC2_7899B
comma
id|AHC_AIC7899
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
op_or
id|AHC_MULTI_CHANNEL
comma
id|AHC_AIC7899_FE
comma
l_int|29
comma
l_int|32
comma
id|C56_66
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC2
comma
id|PCI_DEVICE_ID_ADAPTEC2_7899D
comma
id|AHC_AIC7899
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
op_or
id|AHC_MULTI_CHANNEL
comma
id|AHC_AIC7899_FE
comma
l_int|29
comma
l_int|32
comma
id|C56_66
)brace
comma
(brace
id|PCI_VENDOR_ID_ADAPTEC2
comma
id|PCI_DEVICE_ID_ADAPTEC2_7899P
comma
id|AHC_AIC7899
comma
id|AHC_PAGESCBS
op_or
id|AHC_NEWEEPROM_FMT
op_or
id|AHC_BIOS_ENABLED
op_or
id|AHC_MULTI_CHANNEL
comma
id|AHC_AIC7899_FE
comma
l_int|29
comma
l_int|32
comma
id|C56_66
)brace
comma
)brace
suffix:semicolon
r_int
r_int
id|command
suffix:semicolon
r_int
r_int
id|devconfig
comma
id|i
comma
id|oldverbose
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMBER
c_func
(paren
id|aic_pdevs
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pdev
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|pdev
op_assign
id|pci_find_device
c_func
(paren
id|aic_pdevs
(braket
id|i
)braket
dot
id|vendor_id
comma
id|aic_pdevs
(braket
id|i
)braket
dot
id|device_id
comma
id|pdev
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pdev
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
multiline_comment|/* We found one, but it&squot;s the 7810 RAID cont. */
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
(paren
id|VERBOSE_PROBE
op_or
id|VERBOSE_PROBE2
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: The 7810 RAID controller is not &quot;
l_string|&quot;supported by&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;         this driver, we are ignoring it.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|temp_p
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|aic7xxx_host
)paren
comma
id|GFP_ATOMIC
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|memset
c_func
(paren
id|temp_p
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|aic7xxx_host
)paren
)paren
suffix:semicolon
id|temp_p-&gt;chip
op_assign
id|aic_pdevs
(braket
id|i
)braket
dot
id|chip
op_or
id|AHC_PCI
suffix:semicolon
id|temp_p-&gt;flags
op_assign
id|aic_pdevs
(braket
id|i
)braket
dot
id|flags
suffix:semicolon
id|temp_p-&gt;features
op_assign
id|aic_pdevs
(braket
id|i
)braket
dot
id|features
suffix:semicolon
id|temp_p-&gt;board_name_index
op_assign
id|aic_pdevs
(braket
id|i
)braket
dot
id|board_name_index
suffix:semicolon
id|temp_p-&gt;sc_size
op_assign
id|aic_pdevs
(braket
id|i
)braket
dot
id|seeprom_size
suffix:semicolon
id|temp_p-&gt;sc_type
op_assign
id|aic_pdevs
(braket
id|i
)braket
dot
id|seeprom_type
suffix:semicolon
multiline_comment|/*&n;           * Read sundry information from PCI BIOS.&n;           */
id|temp_p-&gt;irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
id|temp_p-&gt;pdev
op_assign
id|pdev
suffix:semicolon
id|temp_p-&gt;pci_bus
op_assign
id|pdev-&gt;bus-&gt;number
suffix:semicolon
id|temp_p-&gt;pci_device_fn
op_assign
id|pdev-&gt;devfn
suffix:semicolon
id|temp_p-&gt;base
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|temp_p-&gt;mbase
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|1
)paren
suffix:semicolon
id|current_p
op_assign
id|list_p
suffix:semicolon
r_while
c_loop
(paren
id|current_p
op_logical_and
id|temp_p
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|current_p-&gt;pci_bus
op_eq
id|temp_p-&gt;pci_bus
)paren
op_logical_and
(paren
id|current_p-&gt;pci_device_fn
op_eq
id|temp_p-&gt;pci_device_fn
)paren
)paren
op_logical_or
(paren
id|temp_p-&gt;base
op_logical_and
(paren
id|current_p-&gt;base
op_eq
id|temp_p-&gt;base
)paren
)paren
op_logical_or
(paren
id|temp_p-&gt;mbase
op_logical_and
(paren
id|current_p-&gt;mbase
op_eq
id|temp_p-&gt;mbase
)paren
)paren
)paren
(brace
multiline_comment|/* duplicate PCI entry, skip it */
id|kfree
c_func
(paren
id|temp_p
)paren
suffix:semicolon
id|temp_p
op_assign
l_int|NULL
suffix:semicolon
)brace
id|current_p
op_assign
id|current_p-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|temp_p
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
l_string|&quot;aic7xxx: &lt;%s&gt; at PCI %d/%d&bslash;n&quot;
comma
id|board_names
(braket
id|aic_pdevs
(braket
id|i
)braket
dot
id|board_name_index
)braket
comma
id|PCI_SLOT
c_func
(paren
id|pdev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|pdev-&gt;devfn
)paren
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
op_amp
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Initial PCI_COMMAND value was 0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|command
)paren
suffix:semicolon
)brace
macro_line|#ifdef AIC7XXX_STRICT_PCI_SETUP
id|command
op_or_assign
id|PCI_COMMAND_SERR
op_or
id|PCI_COMMAND_PARITY
op_or
id|PCI_COMMAND_MASTER
op_or
id|PCI_COMMAND_MEMORY
op_or
id|PCI_COMMAND_IO
suffix:semicolon
macro_line|#else
id|command
op_or_assign
id|PCI_COMMAND_MASTER
op_or
id|PCI_COMMAND_MEMORY
op_or
id|PCI_COMMAND_IO
suffix:semicolon
macro_line|#endif
id|command
op_and_assign
op_complement
id|PCI_COMMAND_INVALIDATE
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_pci_parity
op_eq
l_int|0
)paren
id|command
op_and_assign
op_complement
(paren
id|PCI_COMMAND_SERR
op_or
id|PCI_COMMAND_PARITY
)paren
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
macro_line|#ifdef AIC7XXX_STRICT_PCI_SETUP
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|DEVCONFIG
comma
op_amp
id|devconfig
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Initial DEVCONFIG value was 0x%x&bslash;n&quot;
comma
id|devconfig
)paren
suffix:semicolon
)brace
id|devconfig
op_or_assign
l_int|0x80000040
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|pdev
comma
id|DEVCONFIG
comma
id|devconfig
)paren
suffix:semicolon
macro_line|#endif /* AIC7XXX_STRICT_PCI_SETUP */
r_if
c_cond
(paren
id|temp_p-&gt;base
op_logical_and
id|check_region
c_func
(paren
id|temp_p-&gt;base
comma
id|MAXREG
op_minus
id|MINREG
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: &lt;%s&gt; at PCI %d/%d/%d&bslash;n&quot;
comma
id|board_names
(braket
id|aic_pdevs
(braket
id|i
)braket
dot
id|board_name_index
)braket
comma
id|temp_p-&gt;pci_bus
comma
id|PCI_SLOT
c_func
(paren
id|temp_p-&gt;pci_device_fn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|temp_p-&gt;pci_device_fn
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aic7xxx: I/O ports already in use, ignoring.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|temp_p
)paren
suffix:semicolon
id|temp_p
op_assign
l_int|NULL
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|temp_p-&gt;unpause
op_assign
id|INTEN
suffix:semicolon
id|temp_p-&gt;pause
op_assign
id|temp_p-&gt;unpause
op_or
id|PAUSE
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|temp_p-&gt;base
op_eq
l_int|0
)paren
op_logical_and
(paren
id|temp_p-&gt;mbase
op_eq
l_int|0
)paren
)paren
op_logical_or
(paren
id|temp_p-&gt;irq
op_eq
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: &lt;%s&gt; at PCI %d/%d/%d&bslash;n&quot;
comma
id|board_names
(braket
id|aic_pdevs
(braket
id|i
)braket
dot
id|board_name_index
)braket
comma
id|temp_p-&gt;pci_bus
comma
id|PCI_SLOT
c_func
(paren
id|temp_p-&gt;pci_device_fn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|temp_p-&gt;pci_device_fn
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Controller disabled by BIOS, ignoring.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|temp_p
)paren
suffix:semicolon
id|temp_p
op_assign
l_int|NULL
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#ifdef MMAPIO
r_if
c_cond
(paren
op_logical_neg
(paren
id|temp_p-&gt;base
)paren
op_logical_or
op_logical_neg
(paren
id|temp_p-&gt;flags
op_amp
id|AHC_MULTI_CHANNEL
)paren
op_logical_or
(paren
(paren
id|temp_p-&gt;chip
op_ne
(paren
id|AHC_AIC7870
op_or
id|AHC_PCI
)paren
)paren
op_logical_and
(paren
id|temp_p-&gt;chip
op_ne
(paren
id|AHC_AIC7880
op_or
id|AHC_PCI
)paren
)paren
)paren
)paren
(brace
r_int
r_int
id|page_offset
comma
id|base
suffix:semicolon
id|base
op_assign
id|temp_p-&gt;mbase
op_amp
id|PAGE_MASK
suffix:semicolon
id|page_offset
op_assign
id|temp_p-&gt;mbase
op_minus
id|base
suffix:semicolon
id|temp_p-&gt;maddr
op_assign
id|ioremap_nocache
c_func
(paren
id|base
comma
id|page_offset
op_plus
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp_p-&gt;maddr
)paren
(brace
id|temp_p-&gt;maddr
op_add_assign
id|page_offset
suffix:semicolon
multiline_comment|/*&n;               * We need to check the I/O with the MMAPed address.  Some machines&n;               * simply fail to work with MMAPed I/O and certain controllers.&n;               */
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|temp_p
comma
id|HCNTRL
)paren
op_eq
l_int|0xff
)paren
(brace
multiline_comment|/*&n;                 * OK.....we failed our test....go back to programmed I/O&n;                 */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: &lt;%s&gt; at PCI %d/%d/%d&bslash;n&quot;
comma
id|board_names
(braket
id|aic_pdevs
(braket
id|i
)braket
dot
id|board_name_index
)braket
comma
id|temp_p-&gt;pci_bus
comma
id|PCI_SLOT
c_func
(paren
id|temp_p-&gt;pci_device_fn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|temp_p-&gt;pci_device_fn
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: MMAPed I/O failed, reverting to &quot;
l_string|&quot;Programmed I/O.&bslash;n&quot;
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
(paren
(paren
(paren
r_int
r_int
)paren
id|temp_p-&gt;maddr
)paren
op_amp
id|PAGE_MASK
)paren
)paren
suffix:semicolon
id|temp_p-&gt;maddr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|temp_p-&gt;base
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: &lt;%s&gt; at PCI %d/%d/%d&bslash;n&quot;
comma
id|board_names
(braket
id|aic_pdevs
(braket
id|i
)braket
dot
id|board_name_index
)braket
comma
id|temp_p-&gt;pci_bus
comma
id|PCI_SLOT
c_func
(paren
id|temp_p-&gt;pci_device_fn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|temp_p-&gt;pci_device_fn
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Controller disabled by BIOS, ignoring.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|temp_p
)paren
suffix:semicolon
id|temp_p
op_assign
l_int|NULL
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;           * Lock out other contenders for our i/o space.&n;           */
r_if
c_cond
(paren
id|temp_p-&gt;base
)paren
(brace
id|request_region
c_func
(paren
id|temp_p-&gt;base
comma
id|MAXREG
op_minus
id|MINREG
comma
l_string|&quot;aic7xxx&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;           * We HAVE to make sure the first pause_sequencer() and all other&n;           * subsequent I/O that isn&squot;t PCI config space I/O takes place&n;           * after the MMAPed I/O region is configured and tested.  The&n;           * problem is the PowerPC architecture that doesn&squot;t support&n;           * programmed I/O at all, so we have to have the MMAP I/O set up&n;           * for this pause to even work on those machines.&n;           */
id|pause_sequencer
c_func
(paren
id|temp_p
)paren
suffix:semicolon
multiline_comment|/*&n;           * Clear out any pending PCI error status messages.  Also set&n;           * verbose to 0 so that we don&squot;t emit strange PCI error messages&n;           * while cleaning out the current status bits.&n;           */
id|oldverbose
op_assign
id|aic7xxx_verbose
suffix:semicolon
id|aic7xxx_verbose
op_assign
l_int|0
suffix:semicolon
id|aic7xxx_pci_intr
c_func
(paren
id|temp_p
)paren
suffix:semicolon
id|aic7xxx_verbose
op_assign
id|oldverbose
suffix:semicolon
id|temp_p-&gt;bios_address
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;           * Remember how the card was setup in case there is no seeprom.&n;           */
r_if
c_cond
(paren
id|temp_p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
id|temp_p-&gt;scsi_id
op_assign
id|aic_inb
c_func
(paren
id|temp_p
comma
id|SCSIID_ULTRA2
)paren
op_amp
id|OID
suffix:semicolon
r_else
id|temp_p-&gt;scsi_id
op_assign
id|aic_inb
c_func
(paren
id|temp_p
comma
id|SCSIID
)paren
op_amp
id|OID
suffix:semicolon
multiline_comment|/*&n;           * Get current termination setting&n;           */
id|sxfrctl1
op_assign
id|aic_inb
c_func
(paren
id|temp_p
comma
id|SXFRCTL1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_chip_reset
c_func
(paren
id|temp_p
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|release_region
c_func
(paren
id|temp_p-&gt;base
comma
id|MAXREG
op_minus
id|MINREG
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|temp_p
)paren
suffix:semicolon
id|temp_p
op_assign
l_int|NULL
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;           * Very quickly put the term setting back into the register since&n;           * the chip reset may cause odd things to happen.  This is to keep&n;           * LVD busses with lots of drives from draining the power out of&n;           * the diffsense line before we get around to running the&n;           * configure_termination() function.  Also restore the STPWLEVEL&n;           * bit of DEVCONFIG&n;           */
id|aic_outb
c_func
(paren
id|temp_p
comma
id|sxfrctl1
comma
id|SXFRCTL1
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|temp_p-&gt;pdev
comma
id|DEVCONFIG
comma
id|devconfig
)paren
suffix:semicolon
id|sxfrctl1
op_and_assign
id|STPWEN
suffix:semicolon
multiline_comment|/*&n;           * We need to set the CHNL? assignments before loading the SEEPROM&n;           * The 3940 and 3985 cards (original stuff, not any of the later&n;           * stuff) are 7870 and 7880 class chips.  The Ultra2 stuff falls&n;           * under 7896 and 7897.  The 7895 is in a class by itself :)&n;           */
r_switch
c_cond
(paren
id|temp_p-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)paren
(brace
r_case
id|AHC_AIC7870
suffix:colon
multiline_comment|/* 3840 / 3985 */
r_case
id|AHC_AIC7880
suffix:colon
multiline_comment|/* 3840 UW / 3985 UW */
r_if
c_cond
(paren
id|temp_p-&gt;flags
op_amp
id|AHC_MULTI_CHANNEL
)paren
(brace
r_switch
c_cond
(paren
id|PCI_SLOT
c_func
(paren
id|temp_p-&gt;pci_device_fn
)paren
)paren
(brace
r_case
l_int|5
suffix:colon
id|temp_p-&gt;flags
op_or_assign
id|AHC_CHNLB
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
id|temp_p-&gt;flags
op_or_assign
id|AHC_CHNLB
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
id|temp_p-&gt;flags
op_or_assign
id|AHC_CHNLC
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|AHC_AIC7895
suffix:colon
multiline_comment|/* 7895 */
r_case
id|AHC_AIC7896
suffix:colon
multiline_comment|/* 7896/7 */
r_case
id|AHC_AIC7899
suffix:colon
multiline_comment|/* 7899 */
r_if
c_cond
(paren
id|PCI_FUNC
c_func
(paren
id|pdev-&gt;devfn
)paren
op_ne
l_int|0
)paren
(brace
id|temp_p-&gt;flags
op_or_assign
id|AHC_CHNLB
suffix:semicolon
)brace
multiline_comment|/*&n;               * The 7895 is the only chipset that sets the SCBSIZE32 param&n;               * in the DEVCONFIG register.  The Ultra2 chipsets use&n;               * the DSCOMMAND0 register instead.&n;               */
r_if
c_cond
(paren
(paren
id|temp_p-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)paren
op_eq
id|AHC_AIC7895
)paren
(brace
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|DEVCONFIG
comma
op_amp
id|devconfig
)paren
suffix:semicolon
id|devconfig
op_or_assign
id|SCBSIZE32
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|pdev
comma
id|DEVCONFIG
comma
id|devconfig
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;           * Loading of the SEEPROM needs to come after we&squot;ve set the flags&n;           * to indicate possible CHNLB and CHNLC assigments.  Otherwise,&n;           * on 394x and 398x cards we&squot;ll end up reading the wrong settings&n;           * for channels B and C&n;           */
r_switch
c_cond
(paren
id|temp_p-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)paren
(brace
r_case
id|AHC_AIC7892
suffix:colon
r_case
id|AHC_AIC7899
suffix:colon
id|aic_outb
c_func
(paren
id|temp_p
comma
l_int|0
comma
id|SCAMCTL
)paren
suffix:semicolon
multiline_comment|/*&n;               * Switch to the alt mode of the chip...&n;               */
id|aic_outb
c_func
(paren
id|temp_p
comma
id|aic_inb
c_func
(paren
id|temp_p
comma
id|SFUNCT
)paren
op_or
id|ALT_MODE
comma
id|SFUNCT
)paren
suffix:semicolon
multiline_comment|/*&n;               * Set our options...the last two items set our CRC after x byte&n;&t;       * count in target mode...&n;               */
id|aic_outb
c_func
(paren
id|temp_p
comma
id|AUTO_MSGOUT_DE
op_or
id|DIS_MSGIN_DUALEDGE
comma
id|OPTIONMODE
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|temp_p
comma
l_int|0x00
comma
l_int|0x0b
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|temp_p
comma
l_int|0x10
comma
l_int|0x0a
)paren
suffix:semicolon
multiline_comment|/*&n;               * switch back to normal mode...&n;               */
id|aic_outb
c_func
(paren
id|temp_p
comma
id|aic_inb
c_func
(paren
id|temp_p
comma
id|SFUNCT
)paren
op_amp
op_complement
id|ALT_MODE
comma
id|SFUNCT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|temp_p
comma
id|CRCVALCHKEN
op_or
id|CRCENDCHKEN
op_or
id|CRCREQCHKEN
op_or
id|TARGCRCENDEN
op_or
id|TARGCRCCNTEN
comma
id|CRCCONTROL1
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|temp_p
comma
(paren
(paren
id|aic_inb
c_func
(paren
id|temp_p
comma
id|DSCOMMAND0
)paren
op_or
id|USCBSIZE32
op_or
id|MPARCKEN
op_or
id|CIOPARCKEN
op_or
id|CACHETHEN
)paren
op_amp
op_complement
id|DPARCKEN
)paren
comma
id|DSCOMMAND0
)paren
suffix:semicolon
id|aic7xxx_load_seeprom
c_func
(paren
id|temp_p
comma
op_amp
id|sxfrctl1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AHC_AIC7890
suffix:colon
r_case
id|AHC_AIC7896
suffix:colon
id|aic_outb
c_func
(paren
id|temp_p
comma
l_int|0
comma
id|SCAMCTL
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|temp_p
comma
(paren
id|aic_inb
c_func
(paren
id|temp_p
comma
id|DSCOMMAND0
)paren
op_or
id|CACHETHEN
op_or
id|MPARCKEN
op_or
id|USCBSIZE32
op_or
id|CIOPARCKEN
)paren
op_amp
op_complement
id|DPARCKEN
comma
id|DSCOMMAND0
)paren
suffix:semicolon
id|aic7xxx_load_seeprom
c_func
(paren
id|temp_p
comma
op_amp
id|sxfrctl1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AHC_AIC7850
suffix:colon
r_case
id|AHC_AIC7860
suffix:colon
multiline_comment|/*&n;               * Set the DSCOMMAND0 register on these cards different from&n;               * on the 789x cards.  Also, read the SEEPROM as well.&n;               */
id|aic_outb
c_func
(paren
id|temp_p
comma
(paren
id|aic_inb
c_func
(paren
id|temp_p
comma
id|DSCOMMAND0
)paren
op_or
id|CACHETHEN
op_or
id|MPARCKEN
)paren
op_amp
op_complement
id|DPARCKEN
comma
id|DSCOMMAND0
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_default
suffix:colon
id|aic7xxx_load_seeprom
c_func
(paren
id|temp_p
comma
op_amp
id|sxfrctl1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AHC_AIC7880
suffix:colon
multiline_comment|/*&n;               * Check the rev of the chipset before we change DSCOMMAND0&n;               */
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|DEVCONFIG
comma
op_amp
id|devconfig
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|devconfig
op_amp
l_int|0xff
)paren
op_ge
l_int|1
)paren
(brace
id|aic_outb
c_func
(paren
id|temp_p
comma
(paren
id|aic_inb
c_func
(paren
id|temp_p
comma
id|DSCOMMAND0
)paren
op_or
id|CACHETHEN
op_or
id|MPARCKEN
)paren
op_amp
op_complement
id|DPARCKEN
comma
id|DSCOMMAND0
)paren
suffix:semicolon
)brace
id|aic7xxx_load_seeprom
c_func
(paren
id|temp_p
comma
op_amp
id|sxfrctl1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;           * and then we need another switch based on the type in order to&n;           * make sure the channel B primary flag is set properly on 7895&n;           * controllers....Arrrgggghhh!!!  We also have to catch the fact&n;           * that when you disable the BIOS on the 7895 on the Intel DK440LX&n;           * motherboard, and possibly others, it only sets the BIOS disabled&n;           * bit on the A channel...I think I&squot;m starting to lean towards&n;           * going postal....&n;           */
r_switch
c_cond
(paren
id|temp_p-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)paren
(brace
r_case
id|AHC_AIC7895
suffix:colon
r_case
id|AHC_AIC7896
suffix:colon
r_case
id|AHC_AIC7899
suffix:colon
id|current_p
op_assign
id|list_p
suffix:semicolon
r_while
c_loop
(paren
id|current_p
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|current_p-&gt;pci_bus
op_eq
id|temp_p-&gt;pci_bus
)paren
op_logical_and
(paren
id|PCI_SLOT
c_func
(paren
id|current_p-&gt;pci_device_fn
)paren
op_eq
id|PCI_SLOT
c_func
(paren
id|temp_p-&gt;pci_device_fn
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|PCI_FUNC
c_func
(paren
id|current_p-&gt;pci_device_fn
)paren
op_eq
l_int|0
)paren
(brace
id|temp_p-&gt;flags
op_or_assign
(paren
id|current_p-&gt;flags
op_amp
id|AHC_CHANNEL_B_PRIMARY
)paren
suffix:semicolon
id|temp_p-&gt;flags
op_and_assign
op_complement
(paren
id|AHC_BIOS_ENABLED
op_or
id|AHC_USEDEFAULTS
)paren
suffix:semicolon
id|temp_p-&gt;flags
op_or_assign
(paren
id|current_p-&gt;flags
op_amp
(paren
id|AHC_BIOS_ENABLED
op_or
id|AHC_USEDEFAULTS
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|current_p-&gt;flags
op_or_assign
(paren
id|temp_p-&gt;flags
op_amp
id|AHC_CHANNEL_B_PRIMARY
)paren
suffix:semicolon
id|current_p-&gt;flags
op_and_assign
op_complement
(paren
id|AHC_BIOS_ENABLED
op_or
id|AHC_USEDEFAULTS
)paren
suffix:semicolon
id|current_p-&gt;flags
op_or_assign
(paren
id|temp_p-&gt;flags
op_amp
(paren
id|AHC_BIOS_ENABLED
op_or
id|AHC_USEDEFAULTS
)paren
)paren
suffix:semicolon
)brace
)brace
id|current_p
op_assign
id|current_p-&gt;next
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;           * We only support external SCB RAM on the 7895/6/7 chipsets.&n;           * We could support it on the 7890/1 easy enough, but I don&squot;t&n;           * know of any 7890/1 based cards that have it.  I do know&n;           * of 7895/6/7 cards that have it and they work properly.&n;           */
r_switch
c_cond
(paren
id|temp_p-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|AHC_AIC7895
suffix:colon
r_case
id|AHC_AIC7896
suffix:colon
r_case
id|AHC_AIC7899
suffix:colon
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|DEVCONFIG
comma
op_amp
id|devconfig
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp_p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
r_if
c_cond
(paren
(paren
id|aic_inb
c_func
(paren
id|temp_p
comma
id|DSCOMMAND0
)paren
op_amp
id|RAMPSM_ULTRA2
)paren
op_logical_and
(paren
id|aic7xxx_scbram
)paren
)paren
(brace
id|aic_outb
c_func
(paren
id|temp_p
comma
id|aic_inb
c_func
(paren
id|temp_p
comma
id|DSCOMMAND0
)paren
op_amp
op_complement
id|SCBRAMSEL_ULTRA2
comma
id|DSCOMMAND0
)paren
suffix:semicolon
id|temp_p-&gt;flags
op_or_assign
id|AHC_EXTERNAL_SRAM
suffix:semicolon
id|devconfig
op_or_assign
id|EXTSCBPEN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|temp_p
comma
id|DSCOMMAND0
)paren
op_amp
id|RAMPSM_ULTRA2
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: &lt;%s&gt; at PCI %d/%d/%d&bslash;n&quot;
comma
id|board_names
(braket
id|aic_pdevs
(braket
id|i
)braket
dot
id|board_name_index
)braket
comma
id|temp_p-&gt;pci_bus
comma
id|PCI_SLOT
c_func
(paren
id|temp_p-&gt;pci_device_fn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|temp_p-&gt;pci_device_fn
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aic7xxx: external SCB RAM detected, &quot;
l_string|&quot;but not enabled&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|devconfig
op_amp
id|RAMPSM
)paren
op_logical_and
(paren
id|aic7xxx_scbram
)paren
)paren
(brace
id|devconfig
op_and_assign
op_complement
id|SCBRAMSEL
suffix:semicolon
id|devconfig
op_or_assign
id|EXTSCBPEN
suffix:semicolon
id|temp_p-&gt;flags
op_or_assign
id|AHC_EXTERNAL_SRAM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|devconfig
op_amp
id|RAMPSM
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: &lt;%s&gt; at PCI %d/%d/%d&bslash;n&quot;
comma
id|board_names
(braket
id|aic_pdevs
(braket
id|i
)braket
dot
id|board_name_index
)braket
comma
id|temp_p-&gt;pci_bus
comma
id|PCI_SLOT
c_func
(paren
id|temp_p-&gt;pci_device_fn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|temp_p-&gt;pci_device_fn
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aic7xxx: external SCB RAM detected, &quot;
l_string|&quot;but not enabled&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|pci_write_config_dword
c_func
(paren
id|pdev
comma
id|DEVCONFIG
comma
id|devconfig
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp_p-&gt;flags
op_amp
id|AHC_EXTERNAL_SRAM
)paren
op_logical_and
(paren
id|temp_p-&gt;flags
op_amp
id|AHC_CHNLB
)paren
)paren
id|aic_outb
c_func
(paren
id|temp_p
comma
l_int|1
comma
id|CCSCBBADDR
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;           * Take the LED out of diagnostic mode&n;           */
id|aic_outb
c_func
(paren
id|temp_p
comma
(paren
id|aic_inb
c_func
(paren
id|temp_p
comma
id|SBLKCTL
)paren
op_amp
op_complement
(paren
id|DIAGLEDEN
op_or
id|DIAGLEDON
)paren
)paren
comma
id|SBLKCTL
)paren
suffix:semicolon
multiline_comment|/*&n;           * We don&squot;t know where this is set in the SEEPROM or by the&n;           * BIOS, so we default to 100%.  On Ultra2 controllers, use 75%&n;           * instead.&n;           */
r_if
c_cond
(paren
id|temp_p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
(brace
id|aic_outb
c_func
(paren
id|temp_p
comma
id|RD_DFTHRSH_MAX
op_or
id|WR_DFTHRSH_MAX
comma
id|DFF_THRSH
)paren
suffix:semicolon
)brace
r_else
(brace
id|aic_outb
c_func
(paren
id|temp_p
comma
id|DFTHRSH_100
comma
id|DSPCISTATUS
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|list_p
op_eq
l_int|NULL
)paren
(brace
id|list_p
op_assign
id|current_p
op_assign
id|temp_p
suffix:semicolon
)brace
r_else
(brace
id|current_p
op_assign
id|list_p
suffix:semicolon
r_while
c_loop
(paren
id|current_p-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|current_p
op_assign
id|current_p-&gt;next
suffix:semicolon
)brace
id|current_p-&gt;next
op_assign
id|temp_p
suffix:semicolon
)brace
id|temp_p-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
multiline_comment|/* Found an Adaptec PCI device. */
r_else
multiline_comment|/* Well, we found one, but we couldn&squot;t get any memory */
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx: Found &lt;%s&gt;&bslash;n&quot;
comma
id|board_names
(braket
id|aic_pdevs
(braket
id|i
)braket
dot
id|board_name_index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Unable to allocate device memory, &quot;
l_string|&quot;skipping.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* while(pdev=....) */
)brace
multiline_comment|/* for PCI_DEVICES */
)brace
multiline_comment|/* PCI BIOS present */
macro_line|#endif CONFIG_PCI
macro_line|#if defined(__i386__) || defined(__alpha__)
multiline_comment|/*&n;   * EISA/VL-bus card signature probe.&n;   */
id|slot
op_assign
id|MINSLOT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|slot
op_le
id|MAXSLOT
)paren
op_logical_and
op_logical_neg
(paren
id|aic7xxx_no_probe
)paren
)paren
(brace
id|base
op_assign
id|SLOTBASE
c_func
(paren
id|slot
)paren
op_plus
id|MINREG
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|base
comma
id|MAXREG
op_minus
id|MINREG
)paren
)paren
(brace
multiline_comment|/*&n;       * Some other driver has staked a&n;       * claim to this i/o region already.&n;       */
id|slot
op_increment
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* back to the beginning of the for loop */
)brace
id|flags
op_assign
l_int|0
suffix:semicolon
id|type
op_assign
id|aic7xxx_probe
c_func
(paren
id|slot
comma
id|base
op_plus
id|AHC_HID0
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
op_minus
l_int|1
)paren
(brace
id|slot
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|temp_p
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|aic7xxx_host
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp_p
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: Unable to allocate device space.&bslash;n&quot;
)paren
suffix:semicolon
id|slot
op_increment
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* back to the beginning of the while loop */
)brace
multiline_comment|/*&n;     * Lock out other contenders for our i/o space.&n;     */
id|request_region
c_func
(paren
id|base
comma
id|MAXREG
op_minus
id|MINREG
comma
l_string|&quot;aic7xxx&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * Pause the card preserving the IRQ type.  Allow the operator&n;     * to override the IRQ trigger.&n;     */
r_if
c_cond
(paren
id|aic7xxx_irq_trigger
op_eq
l_int|1
)paren
id|hcntrl
op_assign
id|IRQMS
suffix:semicolon
multiline_comment|/* Level */
r_else
r_if
c_cond
(paren
id|aic7xxx_irq_trigger
op_eq
l_int|0
)paren
id|hcntrl
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Edge */
r_else
id|hcntrl
op_assign
id|inb
c_func
(paren
id|base
op_plus
id|HCNTRL
)paren
op_amp
id|IRQMS
suffix:semicolon
multiline_comment|/* Default */
id|memset
c_func
(paren
id|temp_p
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|aic7xxx_host
)paren
)paren
suffix:semicolon
id|temp_p-&gt;unpause
op_assign
id|hcntrl
op_or
id|INTEN
suffix:semicolon
id|temp_p-&gt;pause
op_assign
id|hcntrl
op_or
id|PAUSE
op_or
id|INTEN
suffix:semicolon
id|temp_p-&gt;base
op_assign
id|base
suffix:semicolon
id|temp_p-&gt;mbase
op_assign
l_int|0
suffix:semicolon
id|temp_p-&gt;maddr
op_assign
l_int|0
suffix:semicolon
id|temp_p-&gt;pci_bus
op_assign
l_int|0
suffix:semicolon
id|temp_p-&gt;pci_device_fn
op_assign
id|slot
suffix:semicolon
id|aic_outb
c_func
(paren
id|temp_p
comma
id|hcntrl
op_or
id|PAUSE
comma
id|HCNTRL
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|aic_inb
c_func
(paren
id|temp_p
comma
id|HCNTRL
)paren
op_amp
id|PAUSE
)paren
op_eq
l_int|0
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_chip_reset
c_func
(paren
id|temp_p
)paren
op_eq
op_minus
l_int|1
)paren
id|temp_p-&gt;irq
op_assign
l_int|0
suffix:semicolon
r_else
id|temp_p-&gt;irq
op_assign
id|aic_inb
c_func
(paren
id|temp_p
comma
id|INTDEF
)paren
op_amp
l_int|0x0F
suffix:semicolon
id|temp_p-&gt;flags
op_or_assign
id|AHC_PAGESCBS
suffix:semicolon
r_switch
c_cond
(paren
id|temp_p-&gt;irq
)paren
(brace
r_case
l_int|9
suffix:colon
r_case
l_int|10
suffix:colon
r_case
l_int|11
suffix:colon
r_case
l_int|12
suffix:colon
r_case
l_int|14
suffix:colon
r_case
l_int|15
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: Host adapter uses unsupported IRQ &quot;
l_string|&quot;level %d, ignoring.&bslash;n&quot;
comma
id|temp_p-&gt;irq
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|temp_p
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|base
comma
id|MAXREG
op_minus
id|MINREG
)paren
suffix:semicolon
id|slot
op_increment
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* back to the beginning of the while loop */
)brace
multiline_comment|/*&n;     * We are commited now, everything has been checked and this card&n;     * has been found, now we just set it up&n;     */
multiline_comment|/*&n;     * Insert our new struct into the list at the end&n;     */
r_if
c_cond
(paren
id|list_p
op_eq
l_int|NULL
)paren
(brace
id|list_p
op_assign
id|current_p
op_assign
id|temp_p
suffix:semicolon
)brace
r_else
(brace
id|current_p
op_assign
id|list_p
suffix:semicolon
r_while
c_loop
(paren
id|current_p-&gt;next
op_ne
l_int|NULL
)paren
id|current_p
op_assign
id|current_p-&gt;next
suffix:semicolon
id|current_p-&gt;next
op_assign
id|temp_p
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
l_int|0
suffix:colon
id|temp_p-&gt;board_name_index
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
l_string|&quot;aic7xxx: &lt;%s&gt; at EISA %d&bslash;n&quot;
comma
id|board_names
(braket
l_int|2
)braket
comma
id|slot
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
l_int|1
suffix:colon
(brace
id|temp_p-&gt;chip
op_assign
id|AHC_AIC7770
op_or
id|AHC_EISA
suffix:semicolon
id|temp_p-&gt;features
op_or_assign
id|AHC_AIC7770_FE
suffix:semicolon
id|temp_p-&gt;bios_control
op_assign
id|aic_inb
c_func
(paren
id|temp_p
comma
id|HA_274_BIOSCTRL
)paren
suffix:semicolon
multiline_comment|/*&n;         * Get the primary channel information.  Right now we don&squot;t&n;         * do anything with this, but someday we will be able to inform&n;         * the mid-level SCSI code which channel is primary.&n;         */
r_if
c_cond
(paren
id|temp_p-&gt;board_name_index
op_eq
l_int|0
)paren
(brace
id|temp_p-&gt;board_name_index
op_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
l_string|&quot;aic7xxx: &lt;%s&gt; at EISA %d&bslash;n&quot;
comma
id|board_names
(braket
l_int|3
)braket
comma
id|slot
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|temp_p-&gt;bios_control
op_amp
id|CHANNEL_B_PRIMARY
)paren
(brace
id|temp_p-&gt;flags
op_or_assign
id|AHC_CHANNEL_B_PRIMARY
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|temp_p-&gt;bios_control
op_amp
id|BIOSMODE
)paren
op_eq
id|BIOSDISABLED
)paren
(brace
id|temp_p-&gt;flags
op_and_assign
op_complement
id|AHC_BIOS_ENABLED
suffix:semicolon
)brace
r_else
(brace
id|temp_p-&gt;flags
op_and_assign
op_complement
id|AHC_USEDEFAULTS
suffix:semicolon
id|temp_p-&gt;flags
op_or_assign
id|AHC_BIOS_ENABLED
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp_p-&gt;bios_control
op_amp
l_int|0x20
)paren
op_eq
l_int|0
)paren
(brace
id|temp_p-&gt;bios_address
op_assign
l_int|0xcc000
suffix:semicolon
id|temp_p-&gt;bios_address
op_add_assign
(paren
l_int|0x4000
op_star
(paren
id|temp_p-&gt;bios_control
op_amp
l_int|0x07
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|temp_p-&gt;bios_address
op_assign
l_int|0xd0000
suffix:semicolon
id|temp_p-&gt;bios_address
op_add_assign
(paren
l_int|0x8000
op_star
(paren
id|temp_p-&gt;bios_control
op_amp
l_int|0x06
)paren
)paren
suffix:semicolon
)brace
)brace
id|temp_p-&gt;adapter_control
op_assign
id|aic_inb
c_func
(paren
id|temp_p
comma
id|SCSICONF
)paren
op_lshift
l_int|8
suffix:semicolon
id|temp_p-&gt;adapter_control
op_or_assign
id|aic_inb
c_func
(paren
id|temp_p
comma
id|SCSICONF
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp_p-&gt;features
op_amp
id|AHC_WIDE
)paren
(brace
id|temp_p-&gt;scsi_id
op_assign
id|temp_p-&gt;adapter_control
op_amp
id|HWSCSIID
suffix:semicolon
id|temp_p-&gt;scsi_id_b
op_assign
id|temp_p-&gt;scsi_id
suffix:semicolon
)brace
r_else
(brace
id|temp_p-&gt;scsi_id
op_assign
(paren
id|temp_p-&gt;adapter_control
op_rshift
l_int|8
)paren
op_amp
id|HSCSIID
suffix:semicolon
id|temp_p-&gt;scsi_id_b
op_assign
id|temp_p-&gt;adapter_control
op_amp
id|HSCSIID
suffix:semicolon
)brace
id|aic7xxx_load_seeprom
c_func
(paren
id|temp_p
comma
op_amp
id|sxfrctl1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
id|temp_p-&gt;chip
op_assign
id|AHC_AIC7770
op_or
id|AHC_VL
suffix:semicolon
id|temp_p-&gt;features
op_or_assign
id|AHC_AIC7770_FE
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
l_int|2
)paren
id|temp_p-&gt;flags
op_or_assign
id|AHC_BIOS_ENABLED
suffix:semicolon
r_else
id|temp_p-&gt;flags
op_and_assign
op_complement
id|AHC_BIOS_ENABLED
suffix:semicolon
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|temp_p
comma
id|SCSICONF
)paren
op_amp
id|TERM_ENB
)paren
id|sxfrctl1
op_assign
id|STPWEN
suffix:semicolon
id|aic7xxx_load_seeprom
c_func
(paren
id|temp_p
comma
op_amp
id|sxfrctl1
)paren
suffix:semicolon
id|temp_p-&gt;board_name_index
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
l_string|&quot;aic7xxx: &lt;%s&gt; at VLB %d&bslash;n&quot;
comma
id|board_names
(braket
l_int|2
)braket
comma
id|slot
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|aic_inb
c_func
(paren
id|temp_p
comma
id|STATUS_2840
)paren
op_amp
id|BIOS_SEL
)paren
(brace
r_case
l_int|0x00
suffix:colon
id|temp_p-&gt;bios_address
op_assign
l_int|0xe0000
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x20
suffix:colon
id|temp_p-&gt;bios_address
op_assign
l_int|0xc8000
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
id|temp_p-&gt;bios_address
op_assign
l_int|0xd0000
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x60
suffix:colon
id|temp_p-&gt;bios_address
op_assign
l_int|0xd8000
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* can&squot;t get here */
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Won&squot;t get here. */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: BIOS %sabled, IO Port 0x%lx, IRQ %d (%s)&bslash;n&quot;
comma
(paren
id|temp_p-&gt;flags
op_amp
id|AHC_USEDEFAULTS
)paren
ques
c_cond
l_string|&quot;dis&quot;
suffix:colon
l_string|&quot;en&quot;
comma
id|temp_p-&gt;base
comma
id|temp_p-&gt;irq
comma
(paren
id|temp_p-&gt;pause
op_amp
id|IRQMS
)paren
ques
c_cond
l_string|&quot;level sensitive&quot;
suffix:colon
l_string|&quot;edge triggered&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aic7xxx: Extended translation %sabled.&bslash;n&quot;
comma
(paren
id|temp_p-&gt;flags
op_amp
id|AHC_EXTEND_TRANS_A
)paren
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Set the FIFO threshold and the bus off time.&n;     */
id|hostconf
op_assign
id|aic_inb
c_func
(paren
id|temp_p
comma
id|HOSTCONF
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|temp_p
comma
id|hostconf
op_amp
id|DFTHRSH
comma
id|BUSSPD
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|temp_p
comma
(paren
id|hostconf
op_lshift
l_int|2
)paren
op_amp
id|BOFF
comma
id|BUSTIME
)paren
suffix:semicolon
id|slot
op_increment
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
macro_line|#endif /* defined(__i386__) || defined(__alpha__) */
multiline_comment|/*&n;   * Now, we re-order the probed devices by BIOS address and BUS class.&n;   * In general, we follow this algorithm to make the adapters show up&n;   * in the same order under linux that the computer finds them.&n;   *  1: All VLB/EISA cards with BIOS_ENABLED first, according to BIOS&n;   *     address, going from lowest to highest.&n;   *  2: All PCI controllers with BIOS_ENABLED next, according to BIOS&n;   *     address, going from lowest to highest.&n;   *  3: Remaining VLB/EISA controllers going in slot order.&n;   *  4: Remaining PCI controllers, going in PCI device order (reversable)&n;   */
(brace
r_struct
id|aic7xxx_host
op_star
id|sort_list
(braket
l_int|4
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|vlb
comma
op_star
id|pci
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|prev_p
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
r_int
r_char
id|left
suffix:semicolon
id|prev_p
op_assign
id|vlb
op_assign
id|pci
op_assign
l_int|NULL
suffix:semicolon
id|temp_p
op_assign
id|list_p
suffix:semicolon
r_while
c_loop
(paren
id|temp_p
op_ne
l_int|NULL
)paren
(brace
r_switch
c_cond
(paren
id|temp_p-&gt;chip
op_amp
op_complement
id|AHC_CHIPID_MASK
)paren
(brace
r_case
id|AHC_EISA
suffix:colon
r_case
id|AHC_VL
suffix:colon
(brace
id|p
op_assign
id|temp_p
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|AHC_BIOS_ENABLED
)paren
id|vlb
op_assign
id|sort_list
(braket
l_int|0
)braket
suffix:semicolon
r_else
id|vlb
op_assign
id|sort_list
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|vlb
op_eq
l_int|NULL
)paren
(brace
id|vlb
op_assign
id|temp_p
suffix:semicolon
id|temp_p
op_assign
id|temp_p-&gt;next
suffix:semicolon
id|vlb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|current_p
op_assign
id|vlb
suffix:semicolon
id|prev_p
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|current_p
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|current_p-&gt;bios_address
OL
id|temp_p-&gt;bios_address
)paren
)paren
(brace
id|prev_p
op_assign
id|current_p
suffix:semicolon
id|current_p
op_assign
id|current_p-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev_p
op_ne
l_int|NULL
)paren
(brace
id|prev_p-&gt;next
op_assign
id|temp_p
suffix:semicolon
id|temp_p
op_assign
id|temp_p-&gt;next
suffix:semicolon
id|prev_p-&gt;next-&gt;next
op_assign
id|current_p
suffix:semicolon
)brace
r_else
(brace
id|vlb
op_assign
id|temp_p
suffix:semicolon
id|temp_p
op_assign
id|temp_p-&gt;next
suffix:semicolon
id|vlb-&gt;next
op_assign
id|current_p
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|AHC_BIOS_ENABLED
)paren
id|sort_list
(braket
l_int|0
)braket
op_assign
id|vlb
suffix:semicolon
r_else
id|sort_list
(braket
l_int|2
)braket
op_assign
id|vlb
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
(brace
)brace
multiline_comment|/* All PCI controllers fall through to default */
(brace
id|p
op_assign
id|temp_p
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|AHC_BIOS_ENABLED
)paren
id|pci
op_assign
id|sort_list
(braket
l_int|1
)braket
suffix:semicolon
r_else
id|pci
op_assign
id|sort_list
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pci
op_eq
l_int|NULL
)paren
(brace
id|pci
op_assign
id|temp_p
suffix:semicolon
id|temp_p
op_assign
id|temp_p-&gt;next
suffix:semicolon
id|pci-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|current_p
op_assign
id|pci
suffix:semicolon
id|prev_p
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aic7xxx_reverse_scan
)paren
(brace
r_while
c_loop
(paren
(paren
id|current_p
op_ne
l_int|NULL
)paren
op_logical_and
(paren
(paren
id|PCI_SLOT
c_func
(paren
id|current_p-&gt;pci_device_fn
)paren
op_or
(paren
id|current_p-&gt;pci_bus
op_lshift
l_int|8
)paren
)paren
OL
(paren
id|PCI_SLOT
c_func
(paren
id|temp_p-&gt;pci_device_fn
)paren
op_or
(paren
id|temp_p-&gt;pci_bus
op_lshift
l_int|8
)paren
)paren
)paren
)paren
(brace
id|prev_p
op_assign
id|current_p
suffix:semicolon
id|current_p
op_assign
id|current_p-&gt;next
suffix:semicolon
)brace
)brace
r_else
(brace
r_while
c_loop
(paren
(paren
id|current_p
op_ne
l_int|NULL
)paren
op_logical_and
(paren
(paren
id|PCI_SLOT
c_func
(paren
id|current_p-&gt;pci_device_fn
)paren
op_or
(paren
id|current_p-&gt;pci_bus
op_lshift
l_int|8
)paren
)paren
OG
(paren
id|PCI_SLOT
c_func
(paren
id|temp_p-&gt;pci_device_fn
)paren
op_or
(paren
id|temp_p-&gt;pci_bus
op_lshift
l_int|8
)paren
)paren
)paren
)paren
(brace
id|prev_p
op_assign
id|current_p
suffix:semicolon
id|current_p
op_assign
id|current_p-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;             * Are we dealing with a 7895/6/7/9 where we need to sort the&n;             * channels as well, if so, the bios_address values should&n;             * be the same&n;             */
r_if
c_cond
(paren
(paren
id|current_p
)paren
op_logical_and
(paren
id|temp_p-&gt;flags
op_amp
id|AHC_MULTI_CHANNEL
)paren
op_logical_and
(paren
id|temp_p-&gt;pci_bus
op_eq
id|current_p-&gt;pci_bus
)paren
op_logical_and
(paren
id|PCI_SLOT
c_func
(paren
id|temp_p-&gt;pci_device_fn
)paren
op_eq
id|PCI_SLOT
c_func
(paren
id|current_p-&gt;pci_device_fn
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|temp_p-&gt;flags
op_amp
id|AHC_CHNLB
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|temp_p-&gt;flags
op_amp
id|AHC_CHANNEL_B_PRIMARY
)paren
)paren
(brace
id|prev_p
op_assign
id|current_p
suffix:semicolon
id|current_p
op_assign
id|current_p-&gt;next
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|temp_p-&gt;flags
op_amp
id|AHC_CHANNEL_B_PRIMARY
)paren
(brace
id|prev_p
op_assign
id|current_p
suffix:semicolon
id|current_p
op_assign
id|current_p-&gt;next
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|prev_p
op_ne
l_int|NULL
)paren
(brace
id|prev_p-&gt;next
op_assign
id|temp_p
suffix:semicolon
id|temp_p
op_assign
id|temp_p-&gt;next
suffix:semicolon
id|prev_p-&gt;next-&gt;next
op_assign
id|current_p
suffix:semicolon
)brace
r_else
(brace
id|pci
op_assign
id|temp_p
suffix:semicolon
id|temp_p
op_assign
id|temp_p-&gt;next
suffix:semicolon
id|pci-&gt;next
op_assign
id|current_p
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|AHC_BIOS_ENABLED
)paren
id|sort_list
(braket
l_int|1
)braket
op_assign
id|pci
suffix:semicolon
r_else
id|sort_list
(braket
l_int|3
)braket
op_assign
id|pci
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* End of switch(temp_p-&gt;type) */
)brace
multiline_comment|/* End of while (temp_p != NULL) */
multiline_comment|/*&n;     * At this point, the cards have been broken into 4 sorted lists, now&n;     * we run through the lists in order and register each controller&n;     */
(brace
r_int
id|i
suffix:semicolon
id|left
op_assign
id|found
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMBER
c_func
(paren
id|sort_list
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|temp_p
op_assign
id|sort_list
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
id|temp_p
op_ne
l_int|NULL
)paren
(brace
r_template
op_member_access_from_pointer
id|name
op_assign
id|board_names
(braket
id|temp_p-&gt;board_name_index
)braket
suffix:semicolon
id|p
op_assign
id|aic7xxx_alloc
c_func
(paren
r_template
comma
id|temp_p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ne
l_int|NULL
)paren
(brace
id|p-&gt;instance
op_assign
id|found
op_minus
id|left
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_register
c_func
(paren
r_template
comma
id|p
comma
(paren
op_decrement
id|left
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|found
op_decrement
suffix:semicolon
id|aic7xxx_release
c_func
(paren
id|p-&gt;host
)paren
suffix:semicolon
id|scsi_unregister
c_func
(paren
id|p-&gt;host
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|aic7xxx_dump_card
)paren
(brace
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic7xxx_print_card
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic7xxx_print_scratch_ram
c_func
(paren
id|p
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
)brace
)brace
id|current_p
op_assign
id|temp_p
suffix:semicolon
id|temp_p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|temp_p-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|current_p
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
(paren
id|found
)paren
suffix:semicolon
)brace
r_static
r_void
id|aic7xxx_build_negotiation_cmnd
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
id|Scsi_Cmnd
op_star
id|old_cmd
comma
r_int
id|tindex
)paren
suffix:semicolon
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_allocate_negotiation_command&n; *&n; * Description:&n; *   allocate the actual command struct and fill in the gaps...&n; *-F*************************************************************************/
r_static
id|Scsi_Cmnd
op_star
DECL|function|aic7xxx_allocate_negotiation_command
id|aic7xxx_allocate_negotiation_command
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
id|Scsi_Cmnd
op_star
id|old_cmd
comma
r_int
id|tindex
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_char
op_star
id|buffer
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;dev_dtr_cmnd
(braket
id|tindex
)braket
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Cmnd
)paren
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|buffer
op_assign
id|kmalloc
c_func
(paren
l_int|256
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|kfree
c_func
(paren
id|p-&gt;dev_dtr_cmnd
(braket
id|tindex
)braket
)paren
suffix:semicolon
id|p-&gt;dev_dtr_cmnd
(braket
id|tindex
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|cmd
op_assign
id|p-&gt;dev_dtr_cmnd
(braket
id|tindex
)braket
suffix:semicolon
id|memset
c_func
(paren
id|cmd
comma
l_int|0
comma
r_sizeof
(paren
id|Scsi_Cmnd
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|cmd
comma
id|old_cmd
comma
r_sizeof
(paren
id|Scsi_Cmnd
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|cmd-&gt;cmnd
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|cmd-&gt;data_cmnd
(braket
l_int|0
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|cmd-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|cmd-&gt;lun
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;request_bufflen
op_assign
l_int|255
suffix:semicolon
id|cmd-&gt;request_buffer
op_assign
id|buffer
suffix:semicolon
id|cmd-&gt;sc_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|cmd-&gt;use_sg
op_assign
id|cmd-&gt;old_use_sg
op_assign
id|cmd-&gt;sglist_len
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;bufflen
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;cmd_len
op_assign
l_int|6
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|cmd-&gt;data_cmnd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|cmd-&gt;data_cmnd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|2
)braket
op_assign
id|cmd-&gt;data_cmnd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|3
)braket
op_assign
id|cmd-&gt;data_cmnd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
op_assign
id|cmd-&gt;data_cmnd
(braket
l_int|4
)braket
op_assign
l_int|255
suffix:semicolon
multiline_comment|/* match what scsi.c does here */
id|cmd-&gt;cmnd
(braket
l_int|5
)braket
op_assign
id|cmd-&gt;data_cmnd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|cmd
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_negotiation_complete&n; *&n; * Description:&n; *   Handle completion events for our Negotiation commands.  Clear out the&n; *   struct and get it ready for its next use.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_negotiation_complete
id|aic7xxx_negotiation_complete
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
r_int
id|checksum
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
op_star
id|ibuffer
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
r_int
id|tindex
op_assign
id|TARGET_INDEX
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_struct
id|aic7xxx_syncrate
op_star
id|syncrate
suffix:semicolon
multiline_comment|/*&n;   * perform our minimalistic domain validation&n;   */
r_if
c_cond
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
id|DEVICE_SCANNED
)paren
(brace
id|ibuffer
op_assign
(paren
r_int
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|cmd-&gt;request_bufflen
op_rshift
l_int|2
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|checksum
op_add_assign
id|ibuffer
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|checksum
op_ne
id|p-&gt;dev_checksum
(braket
id|tindex
)braket
)paren
op_logical_and
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|cur_offset
op_ne
l_int|0
)paren
)paren
(brace
r_int
r_int
id|period
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|cur_period
suffix:semicolon
r_int
r_char
id|options
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|cur_options
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;needdv
op_amp
(paren
l_int|1
op_lshift
id|tindex
)paren
)paren
(brace
multiline_comment|/*&n;         * oops, we had a failure, lower the transfer rate and try again.  It&squot;s&n;         * worth noting here that it might be wise to also check for typical&n;         * wide setting on narrow cable type problems and try disabling wide&n;         * instead of slowing down if those exist.  That&squot;s hard to do with simple&n;         * checksums though.&n;         */
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;reducing SCSI transfer speed due to Domain &quot;
l_string|&quot;validation failure.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|syncrate
op_assign
id|aic7xxx_find_syncrate
c_func
(paren
id|p
comma
op_amp
id|period
comma
l_int|0
comma
op_amp
id|options
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|syncrate
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|syncrate-&gt;rate
(braket
l_int|0
)braket
op_ne
l_int|NULL
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|p-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_logical_or
(paren
id|syncrate-&gt;sxfr_ultra2
op_eq
l_int|0
)paren
)paren
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_assign
id|syncrate-&gt;period
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
OG
l_int|9
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
op_assign
l_int|0
suffix:semicolon
id|p-&gt;needppr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needppr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr_copy
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
)paren
(brace
id|p-&gt;needwdtr
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needwdtr_copy
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
)paren
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
op_assign
l_int|0
suffix:semicolon
id|p-&gt;needwdtr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needwdtr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_offset
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_period
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
op_assign
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|user_options
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_le
l_int|9
)paren
(brace
id|p-&gt;needppr
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needppr_copy
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;needppr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needppr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr_copy
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_offset
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_period
op_assign
l_int|255
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_options
op_assign
l_int|0
suffix:semicolon
id|p-&gt;transinfo
(braket
id|tindex
)braket
dot
id|goal_width
op_assign
l_int|0
suffix:semicolon
id|p-&gt;needppr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needwdtr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needppr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needsdtr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
id|p-&gt;needwdtr_copy
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
)brace
)brace
id|p-&gt;needdv
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Performing Domain validation.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;         * Update the checksum in case the INQUIRY data has changed, maybe&n;         * in relation to a change in the mode pages, or whatever.&n;         */
id|p-&gt;dev_checksum
(braket
id|tindex
)braket
op_assign
id|checksum
suffix:semicolon
multiline_comment|/*&n;         * Signal that we are trying out the domain validation&n;         */
id|p-&gt;needdv
op_or_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
multiline_comment|/*&n;         * Signal that we need to re-negotiate things, this also gets us our&n;         * INQUIRY command to re-checksum off of.&n;         */
id|p-&gt;needppr
op_or_assign
(paren
id|p-&gt;needppr_copy
op_amp
(paren
l_int|1
op_lshift
id|tindex
)paren
)paren
suffix:semicolon
id|p-&gt;needsdtr
op_or_assign
(paren
id|p-&gt;needsdtr_copy
op_amp
(paren
l_int|1
op_lshift
id|tindex
)paren
)paren
suffix:semicolon
id|p-&gt;needwdtr
op_or_assign
(paren
id|p-&gt;needwdtr_copy
op_amp
(paren
l_int|1
op_lshift
id|tindex
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_NEGOTIATION2
)paren
op_logical_and
(paren
id|p-&gt;needdv
op_amp
(paren
l_int|1
op_lshift
id|tindex
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Successfully completed Domain validation.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;       * We successfully did our checksum, so don&squot;t leave the needdv flag set&n;       * in case we might have set it last time through.&n;       */
id|p-&gt;needdv
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
)brace
)brace
id|p-&gt;dtr_pending
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
id|tindex
)paren
suffix:semicolon
multiline_comment|/*&n;   * This looks recursive in the extreme, but if this was a WDTR negotiation&n;   * and we didn&squot;t follow up with SDTR yet, then this will get it started.&n;   * For all other cases, this should work out to be a no-op, unless we are&n;   * doing domain validation and happen to need a new negotiation command.&n;   *&n;   * In case we don&squot;t want this to go any further, the cmdcmplt interrupt&n;   * handler will NULL out the cmd-&gt;next entry so that the real SCSI command&n;   * can be sent back to the mid layer code with SENSE data intact.  We&squot;ll&n;   * finish things up when the cmd gets sent back down to us, so no worries.&n;   */
r_if
c_cond
(paren
id|cmd-&gt;next
)paren
(brace
id|aic7xxx_build_negotiation_cmnd
c_func
(paren
id|p
comma
id|cmd-&gt;next
comma
id|tindex
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_build_negotiation_command&n; *&n; * Description:&n; *   Build a Scsi_Cmnd structure to perform negotiation with or else send&n; *   a pre-built command specifically for this purpose.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_build_negotiation_cmnd
id|aic7xxx_build_negotiation_cmnd
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
id|Scsi_Cmnd
op_star
id|old_cmd
comma
r_int
id|tindex
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;dtr_pending
op_amp
(paren
l_int|1
op_lshift
id|tindex
)paren
)paren
op_logical_and
(paren
(paren
id|p-&gt;needppr
op_amp
(paren
l_int|1
op_lshift
id|tindex
)paren
)paren
op_logical_or
(paren
id|p-&gt;needwdtr
op_amp
(paren
l_int|1
op_lshift
id|tindex
)paren
)paren
op_logical_or
(paren
id|p-&gt;needsdtr
op_amp
(paren
l_int|1
op_lshift
id|tindex
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;dev_dtr_cmnd
(braket
id|tindex
)braket
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|aic7xxx_allocate_negotiation_command
c_func
(paren
id|p
comma
id|old_cmd
comma
id|tindex
)paren
op_eq
l_int|NULL
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;     * Before sending this thing out, we also make the cmd-&gt;next pointer&n;     * point to the real command so we can stuff any possible SENSE data&n;     * into the real command instead of this fake command.  This has to be&n;     * done each time the command is built, not just the first time, hence&n;     * it&squot;s outside of the above if()...&n;     */
id|p-&gt;dev_dtr_cmnd
(braket
id|tindex
)braket
op_member_access_from_pointer
id|next
op_assign
id|old_cmd
suffix:semicolon
multiline_comment|/*&n;     * Clear the buffer so checksums come out right....&n;     */
id|memset
c_func
(paren
id|p-&gt;dev_dtr_cmnd
(braket
id|tindex
)braket
op_member_access_from_pointer
id|request_buffer
comma
l_int|0
comma
id|p-&gt;dev_dtr_cmnd
(braket
id|tindex
)braket
op_member_access_from_pointer
id|request_bufflen
)paren
suffix:semicolon
multiline_comment|/*&n;     * Remove any commands for this particular device that might be on the&n;     * waiting_scbs queue or qinfifo so that this command goes out first.&n;     * This is vital for our implementation of domain validation.&n;     */
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic7xxx_search_qinfifo
c_func
(paren
id|p
comma
id|old_cmd-&gt;target
comma
id|old_cmd-&gt;channel
comma
id|ALL_LUNS
comma
id|SCB_LIST_NULL
comma
l_int|0
comma
id|TRUE
comma
op_amp
id|p-&gt;delayed_scbs
(braket
id|tindex
)braket
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
(brace
r_struct
id|aic7xxx_scb
op_star
id|scb
comma
op_star
id|next
suffix:semicolon
id|scb
op_assign
id|p-&gt;waiting_scbs.head
suffix:semicolon
r_while
c_loop
(paren
id|scb
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_match_scb
c_func
(paren
id|p
comma
id|scb
comma
id|old_cmd-&gt;target
comma
id|old_cmd-&gt;channel
comma
id|ALL_LUNS
comma
id|SCB_LIST_NULL
)paren
)paren
(brace
id|next
op_assign
id|scb-&gt;q_next
suffix:semicolon
id|scbq_remove
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|scb
)paren
suffix:semicolon
id|scbq_insert_tail
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|tindex
)braket
comma
id|scb
)paren
suffix:semicolon
id|scb
op_assign
id|next
suffix:semicolon
)brace
r_else
(brace
id|scb
op_assign
id|scb-&gt;q_next
suffix:semicolon
)brace
)brace
)brace
id|aic7xxx_queue
c_func
(paren
id|p-&gt;dev_dtr_cmnd
(braket
id|tindex
)braket
comma
id|aic7xxx_negotiation_complete
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_print_scb&n; *&n; * Description:&n; *   Dump the byte codes for an about to be sent SCB.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_print_scb
id|aic7xxx_print_scb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
op_star
id|x
suffix:semicolon
id|x
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|scb-&gt;hscb-&gt;control
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|x
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_buildscb&n; *&n; * Description:&n; *   Build a SCB.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_buildscb
id|aic7xxx_buildscb
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_struct
id|aic7xxx_scb
op_star
id|scb
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_struct
id|aic7xxx_hwscb
op_star
id|hscb
suffix:semicolon
r_int
r_char
id|tindex
op_assign
id|TARGET_INDEX
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|mask
op_assign
(paren
l_int|0x01
op_lshift
id|tindex
)paren
suffix:semicolon
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
multiline_comment|/*&n;   * Setup the control byte if we need negotiation and have not&n;   * already requested it.&n;   */
id|hscb-&gt;control
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;tag_action
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;tag
op_assign
id|hscb-&gt;tag
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;discenable
op_amp
id|mask
)paren
(brace
id|hscb-&gt;control
op_or_assign
id|DISCENB
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;tagenable
op_amp
id|mask
)paren
op_logical_and
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|TEST_UNIT_READY
)paren
)paren
(brace
id|p-&gt;dev_commands_sent
(braket
id|tindex
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;dev_commands_sent
(braket
id|tindex
)braket
OL
l_int|200
)paren
(brace
id|hscb-&gt;control
op_or_assign
id|MSG_SIMPLE_Q_TAG
suffix:semicolon
id|scb-&gt;tag_action
op_assign
id|MSG_SIMPLE_Q_TAG
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|p-&gt;orderedtag
op_amp
id|mask
)paren
(brace
id|hscb-&gt;control
op_or_assign
id|MSG_ORDERED_Q_TAG
suffix:semicolon
id|scb-&gt;tag_action
op_assign
id|MSG_ORDERED_Q_TAG
suffix:semicolon
)brace
r_else
(brace
id|hscb-&gt;control
op_or_assign
id|MSG_SIMPLE_Q_TAG
suffix:semicolon
id|scb-&gt;tag_action
op_assign
id|MSG_SIMPLE_Q_TAG
suffix:semicolon
)brace
id|p-&gt;dev_commands_sent
(braket
id|tindex
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|p-&gt;dev_dtr_cmnd
(braket
id|tindex
)braket
)paren
(brace
id|p-&gt;dtr_pending
op_or_assign
id|mask
suffix:semicolon
id|scb-&gt;tag_action
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
id|DEVICE_SCANNED
)paren
(brace
id|hscb-&gt;control
op_and_assign
id|DISCENB
suffix:semicolon
id|hscb-&gt;control
op_or_assign
id|MK_MESSAGE
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;needppr
op_amp
id|mask
)paren
(brace
id|scb-&gt;flags
op_or_assign
id|SCB_MSGOUT_PPR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;needwdtr
op_amp
id|mask
)paren
(brace
id|scb-&gt;flags
op_or_assign
id|SCB_MSGOUT_WDTR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;needsdtr
op_amp
id|mask
)paren
(brace
id|scb-&gt;flags
op_or_assign
id|SCB_MSGOUT_SDTR
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;dtr_pending
op_amp
id|mask
)paren
op_logical_and
(paren
(paren
id|p-&gt;needppr
op_amp
id|mask
)paren
op_logical_or
(paren
id|p-&gt;needwdtr
op_amp
id|mask
)paren
op_logical_or
(paren
id|p-&gt;needsdtr
op_amp
id|mask
)paren
)paren
)paren
(brace
id|aic7xxx_build_negotiation_cmnd
c_func
(paren
id|p
comma
id|cmd
comma
id|tindex
)paren
suffix:semicolon
)brace
id|hscb-&gt;target_channel_lun
op_assign
(paren
(paren
id|cmd-&gt;target
op_lshift
l_int|4
)paren
op_amp
l_int|0xF0
)paren
op_or
(paren
(paren
id|cmd-&gt;channel
op_amp
l_int|0x01
)paren
op_lshift
l_int|3
)paren
op_or
(paren
id|cmd-&gt;lun
op_amp
l_int|0x07
)paren
suffix:semicolon
multiline_comment|/*&n;   * The interpretation of request_buffer and request_bufflen&n;   * changes depending on whether or not use_sg is zero; a&n;   * non-zero use_sg indicates the number of elements in the&n;   * scatter-gather array.&n;   */
multiline_comment|/*&n;   * XXX - this relies on the host data being stored in a&n;   *       little-endian format.&n;   */
id|hscb-&gt;SCSI_cmd_length
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|memcpy
c_func
(paren
id|scb-&gt;cmnd
comma
id|cmd-&gt;cmnd
comma
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
id|hscb-&gt;SCSI_cmd_pointer
op_assign
id|cpu_to_le32
c_func
(paren
id|SCB_DMA_ADDR
c_func
(paren
id|scb
comma
id|scb-&gt;cmnd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
multiline_comment|/* Must be mid-level SCSI code scatterlist */
multiline_comment|/*&n;     * We must build an SG list in adapter format, as the kernel&squot;s SG list&n;     * cannot be used directly because of data field size (__alpha__)&n;     * differences and the kernel SG list uses virtual addresses where&n;     * we need physical addresses.&n;     */
r_int
id|i
comma
id|use_sg
suffix:semicolon
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|scb-&gt;sg_length
op_assign
l_int|0
suffix:semicolon
id|use_sg
op_assign
id|pci_map_sg
c_func
(paren
id|p-&gt;pdev
comma
id|sg
comma
id|cmd-&gt;use_sg
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * Copy the segments into the SG array.  NOTE!!! - We used to&n;     * have the first entry both in the data_pointer area and the first&n;     * SG element.  That has changed somewhat.  We still have the first&n;     * entry in both places, but now we download the address of&n;     * scb-&gt;sg_list[1] instead of 0 to the sg pointer in the hscb.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|len
op_assign
id|sg_dma_len
c_func
(paren
id|sg
op_plus
id|i
)paren
suffix:semicolon
id|scb-&gt;sg_list
(braket
id|i
)braket
dot
id|address
op_assign
id|cpu_to_le32
c_func
(paren
id|sg_dma_address
c_func
(paren
id|sg
op_plus
id|i
)paren
)paren
suffix:semicolon
id|scb-&gt;sg_list
(braket
id|i
)braket
dot
id|length
op_assign
id|cpu_to_le32
c_func
(paren
id|len
)paren
suffix:semicolon
id|scb-&gt;sg_length
op_add_assign
id|len
suffix:semicolon
)brace
multiline_comment|/* Copy the first SG into the data pointer area. */
id|hscb-&gt;data_pointer
op_assign
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
id|hscb-&gt;data_count
op_assign
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|length
suffix:semicolon
id|scb-&gt;sg_count
op_assign
id|i
suffix:semicolon
id|hscb-&gt;SG_segment_count
op_assign
id|i
suffix:semicolon
id|hscb-&gt;SG_list_pointer
op_assign
id|cpu_to_le32
c_func
(paren
id|SCB_DMA_ADDR
c_func
(paren
id|scb
comma
op_amp
id|scb-&gt;sg_list
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
)paren
(brace
r_int
r_int
id|address
op_assign
id|pci_map_single
c_func
(paren
id|p-&gt;pdev
comma
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;request_bufflen
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
id|aic7xxx_mapping
c_func
(paren
id|cmd
)paren
op_assign
id|address
suffix:semicolon
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|address
op_assign
id|cpu_to_le32
c_func
(paren
id|address
)paren
suffix:semicolon
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|length
op_assign
id|cpu_to_le32
c_func
(paren
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
id|scb-&gt;sg_count
op_assign
l_int|1
suffix:semicolon
id|scb-&gt;sg_length
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|hscb-&gt;SG_segment_count
op_assign
l_int|1
suffix:semicolon
id|hscb-&gt;SG_list_pointer
op_assign
id|cpu_to_le32
c_func
(paren
id|SCB_DMA_ADDR
c_func
(paren
id|scb
comma
op_amp
id|scb-&gt;sg_list
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|hscb-&gt;data_count
op_assign
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|length
suffix:semicolon
id|hscb-&gt;data_pointer
op_assign
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
)brace
r_else
(brace
id|scb-&gt;sg_count
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;sg_length
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;SG_segment_count
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;SG_list_pointer
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;data_count
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;data_pointer
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_queue&n; *&n; * Description:&n; *   Queue a SCB to the controller.&n; *-F*************************************************************************/
r_int
DECL|function|aic7xxx_queue
id|aic7xxx_queue
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|fn
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
r_struct
id|aic7xxx_scb
op_star
id|scb
suffix:semicolon
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_int
id|tindex
op_assign
id|TARGET_INDEX
c_func
(paren
id|cmd
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,1,95)
r_int
r_int
id|cpu_flags
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
multiline_comment|/*&n;   * Check to see if channel was scanned.&n;   */
macro_line|#ifdef AIC7XXX_VERBOSE_DEBUGGING
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|AHC_A_SCANNED
)paren
op_logical_and
(paren
id|cmd-&gt;channel
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Scanning channel for devices.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|AHC_A_SCANNED
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|AHC_B_SCANNED
)paren
op_logical_and
(paren
id|cmd-&gt;channel
op_eq
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_PROBE2
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Scanning channel for devices.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|AHC_B_SCANNED
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
OG
(paren
id|cmd-&gt;device-&gt;queue_depth
op_plus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Commands queued exceeds queue &quot;
l_string|&quot;depth, active=%d&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
comma
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
OG
l_int|220
)paren
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|scb
op_assign
id|scbq_remove_head
c_func
(paren
op_amp
id|p-&gt;scb_data-&gt;free_scbs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|DRIVER_LOCK
id|aic7xxx_allocate_scb
c_func
(paren
id|p
)paren
suffix:semicolon
id|DRIVER_UNLOCK
id|scb
op_assign
id|scbq_remove_head
c_func
(paren
op_amp
id|p-&gt;scb_data-&gt;free_scbs
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Couldn&squot;t get a free SCB.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_BUS_BUSY
op_lshift
l_int|16
)paren
suffix:semicolon
id|DRIVER_LOCK
id|aic7xxx_queue_cmd_complete
c_func
(paren
id|p
comma
id|cmd
)paren
suffix:semicolon
id|DRIVER_UNLOCK
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|scb-&gt;cmd
op_assign
id|cmd
suffix:semicolon
id|aic7xxx_position
c_func
(paren
id|cmd
)paren
op_assign
id|scb-&gt;hscb-&gt;tag
suffix:semicolon
multiline_comment|/*&n;     * Construct the SCB beforehand, so the sequencer is&n;     * paused a minimal amount of time.&n;     */
id|aic7xxx_buildscb
c_func
(paren
id|p
comma
id|cmd
comma
id|scb
)paren
suffix:semicolon
multiline_comment|/*&n;     * Make sure the Scsi_Cmnd pointer is saved, the struct it points to&n;     * is set up properly, and the parity error flag is reset, then send&n;     * the SCB to the sequencer and watch the fun begin.&n;     */
id|cmd-&gt;scsi_done
op_assign
id|fn
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_OK
suffix:semicolon
id|memset
c_func
(paren
id|cmd-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|aic7xxx_error
c_func
(paren
id|cmd
)paren
op_assign
id|DID_OK
suffix:semicolon
id|aic7xxx_status
c_func
(paren
id|cmd
)paren
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_ACTIVE
op_or
id|SCB_WAITINGQ
suffix:semicolon
id|DRIVER_LOCK
id|scbq_insert_tail
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
(paren
id|AHC_IN_ISR
op_or
id|AHC_IN_ABORT
op_or
id|AHC_IN_RESET
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|aic7xxx_run_waiting_queues
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|DRIVER_UNLOCK
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_bus_device_reset&n; *&n; * Description:&n; *   Abort or reset the current SCSI command(s).  If the scb has not&n; *   previously been aborted, then we attempt to send a BUS_DEVICE_RESET&n; *   message to the target.  If the scb has previously been unsuccessfully&n; *   aborted, then we will reset the channel and have all devices renegotiate.&n; *   Returns an enumerated type that indicates the status of the operation.&n; *-F*************************************************************************/
r_static
r_int
DECL|function|aic7xxx_bus_device_reset
id|aic7xxx_bus_device_reset
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scb
suffix:semicolon
r_struct
id|aic7xxx_hwscb
op_star
id|hscb
suffix:semicolon
r_int
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_int
r_char
id|saved_scbptr
comma
id|lastphase
suffix:semicolon
r_int
r_char
id|hscb_index
suffix:semicolon
r_int
id|disconnected
suffix:semicolon
id|scb
op_assign
(paren
id|p-&gt;scb_data-&gt;scb_array
(braket
id|aic7xxx_position
c_func
(paren
id|cmd
)paren
)braket
)paren
suffix:semicolon
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
id|lastphase
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|LASTPHASE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_PROCESS
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Bus Device reset, scb flags 0x%x, &quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|lastphase
)paren
(brace
r_case
id|P_DATAOUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Data-Out phase&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_DATAIN
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Data-In phase&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_COMMAND
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Command phase&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_MESGOUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Message-Out phase&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_STATUS
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Status phase&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_MESGIN
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Message-In phase&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;       * We&squot;re not in a valid phase, so assume we&squot;re idle.&n;       */
id|printk
c_func
(paren
l_string|&quot;while idle, LASTPHASE = 0x%x&bslash;n&quot;
comma
id|lastphase
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;SCSISIGI 0x%x, SEQADDR 0x%x, SSTAT0 0x%x, SSTAT1 &quot;
l_string|&quot;0x%x&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISIGI
)paren
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SEQADDR0
)paren
op_or
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SEQADDR1
)paren
op_lshift
l_int|8
)paren
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SSTAT0
)paren
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SSTAT1
)paren
)paren
suffix:semicolon
)brace
id|channel
op_assign
id|cmd-&gt;channel
suffix:semicolon
multiline_comment|/*&n;     * Send a Device Reset Message:&n;     * The target that is holding up the bus may not be the same as&n;     * the one that triggered this timeout (different commands have&n;     * different timeout lengths).  Our strategy here is to queue an&n;     * abort message to the timed out target if it is disconnected.&n;     * Otherwise, if we have an active target we stuff the message buffer&n;     * with an abort message and assert ATN in the hopes that the target&n;     * will let go of the bus and go to the mesgout phase.  If this&n;     * fails, we&squot;ll get another timeout a few seconds later which will&n;     * attempt a bus reset.&n;     */
id|saved_scbptr
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCBPTR
)paren
suffix:semicolon
id|disconnected
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|lastphase
op_ne
id|P_BUSFREE
)paren
(brace
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
op_ge
id|p-&gt;scb_data-&gt;numscbs
)paren
(brace
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Invalid SCB ID %d is active, &quot;
l_string|&quot;SCB flags = 0x%x.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
comma
id|scb-&gt;hscb-&gt;tag
comma
id|scb-&gt;flags
)paren
suffix:semicolon
r_return
id|SCSI_RESET_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb-&gt;hscb-&gt;tag
op_eq
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|lastphase
op_ne
id|P_MESGOUT
)paren
op_logical_and
(paren
id|lastphase
op_ne
id|P_MESGIN
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Device reset message in &quot;
l_string|&quot;message buffer&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_RESET
op_or
id|SCB_DEVICE_RESET
suffix:semicolon
id|aic7xxx_error
c_func
(paren
id|scb-&gt;cmd
)paren
op_assign
id|DID_RESET
suffix:semicolon
id|p-&gt;dev_flags
(braket
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
)braket
op_or_assign
id|BUS_DEVICE_RESET_PENDING
suffix:semicolon
multiline_comment|/* Send the abort message to the active SCB. */
id|aic_outb
c_func
(paren
id|p
comma
id|HOST_MSG
comma
id|MSG_OUT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|lastphase
op_or
id|ATNO
comma
id|SCSISIGO
)paren
suffix:semicolon
r_return
id|SCSI_RESET_PENDING
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We want to send out the message, but it could screw an already */
multiline_comment|/* in place and being used message.  Instead, we return an error  */
multiline_comment|/* to try and start the bus reset phase since this command is     */
multiline_comment|/* probably hung (aborts failed, and now reset is failing).  We   */
multiline_comment|/* also make sure to set BUS_DEVICE_RESET_PENDING so we won&squot;t try */
multiline_comment|/* any more on this device, but instead will escalate to a bus or */
multiline_comment|/* host reset (additionally, we won&squot;t try to abort any more).     */
id|printk
c_func
(paren
id|WARN_LEAD
l_string|&quot;Device reset, Message buffer &quot;
l_string|&quot;in use&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_RESET
op_or
id|SCB_DEVICE_RESET
suffix:semicolon
id|aic7xxx_error
c_func
(paren
id|scb-&gt;cmd
)paren
op_assign
id|DID_RESET
suffix:semicolon
id|p-&gt;dev_flags
(braket
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
)braket
op_or_assign
id|BUS_DEVICE_RESET_PENDING
suffix:semicolon
r_return
id|SCSI_RESET_ERROR
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* if (last_phase != P_BUSFREE).....indicates we are idle and can work */
id|hscb_index
op_assign
id|aic7xxx_find_scb
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hscb_index
op_eq
id|SCB_LIST_NULL
)paren
(brace
id|disconnected
op_assign
(paren
id|aic7xxx_scb_on_qoutfifo
c_func
(paren
id|p
comma
id|scb
)paren
)paren
ques
c_cond
id|FALSE
suffix:colon
id|TRUE
suffix:semicolon
)brace
r_else
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|hscb_index
comma
id|SCBPTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_CONTROL
)paren
op_amp
id|DISCONNECTED
)paren
(brace
id|disconnected
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|disconnected
)paren
(brace
multiline_comment|/*&n;         * Simply set the MK_MESSAGE flag and the SEQINT handler will do&n;         * the rest on a reconnect.&n;         */
id|scb-&gt;hscb-&gt;control
op_or_assign
id|MK_MESSAGE
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_RESET
op_or
id|SCB_DEVICE_RESET
suffix:semicolon
id|p-&gt;dev_flags
(braket
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
)braket
op_or_assign
id|BUS_DEVICE_RESET_PENDING
suffix:semicolon
r_if
c_cond
(paren
id|hscb_index
op_ne
id|SCB_LIST_NULL
)paren
(brace
r_int
r_char
id|scb_control
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|hscb_index
comma
id|SCBPTR
)paren
suffix:semicolon
id|scb_control
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_CONTROL
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|scb_control
op_or
id|MK_MESSAGE
comma
id|SCB_CONTROL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;         * Actually requeue this SCB in case we can select the&n;         * device before it reconnects.  If the transaction we&n;         * want to abort is not tagged, then this will be the only&n;         * outstanding command and we can simply shove it on the&n;         * qoutfifo and be done.  If it is tagged, then it goes right&n;         * in with all the others, no problem :)  We need to add it&n;         * to the qinfifo and let the sequencer know it is there.&n;         * Now, the only problem left to deal with is, *IF* this&n;         * command completes, in spite of the MK_MESSAGE bit in the&n;         * control byte, then we need to pick that up in the interrupt&n;         * routine and clean things up.  This *shouldn&squot;t* ever happen.&n;         */
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Queueing device reset &quot;
l_string|&quot;command.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|p-&gt;qinfifo
(braket
id|p-&gt;qinfifonext
op_increment
)braket
op_assign
id|scb-&gt;hscb-&gt;tag
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_QUEUE_REGS
)paren
id|aic_outb
c_func
(paren
id|p
comma
id|p-&gt;qinfifonext
comma
id|HNSCB_QOFF
)paren
suffix:semicolon
r_else
id|aic_outb
c_func
(paren
id|p
comma
id|p-&gt;qinfifonext
comma
id|KERNEL_QINPOS
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_QUEUED_ABORT
suffix:semicolon
id|result
op_assign
id|SCSI_RESET_PENDING
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
op_eq
op_minus
l_int|1
)paren
(brace
id|result
op_assign
id|SCSI_RESET_ERROR
suffix:semicolon
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|saved_scbptr
comma
id|SCBPTR
)paren
suffix:semicolon
r_return
(paren
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_panic_abort&n; *&n; * Description:&n; *   Abort the current SCSI command(s).&n; *-F*************************************************************************/
r_void
DECL|function|aic7xxx_panic_abort
id|aic7xxx_panic_abort
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aic7xxx driver version %s/%s&bslash;n&quot;
comma
id|AIC7XXX_C_VERSION
comma
id|UTS_RELEASE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Controller type:&bslash;n    %s&bslash;n&quot;
comma
id|board_names
(braket
id|p-&gt;board_name_index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;p-&gt;flags=0x%x, p-&gt;chip=0x%x, p-&gt;features=0x%x, &quot;
l_string|&quot;sequencer %s paused&bslash;n&quot;
comma
id|p-&gt;flags
comma
id|p-&gt;chip
comma
id|p-&gt;features
comma
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|HCNTRL
)paren
op_amp
id|PAUSE
)paren
ques
c_cond
l_string|&quot;is&quot;
suffix:colon
l_string|&quot;isn&squot;t&quot;
)paren
suffix:semicolon
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
id|disable_irq
c_func
(paren
id|p-&gt;irq
)paren
suffix:semicolon
id|aic7xxx_print_card
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic7xxx_print_scratch_ram
c_func
(paren
id|p
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_abort&n; *&n; * Description:&n; *   Abort the current SCSI command(s).&n; *-F*************************************************************************/
r_int
DECL|function|aic7xxx_abort
id|aic7xxx_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scb
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
r_int
id|result
comma
id|found
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|tmp_char
comma
id|saved_hscbptr
comma
id|next_hscbptr
comma
id|prev_hscbptr
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,1,95)
r_int
r_int
id|cpu_flags
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|Scsi_Cmnd
op_star
id|cmd_next
comma
op_star
id|cmd_prev
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|scb
op_assign
(paren
id|p-&gt;scb_data-&gt;scb_array
(braket
id|aic7xxx_position
c_func
(paren
id|cmd
)paren
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;   * I added a new config option to the driver: &quot;panic_on_abort&quot; that will&n;   * cause the driver to panic and the machine to stop on the first abort&n;   * or reset call into the driver.  At that point, it prints out a lot of&n;   * usefull information for me which I can then use to try and debug the&n;   * problem.  Simply enable the boot time prompt in order to activate this&n;   * code.&n;   */
r_if
c_cond
(paren
id|aic7xxx_panic_on_abort
)paren
id|aic7xxx_panic_abort
c_func
(paren
id|p
comma
id|cmd
)paren
suffix:semicolon
id|DRIVER_LOCK
multiline_comment|/*&n; *  Run the isr to grab any command in the QOUTFIFO and any other misc.&n; *  assundry tasks.  This should also set up the bh handler if there is&n; *  anything to be done, but it won&squot;t run until we are done here since&n; *  we are following a straight code path without entering the scheduler&n; *  code.&n; */
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|INTSTAT
)paren
op_amp
id|INT_PEND
)paren
op_logical_and
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|AHC_IN_ISR
)paren
)paren
(brace
id|aic7xxx_isr
c_func
(paren
id|p-&gt;irq
comma
id|p
comma
(paren
r_void
op_star
)paren
l_int|NULL
)paren
suffix:semicolon
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic7xxx_done_cmds_complete
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|scb
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|cmd-&gt;serial_number
op_ne
id|cmd-&gt;serial_number_at_timeout
)paren
)paren
multiline_comment|/*  Totally bogus cmd since it points beyond our  */
(brace
multiline_comment|/*  valid SCB range or doesn&squot;t even match it&squot;s own*/
multiline_comment|/*  timeout serial number.                        */
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_ABORT_MID
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Abort called with bogus Scsi_Cmnd &quot;
l_string|&quot;pointer.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
id|DRIVER_UNLOCK
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb-&gt;cmd
op_ne
id|cmd
)paren
multiline_comment|/*  Hmmm...either this SCB is currently free with a */
(brace
multiline_comment|/*  NULL cmd pointer (NULLed out when freed) or it  */
multiline_comment|/*  has already been recycled for another command   */
multiline_comment|/*  Either way, this SCB has nothing to do with this*/
multiline_comment|/*  command and we need to deal with cmd without    */
multiline_comment|/*  touching the SCB.                               */
multiline_comment|/*  The theory here is to return a value that will  */
multiline_comment|/*  make the queued for complete command actually   */
multiline_comment|/*  finish successfully, or to indicate that we     */
multiline_comment|/*  don&squot;t have this cmd any more and the mid level  */
multiline_comment|/*  code needs to find it.                          */
id|cmd_next
op_assign
id|p-&gt;completeq.head
suffix:semicolon
id|cmd_prev
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|cmd_next
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|cmd_next
op_eq
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_ABORT_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Abort called for command &quot;
l_string|&quot;on completeq, completing.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd_prev
op_eq
l_int|NULL
)paren
id|p-&gt;completeq.head
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd_next-&gt;host_scribble
suffix:semicolon
r_else
id|cmd_prev-&gt;host_scribble
op_assign
id|cmd_next-&gt;host_scribble
suffix:semicolon
id|cmd_next
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd_next
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
id|DRIVER_UNLOCK
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
multiline_comment|/* It&squot;s already back as a successful&n;                                         * completion */
)brace
id|cmd_prev
op_assign
id|cmd_next
suffix:semicolon
id|cmd_next
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd_next-&gt;host_scribble
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_ABORT_MID
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Abort called for already completed&quot;
l_string|&quot; command.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
id|DRIVER_UNLOCK
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
multiline_comment|/*   At this point we know the following:&n; *     the SCB pointer is valid&n; *     the command pointer passed in to us and the scb-&gt;cmd pointer match&n; *     this then means that the command we need to abort is the same as the&n; *     command held by the scb pointer and is a valid abort request.&n; *   Now, we just have to figure out what to do from here.  Current plan is:&n; *     if we have already been here on this command, escalate to a reset&n; *     if scb is on waiting list or QINFIFO, send it back as aborted, but&n; *       we also need to be aware of the possibility that we could be using&n; *       a faked negotiation command that is holding this command up,  if&n; *       so we need to take care of that command instead, which means we&n; *       would then treat this one like it was sitting around disconnected&n; *       instead.&n; *     if scb is on WAITING_SCB list in sequencer, free scb and send back&n; *     if scb is disconnected and not completed, abort with abort message&n; *     if scb is currently running, then it may be causing the bus to hang&n; *       so we want a return value that indicates a reset would be appropriate&n; *       if the command does not finish shortly&n; *     if scb is already complete but not on completeq, we&squot;re screwed because&n; *       this can&squot;t happen (except if the command is in the QOUTFIFO, in which&n; *       case we would like it to complete successfully instead of having to&n; *       to be re-done)&n; *   All other scenarios already dealt with by previous code.&n; */
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
(paren
id|SCB_ABORT
op_or
id|SCB_RESET
op_or
id|SCB_QUEUED_ABORT
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_ABORT_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;SCB aborted once already, &quot;
l_string|&quot;escalating.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
id|DRIVER_UNLOCK
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
(paren
id|AHC_RESET_PENDING
op_or
id|AHC_ABORT_PENDING
)paren
)paren
op_logical_or
(paren
id|p-&gt;dev_flags
(braket
id|TARGET_INDEX
c_func
(paren
id|scb-&gt;cmd
)paren
)braket
op_amp
id|BUS_DEVICE_RESET_PENDING
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_ABORT_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Reset/Abort pending for this &quot;
l_string|&quot;device, not wasting our time.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
id|DRIVER_UNLOCK
r_return
id|SCSI_ABORT_PENDING
suffix:semicolon
)brace
id|found
op_assign
l_int|0
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|AHC_IN_ABORT
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_ABORT
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Aborting scb %d, flags 0x%x&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;hscb-&gt;tag
comma
id|scb-&gt;flags
)paren
suffix:semicolon
multiline_comment|/*&n; *   First, let&squot;s check to see if the currently running command is our target&n; *    since if it is, the return is fairly easy and quick since we don&squot;t want&n; *    to touch the command in case it might complete, but we do want a timeout&n; *    in case it&squot;s actually hung, so we really do nothing, but tell the mid&n; *    level code to reset the timeout.&n; */
r_if
c_cond
(paren
id|scb-&gt;hscb-&gt;tag
op_eq
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
)paren
(brace
multiline_comment|/*&n;    *  Check to see if the sequencer is just sitting on this command, or&n;    *   if it&squot;s actively being run.&n;    */
id|result
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|LASTPHASE
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|result
)paren
(brace
r_case
id|P_DATAOUT
suffix:colon
multiline_comment|/*    For any of these cases, we can assume we are */
r_case
id|P_DATAIN
suffix:colon
multiline_comment|/*    an active command and act according.  For    */
r_case
id|P_COMMAND
suffix:colon
multiline_comment|/*    anything else we are going to fall on through*/
r_case
id|P_STATUS
suffix:colon
multiline_comment|/*    The SCSI_ABORT_SNOOZE will give us two abort */
r_case
id|P_MESGOUT
suffix:colon
multiline_comment|/*    chances to finish and then escalate to a     */
r_case
id|P_MESGIN
suffix:colon
multiline_comment|/*    reset call                                   */
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_ABORT_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;SCB is currently active.  &quot;
l_string|&quot;Waiting on completion.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
id|p-&gt;flags
op_and_assign
op_complement
id|AHC_IN_ABORT
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_RECOVERY_SCB
suffix:semicolon
multiline_comment|/*  Note the fact that we&squot;ve been  */
id|p-&gt;flags
op_or_assign
id|AHC_ABORT_PENDING
suffix:semicolon
multiline_comment|/*  here so we will know not to    */
id|DRIVER_UNLOCK
multiline_comment|/*  muck with other SCBs if this   */
r_return
id|SCSI_ABORT_PENDING
suffix:semicolon
multiline_comment|/*  one doesn&squot;t complete and clear */
r_break
suffix:semicolon
multiline_comment|/*  out.                           */
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|found
op_eq
l_int|0
)paren
op_logical_and
(paren
id|scb-&gt;flags
op_amp
id|SCB_WAITINGQ
)paren
)paren
(brace
r_int
id|tindex
op_assign
id|TARGET_INDEX
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
id|mask
op_assign
(paren
l_int|1
op_lshift
id|tindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;dtr_pending
op_amp
id|mask
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;dev_dtr_cmnd
(braket
id|tindex
)braket
op_member_access_from_pointer
id|next
op_ne
id|cmd
)paren
id|found
op_assign
l_int|1
suffix:semicolon
r_else
id|found
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|found
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;       * OK..this means the command we are currently getting an abort&n;       * for has an outstanding negotiation command in front of it.&n;       * We don&squot;t really have a way to tie back into the negotiation&n;       * commands, so we just send this back as pending, then it&n;       * will get reset in 2 seconds.&n;       */
id|unpause_sequencer
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_ABORT
suffix:semicolon
id|DRIVER_UNLOCK
r_return
id|SCSI_ABORT_PENDING
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_ABORT_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;SCB found on waiting list and &quot;
l_string|&quot;aborted.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|scbq_remove
c_func
(paren
op_amp
id|p-&gt;waiting_scbs
comma
id|scb
)paren
suffix:semicolon
id|scbq_remove
c_func
(paren
op_amp
id|p-&gt;delayed_scbs
(braket
id|tindex
)braket
comma
id|scb
)paren
suffix:semicolon
id|p-&gt;dev_active_cmds
(braket
id|tindex
)braket
op_increment
suffix:semicolon
id|p-&gt;activescbs
op_increment
suffix:semicolon
id|scb-&gt;flags
op_and_assign
op_complement
(paren
id|SCB_WAITINGQ
op_or
id|SCB_ACTIVE
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_ABORT
op_or
id|SCB_QUEUED_FOR_DONE
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *  We just checked the waiting_q, now for the QINFIFO&n; */
r_if
c_cond
(paren
id|found
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|found
op_assign
id|aic7xxx_search_qinfifo
c_func
(paren
id|p
comma
id|cmd-&gt;target
comma
id|cmd-&gt;channel
comma
id|cmd-&gt;lun
comma
id|scb-&gt;hscb-&gt;tag
comma
id|SCB_ABORT
op_or
id|SCB_QUEUED_FOR_DONE
comma
id|FALSE
comma
l_int|NULL
)paren
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_ABORT_PROCESS
)paren
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;SCB found in QINFIFO and &quot;
l_string|&quot;aborted.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  QINFIFO, waitingq, completeq done.  Next, check WAITING_SCB list in card&n; */
r_if
c_cond
(paren
id|found
op_eq
l_int|0
)paren
(brace
r_int
r_char
id|scb_next_ptr
suffix:semicolon
id|prev_hscbptr
op_assign
id|SCB_LIST_NULL
suffix:semicolon
id|saved_hscbptr
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCBPTR
)paren
suffix:semicolon
id|next_hscbptr
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|WAITING_SCBH
)paren
suffix:semicolon
r_while
c_loop
(paren
id|next_hscbptr
op_ne
id|SCB_LIST_NULL
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|next_hscbptr
comma
id|SCBPTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;hscb-&gt;tag
op_eq
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_TAG
)paren
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_ABORT_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;SCB found on hardware waiting&quot;
l_string|&quot; list and aborted.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev_hscbptr
op_eq
id|SCB_LIST_NULL
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_NEXT
)paren
comma
id|WAITING_SCBH
)paren
suffix:semicolon
multiline_comment|/* stop the selection since we just&n;             * grabbed the scb out from under the&n;             * card&n;             */
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SCSISEQ
)paren
op_amp
op_complement
id|ENSELO
comma
id|SCSISEQ
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|CLRSELTIMEO
comma
id|CLRSINT1
)paren
suffix:semicolon
)brace
r_else
(brace
id|scb_next_ptr
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_NEXT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|prev_hscbptr
comma
id|SCBPTR
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|scb_next_ptr
comma
id|SCB_NEXT
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|next_hscbptr
comma
id|SCBPTR
)paren
suffix:semicolon
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|SCB_LIST_NULL
comma
id|SCB_TAG
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SCB_CONTROL
)paren
suffix:semicolon
id|aic7xxx_add_curscb_to_free_list
c_func
(paren
id|p
)paren
suffix:semicolon
id|scb-&gt;flags
op_assign
id|SCB_ABORT
op_or
id|SCB_QUEUED_FOR_DONE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|prev_hscbptr
op_assign
id|next_hscbptr
suffix:semicolon
id|next_hscbptr
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_NEXT
)paren
suffix:semicolon
)brace
id|aic_outb
c_func
(paren
id|p
comma
id|saved_hscbptr
comma
id|SCBPTR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Hmmm...completeq, QOUTFIFO, QINFIFO, WAITING_SCBH, waitingq all checked.&n; *  OK...the sequencer&squot;s paused, interrupts are off, and we haven&squot;t found the&n; *  command anyplace where it could be easily aborted.  Time for the hard&n; *  work.  We also know the command is valid.  This essentially means the&n; *  command is disconnected, or connected but not into any phases yet, which&n; *  we know due to the tests we ran earlier on the current active scb phase.&n; *  At this point we can queue the abort tag and go on with life.&n; */
r_if
c_cond
(paren
id|found
op_eq
l_int|0
)paren
(brace
id|p-&gt;flags
op_or_assign
id|AHC_ABORT_PENDING
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_QUEUED_ABORT
op_or
id|SCB_ABORT
op_or
id|SCB_RECOVERY_SCB
suffix:semicolon
id|scb-&gt;hscb-&gt;control
op_or_assign
id|MK_MESSAGE
suffix:semicolon
id|result
op_assign
id|aic7xxx_find_scb
c_func
(paren
id|p
comma
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|SCB_LIST_NULL
)paren
(brace
id|saved_hscbptr
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCBPTR
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|result
comma
id|SCBPTR
)paren
suffix:semicolon
id|tmp_char
op_assign
id|aic_inb
c_func
(paren
id|p
comma
id|SCB_CONTROL
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|tmp_char
op_or
id|MK_MESSAGE
comma
id|SCB_CONTROL
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|saved_hscbptr
comma
id|SCBPTR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_ABORT_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;SCB disconnected.  Queueing Abort&quot;
l_string|&quot; SCB.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|p-&gt;qinfifo
(braket
id|p-&gt;qinfifonext
op_increment
)braket
op_assign
id|scb-&gt;hscb-&gt;tag
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_QUEUE_REGS
)paren
id|aic_outb
c_func
(paren
id|p
comma
id|p-&gt;qinfifonext
comma
id|HNSCB_QOFF
)paren
suffix:semicolon
r_else
id|aic_outb
c_func
(paren
id|p
comma
id|p-&gt;qinfifonext
comma
id|KERNEL_QINPOS
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|aic7xxx_run_done_queue
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
id|aic7xxx_run_waiting_queues
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|p-&gt;flags
op_and_assign
op_complement
id|AHC_IN_ABORT
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
id|DRIVER_UNLOCK
multiline_comment|/*&n; *  On the return value.  If we found the command and aborted it, then we know&n; *  it&squot;s already sent back and there is no reason for a further timeout, so&n; *  we use SCSI_ABORT_SUCCESS.  On the queued abort side, we aren&squot;t so certain&n; *  there hasn&squot;t been a bus hang or something that might keep the abort from&n; *  from completing.  Therefore, we use SCSI_ABORT_PENDING.  The first time this&n; *  is passed back, the timeout on the command gets extended, the second time&n; *  we pass this back, the mid level SCSI code calls our reset function, which&n; *  would shake loose a hung bus.&n; */
r_if
c_cond
(paren
id|found
op_ne
l_int|0
)paren
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
r_else
r_return
id|SCSI_ABORT_PENDING
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_reset&n; *&n; * Description:&n; *   Resetting the bus always succeeds - is has to, otherwise the&n; *   kernel will panic! Try a surgical technique - sending a BUS&n; *   DEVICE RESET message - on the offending target before pulling&n; *   the SCSI bus reset line.&n; *-F*************************************************************************/
r_int
DECL|function|aic7xxx_reset
id|aic7xxx_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|aic7xxx_scb
op_star
id|scb
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
r_int
id|tindex
suffix:semicolon
r_int
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,1,95)
r_int
r_int
id|cpu_flags
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|macro|DEVICE_RESET
mdefine_line|#define DEVICE_RESET 0x01
DECL|macro|BUS_RESET
mdefine_line|#define BUS_RESET    0x02
DECL|macro|HOST_RESET
mdefine_line|#define HOST_RESET   0x04
DECL|macro|FAIL
mdefine_line|#define FAIL         0x08
DECL|macro|RESET_DELAY
mdefine_line|#define RESET_DELAY  0x10
r_int
id|action
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd_prev
comma
op_star
id|cmd_next
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi?:?:?:?) Reset called with NULL Scsi_Cmnd &quot;
l_string|&quot;pointer, failing.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|SCSI_RESET_SNOOZE
suffix:semicolon
)brace
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|scb
op_assign
(paren
id|p-&gt;scb_data-&gt;scb_array
(braket
id|aic7xxx_position
c_func
(paren
id|cmd
)paren
)braket
)paren
suffix:semicolon
id|tindex
op_assign
id|TARGET_INDEX
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;   * I added a new config option to the driver: &quot;panic_on_abort&quot; that will&n;   * cause the driver to panic and the machine to stop on the first abort&n;   * or reset call into the driver.  At that point, it prints out a lot of&n;   * usefull information for me which I can then use to try and debug the&n;   * problem.  Simply enable the boot time prompt in order to activate this&n;   * code.&n;   */
r_if
c_cond
(paren
id|aic7xxx_panic_on_abort
)paren
id|aic7xxx_panic_abort
c_func
(paren
id|p
comma
id|cmd
)paren
suffix:semicolon
id|DRIVER_LOCK
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|INTSTAT
)paren
op_amp
id|INT_PEND
)paren
op_logical_and
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|AHC_IN_ISR
)paren
)paren
(brace
id|aic7xxx_isr
c_func
(paren
id|p-&gt;irq
comma
id|p
comma
(paren
r_void
op_star
)paren
l_int|NULL
)paren
suffix:semicolon
id|pause_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic7xxx_done_cmds_complete
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_MID
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Reset called with bogus Scsi_Cmnd&quot;
l_string|&quot;-&gt;SCB mapping, improvising.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SCSI_RESET_SUGGEST_HOST_RESET
)paren
(brace
id|action
op_assign
id|HOST_RESET
suffix:semicolon
)brace
r_else
(brace
id|action
op_assign
id|BUS_RESET
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|scb-&gt;cmd
op_ne
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_MID
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Reset called with recycled SCB &quot;
l_string|&quot;for cmd.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|cmd_prev
op_assign
l_int|NULL
suffix:semicolon
id|cmd_next
op_assign
id|p-&gt;completeq.head
suffix:semicolon
r_while
c_loop
(paren
id|cmd_next
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|cmd_next
op_eq
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_RETURN
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Reset, found cmd on completeq&quot;
l_string|&quot;, completing.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
id|DRIVER_UNLOCK
r_return
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
)brace
id|cmd_prev
op_assign
id|cmd_next
suffix:semicolon
id|cmd_next
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd_next-&gt;host_scribble
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|SCSI_RESET_SYNCHRONOUS
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_RETURN
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Reset, cmd not found,&quot;
l_string|&quot; failing.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
id|DRIVER_UNLOCK
r_return
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_MID
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Reset called, no scb, &quot;
l_string|&quot;flags 0x%x&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
comma
id|flags
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
id|action
op_assign
id|HOST_RESET
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_MID
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Reset called, scb %d, flags &quot;
l_string|&quot;0x%x&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;hscb-&gt;tag
comma
id|scb-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_scb_on_qoutfifo
c_func
(paren
id|p
comma
id|scb
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_RETURN
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;SCB on qoutfifo, completing.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|aic_inb
c_func
(paren
id|p
comma
id|INTSTAT
)paren
op_amp
id|CMDCMPLT
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;missed CMDCMPLT interrupt!&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_SCB
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|aic7xxx_handle_command_completion_intr
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic7xxx_done_cmds_complete
c_func
(paren
id|p
)paren
suffix:semicolon
id|aic7xxx_run_waiting_queues
c_func
(paren
id|p
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
id|DRIVER_UNLOCK
r_return
id|SCSI_RESET_SUCCESS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|SCSI_RESET_SUGGEST_HOST_RESET
)paren
(brace
id|action
op_assign
id|HOST_RESET
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|SCSI_RESET_SUGGEST_BUS_RESET
)paren
(brace
id|action
op_assign
id|BUS_RESET
suffix:semicolon
)brace
r_else
(brace
id|action
op_assign
id|DEVICE_RESET
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|action
op_amp
id|DEVICE_RESET
)paren
op_logical_and
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
id|BUS_DEVICE_RESET_PENDING
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Bus device reset already sent to &quot;
l_string|&quot;device, escalating.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|action
op_assign
id|BUS_RESET
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|action
op_amp
id|DEVICE_RESET
)paren
op_logical_and
(paren
id|scb-&gt;flags
op_amp
id|SCB_QUEUED_ABORT
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_PROCESS
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Have already attempted to reach &quot;
l_string|&quot;device with queued&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;message, will escalate to bus &quot;
l_string|&quot;reset.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
)brace
id|action
op_assign
id|BUS_RESET
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|action
op_amp
id|DEVICE_RESET
)paren
op_logical_and
(paren
id|p-&gt;flags
op_amp
(paren
id|AHC_RESET_PENDING
op_or
id|AHC_ABORT_PENDING
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Bus device reset stupid when &quot;
l_string|&quot;other action has failed.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|action
op_assign
id|BUS_RESET
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|action
op_amp
id|BUS_RESET
)paren
op_logical_and
op_logical_neg
(paren
id|p-&gt;features
op_amp
id|AHC_TWIN
)paren
)paren
(brace
id|action
op_assign
id|HOST_RESET
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|p-&gt;dev_flags
(braket
id|tindex
)braket
op_amp
id|DEVICE_RESET_DELAY
)paren
op_logical_and
op_logical_neg
(paren
id|action
op_amp
(paren
id|HOST_RESET
op_or
id|BUS_RESET
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_PROCESS
)paren
(brace
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Reset called too soon after last &quot;
l_string|&quot;reset without requesting&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;bus or host reset, escalating.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
)brace
id|action
op_assign
id|BUS_RESET
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|AHC_RESET_DELAY
)paren
op_logical_and
(paren
id|action
op_amp
(paren
id|HOST_RESET
op_or
id|BUS_RESET
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|aic7xxx_verbose
op_amp
id|VERBOSE_RESET_PROCESS
)paren
id|printk
c_func
(paren
id|INFO_LEAD
l_string|&quot;Reset called too soon after &quot;
l_string|&quot;last bus reset, delaying.&bslash;n&quot;
comma
id|p-&gt;host_no
comma
id|CTL_OF_CMD
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|action
op_assign
id|RESET_DELAY
suffix:semicolon
)brace
multiline_comment|/*&n; *  By this point, we want to already know what we are going to do and&n; *  only have the following code implement our course of action.&n; */
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|RESET_DELAY
suffix:colon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
id|DRIVER_UNLOCK
r_return
id|SCSI_RESET_PENDING
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FAIL
suffix:colon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
id|DRIVER_UNLOCK
r_return
id|SCSI_RESET_ERROR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEVICE_RESET
suffix:colon
id|p-&gt;flags
op_or_assign
id|AHC_IN_RESET
suffix:semicolon
id|result
op_assign
id|aic7xxx_bus_device_reset
c_func
(paren
id|p
comma
id|cmd
)paren
suffix:semicolon
id|aic7xxx_run_done_queue
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
multiline_comment|/*  We can&squot;t rely on run_waiting_queues to unpause the sequencer for&n;       *  PCI based controllers since we use AAP */
id|aic7xxx_run_waiting_queues
c_func
(paren
id|p
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
id|p-&gt;flags
op_and_assign
op_complement
id|AHC_IN_RESET
suffix:semicolon
id|DRIVER_UNLOCK
r_return
id|result
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BUS_RESET
suffix:colon
r_case
id|HOST_RESET
suffix:colon
r_default
suffix:colon
id|p-&gt;flags
op_or_assign
id|AHC_IN_RESET
op_or
id|AHC_RESET_DELAY
suffix:semicolon
id|p-&gt;dev_expires
(braket
id|p-&gt;scsi_id
)braket
op_assign
id|jiffies
op_plus
(paren
l_int|3
op_star
id|HZ
)paren
suffix:semicolon
id|p-&gt;dev_timer_active
op_or_assign
(paren
l_int|0x01
op_lshift
id|p-&gt;scsi_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;dev_timer_active
op_amp
(paren
l_int|0x01
op_lshift
id|MAX_TARGETS
)paren
)paren
op_logical_or
id|time_after_eq
c_func
(paren
id|p-&gt;dev_timer.expires
comma
id|p-&gt;dev_expires
(braket
id|p-&gt;scsi_id
)braket
)paren
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|p-&gt;dev_timer
comma
id|p-&gt;dev_expires
(braket
id|p-&gt;scsi_id
)braket
)paren
suffix:semicolon
id|p-&gt;dev_timer_active
op_or_assign
(paren
l_int|0x01
op_lshift
id|MAX_TARGETS
)paren
suffix:semicolon
)brace
id|aic7xxx_reset_channel
c_func
(paren
id|p
comma
id|cmd-&gt;channel
comma
id|TRUE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;features
op_amp
id|AHC_TWIN
)paren
op_logical_and
(paren
id|action
op_amp
id|HOST_RESET
)paren
)paren
(brace
id|aic7xxx_reset_channel
c_func
(paren
id|p
comma
id|cmd-&gt;channel
op_xor
l_int|0x01
comma
id|TRUE
)paren
suffix:semicolon
id|restart_sequencer
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action
op_ne
id|HOST_RESET
)paren
id|result
op_assign
id|SCSI_RESET_SUCCESS
op_or
id|SCSI_RESET_BUS_RESET
suffix:semicolon
r_else
(brace
id|result
op_assign
id|SCSI_RESET_SUCCESS
op_or
id|SCSI_RESET_HOST_RESET
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
id|aic_inb
c_func
(paren
id|p
comma
id|SIMODE1
)paren
op_amp
op_complement
(paren
id|ENREQINIT
op_or
id|ENBUSFREE
)paren
comma
id|SIMODE1
)paren
suffix:semicolon
id|aic7xxx_clear_intstat
c_func
(paren
id|p
)paren
suffix:semicolon
id|p-&gt;flags
op_and_assign
op_complement
id|AHC_HANDLING_REQINITS
suffix:semicolon
id|p-&gt;msg_type
op_assign
id|MSG_TYPE_NONE
suffix:semicolon
id|p-&gt;msg_index
op_assign
l_int|0
suffix:semicolon
id|p-&gt;msg_len
op_assign
l_int|0
suffix:semicolon
)brace
id|aic7xxx_run_done_queue
c_func
(paren
id|p
comma
id|TRUE
)paren
suffix:semicolon
multiline_comment|/*&n;       * If this a SCSI_RESET_SYNCHRONOUS then the command we were given is&n;       * in need of being re-started, so send it on through to aic7xxx_queue&n;       * and let it set until the delay is over.  This keeps it from dying&n;       * entirely and avoids getting a bogus dead command back through the&n;       * mid-level code due to too many retries.&n;       */
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,1,132)
r_if
c_cond
(paren
id|flags
op_amp
id|SCSI_RESET_SYNCHRONOUS
)paren
(brace
id|cmd-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
macro_line|#endif
id|p-&gt;flags
op_and_assign
op_complement
id|AHC_IN_RESET
suffix:semicolon
multiline_comment|/*&n;       * We can&squot;t rely on run_waiting_queues to unpause the sequencer for&n;       * PCI based controllers since we use AAP.  NOTE: this also sets&n;       * the timer for the one command we might have queued in the case&n;       * of a synch reset.&n;       */
id|aic7xxx_run_waiting_queues
c_func
(paren
id|p
)paren
suffix:semicolon
id|unpause_sequencer
c_func
(paren
id|p
comma
id|FALSE
)paren
suffix:semicolon
id|DRIVER_UNLOCK
r_return
id|result
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_biosparam&n; *&n; * Description:&n; *   Return the disk geometry for the given SCSI device.&n; *-F*************************************************************************/
r_int
DECL|function|aic7xxx_biosparam
id|aic7xxx_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
id|geom
(braket
)braket
)paren
(brace
r_int
id|heads
comma
id|sectors
comma
id|cylinders
comma
id|ret
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|p
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|disk-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
id|bh
op_assign
id|bread
c_func
(paren
id|MKDEV
c_func
(paren
id|MAJOR
c_func
(paren
id|dev
)paren
comma
id|MINOR
c_func
(paren
id|dev
)paren
op_amp
op_complement
l_int|0xf
)paren
comma
l_int|0
comma
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
id|ret
op_assign
id|scsi_partsize
c_func
(paren
id|bh
comma
id|disk-&gt;capacity
comma
op_amp
id|geom
(braket
l_int|2
)braket
comma
op_amp
id|geom
(braket
l_int|0
)braket
comma
op_amp
id|geom
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
op_minus
l_int|1
)paren
r_return
id|ret
suffix:semicolon
)brace
id|heads
op_assign
l_int|64
suffix:semicolon
id|sectors
op_assign
l_int|32
suffix:semicolon
id|cylinders
op_assign
id|disk-&gt;capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|AHC_EXTEND_TRANS_A
)paren
op_logical_and
(paren
id|cylinders
OG
l_int|1024
)paren
)paren
(brace
id|heads
op_assign
l_int|255
suffix:semicolon
id|sectors
op_assign
l_int|63
suffix:semicolon
id|cylinders
op_assign
id|disk-&gt;capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
)brace
id|geom
(braket
l_int|0
)braket
op_assign
id|heads
suffix:semicolon
id|geom
(braket
l_int|1
)braket
op_assign
id|sectors
suffix:semicolon
id|geom
(braket
l_int|2
)braket
op_assign
id|cylinders
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_release&n; *&n; * Description:&n; *   Free the passed in Scsi_Host memory structures prior to unloading the&n; *   module.&n; *-F*************************************************************************/
r_int
DECL|function|aic7xxx_release
id|aic7xxx_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_struct
id|aic7xxx_host
op_star
id|p
op_assign
(paren
r_struct
id|aic7xxx_host
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_struct
id|aic7xxx_host
op_star
id|next
comma
op_star
id|prev
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;irq
)paren
(brace
id|free_irq
c_func
(paren
id|p-&gt;irq
comma
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;base
)paren
(brace
id|release_region
c_func
(paren
id|p-&gt;base
comma
id|MAXREG
op_minus
id|MINREG
)paren
suffix:semicolon
)brace
macro_line|#ifdef MMAPIO
r_if
c_cond
(paren
id|p-&gt;maddr
)paren
(brace
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
(paren
(paren
(paren
r_int
r_int
)paren
id|p-&gt;maddr
)paren
op_amp
id|PAGE_MASK
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* MMAPIO */
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|next
op_assign
id|first_aic7xxx
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|next
op_eq
id|p
)paren
(brace
r_if
c_cond
(paren
id|prev
op_eq
l_int|NULL
)paren
(brace
id|first_aic7xxx
op_assign
id|next-&gt;next
suffix:semicolon
)brace
r_else
id|prev-&gt;next
op_assign
id|next-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|prev
op_assign
id|next
suffix:semicolon
)brace
id|next
op_assign
id|next-&gt;next
suffix:semicolon
)brace
id|aic7xxx_free
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_print_card&n; *&n; * Description:&n; *   Print out all of the control registers on the card&n; *&n; *   NOTE: This function is not yet safe for use on the VLB and EISA&n; *   controllers, so it isn&squot;t used on those controllers at all.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_print_card
id|aic7xxx_print_card
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_int
id|i
comma
id|j
comma
id|k
comma
id|chip
suffix:semicolon
r_static
r_struct
id|register_ranges
(brace
r_int
id|num_ranges
suffix:semicolon
r_int
id|range_val
(braket
l_int|32
)braket
suffix:semicolon
)brace
id|cards_ds
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
(brace
l_int|0
comma
)brace
)brace
comma
multiline_comment|/* none */
(brace
l_int|10
comma
(brace
l_int|0x00
comma
l_int|0x05
comma
l_int|0x08
comma
l_int|0x11
comma
l_int|0x18
comma
l_int|0x19
comma
l_int|0x1f
comma
l_int|0x1f
comma
l_int|0x60
comma
l_int|0x60
comma
multiline_comment|/*7771*/
l_int|0x62
comma
l_int|0x66
comma
l_int|0x80
comma
l_int|0x8e
comma
l_int|0x90
comma
l_int|0x95
comma
l_int|0x97
comma
l_int|0x97
comma
l_int|0x9b
comma
l_int|0x9f
)brace
)brace
comma
(brace
l_int|9
comma
(brace
l_int|0x00
comma
l_int|0x05
comma
l_int|0x08
comma
l_int|0x11
comma
l_int|0x18
comma
l_int|0x1f
comma
l_int|0x60
comma
l_int|0x60
comma
l_int|0x62
comma
l_int|0x66
comma
multiline_comment|/*7850*/
l_int|0x80
comma
l_int|0x8e
comma
l_int|0x90
comma
l_int|0x95
comma
l_int|0x97
comma
l_int|0x97
comma
l_int|0x9a
comma
l_int|0x9f
)brace
)brace
comma
(brace
l_int|9
comma
(brace
l_int|0x00
comma
l_int|0x05
comma
l_int|0x08
comma
l_int|0x11
comma
l_int|0x18
comma
l_int|0x1f
comma
l_int|0x60
comma
l_int|0x60
comma
l_int|0x62
comma
l_int|0x66
comma
multiline_comment|/*7860*/
l_int|0x80
comma
l_int|0x8e
comma
l_int|0x90
comma
l_int|0x95
comma
l_int|0x97
comma
l_int|0x97
comma
l_int|0x9a
comma
l_int|0x9f
)brace
)brace
comma
(brace
l_int|10
comma
(brace
l_int|0x00
comma
l_int|0x05
comma
l_int|0x08
comma
l_int|0x11
comma
l_int|0x18
comma
l_int|0x19
comma
l_int|0x1c
comma
l_int|0x1f
comma
l_int|0x60
comma
l_int|0x60
comma
multiline_comment|/*7870*/
l_int|0x62
comma
l_int|0x66
comma
l_int|0x80
comma
l_int|0x8e
comma
l_int|0x90
comma
l_int|0x95
comma
l_int|0x97
comma
l_int|0x97
comma
l_int|0x9a
comma
l_int|0x9f
)brace
)brace
comma
(brace
l_int|10
comma
(brace
l_int|0x00
comma
l_int|0x05
comma
l_int|0x08
comma
l_int|0x11
comma
l_int|0x18
comma
l_int|0x1a
comma
l_int|0x1c
comma
l_int|0x1f
comma
l_int|0x60
comma
l_int|0x60
comma
multiline_comment|/*7880*/
l_int|0x62
comma
l_int|0x66
comma
l_int|0x80
comma
l_int|0x8e
comma
l_int|0x90
comma
l_int|0x95
comma
l_int|0x97
comma
l_int|0x97
comma
l_int|0x9a
comma
l_int|0x9f
)brace
)brace
comma
(brace
l_int|16
comma
(brace
l_int|0x00
comma
l_int|0x05
comma
l_int|0x08
comma
l_int|0x11
comma
l_int|0x18
comma
l_int|0x1f
comma
l_int|0x60
comma
l_int|0x60
comma
l_int|0x62
comma
l_int|0x66
comma
multiline_comment|/*7890*/
l_int|0x84
comma
l_int|0x8e
comma
l_int|0x90
comma
l_int|0x95
comma
l_int|0x97
comma
l_int|0x97
comma
l_int|0x9a
comma
l_int|0x9a
comma
l_int|0x9f
comma
l_int|0x9f
comma
l_int|0xe0
comma
l_int|0xf1
comma
l_int|0xf4
comma
l_int|0xf4
comma
l_int|0xf6
comma
l_int|0xf6
comma
l_int|0xf8
comma
l_int|0xf8
comma
l_int|0xfa
comma
l_int|0xfc
comma
l_int|0xfe
comma
l_int|0xff
)brace
)brace
comma
(brace
l_int|12
comma
(brace
l_int|0x00
comma
l_int|0x05
comma
l_int|0x08
comma
l_int|0x11
comma
l_int|0x18
comma
l_int|0x19
comma
l_int|0x1b
comma
l_int|0x1f
comma
l_int|0x60
comma
l_int|0x60
comma
multiline_comment|/*7895*/
l_int|0x62
comma
l_int|0x66
comma
l_int|0x80
comma
l_int|0x8e
comma
l_int|0x90
comma
l_int|0x95
comma
l_int|0x97
comma
l_int|0x97
comma
l_int|0x9a
comma
l_int|0x9a
comma
l_int|0x9f
comma
l_int|0x9f
comma
l_int|0xe0
comma
l_int|0xf1
)brace
)brace
comma
(brace
l_int|16
comma
(brace
l_int|0x00
comma
l_int|0x05
comma
l_int|0x08
comma
l_int|0x11
comma
l_int|0x18
comma
l_int|0x1f
comma
l_int|0x60
comma
l_int|0x60
comma
l_int|0x62
comma
l_int|0x66
comma
multiline_comment|/*7896*/
l_int|0x84
comma
l_int|0x8e
comma
l_int|0x90
comma
l_int|0x95
comma
l_int|0x97
comma
l_int|0x97
comma
l_int|0x9a
comma
l_int|0x9a
comma
l_int|0x9f
comma
l_int|0x9f
comma
l_int|0xe0
comma
l_int|0xf1
comma
l_int|0xf4
comma
l_int|0xf4
comma
l_int|0xf6
comma
l_int|0xf6
comma
l_int|0xf8
comma
l_int|0xf8
comma
l_int|0xfa
comma
l_int|0xfc
comma
l_int|0xfe
comma
l_int|0xff
)brace
)brace
comma
(brace
l_int|12
comma
(brace
l_int|0x00
comma
l_int|0x05
comma
l_int|0x08
comma
l_int|0x11
comma
l_int|0x18
comma
l_int|0x1f
comma
l_int|0x60
comma
l_int|0x60
comma
l_int|0x62
comma
l_int|0x66
comma
multiline_comment|/*7892*/
l_int|0x84
comma
l_int|0x8e
comma
l_int|0x90
comma
l_int|0x95
comma
l_int|0x97
comma
l_int|0x97
comma
l_int|0x9a
comma
l_int|0x9a
comma
l_int|0x9c
comma
l_int|0x9f
comma
l_int|0xe0
comma
l_int|0xf1
comma
l_int|0xf4
comma
l_int|0xfc
)brace
)brace
comma
(brace
l_int|12
comma
(brace
l_int|0x00
comma
l_int|0x05
comma
l_int|0x08
comma
l_int|0x11
comma
l_int|0x18
comma
l_int|0x1f
comma
l_int|0x60
comma
l_int|0x60
comma
l_int|0x62
comma
l_int|0x66
comma
multiline_comment|/*7899*/
l_int|0x84
comma
l_int|0x8e
comma
l_int|0x90
comma
l_int|0x95
comma
l_int|0x97
comma
l_int|0x97
comma
l_int|0x9a
comma
l_int|0x9a
comma
l_int|0x9c
comma
l_int|0x9f
comma
l_int|0xe0
comma
l_int|0xf1
comma
l_int|0xf4
comma
l_int|0xfc
)brace
)brace
comma
)brace
suffix:semicolon
id|chip
op_assign
id|p-&gt;chip
op_amp
id|AHC_CHIPID_MASK
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s at &quot;
comma
id|board_names
(braket
id|p-&gt;board_name_index
)braket
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;chip
op_amp
op_complement
id|AHC_CHIPID_MASK
)paren
(brace
r_case
id|AHC_VL
suffix:colon
id|printk
c_func
(paren
l_string|&quot;VLB Slot %d.&bslash;n&quot;
comma
id|p-&gt;pci_device_fn
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AHC_EISA
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EISA Slot %d.&bslash;n&quot;
comma
id|p-&gt;pci_device_fn
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AHC_PCI
suffix:colon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;PCI %d/%d/%d.&bslash;n&quot;
comma
id|p-&gt;pci_bus
comma
id|PCI_SLOT
c_func
(paren
id|p-&gt;pci_device_fn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|p-&gt;pci_device_fn
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;   * the registers on the card....&n;   */
id|printk
c_func
(paren
l_string|&quot;Card Dump:&bslash;n&quot;
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cards_ds
(braket
id|chip
)braket
dot
id|num_ranges
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|cards_ds
(braket
id|chip
)braket
dot
id|range_val
(braket
id|i
op_star
l_int|2
)braket
suffix:semicolon
id|j
op_le
id|cards_ds
(braket
id|chip
)braket
dot
id|range_val
(braket
id|i
op_star
l_int|2
op_plus
l_int|1
)braket
suffix:semicolon
id|j
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x:%02x &quot;
comma
id|j
comma
id|aic_inb
c_func
(paren
id|p
comma
id|j
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|k
op_eq
l_int|13
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|k
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * If this was an Ultra2 controller, then we just hosed the card in terms&n;   * of the QUEUE REGS.  This function is only called at init time or by&n;   * the panic_abort function, so it&squot;s safe to assume a generic init time&n;   * setting here&n;   */
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_QUEUE_REGS
)paren
(brace
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SDSCB_QOFF
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|SNSCB_QOFF
)paren
suffix:semicolon
id|aic_outb
c_func
(paren
id|p
comma
l_int|0
comma
id|HNSCB_QOFF
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*+F*************************************************************************&n; * Function:&n; *   aic7xxx_print_scratch_ram&n; *&n; * Description:&n; *   Print out the scratch RAM values on the card.&n; *-F*************************************************************************/
r_static
r_void
DECL|function|aic7xxx_print_scratch_ram
id|aic7xxx_print_scratch_ram
c_func
(paren
r_struct
id|aic7xxx_host
op_star
id|p
)paren
(brace
r_int
id|i
comma
id|k
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Scratch RAM:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|SRAM_BASE
suffix:semicolon
id|i
OL
id|SEQCTL
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x:%02x &quot;
comma
id|i
comma
id|aic_inb
c_func
(paren
id|p
comma
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|k
op_eq
l_int|13
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|p-&gt;features
op_amp
id|AHC_MORE_SRAM
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|TARG_OFFSET
suffix:semicolon
id|i
OL
l_int|0x80
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x:%02x &quot;
comma
id|i
comma
id|aic_inb
c_func
(paren
id|p
comma
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|k
op_eq
l_int|13
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#include &quot;aic7xxx_proc.c&quot;
multiline_comment|/* Eventually this will go into an include file, but this will be later */
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|AIC7XXX
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
multiline_comment|/*&n; * Overrides for Emacs so that we almost follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 2&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -2&n; * c-argdecl-indent: 2&n; * c-label-offset: -2&n; * c-continued-statement-offset: 2&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: nil&n; * tab-width: 8&n; * End:&n; */
eof
