multiline_comment|/*&n; *&t;seagate.c Copyright (C) 1992, 1993 Drew Eckhardt &n; *&t;low level scsi driver for ST01/ST02, Future Domain TMC-885, &n; *&t;TMC-950  by&n; *&n; *&t;&t;Drew Eckhardt &n; *&n; *&t;&lt;drew@colorado.edu&gt;&n; *&n; * &t;Note : TMC-880 boards don&squot;t work because they have two bits in &n; *&t;&t;the status register flipped, I&squot;ll fix this &quot;RSN&quot;&n; *&n; *      This card does all the I/O via memory mapped I/O, so there is no need&n; *      to check or snarf a region of the I/O address space.&n; */
multiline_comment|/*&n; * Configuration : &n; * To use without BIOS -DOVERRIDE=base_address -DCONTROLLER=FD or SEAGATE&n; * -DIRQ will override the default of 5.&n; * Note: You can now set these options from the kernel&squot;s &quot;command line&quot;.&n; * The syntax is:&n; *&n; *     st0x=ADDRESS,IRQ                (for a Seagate controller)&n; * or:&n; *     tmc8xx=ADDRESS,IRQ              (for a TMC-8xx or TMC-950 controller)&n; * eg:&n; *     tmc8xx=0xC8000,15&n; *&n; * will configure the driver for a TMC-8xx style controller using IRQ 15&n; * with a base address of 0xC8000.&n; * &n; * -DFAST or -DFAST32 will use blind transfers where possible&n; *&n; * -DARBITRATE will cause the host adapter to arbitrate for the &n; *&t;bus for better SCSI-II compatibility, rather than just &n; *&t;waiting for BUS FREE and then doing its thing.  Should&n; *&t;let us do one command per Lun when I integrate my &n; *&t;reorganization changes into the distribution sources.&n; *&n; * -DSLOW_HANDSHAKE will allow compatibility with broken devices that don&squot;t &n; *&t;handshake fast enough (ie, some CD ROM&squot;s) for the Seagate&n; * &t;code.&n; *&n; * -DSLOW_RATE=x, x some number will let you specify a default &n; *&t;transfer rate if handshaking isn&squot;t working correctly.&n; */
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &quot;../block/blk.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;seagate.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#ifndef IRQ
DECL|macro|IRQ
mdefine_line|#define IRQ 5
macro_line|#endif
macro_line|#if (defined(FAST32) &amp;&amp; !defined(FAST))
DECL|macro|FAST
mdefine_line|#define FAST
macro_line|#endif
macro_line|#if defined(SLOW_RATE) &amp;&amp; !defined(SLOW_HANDSHAKE)
DECL|macro|SLOW_HANDSHAKE
mdefine_line|#define SLOW_HANDSHAKE
macro_line|#endif
macro_line|#if defined(SLOW_HANDSHAKE) &amp;&amp; !defined(SLOW_RATE)
DECL|macro|SLOW_RATE
mdefine_line|#define SLOW_RATE 50
macro_line|#endif
macro_line|#if defined(LINKED)
DECL|macro|LINKED
macro_line|#undef LINKED&t;&t;/* Linked commands are currently broken ! */
macro_line|#endif
r_static
r_int
id|internal_command
c_func
(paren
r_int
r_char
id|target
comma
r_int
r_char
id|lun
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buff
comma
r_int
id|bufflen
comma
r_int
id|reselect
)paren
suffix:semicolon
DECL|variable|incommand
r_static
r_int
id|incommand
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;set if arbitration has finished and we are &n;&t;&t;&t;&t;&t;&t;in some command phase.&n;&t;&t;&t;&t;&t;*/
DECL|variable|base_address
r_static
r_void
op_star
id|base_address
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;Where the card ROM starts,&n;&t;&t;&t;&t;&t;&t;used to calculate memory mapped&n;&t;&t;&t;&t;&t;&t;register location.&n;&t;&t;&t;&t;&t;*/
macro_line|#ifdef notyet
DECL|variable|abort_confirm
r_static
r_volatile
r_int
id|abort_confirm
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|variable|st0x_cr_sr
r_static
r_volatile
r_void
op_star
id|st0x_cr_sr
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;control register write,&n;&t;&t;&t;&t;&t;&t;status register read.&n;&t;&t;&t;&t;&t;&t;256 bytes in length.&n;&n;&t;&t;&t;&t;&t;&t;Read is status of SCSI BUS,&n;&t;&t;&t;&t;&t;&t;as per STAT masks.&n;&n;&t;&t;&t;&t;&t;*/
DECL|variable|st0x_dr
r_static
r_volatile
r_void
op_star
id|st0x_dr
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;data register, read write&n;&t;&t;&t;&t;&t;&t;256 bytes in length.&n;&t;&t;&t;&t;&t;*/
DECL|variable|st0x_aborted
r_static
r_volatile
r_int
id|st0x_aborted
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;set when we are aborted, ie by a time out, etc.&n;&t;&t;&t;&t;&t;*/
DECL|variable|controller_type
r_static
r_int
r_char
id|controller_type
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set to SEAGATE for ST0x boards or FD for TMC-8xx boards */
DECL|variable|irq
r_static
r_int
r_char
id|irq
op_assign
id|IRQ
suffix:semicolon
DECL|macro|retcode
mdefine_line|#define retcode(result) (((result) &lt;&lt; 16) | (message &lt;&lt; 8) | status) &t;&t;&t;
DECL|macro|STATUS
mdefine_line|#define STATUS (*(volatile unsigned char *) st0x_cr_sr)
DECL|macro|CONTROL
mdefine_line|#define CONTROL STATUS 
DECL|macro|DATA
mdefine_line|#define DATA (*(volatile unsigned char *) st0x_dr)
DECL|function|st0x_setup
r_void
id|st0x_setup
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|controller_type
op_assign
id|SEAGATE
suffix:semicolon
id|base_address
op_assign
(paren
r_void
op_star
)paren
id|ints
(braket
l_int|1
)braket
suffix:semicolon
id|irq
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
)brace
DECL|function|tmc8xx_setup
r_void
id|tmc8xx_setup
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|controller_type
op_assign
id|FD
suffix:semicolon
id|base_address
op_assign
(paren
r_void
op_star
)paren
id|ints
(braket
l_int|1
)braket
suffix:semicolon
id|irq
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
)brace
macro_line|#ifndef OVERRIDE&t;&t;
DECL|variable|seagate_bases
r_static
r_const
r_char
op_star
id|seagate_bases
(braket
)braket
op_assign
(brace
(paren
r_char
op_star
)paren
l_int|0xc8000
comma
(paren
r_char
op_star
)paren
l_int|0xca000
comma
(paren
r_char
op_star
)paren
l_int|0xcc000
comma
(paren
r_char
op_star
)paren
l_int|0xce000
comma
(paren
r_char
op_star
)paren
l_int|0xdc000
comma
(paren
r_char
op_star
)paren
l_int|0xde000
)brace
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|signature
r_char
op_star
id|signature
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|type
r_int
r_char
id|type
suffix:semicolon
DECL|typedef|Signature
)brace
id|Signature
suffix:semicolon
DECL|variable|signatures
r_static
r_const
id|Signature
id|signatures
(braket
)braket
op_assign
(brace
macro_line|#ifdef CONFIG_SCSI_SEAGATE
(brace
l_string|&quot;ST01 v1.7  (C) Copyright 1987 Seagate&quot;
comma
l_int|15
comma
l_int|37
comma
id|SEAGATE
)brace
comma
(brace
l_string|&quot;SCSI BIOS 2.00  (C) Copyright 1987 Seagate&quot;
comma
l_int|15
comma
l_int|40
comma
id|SEAGATE
)brace
comma
multiline_comment|/*&n; * The following two lines are NOT mistakes.  One detects ROM revision &n; * 3.0.0, the other 3.2.  Since seagate has only one type of SCSI adapter, &n; * and this is not going to change, the &quot;SEAGATE&quot; and &quot;SCSI&quot; together&n; * are probably &quot;good enough&quot;&n; */
(brace
l_string|&quot;SEAGATE SCSI BIOS &quot;
comma
l_int|16
comma
l_int|17
comma
id|SEAGATE
)brace
comma
(brace
l_string|&quot;SEAGATE SCSI BIOS &quot;
comma
l_int|17
comma
l_int|17
comma
id|SEAGATE
)brace
comma
multiline_comment|/*&n; * However, future domain makes several incompatible SCSI boards, so specific&n; * signatures must be used.&n; */
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1989 V5.0C2/14/89&quot;
comma
l_int|5
comma
l_int|46
comma
id|FD
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1989 V6.0A7/28/89&quot;
comma
l_int|5
comma
l_int|46
comma
id|FD
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1990 V6.0105/31/90&quot;
comma
l_int|5
comma
l_int|47
comma
id|FD
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1990 V6.0209/18/90&quot;
comma
l_int|5
comma
l_int|47
comma
id|FD
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1990 V7.009/18/90&quot;
comma
l_int|5
comma
l_int|46
comma
id|FD
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1992 V8.00.004/02/92&quot;
comma
l_int|5
comma
l_int|44
comma
id|FD
)brace
comma
(brace
l_string|&quot;IBM F1 BIOS V1.1004/30/92&quot;
comma
l_int|5
comma
l_int|25
comma
id|FD
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN TMC-950&quot;
comma
l_int|5
comma
l_int|21
comma
id|FD
)brace
comma
macro_line|#endif /* CONFIG_SCSI_SEAGATE */
)brace
suffix:semicolon
DECL|macro|NUM_SIGNATURES
mdefine_line|#define NUM_SIGNATURES (sizeof(signatures) / sizeof(Signature))
macro_line|#endif /* n OVERRIDE */
multiline_comment|/*&n; * hostno stores the hostnumber, as told to us by the init routine.&n; */
DECL|variable|hostno
r_static
r_int
id|hostno
op_assign
op_minus
l_int|1
suffix:semicolon
r_static
r_void
id|seagate_reconnect_intr
c_func
(paren
r_int
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
macro_line|#ifdef FAST
DECL|variable|fast
r_static
r_int
id|fast
op_assign
l_int|1
suffix:semicolon
macro_line|#endif 
macro_line|#ifdef SLOW_HANDSHAKE
multiline_comment|/* &n; * Support for broken devices : &n; * The Seagate board has a handshaking problem.  Namely, a lack &n; * thereof for slow devices.  You can blast 600K/second through &n; * it if you are polling for each byte, more if you do a blind &n; * transfer.  In the first case, with a fast device, REQ will &n; * transition high-low or high-low-high before your loop restarts &n; * and you&squot;ll have no problems.  In the second case, the board &n; * will insert wait states for up to 13.2 usecs for REQ to &n; * transition low-&gt;high, and everything will work.&n; *&n; * However, there&squot;s nothing in the state machine that says &n; * you *HAVE* to see a high-low-high set of transitions before&n; * sending the next byte, and slow things like the Trantor CD ROMS&n; * will break because of this.&n; * &n; * So, we need to slow things down, which isn&squot;t as simple as it &n; * seems.  We can&squot;t slow things down period, because then people&n; * who don&squot;t recompile their kernels will shoot me for ruining &n; * their performance.  We need to do it on a case per case basis.&n; *&n; * The best for performance will be to, only for borken devices &n; * (this is stored on a per-target basis in the scsi_devices array)&n; * &n; * Wait for a low-&gt;high transition before continuing with that &n; * transfer.  If we timeout, continue anyways.  We don&squot;t need &n; * a long timeout, because REQ should only be asserted until the &n; * corresponding ACK is received and processed.&n; *&n; * Note that we can&squot;t use the system timer for this, because of &n; * resolution, and we *really* can&squot;t use the timer chip since &n; * gettimeofday() and the beeper routines use that.  So,&n; * the best thing for us to do will be to calibrate a timing&n; * loop in the initialization code using the timer chip before&n; * gettimeofday() can screw with it.&n; */
DECL|variable|borken_calibration
r_static
r_int
id|borken_calibration
op_assign
l_int|0
suffix:semicolon
DECL|function|borken_init
r_static
r_void
id|borken_init
(paren
r_void
)paren
(brace
r_register
r_int
id|count
op_assign
l_int|0
comma
id|start
op_assign
id|jiffies
op_plus
l_int|1
comma
id|stop
op_assign
id|start
op_plus
l_int|25
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|start
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|jiffies
OL
id|stop
suffix:semicolon
op_increment
id|count
)paren
suffix:semicolon
multiline_comment|/* &n; * Ok, we now have a count for .25 seconds.  Convert to a &n; * count per second and divide by transfer rate in K.&n; */
id|borken_calibration
op_assign
(paren
id|count
op_star
l_int|4
)paren
op_div
(paren
id|SLOW_RATE
op_star
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
id|borken_calibration
OL
l_int|1
)paren
id|borken_calibration
op_assign
l_int|1
suffix:semicolon
macro_line|#if (DEBUG &amp; DEBUG_BORKEN)
id|printk
c_func
(paren
l_string|&quot;scsi%d : borken calibrated to %dK/sec, %d cycles per transfer&bslash;n&quot;
comma
id|hostno
comma
id|BORKEN_RATE
comma
id|borken_calibration
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|borken_wait
r_static
r_inline
r_void
id|borken_wait
c_func
(paren
r_void
)paren
(brace
r_register
r_int
id|count
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
id|borken_calibration
suffix:semicolon
id|count
op_logical_and
(paren
id|STATUS
op_amp
id|STAT_REQ
)paren
suffix:semicolon
op_decrement
id|count
)paren
suffix:semicolon
macro_line|#if (DEBUG &amp; DEBUG_BORKEN) 
r_if
c_cond
(paren
id|count
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : borken timeout&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif 
)brace
macro_line|#endif /* def SLOW_HANDSHAKE */
DECL|function|seagate_st0x_detect
r_int
id|seagate_st0x_detect
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
macro_line|#ifndef OVERRIDE
r_int
id|i
comma
id|j
suffix:semicolon
macro_line|#endif 
multiline_comment|/*&n; *&t;First, we try for the manual override.&n; */
macro_line|#ifdef DEBUG 
id|printk
c_func
(paren
l_string|&quot;Autodetecting ST0x / TMC-8xx&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|hostno
op_ne
op_minus
l_int|1
)paren
(brace
id|printk
(paren
l_string|&quot;ERROR : seagate_st0x_detect() called twice.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If the user specified the controller type from the command line,&n;         controller_type will be non-zero, so don&squot;t try and detect one */
r_if
c_cond
(paren
op_logical_neg
id|controller_type
)paren
(brace
macro_line|#ifdef OVERRIDE
id|base_address
op_assign
(paren
r_void
op_star
)paren
id|OVERRIDE
suffix:semicolon
multiline_comment|/* CONTROLLER is used to override controller (SEAGATE or FD). PM: 07/01/93 */
macro_line|#ifdef CONTROLLER
id|controller_type
op_assign
id|CONTROLLER
suffix:semicolon
macro_line|#else
macro_line|#error Please use -DCONTROLLER=SEAGATE or -DCONTROLLER=FD to override controller type
macro_line|#endif /* CONTROLLER */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Base address overridden to %x, controller type is %s&bslash;n&quot;
comma
id|base_address
comma
id|controller_type
op_eq
id|SEAGATE
ques
c_cond
l_string|&quot;SEAGATE&quot;
suffix:colon
l_string|&quot;FD&quot;
)paren
suffix:semicolon
macro_line|#endif 
macro_line|#else /* OVERRIDE */&t;
multiline_comment|/*&n; *&t;To detect this card, we simply look for the signature&n; *&t;from the BIOS version notice in all the possible locations&n; *&t;of the ROM&squot;s.  This has a nice side effect of not trashing&n; * &t;any register locations that might be used by something else.&n; *&n; * XXX - note that we probably should be probing the address&n; * space for the on-board RAM instead.&n; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_sizeof
(paren
id|seagate_bases
)paren
op_div
r_sizeof
(paren
r_char
op_star
)paren
)paren
suffix:semicolon
op_increment
id|i
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|base_address
op_logical_and
id|j
OL
id|NUM_SIGNATURES
suffix:semicolon
op_increment
id|j
)paren
r_if
c_cond
(paren
op_logical_neg
id|memcmp
(paren
(paren
r_void
op_star
)paren
(paren
id|seagate_bases
(braket
id|i
)braket
op_plus
id|signatures
(braket
id|j
)braket
dot
id|offset
)paren
comma
(paren
r_void
op_star
)paren
id|signatures
(braket
id|j
)braket
dot
id|signature
comma
id|signatures
(braket
id|j
)braket
dot
id|length
)paren
)paren
(brace
id|base_address
op_assign
(paren
r_void
op_star
)paren
id|seagate_bases
(braket
id|i
)braket
suffix:semicolon
id|controller_type
op_assign
id|signatures
(braket
id|j
)braket
dot
id|type
suffix:semicolon
)brace
macro_line|#endif /* OVERRIDE */
)brace
multiline_comment|/* (! controller_type) */
id|tpnt-&gt;this_id
op_assign
(paren
id|controller_type
op_eq
id|SEAGATE
)paren
ques
c_cond
l_int|7
suffix:colon
l_int|6
suffix:semicolon
id|tpnt-&gt;name
op_assign
(paren
id|controller_type
op_eq
id|SEAGATE
)paren
ques
c_cond
id|ST0X_ID_STR
suffix:colon
id|FD_ID_STR
suffix:semicolon
r_if
c_cond
(paren
id|base_address
)paren
(brace
id|st0x_cr_sr
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|base_address
)paren
op_plus
(paren
id|controller_type
op_eq
id|SEAGATE
ques
c_cond
l_int|0x1a00
suffix:colon
l_int|0x1c00
)paren
)paren
suffix:semicolon
id|st0x_dr
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|base_address
)paren
op_plus
(paren
id|controller_type
op_eq
id|SEAGATE
ques
c_cond
l_int|0x1c00
suffix:colon
l_int|0x1e00
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s detected. Base address = %x, cr = %x, dr = %x&bslash;n&quot;
comma
id|tpnt-&gt;name
comma
id|base_address
comma
id|st0x_cr_sr
comma
id|st0x_dr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;At all times, we will use IRQ 5.  Should also check for IRQ3 if we &n; * &t;loose our first interrupt.&n; */
id|instance
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
l_int|0
)paren
suffix:semicolon
id|hostno
op_assign
id|instance-&gt;host_no
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
(paren
r_int
)paren
id|irq
comma
id|seagate_reconnect_intr
comma
id|SA_INTERRUPT
comma
(paren
id|controller_type
op_eq
id|SEAGATE
)paren
ques
c_cond
l_string|&quot;seagate&quot;
suffix:colon
l_string|&quot;tmc-8xx&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : unable to allocate IRQ%d&bslash;n&quot;
comma
id|hostno
comma
(paren
r_int
)paren
id|irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef SLOW_HANDSHAKE
id|borken_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;%s options:&quot;
macro_line|#ifdef ARBITRATE
l_string|&quot; ARBITRATE&quot;
macro_line|#endif
macro_line|#ifdef SLOW_HANDSHAKE
l_string|&quot; SLOW_HANDSHAKE&quot;
macro_line|#endif
macro_line|#ifdef FAST
macro_line|#ifdef FAST32
l_string|&quot; FAST32&quot;
macro_line|#else
l_string|&quot; FAST&quot;
macro_line|#endif
macro_line|#endif
macro_line|#ifdef LINKED
l_string|&quot; LINKED&quot;
macro_line|#endif
l_string|&quot;&bslash;n&quot;
comma
id|tpnt-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;ST0x / TMC-8xx not detected.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|seagate_st0x_info
r_const
r_char
op_star
id|seagate_st0x_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_static
r_char
id|buffer
(braket
l_int|64
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%s at irq %d, address 0x%05X&quot;
comma
(paren
id|controller_type
op_eq
id|SEAGATE
)paren
ques
c_cond
id|ST0X_ID_STR
suffix:colon
id|FD_ID_STR
comma
id|irq
comma
(paren
r_int
r_int
)paren
id|base_address
)paren
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
multiline_comment|/*&n; * These are our saved pointers for the outstanding command that is &n; * waiting for a reconnect&n; */
DECL|variable|current_target
DECL|variable|current_lun
r_static
r_int
r_char
id|current_target
comma
id|current_lun
suffix:semicolon
DECL|variable|current_cmnd
DECL|variable|current_data
r_static
r_int
r_char
op_star
id|current_cmnd
comma
op_star
id|current_data
suffix:semicolon
DECL|variable|current_nobuffs
r_static
r_int
id|current_nobuffs
suffix:semicolon
DECL|variable|current_buffer
r_static
r_struct
id|scatterlist
op_star
id|current_buffer
suffix:semicolon
DECL|variable|current_bufflen
r_static
r_int
id|current_bufflen
suffix:semicolon
macro_line|#ifdef LINKED
multiline_comment|/* &n; * linked_connected indicates whether or not we are currently connected to &n; * linked_target, linked_lun and in an INFORMATION TRANSFER phase,&n; * using linked commands.&n; */
DECL|variable|linked_connected
r_static
r_int
id|linked_connected
op_assign
l_int|0
suffix:semicolon
DECL|variable|linked_target
DECL|variable|linked_lun
r_static
r_int
r_char
id|linked_target
comma
id|linked_lun
suffix:semicolon
macro_line|#endif
DECL|variable|done_fn
r_static
r_void
(paren
op_star
id|done_fn
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|SCint
r_static
id|Scsi_Cmnd
op_star
id|SCint
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * These control whether or not disconnect / reconnect will be attempted,&n; * or are being attempted.&n; */
DECL|macro|NO_RECONNECT
mdefine_line|#define NO_RECONNECT &t;0
DECL|macro|RECONNECT_NOW
mdefine_line|#define RECONNECT_NOW &t;1
DECL|macro|CAN_RECONNECT
mdefine_line|#define CAN_RECONNECT&t;2
macro_line|#ifdef LINKED
multiline_comment|/*&n; * LINKED_RIGHT indicates that we are currently connected to the correct target&n; * for this command, LINKED_WRONG indicates that we are connected to the wrong &n; * target.  Note that these imply CAN_RECONNECT.&n; */
DECL|macro|LINKED_RIGHT
mdefine_line|#define LINKED_RIGHT &t;3
DECL|macro|LINKED_WRONG
mdefine_line|#define LINKED_WRONG&t;4
macro_line|#endif
multiline_comment|/*&n; * This determines if we are expecting to reconnect or not.&n; */
DECL|variable|should_reconnect
r_static
r_int
id|should_reconnect
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * The seagate_reconnect_intr routine is called when a target reselects the &n; * host adapter.  This occurs on the interrupt triggered by the target &n; * asserting SEL.&n; */
DECL|function|seagate_reconnect_intr
r_static
r_void
id|seagate_reconnect_intr
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|temp
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCtmp
suffix:semicolon
multiline_comment|/* enable all other interrupts. */
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : seagate_reconnect_intr() called&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|should_reconnect
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d: unexpected interrupt.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_else
(brace
id|should_reconnect
op_assign
l_int|0
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : internal_command(&quot;
l_string|&quot;%d, %08x, %08x, %d, RECONNECT_NOW&bslash;n&quot;
comma
id|hostno
comma
id|current_target
comma
id|current_data
comma
id|current_bufflen
)paren
suffix:semicolon
macro_line|#endif
id|temp
op_assign
id|internal_command
(paren
id|current_target
comma
id|current_lun
comma
id|current_cmnd
comma
id|current_data
comma
id|current_bufflen
comma
id|RECONNECT_NOW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg_byte
c_func
(paren
id|temp
)paren
op_ne
id|DISCONNECT
)paren
(brace
r_if
c_cond
(paren
id|done_fn
)paren
(brace
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : done_fn(%d,%08x)&quot;
comma
id|hostno
comma
id|hostno
comma
id|temp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|SCint
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;SCint == NULL in seagate&quot;
)paren
suffix:semicolon
)brace
id|SCtmp
op_assign
id|SCint
suffix:semicolon
id|SCint
op_assign
l_int|NULL
suffix:semicolon
id|SCtmp-&gt;result
op_assign
id|temp
suffix:semicolon
id|done_fn
(paren
id|SCtmp
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;done_fn() not defined.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* &n; * The seagate_st0x_queue_command() function provides a queued interface&n; * to the seagate SCSI driver.  Basically, it just passes control onto the&n; * seagate_command() function, after fixing it so that the done_fn()&n; * is set to the one passed to the function.  We have to be very careful,&n; * because there are some commands on some devices that do not disconnect,&n; * and if we simply call the done_fn when the command is done then another&n; * command is started and queue_command is called again...  We end up&n; * overflowing the kernel stack, and this tends not to be such a good idea.&n; */
DECL|variable|recursion_depth
r_static
r_int
id|recursion_depth
op_assign
l_int|0
suffix:semicolon
DECL|function|seagate_st0x_queue_command
r_int
id|seagate_st0x_queue_command
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
id|result
comma
id|reconnect
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCtmp
suffix:semicolon
id|done_fn
op_assign
id|done
suffix:semicolon
id|current_target
op_assign
id|SCpnt-&gt;target
suffix:semicolon
id|current_lun
op_assign
id|SCpnt-&gt;lun
suffix:semicolon
(paren
r_const
r_void
op_star
)paren
id|current_cmnd
op_assign
id|SCpnt-&gt;cmnd
suffix:semicolon
id|current_data
op_assign
(paren
r_int
r_char
op_star
)paren
id|SCpnt-&gt;request_buffer
suffix:semicolon
id|current_bufflen
op_assign
id|SCpnt-&gt;request_bufflen
suffix:semicolon
id|SCint
op_assign
id|SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|recursion_depth
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
id|recursion_depth
op_increment
suffix:semicolon
r_do
(brace
macro_line|#ifdef LINKED
multiline_comment|/*&n; * Set linked command bit in control field of SCSI command.&n; */
id|current_cmnd
(braket
id|SCpnt-&gt;cmd_len
)braket
op_or_assign
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
id|linked_connected
)paren
(brace
macro_line|#if (DEBUG &amp; DEBUG_LINKED) 
id|printk
c_func
(paren
l_string|&quot;scsi%d : using linked commands, current I_T_L nexus is &quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|linked_target
op_eq
id|current_target
)paren
op_logical_and
(paren
id|linked_lun
op_eq
id|current_lun
)paren
)paren
(brace
macro_line|#if (DEBUG &amp; DEBUG_LINKED) 
id|printk
c_func
(paren
l_string|&quot;correct&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|reconnect
op_assign
id|LINKED_RIGHT
suffix:semicolon
)brace
r_else
(brace
macro_line|#if (DEBUG &amp; DEBUG_LINKED) 
id|printk
c_func
(paren
l_string|&quot;incorrect&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|reconnect
op_assign
id|LINKED_WRONG
suffix:semicolon
)brace
)brace
r_else
macro_line|#endif /* LINKED */
id|reconnect
op_assign
id|CAN_RECONNECT
suffix:semicolon
id|result
op_assign
id|internal_command
(paren
id|SCint-&gt;target
comma
id|SCint-&gt;lun
comma
id|SCint-&gt;cmnd
comma
id|SCint-&gt;request_buffer
comma
id|SCint-&gt;request_bufflen
comma
id|reconnect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg_byte
c_func
(paren
id|result
)paren
op_eq
id|DISCONNECT
)paren
r_break
suffix:semicolon
id|SCtmp
op_assign
id|SCint
suffix:semicolon
id|SCint
op_assign
l_int|NULL
suffix:semicolon
id|SCtmp-&gt;result
op_assign
id|result
suffix:semicolon
id|done_fn
(paren
id|SCtmp
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|SCint
)paren
(brace
suffix:semicolon
)brace
id|recursion_depth
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|seagate_st0x_command
r_int
id|seagate_st0x_command
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_return
id|internal_command
(paren
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;request_buffer
comma
id|SCpnt-&gt;request_bufflen
comma
(paren
r_int
)paren
id|NO_RECONNECT
)paren
suffix:semicolon
)brace
DECL|function|internal_command
r_static
r_int
id|internal_command
c_func
(paren
r_int
r_char
id|target
comma
r_int
r_char
id|lun
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buff
comma
r_int
id|bufflen
comma
r_int
id|reselect
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|scatterlist
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_int
id|nobuffs
op_assign
l_int|0
suffix:semicolon
r_int
id|clock
suffix:semicolon
r_int
id|temp
suffix:semicolon
macro_line|#ifdef SLOW_HANDSHAKE
r_int
id|borken
suffix:semicolon
multiline_comment|/* Does the current target require Very Slow I/O ? */
macro_line|#endif
macro_line|#if (DEBUG &amp; PHASE_DATAIN) || (DEBUG &amp; PHASE_DATOUT) 
r_int
id|transfered
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#if (((DEBUG &amp; PHASE_ETC) == PHASE_ETC) || (DEBUG &amp; PRINT_COMMAND) || &bslash;&n;&t;(DEBUG &amp; PHASE_EXIT))&t;
r_int
id|i
suffix:semicolon
macro_line|#endif
macro_line|#if ((DEBUG &amp; PHASE_ETC) == PHASE_ETC)
r_int
id|phase
op_assign
l_int|0
comma
id|newphase
suffix:semicolon
macro_line|#endif
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|status
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|message
op_assign
l_int|0
suffix:semicolon
r_register
r_int
r_char
id|status_read
suffix:semicolon
r_int
id|transfersize
op_assign
l_int|0
comma
id|underflow
op_assign
l_int|0
suffix:semicolon
id|incommand
op_assign
l_int|0
suffix:semicolon
id|st0x_aborted
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SLOW_HANDSHAKE
id|borken
op_assign
(paren
r_int
)paren
id|SCint-&gt;device-&gt;borken
suffix:semicolon
macro_line|#endif
macro_line|#if (DEBUG &amp; PRINT_COMMAND)
id|printk
(paren
l_string|&quot;scsi%d : target = %d, command = &quot;
comma
id|hostno
comma
id|target
)paren
suffix:semicolon
id|print_command
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
r_switch
c_cond
(paren
id|reselect
)paren
(brace
r_case
id|RECONNECT_NOW
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : reconnecting&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef LINKED
r_case
id|LINKED_RIGHT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : connected, can reconnect&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LINKED_WRONG
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : connected to wrong target, can reconnect&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|CAN_RECONNECT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : allowed to reconnect&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : not allowed to reconnect&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|target
op_eq
(paren
id|controller_type
op_eq
id|SEAGATE
ques
c_cond
l_int|7
suffix:colon
l_int|6
)paren
)paren
r_return
id|DID_BAD_TARGET
suffix:semicolon
multiline_comment|/*&n; *&t;We work it differently depending on if this is is &quot;the first time,&quot;&n; *&t;or a reconnect.  If this is a reselect phase, then SEL will &n; *&t;be asserted, and we must skip selection / arbitration phases.&n; */
r_switch
c_cond
(paren
id|reselect
)paren
(brace
r_case
id|RECONNECT_NOW
suffix:colon
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase RESELECT &bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;At this point, we should find the logical or of our ID and the original&n; *&t;target&squot;s ID on the BUS, with BSY, SEL, and I/O signals asserted.&n; *&n; *&t;After ARBITRATION phase is completed, only SEL, BSY, and the &n; *&t;target ID are asserted.  A valid initiator ID is not on the bus&n; *&t;until IO is asserted, so we must wait for that.&n; */
id|clock
op_assign
id|jiffies
op_plus
l_int|10
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|temp
op_assign
id|STATUS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp
op_amp
id|STAT_IO
)paren
op_logical_and
op_logical_neg
(paren
id|temp
op_amp
id|STAT_BSY
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
OG
id|clock
)paren
(brace
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : RESELECT timed out while waiting for IO .&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|DID_BAD_INTR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * &t;After I/O is asserted by the target, we can read our ID and its&n; *&t;ID off of the BUS.&n; */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|temp
op_assign
id|DATA
)paren
op_amp
(paren
id|controller_type
op_eq
id|SEAGATE
ques
c_cond
l_int|0x80
suffix:colon
l_int|0x40
)paren
)paren
)paren
(brace
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : detected reconnect request to different target.&bslash;n&quot;
l_string|&quot;&bslash;tData bus = %d&bslash;n&quot;
comma
id|hostno
comma
id|temp
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|DID_BAD_INTR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|temp
op_amp
(paren
l_int|1
op_lshift
id|current_target
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : Unexpected reselect interrupt.  Data bus = %d&bslash;n&quot;
comma
id|hostno
comma
id|temp
)paren
suffix:semicolon
r_return
(paren
id|DID_BAD_INTR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
id|buffer
op_assign
id|current_buffer
suffix:semicolon
id|cmnd
op_assign
id|current_cmnd
suffix:semicolon
multiline_comment|/* WDE add */
id|data
op_assign
id|current_data
suffix:semicolon
multiline_comment|/* WDE add */
id|len
op_assign
id|current_bufflen
suffix:semicolon
multiline_comment|/* WDE add */
id|nobuffs
op_assign
id|current_nobuffs
suffix:semicolon
multiline_comment|/*&n; * &t;We have determined that we have been selected.  At this point, &n; *&t;we must respond to the reselection by asserting BSY ourselves&n; */
macro_line|#if 1
id|CONTROL
op_assign
(paren
id|BASE_CMD
op_or
id|CMD_DRVR_ENABLE
op_or
id|CMD_BSY
)paren
suffix:semicolon
macro_line|#else
id|CONTROL
op_assign
(paren
id|BASE_CMD
op_or
id|CMD_BSY
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;The target will drop SEL, and raise BSY, at which time we must drop&n; *&t;BSY.&n; */
r_for
c_loop
(paren
id|clock
op_assign
id|jiffies
op_plus
l_int|10
suffix:semicolon
(paren
id|jiffies
OL
id|clock
)paren
op_logical_and
(paren
id|STATUS
op_amp
id|STAT_SEL
)paren
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
op_ge
id|clock
)paren
(brace
id|CONTROL
op_assign
(paren
id|BASE_CMD
op_or
id|CMD_INTR
)paren
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : RESELECT timed out while waiting for SEL.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|DID_BAD_INTR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
id|CONTROL
op_assign
id|BASE_CMD
suffix:semicolon
multiline_comment|/*&n; *&t;At this point, we have connected with the target and can get &n; *&t;on with our lives.&n; */
r_break
suffix:semicolon
r_case
id|CAN_RECONNECT
suffix:colon
macro_line|#ifdef LINKED
multiline_comment|/*&n; * This is a bletcherous hack, just as bad as the Unix #! interpreter stuff.&n; * If it turns out we are using the wrong I_T_L nexus, the easiest way to deal&n; * with it is to go into our INFORMATION TRANSFER PHASE code, send a ABORT &n; * message on MESSAGE OUT phase, and then loop back to here.&n; */
id|connect_loop
suffix:colon
macro_line|#endif
macro_line|#if (DEBUG &amp; PHASE_BUS_FREE)
id|printk
(paren
l_string|&quot;scsi%d : phase = BUS FREE &bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;BUS FREE PHASE&n; *&n; * &t;On entry, we make sure that the BUS is in a BUS FREE&n; *&t;phase, by insuring that both BSY and SEL are low for&n; *&t;at least one bus settle delay.  Several reads help&n; *&t;eliminate wire glitch.&n; */
id|clock
op_assign
id|jiffies
op_plus
id|ST0X_BUS_FREE_DELAY
suffix:semicolon
macro_line|#if !defined (ARBITRATE) 
r_while
c_loop
(paren
(paren
(paren
id|STATUS
op_or
id|STATUS
op_or
id|STATUS
)paren
op_amp
(paren
id|STAT_BSY
op_or
id|STAT_SEL
)paren
)paren
op_logical_and
(paren
op_logical_neg
id|st0x_aborted
)paren
op_logical_and
(paren
id|jiffies
OL
id|clock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
OG
id|clock
)paren
r_return
id|retcode
c_func
(paren
id|DID_BUS_BUSY
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|st0x_aborted
)paren
r_return
id|retcode
c_func
(paren
id|st0x_aborted
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if (DEBUG &amp; PHASE_SELECTION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = SELECTION&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
id|clock
op_assign
id|jiffies
op_plus
id|ST0X_SELECTION_DELAY
suffix:semicolon
multiline_comment|/*&n; * Arbitration/selection procedure : &n; * 1.  Disable drivers&n; * 2.  Write HOST adapter address bit&n; * 3.  Set start arbitration.&n; * 4.  We get either ARBITRATION COMPLETE or SELECT at this&n; *     point.&n; * 5.  OR our ID and targets on bus.&n; * 6.  Enable SCSI drivers and asserted SEL and ATTN&n; */
macro_line|#if defined(ARBITRATE)&t;
id|cli
c_func
(paren
)paren
suffix:semicolon
id|CONTROL
op_assign
l_int|0
suffix:semicolon
id|DATA
op_assign
(paren
id|controller_type
op_eq
id|SEAGATE
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0x40
suffix:semicolon
id|CONTROL
op_assign
id|CMD_START_ARB
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|status_read
op_assign
id|STATUS
)paren
op_amp
(paren
id|STAT_ARB_CMPL
op_or
id|STAT_SEL
)paren
)paren
op_logical_and
(paren
id|jiffies
OL
id|clock
)paren
op_logical_and
op_logical_neg
id|st0x_aborted
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status_read
op_amp
id|STAT_ARB_CMPL
)paren
)paren
(brace
macro_line|#if (DEBUG &amp; PHASE_SELECTION)
r_if
c_cond
(paren
id|status_read
op_amp
id|STAT_SEL
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : arbitration lost&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;scsi%d : arbitration timeout.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
id|CONTROL
op_assign
id|BASE_CMD
suffix:semicolon
r_return
id|retcode
c_func
(paren
id|DID_NO_CONNECT
)paren
suffix:semicolon
)brace
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_SELECTION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : arbitration complete&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n; *&t;When the SCSI device decides that we&squot;re gawking at it, it will &n; *&t;respond by asserting BUSY on the bus.&n; *&n; * &t;Note : the Seagate ST-01/02 product manual says that we should &n; * &t;twiddle the DATA register before the control register.  However,&n; *&t;this does not work reliably so we do it the other way around.&n; *&n; *&t;Probably could be a problem with arbitration too, we really should&n; *&t;try this with a SCSI protocol or logic analyzer to see what is &n; *&t;going on.&n; */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|DATA
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
l_int|1
op_lshift
id|target
)paren
op_or
(paren
id|controller_type
op_eq
id|SEAGATE
ques
c_cond
l_int|0x80
suffix:colon
l_int|0x40
)paren
)paren
suffix:semicolon
id|CONTROL
op_assign
id|BASE_CMD
op_or
id|CMD_DRVR_ENABLE
op_or
id|CMD_SEL
op_or
(paren
id|reselect
ques
c_cond
id|CMD_ATTN
suffix:colon
l_int|0
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|status_read
op_assign
id|STATUS
)paren
op_amp
id|STAT_BSY
)paren
op_logical_and
(paren
id|jiffies
OL
id|clock
)paren
op_logical_and
op_logical_neg
id|st0x_aborted
)paren
macro_line|#if 0 &amp;&amp; (DEBUG &amp; PHASE_SELECTION)
(brace
id|temp
op_assign
id|clock
op_minus
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|jiffies
op_mod
l_int|5
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;seagate_st0x_timeout : %d            &bslash;r&quot;
comma
id|temp
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Done.                                             &bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : status = %02x, seagate_st0x_timeout = %d, aborted = %02x &bslash;n&quot;
comma
id|hostno
comma
id|status_read
comma
id|temp
comma
id|st0x_aborted
)paren
suffix:semicolon
macro_line|#else
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|jiffies
op_ge
id|clock
)paren
op_logical_and
op_logical_neg
(paren
id|status_read
op_amp
id|STAT_BSY
)paren
)paren
(brace
macro_line|#if (DEBUG &amp; PHASE_SELECTION)
id|printk
(paren
l_string|&quot;scsi%d : NO CONNECT with target %d, status = %x &bslash;n&quot;
comma
id|hostno
comma
id|target
comma
id|STATUS
)paren
suffix:semicolon
macro_line|#endif
r_return
id|retcode
c_func
(paren
id|DID_NO_CONNECT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;If we have been aborted, and we have a command in progress, IE the &n; *&t;target still has BSY asserted, then we will reset the bus, and &n; * &t;notify the midlevel driver to expect sense.&n; */
r_if
c_cond
(paren
id|st0x_aborted
)paren
(brace
id|CONTROL
op_assign
id|BASE_CMD
suffix:semicolon
r_if
c_cond
(paren
id|STATUS
op_amp
id|STAT_BSY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : BST asserted after we&squot;ve been aborted.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|seagate_st0x_reset
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_return
id|retcode
c_func
(paren
id|DID_RESET
)paren
suffix:semicolon
)brace
r_return
id|retcode
c_func
(paren
id|st0x_aborted
)paren
suffix:semicolon
)brace
multiline_comment|/* Establish current pointers.  Take into account scatter / gather */
r_if
c_cond
(paren
(paren
id|nobuffs
op_assign
id|SCint-&gt;use_sg
)paren
)paren
(brace
macro_line|#if (DEBUG &amp; DEBUG_SG)
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : scatter gather requested, using %d buffers.&bslash;n&quot;
comma
id|hostno
comma
id|nobuffs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nobuffs
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d : buffer %d address = %08x length = %d&bslash;n&quot;
comma
id|hostno
comma
id|i
comma
id|buffer
(braket
id|i
)braket
dot
id|address
comma
id|buffer
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
)brace
macro_line|#endif
id|buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCint-&gt;buffer
suffix:semicolon
id|len
op_assign
id|buffer-&gt;length
suffix:semicolon
id|data
op_assign
(paren
r_int
r_char
op_star
)paren
id|buffer-&gt;address
suffix:semicolon
)brace
r_else
(brace
macro_line|#if (DEBUG &amp; DEBUG_SG)
id|printk
c_func
(paren
l_string|&quot;scsi%d : scatter gather not requested.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
id|buffer
op_assign
l_int|NULL
suffix:semicolon
id|len
op_assign
id|SCint-&gt;request_bufflen
suffix:semicolon
id|data
op_assign
(paren
r_int
r_char
op_star
)paren
id|SCint-&gt;request_buffer
suffix:semicolon
)brace
macro_line|#if (DEBUG &amp; (PHASE_DATAIN | PHASE_DATAOUT))
id|printk
c_func
(paren
l_string|&quot;scsi%d : len = %d&bslash;n&quot;
comma
id|hostno
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
macro_line|#ifdef LINKED
r_case
id|LINKED_RIGHT
suffix:colon
r_break
suffix:semicolon
r_case
id|LINKED_WRONG
suffix:colon
r_break
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * &t;There are several conditions under which we wish to send a message : &n; *&t;1.  When we are allowing disconnect / reconnect, and need to establish&n; *&t;    the I_T_L nexus via an IDENTIFY with the DiscPriv bit set.&n; *&n; *&t;2.  When we are doing linked commands, are have the wrong I_T_L nexus&n; *&t;    established and want to send an ABORT message.&n; */
id|CONTROL
op_assign
id|BASE_CMD
op_or
id|CMD_DRVR_ENABLE
op_or
(paren
(paren
(paren
id|reselect
op_eq
id|CAN_RECONNECT
)paren
macro_line|#ifdef LINKED 
op_logical_or
(paren
id|reselect
op_eq
id|LINKED_WRONG
)paren
macro_line|#endif 
)paren
ques
c_cond
id|CMD_ATTN
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n; * &t;INFORMATION TRANSFER PHASE&n; *&n; *&t;The nasty looking read / write inline assembler loops we use for &n; *&t;DATAIN and DATAOUT phases are approximately 4-5 times as fast as &n; *&t;the &squot;C&squot; versions - since we&squot;re moving 1024 bytes of data, this&n; *&t;really adds up.&n; */
macro_line|#if ((DEBUG &amp; PHASE_ETC) == PHASE_ETC)
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = INFORMATION TRANSFER&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif  
id|incommand
op_assign
l_int|1
suffix:semicolon
id|transfersize
op_assign
id|SCint-&gt;transfersize
suffix:semicolon
id|underflow
op_assign
id|SCint-&gt;underflow
suffix:semicolon
multiline_comment|/*&n; * &t;Now, we poll the device for status information,&n; *&t;and handle any requests it makes.  Note that since we are unsure of &n; *&t;how much data will be flowing across the system, etc and cannot &n; *&t;make reasonable timeouts, that we will instead have the midlevel&n; * &t;driver handle any timeouts that occur in this phase.&n; */
r_while
c_loop
(paren
(paren
(paren
id|status_read
op_assign
id|STATUS
)paren
op_amp
id|STAT_BSY
)paren
op_logical_and
op_logical_neg
id|st0x_aborted
op_logical_and
op_logical_neg
id|done
)paren
(brace
macro_line|#ifdef PARITY
r_if
c_cond
(paren
id|status_read
op_amp
id|STAT_PARITY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : got parity error&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_PARITY
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|status_read
op_amp
id|STAT_REQ
)paren
(brace
macro_line|#if ((DEBUG &amp; PHASE_ETC) == PHASE_ETC)
r_if
c_cond
(paren
(paren
id|newphase
op_assign
(paren
id|status_read
op_amp
id|REQ_MASK
)paren
)paren
op_ne
id|phase
)paren
(brace
id|phase
op_assign
id|newphase
suffix:semicolon
r_switch
c_cond
(paren
id|phase
)paren
(brace
r_case
id|REQ_DATAOUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = DATA OUT&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_DATAIN
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = DATA IN&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_CMDOUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = COMMAND OUT&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_STATIN
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = STATUS IN&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_MSGOUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = MESSAGE OUT&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_MSGIN
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = MESSAGE IN&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = UNKNOWN&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_ERROR
suffix:semicolon
)brace
)brace
macro_line|#endif
r_switch
c_cond
(paren
id|status_read
op_amp
id|REQ_MASK
)paren
(brace
r_case
id|REQ_DATAOUT
suffix:colon
multiline_comment|/*&n; * If we are in fast mode, then we simply splat the data out&n; * in word-sized chunks as fast as we can.&n; */
macro_line|#ifdef FAST 
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
(brace
macro_line|#if 0 
id|printk
c_func
(paren
l_string|&quot;scsi%d: underflow to target %d lun %d &bslash;n&quot;
comma
id|hostno
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_ERROR
suffix:semicolon
id|fast
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fast
op_logical_and
id|transfersize
op_logical_and
op_logical_neg
(paren
id|len
op_mod
id|transfersize
)paren
op_logical_and
(paren
id|len
op_ge
id|transfersize
)paren
macro_line|#ifdef FAST32
op_logical_and
op_logical_neg
(paren
id|transfersize
op_mod
l_int|4
)paren
macro_line|#endif
)paren
(brace
macro_line|#if (DEBUG &amp; DEBUG_FAST) 
id|printk
c_func
(paren
l_string|&quot;scsi%d : FAST transfer, underflow = %d, transfersize = %d&bslash;n&quot;
l_string|&quot;         len = %d, data = %08x&bslash;n&quot;
comma
id|hostno
comma
id|SCint-&gt;underflow
comma
id|SCint-&gt;transfersize
comma
id|len
comma
id|data
)paren
suffix:semicolon
macro_line|#endif
id|__asm__
c_func
(paren
"&quot;"
id|cld
suffix:semicolon
"&quot;"
macro_line|#ifdef FAST32
"&quot;"
id|shr
"$"
l_int|2
comma
op_mod
op_mod
id|ecx
suffix:semicolon
l_int|1
suffix:colon
id|lodsl
suffix:semicolon
id|movl
op_mod
op_mod
id|eax
comma
(paren
op_mod
op_mod
id|edi
)paren
suffix:semicolon
"&quot;"
macro_line|#else
"&quot;"
l_int|1
suffix:colon
id|lodsb
suffix:semicolon
id|movb
op_mod
op_mod
id|al
comma
(paren
op_mod
op_mod
id|edi
)paren
suffix:semicolon
"&quot;"
macro_line|#endif
l_string|&quot;&t;loop 1b;&quot;
suffix:colon
suffix:colon
multiline_comment|/* input */
l_string|&quot;D&quot;
(paren
id|st0x_dr
)paren
comma
l_string|&quot;S&quot;
(paren
id|data
)paren
comma
l_string|&quot;c&quot;
(paren
id|SCint-&gt;transfersize
)paren
suffix:colon
multiline_comment|/* clobbered */
l_string|&quot;eax&quot;
comma
l_string|&quot;ecx&quot;
comma
l_string|&quot;esi&quot;
)paren
suffix:semicolon
id|len
op_sub_assign
id|transfersize
suffix:semicolon
id|data
op_add_assign
id|transfersize
suffix:semicolon
macro_line|#if (DEBUG &amp; DEBUG_FAST)
id|printk
c_func
(paren
l_string|&quot;scsi%d : FAST transfer complete len = %d data = %08x&bslash;n&quot;
comma
id|hostno
comma
id|len
comma
id|data
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
macro_line|#endif
(brace
multiline_comment|/*&n; * &t;We loop as long as we are in a data out phase, there is data to send, &n; *&t;and BSY is still active.&n; */
id|__asm__
(paren
multiline_comment|/*&n;&t;Local variables : &n;&t;len = ecx&n;&t;data = esi&n;&t;st0x_cr_sr = ebx&n;&t;st0x_dr =  edi&n;&n;&t;Test for any data here at all.&n;*/
"&quot;&bslash;"
id|torl
op_mod
op_mod
id|ecx
comma
op_mod
op_mod
id|ecx
id|jz
l_float|2f
id|cld
id|movl
id|_st0x_cr_sr
comma
op_mod
op_mod
id|ebx
id|movl
id|_st0x_dr
comma
op_mod
op_mod
id|edi
l_int|1
suffix:colon
id|movb
(paren
op_mod
op_mod
id|ebx
)paren
comma
op_mod
op_mod
id|al
"&bslash;"
id|n
"&quot;"
multiline_comment|/*&n;&t;Test for BSY&n;*/
"&quot;&bslash;"
id|ttest
"$"
l_int|1
comma
op_mod
op_mod
id|al
id|jz
l_float|2f
"&bslash;"
id|n
"&quot;"
multiline_comment|/*&n;&t;Test for data out phase - STATUS &amp; REQ_MASK should be REQ_DATAOUT, which is 0.&n;*/
"&quot;&bslash;"
id|ttest
"$"
l_int|0xe
comma
op_mod
op_mod
id|al
id|jnz
l_float|2f
"&bslash;"
id|n
"&quot;"
multiline_comment|/*&n;&t;Test for REQ&n;*/
"&quot;&bslash;"
id|ttest
"$"
l_int|0x10
comma
op_mod
op_mod
id|al
id|jz
l_int|1
id|b
id|lodsb
id|movb
op_mod
op_mod
id|al
comma
(paren
op_mod
op_mod
id|edi
)paren
id|loop
l_int|1
id|b
l_int|2
suffix:colon
"&quot;"
suffix:colon
multiline_comment|/* output */
l_string|&quot;=S&quot;
(paren
id|data
)paren
comma
l_string|&quot;=c&quot;
(paren
id|len
)paren
suffix:colon
multiline_comment|/* input */
l_string|&quot;0&quot;
(paren
id|data
)paren
comma
l_string|&quot;1&quot;
(paren
id|len
)paren
suffix:colon
multiline_comment|/* clobbered */
l_string|&quot;eax&quot;
comma
l_string|&quot;ebx&quot;
comma
l_string|&quot;edi&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_and
id|nobuffs
)paren
(brace
op_decrement
id|nobuffs
suffix:semicolon
op_increment
id|buffer
suffix:semicolon
id|len
op_assign
id|buffer-&gt;length
suffix:semicolon
id|data
op_assign
(paren
r_int
r_char
op_star
)paren
id|buffer-&gt;address
suffix:semicolon
macro_line|#if (DEBUG &amp; DEBUG_SG)
id|printk
c_func
(paren
l_string|&quot;scsi%d : next scatter-gather buffer len = %d address = %08x&bslash;n&quot;
comma
id|hostno
comma
id|len
comma
id|data
)paren
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
r_case
id|REQ_DATAIN
suffix:colon
macro_line|#ifdef SLOW_HANDSHAKE
r_if
c_cond
(paren
id|borken
)paren
(brace
macro_line|#if (DEBUG &amp; (PHASE_DATAIN))
id|transfered
op_add_assign
id|len
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
suffix:semicolon
id|len
op_logical_and
(paren
id|STATUS
op_amp
(paren
id|REQ_MASK
op_or
id|STAT_REQ
)paren
)paren
op_eq
(paren
id|REQ_DATAIN
op_or
id|STAT_REQ
)paren
suffix:semicolon
op_decrement
id|len
)paren
(brace
op_star
id|data
op_increment
op_assign
id|DATA
suffix:semicolon
id|borken_wait
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#if (DEBUG &amp; (PHASE_DATAIN))
id|transfered
op_sub_assign
id|len
suffix:semicolon
macro_line|#endif
)brace
r_else
macro_line|#endif
macro_line|#ifdef FAST
r_if
c_cond
(paren
id|fast
op_logical_and
id|transfersize
op_logical_and
op_logical_neg
(paren
id|len
op_mod
id|transfersize
)paren
op_logical_and
(paren
id|len
op_ge
id|transfersize
)paren
macro_line|#ifdef FAST32
op_logical_and
op_logical_neg
(paren
id|transfersize
op_mod
l_int|4
)paren
macro_line|#endif
)paren
(brace
macro_line|#if (DEBUG &amp; DEBUG_FAST) 
id|printk
c_func
(paren
l_string|&quot;scsi%d : FAST transfer, underflow = %d, transfersize = %d&bslash;n&quot;
l_string|&quot;         len = %d, data = %08x&bslash;n&quot;
comma
id|hostno
comma
id|SCint-&gt;underflow
comma
id|SCint-&gt;transfersize
comma
id|len
comma
id|data
)paren
suffix:semicolon
macro_line|#endif
id|__asm__
c_func
(paren
"&quot;"
id|cld
suffix:semicolon
"&quot;"
macro_line|#ifdef FAST32
"&quot;"
id|shr
"$"
l_int|2
comma
op_mod
op_mod
id|ecx
suffix:semicolon
l_int|1
suffix:colon
id|movl
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
suffix:semicolon
id|stosl
suffix:semicolon
"&quot;"
macro_line|#else
"&quot;"
l_int|1
suffix:colon
id|movb
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|al
suffix:semicolon
id|stosb
suffix:semicolon
"&quot;"
macro_line|#endif
l_string|&quot;&t;loop 1b;&quot;
suffix:colon
suffix:colon
multiline_comment|/* input */
l_string|&quot;S&quot;
(paren
id|st0x_dr
)paren
comma
l_string|&quot;D&quot;
(paren
id|data
)paren
comma
l_string|&quot;c&quot;
(paren
id|SCint-&gt;transfersize
)paren
suffix:colon
multiline_comment|/* clobbered */
l_string|&quot;eax&quot;
comma
l_string|&quot;ecx&quot;
comma
l_string|&quot;edi&quot;
)paren
suffix:semicolon
id|len
op_sub_assign
id|transfersize
suffix:semicolon
id|data
op_add_assign
id|transfersize
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_DATAIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d: transfered += %d&bslash;n&quot;
comma
id|hostno
comma
id|transfersize
)paren
suffix:semicolon
id|transfered
op_add_assign
id|transfersize
suffix:semicolon
macro_line|#endif
macro_line|#if (DEBUG &amp; DEBUG_FAST)
id|printk
c_func
(paren
l_string|&quot;scsi%d : FAST transfer complete len = %d data = %08x&bslash;n&quot;
comma
id|hostno
comma
id|len
comma
id|data
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
macro_line|#endif
(brace
macro_line|#if (DEBUG &amp; PHASE_DATAIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d: transfered += %d&bslash;n&quot;
comma
id|hostno
comma
id|len
)paren
suffix:semicolon
id|transfered
op_add_assign
id|len
suffix:semicolon
multiline_comment|/* Assume we&squot;ll transfer it all, then&n;&t;&t;&t;&t;   subtract what we *didn&squot;t* transfer */
macro_line|#endif
multiline_comment|/*&n; * &t;We loop as long as we are in a data in phase, there is room to read, &n; * &t;and BSY is still active&n; */
id|__asm__
(paren
multiline_comment|/*&n;&t;Local variables : &n;&t;ecx = len&n;&t;edi = data&n;&t;esi = st0x_cr_sr&n;&t;ebx = st0x_dr&n;&n;&t;Test for room to read&n;*/
"&quot;&bslash;"
id|torl
op_mod
op_mod
id|ecx
comma
op_mod
op_mod
id|ecx
id|jz
l_float|2f
id|cld
id|movl
id|_st0x_cr_sr
comma
op_mod
op_mod
id|esi
id|movl
id|_st0x_dr
comma
op_mod
op_mod
id|ebx
l_int|1
suffix:colon
id|movb
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|al
"&bslash;"
id|n
"&quot;"
multiline_comment|/*&n;&t;Test for BSY&n;*/
"&quot;&bslash;"
id|ttest
"$"
l_int|1
comma
op_mod
op_mod
id|al
id|jz
l_float|2f
"&bslash;"
id|n
"&quot;"
multiline_comment|/*&n;&t;Test for data in phase - STATUS &amp; REQ_MASK should be REQ_DATAIN, = STAT_IO, which is 4.&n;*/
"&quot;&bslash;"
id|tmovb
"$"
l_int|0xe
comma
op_mod
op_mod
id|ah
id|andb
op_mod
op_mod
id|al
comma
op_mod
op_mod
id|ah
id|cmpb
"$"
l_int|0x04
comma
op_mod
op_mod
id|ah
id|jne
l_float|2f
"&bslash;"
id|n
"&quot;"
multiline_comment|/*&n;&t;Test for REQ&n;*/
"&quot;&bslash;"
id|ttest
"$"
l_int|0x10
comma
op_mod
op_mod
id|al
id|jz
l_int|1
id|b
id|movb
(paren
op_mod
op_mod
id|ebx
)paren
comma
op_mod
op_mod
id|al
id|stosb
id|loop
l_int|1
id|b
"&bslash;"
id|n
"&quot;"
l_string|&quot;2:&bslash;n&quot;
suffix:colon
multiline_comment|/* output */
l_string|&quot;=D&quot;
(paren
id|data
)paren
comma
l_string|&quot;=c&quot;
(paren
id|len
)paren
suffix:colon
multiline_comment|/* input */
l_string|&quot;0&quot;
(paren
id|data
)paren
comma
l_string|&quot;1&quot;
(paren
id|len
)paren
suffix:colon
multiline_comment|/* clobbered */
l_string|&quot;eax&quot;
comma
l_string|&quot;ebx&quot;
comma
l_string|&quot;esi&quot;
)paren
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_DATAIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d: transfered -= %d&bslash;n&quot;
comma
id|hostno
comma
id|len
)paren
suffix:semicolon
id|transfered
op_sub_assign
id|len
suffix:semicolon
multiline_comment|/* Since we assumed all of Len got &n;&t;&t;&t;&t;&t; * transfered, correct our mistake */
macro_line|#endif
)brace
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_and
id|nobuffs
)paren
(brace
op_decrement
id|nobuffs
suffix:semicolon
op_increment
id|buffer
suffix:semicolon
id|len
op_assign
id|buffer-&gt;length
suffix:semicolon
id|data
op_assign
(paren
r_int
r_char
op_star
)paren
id|buffer-&gt;address
suffix:semicolon
macro_line|#if (DEBUG &amp; DEBUG_SG)
id|printk
c_func
(paren
l_string|&quot;scsi%d : next scatter-gather buffer len = %d address = %08x&bslash;n&quot;
comma
id|hostno
comma
id|len
comma
id|data
)paren
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
r_case
id|REQ_CMDOUT
suffix:colon
r_while
c_loop
(paren
(paren
(paren
id|status_read
op_assign
id|STATUS
)paren
op_amp
id|STAT_BSY
)paren
op_logical_and
(paren
(paren
id|status_read
op_amp
id|REQ_MASK
)paren
op_eq
id|REQ_CMDOUT
)paren
)paren
r_if
c_cond
(paren
id|status_read
op_amp
id|STAT_REQ
)paren
(brace
id|DATA
op_assign
op_star
(paren
r_int
r_char
op_star
)paren
id|cmnd
suffix:semicolon
id|cmnd
op_assign
l_int|1
op_plus
(paren
r_int
r_char
op_star
)paren
id|cmnd
suffix:semicolon
macro_line|#ifdef SLOW_HANDSHAKE
r_if
c_cond
(paren
id|borken
)paren
id|borken_wait
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
r_case
id|REQ_STATIN
suffix:colon
id|status
op_assign
id|DATA
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_MSGOUT
suffix:colon
multiline_comment|/*&n; *&t;We can only have sent a MSG OUT if we requested to do this &n; *&t;by raising ATTN.  So, we must drop ATTN.&n; */
id|CONTROL
op_assign
id|BASE_CMD
op_or
id|CMD_DRVR_ENABLE
suffix:semicolon
multiline_comment|/*&n; * &t;If we are reconnecting, then we must send an IDENTIFY message in &n; *&t; response  to MSGOUT.&n; */
r_switch
c_cond
(paren
id|reselect
)paren
(brace
r_case
id|CAN_RECONNECT
suffix:colon
id|DATA
op_assign
id|IDENTIFY
c_func
(paren
l_int|1
comma
id|lun
)paren
suffix:semicolon
macro_line|#if (DEBUG &amp; (PHASE_RESELECT | PHASE_MSGOUT)) 
id|printk
c_func
(paren
l_string|&quot;scsi%d : sent IDENTIFY message.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
macro_line|#ifdef LINKED
r_case
id|LINKED_WRONG
suffix:colon
id|DATA
op_assign
id|ABORT
suffix:semicolon
id|linked_connected
op_assign
l_int|0
suffix:semicolon
id|reselect
op_assign
id|CAN_RECONNECT
suffix:semicolon
r_goto
id|connect_loop
suffix:semicolon
macro_line|#if (DEBUG &amp; (PHASE_MSGOUT | DEBUG_LINKED))
id|printk
c_func
(paren
l_string|&quot;scsi%d : sent ABORT message to cancel incorrect I_T_L nexus.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif /* LINKED */
macro_line|#if (DEBUG &amp; DEBUG_LINKED) 
id|printk
c_func
(paren
l_string|&quot;correct&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|DATA
op_assign
id|NOP
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : target %d requested MSGOUT, sent NOP message.&bslash;n&quot;
comma
id|hostno
comma
id|target
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|REQ_MSGIN
suffix:colon
r_switch
c_cond
(paren
id|message
op_assign
id|DATA
)paren
(brace
r_case
id|DISCONNECT
suffix:colon
id|should_reconnect
op_assign
l_int|1
suffix:semicolon
id|current_data
op_assign
id|data
suffix:semicolon
multiline_comment|/* WDE add */
id|current_buffer
op_assign
id|buffer
suffix:semicolon
id|current_bufflen
op_assign
id|len
suffix:semicolon
multiline_comment|/* WDE add */
id|current_nobuffs
op_assign
id|nobuffs
suffix:semicolon
macro_line|#ifdef LINKED
id|linked_connected
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|done
op_assign
l_int|1
suffix:semicolon
macro_line|#if (DEBUG &amp; (PHASE_RESELECT | PHASE_MSGIN))
id|printk
c_func
(paren
l_string|&quot;scsi%d : disconnected.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
macro_line|#ifdef LINKED
r_case
id|LINKED_CMD_COMPLETE
suffix:colon
r_case
id|LINKED_FLG_CMD_COMPLETE
suffix:colon
macro_line|#endif
r_case
id|COMMAND_COMPLETE
suffix:colon
multiline_comment|/*&n; * Note : we should check for underflow here.   &n; */
macro_line|#if (DEBUG &amp; PHASE_MSGIN)&t;
id|printk
c_func
(paren
l_string|&quot;scsi%d : command complete.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ABORT
suffix:colon
macro_line|#if (DEBUG &amp; PHASE_MSGIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d : abort message.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SAVE_POINTERS
suffix:colon
id|current_buffer
op_assign
id|buffer
suffix:semicolon
id|current_bufflen
op_assign
id|len
suffix:semicolon
multiline_comment|/* WDE add */
id|current_data
op_assign
id|data
suffix:semicolon
multiline_comment|/* WDE mod */
id|current_nobuffs
op_assign
id|nobuffs
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_MSGIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d : pointers saved.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif 
r_break
suffix:semicolon
r_case
id|RESTORE_POINTERS
suffix:colon
id|buffer
op_assign
id|current_buffer
suffix:semicolon
id|cmnd
op_assign
id|current_cmnd
suffix:semicolon
id|data
op_assign
id|current_data
suffix:semicolon
multiline_comment|/* WDE mod */
id|len
op_assign
id|current_bufflen
suffix:semicolon
id|nobuffs
op_assign
id|current_nobuffs
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_MSGIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d : pointers restored.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n; * &t;IDENTIFY distinguishes itself from the other messages by setting the&n; *&t;high byte.&n; * &t;&n; *&t;Note : we need to handle at least one outstanding command per LUN,&n; *&t;and need to hash the SCSI command for that I_T_L nexus based on the &n; *&t;known ID (at this point) and LUN.&n; */
r_if
c_cond
(paren
id|message
op_amp
l_int|0x80
)paren
(brace
macro_line|#if (DEBUG &amp; PHASE_MSGIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d : IDENTIFY message received from id %d, lun %d.&bslash;n&quot;
comma
id|hostno
comma
id|target
comma
id|message
op_amp
l_int|7
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/*&n; *      We should go into a MESSAGE OUT phase, and send  a MESSAGE_REJECT &n; * &t;if we run into a message that we don&squot;t like.  The seagate driver &n; * &t;needs some serious restructuring first though.&n; */
macro_line|#if (DEBUG &amp; PHASE_MSGIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d : unknown message %d from target %d.&bslash;n&quot;
comma
id|hostno
comma
id|message
comma
id|target
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : unknown phase.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_ERROR
suffix:semicolon
)brace
macro_line|#ifdef SLOW_HANDSHAKE
multiline_comment|/*&n; * I really don&squot;t care to deal with borken devices in each single &n; * byte transfer case (ie, message in, message out, status), so&n; * I&squot;ll do the wait here if necessary.&n; */
r_if
c_cond
(paren
id|borken
)paren
id|borken_wait
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* if ends */
)brace
multiline_comment|/* while ends */
macro_line|#if (DEBUG &amp; (PHASE_DATAIN | PHASE_DATAOUT | PHASE_EXIT))
id|printk
c_func
(paren
l_string|&quot;scsi%d : Transfered %d bytes&bslash;n&quot;
comma
id|hostno
comma
id|transfered
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if (DEBUG &amp; PHASE_EXIT)
macro_line|#if 0&t;&t;/* Doesn&squot;t work for scatter / gather */
id|printk
c_func
(paren
l_string|&quot;Buffer : &bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
op_increment
id|i
)paren
id|printk
(paren
l_string|&quot;%02x  &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|data
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* WDE mod */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;scsi%d : status = &quot;
comma
id|hostno
)paren
suffix:semicolon
id|print_status
c_func
(paren
id|status
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;message = %02x&bslash;n&quot;
comma
id|message
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* We shouldn&squot;t reach this until *after* BSY has been deasserted */
macro_line|#ifdef notyet
r_if
c_cond
(paren
id|st0x_aborted
)paren
(brace
r_if
c_cond
(paren
id|STATUS
op_amp
id|STAT_BSY
)paren
(brace
id|seagate_st0x_reset
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_RESET
suffix:semicolon
)brace
id|abort_confirm
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef LINKED
r_else
(brace
multiline_comment|/*&n; * Fix the message byte so that unsuspecting high level drivers don&squot;t &n; * puke when they see a LINKED COMMAND message in place of the COMMAND &n; * COMPLETE they may be expecting.  Shouldn&squot;t be necessary, but it&squot;s &n; * better to be on the safe side. &n; *&n; * A non LINKED* message byte will indicate that the command completed, &n; * and we are now disconnected.&n; */
r_switch
c_cond
(paren
id|message
)paren
(brace
r_case
id|LINKED_CMD_COMPLETE
suffix:colon
r_case
id|LINKED_FLG_CMD_COMPLETE
suffix:colon
id|message
op_assign
id|COMMAND_COMPLETE
suffix:semicolon
id|linked_target
op_assign
id|current_target
suffix:semicolon
id|linked_lun
op_assign
id|current_lun
suffix:semicolon
id|linked_connected
op_assign
l_int|1
suffix:semicolon
macro_line|#if (DEBUG &amp; DEBUG_LINKED)
id|printk
c_func
(paren
l_string|&quot;scsi%d : keeping I_T_L nexus established for linked command.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * We also will need to adjust status to accommodate intermediate conditions.&n; */
r_if
c_cond
(paren
(paren
id|status
op_eq
id|INTERMEDIATE_GOOD
)paren
op_logical_or
(paren
id|status
op_eq
id|INTERMEDIATE_C_GOOD
)paren
)paren
id|status
op_assign
id|GOOD
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n; * We should also handle what are &quot;normal&quot; termination messages &n; * here (ABORT, BUS_DEVICE_RESET?, and COMMAND_COMPLETE individually, &n; * and flake if things aren&squot;t right.&n; */
r_default
suffix:colon
macro_line|#if (DEBUG &amp; DEBUG_LINKED)
id|printk
c_func
(paren
l_string|&quot;scsi%d : closing I_T_L nexus.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
id|linked_connected
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif /* LINKED */
r_if
c_cond
(paren
id|should_reconnect
)paren
(brace
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : exiting seagate_st0x_queue_command() with reconnect enabled.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
id|CONTROL
op_assign
id|BASE_CMD
op_or
id|CMD_INTR
suffix:semicolon
)brace
r_else
id|CONTROL
op_assign
id|BASE_CMD
suffix:semicolon
r_return
id|retcode
(paren
id|st0x_aborted
)paren
suffix:semicolon
)brace
DECL|function|seagate_st0x_abort
r_int
id|seagate_st0x_abort
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|st0x_aborted
op_assign
id|DID_ABORT
suffix:semicolon
r_return
id|SCSI_ABORT_PENDING
suffix:semicolon
)brace
multiline_comment|/*&n;&t;the seagate_st0x_reset function resets the SCSI bus&n;*/
DECL|function|seagate_st0x_reset
r_int
id|seagate_st0x_reset
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|clock
suffix:semicolon
multiline_comment|/*&n;&t;&t;No timeouts - this command is going to fail because &n;&t;&t;it was reset.&n;&t;*/
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;In seagate_st0x_reset()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* assert  RESET signal on SCSI bus.  */
id|CONTROL
op_assign
id|BASE_CMD
op_or
id|CMD_RST
suffix:semicolon
id|clock
op_assign
id|jiffies
op_plus
l_int|2
suffix:semicolon
multiline_comment|/* Wait.  */
r_while
c_loop
(paren
id|jiffies
OL
id|clock
)paren
suffix:semicolon
id|CONTROL
op_assign
id|BASE_CMD
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_RESET
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SCSI bus reset.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|SCSI_RESET_WAKEUP
suffix:semicolon
)brace
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &quot;scsi_ioctl.h&quot;
DECL|function|seagate_st0x_biosparam
r_int
id|seagate_st0x_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
r_int
id|dev
comma
r_int
op_star
id|ip
)paren
(brace
r_int
r_char
id|buf
(braket
l_int|256
op_plus
r_sizeof
(paren
r_int
)paren
op_star
l_int|2
)braket
comma
id|cmd
(braket
l_int|6
)braket
comma
op_star
id|data
comma
op_star
id|page
suffix:semicolon
r_int
op_star
id|sizes
comma
id|result
comma
id|formatted_sectors
comma
id|total_sectors
suffix:semicolon
r_int
id|cylinders
comma
id|heads
comma
id|sectors
suffix:semicolon
multiline_comment|/*&n; * Only SCSI-I CCS drives and later implement the necessary mode sense &n; * pages.  &n; */
r_if
c_cond
(paren
id|disk-&gt;device-&gt;scsi_level
OL
l_int|2
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|sizes
op_assign
(paren
r_int
op_star
)paren
id|buf
suffix:semicolon
id|data
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|sizes
op_plus
l_int|2
)paren
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
(paren
id|disk-&gt;device-&gt;lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe5
suffix:semicolon
id|cmd
(braket
l_int|2
)braket
op_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* Read page 4, rigid disk geometry page current values */
id|cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd
(braket
l_int|4
)braket
op_assign
l_int|255
suffix:semicolon
id|cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * We are transferring 0 bytes in the out direction, and expect to get back&n; * 24 bytes for each mode page.&n; */
id|sizes
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|sizes
(braket
l_int|1
)braket
op_assign
l_int|256
suffix:semicolon
id|memcpy
(paren
id|data
comma
id|cmd
comma
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|result
op_assign
id|kernel_scsi_ioctl
(paren
id|disk-&gt;device
comma
id|SCSI_IOCTL_SEND_COMMAND
comma
(paren
r_void
op_star
)paren
id|buf
)paren
)paren
)paren
(brace
multiline_comment|/*&n; * The mode page lies beyond the MODE SENSE header, with length 4, and &n; * the BLOCK DESCRIPTOR, with length header[3].&n; */
id|page
op_assign
id|data
op_plus
l_int|4
op_plus
id|data
(braket
l_int|3
)braket
suffix:semicolon
id|heads
op_assign
(paren
r_int
)paren
id|page
(braket
l_int|5
)braket
suffix:semicolon
id|cylinders
op_assign
(paren
id|page
(braket
l_int|2
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|page
(braket
l_int|3
)braket
op_lshift
l_int|8
)paren
op_or
id|page
(braket
l_int|4
)braket
suffix:semicolon
id|cmd
(braket
l_int|2
)braket
op_assign
l_int|0x03
suffix:semicolon
multiline_comment|/* Read page 3, format page current values */
id|memcpy
(paren
id|data
comma
id|cmd
comma
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|result
op_assign
id|kernel_scsi_ioctl
(paren
id|disk-&gt;device
comma
id|SCSI_IOCTL_SEND_COMMAND
comma
(paren
r_void
op_star
)paren
id|buf
)paren
)paren
)paren
(brace
id|page
op_assign
id|data
op_plus
l_int|4
op_plus
id|data
(braket
l_int|3
)braket
suffix:semicolon
id|sectors
op_assign
(paren
id|page
(braket
l_int|10
)braket
op_lshift
l_int|8
)paren
op_or
id|page
(braket
l_int|11
)braket
suffix:semicolon
multiline_comment|/*&n; * Get the total number of formatted sectors from the block descriptor, &n; * so we can tell how many are being used for alternates.  &n; */
id|formatted_sectors
op_assign
(paren
id|data
(braket
l_int|4
op_plus
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|data
(braket
l_int|4
op_plus
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
id|data
(braket
l_int|4
op_plus
l_int|3
)braket
suffix:semicolon
id|total_sectors
op_assign
(paren
id|heads
op_star
id|cylinders
op_star
id|sectors
)paren
suffix:semicolon
multiline_comment|/*&n; * Adjust the real geometry by subtracting &n; * (spare sectors / (heads * tracks)) cylinders from the number of cylinders.&n; *&n; * It appears that the CE cylinder CAN be a partial cylinder.&n; */
id|printk
c_func
(paren
l_string|&quot;scsi%d : heads = %d cylinders = %d sectors = %d total = %d formatted = %d&bslash;n&quot;
comma
id|hostno
comma
id|heads
comma
id|cylinders
comma
id|sectors
comma
id|total_sectors
comma
id|formatted_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|heads
op_logical_or
op_logical_neg
id|sectors
op_logical_or
op_logical_neg
id|cylinders
)paren
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|cylinders
op_sub_assign
(paren
(paren
id|total_sectors
op_minus
id|formatted_sectors
)paren
op_div
(paren
id|heads
op_star
id|sectors
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * Now, we need to do a sanity check on the geometry to see if it is &n; * BIOS compatible.  The maximum BIOS geometry is 1024 cylinders * &n; * 256 heads * 64 sectors. &n; */
r_if
c_cond
(paren
(paren
id|cylinders
OG
l_int|1024
)paren
op_logical_or
(paren
id|sectors
OG
l_int|64
)paren
)paren
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
(brace
id|ip
(braket
l_int|0
)braket
op_assign
id|heads
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
id|sectors
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
id|cylinders
suffix:semicolon
)brace
multiline_comment|/* &n; * There should be an alternate mapping for things the seagate doesn&squot;t&n; * understand, but I couldn&squot;t say what it is with reasonable certainty.&n; */
)brace
)brace
r_return
id|result
suffix:semicolon
)brace
eof
