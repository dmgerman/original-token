multiline_comment|/*&n; *    seagate.c Copyright (C) 1992, 1993 Drew Eckhardt&n; *      low level scsi driver for ST01/ST02, Future Domain TMC-885,&n; *      TMC-950 by Drew Eckhardt &lt;drew@colorado.edu&gt;&n; *&n; *      Note : TMC-880 boards don&squot;t work because they have two bits in&n; *              the status register flipped, I&squot;ll fix this &quot;RSN&quot;&n; *&t;[why do I have strong feeling that above message is from 1993? :-)&n; *&t;        pavel@ucw.cz]&n; *&n; *      This card does all the I/O via memory mapped I/O, so there is no need&n; *      to check or allocate a region of the I/O address space.&n; */
multiline_comment|/* 1996 - to use new read{b,w,l}, write{b,w,l}, and phys_to_virt&n; * macros, replaced assembler routines with C. There&squot;s probably a&n; * performance hit, but I only have a cdrom and can&squot;t tell. Define&n; * SEAGATE_USE_ASM if you want the old assembler code -- SJT&n; *&n; * 1998-jul-29 - created DPRINTK macros and made it work under &n; * linux 2.1.112, simplified some #defines etc. &lt;pavel@ucw.cz&gt;&n; *&n; * Aug 2000 - aeb - deleted seagate_st0x_biosparam(). It would try to&n; * read the physical disk geometry, a bad mistake. Of course it doesnt&n; * matter much what geometry one invents, but on large disks it&n; * returned 256 (or more) heads, causing all kind of failures.&n; * Of course this means that people might see a different geometry now,&n; * so boot parameters may be necessary in some cases.&n; */
multiline_comment|/*&n; * Configuration :&n; * To use without BIOS -DOVERRIDE=base_address -DCONTROLLER=FD or SEAGATE&n; * -DIRQ will override the default of 5.&n; * Note: You can now set these options from the kernel&squot;s &quot;command line&quot;.&n; * The syntax is:&n; *&n; *     st0x=ADDRESS,IRQ                (for a Seagate controller)&n; * or:&n; *     tmc8xx=ADDRESS,IRQ              (for a TMC-8xx or TMC-950 controller)&n; * eg:&n; *     tmc8xx=0xC8000,15&n; *&n; * will configure the driver for a TMC-8xx style controller using IRQ 15&n; * with a base address of 0xC8000.&n; *&n; * -DARBITRATE &n; *      Will cause the host adapter to arbitrate for the&n; *      bus for better SCSI-II compatibility, rather than just&n; *      waiting for BUS FREE and then doing its thing.  Should&n; *      let us do one command per Lun when I integrate my&n; *      reorganization changes into the distribution sources.&n; *&n; * -DDEBUG=65535&n; *      Will activate debug code.&n; *&n; * -DFAST or -DFAST32 &n; *      Will use blind transfers where possible&n; *&n; * -DPARITY  &n; *      This will enable parity.&n; *&n; * -DSEAGATE_USE_ASM&n; *      Will use older seagate assembly code. should be (very small amount)&n; *      Faster.&n; *&n; * -DSLOW_RATE=50&n; *      Will allow compatibility with broken devices that don&squot;t&n; *      handshake fast enough (ie, some CD ROM&squot;s) for the Seagate&n; *      code.&n; *&n; *      50 is some number, It will let you specify a default&n; *      transfer rate if handshaking isn&squot;t working correctly.&n; *&n; * -DOLDCNTDATASCEME  There is a new sceme to set the CONTROL&n; *                    and DATA reigsters which complies more closely&n; *                    with the SCSI2 standard. This hopefully eliminates&n; *                    the need to swap the order these registers are&n; *                    &squot;messed&squot; with. It makes the following two options&n; *                    obsolete. To reenable the old sceme define this.&n; *&n; * The following to options are patches from the SCSI.HOWTO&n; *&n; * -DSWAPSTAT  This will swap the definitions for STAT_MSG and STAT_CD.&n; *&n; * -DSWAPCNTDATA  This will swap the order that seagate.c messes with&n; *                the CONTROL an DATA registers.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;seagate.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &lt;scsi/scsi_ioctl.h&gt;
macro_line|#ifdef DEBUG
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK( when, msg... ) do { if ( (DEBUG &amp; (when)) == (when) ) printk( msg ); } while (0)
macro_line|#else
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK( when, msg... ) do { } while (0)
macro_line|#endif
DECL|macro|DANY
mdefine_line|#define DANY( msg... ) DPRINTK( 0xffff, msg );
macro_line|#ifndef IRQ
DECL|macro|IRQ
mdefine_line|#define IRQ 5
macro_line|#endif
macro_line|#ifdef FAST32
DECL|macro|FAST
mdefine_line|#define FAST
macro_line|#endif
DECL|macro|LINKED
macro_line|#undef LINKED&t;&t;/* Linked commands are currently broken! */
macro_line|#if defined(OVERRIDE) &amp;&amp; !defined(CONTROLLER)
macro_line|#error Please use -DCONTROLLER=SEAGATE or -DCONTROLLER=FD to override controller type
macro_line|#endif
multiline_comment|/*&n;&t;Thanks to Brian Antoine for the example code in his Messy-Loss ST-01&n;&t;&t;driver, and Mitsugu Suzuki for information on the ST-01&n;&t;&t;SCSI host.&n;*/
multiline_comment|/*&n;&t;CONTROL defines&n;*/
DECL|macro|CMD_RST
mdefine_line|#define CMD_RST &t;&t;0x01
DECL|macro|CMD_SEL
mdefine_line|#define CMD_SEL &t;&t;0x02
DECL|macro|CMD_BSY
mdefine_line|#define CMD_BSY &t;&t;0x04
DECL|macro|CMD_ATTN
mdefine_line|#define CMD_ATTN    &t;&t;0x08
DECL|macro|CMD_START_ARB
mdefine_line|#define CMD_START_ARB&t;&t;0x10
DECL|macro|CMD_EN_PARITY
mdefine_line|#define CMD_EN_PARITY&t;&t;0x20
DECL|macro|CMD_INTR
mdefine_line|#define CMD_INTR&t;&t;0x40
DECL|macro|CMD_DRVR_ENABLE
mdefine_line|#define CMD_DRVR_ENABLE&t;&t;0x80
multiline_comment|/*&n;&t;STATUS&n;*/
macro_line|#ifdef SWAPSTAT
DECL|macro|STAT_MSG
mdefine_line|#define STAT_MSG&t;&t;0x08
DECL|macro|STAT_CD
mdefine_line|#define STAT_CD&t;&t;&t;0x02
macro_line|#else
DECL|macro|STAT_MSG
mdefine_line|#define STAT_MSG&t;&t;0x02
DECL|macro|STAT_CD
mdefine_line|#define STAT_CD&t;&t;&t;0x08
macro_line|#endif
DECL|macro|STAT_BSY
mdefine_line|#define STAT_BSY&t;&t;0x01
DECL|macro|STAT_IO
mdefine_line|#define STAT_IO&t;&t;&t;0x04
DECL|macro|STAT_REQ
mdefine_line|#define STAT_REQ&t;&t;0x10
DECL|macro|STAT_SEL
mdefine_line|#define STAT_SEL&t;&t;0x20
DECL|macro|STAT_PARITY
mdefine_line|#define STAT_PARITY&t;&t;0x40
DECL|macro|STAT_ARB_CMPL
mdefine_line|#define STAT_ARB_CMPL&t;&t;0x80
multiline_comment|/* &n;&t;REQUESTS&n;*/
DECL|macro|REQ_MASK
mdefine_line|#define REQ_MASK (STAT_CD |  STAT_IO | STAT_MSG)
DECL|macro|REQ_DATAOUT
mdefine_line|#define REQ_DATAOUT 0
DECL|macro|REQ_DATAIN
mdefine_line|#define REQ_DATAIN STAT_IO
DECL|macro|REQ_CMDOUT
mdefine_line|#define REQ_CMDOUT STAT_CD
DECL|macro|REQ_STATIN
mdefine_line|#define REQ_STATIN (STAT_CD | STAT_IO)
DECL|macro|REQ_MSGOUT
mdefine_line|#define REQ_MSGOUT (STAT_MSG | STAT_CD)
DECL|macro|REQ_MSGIN
mdefine_line|#define REQ_MSGIN (STAT_MSG | STAT_CD | STAT_IO)
r_extern
r_volatile
r_int
id|seagate_st0x_timeout
suffix:semicolon
macro_line|#ifdef PARITY
DECL|macro|BASE_CMD
mdefine_line|#define BASE_CMD CMD_EN_PARITY
macro_line|#else
DECL|macro|BASE_CMD
mdefine_line|#define BASE_CMD  0
macro_line|#endif
multiline_comment|/*&n;&t;Debugging code&n;*/
DECL|macro|PHASE_BUS_FREE
mdefine_line|#define PHASE_BUS_FREE 1
DECL|macro|PHASE_ARBITRATION
mdefine_line|#define PHASE_ARBITRATION 2
DECL|macro|PHASE_SELECTION
mdefine_line|#define PHASE_SELECTION 4
DECL|macro|PHASE_DATAIN
mdefine_line|#define PHASE_DATAIN 8 
DECL|macro|PHASE_DATAOUT
mdefine_line|#define PHASE_DATAOUT 0x10
DECL|macro|PHASE_CMDOUT
mdefine_line|#define PHASE_CMDOUT 0x20
DECL|macro|PHASE_MSGIN
mdefine_line|#define PHASE_MSGIN 0x40
DECL|macro|PHASE_MSGOUT
mdefine_line|#define PHASE_MSGOUT 0x80
DECL|macro|PHASE_STATUSIN
mdefine_line|#define PHASE_STATUSIN 0x100
DECL|macro|PHASE_ETC
mdefine_line|#define PHASE_ETC (PHASE_DATAIN | PHASE_DATAOUT | PHASE_CMDOUT | PHASE_MSGIN | PHASE_MSGOUT | PHASE_STATUSIN)
DECL|macro|PRINT_COMMAND
mdefine_line|#define PRINT_COMMAND 0x200
DECL|macro|PHASE_EXIT
mdefine_line|#define PHASE_EXIT 0x400
DECL|macro|PHASE_RESELECT
mdefine_line|#define PHASE_RESELECT 0x800
DECL|macro|DEBUG_FAST
mdefine_line|#define DEBUG_FAST 0x1000
DECL|macro|DEBUG_SG
mdefine_line|#define DEBUG_SG   0x2000
DECL|macro|DEBUG_LINKED
mdefine_line|#define DEBUG_LINKED&t;0x4000
DECL|macro|DEBUG_BORKEN
mdefine_line|#define DEBUG_BORKEN&t;0x8000
multiline_comment|/* &n; *&t;Control options - these are timeouts specified in .01 seconds.&n; */
multiline_comment|/* 30, 20 work */
DECL|macro|ST0X_BUS_FREE_DELAY
mdefine_line|#define ST0X_BUS_FREE_DELAY 25
DECL|macro|ST0X_SELECTION_DELAY
mdefine_line|#define ST0X_SELECTION_DELAY 25
DECL|macro|SEAGATE
mdefine_line|#define SEAGATE 1&t;/* these determine the type of the controller */
DECL|macro|FD
mdefine_line|#define FD&t;2
DECL|macro|ST0X_ID_STR
mdefine_line|#define ST0X_ID_STR&t;&quot;Seagate ST-01/ST-02&quot;
DECL|macro|FD_ID_STR
mdefine_line|#define FD_ID_STR&t;&quot;TMC-8XX/TMC-950&quot;
r_static
r_int
id|internal_command
(paren
r_int
r_char
id|target
comma
r_int
r_char
id|lun
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buff
comma
r_int
id|bufflen
comma
r_int
id|reselect
)paren
suffix:semicolon
DECL|variable|incommand
r_static
r_int
id|incommand
suffix:semicolon
multiline_comment|/* set if arbitration has finished&n;                                           and we are in some command phase. */
DECL|variable|base_address
r_static
r_int
r_int
id|base_address
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Where the card ROM starts, used to &n;                                           calculate memory mapped register&n;                                           location.  */
DECL|variable|st0x_cr_sr
r_static
r_int
r_int
id|st0x_cr_sr
suffix:semicolon
multiline_comment|/* control register write, status&n;                                           register read.  256 bytes in&n;                                           length.&n;                                           Read is status of SCSI BUS, as per &n;                                           STAT masks.  */
DECL|variable|st0x_dr
r_static
r_int
r_int
id|st0x_dr
suffix:semicolon
multiline_comment|/* data register, read write 256&n;                                           bytes in length.  */
DECL|variable|st0x_aborted
r_static
r_volatile
r_int
id|st0x_aborted
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set when we are aborted, ie by a&n;                                           time out, etc.  */
DECL|variable|controller_type
r_static
r_int
r_char
id|controller_type
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set to SEAGATE for ST0x&n;                                                   boards or FD for TMC-8xx&n;                                                   boards */
DECL|variable|irq
r_static
r_int
id|irq
op_assign
id|IRQ
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|base_address
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|controller_type
comma
l_string|&quot;b&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|macro|retcode
mdefine_line|#define retcode(result) (((result) &lt;&lt; 16) | (message &lt;&lt; 8) | status)
DECL|macro|STATUS
mdefine_line|#define STATUS ((u8) isa_readb(st0x_cr_sr))
DECL|macro|DATA
mdefine_line|#define DATA ((u8) isa_readb(st0x_dr))
DECL|macro|WRITE_CONTROL
mdefine_line|#define WRITE_CONTROL(d) { isa_writeb((d), st0x_cr_sr); }
DECL|macro|WRITE_DATA
mdefine_line|#define WRITE_DATA(d) { isa_writeb((d), st0x_dr); }
DECL|function|st0x_setup
r_void
id|st0x_setup
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|controller_type
op_assign
id|SEAGATE
suffix:semicolon
id|base_address
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
id|irq
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
)brace
DECL|function|tmc8xx_setup
r_void
id|tmc8xx_setup
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|controller_type
op_assign
id|FD
suffix:semicolon
id|base_address
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
id|irq
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
)brace
macro_line|#ifndef OVERRIDE
DECL|variable|seagate_bases
r_static
r_int
r_int
id|seagate_bases
(braket
)braket
op_assign
(brace
l_int|0xc8000
comma
l_int|0xca000
comma
l_int|0xcc000
comma
l_int|0xce000
comma
l_int|0xdc000
comma
l_int|0xde000
)brace
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|signature
r_const
r_int
r_char
op_star
id|signature
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|type
r_int
r_char
id|type
suffix:semicolon
)brace
DECL|typedef|Signature
id|Signature
suffix:semicolon
DECL|variable|signatures
r_static
r_const
id|Signature
id|__initdata
id|signatures
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;ST01 v1.7  (C) Copyright 1987 Seagate&quot;
comma
l_int|15
comma
l_int|37
comma
id|SEAGATE
)brace
comma
(brace
l_string|&quot;SCSI BIOS 2.00  (C) Copyright 1987 Seagate&quot;
comma
l_int|15
comma
l_int|40
comma
id|SEAGATE
)brace
comma
multiline_comment|/*&n; * The following two lines are NOT mistakes.  One detects ROM revision&n; * 3.0.0, the other 3.2.  Since seagate has only one type of SCSI adapter,&n; * and this is not going to change, the &quot;SEAGATE&quot; and &quot;SCSI&quot; together&n; * are probably &quot;good enough&quot;&n; */
(brace
l_string|&quot;SEAGATE SCSI BIOS &quot;
comma
l_int|16
comma
l_int|17
comma
id|SEAGATE
)brace
comma
(brace
l_string|&quot;SEAGATE SCSI BIOS &quot;
comma
l_int|17
comma
l_int|17
comma
id|SEAGATE
)brace
comma
multiline_comment|/*&n; * However, future domain makes several incompatible SCSI boards, so specific&n; * signatures must be used.&n; */
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1989 V5.0C2/14/89&quot;
comma
l_int|5
comma
l_int|46
comma
id|FD
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1989 V6.0A7/28/89&quot;
comma
l_int|5
comma
l_int|46
comma
id|FD
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1990 V6.0105/31/90&quot;
comma
l_int|5
comma
l_int|47
comma
id|FD
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1990 V6.0209/18/90&quot;
comma
l_int|5
comma
l_int|47
comma
id|FD
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1990 V7.009/18/90&quot;
comma
l_int|5
comma
l_int|46
comma
id|FD
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1992 V8.00.004/02/92&quot;
comma
l_int|5
comma
l_int|44
comma
id|FD
)brace
comma
(brace
l_string|&quot;IBM F1 BIOS V1.1004/30/92&quot;
comma
l_int|5
comma
l_int|25
comma
id|FD
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN TMC-950&quot;
comma
l_int|5
comma
l_int|21
comma
id|FD
)brace
comma
multiline_comment|/* Added for 2.2.16 by Matthias_Heidbrink@b.maus.de */
(brace
l_string|&quot;IBM F1 V1.2009/22/93&quot;
comma
l_int|5
comma
l_int|25
comma
id|FD
)brace
comma
)brace
suffix:semicolon
DECL|macro|NUM_SIGNATURES
mdefine_line|#define NUM_SIGNATURES (sizeof(signatures) / sizeof(Signature))
macro_line|#endif /* n OVERRIDE */
multiline_comment|/*&n; * hostno stores the hostnumber, as told to us by the init routine.&n; */
DECL|variable|hostno
r_static
r_int
id|hostno
op_assign
op_minus
l_int|1
suffix:semicolon
r_static
r_void
id|seagate_reconnect_intr
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|do_seagate_reconnect_intr
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
macro_line|#ifdef FAST
DECL|variable|fast
r_static
r_int
id|fast
op_assign
l_int|1
suffix:semicolon
macro_line|#else
DECL|macro|fast
mdefine_line|#define fast 0
macro_line|#endif
macro_line|#ifdef SLOW_RATE
multiline_comment|/*&n; * Support for broken devices :&n; * The Seagate board has a handshaking problem.  Namely, a lack&n; * thereof for slow devices.  You can blast 600K/second through&n; * it if you are polling for each byte, more if you do a blind&n; * transfer.  In the first case, with a fast device, REQ will&n; * transition high-low or high-low-high before your loop restarts&n; * and you&squot;ll have no problems.  In the second case, the board&n; * will insert wait states for up to 13.2 usecs for REQ to&n; * transition low-&gt;high, and everything will work.&n; *&n; * However, there&squot;s nothing in the state machine that says&n; * you *HAVE* to see a high-low-high set of transitions before&n; * sending the next byte, and slow things like the Trantor CD ROMS&n; * will break because of this.&n; *&n; * So, we need to slow things down, which isn&squot;t as simple as it&n; * seems.  We can&squot;t slow things down period, because then people&n; * who don&squot;t recompile their kernels will shoot me for ruining&n; * their performance.  We need to do it on a case per case basis.&n; *&n; * The best for performance will be to, only for borken devices&n; * (this is stored on a per-target basis in the scsi_devices array)&n; *&n; * Wait for a low-&gt;high transition before continuing with that&n; * transfer.  If we timeout, continue anyways.  We don&squot;t need&n; * a long timeout, because REQ should only be asserted until the&n; * corresponding ACK is received and processed.&n; *&n; * Note that we can&squot;t use the system timer for this, because of&n; * resolution, and we *really* can&squot;t use the timer chip since&n; * gettimeofday() and the beeper routines use that.  So,&n; * the best thing for us to do will be to calibrate a timing&n; * loop in the initialization code using the timer chip before&n; * gettimeofday() can screw with it.&n; *&n; * FIXME: this is broken (not borken :-). Empty loop costs less than&n; * loop with ISA access in it! -- pavel@ucw.cz&n; */
DECL|variable|borken_calibration
r_static
r_int
id|borken_calibration
op_assign
l_int|0
suffix:semicolon
DECL|function|borken_init
r_static
r_void
id|__init
id|borken_init
(paren
r_void
)paren
(brace
r_register
r_int
id|count
op_assign
l_int|0
comma
id|start
op_assign
id|jiffies
op_plus
l_int|1
comma
id|stop
op_assign
id|start
op_plus
l_int|25
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|start
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|time_before
c_func
(paren
id|jiffies
comma
id|stop
)paren
suffix:semicolon
op_increment
id|count
)paren
suffix:semicolon
multiline_comment|/*&n; * Ok, we now have a count for .25 seconds.  Convert to a&n; * count per second and divide by transfer rate in K.  */
id|borken_calibration
op_assign
(paren
id|count
op_star
l_int|4
)paren
op_div
(paren
id|SLOW_RATE
op_star
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
id|borken_calibration
OL
l_int|1
)paren
id|borken_calibration
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|borken_wait
r_static
r_inline
r_void
id|borken_wait
(paren
r_void
)paren
(brace
r_register
r_int
id|count
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
id|borken_calibration
suffix:semicolon
id|count
op_logical_and
(paren
id|STATUS
op_amp
id|STAT_REQ
)paren
suffix:semicolon
op_decrement
id|count
)paren
suffix:semicolon
macro_line|#if (DEBUG &amp; DEBUG_BORKEN)
r_if
c_cond
(paren
id|count
)paren
id|printk
(paren
l_string|&quot;scsi%d : borken timeout&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif /* def SLOW_RATE */
multiline_comment|/* These beasts only live on ISA, and ISA means 8MHz. Each ULOOP()&n; * contains at least one ISA access, which takes more than 0.125&n; * usec. So if we loop 8 times time in usec, we are safe.&n; */
DECL|macro|ULOOP
mdefine_line|#define ULOOP( i ) for (clock = i*8;;)
DECL|macro|TIMEOUT
mdefine_line|#define TIMEOUT (!(clock--))
DECL|function|seagate_st0x_detect
r_int
id|__init
id|seagate_st0x_detect
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|tpnt-&gt;proc_name
op_assign
l_string|&quot;seagate&quot;
suffix:semicolon
multiline_comment|/*&n; *    First, we try for the manual override.  */
id|DANY
(paren
l_string|&quot;Autodetecting ST0x / TMC-8xx&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostno
op_ne
op_minus
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;seagate_st0x_detect() called twice?!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If the user specified the controller type from the command line,&n;   controller_type will be non-zero, so don&squot;t try to detect one */
r_if
c_cond
(paren
op_logical_neg
id|controller_type
)paren
(brace
macro_line|#ifdef OVERRIDE
id|base_address
op_assign
id|OVERRIDE
suffix:semicolon
id|controller_type
op_assign
id|CONTROLLER
suffix:semicolon
id|DANY
c_func
(paren
l_string|&quot;Base address overridden to %x, controller type is %s&bslash;n&quot;
comma
id|base_address
comma
id|controller_type
op_eq
id|SEAGATE
ques
c_cond
l_string|&quot;SEAGATE&quot;
suffix:colon
l_string|&quot;FD&quot;
)paren
suffix:semicolon
macro_line|#else /* OVERRIDE */
multiline_comment|/*&n; *    To detect this card, we simply look for the signature&n; *      from the BIOS version notice in all the possible locations&n; *      of the ROM&squot;s.  This has a nice side effect of not trashing&n; *      any register locations that might be used by something else.&n; *&n; * XXX - note that we probably should be probing the address&n; * space for the on-board RAM instead.&n; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_sizeof
(paren
id|seagate_bases
)paren
op_div
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
op_increment
id|i
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|base_address
op_logical_and
id|j
OL
id|NUM_SIGNATURES
suffix:semicolon
op_increment
id|j
)paren
r_if
c_cond
(paren
id|isa_check_signature
(paren
id|seagate_bases
(braket
id|i
)braket
op_plus
id|signatures
(braket
id|j
)braket
dot
id|offset
comma
id|signatures
(braket
id|j
)braket
dot
id|signature
comma
id|signatures
(braket
id|j
)braket
dot
id|length
)paren
)paren
(brace
id|base_address
op_assign
id|seagate_bases
(braket
id|i
)braket
suffix:semicolon
id|controller_type
op_assign
id|signatures
(braket
id|j
)braket
dot
id|type
suffix:semicolon
)brace
macro_line|#endif /* OVERRIDE */
)brace
multiline_comment|/* (! controller_type) */
id|tpnt-&gt;this_id
op_assign
(paren
id|controller_type
op_eq
id|SEAGATE
)paren
ques
c_cond
l_int|7
suffix:colon
l_int|6
suffix:semicolon
id|tpnt-&gt;name
op_assign
(paren
id|controller_type
op_eq
id|SEAGATE
)paren
ques
c_cond
id|ST0X_ID_STR
suffix:colon
id|FD_ID_STR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base_address
)paren
(brace
id|DANY
(paren
l_string|&quot;ST0x / TMC-8xx not detected.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|st0x_cr_sr
op_assign
id|base_address
op_plus
(paren
id|controller_type
op_eq
id|SEAGATE
ques
c_cond
l_int|0x1a00
suffix:colon
l_int|0x1c00
)paren
suffix:semicolon
id|st0x_dr
op_assign
id|st0x_cr_sr
op_plus
l_int|0x200
suffix:semicolon
id|DANY
(paren
l_string|&quot;%s detected. Base address = %x, cr = %x, dr = %x&bslash;n&quot;
comma
id|tpnt-&gt;name
comma
id|base_address
comma
id|st0x_cr_sr
comma
id|st0x_dr
)paren
suffix:semicolon
multiline_comment|/*&n; *    At all times, we will use IRQ 5.  Should also check for IRQ3 if we&n; *      loose our first interrupt.&n; */
id|instance
op_assign
id|scsi_register
(paren
id|tpnt
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|instance
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|hostno
op_assign
id|instance-&gt;host_no
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
(paren
id|irq
comma
id|do_seagate_reconnect_intr
comma
id|SA_INTERRUPT
comma
(paren
id|controller_type
op_eq
id|SEAGATE
)paren
ques
c_cond
l_string|&quot;seagate&quot;
suffix:colon
l_string|&quot;tmc-8xx&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : unable to allocate IRQ%d&bslash;n&quot;
comma
id|hostno
comma
id|irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|instance-&gt;irq
op_assign
id|irq
suffix:semicolon
id|instance-&gt;io_port
op_assign
id|base_address
suffix:semicolon
macro_line|#ifdef SLOW_RATE
id|printk
c_func
(paren
l_string|&quot;Calibrating borken timer... &quot;
)paren
suffix:semicolon
id|borken_init
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %d cycles per transfer&bslash;n&quot;
comma
id|borken_calibration
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;This is one second... &quot;
)paren
suffix:semicolon
(brace
r_int
id|clock
suffix:semicolon
id|ULOOP
c_func
(paren
l_int|1
op_star
l_int|1000
op_star
l_int|1000
)paren
(brace
id|STATUS
suffix:semicolon
r_if
c_cond
(paren
id|TIMEOUT
)paren
r_break
suffix:semicolon
)brace
)brace
id|printk
(paren
l_string|&quot;done, %s options:&quot;
macro_line|#ifdef ARBITRATE
l_string|&quot; ARBITRATE&quot;
macro_line|#endif
macro_line|#ifdef DEBUG
l_string|&quot; DEBUG&quot;
macro_line|#endif
macro_line|#ifdef FAST
l_string|&quot; FAST&quot;
macro_line|#ifdef FAST32
l_string|&quot;32&quot;
macro_line|#endif
macro_line|#endif
macro_line|#ifdef LINKED
l_string|&quot; LINKED&quot;
macro_line|#endif
macro_line|#ifdef PARITY
l_string|&quot; PARITY&quot;
macro_line|#endif
macro_line|#ifdef SEAGATE_USE_ASM
l_string|&quot; SEAGATE_USE_ASM&quot;
macro_line|#endif
macro_line|#ifdef SLOW_RATE
l_string|&quot; SLOW_RATE&quot;
macro_line|#endif
macro_line|#ifdef SWAPSTAT
l_string|&quot; SWAPSTAT&quot;
macro_line|#endif
macro_line|#ifdef SWAPCNTDATA
l_string|&quot; SWAPCNTDATA&quot;
macro_line|#endif
l_string|&quot;&bslash;n&quot;
comma
id|tpnt-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|seagate_st0x_info
r_const
r_char
op_star
id|seagate_st0x_info
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_static
r_char
id|buffer
(braket
l_int|64
)braket
suffix:semicolon
id|sprintf
(paren
id|buffer
comma
l_string|&quot;%s at irq %d, address 0x%05X&quot;
comma
(paren
id|controller_type
op_eq
id|SEAGATE
)paren
ques
c_cond
id|ST0X_ID_STR
suffix:colon
id|FD_ID_STR
comma
id|irq
comma
id|base_address
)paren
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
multiline_comment|/*&n; * These are our saved pointers for the outstanding command that is&n; * waiting for a reconnect&n; */
DECL|variable|current_target
DECL|variable|current_lun
r_static
r_int
r_char
id|current_target
comma
id|current_lun
suffix:semicolon
DECL|variable|current_cmnd
DECL|variable|current_data
r_static
r_int
r_char
op_star
id|current_cmnd
comma
op_star
id|current_data
suffix:semicolon
DECL|variable|current_nobuffs
r_static
r_int
id|current_nobuffs
suffix:semicolon
DECL|variable|current_buffer
r_static
r_struct
id|scatterlist
op_star
id|current_buffer
suffix:semicolon
DECL|variable|current_bufflen
r_static
r_int
id|current_bufflen
suffix:semicolon
macro_line|#ifdef LINKED
multiline_comment|/*&n; * linked_connected indicates whether or not we are currently connected to&n; * linked_target, linked_lun and in an INFORMATION TRANSFER phase,&n; * using linked commands.&n; */
DECL|variable|linked_connected
r_static
r_int
id|linked_connected
op_assign
l_int|0
suffix:semicolon
DECL|variable|linked_target
DECL|variable|linked_lun
r_static
r_int
r_char
id|linked_target
comma
id|linked_lun
suffix:semicolon
macro_line|#endif
DECL|variable|done_fn
r_static
r_void
(paren
op_star
id|done_fn
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|SCint
r_static
id|Scsi_Cmnd
op_star
id|SCint
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * These control whether or not disconnect / reconnect will be attempted,&n; * or are being attempted.&n; */
DECL|macro|NO_RECONNECT
mdefine_line|#define NO_RECONNECT    0
DECL|macro|RECONNECT_NOW
mdefine_line|#define RECONNECT_NOW   1
DECL|macro|CAN_RECONNECT
mdefine_line|#define CAN_RECONNECT   2
multiline_comment|/*&n; * LINKED_RIGHT indicates that we are currently connected to the correct target&n; * for this command, LINKED_WRONG indicates that we are connected to the wrong&n; * target. Note that these imply CAN_RECONNECT and require defined(LINKED).&n; */
DECL|macro|LINKED_RIGHT
mdefine_line|#define LINKED_RIGHT    3
DECL|macro|LINKED_WRONG
mdefine_line|#define LINKED_WRONG    4
multiline_comment|/*&n; * This determines if we are expecting to reconnect or not.&n; */
DECL|variable|should_reconnect
r_static
r_int
id|should_reconnect
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * The seagate_reconnect_intr routine is called when a target reselects the&n; * host adapter.  This occurs on the interrupt triggered by the target&n; * asserting SEL.&n; */
DECL|function|do_seagate_reconnect_intr
r_static
r_void
id|do_seagate_reconnect_intr
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|seagate_reconnect_intr
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|seagate_reconnect_intr
r_static
r_void
id|seagate_reconnect_intr
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|temp
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCtmp
suffix:semicolon
id|DPRINTK
(paren
id|PHASE_RESELECT
comma
l_string|&quot;scsi%d : seagate_reconnect_intr() called&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|should_reconnect
)paren
id|printk
(paren
l_string|&quot;scsi%d: unexpected interrupt.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_else
(brace
id|should_reconnect
op_assign
l_int|0
suffix:semicolon
id|DPRINTK
(paren
id|PHASE_RESELECT
comma
l_string|&quot;scsi%d : internal_command(&quot;
l_string|&quot;%d, %08x, %08x, RECONNECT_NOW&bslash;n&quot;
comma
id|hostno
comma
id|current_target
comma
id|current_data
comma
id|current_bufflen
)paren
suffix:semicolon
id|temp
op_assign
id|internal_command
(paren
id|current_target
comma
id|current_lun
comma
id|current_cmnd
comma
id|current_data
comma
id|current_bufflen
comma
id|RECONNECT_NOW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg_byte
(paren
id|temp
)paren
op_ne
id|DISCONNECT
)paren
(brace
r_if
c_cond
(paren
id|done_fn
)paren
(brace
id|DPRINTK
(paren
id|PHASE_RESELECT
comma
l_string|&quot;scsi%d : done_fn(%d,%08x)&quot;
comma
id|hostno
comma
id|hostno
comma
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCint
)paren
id|panic
(paren
l_string|&quot;SCint == NULL in seagate&quot;
)paren
suffix:semicolon
id|SCtmp
op_assign
id|SCint
suffix:semicolon
id|SCint
op_assign
l_int|NULL
suffix:semicolon
id|SCtmp-&gt;result
op_assign
id|temp
suffix:semicolon
id|done_fn
(paren
id|SCtmp
)paren
suffix:semicolon
)brace
r_else
id|printk
(paren
l_string|&quot;done_fn() not defined.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * The seagate_st0x_queue_command() function provides a queued interface&n; * to the seagate SCSI driver.  Basically, it just passes control onto the&n; * seagate_command() function, after fixing it so that the done_fn()&n; * is set to the one passed to the function.  We have to be very careful,&n; * because there are some commands on some devices that do not disconnect,&n; * and if we simply call the done_fn when the command is done then another&n; * command is started and queue_command is called again...  We end up&n; * overflowing the kernel stack, and this tends not to be such a good idea.&n; */
DECL|variable|recursion_depth
r_static
r_int
id|recursion_depth
op_assign
l_int|0
suffix:semicolon
DECL|function|seagate_st0x_queue_command
r_int
id|seagate_st0x_queue_command
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
id|result
comma
id|reconnect
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCtmp
suffix:semicolon
id|DANY
c_func
(paren
l_string|&quot;seagate: que_command&quot;
)paren
suffix:semicolon
id|done_fn
op_assign
id|done
suffix:semicolon
id|current_target
op_assign
id|SCpnt-&gt;target
suffix:semicolon
id|current_lun
op_assign
id|SCpnt-&gt;lun
suffix:semicolon
(paren
r_const
r_void
op_star
)paren
id|current_cmnd
op_assign
id|SCpnt-&gt;cmnd
suffix:semicolon
id|current_data
op_assign
(paren
r_int
r_char
op_star
)paren
id|SCpnt-&gt;request_buffer
suffix:semicolon
id|current_bufflen
op_assign
id|SCpnt-&gt;request_bufflen
suffix:semicolon
id|SCint
op_assign
id|SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|recursion_depth
)paren
r_return
l_int|0
suffix:semicolon
id|recursion_depth
op_increment
suffix:semicolon
r_do
(brace
macro_line|#ifdef LINKED
multiline_comment|/*&n; * Set linked command bit in control field of SCSI command.&n; */
id|current_cmnd
(braket
id|SCpnt-&gt;cmd_len
)braket
op_or_assign
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
id|linked_connected
)paren
(brace
id|DPRINTK
(paren
id|DEBUG_LINKED
comma
l_string|&quot;scsi%d : using linked commands, current I_T_L nexus is &quot;
comma
id|hostno
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|linked_target
op_eq
id|current_target
)paren
op_logical_and
(paren
id|linked_lun
op_eq
id|current_lun
)paren
)paren
(brace
id|DPRINTK
(paren
id|DEBUG_LINKED
comma
l_string|&quot;correct&bslash;n&quot;
)paren
suffix:semicolon
id|reconnect
op_assign
id|LINKED_RIGHT
suffix:semicolon
)brace
r_else
(brace
id|DPRINTK
(paren
id|DEBUG_LINKED
comma
l_string|&quot;incorrect&bslash;n&quot;
)paren
suffix:semicolon
id|reconnect
op_assign
id|LINKED_WRONG
suffix:semicolon
)brace
)brace
r_else
macro_line|#endif /* LINKED */
id|reconnect
op_assign
id|CAN_RECONNECT
suffix:semicolon
id|result
op_assign
id|internal_command
(paren
id|SCint-&gt;target
comma
id|SCint-&gt;lun
comma
id|SCint-&gt;cmnd
comma
id|SCint-&gt;request_buffer
comma
id|SCint-&gt;request_bufflen
comma
id|reconnect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg_byte
(paren
id|result
)paren
op_eq
id|DISCONNECT
)paren
r_break
suffix:semicolon
id|SCtmp
op_assign
id|SCint
suffix:semicolon
id|SCint
op_assign
l_int|NULL
suffix:semicolon
id|SCtmp-&gt;result
op_assign
id|result
suffix:semicolon
id|done_fn
(paren
id|SCtmp
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|SCint
)paren
suffix:semicolon
id|recursion_depth
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|seagate_st0x_command
r_int
id|seagate_st0x_command
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_return
id|internal_command
(paren
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;request_buffer
comma
id|SCpnt-&gt;request_bufflen
comma
(paren
r_int
)paren
id|NO_RECONNECT
)paren
suffix:semicolon
)brace
DECL|function|internal_command
r_static
r_int
id|internal_command
(paren
r_int
r_char
id|target
comma
r_int
r_char
id|lun
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buff
comma
r_int
id|bufflen
comma
r_int
id|reselect
)paren
(brace
r_int
r_char
op_star
id|data
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|scatterlist
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_int
id|clock
comma
id|temp
comma
id|nobuffs
op_assign
l_int|0
comma
id|done
op_assign
l_int|0
comma
id|len
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG
r_int
id|transfered
op_assign
l_int|0
comma
id|phase
op_assign
l_int|0
comma
id|newphase
suffix:semicolon
macro_line|#endif
r_register
r_int
r_char
id|status_read
suffix:semicolon
r_int
r_char
id|tmp_data
comma
id|tmp_control
comma
id|status
op_assign
l_int|0
comma
id|message
op_assign
l_int|0
suffix:semicolon
r_int
id|transfersize
op_assign
l_int|0
comma
id|underflow
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SLOW_RATE
r_int
id|borken
op_assign
(paren
r_int
)paren
id|SCint-&gt;device-&gt;borken
suffix:semicolon
multiline_comment|/* Does the current target require&n;&t;&t;&t;&t;&t;       Very Slow I/O ?  */
macro_line|#endif
id|incommand
op_assign
l_int|0
suffix:semicolon
id|st0x_aborted
op_assign
l_int|0
suffix:semicolon
macro_line|#if (DEBUG &amp; PRINT_COMMAND)
id|printk
(paren
l_string|&quot;scsi%d : target = %d, command = &quot;
comma
id|hostno
comma
id|target
)paren
suffix:semicolon
id|print_command
(paren
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
r_switch
c_cond
(paren
id|reselect
)paren
(brace
r_case
id|RECONNECT_NOW
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : reconnecting&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef LINKED
r_case
id|LINKED_RIGHT
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : connected, can reconnect&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LINKED_WRONG
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : connected to wrong target, can reconnect&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|CAN_RECONNECT
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : allowed to reconnect&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : not allowed to reconnect&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|target
op_eq
(paren
id|controller_type
op_eq
id|SEAGATE
ques
c_cond
l_int|7
suffix:colon
l_int|6
)paren
)paren
r_return
id|DID_BAD_TARGET
suffix:semicolon
multiline_comment|/*&n; *    We work it differently depending on if this is is &quot;the first time,&quot;&n; *      or a reconnect.  If this is a reselect phase, then SEL will&n; *      be asserted, and we must skip selection / arbitration phases.&n; */
r_switch
c_cond
(paren
id|reselect
)paren
(brace
r_case
id|RECONNECT_NOW
suffix:colon
id|DPRINTK
(paren
id|PHASE_RESELECT
comma
l_string|&quot;scsi%d : phase RESELECT &bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
multiline_comment|/*&n; *    At this point, we should find the logical or of our ID and the original&n; *      target&squot;s ID on the BUS, with BSY, SEL, and I/O signals asserted.&n; *&n; *      After ARBITRATION phase is completed, only SEL, BSY, and the&n; *      target ID are asserted.  A valid initiator ID is not on the bus&n; *      until IO is asserted, so we must wait for that.&n; */
id|ULOOP
c_func
(paren
l_int|100
op_star
l_int|1000
)paren
(brace
id|temp
op_assign
id|STATUS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp
op_amp
id|STAT_IO
)paren
op_logical_and
op_logical_neg
(paren
id|temp
op_amp
id|STAT_BSY
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|TIMEOUT
)paren
(brace
id|DPRINTK
(paren
id|PHASE_RESELECT
comma
l_string|&quot;scsi%d : RESELECT timed out while waiting for IO .&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_return
(paren
id|DID_BAD_INTR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *    After I/O is asserted by the target, we can read our ID and its&n; *      ID off of the BUS.&n; */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|temp
op_assign
id|DATA
)paren
op_amp
(paren
id|controller_type
op_eq
id|SEAGATE
ques
c_cond
l_int|0x80
suffix:colon
l_int|0x40
)paren
)paren
)paren
(brace
id|DPRINTK
(paren
id|PHASE_RESELECT
comma
l_string|&quot;scsi%d : detected reconnect request to different target.&bslash;n&quot;
l_string|&quot;&bslash;tData bus = %d&bslash;n&quot;
comma
id|hostno
comma
id|temp
)paren
suffix:semicolon
r_return
(paren
id|DID_BAD_INTR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|temp
op_amp
(paren
l_int|1
op_lshift
id|current_target
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : Unexpected reselect interrupt.  Data bus = %d&bslash;n&quot;
comma
id|hostno
comma
id|temp
)paren
suffix:semicolon
r_return
(paren
id|DID_BAD_INTR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
id|buffer
op_assign
id|current_buffer
suffix:semicolon
id|cmnd
op_assign
id|current_cmnd
suffix:semicolon
multiline_comment|/* WDE add */
id|data
op_assign
id|current_data
suffix:semicolon
multiline_comment|/* WDE add */
id|len
op_assign
id|current_bufflen
suffix:semicolon
multiline_comment|/* WDE add */
id|nobuffs
op_assign
id|current_nobuffs
suffix:semicolon
multiline_comment|/*&n; *    We have determined that we have been selected.  At this point,&n; *      we must respond to the reselection by asserting BSY ourselves&n; */
macro_line|#if 1
id|WRITE_CONTROL
(paren
id|BASE_CMD
op_or
id|CMD_DRVR_ENABLE
op_or
id|CMD_BSY
)paren
suffix:semicolon
macro_line|#else
id|WRITE_CONTROL
(paren
id|BASE_CMD
op_or
id|CMD_BSY
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *    The target will drop SEL, and raise BSY, at which time we must drop&n; *      BSY.&n; */
id|ULOOP
c_func
(paren
l_int|100
op_star
l_int|1000
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|STATUS
op_amp
id|STAT_SEL
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|TIMEOUT
)paren
(brace
id|WRITE_CONTROL
(paren
id|BASE_CMD
op_or
id|CMD_INTR
)paren
suffix:semicolon
id|DPRINTK
(paren
id|PHASE_RESELECT
comma
l_string|&quot;scsi%d : RESELECT timed out while waiting for SEL.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_return
(paren
id|DID_BAD_INTR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
)brace
id|WRITE_CONTROL
(paren
id|BASE_CMD
)paren
suffix:semicolon
multiline_comment|/*&n; *    At this point, we have connected with the target and can get&n; *      on with our lives.&n; */
r_break
suffix:semicolon
r_case
id|CAN_RECONNECT
suffix:colon
macro_line|#ifdef LINKED
multiline_comment|/*&n; * This is a bletcherous hack, just as bad as the Unix #! interpreter stuff.&n; * If it turns out we are using the wrong I_T_L nexus, the easiest way to deal&n; * with it is to go into our INFORMATION TRANSFER PHASE code, send a ABORT&n; * message on MESSAGE OUT phase, and then loop back to here.&n; */
id|connect_loop
suffix:colon
macro_line|#endif
id|DPRINTK
(paren
id|PHASE_BUS_FREE
comma
l_string|&quot;scsi%d : phase = BUS FREE &bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
multiline_comment|/*&n; *    BUS FREE PHASE&n; *&n; *      On entry, we make sure that the BUS is in a BUS FREE&n; *      phase, by insuring that both BSY and SEL are low for&n; *      at least one bus settle delay.  Several reads help&n; *      eliminate wire glitch.&n; */
macro_line|#ifndef ARBITRATE
macro_line|#error FIXME: this is broken: we may not use jiffies here - we are under cli(). It will hardlock.
id|clock
op_assign
id|jiffies
op_plus
id|ST0X_BUS_FREE_DELAY
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|STATUS
op_or
id|STATUS
op_or
id|STATUS
)paren
op_amp
(paren
id|STAT_BSY
op_or
id|STAT_SEL
)paren
)paren
op_logical_and
(paren
op_logical_neg
id|st0x_aborted
)paren
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|clock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|clock
)paren
)paren
r_return
id|retcode
(paren
id|DID_BUS_BUSY
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|st0x_aborted
)paren
r_return
id|retcode
(paren
id|st0x_aborted
)paren
suffix:semicolon
macro_line|#endif
id|DPRINTK
(paren
id|PHASE_SELECTION
comma
l_string|&quot;scsi%d : phase = SELECTION&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|clock
op_assign
id|jiffies
op_plus
id|ST0X_SELECTION_DELAY
suffix:semicolon
multiline_comment|/*&n; * Arbitration/selection procedure :&n; * 1.  Disable drivers&n; * 2.  Write HOST adapter address bit&n; * 3.  Set start arbitration.&n; * 4.  We get either ARBITRATION COMPLETE or SELECT at this&n; *     point.&n; * 5.  OR our ID and targets on bus.&n; * 6.  Enable SCSI drivers and asserted SEL and ATTN&n; */
macro_line|#ifdef ARBITRATE
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|WRITE_CONTROL
(paren
l_int|0
)paren
suffix:semicolon
id|WRITE_DATA
(paren
(paren
id|controller_type
op_eq
id|SEAGATE
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0x40
)paren
suffix:semicolon
id|WRITE_CONTROL
(paren
id|CMD_START_ARB
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|ULOOP
c_func
(paren
id|ST0X_SELECTION_DELAY
op_star
l_int|10000
)paren
(brace
id|status_read
op_assign
id|STATUS
suffix:semicolon
r_if
c_cond
(paren
id|status_read
op_amp
id|STAT_ARB_CMPL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|st0x_aborted
)paren
multiline_comment|/* FIXME: What? We are going to do something even after abort? */
r_break
suffix:semicolon
r_if
c_cond
(paren
id|TIMEOUT
op_logical_or
(paren
id|status_read
op_amp
id|STAT_SEL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : arbitration lost or timeout.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|WRITE_CONTROL
(paren
id|BASE_CMD
)paren
suffix:semicolon
r_return
id|retcode
(paren
id|DID_NO_CONNECT
)paren
suffix:semicolon
)brace
)brace
id|DPRINTK
(paren
id|PHASE_SELECTION
comma
l_string|&quot;scsi%d : arbitration complete&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *    When the SCSI device decides that we&squot;re gawking at it, it will&n; *    respond by asserting BUSY on the bus.&n; *&n; *    Note : the Seagate ST-01/02 product manual says that we should&n; *    twiddle the DATA register before the control register.    However,&n; *    this does not work reliably so we do it the other way around.&n; *&n; *    Probably could be a problem with arbitration too, we really should&n; *    try this with a SCSI protocol or logic analyzer to see what is&n; *    going on.&n; */
id|tmp_data
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
l_int|1
op_lshift
id|target
)paren
op_or
(paren
id|controller_type
op_eq
id|SEAGATE
ques
c_cond
l_int|0x80
suffix:colon
l_int|0x40
)paren
)paren
suffix:semicolon
id|tmp_control
op_assign
id|BASE_CMD
op_or
id|CMD_DRVR_ENABLE
op_or
id|CMD_SEL
op_or
(paren
id|reselect
ques
c_cond
id|CMD_ATTN
suffix:colon
l_int|0
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef OLDCNTDATASCEME
macro_line|#ifdef SWAPCNTDATA
id|WRITE_CONTROL
(paren
id|tmp_control
)paren
suffix:semicolon
id|WRITE_DATA
(paren
id|tmp_data
)paren
suffix:semicolon
macro_line|#else
id|WRITE_DATA
(paren
id|tmp_data
)paren
suffix:semicolon
id|WRITE_CONTROL
(paren
id|tmp_control
)paren
suffix:semicolon
macro_line|#endif
macro_line|#else
id|tmp_control
op_xor_assign
id|CMD_BSY
suffix:semicolon
multiline_comment|/* This is guesswork. What used to be in driver&t;   */
id|WRITE_CONTROL
(paren
id|tmp_control
)paren
suffix:semicolon
multiline_comment|/* could never work: it sent data into control&t;   */
id|WRITE_DATA
(paren
id|tmp_data
)paren
suffix:semicolon
multiline_comment|/* register and control info into data. Hopefully  */
id|tmp_control
op_xor_assign
id|CMD_BSY
suffix:semicolon
multiline_comment|/* fixed, but order of first two may be wrong.     */
id|WRITE_CONTROL
(paren
id|tmp_control
)paren
suffix:semicolon
multiline_comment|/* -- pavel@ucw.cz   */
macro_line|#endif       
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|ULOOP
c_func
(paren
l_int|250
op_star
l_int|1000
)paren
(brace
r_if
c_cond
(paren
id|st0x_aborted
)paren
(brace
multiline_comment|/*&n; *    If we have been aborted, and we have a command in progress, IE the&n; *      target still has BSY asserted, then we will reset the bus, and&n; *      notify the midlevel driver to expect sense.&n; */
id|WRITE_CONTROL
(paren
id|BASE_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|STATUS
op_amp
id|STAT_BSY
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : BST asserted after we&squot;ve been aborted.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|seagate_st0x_reset
(paren
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
id|retcode
(paren
id|DID_RESET
)paren
suffix:semicolon
)brace
r_return
id|retcode
(paren
id|st0x_aborted
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|STATUS
op_amp
id|STAT_BSY
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|TIMEOUT
)paren
(brace
id|DPRINTK
(paren
id|PHASE_SELECTION
comma
l_string|&quot;scsi%d : NO CONNECT with target %d, stat = %x &bslash;n&quot;
comma
id|hostno
comma
id|target
comma
id|STATUS
)paren
suffix:semicolon
r_return
id|retcode
(paren
id|DID_NO_CONNECT
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Establish current pointers.  Take into account scatter / gather */
r_if
c_cond
(paren
(paren
id|nobuffs
op_assign
id|SCint-&gt;use_sg
)paren
)paren
(brace
macro_line|#if (DEBUG &amp; DEBUG_SG)
(brace
r_int
id|i
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : scatter gather requested, using %d buffers.&bslash;n&quot;
comma
id|hostno
comma
id|nobuffs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nobuffs
suffix:semicolon
op_increment
id|i
)paren
id|printk
(paren
l_string|&quot;scsi%d : buffer %d address = %08x length = %d&bslash;n&quot;
comma
id|hostno
comma
id|i
comma
id|buffer
(braket
id|i
)braket
dot
id|address
comma
id|buffer
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
)brace
macro_line|#endif
id|buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCint-&gt;buffer
suffix:semicolon
id|len
op_assign
id|buffer-&gt;length
suffix:semicolon
id|data
op_assign
(paren
r_int
r_char
op_star
)paren
id|buffer-&gt;address
suffix:semicolon
)brace
r_else
(brace
id|DPRINTK
(paren
id|DEBUG_SG
comma
l_string|&quot;scsi%d : scatter gather not requested.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|buffer
op_assign
l_int|NULL
suffix:semicolon
id|len
op_assign
id|SCint-&gt;request_bufflen
suffix:semicolon
id|data
op_assign
(paren
r_int
r_char
op_star
)paren
id|SCint-&gt;request_buffer
suffix:semicolon
)brace
id|DPRINTK
(paren
id|PHASE_DATAIN
op_or
id|PHASE_DATAOUT
comma
l_string|&quot;scsi%d : len = %d&bslash;n&quot;
comma
id|hostno
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef LINKED
r_case
id|LINKED_RIGHT
suffix:colon
r_break
suffix:semicolon
r_case
id|LINKED_WRONG
suffix:colon
r_break
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* end of switch(reselect) */
multiline_comment|/*&n; *    There are several conditions under which we wish to send a message :&n; *      1.  When we are allowing disconnect / reconnect, and need to establish&n; *          the I_T_L nexus via an IDENTIFY with the DiscPriv bit set.&n; *&n; *      2.  When we are doing linked commands, are have the wrong I_T_L nexus&n; *          established and want to send an ABORT message.&n; */
multiline_comment|/* GCC does not like an ifdef inside a macro, so do it the hard way. */
macro_line|#ifdef LINKED
id|WRITE_CONTROL
(paren
id|BASE_CMD
op_or
id|CMD_DRVR_ENABLE
op_or
(paren
(paren
(paren
id|reselect
op_eq
id|CAN_RECONNECT
)paren
op_logical_or
(paren
id|reselect
op_eq
id|LINKED_WRONG
)paren
)paren
ques
c_cond
id|CMD_ATTN
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
macro_line|#else
id|WRITE_CONTROL
(paren
id|BASE_CMD
op_or
id|CMD_DRVR_ENABLE
op_or
(paren
(paren
(paren
id|reselect
op_eq
id|CAN_RECONNECT
)paren
)paren
ques
c_cond
id|CMD_ATTN
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *    INFORMATION TRANSFER PHASE&n; *&n; *      The nasty looking read / write inline assembler loops we use for&n; *      DATAIN and DATAOUT phases are approximately 4-5 times as fast as&n; *      the &squot;C&squot; versions - since we&squot;re moving 1024 bytes of data, this&n; *      really adds up.&n; *&n; *      SJT: The nasty-looking assembler is gone, so it&squot;s slower.&n; *&n; */
id|DPRINTK
(paren
id|PHASE_ETC
comma
l_string|&quot;scsi%d : phase = INFORMATION TRANSFER&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|incommand
op_assign
l_int|1
suffix:semicolon
id|transfersize
op_assign
id|SCint-&gt;transfersize
suffix:semicolon
id|underflow
op_assign
id|SCint-&gt;underflow
suffix:semicolon
multiline_comment|/*&n; *    Now, we poll the device for status information,&n; *      and handle any requests it makes.  Note that since we are unsure of&n; *      how much data will be flowing across the system, etc and cannot&n; *      make reasonable timeouts, that we will instead have the midlevel&n; *      driver handle any timeouts that occur in this phase.&n; */
r_while
c_loop
(paren
(paren
(paren
id|status_read
op_assign
id|STATUS
)paren
op_amp
id|STAT_BSY
)paren
op_logical_and
op_logical_neg
id|st0x_aborted
op_logical_and
op_logical_neg
id|done
)paren
(brace
macro_line|#ifdef PARITY
r_if
c_cond
(paren
id|status_read
op_amp
id|STAT_PARITY
)paren
(brace
id|printk
(paren
l_string|&quot;scsi%d : got parity error&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_PARITY
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|status_read
op_amp
id|STAT_REQ
)paren
(brace
macro_line|#if ((DEBUG &amp; PHASE_ETC) == PHASE_ETC)
r_if
c_cond
(paren
(paren
id|newphase
op_assign
(paren
id|status_read
op_amp
id|REQ_MASK
)paren
)paren
op_ne
id|phase
)paren
(brace
id|phase
op_assign
id|newphase
suffix:semicolon
r_switch
c_cond
(paren
id|phase
)paren
(brace
r_case
id|REQ_DATAOUT
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : phase = DATA OUT&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_DATAIN
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : phase = DATA IN&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_CMDOUT
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : phase = COMMAND OUT&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_STATIN
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : phase = STATUS IN&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_MSGOUT
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : phase = MESSAGE OUT&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_MSGIN
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : phase = MESSAGE IN&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : phase = UNKNOWN&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_ERROR
suffix:semicolon
)brace
)brace
macro_line|#endif
r_switch
c_cond
(paren
id|status_read
op_amp
id|REQ_MASK
)paren
(brace
r_case
id|REQ_DATAOUT
suffix:colon
multiline_comment|/*&n; * If we are in fast mode, then we simply splat the data out&n; * in word-sized chunks as fast as we can.&n; */
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
(brace
macro_line|#if 0
id|printk
(paren
l_string|&quot;scsi%d: underflow to target %d lun %d &bslash;n&quot;
comma
id|hostno
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_ERROR
suffix:semicolon
id|fast
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fast
op_logical_and
id|transfersize
op_logical_and
op_logical_neg
(paren
id|len
op_mod
id|transfersize
)paren
op_logical_and
(paren
id|len
op_ge
id|transfersize
)paren
macro_line|#ifdef FAST32
op_logical_and
op_logical_neg
(paren
id|transfersize
op_mod
l_int|4
)paren
macro_line|#endif
)paren
(brace
id|DPRINTK
(paren
id|DEBUG_FAST
comma
l_string|&quot;scsi%d : FAST transfer, underflow = %d, transfersize = %d&bslash;n&quot;
l_string|&quot;         len = %d, data = %08x&bslash;n&quot;
comma
id|hostno
comma
id|SCint-&gt;underflow
comma
id|SCint-&gt;transfersize
comma
id|len
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* SJT: Start. Fast Write */
macro_line|#ifdef SEAGATE_USE_ASM
id|__asm__
c_func
(paren
l_string|&quot;cld&bslash;n&bslash;t&quot;
macro_line|#ifdef FAST32
l_string|&quot;shr $2, %%ecx&bslash;n&bslash;t&quot;
l_string|&quot;1:&bslash;t&quot;
l_string|&quot;lodsl&bslash;n&bslash;t&quot;
l_string|&quot;movl %%eax, (%%edi)&bslash;n&bslash;t&quot;
macro_line|#else
l_string|&quot;1:&bslash;t&quot;
l_string|&quot;lodsb&bslash;n&bslash;t&quot;
l_string|&quot;movb %%al, (%%edi)&bslash;n&bslash;t&quot;
macro_line|#endif
l_string|&quot;loop 1b;&quot;
multiline_comment|/* output */
suffix:colon
multiline_comment|/* input */
suffix:colon
l_string|&quot;D&quot;
(paren
id|phys_to_virt
c_func
(paren
id|st0x_dr
)paren
)paren
comma
l_string|&quot;S&quot;
(paren
id|data
)paren
comma
l_string|&quot;c&quot;
(paren
id|SCint-&gt;transfersize
)paren
multiline_comment|/* clobbered */
suffix:colon
l_string|&quot;eax&quot;
comma
l_string|&quot;ecx&quot;
comma
l_string|&quot;esi&quot;
)paren
suffix:semicolon
macro_line|#else /* SEAGATE_USE_ASM */
(brace
macro_line|#ifdef FAST32
r_int
r_int
op_star
id|iop
op_assign
id|phys_to_virt
(paren
id|st0x_dr
)paren
suffix:semicolon
r_const
r_int
r_int
op_star
id|dp
op_assign
(paren
r_int
r_int
op_star
)paren
id|data
suffix:semicolon
r_int
id|xferlen
op_assign
id|transfersize
op_rshift
l_int|2
suffix:semicolon
macro_line|#else
r_int
r_char
op_star
id|iop
op_assign
id|phys_to_virt
(paren
id|st0x_dr
)paren
suffix:semicolon
r_const
r_int
r_char
op_star
id|dp
op_assign
id|data
suffix:semicolon
r_int
id|xferlen
op_assign
id|transfersize
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
suffix:semicolon
id|xferlen
suffix:semicolon
op_decrement
id|xferlen
)paren
op_star
id|iop
op_assign
op_star
id|dp
op_increment
suffix:semicolon
)brace
macro_line|#endif /* SEAGATE_USE_ASM */
multiline_comment|/* SJT: End */
id|len
op_sub_assign
id|transfersize
suffix:semicolon
id|data
op_add_assign
id|transfersize
suffix:semicolon
id|DPRINTK
(paren
id|DEBUG_FAST
comma
l_string|&quot;scsi%d : FAST transfer complete len = %d data = %08x&bslash;n&quot;
comma
id|hostno
comma
id|len
comma
id|data
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n; *    We loop as long as we are in a data out phase, there is data to send,&n; *      and BSY is still active.&n; */
multiline_comment|/* SJT: Start. Slow Write. */
macro_line|#ifdef SEAGATE_USE_ASM
r_int
id|__dummy_1
comma
id|__dummy_2
suffix:semicolon
multiline_comment|/*&n; *      We loop as long as we are in a data out phase, there is data to send, &n; *      and BSY is still active.&n; */
multiline_comment|/* Local variables : len = ecx , data = esi, &n;                     st0x_cr_sr = ebx, st0x_dr =  edi&n;*/
id|__asm__
(paren
multiline_comment|/* Test for any data here at all. */
l_string|&quot;orl %%ecx, %%ecx&bslash;n&bslash;t&quot;
l_string|&quot;jz 2f&bslash;n&bslash;t&quot;
l_string|&quot;cld&bslash;n&bslash;t&quot;
multiline_comment|/*                    &quot;movl &quot; SYMBOL_NAME_STR(st0x_cr_sr) &quot;, %%ebx&bslash;n&bslash;t&quot;  */
multiline_comment|/*                    &quot;movl &quot; SYMBOL_NAME_STR(st0x_dr) &quot;, %%edi&bslash;n&bslash;t&quot;  */
l_string|&quot;1:&bslash;t&quot;
l_string|&quot;movb (%%ebx), %%al&bslash;n&bslash;t&quot;
multiline_comment|/* Test for BSY */
l_string|&quot;test $1, %%al&bslash;n&bslash;t&quot;
l_string|&quot;jz 2f&bslash;n&bslash;t&quot;
multiline_comment|/* Test for data out phase - STATUS &amp; REQ_MASK should be &n;               REQ_DATAOUT, which is 0. */
l_string|&quot;test $0xe, %%al&bslash;n&bslash;t&quot;
l_string|&quot;jnz 2f&bslash;n&bslash;t&quot;
multiline_comment|/* Test for REQ */
l_string|&quot;test $0x10, %%al&bslash;n&bslash;t&quot;
l_string|&quot;jz 1b&bslash;n&bslash;t&quot;
l_string|&quot;lodsb&bslash;n&bslash;t&quot;
l_string|&quot;movb %%al, (%%edi)&bslash;n&bslash;t&quot;
l_string|&quot;loop 1b&bslash;n&bslash;t&quot;
l_string|&quot;2:&bslash;n&quot;
multiline_comment|/* output */
suffix:colon
l_string|&quot;=S&quot;
(paren
id|data
)paren
comma
l_string|&quot;=c&quot;
(paren
id|len
)paren
comma
l_string|&quot;=b&quot;
(paren
id|__dummy_1
)paren
comma
l_string|&quot;=D&quot;
(paren
id|__dummy_2
)paren
multiline_comment|/* input */
suffix:colon
l_string|&quot;0&quot;
(paren
id|data
)paren
comma
l_string|&quot;1&quot;
(paren
id|len
)paren
comma
l_string|&quot;2&quot;
(paren
id|phys_to_virt
c_func
(paren
id|st0x_cr_sr
)paren
)paren
comma
l_string|&quot;3&quot;
(paren
id|phys_to_virt
c_func
(paren
id|st0x_dr
)paren
)paren
multiline_comment|/* clobbered */
suffix:colon
l_string|&quot;eax&quot;
)paren
suffix:semicolon
macro_line|#else /* SEAGATE_USE_ASM */
r_while
c_loop
(paren
id|len
)paren
(brace
r_int
r_char
id|stat
suffix:semicolon
id|stat
op_assign
id|STATUS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|stat
op_amp
id|STAT_BSY
)paren
op_logical_or
(paren
(paren
id|stat
op_amp
id|REQ_MASK
)paren
op_ne
id|REQ_DATAOUT
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|STAT_REQ
)paren
(brace
id|WRITE_DATA
(paren
op_star
id|data
op_increment
)paren
suffix:semicolon
op_decrement
id|len
suffix:semicolon
)brace
)brace
macro_line|#endif /* SEAGATE_USE_ASM */
multiline_comment|/* SJT: End. */
)brace
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_and
id|nobuffs
)paren
(brace
op_decrement
id|nobuffs
suffix:semicolon
op_increment
id|buffer
suffix:semicolon
id|len
op_assign
id|buffer-&gt;length
suffix:semicolon
id|data
op_assign
(paren
r_int
r_char
op_star
)paren
id|buffer-&gt;address
suffix:semicolon
id|DPRINTK
(paren
id|DEBUG_SG
comma
l_string|&quot;scsi%d : next scatter-gather buffer len = %d address = %08x&bslash;n&quot;
comma
id|hostno
comma
id|len
comma
id|data
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|REQ_DATAIN
suffix:colon
macro_line|#ifdef SLOW_RATE
r_if
c_cond
(paren
id|borken
)paren
(brace
macro_line|#if (DEBUG &amp; (PHASE_DATAIN))
id|transfered
op_add_assign
id|len
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
suffix:semicolon
id|len
op_logical_and
(paren
id|STATUS
op_amp
(paren
id|REQ_MASK
op_or
id|STAT_REQ
)paren
)paren
op_eq
(paren
id|REQ_DATAIN
op_or
id|STAT_REQ
)paren
suffix:semicolon
op_decrement
id|len
)paren
(brace
op_star
id|data
op_increment
op_assign
id|DATA
suffix:semicolon
id|borken_wait
(paren
)paren
suffix:semicolon
)brace
macro_line|#if (DEBUG &amp; (PHASE_DATAIN))
id|transfered
op_sub_assign
id|len
suffix:semicolon
macro_line|#endif
)brace
r_else
macro_line|#endif
r_if
c_cond
(paren
id|fast
op_logical_and
id|transfersize
op_logical_and
op_logical_neg
(paren
id|len
op_mod
id|transfersize
)paren
op_logical_and
(paren
id|len
op_ge
id|transfersize
)paren
macro_line|#ifdef FAST32
op_logical_and
op_logical_neg
(paren
id|transfersize
op_mod
l_int|4
)paren
macro_line|#endif
)paren
(brace
id|DPRINTK
(paren
id|DEBUG_FAST
comma
l_string|&quot;scsi%d : FAST transfer, underflow = %d, transfersize = %d&bslash;n&quot;
l_string|&quot;         len = %d, data = %08x&bslash;n&quot;
comma
id|hostno
comma
id|SCint-&gt;underflow
comma
id|SCint-&gt;transfersize
comma
id|len
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* SJT: Start. Fast Read */
macro_line|#ifdef SEAGATE_USE_ASM
id|__asm__
c_func
(paren
l_string|&quot;cld&bslash;n&bslash;t&quot;
macro_line|#ifdef FAST32
l_string|&quot;shr $2, %%ecx&bslash;n&bslash;t&quot;
l_string|&quot;1:&bslash;t&quot;
l_string|&quot;movl (%%esi), %%eax&bslash;n&bslash;t&quot;
l_string|&quot;stosl&bslash;n&bslash;t&quot;
macro_line|#else
l_string|&quot;1:&bslash;t&quot;
l_string|&quot;movb (%%esi), %%al&bslash;n&bslash;t&quot;
l_string|&quot;stosb&bslash;n&bslash;t&quot;
macro_line|#endif
l_string|&quot;loop 1b&bslash;n&bslash;t&quot;
multiline_comment|/* output */
suffix:colon
multiline_comment|/* input */
suffix:colon
l_string|&quot;S&quot;
(paren
id|phys_to_virt
c_func
(paren
id|st0x_dr
)paren
)paren
comma
l_string|&quot;D&quot;
(paren
id|data
)paren
comma
l_string|&quot;c&quot;
(paren
id|SCint-&gt;transfersize
)paren
multiline_comment|/* clobbered */
suffix:colon
l_string|&quot;eax&quot;
comma
l_string|&quot;ecx&quot;
comma
l_string|&quot;edi&quot;
)paren
suffix:semicolon
macro_line|#else /* SEAGATE_USE_ASM */
(brace
macro_line|#ifdef FAST32
r_const
r_int
r_int
op_star
id|iop
op_assign
id|phys_to_virt
(paren
id|st0x_dr
)paren
suffix:semicolon
r_int
r_int
op_star
id|dp
op_assign
(paren
r_int
r_int
op_star
)paren
id|data
suffix:semicolon
r_int
id|xferlen
op_assign
id|len
op_rshift
l_int|2
suffix:semicolon
macro_line|#else
r_const
r_int
r_char
op_star
id|iop
op_assign
id|phys_to_virt
(paren
id|st0x_dr
)paren
suffix:semicolon
r_int
r_char
op_star
id|dp
op_assign
id|data
suffix:semicolon
r_int
id|xferlen
op_assign
id|len
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
suffix:semicolon
id|xferlen
suffix:semicolon
op_decrement
id|xferlen
)paren
op_star
id|dp
op_increment
op_assign
op_star
id|iop
suffix:semicolon
)brace
macro_line|#endif /* SEAGATE_USE_ASM */
multiline_comment|/* SJT: End */
id|len
op_sub_assign
id|transfersize
suffix:semicolon
id|data
op_add_assign
id|transfersize
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_DATAIN)
id|printk
(paren
l_string|&quot;scsi%d: transfered += %d&bslash;n&quot;
comma
id|hostno
comma
id|transfersize
)paren
suffix:semicolon
id|transfered
op_add_assign
id|transfersize
suffix:semicolon
macro_line|#endif
id|DPRINTK
(paren
id|DEBUG_FAST
comma
l_string|&quot;scsi%d : FAST transfer complete len = %d data = %08x&bslash;n&quot;
comma
id|hostno
comma
id|len
comma
id|data
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if (DEBUG &amp; PHASE_DATAIN)
id|printk
(paren
l_string|&quot;scsi%d: transfered += %d&bslash;n&quot;
comma
id|hostno
comma
id|len
)paren
suffix:semicolon
id|transfered
op_add_assign
id|len
suffix:semicolon
multiline_comment|/* Assume we&squot;ll transfer it all, then&n;                                           subtract what we *didn&squot;t* transfer */
macro_line|#endif
multiline_comment|/*&n; *    We loop as long as we are in a data in phase, there is room to read,&n; *      and BSY is still active&n; */
multiline_comment|/* SJT: Start. */
macro_line|#ifdef SEAGATE_USE_ASM
r_int
id|__dummy_3
comma
id|__dummy_4
suffix:semicolon
multiline_comment|/* Dummy clobbering variables for the new gcc-2.95 */
multiline_comment|/*&n; *      We loop as long as we are in a data in phase, there is room to read, &n; *      and BSY is still active&n; */
multiline_comment|/* Local variables : ecx = len, edi = data&n;                                 esi = st0x_cr_sr, ebx = st0x_dr */
id|__asm__
(paren
multiline_comment|/* Test for room to read */
l_string|&quot;orl %%ecx, %%ecx&bslash;n&bslash;t&quot;
l_string|&quot;jz 2f&bslash;n&bslash;t&quot;
l_string|&quot;cld&bslash;n&bslash;t&quot;
multiline_comment|/*                &quot;movl &quot; SYMBOL_NAME_STR(st0x_cr_sr) &quot;, %%esi&bslash;n&bslash;t&quot;  */
multiline_comment|/*                &quot;movl &quot; SYMBOL_NAME_STR(st0x_dr) &quot;, %%ebx&bslash;n&bslash;t&quot;  */
l_string|&quot;1:&bslash;t&quot;
l_string|&quot;movb (%%esi), %%al&bslash;n&bslash;t&quot;
multiline_comment|/* Test for BSY */
l_string|&quot;test $1, %%al&bslash;n&bslash;t&quot;
l_string|&quot;jz 2f&bslash;n&bslash;t&quot;
multiline_comment|/* Test for data in phase - STATUS &amp; REQ_MASK should be REQ_DATAIN, &n;               = STAT_IO, which is 4. */
l_string|&quot;movb $0xe, %%ah&bslash;n&bslash;t&quot;
l_string|&quot;andb %%al, %%ah&bslash;n&bslash;t&quot;
l_string|&quot;cmpb $0x04, %%ah&bslash;n&bslash;t&quot;
l_string|&quot;jne 2f&bslash;n&bslash;t&quot;
multiline_comment|/* Test for REQ */
l_string|&quot;test $0x10, %%al&bslash;n&bslash;t&quot;
l_string|&quot;jz 1b&bslash;n&bslash;t&quot;
l_string|&quot;movb (%%ebx), %%al&bslash;n&bslash;t&quot;
l_string|&quot;stosb&bslash;n&bslash;t&quot;
l_string|&quot;loop 1b&bslash;n&bslash;t&quot;
l_string|&quot;2:&bslash;n&quot;
multiline_comment|/* output */
suffix:colon
l_string|&quot;=D&quot;
(paren
id|data
)paren
comma
l_string|&quot;=c&quot;
(paren
id|len
)paren
comma
l_string|&quot;=S&quot;
(paren
id|__dummy_3
)paren
comma
l_string|&quot;=b&quot;
(paren
id|__dummy_4
)paren
multiline_comment|/* input */
suffix:colon
l_string|&quot;0&quot;
(paren
id|data
)paren
comma
l_string|&quot;1&quot;
(paren
id|len
)paren
comma
l_string|&quot;2&quot;
(paren
id|phys_to_virt
c_func
(paren
id|st0x_cr_sr
)paren
)paren
comma
l_string|&quot;3&quot;
(paren
id|phys_to_virt
c_func
(paren
id|st0x_dr
)paren
)paren
multiline_comment|/* clobbered */
suffix:colon
l_string|&quot;eax&quot;
)paren
suffix:semicolon
macro_line|#else /* SEAGATE_USE_ASM */
r_while
c_loop
(paren
id|len
)paren
(brace
r_int
r_char
id|stat
suffix:semicolon
id|stat
op_assign
id|STATUS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|stat
op_amp
id|STAT_BSY
)paren
op_logical_or
(paren
(paren
id|stat
op_amp
id|REQ_MASK
)paren
op_ne
id|REQ_DATAIN
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|STAT_REQ
)paren
(brace
op_star
id|data
op_increment
op_assign
id|DATA
suffix:semicolon
op_decrement
id|len
suffix:semicolon
)brace
)brace
macro_line|#endif /* SEAGATE_USE_ASM */
multiline_comment|/* SJT: End. */
macro_line|#if (DEBUG &amp; PHASE_DATAIN)
id|printk
(paren
l_string|&quot;scsi%d: transfered -= %d&bslash;n&quot;
comma
id|hostno
comma
id|len
)paren
suffix:semicolon
id|transfered
op_sub_assign
id|len
suffix:semicolon
multiline_comment|/* Since we assumed all of Len got  *&n;                                           transfered, correct our mistake */
macro_line|#endif
)brace
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_and
id|nobuffs
)paren
(brace
op_decrement
id|nobuffs
suffix:semicolon
op_increment
id|buffer
suffix:semicolon
id|len
op_assign
id|buffer-&gt;length
suffix:semicolon
id|data
op_assign
(paren
r_int
r_char
op_star
)paren
id|buffer-&gt;address
suffix:semicolon
id|DPRINTK
(paren
id|DEBUG_SG
comma
l_string|&quot;scsi%d : next scatter-gather buffer len = %d address = %08x&bslash;n&quot;
comma
id|hostno
comma
id|len
comma
id|data
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|REQ_CMDOUT
suffix:colon
r_while
c_loop
(paren
(paren
(paren
id|status_read
op_assign
id|STATUS
)paren
op_amp
id|STAT_BSY
)paren
op_logical_and
(paren
(paren
id|status_read
op_amp
id|REQ_MASK
)paren
op_eq
id|REQ_CMDOUT
)paren
)paren
r_if
c_cond
(paren
id|status_read
op_amp
id|STAT_REQ
)paren
(brace
id|WRITE_DATA
(paren
op_star
(paren
r_const
r_int
r_char
op_star
)paren
id|cmnd
)paren
suffix:semicolon
id|cmnd
op_assign
l_int|1
op_plus
(paren
r_const
r_int
r_char
op_star
)paren
id|cmnd
suffix:semicolon
macro_line|#ifdef SLOW_RATE
r_if
c_cond
(paren
id|borken
)paren
id|borken_wait
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
r_case
id|REQ_STATIN
suffix:colon
id|status
op_assign
id|DATA
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_MSGOUT
suffix:colon
multiline_comment|/*&n; *    We can only have sent a MSG OUT if we requested to do this&n; *      by raising ATTN.  So, we must drop ATTN.&n; */
id|WRITE_CONTROL
(paren
id|BASE_CMD
op_or
id|CMD_DRVR_ENABLE
)paren
suffix:semicolon
multiline_comment|/*&n; *    If we are reconnecting, then we must send an IDENTIFY message in&n; *       response  to MSGOUT.&n; */
r_switch
c_cond
(paren
id|reselect
)paren
(brace
r_case
id|CAN_RECONNECT
suffix:colon
id|WRITE_DATA
(paren
id|IDENTIFY
(paren
l_int|1
comma
id|lun
)paren
)paren
suffix:semicolon
id|DPRINTK
(paren
id|PHASE_RESELECT
op_or
id|PHASE_MSGOUT
comma
l_string|&quot;scsi%d : sent IDENTIFY message.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef LINKED
r_case
id|LINKED_WRONG
suffix:colon
id|WRITE_DATA
(paren
id|ABORT
)paren
suffix:semicolon
id|linked_connected
op_assign
l_int|0
suffix:semicolon
id|reselect
op_assign
id|CAN_RECONNECT
suffix:semicolon
r_goto
id|connect_loop
suffix:semicolon
id|DPRINTK
(paren
id|PHASE_MSGOUT
op_or
id|DEBUG_LINKED
comma
l_string|&quot;scsi%d : sent ABORT message to cancel incorrect I_T_L nexus.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif /* LINKED */
id|DPRINTK
(paren
id|DEBUG_LINKED
comma
l_string|&quot;correct&bslash;n&quot;
)paren
suffix:semicolon
r_default
suffix:colon
id|WRITE_DATA
(paren
id|NOP
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi%d : target %d requested MSGOUT, sent NOP message.&bslash;n&quot;
comma
id|hostno
comma
id|target
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|REQ_MSGIN
suffix:colon
r_switch
c_cond
(paren
id|message
op_assign
id|DATA
)paren
(brace
r_case
id|DISCONNECT
suffix:colon
id|DANY
(paren
l_string|&quot;seagate: deciding to disconnect&bslash;n&quot;
)paren
suffix:semicolon
id|should_reconnect
op_assign
l_int|1
suffix:semicolon
id|current_data
op_assign
id|data
suffix:semicolon
multiline_comment|/* WDE add */
id|current_buffer
op_assign
id|buffer
suffix:semicolon
id|current_bufflen
op_assign
id|len
suffix:semicolon
multiline_comment|/* WDE add */
id|current_nobuffs
op_assign
id|nobuffs
suffix:semicolon
macro_line|#ifdef LINKED
id|linked_connected
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|done
op_assign
l_int|1
suffix:semicolon
id|DPRINTK
(paren
(paren
id|PHASE_RESELECT
op_or
id|PHASE_MSGIN
)paren
comma
l_string|&quot;scsi%d : disconnected.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef LINKED
r_case
id|LINKED_CMD_COMPLETE
suffix:colon
r_case
id|LINKED_FLG_CMD_COMPLETE
suffix:colon
macro_line|#endif
r_case
id|COMMAND_COMPLETE
suffix:colon
multiline_comment|/*&n; * Note : we should check for underflow here.&n; */
id|DPRINTK
(paren
id|PHASE_MSGIN
comma
l_string|&quot;scsi%d : command complete.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ABORT
suffix:colon
id|DPRINTK
(paren
id|PHASE_MSGIN
comma
l_string|&quot;scsi%d : abort message.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SAVE_POINTERS
suffix:colon
id|current_buffer
op_assign
id|buffer
suffix:semicolon
id|current_bufflen
op_assign
id|len
suffix:semicolon
multiline_comment|/* WDE add */
id|current_data
op_assign
id|data
suffix:semicolon
multiline_comment|/* WDE mod */
id|current_nobuffs
op_assign
id|nobuffs
suffix:semicolon
id|DPRINTK
(paren
id|PHASE_MSGIN
comma
l_string|&quot;scsi%d : pointers saved.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESTORE_POINTERS
suffix:colon
id|buffer
op_assign
id|current_buffer
suffix:semicolon
id|cmnd
op_assign
id|current_cmnd
suffix:semicolon
id|data
op_assign
id|current_data
suffix:semicolon
multiline_comment|/* WDE mod */
id|len
op_assign
id|current_bufflen
suffix:semicolon
id|nobuffs
op_assign
id|current_nobuffs
suffix:semicolon
id|DPRINTK
(paren
id|PHASE_MSGIN
comma
l_string|&quot;scsi%d : pointers restored.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n; *    IDENTIFY distinguishes itself from the other messages by setting the&n; *      high byte. [FIXME: should not this read &quot;the high bit&quot;? - pavel@ucw.cz]&n; *&n; *      Note : we need to handle at least one outstanding command per LUN,&n; *      and need to hash the SCSI command for that I_T_L nexus based on the&n; *      known ID (at this point) and LUN.&n; */
r_if
c_cond
(paren
id|message
op_amp
l_int|0x80
)paren
(brace
id|DPRINTK
(paren
id|PHASE_MSGIN
comma
l_string|&quot;scsi%d : IDENTIFY message received from id %d, lun %d.&bslash;n&quot;
comma
id|hostno
comma
id|target
comma
id|message
op_amp
l_int|7
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n; *      We should go into a MESSAGE OUT phase, and send  a MESSAGE_REJECT&n; *      if we run into a message that we don&squot;t like.  The seagate driver&n; *      needs some serious restructuring first though.&n; */
id|DPRINTK
(paren
id|PHASE_MSGIN
comma
l_string|&quot;scsi%d : unknown message %d from target %d.&bslash;n&quot;
comma
id|hostno
comma
id|message
comma
id|target
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;scsi%d : unknown phase.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_ERROR
suffix:semicolon
)brace
multiline_comment|/* end of switch (status_read &amp;&n;                                           REQ_MASK) */
macro_line|#ifdef SLOW_RATE
multiline_comment|/*&n; * I really don&squot;t care to deal with borken devices in each single&n; * byte transfer case (ie, message in, message out, status), so&n; * I&squot;ll do the wait here if necessary.&n; */
r_if
c_cond
(paren
id|borken
)paren
id|borken_wait
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* if(status_read &amp; STAT_REQ) ends */
)brace
multiline_comment|/* while(((status_read = STATUS)...)&n;                                           ends */
id|DPRINTK
(paren
id|PHASE_DATAIN
op_or
id|PHASE_DATAOUT
op_or
id|PHASE_EXIT
comma
l_string|&quot;scsi%d : Transfered %d bytes&bslash;n&quot;
comma
id|hostno
comma
id|transfered
)paren
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_EXIT)
macro_line|#if 0                                   /* Doesn&squot;t work for scatter/gather */
id|printk
(paren
l_string|&quot;Buffer : &bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
op_increment
id|i
)paren
id|printk
(paren
l_string|&quot;%02x  &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|data
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* WDE mod */
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|printk
(paren
l_string|&quot;scsi%d : status = &quot;
comma
id|hostno
)paren
suffix:semicolon
id|print_status
(paren
id|status
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;message = %02x&bslash;n&quot;
comma
id|message
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* We shouldn&squot;t reach this until *after* BSY has been deasserted */
macro_line|#ifdef LINKED
r_else
(brace
multiline_comment|/*&n; * Fix the message byte so that unsuspecting high level drivers don&squot;t&n; * puke when they see a LINKED COMMAND message in place of the COMMAND&n; * COMPLETE they may be expecting.  Shouldn&squot;t be necessary, but it&squot;s&n; * better to be on the safe side.&n; *&n; * A non LINKED* message byte will indicate that the command completed,&n; * and we are now disconnected.&n; */
r_switch
c_cond
(paren
id|message
)paren
(brace
r_case
id|LINKED_CMD_COMPLETE
suffix:colon
r_case
id|LINKED_FLG_CMD_COMPLETE
suffix:colon
id|message
op_assign
id|COMMAND_COMPLETE
suffix:semicolon
id|linked_target
op_assign
id|current_target
suffix:semicolon
id|linked_lun
op_assign
id|current_lun
suffix:semicolon
id|linked_connected
op_assign
l_int|1
suffix:semicolon
id|DPRINTK
(paren
id|DEBUG_LINKED
comma
l_string|&quot;scsi%d : keeping I_T_L nexus established&quot;
l_string|&quot;for linked command.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
multiline_comment|/* We also will need to adjust status to accommodate intermediate&n;       conditions. */
r_if
c_cond
(paren
(paren
id|status
op_eq
id|INTERMEDIATE_GOOD
)paren
op_logical_or
(paren
id|status
op_eq
id|INTERMEDIATE_C_GOOD
)paren
)paren
id|status
op_assign
id|GOOD
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n; * We should also handle what are &quot;normal&quot; termination messages&n; * here (ABORT, BUS_DEVICE_RESET?, and COMMAND_COMPLETE individually,&n; * and flake if things aren&squot;t right.&n; */
r_default
suffix:colon
id|DPRINTK
(paren
id|DEBUG_LINKED
comma
l_string|&quot;scsi%d : closing I_T_L nexus.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|linked_connected
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif /* LINKED */
r_if
c_cond
(paren
id|should_reconnect
)paren
(brace
id|DPRINTK
(paren
id|PHASE_RESELECT
comma
l_string|&quot;scsi%d : exiting seagate_st0x_queue_command()&quot;
l_string|&quot;with reconnect enabled.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|WRITE_CONTROL
(paren
id|BASE_CMD
op_or
id|CMD_INTR
)paren
suffix:semicolon
)brace
r_else
id|WRITE_CONTROL
(paren
id|BASE_CMD
)paren
suffix:semicolon
r_return
id|retcode
(paren
id|st0x_aborted
)paren
suffix:semicolon
)brace
multiline_comment|/* end of internal_command */
DECL|function|seagate_st0x_abort
r_int
id|seagate_st0x_abort
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|st0x_aborted
op_assign
id|DID_ABORT
suffix:semicolon
r_return
id|SCSI_ABORT_PENDING
suffix:semicolon
)brace
DECL|macro|ULOOP
macro_line|#undef ULOOP
DECL|macro|TIMEOUT
macro_line|#undef TIMEOUT
multiline_comment|/*&n; * the seagate_st0x_reset function resets the SCSI bus &n; */
DECL|function|seagate_st0x_reset
r_int
id|seagate_st0x_reset
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_int
id|reset_flags
)paren
(brace
multiline_comment|/* No timeouts - this command is going to fail because it was reset. */
id|DANY
(paren
l_string|&quot;scsi%d: Reseting bus... &quot;
comma
id|hostno
)paren
suffix:semicolon
multiline_comment|/* assert  RESET signal on SCSI bus.  */
id|WRITE_CONTROL
(paren
id|BASE_CMD
op_or
id|CMD_RST
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
op_star
l_int|1000
)paren
suffix:semicolon
id|WRITE_CONTROL
(paren
id|BASE_CMD
)paren
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_RESET
suffix:semicolon
id|DANY
(paren
l_string|&quot;done.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|SCSI_RESET_WAKEUP
suffix:semicolon
)brace
multiline_comment|/* Eventually this will go into an include file, but this will be later */
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|SEAGATE_ST0X
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
eof
