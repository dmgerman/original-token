multiline_comment|/*&n; *  scsi_error.c Copyright (C) 1997 Eric Youngdale&n; *&n; *  SCSI error/timeout handling&n; *      Initial versions: Eric Youngdale.  Based upon conversations with&n; *&t;&t;&t;  Leonard Zubkoff and David Miller at Linux Expo, &n; *&t;&t;&t;  ideas originating from all over the place.&n; *&n; */
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;constants.h&quot;
DECL|macro|SHUTDOWN_SIGS
mdefine_line|#define SHUTDOWN_SIGS&t;(sigmask(SIGKILL)|sigmask(SIGINT)|sigmask(SIGTERM))
macro_line|#ifdef DEBUG
DECL|macro|SENSE_TIMEOUT
mdefine_line|#define SENSE_TIMEOUT SCSI_TIMEOUT
DECL|macro|ABORT_TIMEOUT
mdefine_line|#define ABORT_TIMEOUT SCSI_TIMEOUT
DECL|macro|RESET_TIMEOUT
mdefine_line|#define RESET_TIMEOUT SCSI_TIMEOUT
macro_line|#else
DECL|macro|SENSE_TIMEOUT
mdefine_line|#define SENSE_TIMEOUT (10*HZ)
DECL|macro|RESET_TIMEOUT
mdefine_line|#define RESET_TIMEOUT (2*HZ)
DECL|macro|ABORT_TIMEOUT
mdefine_line|#define ABORT_TIMEOUT (15*HZ)
macro_line|#endif
DECL|macro|STATIC
mdefine_line|#define STATIC
multiline_comment|/*&n; * These should *probably* be handled by the host itself.&n; * Since it is allowed to sleep, it probably should.&n; */
DECL|macro|BUS_RESET_SETTLE_TIME
mdefine_line|#define BUS_RESET_SETTLE_TIME   5*HZ
DECL|macro|HOST_RESET_SETTLE_TIME
mdefine_line|#define HOST_RESET_SETTLE_TIME  10*HZ
DECL|variable|RCSid
r_static
r_const
r_char
id|RCSid
(braket
)braket
op_assign
l_string|&quot;$Header: /mnt/ide/home/eric/CVSROOT/linux/drivers/scsi/scsi_error.c,v 1.10 1997/12/08 04:50:35 eric Exp $&quot;
suffix:semicolon
id|STATIC
r_int
id|scsi_check_sense
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_request_sense
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
id|STATIC
r_void
id|scsi_send_eh_cmnd
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|timeout
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_try_to_abort_command
c_func
(paren
id|Scsi_Cmnd
op_star
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_test_unit_ready
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_try_bus_device_reset
c_func
(paren
id|Scsi_Cmnd
op_star
comma
r_int
id|timeout
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_try_bus_reset
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_try_host_reset
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_unit_is_ready
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
id|STATIC
r_void
id|scsi_eh_action_done
c_func
(paren
id|Scsi_Cmnd
op_star
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_eh_retry_command
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_eh_completed_normally
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
id|STATIC
r_void
id|scsi_restart_operations
c_func
(paren
r_struct
id|Scsi_Host
op_star
)paren
suffix:semicolon
id|STATIC
r_void
id|scsi_eh_finish_command
c_func
(paren
id|Scsi_Cmnd
op_star
op_star
id|SClist
comma
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n; * Function:    scsi_add_timer()&n; *&n; * Purpose:     Start timeout timer for a single scsi command.&n; *&n; * Arguments:   SCset   - command that is about to start running.&n; *              timeout - amount of time to allow this command to run.&n; *              complete - timeout function to call if timer isn&squot;t&n; *                      canceled.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:&t;This should be turned into an inline function.&n; *&n; * More Notes:  Each scsi command has it&squot;s own timer, and as it is added to&n; *              the queue, we set up the timer.  When the command completes,&n; *              we cancel the timer.  Pretty simple, really, especially&n; *              compared to the old way of handling this crap.&n; */
r_void
DECL|function|scsi_add_timer
id|scsi_add_timer
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCset
comma
r_int
id|timeout
comma
r_void
(paren
op_star
id|complete
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
multiline_comment|/*&n;     * If the clock was already running for this command, then&n;     * first delete the timer.  The timer handling code gets rather&n;     * confused if we don&squot;t do this.&n;     */
r_if
c_cond
(paren
id|SCset-&gt;eh_timeout.function
op_ne
l_int|NULL
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|SCset-&gt;eh_timeout
)paren
suffix:semicolon
)brace
id|SCset-&gt;eh_timeout.data
op_assign
(paren
r_int
r_int
)paren
id|SCset
suffix:semicolon
id|SCset-&gt;eh_timeout.expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|SCset-&gt;eh_timeout.function
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|complete
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Adding timer for command %p at %d (%p)&bslash;n&quot;
comma
id|SCset
comma
id|timeout
comma
id|complete
)paren
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|SCset-&gt;eh_timeout
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_delete_timer()&n; *&n; * Purpose:     Delete/cancel timer for a given function.&n; *&n; * Arguments:   SCset   - command that we are canceling timer for.&n; *&n; * Returns:     Amount of time remaining before command would have timed out.&n; *&n; * Notes:&t;This should be turned into an inline function.&n; */
r_int
DECL|function|scsi_delete_timer
id|scsi_delete_timer
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCset
)paren
(brace
r_int
id|rtn
suffix:semicolon
id|rtn
op_assign
id|jiffies
op_minus
id|SCset-&gt;eh_timeout.expires
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|SCset-&gt;eh_timeout
)paren
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Clearing timer for command %p&bslash;n&quot;
comma
id|SCset
)paren
)paren
suffix:semicolon
id|SCset-&gt;eh_timeout.data
op_assign
(paren
r_int
r_int
)paren
l_int|NULL
suffix:semicolon
id|SCset-&gt;eh_timeout.function
op_assign
l_int|NULL
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_times_out()&n; *&n; * Purpose:     Timeout function for normal scsi commands..&n; *&n; * Arguments:   SCpnt   - command that is timing out.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:&n; */
DECL|function|do_scsi_times_out
r_static
r_void
id|do_scsi_times_out
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
multiline_comment|/* &n;     * Notify the low-level code that this operation failed and we are&n;     * reposessing the command.  &n;     */
macro_line|#ifdef ERIC_neverdef
multiline_comment|/*&n;     * FIXME(eric)&n;     * Allow the host adapter to push a queue ordering tag&n;     * out to the bus to force the command in question to complete.&n;     * If the host wants to do this, then we just restart the timer&n;     * for the command.  Before we really do this, some real thought&n;     * as to the optimum way to handle this should be done.  We *do*&n;     * need to force ordering every so often to ensure that all requests&n;     * do eventually complete, but I am not sure if this is the best way&n;     * to actually go about it.&n;     *&n;     * Better yet, force a sync here, but don&squot;t block since we are in an&n;     * interrupt.&n;     */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;hostt-&gt;eh_ordered_queue_tag
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|SCpnt-&gt;host-&gt;hostt-&gt;eh_ordered_queue_tag
)paren
(paren
id|SCpnt
)paren
)paren
(brace
id|scsi_add_timer
c_func
(paren
id|SCpnt
comma
id|SCpnt-&gt;internal_timeout
comma
id|scsi_times_out
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * FIXME(eric) - add a second special interface to handle this&n;     * case.  Ideally that interface can also be used to request&n;     * a queu&n;     */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;can_queue
)paren
(brace
id|SCpnt-&gt;host-&gt;hostt-&gt;queuecommand
(paren
id|SCpnt
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Set the serial_number_at_timeout to the current serial_number */
id|SCpnt-&gt;serial_number_at_timeout
op_assign
id|SCpnt-&gt;serial_number
suffix:semicolon
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_TIMEOUT
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_ERROR_HANDLER
suffix:semicolon
id|SCpnt-&gt;host-&gt;in_recovery
op_assign
l_int|1
suffix:semicolon
id|SCpnt-&gt;host-&gt;host_failed
op_increment
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command timed out active=%d busy=%d failed=%d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
comma
id|SCpnt-&gt;host-&gt;host_busy
comma
id|SCpnt-&gt;host-&gt;host_failed
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * If the host is having troubles, then look to see if this was the last&n;     * command that might have failed.  If so, wake up the error handler.&n;     */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;host_busy
op_eq
id|SCpnt-&gt;host-&gt;host_failed
)paren
(brace
id|up
c_func
(paren
id|SCpnt-&gt;host-&gt;eh_wait
)paren
suffix:semicolon
)brace
)brace
DECL|function|scsi_times_out
r_void
id|scsi_times_out
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|do_scsi_times_out
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function     scsi_block_when_processing_errors&n; *&n; * Purpose:     Prevent more commands from being queued while error recovery&n; *              is taking place.&n; *&n; * Arguments:   SDpnt - device on which we are performing recovery.&n; *&n; * Returns:     FALSE   The device was taken offline by error recovery.&n; *              TRUE    OK to proceed.&n; *&n; * Notes:       We block until the host is out of error recovery, and then&n; *              check to see whether the host or the device is offline.&n; */
r_int
DECL|function|scsi_block_when_processing_errors
id|scsi_block_when_processing_errors
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
)paren
(brace
id|SCSI_SLEEP
c_func
(paren
op_amp
id|SDpnt-&gt;host-&gt;host_wait
comma
id|SDpnt-&gt;host-&gt;in_recovery
)paren
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Open returning %d&bslash;n&quot;
comma
id|SDpnt-&gt;online
)paren
)paren
suffix:semicolon
r_return
id|SDpnt-&gt;online
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_eh_times_out()&n; *&n; * Purpose:     Timeout function for error handling.&n; *&n; * Arguments:   SCpnt   - command that is timing out.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:&t;During error handling, the kernel thread will be sleeping&n; *&t;&t;waiting for some action to complete on the device.  Our only&n; *&t;&t;job is to record that it timed out, and to wake up the&n; *&t;&t;thread.&n; */
id|STATIC
DECL|function|scsi_eh_times_out
r_void
id|scsi_eh_times_out
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rtn
op_assign
id|FAILED
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|SCpnt-&gt;eh_state
op_assign
id|SCSI_STATE_TIMEOUT
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
multiline_comment|/*&n;   * As far as the low level driver is concerned, this command is still&n;   * active, so we must give the low level driver a chance to abort it. (DB)&n;   */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;hostt-&gt;eh_abort_handler
)paren
id|rtn
op_assign
id|SCpnt-&gt;host-&gt;hostt
op_member_access_from_pointer
id|eh_abort_handler
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_ERROR_HANDLER
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;In scsi_eh_times_out %p&bslash;n&quot;
comma
id|SCpnt
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;eh_action
op_ne
l_int|NULL
)paren
id|up
c_func
(paren
id|SCpnt-&gt;host-&gt;eh_action
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;Missing scsi error handler thread&bslash;n&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_eh_done()&n; *&n; * Purpose:     Completion function for error handling.&n; *&n; * Arguments:   SCpnt   - command that is timing out.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:&t;During error handling, the kernel thread will be sleeping&n; *&t;&t;waiting for some action to complete on the device.  Our only&n; *&t;&t;job is to record that the action completed, and to wake up the&n; *&t;&t;thread.&n; */
id|STATIC
DECL|function|scsi_eh_done
r_void
id|scsi_eh_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_ERROR_HANDLER
suffix:semicolon
id|SCpnt-&gt;eh_state
op_assign
id|SUCCESS
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;In eh_done %p result:%x&bslash;n&quot;
comma
id|SCpnt
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;eh_action
op_ne
l_int|NULL
)paren
id|up
c_func
(paren
id|SCpnt-&gt;host-&gt;eh_action
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_eh_action_done()&n; *&n; * Purpose:     Completion function for error handling.&n; *&n; * Arguments:   SCpnt   - command that is timing out.&n; *&t;&t;answer  - boolean that indicates whether operation succeeded.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:&t;This callback is only used for abort and reset operations.&n; */
id|STATIC
DECL|function|scsi_eh_action_done
r_void
id|scsi_eh_action_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|answer
)paren
(brace
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_ERROR_HANDLER
suffix:semicolon
id|SCpnt-&gt;eh_state
op_assign
(paren
id|answer
ques
c_cond
id|SUCCESS
suffix:colon
id|FAILED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;eh_action
op_ne
l_int|NULL
)paren
id|up
c_func
(paren
id|SCpnt-&gt;host-&gt;eh_action
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_sense_valid()&n; *&n; * Purpose:&t;Determine whether a host has automatically obtained sense&n; *&t;&t;information or not.  If we have it, then give a recommendation&n; *&t;&t;as to what we should do next.&n; */
r_int
DECL|function|scsi_sense_valid
id|scsi_sense_valid
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x70
)paren
op_rshift
l_int|4
)paren
op_ne
l_int|7
)paren
(brace
r_return
id|FALSE
suffix:semicolon
)brace
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_eh_retry_command()&n; *&n; * Purpose:&t;Retry the original command&n; *&n; * Returns:&t;SUCCESS - we were able to get the sense data.&n; *&t;&t;FAILED  - we were not able to get the sense data.&n; * &n; * Notes:&t;This function will *NOT* return until the command either&n; *&t;&t;times out, or it completes.&n; */
id|STATIC
r_int
DECL|function|scsi_eh_retry_command
id|scsi_eh_retry_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|SCpnt-&gt;buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|SCpnt-&gt;bufflen
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|SCpnt-&gt;old_cmd_len
suffix:semicolon
id|scsi_send_eh_cmnd
(paren
id|SCpnt
comma
id|SCpnt-&gt;timeout_per_command
)paren
suffix:semicolon
multiline_comment|/*&n;   * Hey, we are done.  Let&squot;s look to see what happened.&n;   */
r_return
id|SCpnt-&gt;eh_state
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_request_sense()&n; *&n; * Purpose:&t;Request sense data from a particular target.&n; *&n; * Returns:&t;SUCCESS - we were able to get the sense data.&n; *&t;&t;FAILED  - we were not able to get the sense data.&n; * &n; * Notes:&t;Some hosts automatically obtain this information, others&n; *&t;&t;require that we obtain it on our own.&n; *&n; *&t;&t;This function will *NOT* return until the command either&n; *&t;&t;times out, or it completes.&n; */
id|STATIC
r_int
DECL|function|scsi_request_sense
id|scsi_request_sense
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_static
r_int
r_char
id|generic_sense
(braket
l_int|6
)braket
op_assign
(brace
id|REQUEST_SENSE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|255
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|scsi_result0
(braket
l_int|256
)braket
comma
op_star
id|scsi_result
op_assign
l_int|NULL
suffix:semicolon
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|generic_sense
comma
r_sizeof
(paren
id|generic_sense
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|SCpnt-&gt;lun
op_lshift
l_int|5
suffix:semicolon
id|scsi_result
op_assign
(paren
op_logical_neg
id|SCpnt-&gt;host-&gt;hostt-&gt;unchecked_isa_dma
)paren
ques
c_cond
op_amp
id|scsi_result0
(braket
l_int|0
)braket
suffix:colon
id|scsi_init_malloc
(paren
l_int|512
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_result
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot allocate scsi_result in scsi_request_sense.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/*&n;   * Zero the sense buffer.  Some host adapters automatically always request&n;   * sense, so it is not a good idea that SCpnt-&gt;request_buffer and&n;   * SCpnt-&gt;sense_buffer point to the same address (DB).&n;   * 0 is not a valid sense code. &n;   */
id|memset
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|memset
(paren
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|scsi_result
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
l_int|256
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|scsi_send_eh_cmnd
(paren
id|SCpnt
comma
id|SENSE_TIMEOUT
)paren
suffix:semicolon
multiline_comment|/* Last chance to have valid sense data */
r_if
c_cond
(paren
op_logical_neg
id|scsi_sense_valid
c_func
(paren
id|SCpnt
)paren
)paren
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
id|SCpnt-&gt;request_buffer
comma
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_result
op_ne
op_amp
id|scsi_result0
(braket
l_int|0
)braket
op_logical_and
id|scsi_result
op_ne
l_int|NULL
)paren
id|scsi_init_free
(paren
id|scsi_result
comma
l_int|512
)paren
suffix:semicolon
multiline_comment|/*&n;   * When we eventually call scsi_finish, we really wish to complete&n;   * the original request, so let&squot;s restore the original data. (DB)&n;   */
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|SCpnt-&gt;buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|SCpnt-&gt;bufflen
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|SCpnt-&gt;old_cmd_len
suffix:semicolon
multiline_comment|/*&n;   * Hey, we are done.  Let&squot;s look to see what happened.&n;   */
r_return
id|SCpnt-&gt;eh_state
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_test_unit_ready()&n; *&n; * Purpose:&t;Run test unit ready command to see if the device is talking to us or not.&n; *&n; */
id|STATIC
r_int
DECL|function|scsi_test_unit_ready
id|scsi_test_unit_ready
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_static
r_int
r_char
id|tur_command
(braket
l_int|6
)braket
op_assign
(brace
id|TEST_UNIT_READY
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|scsi_result0
(braket
l_int|256
)braket
comma
op_star
id|scsi_result
op_assign
l_int|NULL
suffix:semicolon
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|tur_command
comma
r_sizeof
(paren
id|tur_command
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|SCpnt-&gt;lun
op_lshift
l_int|5
suffix:semicolon
id|scsi_result
op_assign
(paren
op_logical_neg
id|SCpnt-&gt;host-&gt;hostt-&gt;unchecked_isa_dma
)paren
ques
c_cond
op_amp
id|scsi_result0
(braket
l_int|0
)braket
suffix:colon
id|scsi_init_malloc
(paren
l_int|512
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_result
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot allocate scsi_result in scsi_test_unit_ready.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/*&n;   * Zero the sense buffer.  Some host adapters automatically always request&n;   * sense, so it is not a good idea that SCpnt-&gt;request_buffer and&n;   * SCpnt-&gt;sense_buffer point to the same address (DB).&n;   * 0 is not a valid sense code. &n;   */
id|memset
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|memset
(paren
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|scsi_result
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
l_int|256
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|scsi_send_eh_cmnd
(paren
id|SCpnt
comma
id|SENSE_TIMEOUT
)paren
suffix:semicolon
multiline_comment|/* Last chance to have valid sense data */
r_if
c_cond
(paren
op_logical_neg
id|scsi_sense_valid
c_func
(paren
id|SCpnt
)paren
)paren
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
id|SCpnt-&gt;request_buffer
comma
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_result
op_ne
op_amp
id|scsi_result0
(braket
l_int|0
)braket
op_logical_and
id|scsi_result
op_ne
l_int|NULL
)paren
id|scsi_init_free
(paren
id|scsi_result
comma
l_int|512
)paren
suffix:semicolon
multiline_comment|/*&n;   * When we eventually call scsi_finish, we really wish to complete&n;   * the original request, so let&squot;s restore the original data. (DB)&n;   */
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|SCpnt-&gt;buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|SCpnt-&gt;bufflen
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|SCpnt-&gt;old_cmd_len
suffix:semicolon
multiline_comment|/*&n;   * Hey, we are done.  Let&squot;s look to see what happened.&n;   */
r_return
id|SCpnt-&gt;eh_state
suffix:semicolon
)brace
multiline_comment|/*&n; * This would normally need to get the IO request lock,&n; * but as it doesn&squot;t actually touch anything that needs&n; * to be locked we can avoid the lock here..&n; */
id|STATIC
DECL|function|scsi_sleep_done
r_void
id|scsi_sleep_done
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_if
c_cond
(paren
id|sem
op_ne
l_int|NULL
)paren
(brace
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
)brace
)brace
DECL|function|scsi_sleep
r_void
id|scsi_sleep
(paren
r_int
id|timeout
)paren
(brace
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
r_struct
id|timer_list
id|timer
suffix:semicolon
id|timer.data
op_assign
(paren
r_int
r_int
)paren
op_amp
id|sem
suffix:semicolon
id|timer.expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|timer.function
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|scsi_sleep_done
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Sleeping for timer tics %d&bslash;n&quot;
comma
id|timeout
)paren
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_send_eh_cmnd&n; *&n; * Purpose:&t;Send a command out to a device as part of error recovery.&n; *&n; * Notes:&t;The initialization of the structures is quite a bit different&n; *&t;&t;in this case, and furthermore, there is a different completion&n; *&t;&t;handler.&n; */
DECL|function|scsi_send_eh_cmnd
id|STATIC
r_void
id|scsi_send_eh_cmnd
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|timeout
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|retry
suffix:colon
multiline_comment|/*&n;     * We will use a queued command if possible, otherwise we will emulate the&n;     * queuing and calling of completion function ourselves.&n;     */
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;can_queue
)paren
(brace
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
id|SCpnt-&gt;eh_state
op_assign
id|SCSI_STATE_QUEUED
suffix:semicolon
id|scsi_add_timer
c_func
(paren
id|SCpnt
comma
id|timeout
comma
id|scsi_eh_times_out
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the semaphore so we wait for the command to complete.&n;&t; */
id|SCpnt-&gt;host-&gt;eh_action
op_assign
op_amp
id|sem
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|host-&gt;hostt-&gt;queuecommand
(paren
id|SCpnt
comma
id|scsi_eh_done
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|SCpnt-&gt;host-&gt;eh_action
op_assign
l_int|NULL
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|SCpnt-&gt;eh_timeout
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * See if timeout.  If so, tell the host to forget about it.&n;&t; * In other words, we don&squot;t want a callback any more.&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;eh_state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;send_eh_cmnd: %p eh_state:%x&bslash;n&quot;
comma
id|SCpnt
comma
id|SCpnt-&gt;eh_state
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|temp
suffix:semicolon
multiline_comment|/*&n;&t; * We damn well had better never use this code.  There is no timeout&n;&t; * protection here, since we would end up waiting in the actual low&n;&t; * level driver, we don&squot;t know how to wake it up.&n;&t; */
id|temp
op_assign
id|host-&gt;hostt-&gt;command
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|temp
suffix:semicolon
r_if
c_cond
(paren
id|scsi_eh_completed_normally
c_func
(paren
id|SCpnt
)paren
)paren
(brace
id|SCpnt-&gt;eh_state
op_assign
id|SUCCESS
suffix:semicolon
)brace
r_else
(brace
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * Now examine the actual status codes to see whether the command actually&n;     * did complete normally.&n;     */
r_if
c_cond
(paren
id|SCpnt-&gt;eh_state
op_eq
id|SUCCESS
)paren
(brace
r_switch
c_cond
(paren
id|scsi_eh_completed_normally
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_case
id|SUCCESS
suffix:colon
id|SCpnt-&gt;eh_state
op_assign
id|SUCCESS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NEEDS_RETRY
suffix:colon
r_goto
id|retry
suffix:semicolon
r_case
id|FAILED
suffix:colon
r_default
suffix:colon
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:&t;scsi_unit_is_ready()&n; *&n; * Purpose:&t;Called after TEST_UNIT_READY is run, to test to see if&n; *&t;&t;the unit responded in a way that indicates it is ready.&n; */
id|STATIC
r_int
DECL|function|scsi_unit_is_ready
id|scsi_unit_is_ready
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;result
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|driver_byte
(paren
id|SCpnt-&gt;result
)paren
op_amp
id|DRIVER_SENSE
)paren
op_logical_or
(paren
id|status_byte
(paren
id|SCpnt-&gt;result
)paren
op_amp
id|CHECK_CONDITION
)paren
)paren
op_logical_and
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x70
)paren
op_rshift
l_int|4
)paren
op_eq
l_int|7
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|NOT_READY
)paren
op_logical_and
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|UNIT_ATTENTION
)paren
op_logical_and
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|ILLEGAL_REQUEST
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_eh_finish_command&n; *&n; * Purpose:     Handle a command that we are finished with WRT error handling.&n; *&n; * Arguments:   SClist - pointer to list into which we are putting completed commands.&n; *              SCpnt  - command that is completing&n; *&n; * Notes:       We don&squot;t want to use the normal command completion while we are&n; *              are still handling errors - it may cause other commands to be queued,&n; *              and that would disturb what we are doing.  Thus we really want to keep&n; *              a list of pending commands for final completion, and once we&n; *              are ready to leave error handling we handle completion for real.&n; */
id|STATIC
r_void
DECL|function|scsi_eh_finish_command
id|scsi_eh_finish_command
c_func
(paren
id|Scsi_Cmnd
op_star
op_star
id|SClist
comma
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_BHQUEUE
suffix:semicolon
id|SCpnt-&gt;bh_next
op_assign
op_star
id|SClist
suffix:semicolon
multiline_comment|/*&n;     * Set this back so that the upper level can correctly free up&n;     * things.&n;     */
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
op_star
id|SClist
op_assign
id|SCpnt
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_try_to_abort_command&n; *&n; * Purpose:&t;Ask host adapter to abort a running command.&n; *&n; * Returns:&t;FAILED&t;&t;Operation failed or not supported.&n; *&t;&t;SUCCESS&t;&t;Succeeded.&n; *&n; * Notes:&t;This function will not return until the user&squot;s completion&n; *&t;&t;function has been called.  There is no timeout on this&n; *              operation.  If the author of the low-level driver wishes&n; *              this operation to be timed, they can provide this facility&n; *              themselves.  Helper functions in scsi_error.c can be supplied&n; *              to make this easier to do.&n; *&n; * Notes:&t;It may be possible to combine this with all of the reset&n; *&t;&t;handling to eliminate a lot of code duplication.  I don&squot;t&n; *&t;&t;know what makes more sense at the moment - this is just a&n; *&t;&t;prototype.&n; */
id|STATIC
r_int
DECL|function|scsi_try_to_abort_command
id|scsi_try_to_abort_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|timeout
)paren
(brace
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
multiline_comment|/* Until we come up with something better */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;hostt-&gt;eh_abort_handler
op_eq
l_int|NULL
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/* &n;   * scsi_done was called just after the command timed out and before&n;   * we had a chance to process it. (DB)&n;   */
r_if
c_cond
(paren
id|SCpnt-&gt;serial_number
op_eq
l_int|0
)paren
r_return
id|SUCCESS
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
r_return
id|SCpnt-&gt;host-&gt;hostt
op_member_access_from_pointer
id|eh_abort_handler
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_try_bus_device_reset&n; *&n; * Purpose:&t;Ask host adapter to perform a bus device reset for a given&n; *&t;&t;device.&n; *&n; * Returns:&t;FAILED&t;&t;Operation failed or not supported.&n; *&t;&t;SUCCESS&t;&t;Succeeded.&n; *&n; * Notes:&t;There is no timeout for this operation.  If this operation is&n; *              unreliable for a given host, then the host itself needs to put a&n; *              timer on it, and set the host back to a consistent state prior&n; *              to returning.&n; */
id|STATIC
r_int
DECL|function|scsi_try_bus_device_reset
id|scsi_try_bus_device_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|timeout
)paren
(brace
r_int
id|rtn
suffix:semicolon
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
multiline_comment|/* Until we come up with something better */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;hostt-&gt;eh_device_reset_handler
op_eq
l_int|NULL
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
id|rtn
op_assign
id|SCpnt-&gt;host-&gt;hostt
op_member_access_from_pointer
id|eh_device_reset_handler
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
id|SCpnt-&gt;eh_state
op_assign
id|SUCCESS
suffix:semicolon
r_return
id|SCpnt-&gt;eh_state
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_try_bus_reset&n; *&n; * Purpose:&t;Ask host adapter to perform a bus reset for a host.&n; *&n; * Returns:&t;FAILED&t;&t;Operation failed or not supported.&n; *&t;&t;SUCCESS&t;&t;Succeeded.&n; *&n; * Notes:&t;&n; */
id|STATIC
r_int
DECL|function|scsi_try_bus_reset
id|scsi_try_bus_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|rtn
suffix:semicolon
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
multiline_comment|/* Until we come up with something better */
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
id|SCpnt-&gt;serial_number
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;hostt-&gt;eh_bus_reset_handler
op_eq
l_int|NULL
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
id|rtn
op_assign
id|SCpnt-&gt;host-&gt;hostt
op_member_access_from_pointer
id|eh_bus_reset_handler
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
id|SCpnt-&gt;eh_state
op_assign
id|SUCCESS
suffix:semicolon
multiline_comment|/*&n;   * If we had a successful bus reset, mark the command blocks to expect&n;   * a condition code of unit attention.&n;   */
id|scsi_sleep
c_func
(paren
id|BUS_RESET_SETTLE_TIME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;eh_state
op_eq
id|SUCCESS
)paren
(brace
id|Scsi_Device
op_star
id|SDloop
suffix:semicolon
r_for
c_loop
(paren
id|SDloop
op_assign
id|SCpnt-&gt;host-&gt;host_queue
suffix:semicolon
id|SDloop
suffix:semicolon
id|SDloop
op_assign
id|SDloop-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;channel
op_eq
id|SDloop-&gt;channel
)paren
(brace
id|SDloop-&gt;was_reset
op_assign
l_int|1
suffix:semicolon
id|SDloop-&gt;expecting_cc_ua
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_return
id|SCpnt-&gt;eh_state
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_try_host_reset&n; *&n; * Purpose:&t;Ask host adapter to reset itself, and the bus.&n; *&n; * Returns:&t;FAILED&t;&t;Operation failed or not supported.&n; *&t;&t;SUCCESS&t;&t;Succeeded.&n; *&n; * Notes:&n; */
id|STATIC
r_int
DECL|function|scsi_try_host_reset
id|scsi_try_host_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|rtn
suffix:semicolon
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
multiline_comment|/* Until we come up with something better */
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
id|SCpnt-&gt;serial_number
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;hostt-&gt;eh_host_reset_handler
op_eq
l_int|NULL
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
id|rtn
op_assign
id|SCpnt-&gt;host-&gt;hostt
op_member_access_from_pointer
id|eh_host_reset_handler
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
id|SCpnt-&gt;eh_state
op_assign
id|SUCCESS
suffix:semicolon
multiline_comment|/*&n;     * If we had a successful host reset, mark the command blocks to expect&n;     * a condition code of unit attention.&n;     */
id|scsi_sleep
c_func
(paren
id|HOST_RESET_SETTLE_TIME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;eh_state
op_eq
id|SUCCESS
)paren
(brace
id|Scsi_Device
op_star
id|SDloop
suffix:semicolon
r_for
c_loop
(paren
id|SDloop
op_assign
id|SCpnt-&gt;host-&gt;host_queue
suffix:semicolon
id|SDloop
suffix:semicolon
id|SDloop
op_assign
id|SDloop-&gt;next
)paren
(brace
id|SDloop-&gt;was_reset
op_assign
l_int|1
suffix:semicolon
id|SDloop-&gt;expecting_cc_ua
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|SCpnt-&gt;eh_state
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_decide_disposition&n; *&n; * Purpose:&t;Examine a command block that has come back from the low-level&n; *&t;&t;and figure out what to do next.&n; *&n; * Returns:&t;SUCCESS&t;&t;- pass on to upper level.&n; *&t;&t;FAILED&t;&t;- pass on to error handler thread.&n; *&t;&t;RETRY&t;&t;- command should be retried.&n; *&t;&t;SOFTERR&t;&t;- command succeeded, but we need to log&n; *&t;&t;&t;&t;  a soft error.&n; *&n; * Notes:&t;This is *ONLY* called when we are examining the status&n; *&t;&t;after sending out the actual data command.  Any commands&n; *&t;&t;that are queued for error recovery (i.e. TEST_UNIT_READY)&n; *&t;&t;do *NOT* come through here.&n; *&n; *              NOTE - When this routine returns FAILED, it means the error&n; *              handler thread is woken.  In cases where the error code&n; *              indicates an error that doesn&squot;t require the error handler&n; *              thread (i.e. we don&squot;t need to abort/reset), then this function&n; *              should return SUCCESS.&n; */
DECL|function|scsi_decide_disposition
r_int
id|scsi_decide_disposition
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|rtn
suffix:semicolon
multiline_comment|/*&n;   * If the device is offline, then we clearly just pass the result back&n;   * up to the top level.&n;   */
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;online
op_eq
id|FALSE
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;scsi_error.c: device offline - report as SUCCESS&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n;   * First check the host byte, to see if there is anything in there&n;   * that would indicate what we need to do.&n;   */
r_switch
c_cond
(paren
id|host_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
)paren
(brace
r_case
id|DID_PASSTHROUGH
suffix:colon
multiline_comment|/*&n;         * No matter what, pass this through to the upper layer.&n;         * Nuke this special code so that it looks like we are saying&n;         * DID_OK.&n;         */
id|SCpnt-&gt;result
op_and_assign
l_int|0xff00ffff
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
r_case
id|DID_OK
suffix:colon
multiline_comment|/*&n;       * Looks good.  Drop through, and check the next byte.&n;       */
r_break
suffix:semicolon
r_case
id|DID_NO_CONNECT
suffix:colon
r_case
id|DID_BAD_TARGET
suffix:colon
r_case
id|DID_ABORT
suffix:colon
multiline_comment|/*&n;       * Note - this means that we just report the status back to the&n;       * top level driver, not that we actually think that it indicates&n;       * success.&n;       */
r_return
id|SUCCESS
suffix:semicolon
multiline_comment|/*&n;       * When the low level driver returns DID_SOFT_ERROR,&n;       * it is responsible for keeping an internal retry counter &n;       * in order to avoid endless loops (DB)&n;       */
r_case
id|DID_SOFT_ERROR
suffix:colon
r_return
id|NEEDS_RETRY
suffix:semicolon
r_case
id|DID_BUS_BUSY
suffix:colon
r_case
id|DID_PARITY
suffix:colon
r_case
id|DID_ERROR
suffix:colon
r_goto
id|maybe_retry
suffix:semicolon
r_case
id|DID_TIME_OUT
suffix:colon
multiline_comment|/*&n;         * When we scan the bus, we get timeout messages for&n;         * these commands if there is no device available.&n;         * Other hosts report DID_NO_CONNECT for the same thing.&n;         */
r_if
c_cond
(paren
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|TEST_UNIT_READY
op_logical_or
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
)paren
(brace
r_return
id|SUCCESS
suffix:semicolon
)brace
r_else
(brace
r_return
id|FAILED
suffix:semicolon
)brace
r_case
id|DID_RESET
suffix:colon
multiline_comment|/*&n;       * In the normal case where we haven&squot;t initiated a reset, this is&n;       * a failure.&n;       */
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|IS_RESETTING
)paren
(brace
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|IS_RESETTING
suffix:semicolon
r_goto
id|maybe_retry
suffix:semicolon
)brace
multiline_comment|/*&n;       * Examine the sense data to figure out how to proceed from here.&n;       * If there is no sense data, we will be forced into the error&n;       * handler thread, where we get to examine the thing in a lot more&n;       * detail.&n;       */
r_return
id|scsi_check_sense
(paren
id|SCpnt
)paren
suffix:semicolon
r_default
suffix:colon
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/*&n;   * Next, check the message byte.&n;   */
r_if
c_cond
(paren
id|msg_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
op_ne
id|COMMAND_COMPLETE
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/*&n;   * Now, check the status byte to see if this indicates anything special.&n;   */
r_switch
c_cond
(paren
id|status_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
)paren
(brace
r_case
id|QUEUE_FULL
suffix:colon
multiline_comment|/*&n;       * The case of trying to send too many commands to a tagged queueing&n;       * device.&n;       */
r_return
id|ADD_TO_MLQUEUE
suffix:semicolon
r_case
id|GOOD
suffix:colon
r_case
id|COMMAND_TERMINATED
suffix:colon
r_return
id|SUCCESS
suffix:semicolon
r_case
id|CHECK_CONDITION
suffix:colon
id|rtn
op_assign
id|scsi_check_sense
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|NEEDS_RETRY
)paren
(brace
r_goto
id|maybe_retry
suffix:semicolon
)brace
r_return
id|rtn
suffix:semicolon
r_case
id|CONDITION_GOOD
suffix:colon
r_case
id|INTERMEDIATE_GOOD
suffix:colon
r_case
id|INTERMEDIATE_C_GOOD
suffix:colon
multiline_comment|/*&n;       * Who knows?  FIXME(eric)&n;       */
r_return
id|SUCCESS
suffix:semicolon
r_case
id|BUSY
suffix:colon
r_case
id|RESERVATION_CONFLICT
suffix:colon
r_goto
id|maybe_retry
suffix:semicolon
r_default
suffix:colon
r_return
id|FAILED
suffix:semicolon
)brace
r_return
id|FAILED
suffix:semicolon
id|maybe_retry
suffix:colon
r_if
c_cond
(paren
(paren
op_increment
id|SCpnt-&gt;retries
)paren
OL
id|SCpnt-&gt;allowed
)paren
(brace
r_return
id|NEEDS_RETRY
suffix:semicolon
)brace
r_else
(brace
r_return
id|FAILED
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:&t;scsi_eh_completed_normally&n; *&n; * Purpose:&t;Examine a command block that has come back from the low-level&n; *&t;&t;and figure out what to do next.&n; *&n; * Returns:&t;SUCCESS&t;&t;- pass on to upper level.&n; *&t;&t;FAILED&t;&t;- pass on to error handler thread.&n; *&t;&t;RETRY&t;&t;- command should be retried.&n; *&t;&t;SOFTERR&t;&t;- command succeeded, but we need to log&n; *&t;&t;&t;&t;  a soft error.&n; *&n; * Notes:&t;This is *ONLY* called when we are examining the status&n; *&t;&t;of commands queued during error recovery.  The main&n; *&t;&t;difference here is that we don&squot;t allow for the possibility&n; *&t;&t;of retries here, and we are a lot more restrictive about what&n; *              we consider acceptable.&n; */
DECL|function|scsi_eh_completed_normally
id|STATIC
r_int
id|scsi_eh_completed_normally
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|rtn
suffix:semicolon
multiline_comment|/*&n;   * First check the host byte, to see if there is anything in there&n;   * that would indicate what we need to do.&n;   */
r_if
c_cond
(paren
id|host_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
op_eq
id|DID_RESET
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|IS_RESETTING
)paren
(brace
multiline_comment|/*&n;&t;  * OK, this is normal.  We don&squot;t know whether in fact the&n;&t;  * command in question really needs to be rerun or not - &n;&t;  * if this was the original data command then the answer is yes,&n;&t;  * otherwise we just flag it as success.&n;&t;  */
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|IS_RESETTING
suffix:semicolon
r_return
id|NEEDS_RETRY
suffix:semicolon
)brace
multiline_comment|/*&n;      * Rats.  We are already in the error handler, so we now get to try&n;      * and figure out what to do next.  If the sense is valid, we have&n;      * a pretty good idea of what to do.  If not, we mark it as failed.&n;      */
r_return
id|scsi_check_sense
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|host_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
op_ne
id|DID_OK
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/*&n;   * Next, check the message byte.&n;   */
r_if
c_cond
(paren
id|msg_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
op_ne
id|COMMAND_COMPLETE
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/*&n;   * Now, check the status byte to see if this indicates anything special.&n;   */
r_switch
c_cond
(paren
id|status_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
)paren
(brace
r_case
id|GOOD
suffix:colon
r_case
id|COMMAND_TERMINATED
suffix:colon
r_return
id|SUCCESS
suffix:semicolon
r_case
id|CHECK_CONDITION
suffix:colon
id|rtn
op_assign
id|scsi_check_sense
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|NEEDS_RETRY
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
r_return
id|rtn
suffix:semicolon
r_case
id|CONDITION_GOOD
suffix:colon
r_case
id|INTERMEDIATE_GOOD
suffix:colon
r_case
id|INTERMEDIATE_C_GOOD
suffix:colon
multiline_comment|/*&n;       * Who knows?  FIXME(eric)&n;       */
r_return
id|SUCCESS
suffix:semicolon
r_case
id|BUSY
suffix:colon
r_case
id|QUEUE_FULL
suffix:colon
r_case
id|RESERVATION_CONFLICT
suffix:colon
r_default
suffix:colon
r_return
id|FAILED
suffix:semicolon
)brace
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_check_sense&n; *&n; * Purpose:&t;Examine sense information - give suggestion as to what&n; *&t;&t;we should do with it.&n; */
DECL|function|scsi_check_sense
id|STATIC
r_int
id|scsi_check_sense
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|scsi_sense_valid
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xe0
)paren
r_return
id|SUCCESS
suffix:semicolon
r_switch
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
(brace
r_case
id|NO_SENSE
suffix:colon
r_return
id|SUCCESS
suffix:semicolon
r_case
id|RECOVERED_ERROR
suffix:colon
r_return
multiline_comment|/* SOFT_ERROR */
id|SUCCESS
suffix:semicolon
r_case
id|ABORTED_COMMAND
suffix:colon
r_return
id|NEEDS_RETRY
suffix:semicolon
r_case
id|NOT_READY
suffix:colon
r_case
id|UNIT_ATTENTION
suffix:colon
multiline_comment|/*&n;         * If we are expecting a CC/UA because of a bus reset that we&n;         * performed, treat this just as a retry.  Otherwise this is&n;         * information that we should pass up to the upper-level driver&n;         * so that we can deal with it there.&n;         */
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;expecting_cc_ua
)paren
(brace
id|SCpnt-&gt;device-&gt;expecting_cc_ua
op_assign
l_int|0
suffix:semicolon
r_return
id|NEEDS_RETRY
suffix:semicolon
)brace
r_return
id|SUCCESS
suffix:semicolon
multiline_comment|/* these three are not supported */
r_case
id|COPY_ABORTED
suffix:colon
r_case
id|VOLUME_OVERFLOW
suffix:colon
r_case
id|MISCOMPARE
suffix:colon
r_return
id|SUCCESS
suffix:semicolon
r_case
id|MEDIUM_ERROR
suffix:colon
r_return
id|NEEDS_RETRY
suffix:semicolon
r_case
id|ILLEGAL_REQUEST
suffix:colon
r_case
id|BLANK_CHECK
suffix:colon
r_case
id|DATA_PROTECT
suffix:colon
r_case
id|HARDWARE_ERROR
suffix:colon
r_default
suffix:colon
r_return
id|SUCCESS
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:&t;scsi_restart_operations&n; *&n; * Purpose:&t;Restart IO operations to the specified host.&n; *&n; * Arguments:&t;host  - host that we are restarting&n; *&n; * Returns:&t;Nothing&n; *&n; * Notes:&t;When we entered the error handler, we blocked all further&n; *&t;&t;I/O to this device.  We need to &squot;reverse&squot; this process.&n; */
id|STATIC
r_void
DECL|function|scsi_restart_operations
id|scsi_restart_operations
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
multiline_comment|/*&n;   * Next free up anything directly waiting upon the host.  This will be&n;   * requests for character device operations, and also for ioctls to queued&n;   * block devices.&n;   */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;scsi_error.c: Waking up host to restart&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|host-&gt;host_wait
)paren
suffix:semicolon
multiline_comment|/*&n;    * Finally, block devices need an extra kick in the pants.  This is because&n;    * the request queueing mechanism may have queued lots of pending requests&n;    * and there won&squot;t be a process waiting in a place where we can simply wake&n;    * it up.  Thus we simply go through and call the request function to goose&n;    * the various top level drivers and get things moving again.&n;    */
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Calling request function to restart things...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;scsi_request_fn
op_ne
l_int|NULL
)paren
(brace
(paren
op_star
id|SDpnt-&gt;scsi_request_fn
)paren
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Function:&t;scsi_unjam_host&n; *&n; * Purpose:&t;Attempt to fix a host which has a command that failed for&n; *&t;&t;some reason.&n; *&n; * Arguments:&t;host&t;- host that needs unjamming.&n; * &n; * Returns:&t;Nothing&n; *&n; * Notes:&t;When we come in here, we *know* that all commands on the&n; *&t;&t;bus have either completed, failed or timed out.  We also&n; *&t;&t;know that no further commands are being sent to the host,&n; *&t;&t;so things are relatively quiet and we have freedom to&n; *&t;&t;fiddle with things as we wish.&n; *&n; * Additional note:  This is only the *default* implementation.  It is possible&n; *&t;&t;for individual drivers to supply their own version of this&n; *&t;&t;function, and if the maintainer wishes to do this, it is&n; *&t;&t;strongly suggested that this function be taken as a template&n; *&t;&t;and modified.  This function was designed to correctly handle&n; *&t;&t;problems for about 95% of the different cases out there, and&n; *&t;&t;it should always provide at least a reasonable amount of error&n; *&t;&t;recovery.&n; *&n; * Note3:       Any command marked &squot;FAILED&squot; or &squot;TIMEOUT&squot; must eventually&n; *              have scsi_finish_command() called for it.  We do all of&n; *              the retry stuff here, so when we restart the host after we&n; *              return it should have an empty queue.&n; */
id|STATIC
r_int
DECL|function|scsi_unjam_host
id|scsi_unjam_host
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_int
id|devices_failed
suffix:semicolon
r_int
id|numfailed
suffix:semicolon
r_int
id|ourrtn
suffix:semicolon
r_int
id|rtn
op_assign
id|FALSE
suffix:semicolon
r_int
id|result
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCloop
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDloop
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCdone
suffix:semicolon
r_int
id|timed_out
suffix:semicolon
id|SCdone
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;   * First, protect against any sort of race condition.  If any of the outstanding&n;   * commands are in states that indicate that we are not yet blocked (i.e. we are&n;   * not in a quiet state) then we got woken up in error.  If we ever end up here,&n;   * we need to re-examine some of the assumptions.&n;   */
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;state
op_eq
id|SCSI_STATE_FAILED
op_logical_or
id|SCpnt-&gt;state
op_eq
id|SCSI_STATE_TIMEOUT
op_logical_or
id|SCpnt-&gt;state
op_eq
id|SCSI_STATE_INITIALIZING
op_logical_or
id|SCpnt-&gt;state
op_eq
id|SCSI_STATE_UNUSED
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;           * Rats.  Something is still floating around out there.  This could&n;           * be the result of the fact that the upper level drivers are still frobbing&n;           * commands that might have succeeded.  There are two outcomes.  One is that&n;           * the command block will eventually be freed, and the other one is that&n;           * the command will be queued and will be finished along the way.&n;           */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Error handler prematurely woken - commands still active (%p %x %d)&bslash;n&quot;
comma
id|SCpnt
comma
id|SCpnt-&gt;state
comma
id|SCpnt-&gt;target
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; *        panic(&quot;SCSI Error handler woken too early&bslash;n&quot;);&n; *&n; * This is no longer a problem, since now the code cares only about&n; * SCSI_STATE_TIMEOUT and SCSI_STATE_FAILED.&n; * Other states are useful only to release active commands when devices are&n; * set offline. If (host-&gt;host_active == host-&gt;host_busy) we can safely assume&n; * that there are no commands in state other then TIMEOUT od FAILED. (DB)&n; *&n; * FIXME:&n; * It is not easy to release correctly commands according to their state when &n; * devices are set offline, when the state is neither TIMEOUT nor FAILED.&n; * When a device is set offline, we can have some command with&n; * rq_status=RQ_SCSY_BUSY, owner=SCSI_STATE_HIGHLEVEL, &n; * state=SCSI_STATE_INITIALIZING and the driver module cannot be released.&n; * (DB, 17 May 1998)&n; */
)brace
)brace
multiline_comment|/*&n;   * Next, see if we need to request sense information.  if so,&n;   * then get it now, so we have a better idea of what to do.&n;   * FIXME(eric) this has the unfortunate side effect that if a host&n;   * adapter does not automatically request sense information, that we end&n;   * up shutting it down before we request it.  All hosts should be doing this&n;   * anyways, so for now all I have to say is tough noogies if you end up in here.&n;   * On second thought, this is probably a good idea.  We *really* want to give&n;   * authors an incentive to automatically request this.&n;   */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Checking to see if we need to request sense&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;state
op_ne
id|SCSI_STATE_FAILED
op_logical_or
id|scsi_sense_valid
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Requesting sense for %d&bslash;n&quot;
comma
id|SCpnt-&gt;target
)paren
)paren
suffix:semicolon
id|rtn
op_assign
id|scsi_request_sense
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_ne
id|SUCCESS
)paren
(brace
r_continue
suffix:semicolon
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Sense requested for %p - result %x&bslash;n&quot;
comma
id|SCpnt
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|print_sense
c_func
(paren
l_string|&quot;bh&quot;
comma
id|SCpnt
)paren
)paren
suffix:semicolon
id|result
op_assign
id|scsi_decide_disposition
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n;           * If the result was normal, then just pass it along to the&n;           * upper level.&n;           */
r_if
c_cond
(paren
id|result
op_eq
id|SUCCESS
)paren
(brace
id|SCpnt-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCpnt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ne
id|NEEDS_RETRY
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* &n;           * We only come in here if we want to retry a&n;           * command.  The test to see whether the command&n;           * should be retried should be keeping track of the&n;           * number of tries, so we don&squot;t end up looping, of&n;           * course.  &n;           */
id|SCpnt-&gt;state
op_assign
id|NEEDS_RETRY
suffix:semicolon
id|rtn
op_assign
id|scsi_eh_retry_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_ne
id|SUCCESS
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;           * We eventually hand this one back to the top level.&n;           */
id|SCpnt-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCpnt
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Go through the list of commands and figure out where we stand and how bad things&n;   * really are.&n;   */
id|numfailed
op_assign
l_int|0
suffix:semicolon
id|timed_out
op_assign
l_int|0
suffix:semicolon
id|devices_failed
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_int
r_int
id|device_error
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;state
op_eq
id|SCSI_STATE_FAILED
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Command to ID %d failed&bslash;n&quot;
comma
id|SCpnt-&gt;target
)paren
)paren
suffix:semicolon
id|numfailed
op_increment
suffix:semicolon
id|device_error
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Command to ID %d timedout&bslash;n&quot;
comma
id|SCpnt-&gt;target
)paren
)paren
suffix:semicolon
id|timed_out
op_increment
suffix:semicolon
id|device_error
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|device_error
OG
l_int|0
)paren
(brace
id|devices_failed
op_increment
suffix:semicolon
)brace
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;Total of %d+%d commands on %d devices require eh work&bslash;n&quot;
comma
id|numfailed
comma
id|timed_out
comma
id|devices_failed
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;host_failed
op_eq
l_int|0
)paren
(brace
id|ourrtn
op_assign
id|TRUE
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/*&n;   * Next, try and see whether or not it makes sense to try and abort&n;   * the running command.  This only works out to be the case if we have&n;   * one command that has timed out.  If the command simply failed, it&n;   * makes no sense to try and abort the command, since as far as the&n;   * host adapter is concerned, it isn&squot;t running.&n;   */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Checking to see if we want to try abort&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCloop
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCloop
suffix:semicolon
id|SCloop
op_assign
id|SCloop-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCloop-&gt;state
op_ne
id|SCSI_STATE_TIMEOUT
)paren
(brace
r_continue
suffix:semicolon
)brace
id|rtn
op_assign
id|scsi_try_to_abort_command
c_func
(paren
id|SCloop
comma
id|ABORT_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
id|rtn
op_assign
id|scsi_test_unit_ready
c_func
(paren
id|SCloop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
op_logical_and
id|scsi_unit_is_ready
c_func
(paren
id|SCloop
)paren
)paren
(brace
id|rtn
op_assign
id|scsi_eh_retry_command
c_func
(paren
id|SCloop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
id|SCloop-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCloop
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
multiline_comment|/*&n;   * If we have corrected all of the problems, then we are done.&n;   */
r_if
c_cond
(paren
id|host-&gt;host_failed
op_eq
l_int|0
)paren
(brace
id|ourrtn
op_assign
id|TRUE
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/*&n;   * Either the abort wasn&squot;t appropriate, or it didn&squot;t succeed.&n;   * Now try a bus device reset.  Still, look to see whether we have&n;   * multiple devices that are jammed or not - if we have multiple devices,&n;   * it makes no sense to try BUS_DEVICE_RESET - we really would need&n;   * to try a BUS_RESET instead.&n;   *&n;   * Does this make sense - should we try BDR on each device individually?&n;   * Yes, definitely.&n;   */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Checking to see if we want to try BDR&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCloop
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCloop
suffix:semicolon
id|SCloop
op_assign
id|SCloop-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCloop-&gt;state
op_eq
id|SCSI_STATE_FAILED
op_logical_or
id|SCloop-&gt;state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SCloop
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;       * OK, we have a device that is having problems.  Try and send&n;       * a bus device reset to it.&n;       *&n;       * FIXME(eric) - make sure we handle the case where multiple&n;       * commands to the same device have failed. They all must&n;       * get properly restarted.&n;       */
id|rtn
op_assign
id|scsi_try_bus_device_reset
c_func
(paren
id|SCloop
comma
id|RESET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
id|rtn
op_assign
id|scsi_test_unit_ready
c_func
(paren
id|SCloop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
op_logical_and
id|scsi_unit_is_ready
c_func
(paren
id|SCloop
)paren
)paren
(brace
id|rtn
op_assign
id|scsi_eh_retry_command
c_func
(paren
id|SCloop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
id|SCloop-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCloop
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|host-&gt;host_failed
op_eq
l_int|0
)paren
(brace
id|ourrtn
op_assign
id|TRUE
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/*&n;   * If we ended up here, we have serious problems.  The only thing left&n;   * to try is a full bus reset.  If someone has grabbed the bus and isn&squot;t&n;   * letting go, then perhaps this will help.&n;   */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Try hard bus reset&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;   * We really want to loop over the various channels, and do this on&n;   * a channel by channel basis.  We should also check to see if any&n;   * of the failed commands are on soft_reset devices, and if so, skip&n;   * the reset.  &n;   */
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
id|next_device
suffix:colon
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;state
op_ne
id|SCSI_STATE_FAILED
op_logical_and
id|SCpnt-&gt;state
op_ne
id|SCSI_STATE_TIMEOUT
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;           * We have a failed command.  Make sure there are no other failed&n;           * commands on the same channel that are timed out and implement a&n;           * soft reset.&n;           */
r_for
c_loop
(paren
id|SDloop
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDloop
suffix:semicolon
id|SDloop
op_assign
id|SDloop-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCloop
op_assign
id|SDloop-&gt;device_queue
suffix:semicolon
id|SCloop
suffix:semicolon
id|SCloop
op_assign
id|SCloop-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCloop-&gt;channel
op_ne
id|SCpnt-&gt;channel
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCloop-&gt;state
op_ne
id|SCSI_STATE_FAILED
op_logical_and
id|SCloop-&gt;state
op_ne
id|SCSI_STATE_TIMEOUT
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SDloop-&gt;soft_reset
op_logical_and
id|SCloop-&gt;state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
multiline_comment|/* &n;                       * If this device uses the soft reset option, and this&n;                       * is one of the devices acting up, then our only&n;                       * option is to wait a bit, since the command is&n;                       * supposedly still running.  &n;                       *&n;                       * FIXME(eric) - right now we will just end up falling&n;                       * through to the &squot;take device offline&squot; case.&n;                       *&n;                       * FIXME(eric) - It is possible that the command completed&n;                       * *after* the error recovery procedure started, and if this&n;                       * is the case, we are worrying about nothing here.&n;                       */
multiline_comment|/*&n;                       * Due to the spinlock, we will never get out of this&n;                       * loop without a proper wait (DB)&n;                       */
id|scsi_sleep
c_func
(paren
l_int|1
op_star
id|HZ
)paren
suffix:semicolon
r_goto
id|next_device
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;           * We now know that we are able to perform a reset for the&n;           * bus that SCpnt points to.  There are no soft-reset devices&n;           * with outstanding timed out commands.&n;           */
id|rtn
op_assign
id|scsi_try_bus_reset
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
r_for
c_loop
(paren
id|SDloop
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDloop
suffix:semicolon
id|SDloop
op_assign
id|SDloop-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCloop
op_assign
id|SDloop-&gt;device_queue
suffix:semicolon
id|SCloop
suffix:semicolon
id|SCloop
op_assign
id|SCloop-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCloop-&gt;channel
op_ne
id|SCpnt-&gt;channel
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCloop-&gt;state
op_ne
id|SCSI_STATE_FAILED
op_logical_and
id|SCloop-&gt;state
op_ne
id|SCSI_STATE_TIMEOUT
)paren
(brace
r_continue
suffix:semicolon
)brace
id|rtn
op_assign
id|scsi_test_unit_ready
c_func
(paren
id|SCloop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
op_logical_and
id|scsi_unit_is_ready
c_func
(paren
id|SCloop
)paren
)paren
(brace
id|rtn
op_assign
id|scsi_eh_retry_command
c_func
(paren
id|SCloop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
id|SCpnt-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCloop
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;                       * If the bus reset worked, but we are still unable to&n;                       * talk to the device, take it offline.&n;                       * FIXME(eric) - is this really the correct thing to do?&n;                       */
r_if
c_cond
(paren
id|rtn
op_ne
id|SUCCESS
)paren
(brace
id|SCloop-&gt;device-&gt;online
op_assign
id|FALSE
suffix:semicolon
id|SCloop-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCloop
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|host-&gt;host_failed
op_eq
l_int|0
)paren
(brace
id|ourrtn
op_assign
id|TRUE
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/*&n;   * If we ended up here, we have serious problems.  The only thing left&n;   * to try is a full host reset - perhaps the firmware on the device&n;   * crashed, or something like that.&n;   *&n;   * It is assumed that a succesful host reset will cause *all* information&n;   * about the command to be flushed from both the host adapter *and* the&n;   * device.&n;   *&n;   * FIXME(eric) - it isn&squot;t clear that devices that implement the soft reset&n;   * option can ever be cleared except via cycling the power.  The problem is&n;   * that sending the host reset command will cause the host to forget&n;   * about the pending command, but the device won&squot;t forget.  For now, we&n;   * skip the host reset option if any of the failed devices are configured&n;   * to use the soft reset option.&n;   */
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
id|next_device2
suffix:colon
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;state
op_ne
id|SCSI_STATE_FAILED
op_logical_and
id|SCpnt-&gt;state
op_ne
id|SCSI_STATE_TIMEOUT
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SDpnt-&gt;soft_reset
op_logical_and
id|SCpnt-&gt;state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
multiline_comment|/* &n;               * If this device uses the soft reset option, and this&n;               * is one of the devices acting up, then our only&n;               * option is to wait a bit, since the command is&n;               * supposedly still running.  &n;               *&n;               * FIXME(eric) - right now we will just end up falling&n;               * through to the &squot;take device offline&squot; case.&n;               */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Unable to try hard host reset&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;                * Due to the spinlock, we will never get out of this&n;                * loop without a proper wait. (DB)&n;                */
id|scsi_sleep
c_func
(paren
l_int|1
op_star
id|HZ
)paren
suffix:semicolon
r_goto
id|next_device2
suffix:semicolon
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Try hard host reset&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;           * FIXME(eric) - we need to obtain a valid SCpnt to perform this call.&n;           */
id|rtn
op_assign
id|scsi_try_host_reset
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
multiline_comment|/*&n;               * FIXME(eric) we assume that all commands are flushed from the&n;               * controller.  We should get a DID_RESET for all of the commands&n;               * that were pending.  We should ignore these so that we can&n;               * guarantee that we are in a consistent state.&n;               *&n;               * I believe this to be the case right now, but this needs to be&n;               * tested.&n;               */
r_for
c_loop
(paren
id|SDloop
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDloop
suffix:semicolon
id|SDloop
op_assign
id|SDloop-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCloop
op_assign
id|SDloop-&gt;device_queue
suffix:semicolon
id|SCloop
suffix:semicolon
id|SCloop
op_assign
id|SCloop-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCloop-&gt;state
op_ne
id|SCSI_STATE_FAILED
op_logical_and
id|SCloop-&gt;state
op_ne
id|SCSI_STATE_TIMEOUT
)paren
(brace
r_continue
suffix:semicolon
)brace
id|rtn
op_assign
id|scsi_test_unit_ready
c_func
(paren
id|SCloop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
op_logical_and
id|scsi_unit_is_ready
c_func
(paren
id|SCloop
)paren
)paren
(brace
id|rtn
op_assign
id|scsi_eh_retry_command
c_func
(paren
id|SCloop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
id|SCpnt-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCloop
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rtn
op_ne
id|SUCCESS
)paren
(brace
id|SCloop-&gt;device-&gt;online
op_assign
id|FALSE
suffix:semicolon
id|SCloop-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCloop
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
)brace
multiline_comment|/*&n;   * If we solved all of the problems, then let&squot;s rev up the engines again.&n;   */
r_if
c_cond
(paren
id|host-&gt;host_failed
op_eq
l_int|0
)paren
(brace
id|ourrtn
op_assign
id|TRUE
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/*&n;   * If the HOST RESET failed, then for now we assume that the entire host&n;   * adapter is too hosed to be of any use.  For our purposes, however, it is&n;   * easier to simply take the devices offline that correspond to commands&n;   * that failed.&n;   */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Take device offline&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCloop
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCloop
suffix:semicolon
id|SCloop
op_assign
id|SCloop-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCloop-&gt;state
op_eq
id|SCSI_STATE_FAILED
op_logical_or
id|SCloop-&gt;state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
id|SCloop-&gt;device-&gt;online
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/*&n;               * This should pass the failure up to the top level driver, and&n;               * it will have to try and do something intelligent with it.&n;               */
id|SCloop-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|SCloop-&gt;state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
id|SCloop-&gt;result
op_or_assign
(paren
id|DRIVER_TIMEOUT
op_lshift
l_int|24
)paren
suffix:semicolon
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Finishing command for device %d %x&bslash;n&quot;
comma
id|SCloop-&gt;device-&gt;id
comma
id|SCloop-&gt;result
)paren
)paren
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCloop
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|host-&gt;host_failed
op_ne
l_int|0
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;scsi_unjam_host: Miscount of number of failed commands.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Returning&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ourrtn
op_assign
id|FALSE
suffix:semicolon
id|leave
suffix:colon
multiline_comment|/*&n;   * We should have a list of commands that we &squot;finished&squot; during the course of&n;   * error recovery.  This should be the same as the list of commands that timed out&n;   * or failed.  We are currently holding these things in a linked list - we didn&squot;t&n;   * put them in the bottom half queue because we wanted to keep things quiet while&n;   * we were working on recovery, and passing them up to the top level could easily&n;   * cause the top level to try and queue something else again.&n;   *&n;   * Start by marking that the host is no longer in error recovery.&n;   */
id|host-&gt;in_recovery
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   * Take the list of commands, and stick them in the bottom half queue.&n;   * The current implementation of scsi_done will do this for us - if need&n;   * be we can create a special version of this function to do the&n;   * same job for us.&n;   */
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SCdone
suffix:semicolon
id|SCpnt
op_ne
l_int|NULL
suffix:semicolon
id|SCpnt
op_assign
id|SCdone
)paren
(brace
id|SCdone
op_assign
id|SCpnt-&gt;bh_next
suffix:semicolon
id|SCpnt-&gt;bh_next
op_assign
l_int|NULL
suffix:semicolon
id|scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
r_return
(paren
id|ourrtn
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_error_handler&n; *&n; * Purpose:&t;Handle errors/timeouts of scsi commands, try and clean up&n; *&t;&t;and unjam the bus, and restart things.&n; *&n; * Arguments:&t;host&t;- host for which we are running.&n; *&n; * Returns:&t;Never returns.&n; *&n; * Notes:&t;This is always run in the context of a kernel thread.  The&n; *&t;&t;idea is that we start this thing up when the kernel starts&n; *&t;&t;up (one per host that we detect), and it immediately goes to&n; *&t;&t;sleep and waits for some event (i.e. failure).  When this&n; *&t;&t;takes place, we have the job of trying to unjam the bus&n; *&t;&t;and restarting things.&n; *&n; */
r_void
DECL|function|scsi_error_handler
id|scsi_error_handler
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
(paren
r_struct
id|Scsi_Host
op_star
)paren
id|data
suffix:semicolon
r_int
id|rtn
suffix:semicolon
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we were started as result of loading a module, close all of the&n;&t; * user space pages.  We don&squot;t need them, and if we didn&squot;t close them&n;&t; * they would be locked into memory.&n;&t; */
id|exit_mm
c_func
(paren
id|current
)paren
suffix:semicolon
id|current-&gt;session
op_assign
l_int|1
suffix:semicolon
id|current-&gt;pgrp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;         * FIXME(eric) this is still a child process of the one that did the insmod.&n;         * This needs to be attached to task[0] instead.&n;         */
id|siginitsetinv
c_func
(paren
op_amp
id|current-&gt;blocked
comma
id|SHUTDOWN_SIGS
)paren
suffix:semicolon
id|current-&gt;fs-&gt;umask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Set the name of this process.&n;&t; */
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;scsi_eh_%d&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|host-&gt;eh_wait
op_assign
op_amp
id|sem
suffix:semicolon
id|host-&gt;ehandler
op_assign
id|current
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;         * Wake up the thread that created us.&n;         */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Wake up parent %d&bslash;n&quot;
comma
id|host-&gt;eh_notify-&gt;count.counter
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
id|host-&gt;eh_notify
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;     * If we get a signal, it means we are supposed to go&n;&t;     * away and die.  This typically happens if the user is&n;&t;     * trying to unload a module.&n;&t;     */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Error handler sleeping&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|down_interruptible
(paren
op_amp
id|sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Error handler waking up&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|host-&gt;eh_active
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;     * We have a host that is failing for some reason.  Figure out&n;&t;     * what we need to do to get it up and online again (if we can).&n;&t;     * If we fail, we end up taking the thing offline.&n;&t;     */
r_if
c_cond
(paren
id|host-&gt;hostt-&gt;eh_strategy_handler
op_ne
l_int|NULL
)paren
(brace
id|rtn
op_assign
id|host-&gt;hostt
op_member_access_from_pointer
id|eh_strategy_handler
c_func
(paren
id|host
)paren
suffix:semicolon
)brace
r_else
(brace
id|rtn
op_assign
id|scsi_unjam_host
c_func
(paren
id|host
)paren
suffix:semicolon
)brace
id|host-&gt;eh_active
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;     * Note - if the above fails completely, the action is to take&n;&t;     * individual devices offline and flush the queue of any&n;&t;     * outstanding requests that may have been pending.  When we&n;&t;     * restart, we restart any I/O to any other devices on the bus&n;&t;     * which are still online.&n;&t;     */
id|scsi_restart_operations
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* The spinlock is really needed up to this point. (DB) */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Error handler exiting&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure that nobody tries to wake us up again.&n;&t; */
id|host-&gt;eh_wait
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Knock this down too.  From this point on, the host is flying&n;&t; * without a pilot.  If this is because the module is being unloaded,&n;&t; * that&squot;s fine.  If the user sent a signal to this thing, we are&n;&t; * potentially in real danger.&n;&t; */
id|host-&gt;in_recovery
op_assign
l_int|0
suffix:semicolon
id|host-&gt;eh_active
op_assign
l_int|0
suffix:semicolon
id|host-&gt;ehandler
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * If anyone is waiting for us to exit (i.e. someone trying to unload&n;&t; * a driver), then wake up that process to let them know we are on&n;&t; * the way out the door.  This may be overkill - I *think* that we&n;&t; * could probably just unload the driver and send the signal, and when&n;&t; * the error handling thread wakes up that it would just exit without&n;&t; * needing to touch any memory associated with the driver itself.&n;&t; */
r_if
c_cond
(paren
id|host-&gt;eh_notify
op_ne
l_int|NULL
)paren
(brace
id|up
c_func
(paren
id|host-&gt;eh_notify
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: nil&n; * tab-width: 8&n; * End:&n; */
eof
