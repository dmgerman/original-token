multiline_comment|/*&n; *  scsi_error.c Copyright (C) 1997 Eric Youngdale&n; *&n; *  SCSI error/timeout handling&n; *      Initial versions: Eric Youngdale.  Based upon conversations with&n; *                        Leonard Zubkoff and David Miller at Linux Expo, &n; *                        ideas originating from all over the place.&n; *&n; */
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;constants.h&quot;
multiline_comment|/*&n; * We must always allow SHUTDOWN_SIGS.  Even if we are not a module,&n; * the host drivers that we are using may be loaded as modules, and&n; * when we unload these,  we need to ensure that the error handler thread&n; * can be shut down.&n; *&n; * Note - when we unload a module, we send a SIGHUP.  We mustn&squot;t&n; * enable SIGTERM, as this is how the init shuts things down when you&n; * go to single-user mode.  For that matter, init also sends SIGKILL,&n; * so we mustn&squot;t enable that one either.  We use SIGHUP instead.  Other&n; * options would be SIGPWR, I suppose.&n; */
DECL|macro|SHUTDOWN_SIGS
mdefine_line|#define SHUTDOWN_SIGS&t;(sigmask(SIGHUP))
macro_line|#ifdef DEBUG
DECL|macro|SENSE_TIMEOUT
mdefine_line|#define SENSE_TIMEOUT SCSI_TIMEOUT
DECL|macro|ABORT_TIMEOUT
mdefine_line|#define ABORT_TIMEOUT SCSI_TIMEOUT
DECL|macro|RESET_TIMEOUT
mdefine_line|#define RESET_TIMEOUT SCSI_TIMEOUT
macro_line|#else
DECL|macro|SENSE_TIMEOUT
mdefine_line|#define SENSE_TIMEOUT (10*HZ)
DECL|macro|RESET_TIMEOUT
mdefine_line|#define RESET_TIMEOUT (2*HZ)
DECL|macro|ABORT_TIMEOUT
mdefine_line|#define ABORT_TIMEOUT (15*HZ)
macro_line|#endif
DECL|macro|STATIC
mdefine_line|#define STATIC
multiline_comment|/*&n; * These should *probably* be handled by the host itself.&n; * Since it is allowed to sleep, it probably should.&n; */
DECL|macro|BUS_RESET_SETTLE_TIME
mdefine_line|#define BUS_RESET_SETTLE_TIME   5*HZ
DECL|macro|HOST_RESET_SETTLE_TIME
mdefine_line|#define HOST_RESET_SETTLE_TIME  10*HZ
DECL|variable|RCSid
r_static
r_const
r_char
id|RCSid
(braket
)braket
op_assign
l_string|&quot;$Header: /mnt/ide/home/eric/CVSROOT/linux/drivers/scsi/scsi_error.c,v 1.10 1997/12/08 04:50:35 eric Exp $&quot;
suffix:semicolon
id|STATIC
r_int
id|scsi_check_sense
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_request_sense
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
id|STATIC
r_void
id|scsi_send_eh_cmnd
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|timeout
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_try_to_abort_command
c_func
(paren
id|Scsi_Cmnd
op_star
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_test_unit_ready
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_try_bus_device_reset
c_func
(paren
id|Scsi_Cmnd
op_star
comma
r_int
id|timeout
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_try_bus_reset
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_try_host_reset
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_unit_is_ready
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
id|STATIC
r_void
id|scsi_eh_action_done
c_func
(paren
id|Scsi_Cmnd
op_star
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_eh_retry_command
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|scsi_eh_completed_normally
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
id|STATIC
r_void
id|scsi_restart_operations
c_func
(paren
r_struct
id|Scsi_Host
op_star
)paren
suffix:semicolon
id|STATIC
r_void
id|scsi_eh_finish_command
c_func
(paren
id|Scsi_Cmnd
op_star
op_star
id|SClist
comma
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n; * Function:    scsi_add_timer()&n; *&n; * Purpose:     Start timeout timer for a single scsi command.&n; *&n; * Arguments:   SCset   - command that is about to start running.&n; *              timeout - amount of time to allow this command to run.&n; *              complete - timeout function to call if timer isn&squot;t&n; *                      canceled.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       This should be turned into an inline function.&n; *&n; * More Notes:  Each scsi command has it&squot;s own timer, and as it is added to&n; *              the queue, we set up the timer.  When the command completes,&n; *              we cancel the timer.  Pretty simple, really, especially&n; *              compared to the old way of handling this crap.&n; */
DECL|function|scsi_add_timer
r_void
id|scsi_add_timer
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCset
comma
r_int
id|timeout
comma
r_void
(paren
op_star
id|complete
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
multiline_comment|/*&n;&t; * If the clock was already running for this command, then&n;&t; * first delete the timer.  The timer handling code gets rather&n;&t; * confused if we don&squot;t do this.&n;&t; */
r_if
c_cond
(paren
id|SCset-&gt;eh_timeout.function
op_ne
l_int|NULL
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|SCset-&gt;eh_timeout
)paren
suffix:semicolon
)brace
id|SCset-&gt;eh_timeout.data
op_assign
(paren
r_int
r_int
)paren
id|SCset
suffix:semicolon
id|SCset-&gt;eh_timeout.expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|SCset-&gt;eh_timeout.function
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|complete
suffix:semicolon
id|SCset-&gt;done_late
op_assign
l_int|0
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Adding timer for command %p at %d (%p)&bslash;n&quot;
comma
id|SCset
comma
id|timeout
comma
id|complete
)paren
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|SCset-&gt;eh_timeout
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_delete_timer()&n; *&n; * Purpose:     Delete/cancel timer for a given function.&n; *&n; * Arguments:   SCset   - command that we are canceling timer for.&n; *&n; * Returns:     1 if we were able to detach the timer.  0 if we&n; *              blew it, and the timer function has already started&n; *              to run.&n; *&n; * Notes:       This should be turned into an inline function.&n; */
DECL|function|scsi_delete_timer
r_int
id|scsi_delete_timer
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCset
)paren
(brace
r_int
id|rtn
suffix:semicolon
id|rtn
op_assign
id|del_timer
c_func
(paren
op_amp
id|SCset-&gt;eh_timeout
)paren
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Clearing timer for command %p %d&bslash;n&quot;
comma
id|SCset
comma
id|rtn
)paren
)paren
suffix:semicolon
id|SCset-&gt;eh_timeout.data
op_assign
(paren
r_int
r_int
)paren
l_int|NULL
suffix:semicolon
id|SCset-&gt;eh_timeout.function
op_assign
l_int|NULL
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_times_out()&n; *&n; * Purpose:     Timeout function for normal scsi commands..&n; *&n; * Arguments:   SCpnt   - command that is timing out.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:       We do not need to lock this.  There is the potential for&n; *              a race only in that the normal completion handling might&n; *              run, but if the normal completion function determines&n; *              that the timer has already fired, then it mustn&squot;t do&n; *              anything.&n; */
DECL|function|scsi_times_out
r_void
id|scsi_times_out
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
multiline_comment|/* &n;&t; * Notify the low-level code that this operation failed and we are&n;&t; * reposessing the command.  &n;&t; */
macro_line|#ifdef ERIC_neverdef
multiline_comment|/*&n;&t; * FIXME(eric)&n;&t; * Allow the host adapter to push a queue ordering tag&n;&t; * out to the bus to force the command in question to complete.&n;&t; * If the host wants to do this, then we just restart the timer&n;&t; * for the command.  Before we really do this, some real thought&n;&t; * as to the optimum way to handle this should be done.  We *do*&n;&t; * need to force ordering every so often to ensure that all requests&n;&t; * do eventually complete, but I am not sure if this is the best way&n;&t; * to actually go about it.&n;&t; *&n;&t; * Better yet, force a sync here, but don&squot;t block since we are in an&n;&t; * interrupt.&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;hostt-&gt;eh_ordered_queue_tag
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|SCpnt-&gt;host-&gt;hostt-&gt;eh_ordered_queue_tag
)paren
(paren
id|SCpnt
)paren
)paren
(brace
id|scsi_add_timer
c_func
(paren
id|SCpnt
comma
id|SCpnt-&gt;internal_timeout
comma
id|scsi_times_out
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * FIXME(eric) - add a second special interface to handle this&n;&t; * case.  Ideally that interface can also be used to request&n;&t; * a queu&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;can_queue
)paren
(brace
id|SCpnt-&gt;host-&gt;hostt
op_member_access_from_pointer
id|queuecommand
c_func
(paren
id|SCpnt
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Set the serial_number_at_timeout to the current serial_number */
id|SCpnt-&gt;serial_number_at_timeout
op_assign
id|SCpnt-&gt;serial_number
suffix:semicolon
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_TIMEOUT
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_ERROR_HANDLER
suffix:semicolon
id|SCpnt-&gt;host-&gt;in_recovery
op_assign
l_int|1
suffix:semicolon
id|SCpnt-&gt;host-&gt;host_failed
op_increment
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command timed out active=%d busy=%d failed=%d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
comma
id|SCpnt-&gt;host-&gt;host_busy
comma
id|SCpnt-&gt;host-&gt;host_failed
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the host is having troubles, then look to see if this was the last&n;&t; * command that might have failed.  If so, wake up the error handler.&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;eh_wait
op_eq
l_int|NULL
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Error handler thread not present at %p %p %s %d&quot;
comma
id|SCpnt
comma
id|SCpnt-&gt;host
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;host_busy
op_eq
id|SCpnt-&gt;host-&gt;host_failed
)paren
(brace
id|up
c_func
(paren
id|SCpnt-&gt;host-&gt;eh_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function     scsi_block_when_processing_errors&n; *&n; * Purpose:     Prevent more commands from being queued while error recovery&n; *              is taking place.&n; *&n; * Arguments:   SDpnt - device on which we are performing recovery.&n; *&n; * Returns:     FALSE   The device was taken offline by error recovery.&n; *              TRUE    OK to proceed.&n; *&n; * Notes:       We block until the host is out of error recovery, and then&n; *              check to see whether the host or the device is offline.&n; */
DECL|function|scsi_block_when_processing_errors
r_int
id|scsi_block_when_processing_errors
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
)paren
(brace
id|SCSI_SLEEP
c_func
(paren
op_amp
id|SDpnt-&gt;host-&gt;host_wait
comma
id|SDpnt-&gt;host-&gt;in_recovery
)paren
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Open returning %d&bslash;n&quot;
comma
id|SDpnt-&gt;online
)paren
)paren
suffix:semicolon
r_return
id|SDpnt-&gt;online
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_eh_times_out()&n; *&n; * Purpose:     Timeout function for error handling.&n; *&n; * Arguments:   SCpnt   - command that is timing out.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:       During error handling, the kernel thread will be sleeping&n; *              waiting for some action to complete on the device.  Our only&n; *              job is to record that it timed out, and to wake up the&n; *              thread.&n; */
id|STATIC
DECL|function|scsi_eh_times_out
r_void
id|scsi_eh_times_out
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|SCpnt-&gt;eh_state
op_assign
id|SCSI_STATE_TIMEOUT
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;In scsi_eh_times_out %p&bslash;n&quot;
comma
id|SCpnt
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;eh_action
op_ne
l_int|NULL
)paren
id|up
c_func
(paren
id|SCpnt-&gt;host-&gt;eh_action
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;Missing scsi error handler thread&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_eh_done()&n; *&n; * Purpose:     Completion function for error handling.&n; *&n; * Arguments:   SCpnt   - command that is timing out.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:       During error handling, the kernel thread will be sleeping&n; *              waiting for some action to complete on the device.  Our only&n; *              job is to record that the action completed, and to wake up the&n; *              thread.&n; */
id|STATIC
DECL|function|scsi_eh_done
r_void
id|scsi_eh_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|rtn
suffix:semicolon
multiline_comment|/*&n;&t; * If the timeout handler is already running, then just set the&n;&t; * flag which says we finished late, and return.  We have no&n;&t; * way of stopping the timeout handler from running, so we must&n;&t; * always defer to it.&n;&t; */
id|rtn
op_assign
id|del_timer
c_func
(paren
op_amp
id|SCpnt-&gt;eh_timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rtn
)paren
(brace
id|SCpnt-&gt;done_late
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_ERROR_HANDLER
suffix:semicolon
id|SCpnt-&gt;eh_state
op_assign
id|SUCCESS
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;In eh_done %p result:%x&bslash;n&quot;
comma
id|SCpnt
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;eh_action
op_ne
l_int|NULL
)paren
id|up
c_func
(paren
id|SCpnt-&gt;host-&gt;eh_action
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_eh_action_done()&n; *&n; * Purpose:     Completion function for error handling.&n; *&n; * Arguments:   SCpnt   - command that is timing out.&n; *              answer  - boolean that indicates whether operation succeeded.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:       This callback is only used for abort and reset operations.&n; */
id|STATIC
DECL|function|scsi_eh_action_done
r_void
id|scsi_eh_action_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|answer
)paren
(brace
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_ERROR_HANDLER
suffix:semicolon
id|SCpnt-&gt;eh_state
op_assign
(paren
id|answer
ques
c_cond
id|SUCCESS
suffix:colon
id|FAILED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;eh_action
op_ne
l_int|NULL
)paren
id|up
c_func
(paren
id|SCpnt-&gt;host-&gt;eh_action
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:  scsi_sense_valid()&n; *&n; * Purpose:     Determine whether a host has automatically obtained sense&n; *              information or not.  If we have it, then give a recommendation&n; *              as to what we should do next.&n; */
DECL|function|scsi_sense_valid
r_int
id|scsi_sense_valid
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x70
)paren
op_rshift
l_int|4
)paren
op_ne
l_int|7
)paren
(brace
r_return
id|FALSE
suffix:semicolon
)brace
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:  scsi_eh_retry_command()&n; *&n; * Purpose:     Retry the original command&n; *&n; * Returns:     SUCCESS - we were able to get the sense data.&n; *              FAILED  - we were not able to get the sense data.&n; * &n; * Notes:       This function will *NOT* return until the command either&n; *              times out, or it completes.&n; */
DECL|function|scsi_eh_retry_command
id|STATIC
r_int
id|scsi_eh_retry_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|SCpnt-&gt;buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|SCpnt-&gt;bufflen
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|SCpnt-&gt;old_cmd_len
suffix:semicolon
id|SCpnt-&gt;sc_data_direction
op_assign
id|SCpnt-&gt;sc_old_data_direction
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
id|SCpnt-&gt;old_underflow
suffix:semicolon
id|scsi_send_eh_cmnd
c_func
(paren
id|SCpnt
comma
id|SCpnt-&gt;timeout_per_command
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Hey, we are done.  Let&squot;s look to see what happened.&n;&t; */
r_return
id|SCpnt-&gt;eh_state
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:  scsi_request_sense()&n; *&n; * Purpose:     Request sense data from a particular target.&n; *&n; * Returns:     SUCCESS - we were able to get the sense data.&n; *              FAILED  - we were not able to get the sense data.&n; * &n; * Notes:       Some hosts automatically obtain this information, others&n; *              require that we obtain it on our own.&n; *&n; *              This function will *NOT* return until the command either&n; *              times out, or it completes.&n; */
DECL|function|scsi_request_sense
id|STATIC
r_int
id|scsi_request_sense
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_static
r_int
r_char
id|generic_sense
(braket
l_int|6
)braket
op_assign
(brace
id|REQUEST_SENSE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|255
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|scsi_result0
(braket
l_int|256
)braket
comma
op_star
id|scsi_result
op_assign
l_int|NULL
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
op_amp
id|io_request_lock
comma
l_int|0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|generic_sense
comma
r_sizeof
(paren
id|generic_sense
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|SCpnt-&gt;lun
op_lshift
l_int|5
suffix:semicolon
id|scsi_result
op_assign
(paren
op_logical_neg
id|SCpnt-&gt;host-&gt;hostt-&gt;unchecked_isa_dma
)paren
ques
c_cond
op_amp
id|scsi_result0
(braket
l_int|0
)braket
suffix:colon
id|kmalloc
c_func
(paren
l_int|512
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_result
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot allocate scsi_result in scsi_request_sense.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Zero the sense buffer.  Some host adapters automatically always request&n;&t; * sense, so it is not a good idea that SCpnt-&gt;request_buffer and&n;&t; * SCpnt-&gt;sense_buffer point to the same address (DB).&n;&t; * 0 is not a valid sense code. &n;&t; */
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|scsi_result
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
l_int|256
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|SCpnt-&gt;sc_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|scsi_send_eh_cmnd
c_func
(paren
id|SCpnt
comma
id|SENSE_TIMEOUT
)paren
suffix:semicolon
multiline_comment|/* Last chance to have valid sense data */
r_if
c_cond
(paren
op_logical_neg
id|scsi_sense_valid
c_func
(paren
id|SCpnt
)paren
)paren
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
id|SCpnt-&gt;request_buffer
comma
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_result
op_ne
op_amp
id|scsi_result0
(braket
l_int|0
)braket
op_logical_and
id|scsi_result
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|scsi_result
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * When we eventually call scsi_finish, we really wish to complete&n;&t; * the original request, so let&squot;s restore the original data. (DB)&n;&t; */
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|SCpnt-&gt;buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|SCpnt-&gt;bufflen
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|SCpnt-&gt;old_cmd_len
suffix:semicolon
id|SCpnt-&gt;sc_data_direction
op_assign
id|SCpnt-&gt;sc_old_data_direction
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
id|SCpnt-&gt;old_underflow
suffix:semicolon
multiline_comment|/*&n;&t; * Hey, we are done.  Let&squot;s look to see what happened.&n;&t; */
r_return
id|SCpnt-&gt;eh_state
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:  scsi_test_unit_ready()&n; *&n; * Purpose:     Run test unit ready command to see if the device is talking to us or not.&n; *&n; */
DECL|function|scsi_test_unit_ready
id|STATIC
r_int
id|scsi_test_unit_ready
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_static
r_int
r_char
id|tur_command
(braket
l_int|6
)braket
op_assign
(brace
id|TEST_UNIT_READY
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|scsi_result0
(braket
l_int|256
)braket
comma
op_star
id|scsi_result
op_assign
l_int|NULL
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|tur_command
comma
r_sizeof
(paren
id|tur_command
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|SCpnt-&gt;lun
op_lshift
l_int|5
suffix:semicolon
id|scsi_result
op_assign
(paren
op_logical_neg
id|SCpnt-&gt;host-&gt;hostt-&gt;unchecked_isa_dma
)paren
ques
c_cond
op_amp
id|scsi_result0
(braket
l_int|0
)braket
suffix:colon
id|kmalloc
c_func
(paren
l_int|512
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_result
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot allocate scsi_result in scsi_test_unit_ready.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Zero the sense buffer.  Some host adapters automatically always request&n;&t; * sense, so it is not a good idea that SCpnt-&gt;request_buffer and&n;&t; * SCpnt-&gt;sense_buffer point to the same address (DB).&n;&t; * 0 is not a valid sense code. &n;&t; */
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|scsi_result
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
l_int|256
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;sc_data_direction
op_assign
id|SCSI_DATA_NONE
suffix:semicolon
id|scsi_send_eh_cmnd
c_func
(paren
id|SCpnt
comma
id|SENSE_TIMEOUT
)paren
suffix:semicolon
multiline_comment|/* Last chance to have valid sense data */
r_if
c_cond
(paren
op_logical_neg
id|scsi_sense_valid
c_func
(paren
id|SCpnt
)paren
)paren
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
id|SCpnt-&gt;request_buffer
comma
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_result
op_ne
op_amp
id|scsi_result0
(braket
l_int|0
)braket
op_logical_and
id|scsi_result
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|scsi_result
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * When we eventually call scsi_finish, we really wish to complete&n;&t; * the original request, so let&squot;s restore the original data. (DB)&n;&t; */
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|SCpnt-&gt;buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|SCpnt-&gt;bufflen
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|SCpnt-&gt;old_cmd_len
suffix:semicolon
id|SCpnt-&gt;sc_data_direction
op_assign
id|SCpnt-&gt;sc_old_data_direction
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
id|SCpnt-&gt;old_underflow
suffix:semicolon
multiline_comment|/*&n;&t; * Hey, we are done.  Let&squot;s look to see what happened.&n;&t; */
r_return
id|SCpnt-&gt;eh_state
suffix:semicolon
)brace
multiline_comment|/*&n; * This would normally need to get the IO request lock,&n; * but as it doesn&squot;t actually touch anything that needs&n; * to be locked we can avoid the lock here..&n; */
id|STATIC
DECL|function|scsi_sleep_done
r_void
id|scsi_sleep_done
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_if
c_cond
(paren
id|sem
op_ne
l_int|NULL
)paren
(brace
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
)brace
)brace
DECL|function|scsi_sleep
r_void
id|scsi_sleep
c_func
(paren
r_int
id|timeout
)paren
(brace
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|sem
)paren
suffix:semicolon
r_struct
id|timer_list
id|timer
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|timer.data
op_assign
(paren
r_int
r_int
)paren
op_amp
id|sem
suffix:semicolon
id|timer.expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|timer.function
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|scsi_sleep_done
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Sleeping for timer tics %d&bslash;n&quot;
comma
id|timeout
)paren
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:  scsi_send_eh_cmnd&n; *&n; * Purpose:     Send a command out to a device as part of error recovery.&n; *&n; * Notes:       The initialization of the structures is quite a bit different&n; *              in this case, and furthermore, there is a different completion&n; *              handler.&n; */
DECL|function|scsi_send_eh_cmnd
id|STATIC
r_void
id|scsi_send_eh_cmnd
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|timeout
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
op_amp
id|io_request_lock
comma
l_int|0
)paren
suffix:semicolon
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|retry
suffix:colon
multiline_comment|/*&n;&t; * We will use a queued command if possible, otherwise we will emulate the&n;&t; * queuing and calling of completion function ourselves.&n;&t; */
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;can_queue
)paren
(brace
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|sem
)paren
suffix:semicolon
id|SCpnt-&gt;eh_state
op_assign
id|SCSI_STATE_QUEUED
suffix:semicolon
id|scsi_add_timer
c_func
(paren
id|SCpnt
comma
id|timeout
comma
id|scsi_eh_times_out
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set up the semaphore so we wait for the command to complete.&n;&t;&t; */
id|SCpnt-&gt;host-&gt;eh_action
op_assign
op_amp
id|sem
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|host-&gt;hostt
op_member_access_from_pointer
id|queuecommand
c_func
(paren
id|SCpnt
comma
id|scsi_eh_done
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|SCpnt-&gt;host-&gt;eh_action
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * See if timeout.  If so, tell the host to forget about it.&n;&t;&t; * In other words, we don&squot;t want a callback any more.&n;&t;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;eh_state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * As far as the low level driver is&n;&t;&t;&t; * concerned, this command is still active, so&n;&t;&t;&t; * we must give the low level driver a chance&n;&t;&t;&t; * to abort it. (DB) &n;&t;&t;&t; *&n;&t;&t;&t; * FIXME(eric) - we are not tracking whether we could&n;&t;&t;&t; * abort a timed out command or not.  Not sure how&n;&t;&t;&t; * we should treat them differently anyways.&n;&t;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;hostt-&gt;eh_abort_handler
)paren
id|SCpnt-&gt;host-&gt;hostt
op_member_access_from_pointer
id|eh_abort_handler
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_ERROR_HANDLER
suffix:semicolon
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;send_eh_cmnd: %p eh_state:%x&bslash;n&quot;
comma
id|SCpnt
comma
id|SCpnt-&gt;eh_state
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|temp
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We damn well had better never use this code.  There is no timeout&n;&t;&t; * protection here, since we would end up waiting in the actual low&n;&t;&t; * level driver, we don&squot;t know how to wake it up.&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|temp
op_assign
id|host-&gt;hostt
op_member_access_from_pointer
id|command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|temp
suffix:semicolon
r_if
c_cond
(paren
id|scsi_eh_completed_normally
c_func
(paren
id|SCpnt
)paren
)paren
(brace
id|SCpnt-&gt;eh_state
op_assign
id|SUCCESS
suffix:semicolon
)brace
r_else
(brace
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now examine the actual status codes to see whether the command actually&n;&t; * did complete normally.&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;eh_state
op_eq
id|SUCCESS
)paren
(brace
r_switch
c_cond
(paren
id|scsi_eh_completed_normally
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_case
id|SUCCESS
suffix:colon
id|SCpnt-&gt;eh_state
op_assign
id|SUCCESS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NEEDS_RETRY
suffix:colon
r_goto
id|retry
suffix:semicolon
r_case
id|FAILED
suffix:colon
r_default
suffix:colon
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:  scsi_unit_is_ready()&n; *&n; * Purpose:     Called after TEST_UNIT_READY is run, to test to see if&n; *              the unit responded in a way that indicates it is ready.&n; */
DECL|function|scsi_unit_is_ready
id|STATIC
r_int
id|scsi_unit_is_ready
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;result
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|driver_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
op_amp
id|DRIVER_SENSE
)paren
op_logical_or
(paren
id|status_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
op_amp
id|CHECK_CONDITION
)paren
)paren
op_logical_and
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x70
)paren
op_rshift
l_int|4
)paren
op_eq
l_int|7
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|NOT_READY
)paren
op_logical_and
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|UNIT_ATTENTION
)paren
op_logical_and
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|ILLEGAL_REQUEST
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_eh_finish_command&n; *&n; * Purpose:     Handle a command that we are finished with WRT error handling.&n; *&n; * Arguments:   SClist - pointer to list into which we are putting completed commands.&n; *              SCpnt  - command that is completing&n; *&n; * Notes:       We don&squot;t want to use the normal command completion while we are&n; *              are still handling errors - it may cause other commands to be queued,&n; *              and that would disturb what we are doing.  Thus we really want to keep&n; *              a list of pending commands for final completion, and once we&n; *              are ready to leave error handling we handle completion for real.&n; */
DECL|function|scsi_eh_finish_command
id|STATIC
r_void
id|scsi_eh_finish_command
c_func
(paren
id|Scsi_Cmnd
op_star
op_star
id|SClist
comma
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_BHQUEUE
suffix:semicolon
id|SCpnt-&gt;bh_next
op_assign
op_star
id|SClist
suffix:semicolon
multiline_comment|/*&n;&t; * Set this back so that the upper level can correctly free up&n;&t; * things.&n;&t; */
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;sc_data_direction
op_assign
id|SCpnt-&gt;sc_old_data_direction
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
id|SCpnt-&gt;old_underflow
suffix:semicolon
op_star
id|SClist
op_assign
id|SCpnt
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:  scsi_try_to_abort_command&n; *&n; * Purpose:     Ask host adapter to abort a running command.&n; *&n; * Returns:     FAILED          Operation failed or not supported.&n; *              SUCCESS         Succeeded.&n; *&n; * Notes:       This function will not return until the user&squot;s completion&n; *              function has been called.  There is no timeout on this&n; *              operation.  If the author of the low-level driver wishes&n; *              this operation to be timed, they can provide this facility&n; *              themselves.  Helper functions in scsi_error.c can be supplied&n; *              to make this easier to do.&n; *&n; * Notes:       It may be possible to combine this with all of the reset&n; *              handling to eliminate a lot of code duplication.  I don&squot;t&n; *              know what makes more sense at the moment - this is just a&n; *              prototype.&n; */
DECL|function|scsi_try_to_abort_command
id|STATIC
r_int
id|scsi_try_to_abort_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|timeout
)paren
(brace
r_int
id|rtn
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
multiline_comment|/* Until we come up with something better */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;hostt-&gt;eh_abort_handler
op_eq
l_int|NULL
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * scsi_done was called just after the command timed out and before&n;&t; * we had a chance to process it. (DB)&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;serial_number
op_eq
l_int|0
)paren
r_return
id|SUCCESS
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|rtn
op_assign
id|SCpnt-&gt;host-&gt;hostt
op_member_access_from_pointer
id|eh_abort_handler
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:  scsi_try_bus_device_reset&n; *&n; * Purpose:     Ask host adapter to perform a bus device reset for a given&n; *              device.&n; *&n; * Returns:     FAILED          Operation failed or not supported.&n; *              SUCCESS         Succeeded.&n; *&n; * Notes:       There is no timeout for this operation.  If this operation is&n; *              unreliable for a given host, then the host itself needs to put a&n; *              timer on it, and set the host back to a consistent state prior&n; *              to returning.&n; */
DECL|function|scsi_try_bus_device_reset
id|STATIC
r_int
id|scsi_try_bus_device_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|timeout
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rtn
suffix:semicolon
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
multiline_comment|/* Until we come up with something better */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;hostt-&gt;eh_device_reset_handler
op_eq
l_int|NULL
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|rtn
op_assign
id|SCpnt-&gt;host-&gt;hostt
op_member_access_from_pointer
id|eh_device_reset_handler
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
id|SCpnt-&gt;eh_state
op_assign
id|SUCCESS
suffix:semicolon
r_return
id|SCpnt-&gt;eh_state
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:  scsi_try_bus_reset&n; *&n; * Purpose:     Ask host adapter to perform a bus reset for a host.&n; *&n; * Returns:     FAILED          Operation failed or not supported.&n; *              SUCCESS         Succeeded.&n; *&n; * Notes:       &n; */
DECL|function|scsi_try_bus_reset
id|STATIC
r_int
id|scsi_try_bus_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rtn
suffix:semicolon
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
multiline_comment|/* Until we come up with something better */
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
id|SCpnt-&gt;serial_number
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;hostt-&gt;eh_bus_reset_handler
op_eq
l_int|NULL
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|rtn
op_assign
id|SCpnt-&gt;host-&gt;hostt
op_member_access_from_pointer
id|eh_bus_reset_handler
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
id|SCpnt-&gt;eh_state
op_assign
id|SUCCESS
suffix:semicolon
multiline_comment|/*&n;&t; * If we had a successful bus reset, mark the command blocks to expect&n;&t; * a condition code of unit attention.&n;&t; */
id|scsi_sleep
c_func
(paren
id|BUS_RESET_SETTLE_TIME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;eh_state
op_eq
id|SUCCESS
)paren
(brace
id|Scsi_Device
op_star
id|SDloop
suffix:semicolon
r_for
c_loop
(paren
id|SDloop
op_assign
id|SCpnt-&gt;host-&gt;host_queue
suffix:semicolon
id|SDloop
suffix:semicolon
id|SDloop
op_assign
id|SDloop-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;channel
op_eq
id|SDloop-&gt;channel
)paren
(brace
id|SDloop-&gt;was_reset
op_assign
l_int|1
suffix:semicolon
id|SDloop-&gt;expecting_cc_ua
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_return
id|SCpnt-&gt;eh_state
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:  scsi_try_host_reset&n; *&n; * Purpose:     Ask host adapter to reset itself, and the bus.&n; *&n; * Returns:     FAILED          Operation failed or not supported.&n; *              SUCCESS         Succeeded.&n; *&n; * Notes:&n; */
DECL|function|scsi_try_host_reset
id|STATIC
r_int
id|scsi_try_host_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rtn
suffix:semicolon
id|SCpnt-&gt;eh_state
op_assign
id|FAILED
suffix:semicolon
multiline_comment|/* Until we come up with something better */
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
id|SCpnt-&gt;serial_number
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;hostt-&gt;eh_host_reset_handler
op_eq
l_int|NULL
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|rtn
op_assign
id|SCpnt-&gt;host-&gt;hostt
op_member_access_from_pointer
id|eh_host_reset_handler
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
id|SCpnt-&gt;eh_state
op_assign
id|SUCCESS
suffix:semicolon
multiline_comment|/*&n;&t; * If we had a successful host reset, mark the command blocks to expect&n;&t; * a condition code of unit attention.&n;&t; */
id|scsi_sleep
c_func
(paren
id|HOST_RESET_SETTLE_TIME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;eh_state
op_eq
id|SUCCESS
)paren
(brace
id|Scsi_Device
op_star
id|SDloop
suffix:semicolon
r_for
c_loop
(paren
id|SDloop
op_assign
id|SCpnt-&gt;host-&gt;host_queue
suffix:semicolon
id|SDloop
suffix:semicolon
id|SDloop
op_assign
id|SDloop-&gt;next
)paren
(brace
id|SDloop-&gt;was_reset
op_assign
l_int|1
suffix:semicolon
id|SDloop-&gt;expecting_cc_ua
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|SCpnt-&gt;eh_state
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:  scsi_decide_disposition&n; *&n; * Purpose:     Examine a command block that has come back from the low-level&n; *              and figure out what to do next.&n; *&n; * Returns:     SUCCESS         - pass on to upper level.&n; *              FAILED          - pass on to error handler thread.&n; *              RETRY           - command should be retried.&n; *              SOFTERR         - command succeeded, but we need to log&n; *                                a soft error.&n; *&n; * Notes:       This is *ONLY* called when we are examining the status&n; *              after sending out the actual data command.  Any commands&n; *              that are queued for error recovery (i.e. TEST_UNIT_READY)&n; *              do *NOT* come through here.&n; *&n; *              NOTE - When this routine returns FAILED, it means the error&n; *              handler thread is woken.  In cases where the error code&n; *              indicates an error that doesn&squot;t require the error handler&n; *              thread (i.e. we don&squot;t need to abort/reset), then this function&n; *              should return SUCCESS.&n; */
DECL|function|scsi_decide_disposition
r_int
id|scsi_decide_disposition
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|rtn
suffix:semicolon
multiline_comment|/*&n;&t; * If the device is offline, then we clearly just pass the result back&n;&t; * up to the top level.&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;online
op_eq
id|FALSE
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;scsi_error.c: device offline - report as SUCCESS&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * First check the host byte, to see if there is anything in there&n;&t; * that would indicate what we need to do.&n;&t; */
r_switch
c_cond
(paren
id|host_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
)paren
(brace
r_case
id|DID_PASSTHROUGH
suffix:colon
multiline_comment|/*&n;&t;&t; * No matter what, pass this through to the upper layer.&n;&t;&t; * Nuke this special code so that it looks like we are saying&n;&t;&t; * DID_OK.&n;&t;&t; */
id|SCpnt-&gt;result
op_and_assign
l_int|0xff00ffff
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
r_case
id|DID_OK
suffix:colon
multiline_comment|/*&n;&t;&t; * Looks good.  Drop through, and check the next byte.&n;&t;&t; */
r_break
suffix:semicolon
r_case
id|DID_NO_CONNECT
suffix:colon
r_case
id|DID_BAD_TARGET
suffix:colon
r_case
id|DID_ABORT
suffix:colon
multiline_comment|/*&n;&t;&t; * Note - this means that we just report the status back to the&n;&t;&t; * top level driver, not that we actually think that it indicates&n;&t;&t; * success.&n;&t;&t; */
r_return
id|SUCCESS
suffix:semicolon
multiline_comment|/*&n;&t;&t; * When the low level driver returns DID_SOFT_ERROR,&n;&t;&t; * it is responsible for keeping an internal retry counter &n;&t;&t; * in order to avoid endless loops (DB)&n;&t;&t; *&n;&t;&t; * Actually this is a bug in this function here.  We should&n;&t;&t; * be mindful of the maximum number of retries specified&n;&t;&t; * and not get stuck in a loop.&n;&t;&t; */
r_case
id|DID_SOFT_ERROR
suffix:colon
r_goto
id|maybe_retry
suffix:semicolon
r_case
id|DID_BUS_BUSY
suffix:colon
r_case
id|DID_PARITY
suffix:colon
r_case
id|DID_ERROR
suffix:colon
r_goto
id|maybe_retry
suffix:semicolon
r_case
id|DID_TIME_OUT
suffix:colon
multiline_comment|/*&n;&t;&t;   * When we scan the bus, we get timeout messages for&n;&t;&t;   * these commands if there is no device available.&n;&t;&t;   * Other hosts report DID_NO_CONNECT for the same thing.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|TEST_UNIT_READY
op_logical_or
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
)paren
(brace
r_return
id|SUCCESS
suffix:semicolon
)brace
r_else
(brace
r_return
id|FAILED
suffix:semicolon
)brace
r_case
id|DID_RESET
suffix:colon
multiline_comment|/*&n;&t;&t; * In the normal case where we haven&squot;t initiated a reset, this is&n;&t;&t; * a failure.&n;&t;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|IS_RESETTING
)paren
(brace
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|IS_RESETTING
suffix:semicolon
r_goto
id|maybe_retry
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Examine the sense data to figure out how to proceed from here.&n;&t;&t; * If there is no sense data, we will be forced into the error&n;&t;&t; * handler thread, where we get to examine the thing in a lot more&n;&t;&t; * detail.&n;&t;&t; */
r_return
id|scsi_check_sense
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_default
suffix:colon
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Next, check the message byte.&n;&t; */
r_if
c_cond
(paren
id|msg_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
op_ne
id|COMMAND_COMPLETE
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now, check the status byte to see if this indicates anything special.&n;&t; */
r_switch
c_cond
(paren
id|status_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
)paren
(brace
r_case
id|QUEUE_FULL
suffix:colon
multiline_comment|/*&n;&t;&t; * The case of trying to send too many commands to a tagged queueing&n;&t;&t; * device.&n;&t;&t; */
r_return
id|ADD_TO_MLQUEUE
suffix:semicolon
r_case
id|GOOD
suffix:colon
r_case
id|COMMAND_TERMINATED
suffix:colon
r_return
id|SUCCESS
suffix:semicolon
r_case
id|CHECK_CONDITION
suffix:colon
id|rtn
op_assign
id|scsi_check_sense
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|NEEDS_RETRY
)paren
(brace
r_goto
id|maybe_retry
suffix:semicolon
)brace
r_return
id|rtn
suffix:semicolon
r_case
id|CONDITION_GOOD
suffix:colon
r_case
id|INTERMEDIATE_GOOD
suffix:colon
r_case
id|INTERMEDIATE_C_GOOD
suffix:colon
multiline_comment|/*&n;&t;&t; * Who knows?  FIXME(eric)&n;&t;&t; */
r_return
id|SUCCESS
suffix:semicolon
r_case
id|BUSY
suffix:colon
r_case
id|RESERVATION_CONFLICT
suffix:colon
r_goto
id|maybe_retry
suffix:semicolon
r_default
suffix:colon
r_return
id|FAILED
suffix:semicolon
)brace
r_return
id|FAILED
suffix:semicolon
id|maybe_retry
suffix:colon
r_if
c_cond
(paren
(paren
op_increment
id|SCpnt-&gt;retries
)paren
OL
id|SCpnt-&gt;allowed
)paren
(brace
r_return
id|NEEDS_RETRY
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;                 * No more retries - report this one back to upper level.&n;                 */
r_return
id|SUCCESS
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:  scsi_eh_completed_normally&n; *&n; * Purpose:     Examine a command block that has come back from the low-level&n; *              and figure out what to do next.&n; *&n; * Returns:     SUCCESS         - pass on to upper level.&n; *              FAILED          - pass on to error handler thread.&n; *              RETRY           - command should be retried.&n; *              SOFTERR         - command succeeded, but we need to log&n; *                                a soft error.&n; *&n; * Notes:       This is *ONLY* called when we are examining the status&n; *              of commands queued during error recovery.  The main&n; *              difference here is that we don&squot;t allow for the possibility&n; *              of retries here, and we are a lot more restrictive about what&n; *              we consider acceptable.&n; */
DECL|function|scsi_eh_completed_normally
id|STATIC
r_int
id|scsi_eh_completed_normally
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|rtn
suffix:semicolon
multiline_comment|/*&n;&t; * First check the host byte, to see if there is anything in there&n;&t; * that would indicate what we need to do.&n;&t; */
r_if
c_cond
(paren
id|host_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
op_eq
id|DID_RESET
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|IS_RESETTING
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * OK, this is normal.  We don&squot;t know whether in fact the&n;&t;&t;&t; * command in question really needs to be rerun or not - &n;&t;&t;&t; * if this was the original data command then the answer is yes,&n;&t;&t;&t; * otherwise we just flag it as success.&n;&t;&t;&t; */
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|IS_RESETTING
suffix:semicolon
r_return
id|NEEDS_RETRY
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Rats.  We are already in the error handler, so we now get to try&n;&t;&t; * and figure out what to do next.  If the sense is valid, we have&n;&t;&t; * a pretty good idea of what to do.  If not, we mark it as failed.&n;&t;&t; */
r_return
id|scsi_check_sense
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|host_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
op_ne
id|DID_OK
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Next, check the message byte.&n;&t; */
r_if
c_cond
(paren
id|msg_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
op_ne
id|COMMAND_COMPLETE
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now, check the status byte to see if this indicates anything special.&n;&t; */
r_switch
c_cond
(paren
id|status_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
)paren
(brace
r_case
id|GOOD
suffix:colon
r_case
id|COMMAND_TERMINATED
suffix:colon
r_return
id|SUCCESS
suffix:semicolon
r_case
id|CHECK_CONDITION
suffix:colon
id|rtn
op_assign
id|scsi_check_sense
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|NEEDS_RETRY
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
r_return
id|rtn
suffix:semicolon
r_case
id|CONDITION_GOOD
suffix:colon
r_case
id|INTERMEDIATE_GOOD
suffix:colon
r_case
id|INTERMEDIATE_C_GOOD
suffix:colon
multiline_comment|/*&n;&t;&t; * Who knows?  FIXME(eric)&n;&t;&t; */
r_return
id|SUCCESS
suffix:semicolon
r_case
id|BUSY
suffix:colon
r_case
id|QUEUE_FULL
suffix:colon
r_case
id|RESERVATION_CONFLICT
suffix:colon
r_default
suffix:colon
r_return
id|FAILED
suffix:semicolon
)brace
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:  scsi_check_sense&n; *&n; * Purpose:     Examine sense information - give suggestion as to what&n; *              we should do with it.&n; */
DECL|function|scsi_check_sense
id|STATIC
r_int
id|scsi_check_sense
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|scsi_sense_valid
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xe0
)paren
r_return
id|SUCCESS
suffix:semicolon
r_switch
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
(brace
r_case
id|NO_SENSE
suffix:colon
r_return
id|SUCCESS
suffix:semicolon
r_case
id|RECOVERED_ERROR
suffix:colon
r_return
multiline_comment|/* SOFT_ERROR */
id|SUCCESS
suffix:semicolon
r_case
id|ABORTED_COMMAND
suffix:colon
r_return
id|NEEDS_RETRY
suffix:semicolon
r_case
id|NOT_READY
suffix:colon
r_case
id|UNIT_ATTENTION
suffix:colon
multiline_comment|/*&n;&t;&t; * If we are expecting a CC/UA because of a bus reset that we&n;&t;&t; * performed, treat this just as a retry.  Otherwise this is&n;&t;&t; * information that we should pass up to the upper-level driver&n;&t;&t; * so that we can deal with it there.&n;&t;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;expecting_cc_ua
)paren
(brace
id|SCpnt-&gt;device-&gt;expecting_cc_ua
op_assign
l_int|0
suffix:semicolon
r_return
id|NEEDS_RETRY
suffix:semicolon
)brace
r_return
id|SUCCESS
suffix:semicolon
multiline_comment|/* these three are not supported */
r_case
id|COPY_ABORTED
suffix:colon
r_case
id|VOLUME_OVERFLOW
suffix:colon
r_case
id|MISCOMPARE
suffix:colon
r_return
id|SUCCESS
suffix:semicolon
r_case
id|MEDIUM_ERROR
suffix:colon
r_return
id|NEEDS_RETRY
suffix:semicolon
r_case
id|ILLEGAL_REQUEST
suffix:colon
r_case
id|BLANK_CHECK
suffix:colon
r_case
id|DATA_PROTECT
suffix:colon
r_case
id|HARDWARE_ERROR
suffix:colon
r_default
suffix:colon
r_return
id|SUCCESS
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:  scsi_restart_operations&n; *&n; * Purpose:     Restart IO operations to the specified host.&n; *&n; * Arguments:   host  - host that we are restarting&n; *&n; * Lock status: Assumed that locks are not held upon entry.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       When we entered the error handler, we blocked all further&n; *              I/O to this device.  We need to &squot;reverse&squot; this process.&n; */
DECL|function|scsi_restart_operations
id|STATIC
r_void
id|scsi_restart_operations
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
op_amp
id|io_request_lock
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Next free up anything directly waiting upon the host.  This will be&n;&t; * requests for character device operations, and also for ioctls to queued&n;&t; * block devices.&n;&t; */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;scsi_error.c: Waking up host to restart&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|host-&gt;host_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Finally we need to re-initiate requests that may be pending.  We will&n;&t; * have had everything blocked while error handling is taking place, and&n;&t; * now that error recovery is done, we will need to ensure that these&n;&t; * requests are started.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
id|request_queue_t
op_star
id|q
suffix:semicolon
r_if
c_cond
(paren
(paren
id|host-&gt;can_queue
OG
l_int|0
op_logical_and
(paren
id|host-&gt;host_busy
op_ge
id|host-&gt;can_queue
)paren
)paren
op_logical_or
(paren
id|host-&gt;host_blocked
)paren
op_logical_or
(paren
id|host-&gt;host_self_blocked
)paren
op_logical_or
(paren
id|SDpnt-&gt;device_blocked
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|q
op_assign
op_amp
id|SDpnt-&gt;request_queue
suffix:semicolon
id|q
op_member_access_from_pointer
id|request_fn
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:  scsi_unjam_host&n; *&n; * Purpose:     Attempt to fix a host which has a command that failed for&n; *              some reason.&n; *&n; * Arguments:   host    - host that needs unjamming.&n; * &n; * Returns:     Nothing&n; *&n; * Notes:       When we come in here, we *know* that all commands on the&n; *              bus have either completed, failed or timed out.  We also&n; *              know that no further commands are being sent to the host,&n; *              so things are relatively quiet and we have freedom to&n; *              fiddle with things as we wish.&n; *&n; * Additional note:  This is only the *default* implementation.  It is possible&n; *              for individual drivers to supply their own version of this&n; *              function, and if the maintainer wishes to do this, it is&n; *              strongly suggested that this function be taken as a template&n; *              and modified.  This function was designed to correctly handle&n; *              problems for about 95% of the different cases out there, and&n; *              it should always provide at least a reasonable amount of error&n; *              recovery.&n; *&n; * Note3:       Any command marked &squot;FAILED&squot; or &squot;TIMEOUT&squot; must eventually&n; *              have scsi_finish_command() called for it.  We do all of&n; *              the retry stuff here, so when we restart the host after we&n; *              return it should have an empty queue.&n; */
DECL|function|scsi_unjam_host
id|STATIC
r_int
id|scsi_unjam_host
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_int
id|devices_failed
suffix:semicolon
r_int
id|numfailed
suffix:semicolon
r_int
id|ourrtn
suffix:semicolon
r_int
id|rtn
op_assign
id|FALSE
suffix:semicolon
r_int
id|result
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCloop
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDloop
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCdone
suffix:semicolon
r_int
id|timed_out
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
op_amp
id|io_request_lock
comma
l_int|0
)paren
suffix:semicolon
id|SCdone
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * First, protect against any sort of race condition.  If any of the outstanding&n;&t; * commands are in states that indicate that we are not yet blocked (i.e. we are&n;&t; * not in a quiet state) then we got woken up in error.  If we ever end up here,&n;&t; * we need to re-examine some of the assumptions.&n;&t; */
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;state
op_eq
id|SCSI_STATE_FAILED
op_logical_or
id|SCpnt-&gt;state
op_eq
id|SCSI_STATE_TIMEOUT
op_logical_or
id|SCpnt-&gt;state
op_eq
id|SCSI_STATE_INITIALIZING
op_logical_or
id|SCpnt-&gt;state
op_eq
id|SCSI_STATE_UNUSED
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Rats.  Something is still floating around out there.  This could&n;&t;&t;&t; * be the result of the fact that the upper level drivers are still frobbing&n;&t;&t;&t; * commands that might have succeeded.  There are two outcomes.  One is that&n;&t;&t;&t; * the command block will eventually be freed, and the other one is that&n;&t;&t;&t; * the command will be queued and will be finished along the way.&n;&t;&t;&t; */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Error handler prematurely woken - commands still active (%p %x %d)&bslash;n&quot;
comma
id|SCpnt
comma
id|SCpnt-&gt;state
comma
id|SCpnt-&gt;target
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; *        panic(&quot;SCSI Error handler woken too early&bslash;n&quot;);&n; *&n; * This is no longer a problem, since now the code cares only about&n; * SCSI_STATE_TIMEOUT and SCSI_STATE_FAILED.&n; * Other states are useful only to release active commands when devices are&n; * set offline. If (host-&gt;host_active == host-&gt;host_busy) we can safely assume&n; * that there are no commands in state other then TIMEOUT od FAILED. (DB)&n; *&n; * FIXME:&n; * It is not easy to release correctly commands according to their state when &n; * devices are set offline, when the state is neither TIMEOUT nor FAILED.&n; * When a device is set offline, we can have some command with&n; * rq_status=RQ_SCSY_BUSY, owner=SCSI_STATE_HIGHLEVEL, &n; * state=SCSI_STATE_INITIALIZING and the driver module cannot be released.&n; * (DB, 17 May 1998)&n; */
)brace
)brace
multiline_comment|/*&n;&t; * Next, see if we need to request sense information.  if so,&n;&t; * then get it now, so we have a better idea of what to do.&n;&t; * FIXME(eric) this has the unfortunate side effect that if a host&n;&t; * adapter does not automatically request sense information, that we end&n;&t; * up shutting it down before we request it.  All hosts should be doing this&n;&t; * anyways, so for now all I have to say is tough noogies if you end up in here.&n;&t; * On second thought, this is probably a good idea.  We *really* want to give&n;&t; * authors an incentive to automatically request this.&n;&t; */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Checking to see if we need to request sense&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;state
op_ne
id|SCSI_STATE_FAILED
op_logical_or
id|scsi_sense_valid
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Requesting sense for %d&bslash;n&quot;
comma
id|SCpnt-&gt;target
)paren
)paren
suffix:semicolon
id|rtn
op_assign
id|scsi_request_sense
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_ne
id|SUCCESS
)paren
(brace
r_continue
suffix:semicolon
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Sense requested for %p - result %x&bslash;n&quot;
comma
id|SCpnt
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|print_sense
c_func
(paren
l_string|&quot;bh&quot;
comma
id|SCpnt
)paren
)paren
suffix:semicolon
id|result
op_assign
id|scsi_decide_disposition
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If the result was normal, then just pass it along to the&n;&t;&t;&t; * upper level.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|result
op_eq
id|SUCCESS
)paren
(brace
id|SCpnt-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCpnt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ne
id|NEEDS_RETRY
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * We only come in here if we want to retry a&n;&t;&t;&t; * command.  The test to see whether the command&n;&t;&t;&t; * should be retried should be keeping track of the&n;&t;&t;&t; * number of tries, so we don&squot;t end up looping, of&n;&t;&t;&t; * course.  &n;&t;&t;&t; */
id|SCpnt-&gt;state
op_assign
id|NEEDS_RETRY
suffix:semicolon
id|rtn
op_assign
id|scsi_eh_retry_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_ne
id|SUCCESS
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * We eventually hand this one back to the top level.&n;&t;&t;&t; */
id|SCpnt-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCpnt
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Go through the list of commands and figure out where we stand and how bad things&n;&t; * really are.&n;&t; */
id|numfailed
op_assign
l_int|0
suffix:semicolon
id|timed_out
op_assign
l_int|0
suffix:semicolon
id|devices_failed
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_int
r_int
id|device_error
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;state
op_eq
id|SCSI_STATE_FAILED
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Command to ID %d failed&bslash;n&quot;
comma
id|SCpnt-&gt;target
)paren
)paren
suffix:semicolon
id|numfailed
op_increment
suffix:semicolon
id|device_error
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Command to ID %d timedout&bslash;n&quot;
comma
id|SCpnt-&gt;target
)paren
)paren
suffix:semicolon
id|timed_out
op_increment
suffix:semicolon
id|device_error
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|device_error
OG
l_int|0
)paren
(brace
id|devices_failed
op_increment
suffix:semicolon
)brace
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;Total of %d+%d commands on %d devices require eh work&bslash;n&quot;
comma
id|numfailed
comma
id|timed_out
comma
id|devices_failed
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;host_failed
op_eq
l_int|0
)paren
(brace
id|ourrtn
op_assign
id|TRUE
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Next, try and see whether or not it makes sense to try and abort&n;&t; * the running command.  This only works out to be the case if we have&n;&t; * one command that has timed out.  If the command simply failed, it&n;&t; * makes no sense to try and abort the command, since as far as the&n;&t; * host adapter is concerned, it isn&squot;t running.&n;&t; */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Checking to see if we want to try abort&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCloop
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCloop
suffix:semicolon
id|SCloop
op_assign
id|SCloop-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCloop-&gt;state
op_ne
id|SCSI_STATE_TIMEOUT
)paren
(brace
r_continue
suffix:semicolon
)brace
id|rtn
op_assign
id|scsi_try_to_abort_command
c_func
(paren
id|SCloop
comma
id|ABORT_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
id|rtn
op_assign
id|scsi_test_unit_ready
c_func
(paren
id|SCloop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
op_logical_and
id|scsi_unit_is_ready
c_func
(paren
id|SCloop
)paren
)paren
(brace
id|rtn
op_assign
id|scsi_eh_retry_command
c_func
(paren
id|SCloop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
id|SCloop-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCloop
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
multiline_comment|/*&n;&t; * If we have corrected all of the problems, then we are done.&n;&t; */
r_if
c_cond
(paren
id|host-&gt;host_failed
op_eq
l_int|0
)paren
(brace
id|ourrtn
op_assign
id|TRUE
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Either the abort wasn&squot;t appropriate, or it didn&squot;t succeed.&n;&t; * Now try a bus device reset.  Still, look to see whether we have&n;&t; * multiple devices that are jammed or not - if we have multiple devices,&n;&t; * it makes no sense to try BUS_DEVICE_RESET - we really would need&n;&t; * to try a BUS_RESET instead.&n;&t; *&n;&t; * Does this make sense - should we try BDR on each device individually?&n;&t; * Yes, definitely.&n;&t; */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Checking to see if we want to try BDR&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCloop
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCloop
suffix:semicolon
id|SCloop
op_assign
id|SCloop-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCloop-&gt;state
op_eq
id|SCSI_STATE_FAILED
op_logical_or
id|SCloop-&gt;state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SCloop
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * OK, we have a device that is having problems.  Try and send&n;&t;&t; * a bus device reset to it.&n;&t;&t; *&n;&t;&t; * FIXME(eric) - make sure we handle the case where multiple&n;&t;&t; * commands to the same device have failed. They all must&n;&t;&t; * get properly restarted.&n;&t;&t; */
id|rtn
op_assign
id|scsi_try_bus_device_reset
c_func
(paren
id|SCloop
comma
id|RESET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
id|rtn
op_assign
id|scsi_test_unit_ready
c_func
(paren
id|SCloop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
op_logical_and
id|scsi_unit_is_ready
c_func
(paren
id|SCloop
)paren
)paren
(brace
id|rtn
op_assign
id|scsi_eh_retry_command
c_func
(paren
id|SCloop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
id|SCloop-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCloop
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|host-&gt;host_failed
op_eq
l_int|0
)paren
(brace
id|ourrtn
op_assign
id|TRUE
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we ended up here, we have serious problems.  The only thing left&n;&t; * to try is a full bus reset.  If someone has grabbed the bus and isn&squot;t&n;&t; * letting go, then perhaps this will help.&n;&t; */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Try hard bus reset&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * We really want to loop over the various channels, and do this on&n;&t; * a channel by channel basis.  We should also check to see if any&n;&t; * of the failed commands are on soft_reset devices, and if so, skip&n;&t; * the reset.  &n;&t; */
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
id|next_device
suffix:colon
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;state
op_ne
id|SCSI_STATE_FAILED
op_logical_and
id|SCpnt-&gt;state
op_ne
id|SCSI_STATE_TIMEOUT
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * We have a failed command.  Make sure there are no other failed&n;&t;&t;&t; * commands on the same channel that are timed out and implement a&n;&t;&t;&t; * soft reset.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|SDloop
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDloop
suffix:semicolon
id|SDloop
op_assign
id|SDloop-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCloop
op_assign
id|SDloop-&gt;device_queue
suffix:semicolon
id|SCloop
suffix:semicolon
id|SCloop
op_assign
id|SCloop-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCloop-&gt;channel
op_ne
id|SCpnt-&gt;channel
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCloop-&gt;state
op_ne
id|SCSI_STATE_FAILED
op_logical_and
id|SCloop-&gt;state
op_ne
id|SCSI_STATE_TIMEOUT
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SDloop-&gt;soft_reset
op_logical_and
id|SCloop-&gt;state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * If this device uses the soft reset option, and this&n;&t;&t;&t;&t;&t;&t; * is one of the devices acting up, then our only&n;&t;&t;&t;&t;&t;&t; * option is to wait a bit, since the command is&n;&t;&t;&t;&t;&t;&t; * supposedly still running.  &n;&t;&t;&t;&t;&t;&t; *&n;&t;&t;&t;&t;&t;&t; * FIXME(eric) - right now we will just end up falling&n;&t;&t;&t;&t;&t;&t; * through to the &squot;take device offline&squot; case.&n;&t;&t;&t;&t;&t;&t; *&n;&t;&t;&t;&t;&t;&t; * FIXME(eric) - It is possible that the command completed&n;&t;&t;&t;&t;&t;&t; * *after* the error recovery procedure started, and if this&n;&t;&t;&t;&t;&t;&t; * is the case, we are worrying about nothing here.&n;&t;&t;&t;&t;&t;&t; */
id|scsi_sleep
c_func
(paren
l_int|1
op_star
id|HZ
)paren
suffix:semicolon
r_goto
id|next_device
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * We now know that we are able to perform a reset for the&n;&t;&t;&t; * bus that SCpnt points to.  There are no soft-reset devices&n;&t;&t;&t; * with outstanding timed out commands.&n;&t;&t;&t; */
id|rtn
op_assign
id|scsi_try_bus_reset
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
r_for
c_loop
(paren
id|SDloop
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDloop
suffix:semicolon
id|SDloop
op_assign
id|SDloop-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCloop
op_assign
id|SDloop-&gt;device_queue
suffix:semicolon
id|SCloop
suffix:semicolon
id|SCloop
op_assign
id|SCloop-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCloop-&gt;channel
op_ne
id|SCpnt-&gt;channel
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCloop-&gt;state
op_ne
id|SCSI_STATE_FAILED
op_logical_and
id|SCloop-&gt;state
op_ne
id|SCSI_STATE_TIMEOUT
)paren
(brace
r_continue
suffix:semicolon
)brace
id|rtn
op_assign
id|scsi_test_unit_ready
c_func
(paren
id|SCloop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
op_logical_and
id|scsi_unit_is_ready
c_func
(paren
id|SCloop
)paren
)paren
(brace
id|rtn
op_assign
id|scsi_eh_retry_command
c_func
(paren
id|SCloop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
id|SCpnt-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCloop
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * If the bus reset worked, but we are still unable to&n;&t;&t;&t;&t;&t;&t; * talk to the device, take it offline.&n;&t;&t;&t;&t;&t;&t; * FIXME(eric) - is this really the correct thing to do?&n;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|rtn
op_ne
id|SUCCESS
)paren
(brace
id|SCloop-&gt;device-&gt;online
op_assign
id|FALSE
suffix:semicolon
id|SCloop-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCloop
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|host-&gt;host_failed
op_eq
l_int|0
)paren
(brace
id|ourrtn
op_assign
id|TRUE
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we ended up here, we have serious problems.  The only thing left&n;&t; * to try is a full host reset - perhaps the firmware on the device&n;&t; * crashed, or something like that.&n;&t; *&n;&t; * It is assumed that a succesful host reset will cause *all* information&n;&t; * about the command to be flushed from both the host adapter *and* the&n;&t; * device.&n;&t; *&n;&t; * FIXME(eric) - it isn&squot;t clear that devices that implement the soft reset&n;&t; * option can ever be cleared except via cycling the power.  The problem is&n;&t; * that sending the host reset command will cause the host to forget&n;&t; * about the pending command, but the device won&squot;t forget.  For now, we&n;&t; * skip the host reset option if any of the failed devices are configured&n;&t; * to use the soft reset option.&n;&t; */
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
id|next_device2
suffix:colon
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;state
op_ne
id|SCSI_STATE_FAILED
op_logical_and
id|SCpnt-&gt;state
op_ne
id|SCSI_STATE_TIMEOUT
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SDpnt-&gt;soft_reset
op_logical_and
id|SCpnt-&gt;state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t; * If this device uses the soft reset option, and this&n;&t;&t;&t;&t; * is one of the devices acting up, then our only&n;&t;&t;&t;&t; * option is to wait a bit, since the command is&n;&t;&t;&t;&t; * supposedly still running.  &n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * FIXME(eric) - right now we will just end up falling&n;&t;&t;&t;&t; * through to the &squot;take device offline&squot; case.&n;&t;&t;&t;&t; */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Unable to try hard host reset&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Due to the spinlock, we will never get out of this&n;&t;&t;&t;&t; * loop without a proper wait. (DB)&n;&t;&t;&t;&t; */
id|scsi_sleep
c_func
(paren
l_int|1
op_star
id|HZ
)paren
suffix:semicolon
r_goto
id|next_device2
suffix:semicolon
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Try hard host reset&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * FIXME(eric) - we need to obtain a valid SCpnt to perform this call.&n;&t;&t;&t; */
id|rtn
op_assign
id|scsi_try_host_reset
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * FIXME(eric) we assume that all commands are flushed from the&n;&t;&t;&t;&t; * controller.  We should get a DID_RESET for all of the commands&n;&t;&t;&t;&t; * that were pending.  We should ignore these so that we can&n;&t;&t;&t;&t; * guarantee that we are in a consistent state.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * I believe this to be the case right now, but this needs to be&n;&t;&t;&t;&t; * tested.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|SDloop
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDloop
suffix:semicolon
id|SDloop
op_assign
id|SDloop-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCloop
op_assign
id|SDloop-&gt;device_queue
suffix:semicolon
id|SCloop
suffix:semicolon
id|SCloop
op_assign
id|SCloop-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCloop-&gt;state
op_ne
id|SCSI_STATE_FAILED
op_logical_and
id|SCloop-&gt;state
op_ne
id|SCSI_STATE_TIMEOUT
)paren
(brace
r_continue
suffix:semicolon
)brace
id|rtn
op_assign
id|scsi_test_unit_ready
c_func
(paren
id|SCloop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
op_logical_and
id|scsi_unit_is_ready
c_func
(paren
id|SCloop
)paren
)paren
(brace
id|rtn
op_assign
id|scsi_eh_retry_command
c_func
(paren
id|SCloop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
id|SCpnt-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCloop
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rtn
op_ne
id|SUCCESS
)paren
(brace
id|SCloop-&gt;device-&gt;online
op_assign
id|FALSE
suffix:semicolon
id|SCloop-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCloop
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
)brace
multiline_comment|/*&n;&t; * If we solved all of the problems, then let&squot;s rev up the engines again.&n;&t; */
r_if
c_cond
(paren
id|host-&gt;host_failed
op_eq
l_int|0
)paren
(brace
id|ourrtn
op_assign
id|TRUE
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the HOST RESET failed, then for now we assume that the entire host&n;&t; * adapter is too hosed to be of any use.  For our purposes, however, it is&n;&t; * easier to simply take the devices offline that correspond to commands&n;&t; * that failed.&n;&t; */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Take device offline&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt
op_assign
id|host-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|SCloop
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCloop
suffix:semicolon
id|SCloop
op_assign
id|SCloop-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SCloop-&gt;state
op_eq
id|SCSI_STATE_FAILED
op_logical_or
id|SCloop-&gt;state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
id|SCloop-&gt;device-&gt;online
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * This should pass the failure up to the top level driver, and&n;&t;&t;&t;&t; * it will have to try and do something intelligent with it.&n;&t;&t;&t;&t; */
id|SCloop-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|SCloop-&gt;state
op_eq
id|SCSI_STATE_TIMEOUT
)paren
(brace
id|SCloop-&gt;result
op_or_assign
(paren
id|DRIVER_TIMEOUT
op_lshift
l_int|24
)paren
suffix:semicolon
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Finishing command for device %d %x&bslash;n&quot;
comma
id|SCloop-&gt;device-&gt;id
comma
id|SCloop-&gt;result
)paren
)paren
suffix:semicolon
id|scsi_eh_finish_command
c_func
(paren
op_amp
id|SCdone
comma
id|SCloop
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|host-&gt;host_failed
op_ne
l_int|0
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;scsi_unjam_host: Miscount of number of failed commands.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_unjam_host: Returning&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ourrtn
op_assign
id|FALSE
suffix:semicolon
id|leave
suffix:colon
multiline_comment|/*&n;&t; * We should have a list of commands that we &squot;finished&squot; during the course of&n;&t; * error recovery.  This should be the same as the list of commands that timed out&n;&t; * or failed.  We are currently holding these things in a linked list - we didn&squot;t&n;&t; * put them in the bottom half queue because we wanted to keep things quiet while&n;&t; * we were working on recovery, and passing them up to the top level could easily&n;&t; * cause the top level to try and queue something else again.&n;&t; *&n;&t; * Start by marking that the host is no longer in error recovery.&n;&t; */
id|host-&gt;in_recovery
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Take the list of commands, and stick them in the bottom half queue.&n;&t; * The current implementation of scsi_done will do this for us - if need&n;&t; * be we can create a special version of this function to do the&n;&t; * same job for us.&n;&t; */
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SCdone
suffix:semicolon
id|SCpnt
op_ne
l_int|NULL
suffix:semicolon
id|SCpnt
op_assign
id|SCdone
)paren
(brace
id|SCdone
op_assign
id|SCpnt-&gt;bh_next
suffix:semicolon
id|SCpnt-&gt;bh_next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;                 * Oh, this is a vile hack.  scsi_done() expects a timer&n;                 * to be running on the command.  If there isn&squot;t, it assumes&n;                 * that the command has actually timed out, and a timer&n;                 * handler is running.  That may well be how we got into&n;                 * this fix, but right now things are stable.  We add&n;                 * a timer back again so that we can report completion.&n;                 * scsi_done() will immediately remove said timer from&n;                 * the command, and then process it.&n;                 */
id|scsi_add_timer
c_func
(paren
id|SCpnt
comma
l_int|100
comma
id|scsi_eh_times_out
)paren
suffix:semicolon
id|scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
r_return
(paren
id|ourrtn
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:  scsi_error_handler&n; *&n; * Purpose:     Handle errors/timeouts of scsi commands, try and clean up&n; *              and unjam the bus, and restart things.&n; *&n; * Arguments:   host    - host for which we are running.&n; *&n; * Returns:     Never returns.&n; *&n; * Notes:       This is always run in the context of a kernel thread.  The&n; *              idea is that we start this thing up when the kernel starts&n; *              up (one per host that we detect), and it immediately goes to&n; *              sleep and waits for some event (i.e. failure).  When this&n; *              takes place, we have the job of trying to unjam the bus&n; *              and restarting things.&n; *&n; */
DECL|function|scsi_error_handler
r_void
id|scsi_error_handler
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
(paren
r_struct
id|Scsi_Host
op_star
)paren
id|data
suffix:semicolon
r_int
id|rtn
suffix:semicolon
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|sem
)paren
suffix:semicolon
multiline_comment|/*&n;         * We only listen to signals if the HA was loaded as a module.&n;         * If the HA was compiled into the kernel, then we don&squot;t listen&n;         * to any signals.&n;         */
r_if
c_cond
(paren
id|host-&gt;loaded_as_module
)paren
(brace
id|siginitsetinv
c_func
(paren
op_amp
id|current-&gt;blocked
comma
id|SHUTDOWN_SIGS
)paren
suffix:semicolon
)brace
r_else
(brace
id|siginitsetinv
c_func
(paren
op_amp
id|current-&gt;blocked
comma
l_int|0
)paren
suffix:semicolon
)brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *    Flush resources&n;&t; */
id|daemonize
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the name of this process.&n;&t; */
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;scsi_eh_%d&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|host-&gt;eh_wait
op_assign
op_amp
id|sem
suffix:semicolon
id|host-&gt;ehandler
op_assign
id|current
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wake up the thread that created us.&n;&t; */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Wake up parent %d&bslash;n&quot;
comma
id|host-&gt;eh_notify-&gt;count.counter
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
id|host-&gt;eh_notify
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we get a signal, it means we are supposed to go&n;&t;&t; * away and die.  This typically happens if the user is&n;&t;&t; * trying to unload a module.&n;&t;&t; */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Error handler sleeping&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Note - we always use down_interruptible with the semaphore&n;&t;&t; * even if the module was loaded as part of the kernel.  The&n;&t;&t; * reason is that down() will cause this thread to be counted&n;&t;&t; * in the load average as a running process, and down&n;&t;&t; * interruptible doesn&squot;t.  Given that we need to allow this&n;&t;&t; * thread to die if the driver was loaded as a module, using&n;&t;&t; * semaphores isn&squot;t unreasonable.&n;&t;&t; */
id|down_interruptible
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;loaded_as_module
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Error handler waking up&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|host-&gt;eh_active
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We have a host that is failing for some reason.  Figure out&n;&t;&t; * what we need to do to get it up and online again (if we can).&n;&t;&t; * If we fail, we end up taking the thing offline.&n;&t;&t; */
r_if
c_cond
(paren
id|host-&gt;hostt-&gt;eh_strategy_handler
op_ne
l_int|NULL
)paren
(brace
id|rtn
op_assign
id|host-&gt;hostt
op_member_access_from_pointer
id|eh_strategy_handler
c_func
(paren
id|host
)paren
suffix:semicolon
)brace
r_else
(brace
id|rtn
op_assign
id|scsi_unjam_host
c_func
(paren
id|host
)paren
suffix:semicolon
)brace
id|host-&gt;eh_active
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Note - if the above fails completely, the action is to take&n;&t;&t; * individual devices offline and flush the queue of any&n;&t;&t; * outstanding requests that may have been pending.  When we&n;&t;&t; * restart, we restart any I/O to any other devices on the bus&n;&t;&t; * which are still online.&n;&t;&t; */
id|scsi_restart_operations
c_func
(paren
id|host
)paren
suffix:semicolon
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Error handler exiting&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure that nobody tries to wake us up again.&n;&t; */
id|host-&gt;eh_wait
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Knock this down too.  From this point on, the host is flying&n;&t; * without a pilot.  If this is because the module is being unloaded,&n;&t; * that&squot;s fine.  If the user sent a signal to this thing, we are&n;&t; * potentially in real danger.&n;&t; */
id|host-&gt;in_recovery
op_assign
l_int|0
suffix:semicolon
id|host-&gt;eh_active
op_assign
l_int|0
suffix:semicolon
id|host-&gt;ehandler
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * If anyone is waiting for us to exit (i.e. someone trying to unload&n;&t; * a driver), then wake up that process to let them know we are on&n;&t; * the way out the door.  This may be overkill - I *think* that we&n;&t; * could probably just unload the driver and send the signal, and when&n;&t; * the error handling thread wakes up that it would just exit without&n;&t; * needing to touch any memory associated with the driver itself.&n;&t; */
r_if
c_cond
(paren
id|host-&gt;eh_notify
op_ne
l_int|NULL
)paren
id|up
c_func
(paren
id|host-&gt;eh_notify
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: nil&n; * tab-width: 8&n; * End:&n; */
eof
