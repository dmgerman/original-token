multiline_comment|/* $Id: esp.c,v 1.98 2000/11/02 22:34:16 davem Exp $&n; * esp.c:  EnhancedScsiProcessor Sun SCSI driver code.&n; *&n; * Copyright (C) 1995, 1998 David S. Miller (davem@caip.rutgers.edu)&n; */
multiline_comment|/* TODO:&n; *&n; * 1) Maybe disable parity checking in config register one for SCSI1&n; *    targets.  (Gilmore says parity error on the SBus can lock up&n; *    old sun4c&squot;s)&n; * 2) Add support for DMA2 pipelining.&n; * 3) Add tagged queueing.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;esp.h&quot;
macro_line|#include &lt;asm/sbus.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#ifndef __sparc_v9__
macro_line|#include &lt;asm/machines.h&gt;
macro_line|#include &lt;asm/idprom.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/module.h&gt;
DECL|macro|DEBUG_ESP
mdefine_line|#define DEBUG_ESP
multiline_comment|/* #define DEBUG_ESP_HME */
multiline_comment|/* #define DEBUG_ESP_DATA */
multiline_comment|/* #define DEBUG_ESP_QUEUE */
multiline_comment|/* #define DEBUG_ESP_DISCONNECT */
multiline_comment|/* #define DEBUG_ESP_STATUS */
multiline_comment|/* #define DEBUG_ESP_PHASES */
multiline_comment|/* #define DEBUG_ESP_WORKBUS */
multiline_comment|/* #define DEBUG_STATE_MACHINE */
multiline_comment|/* #define DEBUG_ESP_CMDS */
multiline_comment|/* #define DEBUG_ESP_IRQS */
multiline_comment|/* #define DEBUG_SDTR */
multiline_comment|/* #define DEBUG_ESP_SG */
multiline_comment|/* Use the following to sprinkle debugging messages in a way which&n; * suits you if combinations of the above become too verbose when&n; * trying to track down a specific problem.&n; */
multiline_comment|/* #define DEBUG_ESP_MISC */
macro_line|#if defined(DEBUG_ESP)
DECL|macro|ESPLOG
mdefine_line|#define ESPLOG(foo)  printk foo
macro_line|#else
DECL|macro|ESPLOG
mdefine_line|#define ESPLOG(foo)
macro_line|#endif /* (DEBUG_ESP) */
macro_line|#if defined(DEBUG_ESP_HME)
DECL|macro|ESPHME
mdefine_line|#define ESPHME(foo)  printk foo
macro_line|#else
DECL|macro|ESPHME
mdefine_line|#define ESPHME(foo)
macro_line|#endif
macro_line|#if defined(DEBUG_ESP_DATA)
DECL|macro|ESPDATA
mdefine_line|#define ESPDATA(foo)  printk foo
macro_line|#else
DECL|macro|ESPDATA
mdefine_line|#define ESPDATA(foo)
macro_line|#endif
macro_line|#if defined(DEBUG_ESP_QUEUE)
DECL|macro|ESPQUEUE
mdefine_line|#define ESPQUEUE(foo)  printk foo
macro_line|#else
DECL|macro|ESPQUEUE
mdefine_line|#define ESPQUEUE(foo)
macro_line|#endif
macro_line|#if defined(DEBUG_ESP_DISCONNECT)
DECL|macro|ESPDISC
mdefine_line|#define ESPDISC(foo)  printk foo
macro_line|#else
DECL|macro|ESPDISC
mdefine_line|#define ESPDISC(foo)
macro_line|#endif
macro_line|#if defined(DEBUG_ESP_STATUS)
DECL|macro|ESPSTAT
mdefine_line|#define ESPSTAT(foo)  printk foo
macro_line|#else
DECL|macro|ESPSTAT
mdefine_line|#define ESPSTAT(foo)
macro_line|#endif
macro_line|#if defined(DEBUG_ESP_PHASES)
DECL|macro|ESPPHASE
mdefine_line|#define ESPPHASE(foo)  printk foo
macro_line|#else
DECL|macro|ESPPHASE
mdefine_line|#define ESPPHASE(foo)
macro_line|#endif
macro_line|#if defined(DEBUG_ESP_WORKBUS)
DECL|macro|ESPBUS
mdefine_line|#define ESPBUS(foo)  printk foo
macro_line|#else
DECL|macro|ESPBUS
mdefine_line|#define ESPBUS(foo)
macro_line|#endif
macro_line|#if defined(DEBUG_ESP_IRQS)
DECL|macro|ESPIRQ
mdefine_line|#define ESPIRQ(foo)  printk foo
macro_line|#else
DECL|macro|ESPIRQ
mdefine_line|#define ESPIRQ(foo)
macro_line|#endif
macro_line|#if defined(DEBUG_SDTR)
DECL|macro|ESPSDTR
mdefine_line|#define ESPSDTR(foo)  printk foo
macro_line|#else
DECL|macro|ESPSDTR
mdefine_line|#define ESPSDTR(foo)
macro_line|#endif
macro_line|#if defined(DEBUG_ESP_MISC)
DECL|macro|ESPMISC
mdefine_line|#define ESPMISC(foo)  printk foo
macro_line|#else
DECL|macro|ESPMISC
mdefine_line|#define ESPMISC(foo)
macro_line|#endif
multiline_comment|/* Command phase enumeration. */
r_enum
(brace
DECL|enumerator|not_issued
id|not_issued
op_assign
l_int|0x00
comma
multiline_comment|/* Still in the issue_SC queue.          */
multiline_comment|/* Various forms of selecting a target. */
DECL|macro|in_slct_mask
mdefine_line|#define in_slct_mask    0x10
DECL|enumerator|in_slct_norm
id|in_slct_norm
op_assign
l_int|0x10
comma
multiline_comment|/* ESP is arbitrating, normal selection  */
DECL|enumerator|in_slct_stop
id|in_slct_stop
op_assign
l_int|0x11
comma
multiline_comment|/* ESP will select, then stop with IRQ   */
DECL|enumerator|in_slct_msg
id|in_slct_msg
op_assign
l_int|0x12
comma
multiline_comment|/* select, then send a message           */
DECL|enumerator|in_slct_tag
id|in_slct_tag
op_assign
l_int|0x13
comma
multiline_comment|/* select and send tagged queue msg      */
DECL|enumerator|in_slct_sneg
id|in_slct_sneg
op_assign
l_int|0x14
comma
multiline_comment|/* select and acquire sync capabilities  */
multiline_comment|/* Any post selection activity. */
DECL|macro|in_phases_mask
mdefine_line|#define in_phases_mask  0x20
DECL|enumerator|in_datain
id|in_datain
op_assign
l_int|0x20
comma
multiline_comment|/* Data is transferring from the bus     */
DECL|enumerator|in_dataout
id|in_dataout
op_assign
l_int|0x21
comma
multiline_comment|/* Data is transferring to the bus       */
DECL|enumerator|in_data_done
id|in_data_done
op_assign
l_int|0x22
comma
multiline_comment|/* Last DMA data operation done (maybe)  */
DECL|enumerator|in_msgin
id|in_msgin
op_assign
l_int|0x23
comma
multiline_comment|/* Eating message from target            */
DECL|enumerator|in_msgincont
id|in_msgincont
op_assign
l_int|0x24
comma
multiline_comment|/* Eating more msg bytes from target     */
DECL|enumerator|in_msgindone
id|in_msgindone
op_assign
l_int|0x25
comma
multiline_comment|/* Decide what to do with what we got    */
DECL|enumerator|in_msgout
id|in_msgout
op_assign
l_int|0x26
comma
multiline_comment|/* Sending message to target             */
DECL|enumerator|in_msgoutdone
id|in_msgoutdone
op_assign
l_int|0x27
comma
multiline_comment|/* Done sending msg out                  */
DECL|enumerator|in_cmdbegin
id|in_cmdbegin
op_assign
l_int|0x28
comma
multiline_comment|/* Sending cmd after abnormal selection  */
DECL|enumerator|in_cmdend
id|in_cmdend
op_assign
l_int|0x29
comma
multiline_comment|/* Done sending slow cmd                 */
DECL|enumerator|in_status
id|in_status
op_assign
l_int|0x2a
comma
multiline_comment|/* Was in status phase, finishing cmd    */
DECL|enumerator|in_freeing
id|in_freeing
op_assign
l_int|0x2b
comma
multiline_comment|/* freeing the bus for cmd cmplt or disc */
DECL|enumerator|in_the_dark
id|in_the_dark
op_assign
l_int|0x2c
comma
multiline_comment|/* Don&squot;t know what bus phase we are in   */
multiline_comment|/* Special states, ie. not normal bus transitions... */
DECL|macro|in_spec_mask
mdefine_line|#define in_spec_mask    0x80
DECL|enumerator|in_abortone
id|in_abortone
op_assign
l_int|0x80
comma
multiline_comment|/* Aborting one command currently        */
DECL|enumerator|in_abortall
id|in_abortall
op_assign
l_int|0x81
comma
multiline_comment|/* Blowing away all commands we have     */
DECL|enumerator|in_resetdev
id|in_resetdev
op_assign
l_int|0x82
comma
multiline_comment|/* SCSI target reset in progress         */
DECL|enumerator|in_resetbus
id|in_resetbus
op_assign
l_int|0x83
comma
multiline_comment|/* SCSI bus reset in progress            */
DECL|enumerator|in_tgterror
id|in_tgterror
op_assign
l_int|0x84
comma
multiline_comment|/* Target did something stupid           */
)brace
suffix:semicolon
r_enum
(brace
multiline_comment|/* Zero has special meaning, see skipahead[12]. */
DECL|enumerator|do_never
multiline_comment|/*0*/
id|do_never
comma
DECL|enumerator|do_phase_determine
multiline_comment|/*1*/
id|do_phase_determine
comma
DECL|enumerator|do_reset_bus
multiline_comment|/*2*/
id|do_reset_bus
comma
DECL|enumerator|do_reset_complete
multiline_comment|/*3*/
id|do_reset_complete
comma
DECL|enumerator|do_work_bus
multiline_comment|/*4*/
id|do_work_bus
comma
DECL|enumerator|do_intr_end
multiline_comment|/*5*/
id|do_intr_end
)brace
suffix:semicolon
multiline_comment|/* The master ring of all esp hosts we are managing in this driver. */
DECL|variable|espchain
r_static
r_struct
id|esp
op_star
id|espchain
suffix:semicolon
DECL|variable|espchain_lock
r_static
id|spinlock_t
id|espchain_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|esps_running
r_static
r_int
id|esps_running
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Forward declarations. */
r_static
r_void
id|esp_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|pregs
)paren
suffix:semicolon
multiline_comment|/* Debugging routines */
DECL|struct|esp_cmdstrings
r_struct
id|esp_cmdstrings
(brace
DECL|member|cmdchar
id|u8
id|cmdchar
suffix:semicolon
DECL|member|text
r_char
op_star
id|text
suffix:semicolon
DECL|variable|esp_cmd_strings
)brace
id|esp_cmd_strings
(braket
)braket
op_assign
(brace
multiline_comment|/* Miscellaneous */
(brace
id|ESP_CMD_NULL
comma
l_string|&quot;ESP_NOP&quot;
comma
)brace
comma
(brace
id|ESP_CMD_FLUSH
comma
l_string|&quot;FIFO_FLUSH&quot;
comma
)brace
comma
(brace
id|ESP_CMD_RC
comma
l_string|&quot;RSTESP&quot;
comma
)brace
comma
(brace
id|ESP_CMD_RS
comma
l_string|&quot;RSTSCSI&quot;
comma
)brace
comma
multiline_comment|/* Disconnected State Group */
(brace
id|ESP_CMD_RSEL
comma
l_string|&quot;RESLCTSEQ&quot;
comma
)brace
comma
(brace
id|ESP_CMD_SEL
comma
l_string|&quot;SLCTNATN&quot;
comma
)brace
comma
(brace
id|ESP_CMD_SELA
comma
l_string|&quot;SLCTATN&quot;
comma
)brace
comma
(brace
id|ESP_CMD_SELAS
comma
l_string|&quot;SLCTATNSTOP&quot;
comma
)brace
comma
(brace
id|ESP_CMD_ESEL
comma
l_string|&quot;ENSLCTRESEL&quot;
comma
)brace
comma
(brace
id|ESP_CMD_DSEL
comma
l_string|&quot;DISSELRESEL&quot;
comma
)brace
comma
(brace
id|ESP_CMD_SA3
comma
l_string|&quot;SLCTATN3&quot;
comma
)brace
comma
(brace
id|ESP_CMD_RSEL3
comma
l_string|&quot;RESLCTSEQ&quot;
comma
)brace
comma
multiline_comment|/* Target State Group */
(brace
id|ESP_CMD_SMSG
comma
l_string|&quot;SNDMSG&quot;
comma
)brace
comma
(brace
id|ESP_CMD_SSTAT
comma
l_string|&quot;SNDSTATUS&quot;
comma
)brace
comma
(brace
id|ESP_CMD_SDATA
comma
l_string|&quot;SNDDATA&quot;
comma
)brace
comma
(brace
id|ESP_CMD_DSEQ
comma
l_string|&quot;DISCSEQ&quot;
comma
)brace
comma
(brace
id|ESP_CMD_TSEQ
comma
l_string|&quot;TERMSEQ&quot;
comma
)brace
comma
(brace
id|ESP_CMD_TCCSEQ
comma
l_string|&quot;TRGTCMDCOMPSEQ&quot;
comma
)brace
comma
(brace
id|ESP_CMD_DCNCT
comma
l_string|&quot;DISC&quot;
comma
)brace
comma
(brace
id|ESP_CMD_RMSG
comma
l_string|&quot;RCVMSG&quot;
comma
)brace
comma
(brace
id|ESP_CMD_RCMD
comma
l_string|&quot;RCVCMD&quot;
comma
)brace
comma
(brace
id|ESP_CMD_RDATA
comma
l_string|&quot;RCVDATA&quot;
comma
)brace
comma
(brace
id|ESP_CMD_RCSEQ
comma
l_string|&quot;RCVCMDSEQ&quot;
comma
)brace
comma
multiline_comment|/* Initiator State Group */
(brace
id|ESP_CMD_TI
comma
l_string|&quot;TRANSINFO&quot;
comma
)brace
comma
(brace
id|ESP_CMD_ICCSEQ
comma
l_string|&quot;INICMDSEQCOMP&quot;
comma
)brace
comma
(brace
id|ESP_CMD_MOK
comma
l_string|&quot;MSGACCEPTED&quot;
comma
)brace
comma
(brace
id|ESP_CMD_TPAD
comma
l_string|&quot;TPAD&quot;
comma
)brace
comma
(brace
id|ESP_CMD_SATN
comma
l_string|&quot;SATN&quot;
comma
)brace
comma
(brace
id|ESP_CMD_RATN
comma
l_string|&quot;RATN&quot;
comma
)brace
comma
)brace
suffix:semicolon
DECL|macro|NUM_ESP_COMMANDS
mdefine_line|#define NUM_ESP_COMMANDS  ((sizeof(esp_cmd_strings)) / (sizeof(struct esp_cmdstrings)))
multiline_comment|/* Print textual representation of an ESP command */
DECL|function|esp_print_cmd
r_static
r_inline
r_void
id|esp_print_cmd
c_func
(paren
id|u8
id|espcmd
)paren
(brace
id|u8
id|dma_bit
op_assign
id|espcmd
op_amp
id|ESP_CMD_DMA
suffix:semicolon
r_int
id|i
suffix:semicolon
id|espcmd
op_and_assign
op_complement
id|dma_bit
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_ESP_COMMANDS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|esp_cmd_strings
(braket
id|i
)braket
dot
id|cmdchar
op_eq
id|espcmd
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|NUM_ESP_COMMANDS
)paren
id|printk
c_func
(paren
l_string|&quot;ESP_Unknown&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%s%s&quot;
comma
id|esp_cmd_strings
(braket
id|i
)braket
dot
id|text
comma
(paren
(paren
id|dma_bit
)paren
ques
c_cond
l_string|&quot;+DMA&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Print the status register&squot;s value */
DECL|function|esp_print_statreg
r_static
r_inline
r_void
id|esp_print_statreg
c_func
(paren
id|u8
id|statreg
)paren
(brace
id|u8
id|phase
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;STATUS&lt;&quot;
)paren
suffix:semicolon
id|phase
op_assign
id|statreg
op_amp
id|ESP_STAT_PMASK
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s,&quot;
comma
(paren
id|phase
op_eq
id|ESP_DOP
ques
c_cond
l_string|&quot;DATA-OUT&quot;
suffix:colon
(paren
id|phase
op_eq
id|ESP_DIP
ques
c_cond
l_string|&quot;DATA-IN&quot;
suffix:colon
(paren
id|phase
op_eq
id|ESP_CMDP
ques
c_cond
l_string|&quot;COMMAND&quot;
suffix:colon
(paren
id|phase
op_eq
id|ESP_STATP
ques
c_cond
l_string|&quot;STATUS&quot;
suffix:colon
(paren
id|phase
op_eq
id|ESP_MOP
ques
c_cond
l_string|&quot;MSG-OUT&quot;
suffix:colon
(paren
id|phase
op_eq
id|ESP_MIP
ques
c_cond
l_string|&quot;MSG_IN&quot;
suffix:colon
l_string|&quot;unknown&quot;
)paren
)paren
)paren
)paren
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|statreg
op_amp
id|ESP_STAT_TDONE
)paren
id|printk
c_func
(paren
l_string|&quot;TRANS_DONE,&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|statreg
op_amp
id|ESP_STAT_TCNT
)paren
id|printk
c_func
(paren
l_string|&quot;TCOUNT_ZERO,&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|statreg
op_amp
id|ESP_STAT_PERR
)paren
id|printk
c_func
(paren
l_string|&quot;P_ERROR,&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|statreg
op_amp
id|ESP_STAT_SPAM
)paren
id|printk
c_func
(paren
l_string|&quot;SPAM,&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|statreg
op_amp
id|ESP_STAT_INTR
)paren
id|printk
c_func
(paren
l_string|&quot;IRQ,&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Print the interrupt register&squot;s value */
DECL|function|esp_print_ireg
r_static
r_inline
r_void
id|esp_print_ireg
c_func
(paren
id|u8
id|intreg
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;INTREG&lt; &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intreg
op_amp
id|ESP_INTR_S
)paren
id|printk
c_func
(paren
l_string|&quot;SLCT_NATN &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intreg
op_amp
id|ESP_INTR_SATN
)paren
id|printk
c_func
(paren
l_string|&quot;SLCT_ATN &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intreg
op_amp
id|ESP_INTR_RSEL
)paren
id|printk
c_func
(paren
l_string|&quot;RSLCT &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intreg
op_amp
id|ESP_INTR_FDONE
)paren
id|printk
c_func
(paren
l_string|&quot;FDONE &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intreg
op_amp
id|ESP_INTR_BSERV
)paren
id|printk
c_func
(paren
l_string|&quot;BSERV &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intreg
op_amp
id|ESP_INTR_DC
)paren
id|printk
c_func
(paren
l_string|&quot;DISCNCT &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intreg
op_amp
id|ESP_INTR_IC
)paren
id|printk
c_func
(paren
l_string|&quot;ILL_CMD &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intreg
op_amp
id|ESP_INTR_SR
)paren
id|printk
c_func
(paren
l_string|&quot;SCSI_BUS_RESET &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Print the sequence step registers contents */
DECL|function|esp_print_seqreg
r_static
r_inline
r_void
id|esp_print_seqreg
c_func
(paren
id|u8
id|stepreg
)paren
(brace
id|stepreg
op_and_assign
id|ESP_STEP_VBITS
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;STEP&lt;%s&gt;&quot;
comma
(paren
id|stepreg
op_eq
id|ESP_STEP_ASEL
ques
c_cond
l_string|&quot;SLCT_ARB_CMPLT&quot;
suffix:colon
(paren
id|stepreg
op_eq
id|ESP_STEP_SID
ques
c_cond
l_string|&quot;1BYTE_MSG_SENT&quot;
suffix:colon
(paren
id|stepreg
op_eq
id|ESP_STEP_NCMD
ques
c_cond
l_string|&quot;NOT_IN_CMD_PHASE&quot;
suffix:colon
(paren
id|stepreg
op_eq
id|ESP_STEP_PPC
ques
c_cond
l_string|&quot;CMD_BYTES_LOST&quot;
suffix:colon
(paren
id|stepreg
op_eq
id|ESP_STEP_FINI4
ques
c_cond
l_string|&quot;CMD_SENT_OK&quot;
suffix:colon
l_string|&quot;UNKNOWN&quot;
)paren
)paren
)paren
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|phase_string
r_static
r_char
op_star
id|phase_string
c_func
(paren
r_int
id|phase
)paren
(brace
r_switch
c_cond
(paren
id|phase
)paren
(brace
r_case
id|not_issued
suffix:colon
r_return
l_string|&quot;UNISSUED&quot;
suffix:semicolon
r_case
id|in_slct_norm
suffix:colon
r_return
l_string|&quot;SLCTNORM&quot;
suffix:semicolon
r_case
id|in_slct_stop
suffix:colon
r_return
l_string|&quot;SLCTSTOP&quot;
suffix:semicolon
r_case
id|in_slct_msg
suffix:colon
r_return
l_string|&quot;SLCTMSG&quot;
suffix:semicolon
r_case
id|in_slct_tag
suffix:colon
r_return
l_string|&quot;SLCTTAG&quot;
suffix:semicolon
r_case
id|in_slct_sneg
suffix:colon
r_return
l_string|&quot;SLCTSNEG&quot;
suffix:semicolon
r_case
id|in_datain
suffix:colon
r_return
l_string|&quot;DATAIN&quot;
suffix:semicolon
r_case
id|in_dataout
suffix:colon
r_return
l_string|&quot;DATAOUT&quot;
suffix:semicolon
r_case
id|in_data_done
suffix:colon
r_return
l_string|&quot;DATADONE&quot;
suffix:semicolon
r_case
id|in_msgin
suffix:colon
r_return
l_string|&quot;MSGIN&quot;
suffix:semicolon
r_case
id|in_msgincont
suffix:colon
r_return
l_string|&quot;MSGINCONT&quot;
suffix:semicolon
r_case
id|in_msgindone
suffix:colon
r_return
l_string|&quot;MSGINDONE&quot;
suffix:semicolon
r_case
id|in_msgout
suffix:colon
r_return
l_string|&quot;MSGOUT&quot;
suffix:semicolon
r_case
id|in_msgoutdone
suffix:colon
r_return
l_string|&quot;MSGOUTDONE&quot;
suffix:semicolon
r_case
id|in_cmdbegin
suffix:colon
r_return
l_string|&quot;CMDBEGIN&quot;
suffix:semicolon
r_case
id|in_cmdend
suffix:colon
r_return
l_string|&quot;CMDEND&quot;
suffix:semicolon
r_case
id|in_status
suffix:colon
r_return
l_string|&quot;STATUS&quot;
suffix:semicolon
r_case
id|in_freeing
suffix:colon
r_return
l_string|&quot;FREEING&quot;
suffix:semicolon
r_case
id|in_the_dark
suffix:colon
r_return
l_string|&quot;CLUELESS&quot;
suffix:semicolon
r_case
id|in_abortone
suffix:colon
r_return
l_string|&quot;ABORTONE&quot;
suffix:semicolon
r_case
id|in_abortall
suffix:colon
r_return
l_string|&quot;ABORTALL&quot;
suffix:semicolon
r_case
id|in_resetdev
suffix:colon
r_return
l_string|&quot;RESETDEV&quot;
suffix:semicolon
r_case
id|in_resetbus
suffix:colon
r_return
l_string|&quot;RESETBUS&quot;
suffix:semicolon
r_case
id|in_tgterror
suffix:colon
r_return
l_string|&quot;TGTERROR&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;UNKNOWN&quot;
suffix:semicolon
)brace
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_STATE_MACHINE
DECL|function|esp_advance_phase
r_static
r_inline
r_void
id|esp_advance_phase
c_func
(paren
id|Scsi_Cmnd
op_star
id|s
comma
r_int
id|newphase
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;&lt;%s&gt;&quot;
comma
id|phase_string
c_func
(paren
id|newphase
)paren
)paren
)paren
suffix:semicolon
id|s-&gt;SCp.sent_command
op_assign
id|s-&gt;SCp.phase
suffix:semicolon
id|s-&gt;SCp.phase
op_assign
id|newphase
suffix:semicolon
)brace
macro_line|#else
DECL|macro|esp_advance_phase
mdefine_line|#define esp_advance_phase(__s, __newphase) &bslash;&n;&t;(__s)-&gt;SCp.sent_command = (__s)-&gt;SCp.phase; &bslash;&n;&t;(__s)-&gt;SCp.phase = (__newphase);
macro_line|#endif
macro_line|#ifdef DEBUG_ESP_CMDS
DECL|function|esp_cmd
r_extern
r_inline
r_void
id|esp_cmd
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
id|u8
id|cmd
)paren
(brace
id|esp-&gt;espcmdlog
(braket
id|esp-&gt;espcmdent
)braket
op_assign
id|cmd
suffix:semicolon
id|esp-&gt;espcmdent
op_assign
(paren
id|esp-&gt;espcmdent
op_plus
l_int|1
)paren
op_amp
l_int|31
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|cmd
comma
id|esp-&gt;eregs
op_plus
id|ESP_CMD
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|esp_cmd
mdefine_line|#define esp_cmd(__esp, __cmd)&t;&bslash;&n;&t;sbus_writeb((__cmd), ((__esp)-&gt;eregs) + ESP_CMD)
macro_line|#endif
DECL|macro|ESP_INTSOFF
mdefine_line|#define ESP_INTSOFF(__dregs)&t;&bslash;&n;&t;sbus_writel(sbus_readl((__dregs)+DMA_CSR)&amp;~(DMA_INT_ENAB), (__dregs)+DMA_CSR)
DECL|macro|ESP_INTSON
mdefine_line|#define ESP_INTSON(__dregs)&t;&bslash;&n;&t;sbus_writel(sbus_readl((__dregs)+DMA_CSR)|DMA_INT_ENAB, (__dregs)+DMA_CSR)
DECL|macro|ESP_IRQ_P
mdefine_line|#define ESP_IRQ_P(__dregs)&t;&bslash;&n;&t;(sbus_readl((__dregs)+DMA_CSR) &amp; (DMA_HNDL_INTR|DMA_HNDL_ERROR))
multiline_comment|/* How we use the various Linux SCSI data structures for operation.&n; *&n; * struct scsi_cmnd:&n; *&n; *   We keep track of the synchronous capabilities of a target&n; *   in the device member, using sync_min_period and&n; *   sync_max_offset.  These are the values we directly write&n; *   into the ESP registers while running a command.  If offset&n; *   is zero the ESP will use asynchronous transfers.&n; *   If the borken flag is set we assume we shouldn&squot;t even bother&n; *   trying to negotiate for synchronous transfer as this target&n; *   is really stupid.  If we notice the target is dropping the&n; *   bus, and we have been allowing it to disconnect, we clear&n; *   the disconnect flag.&n; */
multiline_comment|/* Manipulation of the ESP command queues.  Thanks to the aha152x driver&n; * and its author, Juergen E. Fischer, for the methods used here.&n; * Note that these are per-ESP queues, not global queues like&n; * the aha152x driver uses.&n; */
DECL|function|append_SC
r_static
r_inline
r_void
id|append_SC
c_func
(paren
id|Scsi_Cmnd
op_star
op_star
id|SC
comma
id|Scsi_Cmnd
op_star
id|new_SC
)paren
(brace
id|Scsi_Cmnd
op_star
id|end
suffix:semicolon
id|new_SC-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|SC
)paren
op_star
id|SC
op_assign
id|new_SC
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|end
op_assign
op_star
id|SC
suffix:semicolon
id|end-&gt;host_scribble
suffix:semicolon
id|end
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|end-&gt;host_scribble
)paren
suffix:semicolon
id|end-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|new_SC
suffix:semicolon
)brace
)brace
DECL|function|prepend_SC
r_static
r_inline
r_void
id|prepend_SC
c_func
(paren
id|Scsi_Cmnd
op_star
op_star
id|SC
comma
id|Scsi_Cmnd
op_star
id|new_SC
)paren
(brace
id|new_SC-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
op_star
id|SC
suffix:semicolon
op_star
id|SC
op_assign
id|new_SC
suffix:semicolon
)brace
DECL|function|remove_first_SC
r_static
r_inline
id|Scsi_Cmnd
op_star
id|remove_first_SC
c_func
(paren
id|Scsi_Cmnd
op_star
op_star
id|SC
)paren
(brace
id|Scsi_Cmnd
op_star
id|ptr
suffix:semicolon
id|ptr
op_assign
op_star
id|SC
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
op_star
id|SC
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
(paren
op_star
id|SC
)paren
op_member_access_from_pointer
id|host_scribble
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
DECL|function|remove_SC
r_static
r_inline
id|Scsi_Cmnd
op_star
id|remove_SC
c_func
(paren
id|Scsi_Cmnd
op_star
op_star
id|SC
comma
r_int
id|target
comma
r_int
id|lun
)paren
(brace
id|Scsi_Cmnd
op_star
id|ptr
comma
op_star
id|prev
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
op_star
id|SC
comma
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|ptr
op_logical_and
(paren
(paren
id|ptr-&gt;target
op_ne
id|target
)paren
op_logical_or
(paren
id|ptr-&gt;lun
op_ne
id|lun
)paren
)paren
suffix:semicolon
id|prev
op_assign
id|ptr
comma
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;host_scribble
op_assign
id|ptr-&gt;host_scribble
suffix:semicolon
r_else
op_star
id|SC
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|ptr-&gt;host_scribble
suffix:semicolon
)brace
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/* Resetting various pieces of the ESP scsi driver chipset/buses. */
DECL|function|esp_reset_dma
r_static
r_void
id|esp_reset_dma
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|can_do_burst16
comma
id|can_do_burst32
comma
id|can_do_burst64
suffix:semicolon
r_int
id|can_do_sbus64
suffix:semicolon
id|u32
id|tmp
suffix:semicolon
id|can_do_burst16
op_assign
(paren
id|esp-&gt;bursts
op_amp
id|DMA_BURST16
)paren
op_ne
l_int|0
suffix:semicolon
id|can_do_burst32
op_assign
(paren
id|esp-&gt;bursts
op_amp
id|DMA_BURST32
)paren
op_ne
l_int|0
suffix:semicolon
id|can_do_burst64
op_assign
l_int|0
suffix:semicolon
id|can_do_sbus64
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sbus_can_dma_64bit
c_func
(paren
id|esp-&gt;sdev
)paren
)paren
id|can_do_sbus64
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sbus_can_burst64
c_func
(paren
id|esp-&gt;sdev
)paren
)paren
id|can_do_burst64
op_assign
(paren
id|esp-&gt;bursts
op_amp
id|DMA_BURST64
)paren
op_ne
l_int|0
suffix:semicolon
multiline_comment|/* Punt the DVMA into a known state. */
r_if
c_cond
(paren
id|esp-&gt;dma-&gt;revision
op_ne
id|dvmahme
)paren
(brace
id|tmp
op_assign
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|tmp
op_or
id|DMA_RST_SCSI
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|tmp
op_amp
op_complement
id|DMA_RST_SCSI
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|esp-&gt;dma-&gt;revision
)paren
(brace
r_case
id|dvmahme
suffix:colon
multiline_comment|/* This is the HME DVMA gate array. */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* I really hate this chip. */
id|sbus_writel
c_func
(paren
id|DMA_RESET_FAS366
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|DMA_RST_SCSI
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
id|esp-&gt;prev_hme_dmacsr
op_assign
(paren
id|DMA_PARITY_OFF
op_or
id|DMA_2CLKS
op_or
id|DMA_SCSI_DISAB
op_or
id|DMA_INT_ENAB
)paren
suffix:semicolon
id|esp-&gt;prev_hme_dmacsr
op_and_assign
op_complement
(paren
id|DMA_ENABLE
op_or
id|DMA_ST_WRITE
op_or
id|DMA_BRST_SZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|can_do_burst64
)paren
id|esp-&gt;prev_hme_dmacsr
op_or_assign
id|DMA_BRST64
suffix:semicolon
r_else
r_if
c_cond
(paren
id|can_do_burst32
)paren
id|esp-&gt;prev_hme_dmacsr
op_or_assign
id|DMA_BRST32
suffix:semicolon
r_if
c_cond
(paren
id|can_do_sbus64
)paren
(brace
id|esp-&gt;prev_hme_dmacsr
op_or_assign
id|DMA_SCSI_SBUS64
suffix:semicolon
id|sbus_set_sbus64
c_func
(paren
id|esp-&gt;sdev
comma
id|esp-&gt;bursts
)paren
suffix:semicolon
)brace
multiline_comment|/* This chip is horrible. */
r_while
c_loop
(paren
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
op_amp
id|DMA_PEND_READ
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
l_int|0
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|esp-&gt;prev_hme_dmacsr
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
multiline_comment|/* This is necessary to avoid having the SCSI channel&n;&t;&t; * engine lock up on us.&n;&t;&t; */
id|sbus_writel
c_func
(paren
l_int|0
comma
id|esp-&gt;dregs
op_plus
id|DMA_ADDR
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|dvmarev2
suffix:colon
multiline_comment|/* This is the gate array found in the sun4m&n;&t;&t; * NCR SBUS I/O subsystem.&n;&t;&t; */
r_if
c_cond
(paren
id|esp-&gt;erev
op_ne
id|esp100
)paren
(brace
id|tmp
op_assign
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|tmp
op_or
id|DMA_3CLKS
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|dvmarev3
suffix:colon
id|tmp
op_assign
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|DMA_3CLKS
suffix:semicolon
id|tmp
op_or_assign
id|DMA_2CLKS
suffix:semicolon
r_if
c_cond
(paren
id|can_do_burst32
)paren
(brace
id|tmp
op_and_assign
op_complement
id|DMA_BRST_SZ
suffix:semicolon
id|tmp
op_or_assign
id|DMA_BRST32
suffix:semicolon
)brace
id|sbus_writel
c_func
(paren
id|tmp
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|dvmaesc1
suffix:colon
multiline_comment|/* This is the DMA unit found on SCSI/Ether cards. */
id|tmp
op_assign
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
id|tmp
op_or_assign
id|DMA_ADD_ENABLE
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|DMA_BCNT_ENAB
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|can_do_burst32
op_logical_and
id|can_do_burst16
)paren
(brace
id|tmp
op_or_assign
id|DMA_ESC_BURST
suffix:semicolon
)brace
r_else
(brace
id|tmp
op_and_assign
op_complement
(paren
id|DMA_ESC_BURST
)paren
suffix:semicolon
)brace
id|sbus_writel
c_func
(paren
id|tmp
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|ESP_INTSON
c_func
(paren
id|esp-&gt;dregs
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset the ESP chip, _not_ the SCSI bus. */
DECL|function|esp_reset_esp
r_static
r_void
id|__init
id|esp_reset_esp
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|u8
id|family_code
comma
id|version
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Now reset the ESP chip */
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_RC
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_NULL
op_or
id|ESP_CMD_DMA
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_NULL
op_or
id|ESP_CMD_DMA
)paren
suffix:semicolon
multiline_comment|/* Reload the configuration registers */
id|sbus_writeb
c_func
(paren
id|esp-&gt;cfact
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFACT
)paren
suffix:semicolon
id|esp-&gt;prev_stp
op_assign
l_int|0
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_stp
comma
id|esp-&gt;eregs
op_plus
id|ESP_STP
)paren
suffix:semicolon
id|esp-&gt;prev_soff
op_assign
l_int|0
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_soff
comma
id|esp-&gt;eregs
op_plus
id|ESP_SOFF
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;neg_defp
comma
id|esp-&gt;eregs
op_plus
id|ESP_TIMEO
)paren
suffix:semicolon
multiline_comment|/* This is the only point at which it is reliable to read&n;&t; * the ID-code for a fast ESP chip variants.&n;&t; */
id|esp-&gt;max_period
op_assign
(paren
(paren
l_int|35
op_star
id|esp-&gt;ccycle
)paren
op_div
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fast
)paren
(brace
id|version
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_UID
)paren
suffix:semicolon
id|family_code
op_assign
(paren
id|version
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|family_code
op_eq
l_int|0x02
)paren
id|esp-&gt;erev
op_assign
id|fas236
suffix:semicolon
r_else
r_if
c_cond
(paren
id|family_code
op_eq
l_int|0x0a
)paren
id|esp-&gt;erev
op_assign
id|fashme
suffix:semicolon
multiline_comment|/* Version is usually &squot;5&squot;. */
r_else
id|esp-&gt;erev
op_assign
id|fas100a
suffix:semicolon
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;esp%d: FAST chip is %s (family=%d, version=%d)&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
(paren
id|esp-&gt;erev
op_eq
id|fas236
)paren
ques
c_cond
l_string|&quot;fas236&quot;
suffix:colon
(paren
(paren
id|esp-&gt;erev
op_eq
id|fas100a
)paren
ques
c_cond
l_string|&quot;fas100a&quot;
suffix:colon
l_string|&quot;fasHME&quot;
)paren
comma
id|family_code
comma
(paren
id|version
op_amp
l_int|7
)paren
)paren
)paren
suffix:semicolon
id|esp-&gt;min_period
op_assign
(paren
(paren
l_int|4
op_star
id|esp-&gt;ccycle
)paren
op_div
l_int|1000
)paren
suffix:semicolon
)brace
r_else
(brace
id|esp-&gt;min_period
op_assign
(paren
(paren
l_int|5
op_star
id|esp-&gt;ccycle
)paren
op_div
l_int|1000
)paren
suffix:semicolon
)brace
id|esp-&gt;max_period
op_assign
(paren
id|esp-&gt;max_period
op_plus
l_int|3
)paren
op_rshift
l_int|2
suffix:semicolon
id|esp-&gt;min_period
op_assign
(paren
id|esp-&gt;min_period
op_plus
l_int|3
)paren
op_rshift
l_int|2
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;config1
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|esp-&gt;erev
)paren
(brace
r_case
id|esp100
suffix:colon
multiline_comment|/* nothing to do */
r_break
suffix:semicolon
r_case
id|esp100a
suffix:colon
id|sbus_writeb
c_func
(paren
id|esp-&gt;config2
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|esp236
suffix:colon
multiline_comment|/* Slow 236 */
id|sbus_writeb
c_func
(paren
id|esp-&gt;config2
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG2
)paren
suffix:semicolon
id|esp-&gt;prev_cfg3
op_assign
id|esp-&gt;config3
(braket
l_int|0
)braket
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_cfg3
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG3
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fashme
suffix:colon
id|esp-&gt;config2
op_or_assign
(paren
id|ESP_CONFIG2_HME32
op_or
id|ESP_CONFIG2_HMEFENAB
)paren
suffix:semicolon
multiline_comment|/* fallthrough... */
r_case
id|fas236
suffix:colon
multiline_comment|/* Fast 236 or HME */
id|sbus_writeb
c_func
(paren
id|esp-&gt;config2
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
id|u8
id|cfg3
suffix:semicolon
id|cfg3
op_assign
id|ESP_CONFIG3_FCLOCK
op_or
id|ESP_CONFIG3_OBPUSH
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;scsi_id
op_ge
l_int|8
)paren
id|cfg3
op_or_assign
id|ESP_CONFIG3_IDBIT3
suffix:semicolon
id|esp-&gt;config3
(braket
id|i
)braket
op_or_assign
id|cfg3
suffix:semicolon
)brace
r_else
(brace
id|esp-&gt;config3
(braket
id|i
)braket
op_or_assign
id|ESP_CONFIG3_FCLK
suffix:semicolon
)brace
)brace
id|esp-&gt;prev_cfg3
op_assign
id|esp-&gt;config3
(braket
l_int|0
)braket
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_cfg3
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
id|esp-&gt;radelay
op_assign
l_int|80
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|esp-&gt;diff
)paren
id|esp-&gt;radelay
op_assign
l_int|0
suffix:semicolon
r_else
id|esp-&gt;radelay
op_assign
l_int|96
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|fas100a
suffix:colon
multiline_comment|/* Fast 100a */
id|sbus_writeb
c_func
(paren
id|esp-&gt;config2
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|esp-&gt;config3
(braket
id|i
)braket
op_or_assign
id|ESP_CONFIG3_FCLOCK
suffix:semicolon
id|esp-&gt;prev_cfg3
op_assign
id|esp-&gt;config3
(braket
l_int|0
)braket
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_cfg3
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG3
)paren
suffix:semicolon
id|esp-&gt;radelay
op_assign
l_int|32
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;esp: what could it be... I wonder...&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Eat any bitrot in the chip */
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_INTRPT
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
multiline_comment|/* This places the ESP into a known state at boot time. */
DECL|function|esp_bootup_reset
r_static
r_void
id|__init
id|esp_bootup_reset
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|u8
id|tmp
suffix:semicolon
multiline_comment|/* Reset the DMA */
id|esp_reset_dma
c_func
(paren
id|esp
)paren
suffix:semicolon
multiline_comment|/* Reset the ESP */
id|esp_reset_esp
c_func
(paren
id|esp
)paren
suffix:semicolon
multiline_comment|/* Reset the SCSI bus, but tell ESP not to generate an irq */
id|tmp
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_CFG1
)paren
suffix:semicolon
id|tmp
op_or_assign
id|ESP_CONFIG1_SRRDISAB
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|tmp
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG1
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_RS
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|400
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;config1
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG1
)paren
suffix:semicolon
multiline_comment|/* Eat any bitrot in the chip and we are done... */
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_INTRPT
)paren
suffix:semicolon
)brace
DECL|function|esp_chain_add
r_static
r_void
id|esp_chain_add
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|espchain_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|espchain
)paren
(brace
r_struct
id|esp
op_star
id|elink
op_assign
id|espchain
suffix:semicolon
r_while
c_loop
(paren
id|elink-&gt;next
)paren
id|elink
op_assign
id|elink-&gt;next
suffix:semicolon
id|elink-&gt;next
op_assign
id|esp
suffix:semicolon
)brace
r_else
(brace
id|espchain
op_assign
id|esp
suffix:semicolon
)brace
id|esp-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|espchain_lock
)paren
suffix:semicolon
)brace
DECL|function|esp_chain_del
r_static
r_void
id|esp_chain_del
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|espchain_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|espchain
op_eq
id|esp
)paren
(brace
id|espchain
op_assign
id|esp-&gt;next
suffix:semicolon
)brace
r_else
(brace
r_struct
id|esp
op_star
id|elink
op_assign
id|espchain
suffix:semicolon
r_while
c_loop
(paren
id|elink-&gt;next
op_ne
id|esp
)paren
id|elink
op_assign
id|elink-&gt;next
suffix:semicolon
id|elink-&gt;next
op_assign
id|esp-&gt;next
suffix:semicolon
)brace
id|esp-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|espchain_lock
)paren
suffix:semicolon
)brace
DECL|function|esp_find_dvma
r_static
r_int
id|__init
id|esp_find_dvma
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
r_struct
id|sbus_dev
op_star
id|dma_sdev
)paren
(brace
r_struct
id|sbus_dev
op_star
id|sdev
op_assign
id|esp-&gt;sdev
suffix:semicolon
r_struct
id|sbus_dma
op_star
id|dma
suffix:semicolon
r_if
c_cond
(paren
id|dma_sdev
op_ne
l_int|NULL
)paren
(brace
id|for_each_dvma
c_func
(paren
id|dma
)paren
(brace
r_if
c_cond
(paren
id|dma-&gt;sdev
op_eq
id|dma_sdev
)paren
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|for_each_dvma
c_func
(paren
id|dma
)paren
(brace
multiline_comment|/* If allocated already, can&squot;t use it. */
r_if
c_cond
(paren
id|dma-&gt;allocated
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dma-&gt;sdev
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
multiline_comment|/* If bus + slot are the same and it has the&n;&t;&t;&t; * correct OBP name, it&squot;s ours.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sdev-&gt;bus
op_eq
id|dma-&gt;sdev-&gt;bus
op_logical_and
id|sdev-&gt;slot
op_eq
id|dma-&gt;sdev-&gt;slot
op_logical_and
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|dma-&gt;sdev-&gt;prom_name
comma
l_string|&quot;dma&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|dma-&gt;sdev-&gt;prom_name
comma
l_string|&quot;espdma&quot;
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* If we don&squot;t know how to handle the dvma,&n;&t; * do not use this device.&n;&t; */
r_if
c_cond
(paren
id|dma
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cannot find dvma for ESP%d&squot;s SCSI&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dma-&gt;allocated
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;esp%d: can&squot;t use my espdma&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|dma-&gt;allocated
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;dma
op_assign
id|dma
suffix:semicolon
id|esp-&gt;dregs
op_assign
id|dma-&gt;regs
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|esp_map_regs
r_static
r_int
id|__init
id|esp_map_regs
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
r_int
id|hme
)paren
(brace
r_struct
id|sbus_dev
op_star
id|sdev
op_assign
id|esp-&gt;sdev
suffix:semicolon
r_struct
id|resource
op_star
id|res
suffix:semicolon
multiline_comment|/* On HME, two reg sets exist, first is DVMA,&n;&t; * second is ESP registers.&n;&t; */
r_if
c_cond
(paren
id|hme
)paren
id|res
op_assign
op_amp
id|sdev-&gt;resource
(braket
l_int|1
)braket
suffix:semicolon
r_else
id|res
op_assign
op_amp
id|sdev-&gt;resource
(braket
l_int|0
)braket
suffix:semicolon
id|esp-&gt;eregs
op_assign
id|sbus_ioremap
c_func
(paren
id|res
comma
l_int|0
comma
id|ESP_REG_SIZE
comma
l_string|&quot;ESP Registers&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;eregs
op_eq
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|esp_map_cmdarea
r_static
r_int
id|__init
id|esp_map_cmdarea
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
r_struct
id|sbus_dev
op_star
id|sdev
op_assign
id|esp-&gt;sdev
suffix:semicolon
id|esp-&gt;esp_command
op_assign
id|sbus_alloc_consistent
c_func
(paren
id|sdev
comma
l_int|16
comma
op_amp
id|esp-&gt;esp_command_dvma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;esp_command
op_eq
l_int|NULL
op_logical_or
id|esp-&gt;esp_command_dvma
op_eq
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|esp_register_irq
r_static
r_int
id|__init
id|esp_register_irq
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|esp-&gt;ehost-&gt;irq
op_assign
id|esp-&gt;irq
op_assign
id|esp-&gt;sdev-&gt;irqs
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* We used to try various overly-clever things to&n;&t; * reduce the interrupt processing overhead on&n;&t; * sun4c/sun4m when multiple ESP&squot;s shared the&n;&t; * same IRQ.  It was too complex and messy to&n;&t; * sanely maintain.&n;&t; */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|esp-&gt;ehost-&gt;irq
comma
id|esp_intr
comma
id|SA_SHIRQ
comma
l_string|&quot;ESP SCSI&quot;
comma
id|esp
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;esp%d: Cannot acquire irq line&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;esp%d: IRQ %s &quot;
comma
id|esp-&gt;esp_id
comma
id|__irq_itoa
c_func
(paren
id|esp-&gt;ehost-&gt;irq
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|esp_get_scsi_id
r_static
r_void
id|__init
id|esp_get_scsi_id
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
r_struct
id|sbus_dev
op_star
id|sdev
op_assign
id|esp-&gt;sdev
suffix:semicolon
id|esp-&gt;scsi_id
op_assign
id|prom_getintdefault
c_func
(paren
id|esp-&gt;prom_node
comma
l_string|&quot;initiator-id&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;scsi_id
op_eq
op_minus
l_int|1
)paren
id|esp-&gt;scsi_id
op_assign
id|prom_getintdefault
c_func
(paren
id|esp-&gt;prom_node
comma
l_string|&quot;scsi-initiator-id&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;scsi_id
op_eq
op_minus
l_int|1
)paren
id|esp-&gt;scsi_id
op_assign
(paren
id|sdev-&gt;bus
op_eq
l_int|NULL
)paren
ques
c_cond
l_int|7
suffix:colon
id|prom_getintdefault
c_func
(paren
id|sdev-&gt;bus-&gt;prom_node
comma
l_string|&quot;scsi-initiator-id&quot;
comma
l_int|7
)paren
suffix:semicolon
id|esp-&gt;ehost-&gt;this_id
op_assign
id|esp-&gt;scsi_id
suffix:semicolon
id|esp-&gt;scsi_id_mask
op_assign
(paren
l_int|1
op_lshift
id|esp-&gt;scsi_id
)paren
suffix:semicolon
)brace
DECL|function|esp_get_clock_params
r_static
r_void
id|__init
id|esp_get_clock_params
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
r_struct
id|sbus_dev
op_star
id|sdev
op_assign
id|esp-&gt;sdev
suffix:semicolon
r_int
id|prom_node
op_assign
id|esp-&gt;prom_node
suffix:semicolon
r_int
id|sbus_prom_node
suffix:semicolon
r_int
r_int
id|fmhz
suffix:semicolon
id|u8
id|ccf
suffix:semicolon
r_if
c_cond
(paren
id|sdev
op_ne
l_int|NULL
op_logical_and
id|sdev-&gt;bus
op_ne
l_int|NULL
)paren
id|sbus_prom_node
op_assign
id|sdev-&gt;bus-&gt;prom_node
suffix:semicolon
r_else
id|sbus_prom_node
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This is getting messy but it has to be done&n;&t; * correctly or else you get weird behavior all&n;&t; * over the place.  We are trying to basically&n;&t; * figure out three pieces of information.&n;&t; *&n;&t; * a) Clock Conversion Factor&n;&t; *&n;&t; *    This is a representation of the input&n;&t; *    crystal clock frequency going into the&n;&t; *    ESP on this machine.  Any operation whose&n;&t; *    timing is longer than 400ns depends on this&n;&t; *    value being correct.  For example, you&squot;ll&n;&t; *    get blips for arbitration/selection during&n;&t; *    high load or with multiple targets if this&n;&t; *    is not set correctly.&n;&t; *&n;&t; * b) Selection Time-Out&n;&t; *&n;&t; *    The ESP isn&squot;t very bright and will arbitrate&n;&t; *    for the bus and try to select a target&n;&t; *    forever if you let it.  This value tells&n;&t; *    the ESP when it has taken too long to&n;&t; *    negotiate and that it should interrupt&n;&t; *    the CPU so we can see what happened.&n;&t; *    The value is computed as follows (from&n;&t; *    NCR/Symbios chip docs).&n;&t; *&n;&t; *          (Time Out Period) *  (Input Clock)&n;&t; *    STO = ----------------------------------&n;&t; *          (8192) * (Clock Conversion Factor)&n;&t; *&n;&t; *    You usually want the time out period to be&n;&t; *    around 250ms, I think we&squot;ll set it a little&n;&t; *    bit higher to account for fully loaded SCSI&n;&t; *    bus&squot;s and slow devices that don&squot;t respond so&n;&t; *    quickly to selection attempts. (yeah, I know&n;&t; *    this is out of spec. but there is a lot of&n;&t; *    buggy pieces of firmware out there so bite me)&n;&t; *&n;&t; * c) Imperical constants for synchronous offset&n;&t; *    and transfer period register values&n;&t; *&n;&t; *    This entails the smallest and largest sync&n;&t; *    period we could ever handle on this ESP.&n;&t; */
id|fmhz
op_assign
id|prom_getintdefault
c_func
(paren
id|prom_node
comma
l_string|&quot;clock-frequency&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmhz
op_eq
op_minus
l_int|1
)paren
id|fmhz
op_assign
(paren
op_logical_neg
id|sbus_prom_node
)paren
ques
c_cond
l_int|0
suffix:colon
id|prom_getintdefault
c_func
(paren
id|sbus_prom_node
comma
l_string|&quot;clock-frequency&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmhz
op_le
(paren
l_int|5000000
)paren
)paren
id|ccf
op_assign
l_int|0
suffix:semicolon
r_else
id|ccf
op_assign
(paren
(paren
(paren
l_int|5000000
op_minus
l_int|1
)paren
op_plus
(paren
id|fmhz
)paren
)paren
op_div
(paren
l_int|5000000
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ccf
op_logical_or
id|ccf
OG
l_int|8
)paren
(brace
multiline_comment|/* If we can&squot;t find anything reasonable,&n;&t;&t; * just assume 20MHZ.  This is the clock&n;&t;&t; * frequency of the older sun4c&squot;s where I&squot;ve&n;&t;&t; * been unable to find the clock-frequency&n;&t;&t; * PROM property.  All other machines provide&n;&t;&t; * useful values it seems.&n;&t;&t; */
id|ccf
op_assign
id|ESP_CCF_F4
suffix:semicolon
id|fmhz
op_assign
(paren
l_int|20000000
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ccf
op_eq
(paren
id|ESP_CCF_F7
op_plus
l_int|1
)paren
)paren
id|esp-&gt;cfact
op_assign
id|ESP_CCF_F0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ccf
op_eq
id|ESP_CCF_NEVER
)paren
id|esp-&gt;cfact
op_assign
id|ESP_CCF_F2
suffix:semicolon
r_else
id|esp-&gt;cfact
op_assign
id|ccf
suffix:semicolon
id|esp-&gt;raw_cfact
op_assign
id|ccf
suffix:semicolon
id|esp-&gt;cfreq
op_assign
id|fmhz
suffix:semicolon
id|esp-&gt;ccycle
op_assign
id|ESP_MHZ_TO_CYCLE
c_func
(paren
id|fmhz
)paren
suffix:semicolon
id|esp-&gt;ctick
op_assign
id|ESP_TICK
c_func
(paren
id|ccf
comma
id|esp-&gt;ccycle
)paren
suffix:semicolon
id|esp-&gt;neg_defp
op_assign
id|ESP_NEG_DEFP
c_func
(paren
id|fmhz
comma
id|ccf
)paren
suffix:semicolon
id|esp-&gt;sync_defp
op_assign
id|SYNC_DEFP_SLOW
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SCSI ID %d Clk %dMHz CCYC=%d CCF=%d TOut %d &quot;
comma
id|esp-&gt;scsi_id
comma
(paren
id|fmhz
op_div
l_int|1000000
)paren
comma
(paren
r_int
)paren
id|esp-&gt;ccycle
comma
(paren
r_int
)paren
id|ccf
comma
(paren
r_int
)paren
id|esp-&gt;neg_defp
)paren
suffix:semicolon
)brace
DECL|function|esp_get_bursts
r_static
r_void
id|__init
id|esp_get_bursts
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
r_struct
id|sbus_dev
op_star
id|dma
)paren
(brace
r_struct
id|sbus_dev
op_star
id|sdev
op_assign
id|esp-&gt;sdev
suffix:semicolon
id|u8
id|bursts
suffix:semicolon
id|bursts
op_assign
id|prom_getintdefault
c_func
(paren
id|esp-&gt;prom_node
comma
l_string|&quot;burst-sizes&quot;
comma
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma
)paren
(brace
id|u8
id|tmp
op_assign
id|prom_getintdefault
c_func
(paren
id|dma-&gt;prom_node
comma
l_string|&quot;burst-sizes&quot;
comma
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ne
l_int|0xff
)paren
id|bursts
op_and_assign
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sdev-&gt;bus
)paren
(brace
id|u8
id|tmp
op_assign
id|prom_getintdefault
c_func
(paren
id|sdev-&gt;bus-&gt;prom_node
comma
l_string|&quot;burst-sizes&quot;
comma
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ne
l_int|0xff
)paren
id|bursts
op_and_assign
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bursts
op_eq
l_int|0xff
op_logical_or
(paren
id|bursts
op_amp
id|DMA_BURST16
)paren
op_eq
l_int|0
op_logical_or
(paren
id|bursts
op_amp
id|DMA_BURST32
)paren
op_eq
l_int|0
)paren
id|bursts
op_assign
(paren
id|DMA_BURST32
op_minus
l_int|1
)paren
suffix:semicolon
id|esp-&gt;bursts
op_assign
id|bursts
suffix:semicolon
)brace
DECL|function|esp_get_revision
r_static
r_void
id|__init
id|esp_get_revision
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|u8
id|tmp
suffix:semicolon
id|esp-&gt;config1
op_assign
(paren
id|ESP_CONFIG1_PENABLE
op_or
(paren
id|esp-&gt;scsi_id
op_amp
l_int|7
)paren
)paren
suffix:semicolon
id|esp-&gt;config2
op_assign
(paren
id|ESP_CONFIG2_SCSI2ENAB
op_or
id|ESP_CONFIG2_REGPARITY
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;config2
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG2
)paren
suffix:semicolon
id|tmp
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_CFG2
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|ESP_CONFIG2_MAGIC
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ne
(paren
id|ESP_CONFIG2_SCSI2ENAB
op_or
id|ESP_CONFIG2_REGPARITY
)paren
)paren
(brace
multiline_comment|/* If what we write to cfg2 does not come back, cfg2&n;&t;&t; * is not implemented, therefore this must be a plain&n;&t;&t; * esp100.&n;&t;&t; */
id|esp-&gt;erev
op_assign
id|esp100
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NCR53C90(esp100)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|esp-&gt;config2
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;prev_cfg3
op_assign
id|esp-&gt;config3
(braket
l_int|0
)braket
op_assign
l_int|5
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;config2
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG2
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
l_int|0
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG3
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_cfg3
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG3
)paren
suffix:semicolon
id|tmp
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_CFG3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ne
l_int|5
)paren
(brace
multiline_comment|/* The cfg2 register is implemented, however&n;&t;&t;&t; * cfg3 is not, must be esp100a.&n;&t;&t;&t; */
id|esp-&gt;erev
op_assign
id|esp100a
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NCR53C90A(esp100a)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|target
suffix:semicolon
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
OL
l_int|16
suffix:semicolon
id|target
op_increment
)paren
id|esp-&gt;config3
(braket
id|target
)braket
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;prev_cfg3
op_assign
l_int|0
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_cfg3
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG3
)paren
suffix:semicolon
multiline_comment|/* All of cfg{1,2,3} implemented, must be one of&n;&t;&t;&t; * the fas variants, figure out which one.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|esp-&gt;raw_cfact
OG
id|ESP_CCF_F5
)paren
(brace
id|esp-&gt;erev
op_assign
id|fast
suffix:semicolon
id|esp-&gt;sync_defp
op_assign
id|SYNC_DEFP_FAST
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NCR53C9XF(espfast)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|esp-&gt;erev
op_assign
id|esp236
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NCR53C9x(esp236)&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|esp-&gt;config2
op_assign
l_int|0
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;config2
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG2
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|esp_init_swstate
r_static
r_void
id|__init
id|esp_init_swstate
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Driver spinlock... */
id|spin_lock_init
c_func
(paren
op_amp
id|esp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Command queues... */
id|esp-&gt;current_SC
op_assign
l_int|NULL
suffix:semicolon
id|esp-&gt;disconnected_SC
op_assign
l_int|NULL
suffix:semicolon
id|esp-&gt;issue_SC
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Target and current command state... */
id|esp-&gt;targets_present
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;resetting_bus
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Debugging... */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|esp-&gt;espcmdlog
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|esp-&gt;espcmdent
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* MSG phase state... */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|esp-&gt;cur_msgout
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;cur_msgin
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|esp-&gt;prevmsgout
op_assign
id|esp-&gt;prevmsgin
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;msgout_len
op_assign
id|esp-&gt;msgin_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear the one behind caches to hold unmatchable values. */
id|esp-&gt;prev_soff
op_assign
id|esp-&gt;prev_stp
op_assign
id|esp-&gt;prev_cfg3
op_assign
l_int|0xff
suffix:semicolon
id|esp-&gt;prev_hme_dmacsr
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
DECL|function|detect_one_esp
r_static
r_int
id|__init
id|detect_one_esp
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_struct
id|sbus_dev
op_star
id|esp_dev
comma
r_struct
id|sbus_dev
op_star
id|espdma
comma
r_struct
id|sbus_bus
op_star
id|sbus
comma
r_int
id|id
comma
r_int
id|hme
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|esp_host
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
r_sizeof
(paren
r_struct
id|esp
)paren
)paren
suffix:semicolon
r_struct
id|esp
op_star
id|esp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|esp_host
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ESP: Cannot register SCSI host&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hme
)paren
id|esp_host-&gt;max_id
op_assign
l_int|16
suffix:semicolon
id|esp
op_assign
(paren
r_struct
id|esp
op_star
)paren
id|esp_host-&gt;hostdata
suffix:semicolon
id|esp-&gt;ehost
op_assign
id|esp_host
suffix:semicolon
id|esp-&gt;sdev
op_assign
id|esp_dev
suffix:semicolon
id|esp-&gt;esp_id
op_assign
id|id
suffix:semicolon
id|esp-&gt;prom_node
op_assign
id|esp_dev-&gt;prom_node
suffix:semicolon
id|prom_getstring
c_func
(paren
id|esp-&gt;prom_node
comma
l_string|&quot;name&quot;
comma
id|esp-&gt;prom_name
comma
r_sizeof
(paren
id|esp-&gt;prom_name
)paren
)paren
suffix:semicolon
id|esp_chain_add
c_func
(paren
id|esp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp_find_dvma
c_func
(paren
id|esp
comma
id|espdma
)paren
OL
l_int|0
)paren
r_goto
id|fail_unlink
suffix:semicolon
r_if
c_cond
(paren
id|esp_map_regs
c_func
(paren
id|esp
comma
id|hme
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ESP registers unmappable&quot;
)paren
suffix:semicolon
r_goto
id|fail_dvma_release
suffix:semicolon
)brace
r_if
c_cond
(paren
id|esp_map_cmdarea
c_func
(paren
id|esp
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ESP DVMA transport area unmappable&quot;
)paren
suffix:semicolon
r_goto
id|fail_unmap_regs
suffix:semicolon
)brace
r_if
c_cond
(paren
id|esp_register_irq
c_func
(paren
id|esp
)paren
OL
l_int|0
)paren
r_goto
id|fail_unmap_cmdarea
suffix:semicolon
id|esp_get_scsi_id
c_func
(paren
id|esp
)paren
suffix:semicolon
id|esp-&gt;diff
op_assign
id|prom_getbool
c_func
(paren
id|esp-&gt;prom_node
comma
l_string|&quot;differential&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;diff
)paren
id|printk
c_func
(paren
l_string|&quot;Differential &quot;
)paren
suffix:semicolon
id|esp_get_clock_params
c_func
(paren
id|esp
)paren
suffix:semicolon
id|esp_get_bursts
c_func
(paren
id|esp
comma
id|espdma
)paren
suffix:semicolon
id|esp_get_revision
c_func
(paren
id|esp
)paren
suffix:semicolon
id|esp_init_swstate
c_func
(paren
id|esp
)paren
suffix:semicolon
id|esp_bootup_reset
c_func
(paren
id|esp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail_unmap_cmdarea
suffix:colon
id|sbus_free_consistent
c_func
(paren
id|esp-&gt;sdev
comma
l_int|16
comma
(paren
r_void
op_star
)paren
id|esp-&gt;esp_command
comma
id|esp-&gt;esp_command_dvma
)paren
suffix:semicolon
id|fail_unmap_regs
suffix:colon
id|sbus_iounmap
c_func
(paren
id|esp-&gt;eregs
comma
id|ESP_REG_SIZE
)paren
suffix:semicolon
id|fail_dvma_release
suffix:colon
id|esp-&gt;dma-&gt;allocated
op_assign
l_int|0
suffix:semicolon
id|fail_unlink
suffix:colon
id|esp_chain_del
c_func
(paren
id|esp
)paren
suffix:semicolon
id|scsi_unregister
c_func
(paren
id|esp_host
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Detecting ESP chips on the machine.  This is the simple and easy&n; * version.&n; */
macro_line|#ifdef CONFIG_SUN4
macro_line|#include &lt;asm/sun4paddr.h&gt;
DECL|function|esp_detect
r_int
id|__init
id|esp_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_static
r_struct
id|sbus_dev
id|esp_dev
suffix:semicolon
r_int
id|esps_in_use
op_assign
l_int|0
suffix:semicolon
id|espchain
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sun4_esp_physaddr
)paren
(brace
id|memset
(paren
op_amp
id|esp_dev
comma
l_int|0
comma
r_sizeof
(paren
id|esp_dev
)paren
)paren
suffix:semicolon
id|esp_dev.reg_addrs
(braket
l_int|0
)braket
dot
id|phys_addr
op_assign
id|sun4_esp_physaddr
suffix:semicolon
id|esp_dev.irqs
(braket
l_int|0
)braket
op_assign
l_int|4
suffix:semicolon
id|esp_dev.resource
(braket
l_int|0
)braket
dot
id|start
op_assign
id|sun4_esp_physaddr
suffix:semicolon
id|esp_dev.resource
(braket
l_int|0
)braket
dot
id|end
op_assign
id|sun4_esp_physaddr
op_plus
id|ESP_REG_SIZE
op_minus
l_int|1
suffix:semicolon
id|esp_dev.resource
(braket
l_int|0
)braket
dot
id|flags
op_assign
id|IORESOURCE_IO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|detect_one_esp
c_func
(paren
id|tpnt
comma
op_amp
id|esp_dev
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
)paren
id|esps_in_use
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ESP: Total of 1 ESP hosts found, %d actually in use.&bslash;n&quot;
comma
id|esps_in_use
)paren
suffix:semicolon
id|esps_running
op_assign
id|esps_in_use
suffix:semicolon
)brace
r_return
id|esps_in_use
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_SUN4 */
DECL|function|esp_detect
r_int
id|__init
id|esp_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_struct
id|sbus_bus
op_star
id|sbus
suffix:semicolon
r_struct
id|sbus_dev
op_star
id|esp_dev
comma
op_star
id|sbdev_iter
suffix:semicolon
r_int
id|nesps
op_assign
l_int|0
comma
id|esps_in_use
op_assign
l_int|0
suffix:semicolon
id|espchain
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sbus_root
)paren
(brace
macro_line|#ifdef CONFIG_PCI
r_return
l_int|0
suffix:semicolon
macro_line|#else
id|panic
c_func
(paren
l_string|&quot;No SBUS in esp_detect()&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
id|for_each_sbus
c_func
(paren
id|sbus
)paren
(brace
id|for_each_sbusdev
c_func
(paren
id|sbdev_iter
comma
id|sbus
)paren
(brace
r_struct
id|sbus_dev
op_star
id|espdma
op_assign
l_int|NULL
suffix:semicolon
r_int
id|hme
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Is it an esp sbus device? */
id|esp_dev
op_assign
id|sbdev_iter
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|esp_dev-&gt;prom_name
comma
l_string|&quot;esp&quot;
)paren
op_logical_and
id|strcmp
c_func
(paren
id|esp_dev-&gt;prom_name
comma
l_string|&quot;SUNW,esp&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|esp_dev-&gt;prom_name
comma
l_string|&quot;SUNW,fas&quot;
)paren
)paren
(brace
id|hme
op_assign
l_int|1
suffix:semicolon
id|espdma
op_assign
id|esp_dev
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|esp_dev-&gt;child
op_logical_or
(paren
id|strcmp
c_func
(paren
id|esp_dev-&gt;prom_name
comma
l_string|&quot;espdma&quot;
)paren
op_logical_and
id|strcmp
c_func
(paren
id|esp_dev-&gt;prom_name
comma
l_string|&quot;dma&quot;
)paren
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* nope... */
id|espdma
op_assign
id|esp_dev
suffix:semicolon
id|esp_dev
op_assign
id|esp_dev-&gt;child
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|esp_dev-&gt;prom_name
comma
l_string|&quot;esp&quot;
)paren
op_logical_and
id|strcmp
c_func
(paren
id|esp_dev-&gt;prom_name
comma
l_string|&quot;SUNW,esp&quot;
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* how can this happen? */
)brace
)brace
r_if
c_cond
(paren
id|detect_one_esp
c_func
(paren
id|tpnt
comma
id|esp_dev
comma
id|espdma
comma
id|sbus
comma
id|nesps
op_increment
comma
id|hme
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
id|esps_in_use
op_increment
suffix:semicolon
)brace
multiline_comment|/* for each sbusdev */
)brace
multiline_comment|/* for each sbus */
id|printk
c_func
(paren
l_string|&quot;ESP: Total of %d ESP hosts found, %d actually in use.&bslash;n&quot;
comma
id|nesps
comma
id|esps_in_use
)paren
suffix:semicolon
id|esps_running
op_assign
id|esps_in_use
suffix:semicolon
r_return
id|esps_in_use
suffix:semicolon
)brace
macro_line|#endif /* !CONFIG_SUN4 */
multiline_comment|/* The info function will return whatever useful&n; * information the developer sees fit.  If not provided, then&n; * the name field will be used instead.&n; */
DECL|function|esp_info
r_const
r_char
op_star
id|esp_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_struct
id|esp
op_star
id|esp
suffix:semicolon
id|esp
op_assign
(paren
r_struct
id|esp
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_switch
c_cond
(paren
id|esp-&gt;erev
)paren
(brace
r_case
id|esp100
suffix:colon
r_return
l_string|&quot;Sparc ESP100 (NCR53C90)&quot;
suffix:semicolon
r_case
id|esp100a
suffix:colon
r_return
l_string|&quot;Sparc ESP100A (NCR53C90A)&quot;
suffix:semicolon
r_case
id|esp236
suffix:colon
r_return
l_string|&quot;Sparc ESP236&quot;
suffix:semicolon
r_case
id|fas236
suffix:colon
r_return
l_string|&quot;Sparc ESP236-FAST&quot;
suffix:semicolon
r_case
id|fashme
suffix:colon
r_return
l_string|&quot;Sparc ESP366-HME&quot;
suffix:semicolon
r_case
id|fas100a
suffix:colon
r_return
l_string|&quot;Sparc ESP100A-FAST&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;Bogon ESP revision&quot;
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/* From Wolfgang Stanglmeier&squot;s NCR scsi driver. */
DECL|struct|info_str
r_struct
id|info_str
(brace
DECL|member|buffer
r_char
op_star
id|buffer
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|pos
r_int
id|pos
suffix:semicolon
)brace
suffix:semicolon
DECL|function|copy_mem_info
r_static
r_void
id|copy_mem_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OG
id|info-&gt;length
)paren
id|len
op_assign
id|info-&gt;length
op_minus
id|info-&gt;pos
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OL
id|info-&gt;offset
)paren
(brace
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;pos
OL
id|info-&gt;offset
)paren
(brace
id|data
op_add_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|info-&gt;buffer
op_plus
id|info-&gt;pos
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
)brace
)brace
DECL|function|copy_info
r_static
r_int
id|copy_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
l_int|81
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|len
op_assign
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
id|copy_mem_info
c_func
(paren
id|info
comma
id|buf
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|esp_host_info
r_static
r_int
id|esp_host_info
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
r_char
op_star
id|ptr
comma
id|off_t
id|offset
comma
r_int
id|len
)paren
(brace
r_struct
id|info_str
id|info
suffix:semicolon
r_int
id|i
suffix:semicolon
id|info.buffer
op_assign
id|ptr
suffix:semicolon
id|info.length
op_assign
id|len
suffix:semicolon
id|info.offset
op_assign
id|offset
suffix:semicolon
id|info.pos
op_assign
l_int|0
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Sparc ESP Host Adapter:&bslash;n&quot;
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;&bslash;tPROM node&bslash;t&bslash;t%08x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|esp-&gt;prom_node
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;&bslash;tPROM name&bslash;t&bslash;t%s&bslash;n&quot;
comma
id|esp-&gt;prom_name
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;&bslash;tESP Model&bslash;t&bslash;t&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|esp-&gt;erev
)paren
(brace
r_case
id|esp100
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;ESP100&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|esp100a
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;ESP100A&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|esp236
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;ESP236&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fas236
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;FAS236&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fas100a
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;FAS100A&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fast
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;FAST&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fashme
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Happy Meal FAS&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|espunknown
suffix:colon
r_default
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Unknown!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;&bslash;tDMA Revision&bslash;t&bslash;t&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|esp-&gt;dma-&gt;revision
)paren
(brace
r_case
id|dvmarev0
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Rev 0&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|dvmaesc1
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;ESC Rev 1&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|dvmarev1
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Rev 1&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|dvmarev2
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Rev 2&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|dvmarev3
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Rev 3&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|dvmarevplus
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Rev 1+&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|dvmahme
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Rev HME/FAS&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Unknown!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;&bslash;tLive Targets&bslash;t&bslash;t[ &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;targets_present
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;%d &quot;
comma
id|i
)paren
suffix:semicolon
)brace
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;]&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Now describe the state of each existing target. */
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Target #&bslash;tconfig3&bslash;t&bslash;tSync Capabilities&bslash;tDisconnect&bslash;tWide&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;targets_present
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|Scsi_Device
op_star
id|SDptr
op_assign
id|esp-&gt;ehost-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
(paren
id|SDptr-&gt;host
op_ne
id|esp-&gt;ehost
)paren
op_logical_and
(paren
id|SDptr-&gt;id
op_ne
id|i
)paren
op_logical_and
(paren
id|SDptr-&gt;next
)paren
)paren
id|SDptr
op_assign
id|SDptr-&gt;next
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;%d&bslash;t&bslash;t&quot;
comma
id|i
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;%08lx&bslash;t&quot;
comma
id|esp-&gt;config3
(braket
id|i
)braket
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;[%02lx,%02lx]&bslash;t&bslash;t&bslash;t&quot;
comma
id|SDptr-&gt;sync_max_offset
comma
id|SDptr-&gt;sync_min_period
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;%s&bslash;t&bslash;t&quot;
comma
id|SDptr-&gt;disconnect
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;%s&bslash;n&quot;
comma
(paren
id|esp-&gt;config3
(braket
id|i
)braket
op_amp
id|ESP_CONFIG3_EWIDE
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
id|info.pos
OG
id|info.offset
ques
c_cond
id|info.pos
op_minus
id|info.offset
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ESP proc filesystem code. */
DECL|function|esp_proc_info
r_int
id|esp_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
r_struct
id|esp
op_star
id|esp
suffix:semicolon
r_if
c_cond
(paren
id|inout
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* not yet */
id|for_each_esp
c_func
(paren
id|esp
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;ehost-&gt;host_no
op_eq
id|hostno
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|esp
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|start
)paren
op_star
id|start
op_assign
id|buffer
suffix:semicolon
r_return
id|esp_host_info
c_func
(paren
id|esp
comma
id|buffer
comma
id|offset
comma
id|length
)paren
suffix:semicolon
)brace
DECL|function|esp_get_dmabufs
r_static
r_void
id|esp_get_dmabufs
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
r_if
c_cond
(paren
id|sp-&gt;use_sg
op_eq
l_int|0
)paren
(brace
id|sp-&gt;SCp.this_residual
op_assign
id|sp-&gt;request_bufflen
suffix:semicolon
id|sp-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|sp-&gt;request_buffer
suffix:semicolon
id|sp-&gt;SCp.buffers_residual
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;request_bufflen
)paren
(brace
id|sp-&gt;SCp.have_data_in
op_assign
id|sbus_map_single
c_func
(paren
id|esp-&gt;sdev
comma
id|sp-&gt;SCp.buffer
comma
id|sp-&gt;SCp.this_residual
comma
id|scsi_to_sbus_dma_dir
c_func
(paren
id|sp-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
id|sp-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|sp-&gt;SCp.have_data_in
)paren
suffix:semicolon
)brace
r_else
(brace
id|sp-&gt;SCp.ptr
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
id|sp-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|sp-&gt;buffer
suffix:semicolon
id|sp-&gt;SCp.buffers_residual
op_assign
id|sbus_map_sg
c_func
(paren
id|esp-&gt;sdev
comma
id|sp-&gt;SCp.buffer
comma
id|sp-&gt;use_sg
comma
id|scsi_to_sbus_dma_dir
c_func
(paren
id|sp-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
id|sp-&gt;SCp.this_residual
op_assign
id|sg_dma_len
c_func
(paren
id|sp-&gt;SCp.buffer
)paren
suffix:semicolon
id|sp-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|sg_dma_address
c_func
(paren
id|sp-&gt;SCp.buffer
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|esp_release_dmabufs
r_static
r_void
id|esp_release_dmabufs
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
r_if
c_cond
(paren
id|sp-&gt;use_sg
)paren
(brace
id|sbus_unmap_sg
c_func
(paren
id|esp-&gt;sdev
comma
id|sp-&gt;buffer
comma
id|sp-&gt;use_sg
comma
id|scsi_to_sbus_dma_dir
c_func
(paren
id|sp-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sp-&gt;request_bufflen
)paren
(brace
id|sbus_unmap_single
c_func
(paren
id|esp-&gt;sdev
comma
id|sp-&gt;SCp.have_data_in
comma
id|sp-&gt;request_bufflen
comma
id|scsi_to_sbus_dma_dir
c_func
(paren
id|sp-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|esp_restore_pointers
r_static
r_void
id|esp_restore_pointers
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
r_struct
id|esp_pointers
op_star
id|ep
op_assign
op_amp
id|esp-&gt;data_pointers
(braket
id|sp-&gt;target
)braket
suffix:semicolon
id|sp-&gt;SCp.ptr
op_assign
id|ep-&gt;saved_ptr
suffix:semicolon
id|sp-&gt;SCp.buffer
op_assign
id|ep-&gt;saved_buffer
suffix:semicolon
id|sp-&gt;SCp.this_residual
op_assign
id|ep-&gt;saved_this_residual
suffix:semicolon
id|sp-&gt;SCp.buffers_residual
op_assign
id|ep-&gt;saved_buffers_residual
suffix:semicolon
)brace
DECL|function|esp_save_pointers
r_static
r_void
id|esp_save_pointers
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
r_struct
id|esp_pointers
op_star
id|ep
op_assign
op_amp
id|esp-&gt;data_pointers
(braket
id|sp-&gt;target
)braket
suffix:semicolon
id|ep-&gt;saved_ptr
op_assign
id|sp-&gt;SCp.ptr
suffix:semicolon
id|ep-&gt;saved_buffer
op_assign
id|sp-&gt;SCp.buffer
suffix:semicolon
id|ep-&gt;saved_this_residual
op_assign
id|sp-&gt;SCp.this_residual
suffix:semicolon
id|ep-&gt;saved_buffers_residual
op_assign
id|sp-&gt;SCp.buffers_residual
suffix:semicolon
)brace
multiline_comment|/* Some rules:&n; *&n; *   1) Never ever panic while something is live on the bus.&n; *      If there is to be any chance of syncing the disks this&n; *      rule is to be obeyed.&n; *&n; *   2) Any target that causes a foul condition will no longer&n; *      have synchronous transfers done to it, no questions&n; *      asked.&n; *&n; *   3) Keep register accesses to a minimum.  Think about some&n; *      day when we have Xbus machines this is running on and&n; *      the ESP chip is on the other end of the machine on a&n; *      different board from the cpu where this is running.&n; */
multiline_comment|/* Fire off a command.  We assume the bus is free and that the only&n; * case where we could see an interrupt is where we have disconnected&n; * commands active and they are trying to reselect us.&n; */
DECL|function|esp_check_cmd
r_static
r_inline
r_void
id|esp_check_cmd
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
r_switch
c_cond
(paren
id|sp-&gt;cmd_len
)paren
(brace
r_case
l_int|6
suffix:colon
r_case
l_int|10
suffix:colon
r_case
l_int|12
suffix:colon
id|esp-&gt;esp_slowcmd
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|esp-&gt;esp_slowcmd
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;esp_scmdleft
op_assign
id|sp-&gt;cmd_len
suffix:semicolon
id|esp-&gt;esp_scmdp
op_assign
op_amp
id|sp-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
DECL|function|build_sync_nego_msg
r_static
r_inline
r_void
id|build_sync_nego_msg
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
r_int
id|period
comma
r_int
id|offset
)paren
(brace
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|1
)braket
op_assign
l_int|3
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|2
)braket
op_assign
id|EXTENDED_SDTR
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|3
)braket
op_assign
id|period
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|4
)braket
op_assign
id|offset
suffix:semicolon
id|esp-&gt;msgout_len
op_assign
l_int|5
suffix:semicolon
)brace
multiline_comment|/* SIZE is in bits, currently HME only supports 16 bit wide transfers. */
DECL|function|build_wide_nego_msg
r_static
r_inline
r_void
id|build_wide_nego_msg
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
r_int
id|size
)paren
(brace
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|2
)braket
op_assign
id|EXTENDED_WDTR
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|32
suffix:colon
id|esp-&gt;cur_msgout
(braket
l_int|3
)braket
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|16
suffix:colon
id|esp-&gt;cur_msgout
(braket
l_int|3
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
r_default
suffix:colon
id|esp-&gt;cur_msgout
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|esp-&gt;msgout_len
op_assign
l_int|4
suffix:semicolon
)brace
DECL|function|esp_exec_cmd
r_static
r_void
id|esp_exec_cmd
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
suffix:semicolon
id|Scsi_Device
op_star
id|SDptr
suffix:semicolon
r_volatile
id|u8
op_star
id|cmdp
op_assign
id|esp-&gt;esp_command
suffix:semicolon
id|u8
id|the_esp_command
suffix:semicolon
r_int
id|lun
comma
id|target
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Hold off if we have disconnected commands and&n;&t; * an IRQ is showing...&n;&t; */
r_if
c_cond
(paren
id|esp-&gt;disconnected_SC
op_logical_and
id|ESP_IRQ_P
c_func
(paren
id|esp-&gt;dregs
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Grab first member of the issue queue. */
id|SCptr
op_assign
id|esp-&gt;current_SC
op_assign
id|remove_first_SC
c_func
(paren
op_amp
id|esp-&gt;issue_SC
)paren
suffix:semicolon
multiline_comment|/* Safe to panic here because current_SC is null. */
r_if
c_cond
(paren
op_logical_neg
id|SCptr
)paren
id|panic
c_func
(paren
l_string|&quot;esp: esp_exec_cmd and issue queue is NULL&quot;
)paren
suffix:semicolon
id|SDptr
op_assign
id|SCptr-&gt;device
suffix:semicolon
id|lun
op_assign
id|SCptr-&gt;lun
suffix:semicolon
id|target
op_assign
id|SCptr-&gt;target
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Send it out whole, or piece by piece?   The ESP&n;&t; * only knows how to automatically send out 6, 10,&n;&t; * and 12 byte commands.  I used to think that the&n;&t; * Linux SCSI code would never throw anything other&n;&t; * than that to us, but then again there is the&n;&t; * SCSI generic driver which can send us anything.&n;&t; */
id|esp_check_cmd
c_func
(paren
id|esp
comma
id|SCptr
)paren
suffix:semicolon
multiline_comment|/* If arbitration/selection is successful, the ESP will leave&n;&t; * ATN asserted, causing the target to go into message out&n;&t; * phase.  The ESP will feed the target the identify and then&n;&t; * the target can only legally go to one of command,&n;&t; * datain/out, status, or message in phase, or stay in message&n;&t; * out phase (should we be trying to send a sync negotiation&n;&t; * message after the identify).  It is not allowed to drop&n;&t; * BSY, but some buggy targets do and we check for this&n;&t; * condition in the selection complete code.  Most of the time&n;&t; * we&squot;ll make the command bytes available to the ESP and it&n;&t; * will not interrupt us until it finishes command phase, we&n;&t; * cannot do this for command sizes the ESP does not&n;&t; * understand and in this case we&squot;ll get interrupted right&n;&t; * when the target goes into command phase.&n;&t; *&n;&t; * It is absolutely _illegal_ in the presence of SCSI-2 devices&n;&t; * to use the ESP select w/o ATN command.  When SCSI-2 devices are&n;&t; * present on the bus we _must_ always go straight to message out&n;&t; * phase with an identify message for the target.  Being that&n;&t; * selection attempts in SCSI-1 w/o ATN was an option, doing SCSI-2&n;&t; * selections should not confuse SCSI-1 we hope.&n;&t; */
r_if
c_cond
(paren
id|SDptr-&gt;sync
)paren
(brace
multiline_comment|/* this targets sync is known */
macro_line|#ifndef __sparc_v9__
id|do_sync_known
suffix:colon
macro_line|#endif
r_if
c_cond
(paren
id|SDptr-&gt;disconnect
)paren
op_star
id|cmdp
op_increment
op_assign
id|IDENTIFY
c_func
(paren
l_int|1
comma
id|lun
)paren
suffix:semicolon
r_else
op_star
id|cmdp
op_increment
op_assign
id|IDENTIFY
c_func
(paren
l_int|0
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;esp_slowcmd
)paren
(brace
id|the_esp_command
op_assign
(paren
id|ESP_CMD_SELAS
op_or
id|ESP_CMD_DMA
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_slct_stop
)paren
suffix:semicolon
)brace
r_else
(brace
id|the_esp_command
op_assign
(paren
id|ESP_CMD_SELA
op_or
id|ESP_CMD_DMA
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_slct_norm
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;targets_present
op_amp
(paren
l_int|1
op_lshift
id|target
)paren
)paren
op_logical_or
op_logical_neg
(paren
id|SDptr-&gt;disconnect
)paren
)paren
(brace
multiline_comment|/* After the bootup SCSI code sends both the&n;&t;&t; * TEST_UNIT_READY and INQUIRY commands we want&n;&t;&t; * to at least attempt allowing the device to&n;&t;&t; * disconnect.&n;&t;&t; */
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;esp: Selecting device for first time. target=%d &quot;
l_string|&quot;lun=%d&bslash;n&quot;
comma
id|target
comma
id|SCptr-&gt;lun
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SDptr-&gt;borken
op_logical_and
op_logical_neg
id|SDptr-&gt;disconnect
)paren
id|SDptr-&gt;disconnect
op_assign
l_int|1
suffix:semicolon
op_star
id|cmdp
op_increment
op_assign
id|IDENTIFY
c_func
(paren
l_int|0
comma
id|lun
)paren
suffix:semicolon
id|esp-&gt;prevmsgout
op_assign
id|NOP
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_slct_norm
)paren
suffix:semicolon
id|the_esp_command
op_assign
(paren
id|ESP_CMD_SELA
op_or
id|ESP_CMD_DMA
)paren
suffix:semicolon
multiline_comment|/* Take no chances... */
id|SDptr-&gt;sync_max_offset
op_assign
l_int|0
suffix:semicolon
id|SDptr-&gt;sync_min_period
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Sorry, I have had way too many problems with&n;&t;&t; * various CDROM devices on ESP. -DaveM&n;&t;&t; */
r_int
id|cdrom_hwbug_wkaround
op_assign
l_int|0
suffix:semicolon
macro_line|#ifndef __sparc_v9__
multiline_comment|/* Never allow disconnects or synchronous transfers on&n;&t;&t; * SparcStation1 and SparcStation1+.  Allowing those&n;&t;&t; * to be enabled seems to lockup the machine completely.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|idprom-&gt;id_machtype
op_eq
(paren
id|SM_SUN4C
op_or
id|SM_4C_SS1
)paren
)paren
op_logical_or
(paren
id|idprom-&gt;id_machtype
op_eq
(paren
id|SM_SUN4C
op_or
id|SM_4C_SS1PLUS
)paren
)paren
)paren
(brace
multiline_comment|/* But we are nice and allow tapes and removable&n;&t;&t;&t; * disks (but not CDROMs) to disconnect.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|SDptr-&gt;type
op_eq
id|TYPE_TAPE
op_logical_or
(paren
id|SDptr-&gt;type
op_ne
id|TYPE_ROM
op_logical_and
id|SDptr-&gt;removable
)paren
)paren
(brace
id|SDptr-&gt;disconnect
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|SDptr-&gt;disconnect
op_assign
l_int|0
suffix:semicolon
id|SDptr-&gt;sync_max_offset
op_assign
l_int|0
suffix:semicolon
id|SDptr-&gt;sync_min_period
op_assign
l_int|0
suffix:semicolon
id|SDptr-&gt;sync
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|0
suffix:semicolon
r_goto
id|do_sync_known
suffix:semicolon
)brace
macro_line|#endif /* !(__sparc_v9__) */
multiline_comment|/* We&squot;ve talked to this guy before,&n;&t;&t; * but never negotiated.  Let&squot;s try,&n;&t;&t; * need to attempt WIDE first, before&n;&t;&t; * sync nego, as per SCSI 2 standard.&n;&t;&t; */
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
op_logical_and
op_logical_neg
id|SDptr-&gt;wide
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|SDptr-&gt;borken
op_logical_and
id|SDptr-&gt;type
op_ne
id|TYPE_ROM
op_logical_and
id|SDptr-&gt;removable
op_eq
l_int|0
)paren
(brace
id|build_wide_nego_msg
c_func
(paren
id|esp
comma
l_int|16
)paren
suffix:semicolon
id|SDptr-&gt;wide
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;wnip
op_assign
l_int|1
suffix:semicolon
r_goto
id|after_nego_msg_built
suffix:semicolon
)brace
r_else
(brace
id|SDptr-&gt;wide
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Fall through and try sync. */
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|SDptr-&gt;borken
)paren
(brace
r_if
c_cond
(paren
(paren
id|SDptr-&gt;type
op_eq
id|TYPE_ROM
)paren
)paren
(brace
multiline_comment|/* Nice try sucker... */
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;esp%d: Disabling sync for buggy &quot;
l_string|&quot;CDROM.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|cdrom_hwbug_wkaround
op_assign
l_int|1
suffix:semicolon
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SDptr-&gt;removable
op_ne
l_int|0
)paren
(brace
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;esp%d: Not negotiating sync/wide but &quot;
l_string|&quot;allowing disconnect for removable media.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
id|esp-&gt;sync_defp
comma
l_int|15
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|SDptr-&gt;sync
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|1
suffix:semicolon
id|after_nego_msg_built
suffix:colon
multiline_comment|/* A fix for broken SCSI1 targets, when they disconnect&n;&t;&t; * they lock up the bus and confuse ESP.  So disallow&n;&t;&t; * disconnects for SCSI1 targets for now until we&n;&t;&t; * find a better fix.&n;&t;&t; *&n;&t;&t; * Addendum: This is funny, I figured out what was going&n;&t;&t; *           on.  The blotzed SCSI1 target would disconnect,&n;&t;&t; *           one of the other SCSI2 targets or both would be&n;&t;&t; *           disconnected as well.  The SCSI1 target would&n;&t;&t; *           stay disconnected long enough that we start&n;&t;&t; *           up a command on one of the SCSI2 targets.  As&n;&t;&t; *           the ESP is arbitrating for the bus the SCSI1&n;&t;&t; *           target begins to arbitrate as well to reselect&n;&t;&t; *           the ESP.  The SCSI1 target refuses to drop it&squot;s&n;&t;&t; *           ID bit on the data bus even though the ESP is&n;&t;&t; *           at ID 7 and is the obvious winner for any&n;&t;&t; *           arbitration.  The ESP is a poor sport and refuses&n;&t;&t; *           to lose arbitration, it will continue indefinately&n;&t;&t; *           trying to arbitrate for the bus and can only be&n;&t;&t; *           stopped via a chip reset or SCSI bus reset.&n;&t;&t; *           Therefore _no_ disconnects for SCSI1 targets&n;&t;&t; *           thank you very much. ;-)&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|SDptr-&gt;scsi_level
OL
l_int|3
)paren
op_logical_and
(paren
id|SDptr-&gt;type
op_ne
id|TYPE_TAPE
)paren
op_logical_and
id|SDptr-&gt;removable
op_eq
l_int|0
)paren
op_logical_or
id|cdrom_hwbug_wkaround
op_logical_or
id|SDptr-&gt;borken
)paren
(brace
id|ESPMISC
c_func
(paren
(paren
id|KERN_INFO
l_string|&quot;esp%d: Disabling DISCONNECT for target %d &quot;
l_string|&quot;lun %d&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|SCptr-&gt;target
comma
id|SCptr-&gt;lun
)paren
)paren
suffix:semicolon
id|SDptr-&gt;disconnect
op_assign
l_int|0
suffix:semicolon
op_star
id|cmdp
op_increment
op_assign
id|IDENTIFY
c_func
(paren
l_int|0
comma
id|lun
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|cmdp
op_increment
op_assign
id|IDENTIFY
c_func
(paren
l_int|1
comma
id|lun
)paren
suffix:semicolon
)brace
multiline_comment|/* ESP fifo is only so big...&n;&t;&t; * Make this look like a slow command.&n;&t;&t; */
id|esp-&gt;esp_slowcmd
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;esp_scmdleft
op_assign
id|SCptr-&gt;cmd_len
suffix:semicolon
id|esp-&gt;esp_scmdp
op_assign
op_amp
id|SCptr-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
id|the_esp_command
op_assign
(paren
id|ESP_CMD_SELAS
op_or
id|ESP_CMD_DMA
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_slct_msg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|esp-&gt;esp_slowcmd
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCptr-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
op_star
id|cmdp
op_increment
op_assign
id|SCptr-&gt;cmnd
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* HME sucks... */
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
id|sbus_writeb
c_func
(paren
(paren
id|target
op_amp
l_int|0xf
)paren
op_or
(paren
id|ESP_BUSID_RESELID
op_or
id|ESP_BUSID_CTR32BIT
)paren
comma
id|esp-&gt;eregs
op_plus
id|ESP_BUSID
)paren
suffix:semicolon
r_else
id|sbus_writeb
c_func
(paren
id|target
op_amp
l_int|7
comma
id|esp-&gt;eregs
op_plus
id|ESP_BUSID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;prev_soff
op_ne
id|SDptr-&gt;sync_max_offset
op_logical_or
id|esp-&gt;prev_stp
op_ne
id|SDptr-&gt;sync_min_period
op_logical_or
(paren
id|esp-&gt;erev
OG
id|esp100a
op_logical_and
id|esp-&gt;prev_cfg3
op_ne
id|esp-&gt;config3
(braket
id|target
)braket
)paren
)paren
(brace
id|esp-&gt;prev_soff
op_assign
id|SDptr-&gt;sync_max_offset
suffix:semicolon
id|esp-&gt;prev_stp
op_assign
id|SDptr-&gt;sync_min_period
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_soff
comma
id|esp-&gt;eregs
op_plus
id|ESP_SOFF
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_stp
comma
id|esp-&gt;eregs
op_plus
id|ESP_STP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
OG
id|esp100a
)paren
(brace
id|esp-&gt;prev_cfg3
op_assign
id|esp-&gt;config3
(braket
id|target
)braket
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_cfg3
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG3
)paren
suffix:semicolon
)brace
)brace
id|i
op_assign
(paren
id|cmdp
op_minus
id|esp-&gt;esp_command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
multiline_comment|/* Grrr! */
multiline_comment|/* Set up the DMA and HME counters */
id|sbus_writeb
c_func
(paren
id|i
comma
id|esp-&gt;eregs
op_plus
id|ESP_TCLOW
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
l_int|0
comma
id|esp-&gt;eregs
op_plus
id|ESP_TCMED
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
l_int|0
comma
id|esp-&gt;eregs
op_plus
id|FAS_RLO
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
l_int|0
comma
id|esp-&gt;eregs
op_plus
id|FAS_RHI
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|the_esp_command
)paren
suffix:semicolon
multiline_comment|/* Talk about touchy hardware... */
id|esp-&gt;prev_hme_dmacsr
op_assign
(paren
(paren
id|esp-&gt;prev_hme_dmacsr
op_or
(paren
id|DMA_SCSI_DISAB
op_or
id|DMA_ENABLE
)paren
)paren
op_amp
op_complement
(paren
id|DMA_ST_WRITE
)paren
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
l_int|16
comma
id|esp-&gt;dregs
op_plus
id|DMA_COUNT
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|esp-&gt;esp_command_dvma
comma
id|esp-&gt;dregs
op_plus
id|DMA_ADDR
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|esp-&gt;prev_hme_dmacsr
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
)brace
r_else
(brace
id|u32
id|tmp
suffix:semicolon
multiline_comment|/* Set up the DMA and ESP counters */
id|sbus_writeb
c_func
(paren
id|i
comma
id|esp-&gt;eregs
op_plus
id|ESP_TCLOW
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
l_int|0
comma
id|esp-&gt;eregs
op_plus
id|ESP_TCMED
)paren
suffix:semicolon
id|tmp
op_assign
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|DMA_ST_WRITE
suffix:semicolon
id|tmp
op_or_assign
id|DMA_ENABLE
suffix:semicolon
id|sbus_writel
c_func
(paren
id|tmp
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;dma-&gt;revision
op_eq
id|dvmaesc1
)paren
(brace
r_if
c_cond
(paren
id|i
)paren
multiline_comment|/* Workaround ESC gate array SBUS rerun bug. */
id|sbus_writel
c_func
(paren
id|PAGE_SIZE
comma
id|esp-&gt;dregs
op_plus
id|DMA_COUNT
)paren
suffix:semicolon
)brace
id|sbus_writel
c_func
(paren
id|esp-&gt;esp_command_dvma
comma
id|esp-&gt;dregs
op_plus
id|DMA_ADDR
)paren
suffix:semicolon
multiline_comment|/* Tell ESP to &quot;go&quot;. */
id|esp_cmd
c_func
(paren
id|esp
comma
id|the_esp_command
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Queue a SCSI command delivered from the mid-level Linux SCSI code. */
DECL|function|esp_queue
r_int
id|esp_queue
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|esp
op_star
id|esp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Set up func ptr and initial driver cmd-phase. */
id|SCpnt-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|SCpnt-&gt;SCp.phase
op_assign
id|not_issued
suffix:semicolon
multiline_comment|/* We use the scratch area. */
id|ESPQUEUE
c_func
(paren
(paren
l_string|&quot;esp_queue: target=%d lun=%d &quot;
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
)paren
)paren
suffix:semicolon
id|ESPDISC
c_func
(paren
(paren
l_string|&quot;N&lt;%02x,%02x&gt;&quot;
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
)paren
)paren
suffix:semicolon
id|esp
op_assign
(paren
r_struct
id|esp
op_star
)paren
id|SCpnt-&gt;host-&gt;hostdata
suffix:semicolon
id|esp_get_dmabufs
c_func
(paren
id|esp
comma
id|SCpnt
)paren
suffix:semicolon
id|esp_save_pointers
c_func
(paren
id|esp
comma
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/* FIXME for tag queueing */
id|SCpnt-&gt;SCp.Status
op_assign
id|CHECK_CONDITION
suffix:semicolon
id|SCpnt-&gt;SCp.Message
op_assign
l_int|0xff
suffix:semicolon
id|SCpnt-&gt;SCp.sent_command
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|esp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Place into our queue. */
r_if
c_cond
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
(brace
id|ESPQUEUE
c_func
(paren
(paren
l_string|&quot;RQSENSE&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|prepend_SC
c_func
(paren
op_amp
id|esp-&gt;issue_SC
comma
id|SCpnt
)paren
suffix:semicolon
)brace
r_else
(brace
id|ESPQUEUE
c_func
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|append_SC
c_func
(paren
op_amp
id|esp-&gt;issue_SC
comma
id|SCpnt
)paren
suffix:semicolon
)brace
multiline_comment|/* Run it now if we can. */
r_if
c_cond
(paren
op_logical_neg
id|esp-&gt;current_SC
op_logical_and
op_logical_neg
id|esp-&gt;resetting_bus
)paren
id|esp_exec_cmd
c_func
(paren
id|esp
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|esp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Only queuing supported in this ESP driver. */
DECL|function|esp_command
r_int
id|esp_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|esp
op_star
id|esp
op_assign
(paren
r_struct
id|esp
op_star
)paren
id|SCpnt-&gt;host-&gt;hostdata
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: esp_command() called...&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Dump driver state. */
DECL|function|esp_dump_cmd
r_static
r_void
id|esp_dump_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCptr
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;[tgt&lt;%02x&gt; lun&lt;%02x&gt; &quot;
l_string|&quot;pphase&lt;%s&gt; cphase&lt;%s&gt;]&quot;
comma
id|SCptr-&gt;target
comma
id|SCptr-&gt;lun
comma
id|phase_string
c_func
(paren
id|SCptr-&gt;SCp.sent_command
)paren
comma
id|phase_string
c_func
(paren
id|SCptr-&gt;SCp.phase
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|esp_dump_state
r_static
r_void
id|esp_dump_state
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
macro_line|#ifdef DEBUG_ESP_CMDS
r_int
id|i
suffix:semicolon
macro_line|#endif
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: dumping state&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: dma -- cond_reg&lt;%08x&gt; addr&lt;%08x&gt;&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
comma
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_ADDR
)paren
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: SW [sreg&lt;%02x&gt; sstep&lt;%02x&gt; ireg&lt;%02x&gt;]&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;sreg
comma
id|esp-&gt;seqreg
comma
id|esp-&gt;ireg
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: HW reread [sreg&lt;%02x&gt; sstep&lt;%02x&gt; ireg&lt;%02x&gt;]&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_STATUS
)paren
comma
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_SSTEP
)paren
comma
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_INTRPT
)paren
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_ESP_CMDS
id|printk
c_func
(paren
l_string|&quot;esp%d: last ESP cmds [&quot;
comma
id|esp-&gt;esp_id
)paren
suffix:semicolon
id|i
op_assign
(paren
id|esp-&gt;espcmdent
op_minus
l_int|1
)paren
op_amp
l_int|31
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&lt;&quot;
)paren
suffix:semicolon
id|esp_print_cmd
c_func
(paren
id|esp-&gt;espcmdlog
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
id|i
op_assign
(paren
id|i
op_minus
l_int|1
)paren
op_amp
l_int|31
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&lt;&quot;
)paren
suffix:semicolon
id|esp_print_cmd
c_func
(paren
id|esp-&gt;espcmdlog
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
id|i
op_assign
(paren
id|i
op_minus
l_int|1
)paren
op_amp
l_int|31
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&lt;&quot;
)paren
suffix:semicolon
id|esp_print_cmd
c_func
(paren
id|esp-&gt;espcmdlog
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
id|i
op_assign
(paren
id|i
op_minus
l_int|1
)paren
op_amp
l_int|31
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&lt;&quot;
)paren
suffix:semicolon
id|esp_print_cmd
c_func
(paren
id|esp-&gt;espcmdlog
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* (DEBUG_ESP_CMDS) */
r_if
c_cond
(paren
id|SCptr
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: current command &quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp_dump_cmd
c_func
(paren
id|SCptr
)paren
suffix:semicolon
)brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|SCptr
op_assign
id|esp-&gt;disconnected_SC
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: disconnected &quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|SCptr
)paren
(brace
id|esp_dump_cmd
c_func
(paren
id|SCptr
)paren
suffix:semicolon
id|SCptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|SCptr-&gt;host_scribble
suffix:semicolon
)brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Abort a command. */
DECL|function|esp_abort
r_int
id|esp_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCptr
)paren
(brace
r_struct
id|esp
op_star
id|esp
op_assign
(paren
r_struct
id|esp
op_star
)paren
id|SCptr-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|don
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|esp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Aborting command&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp_dump_state
c_func
(paren
id|esp
)paren
suffix:semicolon
multiline_comment|/* Wheee, if this is the current command on the bus, the&n;&t; * best we can do is assert ATN and wait for msgout phase.&n;&t; * This should even fix a hung SCSI bus when we lose state&n;&t; * in the driver and timeout because the eventual phase change&n;&t; * will cause the ESP to (eventually) give an interrupt.&n;&t; */
r_if
c_cond
(paren
id|esp-&gt;current_SC
op_eq
id|SCptr
)paren
(brace
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
op_assign
id|ABORT
suffix:semicolon
id|esp-&gt;msgout_len
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;msgout_ctr
op_assign
l_int|0
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_SATN
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|esp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_PENDING
suffix:semicolon
)brace
multiline_comment|/* If it is still in the issue queue then we can safely&n;&t; * call the completion routine and report abort success.&n;&t; */
id|don
op_assign
(paren
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
op_amp
id|DMA_INT_ENAB
)paren
suffix:semicolon
r_if
c_cond
(paren
id|don
)paren
(brace
id|ESP_INTSOFF
c_func
(paren
id|esp-&gt;dregs
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|esp-&gt;issue_SC
)paren
(brace
id|Scsi_Cmnd
op_star
op_star
id|prev
comma
op_star
id|this
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
(paren
op_amp
id|esp-&gt;issue_SC
)paren
comma
id|this
op_assign
id|esp-&gt;issue_SC
suffix:semicolon
id|this
op_ne
l_int|NULL
suffix:semicolon
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
id|this-&gt;host_scribble
)paren
comma
id|this
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|this-&gt;host_scribble
)paren
(brace
r_if
c_cond
(paren
id|this
op_eq
id|SCptr
)paren
(brace
op_star
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|this-&gt;host_scribble
suffix:semicolon
id|this-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|esp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|esp_release_dmabufs
c_func
(paren
id|esp
comma
id|this
)paren
suffix:semicolon
id|this-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|this
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
id|don
)paren
id|ESP_INTSON
c_func
(paren
id|esp-&gt;dregs
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Yuck, the command to abort is disconnected, it is not&n;&t; * worth trying to abort it now if something else is live&n;&t; * on the bus at this time.  So, we let the SCSI code wait&n;&t; * a little bit and try again later.&n;&t; */
r_if
c_cond
(paren
id|esp-&gt;current_SC
)paren
(brace
r_if
c_cond
(paren
id|don
)paren
id|ESP_INTSON
c_func
(paren
id|esp-&gt;dregs
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|esp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_BUSY
suffix:semicolon
)brace
multiline_comment|/* It&squot;s disconnected, we have to reconnect to re-establish&n;&t; * the nexus and tell the device to abort.  However, we really&n;&t; * cannot &squot;reconnect&squot; per se, therefore we tell the upper layer&n;&t; * the safest thing we can.  This is, wait a bit, if nothing&n;&t; * happens, we are really hung so reset the bus.&n;&t; */
r_if
c_cond
(paren
id|don
)paren
id|ESP_INTSON
c_func
(paren
id|esp-&gt;dregs
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|esp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
multiline_comment|/* We&squot;ve sent ESP_CMD_RS to the ESP, the interrupt had just&n; * arrived indicating the end of the SCSI bus reset.  Our job&n; * is to clean out the command queues and begin re-execution&n; * of SCSI commands once more.&n; */
DECL|function|esp_finish_reset
r_static
r_int
id|esp_finish_reset
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|Scsi_Cmnd
op_star
id|sp
op_assign
id|esp-&gt;current_SC
suffix:semicolon
multiline_comment|/* Clean up currently executing command, if any. */
r_if
c_cond
(paren
id|sp
op_ne
l_int|NULL
)paren
(brace
id|esp-&gt;current_SC
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|esp-&gt;lock
)paren
suffix:semicolon
id|esp_release_dmabufs
c_func
(paren
id|esp
comma
id|sp
)paren
suffix:semicolon
id|sp-&gt;result
op_assign
(paren
id|DID_RESET
op_lshift
l_int|16
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|sp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|sp
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|esp-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Clean up disconnected queue, they have been invalidated&n;&t; * by the bus reset.&n;&t; */
r_if
c_cond
(paren
id|esp-&gt;disconnected_SC
)paren
(brace
r_while
c_loop
(paren
(paren
id|sp
op_assign
id|remove_first_SC
c_func
(paren
op_amp
id|esp-&gt;disconnected_SC
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|esp-&gt;lock
)paren
suffix:semicolon
id|esp_release_dmabufs
c_func
(paren
id|esp
comma
id|sp
)paren
suffix:semicolon
id|sp-&gt;result
op_assign
(paren
id|DID_RESET
op_lshift
l_int|16
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|sp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|sp
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|esp-&gt;lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* SCSI bus reset is complete. */
id|esp-&gt;resetting_bus
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Ok, now it is safe to get commands going once more. */
r_if
c_cond
(paren
id|esp-&gt;issue_SC
)paren
id|esp_exec_cmd
c_func
(paren
id|esp
)paren
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
DECL|function|esp_do_resetbus
r_static
r_int
id|esp_do_resetbus
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Resetting scsi bus&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp-&gt;resetting_bus
op_assign
l_int|1
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_RS
)paren
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
multiline_comment|/* Reset ESP chip, reset hanging bus, then kill active and&n; * disconnected commands for targets without soft reset.&n; */
DECL|function|esp_reset
r_int
id|esp_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCptr
comma
r_int
r_int
id|how
)paren
(brace
r_struct
id|esp
op_star
id|esp
op_assign
(paren
r_struct
id|esp
op_star
)paren
id|SCptr-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|esp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
(paren
r_void
)paren
id|esp_do_resetbus
c_func
(paren
id|esp
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|esp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_RESET_PENDING
suffix:semicolon
)brace
multiline_comment|/* Internal ESP done function. */
DECL|function|esp_done
r_static
r_void
id|esp_done
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
r_int
id|error
)paren
(brace
id|Scsi_Cmnd
op_star
id|done_SC
op_assign
id|esp-&gt;current_SC
suffix:semicolon
id|esp-&gt;current_SC
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|esp-&gt;lock
)paren
suffix:semicolon
id|esp_release_dmabufs
c_func
(paren
id|esp
comma
id|done_SC
)paren
suffix:semicolon
id|done_SC-&gt;result
op_assign
id|error
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|done_SC
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|done_SC
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
multiline_comment|/* Bus is free, issue any commands in the queue. */
id|spin_lock
c_func
(paren
op_amp
id|esp-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;issue_SC
op_logical_and
op_logical_neg
id|esp-&gt;current_SC
)paren
id|esp_exec_cmd
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
multiline_comment|/* Wheee, ESP interrupt engine. */
multiline_comment|/* Forward declarations. */
r_static
r_int
id|esp_do_phase_determine
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
suffix:semicolon
r_static
r_int
id|esp_do_data_finale
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
suffix:semicolon
r_static
r_int
id|esp_select_complete
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
suffix:semicolon
r_static
r_int
id|esp_do_status
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
suffix:semicolon
r_static
r_int
id|esp_do_msgin
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
suffix:semicolon
r_static
r_int
id|esp_do_msgindone
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
suffix:semicolon
r_static
r_int
id|esp_do_msgout
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
suffix:semicolon
r_static
r_int
id|esp_do_cmdbegin
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
suffix:semicolon
DECL|macro|sreg_datainp
mdefine_line|#define sreg_datainp(__sreg)  (((__sreg) &amp; ESP_STAT_PMASK) == ESP_DIP)
DECL|macro|sreg_dataoutp
mdefine_line|#define sreg_dataoutp(__sreg) (((__sreg) &amp; ESP_STAT_PMASK) == ESP_DOP)
multiline_comment|/* Read any bytes found in the FAS366 fifo, storing them into&n; * the ESP driver software state structure.&n; */
DECL|function|hme_fifo_read
r_static
r_void
id|hme_fifo_read
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|u8
id|count
op_assign
l_int|0
suffix:semicolon
id|u8
id|status
op_assign
id|esp-&gt;sreg
suffix:semicolon
multiline_comment|/* Cannot safely frob the fifo for these following cases, but&n;&t; * we must always read the fifo when the reselect interrupt&n;&t; * is pending.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_RSEL
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|sreg_datainp
c_func
(paren
id|status
)paren
op_logical_or
id|sreg_dataoutp
c_func
(paren
id|status
)paren
op_logical_or
(paren
id|esp-&gt;current_SC
op_logical_and
id|esp-&gt;current_SC-&gt;SCp.phase
op_eq
id|in_data_done
)paren
)paren
)paren
(brace
id|ESPHME
c_func
(paren
(paren
l_string|&quot;&lt;wkaround_skipped&gt;&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|fcnt
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_FFLAGS
)paren
op_amp
id|ESP_FF_FBYTES
suffix:semicolon
multiline_comment|/* The HME stores bytes in multiples of 2 in the fifo. */
id|ESPHME
c_func
(paren
(paren
l_string|&quot;hme_fifo[fcnt=%d&quot;
comma
(paren
r_int
)paren
id|fcnt
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fcnt
)paren
(brace
id|esp-&gt;hme_fifo_workaround_buffer
(braket
id|count
op_increment
)braket
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_FDATA
)paren
suffix:semicolon
id|esp-&gt;hme_fifo_workaround_buffer
(braket
id|count
op_increment
)braket
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_FDATA
)paren
suffix:semicolon
id|ESPHME
c_func
(paren
(paren
l_string|&quot;&lt;%02x,%02x&gt;&quot;
comma
id|esp-&gt;hme_fifo_workaround_buffer
(braket
id|count
op_minus
l_int|2
)braket
comma
id|esp-&gt;hme_fifo_workaround_buffer
(braket
id|count
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|fcnt
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_STATUS2
)paren
op_amp
id|ESP_STAT2_F1BYTE
)paren
(brace
id|ESPHME
c_func
(paren
(paren
l_string|&quot;&lt;poke_byte&gt;&quot;
)paren
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
l_int|0
comma
id|esp-&gt;eregs
op_plus
id|ESP_FDATA
)paren
suffix:semicolon
id|esp-&gt;hme_fifo_workaround_buffer
(braket
id|count
op_increment
)braket
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_FDATA
)paren
suffix:semicolon
id|ESPHME
c_func
(paren
(paren
l_string|&quot;&lt;%02x,0x00&gt;&quot;
comma
id|esp-&gt;hme_fifo_workaround_buffer
(braket
id|count
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|ESPHME
c_func
(paren
(paren
l_string|&quot;CMD_FLUSH&quot;
)paren
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
)brace
r_else
(brace
id|ESPHME
c_func
(paren
(paren
l_string|&quot;no_xtra_byte&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
id|ESPHME
c_func
(paren
(paren
l_string|&quot;wkarnd_cnt=%d]&quot;
comma
(paren
r_int
)paren
id|count
)paren
)paren
suffix:semicolon
id|esp-&gt;hme_fifo_workaround_count
op_assign
id|count
suffix:semicolon
)brace
DECL|function|hme_fifo_push
r_static
r_inline
r_void
id|hme_fifo_push
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
id|u8
op_star
id|bytes
comma
id|u8
id|count
)paren
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|u8
id|tmp
op_assign
op_star
id|bytes
op_increment
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|tmp
comma
id|esp-&gt;eregs
op_plus
id|ESP_FDATA
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
l_int|0
comma
id|esp-&gt;eregs
op_plus
id|ESP_FDATA
)paren
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/* We try to avoid some interrupts by jumping ahead and see if the ESP&n; * has gotten far enough yet.  Hence the following.&n; */
DECL|function|skipahead1
r_static
r_inline
r_int
id|skipahead1
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|scp
comma
r_int
id|prev_phase
comma
r_int
id|new_phase
)paren
(brace
r_if
c_cond
(paren
id|scp-&gt;SCp.sent_command
op_ne
id|prev_phase
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ESP_IRQ_P
c_func
(paren
id|esp-&gt;dregs
)paren
)paren
(brace
multiline_comment|/* Yes, we are able to save an interrupt. */
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
id|esp-&gt;sreg2
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_STATUS2
)paren
suffix:semicolon
id|esp-&gt;sreg
op_assign
(paren
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_STATUS
)paren
op_amp
op_complement
(paren
id|ESP_STAT_INTR
)paren
)paren
suffix:semicolon
id|esp-&gt;ireg
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_INTRPT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
multiline_comment|/* This chip is really losing. */
id|ESPHME
c_func
(paren
(paren
l_string|&quot;HME[&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Must latch fifo before reading the interrupt&n;&t;&t;&t; * register else garbage ends up in the FIFO&n;&t;&t;&t; * which confuses the driver utterly.&n;&t;&t;&t; * Happy Meal indeed....&n;&t;&t;&t; */
id|ESPHME
c_func
(paren
(paren
l_string|&quot;fifo_workaround]&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;sreg2
op_amp
id|ESP_STAT2_FEMPTY
)paren
op_logical_or
(paren
id|esp-&gt;sreg2
op_amp
id|ESP_STAT2_F1BYTE
)paren
)paren
id|hme_fifo_read
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_SR
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
id|do_reset_complete
suffix:semicolon
)brace
multiline_comment|/* Ho hum, target is taking forever... */
id|scp-&gt;SCp.sent_command
op_assign
id|new_phase
suffix:semicolon
multiline_comment|/* so we don&squot;t recurse... */
r_return
id|do_intr_end
suffix:semicolon
)brace
DECL|function|skipahead2
r_static
r_inline
r_int
id|skipahead2
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|scp
comma
r_int
id|prev_phase1
comma
r_int
id|prev_phase2
comma
r_int
id|new_phase
)paren
(brace
r_if
c_cond
(paren
id|scp-&gt;SCp.sent_command
op_ne
id|prev_phase1
op_logical_and
id|scp-&gt;SCp.sent_command
op_ne
id|prev_phase2
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ESP_IRQ_P
c_func
(paren
id|esp-&gt;dregs
)paren
)paren
(brace
multiline_comment|/* Yes, we are able to save an interrupt. */
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
id|esp-&gt;sreg2
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_STATUS2
)paren
suffix:semicolon
id|esp-&gt;sreg
op_assign
(paren
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_STATUS
)paren
op_amp
op_complement
(paren
id|ESP_STAT_INTR
)paren
)paren
suffix:semicolon
id|esp-&gt;ireg
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_INTRPT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
multiline_comment|/* This chip is really losing. */
id|ESPHME
c_func
(paren
(paren
l_string|&quot;HME[&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Must latch fifo before reading the interrupt&n;&t;&t;&t; * register else garbage ends up in the FIFO&n;&t;&t;&t; * which confuses the driver utterly.&n;&t;&t;&t; * Happy Meal indeed....&n;&t;&t;&t; */
id|ESPHME
c_func
(paren
(paren
l_string|&quot;fifo_workaround]&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;sreg2
op_amp
id|ESP_STAT2_FEMPTY
)paren
op_logical_or
(paren
id|esp-&gt;sreg2
op_amp
id|ESP_STAT2_F1BYTE
)paren
)paren
id|hme_fifo_read
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_SR
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
id|do_reset_complete
suffix:semicolon
)brace
multiline_comment|/* Ho hum, target is taking forever... */
id|scp-&gt;SCp.sent_command
op_assign
id|new_phase
suffix:semicolon
multiline_comment|/* so we don&squot;t recurse... */
r_return
id|do_intr_end
suffix:semicolon
)brace
multiline_comment|/* Now some dma helpers. */
DECL|function|dma_setup
r_static
r_void
id|dma_setup
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
id|__u32
id|addr
comma
r_int
id|count
comma
r_int
id|write
)paren
(brace
id|u32
id|nreg
op_assign
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write
)paren
id|nreg
op_or_assign
id|DMA_ST_WRITE
suffix:semicolon
r_else
id|nreg
op_and_assign
op_complement
(paren
id|DMA_ST_WRITE
)paren
suffix:semicolon
id|nreg
op_or_assign
id|DMA_ENABLE
suffix:semicolon
id|sbus_writel
c_func
(paren
id|nreg
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;dma-&gt;revision
op_eq
id|dvmaesc1
)paren
(brace
multiline_comment|/* This ESC gate array sucks! */
id|__u32
id|src
op_assign
id|addr
suffix:semicolon
id|__u32
id|dest
op_assign
id|src
op_plus
id|count
suffix:semicolon
r_if
c_cond
(paren
id|dest
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
id|count
op_assign
id|PAGE_ALIGN
c_func
(paren
id|count
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|count
comma
id|esp-&gt;dregs
op_plus
id|DMA_COUNT
)paren
suffix:semicolon
)brace
id|sbus_writel
c_func
(paren
id|addr
comma
id|esp-&gt;dregs
op_plus
id|DMA_ADDR
)paren
suffix:semicolon
)brace
DECL|function|dma_drain
r_static
r_void
id|dma_drain
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|u32
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;dma-&gt;revision
op_eq
id|dvmahme
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_assign
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
)paren
op_amp
id|DMA_FIFO_ISDRAIN
)paren
(brace
r_switch
c_cond
(paren
id|esp-&gt;dma-&gt;revision
)paren
(brace
r_default
suffix:colon
id|tmp
op_or_assign
id|DMA_FIFO_STDRAIN
suffix:semicolon
id|sbus_writel
c_func
(paren
id|tmp
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
r_case
id|dvmarev3
suffix:colon
r_case
id|dvmaesc1
suffix:colon
r_while
c_loop
(paren
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
op_amp
id|DMA_FIFO_ISDRAIN
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
)brace
DECL|function|dma_invalidate
r_static
r_void
id|dma_invalidate
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|u32
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;dma-&gt;revision
op_eq
id|dvmahme
)paren
(brace
id|sbus_writel
c_func
(paren
id|DMA_RST_SCSI
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
id|esp-&gt;prev_hme_dmacsr
op_assign
(paren
(paren
id|esp-&gt;prev_hme_dmacsr
op_or
(paren
id|DMA_PARITY_OFF
op_or
id|DMA_2CLKS
op_or
id|DMA_SCSI_DISAB
op_or
id|DMA_INT_ENAB
)paren
)paren
op_amp
op_complement
(paren
id|DMA_ST_WRITE
op_or
id|DMA_ENABLE
)paren
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
l_int|0
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|esp-&gt;prev_hme_dmacsr
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
multiline_comment|/* This is necessary to avoid having the SCSI channel&n;&t;&t; * engine lock up on us.&n;&t;&t; */
id|sbus_writel
c_func
(paren
l_int|0
comma
id|esp-&gt;dregs
op_plus
id|DMA_ADDR
)paren
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
)paren
op_amp
id|DMA_PEND_READ
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
(paren
id|DMA_ENABLE
op_or
id|DMA_ST_WRITE
op_or
id|DMA_BCNT_ENAB
)paren
suffix:semicolon
id|tmp
op_or_assign
id|DMA_FIFO_INV
suffix:semicolon
id|sbus_writel
c_func
(paren
id|tmp
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|DMA_FIFO_INV
suffix:semicolon
id|sbus_writel
c_func
(paren
id|tmp
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
)brace
)brace
DECL|function|dma_flashclear
r_static
r_inline
r_void
id|dma_flashclear
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|dma_drain
c_func
(paren
id|esp
)paren
suffix:semicolon
id|dma_invalidate
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
DECL|function|dma_can_transfer
r_static
r_int
id|dma_can_transfer
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
id|__u32
id|base
comma
id|end
comma
id|sz
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;dma-&gt;revision
op_eq
id|dvmarev3
)paren
(brace
id|sz
op_assign
id|sp-&gt;SCp.this_residual
suffix:semicolon
r_if
c_cond
(paren
id|sz
OG
l_int|0x1000000
)paren
id|sz
op_assign
l_int|0x1000000
suffix:semicolon
)brace
r_else
(brace
id|base
op_assign
(paren
(paren
id|__u32
)paren
(paren
(paren
r_int
r_int
)paren
id|sp-&gt;SCp.ptr
)paren
)paren
suffix:semicolon
id|base
op_and_assign
(paren
l_int|0x1000000
op_minus
l_int|1
)paren
suffix:semicolon
id|end
op_assign
(paren
id|base
op_plus
id|sp-&gt;SCp.this_residual
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
l_int|0x1000000
)paren
id|end
op_assign
l_int|0x1000000
suffix:semicolon
id|sz
op_assign
(paren
id|end
op_minus
id|base
)paren
suffix:semicolon
)brace
r_return
id|sz
suffix:semicolon
)brace
multiline_comment|/* Misc. esp helper macros. */
DECL|macro|esp_setcount
mdefine_line|#define esp_setcount(__eregs, __cnt, __hme) &bslash;&n;&t;sbus_writeb(((__cnt)&amp;0xff), (__eregs) + ESP_TCLOW); &bslash;&n;&t;sbus_writeb((((__cnt)&gt;&gt;8)&amp;0xff), (__eregs) + ESP_TCMED); &bslash;&n;&t;if (__hme) { &bslash;&n;&t;&t;sbus_writeb((((__cnt)&gt;&gt;16)&amp;0xff), (__eregs) + FAS_RLO); &bslash;&n;&t;&t;sbus_writeb(0, (__eregs) + FAS_RHI); &bslash;&n;&t;}
DECL|macro|esp_getcount
mdefine_line|#define esp_getcount(__eregs, __hme) &bslash;&n;&t;((sbus_readb((__eregs) + ESP_TCLOW)&amp;0xff) | &bslash;&n;&t; ((sbus_readb((__eregs) + ESP_TCMED)&amp;0xff) &lt;&lt; 8) | &bslash;&n;         ((__hme) ? sbus_readb((__eregs) + FAS_RLO) &lt;&lt; 16 : 0))
DECL|macro|fcount
mdefine_line|#define fcount(__esp) &bslash;&n;&t;(((__esp)-&gt;erev == fashme) ? &bslash;&n;&t;  (__esp)-&gt;hme_fifo_workaround_count : &bslash;&n;&t;  sbus_readb(((__esp)-&gt;eregs) + ESP_FFLAGS) &amp; ESP_FF_FBYTES)
DECL|macro|fnzero
mdefine_line|#define fnzero(__esp) &bslash;&n;&t;(((__esp)-&gt;erev == fashme) ? 0 : &bslash;&n;&t; sbus_readb(((__esp)-&gt;eregs) + ESP_FFLAGS) &amp; ESP_FF_ONOTZERO)
multiline_comment|/* XXX speculative nops unnecessary when continuing amidst a data phase&n; * XXX even on esp100!!!  another case of flooding the bus with I/O reg&n; * XXX writes...&n; */
DECL|macro|esp_maybe_nop
mdefine_line|#define esp_maybe_nop(__esp) &bslash;&n;&t;if ((__esp)-&gt;erev == esp100) &bslash;&n;&t;&t;esp_cmd((__esp), ESP_CMD_NULL)
DECL|macro|sreg_to_dataphase
mdefine_line|#define sreg_to_dataphase(__sreg) &bslash;&n;&t;((((__sreg) &amp; ESP_STAT_PMASK) == ESP_DOP) ? in_dataout : in_datain)
multiline_comment|/* The ESP100 when in synchronous data phase, can mistake a long final&n; * REQ pulse from the target as an extra byte, it places whatever is on&n; * the data lines into the fifo.  For now, we will assume when this&n; * happens that the target is a bit quirky and we don&squot;t want to&n; * be talking synchronously to it anyways.  Regardless, we need to&n; * tell the ESP to eat the extraneous byte so that we can proceed&n; * to the next phase.&n; */
DECL|function|esp100_sync_hwbug
r_static
r_int
id|esp100_sync_hwbug
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
comma
r_int
id|fifocnt
)paren
(brace
multiline_comment|/* Do not touch this piece of code. */
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|esp-&gt;erev
op_eq
id|esp100
)paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|sreg_datainp
c_func
(paren
(paren
id|esp-&gt;sreg
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_STATUS
)paren
)paren
)paren
op_logical_and
op_logical_neg
id|fifocnt
)paren
op_logical_and
op_logical_neg
(paren
id|sreg_dataoutp
c_func
(paren
id|esp-&gt;sreg
)paren
op_logical_and
op_logical_neg
id|fnzero
c_func
(paren
id|esp
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|sp-&gt;SCp.phase
op_eq
id|in_dataout
)paren
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Async mode for this guy. */
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Ack the bogus byte, but set ATN first. */
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_SATN
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_MOK
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* This closes the window during a selection with a reselect pending, because&n; * we use DMA for the selection process the FIFO should hold the correct&n; * contents if we get reselected during this process.  So we just need to&n; * ack the possible illegal cmd interrupt pending on the esp100.&n; */
DECL|function|esp100_reconnect_hwbug
r_static
r_inline
r_int
id|esp100_reconnect_hwbug
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|u8
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_ne
id|esp100
)paren
r_return
l_int|0
suffix:semicolon
id|tmp
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_INTRPT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
id|ESP_INTR_SR
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This verifies the BUSID bits during a reselection so that we know which&n; * target is talking to us.&n; */
DECL|function|reconnect_target
r_static
r_inline
r_int
id|reconnect_target
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
r_int
id|it
comma
id|me
op_assign
id|esp-&gt;scsi_id_mask
comma
id|targ
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
l_int|2
op_ne
id|fcount
c_func
(paren
id|esp
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
multiline_comment|/* HME does not latch it&squot;s own BUS ID bits during&n;&t;&t; * a reselection.  Also the target number is given&n;&t;&t; * as an unsigned char, not as a sole bit number&n;&t;&t; * like the other ESP&squot;s do.&n;&t;&t; * Happy Meal indeed....&n;&t;&t; */
id|targ
op_assign
id|esp-&gt;hme_fifo_workaround_buffer
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
(brace
id|it
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_FDATA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|it
op_amp
id|me
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|it
op_and_assign
op_complement
id|me
suffix:semicolon
r_if
c_cond
(paren
id|it
op_amp
(paren
id|it
op_minus
l_int|1
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|it
op_amp
l_int|1
)paren
)paren
id|targ
op_increment
comma
id|it
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_return
id|targ
suffix:semicolon
)brace
multiline_comment|/* This verifies the identify from the target so that we know which lun is&n; * being reconnected.&n; */
DECL|function|reconnect_lun
r_static
r_inline
r_int
id|reconnect_lun
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
r_int
id|lun
suffix:semicolon
r_if
c_cond
(paren
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PMASK
)paren
op_ne
id|ESP_MIP
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
id|lun
op_assign
id|esp-&gt;hme_fifo_workaround_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_else
id|lun
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_FDATA
)paren
suffix:semicolon
multiline_comment|/* Yes, you read this correctly.  We report lun of zero&n;&t; * if we see parity error.  ESP reports parity error for&n;&t; * the lun byte, and this is the only way to hope to recover&n;&t; * because the target is connected.&n;&t; */
r_if
c_cond
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PERR
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Check for illegal bits being set in the lun. */
r_if
c_cond
(paren
(paren
id|lun
op_amp
l_int|0x40
)paren
op_logical_or
op_logical_neg
(paren
id|lun
op_amp
l_int|0x80
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
id|lun
op_amp
l_int|7
suffix:semicolon
)brace
multiline_comment|/* This puts the driver in a state where it can revitalize a command that&n; * is being continued due to reselection.&n; */
DECL|function|esp_connect
r_static
r_inline
r_void
id|esp_connect
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
id|Scsi_Device
op_star
id|dp
op_assign
id|sp-&gt;device
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;prev_soff
op_ne
id|dp-&gt;sync_max_offset
op_logical_or
id|esp-&gt;prev_stp
op_ne
id|dp-&gt;sync_min_period
op_logical_or
(paren
id|esp-&gt;erev
OG
id|esp100a
op_logical_and
id|esp-&gt;prev_cfg3
op_ne
id|esp-&gt;config3
(braket
id|sp-&gt;target
)braket
)paren
)paren
(brace
id|esp-&gt;prev_soff
op_assign
id|dp-&gt;sync_max_offset
suffix:semicolon
id|esp-&gt;prev_stp
op_assign
id|dp-&gt;sync_min_period
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_soff
comma
id|esp-&gt;eregs
op_plus
id|ESP_SOFF
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_stp
comma
id|esp-&gt;eregs
op_plus
id|ESP_STP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
OG
id|esp100a
)paren
(brace
id|esp-&gt;prev_cfg3
op_assign
id|esp-&gt;config3
(braket
id|sp-&gt;target
)braket
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_cfg3
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG3
)paren
suffix:semicolon
)brace
)brace
id|esp-&gt;current_SC
op_assign
id|sp
suffix:semicolon
)brace
multiline_comment|/* This will place the current working command back into the issue queue&n; * if we are to receive a reselection amidst a selection attempt.&n; */
DECL|function|esp_reconnect
r_static
r_inline
r_void
id|esp_reconnect
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|esp-&gt;disconnected_SC
)paren
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Weird, being reselected but disconnected &quot;
l_string|&quot;command queue is empty.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;current_SC
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;SCp.phase
op_assign
id|not_issued
suffix:semicolon
id|append_SC
c_func
(paren
op_amp
id|esp-&gt;issue_SC
comma
id|sp
)paren
suffix:semicolon
)brace
multiline_comment|/* Begin message in phase. */
DECL|function|esp_do_msgin
r_static
r_int
id|esp_do_msgin
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
multiline_comment|/* Must be very careful with the fifo on the HME */
r_if
c_cond
(paren
(paren
id|esp-&gt;erev
op_ne
id|fashme
)paren
op_logical_or
op_logical_neg
(paren
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_STATUS2
)paren
op_amp
id|ESP_STAT2_FEMPTY
)paren
)paren
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
id|esp_maybe_nop
c_func
(paren
id|esp
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
id|esp-&gt;msgin_len
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;msgin_ctr
op_assign
l_int|0
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_msgindone
)paren
suffix:semicolon
r_return
id|do_work_bus
suffix:semicolon
)brace
multiline_comment|/* This uses various DMA csr fields and the fifo flags count value to&n; * determine how many bytes were successfully sent/received by the ESP.&n; */
DECL|function|esp_bytes_sent
r_static
r_inline
r_int
id|esp_bytes_sent
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
r_int
id|fifo_count
)paren
(brace
r_int
id|rval
op_assign
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_ADDR
)paren
op_minus
id|esp-&gt;esp_command_dvma
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;dma-&gt;revision
op_eq
id|dvmarev1
)paren
id|rval
op_sub_assign
(paren
l_int|4
op_minus
(paren
(paren
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
op_amp
id|DMA_READ_AHEAD
)paren
op_rshift
l_int|11
)paren
)paren
suffix:semicolon
r_return
id|rval
op_minus
id|fifo_count
suffix:semicolon
)brace
DECL|function|advance_sg
r_static
r_inline
r_void
id|advance_sg
c_func
(paren
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
op_increment
id|sp-&gt;SCp.buffer
suffix:semicolon
op_decrement
id|sp-&gt;SCp.buffers_residual
suffix:semicolon
id|sp-&gt;SCp.this_residual
op_assign
id|sg_dma_len
c_func
(paren
id|sp-&gt;SCp.buffer
)paren
suffix:semicolon
id|sp-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|sg_dma_address
c_func
(paren
id|sp-&gt;SCp.buffer
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Please note that the way I&squot;ve coded these routines is that I _always_&n; * check for a disconnect during any and all information transfer&n; * phases.  The SCSI standard states that the target _can_ cause a BUS&n; * FREE condition by dropping all MSG/CD/IO/BSY signals.  Also note&n; * that during information transfer phases the target controls every&n; * change in phase, the only thing the initiator can do is &quot;ask&quot; for&n; * a message out phase by driving ATN true.  The target can, and sometimes&n; * will, completely ignore this request so we cannot assume anything when&n; * we try to force a message out phase to abort/reset a target.  Most of&n; * the time the target will eventually be nice and go to message out, so&n; * we may have to hold on to our state about what we want to tell the target&n; * for some period of time.&n; */
multiline_comment|/* I think I have things working here correctly.  Even partial transfers&n; * within a buffer or sub-buffer should not upset us at all no matter&n; * how bad the target and/or ESP fucks things up.&n; */
DECL|function|esp_do_data
r_static
r_int
id|esp_do_data
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
r_int
id|thisphase
comma
id|hmuch
suffix:semicolon
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;esp_do_data: &quot;
)paren
)paren
suffix:semicolon
id|esp_maybe_nop
c_func
(paren
id|esp
)paren
suffix:semicolon
id|thisphase
op_assign
id|sreg_to_dataphase
c_func
(paren
id|esp-&gt;sreg
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|thisphase
)paren
suffix:semicolon
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;newphase&lt;%s&gt; &quot;
comma
(paren
id|thisphase
op_eq
id|in_datain
)paren
ques
c_cond
l_string|&quot;DATAIN&quot;
suffix:colon
l_string|&quot;DATAOUT&quot;
)paren
)paren
suffix:semicolon
id|hmuch
op_assign
id|dma_can_transfer
c_func
(paren
id|esp
comma
id|SCptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hmuch
OG
(paren
l_int|64
op_star
l_int|1024
)paren
op_logical_and
(paren
id|esp-&gt;erev
op_ne
id|fashme
)paren
)paren
id|hmuch
op_assign
(paren
l_int|64
op_star
l_int|1024
)paren
suffix:semicolon
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;hmuch&lt;%d&gt; &quot;
comma
id|hmuch
)paren
)paren
suffix:semicolon
id|esp-&gt;current_transfer_size
op_assign
id|hmuch
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
id|u32
id|tmp
op_assign
id|esp-&gt;prev_hme_dmacsr
suffix:semicolon
multiline_comment|/* Always set the ESP count registers first. */
id|esp_setcount
c_func
(paren
id|esp-&gt;eregs
comma
id|hmuch
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Get the DMA csr computed. */
id|tmp
op_or_assign
(paren
id|DMA_SCSI_DISAB
op_or
id|DMA_ENABLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thisphase
op_eq
id|in_datain
)paren
id|tmp
op_or_assign
id|DMA_ST_WRITE
suffix:semicolon
r_else
id|tmp
op_and_assign
op_complement
(paren
id|DMA_ST_WRITE
)paren
suffix:semicolon
id|esp-&gt;prev_hme_dmacsr
op_assign
id|tmp
suffix:semicolon
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;DMA|TI --&gt; do_intr_end&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thisphase
op_eq
id|in_datain
)paren
(brace
id|sbus_writel
c_func
(paren
id|hmuch
comma
id|esp-&gt;dregs
op_plus
id|DMA_COUNT
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_DMA
op_or
id|ESP_CMD_TI
)paren
suffix:semicolon
)brace
r_else
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_DMA
op_or
id|ESP_CMD_TI
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|hmuch
comma
id|esp-&gt;dregs
op_plus
id|DMA_COUNT
)paren
suffix:semicolon
)brace
id|sbus_writel
c_func
(paren
(paren
id|__u32
)paren
(paren
(paren
r_int
r_int
)paren
id|SCptr-&gt;SCp.ptr
)paren
comma
id|esp-&gt;dregs
op_plus
id|DMA_ADDR
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|esp-&gt;prev_hme_dmacsr
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
)brace
r_else
(brace
id|esp_setcount
c_func
(paren
id|esp-&gt;eregs
comma
id|hmuch
comma
l_int|0
)paren
suffix:semicolon
id|dma_setup
c_func
(paren
id|esp
comma
(paren
(paren
id|__u32
)paren
(paren
(paren
r_int
r_int
)paren
id|SCptr-&gt;SCp.ptr
)paren
)paren
comma
id|hmuch
comma
(paren
id|thisphase
op_eq
id|in_datain
)paren
)paren
suffix:semicolon
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;DMA|TI --&gt; do_intr_end&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_DMA
op_or
id|ESP_CMD_TI
)paren
suffix:semicolon
)brace
r_return
id|do_intr_end
suffix:semicolon
)brace
multiline_comment|/* See how successful the data transfer was. */
DECL|function|esp_do_data_finale
r_static
r_int
id|esp_do_data_finale
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
r_int
id|bogus_data
op_assign
l_int|0
comma
id|bytes_sent
op_assign
l_int|0
comma
id|fifocnt
comma
id|ecount
op_assign
l_int|0
suffix:semicolon
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;esp_do_data_finale: &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCptr-&gt;SCp.phase
op_eq
id|in_datain
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PERR
)paren
(brace
multiline_comment|/* Yuck, parity error.  The ESP asserts ATN&n;&t;&t;&t; * so that we can go to message out phase&n;&t;&t;&t; * immediately and inform the target that&n;&t;&t;&t; * something bad happened.&n;&t;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: data bad parity detected.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
op_assign
id|INITIATOR_ERROR
suffix:semicolon
id|esp-&gt;msgout_len
op_assign
l_int|1
suffix:semicolon
)brace
id|dma_drain
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
id|dma_invalidate
c_func
(paren
id|esp
)paren
suffix:semicolon
multiline_comment|/* This could happen for the above parity error case. */
r_if
c_cond
(paren
id|esp-&gt;ireg
op_ne
id|ESP_INTR_BSERV
)paren
(brace
multiline_comment|/* Please go to msgout phase, please please please... */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: !BSERV after data, probably to msgout&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_return
id|esp_do_phase_determine
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for partial transfers and other horrible events.&n;&t; * Note, here we read the real fifo flags register even&n;&t; * on HME broken adapters because we skip the HME fifo&n;&t; * workaround code in esp_handle() if we are doing data&n;&t; * phase things.  We don&squot;t want to fuck directly with&n;&t; * the fifo like that, especially if doing synchronous&n;&t; * transfers!  Also, will need to double the count on&n;&t; * HME if we are doing wide transfers, as the HME fifo&n;&t; * will move and count 16-bit quantities during wide data.&n;&t; * SMCC _and_ Qlogic can both bite me.&n;&t; */
id|fifocnt
op_assign
(paren
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_FFLAGS
)paren
op_amp
id|ESP_FF_FBYTES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_ne
id|fashme
)paren
id|ecount
op_assign
id|esp_getcount
c_func
(paren
id|esp-&gt;eregs
comma
l_int|0
)paren
suffix:semicolon
id|bytes_sent
op_assign
id|esp-&gt;current_transfer_size
suffix:semicolon
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;trans_sz(%d), &quot;
comma
id|bytes_sent
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_TCNT
)paren
)paren
(brace
id|ecount
op_assign
id|esp_getcount
c_func
(paren
id|esp-&gt;eregs
comma
l_int|1
)paren
suffix:semicolon
id|bytes_sent
op_sub_assign
id|ecount
suffix:semicolon
)brace
multiline_comment|/* Always subtract any cruft remaining in the FIFO. */
r_if
c_cond
(paren
id|esp-&gt;prev_cfg3
op_amp
id|ESP_CONFIG3_EWIDE
)paren
id|fifocnt
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|SCptr-&gt;SCp.phase
op_eq
id|in_dataout
)paren
id|bytes_sent
op_sub_assign
id|fifocnt
suffix:semicolon
multiline_comment|/* I have an IBM disk which exhibits the following&n;&t;&t; * behavior during writes to it.  It disconnects in&n;&t;&t; * the middle of a partial transfer, the current sglist&n;&t;&t; * buffer is 1024 bytes, the disk stops data transfer&n;&t;&t; * at 512 bytes.&n;&t;&t; *&n;&t;&t; * However the FAS366 reports that 32 more bytes were&n;&t;&t; * transferred than really were.  This is precisely&n;&t;&t; * the size of a fully loaded FIFO in wide scsi mode.&n;&t;&t; * The FIFO state recorded indicates that it is empty.&n;&t;&t; *&n;&t;&t; * I have no idea if this is a bug in the FAS366 chip&n;&t;&t; * or a bug in the firmware on this IBM disk.  In any&n;&t;&t; * event the following seems to be a good workaround.  -DaveM&n;&t;&t; */
r_if
c_cond
(paren
id|bytes_sent
op_ne
id|esp-&gt;current_transfer_size
op_logical_and
id|SCptr-&gt;SCp.phase
op_eq
id|in_dataout
)paren
(brace
r_int
id|mask
op_assign
(paren
l_int|64
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|esp-&gt;prev_cfg3
op_amp
id|ESP_CONFIG3_EWIDE
)paren
op_eq
l_int|0
)paren
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bytes_sent
op_amp
id|mask
)paren
id|bytes_sent
op_sub_assign
(paren
id|bytes_sent
op_amp
id|mask
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_TCNT
)paren
)paren
id|bytes_sent
op_sub_assign
id|ecount
suffix:semicolon
r_if
c_cond
(paren
id|SCptr-&gt;SCp.phase
op_eq
id|in_dataout
)paren
id|bytes_sent
op_sub_assign
id|fifocnt
suffix:semicolon
)brace
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;bytes_sent(%d), &quot;
comma
id|bytes_sent
)paren
)paren
suffix:semicolon
multiline_comment|/* If we were in synchronous mode, check for peculiarities. */
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
r_if
c_cond
(paren
id|SCptr-&gt;device-&gt;sync_max_offset
)paren
(brace
r_if
c_cond
(paren
id|SCptr-&gt;SCp.phase
op_eq
id|in_dataout
)paren
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
)brace
r_else
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|SCptr-&gt;device-&gt;sync_max_offset
)paren
id|bogus_data
op_assign
id|esp100_sync_hwbug
c_func
(paren
id|esp
comma
id|SCptr
comma
id|fifocnt
)paren
suffix:semicolon
r_else
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
)brace
multiline_comment|/* Until we are sure of what has happened, we are certainly&n;&t; * in the dark.&n;&t; */
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes_sent
OL
l_int|0
)paren
(brace
multiline_comment|/* I&squot;ve seen this happen due to lost state in this&n;&t;&t; * driver.  No idea why it happened, but allowing&n;&t;&t; * this value to be negative caused things to&n;&t;&t; * lock up.  This allows greater chance of recovery.&n;&t;&t; * In fact every time I&squot;ve seen this, it has been&n;&t;&t; * a driver bug without question.&n;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: yieee, bytes_sent &lt; 0!&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: csz=%d fifocount=%d ecount=%d&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;current_transfer_size
comma
id|fifocnt
comma
id|ecount
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: use_sg=%d ptr=%p this_residual=%d&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|SCptr-&gt;use_sg
comma
id|SCptr-&gt;SCp.ptr
comma
id|SCptr-&gt;SCp.this_residual
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Forcing async for target %d&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|SCptr-&gt;target
)paren
)paren
suffix:semicolon
id|SCptr-&gt;device-&gt;borken
op_assign
l_int|1
suffix:semicolon
id|SCptr-&gt;device-&gt;sync
op_assign
l_int|0
suffix:semicolon
id|bytes_sent
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Update the state of our transfer. */
id|SCptr-&gt;SCp.ptr
op_add_assign
id|bytes_sent
suffix:semicolon
id|SCptr-&gt;SCp.this_residual
op_sub_assign
id|bytes_sent
suffix:semicolon
r_if
c_cond
(paren
id|SCptr-&gt;SCp.this_residual
OL
l_int|0
)paren
(brace
multiline_comment|/* shit */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Data transfer overrun.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|SCptr-&gt;SCp.this_residual
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Maybe continue. */
r_if
c_cond
(paren
op_logical_neg
id|bogus_data
)paren
(brace
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;!bogus_data, &quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* NO MATTER WHAT, we advance the scatterlist,&n;&t;&t; * if the target should decide to disconnect&n;&t;&t; * in between scatter chunks (which is common)&n;&t;&t; * we could die horribly!  I used to have the sg&n;&t;&t; * advance occur only if we are going back into&n;&t;&t; * (or are staying in) a data phase, you can&n;&t;&t; * imagine the hell I went through trying to&n;&t;&t; * figure this out.&n;&t;&t; */
r_if
c_cond
(paren
id|SCptr-&gt;use_sg
op_logical_and
op_logical_neg
id|SCptr-&gt;SCp.this_residual
)paren
id|advance_sg
c_func
(paren
id|SCptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreg_datainp
c_func
(paren
id|esp-&gt;sreg
)paren
op_logical_or
id|sreg_dataoutp
c_func
(paren
id|esp-&gt;sreg
)paren
)paren
(brace
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;to more data&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|esp_do_data
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
id|ESPDATA
c_func
(paren
(paren
l_string|&quot;to new phase&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|esp_do_phase_determine
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
multiline_comment|/* Bogus data, just wait for next interrupt. */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: bogus_data during end of data phase&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
multiline_comment|/* We received a non-good status return at the end of&n; * running a SCSI command.  This is used to decide if&n; * we should clear our synchronous transfer state for&n; * such a device when that happens.&n; *&n; * The idea is that when spinning up a disk or rewinding&n; * a tape, we don&squot;t want to go into a loop re-negotiating&n; * synchronous capabilities over and over.&n; */
DECL|function|esp_should_clear_sync
r_static
r_int
id|esp_should_clear_sync
c_func
(paren
id|Scsi_Cmnd
op_star
id|sp
)paren
(brace
id|u8
id|cmd1
op_assign
id|sp-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
id|u8
id|cmd2
op_assign
id|sp-&gt;data_cmnd
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* These cases are for spinning up a disk and&n;&t; * waiting for that spinup to complete.&n;&t; */
r_if
c_cond
(paren
id|cmd1
op_eq
id|START_STOP
op_logical_or
id|cmd2
op_eq
id|START_STOP
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cmd1
op_eq
id|TEST_UNIT_READY
op_logical_or
id|cmd2
op_eq
id|TEST_UNIT_READY
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* One more special case for SCSI tape drives,&n;&t; * this is what is used to probe the device for&n;&t; * completion of a rewind or tape load operation.&n;&t; */
r_if
c_cond
(paren
id|sp-&gt;device-&gt;type
op_eq
id|TYPE_TAPE
)paren
(brace
r_if
c_cond
(paren
id|cmd1
op_eq
id|MODE_SENSE
op_logical_or
id|cmd2
op_eq
id|MODE_SENSE
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Either a command is completing or a target is dropping off the bus&n; * to continue the command in the background so we can do other work.&n; */
DECL|function|esp_do_freebus
r_static
r_int
id|esp_do_freebus
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
r_int
id|rval
suffix:semicolon
id|rval
op_assign
id|skipahead2
c_func
(paren
id|esp
comma
id|SCptr
comma
id|in_status
comma
id|in_msgindone
comma
id|in_freeing
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
)paren
r_return
id|rval
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;ireg
op_ne
id|ESP_INTR_DC
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Target will not disconnect&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
multiline_comment|/* target will not drop BSY... */
)brace
id|esp-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;prevmsgout
op_assign
id|NOP
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;prevmsgin
op_eq
id|COMMAND_COMPLETE
)paren
(brace
multiline_comment|/* Normal end of nexus. */
r_if
c_cond
(paren
id|esp-&gt;disconnected_SC
op_logical_or
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
)paren
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_ESEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCptr-&gt;SCp.Status
op_ne
id|GOOD
op_logical_and
id|SCptr-&gt;SCp.Status
op_ne
id|CONDITION_GOOD
op_logical_and
(paren
(paren
l_int|1
op_lshift
id|SCptr-&gt;target
)paren
op_amp
id|esp-&gt;targets_present
)paren
op_logical_and
id|SCptr-&gt;device-&gt;sync
op_logical_and
id|SCptr-&gt;device-&gt;sync_max_offset
)paren
(brace
multiline_comment|/* SCSI standard says that the synchronous capabilities&n;&t;&t;&t; * should be renegotiated at this point.  Most likely&n;&t;&t;&t; * we are about to request sense from this target&n;&t;&t;&t; * in which case we want to avoid using sync&n;&t;&t;&t; * transfers until we are sure of the current target&n;&t;&t;&t; * state.&n;&t;&t;&t; */
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;esp: Status &lt;%d&gt; for target %d lun %d&bslash;n&quot;
comma
id|SCptr-&gt;SCp.Status
comma
id|SCptr-&gt;target
comma
id|SCptr-&gt;lun
)paren
)paren
suffix:semicolon
multiline_comment|/* But don&squot;t do this when spinning up a disk at&n;&t;&t;&t; * boot time while we poll for completion as it&n;&t;&t;&t; * fills up the console with messages.  Also, tapes&n;&t;&t;&t; * can report not ready many times right after&n;&t;&t;&t; * loading up a tape.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|esp_should_clear_sync
c_func
(paren
id|SCptr
)paren
op_ne
l_int|0
)paren
id|SCptr-&gt;device-&gt;sync
op_assign
l_int|0
suffix:semicolon
)brace
id|ESPDISC
c_func
(paren
(paren
l_string|&quot;F&lt;%02x,%02x&gt;&quot;
comma
id|SCptr-&gt;target
comma
id|SCptr-&gt;lun
)paren
)paren
suffix:semicolon
id|esp_done
c_func
(paren
id|esp
comma
(paren
(paren
id|SCptr-&gt;SCp.Status
op_amp
l_int|0xff
)paren
op_or
(paren
(paren
id|SCptr-&gt;SCp.Message
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|DID_OK
op_lshift
l_int|16
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;prevmsgin
op_eq
id|DISCONNECT
)paren
(brace
multiline_comment|/* Normal disconnect. */
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_ESEL
)paren
suffix:semicolon
id|ESPDISC
c_func
(paren
(paren
l_string|&quot;D&lt;%02x,%02x&gt;&quot;
comma
id|SCptr-&gt;target
comma
id|SCptr-&gt;lun
)paren
)paren
suffix:semicolon
id|append_SC
c_func
(paren
op_amp
id|esp-&gt;disconnected_SC
comma
id|SCptr
)paren
suffix:semicolon
id|esp-&gt;current_SC
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;issue_SC
)paren
id|esp_exec_cmd
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Driver bug, we do not expect a disconnect here&n;&t;&t; * and should not have advanced the state engine&n;&t;&t; * to in_freeing.&n;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: last msg not disc and not cmd cmplt.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
)brace
r_return
id|do_intr_end
suffix:semicolon
)brace
multiline_comment|/* When a reselect occurs, and we cannot find the command to&n; * reconnect to in our queues, we do this.&n; */
DECL|function|esp_bad_reconnect
r_static
r_int
id|esp_bad_reconnect
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|Scsi_Cmnd
op_star
id|sp
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Eieeee, reconnecting unknown command!&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;QUEUE DUMP&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sp
op_assign
id|esp-&gt;issue_SC
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: issue_SC[&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sp
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;&lt;%02x,%02x&gt;&quot;
comma
id|sp-&gt;target
comma
id|sp-&gt;lun
)paren
)paren
suffix:semicolon
id|sp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|sp-&gt;host_scribble
suffix:semicolon
)brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;]&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sp
op_assign
id|esp-&gt;current_SC
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: current_SC[&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sp
)paren
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;&lt;%02x,%02x&gt;&quot;
comma
id|sp-&gt;target
comma
id|sp-&gt;lun
)paren
)paren
suffix:semicolon
r_else
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;&lt;NULL&gt;&quot;
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;]&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sp
op_assign
id|esp-&gt;disconnected_SC
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: disconnected_SC[&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sp
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;&lt;%02x,%02x&gt;&quot;
comma
id|sp-&gt;target
comma
id|sp-&gt;lun
)paren
)paren
suffix:semicolon
id|sp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|sp-&gt;host_scribble
suffix:semicolon
)brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;]&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
)brace
multiline_comment|/* Do the needy when a target tries to reconnect to us. */
DECL|function|esp_do_reconnect
r_static
r_int
id|esp_do_reconnect
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
r_int
id|lun
comma
id|target
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCptr
suffix:semicolon
multiline_comment|/* Check for all bogus conditions first. */
id|target
op_assign
id|reconnect_target
c_func
(paren
id|esp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
OL
l_int|0
)paren
(brace
id|ESPDISC
c_func
(paren
(paren
l_string|&quot;bad bus bits&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
)brace
id|lun
op_assign
id|reconnect_lun
c_func
(paren
id|esp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lun
OL
l_int|0
)paren
(brace
id|ESPDISC
c_func
(paren
(paren
l_string|&quot;target=%2x, bad identify msg&bslash;n&quot;
comma
id|target
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
)brace
multiline_comment|/* Things look ok... */
id|ESPDISC
c_func
(paren
(paren
l_string|&quot;R&lt;%02x,%02x&gt;&quot;
comma
id|target
comma
id|lun
)paren
)paren
suffix:semicolon
multiline_comment|/* Must not flush FIFO or DVMA on HME. */
r_if
c_cond
(paren
id|esp-&gt;erev
op_ne
id|fashme
)paren
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp100_reconnect_hwbug
c_func
(paren
id|esp
)paren
)paren
r_return
id|do_reset_bus
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_NULL
)paren
suffix:semicolon
)brace
id|SCptr
op_assign
id|remove_SC
c_func
(paren
op_amp
id|esp-&gt;disconnected_SC
comma
(paren
id|u8
)paren
id|target
comma
(paren
id|u8
)paren
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCptr
)paren
r_return
id|esp_bad_reconnect
c_func
(paren
id|esp
)paren
suffix:semicolon
id|esp_connect
c_func
(paren
id|esp
comma
id|SCptr
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_MOK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
id|sbus_writeb
c_func
(paren
(paren
(paren
id|SCptr-&gt;target
op_amp
l_int|0xf
)paren
op_or
(paren
id|ESP_BUSID_RESELID
op_or
id|ESP_BUSID_CTR32BIT
)paren
)paren
comma
id|esp-&gt;eregs
op_plus
id|ESP_BUSID
)paren
suffix:semicolon
multiline_comment|/* Reconnect implies a restore pointers operation. */
id|esp_restore_pointers
c_func
(paren
id|esp
comma
id|SCptr
)paren
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|0
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
multiline_comment|/* End of NEXUS (hopefully), pick up status + message byte then leave if&n; * all goes well.&n; */
DECL|function|esp_do_status
r_static
r_int
id|esp_do_status
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
r_int
id|intr
comma
id|rval
suffix:semicolon
id|rval
op_assign
id|skipahead1
c_func
(paren
id|esp
comma
id|SCptr
comma
id|in_the_dark
comma
id|in_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
)paren
r_return
id|rval
suffix:semicolon
id|intr
op_assign
id|esp-&gt;ireg
suffix:semicolon
id|ESPSTAT
c_func
(paren
(paren
l_string|&quot;esp_do_status: &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr
op_ne
id|ESP_INTR_DC
)paren
(brace
r_int
id|message_out
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* for parity problems */
multiline_comment|/* Ack the message. */
id|ESPSTAT
c_func
(paren
(paren
l_string|&quot;ack msg, &quot;
)paren
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_MOK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_ne
id|fashme
)paren
(brace
id|dma_flashclear
c_func
(paren
id|esp
)paren
suffix:semicolon
multiline_comment|/* Wait till the first bits settle. */
r_while
c_loop
(paren
id|esp-&gt;esp_command
(braket
l_int|0
)braket
op_eq
l_int|0xff
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|esp-&gt;esp_command
(braket
l_int|0
)braket
op_assign
id|esp-&gt;hme_fifo_workaround_buffer
(braket
l_int|0
)braket
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|1
)braket
op_assign
id|esp-&gt;hme_fifo_workaround_buffer
(braket
l_int|1
)braket
suffix:semicolon
)brace
id|ESPSTAT
c_func
(paren
(paren
l_string|&quot;got something, &quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* ESP chimes in with one of&n;&t;&t; *&n;&t;&t; * 1) function done interrupt:&n;&t;&t; *&t;both status and message in bytes&n;&t;&t; *&t;are available&n;&t;&t; *&n;&t;&t; * 2) bus service interrupt:&n;&t;&t; *&t;only status byte was acquired&n;&t;&t; *&n;&t;&t; * 3) Anything else:&n;&t;&t; *&t;can&squot;t happen, but we test for it&n;&t;&t; *&t;anyways&n;&t;&t; *&n;&t;&t; * ALSO: If bad parity was detected on either&n;&t;&t; *       the status _or_ the message byte then&n;&t;&t; *       the ESP has asserted ATN on the bus&n;&t;&t; *       and we must therefore wait for the&n;&t;&t; *       next phase change.&n;&t;&t; */
r_if
c_cond
(paren
id|intr
op_amp
id|ESP_INTR_FDONE
)paren
(brace
multiline_comment|/* We got it all, hallejulia. */
id|ESPSTAT
c_func
(paren
(paren
l_string|&quot;got both, &quot;
)paren
)paren
suffix:semicolon
id|SCptr-&gt;SCp.Status
op_assign
id|esp-&gt;esp_command
(braket
l_int|0
)braket
suffix:semicolon
id|SCptr-&gt;SCp.Message
op_assign
id|esp-&gt;esp_command
(braket
l_int|1
)braket
suffix:semicolon
id|esp-&gt;prevmsgin
op_assign
id|SCptr-&gt;SCp.Message
suffix:semicolon
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
op_assign
id|SCptr-&gt;SCp.Message
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PERR
)paren
(brace
multiline_comment|/* There was bad parity for the&n;&t;&t;&t;&t; * message byte, the status byte&n;&t;&t;&t;&t; * was ok.&n;&t;&t;&t;&t; */
id|message_out
op_assign
id|MSG_PARITY_ERROR
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|intr
op_eq
id|ESP_INTR_BSERV
)paren
(brace
multiline_comment|/* Only got status byte. */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: got status only, &quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PERR
)paren
)paren
(brace
id|SCptr-&gt;SCp.Status
op_assign
id|esp-&gt;esp_command
(braket
l_int|0
)braket
suffix:semicolon
id|SCptr-&gt;SCp.Message
op_assign
l_int|0xff
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The status byte had bad parity.&n;&t;&t;&t;&t; * we leave the scsi_pointer Status&n;&t;&t;&t;&t; * field alone as we set it to a default&n;&t;&t;&t;&t; * of CHECK_CONDITION in esp_queue.&n;&t;&t;&t;&t; */
id|message_out
op_assign
id|INITIATOR_ERROR
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* This shouldn&squot;t happen ever. */
id|ESPSTAT
c_func
(paren
(paren
l_string|&quot;got bolixed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|esp_do_phase_determine
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|message_out
)paren
(brace
id|ESPSTAT
c_func
(paren
(paren
l_string|&quot;status=%2x msg=%2x, &quot;
comma
id|SCptr-&gt;SCp.Status
comma
id|SCptr-&gt;SCp.Message
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCptr-&gt;SCp.Message
op_eq
id|COMMAND_COMPLETE
)paren
(brace
id|ESPSTAT
c_func
(paren
(paren
l_string|&quot;and was COMMAND_COMPLETE&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_freeing
)paren
suffix:semicolon
r_return
id|esp_do_freebus
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_else
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: and _not_ COMMAND_COMPLETE&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp-&gt;msgin_len
op_assign
id|esp-&gt;msgin_ctr
op_assign
l_int|1
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_msgindone
)paren
suffix:semicolon
r_return
id|esp_do_msgindone
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* With luck we&squot;ll be able to let the target&n;&t;&t;&t; * know that bad parity happened, it will know&n;&t;&t;&t; * which byte caused the problems and send it&n;&t;&t;&t; * again.  For the case where the status byte&n;&t;&t;&t; * receives bad parity, I do not believe most&n;&t;&t;&t; * targets recover very well.  We&squot;ll see.&n;&t;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: bad parity somewhere mout=%2x&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|message_out
)paren
)paren
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
op_assign
id|message_out
suffix:semicolon
id|esp-&gt;msgout_len
op_assign
id|esp-&gt;msgout_ctr
op_assign
l_int|1
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|esp_do_phase_determine
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* If we disconnect now, all hell breaks loose. */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: whoops, disconnect&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|esp_do_phase_determine
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
)brace
DECL|function|esp_enter_status
r_static
r_int
id|esp_enter_status
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|u8
id|thecmd
op_assign
id|ESP_CMD_ICCSEQ
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_ne
id|fashme
)paren
(brace
id|u32
id|tmp
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|0
)braket
op_assign
id|esp-&gt;esp_command
(braket
l_int|1
)braket
op_assign
l_int|0xff
suffix:semicolon
id|sbus_writeb
c_func
(paren
l_int|2
comma
id|esp-&gt;eregs
op_plus
id|ESP_TCLOW
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
l_int|0
comma
id|esp-&gt;eregs
op_plus
id|ESP_TCMED
)paren
suffix:semicolon
id|tmp
op_assign
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
id|tmp
op_or_assign
(paren
id|DMA_ST_WRITE
op_or
id|DMA_ENABLE
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|tmp
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;dma-&gt;revision
op_eq
id|dvmaesc1
)paren
id|sbus_writel
c_func
(paren
l_int|0x100
comma
id|esp-&gt;dregs
op_plus
id|DMA_COUNT
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|esp-&gt;esp_command_dvma
comma
id|esp-&gt;dregs
op_plus
id|DMA_ADDR
)paren
suffix:semicolon
id|thecmd
op_or_assign
id|ESP_CMD_DMA
suffix:semicolon
)brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|thecmd
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_status
)paren
suffix:semicolon
r_return
id|esp_do_status
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
DECL|function|esp_disconnect_amidst_phases
r_static
r_int
id|esp_disconnect_amidst_phases
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|Scsi_Cmnd
op_star
id|sp
op_assign
id|esp-&gt;current_SC
suffix:semicolon
id|Scsi_Device
op_star
id|dp
op_assign
id|sp-&gt;device
suffix:semicolon
multiline_comment|/* This means real problems if we see this&n;&t; * here.  Unless we were actually trying&n;&t; * to force the device to abort/reset.&n;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d Disconnect amidst phases, &quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;pphase&lt;%s&gt; cphase&lt;%s&gt;, &quot;
comma
id|phase_string
c_func
(paren
id|sp-&gt;SCp.phase
)paren
comma
id|phase_string
c_func
(paren
id|sp-&gt;SCp.sent_command
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;disconnected_SC
op_ne
l_int|NULL
op_logical_or
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
)paren
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_ESEL
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
)paren
(brace
r_default
suffix:colon
multiline_comment|/* We didn&squot;t expect this to happen at all. */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;device is bolixed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|sp
comma
id|in_tgterror
)paren
suffix:semicolon
id|esp_done
c_func
(paren
id|esp
comma
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BUS_DEVICE_RESET
suffix:colon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;device reset successful&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|dp-&gt;sync_max_offset
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;sync_min_period
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;sync
op_assign
l_int|0
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|sp
comma
id|in_resetdev
)paren
suffix:semicolon
id|esp_done
c_func
(paren
id|esp
comma
(paren
id|DID_RESET
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ABORT
suffix:colon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;device abort successful&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|sp
comma
id|in_abortone
)paren
suffix:semicolon
id|esp_done
c_func
(paren
id|esp
comma
(paren
id|DID_ABORT
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
DECL|function|esp_enter_msgout
r_static
r_int
id|esp_enter_msgout
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_msgout
)paren
suffix:semicolon
r_return
id|esp_do_msgout
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
DECL|function|esp_enter_msgin
r_static
r_int
id|esp_enter_msgin
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_msgin
)paren
suffix:semicolon
r_return
id|esp_do_msgin
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
DECL|function|esp_enter_cmd
r_static
r_int
id|esp_enter_cmd
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_cmdbegin
)paren
suffix:semicolon
r_return
id|esp_do_cmdbegin
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
DECL|function|esp_enter_badphase
r_static
r_int
id|esp_enter_badphase
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Bizarre bus phase %2x.&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PMASK
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
)brace
DECL|typedef|espfunc_t
r_typedef
r_int
(paren
op_star
id|espfunc_t
)paren
(paren
r_struct
id|esp
op_star
)paren
suffix:semicolon
DECL|variable|phase_vector
r_static
id|espfunc_t
id|phase_vector
(braket
)braket
op_assign
(brace
id|esp_do_data
comma
multiline_comment|/* ESP_DOP */
id|esp_do_data
comma
multiline_comment|/* ESP_DIP */
id|esp_enter_cmd
comma
multiline_comment|/* ESP_CMDP */
id|esp_enter_status
comma
multiline_comment|/* ESP_STATP */
id|esp_enter_badphase
comma
multiline_comment|/* ESP_STAT_PMSG */
id|esp_enter_badphase
comma
multiline_comment|/* ESP_STAT_PMSG | ESP_STAT_PIO */
id|esp_enter_msgout
comma
multiline_comment|/* ESP_MOP */
id|esp_enter_msgin
comma
multiline_comment|/* ESP_MIP */
)brace
suffix:semicolon
multiline_comment|/* The target has control of the bus and we have to see where it has&n; * taken us.&n; */
DECL|function|esp_do_phase_determine
r_static
r_int
id|esp_do_phase_determine
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
r_if
c_cond
(paren
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_DC
)paren
op_ne
l_int|0
)paren
r_return
id|esp_disconnect_amidst_phases
c_func
(paren
id|esp
)paren
suffix:semicolon
r_return
id|phase_vector
(braket
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PMASK
)braket
(paren
id|esp
)paren
suffix:semicolon
)brace
multiline_comment|/* First interrupt after exec&squot;ing a cmd comes here. */
DECL|function|esp_select_complete
r_static
r_int
id|esp_select_complete
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
id|Scsi_Device
op_star
id|SDptr
op_assign
id|SCptr-&gt;device
suffix:semicolon
r_int
id|cmd_bytes_sent
comma
id|fcnt
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_ne
id|fashme
)paren
id|esp-&gt;seqreg
op_assign
(paren
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_SSTEP
)paren
op_amp
id|ESP_STEP_VBITS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
id|fcnt
op_assign
id|esp-&gt;hme_fifo_workaround_count
suffix:semicolon
r_else
id|fcnt
op_assign
(paren
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_FFLAGS
)paren
op_amp
id|ESP_FF_FBYTES
)paren
suffix:semicolon
id|cmd_bytes_sent
op_assign
id|esp_bytes_sent
c_func
(paren
id|esp
comma
id|fcnt
)paren
suffix:semicolon
id|dma_invalidate
c_func
(paren
id|esp
)paren
suffix:semicolon
multiline_comment|/* Let&squot;s check to see if a reselect happened&n;&t; * while we we&squot;re trying to select.  This must&n;&t; * be checked first.&n;&t; */
r_if
c_cond
(paren
id|esp-&gt;ireg
op_eq
(paren
id|ESP_INTR_RSEL
op_or
id|ESP_INTR_FDONE
)paren
)paren
(brace
id|esp_reconnect
c_func
(paren
id|esp
comma
id|SCptr
)paren
suffix:semicolon
r_return
id|esp_do_reconnect
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
multiline_comment|/* Looks like things worked, we should see a bus service &amp;&n;&t; * a function complete interrupt at this point.  Note we&n;&t; * are doing a direct comparison because we don&squot;t want to&n;&t; * be fooled into thinking selection was successful if&n;&t; * ESP_INTR_DC is set, see below.&n;&t; */
r_if
c_cond
(paren
id|esp-&gt;ireg
op_eq
(paren
id|ESP_INTR_FDONE
op_or
id|ESP_INTR_BSERV
)paren
)paren
(brace
multiline_comment|/* target speaks... */
id|esp-&gt;targets_present
op_or_assign
(paren
l_int|1
op_lshift
id|SCptr-&gt;target
)paren
suffix:semicolon
multiline_comment|/* What if the target ignores the sdtr? */
r_if
c_cond
(paren
id|esp-&gt;snip
)paren
id|SDptr-&gt;sync
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* See how far, if at all, we got in getting&n;&t;&t; * the information out to the target.&n;&t;&t; */
r_switch
c_cond
(paren
id|esp-&gt;seqreg
)paren
(brace
r_default
suffix:colon
r_case
id|ESP_STEP_ASEL
suffix:colon
multiline_comment|/* Arbitration won, target selected, but&n;&t;&t;&t; * we are in some phase which is not command&n;&t;&t;&t; * phase nor is it message out phase.&n;&t;&t;&t; *&n;&t;&t;&t; * XXX We&squot;ve confused the target, obviously.&n;&t;&t;&t; * XXX So clear it&squot;s state, but we also end&n;&t;&t;&t; * XXX up clearing everyone elses.  That isn&squot;t&n;&t;&t;&t; * XXX so nice.  I&squot;d like to just reset this&n;&t;&t;&t; * XXX target, but if I cannot even get it&squot;s&n;&t;&t;&t; * XXX attention and finish selection to talk&n;&t;&t;&t; * XXX to it, there is not much more I can do.&n;&t;&t;&t; * XXX If we have a loaded bus we&squot;re going to&n;&t;&t;&t; * XXX spend the next second or so renegotiating&n;&t;&t;&t; * XXX for synchronous transfers.&n;&t;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: STEP_ASEL for tgt %d&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|SCptr-&gt;target
)paren
)paren
suffix:semicolon
r_case
id|ESP_STEP_SID
suffix:colon
multiline_comment|/* Arbitration won, target selected, went&n;&t;&t;&t; * to message out phase, sent one message&n;&t;&t;&t; * byte, then we stopped.  ATN is asserted&n;&t;&t;&t; * on the SCSI bus and the target is still&n;&t;&t;&t; * there hanging on.  This is a legal&n;&t;&t;&t; * sequence step if we gave the ESP a select&n;&t;&t;&t; * and stop command.&n;&t;&t;&t; *&n;&t;&t;&t; * XXX See above, I could set the borken flag&n;&t;&t;&t; * XXX in the device struct and retry the&n;&t;&t;&t; * XXX command.  But would that help for&n;&t;&t;&t; * XXX tagged capable targets?&n;&t;&t;&t; */
r_case
id|ESP_STEP_NCMD
suffix:colon
multiline_comment|/* Arbitration won, target selected, maybe&n;&t;&t;&t; * sent the one message byte in message out&n;&t;&t;&t; * phase, but we did not go to command phase&n;&t;&t;&t; * in the end.  Actually, we could have sent&n;&t;&t;&t; * only some of the message bytes if we tried&n;&t;&t;&t; * to send out the entire identify and tag&n;&t;&t;&t; * message using ESP_CMD_SA3.&n;&t;&t;&t; */
id|cmd_bytes_sent
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ESP_STEP_PPC
suffix:colon
multiline_comment|/* No, not the powerPC pinhead.  Arbitration&n;&t;&t;&t; * won, all message bytes sent if we went to&n;&t;&t;&t; * message out phase, went to command phase&n;&t;&t;&t; * but only part of the command was sent.&n;&t;&t;&t; *&n;&t;&t;&t; * XXX I&squot;ve seen this, but usually in conjunction&n;&t;&t;&t; * XXX with a gross error which appears to have&n;&t;&t;&t; * XXX occurred between the time I told the&n;&t;&t;&t; * XXX ESP to arbitrate and when I got the&n;&t;&t;&t; * XXX interrupt.  Could I have misloaded the&n;&t;&t;&t; * XXX command bytes into the fifo?  Actually,&n;&t;&t;&t; * XXX I most likely missed a phase, and therefore&n;&t;&t;&t; * XXX went into never never land and didn&squot;t even&n;&t;&t;&t; * XXX know it.  That was the old driver though.&n;&t;&t;&t; * XXX What is even more peculiar is that the ESP&n;&t;&t;&t; * XXX showed the proper function complete and&n;&t;&t;&t; * XXX bus service bits in the interrupt register.&n;&t;&t;&t; */
r_case
id|ESP_STEP_FINI4
suffix:colon
r_case
id|ESP_STEP_FINI5
suffix:colon
r_case
id|ESP_STEP_FINI6
suffix:colon
r_case
id|ESP_STEP_FINI7
suffix:colon
multiline_comment|/* Account for the identify message */
r_if
c_cond
(paren
id|SCptr-&gt;SCp.phase
op_eq
id|in_slct_norm
)paren
id|cmd_bytes_sent
op_sub_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_ne
id|fashme
)paren
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_NULL
)paren
suffix:semicolon
multiline_comment|/* Be careful, we could really get fucked during synchronous&n;&t;&t; * data transfers if we try to flush the fifo now.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|esp-&gt;erev
op_ne
id|fashme
)paren
op_logical_and
multiline_comment|/* not a Happy Meal and... */
op_logical_neg
id|fcnt
op_logical_and
multiline_comment|/* Fifo is empty and... */
multiline_comment|/* either we are not doing synchronous transfers or... */
(paren
op_logical_neg
id|SDptr-&gt;sync_max_offset
op_logical_or
multiline_comment|/* We are not going into data in phase. */
(paren
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PMASK
)paren
op_ne
id|ESP_DIP
)paren
)paren
)paren
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
multiline_comment|/* flush is safe */
multiline_comment|/* See how far we got if this is not a slow command. */
r_if
c_cond
(paren
op_logical_neg
id|esp-&gt;esp_slowcmd
)paren
(brace
r_if
c_cond
(paren
id|cmd_bytes_sent
OL
l_int|0
)paren
id|cmd_bytes_sent
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cmd_bytes_sent
op_ne
id|SCptr-&gt;cmd_len
)paren
(brace
multiline_comment|/* Crapola, mark it as a slowcmd&n;&t;&t;&t;&t; * so that we have some chance of&n;&t;&t;&t;&t; * keeping the command alive with&n;&t;&t;&t;&t; * good luck.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * XXX Actually, if we didn&squot;t send it all&n;&t;&t;&t;&t; * XXX this means either we didn&squot;t set things&n;&t;&t;&t;&t; * XXX up properly (driver bug) or the target&n;&t;&t;&t;&t; * XXX or the ESP detected parity on one of&n;&t;&t;&t;&t; * XXX the command bytes.  This makes much&n;&t;&t;&t;&t; * XXX more sense, and therefore this code&n;&t;&t;&t;&t; * XXX should be changed to send out a&n;&t;&t;&t;&t; * XXX parity error message or if the status&n;&t;&t;&t;&t; * XXX register shows no parity error then&n;&t;&t;&t;&t; * XXX just expect the target to bring the&n;&t;&t;&t;&t; * XXX bus into message in phase so that it&n;&t;&t;&t;&t; * XXX can send us the parity error message.&n;&t;&t;&t;&t; * XXX SCSI sucks...&n;&t;&t;&t;&t; */
id|esp-&gt;esp_slowcmd
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;esp_scmdp
op_assign
op_amp
(paren
id|SCptr-&gt;cmnd
(braket
id|cmd_bytes_sent
)braket
)paren
suffix:semicolon
id|esp-&gt;esp_scmdleft
op_assign
(paren
id|SCptr-&gt;cmd_len
op_minus
id|cmd_bytes_sent
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Now figure out where we went. */
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|esp_do_phase_determine
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
multiline_comment|/* Did the target even make it? */
r_if
c_cond
(paren
id|esp-&gt;ireg
op_eq
id|ESP_INTR_DC
)paren
(brace
multiline_comment|/* wheee... nobody there or they didn&squot;t like&n;&t;&t; * what we told it to do, clean up.&n;&t;&t; */
multiline_comment|/* If anyone is off the bus, but working on&n;&t;&t; * a command in the background for us, tell&n;&t;&t; * the ESP to listen for them.&n;&t;&t; */
r_if
c_cond
(paren
id|esp-&gt;disconnected_SC
)paren
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_ESEL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
l_int|1
op_lshift
id|SCptr-&gt;target
)paren
op_amp
id|esp-&gt;targets_present
)paren
op_logical_and
id|esp-&gt;seqreg
op_ne
l_int|0
op_logical_and
(paren
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
op_eq
id|EXTENDED_MESSAGE
)paren
op_logical_and
(paren
id|SCptr-&gt;SCp.phase
op_eq
id|in_slct_msg
op_logical_or
id|SCptr-&gt;SCp.phase
op_eq
id|in_slct_stop
)paren
)paren
(brace
multiline_comment|/* shit */
id|esp-&gt;snip
op_assign
l_int|0
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Failed synchronous negotiation for target %d &quot;
l_string|&quot;lun %d&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|SCptr-&gt;target
comma
id|SCptr-&gt;lun
)paren
)paren
suffix:semicolon
id|SDptr-&gt;sync_max_offset
op_assign
l_int|0
suffix:semicolon
id|SDptr-&gt;sync_min_period
op_assign
l_int|0
suffix:semicolon
id|SDptr-&gt;sync
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* so we don&squot;t negotiate again */
multiline_comment|/* Run the command again, this time though we&n;&t;&t;&t; * won&squot;t try to negotiate for synchronous transfers.&n;&t;&t;&t; *&n;&t;&t;&t; * XXX I&squot;d like to do something like send an&n;&t;&t;&t; * XXX INITIATOR_ERROR or ABORT message to the&n;&t;&t;&t; * XXX target to tell it, &quot;Sorry I confused you,&n;&t;&t;&t; * XXX please come back and I will be nicer next&n;&t;&t;&t; * XXX time&quot;.  But that requires having the target&n;&t;&t;&t; * XXX on the bus, and it has dropped BSY on us.&n;&t;&t;&t; */
id|esp-&gt;current_SC
op_assign
l_int|NULL
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|not_issued
)paren
suffix:semicolon
id|prepend_SC
c_func
(paren
op_amp
id|esp-&gt;issue_SC
comma
id|SCptr
)paren
suffix:semicolon
id|esp_exec_cmd
c_func
(paren
id|esp
)paren
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
multiline_comment|/* Ok, this is normal, this is what we see during boot&n;&t;&t; * or whenever when we are scanning the bus for targets.&n;&t;&t; * But first make sure that is really what is happening.&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
l_int|1
op_lshift
id|SCptr-&gt;target
)paren
op_amp
id|esp-&gt;targets_present
)paren
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Warning, live target %d not responding to &quot;
l_string|&quot;selection.&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|SCptr-&gt;target
)paren
)paren
suffix:semicolon
multiline_comment|/* This _CAN_ happen.  The SCSI standard states that&n;&t;&t;&t; * the target is to _not_ respond to selection if&n;&t;&t;&t; * _it_ detects bad parity on the bus for any reason.&n;&t;&t;&t; * Therefore, we assume that if we&squot;ve talked successfully&n;&t;&t;&t; * to this target before, bad parity is the problem.&n;&t;&t;&t; */
id|esp_done
c_func
(paren
id|esp
comma
(paren
id|DID_PARITY
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Else, there really isn&squot;t anyone there. */
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;esp: selection failure, maybe nobody there?&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;esp: target %d lun %d&bslash;n&quot;
comma
id|SCptr-&gt;target
comma
id|SCptr-&gt;lun
)paren
)paren
suffix:semicolon
id|esp_done
c_func
(paren
id|esp
comma
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
)brace
r_return
id|do_intr_end
suffix:semicolon
)brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Selection failure.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;esp%d: Currently -- &quot;
comma
id|esp-&gt;esp_id
)paren
suffix:semicolon
id|esp_print_ireg
c_func
(paren
id|esp-&gt;ireg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|esp_print_statreg
c_func
(paren
id|esp-&gt;sreg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|esp_print_seqreg
c_func
(paren
id|esp-&gt;seqreg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;esp%d: New -- &quot;
comma
id|esp-&gt;esp_id
)paren
suffix:semicolon
id|esp-&gt;sreg
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_STATUS
)paren
suffix:semicolon
id|esp-&gt;seqreg
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_SSTEP
)paren
suffix:semicolon
id|esp-&gt;ireg
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_INTRPT
)paren
suffix:semicolon
id|esp_print_ireg
c_func
(paren
id|esp-&gt;ireg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|esp_print_statreg
c_func
(paren
id|esp-&gt;sreg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|esp_print_seqreg
c_func
(paren
id|esp-&gt;seqreg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: resetting bus&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
multiline_comment|/* ugh... */
)brace
multiline_comment|/* Continue reading bytes for msgin phase. */
DECL|function|esp_do_msgincont
r_static
r_int
id|esp_do_msgincont
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_BSERV
)paren
(brace
multiline_comment|/* in the right phase too? */
r_if
c_cond
(paren
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PMASK
)paren
op_eq
id|ESP_MIP
)paren
(brace
multiline_comment|/* phew... */
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_msgindone
)paren
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
multiline_comment|/* We changed phase but ESP shows bus service,&n;&t;&t; * in this case it is most likely that we, the&n;&t;&t; * hacker who has been up for 20hrs straight&n;&t;&t; * staring at the screen, drowned in coffee&n;&t;&t; * smelling like retched cigarette ashes&n;&t;&t; * have miscoded something..... so, try to&n;&t;&t; * recover as best we can.&n;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: message in mis-carriage.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
)brace
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|do_phase_determine
suffix:semicolon
)brace
DECL|function|check_singlebyte_msg
r_static
r_int
id|check_singlebyte_msg
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|esp-&gt;prevmsgin
op_assign
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
(brace
multiline_comment|/* wheee... */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: target sends identify amidst phases&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
op_logical_or
(paren
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
op_eq
id|EXTENDED_MESSAGE
)paren
)paren
(brace
id|esp-&gt;msgin_len
op_assign
l_int|2
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_msgincont
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_the_dark
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
)paren
(brace
r_default
suffix:colon
multiline_comment|/* We don&squot;t want to hear about it. */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: msg %02x which we don&squot;t know about&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_return
id|MESSAGE_REJECT
suffix:semicolon
r_case
id|NOP
suffix:colon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: target %d sends a nop&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;current_SC-&gt;target
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|RESTORE_POINTERS
suffix:colon
multiline_comment|/* In this case we might also have to backup the&n;&t;&t; * &quot;slow command&quot; pointer.  It is rare to get such&n;&t;&t; * a save/restore pointer sequence so early in the&n;&t;&t; * bus transition sequences, but cover it.&n;&t;&t; */
r_if
c_cond
(paren
id|esp-&gt;esp_slowcmd
)paren
(brace
id|esp-&gt;esp_scmdleft
op_assign
id|esp-&gt;current_SC-&gt;cmd_len
suffix:semicolon
id|esp-&gt;esp_scmdp
op_assign
op_amp
id|esp-&gt;current_SC-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|esp_restore_pointers
c_func
(paren
id|esp
comma
id|esp-&gt;current_SC
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SAVE_POINTERS
suffix:colon
id|esp_save_pointers
c_func
(paren
id|esp
comma
id|esp-&gt;current_SC
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|COMMAND_COMPLETE
suffix:colon
r_case
id|DISCONNECT
suffix:colon
multiline_comment|/* Freeing the bus, let it go. */
id|esp-&gt;current_SC-&gt;SCp.phase
op_assign
id|in_freeing
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|MESSAGE_REJECT
suffix:colon
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;msg reject, &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;prevmsgout
op_eq
id|EXTENDED_MESSAGE
)paren
(brace
id|Scsi_Device
op_star
id|SDptr
op_assign
id|esp-&gt;current_SC-&gt;device
suffix:semicolon
multiline_comment|/* Doesn&squot;t look like this target can&n;&t;&t;&t; * do synchronous or WIDE transfers.&n;&t;&t;&t; */
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;got reject, was trying nego, clearing sync/WIDE&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|SDptr-&gt;sync
op_assign
l_int|1
suffix:semicolon
id|SDptr-&gt;wide
op_assign
l_int|1
suffix:semicolon
id|SDptr-&gt;sync_min_period
op_assign
l_int|0
suffix:semicolon
id|SDptr-&gt;sync_max_offset
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;not sync nego, sending ABORT&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|ABORT
suffix:semicolon
)brace
)brace
suffix:semicolon
)brace
multiline_comment|/* Target negotiates for synchronous transfers before we do, this&n; * is legal although very strange.  What is even funnier is that&n; * the SCSI2 standard specifically recommends against targets doing&n; * this because so many initiators cannot cope with this occuring.&n; */
DECL|function|target_with_ants_in_pants
r_static
r_int
id|target_with_ants_in_pants
c_func
(paren
r_struct
id|esp
op_star
id|esp
comma
id|Scsi_Cmnd
op_star
id|SCptr
comma
id|Scsi_Device
op_star
id|SDptr
)paren
(brace
r_if
c_cond
(paren
id|SDptr-&gt;sync
op_logical_or
id|SDptr-&gt;borken
)paren
(brace
multiline_comment|/* sorry, no can do */
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;forcing to async, &quot;
)paren
)paren
suffix:semicolon
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|SDptr-&gt;sync
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|1
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: hoping for msgout&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|EXTENDED_MESSAGE
suffix:semicolon
)brace
multiline_comment|/* Ok, we&squot;ll check them out... */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sync_report
r_static
r_void
id|sync_report
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
r_int
id|msg3
comma
id|msg4
suffix:semicolon
r_char
op_star
id|type
suffix:semicolon
id|msg3
op_assign
id|esp-&gt;cur_msgin
(braket
l_int|3
)braket
suffix:semicolon
id|msg4
op_assign
id|esp-&gt;cur_msgin
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|msg4
)paren
(brace
r_int
id|hz
op_assign
l_int|1000000000
op_div
(paren
id|msg3
op_star
l_int|4
)paren
suffix:semicolon
r_int
id|integer
op_assign
id|hz
op_div
l_int|1000000
suffix:semicolon
r_int
id|fraction
op_assign
(paren
id|hz
op_minus
(paren
id|integer
op_star
l_int|1000000
)paren
)paren
op_div
l_int|10000
suffix:semicolon
r_if
c_cond
(paren
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
op_logical_and
(paren
id|esp-&gt;config3
(braket
id|esp-&gt;current_SC-&gt;target
)braket
op_amp
id|ESP_CONFIG3_EWIDE
)paren
)paren
(brace
id|type
op_assign
l_string|&quot;FAST-WIDE&quot;
suffix:semicolon
id|integer
op_lshift_assign
l_int|1
suffix:semicolon
id|fraction
op_lshift_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|msg3
op_star
l_int|4
)paren
OL
l_int|200
)paren
(brace
id|type
op_assign
l_string|&quot;FAST&quot;
suffix:semicolon
)brace
r_else
(brace
id|type
op_assign
l_string|&quot;synchronous&quot;
suffix:semicolon
)brace
multiline_comment|/* Do not transform this back into one big printk&n;&t;&t; * again, it triggers a bug in our sparc64-gcc272&n;&t;&t; * sibling call optimization.  -DaveM&n;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
id|KERN_INFO
l_string|&quot;esp%d: target %d &quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;current_SC-&gt;target
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;[period %dns offset %d %d.%02dMHz &quot;
comma
(paren
r_int
)paren
id|msg3
op_star
l_int|4
comma
(paren
r_int
)paren
id|msg4
comma
id|integer
comma
id|fraction
)paren
)paren
suffix:semicolon
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;%s SCSI%s]&bslash;n&quot;
comma
id|type
comma
(paren
(paren
(paren
id|msg3
op_star
l_int|4
)paren
OL
l_int|200
)paren
ques
c_cond
l_string|&quot;-II&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ESPLOG
c_func
(paren
(paren
id|KERN_INFO
l_string|&quot;esp%d: target %d asynchronous&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;current_SC-&gt;target
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|check_multibyte_msg
r_static
r_int
id|check_multibyte_msg
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
id|Scsi_Device
op_star
id|SDptr
op_assign
id|SCptr-&gt;device
suffix:semicolon
id|u8
id|regval
op_assign
l_int|0
suffix:semicolon
r_int
id|message_out
op_assign
l_int|0
suffix:semicolon
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;chk multibyte msg: &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;cur_msgin
(braket
l_int|2
)braket
op_eq
id|EXTENDED_SDTR
)paren
(brace
r_int
id|period
op_assign
id|esp-&gt;cur_msgin
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|offset
op_assign
id|esp-&gt;cur_msgin
(braket
l_int|4
)braket
suffix:semicolon
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;is sync nego response, &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|esp-&gt;snip
)paren
(brace
r_int
id|rval
suffix:semicolon
multiline_comment|/* Target negotiates first! */
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;target jumps the gun, &quot;
)paren
)paren
suffix:semicolon
id|message_out
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
multiline_comment|/* we must respond */
id|rval
op_assign
id|target_with_ants_in_pants
c_func
(paren
id|esp
comma
id|SCptr
comma
id|SDptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
)paren
r_return
id|rval
suffix:semicolon
)brace
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;examining sdtr, &quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Offset cannot be larger than ESP fifo size. */
r_if
c_cond
(paren
id|offset
OG
l_int|15
)paren
(brace
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;offset too big %2x, &quot;
comma
id|offset
)paren
)paren
suffix:semicolon
id|offset
op_assign
l_int|15
suffix:semicolon
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;sending back new offset&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
id|period
comma
id|offset
)paren
suffix:semicolon
r_return
id|EXTENDED_MESSAGE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
op_logical_and
id|period
OG
id|esp-&gt;max_period
)paren
(brace
multiline_comment|/* Yeee, async for this slow device. */
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;period too long %2x, &quot;
comma
id|period
)paren
)paren
suffix:semicolon
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;hoping for msgout&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|EXTENDED_MESSAGE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|offset
op_logical_and
id|period
OL
id|esp-&gt;min_period
)paren
(brace
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;period too short %2x, &quot;
comma
id|period
)paren
)paren
suffix:semicolon
id|period
op_assign
id|esp-&gt;min_period
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
OG
id|esp236
)paren
id|regval
op_assign
l_int|4
suffix:semicolon
r_else
id|regval
op_assign
l_int|5
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|offset
)paren
(brace
r_int
id|tmp
suffix:semicolon
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;period is ok, &quot;
)paren
)paren
suffix:semicolon
id|tmp
op_assign
id|esp-&gt;ccycle
op_div
l_int|1000
suffix:semicolon
id|regval
op_assign
(paren
(paren
(paren
id|period
op_lshift
l_int|2
)paren
op_plus
id|tmp
op_minus
l_int|1
)paren
op_div
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regval
op_logical_and
(paren
(paren
id|esp-&gt;erev
op_eq
id|fas100a
op_logical_or
id|esp-&gt;erev
op_eq
id|fas236
op_logical_or
id|esp-&gt;erev
op_eq
id|fashme
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|period
op_ge
l_int|50
)paren
id|regval
op_decrement
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|offset
)paren
(brace
id|u8
id|bit
suffix:semicolon
id|SDptr-&gt;sync_min_period
op_assign
(paren
id|regval
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|SDptr-&gt;sync_max_offset
op_assign
(paren
id|offset
op_or
id|esp-&gt;radelay
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fas100a
op_logical_or
id|esp-&gt;erev
op_eq
id|fas236
op_logical_or
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
r_if
c_cond
(paren
(paren
id|esp-&gt;erev
op_eq
id|fas100a
)paren
op_logical_or
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
)paren
id|bit
op_assign
id|ESP_CONFIG3_FAST
suffix:semicolon
r_else
id|bit
op_assign
id|ESP_CONFIG3_FSCSI
suffix:semicolon
r_if
c_cond
(paren
id|period
OL
l_int|50
)paren
(brace
multiline_comment|/* On FAS366, if using fast-20 synchronous transfers&n;&t;&t;&t;&t;&t; * we need to make sure the REQ/ACK assert/deassert&n;&t;&t;&t;&t;&t; * control bits are clear.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
id|SDptr-&gt;sync_max_offset
op_and_assign
op_complement
id|esp-&gt;radelay
suffix:semicolon
id|esp-&gt;config3
(braket
id|SCptr-&gt;target
)braket
op_or_assign
id|bit
suffix:semicolon
)brace
r_else
(brace
id|esp-&gt;config3
(braket
id|SCptr-&gt;target
)braket
op_and_assign
op_complement
id|bit
suffix:semicolon
)brace
id|esp-&gt;prev_cfg3
op_assign
id|esp-&gt;config3
(braket
id|SCptr-&gt;target
)braket
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_cfg3
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG3
)paren
suffix:semicolon
)brace
id|esp-&gt;prev_soff
op_assign
id|SDptr-&gt;sync_max_offset
suffix:semicolon
id|esp-&gt;prev_stp
op_assign
id|SDptr-&gt;sync_min_period
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_soff
comma
id|esp-&gt;eregs
op_plus
id|ESP_SOFF
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_stp
comma
id|esp-&gt;eregs
op_plus
id|ESP_STP
)paren
suffix:semicolon
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;soff=%2x stp=%2x cfg3=%2x&bslash;n&quot;
comma
id|SDptr-&gt;sync_max_offset
comma
id|SDptr-&gt;sync_min_period
comma
id|esp-&gt;config3
(braket
id|SCptr-&gt;target
)braket
)paren
)paren
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SDptr-&gt;sync_max_offset
)paren
(brace
id|u8
id|bit
suffix:semicolon
multiline_comment|/* back to async mode */
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;unaccaptable sync nego, forcing async&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|SDptr-&gt;sync_max_offset
op_assign
l_int|0
suffix:semicolon
id|SDptr-&gt;sync_min_period
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;prev_soff
op_assign
l_int|0
suffix:semicolon
id|esp-&gt;prev_stp
op_assign
l_int|0
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_soff
comma
id|esp-&gt;eregs
op_plus
id|ESP_SOFF
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_stp
comma
id|esp-&gt;eregs
op_plus
id|ESP_STP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fas100a
op_logical_or
id|esp-&gt;erev
op_eq
id|fas236
op_logical_or
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
r_if
c_cond
(paren
(paren
id|esp-&gt;erev
op_eq
id|fas100a
)paren
op_logical_or
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
)paren
id|bit
op_assign
id|ESP_CONFIG3_FAST
suffix:semicolon
r_else
id|bit
op_assign
id|ESP_CONFIG3_FSCSI
suffix:semicolon
id|esp-&gt;config3
(braket
id|SCptr-&gt;target
)braket
op_and_assign
op_complement
id|bit
suffix:semicolon
id|esp-&gt;prev_cfg3
op_assign
id|esp-&gt;config3
(braket
id|SCptr-&gt;target
)braket
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_cfg3
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG3
)paren
suffix:semicolon
)brace
)brace
id|sync_report
c_func
(paren
id|esp
)paren
suffix:semicolon
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;chk multibyte msg: sync is known, &quot;
)paren
)paren
suffix:semicolon
id|SDptr-&gt;sync
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|message_out
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: sending sdtr back, hoping for msgout&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
id|period
comma
id|offset
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|EXTENDED_MESSAGE
suffix:semicolon
)brace
id|ESPSDTR
c_func
(paren
(paren
l_string|&quot;returning zero&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
multiline_comment|/* ...or else! */
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;cur_msgin
(braket
l_int|2
)braket
op_eq
id|EXTENDED_WDTR
)paren
(brace
r_int
id|size
op_assign
l_int|8
op_lshift
id|esp-&gt;cur_msgin
(braket
l_int|3
)braket
suffix:semicolon
id|esp-&gt;wnip
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_ne
id|fashme
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: AIEEE wide msg received and not HME.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|message_out
op_assign
id|MESSAGE_REJECT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|size
OG
l_int|16
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: AIEEE wide transfer for %d size &quot;
l_string|&quot;not supported.&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|size
)paren
)paren
suffix:semicolon
id|message_out
op_assign
id|MESSAGE_REJECT
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Things look good; let&squot;s see what we got. */
r_if
c_cond
(paren
id|size
op_eq
l_int|16
)paren
(brace
multiline_comment|/* Set config 3 register for this target. */
id|esp-&gt;config3
(braket
id|SCptr-&gt;target
)braket
op_or_assign
id|ESP_CONFIG3_EWIDE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Just make sure it was one byte sized. */
r_if
c_cond
(paren
id|size
op_ne
l_int|8
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Aieee, wide nego of %d size.&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|size
)paren
)paren
suffix:semicolon
id|message_out
op_assign
id|MESSAGE_REJECT
suffix:semicolon
r_goto
id|finish
suffix:semicolon
)brace
multiline_comment|/* Pure paranoia. */
id|esp-&gt;config3
(braket
id|SCptr-&gt;target
)braket
op_and_assign
op_complement
(paren
id|ESP_CONFIG3_EWIDE
)paren
suffix:semicolon
)brace
id|esp-&gt;prev_cfg3
op_assign
id|esp-&gt;config3
(braket
id|SCptr-&gt;target
)braket
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|esp-&gt;prev_cfg3
comma
id|esp-&gt;eregs
op_plus
id|ESP_CFG3
)paren
suffix:semicolon
multiline_comment|/* Regardless, next try for sync transfers. */
id|build_sync_nego_msg
c_func
(paren
id|esp
comma
id|esp-&gt;sync_defp
comma
l_int|15
)paren
suffix:semicolon
id|SDptr-&gt;sync
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|1
suffix:semicolon
id|message_out
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;cur_msgin
(braket
l_int|2
)braket
op_eq
id|EXTENDED_MODIFY_DATA_POINTER
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: rejecting modify data ptr msg&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|message_out
op_assign
id|MESSAGE_REJECT
suffix:semicolon
)brace
id|finish
suffix:colon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|message_out
suffix:semicolon
)brace
DECL|function|esp_do_msgindone
r_static
r_int
id|esp_do_msgindone
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
r_int
id|message_out
op_assign
l_int|0
comma
id|it
op_assign
l_int|0
comma
id|rval
suffix:semicolon
id|rval
op_assign
id|skipahead1
c_func
(paren
id|esp
comma
id|SCptr
comma
id|in_msgin
comma
id|in_msgindone
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
)paren
r_return
id|rval
suffix:semicolon
r_if
c_cond
(paren
id|SCptr-&gt;SCp.sent_command
op_ne
id|in_status
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_DC
)paren
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;msgin_len
op_logical_and
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PERR
)paren
)paren
(brace
id|message_out
op_assign
id|MSG_PARITY_ERROR
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;erev
op_ne
id|fashme
op_logical_and
(paren
id|it
op_assign
(paren
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_FFLAGS
)paren
op_amp
id|ESP_FF_FBYTES
)paren
)paren
op_ne
l_int|1
)paren
(brace
multiline_comment|/* We certainly dropped the ball somewhere. */
id|message_out
op_assign
id|INITIATOR_ERROR
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|esp-&gt;msgin_len
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
id|it
op_assign
id|esp-&gt;hme_fifo_workaround_buffer
(braket
l_int|0
)braket
suffix:semicolon
r_else
id|it
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_FDATA
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_msgincont
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* it is ok and we want it */
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
id|it
op_assign
id|esp-&gt;cur_msgin
(braket
id|esp-&gt;msgin_ctr
)braket
op_assign
id|esp-&gt;hme_fifo_workaround_buffer
(braket
l_int|0
)braket
suffix:semicolon
r_else
id|it
op_assign
id|esp-&gt;cur_msgin
(braket
id|esp-&gt;msgin_ctr
)braket
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_FDATA
)paren
suffix:semicolon
id|esp-&gt;msgin_ctr
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|do_work_bus
suffix:semicolon
)brace
)brace
r_else
(brace
id|it
op_assign
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|message_out
op_logical_and
id|esp-&gt;msgin_len
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;msgin_ctr
OL
id|esp-&gt;msgin_len
)paren
(brace
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_msgincont
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;msgin_len
op_eq
l_int|1
)paren
(brace
id|message_out
op_assign
id|check_singlebyte_msg
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;msgin_len
op_eq
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;cur_msgin
(braket
l_int|0
)braket
op_eq
id|EXTENDED_MESSAGE
)paren
(brace
r_if
c_cond
(paren
(paren
id|it
op_plus
l_int|2
)paren
op_ge
l_int|15
)paren
(brace
id|message_out
op_assign
id|MESSAGE_REJECT
suffix:semicolon
)brace
r_else
(brace
id|esp-&gt;msgin_len
op_assign
(paren
id|it
op_plus
l_int|2
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_msgincont
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|message_out
op_assign
id|MESSAGE_REJECT
suffix:semicolon
multiline_comment|/* foo on you */
)brace
)brace
r_else
(brace
id|message_out
op_assign
id|check_multibyte_msg
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|message_out
OL
l_int|0
)paren
(brace
r_return
op_minus
id|message_out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|message_out
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|message_out
op_ne
l_int|1
)paren
op_logical_and
(paren
(paren
id|message_out
OL
l_int|0x20
)paren
op_logical_or
(paren
id|message_out
op_amp
l_int|0x80
)paren
)paren
)paren
)paren
id|esp-&gt;msgout_len
op_assign
l_int|1
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
op_assign
id|message_out
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_SATN
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_the_dark
)paren
suffix:semicolon
id|esp-&gt;msgin_len
op_assign
l_int|0
suffix:semicolon
)brace
id|esp-&gt;sreg
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_STATUS
)paren
suffix:semicolon
id|esp-&gt;sreg
op_and_assign
op_complement
(paren
id|ESP_STAT_INTR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|esp-&gt;sreg
op_amp
(paren
id|ESP_STAT_PMSG
op_or
id|ESP_STAT_PCD
)paren
)paren
op_eq
(paren
id|ESP_STAT_PMSG
op_or
id|ESP_STAT_PCD
)paren
)paren
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_MOK
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|SCptr-&gt;SCp.sent_command
op_eq
id|in_msgindone
)paren
op_logical_and
(paren
id|SCptr-&gt;SCp.phase
op_eq
id|in_freeing
)paren
)paren
r_return
id|esp_do_freebus
c_func
(paren
id|esp
)paren
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
DECL|function|esp_do_cmdbegin
r_static
r_int
id|esp_do_cmdbegin
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|SCptr
comma
id|in_cmdend
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
id|u32
id|tmp
op_assign
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|esp-&gt;esp_scmdleft
suffix:semicolon
id|i
op_increment
)paren
id|esp-&gt;esp_command
(braket
id|i
)braket
op_assign
op_star
id|esp-&gt;esp_scmdp
op_increment
suffix:semicolon
id|esp-&gt;esp_scmdleft
op_assign
l_int|0
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
id|esp_setcount
c_func
(paren
id|esp-&gt;eregs
comma
id|i
comma
l_int|1
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
(paren
id|ESP_CMD_DMA
op_or
id|ESP_CMD_TI
)paren
)paren
suffix:semicolon
id|tmp
op_or_assign
(paren
id|DMA_SCSI_DISAB
op_or
id|DMA_ENABLE
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
(paren
id|DMA_ST_WRITE
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|i
comma
id|esp-&gt;dregs
op_plus
id|DMA_COUNT
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|esp-&gt;esp_command_dvma
comma
id|esp-&gt;dregs
op_plus
id|DMA_ADDR
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|tmp
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
)brace
r_else
(brace
id|u8
id|tmp
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
id|tmp
op_assign
op_star
id|esp-&gt;esp_scmdp
op_increment
suffix:semicolon
id|esp-&gt;esp_scmdleft
op_decrement
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|tmp
comma
id|esp-&gt;eregs
op_plus
id|ESP_FDATA
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
)brace
r_return
id|do_intr_end
suffix:semicolon
)brace
DECL|function|esp_do_cmddone
r_static
r_int
id|esp_do_cmddone
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
id|dma_invalidate
c_func
(paren
id|esp
)paren
suffix:semicolon
r_else
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_BSERV
)paren
(brace
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|esp_do_phase_determine
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: in do_cmddone() but didn&squot;t get BSERV interrupt.&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
)brace
DECL|function|esp_do_msgout
r_static
r_int
id|esp_do_msgout
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|esp-&gt;msgout_len
)paren
(brace
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
id|hme_fifo_push
c_func
(paren
id|esp
comma
op_amp
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
comma
l_int|1
)paren
suffix:semicolon
r_else
id|sbus_writeb
c_func
(paren
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
comma
id|esp-&gt;eregs
op_plus
id|ESP_FDATA
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|esp-&gt;esp_command
(braket
l_int|0
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|1
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
id|hme_fifo_push
c_func
(paren
id|esp
comma
op_amp
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
comma
l_int|2
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
)brace
r_else
(brace
id|dma_setup
c_func
(paren
id|esp
comma
id|esp-&gt;esp_command_dvma
comma
l_int|2
comma
l_int|0
)paren
suffix:semicolon
id|esp_setcount
c_func
(paren
id|esp-&gt;eregs
comma
l_int|2
comma
l_int|0
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_DMA
op_or
id|ESP_CMD_TI
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|esp-&gt;esp_command
(braket
l_int|0
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|1
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|1
)braket
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|2
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|2
)braket
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|3
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|3
)braket
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
id|hme_fifo_push
c_func
(paren
id|esp
comma
op_amp
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
comma
l_int|4
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
)brace
r_else
(brace
id|dma_setup
c_func
(paren
id|esp
comma
id|esp-&gt;esp_command_dvma
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|esp_setcount
c_func
(paren
id|esp-&gt;eregs
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_DMA
op_or
id|ESP_CMD_TI
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|esp-&gt;esp_command
(braket
l_int|0
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|1
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|1
)braket
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|2
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|2
)braket
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|3
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|3
)braket
suffix:semicolon
id|esp-&gt;esp_command
(braket
l_int|4
)braket
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|4
)braket
suffix:semicolon
id|esp-&gt;snip
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
id|hme_fifo_push
c_func
(paren
id|esp
comma
op_amp
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
comma
l_int|5
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
)brace
r_else
(brace
id|dma_setup
c_func
(paren
id|esp
comma
id|esp-&gt;esp_command_dvma
comma
l_int|5
comma
l_int|0
)paren
suffix:semicolon
id|esp_setcount
c_func
(paren
id|esp-&gt;eregs
comma
l_int|5
comma
l_int|0
)paren
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_DMA
op_or
id|ESP_CMD_TI
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* whoops */
id|ESPMISC
c_func
(paren
(paren
l_string|&quot;bogus msgout sending NOP&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
op_assign
id|NOP
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
id|hme_fifo_push
c_func
(paren
id|esp
comma
op_amp
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|sbus_writeb
c_func
(paren
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
comma
id|esp-&gt;eregs
op_plus
id|ESP_FDATA
)paren
suffix:semicolon
)brace
id|esp-&gt;msgout_len
op_assign
l_int|1
suffix:semicolon
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_TI
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_msgoutdone
)paren
suffix:semicolon
r_return
id|do_intr_end
suffix:semicolon
)brace
DECL|function|esp_do_msgoutdone
r_static
r_int
id|esp_do_msgoutdone
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;msgout_len
OG
l_int|1
)paren
(brace
multiline_comment|/* XXX HME/FAS ATN deassert workaround required,&n;&t;&t; * XXX no DMA flushing, only possible ESP_CMD_FLUSH&n;&t;&t; * XXX to kill the fifo.&n;&t;&t; */
r_if
c_cond
(paren
id|esp-&gt;erev
op_ne
id|fashme
)paren
(brace
id|u32
id|tmp
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
)paren
op_amp
id|DMA_PEND_READ
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|DMA_ENABLE
suffix:semicolon
id|sbus_writel
c_func
(paren
id|tmp
comma
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
suffix:semicolon
id|dma_invalidate
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_else
(brace
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_DC
)paren
)paren
(brace
r_if
c_cond
(paren
id|esp-&gt;erev
op_ne
id|fashme
)paren
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_NULL
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|esp-&gt;sreg
op_amp
id|ESP_STAT_PMASK
)paren
(brace
r_case
id|ESP_MOP
suffix:colon
multiline_comment|/* whoops, parity error */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: still in msgout, parity error assumed&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;msgout_len
OG
l_int|1
)paren
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_SATN
)paren
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_msgout
)paren
suffix:semicolon
r_return
id|do_work_bus
suffix:semicolon
r_case
id|ESP_DIP
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* Happy Meal fifo is touchy... */
r_if
c_cond
(paren
(paren
id|esp-&gt;erev
op_ne
id|fashme
)paren
op_logical_and
op_logical_neg
id|fcount
c_func
(paren
id|esp
)paren
op_logical_and
op_logical_neg
(paren
id|esp-&gt;current_SC-&gt;device-&gt;sync_max_offset
)paren
)paren
id|esp_cmd
c_func
(paren
id|esp
comma
id|ESP_CMD_FLUSH
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
r_else
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: disconnect, resetting bus&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
)brace
multiline_comment|/* If we sent out a synchronous negotiation message, update&n;&t; * our state.&n;&t; */
r_if
c_cond
(paren
id|esp-&gt;cur_msgout
(braket
l_int|2
)braket
op_eq
id|EXTENDED_MESSAGE
op_logical_and
id|esp-&gt;cur_msgout
(braket
l_int|4
)braket
op_eq
id|EXTENDED_SDTR
)paren
(brace
id|esp-&gt;snip
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* anal retentiveness... */
)brace
id|esp-&gt;prevmsgout
op_assign
id|esp-&gt;cur_msgout
(braket
l_int|0
)braket
suffix:semicolon
id|esp-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|esp_advance_phase
c_func
(paren
id|esp-&gt;current_SC
comma
id|in_the_dark
)paren
suffix:semicolon
r_return
id|esp_do_phase_determine
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
DECL|function|esp_bus_unexpected
r_static
r_int
id|esp_bus_unexpected
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: command in weird state %2x&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;current_SC-&gt;SCp.phase
)paren
)paren
suffix:semicolon
r_return
id|do_reset_bus
suffix:semicolon
)brace
DECL|variable|bus_vector
r_static
id|espfunc_t
id|bus_vector
(braket
)braket
op_assign
(brace
id|esp_do_data_finale
comma
id|esp_do_data_finale
comma
id|esp_bus_unexpected
comma
id|esp_do_msgin
comma
id|esp_do_msgincont
comma
id|esp_do_msgindone
comma
id|esp_do_msgout
comma
id|esp_do_msgoutdone
comma
id|esp_do_cmdbegin
comma
id|esp_do_cmddone
comma
id|esp_do_status
comma
id|esp_do_freebus
comma
id|esp_do_phase_determine
comma
id|esp_bus_unexpected
comma
id|esp_bus_unexpected
comma
id|esp_bus_unexpected
comma
)brace
suffix:semicolon
multiline_comment|/* This is the second tier in our dual-level SCSI state machine. */
DECL|function|esp_work_bus
r_static
r_int
id|esp_work_bus
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
r_int
r_int
id|phase
suffix:semicolon
id|ESPBUS
c_func
(paren
(paren
l_string|&quot;esp_work_bus: &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCptr
)paren
(brace
id|ESPBUS
c_func
(paren
(paren
l_string|&quot;reconnect&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|esp_do_reconnect
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
id|phase
op_assign
id|SCptr-&gt;SCp.phase
suffix:semicolon
r_if
c_cond
(paren
(paren
id|phase
op_amp
l_int|0xf0
)paren
op_eq
id|in_phases_mask
)paren
r_return
id|bus_vector
(braket
(paren
id|phase
op_amp
l_int|0x0f
)paren
)braket
(paren
id|esp
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|phase
op_amp
l_int|0xf0
)paren
op_eq
id|in_slct_mask
)paren
r_return
id|esp_select_complete
c_func
(paren
id|esp
)paren
suffix:semicolon
r_else
r_return
id|esp_bus_unexpected
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
DECL|variable|isvc_vector
r_static
id|espfunc_t
id|isvc_vector
(braket
)braket
op_assign
(brace
l_int|0
comma
id|esp_do_phase_determine
comma
id|esp_do_resetbus
comma
id|esp_finish_reset
comma
id|esp_work_bus
)brace
suffix:semicolon
multiline_comment|/* Main interrupt handler for an esp adapter. */
DECL|function|esp_handle
r_static
r_void
id|esp_handle
c_func
(paren
r_struct
id|esp
op_star
id|esp
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCptr
suffix:semicolon
r_int
id|what_next
op_assign
id|do_intr_end
suffix:semicolon
id|SCptr
op_assign
id|esp-&gt;current_SC
suffix:semicolon
multiline_comment|/* Check for errors. */
id|esp-&gt;sreg
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_STATUS
)paren
suffix:semicolon
id|esp-&gt;sreg
op_and_assign
(paren
op_complement
id|ESP_STAT_INTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
id|esp-&gt;sreg2
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_STATUS2
)paren
suffix:semicolon
id|esp-&gt;seqreg
op_assign
(paren
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_SSTEP
)paren
op_amp
id|ESP_STEP_VBITS
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|esp-&gt;sreg
op_amp
(paren
id|ESP_STAT_SPAM
)paren
)paren
(brace
multiline_comment|/* Gross error, could be due to one of:&n;&t;&t; *&n;&t;&t; * - top of fifo overwritten, could be because&n;&t;&t; *   we tried to do a synchronous transfer with&n;&t;&t; *   an offset greater than ESP fifo size&n;&t;&t; *&n;&t;&t; * - top of command register overwritten&n;&t;&t; *&n;&t;&t; * - DMA setup to go in one direction, SCSI&n;&t;&t; *   bus points in the other, whoops&n;&t;&t; *&n;&t;&t; * - weird phase change during asynchronous&n;&t;&t; *   data phase while we are initiator&n;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Gross error sreg=%2x&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|esp-&gt;sreg
)paren
)paren
suffix:semicolon
multiline_comment|/* If a command is live on the bus we cannot safely&n;&t;&t; * reset the bus, so we&squot;ll just let the pieces fall&n;&t;&t; * where they may.  Here we are hoping that the&n;&t;&t; * target will be able to cleanly go away soon&n;&t;&t; * so we can safely reset things.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|SCptr
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: No current cmd during gross error, &quot;
l_string|&quot;resetting bus&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|what_next
op_assign
id|do_reset_bus
suffix:semicolon
r_goto
id|state_machine
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
op_amp
id|DMA_HNDL_ERROR
)paren
(brace
multiline_comment|/* A DMA gate array error.  Here we must&n;&t;&t; * be seeing one of two things.  Either the&n;&t;&t; * virtual to physical address translation&n;&t;&t; * on the SBUS could not occur, else the&n;&t;&t; * translation it did get pointed to a bogus&n;&t;&t; * page.  Ho hum...&n;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: DMA error %08x&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|sbus_readl
c_func
(paren
id|esp-&gt;dregs
op_plus
id|DMA_CSR
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* DMA gate array itself must be reset to clear the&n;&t;&t; * error condition.&n;&t;&t; */
id|esp_reset_dma
c_func
(paren
id|esp
)paren
suffix:semicolon
id|what_next
op_assign
id|do_reset_bus
suffix:semicolon
r_goto
id|state_machine
suffix:semicolon
)brace
id|esp-&gt;ireg
op_assign
id|sbus_readb
c_func
(paren
id|esp-&gt;eregs
op_plus
id|ESP_INTRPT
)paren
suffix:semicolon
multiline_comment|/* Unlatch intr reg */
r_if
c_cond
(paren
id|esp-&gt;erev
op_eq
id|fashme
)paren
(brace
multiline_comment|/* This chip is really losing. */
id|ESPHME
c_func
(paren
(paren
l_string|&quot;HME[&quot;
)paren
)paren
suffix:semicolon
id|ESPHME
c_func
(paren
(paren
l_string|&quot;sreg2=%02x,&quot;
comma
id|esp-&gt;sreg2
)paren
)paren
suffix:semicolon
multiline_comment|/* Must latch fifo before reading the interrupt&n;&t;&t; * register else garbage ends up in the FIFO&n;&t;&t; * which confuses the driver utterly.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;sreg2
op_amp
id|ESP_STAT2_FEMPTY
)paren
op_logical_or
(paren
id|esp-&gt;sreg2
op_amp
id|ESP_STAT2_F1BYTE
)paren
)paren
(brace
id|ESPHME
c_func
(paren
(paren
l_string|&quot;fifo_workaround]&quot;
)paren
)paren
suffix:semicolon
id|hme_fifo_read
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_else
(brace
id|ESPHME
c_func
(paren
(paren
l_string|&quot;no_fifo_workaround]&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* No current cmd is only valid at this point when there are&n;&t; * commands off the bus or we are trying a reset.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|SCptr
op_logical_and
op_logical_neg
id|esp-&gt;disconnected_SC
op_logical_and
op_logical_neg
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_SR
)paren
)paren
(brace
multiline_comment|/* Panic is safe, since current_SC is null. */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: no command in esp_handle()&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;esp_handle: current_SC == penguin within interrupt!&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|esp-&gt;ireg
op_amp
(paren
id|ESP_INTR_IC
)paren
)paren
(brace
multiline_comment|/* Illegal command fed to ESP.  Outside of obvious&n;&t;&t; * software bugs that could cause this, there is&n;&t;&t; * a condition with esp100 where we can confuse the&n;&t;&t; * ESP into an erroneous illegal command interrupt&n;&t;&t; * because it does not scrape the FIFO properly&n;&t;&t; * for reselection.  See esp100_reconnect_hwbug()&n;&t;&t; * to see how we try very hard to avoid this.&n;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: illegal command&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp_dump_state
c_func
(paren
id|esp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCptr
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Devices with very buggy firmware can drop BSY&n;&t;&t;&t; * during a scatter list interrupt when using sync&n;&t;&t;&t; * mode transfers.  We continue the transfer as&n;&t;&t;&t; * expected, the target drops the bus, the ESP&n;&t;&t;&t; * gets confused, and we get a illegal command&n;&t;&t;&t; * interrupt because the bus is in the disconnected&n;&t;&t;&t; * state now and ESP_CMD_TI is only allowed when&n;&t;&t;&t; * a nexus is alive on the bus.&n;&t;&t;&t; */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Forcing async and disabling disconnect for &quot;
l_string|&quot;target %d&bslash;n&quot;
comma
id|esp-&gt;esp_id
comma
id|SCptr-&gt;target
)paren
)paren
suffix:semicolon
id|SCptr-&gt;device-&gt;borken
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* foo on you */
)brace
id|what_next
op_assign
id|do_reset_bus
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|esp-&gt;ireg
op_amp
op_complement
(paren
id|ESP_INTR_FDONE
op_or
id|ESP_INTR_BSERV
op_or
id|ESP_INTR_DC
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|SCptr
)paren
(brace
r_int
r_int
id|phase
op_assign
id|SCptr-&gt;SCp.phase
suffix:semicolon
r_if
c_cond
(paren
id|phase
op_amp
id|in_phases_mask
)paren
(brace
id|what_next
op_assign
id|esp_work_bus
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|phase
op_amp
id|in_slct_mask
)paren
(brace
id|what_next
op_assign
id|esp_select_complete
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_else
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: interrupt for no good reason...&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|what_next
op_assign
id|do_intr_end
suffix:semicolon
)brace
)brace
r_else
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: BSERV or FDONE or DC while SCptr==NULL&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|what_next
op_assign
id|do_reset_bus
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_SR
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: SCSI bus reset interrupt&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|what_next
op_assign
id|do_reset_complete
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;ireg
op_amp
(paren
id|ESP_INTR_S
op_or
id|ESP_INTR_SATN
)paren
)paren
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: AIEEE we have been selected by another initiator!&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|what_next
op_assign
id|do_reset_bus
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|esp-&gt;ireg
op_amp
id|ESP_INTR_RSEL
)paren
(brace
r_if
c_cond
(paren
id|SCptr
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* This is ok. */
id|what_next
op_assign
id|esp_do_reconnect
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SCptr-&gt;SCp.phase
op_amp
id|in_slct_mask
)paren
(brace
multiline_comment|/* Only selection code knows how to clean&n;&t;&t;&t; * up properly.&n;&t;&t;&t; */
id|ESPDISC
c_func
(paren
(paren
l_string|&quot;Reselected during selection attempt&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|what_next
op_assign
id|esp_select_complete
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
r_else
(brace
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: Reselected while bus is busy&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|what_next
op_assign
id|do_reset_bus
suffix:semicolon
)brace
)brace
multiline_comment|/* This is tier-one in our dual level SCSI state machine. */
id|state_machine
suffix:colon
r_while
c_loop
(paren
id|what_next
op_ne
id|do_intr_end
)paren
(brace
r_if
c_cond
(paren
id|what_next
op_ge
id|do_phase_determine
op_logical_and
id|what_next
OL
id|do_intr_end
)paren
(brace
id|what_next
op_assign
id|isvc_vector
(braket
id|what_next
)braket
(paren
id|esp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* state is completely lost ;-( */
id|ESPLOG
c_func
(paren
(paren
l_string|&quot;esp%d: interrupt engine loses state, resetting bus&bslash;n&quot;
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|what_next
op_assign
id|do_reset_bus
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Service only the ESP described by dev_id. */
DECL|function|esp_intr
r_static
r_void
id|esp_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|pregs
)paren
(brace
r_struct
id|esp
op_star
id|esp
op_assign
id|dev_id
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|esp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ESP_IRQ_P
c_func
(paren
id|esp-&gt;dregs
)paren
)paren
(brace
id|ESP_INTSOFF
c_func
(paren
id|esp-&gt;dregs
)paren
suffix:semicolon
id|ESPIRQ
c_func
(paren
(paren
l_string|&quot;I[%d:%d](&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|esp-&gt;esp_id
)paren
)paren
suffix:semicolon
id|esp_handle
c_func
(paren
id|esp
)paren
suffix:semicolon
id|ESPIRQ
c_func
(paren
(paren
l_string|&quot;)&quot;
)paren
)paren
suffix:semicolon
id|ESP_INTSON
c_func
(paren
id|esp-&gt;dregs
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|esp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|esp_revoke
r_int
id|esp_revoke
c_func
(paren
id|Scsi_Device
op_star
id|SDptr
)paren
(brace
r_struct
id|esp
op_star
id|esp
op_assign
(paren
r_struct
id|esp
op_star
)paren
id|SDptr-&gt;host-&gt;hostdata
suffix:semicolon
id|esp-&gt;targets_present
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|SDptr-&gt;id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|SCSI_SPARC_ESP
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
id|EXPORT_NO_SYMBOLS
suffix:semicolon
eof
