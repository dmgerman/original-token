multiline_comment|/* imm.c   --  low level driver for the IOMEGA MatchMaker&n; * parallel port SCSI host adapter.&n; * &n; * (The IMM is the embedded controller in the ZIP Plus drive.)&n; * &n; * Current Maintainer: David Campbell (Perth, Western Australia)&n; *                     campbell@torque.net&n; *&n; * My unoffical company acronym list is 21 pages long:&n; *      FLA:    Four letter acronym with built in facility for&n; *              future expansion to five letters.&n; */
macro_line|#include &lt;linux/config.h&gt;
multiline_comment|/* The following #define is to avoid a clash with hosts.c */
DECL|macro|IMM_CODE
mdefine_line|#define IMM_CODE 1
DECL|macro|IMM_PROBE_SPP
mdefine_line|#define IMM_PROBE_SPP   0x0001
DECL|macro|IMM_PROBE_PS2
mdefine_line|#define IMM_PROBE_PS2   0x0002
DECL|macro|IMM_PROBE_ECR
mdefine_line|#define IMM_PROBE_ECR   0x0010
DECL|macro|IMM_PROBE_EPP17
mdefine_line|#define IMM_PROBE_EPP17 0x0100
DECL|macro|IMM_PROBE_EPP19
mdefine_line|#define IMM_PROBE_EPP19 0x0200
r_void
id|imm_reset_pulse
c_func
(paren
r_int
r_int
id|base
)paren
suffix:semicolon
r_static
r_int
id|device_check
c_func
(paren
r_int
id|host_no
)paren
suffix:semicolon
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &quot;hosts.h&quot;
r_typedef
r_struct
(brace
DECL|member|dev
r_struct
id|pardevice
op_star
id|dev
suffix:semicolon
multiline_comment|/* Parport device entry         */
DECL|member|base
r_int
id|base
suffix:semicolon
multiline_comment|/* Actual port address          */
DECL|member|base_hi
r_int
id|base_hi
suffix:semicolon
multiline_comment|/* Hi Base address for ECP-ISA chipset */
DECL|member|mode
r_int
id|mode
suffix:semicolon
multiline_comment|/* Transfer mode                */
DECL|member|host
r_int
id|host
suffix:semicolon
multiline_comment|/* Host number (for proc)       */
DECL|member|cur_cmd
id|Scsi_Cmnd
op_star
id|cur_cmd
suffix:semicolon
multiline_comment|/* Current queued command       */
DECL|member|imm_tq
r_struct
id|tq_struct
id|imm_tq
suffix:semicolon
multiline_comment|/* Polling interupt stuff       */
DECL|member|jstart
r_int
r_int
id|jstart
suffix:semicolon
multiline_comment|/* Jiffies at start             */
DECL|member|failed
r_int
id|failed
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Failure flag                 */
DECL|member|dp
r_int
id|dp
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Data phase present           */
DECL|member|rd
r_int
id|rd
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Read data in data phase      */
DECL|member|p_busy
r_int
id|p_busy
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Parport sharing busy flag    */
DECL|typedef|imm_struct
)brace
id|imm_struct
suffix:semicolon
DECL|macro|IMM_EMPTY
mdefine_line|#define IMM_EMPTY &bslash;&n;{&t;dev:&t;&t;NULL,&t;&t;&bslash;&n;&t;base:&t;&t;-1,&t;&t;&bslash;&n;&t;base_hi:&t;0,&t;&t;&bslash;&n;&t;mode:&t;&t;IMM_AUTODETECT,&t;&bslash;&n;&t;host:&t;&t;-1,&t;&t;&bslash;&n;&t;cur_cmd:&t;NULL,&t;&t;&bslash;&n;&t;imm_tq:&t;&t;{ routine: imm_interrupt },    &bslash;&n;&t;jstart:&t;&t;0,&t;&t;&bslash;&n;&t;failed:&t;&t;0,&t;&t;&bslash;&n;&t;dp:&t;&t;0,&t;&t;&bslash;&n;&t;rd:&t;&t;0,&t;&t;&bslash;&n;&t;p_busy:&t;&t;0&t;&t;&bslash;&n;}
macro_line|#include &quot;imm.h&quot;
DECL|macro|NO_HOSTS
mdefine_line|#define NO_HOSTS 4
DECL|variable|imm_hosts
r_static
id|imm_struct
id|imm_hosts
(braket
id|NO_HOSTS
)braket
op_assign
(brace
id|IMM_EMPTY
comma
id|IMM_EMPTY
comma
id|IMM_EMPTY
comma
id|IMM_EMPTY
)brace
suffix:semicolon
DECL|macro|IMM_BASE
mdefine_line|#define IMM_BASE(x)&t;imm_hosts[(x)].base
DECL|macro|IMM_BASE_HI
mdefine_line|#define IMM_BASE_HI(x)     imm_hosts[(x)].base_hi
DECL|variable|parbus_base
r_int
id|parbus_base
(braket
id|NO_HOSTS
)braket
op_assign
(brace
l_int|0x03bc
comma
l_int|0x0378
comma
l_int|0x0278
comma
l_int|0x0000
)brace
suffix:semicolon
DECL|function|imm_wakeup
r_void
id|imm_wakeup
c_func
(paren
r_void
op_star
id|ref
)paren
(brace
id|imm_struct
op_star
id|imm_dev
op_assign
(paren
id|imm_struct
op_star
)paren
id|ref
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|imm_dev-&gt;p_busy
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|parport_claim
c_func
(paren
id|imm_dev-&gt;dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;imm: bug in imm_wakeup&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|imm_dev-&gt;p_busy
op_assign
l_int|0
suffix:semicolon
id|imm_dev-&gt;base
op_assign
id|imm_dev-&gt;dev-&gt;port-&gt;base
suffix:semicolon
r_if
c_cond
(paren
id|imm_dev-&gt;cur_cmd
)paren
id|imm_dev-&gt;cur_cmd-&gt;SCp.phase
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|imm_release
r_int
id|imm_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_int
id|host_no
op_assign
id|host-&gt;unique_id
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Releasing imm%i&bslash;n&quot;
comma
id|host_no
)paren
suffix:semicolon
id|parport_unregister_device
c_func
(paren
id|imm_hosts
(braket
id|host_no
)braket
dot
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|imm_pb_claim
r_static
r_int
id|imm_pb_claim
c_func
(paren
r_int
id|host_no
)paren
(brace
r_if
c_cond
(paren
id|parport_claim
c_func
(paren
id|imm_hosts
(braket
id|host_no
)braket
dot
id|dev
)paren
)paren
(brace
id|imm_hosts
(braket
id|host_no
)braket
dot
id|p_busy
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|imm_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
)paren
id|imm_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd-&gt;SCp.phase
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|imm_pb_release
mdefine_line|#define imm_pb_release(x) parport_release(imm_hosts[(x)].dev)
multiline_comment|/***************************************************************************&n; *                   Parallel port probing routines                        *&n; ***************************************************************************/
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|IMM
suffix:semicolon
macro_line|#include  &quot;scsi_module.c&quot;
DECL|function|imm_detect
r_int
id|imm_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|host
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|hreg
suffix:semicolon
r_int
id|ports
suffix:semicolon
r_int
id|i
comma
id|nhosts
comma
id|try_again
suffix:semicolon
r_struct
id|parport
op_star
id|pb
suffix:semicolon
multiline_comment|/*&n;     * unlock to allow the lowlevel parport driver to probe&n;     * the irqs&n;     */
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|pb
op_assign
id|parport_enumerate
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;imm: Version %s&bslash;n&quot;
comma
id|IMM_VERSION
)paren
suffix:semicolon
id|nhosts
op_assign
l_int|0
suffix:semicolon
id|try_again
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pb
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;imm: parport reports no devices.&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|retry_entry
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|pb
suffix:semicolon
id|i
op_increment
comma
id|pb
op_assign
id|pb-&gt;next
)paren
(brace
r_int
id|modes
comma
id|ppb
suffix:semicolon
id|imm_hosts
(braket
id|i
)braket
dot
id|dev
op_assign
id|parport_register_device
c_func
(paren
id|pb
comma
l_string|&quot;imm&quot;
comma
l_int|NULL
comma
id|imm_wakeup
comma
l_int|NULL
comma
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|imm_hosts
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|imm_hosts
(braket
id|i
)braket
dot
id|dev
)paren
r_continue
suffix:semicolon
multiline_comment|/* Claim the bus so it remembers what we do to the control&n;&t; * registers. [ CTR and ECP ]&n;&t; */
r_if
c_cond
(paren
id|imm_pb_claim
c_func
(paren
id|i
)paren
)paren
(brace
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|imm_hosts
(braket
id|i
)braket
dot
id|p_busy
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We are safe to schedule here */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|now
op_plus
l_int|3
op_star
id|HZ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;imm%d: failed to claim parport because a &quot;
l_string|&quot;pardevice is owning the port for too longtime!&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|ppb
op_assign
id|IMM_BASE
c_func
(paren
id|i
)paren
op_assign
id|imm_hosts
(braket
id|i
)braket
dot
id|dev-&gt;port-&gt;base
suffix:semicolon
id|IMM_BASE_HI
c_func
(paren
id|i
)paren
op_assign
id|imm_hosts
(braket
id|i
)braket
dot
id|dev-&gt;port-&gt;base_hi
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|modes
op_assign
id|imm_hosts
(braket
id|i
)braket
dot
id|dev-&gt;port-&gt;modes
suffix:semicolon
multiline_comment|/* Mode detection works up the chain of speed&n;&t; * This avoids a nasty if-then-else-if-... tree&n;&t; */
id|imm_hosts
(braket
id|i
)braket
dot
id|mode
op_assign
id|IMM_NIBBLE
suffix:semicolon
r_if
c_cond
(paren
id|modes
op_amp
id|PARPORT_MODE_TRISTATE
)paren
id|imm_hosts
(braket
id|i
)braket
dot
id|mode
op_assign
id|IMM_PS2
suffix:semicolon
multiline_comment|/* Done configuration */
id|imm_pb_release
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imm_init
c_func
(paren
id|i
)paren
)paren
(brace
id|parport_unregister_device
c_func
(paren
id|imm_hosts
(braket
id|i
)braket
dot
id|dev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* now the glue ... */
r_switch
c_cond
(paren
id|imm_hosts
(braket
id|i
)braket
dot
id|mode
)paren
(brace
r_case
id|IMM_NIBBLE
suffix:colon
id|ports
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IMM_PS2
suffix:colon
id|ports
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IMM_EPP_8
suffix:colon
r_case
id|IMM_EPP_16
suffix:colon
r_case
id|IMM_EPP_32
suffix:colon
id|ports
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Never gets here */
r_continue
suffix:semicolon
)brace
id|host-&gt;can_queue
op_assign
id|IMM_CAN_QUEUE
suffix:semicolon
id|host-&gt;sg_tablesize
op_assign
id|imm_sg
suffix:semicolon
id|hreg
op_assign
id|scsi_register
c_func
(paren
id|host
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hreg
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
id|hreg-&gt;io_port
op_assign
id|pb-&gt;base
suffix:semicolon
id|hreg-&gt;n_io_port
op_assign
id|ports
suffix:semicolon
id|hreg-&gt;dma_channel
op_assign
op_minus
l_int|1
suffix:semicolon
id|hreg-&gt;unique_id
op_assign
id|i
suffix:semicolon
id|imm_hosts
(braket
id|i
)braket
dot
id|host
op_assign
id|hreg-&gt;host_no
suffix:semicolon
id|nhosts
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nhosts
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|try_again
op_eq
l_int|1
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|try_again
op_assign
l_int|1
suffix:semicolon
r_goto
id|retry_entry
suffix:semicolon
)brace
r_else
(brace
id|spin_lock_irq
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* return number of hosts detected */
)brace
)brace
multiline_comment|/* This is to give the imm driver a way to modify the timings (and other&n; * parameters) by writing to the /proc/scsi/imm/0 file.&n; * Very simple method really... (To simple, no error checking :( )&n; * Reason: Kernel hackers HATE having to unload and reload modules for&n; * testing...&n; * Also gives a method to use a script to obtain optimum timings (TODO)&n; */
DECL|function|imm_proc_write
r_static
r_inline
r_int
id|imm_proc_write
c_func
(paren
r_int
id|hostno
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_int
r_int
id|x
suffix:semicolon
r_if
c_cond
(paren
(paren
id|length
OG
l_int|5
)paren
op_logical_and
(paren
id|strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;mode=&quot;
comma
l_int|5
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|x
op_assign
id|simple_strtoul
c_func
(paren
id|buffer
op_plus
l_int|5
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|imm_hosts
(braket
id|hostno
)braket
dot
id|mode
op_assign
id|x
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;imm /proc: invalid variable&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
DECL|function|imm_proc_info
r_int
id|imm_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|imm_hosts
(braket
id|i
)braket
dot
id|host
op_eq
id|hostno
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|inout
)paren
r_return
id|imm_proc_write
c_func
(paren
id|i
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Version : %s&bslash;n&quot;
comma
id|IMM_VERSION
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Parport : %s&bslash;n&quot;
comma
id|imm_hosts
(braket
id|i
)braket
dot
id|dev-&gt;port-&gt;name
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Mode    : %s&bslash;n&quot;
comma
id|IMM_MODE_STRING
(braket
id|imm_hosts
(braket
id|i
)braket
dot
id|mode
)braket
)paren
suffix:semicolon
multiline_comment|/* Request for beyond end of buffer */
r_if
c_cond
(paren
id|offset
OG
id|len
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
id|len
op_sub_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#if IMM_DEBUG &gt; 0
DECL|macro|imm_fail
mdefine_line|#define imm_fail(x,y) printk(&quot;imm: imm_fail(%i) from %s at line %d&bslash;n&quot;,&bslash;&n;&t;   y, __FUNCTION__, __LINE__); imm_fail_func(x,y);
DECL|function|imm_fail_func
r_static
r_inline
r_void
id|imm_fail_func
c_func
(paren
r_int
id|host_no
comma
r_int
id|error_code
)paren
macro_line|#else
r_static
r_inline
r_void
id|imm_fail
c_func
(paren
r_int
id|host_no
comma
r_int
id|error_code
)paren
macro_line|#endif
(brace
multiline_comment|/* If we fail a device then we trash status / message bytes */
r_if
c_cond
(paren
id|imm_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
)paren
(brace
id|imm_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd-&gt;result
op_assign
id|error_code
op_lshift
l_int|16
suffix:semicolon
id|imm_hosts
(braket
id|host_no
)braket
dot
id|failed
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Wait for the high bit to be set.&n; * &n; * In principle, this could be tied to an interrupt, but the adapter&n; * doesn&squot;t appear to be designed to support interrupts.  We spin on&n; * the 0x80 ready bit. &n; */
DECL|function|imm_wait
r_static
r_int
r_char
id|imm_wait
c_func
(paren
r_int
id|host_no
)paren
(brace
r_int
id|k
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|IMM_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_int
r_char
id|r
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|k
op_assign
id|IMM_SPIN_TMO
suffix:semicolon
r_do
(brace
id|r
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|k
op_decrement
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|r
op_amp
l_int|0x80
)paren
op_logical_and
(paren
id|k
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * STR register (LPT base+1) to SCSI mapping:&n;     *&n;     * STR      imm     imm&n;     * ===================================&n;     * 0x80     S_REQ   S_REQ&n;     * 0x40     !S_BSY  (????)&n;     * 0x20     !S_CD   !S_CD&n;     * 0x10     !S_IO   !S_IO&n;     * 0x08     (????)  !S_BSY&n;     *&n;     * imm      imm     meaning&n;     * ==================================&n;     * 0xf0     0xb8    Bit mask&n;     * 0xc0     0x88    ZIP wants more data&n;     * 0xd0     0x98    ZIP wants to send more data&n;     * 0xe0     0xa8    ZIP is expecting SCSI command data&n;     * 0xf0     0xb8    end of transfer, ZIP is sending status&n;     */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x04
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
)paren
r_return
(paren
id|r
op_amp
l_int|0xb8
)paren
suffix:semicolon
multiline_comment|/* Counter expired - Time out occurred */
id|imm_fail
c_func
(paren
id|host_no
comma
id|DID_TIME_OUT
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;imm timeout in imm_wait&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* command timed out */
)brace
DECL|function|imm_negotiate
r_static
r_int
id|imm_negotiate
c_func
(paren
id|imm_struct
op_star
id|tmp
)paren
(brace
multiline_comment|/*&n;     * The following is supposedly the IEEE 1284-1994 negotiate&n;     * sequence. I have yet to obtain a copy of the above standard&n;     * so this is a bit of a guess...&n;     *&n;     * A fair chunk of this is based on the Linux parport implementation&n;     * of IEEE 1284.&n;     *&n;     * Return 0 if data available&n;     *        1 if no data available&n;     */
r_int
r_int
id|base
op_assign
id|tmp-&gt;base
suffix:semicolon
r_int
r_char
id|a
comma
id|mode
suffix:semicolon
r_switch
c_cond
(paren
id|tmp-&gt;mode
)paren
(brace
r_case
id|IMM_NIBBLE
suffix:colon
id|mode
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IMM_PS2
suffix:colon
id|mode
op_assign
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x04
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|w_dtr
c_func
(paren
id|base
comma
id|mode
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x06
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|a
op_assign
(paren
id|r_str
c_func
(paren
id|base
)paren
op_amp
l_int|0x20
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x07
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x06
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IMM: IEEE1284 negotiate indicates no data available.&bslash;n&quot;
)paren
suffix:semicolon
id|imm_fail
c_func
(paren
id|tmp-&gt;host
comma
id|DID_ERROR
)paren
suffix:semicolon
)brace
r_return
id|a
suffix:semicolon
)brace
multiline_comment|/* &n; * Clear EPP timeout bit. &n; */
DECL|function|epp_reset
r_static
r_inline
r_void
id|epp_reset
c_func
(paren
r_int
r_int
id|ppb
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|w_str
c_func
(paren
id|ppb
comma
id|i
)paren
suffix:semicolon
id|w_str
c_func
(paren
id|ppb
comma
id|i
op_amp
l_int|0xfe
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Wait for empty ECP fifo (if we are in ECP fifo mode only)&n; */
DECL|function|ecp_sync
r_static
r_inline
r_void
id|ecp_sync
c_func
(paren
r_int
r_int
id|hostno
)paren
(brace
r_int
id|i
comma
id|ppb_hi
op_assign
id|IMM_BASE_HI
c_func
(paren
id|hostno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppb_hi
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r_ecr
c_func
(paren
id|ppb_hi
)paren
op_amp
l_int|0xe0
)paren
op_eq
l_int|0x60
)paren
(brace
multiline_comment|/* mode 011 == ECP fifo mode */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|r_ecr
c_func
(paren
id|ppb_hi
)paren
op_amp
l_int|0x01
)paren
r_return
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;imm: ECP sync failed as data still present in FIFO.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|imm_byte_out
r_static
r_int
id|imm_byte_out
c_func
(paren
r_int
r_int
id|base
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x4
)paren
suffix:semicolon
multiline_comment|/* apparently a sane mode */
r_for
c_loop
(paren
id|i
op_assign
id|len
op_rshift
l_int|1
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|w_dtr
c_func
(paren
id|base
comma
op_star
id|buffer
op_increment
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x5
)paren
suffix:semicolon
multiline_comment|/* Drop STROBE low */
id|w_dtr
c_func
(paren
id|base
comma
op_star
id|buffer
op_increment
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x0
)paren
suffix:semicolon
multiline_comment|/* STROBE high + INIT low */
)brace
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x4
)paren
suffix:semicolon
multiline_comment|/* apparently a sane mode */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* All went well - we hope! */
)brace
DECL|function|imm_nibble_in
r_static
r_int
id|imm_nibble_in
c_func
(paren
r_int
r_int
id|base
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
r_char
id|l
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;     * The following is based on documented timing signals&n;     */
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|len
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x6
)paren
suffix:semicolon
id|l
op_assign
(paren
id|r_str
c_func
(paren
id|base
)paren
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x5
)paren
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
(paren
id|r_str
c_func
(paren
id|base
)paren
op_amp
l_int|0xf0
)paren
op_or
id|l
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x4
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* All went well - we hope! */
)brace
DECL|function|imm_byte_in
r_static
r_int
id|imm_byte_in
c_func
(paren
r_int
r_int
id|base
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;     * The following is based on documented timing signals&n;     */
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|len
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x26
)paren
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
id|r_dtr
c_func
(paren
id|base
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x25
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* All went well - we hope! */
)brace
DECL|function|imm_out
r_static
r_int
id|imm_out
c_func
(paren
r_int
id|host_no
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|r
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|IMM_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|r
op_assign
id|imm_wait
c_func
(paren
id|host_no
)paren
suffix:semicolon
multiline_comment|/*&n;     * Make sure that:&n;     * a) the SCSI bus is BUSY (device still listening)&n;     * b) the device is listening&n;     */
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|0x18
)paren
op_ne
l_int|0x08
)paren
(brace
id|imm_fail
c_func
(paren
id|host_no
comma
id|DID_ERROR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IMM: returned SCSI status %2x&bslash;n&quot;
comma
id|r
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|imm_hosts
(braket
id|host_no
)braket
dot
id|mode
)paren
(brace
r_case
id|IMM_EPP_32
suffix:colon
r_case
id|IMM_EPP_16
suffix:colon
r_case
id|IMM_EPP_8
suffix:colon
id|epp_reset
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI_IZIP_EPP16
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
r_int
)paren
id|buffer
op_or
id|len
)paren
op_amp
l_int|0x01
)paren
)paren
id|outsw
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
op_rshift
l_int|1
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
r_int
)paren
id|buffer
op_or
id|len
)paren
op_amp
l_int|0x03
)paren
)paren
id|outsl
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
op_rshift
l_int|2
)paren
suffix:semicolon
macro_line|#endif
r_else
id|outsb
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|r
op_assign
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x01
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IMM_NIBBLE
suffix:colon
r_case
id|IMM_PS2
suffix:colon
multiline_comment|/* 8 bit output, with a loop */
id|r
op_assign
id|imm_byte_out
c_func
(paren
id|ppb
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;IMM: bug in imm_out()&bslash;n&quot;
)paren
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
DECL|function|imm_in
r_static
r_int
id|imm_in
c_func
(paren
r_int
id|host_no
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|r
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|IMM_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|r
op_assign
id|imm_wait
c_func
(paren
id|host_no
)paren
suffix:semicolon
multiline_comment|/*&n;     * Make sure that:&n;     * a) the SCSI bus is BUSY (device still listening)&n;     * b) the device is sending data&n;     */
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|0x18
)paren
op_ne
l_int|0x18
)paren
(brace
id|imm_fail
c_func
(paren
id|host_no
comma
id|DID_ERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|imm_hosts
(braket
id|host_no
)braket
dot
id|mode
)paren
(brace
r_case
id|IMM_NIBBLE
suffix:colon
multiline_comment|/* 4 bit input, with a loop */
id|r
op_assign
id|imm_nibble_in
c_func
(paren
id|ppb
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IMM_PS2
suffix:colon
multiline_comment|/* 8 bit input, with a loop */
id|r
op_assign
id|imm_byte_in
c_func
(paren
id|ppb
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IMM_EPP_32
suffix:colon
r_case
id|IMM_EPP_16
suffix:colon
r_case
id|IMM_EPP_8
suffix:colon
id|epp_reset
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x24
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI_IZIP_EPP16
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
r_int
)paren
id|buffer
op_or
id|len
)paren
op_amp
l_int|0x01
)paren
)paren
id|insw
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
op_rshift
l_int|1
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
r_int
)paren
id|buffer
op_or
id|len
)paren
op_amp
l_int|0x03
)paren
)paren
id|insl
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
op_rshift
l_int|2
)paren
suffix:semicolon
macro_line|#endif
r_else
id|insb
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x2c
)paren
suffix:semicolon
id|r
op_assign
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x01
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x2c
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;IMM: bug in imm_ins()&bslash;n&quot;
)paren
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
DECL|function|imm_cpp
r_static
r_int
id|imm_cpp
c_func
(paren
r_int
r_int
id|ppb
comma
r_int
r_char
id|b
)paren
(brace
multiline_comment|/*&n;     * Comments on udelay values refer to the&n;     * Command Packet Protocol (CPP) timing diagram.&n;     */
r_int
r_char
id|s1
comma
id|s2
comma
id|s3
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 1 usec - infinite */
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0xaa
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0x55
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0x00
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0xff
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
id|s1
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0xb8
suffix:semicolon
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0x87
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
id|s2
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0xb8
suffix:semicolon
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0x78
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
id|s3
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x38
suffix:semicolon
multiline_comment|/*&n;     * Values for b are:&n;     * 0000 00aa    Assign address aa to current device&n;     * 0010 00aa    Select device aa in EPP Winbond mode&n;     * 0010 10aa    Select device aa in EPP mode&n;     * 0011 xxxx    Deselect all devices&n;     * 0110 00aa    Test device aa&n;     * 1101 00aa    Select device aa in ECP mode&n;     * 1110 00aa    Select device aa in Compatible mode&n;     */
id|w_dtr
c_func
(paren
id|ppb
comma
id|b
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 1 usec - infinite */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0d
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 1 usec - infinite */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0xff
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
multiline_comment|/*&n;     * The following table is electrical pin values.&n;     * (BSY is inverted at the CTR register)&n;     *&n;     *       BSY  ACK  POut SEL  Fault&n;     * S1    0    X    1    1    1&n;     * S2    1    X    0    1    1&n;     * S3    L    X    1    1    S&n;     *&n;     * L =&gt; Last device in chain&n;     * S =&gt; Selected&n;     *&n;     * Observered values for S1,S2,S3 are:&n;     * Disconnect =&gt; f8/58/78&n;     * Connect    =&gt; f8/58/70&n;     */
r_if
c_cond
(paren
(paren
id|s1
op_eq
l_int|0xb8
)paren
op_logical_and
(paren
id|s2
op_eq
l_int|0x18
)paren
op_logical_and
(paren
id|s3
op_eq
l_int|0x30
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Connected */
r_if
c_cond
(paren
(paren
id|s1
op_eq
l_int|0xb8
)paren
op_logical_and
(paren
id|s2
op_eq
l_int|0x18
)paren
op_logical_and
(paren
id|s3
op_eq
l_int|0x38
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Disconnected */
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* No device present */
)brace
DECL|function|imm_connect
r_static
r_inline
r_int
id|imm_connect
c_func
(paren
r_int
id|host_no
comma
r_int
id|flag
)paren
(brace
r_int
r_int
id|ppb
op_assign
id|IMM_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|imm_cpp
c_func
(paren
id|ppb
comma
l_int|0xe0
)paren
suffix:semicolon
multiline_comment|/* Select device 0 in compatible mode */
id|imm_cpp
c_func
(paren
id|ppb
comma
l_int|0x30
)paren
suffix:semicolon
multiline_comment|/* Disconnect all devices */
r_if
c_cond
(paren
(paren
id|imm_hosts
(braket
id|host_no
)braket
dot
id|mode
op_eq
id|IMM_EPP_8
)paren
op_logical_or
(paren
id|imm_hosts
(braket
id|host_no
)braket
dot
id|mode
op_eq
id|IMM_EPP_16
)paren
op_logical_or
(paren
id|imm_hosts
(braket
id|host_no
)braket
dot
id|mode
op_eq
id|IMM_EPP_32
)paren
)paren
r_return
id|imm_cpp
c_func
(paren
id|ppb
comma
l_int|0x28
)paren
suffix:semicolon
multiline_comment|/* Select device 0 in EPP mode */
r_return
id|imm_cpp
c_func
(paren
id|ppb
comma
l_int|0xe0
)paren
suffix:semicolon
multiline_comment|/* Select device 0 in compatible mode */
)brace
DECL|function|imm_disconnect
r_static
r_void
id|imm_disconnect
c_func
(paren
r_int
id|host_no
)paren
(brace
r_int
r_int
id|ppb
op_assign
id|IMM_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|imm_cpp
c_func
(paren
id|ppb
comma
l_int|0x30
)paren
suffix:semicolon
multiline_comment|/* Disconnect all devices */
)brace
DECL|function|imm_select
r_static
r_int
id|imm_select
c_func
(paren
r_int
id|host_no
comma
r_int
id|target
)paren
(brace
r_int
id|k
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|IMM_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
multiline_comment|/*&n;     * Firstly we want to make sure there is nothing&n;     * holding onto the SCSI bus.&n;     */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|k
op_assign
id|IMM_SELECT_TMO
suffix:semicolon
r_do
(brace
id|k
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x08
)paren
op_logical_and
(paren
id|k
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|k
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;     * Now assert the SCSI ID (HOST and TARGET) on the data bus&n;     */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0x80
op_or
(paren
l_int|1
op_lshift
id|target
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;     * Deassert SELIN first followed by STROBE&n;     */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xd
)paren
suffix:semicolon
multiline_comment|/*&n;     * ACK should drop low while SELIN is deasserted.&n;     * FAULT should drop low when the SCSI device latches the bus.&n;     */
id|k
op_assign
id|IMM_SELECT_TMO
suffix:semicolon
r_do
(brace
id|k
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x08
)paren
op_logical_and
(paren
id|k
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * Place the interface back into a sane state (status mode)&n;     */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
r_return
(paren
id|k
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|imm_init
r_static
r_int
id|imm_init
c_func
(paren
r_int
id|host_no
)paren
(brace
r_int
id|retv
suffix:semicolon
macro_line|#if defined(CONFIG_PARPORT) || defined(CONFIG_PARPORT_MODULE)
r_if
c_cond
(paren
id|imm_pb_claim
c_func
(paren
id|host_no
)paren
)paren
r_while
c_loop
(paren
id|imm_hosts
(braket
id|host_no
)braket
dot
id|p_busy
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We can safe schedule here */
macro_line|#endif
id|retv
op_assign
id|imm_connect
c_func
(paren
id|host_no
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retv
op_eq
l_int|1
)paren
(brace
id|imm_reset_pulse
c_func
(paren
id|IMM_BASE
c_func
(paren
id|host_no
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* Delay to allow devices to settle */
id|imm_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* Another delay to allow devices to settle */
id|retv
op_assign
id|device_check
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|imm_pb_release
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
id|imm_pb_release
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|imm_send_command
r_static
r_inline
r_int
id|imm_send_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_int
id|k
suffix:semicolon
multiline_comment|/* NOTE: IMM uses byte pairs */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|cmd-&gt;cmd_len
suffix:semicolon
id|k
op_add_assign
l_int|2
)paren
r_if
c_cond
(paren
op_logical_neg
id|imm_out
c_func
(paren
id|host_no
comma
op_amp
id|cmd-&gt;cmnd
(braket
id|k
)braket
comma
l_int|2
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * The bulk flag enables some optimisations in the data transfer loops,&n; * it should be true for any command that transfers data in integral&n; * numbers of sectors.&n; * &n; * The driver appears to remain stable if we speed up the parallel port&n; * i/o in this function, but not elsewhere.&n; */
DECL|function|imm_completion
r_static
r_int
id|imm_completion
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/* Return codes:&n;     * -1     Error&n;     *  0     Told to schedule&n;     *  1     Finished data transfer&n;     */
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|IMM_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_int
r_int
id|start_jiffies
op_assign
id|jiffies
suffix:semicolon
r_int
r_char
id|r
comma
id|v
suffix:semicolon
r_int
id|fast
comma
id|bulk
comma
id|status
suffix:semicolon
id|v
op_assign
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
id|bulk
op_assign
(paren
(paren
id|v
op_eq
id|READ_6
)paren
op_logical_or
(paren
id|v
op_eq
id|READ_10
)paren
op_logical_or
(paren
id|v
op_eq
id|WRITE_6
)paren
op_logical_or
(paren
id|v
op_eq
id|WRITE_10
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * We only get here if the drive is ready to comunicate,&n;     * hence no need for a full imm_wait.&n;     */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|r
op_assign
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0xb8
)paren
suffix:semicolon
multiline_comment|/*&n;     * while (device is not ready to send status byte)&n;     *     loop;&n;     */
r_while
c_loop
(paren
id|r
op_ne
(paren
r_int
r_char
)paren
l_int|0xb8
)paren
(brace
multiline_comment|/*&n;&t; * If we have been running for more than a full timer tick&n;&t; * then take a rest.&n;&t; */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|start_jiffies
op_plus
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * FAIL if:&n;&t; * a) Drive status is screwy (!ready &amp;&amp; !present)&n;&t; * b) Drive is requesting/sending more data than expected&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|r
op_amp
l_int|0x88
)paren
op_ne
l_int|0x88
)paren
op_logical_or
(paren
id|cmd-&gt;SCp.this_residual
op_le
l_int|0
)paren
)paren
(brace
id|imm_fail
c_func
(paren
id|host_no
comma
id|DID_ERROR
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ERROR_RETURN */
)brace
multiline_comment|/* determine if we should use burst I/O */
r_if
c_cond
(paren
id|imm_hosts
(braket
id|host_no
)braket
dot
id|rd
op_eq
l_int|0
)paren
(brace
id|fast
op_assign
(paren
id|bulk
op_logical_and
(paren
id|cmd-&gt;SCp.this_residual
op_ge
id|IMM_BURST_SIZE
)paren
)paren
ques
c_cond
id|IMM_BURST_SIZE
suffix:colon
l_int|2
suffix:semicolon
id|status
op_assign
id|imm_out
c_func
(paren
id|host_no
comma
id|cmd-&gt;SCp.ptr
comma
id|fast
)paren
suffix:semicolon
)brace
r_else
(brace
id|fast
op_assign
(paren
id|bulk
op_logical_and
(paren
id|cmd-&gt;SCp.this_residual
op_ge
id|IMM_BURST_SIZE
)paren
)paren
ques
c_cond
id|IMM_BURST_SIZE
suffix:colon
l_int|1
suffix:semicolon
id|status
op_assign
id|imm_in
c_func
(paren
id|host_no
comma
id|cmd-&gt;SCp.ptr
comma
id|fast
)paren
suffix:semicolon
)brace
id|cmd-&gt;SCp.ptr
op_add_assign
id|fast
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_sub_assign
id|fast
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
id|imm_fail
c_func
(paren
id|host_no
comma
id|DID_BUS_BUSY
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ERROR_RETURN */
)brace
r_if
c_cond
(paren
id|cmd-&gt;SCp.buffer
op_logical_and
op_logical_neg
id|cmd-&gt;SCp.this_residual
)paren
(brace
multiline_comment|/* if scatter/gather, advance to the next segment */
r_if
c_cond
(paren
id|cmd-&gt;SCp.buffers_residual
op_decrement
)paren
(brace
id|cmd-&gt;SCp.buffer
op_increment
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|cmd-&gt;SCp.buffer-&gt;address
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure that we transfer even number of bytes&n;&t;&t; * otherwise it makes imm_byte_out() messy.&n;&t;&t; */
r_if
c_cond
(paren
id|cmd-&gt;SCp.this_residual
op_amp
l_int|0x01
)paren
id|cmd-&gt;SCp.this_residual
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Now check to see if the drive is ready to comunicate */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|r
op_assign
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0xb8
)paren
suffix:semicolon
multiline_comment|/* If not, drop back down to the scheduler and wait a timer tick */
r_if
c_cond
(paren
op_logical_neg
(paren
id|r
op_amp
l_int|0x80
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* FINISH_RETURN */
)brace
multiline_comment|/* deprecated synchronous interface */
DECL|function|imm_command
r_int
id|imm_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_static
r_int
id|first_pass
op_assign
l_int|1
suffix:semicolon
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_if
c_cond
(paren
id|first_pass
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;imm: using non-queuing interface&bslash;n&quot;
)paren
suffix:semicolon
id|first_pass
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|imm_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IMM: bug in imm_command&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|imm_hosts
(braket
id|host_no
)braket
dot
id|failed
op_assign
l_int|0
suffix:semicolon
id|imm_hosts
(braket
id|host_no
)braket
dot
id|jstart
op_assign
id|jiffies
suffix:semicolon
id|imm_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
op_assign
id|cmd
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* default return code */
id|cmd-&gt;SCp.phase
op_assign
l_int|0
suffix:semicolon
id|imm_pb_claim
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_while
c_loop
(paren
id|imm_engine
c_func
(paren
op_amp
id|imm_hosts
(braket
id|host_no
)braket
comma
id|cmd
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;SCp.phase
)paren
multiline_comment|/* Only disconnect if we have connected */
id|imm_disconnect
c_func
(paren
id|cmd-&gt;host-&gt;unique_id
)paren
suffix:semicolon
id|imm_pb_release
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|imm_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
op_assign
l_int|0
suffix:semicolon
r_return
id|cmd-&gt;result
suffix:semicolon
)brace
multiline_comment|/*&n; * Since the IMM itself doesn&squot;t generate interrupts, we use&n; * the scheduler&squot;s task queue to generate a stream of call-backs and&n; * complete the request when the drive is ready.&n; */
DECL|function|imm_interrupt
r_static
r_void
id|imm_interrupt
c_func
(paren
r_void
op_star
id|data
)paren
(brace
id|imm_struct
op_star
id|tmp
op_assign
(paren
id|imm_struct
op_star
)paren
id|data
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
op_assign
id|tmp-&gt;cur_cmd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IMM: bug in imm_interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|imm_engine
c_func
(paren
id|tmp
comma
id|cmd
)paren
)paren
(brace
id|tmp-&gt;imm_tq.data
op_assign
(paren
r_void
op_star
)paren
id|tmp
suffix:semicolon
id|tmp-&gt;imm_tq.sync
op_assign
l_int|0
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|tmp-&gt;imm_tq
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Command must of completed hence it is safe to let go... */
macro_line|#if IMM_DEBUG &gt; 0
r_switch
c_cond
(paren
(paren
id|cmd-&gt;result
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
(brace
r_case
id|DID_OK
suffix:colon
r_break
suffix:semicolon
r_case
id|DID_NO_CONNECT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: no device at SCSI ID %i&bslash;n&quot;
comma
id|cmd-&gt;target
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_BUS_BUSY
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: BUS BUSY - EPP timeout detected&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_TIME_OUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: unknown timeout&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_ABORT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: told to abort&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_PARITY
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: parity error (???)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_ERROR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: internal driver error&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_RESET
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: told to reset device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_BAD_INTR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: bad interrupt (???)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: bad return code (%02x)&bslash;n&quot;
comma
(paren
id|cmd-&gt;result
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|cmd-&gt;SCp.phase
OG
l_int|1
)paren
id|imm_disconnect
c_func
(paren
id|cmd-&gt;host-&gt;unique_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;SCp.phase
OG
l_int|0
)paren
id|imm_pb_release
c_func
(paren
id|cmd-&gt;host-&gt;unique_id
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|tmp-&gt;cur_cmd
op_assign
l_int|0
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|imm_engine
r_static
r_int
id|imm_engine
c_func
(paren
id|imm_struct
op_star
id|tmp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|IMM_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_int
r_char
id|l
op_assign
l_int|0
comma
id|h
op_assign
l_int|0
suffix:semicolon
r_int
id|retv
comma
id|x
suffix:semicolon
multiline_comment|/* First check for any errors that may of occurred&n;     * Here we check for internal errors&n;     */
r_if
c_cond
(paren
id|tmp-&gt;failed
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;SCp.phase
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Phase 0 - Waiting for parport */
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|tmp-&gt;jstart
)paren
OG
id|HZ
)paren
(brace
multiline_comment|/*&n;&t;     * We waited more than a second&n;&t;     * for parport to call us&n;&t;     */
id|imm_fail
c_func
(paren
id|host_no
comma
id|DID_BUS_BUSY
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* wait until imm_wakeup claims parport */
multiline_comment|/* Phase 1 - Connected */
r_case
l_int|1
suffix:colon
id|imm_connect
c_func
(paren
id|host_no
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
multiline_comment|/* Phase 2 - We are now talking to the scsi bus */
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|imm_select
c_func
(paren
id|host_no
comma
id|cmd-&gt;target
)paren
)paren
(brace
id|imm_fail
c_func
(paren
id|host_no
comma
id|DID_NO_CONNECT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
multiline_comment|/* Phase 3 - Ready to accept a command */
r_case
l_int|3
suffix:colon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x80
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|imm_send_command
c_func
(paren
id|cmd
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
multiline_comment|/* Phase 4 - Setup scatter/gather buffers */
r_case
l_int|4
suffix:colon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
multiline_comment|/* if many buffers are available, start filling the first */
id|cmd-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|cmd-&gt;SCp.buffer-&gt;address
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* else fill the only available buffer */
id|cmd-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|cmd-&gt;request_buffer
suffix:semicolon
)brace
id|cmd-&gt;SCp.buffers_residual
op_assign
id|cmd-&gt;use_sg
suffix:semicolon
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;SCp.this_residual
op_amp
l_int|0x01
)paren
id|cmd-&gt;SCp.this_residual
op_increment
suffix:semicolon
multiline_comment|/* Phase 5 - Pre-Data transfer stage */
r_case
l_int|5
suffix:colon
multiline_comment|/* Spin lock for BUSY */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x80
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Require negotiation for read requests */
id|x
op_assign
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0xb8
)paren
suffix:semicolon
id|tmp-&gt;rd
op_assign
(paren
id|x
op_amp
l_int|0x10
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|tmp-&gt;dp
op_assign
(paren
id|x
op_amp
l_int|0x20
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp-&gt;dp
)paren
op_logical_and
(paren
id|tmp-&gt;rd
)paren
)paren
r_if
c_cond
(paren
id|imm_negotiate
c_func
(paren
id|tmp
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
multiline_comment|/* Phase 6 - Data transfer stage */
r_case
l_int|6
suffix:colon
multiline_comment|/* Spin lock for BUSY */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x80
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;dp
)paren
(brace
id|retv
op_assign
id|imm_completion
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retv
op_eq
op_minus
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|retv
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
)brace
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
multiline_comment|/* Phase 7 - Post data transfer stage */
r_case
l_int|7
suffix:colon
r_if
c_cond
(paren
(paren
id|tmp-&gt;dp
)paren
op_logical_and
(paren
id|tmp-&gt;rd
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|tmp-&gt;mode
op_eq
id|IMM_NIBBLE
)paren
op_logical_or
(paren
id|tmp-&gt;mode
op_eq
id|IMM_PS2
)paren
)paren
(brace
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xe
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
)brace
)brace
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
multiline_comment|/* Phase 8 - Read status/message */
r_case
l_int|8
suffix:colon
multiline_comment|/* Check for data overrun */
r_if
c_cond
(paren
id|imm_wait
c_func
(paren
id|host_no
)paren
op_ne
(paren
r_int
r_char
)paren
l_int|0xb8
)paren
(brace
id|imm_fail
c_func
(paren
id|host_no
comma
id|DID_ERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|imm_negotiate
c_func
(paren
id|tmp
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|imm_in
c_func
(paren
id|host_no
comma
op_amp
id|l
comma
l_int|1
)paren
)paren
(brace
multiline_comment|/* read status byte */
multiline_comment|/* Check for optional message byte */
r_if
c_cond
(paren
id|imm_wait
c_func
(paren
id|host_no
)paren
op_eq
(paren
r_int
r_char
)paren
l_int|0xb8
)paren
id|imm_in
c_func
(paren
id|host_no
comma
op_amp
id|h
comma
l_int|1
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_OK
op_lshift
l_int|16
)paren
op_plus
(paren
id|l
op_amp
id|STATUS_MASK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|tmp-&gt;mode
op_eq
id|IMM_NIBBLE
)paren
op_logical_or
(paren
id|tmp-&gt;mode
op_eq
id|IMM_PS2
)paren
)paren
(brace
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xe
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Finished */
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: Invalid scsi phase&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|imm_queuecommand
r_int
id|imm_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_if
c_cond
(paren
id|imm_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IMM: bug in imm_queuecommand&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|imm_hosts
(braket
id|host_no
)braket
dot
id|failed
op_assign
l_int|0
suffix:semicolon
id|imm_hosts
(braket
id|host_no
)braket
dot
id|jstart
op_assign
id|jiffies
suffix:semicolon
id|imm_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
op_assign
id|cmd
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* default return code */
id|cmd-&gt;SCp.phase
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bus free */
id|imm_pb_claim
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|imm_hosts
(braket
id|host_no
)braket
dot
id|imm_tq.data
op_assign
id|imm_hosts
op_plus
id|host_no
suffix:semicolon
id|imm_hosts
(braket
id|host_no
)braket
dot
id|imm_tq.sync
op_assign
l_int|0
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|imm_hosts
(braket
id|host_no
)braket
dot
id|imm_tq
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Apparently the the disk-&gt;capacity attribute is off by 1 sector &n; * for all disk drives.  We add the one here, but it should really&n; * be done in sd.c.  Even if it gets fixed there, this will still&n; * work.&n; */
DECL|function|imm_biosparam
r_int
id|imm_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
id|ip
(braket
)braket
)paren
(brace
id|ip
(braket
l_int|0
)braket
op_assign
l_int|0x40
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|0x20
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
(paren
id|disk-&gt;capacity
op_plus
l_int|1
)paren
op_div
(paren
id|ip
(braket
l_int|0
)braket
op_star
id|ip
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
(braket
l_int|2
)braket
OG
l_int|1024
)paren
(brace
id|ip
(braket
l_int|0
)braket
op_assign
l_int|0xff
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|0x3f
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
(paren
id|disk-&gt;capacity
op_plus
l_int|1
)paren
op_div
(paren
id|ip
(braket
l_int|0
)braket
op_star
id|ip
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|imm_abort
r_int
id|imm_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
multiline_comment|/*&n;     * There is no method for aborting commands since Iomega&n;     * have tied the SCSI_MESSAGE line high in the interface&n;     */
r_switch
c_cond
(paren
id|cmd-&gt;SCp.phase
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Do not have access to parport */
r_case
l_int|1
suffix:colon
multiline_comment|/* Have not connected to interface */
id|imm_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Forget the problem */
r_return
id|SUCCESS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* SCSI command sent, can not abort */
r_return
id|FAILED
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|imm_reset_pulse
r_void
id|imm_reset_pulse
c_func
(paren
r_int
r_int
id|base
)paren
(brace
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x04
)paren
suffix:semicolon
id|w_dtr
c_func
(paren
id|base
comma
l_int|0x40
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x0c
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x0d
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x0c
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x04
)paren
suffix:semicolon
)brace
DECL|function|imm_reset
r_int
id|imm_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|host_no
op_assign
id|cmd-&gt;host-&gt;unique_id
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;SCp.phase
)paren
id|imm_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|imm_hosts
(braket
id|host_no
)braket
dot
id|cur_cmd
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Forget the problem */
id|imm_connect
c_func
(paren
id|host_no
comma
id|CONNECT_NORMAL
)paren
suffix:semicolon
id|imm_reset_pulse
c_func
(paren
id|IMM_BASE
c_func
(paren
id|host_no
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* device settle delay */
id|imm_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* device settle delay */
r_return
id|SUCCESS
suffix:semicolon
)brace
DECL|function|device_check
r_static
r_int
id|device_check
c_func
(paren
r_int
id|host_no
)paren
(brace
multiline_comment|/* This routine looks for a device and then attempts to use EPP&n;       to send a command. If all goes as planned then EPP is available. */
r_static
r_char
id|cmd
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_int
id|loop
comma
id|old_mode
comma
id|status
comma
id|k
comma
id|ppb
op_assign
id|IMM_BASE
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_int
r_char
id|l
suffix:semicolon
id|old_mode
op_assign
id|imm_hosts
(braket
id|host_no
)braket
dot
id|mode
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
l_int|8
suffix:semicolon
id|loop
op_increment
)paren
(brace
multiline_comment|/* Attempt to use EPP for Test Unit Ready */
r_if
c_cond
(paren
(paren
id|ppb
op_amp
l_int|0x0007
)paren
op_eq
l_int|0x0000
)paren
id|imm_hosts
(braket
id|host_no
)braket
dot
id|mode
op_assign
id|IMM_EPP_32
suffix:semicolon
id|second_pass
suffix:colon
id|imm_connect
c_func
(paren
id|host_no
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
multiline_comment|/* Select SCSI device */
r_if
c_cond
(paren
op_logical_neg
id|imm_select
c_func
(paren
id|host_no
comma
id|loop
)paren
)paren
(brace
id|imm_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;imm: Found device at ID %i, Attempting to use %s&bslash;n&quot;
comma
id|loop
comma
id|IMM_MODE_STRING
(braket
id|imm_hosts
(braket
id|host_no
)braket
dot
id|mode
)braket
)paren
suffix:semicolon
multiline_comment|/* Send SCSI command */
id|status
op_assign
l_int|1
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
(paren
id|l
OL
l_int|3
)paren
op_logical_and
(paren
id|status
)paren
suffix:semicolon
id|l
op_increment
)paren
id|status
op_assign
id|imm_out
c_func
(paren
id|host_no
comma
op_amp
id|cmd
(braket
id|l
op_lshift
l_int|1
)braket
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
id|imm_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|imm_connect
c_func
(paren
id|host_no
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
id|imm_reset_pulse
c_func
(paren
id|IMM_BASE
c_func
(paren
id|host_no
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|imm_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imm_hosts
(braket
id|host_no
)braket
dot
id|mode
op_eq
id|IMM_EPP_32
)paren
(brace
id|imm_hosts
(braket
id|host_no
)braket
dot
id|mode
op_assign
id|old_mode
suffix:semicolon
r_goto
id|second_pass
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;imm: Unable to establish communication, aborting driver load.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|k
op_assign
l_int|1000000
suffix:semicolon
multiline_comment|/* 1 Second */
r_do
(brace
id|l
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|k
op_decrement
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|l
op_amp
l_int|0x80
)paren
op_logical_and
(paren
id|k
)paren
)paren
suffix:semicolon
id|l
op_and_assign
l_int|0xb8
suffix:semicolon
r_if
c_cond
(paren
id|l
op_ne
l_int|0xb8
)paren
(brace
id|imm_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|imm_connect
c_func
(paren
id|host_no
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
id|imm_reset_pulse
c_func
(paren
id|IMM_BASE
c_func
(paren
id|host_no
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|imm_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imm_hosts
(braket
id|host_no
)braket
dot
id|mode
op_eq
id|IMM_EPP_32
)paren
(brace
id|imm_hosts
(braket
id|host_no
)braket
dot
id|mode
op_assign
id|old_mode
suffix:semicolon
r_goto
id|second_pass
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;imm: Unable to establish communication, aborting driver load.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|imm_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;imm: Communication established at 0x%x with ID %i using %s&bslash;n&quot;
comma
id|ppb
comma
id|loop
comma
id|IMM_MODE_STRING
(braket
id|imm_hosts
(braket
id|host_no
)braket
dot
id|mode
)braket
)paren
suffix:semicolon
id|imm_connect
c_func
(paren
id|host_no
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
id|imm_reset_pulse
c_func
(paren
id|IMM_BASE
c_func
(paren
id|host_no
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|imm_disconnect
c_func
(paren
id|host_no
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;imm: No devices found, aborting driver load.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
eof
