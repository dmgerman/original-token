multiline_comment|/*&n; *  History:&n; *  Started: Aug 9 by Lawrence Foard (entropy@world.std.com),&n; *           to allow user process control of SCSI devices.&n; *  Development Sponsored by Killy Corp. NY NY&n; *&n; * Original driver (sg.c):&n; *        Copyright (C) 1992 Lawrence Foard&n; * 2.x extensions to driver:&n; *        Copyright (C) 1998, 1999 Douglas Gilbert&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; *  Borrows code from st driver. Thanks to Alessandro Rubini&squot;s &quot;dd&quot; book.&n; */
DECL|variable|sg_version_str
r_static
r_char
op_star
id|sg_version_str
op_assign
l_string|&quot;Version: 2.1.32 (990501)&quot;
suffix:semicolon
multiline_comment|/*&n; *  D. P. Gilbert (dgilbert@interlog.com, dougg@triode.net.au)&n; *      - scatter list logic replaces previous large atomic SG_BIG_BUFF&n; *        sized allocation. See notes in &lt;scsi/sg.h&gt; include file. &n; * &n; *      - scsi logging is available via SCSI_LOG_TIMEOUT macros. First&n; *        the kernel/module needs to be built with CONFIG_SCSI_LOGGING&n; *        (otherwise the macros compile to empty statements), then do&n; *        something like: &squot;echo &quot;scsi log all&quot; &gt; /proc/scsi/scsi&squot; to log&n; *        everything or &squot;echo &quot;scsi log {token} #N&quot; &gt; /proc/scsi/scsi&squot;&n; *        where {token} is one of [error,timeout,scan,mlqueue,mlcomplete,&n; *        llqueue,llcomplete,hlqueue,hlcomplete,ioctl] and #N is 0...7&n; *        (with 0 meaning off). For example: &squot;scsi log timeout 7 &gt; &n; *        /proc/scsi/scsi&squot; to get all logging messages from this driver.&n; *        Should use hlcomplete but it is too &quot;noisy&quot; (sd uses it).&n; *&n; *      - This driver obtains memory (heap) for the low-level driver to&n; *        transfer/dma to and from. It is obtained from up to 4 sources:&n; *              - 1 SG_SCATTER_SZ sized buffer on open() (per fd)&n; *                [could be less if SG_SCATTER_SZ bytes not available]&n; *              - obtain heap as required on write()s (get_free_pages)&n; *              - obtain heap from the shared scsi dma pool&n; *              - obtain heap from kernel directly (kmalloc) [last choice]&n; *        the &squot;alt_address&squot; field in the scatter_list structure and the&n; *        related &squot;mem_src&squot; indicate the source of the heap allocation.&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mtio.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &lt;scsi/scsi_ioctl.h&gt;
macro_line|#include &lt;scsi/sg.h&gt;
DECL|variable|sg_big_buff
r_int
id|sg_big_buff
op_assign
id|SG_SCATTER_SZ
suffix:semicolon
multiline_comment|/* sg_big_buff is ro through sysctl */
multiline_comment|/* N.B. This global is here to keep existing software happy. It now holds&n;   the size of the &quot;first buffer&quot; of the most recent sucessful sg_open(). &n;   Only available when &squot;sg&squot; compiled into kernel (rather than a module). &n;   This should probably be deprecated (use SG_GET_RESERVED_SIZE instead). */
DECL|macro|SG_SECTOR_SZ
mdefine_line|#define SG_SECTOR_SZ 512
DECL|macro|SG_SECTOR_MSK
mdefine_line|#define SG_SECTOR_MSK (SG_SECTOR_SZ - 1)
DECL|macro|SG_LOW_POOL_THRESHHOLD
mdefine_line|#define SG_LOW_POOL_THRESHHOLD 30
DECL|macro|SG_MAX_POOL_SECTORS
mdefine_line|#define SG_MAX_POOL_SECTORS 320  /* Max. number of pool sectors to take */
DECL|variable|sg_pool_secs_avail
r_static
r_int
id|sg_pool_secs_avail
op_assign
id|SG_MAX_POOL_SECTORS
suffix:semicolon
multiline_comment|/* #define SG_DEBUG */
multiline_comment|/* for counting varieties of allocations */
macro_line|#ifdef SG_DEBUG
DECL|variable|sg_num_kmal
r_static
r_int
id|sg_num_kmal
op_assign
l_int|0
suffix:semicolon
DECL|variable|sg_num_pool
r_static
r_int
id|sg_num_pool
op_assign
l_int|0
suffix:semicolon
DECL|variable|sg_num_page
r_static
r_int
id|sg_num_page
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|macro|SG_HEAP_FB
mdefine_line|#define SG_HEAP_FB 0    /* heap obtained at open() (one buffer per fd) */
DECL|macro|SG_HEAP_PAGE
mdefine_line|#define SG_HEAP_PAGE 1  /* heap from kernel via get_free_pages() */
DECL|macro|SG_HEAP_KMAL
mdefine_line|#define SG_HEAP_KMAL 2  /* heap from kernel via kmalloc() */
DECL|macro|SG_HEAP_POOL
mdefine_line|#define SG_HEAP_POOL 3  /* heap from scsi dma pool (mid-level) */
r_static
r_int
id|sg_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|sg_attach
c_func
(paren
id|Scsi_Device
op_star
)paren
suffix:semicolon
r_static
r_void
id|sg_finish
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|sg_detect
c_func
(paren
id|Scsi_Device
op_star
)paren
suffix:semicolon
r_static
r_void
id|sg_detach
c_func
(paren
id|Scsi_Device
op_star
)paren
suffix:semicolon
DECL|variable|sg_template
r_struct
id|Scsi_Device_Template
id|sg_template
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;sg&quot;
comma
l_int|NULL
comma
l_int|0xff
comma
id|SCSI_GENERIC_MAJOR
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|sg_detect
comma
id|sg_init
comma
id|sg_finish
comma
id|sg_attach
comma
id|sg_detach
)brace
suffix:semicolon
DECL|struct|sg_scatter_hold
r_typedef
r_struct
id|sg_scatter_hold
multiline_comment|/* holding area for scsi scatter gather info */
(brace
DECL|member|use_sg
r_int
r_int
id|use_sg
suffix:semicolon
multiline_comment|/* Number of pieces of scatter-gather */
DECL|member|sglist_len
r_int
r_int
id|sglist_len
suffix:semicolon
multiline_comment|/* size of malloc&squot;d scatter-gather list */
DECL|member|bufflen
r_int
id|bufflen
suffix:semicolon
multiline_comment|/* Size of data buffer */
DECL|member|b_malloc_len
r_int
id|b_malloc_len
suffix:semicolon
multiline_comment|/* actual len malloc&squot;ed in buffer */
DECL|member|buffer
r_void
op_star
id|buffer
suffix:semicolon
multiline_comment|/* Data buffer or scatter list (12 bytes) */
DECL|member|mem_src
r_char
id|mem_src
suffix:semicolon
multiline_comment|/* heap whereabouts of &squot;buffer&squot; */
DECL|typedef|Sg_scatter_hold
)brace
id|Sg_scatter_hold
suffix:semicolon
multiline_comment|/* 20 bytes long on i386 */
r_struct
id|sg_device
suffix:semicolon
multiline_comment|/* forward declarations */
r_struct
id|sg_fd
suffix:semicolon
DECL|struct|sg_request
r_typedef
r_struct
id|sg_request
multiline_comment|/* SG_MAX_QUEUE requests outstanding per file */
(brace
DECL|member|my_cmdp
id|Scsi_Cmnd
op_star
id|my_cmdp
suffix:semicolon
multiline_comment|/* NULL -&gt; ready to read, else id */
DECL|member|nextrp
r_struct
id|sg_request
op_star
id|nextrp
suffix:semicolon
multiline_comment|/* NULL -&gt; tail request (slist) */
DECL|member|parentfp
r_struct
id|sg_fd
op_star
id|parentfp
suffix:semicolon
multiline_comment|/* NULL -&gt; not in use */
DECL|member|data
id|Sg_scatter_hold
id|data
suffix:semicolon
multiline_comment|/* hold buffers, perhaps scatter list */
DECL|member|header
r_struct
id|sg_header
id|header
suffix:semicolon
multiline_comment|/* scsi command+info &lt;include/sg.h&gt; */
DECL|member|fb_used
r_char
id|fb_used
suffix:semicolon
multiline_comment|/* 1 -&gt; using fst_buf, normally 0 (used) */
DECL|typedef|Sg_request
)brace
id|Sg_request
suffix:semicolon
multiline_comment|/* around 72 bytes long on i386 */
DECL|struct|sg_fd
r_typedef
r_struct
id|sg_fd
multiline_comment|/* holds the state of a file descriptor */
(brace
DECL|member|nextfp
r_struct
id|sg_fd
op_star
id|nextfp
suffix:semicolon
multiline_comment|/* NULL when last opened fd on this device */
DECL|member|parentdp
r_struct
id|sg_device
op_star
id|parentdp
suffix:semicolon
multiline_comment|/* owning device */
DECL|member|read_wait
id|wait_queue_head_t
id|read_wait
suffix:semicolon
multiline_comment|/* queue read until command done */
DECL|member|timeout
r_int
id|timeout
suffix:semicolon
multiline_comment|/* defaults to SG_DEFAULT_TIMEOUT */
DECL|member|fst_buf
r_char
op_star
id|fst_buf
suffix:semicolon
multiline_comment|/* try to grab SG_SCATTER_SZ sized buffer on open */
DECL|member|fb_size
r_int
id|fb_size
suffix:semicolon
multiline_comment|/* actual size of allocated fst_buf */
DECL|member|headrp
id|Sg_request
op_star
id|headrp
suffix:semicolon
multiline_comment|/* head of request slist, NULL-&gt;empty */
DECL|member|async_qp
r_struct
id|fasync_struct
op_star
id|async_qp
suffix:semicolon
multiline_comment|/* used by asynchronous notification */
DECL|member|req_arr
id|Sg_request
id|req_arr
(braket
id|SG_MAX_QUEUE
)braket
suffix:semicolon
multiline_comment|/* used as singly-linked list */
DECL|member|low_dma
r_char
id|low_dma
suffix:semicolon
multiline_comment|/* as in parent but possible overridden to 1 */
DECL|member|force_packid
r_char
id|force_packid
suffix:semicolon
multiline_comment|/* 1 -&gt; pack_id input to read(), 0 -&gt; ignored */
DECL|member|closed
r_char
id|closed
suffix:semicolon
multiline_comment|/* 1 -&gt; fd closed but request(s) outstanding */
DECL|member|my_mem_src
r_char
id|my_mem_src
suffix:semicolon
multiline_comment|/* heap whereabouts of this sg_fb object */
DECL|member|cmd_q
r_char
id|cmd_q
suffix:semicolon
multiline_comment|/* 1 -&gt; allow command queuing, 0 -&gt; don&squot;t */
DECL|member|underrun_flag
r_char
id|underrun_flag
suffix:semicolon
multiline_comment|/* 1 -&gt; flag underruns, 0 -&gt; don&squot;t, 2 -&gt; test */
DECL|typedef|Sg_fd
)brace
id|Sg_fd
suffix:semicolon
multiline_comment|/* around 1192 bytes long on i386 */
DECL|struct|sg_device
r_typedef
r_struct
id|sg_device
multiline_comment|/* holds the state of each scsi generic device */
(brace
DECL|member|device
id|Scsi_Device
op_star
id|device
suffix:semicolon
DECL|member|generic_wait
id|wait_queue_head_t
id|generic_wait
suffix:semicolon
multiline_comment|/* queue open if O_EXCL on prev. open */
DECL|member|sg_tablesize
r_int
id|sg_tablesize
suffix:semicolon
multiline_comment|/* adapter&squot;s max scatter-gather table size */
DECL|member|headfp
id|Sg_fd
op_star
id|headfp
suffix:semicolon
multiline_comment|/* first open fd belonging to this device */
DECL|member|i_rdev
id|kdev_t
id|i_rdev
suffix:semicolon
multiline_comment|/* holds device major+minor number */
DECL|member|exclude
r_char
id|exclude
suffix:semicolon
multiline_comment|/* opened for exclusive access */
DECL|member|sgdebug
r_char
id|sgdebug
suffix:semicolon
multiline_comment|/* 0-&gt;off, 1-&gt;sense, 9-&gt;dump dev, 10-&gt; all devs */
DECL|member|merge_fd
r_int
r_char
id|merge_fd
suffix:semicolon
multiline_comment|/* 0-&gt;sequencing per fd (def) else fd count */
DECL|typedef|Sg_device
)brace
id|Sg_device
suffix:semicolon
multiline_comment|/* around 24 bytes long on i386 */
r_static
r_int
id|sg_fasync
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|mode
)paren
suffix:semicolon
r_static
r_void
id|sg_command_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_static
r_int
id|sg_sc_build
c_func
(paren
id|Sg_request
op_star
id|srp
comma
r_int
id|max_buff_size
comma
r_const
r_char
op_star
id|inp
comma
r_int
id|num_write_xfer
)paren
suffix:semicolon
r_static
r_int
id|sg_sc_undo_rem
c_func
(paren
id|Sg_request
op_star
id|srp
comma
r_char
op_star
id|outp
comma
r_int
id|num_read_xfer
)paren
suffix:semicolon
r_static
r_char
op_star
id|sg_malloc
c_func
(paren
id|Sg_request
op_star
id|srp
comma
r_int
id|size
comma
r_int
op_star
id|retSzp
comma
r_int
op_star
id|mem_srcp
)paren
suffix:semicolon
r_static
r_void
id|sg_free
c_func
(paren
id|Sg_request
op_star
id|srp
comma
r_char
op_star
id|buff
comma
r_int
id|size
comma
r_int
id|mem_src
)paren
suffix:semicolon
r_static
r_char
op_star
id|sg_low_malloc
c_func
(paren
r_int
id|rqSz
comma
r_int
id|lowDma
comma
r_int
id|mem_src
comma
r_int
op_star
id|retSzp
)paren
suffix:semicolon
r_static
r_void
id|sg_low_free
c_func
(paren
r_char
op_star
id|buff
comma
r_int
id|size
comma
r_int
id|mem_src
)paren
suffix:semicolon
r_static
id|Sg_fd
op_star
id|sg_add_sfp
c_func
(paren
id|Sg_device
op_star
id|sdp
comma
r_int
id|dev
comma
r_int
id|get_reserved
)paren
suffix:semicolon
r_static
r_int
id|sg_remove_sfp
c_func
(paren
id|Sg_device
op_star
id|sdp
comma
id|Sg_fd
op_star
id|sfp
)paren
suffix:semicolon
r_static
id|Sg_request
op_star
id|sg_get_request
c_func
(paren
r_const
id|Sg_fd
op_star
id|sfp
comma
r_int
id|pack_id
)paren
suffix:semicolon
r_static
id|Sg_request
op_star
id|sg_add_request
c_func
(paren
id|Sg_fd
op_star
id|sfp
)paren
suffix:semicolon
r_static
r_int
id|sg_remove_request
c_func
(paren
id|Sg_fd
op_star
id|sfp
comma
r_const
id|Sg_request
op_star
id|srp
)paren
suffix:semicolon
r_static
r_int
id|sg_fb_in_use
c_func
(paren
r_const
id|Sg_fd
op_star
id|sfp
)paren
suffix:semicolon
r_static
r_void
id|sg_clr_scpnt
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_static
r_void
id|sg_shorten_timeout
c_func
(paren
id|Scsi_Cmnd
op_star
id|scpnt
)paren
suffix:semicolon
r_static
r_void
id|sg_debug
c_func
(paren
r_const
id|Sg_device
op_star
id|sdp
comma
r_const
id|Sg_fd
op_star
id|sfp
comma
r_int
id|part_of
)paren
suffix:semicolon
r_static
r_void
id|sg_debug_all
c_func
(paren
r_const
id|Sg_fd
op_star
id|sfp
)paren
suffix:semicolon
DECL|variable|sg_dev_arr
r_static
id|Sg_device
op_star
id|sg_dev_arr
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|size_sg_header
r_static
r_const
r_int
id|size_sg_header
op_assign
r_sizeof
(paren
r_struct
id|sg_header
)paren
suffix:semicolon
DECL|function|sg_open
r_static
r_int
id|sg_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|dev
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_int
id|flags
op_assign
id|filp-&gt;f_flags
suffix:semicolon
id|Sg_device
op_star
id|sdp
suffix:semicolon
id|Sg_fd
op_star
id|sfp
suffix:semicolon
r_if
c_cond
(paren
(paren
l_int|NULL
op_eq
id|sg_dev_arr
)paren
op_logical_or
(paren
id|dev
OL
l_int|0
)paren
op_logical_or
(paren
id|dev
op_ge
id|sg_template.dev_max
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|sdp
op_assign
op_amp
id|sg_dev_arr
(braket
id|dev
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|sdp-&gt;device
)paren
op_logical_or
(paren
op_logical_neg
id|sdp-&gt;device-&gt;host
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|sdp-&gt;i_rdev
op_ne
id|inode-&gt;i_rdev
)paren
id|printk
c_func
(paren
l_string|&quot;sg_open: inode maj=%d, min=%d   sdp maj=%d, min=%d&bslash;n&quot;
comma
id|MAJOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
comma
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
comma
id|MAJOR
c_func
(paren
id|sdp-&gt;i_rdev
)paren
comma
id|MINOR
c_func
(paren
id|sdp-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_block_when_processing_errors
c_func
(paren
id|sdp-&gt;device
)paren
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*  if (O_RDWR != (flags &amp; O_ACCMODE)) */
multiline_comment|/*      return -EACCES;   May just want to get to a ioctl, so remove */
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;sg_open: dev=%d, flags=0x%x&bslash;n&quot;
comma
id|dev
comma
id|flags
)paren
)paren
suffix:semicolon
multiline_comment|/* If we want exclusive access, then wait until the device is not&n;    * busy, and then set the flag to prevent anyone else from using it. */
r_if
c_cond
(paren
id|flags
op_amp
id|O_EXCL
)paren
(brace
r_if
c_cond
(paren
id|O_RDONLY
op_eq
(paren
id|flags
op_amp
id|O_ACCMODE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* Can&squot;t lock it with read only access */
r_while
c_loop
(paren
id|sdp-&gt;headfp
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|sdp-&gt;generic_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|sdp-&gt;exclude
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Wait until nobody has an exclusive open on this device. */
r_while
c_loop
(paren
id|sdp-&gt;exclude
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|sdp-&gt;generic_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
multiline_comment|/* OK, we should have grabbed the device.  Mark the thing so&n;     * that other processes know that we have it, and initialize the&n;     * state variables to known values. */
r_if
c_cond
(paren
op_logical_neg
id|sdp-&gt;headfp
)paren
(brace
multiline_comment|/* no existing opens on this device */
id|sdp-&gt;sgdebug
op_assign
l_int|0
suffix:semicolon
id|sdp-&gt;sg_tablesize
op_assign
id|sdp-&gt;device-&gt;host-&gt;sg_tablesize
suffix:semicolon
id|sdp-&gt;merge_fd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* A little tricky if SG_DEF_MERGE_FD set */
)brace
r_if
c_cond
(paren
(paren
id|sfp
op_assign
id|sg_add_sfp
c_func
(paren
id|sdp
comma
id|dev
comma
id|O_RDWR
op_eq
(paren
id|flags
op_amp
id|O_ACCMODE
)paren
)paren
)paren
)paren
(brace
id|filp-&gt;private_data
op_assign
id|sfp
suffix:semicolon
macro_line|#if SG_DEF_MERGE_FD
r_if
c_cond
(paren
l_int|0
op_eq
id|sdp-&gt;merge_fd
)paren
id|sdp-&gt;merge_fd
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|O_EXCL
)paren
id|sdp-&gt;exclude
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* undo if error */
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sdp-&gt;device-&gt;host-&gt;hostt-&gt;module
)paren
id|__MOD_INC_USE_COUNT
c_func
(paren
id|sdp-&gt;device-&gt;host-&gt;hostt-&gt;module
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sg_template.module
)paren
id|__MOD_INC_USE_COUNT
c_func
(paren
id|sg_template.module
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Following function was formerly called &squot;sg_close&squot; */
DECL|function|sg_release
r_static
r_int
id|sg_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|Sg_device
op_star
id|sdp
suffix:semicolon
id|Sg_fd
op_star
id|sfp
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|sfp
op_assign
(paren
id|Sg_fd
op_star
)paren
id|filp-&gt;private_data
)paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|sdp
op_assign
id|sfp-&gt;parentdp
)paren
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;sg_release: dev=%d&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|sdp-&gt;i_rdev
)paren
)paren
)paren
suffix:semicolon
id|sg_fasync
c_func
(paren
op_minus
l_int|1
comma
id|filp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* remove filp from async notification list */
id|sg_remove_sfp
c_func
(paren
id|sdp
comma
id|sfp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sdp-&gt;headfp
)paren
(brace
id|filp-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
id|sdp-&gt;merge_fd
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sdp-&gt;device-&gt;host-&gt;hostt-&gt;module
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|sdp-&gt;device-&gt;host-&gt;hostt-&gt;module
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sg_template.module
)paren
(brace
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|sg_template.module
)paren
suffix:semicolon
)brace
id|sdp-&gt;exclude
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|sdp-&gt;generic_wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Read back the results of a SCSI command which was sent in a prior&n;   write(). */
DECL|function|sg_read
r_static
id|ssize_t
id|sg_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|k
suffix:semicolon
id|Sg_device
op_star
id|sdp
suffix:semicolon
id|Sg_fd
op_star
id|sfp
suffix:semicolon
id|Sg_request
op_star
id|srp
suffix:semicolon
r_int
id|req_pack_id
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|sg_header
op_star
id|shp
op_assign
(paren
r_struct
id|sg_header
op_star
)paren
id|buf
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|sfp
op_assign
(paren
id|Sg_fd
op_star
)paren
id|filp-&gt;private_data
)paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|sdp
op_assign
id|sfp-&gt;parentdp
)paren
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;sg_read: dev=%d, count=%d&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|sdp-&gt;i_rdev
)paren
comma
(paren
r_int
)paren
id|count
)paren
)paren
suffix:semicolon
multiline_comment|/* If we are in the middle of error recovery, don&squot;t let anyone&n;     * else try and use this device.  Also, if error recovery fails, it&n;     * may try and take the device offline, in which case all further&n;     * access to the device is prohibited.  */
r_if
c_cond
(paren
op_logical_neg
id|scsi_block_when_processing_errors
c_func
(paren
id|sdp-&gt;device
)paren
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|filp-&gt;f_pos
)paren
suffix:semicolon
multiline_comment|/* FIXME: Hmm.  Seek to the right place, or fail?  */
r_if
c_cond
(paren
(paren
id|k
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|count
)paren
)paren
)paren
r_return
id|k
suffix:semicolon
r_if
c_cond
(paren
id|sfp-&gt;force_packid
op_logical_and
(paren
id|count
op_ge
id|size_sg_header
)paren
)paren
id|req_pack_id
op_assign
id|shp-&gt;pack_id
suffix:semicolon
id|srp
op_assign
id|sg_get_request
c_func
(paren
id|sfp
comma
id|req_pack_id
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|srp
)paren
(brace
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|sfp-&gt;read_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
id|srp
op_assign
id|sg_get_request
c_func
(paren
id|sfp
comma
id|req_pack_id
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
l_int|2
op_ne
id|sfp-&gt;underrun_flag
)paren
id|srp-&gt;header.pack_len
op_assign
id|srp-&gt;header.reply_len
suffix:semicolon
multiline_comment|/* Why ????? */
multiline_comment|/* Now copy the result back to the user buffer.  */
r_if
c_cond
(paren
id|count
op_ge
id|size_sg_header
)paren
(brace
id|__copy_to_user
c_func
(paren
id|buf
comma
op_amp
id|srp-&gt;header
comma
id|size_sg_header
)paren
suffix:semicolon
id|buf
op_add_assign
id|size_sg_header
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|srp-&gt;header.reply_len
)paren
id|count
op_assign
id|srp-&gt;header.reply_len
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|size_sg_header
)paren
multiline_comment|/* release does copy_to_user */
id|sg_sc_undo_rem
c_func
(paren
id|srp
comma
id|buf
comma
id|count
op_minus
id|size_sg_header
)paren
suffix:semicolon
r_else
id|sg_sc_undo_rem
c_func
(paren
id|srp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|count
op_assign
(paren
id|srp-&gt;header.result
op_eq
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
id|sg_sc_undo_rem
c_func
(paren
id|srp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|sg_write
r_static
id|ssize_t
id|sg_write
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|mxsize
comma
id|cmd_size
comma
id|k
suffix:semicolon
r_int
r_char
id|cmnd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_int
id|input_size
suffix:semicolon
r_int
r_char
id|opcode
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|Sg_device
op_star
id|sdp
suffix:semicolon
id|Sg_fd
op_star
id|sfp
suffix:semicolon
id|Sg_request
op_star
id|srp
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|sfp
op_assign
(paren
id|Sg_fd
op_star
)paren
id|filp-&gt;private_data
)paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|sdp
op_assign
id|sfp-&gt;parentdp
)paren
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;sg_write: dev=%d, count=%d&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|sdp-&gt;i_rdev
)paren
comma
(paren
r_int
)paren
id|count
)paren
)paren
suffix:semicolon
multiline_comment|/* If we are in the middle of error recovery, don&squot;t let anyone&n; * else try and use this device.  Also, if error recovery fails, it&n; * may try and take the device offline, in which case all further&n; * access to the device is prohibited.  */
r_if
c_cond
(paren
op_logical_neg
id|scsi_block_when_processing_errors
c_func
(paren
id|sdp-&gt;device
)paren
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|filp-&gt;f_pos
)paren
suffix:semicolon
multiline_comment|/* FIXME: Hmm.  Seek to the right place, or fail?  */
r_if
c_cond
(paren
(paren
id|k
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|buf
comma
id|count
)paren
)paren
)paren
r_return
id|k
suffix:semicolon
multiline_comment|/* protects following copy_from_user()s + get_user()s */
multiline_comment|/* The minimum scsi command length is 6 bytes.  If we get anything&n; * less than this, it is clearly bogus.  */
r_if
c_cond
(paren
id|count
OL
(paren
id|size_sg_header
op_plus
l_int|6
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|srp
op_assign
id|sg_add_request
c_func
(paren
id|sfp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|srp
)paren
(brace
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;sg_write: queue full, domain error&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EDOM
suffix:semicolon
)brace
id|__copy_from_user
c_func
(paren
op_amp
id|srp-&gt;header
comma
id|buf
comma
id|size_sg_header
)paren
suffix:semicolon
id|buf
op_add_assign
id|size_sg_header
suffix:semicolon
id|srp-&gt;header.pack_len
op_assign
id|count
suffix:semicolon
id|__get_user
c_func
(paren
id|opcode
comma
id|buf
)paren
suffix:semicolon
id|cmd_size
op_assign
id|COMMAND_SIZE
c_func
(paren
id|opcode
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|opcode
op_ge
l_int|0xc0
)paren
op_logical_and
id|srp-&gt;header.twelve_byte
)paren
id|cmd_size
op_assign
l_int|12
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;sg_write:   scsi opcode=0x%02x, cmd_size=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|opcode
comma
id|cmd_size
)paren
)paren
suffix:semicolon
multiline_comment|/* Determine buffer size.  */
id|input_size
op_assign
id|count
op_minus
id|cmd_size
suffix:semicolon
id|mxsize
op_assign
(paren
id|input_size
OG
id|srp-&gt;header.reply_len
)paren
ques
c_cond
id|input_size
suffix:colon
id|srp-&gt;header.reply_len
suffix:semicolon
multiline_comment|/* Don&squot;t include the command header itself in the size.  */
id|mxsize
op_sub_assign
id|size_sg_header
suffix:semicolon
id|input_size
op_sub_assign
id|size_sg_header
suffix:semicolon
multiline_comment|/* Verify user has actually passed enough bytes for this command. */
r_if
c_cond
(paren
id|input_size
OL
l_int|0
)paren
(brace
id|sg_sc_undo_rem
c_func
(paren
id|srp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* If we cannot allocate the buffer, report an error. */
r_if
c_cond
(paren
(paren
id|k
op_assign
id|sg_sc_build
c_func
(paren
id|srp
comma
id|mxsize
comma
id|buf
op_plus
id|cmd_size
comma
id|input_size
)paren
)paren
)paren
(brace
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;sg_write: build err=%d&bslash;n&quot;
comma
id|k
)paren
)paren
suffix:semicolon
id|sg_sc_undo_rem
c_func
(paren
id|srp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
id|k
suffix:semicolon
)brace
multiline_comment|/*  SCSI_LOG_TIMEOUT(7, printk(&quot;sg_write: allocating device&bslash;n&quot;)); */
multiline_comment|/* Grab a command pointer for the device we want to talk to. If we&n; * don&squot;t want to block, just return with the appropriate message.  */
r_if
c_cond
(paren
op_logical_neg
(paren
id|SCpnt
op_assign
id|scsi_allocate_device
c_func
(paren
l_int|NULL
comma
id|sdp-&gt;device
comma
op_logical_neg
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
)paren
)paren
)paren
(brace
id|sg_sc_undo_rem
c_func
(paren
id|srp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*  SCSI_LOG_TIMEOUT(7, printk(&quot;sg_write: device allocated&bslash;n&quot;)); */
id|srp-&gt;my_cmdp
op_assign
id|SCpnt
suffix:semicolon
id|SCpnt-&gt;request.rq_dev
op_assign
id|sdp-&gt;i_rdev
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_ACTIVE
suffix:semicolon
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|cmd_size
suffix:semicolon
multiline_comment|/* Now copy the SCSI command from the user&squot;s address space.  */
id|__copy_from_user
c_func
(paren
id|cmnd
comma
id|buf
comma
id|cmd_size
)paren
suffix:semicolon
multiline_comment|/* Set the LUN field in the command structure.  */
id|cmnd
(braket
l_int|1
)braket
op_assign
(paren
id|cmnd
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
op_or
(paren
id|sdp-&gt;device-&gt;lun
op_lshift
l_int|5
)paren
suffix:semicolon
multiline_comment|/*  SCSI_LOG_TIMEOUT(7, printk(&quot;sg_write: do cmd&bslash;n&quot;)); */
multiline_comment|/* Now pass the actual command down to the low-level driver.  We&n; * do not do any more here - when the interrupt arrives, we will&n; * then do the post-processing.  */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|srp-&gt;data.use_sg
suffix:semicolon
id|SCpnt-&gt;sglist_len
op_assign
id|srp-&gt;data.sglist_len
suffix:semicolon
id|SCpnt-&gt;bufflen
op_assign
id|srp-&gt;data.bufflen
suffix:semicolon
r_if
c_cond
(paren
l_int|1
op_eq
id|sfp-&gt;underrun_flag
)paren
id|SCpnt-&gt;underflow
op_assign
id|srp-&gt;data.bufflen
suffix:semicolon
r_else
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;buffer
op_assign
id|srp-&gt;data.buffer
suffix:semicolon
id|srp-&gt;data.use_sg
op_assign
l_int|0
suffix:semicolon
id|srp-&gt;data.sglist_len
op_assign
l_int|0
suffix:semicolon
id|srp-&gt;data.bufflen
op_assign
l_int|0
suffix:semicolon
id|srp-&gt;data.buffer
op_assign
l_int|NULL
suffix:semicolon
id|scsi_do_cmd
c_func
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|cmnd
comma
(paren
r_void
op_star
)paren
id|SCpnt-&gt;buffer
comma
id|mxsize
comma
id|sg_command_done
comma
id|sfp-&gt;timeout
comma
id|SG_DEFAULT_RETRIES
)paren
suffix:semicolon
multiline_comment|/* &squot;mxsize&squot; overwrites SCpnt-&gt;bufflen, hence need for b_malloc_len */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*  SCSI_LOG_TIMEOUT(6, printk(&quot;sg_write: sent scsi cmd to mid-level&bslash;n&quot;)); */
r_return
id|count
suffix:semicolon
)brace
DECL|function|sg_ioctl
r_static
r_int
id|sg_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd_in
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|result
comma
id|val
suffix:semicolon
id|Sg_device
op_star
id|sdp
suffix:semicolon
id|Sg_fd
op_star
id|sfp
suffix:semicolon
id|Sg_request
op_star
id|srp
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|sfp
op_assign
(paren
id|Sg_fd
op_star
)paren
id|filp-&gt;private_data
)paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|sdp
op_assign
id|sfp-&gt;parentdp
)paren
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;sg_ioctl: dev=%d, cmd=0x%x&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|sdp-&gt;i_rdev
)paren
comma
(paren
r_int
)paren
id|cmd_in
)paren
)paren
suffix:semicolon
multiline_comment|/* If we are in the middle of error recovery, then don&squot;t allow any&n;     *  access to this device.  Also, error recovery *may* have taken the&n;     *  device offline, in which case all further access is prohibited.  */
r_if
c_cond
(paren
op_logical_neg
id|scsi_block_when_processing_errors
c_func
(paren
id|sdp-&gt;device
)paren
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd_in
)paren
(brace
r_case
id|SG_SET_TIMEOUT
suffix:colon
r_return
id|get_user
c_func
(paren
id|sfp-&gt;timeout
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SG_GET_TIMEOUT
suffix:colon
r_return
id|sfp-&gt;timeout
suffix:semicolon
multiline_comment|/* strange ..., for backward compatibility */
r_case
id|SG_SET_FORCE_LOW_DMA
suffix:colon
id|result
op_assign
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
r_if
c_cond
(paren
(paren
l_int|0
op_eq
id|sfp-&gt;low_dma
)paren
op_logical_and
(paren
l_int|0
op_eq
id|sg_fb_in_use
c_func
(paren
id|sfp
)paren
)paren
)paren
(brace
id|sg_low_free
c_func
(paren
id|sfp-&gt;fst_buf
comma
id|sfp-&gt;fb_size
comma
id|SG_HEAP_PAGE
)paren
suffix:semicolon
id|sfp-&gt;fst_buf
op_assign
id|sg_low_malloc
c_func
(paren
id|SG_SCATTER_SZ
comma
l_int|1
comma
id|SG_HEAP_PAGE
comma
op_amp
id|sfp-&gt;fb_size
)paren
suffix:semicolon
)brace
id|sfp-&gt;low_dma
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sfp-&gt;fst_buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
id|sfp-&gt;low_dma
op_assign
id|sdp-&gt;device-&gt;host-&gt;unchecked_isa_dma
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SG_GET_LOW_DMA
suffix:colon
r_return
id|put_user
c_func
(paren
(paren
r_int
)paren
id|sfp-&gt;low_dma
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SG_GET_SCSI_ID
suffix:colon
id|result
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|Sg_scsi_id
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
r_else
(brace
id|Sg_scsi_id
op_star
id|sg_idp
op_assign
(paren
id|Sg_scsi_id
op_star
)paren
id|arg
suffix:semicolon
id|__put_user
c_func
(paren
(paren
r_int
)paren
id|sdp-&gt;device-&gt;host-&gt;host_no
comma
op_amp
id|sg_idp-&gt;host_no
)paren
suffix:semicolon
id|__put_user
c_func
(paren
(paren
r_int
)paren
id|sdp-&gt;device-&gt;channel
comma
op_amp
id|sg_idp-&gt;channel
)paren
suffix:semicolon
id|__put_user
c_func
(paren
(paren
r_int
)paren
id|sdp-&gt;device-&gt;id
comma
op_amp
id|sg_idp-&gt;scsi_id
)paren
suffix:semicolon
id|__put_user
c_func
(paren
(paren
r_int
)paren
id|sdp-&gt;device-&gt;lun
comma
op_amp
id|sg_idp-&gt;lun
)paren
suffix:semicolon
id|__put_user
c_func
(paren
(paren
r_int
)paren
id|sdp-&gt;device-&gt;type
comma
op_amp
id|sg_idp-&gt;scsi_type
)paren
suffix:semicolon
id|__put_user
c_func
(paren
l_int|0
comma
op_amp
id|sg_idp-&gt;unused1
)paren
suffix:semicolon
id|__put_user
c_func
(paren
l_int|0
comma
op_amp
id|sg_idp-&gt;unused2
)paren
suffix:semicolon
id|__put_user
c_func
(paren
l_int|0
comma
op_amp
id|sg_idp-&gt;unused3
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|SG_SET_FORCE_PACK_ID
suffix:colon
id|result
op_assign
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
id|sfp-&gt;force_packid
op_assign
id|val
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SG_GET_PACK_ID
suffix:colon
id|result
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
id|srp
op_assign
id|sfp-&gt;headrp
suffix:semicolon
r_while
c_loop
(paren
id|srp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|srp-&gt;my_cmdp
)paren
(brace
id|__put_user
c_func
(paren
id|srp-&gt;header.pack_id
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|srp
op_assign
id|srp-&gt;nextrp
suffix:semicolon
)brace
id|__put_user
c_func
(paren
op_minus
l_int|1
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SG_GET_NUM_WAITING
suffix:colon
id|srp
op_assign
id|sfp-&gt;headrp
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|srp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|srp-&gt;my_cmdp
)paren
op_increment
id|val
suffix:semicolon
id|srp
op_assign
id|srp-&gt;nextrp
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SG_GET_SG_TABLESIZE
suffix:colon
r_return
id|put_user
c_func
(paren
id|sdp-&gt;sg_tablesize
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SG_SET_RESERVED_SIZE
suffix:colon
multiline_comment|/* currently ignored, future extension */
r_if
c_cond
(paren
id|O_RDWR
op_ne
(paren
id|filp-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|result
op_assign
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
multiline_comment|/* logic should go here */
r_return
l_int|0
suffix:semicolon
r_case
id|SG_GET_RESERVED_SIZE
suffix:colon
r_return
id|put_user
c_func
(paren
id|sfp-&gt;fb_size
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SG_GET_MERGE_FD
suffix:colon
r_return
id|put_user
c_func
(paren
(paren
r_int
)paren
id|sdp-&gt;merge_fd
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SG_SET_MERGE_FD
suffix:colon
r_if
c_cond
(paren
id|O_RDWR
op_ne
(paren
id|filp-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* require write access since effect wider&n;                               then just this fd */
id|result
op_assign
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
id|val
op_assign
id|val
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_xor
(paren
l_int|0
op_ne
id|sdp-&gt;merge_fd
)paren
)paren
op_logical_and
id|sdp-&gt;headfp
op_logical_and
id|sdp-&gt;headfp-&gt;nextfp
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* too much work if multiple fds already */
id|sdp-&gt;merge_fd
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SG_SET_COMMAND_Q
suffix:colon
id|result
op_assign
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
id|sfp-&gt;cmd_q
op_assign
id|val
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SG_GET_COMMAND_Q
suffix:colon
r_return
id|put_user
c_func
(paren
(paren
r_int
)paren
id|sfp-&gt;cmd_q
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SG_SET_UNDERRUN_FLAG
suffix:colon
id|result
op_assign
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
id|sfp-&gt;underrun_flag
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SG_GET_UNDERRUN_FLAG
suffix:colon
r_return
id|put_user
c_func
(paren
(paren
r_int
)paren
id|sfp-&gt;underrun_flag
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SG_EMULATED_HOST
suffix:colon
r_return
id|put_user
c_func
(paren
id|sdp-&gt;device-&gt;host-&gt;hostt-&gt;emulated
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SCSI_IOCTL_SEND_COMMAND
suffix:colon
multiline_comment|/* Allow SCSI_IOCTL_SEND_COMMAND without checking suser() since the&n;           user already has read/write access to the generic device and so&n;           can execute arbitrary SCSI commands.  */
r_if
c_cond
(paren
id|O_RDWR
op_ne
(paren
id|filp-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* require write access since these could be&n;                               dangerous */
r_return
id|scsi_ioctl_send_command
c_func
(paren
id|sdp-&gt;device
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SG_SET_DEBUG
suffix:colon
id|result
op_assign
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
id|sdp-&gt;sgdebug
op_assign
(paren
r_char
)paren
id|val
suffix:semicolon
r_if
c_cond
(paren
l_int|9
op_eq
id|sdp-&gt;sgdebug
)paren
id|sg_debug
c_func
(paren
id|sdp
comma
id|sfp
comma
l_int|0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sdp-&gt;sgdebug
OG
l_int|9
)paren
id|sg_debug_all
c_func
(paren
id|sfp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SCSI_IOCTL_GET_IDLUN
suffix:colon
r_case
id|SCSI_IOCTL_GET_BUS_NUMBER
suffix:colon
r_case
id|SCSI_IOCTL_PROBE_HOST
suffix:colon
r_case
id|SG_GET_TRANSFORM
suffix:colon
r_return
id|scsi_ioctl
c_func
(paren
id|sdp-&gt;device
comma
id|cmd_in
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|O_RDWR
op_ne
(paren
id|filp-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* require write access since these could be&n;                               dangerous */
r_return
id|scsi_ioctl
c_func
(paren
id|sdp-&gt;device
comma
id|cmd_in
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
)brace
DECL|function|sg_poll
r_static
r_int
r_int
id|sg_poll
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_int
r_int
id|res
op_assign
l_int|0
suffix:semicolon
id|Sg_device
op_star
id|sdp
suffix:semicolon
id|Sg_fd
op_star
id|sfp
suffix:semicolon
id|Sg_request
op_star
id|srp
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|sfp
op_assign
(paren
id|Sg_fd
op_star
)paren
id|filp-&gt;private_data
)paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|sdp
op_assign
id|sfp-&gt;parentdp
)paren
)paren
)paren
r_return
id|POLLERR
suffix:semicolon
id|poll_wait
c_func
(paren
id|filp
comma
op_amp
id|sfp-&gt;read_wait
comma
id|wait
)paren
suffix:semicolon
id|srp
op_assign
id|sfp-&gt;headrp
suffix:semicolon
r_while
c_loop
(paren
id|srp
)paren
(brace
multiline_comment|/* if any read waiting, flag it */
r_if
c_cond
(paren
op_logical_neg
(paren
id|res
op_logical_or
id|srp-&gt;my_cmdp
)paren
)paren
id|res
op_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
op_increment
id|count
suffix:semicolon
id|srp
op_assign
id|srp-&gt;nextrp
suffix:semicolon
)brace
r_if
c_cond
(paren
l_int|0
op_eq
id|sfp-&gt;cmd_q
)paren
(brace
r_if
c_cond
(paren
l_int|0
op_eq
id|count
)paren
id|res
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|count
OL
id|SG_MAX_QUEUE
)paren
id|res
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;sg_poll: dev=%d, res=0x%x&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|sdp-&gt;i_rdev
)paren
comma
(paren
r_int
)paren
id|res
)paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|sg_fasync
r_static
r_int
id|sg_fasync
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|mode
)paren
(brace
r_int
id|retval
suffix:semicolon
id|Sg_device
op_star
id|sdp
suffix:semicolon
id|Sg_fd
op_star
id|sfp
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|sfp
op_assign
(paren
id|Sg_fd
op_star
)paren
id|filp-&gt;private_data
)paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|sdp
op_assign
id|sfp-&gt;parentdp
)paren
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;sg_fasync: dev=%d, mode=%d&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|sdp-&gt;i_rdev
)paren
comma
id|mode
)paren
)paren
suffix:semicolon
id|retval
op_assign
id|fasync_helper
c_func
(paren
id|fd
comma
id|filp
comma
id|mode
comma
op_amp
id|sfp-&gt;async_qp
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function is called by the interrupt handler when we&n; * actually have a command that is complete.  Change the&n; * flags to indicate that we have a result.  */
DECL|function|sg_command_done
r_static
r_void
id|sg_command_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|dev
op_assign
id|MINOR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
suffix:semicolon
id|Sg_device
op_star
id|sdp
suffix:semicolon
id|Sg_fd
op_star
id|sfp
suffix:semicolon
id|Sg_request
op_star
id|srp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|closed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
l_int|NULL
op_eq
id|sg_dev_arr
)paren
op_logical_or
(paren
id|dev
OL
l_int|0
)paren
op_logical_or
(paren
id|dev
op_ge
id|sg_template.dev_max
)paren
)paren
(brace
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;sg__done: bad args dev=%d&bslash;n&quot;
comma
id|dev
)paren
)paren
suffix:semicolon
id|scsi_release_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sdp
op_assign
op_amp
id|sg_dev_arr
(braket
id|dev
)braket
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|sdp-&gt;device
)paren
r_return
suffix:semicolon
multiline_comment|/* Get out of here quick ... */
id|sfp
op_assign
id|sdp-&gt;headfp
suffix:semicolon
r_while
c_loop
(paren
id|sfp
)paren
(brace
id|srp
op_assign
id|sfp-&gt;headrp
suffix:semicolon
r_while
c_loop
(paren
id|srp
)paren
(brace
r_if
c_cond
(paren
id|SCpnt
op_eq
id|srp-&gt;my_cmdp
)paren
r_break
suffix:semicolon
id|srp
op_assign
id|srp-&gt;nextrp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srp
)paren
r_break
suffix:semicolon
id|sfp
op_assign
id|sfp-&gt;nextfp
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|srp
)paren
(brace
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;sg__done: req missing, dev=%d&bslash;n&quot;
comma
id|dev
)paren
)paren
suffix:semicolon
id|scsi_release_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* First transfer ownership of data buffers to sg_device object. */
id|srp-&gt;data.use_sg
op_assign
id|SCpnt-&gt;use_sg
suffix:semicolon
id|srp-&gt;data.sglist_len
op_assign
id|SCpnt-&gt;sglist_len
suffix:semicolon
id|srp-&gt;data.bufflen
op_assign
id|SCpnt-&gt;bufflen
suffix:semicolon
id|srp-&gt;data.buffer
op_assign
id|SCpnt-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
l_int|2
op_eq
id|sfp-&gt;underrun_flag
)paren
id|srp-&gt;header.pack_len
op_assign
id|SCpnt-&gt;underflow
suffix:semicolon
id|sg_clr_scpnt
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|srp-&gt;my_cmdp
op_assign
l_int|NULL
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;sg__done: dev=%d, scsi_stat=%d, res=0x%x&bslash;n&quot;
comma
id|dev
comma
(paren
r_int
)paren
id|status_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
comma
(paren
r_int
)paren
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
multiline_comment|/* See if the command completed normally, or whether something went wrong. */
id|memcpy
c_func
(paren
id|srp-&gt;header.sense_buffer
comma
id|SCpnt-&gt;sense_buffer
comma
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|host_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
)paren
(brace
r_case
id|DID_OK
suffix:colon
r_case
id|DID_PASSTHROUGH
suffix:colon
multiline_comment|/* just guessing */
r_case
id|DID_SOFT_ERROR
suffix:colon
multiline_comment|/* just guessing */
id|srp-&gt;header.result
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_NO_CONNECT
suffix:colon
r_case
id|DID_BUS_BUSY
suffix:colon
r_case
id|DID_TIME_OUT
suffix:colon
id|srp-&gt;header.result
op_assign
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_BAD_TARGET
suffix:colon
r_case
id|DID_ABORT
suffix:colon
r_case
id|DID_PARITY
suffix:colon
r_case
id|DID_RESET
suffix:colon
r_case
id|DID_BAD_INTR
suffix:colon
id|srp-&gt;header.result
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_ERROR
suffix:colon
multiline_comment|/* There really should be DID_UNDERRUN and DID_OVERRUN error values,&n;       * and a means for callers of scsi_do_cmd to indicate whether an&n;       * underrun or overrun should signal an error.  Until that can be&n;       * implemented, this kludge allows for returning useful error values&n;       * except in cases that return DID_ERROR that might be due to an&n;       * underrun. */
r_if
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_and
id|status_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
op_eq
id|GOOD
)paren
id|srp-&gt;header.result
op_assign
l_int|0
suffix:semicolon
r_else
id|srp-&gt;header.result
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;sg: unexpected host_byte=%d, dev=%d in &squot;done&squot;&bslash;n&quot;
comma
id|host_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
comma
id|dev
)paren
)paren
suffix:semicolon
id|srp-&gt;header.result
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Following if statement is a patch supplied by Eric Youngdale */
r_if
c_cond
(paren
id|driver_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
op_ne
l_int|0
op_logical_and
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x7f
)paren
op_eq
l_int|0x70
op_logical_and
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
id|UNIT_ATTENTION
op_logical_and
id|sdp-&gt;device-&gt;removable
)paren
(brace
multiline_comment|/* Detected disc change. Set the bit - this may be used if there are */
multiline_comment|/* filesystems using this device. */
id|sdp-&gt;device-&gt;changed
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Pick up error and status information */
id|srp-&gt;header.target_status
op_assign
id|status_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sdp-&gt;sgdebug
OG
l_int|0
)paren
op_logical_and
(paren
(paren
id|CHECK_CONDITION
op_eq
id|srp-&gt;header.target_status
)paren
op_logical_or
(paren
id|COMMAND_TERMINATED
op_eq
id|srp-&gt;header.target_status
)paren
)paren
)paren
id|print_sense
c_func
(paren
l_string|&quot;sg_command_done&quot;
comma
id|SCpnt
)paren
suffix:semicolon
id|srp-&gt;header.host_status
op_assign
id|host_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
suffix:semicolon
id|srp-&gt;header.driver_status
op_assign
id|driver_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
suffix:semicolon
id|scsi_release_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sfp-&gt;closed
)paren
(brace
multiline_comment|/* whoops this fd already released, cleanup */
id|closed
op_assign
l_int|1
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;sg__done: already closed, freeing ...&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* should check if module is unloaded &lt;&lt;&lt;&lt;&lt;&lt;&lt; */
id|sg_sc_undo_rem
c_func
(paren
id|srp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|sfp-&gt;headrp
)paren
(brace
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;sg__done: already closed, final cleanup&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sg_remove_sfp
c_func
(paren
id|sdp
comma
id|sfp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Now wake up the process that is waiting for the result. */
multiline_comment|/* A. Rubini says this is preferable+faster than wake_up() */
id|wake_up_interruptible
c_func
(paren
op_amp
id|sfp-&gt;read_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sfp-&gt;async_qp
)paren
op_logical_and
(paren
op_logical_neg
id|closed
)paren
)paren
id|kill_fasync
c_func
(paren
id|sfp-&gt;async_qp
comma
id|SIGPOLL
)paren
suffix:semicolon
)brace
DECL|function|sg_debug_all
r_static
r_void
id|sg_debug_all
c_func
(paren
r_const
id|Sg_fd
op_star
id|sfp
)paren
(brace
r_const
id|Sg_device
op_star
id|sdp
op_assign
id|sg_dev_arr
suffix:semicolon
r_int
id|k
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|sg_dev_arr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sg_debug_all: sg_dev_arr NULL, death is imminent&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sfp
)paren
id|printk
c_func
(paren
l_string|&quot;sg_debug_all: sfp (file descriptor pointer) NULL&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sg_debug_all: dev_max=%d, %s&bslash;n&quot;
comma
id|sg_template.dev_max
comma
id|sg_version_str
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; scsi_dma_free_sectors=%u, sg_pool_secs_aval=%d&bslash;n&quot;
comma
id|scsi_dma_free_sectors
comma
id|sg_pool_secs_avail
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; sg_big_buff=%d&bslash;n&quot;
comma
id|sg_big_buff
)paren
suffix:semicolon
macro_line|#ifdef SG_DEBUG
id|printk
c_func
(paren
l_string|&quot; malloc counts, kmallocs=%d, dma_pool=%d, pages=%d&bslash;n&quot;
comma
id|sg_num_kmal
comma
id|sg_num_pool
comma
id|sg_num_page
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|sg_template.dev_max
suffix:semicolon
op_increment
id|k
comma
op_increment
id|sdp
)paren
(brace
r_if
c_cond
(paren
id|sdp-&gt;headfp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sfp
)paren
id|sfp
op_assign
id|sdp-&gt;headfp
suffix:semicolon
multiline_comment|/* just to keep things going */
r_else
r_if
c_cond
(paren
id|sdp
op_eq
id|sfp-&gt;parentdp
)paren
id|printk
c_func
(paren
l_string|&quot;  ***** Invoking device follows *****&bslash;n&quot;
)paren
suffix:semicolon
id|sg_debug
c_func
(paren
id|sdp
comma
id|sfp
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|sg_debug
r_static
r_void
id|sg_debug
c_func
(paren
r_const
id|Sg_device
op_star
id|sdp
comma
r_const
id|Sg_fd
op_star
id|sfp
comma
r_int
id|part_of
)paren
(brace
id|Sg_fd
op_star
id|fp
suffix:semicolon
id|Sg_request
op_star
id|srp
suffix:semicolon
r_int
id|dev
suffix:semicolon
r_int
id|k
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sfp
)paren
id|printk
c_func
(paren
l_string|&quot;sg_debug: sfp (file descriptor pointer) NULL&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sdp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sg_debug: sdp pointer (to device) NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|sdp-&gt;device
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sg_debug: device detached ??&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev
op_assign
id|MINOR
c_func
(paren
id|sdp-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|part_of
)paren
id|printk
c_func
(paren
l_string|&quot; &gt;&gt;&gt; device=%d(sg%c), &quot;
comma
id|dev
comma
l_char|&squot;a&squot;
op_plus
id|dev
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;sg_debug: device=%d(sg%c), &quot;
comma
id|dev
comma
l_char|&squot;a&squot;
op_plus
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d chan=%d id=%d lun=%d  em=%d&bslash;n&quot;
comma
id|sdp-&gt;device-&gt;host-&gt;host_no
comma
id|sdp-&gt;device-&gt;channel
comma
id|sdp-&gt;device-&gt;id
comma
id|sdp-&gt;device-&gt;lun
comma
id|sdp-&gt;device-&gt;host-&gt;hostt-&gt;emulated
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; sg_tablesize=%d, excl=%d, sgdebug=%d, merge_fd=%d&bslash;n&quot;
comma
id|sdp-&gt;sg_tablesize
comma
id|sdp-&gt;exclude
comma
id|sdp-&gt;sgdebug
comma
id|sdp-&gt;merge_fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|part_of
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; scsi_dma_free_sectors=%u, sg_pool_secs_aval=%d&bslash;n&quot;
comma
id|scsi_dma_free_sectors
comma
id|sg_pool_secs_avail
)paren
suffix:semicolon
macro_line|#ifdef SG_DEBUG
id|printk
c_func
(paren
l_string|&quot; mallocs: kmallocs=%d, dma_pool=%d, pages=%d&bslash;n&quot;
comma
id|sg_num_kmal
comma
id|sg_num_pool
comma
id|sg_num_page
)paren
suffix:semicolon
macro_line|#endif
)brace
id|fp
op_assign
id|sdp-&gt;headfp
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|1
suffix:semicolon
id|fp
suffix:semicolon
id|fp
op_assign
id|fp-&gt;nextfp
comma
op_increment
id|k
)paren
(brace
r_if
c_cond
(paren
id|sfp
op_eq
id|fp
)paren
id|printk
c_func
(paren
l_string|&quot;  *** Following data belongs to invoking FD ***&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|fp-&gt;parentdp
)paren
id|printk
c_func
(paren
l_string|&quot;&gt;&gt; Following FD has NULL parent pointer ???&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   FD(%d): timeout=%d, fb_size=%d, cmd_q=%d&bslash;n&quot;
comma
id|k
comma
id|fp-&gt;timeout
comma
id|fp-&gt;fb_size
comma
(paren
r_int
)paren
id|fp-&gt;cmd_q
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   low_dma=%d, force_packid=%d, urun_flag=%d, closed=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|fp-&gt;low_dma
comma
(paren
r_int
)paren
id|fp-&gt;force_packid
comma
(paren
r_int
)paren
id|fp-&gt;underrun_flag
comma
(paren
r_int
)paren
id|fp-&gt;closed
)paren
suffix:semicolon
id|srp
op_assign
id|fp-&gt;headrp
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|srp
)paren
id|printk
c_func
(paren
l_string|&quot;     No requests active&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|srp
)paren
(brace
r_if
c_cond
(paren
id|srp-&gt;fb_used
)paren
id|printk
c_func
(paren
l_string|&quot;using 1st buff &gt;&gt; &quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;     &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|srp-&gt;my_cmdp
)paren
id|printk
c_func
(paren
l_string|&quot;written: pack_id=%d, bufflen=%d, use_sg=%d&bslash;n&quot;
comma
id|srp-&gt;header.pack_id
comma
id|srp-&gt;my_cmdp-&gt;bufflen
comma
id|srp-&gt;my_cmdp-&gt;use_sg
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;to_read: pack_id=%d, bufflen=%d, use_sg=%d&bslash;n&quot;
comma
id|srp-&gt;header.pack_id
comma
id|srp-&gt;data.bufflen
comma
id|srp-&gt;data.use_sg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|srp-&gt;parentfp
)paren
id|printk
c_func
(paren
l_string|&quot;&gt;&gt; request has NULL parent pointer ???&bslash;n&quot;
)paren
suffix:semicolon
id|srp
op_assign
id|srp-&gt;nextrp
suffix:semicolon
)brace
)brace
)brace
DECL|variable|sg_fops
r_static
r_struct
id|file_operations
id|sg_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek */
id|sg_read
comma
multiline_comment|/* read */
id|sg_write
comma
multiline_comment|/* write */
l_int|NULL
comma
multiline_comment|/* readdir */
id|sg_poll
comma
multiline_comment|/* poll */
id|sg_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|sg_open
comma
multiline_comment|/* open */
l_int|NULL
comma
multiline_comment|/* flush */
id|sg_release
comma
multiline_comment|/* release, was formerly sg_close */
l_int|NULL
comma
multiline_comment|/* fsync */
id|sg_fasync
comma
multiline_comment|/* fasync */
l_int|NULL
comma
multiline_comment|/* check_media_change */
l_int|NULL
comma
multiline_comment|/* revalidate */
l_int|NULL
comma
multiline_comment|/* lock */
)brace
suffix:semicolon
DECL|function|sg_detect
r_static
r_int
id|sg_detect
c_func
(paren
id|Scsi_Device
op_star
id|scsidp
)paren
(brace
r_switch
c_cond
(paren
id|scsidp-&gt;type
)paren
(brace
r_case
id|TYPE_DISK
suffix:colon
r_case
id|TYPE_MOD
suffix:colon
r_case
id|TYPE_ROM
suffix:colon
r_case
id|TYPE_WORM
suffix:colon
r_case
id|TYPE_TAPE
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Detected scsi generic sg%c at scsi%d,&quot;
l_string|&quot; channel %d, id %d, lun %d&bslash;n&quot;
comma
l_char|&squot;a&squot;
op_plus
id|sg_template.dev_noticed
comma
id|scsidp-&gt;host-&gt;host_no
comma
id|scsidp-&gt;channel
comma
id|scsidp-&gt;id
comma
id|scsidp-&gt;lun
)paren
suffix:semicolon
)brace
id|sg_template.dev_noticed
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Driver initialization */
DECL|function|sg_init
r_static
r_int
id|sg_init
c_func
(paren
)paren
(brace
r_static
r_int
id|sg_registered
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sg_template.dev_noticed
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg_registered
)paren
(brace
r_if
c_cond
(paren
id|register_chrdev
c_func
(paren
id|SCSI_GENERIC_MAJOR
comma
l_string|&quot;sg&quot;
comma
op_amp
id|sg_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to get major %d for generic SCSI device&bslash;n&quot;
comma
id|SCSI_GENERIC_MAJOR
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|sg_registered
op_increment
suffix:semicolon
)brace
multiline_comment|/* If we have already been through here, return */
r_if
c_cond
(paren
id|sg_dev_arr
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;sg_init&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sg_dev_arr
op_assign
(paren
id|Sg_device
op_star
)paren
id|scsi_init_malloc
c_func
(paren
(paren
id|sg_template.dev_noticed
op_plus
id|SG_EXTRA_DEVS
)paren
op_star
r_sizeof
(paren
id|Sg_device
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|sg_dev_arr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sg_init: no space for sg_dev_arr&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|sg_template.dev_max
op_assign
id|sg_template.dev_noticed
op_plus
id|SG_EXTRA_DEVS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sg_attach
r_static
r_int
id|sg_attach
c_func
(paren
id|Scsi_Device
op_star
id|scsidp
)paren
(brace
id|Sg_device
op_star
id|sdp
op_assign
id|sg_dev_arr
suffix:semicolon
r_int
id|k
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sg_template.nr_dev
op_ge
id|sg_template.dev_max
)paren
op_logical_or
(paren
op_logical_neg
id|sdp
)paren
)paren
(brace
id|scsidp-&gt;attached
op_decrement
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|sg_template.dev_max
suffix:semicolon
id|k
op_increment
comma
id|sdp
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|sdp-&gt;device
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
op_ge
id|sg_template.dev_max
)paren
(brace
id|panic
(paren
l_string|&quot;scsi_devices corrupt (sg)&quot;
)paren
suffix:semicolon
)brace
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;sg_attach: dev=%d &bslash;n&quot;
comma
id|k
)paren
)paren
suffix:semicolon
id|sdp-&gt;device
op_assign
id|scsidp
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|sdp-&gt;generic_wait
)paren
suffix:semicolon
id|sdp-&gt;headfp
op_assign
l_int|NULL
suffix:semicolon
id|sdp-&gt;exclude
op_assign
l_int|0
suffix:semicolon
id|sdp-&gt;merge_fd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Cope with SG_DEF_MERGE_FD on open */
id|sdp-&gt;sgdebug
op_assign
l_int|0
suffix:semicolon
id|sdp-&gt;sg_tablesize
op_assign
id|scsidp-&gt;host
ques
c_cond
id|scsidp-&gt;host-&gt;sg_tablesize
suffix:colon
l_int|0
suffix:semicolon
id|sdp-&gt;i_rdev
op_assign
id|MKDEV
c_func
(paren
id|SCSI_GENERIC_MAJOR
comma
id|k
)paren
suffix:semicolon
id|sg_template.nr_dev
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Called at &squot;finish&squot; of init process, after all attaches */
DECL|function|sg_finish
r_static
r_void
id|sg_finish
c_func
(paren
r_void
)paren
(brace
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;sg_finish: dma_free_sectors=%u&bslash;n&quot;
comma
id|scsi_dma_free_sectors
)paren
)paren
suffix:semicolon
)brace
DECL|function|sg_detach
r_static
r_void
id|sg_detach
c_func
(paren
id|Scsi_Device
op_star
id|scsidp
)paren
(brace
id|Sg_device
op_star
id|sdp
op_assign
id|sg_dev_arr
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|Sg_fd
op_star
id|sfp
suffix:semicolon
id|Sg_request
op_star
id|srp
suffix:semicolon
r_int
id|k
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|sdp
)paren
r_return
suffix:semicolon
multiline_comment|/* all is not well ... */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|sg_template.dev_max
suffix:semicolon
id|k
op_increment
comma
id|sdp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sdp-&gt;device
op_ne
id|scsidp
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* dirty but lowers nesting */
r_if
c_cond
(paren
id|sdp-&gt;headfp
)paren
(brace
multiline_comment|/* Need to stop sg_command_done() playing with this list during this loop */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|sfp
op_assign
id|sdp-&gt;headfp
suffix:semicolon
r_while
c_loop
(paren
id|sfp
)paren
(brace
id|srp
op_assign
id|sfp-&gt;headrp
suffix:semicolon
r_while
c_loop
(paren
id|srp
)paren
(brace
r_if
c_cond
(paren
id|srp-&gt;my_cmdp
)paren
id|sg_shorten_timeout
c_func
(paren
id|srp-&gt;my_cmdp
)paren
suffix:semicolon
id|srp
op_assign
id|srp-&gt;nextrp
suffix:semicolon
)brace
id|sfp
op_assign
id|sfp-&gt;nextfp
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;sg_detach: dev=%d, dirty, sleep(3)&bslash;n&quot;
comma
id|k
)paren
)paren
suffix:semicolon
id|scsi_sleep
c_func
(paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* sleep 3 jiffies, hoping for timeout to go off */
)brace
r_else
(brace
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;sg_detach: dev=%d&bslash;n&quot;
comma
id|k
)paren
)paren
suffix:semicolon
id|sdp-&gt;device
op_assign
l_int|NULL
suffix:semicolon
)brace
id|scsidp-&gt;attached
op_decrement
suffix:semicolon
id|sg_template.nr_dev
op_decrement
suffix:semicolon
multiline_comment|/*&n;         * avoid associated device /dev/sg? bying incremented&n;         * each time module is inserted/removed , &lt;dan@lectra.fr&gt;&n;         */
id|sg_template.dev_noticed
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
id|sg_template.module
op_assign
op_amp
id|__this_module
suffix:semicolon
r_return
id|scsi_register_module
c_func
(paren
id|MODULE_SCSI_DEV
comma
op_amp
id|sg_template
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|scsi_unregister_module
c_func
(paren
id|MODULE_SCSI_DEV
comma
op_amp
id|sg_template
)paren
suffix:semicolon
id|unregister_chrdev
c_func
(paren
id|SCSI_GENERIC_MAJOR
comma
l_string|&quot;sg&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sg_dev_arr
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Really worrying situation of writes still pending and get here */
multiline_comment|/* Strategy: shorten timeout on release + wait on detach ... */
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|sg_dev_arr
comma
(paren
id|sg_template.dev_noticed
op_plus
id|SG_EXTRA_DEVS
)paren
op_star
r_sizeof
(paren
id|Sg_device
)paren
)paren
suffix:semicolon
id|sg_dev_arr
op_assign
l_int|NULL
suffix:semicolon
)brace
id|sg_template.dev_max
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
macro_line|#if 0
r_extern
r_void
id|scsi_times_out
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_extern
r_void
id|scsi_old_times_out
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Can&squot;t see clean way to abort a command so shorten timeout to 1 jiffy */
DECL|function|sg_shorten_timeout
r_static
r_void
id|sg_shorten_timeout
c_func
(paren
id|Scsi_Cmnd
op_star
id|scpnt
)paren
(brace
macro_line|#if 0 /* scsi_syms.c is very miserly about exported functions */
id|scsi_delete_timer
c_func
(paren
id|scpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scpnt
)paren
r_return
suffix:semicolon
id|scpnt-&gt;timeout_per_command
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* try 1 jiffy (perhaps 0 jiffies) */
r_if
c_cond
(paren
id|scpnt-&gt;host-&gt;hostt-&gt;use_new_eh_code
)paren
id|scsi_add_timer
c_func
(paren
id|scpnt
comma
id|scpnt-&gt;timeout_per_command
comma
id|scsi_times_out
)paren
suffix:semicolon
r_else
id|scsi_add_timer
c_func
(paren
id|scpnt
comma
id|scpnt-&gt;timeout_per_command
comma
id|scsi_old_times_out
)paren
suffix:semicolon
macro_line|#else
id|scsi_sleep
c_func
(paren
id|HZ
)paren
suffix:semicolon
multiline_comment|/* just sleep 1 second and hope ... */
macro_line|#endif
)brace
DECL|function|sg_sc_build
r_static
r_int
id|sg_sc_build
c_func
(paren
id|Sg_request
op_star
id|srp
comma
r_int
id|max_buff_size
comma
r_const
r_char
op_star
id|inp
comma
r_int
id|num_write_xfer
)paren
(brace
r_int
id|ret_sz
comma
id|mem_src
suffix:semicolon
r_int
id|blk_size
op_assign
id|max_buff_size
suffix:semicolon
r_char
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|blk_size
OL
l_int|0
)paren
op_logical_or
(paren
op_logical_neg
id|srp
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;sg_sc_build: m_b_s=%d, num_write_xfer=%d&bslash;n&quot;
comma
id|max_buff_size
comma
id|num_write_xfer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|blk_size
)paren
op_increment
id|blk_size
suffix:semicolon
multiline_comment|/* don&squot;t know why */
multiline_comment|/* round request up to next highest SG_SECTOR_SZ byte boundary */
id|blk_size
op_assign
(paren
id|blk_size
op_plus
id|SG_SECTOR_MSK
)paren
op_amp
(paren
op_complement
id|SG_SECTOR_MSK
)paren
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;sg_sc_build: blk_size=%d&bslash;n&quot;
comma
id|blk_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk_size
op_le
id|SG_SCATTER_SZ
)paren
(brace
id|mem_src
op_assign
id|SG_HEAP_FB
suffix:semicolon
id|p
op_assign
id|sg_malloc
c_func
(paren
id|srp
comma
id|blk_size
comma
op_amp
id|ret_sz
comma
op_amp
id|mem_src
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|blk_size
op_eq
id|ret_sz
)paren
(brace
multiline_comment|/* got it on the first attempt */
id|srp-&gt;data.buffer
op_assign
id|p
suffix:semicolon
id|srp-&gt;data.bufflen
op_assign
id|blk_size
suffix:semicolon
id|srp-&gt;data.mem_src
op_assign
id|mem_src
suffix:semicolon
id|srp-&gt;data.b_malloc_len
op_assign
id|blk_size
suffix:semicolon
r_if
c_cond
(paren
id|inp
op_logical_and
(paren
id|num_write_xfer
OG
l_int|0
)paren
)paren
id|__copy_from_user
c_func
(paren
id|srp-&gt;data.buffer
comma
id|inp
comma
id|num_write_xfer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|mem_src
op_assign
id|SG_HEAP_PAGE
suffix:semicolon
id|p
op_assign
id|sg_malloc
c_func
(paren
id|srp
comma
id|SG_SCATTER_SZ
comma
op_amp
id|ret_sz
comma
op_amp
id|mem_src
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Want some local declarations, so start new block ... */
(brace
multiline_comment|/* lets try and build a scatter gather list */
r_struct
id|scatterlist
op_star
id|sclp
suffix:semicolon
r_int
id|k
comma
id|rem_sz
comma
id|num
comma
id|nxt
suffix:semicolon
r_int
id|sc_bufflen
op_assign
id|PAGE_SIZE
suffix:semicolon
r_int
id|mx_sc_elems
op_assign
(paren
id|sc_bufflen
op_div
r_sizeof
(paren
r_struct
id|scatterlist
)paren
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|sg_tablesize
op_assign
id|srp-&gt;parentfp-&gt;parentdp-&gt;sg_tablesize
suffix:semicolon
r_int
id|first
op_assign
l_int|1
suffix:semicolon
id|k
op_assign
id|SG_HEAP_KMAL
suffix:semicolon
multiline_comment|/* want to protect mem_src, use k as scratch */
id|srp-&gt;data.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|sg_malloc
c_func
(paren
id|srp
comma
id|sc_bufflen
comma
op_amp
id|num
comma
op_amp
id|k
)paren
suffix:semicolon
id|srp-&gt;data.mem_src
op_assign
(paren
r_char
)paren
id|k
suffix:semicolon
multiline_comment|/* N.B. ret_sz and mem_src carried into this block ... */
r_if
c_cond
(paren
op_logical_neg
id|srp-&gt;data.buffer
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_else
r_if
c_cond
(paren
id|num
op_ne
id|sc_bufflen
)paren
(brace
id|sc_bufflen
op_assign
id|num
suffix:semicolon
id|mx_sc_elems
op_assign
(paren
id|sc_bufflen
op_div
r_sizeof
(paren
r_struct
id|scatterlist
)paren
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|srp-&gt;data.sglist_len
op_assign
id|sc_bufflen
suffix:semicolon
id|memset
c_func
(paren
id|srp-&gt;data.buffer
comma
l_int|0
comma
id|sc_bufflen
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
comma
id|sclp
op_assign
id|srp-&gt;data.buffer
comma
id|rem_sz
op_assign
id|blk_size
comma
id|nxt
op_assign
l_int|0
suffix:semicolon
(paren
id|k
OL
id|sg_tablesize
)paren
op_logical_and
(paren
id|rem_sz
OG
l_int|0
)paren
op_logical_and
(paren
id|k
OL
id|mx_sc_elems
)paren
suffix:semicolon
op_increment
id|k
comma
id|rem_sz
op_sub_assign
id|ret_sz
comma
op_increment
id|sclp
)paren
(brace
r_if
c_cond
(paren
id|first
)paren
id|first
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|num
op_assign
(paren
id|rem_sz
OG
id|SG_SCATTER_SZ
)paren
ques
c_cond
id|SG_SCATTER_SZ
suffix:colon
id|rem_sz
suffix:semicolon
id|mem_src
op_assign
id|SG_HEAP_PAGE
suffix:semicolon
id|p
op_assign
id|sg_malloc
c_func
(paren
id|srp
comma
id|num
comma
op_amp
id|ret_sz
comma
op_amp
id|mem_src
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_break
suffix:semicolon
)brace
id|sclp-&gt;address
op_assign
id|p
suffix:semicolon
id|sclp-&gt;length
op_assign
id|ret_sz
suffix:semicolon
id|sclp-&gt;alt_address
op_assign
(paren
r_char
op_star
)paren
(paren
r_int
)paren
id|mem_src
suffix:semicolon
r_if
c_cond
(paren
id|inp
op_logical_and
(paren
id|num_write_xfer
OG
l_int|0
)paren
)paren
(brace
id|num
op_assign
(paren
id|ret_sz
OG
id|num_write_xfer
)paren
ques
c_cond
id|num_write_xfer
suffix:colon
id|ret_sz
suffix:semicolon
id|__copy_from_user
c_func
(paren
id|sclp-&gt;address
comma
id|inp
comma
id|num
)paren
suffix:semicolon
id|num_write_xfer
op_sub_assign
id|num
suffix:semicolon
id|inp
op_add_assign
id|num
suffix:semicolon
)brace
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;sg_sc_build: k=%d, a=0x%p, len=%d, ms=%d&bslash;n&quot;
comma
id|k
comma
id|sclp-&gt;address
comma
id|ret_sz
comma
id|mem_src
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* end of for loop */
id|srp-&gt;data.use_sg
op_assign
id|k
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;sg_sc_build: use_sg=%d, rem_sz=%d&bslash;n&quot;
comma
id|k
comma
id|rem_sz
)paren
)paren
suffix:semicolon
id|srp-&gt;data.bufflen
op_assign
id|blk_size
suffix:semicolon
r_if
c_cond
(paren
id|rem_sz
OG
l_int|0
)paren
multiline_comment|/* must have failed */
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sg_sc_undo_rem
r_static
r_int
id|sg_sc_undo_rem
c_func
(paren
id|Sg_request
op_star
id|srp
comma
r_char
op_star
id|outp
comma
r_int
id|num_read_xfer
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|srp
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;sg_sc_undo_rem: num_read_xfer=%d&bslash;n&quot;
comma
id|num_read_xfer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|outp
)paren
id|num_read_xfer
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|srp-&gt;data.use_sg
)paren
(brace
r_int
id|k
comma
id|num
comma
id|mem_src
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sclp
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|srp-&gt;data.buffer
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
(paren
id|k
OL
id|srp-&gt;data.use_sg
)paren
op_logical_and
id|sclp-&gt;address
suffix:semicolon
op_increment
id|k
comma
op_increment
id|sclp
)paren
(brace
r_if
c_cond
(paren
id|num_read_xfer
OG
l_int|0
)paren
(brace
id|num
op_assign
(paren
r_int
)paren
id|sclp-&gt;length
suffix:semicolon
r_if
c_cond
(paren
id|num
OG
id|num_read_xfer
)paren
(brace
id|__copy_to_user
c_func
(paren
id|outp
comma
id|sclp-&gt;address
comma
id|num_read_xfer
)paren
suffix:semicolon
id|outp
op_add_assign
id|num_read_xfer
suffix:semicolon
id|num_read_xfer
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|__copy_to_user
c_func
(paren
id|outp
comma
id|sclp-&gt;address
comma
id|num
)paren
suffix:semicolon
id|outp
op_add_assign
id|num
suffix:semicolon
id|num_read_xfer
op_sub_assign
id|num
suffix:semicolon
)brace
)brace
id|mem_src
op_assign
(paren
r_int
)paren
(paren
r_int
)paren
id|sclp-&gt;alt_address
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;sg_sc_undo_rem: k=%d, a=0x%p, len=%d, ms=%d&bslash;n&quot;
comma
id|k
comma
id|sclp-&gt;address
comma
id|sclp-&gt;length
comma
id|mem_src
)paren
)paren
suffix:semicolon
id|sg_free
c_func
(paren
id|srp
comma
id|sclp-&gt;address
comma
id|sclp-&gt;length
comma
id|mem_src
)paren
suffix:semicolon
)brace
id|sg_free
c_func
(paren
id|srp
comma
id|srp-&gt;data.buffer
comma
id|srp-&gt;data.sglist_len
comma
id|srp-&gt;data.mem_src
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|num_read_xfer
OG
l_int|0
)paren
id|__copy_to_user
c_func
(paren
id|outp
comma
id|srp-&gt;data.buffer
comma
id|num_read_xfer
)paren
suffix:semicolon
id|sg_free
c_func
(paren
id|srp
comma
id|srp-&gt;data.buffer
comma
id|srp-&gt;data.b_malloc_len
comma
id|srp-&gt;data.mem_src
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
l_int|0
op_eq
id|sg_remove_request
c_func
(paren
id|srp-&gt;parentfp
comma
id|srp
)paren
)paren
(brace
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;sg_sc_undo_rem: srp=0x%p not found&bslash;n&quot;
comma
id|srp
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sg_get_request
r_static
id|Sg_request
op_star
id|sg_get_request
c_func
(paren
r_const
id|Sg_fd
op_star
id|sfp
comma
r_int
id|pack_id
)paren
(brace
id|Sg_request
op_star
id|resp
op_assign
l_int|NULL
suffix:semicolon
id|resp
op_assign
id|sfp-&gt;headrp
suffix:semicolon
r_while
c_loop
(paren
id|resp
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|resp-&gt;my_cmdp
)paren
op_logical_and
(paren
(paren
op_minus
l_int|1
op_eq
id|pack_id
)paren
op_logical_or
(paren
id|resp-&gt;header.pack_id
op_eq
id|pack_id
)paren
)paren
)paren
r_return
id|resp
suffix:semicolon
id|resp
op_assign
id|resp-&gt;nextrp
suffix:semicolon
)brace
r_return
id|resp
suffix:semicolon
)brace
multiline_comment|/* always adds to end of list */
DECL|function|sg_add_request
r_static
id|Sg_request
op_star
id|sg_add_request
c_func
(paren
id|Sg_fd
op_star
id|sfp
)paren
(brace
r_int
id|k
suffix:semicolon
id|Sg_request
op_star
id|resp
op_assign
l_int|NULL
suffix:semicolon
id|Sg_request
op_star
id|rp
suffix:semicolon
id|resp
op_assign
id|sfp-&gt;headrp
suffix:semicolon
id|rp
op_assign
id|sfp-&gt;req_arr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|resp
)paren
(brace
id|resp
op_assign
id|rp
suffix:semicolon
id|sfp-&gt;headrp
op_assign
id|resp
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
l_int|0
op_eq
id|sfp-&gt;cmd_q
)paren
id|resp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* command queuing disallowed */
r_else
(brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
comma
id|rp
suffix:semicolon
id|k
OL
id|SG_MAX_QUEUE
suffix:semicolon
op_increment
id|k
comma
op_increment
id|rp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rp-&gt;parentfp
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
OL
id|SG_MAX_QUEUE
)paren
(brace
r_while
c_loop
(paren
id|resp-&gt;nextrp
)paren
id|resp
op_assign
id|resp-&gt;nextrp
suffix:semicolon
id|resp-&gt;nextrp
op_assign
id|rp
suffix:semicolon
id|resp
op_assign
id|rp
suffix:semicolon
)brace
r_else
id|resp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|resp
)paren
(brace
id|resp-&gt;parentfp
op_assign
id|sfp
suffix:semicolon
id|resp-&gt;nextrp
op_assign
l_int|NULL
suffix:semicolon
id|resp-&gt;fb_used
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|resp-&gt;data
comma
l_int|0
comma
r_sizeof
(paren
id|Sg_scatter_hold
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|resp-&gt;header
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sg_header
)paren
)paren
suffix:semicolon
id|resp-&gt;my_cmdp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|resp
suffix:semicolon
)brace
multiline_comment|/* Return of 1 for found; 0 for not found */
DECL|function|sg_remove_request
r_static
r_int
id|sg_remove_request
c_func
(paren
id|Sg_fd
op_star
id|sfp
comma
r_const
id|Sg_request
op_star
id|srp
)paren
(brace
id|Sg_request
op_star
id|prev_rp
suffix:semicolon
id|Sg_request
op_star
id|rp
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|sfp
)paren
op_logical_or
(paren
op_logical_neg
id|srp
)paren
op_logical_or
(paren
op_logical_neg
id|sfp-&gt;headrp
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|prev_rp
op_assign
id|sfp-&gt;headrp
suffix:semicolon
r_if
c_cond
(paren
id|srp
op_eq
id|prev_rp
)paren
(brace
id|prev_rp-&gt;parentfp
op_assign
l_int|NULL
suffix:semicolon
id|sfp-&gt;headrp
op_assign
id|prev_rp-&gt;nextrp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|rp
op_assign
id|prev_rp-&gt;nextrp
)paren
)paren
(brace
r_if
c_cond
(paren
id|srp
op_eq
id|rp
)paren
(brace
id|rp-&gt;parentfp
op_assign
l_int|NULL
suffix:semicolon
id|prev_rp-&gt;nextrp
op_assign
id|rp-&gt;nextrp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|prev_rp
op_assign
id|rp
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sg_add_sfp
r_static
id|Sg_fd
op_star
id|sg_add_sfp
c_func
(paren
id|Sg_device
op_star
id|sdp
comma
r_int
id|dev
comma
r_int
id|get_reserved
)paren
(brace
id|Sg_fd
op_star
id|sfp
suffix:semicolon
r_if
c_cond
(paren
id|sdp-&gt;merge_fd
)paren
(brace
op_increment
id|sdp-&gt;merge_fd
suffix:semicolon
r_return
id|sdp-&gt;headfp
suffix:semicolon
)brace
id|sfp
op_assign
(paren
id|Sg_fd
op_star
)paren
id|sg_low_malloc
c_func
(paren
r_sizeof
(paren
id|Sg_fd
)paren
comma
l_int|0
comma
id|SG_HEAP_KMAL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sfp
)paren
(brace
id|memset
c_func
(paren
id|sfp
comma
l_int|0
comma
r_sizeof
(paren
id|Sg_fd
)paren
)paren
suffix:semicolon
id|sfp-&gt;my_mem_src
op_assign
id|SG_HEAP_KMAL
suffix:semicolon
)brace
r_else
r_return
l_int|NULL
suffix:semicolon
id|sfp-&gt;timeout
op_assign
id|SG_DEFAULT_TIMEOUT
suffix:semicolon
id|sfp-&gt;force_packid
op_assign
id|SG_DEF_FORCE_PACK_ID
suffix:semicolon
id|sfp-&gt;low_dma
op_assign
(paren
id|SG_DEF_FORCE_LOW_DMA
op_eq
l_int|0
)paren
ques
c_cond
id|sdp-&gt;device-&gt;host-&gt;unchecked_isa_dma
suffix:colon
l_int|1
suffix:semicolon
id|sfp-&gt;cmd_q
op_assign
id|SG_DEF_COMMAND_Q
suffix:semicolon
id|sfp-&gt;underrun_flag
op_assign
id|SG_DEF_UNDERRUN_FLAG
suffix:semicolon
r_if
c_cond
(paren
id|get_reserved
)paren
id|sfp-&gt;fst_buf
op_assign
id|sg_low_malloc
c_func
(paren
id|SG_SCATTER_SZ
comma
id|sfp-&gt;low_dma
comma
id|SG_HEAP_PAGE
comma
op_amp
id|sfp-&gt;fb_size
)paren
suffix:semicolon
r_else
id|sfp-&gt;fst_buf
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sfp-&gt;fst_buf
)paren
id|sfp-&gt;fb_size
op_assign
l_int|0
suffix:semicolon
id|sfp-&gt;parentdp
op_assign
id|sdp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sdp-&gt;headfp
)paren
id|sdp-&gt;headfp
op_assign
id|sfp
suffix:semicolon
r_else
(brace
multiline_comment|/* add to tail of existing list */
id|Sg_fd
op_star
id|pfp
op_assign
id|sdp-&gt;headfp
suffix:semicolon
r_while
c_loop
(paren
id|pfp-&gt;nextfp
)paren
id|pfp
op_assign
id|pfp-&gt;nextfp
suffix:semicolon
id|pfp-&gt;nextfp
op_assign
id|sfp
suffix:semicolon
)brace
id|sg_big_buff
op_assign
id|sfp-&gt;fb_size
suffix:semicolon
multiline_comment|/* show sysctl most recent &quot;fb&quot; size */
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;sg_add_sfp: sfp=0x%p, m_s=%d&bslash;n&quot;
comma
id|sfp
comma
(paren
r_int
)paren
id|sfp-&gt;my_mem_src
)paren
)paren
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;sg_add_sfp:   fb_sz=%d, fst_buf=0x%p&bslash;n&quot;
comma
id|sfp-&gt;fb_size
comma
id|sfp-&gt;fst_buf
)paren
)paren
suffix:semicolon
r_return
id|sfp
suffix:semicolon
)brace
DECL|function|sg_remove_sfp
r_static
r_int
id|sg_remove_sfp
c_func
(paren
id|Sg_device
op_star
id|sdp
comma
id|Sg_fd
op_star
id|sfp
)paren
(brace
id|Sg_request
op_star
id|srp
suffix:semicolon
id|Sg_request
op_star
id|tsrp
suffix:semicolon
r_int
id|dirty
op_assign
l_int|0
suffix:semicolon
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sdp-&gt;merge_fd
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|sdp-&gt;merge_fd
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* if merge_fd then dec merge_fd counter */
)brace
id|srp
op_assign
id|sfp-&gt;headrp
suffix:semicolon
r_if
c_cond
(paren
id|srp
)paren
(brace
multiline_comment|/* Need to stop sg_command_done() playing with this list during this loop */
r_while
c_loop
(paren
id|srp
)paren
(brace
id|tsrp
op_assign
id|srp-&gt;nextrp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|srp-&gt;my_cmdp
)paren
id|sg_sc_undo_rem
c_func
(paren
id|srp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_else
op_increment
id|dirty
suffix:semicolon
id|srp
op_assign
id|tsrp
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
l_int|0
op_eq
id|dirty
)paren
(brace
id|Sg_fd
op_star
id|fp
suffix:semicolon
id|Sg_fd
op_star
id|prev_fp
op_assign
id|sdp-&gt;headfp
suffix:semicolon
r_if
c_cond
(paren
id|sfp
op_eq
id|prev_fp
)paren
id|sdp-&gt;headfp
op_assign
id|prev_fp-&gt;nextfp
suffix:semicolon
r_else
(brace
r_while
c_loop
(paren
(paren
id|fp
op_assign
id|prev_fp-&gt;nextfp
)paren
)paren
(brace
r_if
c_cond
(paren
id|sfp
op_eq
id|fp
)paren
(brace
id|prev_fp-&gt;nextfp
op_assign
id|fp-&gt;nextfp
suffix:semicolon
r_break
suffix:semicolon
)brace
id|prev_fp
op_assign
id|fp
suffix:semicolon
)brace
)brace
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|6
comma
id|printk
c_func
(paren
l_string|&quot;sg_remove_sfp:    fb_sz=%d, fst_buf=0x%p&bslash;n&quot;
comma
id|sfp-&gt;fb_size
comma
id|sfp-&gt;fst_buf
)paren
)paren
suffix:semicolon
id|sg_low_free
c_func
(paren
id|sfp-&gt;fst_buf
comma
id|sfp-&gt;fb_size
comma
id|SG_HEAP_PAGE
)paren
suffix:semicolon
id|sfp-&gt;parentdp
op_assign
l_int|NULL
suffix:semicolon
id|sfp-&gt;fst_buf
op_assign
l_int|NULL
suffix:semicolon
id|sfp-&gt;fb_size
op_assign
l_int|0
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|6
comma
id|printk
c_func
(paren
l_string|&quot;sg_remove_sfp:    sfp=0x%p&bslash;n&quot;
comma
id|sfp
)paren
)paren
suffix:semicolon
id|sg_low_free
c_func
(paren
(paren
r_char
op_star
)paren
id|sfp
comma
r_sizeof
(paren
id|Sg_fd
)paren
comma
id|sfp-&gt;my_mem_src
)paren
suffix:semicolon
id|res
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|sfp-&gt;closed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* flag dirty state on this fd */
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;sg_remove_sfp: worrisome, %d writes pending&bslash;n&quot;
comma
id|dirty
)paren
)paren
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|function|sg_fb_in_use
r_static
r_int
id|sg_fb_in_use
c_func
(paren
r_const
id|Sg_fd
op_star
id|sfp
)paren
(brace
r_const
id|Sg_request
op_star
id|srp
op_assign
id|sfp-&gt;headrp
suffix:semicolon
r_while
c_loop
(paren
id|srp
)paren
(brace
r_if
c_cond
(paren
id|srp-&gt;fb_used
)paren
r_return
l_int|1
suffix:semicolon
id|srp
op_assign
id|srp-&gt;nextrp
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If retSzp==NULL want exact size or fail */
multiline_comment|/* sg_low_malloc() should always be called from a process context allowing&n;   GFP_KERNEL to be used instead of GFP_ATOMIC */
DECL|function|sg_low_malloc
r_static
r_char
op_star
id|sg_low_malloc
c_func
(paren
r_int
id|rqSz
comma
r_int
id|lowDma
comma
r_int
id|mem_src
comma
r_int
op_star
id|retSzp
)paren
(brace
r_char
op_star
id|resp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|page_mask
op_assign
id|lowDma
ques
c_cond
(paren
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
suffix:colon
id|GFP_KERNEL
suffix:semicolon
r_if
c_cond
(paren
id|rqSz
op_le
l_int|0
)paren
r_return
id|resp
suffix:semicolon
r_if
c_cond
(paren
id|SG_HEAP_KMAL
op_eq
id|mem_src
)paren
(brace
id|page_mask
op_assign
id|lowDma
ques
c_cond
(paren
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:colon
id|GFP_ATOMIC
suffix:semicolon
multiline_comment|/* Seen kmalloc(..,GFP_KERNEL) hang for 40 secs! */
id|resp
op_assign
id|kmalloc
c_func
(paren
id|rqSz
comma
id|page_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resp
op_logical_and
id|retSzp
)paren
op_star
id|retSzp
op_assign
id|rqSz
suffix:semicolon
macro_line|#ifdef SG_DEBUG
r_if
c_cond
(paren
id|resp
)paren
op_increment
id|sg_num_kmal
suffix:semicolon
macro_line|#endif
r_return
id|resp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SG_HEAP_POOL
op_eq
id|mem_src
)paren
(brace
r_int
id|num_sect
op_assign
id|rqSz
op_div
id|SG_SECTOR_SZ
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
(paren
id|rqSz
op_amp
id|SG_SECTOR_MSK
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|retSzp
)paren
r_return
id|resp
suffix:semicolon
op_increment
id|num_sect
suffix:semicolon
id|rqSz
op_assign
id|num_sect
op_star
id|SG_SECTOR_SZ
suffix:semicolon
)brace
r_while
c_loop
(paren
id|num_sect
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|num_sect
op_le
id|sg_pool_secs_avail
)paren
op_logical_and
(paren
id|scsi_dma_free_sectors
OG
(paren
id|SG_LOW_POOL_THRESHHOLD
op_plus
id|num_sect
)paren
)paren
)paren
(brace
id|resp
op_assign
id|scsi_malloc
c_func
(paren
id|rqSz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resp
)paren
(brace
r_if
c_cond
(paren
id|retSzp
)paren
op_star
id|retSzp
op_assign
id|rqSz
suffix:semicolon
id|sg_pool_secs_avail
op_sub_assign
id|num_sect
suffix:semicolon
macro_line|#ifdef SG_DEBUG
op_increment
id|sg_num_pool
suffix:semicolon
macro_line|#endif
r_return
id|resp
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|retSzp
)paren
r_return
id|resp
suffix:semicolon
id|num_sect
op_div_assign
l_int|2
suffix:semicolon
multiline_comment|/* try half as many */
id|rqSz
op_assign
id|num_sect
op_star
id|SG_SECTOR_SZ
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|SG_HEAP_PAGE
op_eq
id|mem_src
)paren
(brace
r_int
id|order
comma
id|a_size
suffix:semicolon
r_int
id|resSz
op_assign
id|rqSz
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
comma
id|a_size
op_assign
id|PAGE_SIZE
suffix:semicolon
id|a_size
OL
id|rqSz
suffix:semicolon
id|order
op_increment
comma
id|a_size
op_lshift_assign
l_int|1
)paren
suffix:semicolon
id|resp
op_assign
(paren
r_char
op_star
)paren
id|__get_free_pages
c_func
(paren
id|page_mask
comma
id|order
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
op_logical_neg
id|resp
)paren
op_logical_and
id|order
op_logical_and
id|retSzp
)paren
(brace
op_decrement
id|order
suffix:semicolon
id|a_size
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* divide by 2, until PAGE_SIZE */
id|resp
op_assign
(paren
r_char
op_star
)paren
id|__get_free_pages
c_func
(paren
id|page_mask
comma
id|order
)paren
suffix:semicolon
multiline_comment|/* try half */
id|resSz
op_assign
id|a_size
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retSzp
)paren
op_star
id|retSzp
op_assign
id|resSz
suffix:semicolon
macro_line|#ifdef SG_DEBUG
r_if
c_cond
(paren
id|resp
)paren
op_increment
id|sg_num_page
suffix:semicolon
macro_line|#endif
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;sg_low_malloc: bad mem_src=%d, rqSz=%df&bslash;n&quot;
comma
id|mem_src
comma
id|rqSz
)paren
suffix:semicolon
r_return
id|resp
suffix:semicolon
)brace
DECL|function|sg_malloc
r_static
r_char
op_star
id|sg_malloc
c_func
(paren
id|Sg_request
op_star
id|srp
comma
r_int
id|size
comma
r_int
op_star
id|retSzp
comma
r_int
op_star
id|mem_srcp
)paren
(brace
r_char
op_star
id|resp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|retSzp
)paren
op_star
id|retSzp
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|size
op_le
l_int|0
)paren
suffix:semicolon
r_else
(brace
id|Sg_fd
op_star
id|sfp
op_assign
id|srp-&gt;parentfp
suffix:semicolon
r_int
id|low_dma
op_assign
id|sfp-&gt;low_dma
suffix:semicolon
r_int
id|l_ms
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* invalid value */
r_switch
c_cond
(paren
op_star
id|mem_srcp
)paren
(brace
r_case
id|SG_HEAP_PAGE
suffix:colon
r_case
id|SG_HEAP_FB
suffix:colon
id|l_ms
op_assign
(paren
id|size
OL
id|PAGE_SIZE
)paren
ques
c_cond
id|SG_HEAP_POOL
suffix:colon
id|SG_HEAP_PAGE
suffix:semicolon
id|resp
op_assign
id|sg_low_malloc
c_func
(paren
id|size
comma
id|low_dma
comma
id|l_ms
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resp
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|size
op_le
id|sfp-&gt;fb_size
)paren
op_logical_and
(paren
l_int|0
op_eq
id|sg_fb_in_use
c_func
(paren
id|sfp
)paren
)paren
)paren
(brace
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|6
comma
id|printk
c_func
(paren
l_string|&quot;sg_malloc: scsi_malloc failed, get fst_buf&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|resp
op_assign
id|sfp-&gt;fst_buf
suffix:semicolon
id|srp-&gt;fb_used
op_assign
l_int|1
suffix:semicolon
id|l_ms
op_assign
id|SG_HEAP_FB
suffix:semicolon
r_break
suffix:semicolon
)brace
id|resp
op_assign
id|sg_low_malloc
c_func
(paren
id|size
comma
id|low_dma
comma
id|l_ms
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|resp
)paren
(brace
id|l_ms
op_assign
(paren
id|SG_HEAP_POOL
op_eq
id|l_ms
)paren
ques
c_cond
id|SG_HEAP_PAGE
suffix:colon
id|SG_HEAP_POOL
suffix:semicolon
id|resp
op_assign
id|sg_low_malloc
c_func
(paren
id|size
comma
id|low_dma
comma
id|l_ms
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|resp
)paren
(brace
id|l_ms
op_assign
id|SG_HEAP_KMAL
suffix:semicolon
id|resp
op_assign
id|sg_low_malloc
c_func
(paren
id|size
comma
id|low_dma
comma
id|l_ms
comma
op_amp
id|size
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|resp
op_logical_and
id|retSzp
)paren
op_star
id|retSzp
op_assign
id|size
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SG_HEAP_KMAL
suffix:colon
id|l_ms
op_assign
id|SG_HEAP_PAGE
suffix:semicolon
id|resp
op_assign
id|sg_low_malloc
c_func
(paren
id|size
comma
id|low_dma
comma
id|l_ms
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resp
)paren
r_break
suffix:semicolon
id|l_ms
op_assign
id|SG_HEAP_POOL
suffix:semicolon
id|resp
op_assign
id|sg_low_malloc
c_func
(paren
id|size
comma
id|low_dma
comma
id|l_ms
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resp
op_logical_and
id|retSzp
)paren
op_star
id|retSzp
op_assign
id|size
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;sg_malloc: bad ms=%d&bslash;n&quot;
comma
op_star
id|mem_srcp
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|resp
)paren
op_star
id|mem_srcp
op_assign
id|l_ms
suffix:semicolon
)brace
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|6
comma
id|printk
c_func
(paren
l_string|&quot;sg_malloc: size=%d, ms=%d, ret=0x%p&bslash;n&quot;
comma
id|size
comma
op_star
id|mem_srcp
comma
id|resp
)paren
)paren
suffix:semicolon
r_return
id|resp
suffix:semicolon
)brace
DECL|function|sg_low_free
r_static
r_void
id|sg_low_free
c_func
(paren
r_char
op_star
id|buff
comma
r_int
id|size
comma
r_int
id|mem_src
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buff
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|SG_HEAP_POOL
op_eq
id|mem_src
)paren
(brace
r_int
id|num_sect
op_assign
id|size
op_div
id|SG_SECTOR_SZ
suffix:semicolon
id|scsi_free
c_func
(paren
id|buff
comma
id|size
)paren
suffix:semicolon
id|sg_pool_secs_avail
op_add_assign
id|num_sect
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SG_HEAP_KMAL
op_eq
id|mem_src
)paren
id|kfree
c_func
(paren
id|buff
)paren
suffix:semicolon
multiline_comment|/* size not used */
r_else
r_if
c_cond
(paren
id|SG_HEAP_PAGE
op_eq
id|mem_src
)paren
(brace
r_int
id|order
comma
id|a_size
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
comma
id|a_size
op_assign
id|PAGE_SIZE
suffix:semicolon
id|a_size
OL
id|size
suffix:semicolon
id|order
op_increment
comma
id|a_size
op_lshift_assign
l_int|1
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|buff
comma
id|order
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;sg_low_free: bad mem_src=%d, buff=0x%p, rqSz=%df&bslash;n&quot;
comma
id|mem_src
comma
id|buff
comma
id|size
)paren
suffix:semicolon
)brace
DECL|function|sg_free
r_static
r_void
id|sg_free
c_func
(paren
id|Sg_request
op_star
id|srp
comma
r_char
op_star
id|buff
comma
r_int
id|size
comma
r_int
id|mem_src
)paren
(brace
id|Sg_fd
op_star
id|sfp
op_assign
id|srp-&gt;parentfp
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|6
comma
id|printk
c_func
(paren
l_string|&quot;sg_free: buff=0x%p, size=%d&bslash;n&quot;
comma
id|buff
comma
id|size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|sfp
)paren
op_logical_or
(paren
op_logical_neg
id|buff
)paren
op_logical_or
(paren
id|size
op_le
l_int|0
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sfp-&gt;fst_buf
op_eq
id|buff
)paren
(brace
id|srp-&gt;fb_used
op_assign
l_int|0
suffix:semicolon
id|SCSI_LOG_TIMEOUT
c_func
(paren
l_int|6
comma
id|printk
c_func
(paren
l_string|&quot;sg_free:   left cause fst_buf&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
id|sg_low_free
c_func
(paren
id|buff
comma
id|size
comma
id|mem_src
)paren
suffix:semicolon
)brace
DECL|function|sg_clr_scpnt
r_static
r_void
id|sg_clr_scpnt
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;sglist_len
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;bufflen
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;request.rq_dev
op_assign
id|MKDEV
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &quot;sg&quot; _disowns_ command blk */
)brace
eof
