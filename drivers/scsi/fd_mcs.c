multiline_comment|/* fd_mcs.c -- Future Domain MCS 600/700 (or IBM OEM) driver&n; *&n; * FutureDomain MCS-600/700 v0.2 03/11/1998 by ZP Gu (zpg@castle.net)&n; *&n; * This driver is cloned from fdomain.* to specifically support&n; * the Future Domain MCS 600/700 MCA SCSI adapters. Some PS/2s&n; * also equipped with IBM Fast SCSI Adapter/A which is an OEM&n; * of MCS 700.&n; *&n; * This driver also supports Reply SB16/SCSI card (the SCSI part).&n; *&n; * What makes this driver different is that this driver is MCA only&n; * and it supports multiple adapters in the same system, IRQ &n; * sharing, some driver statistics, and maps highest SCSI id to sda.&n; * All cards are auto-detected.&n; *&n; * Assumptions: TMC-1800/18C50/18C30, BIOS &gt;= 3.4&n; *&n; * LILO command-line options:&n; *   fd_mcs=&lt;FIFO_COUNT&gt;[,&lt;FIFO_SIZE&gt;]&n; *&n; * ********************************************************&n; * Please see Copyrights/Comments in fdomain.* for credits.&n; * Following is from fdomain.c for acknowledgement:&n; *&n; * Created: Sun May  3 18:53:19 1992 by faith@cs.unc.edu&n; * Revised: Wed Oct  2 11:10:55 1996 by r.faith@ieee.org&n; * Author: Rickard E. Faith, faith@cs.unc.edu&n; * Copyright 1992, 1993, 1994, 1995, 1996 Rickard E. Faith&n; *&n; * $Id: fdomain.c,v 5.45 1996/10/02 15:13:06 root Exp $&n;&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n;&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n;&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; **************************************************************************&n;&n; NOTES ON USER DEFINABLE OPTIONS:&n;&n; DEBUG: This turns on the printing of various debug information.&n;&n; ENABLE_PARITY: This turns on SCSI parity checking.  With the current&n; driver, all attached devices must support SCSI parity.  If none of your&n; devices support parity, then you can probably get the driver to work by&n; turning this option off.  I have no way of testing this, however, and it&n; would appear that no one ever uses this option.&n;&n; FIFO_COUNT: The host adapter has an 8K cache (host adapters based on the&n; 18C30 chip have a 2k cache).  When this many 512 byte blocks are filled by&n; the SCSI device, an interrupt will be raised.  Therefore, this could be as&n; low as 0, or as high as 16.  Note, however, that values which are too high&n; or too low seem to prevent any interrupts from occurring, and thereby lock&n; up the machine.  I have found that 2 is a good number, but throughput may&n; be increased by changing this value to values which are close to 2.&n; Please let me know if you try any different values.&n; [*****Now a runtime option*****]&n;&n; RESELECTION: This is no longer an option, since I gave up trying to&n; implement it in version 4.x of this driver.  It did not improve&n; performance at all and made the driver unstable (because I never found one&n; of the two race conditions which were introduced by the multiple&n; outstanding command code).  The instability seems a very high price to pay&n; just so that you don&squot;t have to wait for the tape to rewind.  If you want&n; this feature implemented, send me patches.  I&squot;ll be happy to send a copy&n; of my (broken) driver to anyone who would like to see a copy.&n;&n; **************************************************************************/
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/mca.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;fd_mcs.h&quot;
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION &quot;v0.2 by ZP Gu&lt;zpg@castle.net&gt;&quot;
multiline_comment|/* START OF USER DEFINABLE OPTIONS */
DECL|macro|DEBUG
mdefine_line|#define DEBUG            0&t;/* Enable debugging output */
DECL|macro|ENABLE_PARITY
mdefine_line|#define ENABLE_PARITY    1&t;/* Enable SCSI Parity */
DECL|macro|DO_DETECT
mdefine_line|#define DO_DETECT        0&t;/* Do device detection here (see scsi.c) */
multiline_comment|/* END OF USER DEFINABLE OPTIONS */
macro_line|#if DEBUG
DECL|macro|EVERY_ACCESS
mdefine_line|#define EVERY_ACCESS     0&t;/* Write a line on every scsi access */
DECL|macro|ERRORS_ONLY
mdefine_line|#define ERRORS_ONLY      1&t;/* Only write a line if there is an error */
DECL|macro|DEBUG_DETECT
mdefine_line|#define DEBUG_DETECT     1&t;/* Debug fd_mcs_detect() */
DECL|macro|DEBUG_MESSAGES
mdefine_line|#define DEBUG_MESSAGES   1&t;/* Debug MESSAGE IN phase */
DECL|macro|DEBUG_ABORT
mdefine_line|#define DEBUG_ABORT      1&t;/* Debug abort() routine */
DECL|macro|DEBUG_RESET
mdefine_line|#define DEBUG_RESET      1&t;/* Debug reset() routine */
DECL|macro|DEBUG_RACE
mdefine_line|#define DEBUG_RACE       1      /* Debug interrupt-driven race condition */
macro_line|#else
DECL|macro|EVERY_ACCESS
mdefine_line|#define EVERY_ACCESS     0&t;/* LEAVE THESE ALONE--CHANGE THE ONES ABOVE */
DECL|macro|ERRORS_ONLY
mdefine_line|#define ERRORS_ONLY      0
DECL|macro|DEBUG_DETECT
mdefine_line|#define DEBUG_DETECT     0
DECL|macro|DEBUG_MESSAGES
mdefine_line|#define DEBUG_MESSAGES   0
DECL|macro|DEBUG_ABORT
mdefine_line|#define DEBUG_ABORT      0
DECL|macro|DEBUG_RESET
mdefine_line|#define DEBUG_RESET      0
DECL|macro|DEBUG_RACE
mdefine_line|#define DEBUG_RACE       0
macro_line|#endif
multiline_comment|/* Errors are reported on the line, so we don&squot;t need to report them again */
macro_line|#if EVERY_ACCESS
DECL|macro|ERRORS_ONLY
macro_line|#undef ERRORS_ONLY
DECL|macro|ERRORS_ONLY
mdefine_line|#define ERRORS_ONLY      0
macro_line|#endif
macro_line|#if ENABLE_PARITY
DECL|macro|PARITY_MASK
mdefine_line|#define PARITY_MASK      0x08
macro_line|#else
DECL|macro|PARITY_MASK
mdefine_line|#define PARITY_MASK      0x00
macro_line|#endif
DECL|enum|chip_type
r_enum
id|chip_type
(brace
DECL|enumerator|unknown
id|unknown
op_assign
l_int|0x00
comma
DECL|enumerator|tmc1800
id|tmc1800
op_assign
l_int|0x01
comma
DECL|enumerator|tmc18c50
id|tmc18c50
op_assign
l_int|0x02
comma
DECL|enumerator|tmc18c30
id|tmc18c30
op_assign
l_int|0x03
comma
)brace
suffix:semicolon
r_enum
(brace
DECL|enumerator|in_arbitration
id|in_arbitration
op_assign
l_int|0x02
comma
DECL|enumerator|in_selection
id|in_selection
op_assign
l_int|0x04
comma
DECL|enumerator|in_other
id|in_other
op_assign
l_int|0x08
comma
DECL|enumerator|disconnect
id|disconnect
op_assign
l_int|0x10
comma
DECL|enumerator|aborted
id|aborted
op_assign
l_int|0x20
comma
DECL|enumerator|sent_ident
id|sent_ident
op_assign
l_int|0x40
comma
)brace
suffix:semicolon
DECL|enum|in_port_type
r_enum
id|in_port_type
(brace
DECL|enumerator|Read_SCSI_Data
id|Read_SCSI_Data
op_assign
l_int|0
comma
DECL|enumerator|SCSI_Status
id|SCSI_Status
op_assign
l_int|1
comma
DECL|enumerator|TMC_Status
id|TMC_Status
op_assign
l_int|2
comma
DECL|enumerator|FIFO_Status
id|FIFO_Status
op_assign
l_int|3
comma
multiline_comment|/* tmc18c50/tmc18c30 only */
DECL|enumerator|Interrupt_Cond
id|Interrupt_Cond
op_assign
l_int|4
comma
multiline_comment|/* tmc18c50/tmc18c30 only */
DECL|enumerator|LSB_ID_Code
id|LSB_ID_Code
op_assign
l_int|5
comma
DECL|enumerator|MSB_ID_Code
id|MSB_ID_Code
op_assign
l_int|6
comma
DECL|enumerator|Read_Loopback
id|Read_Loopback
op_assign
l_int|7
comma
DECL|enumerator|SCSI_Data_NoACK
id|SCSI_Data_NoACK
op_assign
l_int|8
comma
DECL|enumerator|Interrupt_Status
id|Interrupt_Status
op_assign
l_int|9
comma
DECL|enumerator|Configuration1
id|Configuration1
op_assign
l_int|10
comma
DECL|enumerator|Configuration2
id|Configuration2
op_assign
l_int|11
comma
multiline_comment|/* tmc18c50/tmc18c30 only */
DECL|enumerator|Read_FIFO
id|Read_FIFO
op_assign
l_int|12
comma
DECL|enumerator|FIFO_Data_Count
id|FIFO_Data_Count
op_assign
l_int|14
)brace
suffix:semicolon
DECL|enum|out_port_type
r_enum
id|out_port_type
(brace
DECL|enumerator|Write_SCSI_Data
id|Write_SCSI_Data
op_assign
l_int|0
comma
DECL|enumerator|SCSI_Cntl
id|SCSI_Cntl
op_assign
l_int|1
comma
DECL|enumerator|Interrupt_Cntl
id|Interrupt_Cntl
op_assign
l_int|2
comma
DECL|enumerator|SCSI_Mode_Cntl
id|SCSI_Mode_Cntl
op_assign
l_int|3
comma
DECL|enumerator|TMC_Cntl
id|TMC_Cntl
op_assign
l_int|4
comma
DECL|enumerator|Memory_Cntl
id|Memory_Cntl
op_assign
l_int|5
comma
multiline_comment|/* tmc18c50/tmc18c30 only */
DECL|enumerator|Write_Loopback
id|Write_Loopback
op_assign
l_int|7
comma
DECL|enumerator|IO_Control
id|IO_Control
op_assign
l_int|11
comma
multiline_comment|/* tmc18c30 only */
DECL|enumerator|Write_FIFO
id|Write_FIFO
op_assign
l_int|12
)brace
suffix:semicolon
DECL|struct|fd_hostdata
r_struct
id|fd_hostdata
(brace
DECL|member|_bios_base
r_int
r_int
id|_bios_base
suffix:semicolon
DECL|member|_bios_major
r_int
id|_bios_major
suffix:semicolon
DECL|member|_bios_minor
r_int
id|_bios_minor
suffix:semicolon
DECL|member|_in_command
r_volatile
r_int
id|_in_command
suffix:semicolon
DECL|member|_current_SC
id|Scsi_Cmnd
op_star
id|_current_SC
suffix:semicolon
DECL|member|_chip
r_enum
id|chip_type
id|_chip
suffix:semicolon
DECL|member|_adapter_mask
r_int
id|_adapter_mask
suffix:semicolon
DECL|member|_fifo_count
r_int
id|_fifo_count
suffix:semicolon
multiline_comment|/* Number of 512 byte blocks before INTR */
DECL|member|_adapter_name
r_char
id|_adapter_name
(braket
l_int|64
)braket
suffix:semicolon
macro_line|#if DEBUG_RACE
DECL|member|_in_interrupt_flag
r_volatile
r_int
id|_in_interrupt_flag
suffix:semicolon
macro_line|#endif
DECL|member|_SCSI_Mode_Cntl_port
r_int
id|_SCSI_Mode_Cntl_port
suffix:semicolon
DECL|member|_FIFO_Data_Count_port
r_int
id|_FIFO_Data_Count_port
suffix:semicolon
DECL|member|_Interrupt_Cntl_port
r_int
id|_Interrupt_Cntl_port
suffix:semicolon
DECL|member|_Interrupt_Status_port
r_int
id|_Interrupt_Status_port
suffix:semicolon
DECL|member|_Interrupt_Cond_port
r_int
id|_Interrupt_Cond_port
suffix:semicolon
DECL|member|_Read_FIFO_port
r_int
id|_Read_FIFO_port
suffix:semicolon
DECL|member|_Read_SCSI_Data_port
r_int
id|_Read_SCSI_Data_port
suffix:semicolon
DECL|member|_SCSI_Cntl_port
r_int
id|_SCSI_Cntl_port
suffix:semicolon
DECL|member|_SCSI_Data_NoACK_port
r_int
id|_SCSI_Data_NoACK_port
suffix:semicolon
DECL|member|_SCSI_Status_port
r_int
id|_SCSI_Status_port
suffix:semicolon
DECL|member|_TMC_Cntl_port
r_int
id|_TMC_Cntl_port
suffix:semicolon
DECL|member|_TMC_Status_port
r_int
id|_TMC_Status_port
suffix:semicolon
DECL|member|_Write_FIFO_port
r_int
id|_Write_FIFO_port
suffix:semicolon
DECL|member|_Write_SCSI_Data_port
r_int
id|_Write_SCSI_Data_port
suffix:semicolon
DECL|member|_FIFO_Size
r_int
id|_FIFO_Size
suffix:semicolon
multiline_comment|/* = 0x2000;  8k FIFO for&n;&t;&t;&t;&t;   pre-tmc18c30 chips */
multiline_comment|/* simple stats */
DECL|member|_Bytes_Read
r_int
id|_Bytes_Read
suffix:semicolon
DECL|member|_Bytes_Written
r_int
id|_Bytes_Written
suffix:semicolon
DECL|member|_INTR_Processed
r_int
id|_INTR_Processed
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|FD_MAX_HOSTS
mdefine_line|#define FD_MAX_HOSTS 3&t;&t;/* enough? */
DECL|macro|HOSTDATA
mdefine_line|#define HOSTDATA(shpnt) ((struct fd_hostdata *) shpnt-&gt;hostdata)
DECL|macro|bios_base
mdefine_line|#define bios_base             (HOSTDATA(shpnt)-&gt;_bios_base)
DECL|macro|bios_major
mdefine_line|#define bios_major            (HOSTDATA(shpnt)-&gt;_bios_major)
DECL|macro|bios_minor
mdefine_line|#define bios_minor            (HOSTDATA(shpnt)-&gt;_bios_minor)
DECL|macro|in_command
mdefine_line|#define in_command            (HOSTDATA(shpnt)-&gt;_in_command)
DECL|macro|current_SC
mdefine_line|#define current_SC            (HOSTDATA(shpnt)-&gt;_current_SC)
DECL|macro|chip
mdefine_line|#define chip                  (HOSTDATA(shpnt)-&gt;_chip)
DECL|macro|adapter_mask
mdefine_line|#define adapter_mask          (HOSTDATA(shpnt)-&gt;_adapter_mask)
DECL|macro|FIFO_COUNT
mdefine_line|#define FIFO_COUNT            (HOSTDATA(shpnt)-&gt;_fifo_count)
DECL|macro|adapter_name
mdefine_line|#define adapter_name          (HOSTDATA(shpnt)-&gt;_adapter_name)
macro_line|#if DEBUG_RACE
DECL|macro|in_interrupt_flag
mdefine_line|#define in_interrupt_flag     (HOSTDATA(shpnt)-&gt;_in_interrupt_flag)
macro_line|#endif&t;                     
DECL|macro|SCSI_Mode_Cntl_port
mdefine_line|#define SCSI_Mode_Cntl_port   (HOSTDATA(shpnt)-&gt;_SCSI_Mode_Cntl_port)
DECL|macro|FIFO_Data_Count_port
mdefine_line|#define FIFO_Data_Count_port  (HOSTDATA(shpnt)-&gt;_FIFO_Data_Count_port)
DECL|macro|Interrupt_Cntl_port
mdefine_line|#define Interrupt_Cntl_port   (HOSTDATA(shpnt)-&gt;_Interrupt_Cntl_port)
DECL|macro|Interrupt_Status_port
mdefine_line|#define Interrupt_Status_port (HOSTDATA(shpnt)-&gt;_Interrupt_Status_port)
DECL|macro|Interrupt_Cond_port
mdefine_line|#define Interrupt_Cond_port   (HOSTDATA(shpnt)-&gt;_Interrupt_Cond_port)
DECL|macro|Read_FIFO_port
mdefine_line|#define Read_FIFO_port        (HOSTDATA(shpnt)-&gt;_Read_FIFO_port)
DECL|macro|Read_SCSI_Data_port
mdefine_line|#define Read_SCSI_Data_port   (HOSTDATA(shpnt)-&gt;_Read_SCSI_Data_port)
DECL|macro|SCSI_Cntl_port
mdefine_line|#define SCSI_Cntl_port        (HOSTDATA(shpnt)-&gt;_SCSI_Cntl_port)
DECL|macro|SCSI_Data_NoACK_port
mdefine_line|#define SCSI_Data_NoACK_port  (HOSTDATA(shpnt)-&gt;_SCSI_Data_NoACK_port)
DECL|macro|SCSI_Status_port
mdefine_line|#define SCSI_Status_port      (HOSTDATA(shpnt)-&gt;_SCSI_Status_port)
DECL|macro|TMC_Cntl_port
mdefine_line|#define TMC_Cntl_port         (HOSTDATA(shpnt)-&gt;_TMC_Cntl_port)
DECL|macro|TMC_Status_port
mdefine_line|#define TMC_Status_port       (HOSTDATA(shpnt)-&gt;_TMC_Status_port)
DECL|macro|Write_FIFO_port
mdefine_line|#define Write_FIFO_port       (HOSTDATA(shpnt)-&gt;_Write_FIFO_port)
DECL|macro|Write_SCSI_Data_port
mdefine_line|#define Write_SCSI_Data_port  (HOSTDATA(shpnt)-&gt;_Write_SCSI_Data_port)
DECL|macro|FIFO_Size
mdefine_line|#define FIFO_Size             (HOSTDATA(shpnt)-&gt;_FIFO_Size)
DECL|macro|Bytes_Read
mdefine_line|#define Bytes_Read            (HOSTDATA(shpnt)-&gt;_Bytes_Read)
DECL|macro|Bytes_Written
mdefine_line|#define Bytes_Written         (HOSTDATA(shpnt)-&gt;_Bytes_Written)
DECL|macro|INTR_Processed
mdefine_line|#define INTR_Processed        (HOSTDATA(shpnt)-&gt;_INTR_Processed)
DECL|struct|fd_mcs_adapters_struct
r_struct
id|fd_mcs_adapters_struct
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|id
r_int
id|id
suffix:semicolon
DECL|member|fd_chip
r_enum
id|chip_type
id|fd_chip
suffix:semicolon
DECL|member|fifo_size
r_int
id|fifo_size
suffix:semicolon
DECL|member|fifo_count
r_int
id|fifo_count
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|REPLY_ID
mdefine_line|#define REPLY_ID 0x5137
DECL|variable|fd_mcs_adapters
r_static
r_struct
id|fd_mcs_adapters_struct
id|fd_mcs_adapters
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;Future Domain SCSI Adapter MCS-700(18C50)&quot;
comma
l_int|0x60e9
comma
id|tmc18c50
comma
l_int|0x2000
comma
l_int|4
)brace
comma
(brace
l_string|&quot;Future Domain SCSI Adapter MCS-600/700(TMC-1800)&quot;
comma
l_int|0x6127
comma
id|tmc1800
comma
l_int|0x2000
comma
l_int|4
)brace
comma
(brace
l_string|&quot;Reply Sound Blaster/SCSI Adapter&quot;
comma
id|REPLY_ID
comma
id|tmc18c30
comma
l_int|0x800
comma
l_int|2
)brace
comma
)brace
suffix:semicolon
DECL|macro|FD_BRDS
mdefine_line|#define FD_BRDS sizeof(fd_mcs_adapters)/sizeof(struct fd_mcs_adapters_struct)
r_static
r_void
id|fd_mcs_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|variable|addresses
r_static
r_int
r_int
id|addresses
(braket
)braket
op_assign
(brace
l_int|0xc8000
comma
l_int|0xca000
comma
l_int|0xce000
comma
l_int|0xde000
)brace
suffix:semicolon
DECL|variable|ports
r_static
r_int
r_int
id|ports
(braket
)braket
op_assign
(brace
l_int|0x140
comma
l_int|0x150
comma
l_int|0x160
comma
l_int|0x170
)brace
suffix:semicolon
DECL|variable|ints
r_static
r_int
r_int
id|ints
(braket
)braket
op_assign
(brace
l_int|3
comma
l_int|5
comma
l_int|10
comma
l_int|11
comma
l_int|12
comma
l_int|14
comma
l_int|15
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* host information */
DECL|variable|found
r_static
r_int
id|found
op_assign
l_int|0
suffix:semicolon
DECL|variable|hosts
r_static
r_struct
id|Scsi_Host
op_star
id|hosts
(braket
id|FD_MAX_HOSTS
op_plus
l_int|1
)braket
op_assign
(brace
l_int|NULL
)brace
suffix:semicolon
DECL|variable|user_fifo_count
r_static
r_int
id|user_fifo_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|user_fifo_size
r_static
r_int
id|user_fifo_size
op_assign
l_int|0
suffix:semicolon
DECL|function|fd_mcs_setup
r_void
id|fd_mcs_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_static
r_int
id|done_setup
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|done_setup
op_increment
op_logical_or
id|ints
(braket
l_int|0
)braket
template_param
l_int|2
op_logical_or
id|ints
(braket
l_int|1
)braket
template_param
l_int|16
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd_mcs: usage: fd_mcs=FIFO_COUNT, FIFO_SIZE&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|user_fifo_count
op_assign
id|ints
(braket
l_int|0
)braket
op_ge
l_int|1
ques
c_cond
id|ints
(braket
l_int|1
)braket
suffix:colon
l_int|0
suffix:semicolon
id|user_fifo_size
op_assign
id|ints
(braket
l_int|0
)braket
op_ge
l_int|2
ques
c_cond
id|ints
(braket
l_int|2
)braket
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|print_banner
r_static
r_void
id|print_banner
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d &lt;fd_mcs&gt;: &quot;
comma
id|shpnt-&gt;host_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bios_base
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BIOS at 0x%lX&quot;
comma
id|bios_base
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;No BIOS&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;, HostID %d, %s Chip, IRQ %d, IO 0x%lX&bslash;n&quot;
comma
id|shpnt-&gt;this_id
comma
id|chip
op_eq
id|tmc18c50
ques
c_cond
l_string|&quot;TMC-18C50&quot;
suffix:colon
(paren
id|chip
op_eq
id|tmc18c30
ques
c_cond
l_string|&quot;TMC-18C30&quot;
suffix:colon
(paren
id|chip
op_eq
id|tmc1800
ques
c_cond
l_string|&quot;TMC-1800&quot;
suffix:colon
l_string|&quot;Unknown&quot;
)paren
)paren
comma
id|shpnt-&gt;irq
comma
id|shpnt-&gt;io_port
)paren
suffix:semicolon
)brace
DECL|function|do_pause
r_static
r_void
id|do_pause
c_func
(paren
r_int
id|amount
)paren
multiline_comment|/* Pause for amount*10 milliseconds */
(brace
r_do
(brace
id|udelay
c_func
(paren
l_int|10
op_star
l_int|1000
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|amount
)paren
suffix:semicolon
)brace
DECL|function|fd_mcs_make_bus_idle
r_inline
r_static
r_void
id|fd_mcs_make_bus_idle
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCSI_Mode_Cntl_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip
op_eq
id|tmc18c50
op_logical_or
id|chip
op_eq
id|tmc18c30
)paren
id|outb
c_func
(paren
l_int|0x21
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Clear forced intr. */
r_else
id|outb
c_func
(paren
l_int|0x01
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
)brace
DECL|function|fd_mcs_detect
r_int
id|fd_mcs_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|loop
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
multiline_comment|/* get id, port, bios, irq */
r_int
id|slot
suffix:semicolon
id|u_char
id|pos2
comma
id|pos3
comma
id|pos4
suffix:semicolon
r_int
id|id
comma
id|port
comma
id|irq
suffix:semicolon
r_int
r_int
id|bios
suffix:semicolon
multiline_comment|/* if not MCA machine, return */
r_if
c_cond
(paren
op_logical_neg
id|MCA_bus
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* changeable? */
id|id
op_assign
l_int|7
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|FD_BRDS
suffix:semicolon
id|loop
op_increment
)paren
(brace
id|slot
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|MCA_NOTFOUND
op_ne
(paren
id|slot
op_assign
id|mca_find_adapter
c_func
(paren
id|fd_mcs_adapters
(braket
id|loop
)braket
dot
id|id
comma
id|slot
)paren
)paren
)paren
(brace
multiline_comment|/* if we get this far, an adapter has been detected and is&n;&t; enabled */
id|printk
c_func
(paren
l_string|&quot;scsi  &lt;fd_mcs&gt;: %s at slot %d&bslash;n&quot;
comma
id|fd_mcs_adapters
(braket
id|loop
)braket
dot
id|name
comma
id|slot
op_plus
l_int|1
)paren
suffix:semicolon
id|pos2
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|2
)paren
suffix:semicolon
id|pos3
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|3
)paren
suffix:semicolon
id|pos4
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* ready for next probe */
id|slot
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|fd_mcs_adapters
(braket
id|loop
)braket
dot
id|id
op_eq
id|REPLY_ID
)paren
(brace
multiline_comment|/* reply card */
r_static
r_int
id|reply_irq
(braket
)braket
op_assign
(brace
l_int|10
comma
l_int|11
comma
l_int|14
comma
l_int|15
)brace
suffix:semicolon
id|bios
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no bios */
r_if
c_cond
(paren
id|pos2
op_amp
l_int|0x2
)paren
id|port
op_assign
id|ports
(braket
id|pos4
op_amp
l_int|0x3
)braket
suffix:semicolon
r_else
r_continue
suffix:semicolon
multiline_comment|/* can&squot;t really disable it, same as irq=10 */
id|irq
op_assign
id|reply_irq
(braket
(paren
(paren
id|pos4
op_rshift
l_int|2
)paren
op_amp
l_int|0x1
)paren
op_plus
l_int|2
op_star
(paren
(paren
id|pos4
op_rshift
l_int|4
)paren
op_amp
l_int|0x1
)paren
)braket
suffix:semicolon
)brace
r_else
(brace
id|bios
op_assign
id|addresses
(braket
id|pos2
op_rshift
l_int|6
)braket
suffix:semicolon
id|port
op_assign
id|ports
(braket
(paren
id|pos2
op_rshift
l_int|4
)paren
op_amp
l_int|0x03
)braket
suffix:semicolon
id|irq
op_assign
id|ints
(braket
(paren
id|pos2
op_rshift
l_int|1
)paren
op_amp
l_int|0x07
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq
)paren
(brace
multiline_comment|/* claim the slot */
id|mca_set_adapter_name
c_func
(paren
id|slot
op_minus
l_int|1
comma
id|fd_mcs_adapters
(braket
id|loop
)braket
dot
id|name
)paren
suffix:semicolon
multiline_comment|/* check irq/region */
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|port
comma
l_int|0x10
)paren
op_logical_or
id|request_irq
c_func
(paren
id|irq
comma
id|fd_mcs_intr
comma
id|SA_SHIRQ
comma
l_string|&quot;fd_mcs&quot;
comma
id|hosts
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd_mcs: check_region() || request_irq() failed, Skip it&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* register */
r_if
c_cond
(paren
op_logical_neg
(paren
id|shpnt
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
r_sizeof
(paren
r_struct
id|fd_hostdata
)paren
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd_mcs: scsi_register() failed&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* request I/O region */
id|request_region
c_func
(paren
id|port
comma
l_int|0x10
comma
l_string|&quot;fd_mcs&quot;
)paren
suffix:semicolon
multiline_comment|/* save name */
id|strcpy
c_func
(paren
id|adapter_name
comma
id|fd_mcs_adapters
(braket
id|loop
)braket
dot
id|name
)paren
suffix:semicolon
multiline_comment|/* chip/fifo */
id|chip
op_assign
id|fd_mcs_adapters
(braket
id|loop
)braket
dot
id|fd_chip
suffix:semicolon
multiline_comment|/* use boot time value if available */
id|FIFO_COUNT
op_assign
id|user_fifo_count
ques
c_cond
id|user_fifo_count
suffix:colon
id|fd_mcs_adapters
(braket
id|loop
)braket
dot
id|fifo_count
suffix:semicolon
id|FIFO_Size
op_assign
id|user_fifo_size
ques
c_cond
id|user_fifo_size
suffix:colon
id|fd_mcs_adapters
(braket
id|loop
)braket
dot
id|fifo_size
suffix:semicolon
macro_line|#ifdef NOT_USED
multiline_comment|/* *************************************************** */
multiline_comment|/* Try to toggle 32-bit mode.  This only&n;&t;   works on an 18c30 chip.  (User reports&n;&t;   say this works, so we should switch to&n;&t;   it in the near future.) */
id|outb
c_func
(paren
l_int|0x80
comma
id|port
op_plus
id|IO_Control
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|port
op_plus
id|Configuration2
)paren
op_amp
l_int|0x80
)paren
op_eq
l_int|0x80
)paren
(brace
id|outb
c_func
(paren
l_int|0x00
comma
id|port
op_plus
id|IO_Control
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|port
op_plus
id|Configuration2
)paren
op_amp
l_int|0x80
)paren
op_eq
l_int|0x00
)paren
(brace
id|chip
op_assign
id|tmc18c30
suffix:semicolon
id|FIFO_Size
op_assign
l_int|0x800
suffix:semicolon
multiline_comment|/* 2k FIFO */
id|printk
c_func
(paren
l_string|&quot;FIRST: chip=%s, fifo_size=0x%x&bslash;n&quot;
comma
(paren
id|chip
op_eq
id|tmc18c30
)paren
ques
c_cond
l_string|&quot;tmc18c30&quot;
suffix:colon
l_string|&quot;tmc18c50&quot;
comma
id|FIFO_Size
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* That should have worked, but appears to&n;&t;   have problems.  Let&squot;s assume it is an&n;&t;   18c30 if the RAM is disabled. */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
id|Configuration2
)paren
op_amp
l_int|0x02
)paren
(brace
id|chip
op_assign
id|tmc18c30
suffix:semicolon
id|FIFO_Size
op_assign
l_int|0x800
suffix:semicolon
multiline_comment|/* 2k FIFO */
id|printk
c_func
(paren
l_string|&quot;SECOND: chip=%s, fifo_size=0x%x&bslash;n&quot;
comma
(paren
id|chip
op_eq
id|tmc18c30
)paren
ques
c_cond
l_string|&quot;tmc18c30&quot;
suffix:colon
l_string|&quot;tmc18c50&quot;
comma
id|FIFO_Size
)paren
suffix:semicolon
)brace
multiline_comment|/* *************************************************** */
macro_line|#endif
multiline_comment|/* IBM/ANSI scsi scan ordering */
multiline_comment|/* Stick this back in when the scsi.c changes are there */
id|shpnt-&gt;reverse_ordering
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* saving info */
id|hosts
(braket
id|found
op_increment
)braket
op_assign
id|shpnt
suffix:semicolon
id|shpnt-&gt;this_id
op_assign
id|id
suffix:semicolon
id|shpnt-&gt;irq
op_assign
id|irq
suffix:semicolon
id|shpnt-&gt;io_port
op_assign
id|port
suffix:semicolon
id|shpnt-&gt;n_io_port
op_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* save */
id|bios_base
op_assign
id|bios
suffix:semicolon
id|adapter_mask
op_assign
(paren
l_int|1
op_lshift
id|id
)paren
suffix:semicolon
multiline_comment|/* save more */
id|SCSI_Mode_Cntl_port
op_assign
id|port
op_plus
id|SCSI_Mode_Cntl
suffix:semicolon
id|FIFO_Data_Count_port
op_assign
id|port
op_plus
id|FIFO_Data_Count
suffix:semicolon
id|Interrupt_Cntl_port
op_assign
id|port
op_plus
id|Interrupt_Cntl
suffix:semicolon
id|Interrupt_Status_port
op_assign
id|port
op_plus
id|Interrupt_Status
suffix:semicolon
id|Interrupt_Cond_port
op_assign
id|port
op_plus
id|Interrupt_Cond
suffix:semicolon
id|Read_FIFO_port
op_assign
id|port
op_plus
id|Read_FIFO
suffix:semicolon
id|Read_SCSI_Data_port
op_assign
id|port
op_plus
id|Read_SCSI_Data
suffix:semicolon
id|SCSI_Cntl_port
op_assign
id|port
op_plus
id|SCSI_Cntl
suffix:semicolon
id|SCSI_Data_NoACK_port
op_assign
id|port
op_plus
id|SCSI_Data_NoACK
suffix:semicolon
id|SCSI_Status_port
op_assign
id|port
op_plus
id|SCSI_Status
suffix:semicolon
id|TMC_Cntl_port
op_assign
id|port
op_plus
id|TMC_Cntl
suffix:semicolon
id|TMC_Status_port
op_assign
id|port
op_plus
id|TMC_Status
suffix:semicolon
id|Write_FIFO_port
op_assign
id|port
op_plus
id|Write_FIFO
suffix:semicolon
id|Write_SCSI_Data_port
op_assign
id|port
op_plus
id|Write_SCSI_Data
suffix:semicolon
id|Bytes_Read
op_assign
l_int|0
suffix:semicolon
id|Bytes_Written
op_assign
l_int|0
suffix:semicolon
id|INTR_Processed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* say something */
id|print_banner
c_func
(paren
id|shpnt
)paren
suffix:semicolon
multiline_comment|/* reset */
id|outb
c_func
(paren
l_int|1
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|do_pause
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|do_pause
c_func
(paren
l_int|115
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCSI_Mode_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* done reset */
macro_line|#if DO_DETECT
multiline_comment|/* scan devices attached */
(brace
r_const
r_int
id|buflen
op_assign
l_int|255
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|retcode
suffix:semicolon
id|Scsi_Cmnd
id|SCinit
suffix:semicolon
r_int
r_char
id|do_inquiry
(braket
)braket
op_assign
(brace
id|INQUIRY
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|buflen
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|do_request_sense
(braket
)braket
op_assign
(brace
id|REQUEST_SENSE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|buflen
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|do_read_capacity
(braket
)braket
op_assign
(brace
id|READ_CAPACITY
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|buf
(braket
id|buflen
)braket
suffix:semicolon
id|SCinit.request_buffer
op_assign
id|SCinit.buffer
op_assign
id|buf
suffix:semicolon
id|SCinit.request_bufflen
op_assign
id|SCinit.bufflen
op_assign
r_sizeof
(paren
id|buf
)paren
op_minus
l_int|1
suffix:semicolon
id|SCinit.use_sg
op_assign
l_int|0
suffix:semicolon
id|SCinit.lun
op_assign
l_int|0
suffix:semicolon
id|SCinit.host
op_assign
id|shpnt
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fd_mcs: detection routine scanning for devices:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|shpnt-&gt;this_id
)paren
multiline_comment|/* Skip host adapter */
r_continue
suffix:semicolon
id|SCinit.target
op_assign
id|i
suffix:semicolon
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_request_sense
comma
r_sizeof
(paren
id|do_request_sense
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fd_mcs_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
(brace
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_inquiry
comma
r_sizeof
(paren
id|do_inquiry
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fd_mcs_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;     SCSI ID %d: &quot;
comma
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|8
suffix:semicolon
id|j
OL
(paren
id|buf
(braket
l_int|4
)braket
OL
l_int|32
ques
c_cond
id|buf
(braket
l_int|4
)braket
suffix:colon
l_int|32
)paren
suffix:semicolon
id|j
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|buf
(braket
id|j
)braket
op_ge
l_int|20
ques
c_cond
id|buf
(braket
id|j
)braket
suffix:colon
l_char|&squot; &squot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_read_capacity
comma
r_sizeof
(paren
id|do_read_capacity
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fd_mcs_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
(brace
r_int
r_int
id|blocks
comma
id|size
comma
id|capacity
suffix:semicolon
id|blocks
op_assign
(paren
id|buf
(braket
l_int|0
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buf
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buf
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
id|buf
(braket
l_int|3
)braket
suffix:semicolon
id|size
op_assign
(paren
id|buf
(braket
l_int|4
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buf
(braket
l_int|5
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buf
(braket
l_int|6
)braket
op_lshift
l_int|8
)paren
op_or
id|buf
(braket
l_int|7
)braket
suffix:semicolon
id|capacity
op_assign
op_plus
(paren
op_plus
(paren
id|blocks
op_div
l_int|1024L
)paren
op_star
op_plus
(paren
id|size
op_star
l_int|10L
)paren
)paren
op_div
l_int|1024L
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%lu MB (%lu byte blocks)&bslash;n&quot;
comma
(paren
(paren
id|capacity
op_plus
l_int|5L
)paren
op_div
l_int|10L
)paren
comma
id|size
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
macro_line|#endif
)brace
)brace
r_if
c_cond
(paren
id|found
op_eq
id|FD_MAX_HOSTS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd_mcs: detecting reached max=%d host adapters.&bslash;n&quot;
comma
id|FD_MAX_HOSTS
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|found
suffix:semicolon
)brace
DECL|function|fd_mcs_info
r_const
r_char
op_star
id|fd_mcs_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_return
id|adapter_name
suffix:semicolon
)brace
DECL|variable|TOTAL_INTR
r_static
r_int
id|TOTAL_INTR
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * inout : decides on the direction of the dataflow and the meaning of the &n; *         variables&n; * buffer: If inout==FALSE data is being written to it else read from it&n; * *start: If inout==FALSE start of the valid data in the buffer&n; * offset: If inout==FALSE offset from the beginning of the imaginary file &n; *         from which we start writing into the buffer&n; * length: If inout==FALSE max number of bytes to be written into the buffer &n; *         else number of bytes in the buffer&n; */
DECL|function|fd_mcs_proc_info
r_int
id|fd_mcs_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|inout
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|hosts
(braket
id|i
)braket
op_logical_and
id|hosts
(braket
id|i
)braket
op_member_access_from_pointer
id|host_no
op_ne
id|hostno
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
id|shpnt
op_assign
id|hosts
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|shpnt
)paren
(brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_else
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Future Domain MCS-600/700 Driver %s&bslash;n&quot;
comma
id|DRIVER_VERSION
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;HOST #%d: %s&bslash;n&quot;
comma
id|hostno
comma
id|adapter_name
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;FIFO Size=0x%x, FIFO Count=%d&bslash;n&quot;
comma
id|FIFO_Size
comma
id|FIFO_COUNT
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;DriverCalls=%d, Interrupts=%d, BytesRead=%d, BytesWrite=%d&bslash;n&bslash;n&quot;
comma
id|TOTAL_INTR
comma
id|INTR_Processed
comma
id|Bytes_Read
comma
id|Bytes_Written
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|len
op_sub_assign
id|offset
)paren
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|fd_mcs_select
r_static
r_int
id|fd_mcs_select
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_int
id|target
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|outb
c_func
(paren
l_int|0x82
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Bus Enable + Select */
id|outb
c_func
(paren
id|adapter_mask
op_or
(paren
l_int|1
op_lshift
id|target
)paren
comma
id|SCSI_Data_NoACK_port
)paren
suffix:semicolon
multiline_comment|/* Stop arbitration and enable parity */
id|outb
c_func
(paren
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
id|timeout
op_assign
l_int|350
suffix:semicolon
multiline_comment|/* 350mS -- because of timeouts&n;&t;&t;&t;&t;   (was 250mS) */
r_do
(brace
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
suffix:semicolon
multiline_comment|/* Read adapter status */
r_if
c_cond
(paren
id|status
op_amp
l_int|1
)paren
(brace
multiline_comment|/* Busy asserted */
multiline_comment|/* Enable SCSI Bus (on error, should make bus idle with 0) */
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* wait one msec */
)brace
r_while
c_loop
(paren
op_decrement
id|timeout
)paren
suffix:semicolon
multiline_comment|/* Make bus idle */
id|fd_mcs_make_bus_idle
c_func
(paren
id|shpnt
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
r_if
c_cond
(paren
op_logical_neg
id|target
)paren
id|printk
c_func
(paren
l_string|&quot;Selection failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
op_logical_neg
id|target
)paren
(brace
r_static
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
multiline_comment|/* Skip first failure for all chips. */
op_increment
id|flag
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;fd_mcs: Selection failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|my_done
r_static
r_void
id|my_done
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_int
id|error
)paren
(brace
r_if
c_cond
(paren
id|in_command
)paren
(brace
id|in_command
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|fd_mcs_make_bus_idle
c_func
(paren
id|shpnt
)paren
suffix:semicolon
id|current_SC-&gt;result
op_assign
id|error
suffix:semicolon
id|current_SC
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|current_SC
)paren
suffix:semicolon
)brace
r_else
(brace
id|panic
c_func
(paren
l_string|&quot;fd_mcs: my_done() called outside of command&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if DEBUG_RACE
id|in_interrupt_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* only my_done needs to be protected  */
DECL|function|fd_mcs_intr
r_static
r_void
id|fd_mcs_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
id|data_count
comma
id|tmp_count
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
id|TOTAL_INTR
op_increment
suffix:semicolon
multiline_comment|/* search for one adapter-response on shared interrupt */
r_while
c_loop
(paren
(paren
id|shpnt
op_assign
id|hosts
(braket
id|i
op_increment
)braket
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|TMC_Status_port
)paren
)paren
op_amp
l_int|1
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* return if some other device on this IRQ caused the interrupt */
r_if
c_cond
(paren
op_logical_neg
id|shpnt
)paren
(brace
r_return
suffix:semicolon
)brace
id|INTR_Processed
op_increment
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Abort calls my_done, so we do nothing here. */
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|aborted
)paren
(brace
macro_line|#if DEBUG_ABORT
id|printk
c_func
(paren
l_string|&quot;Interrupt after abort, ignoring&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* return; */
)brace
macro_line|#if DEBUG_RACE
op_increment
id|in_interrupt_flag
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|in_arbitration
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|TMC_Status_port
)paren
suffix:semicolon
multiline_comment|/* Read adapter status */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
l_int|0x02
)paren
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; AFAIL &quot;
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|my_done
c_func
(paren
id|shpnt
comma
id|DID_BUS_BUSY
op_lshift
l_int|16
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|current_SC-&gt;SCp.phase
op_assign
id|in_selection
suffix:semicolon
id|outb
c_func
(paren
l_int|0x40
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x82
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Bus Enable + Select */
id|outb
c_func
(paren
id|adapter_mask
op_or
(paren
l_int|1
op_lshift
id|current_SC-&gt;target
)paren
comma
id|SCSI_Data_NoACK_port
)paren
suffix:semicolon
multiline_comment|/* Stop arbitration and enable parity */
id|outb
c_func
(paren
l_int|0x10
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
macro_line|#if DEBUG_RACE
id|in_interrupt_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|in_selection
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
l_int|0x01
)paren
)paren
(brace
multiline_comment|/* Try again, for slow devices */
r_if
c_cond
(paren
id|fd_mcs_select
c_func
(paren
id|shpnt
comma
id|current_SC-&gt;target
)paren
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; SFAIL &quot;
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|my_done
c_func
(paren
id|shpnt
comma
id|DID_NO_CONNECT
op_lshift
l_int|16
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; AltSel &quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Stop arbitration and enable parity */
id|outb
c_func
(paren
l_int|0x10
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
)brace
)brace
id|current_SC-&gt;SCp.phase
op_assign
id|in_other
suffix:semicolon
id|outb
c_func
(paren
l_int|0x90
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
macro_line|#if DEBUG_RACE
id|in_interrupt_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* current_SC-&gt;SCp.phase == in_other: this is the body of the routine */
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* REQ */
r_switch
c_cond
(paren
id|status
op_amp
l_int|0x0e
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/* COMMAND OUT */
id|outb
c_func
(paren
id|current_SC-&gt;cmnd
(braket
id|current_SC-&gt;SCp.sent_command
op_increment
)braket
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;CMD = %x,&quot;
comma
id|current_SC-&gt;cmnd
(braket
id|current_SC-&gt;SCp.sent_command
op_minus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x00
suffix:colon
multiline_comment|/* DATA OUT -- tmc18c50/tmc18c30 only */
r_if
c_cond
(paren
id|chip
op_ne
id|tmc1800
op_logical_and
op_logical_neg
id|current_SC-&gt;SCp.have_data_in
)paren
(brace
id|current_SC-&gt;SCp.have_data_in
op_assign
op_minus
l_int|1
suffix:semicolon
id|outb
c_func
(paren
l_int|0xd0
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x04
suffix:colon
multiline_comment|/* DATA IN -- tmc18c50/tmc18c30 only */
r_if
c_cond
(paren
id|chip
op_ne
id|tmc1800
op_logical_and
op_logical_neg
id|current_SC-&gt;SCp.have_data_in
)paren
(brace
id|current_SC-&gt;SCp.have_data_in
op_assign
l_int|1
suffix:semicolon
id|outb
c_func
(paren
l_int|0x90
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x0c
suffix:colon
multiline_comment|/* STATUS IN */
id|current_SC-&gt;SCp.Status
op_assign
id|inb
c_func
(paren
id|Read_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Status = %x, &quot;
comma
id|current_SC-&gt;SCp.Status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
id|current_SC-&gt;SCp.Status
op_logical_and
id|current_SC-&gt;SCp.Status
op_ne
l_int|2
op_logical_and
id|current_SC-&gt;SCp.Status
op_ne
l_int|8
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ERROR fd_mcs: target = %d, command = %x, status = %x&bslash;n&quot;
comma
id|current_SC-&gt;target
comma
id|current_SC-&gt;cmnd
(braket
l_int|0
)braket
comma
id|current_SC-&gt;SCp.Status
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0a
suffix:colon
multiline_comment|/* MESSAGE OUT */
id|outb
c_func
(paren
id|MESSAGE_REJECT
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
multiline_comment|/* Reject */
r_break
suffix:semicolon
r_case
l_int|0x0e
suffix:colon
multiline_comment|/* MESSAGE IN */
id|current_SC-&gt;SCp.Message
op_assign
id|inb
c_func
(paren
id|Read_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Message = %x, &quot;
comma
id|current_SC-&gt;SCp.Message
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.Message
)paren
op_increment
id|done
suffix:semicolon
macro_line|#if DEBUG_MESSAGES || EVERY_ACCESS
r_if
c_cond
(paren
id|current_SC-&gt;SCp.Message
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd_mcs: message = %x&bslash;n&quot;
comma
id|current_SC-&gt;SCp.Message
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|chip
op_eq
id|tmc1800
op_logical_and
op_logical_neg
id|current_SC-&gt;SCp.have_data_in
op_logical_and
(paren
id|current_SC-&gt;SCp.sent_command
op_ge
id|current_SC-&gt;cmd_len
)paren
)paren
(brace
multiline_comment|/* We have to get the FIFO direction&n;       correct, so I&squot;ve made a table based&n;       on the SCSI Standard of which commands&n;       appear to require a DATA OUT phase.&n;       */
multiline_comment|/*&n;      p. 94: Command for all device types&n;      CHANGE DEFINITION            40 DATA OUT&n;      COMPARE                      39 DATA OUT&n;      COPY                         18 DATA OUT&n;      COPY AND VERIFY              3a DATA OUT&n;      INQUIRY                      12 &n;      LOG SELECT                   4c DATA OUT&n;      LOG SENSE                    4d&n;      MODE SELECT (6)              15 DATA OUT&n;      MODE SELECT (10)             55 DATA OUT&n;      MODE SENSE (6)               1a&n;      MODE SENSE (10)              5a&n;      READ BUFFER                  3c&n;      RECEIVE DIAGNOSTIC RESULTS   1c&n;      REQUEST SENSE                03&n;      SEND DIAGNOSTIC              1d DATA OUT&n;      TEST UNIT READY              00&n;      WRITE BUFFER                 3b DATA OUT&n;&n;      p.178: Commands for direct-access devices (not listed on p. 94)&n;      FORMAT UNIT                  04 DATA OUT&n;      LOCK-UNLOCK CACHE            36&n;      PRE-FETCH                    34&n;      PREVENT-ALLOW MEDIUM REMOVAL 1e&n;      READ (6)/RECEIVE             08&n;      READ (10)                    3c&n;      READ CAPACITY                25&n;      READ DEFECT DATA (10)        37&n;      READ LONG                    3e&n;      REASSIGN BLOCKS              07 DATA OUT&n;      RELEASE                      17&n;      RESERVE                      16 DATA OUT&n;      REZERO UNIT/REWIND           01&n;      SEARCH DATA EQUAL (10)       31 DATA OUT&n;      SEARCH DATA HIGH (10)        30 DATA OUT&n;      SEARCH DATA LOW (10)         32 DATA OUT&n;      SEEK (6)                     0b&n;      SEEK (10)                    2b&n;      SET LIMITS (10)              33&n;      START STOP UNIT              1b&n;      SYNCHRONIZE CACHE            35&n;      VERIFY (10)                  2f&n;      WRITE (6)/PRINT/SEND         0a DATA OUT&n;      WRITE (10)/SEND              2a DATA OUT&n;      WRITE AND VERIFY (10)        2e DATA OUT&n;      WRITE LONG                   3f DATA OUT&n;      WRITE SAME                   41 DATA OUT ?&n;&n;      p. 261: Commands for sequential-access devices (not previously listed)&n;      ERASE                        19&n;      LOAD UNLOAD                  1b&n;      LOCATE                       2b&n;      READ BLOCK LIMITS            05&n;      READ POSITION                34&n;      READ REVERSE                 0f&n;      RECOVER BUFFERED DATA        14&n;      SPACE                        11&n;      WRITE FILEMARKS              10 ?&n;&n;      p. 298: Commands for printer devices (not previously listed)&n;      ****** NOT SUPPORTED BY THIS DRIVER, since 0b is SEEK (6) *****&n;      SLEW AND PRINT               0b DATA OUT  -- same as seek&n;      STOP PRINT                   1b&n;      SYNCHRONIZE BUFFER           10&n;&n;      p. 315: Commands for processor devices (not previously listed)&n;&t;&n;      p. 321: Commands for write-once devices (not previously listed)&n;      MEDIUM SCAN                  38&n;      READ (12)                    a8&n;      SEARCH DATA EQUAL (12)       b1 DATA OUT&n;      SEARCH DATA HIGH (12)        b0 DATA OUT&n;      SEARCH DATA LOW (12)         b2 DATA OUT&n;      SET LIMITS (12)              b3&n;      VERIFY (12)                  af&n;      WRITE (12)                   aa DATA OUT&n;      WRITE AND VERIFY (12)        ae DATA OUT&n;&n;      p. 332: Commands for CD-ROM devices (not previously listed)&n;      PAUSE/RESUME                 4b&n;      PLAY AUDIO (10)              45&n;      PLAY AUDIO (12)              a5&n;      PLAY AUDIO MSF               47&n;      PLAY TRACK RELATIVE (10)     49&n;      PLAY TRACK RELATIVE (12)     a9&n;      READ HEADER                  44&n;      READ SUB-CHANNEL             42&n;      READ TOC                     43&n;&n;      p. 370: Commands for scanner devices (not previously listed)&n;      GET DATA BUFFER STATUS       34&n;      GET WINDOW                   25&n;      OBJECT POSITION              31&n;      SCAN                         1b&n;      SET WINDOW                   24 DATA OUT&n;&n;      p. 391: Commands for optical memory devices (not listed)&n;      ERASE (10)                   2c&n;      ERASE (12)                   ac&n;      MEDIUM SCAN                  38 DATA OUT&n;      READ DEFECT DATA (12)        b7&n;      READ GENERATION              29&n;      READ UPDATED BLOCK           2d&n;      UPDATE BLOCK                 3d DATA OUT&n;&n;      p. 419: Commands for medium changer devices (not listed)&n;      EXCHANGE MEDIUM              46&n;      INITIALIZE ELEMENT STATUS    07&n;      MOVE MEDIUM                  a5&n;      POSITION TO ELEMENT          2b&n;      READ ELEMENT STATUS          b8&n;      REQUEST VOL. ELEMENT ADDRESS b5&n;      SEND VOLUME TAG              b6 DATA OUT&n;&n;      p. 454: Commands for communications devices (not listed previously)&n;      GET MESSAGE (6)              08&n;      GET MESSAGE (10)             28&n;      GET MESSAGE (12)             a8&n;      */
r_switch
c_cond
(paren
id|current_SC-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|CHANGE_DEFINITION
suffix:colon
r_case
id|COMPARE
suffix:colon
r_case
id|COPY
suffix:colon
r_case
id|COPY_VERIFY
suffix:colon
r_case
id|LOG_SELECT
suffix:colon
r_case
id|MODE_SELECT
suffix:colon
r_case
id|MODE_SELECT_10
suffix:colon
r_case
id|SEND_DIAGNOSTIC
suffix:colon
r_case
id|WRITE_BUFFER
suffix:colon
r_case
id|FORMAT_UNIT
suffix:colon
r_case
id|REASSIGN_BLOCKS
suffix:colon
r_case
id|RESERVE
suffix:colon
r_case
id|SEARCH_EQUAL
suffix:colon
r_case
id|SEARCH_HIGH
suffix:colon
r_case
id|SEARCH_LOW
suffix:colon
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
r_case
id|WRITE_VERIFY
suffix:colon
r_case
l_int|0x3f
suffix:colon
r_case
l_int|0x41
suffix:colon
r_case
l_int|0xb1
suffix:colon
r_case
l_int|0xb0
suffix:colon
r_case
l_int|0xb2
suffix:colon
r_case
l_int|0xaa
suffix:colon
r_case
l_int|0xae
suffix:colon
r_case
l_int|0x24
suffix:colon
r_case
l_int|0x38
suffix:colon
r_case
l_int|0x3d
suffix:colon
r_case
l_int|0xb6
suffix:colon
r_case
l_int|0xea
suffix:colon
multiline_comment|/* alternate number for WRITE LONG */
id|current_SC-&gt;SCp.have_data_in
op_assign
op_minus
l_int|1
suffix:semicolon
id|outb
c_func
(paren
l_int|0xd0
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x00
suffix:colon
r_default
suffix:colon
id|current_SC-&gt;SCp.have_data_in
op_assign
l_int|1
suffix:semicolon
id|outb
c_func
(paren
l_int|0x90
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|current_SC-&gt;SCp.have_data_in
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* DATA OUT */
r_while
c_loop
(paren
(paren
id|data_count
op_assign
id|FIFO_Size
op_minus
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
)paren
OG
l_int|512
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;DC=%d, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
OG
id|current_SC-&gt;SCp.this_residual
)paren
id|data_count
op_assign
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
r_if
c_cond
(paren
id|data_count
OG
l_int|0
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;%d OUT, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
id|Bytes_Written
op_increment
suffix:semicolon
id|outb
c_func
(paren
op_star
id|current_SC-&gt;SCp.ptr
op_increment
comma
id|Write_FIFO_port
)paren
suffix:semicolon
op_decrement
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
id|tmp_count
op_assign
id|data_count
op_lshift
l_int|1
suffix:semicolon
id|outsw
c_func
(paren
id|Write_FIFO_port
comma
id|current_SC-&gt;SCp.ptr
comma
id|data_count
)paren
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_add_assign
id|tmp_count
suffix:semicolon
id|Bytes_Written
op_add_assign
id|tmp_count
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_sub_assign
id|tmp_count
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.this_residual
)paren
(brace
r_if
c_cond
(paren
id|current_SC-&gt;SCp.buffers_residual
)paren
(brace
op_decrement
id|current_SC-&gt;SCp.buffers_residual
suffix:semicolon
op_increment
id|current_SC-&gt;SCp.buffer
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|current_SC-&gt;SCp.have_data_in
op_eq
l_int|1
)paren
(brace
multiline_comment|/* DATA IN */
r_while
c_loop
(paren
(paren
id|data_count
op_assign
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
)paren
OG
l_int|0
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;DC=%d, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
OG
id|current_SC-&gt;SCp.this_residual
)paren
id|data_count
op_assign
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
r_if
c_cond
(paren
id|data_count
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;%d IN, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
id|Bytes_Read
op_increment
suffix:semicolon
op_star
id|current_SC-&gt;SCp.ptr
op_increment
op_assign
id|inb
c_func
(paren
id|Read_FIFO_port
)paren
suffix:semicolon
op_decrement
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Number of words */
id|tmp_count
op_assign
id|data_count
op_lshift
l_int|1
suffix:semicolon
id|insw
c_func
(paren
id|Read_FIFO_port
comma
id|current_SC-&gt;SCp.ptr
comma
id|data_count
)paren
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_add_assign
id|tmp_count
suffix:semicolon
id|Bytes_Read
op_add_assign
id|tmp_count
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_sub_assign
id|tmp_count
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.this_residual
op_logical_and
id|current_SC-&gt;SCp.buffers_residual
)paren
(brace
op_decrement
id|current_SC-&gt;SCp.buffers_residual
suffix:semicolon
op_increment
id|current_SC-&gt;SCp.buffer
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|done
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; ** IN DONE %d ** &quot;
comma
id|current_SC-&gt;SCp.have_data_in
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
id|current_SC-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
op_logical_neg
id|current_SC-&gt;SCp.Status
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|current_SC-&gt;request_buffer
op_plus
l_int|2
)paren
)paren
op_amp
l_int|0x0f
)paren
(brace
r_int
r_char
id|key
suffix:semicolon
r_int
r_char
id|code
suffix:semicolon
r_int
r_char
id|qualifier
suffix:semicolon
id|key
op_assign
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|current_SC-&gt;request_buffer
op_plus
l_int|2
)paren
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|code
op_assign
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|current_SC-&gt;request_buffer
op_plus
l_int|12
)paren
)paren
suffix:semicolon
id|qualifier
op_assign
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|current_SC-&gt;request_buffer
op_plus
l_int|13
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|key
op_ne
id|UNIT_ATTENTION
op_logical_and
op_logical_neg
(paren
id|key
op_eq
id|NOT_READY
op_logical_and
id|code
op_eq
l_int|0x04
op_logical_and
(paren
op_logical_neg
id|qualifier
op_logical_or
id|qualifier
op_eq
l_int|0x02
op_logical_or
id|qualifier
op_eq
l_int|0x01
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
(paren
id|code
op_eq
l_int|0x25
op_logical_or
id|code
op_eq
l_int|0x24
op_logical_or
op_logical_neg
id|code
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;fd_mcs: REQUEST SENSE &quot;
l_string|&quot;Key = %x, Code = %x, Qualifier = %x&bslash;n&quot;
comma
id|key
comma
id|code
comma
id|qualifier
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;BEFORE MY_DONE. . .&quot;
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|my_done
c_func
(paren
id|shpnt
comma
(paren
id|current_SC-&gt;SCp.Status
op_amp
l_int|0xff
)paren
op_or
(paren
(paren
id|current_SC-&gt;SCp.Message
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|DID_OK
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;RETURNING.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|disconnect
)paren
(brace
id|outb
c_func
(paren
l_int|0xd0
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
l_int|0x90
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
)brace
)brace
macro_line|#if DEBUG_RACE
id|in_interrupt_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|function|fd_mcs_release
r_int
id|fd_mcs_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_int
id|i
comma
id|this_host
comma
id|irq_usage
suffix:semicolon
id|release_region
c_func
(paren
id|shpnt-&gt;io_port
comma
id|shpnt-&gt;n_io_port
)paren
suffix:semicolon
id|this_host
op_assign
op_minus
l_int|1
suffix:semicolon
id|irq_usage
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|found
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|shpnt
op_eq
id|hosts
(braket
id|i
)braket
)paren
id|this_host
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;irq
op_eq
id|hosts
(braket
id|i
)braket
op_member_access_from_pointer
id|irq
)paren
id|irq_usage
op_increment
suffix:semicolon
)brace
multiline_comment|/* only for the last one */
r_if
c_cond
(paren
l_int|1
op_eq
id|irq_usage
)paren
id|free_irq
c_func
(paren
id|shpnt-&gt;irq
comma
id|hosts
)paren
suffix:semicolon
id|found
op_decrement
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|this_host
suffix:semicolon
id|i
OL
id|found
suffix:semicolon
id|i
op_increment
)paren
id|hosts
(braket
id|i
)braket
op_assign
id|hosts
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
id|hosts
(braket
id|found
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fd_mcs_queue
r_int
id|fd_mcs_queue
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shpnt
op_assign
id|SCpnt-&gt;host
suffix:semicolon
r_if
c_cond
(paren
id|in_command
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;fd_mcs: fd_mcs_queue() NOT REENTRANT!&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;queue: target = %d cmnd = 0x%02x pieces = %d size = %u&bslash;n&quot;
comma
id|SCpnt-&gt;target
comma
op_star
(paren
r_int
r_char
op_star
)paren
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
macro_line|#endif
id|fd_mcs_make_bus_idle
c_func
(paren
id|shpnt
)paren
suffix:semicolon
id|SCpnt-&gt;scsi_done
op_assign
id|done
suffix:semicolon
multiline_comment|/* Save this for the done function */
id|current_SC
op_assign
id|SCpnt
suffix:semicolon
multiline_comment|/* Initialize static data */
r_if
c_cond
(paren
id|current_SC-&gt;use_sg
)paren
(brace
id|current_SC-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|current_SC-&gt;request_buffer
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|current_SC-&gt;SCp.buffers_residual
op_assign
id|current_SC-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|current_SC-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|current_SC-&gt;request_buffer
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;request_bufflen
suffix:semicolon
id|current_SC-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|current_SC-&gt;SCp.buffers_residual
op_assign
l_int|0
suffix:semicolon
)brace
id|current_SC-&gt;SCp.Status
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.Message
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.have_data_in
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.sent_command
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_assign
id|in_arbitration
suffix:semicolon
multiline_comment|/* Start arbitration */
id|outb
c_func
(paren
l_int|0x00
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Disable data drivers */
id|outb
c_func
(paren
id|adapter_mask
comma
id|SCSI_Data_NoACK_port
)paren
suffix:semicolon
multiline_comment|/* Set our id bit */
id|in_command
op_assign
l_int|1
suffix:semicolon
id|outb
c_func
(paren
l_int|0x20
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x14
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Start arbitration */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|internal_done
r_static
r_void
id|internal_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
multiline_comment|/* flag it done */
id|SCpnt-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
l_int|1
suffix:semicolon
)brace
DECL|function|fd_mcs_command
r_int
id|fd_mcs_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|fd_mcs_queue
c_func
(paren
id|SCpnt
comma
id|internal_done
)paren
suffix:semicolon
multiline_comment|/* host_scribble is used for status here */
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|SCpnt-&gt;host_scribble
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_return
id|SCpnt-&gt;result
suffix:semicolon
)brace
macro_line|#if DEBUG_ABORT || DEBUG_RESET
DECL|function|fd_mcs_print_info
r_static
r_void
id|fd_mcs_print_info
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|imr
suffix:semicolon
r_int
r_int
id|irr
suffix:semicolon
r_int
r_int
id|isr
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
op_assign
id|SCpnt-&gt;host
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
op_logical_or
op_logical_neg
id|SCpnt-&gt;host
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd_mcs: cannot provide detailed information&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|fd_mcs_info
c_func
(paren
id|SCpnt-&gt;host
)paren
)paren
suffix:semicolon
id|print_banner
c_func
(paren
id|SCpnt-&gt;host
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|SCpnt-&gt;SCp.phase
)paren
(brace
r_case
id|in_arbitration
suffix:colon
id|printk
c_func
(paren
l_string|&quot;arbitration &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|in_selection
suffix:colon
id|printk
c_func
(paren
l_string|&quot;selection &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|in_other
suffix:colon
id|printk
c_func
(paren
l_string|&quot;other &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;unknown &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;(%d), target = %d cmnd = 0x%02x pieces = %d size = %u&bslash;n&quot;
comma
id|SCpnt-&gt;SCp.phase
comma
id|SCpnt-&gt;target
comma
op_star
(paren
r_int
r_char
op_star
)paren
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sent_command = %d, have_data_in = %d, timeout = %d&bslash;n&quot;
comma
id|SCpnt-&gt;SCp.sent_command
comma
id|SCpnt-&gt;SCp.have_data_in
comma
id|SCpnt-&gt;timeout
)paren
suffix:semicolon
macro_line|#if DEBUG_RACE
id|printk
c_func
(paren
l_string|&quot;in_interrupt_flag = %d&bslash;n&quot;
comma
id|in_interrupt_flag
)paren
suffix:semicolon
macro_line|#endif
id|imr
op_assign
(paren
id|inb
c_func
(paren
l_int|0x0a1
)paren
op_lshift
l_int|8
)paren
op_plus
id|inb
c_func
(paren
l_int|0x21
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0a
comma
l_int|0xa0
)paren
suffix:semicolon
id|irr
op_assign
id|inb
c_func
(paren
l_int|0xa0
)paren
op_lshift
l_int|8
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0a
comma
l_int|0x20
)paren
suffix:semicolon
id|irr
op_add_assign
id|inb
c_func
(paren
l_int|0x20
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0b
comma
l_int|0xa0
)paren
suffix:semicolon
id|isr
op_assign
id|inb
c_func
(paren
l_int|0xa0
)paren
op_lshift
l_int|8
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0b
comma
l_int|0x20
)paren
suffix:semicolon
id|isr
op_add_assign
id|inb
c_func
(paren
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/* Print out interesting information */
id|printk
c_func
(paren
l_string|&quot;IMR = 0x%04x&quot;
comma
id|imr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imr
op_amp
(paren
l_int|1
op_lshift
id|shpnt-&gt;irq
)paren
)paren
id|printk
c_func
(paren
l_string|&quot; (masked)&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, IRR = 0x%04x, ISR = 0x%04x&bslash;n&quot;
comma
id|irr
comma
id|isr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SCSI Status      = 0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TMC Status       = 0x%02x&quot;
comma
id|inb
c_func
(paren
id|TMC_Status_port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|TMC_Status_port
)paren
op_amp
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot; (interrupt)&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Interrupt Status = 0x%02x&quot;
comma
id|inb
c_func
(paren
id|Interrupt_Status_port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|Interrupt_Status_port
)paren
op_amp
l_int|0x08
)paren
id|printk
c_func
(paren
l_string|&quot; (enabled)&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip
op_eq
id|tmc18c50
op_logical_or
id|chip
op_eq
id|tmc18c30
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FIFO Status      = 0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|shpnt-&gt;io_port
op_plus
id|FIFO_Status
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Int. Condition   = 0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|shpnt-&gt;io_port
op_plus
id|Interrupt_Cond
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Configuration 1  = 0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|shpnt-&gt;io_port
op_plus
id|Configuration1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip
op_eq
id|tmc18c50
op_logical_or
id|chip
op_eq
id|tmc18c30
)paren
id|printk
c_func
(paren
l_string|&quot;Configuration 2  = 0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|shpnt-&gt;io_port
op_plus
id|Configuration2
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|fd_mcs_abort
r_int
id|fd_mcs_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shpnt
op_assign
id|SCpnt-&gt;host
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if EVERY_ACCESS || ERRORS_ONLY || DEBUG_ABORT
id|printk
c_func
(paren
l_string|&quot;fd_mcs: abort &quot;
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_command
)paren
(brace
macro_line|#if EVERY_ACCESS || ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot; (not in command)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if DEBUG_ABORT
id|fd_mcs_print_info
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
macro_line|#endif
id|fd_mcs_make_bus_idle
c_func
(paren
id|shpnt
)paren
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_or_assign
id|aborted
suffix:semicolon
id|current_SC-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Aborts are not done well. . . */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|my_done
c_func
(paren
id|shpnt
comma
id|DID_ABORT
op_lshift
l_int|16
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
DECL|function|fd_mcs_reset
r_int
id|fd_mcs_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_int
id|reset_flags
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shpnt
op_assign
id|SCpnt-&gt;host
suffix:semicolon
macro_line|#if DEBUG_RESET
r_static
r_int
id|called_once
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
id|SCpnt
)paren
id|printk
c_func
(paren
l_string|&quot;fd_mcs: SCSI Bus Reset&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG_RESET
r_if
c_cond
(paren
id|called_once
)paren
id|fd_mcs_print_info
c_func
(paren
id|current_SC
)paren
suffix:semicolon
id|called_once
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
l_int|1
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|do_pause
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|do_pause
c_func
(paren
l_int|115
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCSI_Mode_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Unless this is the very first call (i.e., SCPnt == NULL), everything&n;     is probably hosed at this point.  We will, however, try to keep&n;     things going by informing the high-level code that we need help. */
r_return
id|SCSI_RESET_WAKEUP
suffix:semicolon
)brace
macro_line|#include &quot;sd.h&quot;
macro_line|#include &lt;scsi/scsi_ioctl.h&gt;
DECL|function|fd_mcs_biosparam
r_int
id|fd_mcs_biosparam
c_func
(paren
id|Scsi_Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
op_star
id|info_array
)paren
(brace
r_int
id|drive
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|512
op_plus
r_sizeof
(paren
r_int
)paren
op_star
l_int|2
)braket
suffix:semicolon
r_int
id|size
op_assign
id|disk-&gt;capacity
suffix:semicolon
r_int
op_star
id|sizes
op_assign
(paren
r_int
op_star
)paren
id|buf
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|sizes
op_plus
l_int|2
)paren
suffix:semicolon
r_int
r_char
id|do_read
(braket
)braket
op_assign
(brace
id|READ_6
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
)brace
suffix:semicolon
r_int
id|retcode
suffix:semicolon
multiline_comment|/* BIOS &gt;= 3.4 for MCA cards */
id|drive
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
op_div
l_int|16
suffix:semicolon
multiline_comment|/* This algorithm was provided by Future Domain (much thanks!). */
id|sizes
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* zero bytes out */
id|sizes
(braket
l_int|1
)braket
op_assign
l_int|512
suffix:semicolon
multiline_comment|/* one sector in */
id|memcpy
c_func
(paren
id|data
comma
id|do_read
comma
r_sizeof
(paren
id|do_read
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|kernel_scsi_ioctl
c_func
(paren
id|disk-&gt;device
comma
id|SCSI_IOCTL_SEND_COMMAND
comma
(paren
r_void
op_star
)paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
multiline_comment|/* SCSI command ok */
op_logical_and
id|data
(braket
l_int|511
)braket
op_eq
l_int|0xaa
op_logical_and
id|data
(braket
l_int|510
)braket
op_eq
l_int|0x55
multiline_comment|/* Partition table valid */
op_logical_and
id|data
(braket
l_int|0x1c2
)braket
)paren
(brace
multiline_comment|/* Partition type */
multiline_comment|/* The partition table layout is as follows:&n;&n;&t; Start: 0x1b3h&n;&t; Offset: 0 = partition status&n;&t; 1 = starting head&n;&t; 2 = starting sector and cylinder (word, encoded)&n;&t; 4 = partition type&n;&t; 5 = ending head&n;&t; 6 = ending sector and cylinder (word, encoded)&n;&t; 8 = starting absolute sector (double word)&n;&t; c = number of sectors (double word)&n;&t; Signature: 0x1fe = 0x55aa&n;&n;&t; So, this algorithm assumes:&n;&t; 1) the first partition table is in use,&n;&t; 2) the data in the first entry is correct, and&n;&t; 3) partitions never divide cylinders&n;&n;&t; Note that (1) may be FALSE for NetBSD (and other BSD flavors),&n;&t; as well as for Linux.  Note also, that Linux doesn&squot;t pay any&n;&t; attention to the fields that are used by this algorithm -- it&n;&t; only uses the absolute sector data.  Recent versions of Linux&squot;s&n;&t; fdisk(1) will fill this data in correctly, and forthcoming&n;&t; versions will check for consistency.&n;&n;&t; Checking for a non-zero partition type is not part of the&n;&t; Future Domain algorithm, but it seemed to be a reasonable thing&n;&t; to do, especially in the Linux and BSD worlds. */
id|info_array
(braket
l_int|0
)braket
op_assign
id|data
(braket
l_int|0x1c3
)braket
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* heads */
id|info_array
(braket
l_int|1
)braket
op_assign
id|data
(braket
l_int|0x1c4
)braket
op_amp
l_int|0x3f
suffix:semicolon
multiline_comment|/* sectors */
)brace
r_else
(brace
multiline_comment|/* Note that this new method guarantees that there will always be&n;&t; less than 1024 cylinders on a platter.  This is good for drives&n;&t; up to approximately 7.85GB (where 1GB = 1024 * 1024 kB). */
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|size
op_ge
l_int|0x7e0000U
)paren
(brace
id|info_array
(braket
l_int|0
)braket
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* heads   = 255 */
id|info_array
(braket
l_int|1
)braket
op_assign
l_int|0x3f
suffix:semicolon
multiline_comment|/* sectors =  63 */
)brace
r_else
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|size
op_ge
l_int|0x200000U
)paren
(brace
id|info_array
(braket
l_int|0
)braket
op_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* heads   = 128 */
id|info_array
(braket
l_int|1
)braket
op_assign
l_int|0x3f
suffix:semicolon
multiline_comment|/* sectors =  63 */
)brace
r_else
(brace
id|info_array
(braket
l_int|0
)braket
op_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* heads   =  64 */
id|info_array
(braket
l_int|1
)braket
op_assign
l_int|0x20
suffix:semicolon
multiline_comment|/* sectors =  32 */
)brace
)brace
multiline_comment|/* For both methods, compute the cylinders */
id|info_array
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_int
)paren
id|size
op_div
(paren
id|info_array
(braket
l_int|0
)braket
op_star
id|info_array
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Eventually this will go into an include file, but this will be later */
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|FD_MCS
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
eof
