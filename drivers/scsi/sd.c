multiline_comment|/*&n; *      sd.c Copyright (C) 1992 Drew Eckhardt &n; *           Copyright (C) 1993, 1994, 1995 Eric Youngdale&n; *&n; *      Linux scsi disk driver&n; *              Initial versions: Drew Eckhardt &n; *              Subsequent revisions: Eric Youngdale&n; *&n; *      &lt;drew@colorado.edu&gt;&n; *&n; *       Modified by Eric Youngdale ericy@cais.com to&n; *       add scatter-gather, multiple outstanding request, and other&n; *       enhancements.&n; *&n; *       Modified by Eric Youngdale eric@aib.com to support loadable&n; *       low-level scsi drivers.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#ifdef MODULE
multiline_comment|/*&n; * This is a variable in scsi.c that is set when we are processing something&n; * after boot time.  By definition, this is true when we are a loadable module&n; * ourselves.&n; */
DECL|macro|MODULE_FLAG
mdefine_line|#define MODULE_FLAG 1
macro_line|#else
DECL|macro|MODULE_FLAG
mdefine_line|#define MODULE_FLAG scsi_loadable_module_flag
macro_line|#endif /* MODULE */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/system.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR SCSI_DISK_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &lt;scsi/scsi_ioctl.h&gt;
macro_line|#include &quot;constants.h&quot;
macro_line|#include &lt;linux/genhd.h&gt;
multiline_comment|/*&n; *  static const char RCSid[] = &quot;$Header:&quot;;&n; */
DECL|macro|MAX_RETRIES
mdefine_line|#define MAX_RETRIES 5
multiline_comment|/*&n; *  Time out in seconds for disks and Magneto-opticals (which are slower).&n; */
DECL|macro|SD_TIMEOUT
mdefine_line|#define SD_TIMEOUT (15 * HZ)
DECL|macro|SD_MOD_TIMEOUT
mdefine_line|#define SD_MOD_TIMEOUT (15 * HZ)
DECL|macro|CLUSTERABLE_DEVICE
mdefine_line|#define CLUSTERABLE_DEVICE(SC) (SC-&gt;host-&gt;use_clustering &amp;&amp; &bslash;&n;&t;&t;&t;&t;SC-&gt;device-&gt;type != TYPE_MOD)
DECL|variable|sd
r_struct
id|hd_struct
op_star
id|sd
suffix:semicolon
DECL|variable|rscsi_disks
id|Scsi_Disk
op_star
id|rscsi_disks
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|sd_sizes
r_static
r_int
op_star
id|sd_sizes
suffix:semicolon
DECL|variable|sd_blocksizes
r_static
r_int
op_star
id|sd_blocksizes
suffix:semicolon
DECL|variable|sd_hardsizes
r_static
r_int
op_star
id|sd_hardsizes
suffix:semicolon
multiline_comment|/* Hardware sector size */
r_extern
r_int
id|sd_ioctl
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
id|check_scsidisk_media_change
c_func
(paren
id|kdev_t
)paren
suffix:semicolon
r_static
r_int
id|fop_revalidate_scsidisk
c_func
(paren
id|kdev_t
)paren
suffix:semicolon
r_static
id|sd_init_onedisk
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_void
id|requeue_sd_request
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_static
r_int
id|sd_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|sd_finish
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|sd_attach
c_func
(paren
id|Scsi_Device
op_star
)paren
suffix:semicolon
r_static
r_int
id|sd_detect
c_func
(paren
id|Scsi_Device
op_star
)paren
suffix:semicolon
r_static
r_void
id|sd_detach
c_func
(paren
id|Scsi_Device
op_star
)paren
suffix:semicolon
DECL|variable|sd_template
r_struct
id|Scsi_Device_Template
id|sd_template
op_assign
(brace
l_int|NULL
comma
l_string|&quot;disk&quot;
comma
l_string|&quot;sd&quot;
comma
l_int|NULL
comma
id|TYPE_DISK
comma
id|SCSI_DISK_MAJOR
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
id|sd_detect
comma
id|sd_init
comma
id|sd_finish
comma
id|sd_attach
comma
id|sd_detach
)brace
suffix:semicolon
DECL|function|sd_open
r_static
r_int
id|sd_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|target
suffix:semicolon
id|target
op_assign
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
op_ge
id|sd_template.dev_max
op_logical_or
op_logical_neg
id|rscsi_disks
(braket
id|target
)braket
dot
id|device
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* No such device */
multiline_comment|/* &n;     * Make sure that only one process can do a check_change_disk at one time.&n;     * This is also used to lock out further access when the partition table &n;     * is being re-read. &n;     */
r_while
c_loop
(paren
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;busy
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;removable
)paren
(brace
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the drive is empty, just let the open fail.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rscsi_disks
(braket
id|target
)braket
dot
id|ready
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/*&n;&t; * Similarly, if the device has the write protect tab set,&n;&t; * have the open fail if the user expects to be able to write&n;&t; * to the thing.&n;&t; */
r_if
c_cond
(paren
(paren
id|rscsi_disks
(braket
id|target
)braket
dot
id|write_prot
)paren
op_logical_and
(paren
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
multiline_comment|/*&n;     * See if we are requesting a non-existent partition.  Do this&n;     * after checking for disk change.&n;     */
r_if
c_cond
(paren
id|sd_sizes
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;removable
)paren
r_if
c_cond
(paren
op_logical_neg
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;access_count
)paren
(brace
id|sd_ioctl
c_func
(paren
id|inode
comma
l_int|NULL
comma
id|SCSI_IOCTL_DOORLOCK
comma
l_int|0
)paren
suffix:semicolon
)brace
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;access_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;host-&gt;hostt-&gt;usage_count
)paren
(paren
op_star
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;host-&gt;hostt-&gt;usage_count
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sd_template.usage_count
)paren
(brace
(paren
op_star
id|sd_template.usage_count
)paren
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sd_release
r_static
r_void
id|sd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|target
suffix:semicolon
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|target
op_assign
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;access_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;host-&gt;hostt-&gt;usage_count
)paren
(paren
op_star
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;host-&gt;hostt-&gt;usage_count
)paren
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|sd_template.usage_count
)paren
(brace
(paren
op_star
id|sd_template.usage_count
)paren
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;removable
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;access_count
)paren
(brace
id|sd_ioctl
c_func
(paren
id|inode
comma
l_int|NULL
comma
id|SCSI_IOCTL_DOORUNLOCK
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
id|sd_geninit
c_func
(paren
r_struct
id|gendisk
op_star
)paren
suffix:semicolon
DECL|variable|sd_fops
r_static
r_struct
id|file_operations
id|sd_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|sd_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|sd_open
comma
multiline_comment|/* open code */
id|sd_release
comma
multiline_comment|/* release */
id|block_fsync
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
id|check_scsidisk_media_change
comma
multiline_comment|/* Disk change */
id|fop_revalidate_scsidisk
multiline_comment|/* revalidate */
)brace
suffix:semicolon
DECL|variable|sd_gendisk
r_static
r_struct
id|gendisk
id|sd_gendisk
op_assign
(brace
id|MAJOR_NR
comma
multiline_comment|/* Major number */
l_string|&quot;sd&quot;
comma
multiline_comment|/* Major name */
l_int|4
comma
multiline_comment|/* Bits to shift to get real from partition */
l_int|1
op_lshift
l_int|4
comma
multiline_comment|/* Number of partitions per real */
l_int|0
comma
multiline_comment|/* maximum number of real */
id|sd_geninit
comma
multiline_comment|/* init function */
l_int|NULL
comma
multiline_comment|/* hd struct */
l_int|NULL
comma
multiline_comment|/* block sizes */
l_int|0
comma
multiline_comment|/* number */
l_int|NULL
comma
multiline_comment|/* internal */
l_int|NULL
multiline_comment|/* next */
)brace
suffix:semicolon
DECL|function|sd_geninit
r_static
r_void
id|sd_geninit
(paren
r_struct
id|gendisk
op_star
id|ignored
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sd_template.dev_max
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|i
)braket
dot
id|device
)paren
(brace
id|sd
(braket
id|i
op_lshift
l_int|4
)braket
dot
id|nr_sects
op_assign
id|rscsi_disks
(braket
id|i
)braket
dot
id|capacity
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* No longer needed - we keep track of this as we attach/detach */
id|sd_gendisk.nr_real
op_assign
id|sd_template.dev_max
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * rw_intr is the interrupt routine for the device driver.&n; * It will be notified on the end of a SCSI read / write, and&n; * will take one of several actions based on success or failure.&n; */
DECL|function|rw_intr
r_static
r_void
id|rw_intr
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|result
op_assign
id|SCpnt-&gt;result
suffix:semicolon
r_int
id|this_count
op_assign
id|SCpnt-&gt;bufflen
op_rshift
l_int|9
suffix:semicolon
r_int
id|good_sectors
op_assign
(paren
id|result
op_eq
l_int|0
ques
c_cond
id|this_count
suffix:colon
l_int|0
)paren
suffix:semicolon
r_int
id|block_sectors
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sd%c : rw_intr(%d, %d)&bslash;n&quot;
comma
l_char|&squot;a&squot;
op_plus
id|MINOR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|result
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;      Handle MEDIUM ERRORs that indicate partial success.  Since this is a&n;      relatively rare error condition, no care is taken to avoid unnecessary&n;      additional work such as memcpy&squot;s that could be avoided.&n;    */
r_if
c_cond
(paren
id|driver_byte
c_func
(paren
id|result
)paren
op_ne
l_int|0
op_logical_and
multiline_comment|/* An error occurred */
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_eq
l_int|0xF0
op_logical_and
multiline_comment|/* Sense data is valid */
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_eq
id|MEDIUM_ERROR
)paren
(brace
r_int
id|error_sector
op_assign
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|3
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|4
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|5
)braket
op_lshift
l_int|8
)paren
op_or
id|SCpnt-&gt;sense_buffer
(braket
l_int|6
)braket
suffix:semicolon
r_int
id|sector_size
op_assign
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)braket
dot
id|sector_size
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request.bh
op_ne
l_int|NULL
)paren
id|block_sectors
op_assign
id|SCpnt-&gt;request.bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|sector_size
op_eq
l_int|1024
)paren
(brace
id|error_sector
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|block_sectors
OL
l_int|2
)paren
id|block_sectors
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sector_size
op_eq
l_int|256
)paren
id|error_sector
op_rshift_assign
l_int|1
suffix:semicolon
id|error_sector
op_sub_assign
id|sd
(braket
id|MINOR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)braket
dot
id|start_sect
suffix:semicolon
id|error_sector
op_and_assign
op_complement
(paren
id|block_sectors
op_minus
l_int|1
)paren
suffix:semicolon
id|good_sectors
op_assign
id|error_sector
op_minus
id|SCpnt-&gt;request.sector
suffix:semicolon
r_if
c_cond
(paren
id|good_sectors
OL
l_int|0
op_logical_or
id|good_sectors
op_ge
id|this_count
)paren
id|good_sectors
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * First case : we assume that the command succeeded.  One of two things &n;     * will happen here.  Either we will be finished, or there will be more&n;     * sectors that we were unable to read last time.&n;     */
r_if
c_cond
(paren
id|good_sectors
OG
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sd%c : %d sectors remain.&bslash;n&quot;
comma
l_char|&squot;a&squot;
op_plus
id|MINOR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
comma
id|SCpnt-&gt;request.nr_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;use_sg is %d&bslash;n &quot;
comma
id|SCpnt-&gt;use_sg
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
r_struct
id|scatterlist
op_star
id|sgpnt
suffix:semicolon
r_int
id|i
suffix:semicolon
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;:%x %x %d&bslash;n&quot;
comma
id|sgpnt
(braket
id|i
)braket
dot
id|alt_address
comma
id|sgpnt
(braket
id|i
)braket
dot
id|address
comma
id|sgpnt
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sgpnt
(braket
id|i
)braket
dot
id|alt_address
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;request.cmd
op_eq
id|READ
)paren
id|memcpy
c_func
(paren
id|sgpnt
(braket
id|i
)braket
dot
id|alt_address
comma
id|sgpnt
(braket
id|i
)braket
dot
id|address
comma
id|sgpnt
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
id|scsi_free
c_func
(paren
id|sgpnt
(braket
id|i
)braket
dot
id|address
comma
id|sgpnt
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Free list of scatter-gather pointers */
id|scsi_free
c_func
(paren
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;sglist_len
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;buffer
op_ne
id|SCpnt-&gt;request.buffer
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;nosg: %x %x %d&bslash;n&quot;
comma
id|SCpnt-&gt;request.buffer
comma
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;bufflen
)paren
suffix:semicolon
macro_line|#endif  
r_if
c_cond
(paren
id|SCpnt-&gt;request.cmd
op_eq
id|READ
)paren
id|memcpy
c_func
(paren
id|SCpnt-&gt;request.buffer
comma
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;bufflen
)paren
suffix:semicolon
id|scsi_free
c_func
(paren
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;bufflen
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If multiple sectors are requested in one buffer, then&n;&t; * they will have been finished off by the first command.&n;&t; * If not, then we have a multi-buffer command.&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;request.nr_sectors
OG
id|this_count
)paren
(brace
id|SCpnt-&gt;request.errors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCpnt-&gt;request.bh
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sd%c : handling page request, no buffer&bslash;n&quot;
comma
l_char|&squot;a&squot;
op_plus
id|MINOR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * The SCpnt-&gt;request.nr_sectors field is always done in &n;&t;&t; * 512 byte sectors, even if this really isn&squot;t the case.&n;&t;&t; */
id|panic
c_func
(paren
l_string|&quot;sd.c: linked page request (%lx %x)&quot;
comma
id|SCpnt-&gt;request.sector
comma
id|this_count
)paren
suffix:semicolon
)brace
)brace
id|SCpnt
op_assign
id|end_scsi_request
c_func
(paren
id|SCpnt
comma
l_int|1
comma
id|good_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|requeue_sd_request
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|good_sectors
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Free up any indirection buffers we allocated for DMA purposes. */
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
r_struct
id|scatterlist
op_star
id|sgpnt
suffix:semicolon
r_int
id|i
suffix:semicolon
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;err: %x %x %d&bslash;n&quot;
comma
id|SCpnt-&gt;request.buffer
comma
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;bufflen
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sgpnt
(braket
id|i
)braket
dot
id|alt_address
)paren
(brace
id|scsi_free
c_func
(paren
id|sgpnt
(braket
id|i
)braket
dot
id|address
comma
id|sgpnt
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
)brace
)brace
id|scsi_free
c_func
(paren
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;sglist_len
)paren
suffix:semicolon
multiline_comment|/* Free list of scatter-gather pointers */
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;nosgerr: %x %x %d&bslash;n&quot;
comma
id|SCpnt-&gt;request.buffer
comma
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;bufflen
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SCpnt-&gt;buffer
op_ne
id|SCpnt-&gt;request.buffer
)paren
id|scsi_free
c_func
(paren
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;bufflen
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * Now, if we were good little boys and girls, Santa left us a request&n;     * sense buffer.  We can extract information from this, so we&n;     * can choose a block to remap, etc.&n;     */
r_if
c_cond
(paren
id|driver_byte
c_func
(paren
id|result
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|suggestion
c_func
(paren
id|result
)paren
op_eq
id|SUGGEST_REMAP
)paren
(brace
macro_line|#ifdef REMAP
multiline_comment|/*&n;&t;     * Not yet implemented.  A read will fail after being remapped,&n;&t;     * a write will call the strategy routine again.&n;&t;     */
r_if
c_cond
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)braket
dot
id|remap
(brace
id|result
op_assign
l_int|0
suffix:semicolon
)brace
r_else
macro_line|#endif
)brace
r_if
c_cond
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x7f
)paren
op_eq
l_int|0x70
)paren
(brace
r_if
c_cond
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
id|UNIT_ATTENTION
)paren
(brace
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)braket
dot
id|device-&gt;removable
)paren
(brace
multiline_comment|/* detected disc change.  set a bit and quietly refuse&n;&t;&t;     * further access.&n;&t;&t;     */
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)braket
dot
id|device-&gt;changed
op_assign
l_int|1
suffix:semicolon
id|SCpnt
op_assign
id|end_scsi_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|this_count
)paren
suffix:semicolon
id|requeue_sd_request
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;                     * Must have been a power glitch, or a bus reset.&n;                     * Could not have been a media change, so we just retry&n;                     * the request and see what happens.&n;                     */
id|requeue_sd_request
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* If we had an ILLEGAL REQUEST returned, then we may have&n;&t; * performed an unsupported command.  The only thing this should be &n;&t; * would be a ten byte read where only a six byte read was supported.&n;&t; * Also, on a system where READ CAPACITY failed, we have have read &n;&t; * past the end of the disk. &n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_eq
id|ILLEGAL_REQUEST
)paren
(brace
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)braket
dot
id|ten
)paren
(brace
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)braket
dot
id|ten
op_assign
l_int|0
suffix:semicolon
id|requeue_sd_request
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ???? */
)brace
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_eq
id|MEDIUM_ERROR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d: MEDIUM ERROR on channel %d, id %d, lun %d, CDB: &quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
(paren
r_int
)paren
id|SCpnt-&gt;channel
comma
(paren
r_int
)paren
id|SCpnt-&gt;target
comma
(paren
r_int
)paren
id|SCpnt-&gt;lun
)paren
suffix:semicolon
id|print_command
c_func
(paren
id|SCpnt-&gt;cmnd
)paren
suffix:semicolon
id|print_sense
c_func
(paren
l_string|&quot;sr&quot;
comma
id|SCpnt
)paren
suffix:semicolon
id|SCpnt
op_assign
id|end_scsi_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|block_sectors
)paren
suffix:semicolon
id|requeue_sd_request
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* driver byte != 0 */
r_if
c_cond
(paren
id|result
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI disk error : host %d channel %d id %d lun %d return code = %x&bslash;n&quot;
comma
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)braket
dot
id|device-&gt;host-&gt;host_no
comma
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)braket
dot
id|device-&gt;channel
comma
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)braket
dot
id|device-&gt;id
comma
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
)braket
dot
id|device-&gt;lun
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_byte
c_func
(paren
id|result
)paren
op_amp
id|DRIVER_SENSE
)paren
id|print_sense
c_func
(paren
l_string|&quot;sd&quot;
comma
id|SCpnt
)paren
suffix:semicolon
id|SCpnt
op_assign
id|end_scsi_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|SCpnt-&gt;request.current_nr_sectors
)paren
suffix:semicolon
id|requeue_sd_request
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * requeue_sd_request() is the request handler function for the sd driver.&n; * Its function in life is to take block device requests, and translate&n; * them to SCSI commands.&n; */
DECL|function|do_sd_request
r_static
r_void
id|do_sd_request
(paren
r_void
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Device
op_star
id|SDev
suffix:semicolon
r_struct
id|request
op_star
id|req
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
op_eq
l_int|1
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_ne
l_int|NULL
op_logical_and
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|INIT_SCSI_REQUEST
suffix:semicolon
id|SDev
op_assign
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
)braket
dot
id|device
suffix:semicolon
multiline_comment|/*&n;         * I am not sure where the best place to do this is.  We need&n;         * to hook in a place where we are likely to come if in user&n;         * space.&n;         */
r_if
c_cond
(paren
id|SDev-&gt;was_reset
)paren
(brace
multiline_comment|/*&n;&t;     * We need to relock the door, but we might&n;&t;     * be in an interrupt handler.  Only do this&n;&t;     * from user space, since we do not want to&n;&t;     * sleep from an interrupt.&n;&t;     */
r_if
c_cond
(paren
id|SDev-&gt;removable
op_logical_and
op_logical_neg
id|intr_count
)paren
(brace
id|scsi_ioctl
c_func
(paren
id|SDev
comma
id|SCSI_IOCTL_DOORLOCK
comma
l_int|0
)paren
suffix:semicolon
)brace
id|SDev-&gt;was_reset
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We have to be careful here. allocate_device will get a free pointer,&n;&t; * but there is no guarantee that it is queueable.  In normal usage, &n;&t; * we want to call this, because other types of devices may have the &n;&t; * host all tied up, and we want to make sure that we have at least &n;&t; * one request pending for this type of device. We can also come &n;&t; * through here while servicing an interrupt, because of the need to &n;&t; * start another command. If we call allocate_device more than once, &n;&t; * then the system can wedge if the command is not queueable. The &n;&t; * request_queueable function is safe because it checks to make sure &n;&t; * that the host is able to take another command before it returns&n;&t; * a pointer.  &n;&t; */
r_if
c_cond
(paren
id|flag
op_increment
op_eq
l_int|0
)paren
id|SCpnt
op_assign
id|allocate_device
c_func
(paren
op_amp
id|CURRENT
comma
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
)braket
dot
id|device
comma
l_int|0
)paren
suffix:semicolon
r_else
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * The following restore_flags leads to latency problems.  FIXME.&n;&t; * Using a &quot;sti()&quot; gets rid of the latency problems but causes&n;&t; * race conditions and crashes.&n;&t; */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* This is a performance enhancement. We dig down into the request &n;&t; * list and try to find a queueable request (i.e. device not busy, &n;&t; * and host able to accept another command. If we find one, then we &n;&t; * queue it. This can make a big difference on systems with more than &n;&t; * one disk drive.  We want to have the interrupts off when monkeying &n;&t; * with the request list, because otherwise the kernel might try to &n;&t; * slip in a request in between somewhere. &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
op_logical_and
id|sd_template.nr_dev
OG
l_int|1
)paren
(brace
r_struct
id|request
op_star
id|req1
suffix:semicolon
id|req1
op_assign
l_int|NULL
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|req
op_assign
id|CURRENT
suffix:semicolon
r_while
c_loop
(paren
id|req
)paren
(brace
id|SCpnt
op_assign
id|request_queueable
c_func
(paren
id|req
comma
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|req-&gt;rq_dev
)paren
)braket
dot
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
)paren
(brace
r_break
suffix:semicolon
)brace
id|req1
op_assign
id|req
suffix:semicolon
id|req
op_assign
id|req-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt
op_logical_and
id|req-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_if
c_cond
(paren
id|req
op_eq
id|CURRENT
)paren
id|CURRENT
op_assign
id|CURRENT-&gt;next
suffix:semicolon
r_else
id|req1-&gt;next
op_assign
id|req-&gt;next
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
)paren
r_return
suffix:semicolon
multiline_comment|/* Could not find anything to do */
multiline_comment|/* Queue command */
id|requeue_sd_request
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
multiline_comment|/* While */
)brace
DECL|function|requeue_sd_request
r_static
r_void
id|requeue_sd_request
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|dev
comma
id|devm
comma
id|block
comma
id|this_count
suffix:semicolon
r_int
r_char
id|cmd
(braket
l_int|10
)braket
suffix:semicolon
r_int
id|bounce_size
comma
id|contiguous
suffix:semicolon
r_int
id|max_sg
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|bhp
suffix:semicolon
r_char
op_star
id|buff
comma
op_star
id|bounce_buffer
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
op_logical_or
id|SCpnt-&gt;request.rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
id|do_sd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|devm
op_assign
id|MINOR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
suffix:semicolon
id|dev
op_assign
id|DEVICE_NR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
suffix:semicolon
id|block
op_assign
id|SCpnt-&gt;request.sector
suffix:semicolon
id|this_count
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Doing sd request, dev = %d, block = %d&bslash;n&quot;
comma
id|devm
comma
id|block
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|devm
op_ge
(paren
id|sd_template.dev_max
op_lshift
l_int|4
)paren
op_logical_or
op_logical_neg
id|rscsi_disks
(braket
id|dev
)braket
dot
id|device
op_logical_or
id|block
op_plus
id|SCpnt-&gt;request.nr_sectors
OG
id|sd
(braket
id|devm
)braket
dot
id|nr_sects
)paren
(brace
id|SCpnt
op_assign
id|end_scsi_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|SCpnt-&gt;request.nr_sectors
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|block
op_add_assign
id|sd
(braket
id|devm
)braket
dot
id|start_sect
suffix:semicolon
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|dev
)braket
dot
id|device-&gt;changed
)paren
(brace
multiline_comment|/*&n;&t; * quietly refuse to do anything to a changed disc until the changed &n;&t; * bit has been reset&n;&t; */
multiline_comment|/* printk(&quot;SCSI disk has been changed. Prohibiting further I/O.&bslash;n&quot;); */
id|SCpnt
op_assign
id|end_scsi_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|SCpnt-&gt;request.nr_sectors
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sd%c : real dev = /dev/sd%c, block = %d&bslash;n&quot;
comma
l_char|&squot;a&squot;
op_plus
id|devm
comma
id|dev
comma
id|block
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;     * If we have a 1K hardware sectorsize, prevent access to single&n;     * 512 byte sectors.  In theory we could handle this - in fact&n;     * the scsi cdrom driver must be able to handle this because&n;     * we typically use 1K blocksizes, and cdroms typically have&n;     * 2K hardware sectorsizes.  Of course, things are simpler&n;     * with the cdrom, since it is read-only.  For performance&n;     * reasons, the filesystems should be able to handle this&n;     * and not force the scsi disk driver to use bounce buffers&n;     * for this.&n;     */
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|dev
)braket
dot
id|sector_size
op_eq
l_int|1024
)paren
r_if
c_cond
(paren
(paren
id|block
op_amp
l_int|1
)paren
op_logical_or
(paren
id|SCpnt-&gt;request.nr_sectors
op_amp
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sd.c:Bad block number requested&quot;
)paren
suffix:semicolon
id|SCpnt
op_assign
id|end_scsi_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|SCpnt-&gt;request.nr_sectors
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|SCpnt-&gt;request.cmd
)paren
(brace
r_case
id|WRITE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|rscsi_disks
(braket
id|dev
)braket
dot
id|device-&gt;writeable
)paren
(brace
id|SCpnt
op_assign
id|end_scsi_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|SCpnt-&gt;request.nr_sectors
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|cmd
(braket
l_int|0
)braket
op_assign
id|WRITE_6
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ
suffix:colon
id|cmd
(braket
l_int|0
)braket
op_assign
id|READ_6
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
(paren
l_string|&quot;Unknown sd command %d&bslash;n&quot;
comma
id|SCpnt-&gt;request.cmd
)paren
suffix:semicolon
)brace
id|SCpnt-&gt;this_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If the host adapter can deal with very large scatter-gather&n;     * requests, it is a waste of time to cluster &n;     */
id|contiguous
op_assign
(paren
op_logical_neg
id|CLUSTERABLE_DEVICE
c_func
(paren
id|SCpnt
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
id|bounce_buffer
op_assign
l_int|NULL
suffix:semicolon
id|bounce_size
op_assign
(paren
id|SCpnt-&gt;request.nr_sectors
op_lshift
l_int|9
)paren
suffix:semicolon
multiline_comment|/* First see if we need a bounce buffer for this request. If we do, make &n;     * sure that we can allocate a buffer. Do not waste space by allocating &n;     * a bounce buffer if we are straddling the 16Mb line &n;     */
r_if
c_cond
(paren
id|contiguous
op_logical_and
id|SCpnt-&gt;request.bh
op_logical_and
(paren
(paren
r_int
)paren
id|SCpnt-&gt;request.bh-&gt;b_data
)paren
op_plus
(paren
id|SCpnt-&gt;request.nr_sectors
op_lshift
l_int|9
)paren
op_minus
l_int|1
OG
id|ISA_DMA_THRESHOLD
op_logical_and
id|SCpnt-&gt;host-&gt;unchecked_isa_dma
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|SCpnt-&gt;request.bh-&gt;b_data
)paren
OG
id|ISA_DMA_THRESHOLD
)paren
(brace
id|bounce_buffer
op_assign
(paren
r_char
op_star
)paren
id|scsi_malloc
c_func
(paren
id|bounce_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bounce_buffer
)paren
(brace
id|contiguous
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|contiguous
op_logical_and
id|SCpnt-&gt;request.bh
op_logical_and
id|SCpnt-&gt;request.bh-&gt;b_reqnext
)paren
r_for
c_loop
(paren
id|bh
op_assign
id|SCpnt-&gt;request.bh
comma
id|bhp
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
id|bhp
suffix:semicolon
id|bh
op_assign
id|bhp
comma
id|bhp
op_assign
id|bhp-&gt;b_reqnext
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|CONTIGUOUS_BUFFERS
c_func
(paren
id|bh
comma
id|bhp
)paren
)paren
(brace
r_if
c_cond
(paren
id|bounce_buffer
)paren
(brace
id|scsi_free
c_func
(paren
id|bounce_buffer
comma
id|bounce_size
)paren
suffix:semicolon
)brace
id|contiguous
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|SCpnt-&gt;request.bh
op_logical_or
id|contiguous
)paren
(brace
multiline_comment|/* case of page request (i.e. raw device), or unlinked buffer */
id|this_count
op_assign
id|SCpnt-&gt;request.nr_sectors
suffix:semicolon
id|buff
op_assign
id|SCpnt-&gt;request.buffer
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;sg_tablesize
op_eq
l_int|0
op_logical_or
(paren
id|need_isa_buffer
op_logical_and
id|dma_free_sectors
op_le
l_int|10
)paren
)paren
(brace
multiline_comment|/* Case of host adapter that cannot scatter-gather.  We also&n;&t; * come here if we are running low on DMA buffer memory.  We set&n;&t; * a threshold higher than that we would need for this request so&n;&t; * we leave room for other requests.  Even though we would not need&n;&t; * it all, we need to be conservative, because if we run low enough&n;&t; * we have no choice but to panic. &n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;sg_tablesize
op_ne
l_int|0
op_logical_and
id|need_isa_buffer
op_logical_and
id|dma_free_sectors
op_le
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;Warning: SCSI DMA buffer space running low.  Using non scatter-gather I/O.&bslash;n&quot;
)paren
suffix:semicolon
id|this_count
op_assign
id|SCpnt-&gt;request.current_nr_sectors
suffix:semicolon
id|buff
op_assign
id|SCpnt-&gt;request.buffer
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Scatter-gather capable host adapter */
r_struct
id|scatterlist
op_star
id|sgpnt
suffix:semicolon
r_int
id|count
comma
id|this_count_max
suffix:semicolon
r_int
id|counted
suffix:semicolon
id|bh
op_assign
id|SCpnt-&gt;request.bh
suffix:semicolon
id|this_count
op_assign
l_int|0
suffix:semicolon
id|this_count_max
op_assign
(paren
id|rscsi_disks
(braket
id|dev
)braket
dot
id|ten
ques
c_cond
l_int|0xffff
suffix:colon
l_int|0xff
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
id|bhp
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|bh
)paren
(brace
r_if
c_cond
(paren
(paren
id|this_count
op_plus
(paren
id|bh-&gt;b_size
op_rshift
l_int|9
)paren
)paren
OG
id|this_count_max
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bhp
op_logical_or
op_logical_neg
id|CONTIGUOUS_BUFFERS
c_func
(paren
id|bhp
comma
id|bh
)paren
op_logical_or
op_logical_neg
id|CLUSTERABLE_DEVICE
c_func
(paren
id|SCpnt
)paren
op_logical_or
(paren
id|SCpnt-&gt;host-&gt;unchecked_isa_dma
op_logical_and
(paren
(paren
r_int
r_int
)paren
id|bh-&gt;b_data
op_minus
l_int|1
)paren
op_eq
id|ISA_DMA_THRESHOLD
)paren
)paren
(brace
r_if
c_cond
(paren
id|count
OL
id|SCpnt-&gt;host-&gt;sg_tablesize
)paren
id|count
op_increment
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
id|this_count
op_add_assign
(paren
id|bh-&gt;b_size
op_rshift
l_int|9
)paren
suffix:semicolon
id|bhp
op_assign
id|bh
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;unchecked_isa_dma
op_logical_and
(paren
(paren
r_int
r_int
)paren
id|SCpnt-&gt;request.bh-&gt;b_data
op_minus
l_int|1
)paren
op_eq
id|ISA_DMA_THRESHOLD
)paren
(brace
id|count
op_decrement
suffix:semicolon
)brace
macro_line|#endif
id|SCpnt-&gt;use_sg
op_assign
id|count
suffix:semicolon
multiline_comment|/* Number of chains */
id|count
op_assign
l_int|512
suffix:semicolon
multiline_comment|/* scsi_malloc can only allocate in chunks of 512 bytes */
r_while
c_loop
(paren
id|count
OL
(paren
id|SCpnt-&gt;use_sg
op_star
r_sizeof
(paren
r_struct
id|scatterlist
)paren
)paren
)paren
(brace
id|count
op_assign
id|count
op_lshift
l_int|1
suffix:semicolon
)brace
id|SCpnt-&gt;sglist_len
op_assign
id|count
suffix:semicolon
id|max_sg
op_assign
id|count
op_div
r_sizeof
(paren
r_struct
id|scatterlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;sg_tablesize
OL
id|max_sg
)paren
(brace
id|max_sg
op_assign
id|SCpnt-&gt;host-&gt;sg_tablesize
suffix:semicolon
)brace
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|scsi_malloc
c_func
(paren
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sgpnt
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning - running *really* short on DMA buffers&bslash;n&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No memory left - bail out */
id|this_count
op_assign
id|SCpnt-&gt;request.current_nr_sectors
suffix:semicolon
id|buff
op_assign
id|SCpnt-&gt;request.buffer
suffix:semicolon
)brace
r_else
(brace
id|memset
c_func
(paren
id|sgpnt
comma
l_int|0
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* Zero so it is easy to fill, but only&n;&t;&t;&t;&t;       * if memory is available &n;&t;&t;&t;&t;       */
id|buff
op_assign
(paren
r_char
op_star
)paren
id|sgpnt
suffix:semicolon
id|counted
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
comma
id|bh
op_assign
id|SCpnt-&gt;request.bh
comma
id|bhp
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
id|count
OL
id|SCpnt-&gt;use_sg
op_logical_and
id|bh
suffix:semicolon
id|count
op_increment
comma
id|bh
op_assign
id|bhp
)paren
(brace
id|bhp
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sgpnt
(braket
id|count
)braket
dot
id|address
)paren
(brace
id|sgpnt
(braket
id|count
)braket
dot
id|address
op_assign
id|bh-&gt;b_data
suffix:semicolon
)brace
id|sgpnt
(braket
id|count
)braket
dot
id|length
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
id|counted
op_add_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|sgpnt
(braket
id|count
)braket
dot
id|address
)paren
op_plus
id|sgpnt
(braket
id|count
)braket
dot
id|length
op_minus
l_int|1
OG
id|ISA_DMA_THRESHOLD
op_logical_and
(paren
id|SCpnt-&gt;host-&gt;unchecked_isa_dma
)paren
op_logical_and
op_logical_neg
id|sgpnt
(braket
id|count
)braket
dot
id|alt_address
)paren
(brace
id|sgpnt
(braket
id|count
)braket
dot
id|alt_address
op_assign
id|sgpnt
(braket
id|count
)braket
dot
id|address
suffix:semicolon
multiline_comment|/* We try to avoid exhausting the DMA pool, since it is &n;&t;&t;     * easier to control usage here. In other places we might &n;&t;&t;     * have a more pressing need, and we would be screwed if &n;&t;&t;     * we ran out */
r_if
c_cond
(paren
id|dma_free_sectors
OL
(paren
id|sgpnt
(braket
id|count
)braket
dot
id|length
op_rshift
l_int|9
)paren
op_plus
l_int|10
)paren
(brace
id|sgpnt
(braket
id|count
)braket
dot
id|address
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|sgpnt
(braket
id|count
)braket
dot
id|address
op_assign
(paren
r_char
op_star
)paren
id|scsi_malloc
c_func
(paren
id|sgpnt
(braket
id|count
)braket
dot
id|length
)paren
suffix:semicolon
)brace
multiline_comment|/* If we start running low on DMA buffers, we abort the &n;&t;&t;     * scatter-gather operation, and free all of the memory &n;&t;&t;     * we have allocated.  We want to ensure that all scsi &n;&t;&t;     * operations are able to do at least a non-scatter/gather&n;&t;&t;     * operation */
r_if
c_cond
(paren
id|sgpnt
(braket
id|count
)braket
dot
id|address
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Out of dma memory */
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;Warning: Running low on SCSI DMA buffers&quot;
)paren
suffix:semicolon
multiline_comment|/* Try switching back to a non s-g operation. */
r_while
c_loop
(paren
op_decrement
id|count
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sgpnt
(braket
id|count
)braket
dot
id|alt_address
)paren
(brace
id|scsi_free
c_func
(paren
id|sgpnt
(braket
id|count
)braket
dot
id|address
comma
id|sgpnt
(braket
id|count
)braket
dot
id|length
)paren
suffix:semicolon
)brace
)brace
id|this_count
op_assign
id|SCpnt-&gt;request.current_nr_sectors
suffix:semicolon
id|buff
op_assign
id|SCpnt-&gt;request.buffer
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|scsi_free
c_func
(paren
id|sgpnt
comma
id|SCpnt-&gt;sglist_len
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt-&gt;use_sg
op_assign
id|count
suffix:semicolon
id|this_count
op_assign
id|counted
op_sub_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Only cluster buffers if we know that we can supply DMA &n;&t;&t; * buffers large enough to satisfy the request. Do not cluster&n;&t;&t; * a new request if this would mean that we suddenly need to &n;&t;&t; * start using DMA bounce buffers */
r_if
c_cond
(paren
id|bhp
op_logical_and
id|CONTIGUOUS_BUFFERS
c_func
(paren
id|bh
comma
id|bhp
)paren
op_logical_and
id|CLUSTERABLE_DEVICE
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_char
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|sgpnt
(braket
id|count
)braket
dot
id|address
)paren
op_plus
id|sgpnt
(braket
id|count
)braket
dot
id|length
op_plus
id|bhp-&gt;b_size
op_minus
l_int|1
OG
id|ISA_DMA_THRESHOLD
op_logical_and
(paren
id|SCpnt-&gt;host-&gt;unchecked_isa_dma
)paren
op_logical_and
op_logical_neg
id|sgpnt
(braket
id|count
)braket
dot
id|alt_address
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sgpnt
(braket
id|count
)braket
dot
id|alt_address
)paren
(brace
id|count
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dma_free_sectors
OG
l_int|10
)paren
(brace
id|tmp
op_assign
(paren
r_char
op_star
)paren
id|scsi_malloc
c_func
(paren
id|sgpnt
(braket
id|count
)braket
dot
id|length
op_plus
id|bhp-&gt;b_size
)paren
suffix:semicolon
)brace
r_else
(brace
id|tmp
op_assign
l_int|NULL
suffix:semicolon
id|max_sg
op_assign
id|SCpnt-&gt;use_sg
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp
)paren
(brace
id|scsi_free
c_func
(paren
id|sgpnt
(braket
id|count
)braket
dot
id|address
comma
id|sgpnt
(braket
id|count
)braket
dot
id|length
)paren
suffix:semicolon
id|sgpnt
(braket
id|count
)braket
dot
id|address
op_assign
id|tmp
suffix:semicolon
id|count
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* If we are allowed another sg chain, then increment &n;&t;&t;     * counter so we can insert it.  Otherwise we will end &n;&t;&t;     up truncating */
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
OL
id|max_sg
)paren
id|SCpnt-&gt;use_sg
op_increment
suffix:semicolon
)brace
multiline_comment|/* contiguous buffers */
)brace
multiline_comment|/* for loop */
multiline_comment|/* This is actually how many we are going to transfer */
id|this_count
op_assign
id|counted
suffix:semicolon
r_if
c_cond
(paren
id|count
template_param
id|SCpnt-&gt;host-&gt;sg_tablesize
)paren
(brace
id|bh
op_assign
id|SCpnt-&gt;request.bh
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Use sg, count %d %x %d&bslash;n&quot;
comma
id|SCpnt-&gt;use_sg
comma
id|count
comma
id|dma_free_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;maxsg = %x, counted = %d this_count = %d&bslash;n&quot;
comma
id|max_sg
comma
id|counted
comma
id|this_count
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bh
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;[%p %lx] &quot;
comma
id|bh-&gt;b_data
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
OL
l_int|16
)paren
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|count
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;{%d:%p %p %d}  &quot;
comma
id|count
comma
id|sgpnt
(braket
id|count
)braket
dot
id|address
comma
id|sgpnt
(braket
id|count
)braket
dot
id|alt_address
comma
id|sgpnt
(braket
id|count
)braket
dot
id|length
)paren
suffix:semicolon
)brace
id|panic
c_func
(paren
l_string|&quot;Ooops&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;request.cmd
op_eq
id|WRITE
)paren
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|count
op_increment
)paren
r_if
c_cond
(paren
id|sgpnt
(braket
id|count
)braket
dot
id|alt_address
)paren
(brace
id|memcpy
c_func
(paren
id|sgpnt
(braket
id|count
)braket
dot
id|address
comma
id|sgpnt
(braket
id|count
)braket
dot
id|alt_address
comma
id|sgpnt
(braket
id|count
)braket
dot
id|length
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Able to malloc sgpnt */
)brace
multiline_comment|/* Host adapter capable of scatter-gather */
multiline_comment|/* Now handle the possibility of DMA to addresses &gt; 16Mb */
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|buff
)paren
op_plus
(paren
id|this_count
op_lshift
l_int|9
)paren
op_minus
l_int|1
OG
id|ISA_DMA_THRESHOLD
op_logical_and
(paren
id|SCpnt-&gt;host-&gt;unchecked_isa_dma
)paren
)paren
(brace
r_if
c_cond
(paren
id|bounce_buffer
)paren
(brace
id|buff
op_assign
id|bounce_buffer
suffix:semicolon
)brace
r_else
id|buff
op_assign
(paren
r_char
op_star
)paren
id|scsi_malloc
c_func
(paren
id|this_count
op_lshift
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Try backing off a bit if we are low on mem*/
id|this_count
op_assign
id|SCpnt-&gt;request.current_nr_sectors
suffix:semicolon
id|buff
op_assign
(paren
r_char
op_star
)paren
id|scsi_malloc
c_func
(paren
id|this_count
op_lshift
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buff
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Ran out of DMA buffers.&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;request.cmd
op_eq
id|WRITE
)paren
id|memcpy
c_func
(paren
id|buff
comma
(paren
r_char
op_star
)paren
id|SCpnt-&gt;request.buffer
comma
id|this_count
op_lshift
l_int|9
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sd%c : %s %d/%d 512 byte blocks.&bslash;n&quot;
comma
l_char|&squot;a&squot;
op_plus
id|devm
comma
(paren
id|SCpnt-&gt;request.cmd
op_eq
id|WRITE
)paren
ques
c_cond
l_string|&quot;writing&quot;
suffix:colon
l_string|&quot;reading&quot;
comma
id|this_count
comma
id|SCpnt-&gt;request.nr_sectors
)paren
suffix:semicolon
macro_line|#endif
id|cmd
(braket
l_int|1
)braket
op_assign
(paren
id|SCpnt-&gt;lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|dev
)braket
dot
id|sector_size
op_eq
l_int|1024
)paren
(brace
r_if
c_cond
(paren
id|block
op_amp
l_int|1
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;sd.c:Bad block number requested&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|this_count
op_amp
l_int|1
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;sd.c:Bad block number requested&quot;
)paren
suffix:semicolon
)brace
id|block
op_assign
id|block
op_rshift
l_int|1
suffix:semicolon
id|this_count
op_assign
id|this_count
op_rshift
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|dev
)braket
dot
id|sector_size
op_eq
l_int|256
)paren
(brace
id|block
op_assign
id|block
op_lshift
l_int|1
suffix:semicolon
id|this_count
op_assign
id|this_count
op_lshift
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|this_count
OG
l_int|0xff
)paren
op_logical_or
(paren
id|block
OG
l_int|0x1fffff
)paren
)paren
op_logical_and
id|rscsi_disks
(braket
id|dev
)braket
dot
id|ten
)paren
(brace
r_if
c_cond
(paren
id|this_count
OG
l_int|0xffff
)paren
id|this_count
op_assign
l_int|0xffff
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_add_assign
id|READ_10
op_minus
id|READ_6
suffix:semicolon
id|cmd
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|block
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|3
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|block
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|4
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|block
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|5
)braket
op_assign
(paren
r_int
r_char
)paren
id|block
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|6
)braket
op_assign
id|cmd
(braket
l_int|9
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd
(braket
l_int|7
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|this_count
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|8
)braket
op_assign
(paren
r_int
r_char
)paren
id|this_count
op_amp
l_int|0xff
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|this_count
OG
l_int|0xff
)paren
id|this_count
op_assign
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_or_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|block
op_rshift
l_int|16
)paren
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|cmd
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|block
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|cmd
(braket
l_int|3
)braket
op_assign
(paren
r_int
r_char
)paren
id|block
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|4
)braket
op_assign
(paren
r_int
r_char
)paren
id|this_count
suffix:semicolon
id|cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * We shouldn&squot;t disconnect in the middle of a sector, so with a dumb &n;     * host adapter, it&squot;s safe to assume that we can at least transfer &n;     * this many bytes between each connect / disconnect.  &n;     */
id|SCpnt-&gt;transfersize
op_assign
id|rscsi_disks
(braket
id|dev
)braket
dot
id|sector_size
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
id|this_count
op_lshift
l_int|9
suffix:semicolon
id|scsi_do_cmd
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|cmd
comma
id|buff
comma
id|this_count
op_star
id|rscsi_disks
(braket
id|dev
)braket
dot
id|sector_size
comma
id|rw_intr
comma
(paren
id|SCpnt-&gt;device-&gt;type
op_eq
id|TYPE_DISK
ques
c_cond
id|SD_TIMEOUT
suffix:colon
id|SD_MOD_TIMEOUT
)paren
comma
id|MAX_RETRIES
)paren
suffix:semicolon
)brace
DECL|function|check_scsidisk_media_change
r_static
r_int
(def_block
id|check_scsidisk_media_change
c_func
(paren
id|kdev_t
id|full_dev
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
id|target
suffix:semicolon
r_struct
id|inode
id|inode
suffix:semicolon
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
id|target
op_assign
id|DEVICE_NR
c_func
(paren
id|full_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
op_ge
id|sd_template.dev_max
op_logical_or
op_logical_neg
id|rscsi_disks
(braket
id|target
)braket
dot
id|device
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI disk request error: invalid device.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;removable
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|inode.i_rdev
op_assign
id|full_dev
suffix:semicolon
multiline_comment|/* This is all we really need here */
id|retval
op_assign
id|sd_ioctl
c_func
(paren
op_amp
id|inode
comma
l_int|NULL
comma
id|SCSI_IOCTL_TEST_UNIT_READY
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
multiline_comment|/* Unable to test, unit probably not ready.  This usually&n;&t;&t; * means there is no disc in the drive.  Mark as changed,&n;&t;&t; * and we will figure it out later once the drive is&n;&t;&t; * available again.  */
id|rscsi_disks
(braket
id|target
)braket
dot
id|ready
op_assign
l_int|0
suffix:semicolon
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;changed
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* This will force a flush, if called from&n;&t;&t;   * check_disk_change */
)brace
multiline_comment|/* &n;     * for removable scsi disk ( FLOPTICAL ) we have to recognise the&n;     * presence of disk in the drive. This is kept in the Scsi_Disk&n;     * struct and tested at open !  Daniel Roche ( dan@lectra.fr ) &n;     */
id|rscsi_disks
(braket
id|target
)braket
dot
id|ready
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* FLOPTICAL */
id|retval
op_assign
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;changed
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;changed
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
)def_block
DECL|function|sd_init_done
r_static
r_void
id|sd_init_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
id|req
op_assign
op_amp
id|SCpnt-&gt;request
suffix:semicolon
id|req-&gt;rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
multiline_comment|/* Busy, but indicate request done */
r_if
c_cond
(paren
id|req-&gt;sem
op_ne
l_int|NULL
)paren
(brace
id|up
c_func
(paren
id|req-&gt;sem
)paren
suffix:semicolon
)brace
)brace
DECL|function|sd_init_onedisk
r_static
r_int
id|sd_init_onedisk
c_func
(paren
r_int
id|i
)paren
(brace
r_int
r_char
id|cmd
(braket
l_int|10
)braket
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
r_int
r_int
id|spintime
suffix:semicolon
r_int
id|the_result
comma
id|retries
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
multiline_comment|/* We need to retry the READ_CAPACITY because a UNIT_ATTENTION is &n;     * considered a fatal error, and many devices report such an error &n;     * just after a scsi bus reset. &n;     */
id|SCpnt
op_assign
id|allocate_device
c_func
(paren
l_int|NULL
comma
id|rscsi_disks
(braket
id|i
)braket
dot
id|device
comma
l_int|1
)paren
suffix:semicolon
id|buffer
op_assign
(paren
r_int
r_char
op_star
)paren
id|scsi_malloc
c_func
(paren
l_int|512
)paren
suffix:semicolon
id|spintime
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Spin up drives, as required.  Only do this at boot time */
r_if
c_cond
(paren
op_logical_neg
id|MODULE_FLAG
)paren
(brace
r_do
(brace
id|retries
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|retries
OL
l_int|3
)paren
(brace
id|cmd
(braket
l_int|0
)braket
op_assign
id|TEST_UNIT_READY
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
(paren
id|rscsi_disks
(braket
id|i
)braket
dot
id|device-&gt;lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|memset
(paren
(paren
r_void
op_star
)paren
op_amp
id|cmd
(braket
l_int|2
)braket
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
(brace
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
multiline_comment|/* Mark as really busy again */
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
op_amp
id|sem
suffix:semicolon
id|scsi_do_cmd
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|buffer
comma
l_int|512
comma
id|sd_init_done
comma
id|SD_TIMEOUT
comma
id|MAX_RETRIES
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
)brace
id|the_result
op_assign
id|SCpnt-&gt;result
suffix:semicolon
id|retries
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|the_result
op_eq
l_int|0
op_logical_or
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_ne
id|UNIT_ATTENTION
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Look for non-removable devices that return NOT_READY.  &n;&t;     * Issue command to spin up drive for these cases. */
r_if
c_cond
(paren
id|the_result
op_logical_and
op_logical_neg
id|rscsi_disks
(braket
id|i
)braket
dot
id|device-&gt;removable
op_logical_and
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_eq
id|NOT_READY
)paren
(brace
r_int
id|time1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spintime
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sd%c: Spinning up disk...&quot;
comma
l_char|&squot;a&squot;
op_plus
id|i
)paren
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|START_STOP
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
(paren
id|rscsi_disks
(braket
id|i
)braket
dot
id|device-&gt;lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_or_assign
l_int|1
suffix:semicolon
multiline_comment|/* Return immediately */
id|memset
(paren
(paren
r_void
op_star
)paren
op_amp
id|cmd
(braket
l_int|2
)braket
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
id|cmd
(braket
l_int|4
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Start spin cycle */
id|SCpnt-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
(brace
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
multiline_comment|/* Mark as really busy again */
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
op_amp
id|sem
suffix:semicolon
id|scsi_do_cmd
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|buffer
comma
l_int|512
comma
id|sd_init_done
comma
id|SD_TIMEOUT
comma
id|MAX_RETRIES
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
)brace
id|spintime
op_assign
id|jiffies
suffix:semicolon
)brace
id|time1
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|time1
op_plus
id|HZ
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Wait 1 second for next try */
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|the_result
op_logical_and
id|spintime
op_logical_and
id|spintime
op_plus
l_int|100
op_star
id|HZ
OG
id|jiffies
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|spintime
)paren
(brace
r_if
c_cond
(paren
id|the_result
)paren
id|printk
c_func
(paren
l_string|&quot;not responding...&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;ready&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* !MODULE_FLAG */
id|retries
op_assign
l_int|3
suffix:semicolon
r_do
(brace
id|cmd
(braket
l_int|0
)braket
op_assign
id|READ_CAPACITY
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
(paren
id|rscsi_disks
(braket
id|i
)braket
dot
id|device-&gt;lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|memset
(paren
(paren
r_void
op_star
)paren
op_amp
id|cmd
(braket
l_int|2
)braket
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
id|memset
(paren
(paren
r_void
op_star
)paren
id|buffer
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
(brace
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
multiline_comment|/* Mark as really busy again */
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|SCpnt-&gt;request.sem
op_assign
op_amp
id|sem
suffix:semicolon
id|scsi_do_cmd
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|buffer
comma
l_int|8
comma
id|sd_init_done
comma
id|SD_TIMEOUT
comma
id|MAX_RETRIES
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
multiline_comment|/* sleep until it is ready */
)brace
id|the_result
op_assign
id|SCpnt-&gt;result
suffix:semicolon
id|retries
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|the_result
op_logical_and
id|retries
)paren
(brace
suffix:semicolon
)brace
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
multiline_comment|/* Mark as not busy */
id|wake_up
c_func
(paren
op_amp
id|SCpnt-&gt;device-&gt;device_wait
)paren
suffix:semicolon
multiline_comment|/* Wake up a process waiting for device */
multiline_comment|/*&n;     * The SCSI standard says: &n;     * &quot;READ CAPACITY is necessary for self configuring software&quot;&n;     *  While not mandatory, support of READ CAPACITY is strongly encouraged.&n;     *  We used to die if we couldn&squot;t successfully do a READ CAPACITY.&n;     *  But, now we go on about our way.  The side effects of this are&n;     *&n;     *  1. We can&squot;t know block size with certainty. I have said &quot;512 bytes &n;     *     is it&quot; as this is most common.&n;     *&n;     *  2. Recovery from when some one attempts to read past the end of the &n;     *     raw device will be slower.&n;     */
r_if
c_cond
(paren
id|the_result
)paren
(brace
id|printk
(paren
l_string|&quot;sd%c : READ CAPACITY failed.&bslash;n&quot;
l_string|&quot;sd%c : status = %x, message = %02x, host = %d, driver = %02x &bslash;n&quot;
comma
l_char|&squot;a&squot;
op_plus
id|i
comma
l_char|&squot;a&squot;
op_plus
id|i
comma
id|status_byte
c_func
(paren
id|the_result
)paren
comma
id|msg_byte
c_func
(paren
id|the_result
)paren
comma
id|host_byte
c_func
(paren
id|the_result
)paren
comma
id|driver_byte
c_func
(paren
id|the_result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_byte
c_func
(paren
id|the_result
)paren
op_amp
id|DRIVER_SENSE
)paren
id|printk
c_func
(paren
l_string|&quot;sd%c : extended sense code = %1x &bslash;n&quot;
comma
l_char|&squot;a&squot;
op_plus
id|i
comma
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;sd%c : sense not available. &bslash;n&quot;
comma
l_char|&squot;a&squot;
op_plus
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sd%c : block size assumed to be 512 bytes, disk size 1GB.  &bslash;n&quot;
comma
l_char|&squot;a&squot;
op_plus
id|i
)paren
suffix:semicolon
id|rscsi_disks
(braket
id|i
)braket
dot
id|capacity
op_assign
l_int|0x1fffff
suffix:semicolon
id|rscsi_disks
(braket
id|i
)braket
dot
id|sector_size
op_assign
l_int|512
suffix:semicolon
multiline_comment|/* Set dirty bit for removable devices if not ready - sometimes drives&n;&t; * will not report this properly. */
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|i
)braket
dot
id|device-&gt;removable
op_logical_and
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_eq
id|NOT_READY
)paren
(brace
id|rscsi_disks
(braket
id|i
)braket
dot
id|device-&gt;changed
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t; * FLOPTICAL , if read_capa is ok , drive is assumed to be ready &n;&t; */
id|rscsi_disks
(braket
id|i
)braket
dot
id|ready
op_assign
l_int|1
suffix:semicolon
id|rscsi_disks
(braket
id|i
)braket
dot
id|capacity
op_assign
l_int|1
op_plus
(paren
(paren
id|buffer
(braket
l_int|0
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buffer
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buffer
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
id|buffer
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|rscsi_disks
(braket
id|i
)braket
dot
id|sector_size
op_assign
(paren
id|buffer
(braket
l_int|4
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buffer
(braket
l_int|5
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buffer
(braket
l_int|6
)braket
op_lshift
l_int|8
)paren
op_or
id|buffer
(braket
l_int|7
)braket
suffix:semicolon
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|i
)braket
dot
id|sector_size
op_eq
l_int|0
)paren
(brace
id|rscsi_disks
(braket
id|i
)braket
dot
id|sector_size
op_assign
l_int|512
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sd%c : sector size 0 reported, assuming 512.&bslash;n&quot;
comma
l_char|&squot;a&squot;
op_plus
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|i
)braket
dot
id|sector_size
op_ne
l_int|512
op_logical_and
id|rscsi_disks
(braket
id|i
)braket
dot
id|sector_size
op_ne
l_int|1024
op_logical_and
id|rscsi_disks
(braket
id|i
)braket
dot
id|sector_size
op_ne
l_int|256
)paren
(brace
id|printk
(paren
l_string|&quot;sd%c : unsupported sector size %d.&bslash;n&quot;
comma
l_char|&squot;a&squot;
op_plus
id|i
comma
id|rscsi_disks
(braket
id|i
)braket
dot
id|sector_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|i
)braket
dot
id|device-&gt;removable
)paren
(brace
id|rscsi_disks
(braket
id|i
)braket
dot
id|capacity
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;scsi : deleting disk entry.&bslash;n&quot;
)paren
suffix:semicolon
id|rscsi_disks
(braket
id|i
)braket
dot
id|device
op_assign
l_int|NULL
suffix:semicolon
id|sd_template.nr_dev
op_decrement
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
)brace
(brace
multiline_comment|/*&n;&t; * The msdos fs needs to know the hardware sector size&n;&t; * So I have created this table. See ll_rw_blk.c&n;&t; * Jacques Gelinas (Jacques@solucorp.qc.ca)&n;&t; */
r_int
id|m
comma
id|mb
suffix:semicolon
r_int
id|sz_quot
comma
id|sz_rem
suffix:semicolon
r_int
id|hard_sector
op_assign
id|rscsi_disks
(braket
id|i
)braket
dot
id|sector_size
suffix:semicolon
multiline_comment|/* There are 16 minors allocated for each major device */
r_for
c_loop
(paren
id|m
op_assign
id|i
op_lshift
l_int|4
suffix:semicolon
id|m
OL
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_lshift
l_int|4
)paren
suffix:semicolon
id|m
op_increment
)paren
(brace
id|sd_hardsizes
(braket
id|m
)braket
op_assign
id|hard_sector
suffix:semicolon
)brace
id|mb
op_assign
id|rscsi_disks
(braket
id|i
)braket
dot
id|capacity
op_div
l_int|1024
op_star
id|hard_sector
op_div
l_int|1024
suffix:semicolon
multiline_comment|/* sz = div(m/100, 10);  this seems to not be in the libr */
id|m
op_assign
(paren
id|mb
op_plus
l_int|50
)paren
op_div
l_int|100
suffix:semicolon
id|sz_quot
op_assign
id|m
op_div
l_int|10
suffix:semicolon
id|sz_rem
op_assign
id|m
op_minus
(paren
l_int|10
op_star
id|sz_quot
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;SCSI device sd%c: hdwr sector= %d bytes.&quot;
l_string|&quot; Sectors= %d [%d MB] [%d.%1d GB]&bslash;n&quot;
comma
id|i
op_plus
l_char|&squot;a&squot;
comma
id|hard_sector
comma
id|rscsi_disks
(braket
id|i
)braket
dot
id|capacity
comma
id|mb
comma
id|sz_quot
comma
id|sz_rem
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|i
)braket
dot
id|sector_size
op_eq
l_int|1024
)paren
(brace
id|rscsi_disks
(braket
id|i
)braket
dot
id|capacity
op_lshift_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Change into 512 byte sectors */
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|i
)braket
dot
id|sector_size
op_eq
l_int|256
)paren
(brace
id|rscsi_disks
(braket
id|i
)braket
dot
id|capacity
op_rshift_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Change into 512 byte sectors */
)brace
multiline_comment|/*&n;     * Unless otherwise specified, this is not write protected.&n;     */
id|rscsi_disks
(braket
id|i
)braket
dot
id|write_prot
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|i
)braket
dot
id|device-&gt;removable
op_logical_and
id|rscsi_disks
(braket
id|i
)braket
dot
id|ready
)paren
(brace
multiline_comment|/* FLOPTICAL */
multiline_comment|/* &n;&t; *&t;for removable scsi disk ( FLOPTICAL ) we have to recognise  &n;&t; * the Write Protect Flag. This flag is kept in the Scsi_Disk struct&n;&t; * and tested at open !&n;&t; * Daniel Roche ( dan@lectra.fr )&n;&t; */
id|memset
(paren
(paren
r_void
op_star
)paren
op_amp
id|cmd
(braket
l_int|0
)braket
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
(paren
id|rscsi_disks
(braket
id|i
)braket
dot
id|device-&gt;lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|cmd
(braket
l_int|2
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* page code 1 ?? */
id|cmd
(braket
l_int|4
)braket
op_assign
l_int|12
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* same code as READCAPA !! */
(brace
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
multiline_comment|/* Mark as really busy again */
id|SCpnt-&gt;request.sem
op_assign
op_amp
id|sem
suffix:semicolon
id|scsi_do_cmd
(paren
id|SCpnt
comma
(paren
r_void
op_star
)paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|buffer
comma
l_int|512
comma
id|sd_init_done
comma
id|SD_TIMEOUT
comma
id|MAX_RETRIES
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
)brace
id|the_result
op_assign
id|SCpnt-&gt;result
suffix:semicolon
id|SCpnt-&gt;request.rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
multiline_comment|/* Mark as not busy */
id|wake_up
c_func
(paren
op_amp
id|SCpnt-&gt;device-&gt;device_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|the_result
)paren
(brace
id|printk
(paren
l_string|&quot;sd%c: test WP failed, assume Write Protected&bslash;n&quot;
comma
id|i
op_plus
l_char|&squot;a&squot;
)paren
suffix:semicolon
id|rscsi_disks
(braket
id|i
)braket
dot
id|write_prot
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|rscsi_disks
(braket
id|i
)braket
dot
id|write_prot
op_assign
(paren
(paren
id|buffer
(braket
l_int|2
)braket
op_amp
l_int|0x80
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;sd%c: Write Protect is %s&bslash;n&quot;
comma
id|i
op_plus
l_char|&squot;a&squot;
comma
id|rscsi_disks
(braket
id|i
)braket
dot
id|write_prot
ques
c_cond
l_string|&quot;on&quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* check for write protect */
id|rscsi_disks
(braket
id|i
)braket
dot
id|ten
op_assign
l_int|1
suffix:semicolon
id|rscsi_disks
(braket
id|i
)braket
dot
id|remap
op_assign
l_int|1
suffix:semicolon
id|scsi_free
c_func
(paren
id|buffer
comma
l_int|512
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * The sd_init() function looks at all SCSI drives present, determines&n; * their size, and reads partition table entries for them.&n; */
DECL|variable|sd_registered
r_static
r_int
id|sd_registered
op_assign
l_int|0
suffix:semicolon
DECL|function|sd_init
r_static
r_int
id|sd_init
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|sd_template.dev_noticed
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sd_registered
)paren
(brace
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;sd&quot;
comma
op_amp
id|sd_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to get major %d for SCSI disk&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|sd_registered
op_increment
suffix:semicolon
)brace
multiline_comment|/* We do not support attaching loadable devices yet. */
r_if
c_cond
(paren
id|rscsi_disks
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|sd_template.dev_max
op_assign
id|sd_template.dev_noticed
op_plus
id|SD_EXTRA_DEVS
suffix:semicolon
id|rscsi_disks
op_assign
(paren
id|Scsi_Disk
op_star
)paren
id|scsi_init_malloc
c_func
(paren
id|sd_template.dev_max
op_star
r_sizeof
(paren
id|Scsi_Disk
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|memset
c_func
(paren
id|rscsi_disks
comma
l_int|0
comma
id|sd_template.dev_max
op_star
r_sizeof
(paren
id|Scsi_Disk
)paren
)paren
suffix:semicolon
id|sd_sizes
op_assign
(paren
r_int
op_star
)paren
id|scsi_init_malloc
c_func
(paren
(paren
id|sd_template.dev_max
op_lshift
l_int|4
)paren
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|memset
c_func
(paren
id|sd_sizes
comma
l_int|0
comma
(paren
id|sd_template.dev_max
op_lshift
l_int|4
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|sd_blocksizes
op_assign
(paren
r_int
op_star
)paren
id|scsi_init_malloc
c_func
(paren
(paren
id|sd_template.dev_max
op_lshift
l_int|4
)paren
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|sd_hardsizes
op_assign
(paren
r_int
op_star
)paren
id|scsi_init_malloc
c_func
(paren
(paren
id|sd_template.dev_max
op_lshift
l_int|4
)paren
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|sd_template.dev_max
op_lshift
l_int|4
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sd_blocksizes
(braket
id|i
)braket
op_assign
l_int|1024
suffix:semicolon
id|sd_hardsizes
(braket
id|i
)braket
op_assign
l_int|512
suffix:semicolon
)brace
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|sd_blocksizes
suffix:semicolon
id|hardsect_size
(braket
id|MAJOR_NR
)braket
op_assign
id|sd_hardsizes
suffix:semicolon
id|sd
op_assign
(paren
r_struct
id|hd_struct
op_star
)paren
id|scsi_init_malloc
c_func
(paren
(paren
id|sd_template.dev_max
op_lshift
l_int|4
)paren
op_star
r_sizeof
(paren
r_struct
id|hd_struct
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|sd_gendisk.max_nr
op_assign
id|sd_template.dev_max
suffix:semicolon
id|sd_gendisk.part
op_assign
id|sd
suffix:semicolon
id|sd_gendisk.sizes
op_assign
id|sd_sizes
suffix:semicolon
id|sd_gendisk.real_devices
op_assign
(paren
r_void
op_star
)paren
id|rscsi_disks
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sd_finish
r_static
r_void
id|sd_finish
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|sd_gendisk.next
op_assign
id|gendisk_head
suffix:semicolon
id|gendisk_head
op_assign
op_amp
id|sd_gendisk
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sd_template.dev_max
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
op_logical_neg
id|rscsi_disks
(braket
id|i
)braket
dot
id|capacity
op_logical_and
id|rscsi_disks
(braket
id|i
)braket
dot
id|device
)paren
(brace
r_if
c_cond
(paren
id|MODULE_FLAG
op_logical_and
op_logical_neg
id|rscsi_disks
(braket
id|i
)braket
dot
id|has_part_table
)paren
(brace
id|sd_sizes
(braket
id|i
op_lshift
l_int|4
)braket
op_assign
id|rscsi_disks
(braket
id|i
)braket
dot
id|capacity
suffix:semicolon
multiline_comment|/* revalidate does sd_init_onedisk via MAYBE_REINIT*/
id|revalidate_scsidisk
c_func
(paren
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|i
op_lshift
l_int|4
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|i
op_assign
id|sd_init_onedisk
c_func
(paren
id|i
)paren
suffix:semicolon
id|rscsi_disks
(braket
id|i
)braket
dot
id|has_part_table
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If our host adapter is capable of scatter-gather, then we increase&n;     * the read-ahead to 16 blocks (32 sectors).  If not, we use&n;     * a two block (4 sector) read ahead. &n;     */
r_if
c_cond
(paren
id|rscsi_disks
(braket
l_int|0
)braket
dot
id|device
op_logical_and
id|rscsi_disks
(braket
l_int|0
)braket
dot
id|device-&gt;host-&gt;sg_tablesize
)paren
(brace
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|120
suffix:semicolon
)brace
multiline_comment|/* 120 sector read-ahead */
r_else
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* 4 sector read-ahead */
r_return
suffix:semicolon
)brace
DECL|function|sd_detect
r_static
r_int
(def_block
id|sd_detect
c_func
(paren
id|Scsi_Device
op_star
id|SDp
)paren
(brace
r_if
c_cond
(paren
id|SDp-&gt;type
op_ne
id|TYPE_DISK
op_logical_and
id|SDp-&gt;type
op_ne
id|TYPE_MOD
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Detected scsi disk sd%c at scsi%d, channel %d, id %d, lun %d&bslash;n&quot;
comma
l_char|&squot;a&squot;
op_plus
(paren
id|sd_template.dev_noticed
op_increment
)paren
comma
id|SDp-&gt;host-&gt;host_no
comma
id|SDp-&gt;channel
comma
id|SDp-&gt;id
comma
id|SDp-&gt;lun
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)def_block
DECL|function|sd_attach
r_static
r_int
(def_block
id|sd_attach
c_func
(paren
id|Scsi_Device
op_star
id|SDp
)paren
(brace
id|Scsi_Disk
op_star
id|dpnt
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|SDp-&gt;type
op_ne
id|TYPE_DISK
op_logical_and
id|SDp-&gt;type
op_ne
id|TYPE_MOD
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sd_template.nr_dev
op_ge
id|sd_template.dev_max
)paren
(brace
id|SDp-&gt;attached
op_decrement
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|dpnt
op_assign
id|rscsi_disks
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sd_template.dev_max
suffix:semicolon
id|i
op_increment
comma
id|dpnt
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|dpnt-&gt;device
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ge
id|sd_template.dev_max
)paren
(brace
id|panic
(paren
l_string|&quot;scsi_devices corrupt (sd)&quot;
)paren
suffix:semicolon
)brace
id|SDp-&gt;scsi_request_fn
op_assign
id|do_sd_request
suffix:semicolon
id|rscsi_disks
(braket
id|i
)braket
dot
id|device
op_assign
id|SDp
suffix:semicolon
id|rscsi_disks
(braket
id|i
)braket
dot
id|has_part_table
op_assign
l_int|0
suffix:semicolon
id|sd_template.nr_dev
op_increment
suffix:semicolon
id|sd_gendisk.nr_real
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)def_block
DECL|macro|DEVICE_BUSY
mdefine_line|#define DEVICE_BUSY rscsi_disks[target].device-&gt;busy
DECL|macro|USAGE
mdefine_line|#define USAGE rscsi_disks[target].device-&gt;access_count
DECL|macro|CAPACITY
mdefine_line|#define CAPACITY rscsi_disks[target].capacity
DECL|macro|MAYBE_REINIT
mdefine_line|#define MAYBE_REINIT  sd_init_onedisk(target)
DECL|macro|GENDISK_STRUCT
mdefine_line|#define GENDISK_STRUCT sd_gendisk
multiline_comment|/* This routine is called to flush all partitions and partition tables&n; * for a changed scsi disk, and then re-read the new partition table.&n; * If we are revalidating a disk because of a media change, then we&n; * enter with usage == 0.  If we are using an ioctl, we automatically have&n; * usage == 1 (we need an open channel to use an ioctl :-), so this&n; * is our limit.&n; */
DECL|function|revalidate_scsidisk
r_int
(def_block
id|revalidate_scsidisk
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|maxusage
)paren
(brace
r_int
id|target
suffix:semicolon
r_struct
id|gendisk
op_star
id|gdev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|max_p
suffix:semicolon
r_int
id|start
suffix:semicolon
r_int
id|i
suffix:semicolon
id|target
op_assign
id|DEVICE_NR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|gdev
op_assign
op_amp
id|GENDISK_STRUCT
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEVICE_BUSY
op_logical_or
id|USAGE
OG
id|maxusage
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Device busy for revalidation (usage=%d)&bslash;n&quot;
comma
id|USAGE
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|DEVICE_BUSY
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|max_p
op_assign
id|gdev-&gt;max_p
suffix:semicolon
id|start
op_assign
id|target
op_lshift
id|gdev-&gt;minor_shift
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|max_p
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|minor
op_assign
id|start
op_plus
id|i
suffix:semicolon
id|kdev_t
id|devi
op_assign
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|minor
)paren
suffix:semicolon
id|sync_dev
c_func
(paren
id|devi
)paren
suffix:semicolon
id|invalidate_inodes
c_func
(paren
id|devi
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|devi
)paren
suffix:semicolon
id|gdev-&gt;part
(braket
id|minor
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|gdev-&gt;part
(braket
id|minor
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;         * Reset the blocksize for everything so that we can read&n;         * the partition table.&n;         */
id|blksize_size
(braket
id|MAJOR_NR
)braket
(braket
id|minor
)braket
op_assign
l_int|1024
suffix:semicolon
)brace
macro_line|#ifdef MAYBE_REINIT
id|MAYBE_REINIT
suffix:semicolon
macro_line|#endif
id|gdev-&gt;part
(braket
id|start
)braket
dot
id|nr_sects
op_assign
id|CAPACITY
suffix:semicolon
id|resetup_one_dev
c_func
(paren
id|gdev
comma
id|target
)paren
suffix:semicolon
id|DEVICE_BUSY
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)def_block
DECL|function|fop_revalidate_scsidisk
r_static
r_int
(def_block
id|fop_revalidate_scsidisk
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_return
id|revalidate_scsidisk
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
)def_block
DECL|function|sd_detach
r_static
r_void
id|sd_detach
c_func
(paren
id|Scsi_Device
op_star
id|SDp
)paren
(brace
id|Scsi_Disk
op_star
id|dpnt
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|max_p
suffix:semicolon
r_int
id|start
suffix:semicolon
r_for
c_loop
(paren
id|dpnt
op_assign
id|rscsi_disks
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sd_template.dev_max
suffix:semicolon
id|i
op_increment
comma
id|dpnt
op_increment
)paren
r_if
c_cond
(paren
id|dpnt-&gt;device
op_eq
id|SDp
)paren
(brace
multiline_comment|/* If we are disconnecting a disk driver, sync and invalidate &n;&t;     * everything */
id|max_p
op_assign
id|sd_gendisk.max_p
suffix:semicolon
id|start
op_assign
id|i
op_lshift
id|sd_gendisk.minor_shift
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|max_p
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|minor
op_assign
id|start
op_plus
id|i
suffix:semicolon
id|kdev_t
id|devi
op_assign
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|minor
)paren
suffix:semicolon
id|sync_dev
c_func
(paren
id|devi
)paren
suffix:semicolon
id|invalidate_inodes
c_func
(paren
id|devi
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|devi
)paren
suffix:semicolon
id|sd_gendisk.part
(braket
id|minor
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|sd_gendisk.part
(braket
id|minor
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
id|sd_sizes
(braket
id|minor
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|dpnt-&gt;has_part_table
op_assign
l_int|0
suffix:semicolon
id|dpnt-&gt;device
op_assign
l_int|NULL
suffix:semicolon
id|dpnt-&gt;capacity
op_assign
l_int|0
suffix:semicolon
id|SDp-&gt;attached
op_decrement
suffix:semicolon
id|sd_template.dev_noticed
op_decrement
suffix:semicolon
id|sd_template.nr_dev
op_decrement
suffix:semicolon
id|sd_gendisk.nr_real
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
id|sd_template.usage_count
op_assign
op_amp
id|mod_use_count_
suffix:semicolon
r_return
id|scsi_register_module
c_func
(paren
id|MODULE_SCSI_DEV
comma
op_amp
id|sd_template
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|gendisk
op_star
id|prev_sdgd
suffix:semicolon
r_struct
id|gendisk
op_star
id|sdgd
suffix:semicolon
id|scsi_unregister_module
c_func
(paren
id|MODULE_SCSI_DEV
comma
op_amp
id|sd_template
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|SCSI_DISK_MAJOR
comma
l_string|&quot;sd&quot;
)paren
suffix:semicolon
id|sd_registered
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|rscsi_disks
op_ne
l_int|NULL
)paren
(brace
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|rscsi_disks
comma
(paren
id|sd_template.dev_noticed
op_plus
id|SD_EXTRA_DEVS
)paren
op_star
r_sizeof
(paren
id|Scsi_Disk
)paren
)paren
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|sd_sizes
comma
id|sd_template.dev_max
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|sd_blocksizes
comma
id|sd_template.dev_max
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|sd_hardsizes
comma
id|sd_template.dev_max
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|scsi_init_free
c_func
(paren
(paren
r_char
op_star
)paren
id|sd
comma
(paren
id|sd_template.dev_max
op_lshift
l_int|4
)paren
op_star
r_sizeof
(paren
r_struct
id|hd_struct
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now remove sd_gendisk from the linked list&n;&t; */
id|sdgd
op_assign
id|gendisk_head
suffix:semicolon
id|prev_sdgd
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|sdgd
op_ne
op_amp
id|sd_gendisk
)paren
(brace
id|prev_sdgd
op_assign
id|sdgd
suffix:semicolon
id|sdgd
op_assign
id|sdgd-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sdgd
op_ne
op_amp
id|sd_gendisk
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sd_gendisk not in disk chain.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|prev_sdgd
op_ne
l_int|NULL
)paren
(brace
id|prev_sdgd-&gt;next
op_assign
id|sdgd-&gt;next
suffix:semicolon
)brace
r_else
id|gendisk_head
op_assign
id|sdgd-&gt;next
suffix:semicolon
)brace
)brace
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
l_int|NULL
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
l_int|NULL
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
l_int|NULL
suffix:semicolon
id|hardsect_size
(braket
id|MAJOR_NR
)braket
op_assign
l_int|NULL
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|0
suffix:semicolon
id|sd_template.dev_max
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
multiline_comment|/*&n; * Overrides for Emacs so that we almost follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: nil&n; * tab-width: 8&n; * End:&n; */
eof
