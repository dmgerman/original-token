multiline_comment|/* &n; * NCR 5380 generic driver routines.  These should make it *trivial*&n; * &t;to implement 5380 SCSI drivers under Linux with a non-trantor&n; *&t;architecture.&n; *&n; *&t;Note that these routines also work with NR53c400 family chips.&n; *&n; * Copyright 1993, Drew Eckhardt&n; *&t;Visionary Computing &n; *&t;(Unix and Linux consulting and custom programming)&n; * &t;drew@colorado.edu&n; *&t;+1 (303) 666-5836&n; *&n; * DISTRIBUTION RELEASE 6. &n; *&n; * For more information, please consult &n; *&n; * NCR 5380 Family&n; * SCSI Protocol Controller&n; * Databook&n; *&n; * NCR Microelectronics&n; * 1635 Aeroplaza Drive&n; * Colorado Springs, CO 80916&n; * 1+ (719) 578-3400&n; * 1+ (800) 334-5454&n; */
multiline_comment|/*&n; * ++roman: To port the 5380 driver to the Atari, I had to do some changes in&n; * this file, too:&n; *&n; *  - Some of the debug statements were incorrect (undefined variables and the&n; *    like). I fixed that.&n; *&n; *  - In information_transfer(), I think a #ifdef was wrong. Looking at the&n; *    possible DMA transfer size should also happen for REAL_DMA. I added this&n; *    in the #if statement.&n; *&n; *  - When using real DMA, information_transfer() should return in a DATAOUT&n; *    phase after starting the DMA. It has nothing more to do.&n; *&n; *  - The interrupt service routine should run main after end of DMA, too (not&n; *    only after RESELECTION interrupts). Additionally, it should _not_ test&n; *    for more interrupts after running main, since a DMA process may have&n; *    been started and interrupts are turned on now. The new int could happen&n; *    inside the execution of NCR5380_intr(), leading to recursive&n; *    calls.&n; *&n; *  - I&squot;ve added a function merge_contiguous_buffers() that tries to&n; *    merge scatter-gather buffers that are located at contiguous&n; *    physical addresses and can be processed with the same DMA setup.&n; *    Since most scatter-gather operations work on a page (4K) of&n; *    4 buffers (1K), in more than 90% of all cases three interrupts and&n; *    DMA setup actions are saved.&n; *&n; * - I&squot;ve deleted all the stuff for AUTOPROBE_IRQ, REAL_DMA_POLL, PSEUDO_DMA&n; *    and USLEEP, because these were messing up readability and will never be&n; *    needed for Atari SCSI.&n; * &n; * - I&squot;ve revised the NCR5380_main() calling scheme (relax the &squot;main_running&squot;&n; *   stuff), and &squot;main&squot; is executed in a bottom half if awoken by an&n; *   interrupt.&n; *&n; * - The code was quite cluttered up by &quot;#if (NDEBUG &amp; NDEBUG_*) printk...&quot;&n; *   constructs. In my eyes, this made the source rather unreadable, so I&n; *   finally replaced that by the *_PRINTK() macros.&n; *&n; */
multiline_comment|/*&n; * Further development / testing that should be done : &n; * 1.  Test linked command handling code after Eric is ready with &n; *     the high level code.&n; */
macro_line|#if (NDEBUG &amp; NDEBUG_LISTS)
DECL|macro|LIST
mdefine_line|#define LIST(x,y) &bslash;&n;  { printk(&quot;LINE:%d   Adding %p to %p&bslash;n&quot;, __LINE__, (void*)(x), (void*)(y)); &bslash;&n;    if ((x)==(y)) udelay(5); }
DECL|macro|REMOVE
mdefine_line|#define REMOVE(w,x,y,z) &bslash;&n;  { printk(&quot;LINE:%d   Removing: %p-&gt;%p  %p-&gt;%p &bslash;n&quot;, __LINE__, &bslash;&n;&t;   (void*)(w), (void*)(x), (void*)(y), (void*)(z)); &bslash;&n;    if ((x)==(y)) udelay(5); }
macro_line|#else
DECL|macro|LIST
mdefine_line|#define LIST(x,y)
DECL|macro|REMOVE
mdefine_line|#define REMOVE(w,x,y,z)
macro_line|#endif
macro_line|#ifndef notyet
DECL|macro|LINKED
macro_line|#undef LINKED
macro_line|#endif
multiline_comment|/*&n; * Design&n; * Issues :&n; *&n; * The other Linux SCSI drivers were written when Linux was Intel PC-only,&n; * and specifically for each board rather than each chip.  This makes their&n; * adaptation to platforms like the Mac (Some of which use NCR5380&squot;s)&n; * more difficult than it has to be.&n; *&n; * Also, many of the SCSI drivers were written before the command queuing&n; * routines were implemented, meaning their implementations of queued &n; * commands were hacked on rather than designed in from the start.&n; *&n; * When I designed the Linux SCSI drivers I figured that &n; * while having two different SCSI boards in a system might be useful&n; * for debugging things, two of the same type wouldn&squot;t be used.&n; * Well, I was wrong and a number of users have mailed me about running&n; * multiple high-performance SCSI boards in a server.&n; *&n; * Finally, when I get questions from users, I have no idea what &n; * revision of my driver they are running.&n; *&n; * This driver attempts to address these problems :&n; * This is a generic 5380 driver.  To use it on a different platform, &n; * one simply writes appropriate system specific macros (ie, data&n; * transfer - some PC&squot;s will use the I/O bus, 68K&squot;s must use &n; * memory mapped) and drops this file in their &squot;C&squot; wrapper.&n; *&n; * As far as command queueing, two queues are maintained for &n; * each 5380 in the system - commands that haven&squot;t been issued yet,&n; * and commands that are currently executing.  This means that an &n; * unlimited number of commands may be queued, letting &n; * more commands propagate from the higher driver levels giving higher &n; * throughput.  Note that both I_T_L and I_T_L_Q nexuses are supported, &n; * allowing multiple commands to propagate all the way to a SCSI-II device &n; * while a command is already executing.&n; *&n; * To solve the multiple-boards-in-the-same-system problem, &n; * there is a separate instance structure for each instance&n; * of a 5380 in the system.  So, multiple NCR5380 drivers will&n; * be able to coexist with appropriate changes to the high level&n; * SCSI code.  &n; *&n; * A NCR5380_PUBLIC_REVISION macro is provided, with the release&n; * number (updated for each public release) printed by the &n; * NCR5380_print_options command, which should be called from the &n; * wrapper detect function, so that I know what release of the driver&n; * users are using.&n; *&n; * Issues specific to the NCR5380 : &n; *&n; * When used in a PIO or pseudo-dma mode, the NCR5380 is a braindead &n; * piece of hardware that requires you to sit in a loop polling for &n; * the REQ signal as long as you are connected.  Some devices are &n; * brain dead (ie, many TEXEL CD ROM drives) and won&squot;t disconnect &n; * while doing long seek operations.&n; * &n; * The workaround for this is to keep track of devices that have&n; * disconnected.  If the device hasn&squot;t disconnected, for commands that&n; * should disconnect, we do something like &n; *&n; * while (!REQ is asserted) { sleep for N usecs; poll for M usecs }&n; * &n; * Some tweaking of N and M needs to be done.  An algorithm based &n; * on &quot;time to data&quot; would give the best results as long as short time&n; * to datas (ie, on the same track) were considered, however these &n; * broken devices are the exception rather than the rule and I&squot;d rather&n; * spend my time optimizing for the normal case.&n; *&n; * Architecture :&n; *&n; * At the heart of the design is a coroutine, NCR5380_main,&n; * which is started when not running by the interrupt handler,&n; * timer, and queue command function.  It attempts to establish&n; * I_T_L or I_T_L_Q nexuses by removing the commands from the &n; * issue queue and calling NCR5380_select() if a nexus &n; * is not established. &n; *&n; * Once a nexus is established, the NCR5380_information_transfer()&n; * phase goes through the various phases as instructed by the target.&n; * if the target goes into MSG IN and sends a DISCONNECT message,&n; * the command structure is placed into the per instance disconnected&n; * queue, and NCR5380_main tries to find more work.  If USLEEP&n; * was defined, and the target is idle for too long, the system&n; * will try to sleep.&n; *&n; * If a command has disconnected, eventually an interrupt will trigger,&n; * calling NCR5380_intr()  which will in turn call NCR5380_reselect&n; * to reestablish a nexus.  This will run main if necessary.&n; *&n; * On command termination, the done function will be called as &n; * appropriate.&n; *&n; * SCSI pointers are maintained in the SCp field of SCSI command &n; * structures, being initialized after the command is connected&n; * in NCR5380_select, and set as appropriate in NCR5380_information_transfer.&n; * Note that in violation of the standard, an implicit SAVE POINTERS operation&n; * is done, since some BROKEN disks fail to issue an explicit SAVE POINTERS.&n; */
multiline_comment|/*&n; * Using this file :&n; * This file a skeleton Linux SCSI driver for the NCR 5380 series&n; * of chips.  To use it, you write an architecture specific functions &n; * and macros and include this file in your driver.&n; *&n; * These macros control options : &n; * AUTOSENSE - if defined, REQUEST SENSE will be performed automatically&n; *&t;for commands that return with a CHECK CONDITION status. &n; *&n; * LINKED - if defined, linked commands are supported.&n; *&n; * REAL_DMA - if defined, REAL DMA is used during the data transfer phases.&n; *&n; * SUPPORT_TAGS - if defined, SCSI-2 tagged queuing is used where possible&n; *&n; * These macros MUST be defined :&n; * &n; * NCR5380_read(register)  - read from the specified register&n; *&n; * NCR5380_write(register, value) - write to the specific register &n; *&n; * Either real DMA *or* pseudo DMA may be implemented&n; * REAL functions : &n; * NCR5380_REAL_DMA should be defined if real DMA is to be used.&n; * Note that the DMA setup functions should return the number of bytes &n; *&t;that they were able to program the controller for.&n; *&n; * Also note that generic i386/PC versions of these macros are &n; *&t;available as NCR5380_i386_dma_write_setup,&n; *&t;NCR5380_i386_dma_read_setup, and NCR5380_i386_dma_residual.&n; *&n; * NCR5380_dma_write_setup(instance, src, count) - initialize&n; * NCR5380_dma_read_setup(instance, dst, count) - initialize&n; * NCR5380_dma_residual(instance); - residual count&n; *&n; * PSEUDO functions :&n; * NCR5380_pwrite(instance, src, count)&n; * NCR5380_pread(instance, dst, count);&n; *&n; * If nothing specific to this implementation needs doing (ie, with external&n; * hardware), you must also define &n; *  &n; * NCR5380_queue_command&n; * NCR5380_reset&n; * NCR5380_abort&n; * NCR5380_proc_info&n; *&n; * to be the global entry points into the specific driver, ie &n; * #define NCR5380_queue_command t128_queue_command.&n; *&n; * If this is not done, the routines will be defined as static functions&n; * with the NCR5380* names and the user must provide a globally&n; * accessible wrapper function.&n; *&n; * The generic driver is initialized by calling NCR5380_init(instance),&n; * after setting the appropriate host specific fields and ID.  If the &n; * driver wishes to autoprobe for an IRQ line, the NCR5380_probe_irq(instance,&n; * possible) function may be used.  Before the specific driver initialization&n; * code finishes, NCR5380_print_options should be called.&n; */
DECL|variable|first_instance
r_static
r_struct
id|Scsi_Host
op_star
id|first_instance
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|the_template
r_static
id|Scsi_Host_Template
op_star
id|the_template
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Macros ease life... :-) */
DECL|macro|SETUP_HOSTDATA
mdefine_line|#define&t;SETUP_HOSTDATA(in)&t;&t;&t;&t;&bslash;&n;    struct NCR5380_hostdata *hostdata =&t;&t;&t;&bslash;&n;&t;(struct NCR5380_hostdata *)(in)-&gt;hostdata
DECL|macro|HOSTDATA
mdefine_line|#define&t;HOSTDATA(in) ((struct NCR5380_hostdata *)(in)-&gt;hostdata)
DECL|macro|NEXT
mdefine_line|#define&t;NEXT(cmd)&t;((Scsi_Cmnd *)((cmd)-&gt;host_scribble))
DECL|macro|NEXTADDR
mdefine_line|#define&t;NEXTADDR(cmd)&t;((Scsi_Cmnd **)&amp;((cmd)-&gt;host_scribble))
DECL|macro|HOSTNO
mdefine_line|#define&t;HOSTNO&t;&t;instance-&gt;host_no
DECL|macro|H_NO
mdefine_line|#define&t;H_NO(cmd)&t;(cmd)-&gt;host-&gt;host_no
macro_line|#ifdef SUPPORT_TAGS
multiline_comment|/*&n; * Functions for handling tagged queuing&n; * =====================================&n; *&n; * ++roman (01/96): Now I&squot;ve implemented SCSI-2 tagged queuing. Some notes:&n; *&n; * Using consecutive numbers for the tags is no good idea in my eyes. There&n; * could be wrong re-usings if the counter (8 bit!) wraps and some early&n; * command has been preempted for a long time. My solution: a bitfield for&n; * remembering used tags.&n; *&n; * There&squot;s also the problem that each target has a certain queue size, but we&n; * cannot know it in advance :-( We just see a QUEUE_FULL status being&n; * returned. So, in this case, the driver internal queue size assumption is&n; * reduced to the number of active tags if QUEUE_FULL is returned by the&n; * target. The command is returned to the mid-level, but with status changed&n; * to BUSY, since --as I&squot;ve seen-- the mid-level can&squot;t handle QUEUE_FULL&n; * correctly.&n; *&n; * We&squot;re also not allowed running tagged commands as long as an untagged&n; * command is active. And REQUEST SENSE commands after a contingent allegiance&n; * condition _must_ be untagged. To keep track whether an untagged command has&n; * been issued, the host-&gt;busy array is still employed, as it is without&n; * support for tagged queuing.&n; *&n; * One could suspect that there are possible race conditions between&n; * is_lun_busy(), cmd_get_tag() and cmd_free_tag(). But I think this isn&squot;t the&n; * case: is_lun_busy() and cmd_get_tag() are both called from NCR5380_main(),&n; * which already guaranteed to be running at most once. It is also the only&n; * place where tags/LUNs are allocated. So no other allocation can slip&n; * between that pair, there could only happen a reselection, which can free a&n; * tag, but that doesn&squot;t hurt. Only the sequence in cmd_free_tag() becomes&n; * important: the tag bit must be cleared before &squot;nr_allocated&squot; is decreased.&n; */
multiline_comment|/* -1 for TAG_NONE is not possible with unsigned char cmd-&gt;tag */
DECL|macro|TAG_NONE
macro_line|#undef TAG_NONE
DECL|macro|TAG_NONE
mdefine_line|#define TAG_NONE 0xff
multiline_comment|/* For the m68k, the number of bits in &squot;allocated&squot; must be a multiple of 32! */
macro_line|#if (MAX_TAGS % 32) != 0
macro_line|#error &quot;MAX_TAGS must be a multiple of 32!&quot;
macro_line|#endif
r_typedef
r_struct
(brace
DECL|member|allocated
r_char
id|allocated
(braket
id|MAX_TAGS
op_div
l_int|8
)braket
suffix:semicolon
DECL|member|nr_allocated
r_int
id|nr_allocated
suffix:semicolon
DECL|member|queue_size
r_int
id|queue_size
suffix:semicolon
DECL|typedef|TAG_ALLOC
)brace
id|TAG_ALLOC
suffix:semicolon
DECL|variable|TagAlloc
r_static
id|TAG_ALLOC
id|TagAlloc
(braket
l_int|8
)braket
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* 8 targets and 8 LUNs */
DECL|function|init_tags
r_static
r_void
id|__init
id|init_tags
c_func
(paren
r_void
)paren
(brace
r_int
id|target
comma
id|lun
suffix:semicolon
id|TAG_ALLOC
op_star
id|ta
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|setup_use_tagged_queuing
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
OL
l_int|8
suffix:semicolon
op_increment
id|target
)paren
(brace
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
l_int|8
suffix:semicolon
op_increment
id|lun
)paren
(brace
id|ta
op_assign
op_amp
id|TagAlloc
(braket
id|target
)braket
(braket
id|lun
)braket
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ta-&gt;allocated
comma
l_int|0
comma
id|MAX_TAGS
op_div
l_int|8
)paren
suffix:semicolon
id|ta-&gt;nr_allocated
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* At the beginning, assume the maximum queue size we could&n;&t;     * support (MAX_TAGS). This value will be decreased if the target&n;&t;     * returns QUEUE_FULL status.&n;&t;     */
id|ta-&gt;queue_size
op_assign
id|MAX_TAGS
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Check if we can issue a command to this LUN: First see if the LUN is marked&n; * busy by an untagged command. If the command should use tagged queuing, also&n; * check that there is a free tag and the target&squot;s queue won&squot;t overflow. This&n; * function should be called with interrupts disabled to avoid race&n; * conditions.&n; */
DECL|function|is_lun_busy
r_static
r_int
id|is_lun_busy
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|should_be_tagged
)paren
(brace
id|SETUP_HOSTDATA
c_func
(paren
id|cmd-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|should_be_tagged
op_logical_or
op_logical_neg
id|setup_use_tagged_queuing
op_logical_or
op_logical_neg
id|cmd-&gt;device-&gt;tagged_supported
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|TagAlloc
(braket
id|cmd-&gt;target
)braket
(braket
id|cmd-&gt;lun
)braket
dot
id|nr_allocated
op_ge
id|TagAlloc
(braket
id|cmd-&gt;target
)braket
(braket
id|cmd-&gt;lun
)braket
dot
id|queue_size
)paren
(brace
id|TAG_PRINTK
c_func
(paren
l_string|&quot;scsi%d: target %d lun %d: no free tags&bslash;n&quot;
comma
id|H_NO
c_func
(paren
id|cmd
)paren
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Allocate a tag for a command (there are no checks anymore, check_lun_busy()&n; * must be called before!), or reserve the LUN in &squot;busy&squot; if the command is&n; * untagged.&n; */
DECL|function|cmd_get_tag
r_static
r_void
id|cmd_get_tag
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|should_be_tagged
)paren
(brace
id|SETUP_HOSTDATA
c_func
(paren
id|cmd-&gt;host
)paren
suffix:semicolon
multiline_comment|/* If we or the target don&squot;t support tagged queuing, allocate the LUN for&n;     * an untagged command.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|should_be_tagged
op_logical_or
op_logical_neg
id|setup_use_tagged_queuing
op_logical_or
op_logical_neg
id|cmd-&gt;device-&gt;tagged_supported
)paren
(brace
id|cmd-&gt;tag
op_assign
id|TAG_NONE
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|TAG_PRINTK
c_func
(paren
l_string|&quot;scsi%d: target %d lun %d now allocated by untagged &quot;
l_string|&quot;command&bslash;n&quot;
comma
id|H_NO
c_func
(paren
id|cmd
)paren
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
)brace
r_else
(brace
id|TAG_ALLOC
op_star
id|ta
op_assign
op_amp
id|TagAlloc
(braket
id|cmd-&gt;target
)braket
(braket
id|cmd-&gt;lun
)braket
suffix:semicolon
id|cmd-&gt;tag
op_assign
id|find_first_zero_bit
c_func
(paren
op_amp
id|ta-&gt;allocated
comma
id|MAX_TAGS
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|cmd-&gt;tag
comma
op_amp
id|ta-&gt;allocated
)paren
suffix:semicolon
id|ta-&gt;nr_allocated
op_increment
suffix:semicolon
id|TAG_PRINTK
c_func
(paren
l_string|&quot;scsi%d: using tag %d for target %d lun %d &quot;
l_string|&quot;(now %d tags in use)&bslash;n&quot;
comma
id|H_NO
c_func
(paren
id|cmd
)paren
comma
id|cmd-&gt;tag
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|ta-&gt;nr_allocated
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Mark the tag of command &squot;cmd&squot; as free, or in case of an untagged command,&n; * unlock the LUN.&n; */
DECL|function|cmd_free_tag
r_static
r_void
id|cmd_free_tag
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|SETUP_HOSTDATA
c_func
(paren
id|cmd-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;tag
op_eq
id|TAG_NONE
)paren
(brace
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|TAG_PRINTK
c_func
(paren
l_string|&quot;scsi%d: target %d lun %d untagged cmd finished&bslash;n&quot;
comma
id|H_NO
c_func
(paren
id|cmd
)paren
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd-&gt;tag
op_ge
id|MAX_TAGS
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;scsi%d: trying to free bad tag %d!&bslash;n&quot;
comma
id|H_NO
c_func
(paren
id|cmd
)paren
comma
id|cmd-&gt;tag
)paren
suffix:semicolon
)brace
r_else
(brace
id|TAG_ALLOC
op_star
id|ta
op_assign
op_amp
id|TagAlloc
(braket
id|cmd-&gt;target
)braket
(braket
id|cmd-&gt;lun
)braket
suffix:semicolon
id|clear_bit
c_func
(paren
id|cmd-&gt;tag
comma
op_amp
id|ta-&gt;allocated
)paren
suffix:semicolon
id|ta-&gt;nr_allocated
op_decrement
suffix:semicolon
id|TAG_PRINTK
c_func
(paren
l_string|&quot;scsi%d: freed tag %d for target %d lun %d&bslash;n&quot;
comma
id|H_NO
c_func
(paren
id|cmd
)paren
comma
id|cmd-&gt;tag
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
)brace
)brace
DECL|function|free_all_tags
r_static
r_void
id|free_all_tags
c_func
(paren
r_void
)paren
(brace
r_int
id|target
comma
id|lun
suffix:semicolon
id|TAG_ALLOC
op_star
id|ta
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|setup_use_tagged_queuing
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
OL
l_int|8
suffix:semicolon
op_increment
id|target
)paren
(brace
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
l_int|8
suffix:semicolon
op_increment
id|lun
)paren
(brace
id|ta
op_assign
op_amp
id|TagAlloc
(braket
id|target
)braket
(braket
id|lun
)braket
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ta-&gt;allocated
comma
l_int|0
comma
id|MAX_TAGS
op_div
l_int|8
)paren
suffix:semicolon
id|ta-&gt;nr_allocated
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* SUPPORT_TAGS */
multiline_comment|/*&n; * Function: void merge_contiguous_buffers( Scsi_Cmnd *cmd )&n; *&n; * Purpose: Try to merge several scatter-gather requests into one DMA&n; *    transfer. This is possible if the scatter buffers lie on&n; *    physical contiguous addresses.&n; *&n; * Parameters: Scsi_Cmnd *cmd&n; *    The command to work on. The first scatter buffer&squot;s data are&n; *    assumed to be already transfered into ptr/this_residual.&n; */
DECL|function|merge_contiguous_buffers
r_static
r_void
id|merge_contiguous_buffers
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
r_int
id|endaddr
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_MERGING)
r_int
r_int
id|oldlen
op_assign
id|cmd-&gt;SCp.this_residual
suffix:semicolon
r_int
id|cnt
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|endaddr
op_assign
id|virt_to_phys
c_func
(paren
id|cmd-&gt;SCp.ptr
op_plus
id|cmd-&gt;SCp.this_residual
op_minus
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
id|cmd-&gt;SCp.buffers_residual
op_logical_and
id|virt_to_phys
c_func
(paren
id|cmd-&gt;SCp.buffer
(braket
l_int|1
)braket
dot
id|address
)paren
op_eq
id|endaddr
suffix:semicolon
)paren
(brace
id|MER_PRINTK
c_func
(paren
l_string|&quot;VTOP(%p) == %08lx -&gt; merging&bslash;n&quot;
comma
id|cmd-&gt;SCp.buffer
(braket
l_int|1
)braket
dot
id|address
comma
id|endaddr
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_MERGING)
op_increment
id|cnt
suffix:semicolon
macro_line|#endif
op_increment
id|cmd-&gt;SCp.buffer
suffix:semicolon
op_decrement
id|cmd-&gt;SCp.buffers_residual
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_add_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|endaddr
op_add_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
macro_line|#if (NDEBUG &amp; NDEBUG_MERGING)
r_if
c_cond
(paren
id|oldlen
op_ne
id|cmd-&gt;SCp.this_residual
)paren
id|MER_PRINTK
c_func
(paren
l_string|&quot;merged %d buffers from %p, new length %08x&bslash;n&quot;
comma
id|cnt
comma
id|cmd-&gt;SCp.ptr
comma
id|cmd-&gt;SCp.this_residual
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Function : void initialize_SCp(Scsi_Cmnd *cmd)&n; *&n; * Purpose : initialize the saved data pointers for cmd to point to the &n; *&t;start of the buffer.&n; *&n; * Inputs : cmd - Scsi_Cmnd structure to have pointers reset.&n; */
DECL|function|initialize_SCp
r_static
id|__inline__
r_void
id|initialize_SCp
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/* &n;     * Initialize the Scsi Pointer field so that all of the commands in the &n;     * various queues are valid.&n;     */
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
id|cmd-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
id|cmd-&gt;SCp.buffers_residual
op_assign
id|cmd-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|cmd-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
multiline_comment|/* ++roman: Try to merge some scatter-buffers if they are at&n;&t; * contiguous physical addresses.&n;&t; */
id|merge_contiguous_buffers
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
r_else
(brace
id|cmd-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.buffers_residual
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
)brace
)brace
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#if NDEBUG
r_static
r_struct
(brace
DECL|member|mask
r_int
r_char
id|mask
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
)brace
DECL|variable|signals
id|signals
(braket
)braket
op_assign
(brace
(brace
id|SR_DBP
comma
l_string|&quot;PARITY&quot;
)brace
comma
(brace
id|SR_RST
comma
l_string|&quot;RST&quot;
)brace
comma
(brace
id|SR_BSY
comma
l_string|&quot;BSY&quot;
)brace
comma
(brace
id|SR_REQ
comma
l_string|&quot;REQ&quot;
)brace
comma
(brace
id|SR_MSG
comma
l_string|&quot;MSG&quot;
)brace
comma
(brace
id|SR_CD
comma
l_string|&quot;CD&quot;
)brace
comma
(brace
id|SR_IO
comma
l_string|&quot;IO&quot;
)brace
comma
(brace
id|SR_SEL
comma
l_string|&quot;SEL&quot;
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
comma
DECL|variable|basrs
id|basrs
(braket
)braket
op_assign
(brace
(brace
id|BASR_ATN
comma
l_string|&quot;ATN&quot;
)brace
comma
(brace
id|BASR_ACK
comma
l_string|&quot;ACK&quot;
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
comma
DECL|variable|icrs
id|icrs
(braket
)braket
op_assign
(brace
(brace
id|ICR_ASSERT_RST
comma
l_string|&quot;ASSERT RST&quot;
)brace
comma
(brace
id|ICR_ASSERT_ACK
comma
l_string|&quot;ASSERT ACK&quot;
)brace
comma
(brace
id|ICR_ASSERT_BSY
comma
l_string|&quot;ASSERT BSY&quot;
)brace
comma
(brace
id|ICR_ASSERT_SEL
comma
l_string|&quot;ASSERT SEL&quot;
)brace
comma
(brace
id|ICR_ASSERT_ATN
comma
l_string|&quot;ASSERT ATN&quot;
)brace
comma
(brace
id|ICR_ASSERT_DATA
comma
l_string|&quot;ASSERT DATA&quot;
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
comma
DECL|variable|mrs
id|mrs
(braket
)braket
op_assign
(brace
(brace
id|MR_BLOCK_DMA_MODE
comma
l_string|&quot;MODE BLOCK DMA&quot;
)brace
comma
(brace
id|MR_TARGET
comma
l_string|&quot;MODE TARGET&quot;
)brace
comma
(brace
id|MR_ENABLE_PAR_CHECK
comma
l_string|&quot;MODE PARITY CHECK&quot;
)brace
comma
(brace
id|MR_ENABLE_PAR_INTR
comma
l_string|&quot;MODE PARITY INTR&quot;
)brace
comma
(brace
id|MR_ENABLE_EOP_INTR
comma
l_string|&quot;MODE EOP INTR&quot;
)brace
comma
(brace
id|MR_MONITOR_BSY
comma
l_string|&quot;MODE MONITOR BSY&quot;
)brace
comma
(brace
id|MR_DMA_MODE
comma
l_string|&quot;MODE DMA&quot;
)brace
comma
(brace
id|MR_ARBITRATE
comma
l_string|&quot;MODE ARBITRATION&quot;
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Function : void NCR5380_print(struct Scsi_Host *instance)&n; *&n; * Purpose : print the SCSI bus signals for debugging purposes&n; *&n; * Input : instance - which NCR5380&n; */
DECL|function|NCR5380_print
r_static
r_void
id|NCR5380_print
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
r_int
r_char
id|status
comma
id|data
comma
id|basr
comma
id|mr
comma
id|icr
comma
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|data
op_assign
id|NCR5380_read
c_func
(paren
id|CURRENT_SCSI_DATA_REG
)paren
suffix:semicolon
id|status
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
suffix:semicolon
id|mr
op_assign
id|NCR5380_read
c_func
(paren
id|MODE_REG
)paren
suffix:semicolon
id|icr
op_assign
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
suffix:semicolon
id|basr
op_assign
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;STATUS_REG: %02x &quot;
comma
id|status
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|signals
(braket
id|i
)braket
dot
id|mask
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|status
op_amp
id|signals
(braket
id|i
)braket
dot
id|mask
)paren
id|printk
c_func
(paren
l_string|&quot;,%s&quot;
comma
id|signals
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nBASR: %02x &quot;
comma
id|basr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|basrs
(braket
id|i
)braket
dot
id|mask
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|basr
op_amp
id|basrs
(braket
id|i
)braket
dot
id|mask
)paren
id|printk
c_func
(paren
l_string|&quot;,%s&quot;
comma
id|basrs
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nICR: %02x &quot;
comma
id|icr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|icrs
(braket
id|i
)braket
dot
id|mask
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|icr
op_amp
id|icrs
(braket
id|i
)braket
dot
id|mask
)paren
id|printk
c_func
(paren
l_string|&quot;,%s&quot;
comma
id|icrs
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nMODE: %02x &quot;
comma
id|mr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mrs
(braket
id|i
)braket
dot
id|mask
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|mr
op_amp
id|mrs
(braket
id|i
)braket
dot
id|mask
)paren
id|printk
c_func
(paren
l_string|&quot;,%s&quot;
comma
id|mrs
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_static
r_struct
(brace
DECL|member|value
r_int
r_char
id|value
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|variable|phases
)brace
id|phases
(braket
)braket
op_assign
(brace
(brace
id|PHASE_DATAOUT
comma
l_string|&quot;DATAOUT&quot;
)brace
comma
(brace
id|PHASE_DATAIN
comma
l_string|&quot;DATAIN&quot;
)brace
comma
(brace
id|PHASE_CMDOUT
comma
l_string|&quot;CMDOUT&quot;
)brace
comma
(brace
id|PHASE_STATIN
comma
l_string|&quot;STATIN&quot;
)brace
comma
(brace
id|PHASE_MSGOUT
comma
l_string|&quot;MSGOUT&quot;
)brace
comma
(brace
id|PHASE_MSGIN
comma
l_string|&quot;MSGIN&quot;
)brace
comma
(brace
id|PHASE_UNKNOWN
comma
l_string|&quot;UNKNOWN&quot;
)brace
)brace
suffix:semicolon
multiline_comment|/* &n; * Function : void NCR5380_print_phase(struct Scsi_Host *instance)&n; *&n; * Purpose : print the current SCSI phase for debugging purposes&n; *&n; * Input : instance - which NCR5380&n; */
DECL|function|NCR5380_print_phase
r_static
r_void
id|NCR5380_print_phase
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
r_int
id|i
suffix:semicolon
id|status
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|SR_REQ
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;scsi%d: REQ not asserted, phase unknown.&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|phases
(braket
id|i
)braket
dot
id|value
op_ne
id|PHASE_UNKNOWN
)paren
op_logical_and
(paren
id|phases
(braket
id|i
)braket
dot
id|value
op_ne
(paren
id|status
op_amp
id|PHASE_MASK
)paren
)paren
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;scsi%d: phase %s&bslash;n&quot;
comma
id|HOSTNO
comma
id|phases
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
)brace
)brace
macro_line|#else /* !NDEBUG */
multiline_comment|/* dummies... */
DECL|function|NCR5380_print
id|__inline__
r_void
id|NCR5380_print
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
)brace
suffix:semicolon
DECL|function|NCR5380_print_phase
id|__inline__
r_void
id|NCR5380_print_phase
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * ++roman: New scheme of calling NCR5380_main()&n; * &n; * If we&squot;re not in an interrupt, we can call our main directly, it cannot be&n; * already running. Else, we queue it on a task queue, if not &squot;main_running&squot;&n; * tells us that a lower level is already executing it. This way,&n; * &squot;main_running&squot; needs not be protected in a special way.&n; *&n; * queue_main() is a utility function for putting our main onto the task&n; * queue, if main_running is false. It should be called only from a&n; * interrupt or bottom half.&n; */
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
DECL|variable|main_running
r_static
r_volatile
r_int
id|main_running
op_assign
l_int|0
suffix:semicolon
DECL|variable|NCR5380_tqueue
r_static
r_struct
id|tq_struct
id|NCR5380_tqueue
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* next */
l_int|0
comma
multiline_comment|/* sync */
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|NCR5380_main
comma
multiline_comment|/* routine, must have (void *) arg... */
l_int|NULL
multiline_comment|/* data */
)brace
suffix:semicolon
DECL|function|queue_main
r_static
id|__inline__
r_void
id|queue_main
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|main_running
)paren
(brace
multiline_comment|/* If in interrupt and NCR5380_main() not already running,&n;&t;   queue it on the &squot;immediate&squot; task queue, to be processed&n;&t;   immediately after the current interrupt processing has&n;&t;   finished. */
id|queue_task
c_func
(paren
op_amp
id|NCR5380_tqueue
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
)brace
multiline_comment|/* else: nothing to do: the running NCR5380_main() will pick up&n;       any newly queued command. */
)brace
DECL|function|NCR5380_all_init
r_static
r_inline
r_void
id|NCR5380_all_init
(paren
r_void
)paren
(brace
r_static
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
(brace
id|INI_PRINTK
c_func
(paren
l_string|&quot;scsi : NCR5380_all_init()&bslash;n&quot;
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function : void NCR58380_print_options (struct Scsi_Host *instance)&n; *&n; * Purpose : called by probe code indicating the NCR5380 driver&n; *&t;     options that were selected.&n; *&n; * Inputs : instance, pointer to this instance.  Unused.&n; */
DECL|function|NCR5380_print_options
r_static
r_void
id|__init
id|NCR5380_print_options
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; generic options&quot;
macro_line|#ifdef AUTOSENSE 
l_string|&quot; AUTOSENSE&quot;
macro_line|#endif
macro_line|#ifdef REAL_DMA
l_string|&quot; REAL DMA&quot;
macro_line|#endif
macro_line|#ifdef PARITY
l_string|&quot; PARITY&quot;
macro_line|#endif
macro_line|#ifdef SUPPORT_TAGS
l_string|&quot; SCSI-2 TAGGED QUEUING&quot;
macro_line|#endif
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; generic release=%d&quot;
comma
id|NCR5380_PUBLIC_RELEASE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : void NCR5380_print_status (struct Scsi_Host *instance)&n; *&n; * Purpose : print commands in the various queues, called from&n; *&t;NCR5380_abort and NCR5380_debug to aid debugging.&n; *&n; * Inputs : instance, pointer to this instance.  &n; */
DECL|function|NCR5380_print_status
r_static
r_void
id|NCR5380_print_status
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
r_char
op_star
id|pr_bfr
suffix:semicolon
r_char
op_star
id|start
suffix:semicolon
r_int
id|len
suffix:semicolon
id|NCR_PRINT
c_func
(paren
id|NDEBUG_ANY
)paren
suffix:semicolon
id|NCR_PRINT_PHASE
c_func
(paren
id|NDEBUG_ANY
)paren
suffix:semicolon
id|pr_bfr
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr_bfr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NCR5380_print_status: no memory for print buffer&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|len
op_assign
id|NCR5380_proc_info
c_func
(paren
id|pr_bfr
comma
op_amp
id|start
comma
l_int|0
comma
id|PAGE_SIZE
comma
id|HOSTNO
comma
l_int|0
)paren
suffix:semicolon
id|pr_bfr
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n%s&bslash;n&quot;
comma
id|pr_bfr
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|pr_bfr
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************/
multiline_comment|/*&n; * /proc/scsi/[dtc pas16 t128 generic]/[0-ASC_NUM_BOARD_SUPPORTED]&n; *&n; * *buffer: I/O buffer&n; * **start: if inout == FALSE pointer into buffer where user read should start&n; * offset: current offset&n; * length: length of buffer&n; * hostno: Scsi_Host host_no&n; * inout: TRUE - user is writing; FALSE - user is reading&n; *&n; * Return the number of bytes read from or written&n;*/
DECL|macro|SPRINTF
macro_line|#undef SPRINTF
DECL|macro|SPRINTF
mdefine_line|#define SPRINTF(fmt,args...) &bslash;&n;  do { if (pos + strlen(fmt) + 20 /* slop */ &lt; buffer + length) &bslash;&n;&t; pos += sprintf(pos, fmt , ## args); } while(0)
r_static
r_char
op_star
id|lprint_Scsi_Cmnd
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_char
op_star
id|pos
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
suffix:semicolon
macro_line|#ifndef NCR5380_proc_info
r_static
macro_line|#endif
DECL|function|NCR5380_proc_info
r_int
id|NCR5380_proc_info
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
r_char
op_star
id|pos
op_assign
id|buffer
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
suffix:semicolon
id|Scsi_Cmnd
op_star
id|ptr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
DECL|macro|check_offset
mdefine_line|#define check_offset()&t;&t;&t;&t;&bslash;&n;    do {&t;&t;&t;&t;&t;&bslash;&n;&t;if (pos - buffer &lt; offset - begin) {&t;&bslash;&n;&t;    begin += pos - buffer;&t;&t;&bslash;&n;&t;    pos = buffer;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&bslash;&n;    } while (0)
r_for
c_loop
(paren
id|instance
op_assign
id|first_instance
suffix:semicolon
id|instance
op_logical_and
id|HOSTNO
op_ne
id|hostno
suffix:semicolon
id|instance
op_assign
id|instance-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
r_return
op_minus
id|ESRCH
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|NCR5380_hostdata
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
r_if
c_cond
(paren
id|inout
)paren
(brace
multiline_comment|/* Has data been written to the file ? */
r_return
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* Currently this is a no-op */
)brace
id|SPRINTF
c_func
(paren
l_string|&quot;NCR5380 core release=%d.&bslash;n&quot;
comma
id|NCR5380_PUBLIC_RELEASE
)paren
suffix:semicolon
id|check_offset
c_func
(paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;NCR5380: coroutine is%s running.&bslash;n&quot;
comma
id|main_running
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;n&squot;t&quot;
)paren
suffix:semicolon
id|check_offset
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;connected
)paren
id|SPRINTF
c_func
(paren
l_string|&quot;scsi%d: no currently connected command&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
r_else
id|pos
op_assign
id|lprint_Scsi_Cmnd
(paren
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;connected
comma
id|pos
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;scsi%d: issue_queue&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|check_offset
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|ptr
suffix:semicolon
id|ptr
op_assign
id|NEXT
c_func
(paren
id|ptr
)paren
)paren
(brace
id|pos
op_assign
id|lprint_Scsi_Cmnd
(paren
id|ptr
comma
id|pos
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
id|check_offset
c_func
(paren
)paren
suffix:semicolon
)brace
id|SPRINTF
c_func
(paren
l_string|&quot;scsi%d: disconnected_queue&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|check_offset
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_queue
suffix:semicolon
id|ptr
suffix:semicolon
id|ptr
op_assign
id|NEXT
c_func
(paren
id|ptr
)paren
)paren
(brace
id|pos
op_assign
id|lprint_Scsi_Cmnd
(paren
id|ptr
comma
id|pos
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
id|check_offset
c_func
(paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_minus
id|buffer
OL
id|offset
op_minus
id|begin
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pos
op_minus
id|buffer
op_minus
(paren
id|offset
op_minus
id|begin
)paren
OL
id|length
)paren
r_return
id|pos
op_minus
id|buffer
op_minus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
r_static
r_char
op_star
DECL|function|lprint_Scsi_Cmnd
id|lprint_Scsi_Cmnd
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_char
op_star
id|pos
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_int
id|i
comma
id|s
suffix:semicolon
r_int
r_char
op_star
id|command
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;scsi%d: destination target %d, lun %d&bslash;n&quot;
comma
id|H_NO
c_func
(paren
id|cmd
)paren
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;        command = &quot;
)paren
suffix:semicolon
id|command
op_assign
id|cmd-&gt;cmnd
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;%2d (0x%02x)&quot;
comma
id|command
(braket
l_int|0
)braket
comma
id|command
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
comma
id|s
op_assign
id|COMMAND_SIZE
c_func
(paren
id|command
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
OL
id|s
suffix:semicolon
op_increment
id|i
)paren
id|SPRINTF
c_func
(paren
l_string|&quot; %02x&quot;
comma
id|command
(braket
id|i
)braket
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|pos
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : void NCR5380_init (struct Scsi_Host *instance)&n; *&n; * Purpose : initializes *instance and corresponding 5380 chip.&n; *&n; * Inputs : instance - instantiation of the 5380 driver.  &n; *&n; * Notes : I assume that the host, hostno, and id bits have been&n; * &t;set correctly.  I don&squot;t care about the irq and other fields. &n; * &n; */
DECL|function|NCR5380_init
r_static
r_void
id|__init
id|NCR5380_init
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
id|flags
)paren
(brace
r_int
id|i
suffix:semicolon
id|SETUP_HOSTDATA
c_func
(paren
id|instance
)paren
suffix:semicolon
id|NCR5380_all_init
c_func
(paren
)paren
suffix:semicolon
id|hostdata-&gt;aborted
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;id_mask
op_assign
l_int|1
op_lshift
id|instance-&gt;this_id
suffix:semicolon
id|hostdata-&gt;id_higher_mask
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|hostdata-&gt;id_mask
suffix:semicolon
id|i
op_le
l_int|0x80
suffix:semicolon
id|i
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|i
OG
id|hostdata-&gt;id_mask
)paren
id|hostdata-&gt;id_higher_mask
op_or_assign
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
id|hostdata-&gt;busy
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SUPPORT_TAGS
id|init_tags
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined (REAL_DMA)
id|hostdata-&gt;dma_len
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;targets_present
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;disconnected_queue
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;flags
op_assign
id|FLAG_CHECK_LAST_BYTE_SENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|the_template
)paren
(brace
id|the_template
op_assign
id|instance-&gt;hostt
suffix:semicolon
id|first_instance
op_assign
id|instance
suffix:semicolon
)brace
macro_line|#ifndef AUTOSENSE
r_if
c_cond
(paren
(paren
id|instance-&gt;cmd_per_lun
OG
l_int|1
)paren
op_logical_or
(paren
id|instance-&gt;can_queue
OG
l_int|1
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d: WARNING : support for multiple outstanding commands enabled&bslash;n&quot;
l_string|&quot;        without AUTOSENSE option, contingent allegiance conditions may&bslash;n&quot;
l_string|&quot;        be incorrectly cleared.&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
macro_line|#endif /* def AUTOSENSE */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
l_int|0
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : int NCR5380_queue_command (Scsi_Cmnd *cmd, &n; *&t;void (*done)(Scsi_Cmnd *)) &n; *&n; * Purpose :  enqueues a SCSI command&n; *&n; * Inputs : cmd - SCSI command, done - function called on completion, with&n; *&t;a pointer to the command descriptor.&n; * &n; * Returns : 0&n; *&n; * Side effects : &n; *      cmd is added to the per instance issue_queue, with minor &n; *&t;twiddling done to the host specific fields of cmd.  If the &n; *&t;main coroutine is not running, it is restarted.&n; *&n; */
multiline_comment|/* Only make static if a wrapper function is used */
macro_line|#ifndef NCR5380_queue_command
r_static
macro_line|#endif
DECL|function|NCR5380_queue_command
r_int
id|NCR5380_queue_command
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|SETUP_HOSTDATA
c_func
(paren
id|cmd-&gt;host
)paren
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
suffix:semicolon
r_int
id|oldto
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_extern
r_int
id|update_timeout
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCset
comma
r_int
id|timeout
)paren
suffix:semicolon
macro_line|#if (NDEBUG &amp; NDEBUG_NO_WRITE)
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;scsi%d: WRITE attempted with NO_WRITE debugging flag set&bslash;n&quot;
comma
id|H_NO
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* (NDEBUG &amp; NDEBUG_NO_WRITE) */
macro_line|#ifdef NCR5380_STATS
macro_line|# if 0
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;connected
op_logical_and
op_logical_neg
id|hostdata-&gt;issue_queue
op_logical_and
op_logical_neg
id|hostdata-&gt;disconnected_queue
)paren
(brace
id|hostdata-&gt;timebase
op_assign
id|jiffies
suffix:semicolon
)brace
macro_line|# endif
macro_line|# ifdef NCR5380_STAT_LIMIT
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
OG
id|NCR5380_STAT_LIMIT
)paren
macro_line|# endif
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|WRITE
suffix:colon
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
id|hostdata-&gt;time_write
(braket
id|cmd-&gt;target
)braket
op_sub_assign
(paren
id|jiffies
op_minus
id|hostdata-&gt;timebase
)paren
suffix:semicolon
id|hostdata-&gt;bytes_write
(braket
id|cmd-&gt;target
)braket
op_add_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|hostdata-&gt;pendingw
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ
suffix:colon
r_case
id|READ_6
suffix:colon
r_case
id|READ_10
suffix:colon
id|hostdata-&gt;time_read
(braket
id|cmd-&gt;target
)braket
op_sub_assign
(paren
id|jiffies
op_minus
id|hostdata-&gt;timebase
)paren
suffix:semicolon
id|hostdata-&gt;bytes_read
(braket
id|cmd-&gt;target
)braket
op_add_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|hostdata-&gt;pendingr
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* &n;     * We use the host_scribble field as a pointer to the next command  &n;     * in a queue &n;     */
id|NEXT
c_func
(paren
id|cmd
)paren
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;     * Insert the cmd into the issue queue. Note that REQUEST SENSE &n;     * commands are added to the head of the queue since any command will&n;     * clear the contingent allegiance condition that exists and the &n;     * sense data is only guaranteed to be valid while the condition exists.&n;     */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ++guenther: now that the issue queue is being set up, we can lock ST-DMA.&n;     * Otherwise a running NCR5380_main may steal the lock.&n;     * Lock before actually inserting due to fairness reasons explained in&n;     * atari_scsi.c. If we insert first, then it&squot;s impossible for this driver&n;     * to release the lock.&n;     * Stop timer for this command while waiting for the lock, or timeouts&n;     * may happen (and they really do), and it&squot;s no good if the command doesn&squot;t&n;     * appear in any of the queues.&n;     * ++roman: Just disabling the NCR interrupt isn&squot;t sufficient here,&n;     * because also a timer int can trigger an abort or reset, which would&n;     * alter queues and touch the lock.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|IS_A_TT
c_func
(paren
)paren
)paren
(brace
id|oldto
op_assign
id|update_timeout
c_func
(paren
id|cmd
comma
l_int|0
)paren
suffix:semicolon
id|falcon_get_lock
c_func
(paren
)paren
suffix:semicolon
id|update_timeout
c_func
(paren
id|cmd
comma
id|oldto
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hostdata-&gt;issue_queue
)paren
op_logical_or
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
)paren
(brace
id|LIST
c_func
(paren
id|cmd
comma
id|hostdata-&gt;issue_queue
)paren
suffix:semicolon
id|NEXT
c_func
(paren
id|cmd
)paren
op_assign
id|hostdata-&gt;issue_queue
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
id|cmd
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|NEXT
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|tmp
op_assign
id|NEXT
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|LIST
c_func
(paren
id|cmd
comma
id|tmp
)paren
suffix:semicolon
id|NEXT
c_func
(paren
id|tmp
)paren
op_assign
id|cmd
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|QU_PRINTK
c_func
(paren
l_string|&quot;scsi%d: command added to %s of queue&bslash;n&quot;
comma
id|H_NO
c_func
(paren
id|cmd
)paren
comma
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
ques
c_cond
l_string|&quot;head&quot;
suffix:colon
l_string|&quot;tail&quot;
)paren
suffix:semicolon
multiline_comment|/* If queue_command() is called from an interrupt (real one or bottom&n;     * half), we let queue_main() do the job of taking care about main. If it&n;     * is already running, this is a no-op, else main will be queued.&n;     *&n;     * If we&squot;re not in an interrupt, we can call NCR5380_main()&n;     * unconditionally, because it cannot be already running.&n;     */
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
op_logical_or
(paren
(paren
id|flags
op_rshift
l_int|8
)paren
op_amp
l_int|7
)paren
op_ge
l_int|6
)paren
id|queue_main
c_func
(paren
)paren
suffix:semicolon
r_else
id|NCR5380_main
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : NCR5380_main (void) &n; *&n; * Purpose : NCR5380_main is a coroutine that runs as long as more work can &n; *&t;be done on the NCR5380 host adapters in a system.  Both &n; *&t;NCR5380_queue_command() and NCR5380_intr() will try to start it &n; *&t;in case it is not running.&n; * &n; * NOTE : NCR5380_main exits with interrupts *disabled*, the caller should &n; *  reenable them.  This prevents reentrancy and kernel stack overflow.&n; */
DECL|function|NCR5380_main
r_static
r_void
id|NCR5380_main
(paren
r_void
)paren
(brace
id|Scsi_Cmnd
op_star
id|tmp
comma
op_star
id|prev
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
op_assign
id|first_instance
suffix:semicolon
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
op_assign
id|HOSTDATA
c_func
(paren
id|instance
)paren
suffix:semicolon
r_int
id|done
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;     * We run (with interrupts disabled) until we&squot;re sure that none of &n;     * the host adapters have anything that can be done, at which point &n;     * we set main_running to 0 and exit.&n;     *&n;     * Interrupts are enabled before doing various other internal &n;     * instructions, after we&squot;ve decided that we need to run through&n;     * the loop again.&n;     *&n;     * this should prevent any race conditions.&n;     * &n;     * ++roman: Just disabling the NCR interrupt isn&squot;t sufficient here,&n;     * because also a timer int can trigger an abort or reset, which can&n;     * alter queues and touch the Falcon lock.&n;     */
multiline_comment|/* Tell int handlers main() is now already executing.  Note that&n;       no races are possible here. If an int comes in before&n;       &squot;main_running&squot; is set here, and queues/executes main via the&n;       task queue, it doesn&squot;t do any harm, just this instance of main&n;       won&squot;t find any work left to do. */
r_if
c_cond
(paren
id|main_running
)paren
r_return
suffix:semicolon
id|main_running
op_assign
l_int|1
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_do
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Freeze request queues */
id|done
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;connected
)paren
(brace
id|MAIN_PRINTK
c_func
(paren
l_string|&quot;scsi%d: not connected&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
multiline_comment|/*&n;&t;     * Search through the issue_queue for a command destined&n;&t;     * for a target that&squot;s not busy.&n;&t;     */
macro_line|#if (NDEBUG &amp; NDEBUG_LISTS)
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
comma
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|tmp
op_logical_and
(paren
id|tmp
op_ne
id|prev
)paren
suffix:semicolon
id|prev
op_assign
id|tmp
comma
id|tmp
op_assign
id|NEXT
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
multiline_comment|/*printk(&quot;%p  &quot;, tmp);*/
r_if
c_cond
(paren
(paren
id|tmp
op_eq
id|prev
)paren
op_logical_and
id|tmp
)paren
id|printk
c_func
(paren
l_string|&quot; LOOP&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* else printk(&quot;&bslash;n&quot;);*/
macro_line|#endif
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
comma
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|tmp
suffix:semicolon
id|prev
op_assign
id|tmp
comma
id|tmp
op_assign
id|NEXT
c_func
(paren
id|tmp
)paren
)paren
(brace
macro_line|#if (NDEBUG &amp; NDEBUG_LISTS)
r_if
c_cond
(paren
id|prev
op_ne
id|tmp
)paren
id|printk
c_func
(paren
l_string|&quot;MAIN tmp=%p   target=%d   busy=%d lun=%d&bslash;n&quot;
comma
id|tmp
comma
id|tmp-&gt;target
comma
id|hostdata-&gt;busy
(braket
id|tmp-&gt;target
)braket
comma
id|tmp-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*  When we find one, remove it from the issue queue. */
multiline_comment|/* ++guenther: possible race with Falcon locking */
r_if
c_cond
(paren
macro_line|#ifdef SUPPORT_TAGS
op_logical_neg
id|is_lun_busy
c_func
(paren
id|tmp
comma
id|tmp-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|REQUEST_SENSE
)paren
macro_line|#else
op_logical_neg
(paren
id|hostdata-&gt;busy
(braket
id|tmp-&gt;target
)braket
op_amp
(paren
l_int|1
op_lshift
id|tmp-&gt;lun
)paren
)paren
macro_line|#endif
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ++guenther: just to be sure, this must be atomic */
r_if
c_cond
(paren
id|prev
)paren
(brace
id|REMOVE
c_func
(paren
id|prev
comma
id|NEXT
c_func
(paren
id|prev
)paren
comma
id|tmp
comma
id|NEXT
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|NEXT
c_func
(paren
id|prev
)paren
op_assign
id|NEXT
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
r_else
(brace
id|REMOVE
c_func
(paren
op_minus
l_int|1
comma
id|hostdata-&gt;issue_queue
comma
id|tmp
comma
id|NEXT
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
id|NEXT
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|NEXT
c_func
(paren
id|tmp
)paren
op_assign
l_int|NULL
suffix:semicolon
id|falcon_dont_release
op_increment
suffix:semicolon
multiline_comment|/* reenable interrupts after finding one */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;     * Attempt to establish an I_T_L nexus here. &n;&t;&t;     * On success, instance-&gt;hostdata-&gt;connected is set.&n;&t;&t;     * On failure, we must add the command back to the&n;&t;&t;     *   issue queue so we can keep trying.&t;&n;&t;&t;     */
id|MAIN_PRINTK
c_func
(paren
l_string|&quot;scsi%d: main(): command for target %d &quot;
l_string|&quot;lun %d removed from issue_queue&bslash;n&quot;
comma
id|HOSTNO
comma
id|tmp-&gt;target
comma
id|tmp-&gt;lun
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;     * REQUEST SENSE commands are issued without tagged&n;&t;&t;     * queueing, even on SCSI-II devices because the &n;&t;&t;     * contingent allegiance condition exists for the &n;&t;&t;     * entire unit.&n;&t;&t;     */
multiline_comment|/* ++roman: ...and the standard also requires that&n;&t;&t;     * REQUEST SENSE command are untagged.&n;&t;&t;     */
macro_line|#ifdef SUPPORT_TAGS
id|cmd_get_tag
c_func
(paren
id|tmp
comma
id|tmp-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|REQUEST_SENSE
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|NCR5380_select
c_func
(paren
id|instance
comma
id|tmp
comma
(paren
id|tmp-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
ques
c_cond
id|TAG_NONE
suffix:colon
id|TAG_NEXT
)paren
)paren
(brace
id|falcon_dont_release
op_decrement
suffix:semicolon
multiline_comment|/* release if target did not response! */
id|falcon_release_lock_if_possible
c_func
(paren
id|hostdata
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|LIST
c_func
(paren
id|tmp
comma
id|hostdata-&gt;issue_queue
)paren
suffix:semicolon
id|NEXT
c_func
(paren
id|tmp
)paren
op_assign
id|hostdata-&gt;issue_queue
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
id|tmp
suffix:semicolon
macro_line|#ifdef SUPPORT_TAGS
id|cmd_free_tag
c_func
(paren
id|tmp
)paren
suffix:semicolon
macro_line|#endif
id|falcon_dont_release
op_decrement
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|MAIN_PRINTK
c_func
(paren
l_string|&quot;scsi%d: main(): select() failed, &quot;
l_string|&quot;returned to issue_queue&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;connected
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* if target/lun/target queue is not busy */
)brace
multiline_comment|/* for issue_queue */
)brace
multiline_comment|/* if (!hostdata-&gt;connected) */
r_if
c_cond
(paren
id|hostdata-&gt;connected
macro_line|#ifdef REAL_DMA
op_logical_and
op_logical_neg
id|hostdata-&gt;dma_len
macro_line|#endif
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|MAIN_PRINTK
c_func
(paren
l_string|&quot;scsi%d: main: performing information transfer&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|NCR5380_information_transfer
c_func
(paren
id|instance
)paren
suffix:semicolon
id|MAIN_PRINTK
c_func
(paren
l_string|&quot;scsi%d: main: done set false&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|done
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
suffix:semicolon
multiline_comment|/* Better allow ints _after_ &squot;main_running&squot; has been cleared, else&n;       an interrupt could believe we&squot;ll pick up the work it left for&n;       us, but we won&squot;t see it anymore here... */
id|main_running
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#ifdef REAL_DMA
multiline_comment|/*&n; * Function : void NCR5380_dma_complete (struct Scsi_Host *instance)&n; *&n; * Purpose : Called by interrupt handler when DMA finishes or a phase&n; *&t;mismatch occurs (which would finish the DMA transfer).  &n; *&n; * Inputs : instance - this instance of the NCR5380.&n; *&n; */
DECL|function|NCR5380_dma_complete
r_static
r_void
id|NCR5380_dma_complete
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
id|SETUP_HOSTDATA
c_func
(paren
id|instance
)paren
suffix:semicolon
r_int
id|transfered
comma
id|saved_data
op_assign
l_int|0
comma
id|overrun
op_assign
l_int|0
comma
id|cnt
comma
id|toPIO
suffix:semicolon
r_int
r_char
op_star
op_star
id|data
comma
id|p
suffix:semicolon
r_volatile
r_int
op_star
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hostdata-&gt;connected
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: received end of DMA interrupt with &quot;
l_string|&quot;no connected cmd&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atari_read_overruns
)paren
(brace
id|p
op_assign
id|hostdata-&gt;connected-&gt;SCp.phase
suffix:semicolon
r_if
c_cond
(paren
id|p
op_amp
id|SR_IO
)paren
(brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
(paren
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
)paren
op_amp
(paren
id|BASR_PHASE_MATCH
op_or
id|BASR_ACK
)paren
)paren
op_eq
(paren
id|BASR_PHASE_MATCH
op_or
id|BASR_ACK
)paren
)paren
)paren
(brace
id|saved_data
op_assign
id|NCR5380_read
c_func
(paren
id|INPUT_DATA_REG
)paren
suffix:semicolon
id|overrun
op_assign
l_int|1
suffix:semicolon
id|DMA_PRINTK
c_func
(paren
l_string|&quot;scsi%d: read overrun handled&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
)brace
)brace
)brace
id|DMA_PRINTK
c_func
(paren
l_string|&quot;scsi%d: real DMA transfer complete, basr 0x%X, sr 0x%X&bslash;n&quot;
comma
id|HOSTNO
comma
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
comma
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|transfered
op_assign
id|hostdata-&gt;dma_len
op_minus
id|NCR5380_dma_residual
c_func
(paren
id|instance
)paren
suffix:semicolon
id|hostdata-&gt;dma_len
op_assign
l_int|0
suffix:semicolon
id|data
op_assign
(paren
r_int
r_char
op_star
op_star
)paren
op_amp
(paren
id|hostdata-&gt;connected-&gt;SCp.ptr
)paren
suffix:semicolon
id|count
op_assign
op_amp
(paren
id|hostdata-&gt;connected-&gt;SCp.this_residual
)paren
suffix:semicolon
op_star
id|data
op_add_assign
id|transfered
suffix:semicolon
op_star
id|count
op_sub_assign
id|transfered
suffix:semicolon
r_if
c_cond
(paren
id|atari_read_overruns
)paren
(brace
r_if
c_cond
(paren
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|PHASE_MASK
)paren
op_eq
id|p
op_logical_and
(paren
id|p
op_amp
id|SR_IO
)paren
)paren
(brace
id|cnt
op_assign
id|toPIO
op_assign
id|atari_read_overruns
suffix:semicolon
r_if
c_cond
(paren
id|overrun
)paren
(brace
id|DMA_PRINTK
c_func
(paren
l_string|&quot;Got an input overrun, using saved byte&bslash;n&quot;
)paren
suffix:semicolon
op_star
(paren
op_star
id|data
)paren
op_increment
op_assign
id|saved_data
suffix:semicolon
(paren
op_star
id|count
)paren
op_decrement
suffix:semicolon
id|cnt
op_decrement
suffix:semicolon
id|toPIO
op_decrement
suffix:semicolon
)brace
id|DMA_PRINTK
c_func
(paren
l_string|&quot;Doing %d-byte PIO to 0x%08lx&bslash;n&quot;
comma
id|cnt
comma
(paren
r_int
)paren
op_star
id|data
)paren
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|p
comma
op_amp
id|cnt
comma
id|data
)paren
suffix:semicolon
op_star
id|count
op_sub_assign
id|toPIO
op_minus
id|cnt
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* REAL_DMA */
multiline_comment|/*&n; * Function : void NCR5380_intr (int irq)&n; * &n; * Purpose : handle interrupts, reestablishing I_T_L or I_T_L_Q nexuses&n; *&t;from the disconnected queue, and restarting NCR5380_main() &n; *&t;as required.&n; *&n; * Inputs : int irq, irq that caused this interrupt.&n; *&n; */
DECL|function|NCR5380_intr
r_static
r_void
id|NCR5380_intr
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|instance
op_assign
id|first_instance
suffix:semicolon
r_int
id|done
op_assign
l_int|1
suffix:semicolon
r_int
r_char
id|basr
suffix:semicolon
id|INT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: NCR5380 irq triggered&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
multiline_comment|/* Look for pending interrupts */
id|basr
op_assign
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
suffix:semicolon
id|INT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: BASR=%02x&bslash;n&quot;
comma
id|HOSTNO
comma
id|basr
)paren
suffix:semicolon
multiline_comment|/* dispatch to appropriate routine if found and done=0 */
r_if
c_cond
(paren
id|basr
op_amp
id|BASR_IRQ
)paren
(brace
id|NCR_PRINT
c_func
(paren
id|NDEBUG_INTR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
(paren
id|SR_SEL
op_or
id|SR_IO
)paren
)paren
op_eq
(paren
id|SR_SEL
op_or
id|SR_IO
)paren
)paren
(brace
id|done
op_assign
l_int|0
suffix:semicolon
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|INT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: SEL interrupt&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|NCR5380_reselect
c_func
(paren
id|instance
)paren
suffix:semicolon
(paren
r_void
)paren
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|basr
op_amp
id|BASR_PARITY_ERROR
)paren
(brace
id|INT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: PARITY interrupt&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
(paren
r_void
)paren
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_RST
)paren
op_eq
id|SR_RST
)paren
(brace
id|INT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: RESET interrupt&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
(paren
r_void
)paren
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  &n;&t;     * The rest of the interrupt conditions can occur only during a&n;&t;     * DMA transfer&n;&t;     */
macro_line|#if defined(REAL_DMA)
multiline_comment|/*&n;&t;     * We should only get PHASE MISMATCH and EOP interrupts if we have&n;&t;     * DMA enabled, so do a sanity check based on the current setting&n;&t;     * of the MODE register.&n;&t;     */
r_if
c_cond
(paren
(paren
id|NCR5380_read
c_func
(paren
id|MODE_REG
)paren
op_amp
id|MR_DMA_MODE
)paren
op_logical_and
(paren
(paren
id|basr
op_amp
id|BASR_END_DMA_TRANSFER
)paren
op_logical_or
op_logical_neg
(paren
id|basr
op_amp
id|BASR_PHASE_MATCH
)paren
)paren
)paren
(brace
id|INT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: PHASE MISM or EOP interrupt&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|NCR5380_dma_complete
c_func
(paren
id|instance
)paren
suffix:semicolon
id|done
op_assign
l_int|0
suffix:semicolon
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif /* REAL_DMA */
(brace
multiline_comment|/* MS: Ignore unknown phase mismatch interrupts (caused by EOP interrupt) */
r_if
c_cond
(paren
id|basr
op_amp
id|BASR_PHASE_MATCH
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;scsi%d: unknown interrupt, &quot;
l_string|&quot;BASR 0x%x, MR 0x%x, SR 0x%x&bslash;n&quot;
comma
id|HOSTNO
comma
id|basr
comma
id|NCR5380_read
c_func
(paren
id|MODE_REG
)paren
comma
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* if !(SELECTION || PARITY) */
)brace
multiline_comment|/* BASR &amp; IRQ */
r_else
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;scsi%d: interrupt without IRQ bit set in BASR, &quot;
l_string|&quot;BASR 0x%X, MR 0x%X, SR 0x%x&bslash;n&quot;
comma
id|HOSTNO
comma
id|basr
comma
id|NCR5380_read
c_func
(paren
id|MODE_REG
)paren
comma
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
(brace
id|INT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: in int routine, calling main&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
multiline_comment|/* Put a call to NCR5380_main() on the queue... */
id|queue_main
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef NCR5380_STATS
DECL|function|collect_stats
r_static
r_void
id|collect_stats
c_func
(paren
r_struct
id|NCR5380_hostdata
op_star
id|hostdata
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
macro_line|# ifdef NCR5380_STAT_LIMIT
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
OG
id|NCR5380_STAT_LIMIT
)paren
macro_line|# endif
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|WRITE
suffix:colon
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
id|hostdata-&gt;time_write
(braket
id|cmd-&gt;target
)braket
op_add_assign
(paren
id|jiffies
op_minus
id|hostdata-&gt;timebase
)paren
suffix:semicolon
multiline_comment|/*hostdata-&gt;bytes_write[cmd-&gt;target] += cmd-&gt;request_bufflen;*/
id|hostdata-&gt;pendingw
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ
suffix:colon
r_case
id|READ_6
suffix:colon
r_case
id|READ_10
suffix:colon
id|hostdata-&gt;time_read
(braket
id|cmd-&gt;target
)braket
op_add_assign
(paren
id|jiffies
op_minus
id|hostdata-&gt;timebase
)paren
suffix:semicolon
multiline_comment|/*hostdata-&gt;bytes_read[cmd-&gt;target] += cmd-&gt;request_bufflen;*/
id|hostdata-&gt;pendingr
op_decrement
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* &n; * Function : int NCR5380_select (struct Scsi_Host *instance, Scsi_Cmnd *cmd, &n; *&t;int tag);&n; *&n; * Purpose : establishes I_T_L or I_T_L_Q nexus for new or existing command,&n; *&t;including ARBITRATION, SELECTION, and initial message out for &n; *&t;IDENTIFY and queue messages. &n; *&n; * Inputs : instance - instantiation of the 5380 driver on which this &n; * &t;target lives, cmd - SCSI command to execute, tag - set to TAG_NEXT for &n; *&t;new tag, TAG_NONE for untagged queueing, otherwise set to the tag for &n; *&t;the command that is presently connected.&n; * &n; * Returns : -1 if selection could not execute for some reason,&n; *&t;0 if selection succeeded or failed because the target &n; * &t;did not respond.&n; *&n; * Side effects : &n; * &t;If bus busy, arbitration failed, etc, NCR5380_select() will exit &n; *&t;&t;with registers as they should have been on entry - ie&n; *&t;&t;SELECT_ENABLE will be set appropriately, the NCR5380&n; *&t;&t;will cease to drive any SCSI bus signals.&n; *&n; *&t;If successful : I_T_L or I_T_L_Q nexus will be established, &n; *&t;&t;instance-&gt;connected will be set to cmd.  &n; * &t;&t;SELECT interrupt will be disabled.&n; *&n; *&t;If failed (no target) : cmd-&gt;scsi_done() will be called, and the &n; *&t;&t;cmd-&gt;result host byte set to DID_BAD_TARGET.&n; */
DECL|function|NCR5380_select
r_static
r_int
id|NCR5380_select
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|tag
)paren
(brace
id|SETUP_HOSTDATA
c_func
(paren
id|instance
)paren
suffix:semicolon
r_int
r_char
id|tmp
(braket
l_int|3
)braket
comma
id|phase
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|hostdata-&gt;restart_select
op_assign
l_int|0
suffix:semicolon
id|NCR_PRINT
c_func
(paren
id|NDEBUG_ARBITRATION
)paren
suffix:semicolon
id|ARB_PRINTK
c_func
(paren
l_string|&quot;scsi%d: starting arbitration, id = %d&bslash;n&quot;
comma
id|HOSTNO
comma
id|instance-&gt;this_id
)paren
suffix:semicolon
multiline_comment|/* &n;     * Set the phase bits to 0, otherwise the NCR5380 won&squot;t drive the &n;     * data bus during SELECTION.&n;     */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;connected
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;     * Start arbitration.&n;     */
id|NCR5380_write
c_func
(paren
id|OUTPUT_DATA_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_ARBITRATE
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Wait for arbitration logic to complete */
macro_line|#if NCR_TIMEOUT
(brace
r_int
r_int
id|timeout
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|NCR_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
op_amp
id|ICR_ARBITRATION_PROGRESS
)paren
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
op_logical_and
op_logical_neg
id|hostdata-&gt;connected
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi : arbitration timeout at %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#else /* NCR_TIMEOUT */
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
op_amp
id|ICR_ARBITRATION_PROGRESS
)paren
op_logical_and
op_logical_neg
id|hostdata-&gt;connected
)paren
suffix:semicolon
macro_line|#endif
id|ARB_PRINTK
c_func
(paren
l_string|&quot;scsi%d: arbitration complete&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;connected
)paren
(brace
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;     * The arbitration delay is 2.2us, but this is a minimum and there is &n;     * no maximum so we can safely sleep for ceil(2.2) usecs to accommodate&n;     * the integral nature of udelay().&n;     *&n;     */
id|udelay
c_func
(paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Check for lost arbitration */
r_if
c_cond
(paren
(paren
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
op_amp
id|ICR_ARBITRATION_LOST
)paren
op_logical_or
(paren
id|NCR5380_read
c_func
(paren
id|CURRENT_SCSI_DATA_REG
)paren
op_amp
id|hostdata-&gt;id_higher_mask
)paren
op_logical_or
(paren
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
op_amp
id|ICR_ARBITRATION_LOST
)paren
op_logical_or
id|hostdata-&gt;connected
)paren
(brace
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|ARB_PRINTK
c_func
(paren
l_string|&quot;scsi%d: lost arbitration, deasserting MR_ARBITRATE&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* after/during arbitration, BSY should be asserted.&n;&t;IBM DPES-31080 Version S31Q works now */
multiline_comment|/* Tnx to Thomas_Roesch@m2.maus.de for finding this! (Roman) */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_SEL
op_or
id|ICR_ASSERT_BSY
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|NCR5380_read
c_func
(paren
id|INITIATOR_COMMAND_REG
)paren
op_amp
id|ICR_ARBITRATION_LOST
)paren
op_logical_or
id|hostdata-&gt;connected
)paren
(brace
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|ARB_PRINTK
c_func
(paren
l_string|&quot;scsi%d: lost arbitration, deasserting ICR_ASSERT_SEL&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;     * Again, bus clear + bus settle time is 1.2us, however, this is &n;     * a minimum so we&squot;ll udelay ceil(1.2)&n;     */
macro_line|#ifdef CONFIG_ATARI_SCSI_TOSHIBA_DELAY
multiline_comment|/* ++roman: But some targets (see above :-) seem to need a bit more... */
id|udelay
c_func
(paren
l_int|15
)paren
suffix:semicolon
macro_line|#else
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|hostdata-&gt;connected
)paren
(brace
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ARB_PRINTK
c_func
(paren
l_string|&quot;scsi%d: won arbitration&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
multiline_comment|/* &n;     * Now that we have won arbitration, start Selection process, asserting &n;     * the host and target ID&squot;s on the SCSI bus.&n;     */
id|NCR5380_write
c_func
(paren
id|OUTPUT_DATA_REG
comma
(paren
id|hostdata-&gt;id_mask
op_or
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;     * Raise ATN while SEL is true before BSY goes false from arbitration,&n;     * since this is the only way to guarantee that we&squot;ll get a MESSAGE OUT&n;     * phase immediately after selection.&n;     */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
(paren
id|ICR_BASE
op_or
id|ICR_ASSERT_BSY
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_ATN
op_or
id|ICR_ASSERT_SEL
)paren
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
multiline_comment|/* &n;     * Reselect interrupts must be turned off prior to the dropping of BSY,&n;     * otherwise we will trigger an interrupt.&n;     */
r_if
c_cond
(paren
id|hostdata-&gt;connected
)paren
(brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;     * The initiator shall then wait at least two deskew delays and release &n;     * the BSY signal.&n;     */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* wingel -- wait two bus deskew delay &gt;2*45ns */
multiline_comment|/* Reset BSY */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
(paren
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_ATN
op_or
id|ICR_ASSERT_SEL
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;     * Something weird happens when we cease to drive BSY - looks&n;     * like the board/chip is letting us do another read before the &n;     * appropriate propagation delay has expired, and we&squot;re confusing&n;     * a BSY signal from ourselves as the target&squot;s response to SELECTION.&n;     *&n;     * A small delay (the &squot;C++&squot; frontend breaks the pipeline with an&n;     * unnecessary jump, making it work on my 386-33/Trantor T128, the&n;     * tighter &squot;C&squot; code breaks and requires this) solves the problem - &n;     * the 1 us delay is arbitrary, and only used because this delay will &n;     * be the same on other platforms and since it works here, it should &n;     * work there.&n;     *&n;     * wingel suggests that this could be due to failing to wait&n;     * one deskew delay.&n;     */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|SEL_PRINTK
c_func
(paren
l_string|&quot;scsi%d: selecting target %d&bslash;n&quot;
comma
id|HOSTNO
comma
id|cmd-&gt;target
)paren
suffix:semicolon
multiline_comment|/* &n;     * The SCSI specification calls for a 250 ms timeout for the actual &n;     * selection.&n;     */
id|timeout
op_assign
id|jiffies
op_plus
l_int|25
suffix:semicolon
multiline_comment|/* &n;     * XXX very interesting - we&squot;re seeing a bounce where the BSY we &n;     * asserted is being reflected / still asserted (propagation delay?)&n;     * and it&squot;s detecting as true.  Sigh.&n;     */
macro_line|#if 0
multiline_comment|/* ++roman: If a target conformed to the SCSI standard, it wouldn&squot;t assert&n;     * IO while SEL is true. But again, there are some disks out the in the&n;     * world that do that nevertheless. (Somebody claimed that this announces&n;     * reselection capability of the target.) So we better skip that test and&n;     * only wait for BSY... (Famous german words: Der Kl&#xfffd;gere gibt nach :-)&n;     */
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
op_logical_and
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
(paren
id|SR_BSY
op_or
id|SR_IO
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
(paren
id|SR_SEL
op_or
id|SR_IO
)paren
)paren
op_eq
(paren
id|SR_SEL
op_or
id|SR_IO
)paren
)paren
(brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|NCR5380_reselect
c_func
(paren
id|instance
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;scsi%d: reselection after won arbitration?&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#else
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
op_logical_and
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_BSY
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;     * No less than two deskew delays after the initiator detects the &n;     * BSY signal is true, it shall release the SEL signal and may &n;     * change the DATA BUS.                                     -wingel&n;     */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_BSY
)paren
)paren
(brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;targets_present
op_amp
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi%d: weirdness&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;restart_select
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;&bslash;trestart select&bslash;n&quot;
)paren
suffix:semicolon
id|NCR_PRINT
c_func
(paren
id|NDEBUG_ANY
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|cmd-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
macro_line|#ifdef NCR5380_STATS
id|collect_stats
c_func
(paren
id|hostdata
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SUPPORT_TAGS
id|cmd_free_tag
c_func
(paren
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
id|SEL_PRINTK
c_func
(paren
l_string|&quot;scsi%d: target did not respond within 250ms&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|hostdata-&gt;targets_present
op_or_assign
(paren
l_int|1
op_lshift
id|cmd-&gt;target
)paren
suffix:semicolon
multiline_comment|/*&n;     * Since we followed the SCSI spec, and raised ATN while SEL &n;     * was true but before BSY was false during selection, the information&n;     * transfer phase should be a MESSAGE OUT phase so that we can send the&n;     * IDENTIFY message.&n;     * &n;     * If SCSI-II tagged queuing is enabled, we also send a SIMPLE_QUEUE_TAG&n;     * message (2 bytes) with a tag ID that we increment with every command&n;     * until it wraps back to 0.&n;     *&n;     * XXX - it turns out that there are some broken SCSI-II devices,&n;     *&t;     which claim to support tagged queuing but fail when more than&n;     *&t;     some number of commands are issued at once.&n;     */
multiline_comment|/* Wait for start of REQ/ACK handshake */
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
)paren
suffix:semicolon
id|SEL_PRINTK
c_func
(paren
l_string|&quot;scsi%d: target %d selected, going into MESSAGE OUT phase.&bslash;n&quot;
comma
id|HOSTNO
comma
id|cmd-&gt;target
)paren
suffix:semicolon
id|tmp
(braket
l_int|0
)braket
op_assign
id|IDENTIFY
c_func
(paren
l_int|1
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#ifdef SUPPORT_TAGS
r_if
c_cond
(paren
id|cmd-&gt;tag
op_ne
id|TAG_NONE
)paren
(brace
id|tmp
(braket
l_int|1
)braket
op_assign
id|hostdata-&gt;last_message
op_assign
id|SIMPLE_QUEUE_TAG
suffix:semicolon
id|tmp
(braket
l_int|2
)braket
op_assign
id|cmd-&gt;tag
suffix:semicolon
id|len
op_assign
l_int|3
suffix:semicolon
)brace
r_else
id|len
op_assign
l_int|1
suffix:semicolon
macro_line|#else
id|len
op_assign
l_int|1
suffix:semicolon
id|cmd-&gt;tag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* SUPPORT_TAGS */
multiline_comment|/* Send message(s) */
id|data
op_assign
id|tmp
suffix:semicolon
id|phase
op_assign
id|PHASE_MSGOUT
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
id|SEL_PRINTK
c_func
(paren
l_string|&quot;scsi%d: nexus established.&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
multiline_comment|/* XXX need to handle errors here */
id|hostdata-&gt;connected
op_assign
id|cmd
suffix:semicolon
macro_line|#ifndef SUPPORT_TAGS
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#endif    
id|initialize_SCp
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : int NCR5380_transfer_pio (struct Scsi_Host *instance, &n; *      unsigned char *phase, int *count, unsigned char **data)&n; *&n; * Purpose : transfers data in given phase using polled I/O&n; *&n; * Inputs : instance - instance of driver, *phase - pointer to &n; *&t;what phase is expected, *count - pointer to number of &n; *&t;bytes to transfer, **data - pointer to data pointer.&n; * &n; * Returns : -1 when different phase is entered without transferring&n; *&t;maximum number of bytes, 0 if all bytes are transfered or exit&n; *&t;is in same phase.&n; *&n; * &t;Also, *phase, *count, *data are modified in place.&n; *&n; * XXX Note : handling for bus free may be useful.&n; */
multiline_comment|/*&n; * Note : this code is not as quick as it could be, however it &n; * IS 100% reliable, and for the actual data transfer where speed&n; * counts, we will always do a pseudo DMA or DMA transfer.&n; */
DECL|function|NCR5380_transfer_pio
r_static
r_int
id|NCR5380_transfer_pio
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
r_char
op_star
id|phase
comma
r_int
op_star
id|count
comma
r_int
r_char
op_star
op_star
id|data
)paren
(brace
r_register
r_int
r_char
id|p
op_assign
op_star
id|phase
comma
id|tmp
suffix:semicolon
r_register
r_int
id|c
op_assign
op_star
id|count
suffix:semicolon
r_register
r_int
r_char
op_star
id|d
op_assign
op_star
id|data
suffix:semicolon
multiline_comment|/* &n;     * The NCR5380 chip will only drive the SCSI bus when the &n;     * phase specified in the appropriate bits of the TARGET COMMAND&n;     * REGISTER match the STATUS REGISTER&n;     */
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* &n;&t; * Wait for assertion of REQ, after which the phase bits will be &n;&t; * valid &n;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
op_amp
id|SR_REQ
)paren
)paren
suffix:semicolon
id|HSH_PRINTK
c_func
(paren
l_string|&quot;scsi%d: REQ detected&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
multiline_comment|/* Check for phase mismatch */
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|PHASE_MASK
)paren
op_ne
id|p
)paren
(brace
id|PIO_PRINTK
c_func
(paren
l_string|&quot;scsi%d: phase mismatch&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|NCR_PRINT_PHASE
c_func
(paren
id|NDEBUG_PIO
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Do actual transfer from SCSI bus to / from memory */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_amp
id|SR_IO
)paren
)paren
id|NCR5380_write
c_func
(paren
id|OUTPUT_DATA_REG
comma
op_star
id|d
)paren
suffix:semicolon
r_else
op_star
id|d
op_assign
id|NCR5380_read
c_func
(paren
id|CURRENT_SCSI_DATA_REG
)paren
suffix:semicolon
op_increment
id|d
suffix:semicolon
multiline_comment|/* &n;&t; * The SCSI standard suggests that in MSGOUT phase, the initiator&n;&t; * should drop ATN on the last byte of the message phase&n;&t; * after REQ has been asserted for the handshake but before&n;&t; * the initiator raises ACK.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_amp
id|SR_IO
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|p
op_amp
id|SR_MSG
)paren
op_logical_and
id|c
OG
l_int|1
)paren
)paren
(brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
)paren
suffix:semicolon
id|NCR_PRINT
c_func
(paren
id|NDEBUG_PIO
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_ACK
)paren
suffix:semicolon
)brace
r_else
(brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
id|NCR_PRINT
c_func
(paren
id|NDEBUG_PIO
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
op_or
id|ICR_ASSERT_ATN
op_or
id|ICR_ASSERT_ACK
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|NCR_PRINT
c_func
(paren
id|NDEBUG_PIO
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ACK
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
suffix:semicolon
id|HSH_PRINTK
c_func
(paren
l_string|&quot;scsi%d: req false, handshake complete&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
multiline_comment|/*&n; * We have several special cases to consider during REQ/ACK handshaking : &n; * 1.  We were in MSGOUT phase, and we are on the last byte of the &n; *&t;message.  ATN must be dropped as ACK is dropped.&n; *&n; * 2.  We are in a MSGIN phase, and we are on the last byte of the  &n; *&t;message.  We must exit with ACK asserted, so that the calling&n; *&t;code may raise ATN before dropping ACK to reject the message.&n; *&n; * 3.  ACK and ATN are clear and the target may proceed as normal.&n; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_eq
id|PHASE_MSGIN
op_logical_and
id|c
op_eq
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
id|PHASE_MSGOUT
op_logical_and
id|c
OG
l_int|1
)paren
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
r_else
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_decrement
id|c
)paren
suffix:semicolon
id|PIO_PRINTK
c_func
(paren
l_string|&quot;scsi%d: residual %d&bslash;n&quot;
comma
id|HOSTNO
comma
id|c
)paren
suffix:semicolon
op_star
id|count
op_assign
id|c
suffix:semicolon
op_star
id|data
op_assign
id|d
suffix:semicolon
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
suffix:semicolon
multiline_comment|/* The phase read from the bus is valid if either REQ is (already)&n;     * asserted or if ACK hasn&squot;t been released yet. The latter is the case if&n;     * we&squot;re in MSGIN and all wanted bytes have been received. */
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|SR_REQ
)paren
op_logical_or
(paren
id|p
op_eq
id|PHASE_MSGIN
op_logical_and
id|c
op_eq
l_int|0
)paren
)paren
op_star
id|phase
op_assign
id|tmp
op_amp
id|PHASE_MASK
suffix:semicolon
r_else
op_star
id|phase
op_assign
id|PHASE_UNKNOWN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
op_logical_or
(paren
op_star
id|phase
op_eq
id|p
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : do_abort (Scsi_Host *host)&n; * &n; * Purpose : abort the currently established nexus.  Should only be &n; * &t;called from a routine which can drop into a &n; * &n; * Returns : 0 on success, -1 on failure.&n; */
DECL|function|do_abort
r_static
r_int
id|do_abort
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_int
r_char
id|tmp
comma
op_star
id|msgptr
comma
id|phase
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* Request message out phase */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
multiline_comment|/* &n;     * Wait for the target to indicate a valid phase by asserting &n;     * REQ.  Once this happens, we&squot;ll have either a MSGOUT phase &n;     * and can immediately send the ABORT message, or we&squot;ll have some &n;     * other phase and will have to source/sink data.&n;     * &n;     * We really don&squot;t care what value was on the bus or what value&n;     * the target sees, so we just handshake.&n;     */
r_while
c_loop
(paren
op_logical_neg
(paren
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
op_amp
id|SR_REQ
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|PHASE_MASK
)paren
op_ne
id|PHASE_MSGOUT
)paren
(brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
op_or
id|ICR_ASSERT_ACK
)paren
suffix:semicolon
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
)brace
id|tmp
op_assign
id|ABORT
suffix:semicolon
id|msgptr
op_assign
op_amp
id|tmp
suffix:semicolon
id|len
op_assign
l_int|1
suffix:semicolon
id|phase
op_assign
id|PHASE_MSGOUT
suffix:semicolon
id|NCR5380_transfer_pio
(paren
id|host
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|msgptr
)paren
suffix:semicolon
multiline_comment|/*&n;     * If we got here, and the command completed successfully,&n;     * we&squot;re about to go into bus free state.&n;     */
r_return
id|len
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#if defined(REAL_DMA)
multiline_comment|/* &n; * Function : int NCR5380_transfer_dma (struct Scsi_Host *instance, &n; *      unsigned char *phase, int *count, unsigned char **data)&n; *&n; * Purpose : transfers data in given phase using either real&n; *&t;or pseudo DMA.&n; *&n; * Inputs : instance - instance of driver, *phase - pointer to &n; *&t;what phase is expected, *count - pointer to number of &n; *&t;bytes to transfer, **data - pointer to data pointer.&n; * &n; * Returns : -1 when different phase is entered without transferring&n; *&t;maximum number of bytes, 0 if all bytes or transfered or exit&n; *&t;is in same phase.&n; *&n; * &t;Also, *phase, *count, *data are modified in place.&n; *&n; */
DECL|function|NCR5380_transfer_dma
r_static
r_int
id|NCR5380_transfer_dma
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|instance
comma
r_int
r_char
op_star
id|phase
comma
r_int
op_star
id|count
comma
r_int
r_char
op_star
op_star
id|data
)paren
(brace
id|SETUP_HOSTDATA
c_func
(paren
id|instance
)paren
suffix:semicolon
r_register
r_int
id|c
op_assign
op_star
id|count
suffix:semicolon
r_register
r_int
r_char
id|p
op_assign
op_star
id|phase
suffix:semicolon
r_register
r_int
r_char
op_star
id|d
op_assign
op_star
id|data
suffix:semicolon
r_int
r_char
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_assign
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|PHASE_MASK
)paren
)paren
op_ne
id|p
)paren
(brace
op_star
id|phase
op_assign
id|tmp
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atari_read_overruns
op_logical_and
(paren
id|p
op_amp
id|SR_IO
)paren
)paren
(brace
id|c
op_sub_assign
id|atari_read_overruns
suffix:semicolon
)brace
id|DMA_PRINTK
c_func
(paren
l_string|&quot;scsi%d: initializing DMA for %s, %d bytes %s %p&bslash;n&quot;
comma
id|HOSTNO
comma
(paren
id|p
op_amp
id|SR_IO
)paren
ques
c_cond
l_string|&quot;reading&quot;
suffix:colon
l_string|&quot;writing&quot;
comma
id|c
comma
(paren
id|p
op_amp
id|SR_IO
)paren
ques
c_cond
l_string|&quot;to&quot;
suffix:colon
l_string|&quot;from&quot;
comma
id|d
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
macro_line|#ifdef REAL_DMA
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
op_or
id|MR_DMA_MODE
op_or
id|MR_ENABLE_EOP_INTR
op_or
id|MR_MONITOR_BSY
)paren
suffix:semicolon
macro_line|#endif /* def REAL_DMA  */
r_if
c_cond
(paren
id|IS_A_TT
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* On the Medusa, it is a must to initialize the DMA before&n;&t; * starting the NCR. This is also the cleaner way for the TT.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|hostdata-&gt;dma_len
op_assign
(paren
id|p
op_amp
id|SR_IO
)paren
ques
c_cond
id|NCR5380_dma_read_setup
c_func
(paren
id|instance
comma
id|d
comma
id|c
)paren
suffix:colon
id|NCR5380_dma_write_setup
c_func
(paren
id|instance
comma
id|d
comma
id|c
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
op_amp
id|SR_IO
)paren
id|NCR5380_write
c_func
(paren
id|START_DMA_INITIATOR_RECEIVE_REG
comma
l_int|0
)paren
suffix:semicolon
r_else
(brace
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_DATA
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|START_DMA_SEND_REG
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|IS_A_TT
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* On the Falcon, the DMA setup must be done after the last */
multiline_comment|/* NCR access, else the DMA setup gets trashed!&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|hostdata-&gt;dma_len
op_assign
(paren
id|p
op_amp
id|SR_IO
)paren
ques
c_cond
id|NCR5380_dma_read_setup
c_func
(paren
id|instance
comma
id|d
comma
id|c
)paren
suffix:colon
id|NCR5380_dma_write_setup
c_func
(paren
id|instance
comma
id|d
comma
id|c
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* defined(REAL_DMA) */
multiline_comment|/*&n; * Function : NCR5380_information_transfer (struct Scsi_Host *instance)&n; *&n; * Purpose : run through the various SCSI phases and do as the target &n; * &t;directs us to.  Operates on the currently connected command, &n; *&t;instance-&gt;connected.&n; *&n; * Inputs : instance, instance for which we are doing commands&n; *&n; * Side effects : SCSI things happen, the disconnected queue will be &n; *&t;modified if a command disconnects, *instance-&gt;connected will&n; *&t;change.&n; *&n; * XXX Note : we need to watch for bus free or a reset condition here &n; * &t;to recover from an unexpected bus free condition.&n; */
DECL|function|NCR5380_information_transfer
r_static
r_void
id|NCR5380_information_transfer
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
id|SETUP_HOSTDATA
c_func
(paren
id|instance
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|msgout
op_assign
id|NOP
suffix:semicolon
r_int
id|sink
op_assign
l_int|0
suffix:semicolon
r_int
id|len
suffix:semicolon
macro_line|#if defined(REAL_DMA)
r_int
id|transfersize
suffix:semicolon
macro_line|#endif
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
r_char
id|phase
comma
id|tmp
comma
id|extended_msg
(braket
l_int|10
)braket
comma
id|old_phase
op_assign
l_int|0xff
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;connected
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|tmp
op_assign
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
suffix:semicolon
multiline_comment|/* We only have a valid SCSI phase when REQ is asserted */
r_if
c_cond
(paren
id|tmp
op_amp
id|SR_REQ
)paren
(brace
id|phase
op_assign
(paren
id|tmp
op_amp
id|PHASE_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|phase
op_ne
id|old_phase
)paren
(brace
id|old_phase
op_assign
id|phase
suffix:semicolon
id|NCR_PRINT_PHASE
c_func
(paren
id|NDEBUG_INFORMATION
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sink
op_logical_and
(paren
id|phase
op_ne
id|PHASE_MSGOUT
)paren
)paren
(brace
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
op_or
id|ICR_ASSERT_ACK
)paren
suffix:semicolon
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
id|sink
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|phase
)paren
(brace
r_case
id|PHASE_DATAOUT
suffix:colon
macro_line|#if (NDEBUG &amp; NDEBUG_NO_DATAOUT)
id|printk
c_func
(paren
l_string|&quot;scsi%d: NDEBUG_NO_DATAOUT set, attempted DATAOUT &quot;
l_string|&quot;aborted&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|sink
op_assign
l_int|1
suffix:semicolon
id|do_abort
c_func
(paren
id|instance
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif
r_case
id|PHASE_DATAIN
suffix:colon
multiline_comment|/* &n;&t;&t; * If there is no room left in the current buffer in the&n;&t;&t; * scatter-gather list, move onto the next one.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;SCp.this_residual
op_logical_and
id|cmd-&gt;SCp.buffers_residual
)paren
(brace
op_increment
id|cmd-&gt;SCp.buffer
suffix:semicolon
op_decrement
id|cmd-&gt;SCp.buffers_residual
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|cmd-&gt;SCp.buffer-&gt;address
suffix:semicolon
multiline_comment|/* ++roman: Try to merge some scatter-buffers if&n;&t;&t;     * they are at contiguous physical addresses.&n;&t;&t;     */
id|merge_contiguous_buffers
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|INF_PRINTK
c_func
(paren
l_string|&quot;scsi%d: %d bytes and %d buffers left&bslash;n&quot;
comma
id|HOSTNO
comma
id|cmd-&gt;SCp.this_residual
comma
id|cmd-&gt;SCp.buffers_residual
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The preferred transfer method is going to be &n;&t;&t; * PSEUDO-DMA for systems that are strictly PIO,&n;&t;&t; * since we can let the hardware do the handshaking.&n;&t;&t; *&n;&t;&t; * For this to work, we need to know the transfersize&n;&t;&t; * ahead of time, since the pseudo-DMA code will sit&n;&t;&t; * in an unconditional loop.&n;&t;&t; */
multiline_comment|/* ++roman: I suggest, this should be&n; *   #if def(REAL_DMA)&n; * instead of leaving REAL_DMA out.&n; */
macro_line|#if defined(REAL_DMA)
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;device-&gt;borken
op_logical_and
(paren
id|transfersize
op_assign
id|NCR5380_dma_xfer_len
c_func
(paren
id|instance
comma
id|cmd
comma
id|phase
)paren
)paren
OG
l_int|31
)paren
(brace
id|len
op_assign
id|transfersize
suffix:semicolon
id|cmd-&gt;SCp.phase
op_assign
id|phase
suffix:semicolon
r_if
c_cond
(paren
id|NCR5380_transfer_dma
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
(paren
r_int
r_char
op_star
op_star
)paren
op_amp
id|cmd-&gt;SCp.ptr
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If the watchdog timer fires, all future&n;&t;&t;&t; * accesses to this device will use the&n;&t;&t;&t; * polled-IO. */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;scsi%d: switching target %d &quot;
l_string|&quot;lun %d to slow handshake&bslash;n&quot;
comma
id|HOSTNO
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|cmd-&gt;device-&gt;borken
op_assign
l_int|1
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
id|sink
op_assign
l_int|1
suffix:semicolon
id|do_abort
c_func
(paren
id|instance
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/* XXX - need to source or sink data here, as appropriate */
)brace
r_else
(brace
macro_line|#ifdef REAL_DMA
multiline_comment|/* ++roman: When using real DMA,&n;&t;&t;&t; * information_transfer() should return after&n;&t;&t;&t; * starting DMA since it has nothing more to&n;&t;&t;&t; * do.&n;&t;&t;&t; */
r_return
suffix:semicolon
macro_line|#else&t;&t;&t;
id|cmd-&gt;SCp.this_residual
op_sub_assign
id|transfersize
op_minus
id|len
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
macro_line|#endif /* defined(REAL_DMA) */
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
(paren
r_int
op_star
)paren
op_amp
id|cmd-&gt;SCp.this_residual
comma
(paren
r_int
r_char
op_star
op_star
)paren
op_amp
id|cmd-&gt;SCp.ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PHASE_MSGIN
suffix:colon
id|len
op_assign
l_int|1
suffix:semicolon
id|data
op_assign
op_amp
id|tmp
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable reselects */
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
id|cmd-&gt;SCp.Message
op_assign
id|tmp
suffix:semicolon
r_switch
c_cond
(paren
id|tmp
)paren
(brace
multiline_comment|/*&n;&t;&t; * Linking lets us reduce the time required to get the &n;&t;&t; * next command out to the device, hopefully this will&n;&t;&t; * mean we don&squot;t waste another revolution due to the delays&n;&t;&t; * required by ARBITRATION and another SELECTION.&n;&t;&t; *&n;&t;&t; * In the current implementation proposal, low level drivers&n;&t;&t; * merely have to start the next command, pointed to by &n;&t;&t; * next_link, done() is called as with unlinked commands.&n;&t;&t; */
macro_line|#ifdef LINKED
r_case
id|LINKED_CMD_COMPLETE
suffix:colon
r_case
id|LINKED_FLG_CMD_COMPLETE
suffix:colon
multiline_comment|/* Accept message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|LNK_PRINTK
c_func
(paren
l_string|&quot;scsi%d: target %d lun %d linked command &quot;
l_string|&quot;complete.&bslash;n&quot;
comma
id|HOSTNO
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
multiline_comment|/* Enable reselect interrupts */
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;     * Sanity check : A linked command should only terminate&n;&t;&t;     * with one of these messages if there are more linked&n;&t;&t;     * commands available.&n;&t;&t;     */
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;next_link
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;scsi%d: target %d lun %d &quot;
l_string|&quot;linked command complete, no next_link&bslash;n&quot;
comma
id|HOSTNO
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|sink
op_assign
l_int|1
suffix:semicolon
id|do_abort
(paren
id|instance
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|initialize_SCp
c_func
(paren
id|cmd-&gt;next_link
)paren
suffix:semicolon
multiline_comment|/* The next command is still part of this process; copy it&n;&t;&t;     * and don&squot;t free it! */
id|cmd-&gt;next_link-&gt;tag
op_assign
id|cmd-&gt;tag
suffix:semicolon
id|cmd-&gt;result
op_assign
id|cmd-&gt;SCp.Status
op_or
(paren
id|cmd-&gt;SCp.Message
op_lshift
l_int|8
)paren
suffix:semicolon
id|LNK_PRINTK
c_func
(paren
l_string|&quot;scsi%d: target %d lun %d linked request &quot;
l_string|&quot;done, calling scsi_done().&bslash;n&quot;
comma
id|HOSTNO
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#ifdef NCR5380_STATS
id|collect_stats
c_func
(paren
id|hostdata
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|cmd
op_assign
id|hostdata-&gt;connected
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* def LINKED */
r_case
id|ABORT
suffix:colon
r_case
id|COMMAND_COMPLETE
suffix:colon
multiline_comment|/* Accept message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
multiline_comment|/* ++guenther: possible race with Falcon locking */
id|falcon_dont_release
op_increment
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|QU_PRINTK
c_func
(paren
l_string|&quot;scsi%d: command for target %d, lun %d &quot;
l_string|&quot;completed&bslash;n&quot;
comma
id|HOSTNO
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#ifdef SUPPORT_TAGS
id|cmd_free_tag
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status_byte
c_func
(paren
id|cmd-&gt;SCp.Status
)paren
op_eq
id|QUEUE_FULL
)paren
(brace
multiline_comment|/* Turn a QUEUE FULL status into BUSY, I think the&n;&t;&t;&t; * mid level cannot handle QUEUE FULL :-( (The&n;&t;&t;&t; * command is retried after BUSY). Also update our&n;&t;&t;&t; * queue size to the number of currently issued&n;&t;&t;&t; * commands now.&n;&t;&t;&t; */
multiline_comment|/* ++Andreas: the mid level code knows about&n;&t;&t;&t;   QUEUE_FULL now. */
id|TAG_ALLOC
op_star
id|ta
op_assign
op_amp
id|TagAlloc
(braket
id|cmd-&gt;target
)braket
(braket
id|cmd-&gt;lun
)braket
suffix:semicolon
id|TAG_PRINTK
c_func
(paren
l_string|&quot;scsi%d: target %d lun %d returned &quot;
l_string|&quot;QUEUE_FULL after %d commands&bslash;n&quot;
comma
id|HOSTNO
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|ta-&gt;nr_allocated
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ta-&gt;queue_size
OG
id|ta-&gt;nr_allocated
)paren
id|ta-&gt;nr_allocated
op_assign
id|ta-&gt;queue_size
suffix:semicolon
)brace
macro_line|#else
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Enable reselect interrupts */
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;     * I&squot;m not sure what the correct thing to do here is : &n;&t;&t;     * &n;&t;&t;     * If the command that just executed is NOT a request &n;&t;&t;     * sense, the obvious thing to do is to set the result&n;&t;&t;     * code to the values of the stored parameters.&n;&t;&t;     * &n;&t;&t;     * If it was a REQUEST SENSE command, we need some way to&n;&t;&t;     * differentiate between the failure code of the original&n;&t;&t;     * and the failure code of the REQUEST sense - the obvious&n;&t;&t;     * case is success, where we fall through and leave the&n;&t;&t;     * result code unchanged.&n;&t;&t;     * &n;&t;&t;     * The non-obvious place is where the REQUEST SENSE failed&n;&t;&t;     */
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|REQUEST_SENSE
)paren
id|cmd-&gt;result
op_assign
id|cmd-&gt;SCp.Status
op_or
(paren
id|cmd-&gt;SCp.Message
op_lshift
l_int|8
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|status_byte
c_func
(paren
id|cmd-&gt;SCp.Status
)paren
op_ne
id|GOOD
)paren
id|cmd-&gt;result
op_assign
(paren
id|cmd-&gt;result
op_amp
l_int|0x00ffff
)paren
op_or
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
macro_line|#ifdef AUTOSENSE
r_if
c_cond
(paren
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|REQUEST_SENSE
)paren
op_logical_and
(paren
id|status_byte
c_func
(paren
id|cmd-&gt;SCp.Status
)paren
op_eq
id|CHECK_CONDITION
)paren
)paren
(brace
id|ASEN_PRINTK
c_func
(paren
l_string|&quot;scsi%d: performing request sense&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
op_and_assign
l_int|0xe0
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|cmd-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* this is initialized from initialize_SCp &n;&t;&t;&t;cmd-&gt;SCp.buffer = NULL;&n;&t;&t;&t;cmd-&gt;SCp.buffers_residual = 0;&n;&t;&t;&t;*/
id|cmd-&gt;request_buffer
op_assign
(paren
r_char
op_star
)paren
id|cmd-&gt;sense_buffer
suffix:semicolon
id|cmd-&gt;request_bufflen
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|LIST
c_func
(paren
id|cmd
comma
id|hostdata-&gt;issue_queue
)paren
suffix:semicolon
id|NEXT
c_func
(paren
id|cmd
)paren
op_assign
id|hostdata-&gt;issue_queue
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|QU_PRINTK
c_func
(paren
l_string|&quot;scsi%d: REQUEST SENSE added to head of &quot;
l_string|&quot;issue queue&bslash;n&quot;
comma
id|H_NO
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif /* def AUTOSENSE */
(brace
macro_line|#ifdef NCR5380_STATS
id|collect_stats
c_func
(paren
id|hostdata
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;     * Restore phase bits to 0 so an interrupted selection, &n;&t;&t;     * arbitration can resume.&n;&t;&t;     */
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_BSY
)paren
op_logical_and
op_logical_neg
id|hostdata-&gt;connected
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|falcon_dont_release
op_decrement
suffix:semicolon
multiline_comment|/* ++roman: For Falcon SCSI, release the lock on the&n;&t;&t;     * ST-DMA here if no other commands are waiting on the&n;&t;&t;     * disconnected queue.&n;&t;&t;     */
id|falcon_release_lock_if_possible
c_func
(paren
id|hostdata
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|MESSAGE_REJECT
suffix:colon
multiline_comment|/* Accept message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
multiline_comment|/* Enable reselect interrupts */
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hostdata-&gt;last_message
)paren
(brace
r_case
id|HEAD_OF_QUEUE_TAG
suffix:colon
r_case
id|ORDERED_QUEUE_TAG
suffix:colon
r_case
id|SIMPLE_QUEUE_TAG
suffix:colon
multiline_comment|/* The target obviously doesn&squot;t support tagged&n;&t;&t;&t; * queuing, even though it announced this ability in&n;&t;&t;&t; * its INQUIRY data ?!? (maybe only this LUN?) Ok,&n;&t;&t;&t; * clear &squot;tagged_supported&squot; and lock the LUN, since&n;&t;&t;&t; * the command is treated as untagged further on.&n;&t;&t;&t; */
id|cmd-&gt;device-&gt;tagged_supported
op_assign
l_int|0
suffix:semicolon
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
id|cmd-&gt;tag
op_assign
id|TAG_NONE
suffix:semicolon
id|TAG_PRINTK
c_func
(paren
l_string|&quot;scsi%d: target %d lun %d rejected &quot;
l_string|&quot;QUEUE_TAG message; tagged queuing &quot;
l_string|&quot;disabled&bslash;n&quot;
comma
id|HOSTNO
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISCONNECT
suffix:colon
multiline_comment|/* Accept message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|cmd-&gt;device-&gt;disconnect
op_assign
l_int|1
suffix:semicolon
id|LIST
c_func
(paren
id|cmd
comma
id|hostdata-&gt;disconnected_queue
)paren
suffix:semicolon
id|NEXT
c_func
(paren
id|cmd
)paren
op_assign
id|hostdata-&gt;disconnected_queue
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;disconnected_queue
op_assign
id|cmd
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|QU_PRINTK
c_func
(paren
l_string|&quot;scsi%d: command for target %d lun %d was &quot;
l_string|&quot;moved from connected to the &quot;
l_string|&quot;disconnected_queue&bslash;n&quot;
comma
id|HOSTNO
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;     * Restore phase bits to 0 so an interrupted selection, &n;&t;&t;     * arbitration can resume.&n;&t;&t;     */
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Enable reselect interrupts */
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
multiline_comment|/* Wait for bus free to avoid nasty timeouts */
r_while
c_loop
(paren
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_BSY
)paren
op_logical_and
op_logical_neg
id|hostdata-&gt;connected
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* &n;&t;&t; * The SCSI data pointer is *IMPLICITLY* saved on a disconnect&n;&t;&t; * operation, in violation of the SCSI spec so we can safely &n;&t;&t; * ignore SAVE/RESTORE pointers calls.&n;&t;&t; *&n;&t;&t; * Unfortunately, some disks violate the SCSI spec and &n;&t;&t; * don&squot;t issue the required SAVE_POINTERS message before&n;&t;&t; * disconnecting, and we have to break spec to remain &n;&t;&t; * compatible.&n;&t;&t; */
r_case
id|SAVE_POINTERS
suffix:colon
r_case
id|RESTORE_POINTERS
suffix:colon
multiline_comment|/* Accept message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
multiline_comment|/* Enable reselect interrupts */
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EXTENDED_MESSAGE
suffix:colon
multiline_comment|/* &n; * Extended messages are sent in the following format :&n; * Byte &t;&n; * 0&t;&t;EXTENDED_MESSAGE == 1&n; * 1&t;&t;length (includes one byte for code, doesn&squot;t &n; *&t;&t;include first two bytes)&n; * 2 &t;&t;code&n; * 3..length+1&t;arguments&n; *&n; * Start the extended message buffer with the EXTENDED_MESSAGE&n; * byte, since print_msg() wants the whole thing.  &n; */
id|extended_msg
(braket
l_int|0
)braket
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
multiline_comment|/* Accept first byte by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|EXT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: receiving extended message&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|len
op_assign
l_int|2
suffix:semicolon
id|data
op_assign
id|extended_msg
op_plus
l_int|1
suffix:semicolon
id|phase
op_assign
id|PHASE_MSGIN
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
id|EXT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: length=%d, code=0x%02x&bslash;n&quot;
comma
id|HOSTNO
comma
(paren
r_int
)paren
id|extended_msg
(braket
l_int|1
)braket
comma
(paren
r_int
)paren
id|extended_msg
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_and
id|extended_msg
(braket
l_int|1
)braket
op_le
(paren
r_sizeof
(paren
id|extended_msg
)paren
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* Accept third byte by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|len
op_assign
id|extended_msg
(braket
l_int|1
)braket
op_minus
l_int|1
suffix:semicolon
id|data
op_assign
id|extended_msg
op_plus
l_int|3
suffix:semicolon
id|phase
op_assign
id|PHASE_MSGIN
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
id|EXT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: message received, residual %d&bslash;n&quot;
comma
id|HOSTNO
comma
id|len
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|extended_msg
(braket
l_int|2
)braket
)paren
(brace
r_case
id|EXTENDED_SDTR
suffix:colon
r_case
id|EXTENDED_WDTR
suffix:colon
r_case
id|EXTENDED_MODIFY_DATA_POINTER
suffix:colon
r_case
id|EXTENDED_EXTENDED_IDENTIFY
suffix:colon
id|tmp
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|len
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;scsi%d: error receiving &quot;
l_string|&quot;extended message&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|tmp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;scsi%d: extended message &quot;
l_string|&quot;code %02x length %d is too long&bslash;n&quot;
comma
id|HOSTNO
comma
id|extended_msg
(braket
l_int|2
)braket
comma
id|extended_msg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|tmp
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Fall through to reject message */
multiline_comment|/* &n;  &t;&t; * If we get something weird that we aren&squot;t expecting, &n; &t;&t; * reject it.&n;&t;&t; */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;scsi%d: rejecting message &quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|print_msg
(paren
id|extended_msg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tmp
op_ne
id|EXTENDED_MESSAGE
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;scsi%d: rejecting unknown &quot;
l_string|&quot;message %02x from target %d, lun %d&bslash;n&quot;
comma
id|HOSTNO
comma
id|tmp
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;scsi%d: rejecting unknown &quot;
l_string|&quot;extended message &quot;
l_string|&quot;code %02x, length %d from target %d, lun %d&bslash;n&quot;
comma
id|HOSTNO
comma
id|extended_msg
(braket
l_int|1
)braket
comma
id|extended_msg
(braket
l_int|0
)braket
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|msgout
op_assign
id|MESSAGE_REJECT
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_ATN
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* switch (tmp) */
r_break
suffix:semicolon
r_case
id|PHASE_MSGOUT
suffix:colon
id|len
op_assign
l_int|1
suffix:semicolon
id|data
op_assign
op_amp
id|msgout
suffix:semicolon
id|hostdata-&gt;last_message
op_assign
id|msgout
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msgout
op_eq
id|ABORT
)paren
(brace
macro_line|#ifdef SUPPORT_TAGS
id|cmd_free_tag
c_func
(paren
id|cmd
)paren
suffix:semicolon
macro_line|#else
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
macro_line|#ifdef NCR5380_STATS
id|collect_stats
c_func
(paren
id|hostdata
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
id|falcon_release_lock_if_possible
c_func
(paren
id|hostdata
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|msgout
op_assign
id|NOP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PHASE_CMDOUT
suffix:colon
id|len
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|data
op_assign
id|cmd-&gt;cmnd
suffix:semicolon
multiline_comment|/* &n;&t;&t; * XXX for performance reasons, on machines with a &n;&t;&t; * PSEUDO-DMA architecture we should probably &n;&t;&t; * use the dma transfer function.  &n;&t;&t; */
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PHASE_STATIN
suffix:colon
id|len
op_assign
l_int|1
suffix:semicolon
id|data
op_assign
op_amp
id|tmp
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
id|cmd-&gt;SCp.Status
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d: unknown phase&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|NCR_PRINT
c_func
(paren
id|NDEBUG_ANY
)paren
suffix:semicolon
)brace
multiline_comment|/* switch(phase) */
)brace
multiline_comment|/* if (tmp * SR_REQ) */
)brace
multiline_comment|/* while (1) */
)brace
multiline_comment|/*&n; * Function : void NCR5380_reselect (struct Scsi_Host *instance)&n; *&n; * Purpose : does reselection, initializing the instance-&gt;connected &n; *&t;field to point to the Scsi_Cmnd for which the I_T_L or I_T_L_Q &n; *&t;nexus has been reestablished,&n; *&t;&n; * Inputs : instance - this instance of the NCR5380.&n; *&n; */
DECL|function|NCR5380_reselect
r_static
r_void
id|NCR5380_reselect
(paren
r_struct
id|Scsi_Host
op_star
id|instance
)paren
(brace
id|SETUP_HOSTDATA
c_func
(paren
id|instance
)paren
suffix:semicolon
r_int
r_char
id|target_mask
suffix:semicolon
r_int
r_char
id|lun
comma
id|phase
suffix:semicolon
r_int
id|len
suffix:semicolon
macro_line|#ifdef SUPPORT_TAGS
r_int
r_char
id|tag
suffix:semicolon
macro_line|#endif
r_int
r_char
id|msg
(braket
l_int|3
)braket
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
op_assign
l_int|NULL
comma
op_star
id|prev
suffix:semicolon
multiline_comment|/*    unsigned long flags; */
multiline_comment|/*&n;     * Disable arbitration, etc. since the host adapter obviously&n;     * lost, and tell an interrupted NCR5380_select() to restart.&n;     */
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|hostdata-&gt;restart_select
op_assign
l_int|1
suffix:semicolon
id|target_mask
op_assign
id|NCR5380_read
c_func
(paren
id|CURRENT_SCSI_DATA_REG
)paren
op_amp
op_complement
(paren
id|hostdata-&gt;id_mask
)paren
suffix:semicolon
id|RSL_PRINTK
c_func
(paren
l_string|&quot;scsi%d: reselect&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
multiline_comment|/* &n;     * At this point, we have detected that our SCSI ID is on the bus,&n;     * SEL is true and BSY was false for at least one bus settle delay&n;     * (400 ns).&n;     *&n;     * We must assert BSY ourselves, until the target drops the SEL&n;     * signal.&n;     */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_BSY
)paren
suffix:semicolon
r_while
c_loop
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_SEL
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
multiline_comment|/*&n;     * Wait for target to go into MSGIN.&n;     */
r_while
c_loop
(paren
op_logical_neg
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
op_amp
id|SR_REQ
)paren
)paren
suffix:semicolon
id|len
op_assign
l_int|1
suffix:semicolon
id|data
op_assign
id|msg
suffix:semicolon
id|phase
op_assign
id|PHASE_MSGIN
suffix:semicolon
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msg
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;scsi%d: expecting IDENTIFY message, got &quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|print_msg
c_func
(paren
id|msg
)paren
suffix:semicolon
id|do_abort
c_func
(paren
id|instance
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lun
op_assign
(paren
id|msg
(braket
l_int|0
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
macro_line|#ifdef SUPPORT_TAGS
multiline_comment|/* If the phase is still MSGIN, the target wants to send some more&n;     * messages. In case it supports tagged queuing, this is probably a&n;     * SIMPLE_QUEUE_TAG for the I_T_L_Q nexus.&n;     */
id|tag
op_assign
id|TAG_NONE
suffix:semicolon
r_if
c_cond
(paren
id|phase
op_eq
id|PHASE_MSGIN
op_logical_and
id|setup_use_tagged_queuing
)paren
(brace
multiline_comment|/* Accept previous IDENTIFY message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|len
op_assign
l_int|2
suffix:semicolon
id|data
op_assign
id|msg
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NCR5380_transfer_pio
c_func
(paren
id|instance
comma
op_amp
id|phase
comma
op_amp
id|len
comma
op_amp
id|data
)paren
op_logical_and
id|msg
(braket
l_int|1
)braket
op_eq
id|SIMPLE_QUEUE_TAG
)paren
id|tag
op_assign
id|msg
(braket
l_int|2
)braket
suffix:semicolon
id|TAG_PRINTK
c_func
(paren
l_string|&quot;scsi%d: target mask %02x, lun %d sent tag %d at &quot;
l_string|&quot;reselection&bslash;n&quot;
comma
id|HOSTNO
comma
id|target_mask
comma
id|lun
comma
id|tag
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* &n;     * Find the command corresponding to the I_T_L or I_T_L_Q  nexus we &n;     * just reestablished, and remove it from the disconnected queue.&n;     */
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_queue
comma
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|tmp
suffix:semicolon
id|prev
op_assign
id|tmp
comma
id|tmp
op_assign
id|NEXT
c_func
(paren
id|tmp
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|target_mask
op_eq
(paren
l_int|1
op_lshift
id|tmp-&gt;target
)paren
)paren
op_logical_and
(paren
id|lun
op_eq
id|tmp-&gt;lun
)paren
macro_line|#ifdef SUPPORT_TAGS
op_logical_and
(paren
id|tag
op_eq
id|tmp-&gt;tag
)paren
macro_line|#endif
)paren
(brace
multiline_comment|/* ++guenther: prevent race with falcon_release_lock */
id|falcon_dont_release
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
(brace
id|REMOVE
c_func
(paren
id|prev
comma
id|NEXT
c_func
(paren
id|prev
)paren
comma
id|tmp
comma
id|NEXT
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|NEXT
c_func
(paren
id|prev
)paren
op_assign
id|NEXT
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
r_else
(brace
id|REMOVE
c_func
(paren
op_minus
l_int|1
comma
id|hostdata-&gt;disconnected_queue
comma
id|tmp
comma
id|NEXT
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|hostdata-&gt;disconnected_queue
op_assign
id|NEXT
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|NEXT
c_func
(paren
id|tmp
)paren
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi%d: warning: target bitmask %02x lun %d &quot;
macro_line|#ifdef SUPPORT_TAGS
l_string|&quot;tag %d &quot;
macro_line|#endif
l_string|&quot;not in disconnected_queue.&bslash;n&quot;
comma
id|HOSTNO
comma
id|target_mask
comma
id|lun
macro_line|#ifdef SUPPORT_TAGS
comma
id|tag
macro_line|#endif
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Since we have an established nexus that we can&squot;t do anything&n;&t; * with, we must abort it.  &n;&t; */
id|do_abort
c_func
(paren
id|instance
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Accept message by clearing ACK */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|hostdata-&gt;connected
op_assign
id|tmp
suffix:semicolon
id|RSL_PRINTK
c_func
(paren
l_string|&quot;scsi%d: nexus established, target = %d, lun = %d, tag = %d&bslash;n&quot;
comma
id|HOSTNO
comma
id|tmp-&gt;target
comma
id|tmp-&gt;lun
comma
id|tmp-&gt;tag
)paren
suffix:semicolon
id|falcon_dont_release
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n; * Function : int NCR5380_abort (Scsi_Cmnd *cmd)&n; *&n; * Purpose : abort a command&n; *&n; * Inputs : cmd - the Scsi_Cmnd to abort, code - code to set the &n; * &t;host byte of the result field to, if zero DID_ABORTED is &n; *&t;used.&n; *&n; * Returns : 0 - success, -1 on failure.&n; *&n; * XXX - there is no way to abort the command that is currently &n; * &t; connected, you have to wait for it to complete.  If this is &n; *&t; a problem, we could implement longjmp() / setjmp(), setjmp()&n; * &t; called where the loop started in NCR5380_main().&n; */
macro_line|#ifndef NCR5380_abort
r_static
macro_line|#endif
DECL|function|NCR5380_abort
r_int
id|NCR5380_abort
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|instance
op_assign
id|cmd-&gt;host
suffix:semicolon
id|SETUP_HOSTDATA
c_func
(paren
id|instance
)paren
suffix:semicolon
id|Scsi_Cmnd
op_star
id|tmp
comma
op_star
op_star
id|prev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;scsi%d: aborting command&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|print_Scsi_Cmnd
(paren
id|cmd
)paren
suffix:semicolon
id|NCR5380_print_status
(paren
id|instance
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_A_TT
c_func
(paren
)paren
op_logical_and
op_logical_neg
id|falcon_got_lock
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi%d: !!BINGO!! Falcon has no lock in NCR5380_abort&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|ABRT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: abort called basr 0x%02x, sr 0x%02x&bslash;n&quot;
comma
id|HOSTNO
comma
id|NCR5380_read
c_func
(paren
id|BUS_AND_STATUS_REG
)paren
comma
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
suffix:semicolon
macro_line|#if 1
multiline_comment|/* &n; * Case 1 : If the command is the currently executing command, &n; * we&squot;ll set the aborted flag and return control so that &n; * information transfer routine can exit cleanly.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;connected
op_eq
id|cmd
)paren
(brace
id|ABRT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: aborting connected command&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
multiline_comment|/*&n; * We should perform BSY checking, and make sure we haven&squot;t slipped&n; * into BUS FREE.&n; */
multiline_comment|/*&t;NCR5380_write(INITIATOR_COMMAND_REG, ICR_ASSERT_ATN); */
multiline_comment|/* &n; * Since we can&squot;t change phases until we&squot;ve completed the current &n; * handshake, we have to source or sink a byte of data if the current&n; * phase is not MSGOUT.&n; */
multiline_comment|/* &n; * Return control to the executing NCR drive so we can clear the&n; * aborted flag and get back into our main loop.&n; */
r_if
c_cond
(paren
id|do_abort
c_func
(paren
id|instance
)paren
op_eq
l_int|0
)paren
(brace
id|hostdata-&gt;aborted
op_assign
l_int|1
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
macro_line|#ifdef SUPPORT_TAGS
id|cmd_free_tag
c_func
(paren
id|cmd
)paren
suffix:semicolon
macro_line|#else
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|falcon_release_lock_if_possible
c_func
(paren
id|hostdata
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&t;  restore_flags(flags); */
id|printk
c_func
(paren
l_string|&quot;scsi%d: abort of connected command failed!&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_ERROR
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* &n; * Case 2 : If the command hasn&squot;t been issued yet, we simply remove it &n; * &t;    from the issue queue.&n; */
r_for
c_loop
(paren
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
id|hostdata-&gt;issue_queue
)paren
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;issue_queue
suffix:semicolon
id|tmp
suffix:semicolon
id|prev
op_assign
id|NEXTADDR
c_func
(paren
id|tmp
)paren
comma
id|tmp
op_assign
id|NEXT
c_func
(paren
id|tmp
)paren
)paren
r_if
c_cond
(paren
id|cmd
op_eq
id|tmp
)paren
(brace
id|REMOVE
c_func
(paren
l_int|5
comma
op_star
id|prev
comma
id|tmp
comma
id|NEXT
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
(paren
op_star
id|prev
)paren
op_assign
id|NEXT
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|NEXT
c_func
(paren
id|tmp
)paren
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ABRT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: abort removed command from issue queue.&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
multiline_comment|/* Tagged queuing note: no tag to free here, hasn&squot;t been assigned&n;&t;     * yet... */
id|tmp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|falcon_release_lock_if_possible
c_func
(paren
id|hostdata
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
multiline_comment|/* &n; * Case 3 : If any commands are connected, we&squot;re going to fail the abort&n; *&t;    and let the high level SCSI driver retry at a later time or &n; *&t;    issue a reset.&n; *&n; *&t;    Timeouts, and therefore aborted commands, will be highly unlikely&n; *          and handling them cleanly in this situation would make the common&n; *&t;    case of noresets less efficient, and would pollute our code.  So,&n; *&t;    we fail.&n; */
r_if
c_cond
(paren
id|hostdata-&gt;connected
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ABRT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: abort failed, command connected.&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
multiline_comment|/*&n; * Case 4: If the command is currently disconnected from the bus, and &n; * &t;there are no connected commands, we reconnect the I_T_L or &n; *&t;I_T_L_Q nexus associated with it, go into message out, and send &n; *      an abort message.&n; *&n; * This case is especially ugly. In order to reestablish the nexus, we&n; * need to call NCR5380_select().  The easiest way to implement this &n; * function was to abort if the bus was busy, and let the interrupt&n; * handler triggered on the SEL for reselect take care of lost arbitrations&n; * where necessary, meaning interrupts need to be enabled.&n; *&n; * When interrupts are enabled, the queues may change - so we &n; * can&squot;t remove it from the disconnected queue before selecting it&n; * because that could cause a failure in hashing the nexus if that &n; * device reselected.&n; * &n; * Since the queues may change, we can&squot;t use the pointers from when we&n; * first locate it.&n; *&n; * So, we must first locate the command, and if NCR5380_select()&n; * succeeds, then issue the abort, relocate the command and remove&n; * it from the disconnected queue.&n; */
r_for
c_loop
(paren
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_queue
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|NEXT
c_func
(paren
id|tmp
)paren
)paren
r_if
c_cond
(paren
id|cmd
op_eq
id|tmp
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ABRT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: aborting disconnected command.&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NCR5380_select
(paren
id|instance
comma
id|cmd
comma
(paren
r_int
)paren
id|cmd-&gt;tag
)paren
)paren
r_return
id|SCSI_ABORT_BUSY
suffix:semicolon
id|ABRT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: nexus reestablished.&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
id|do_abort
(paren
id|instance
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
id|hostdata-&gt;disconnected_queue
)paren
comma
id|tmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_queue
suffix:semicolon
id|tmp
suffix:semicolon
id|prev
op_assign
id|NEXTADDR
c_func
(paren
id|tmp
)paren
comma
id|tmp
op_assign
id|NEXT
c_func
(paren
id|tmp
)paren
)paren
r_if
c_cond
(paren
id|cmd
op_eq
id|tmp
)paren
(brace
id|REMOVE
c_func
(paren
l_int|5
comma
op_star
id|prev
comma
id|tmp
comma
id|NEXT
c_func
(paren
id|tmp
)paren
)paren
suffix:semicolon
op_star
id|prev
op_assign
id|NEXT
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|NEXT
c_func
(paren
id|tmp
)paren
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* We must unlock the tag/LUN immediately here, since the&n;&t;&t;     * target goes to BUS FREE and doesn&squot;t send us another&n;&t;&t;     * message (COMMAND_COMPLETE or the like)&n;&t;&t;     */
macro_line|#ifdef SUPPORT_TAGS
id|cmd_free_tag
c_func
(paren
id|tmp
)paren
suffix:semicolon
macro_line|#else
id|hostdata-&gt;busy
(braket
id|cmd-&gt;target
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cmd-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|tmp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|falcon_release_lock_if_possible
c_func
(paren
id|hostdata
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Case 5 : If we reached this point, the command was not found in any of &n; *&t;    the queues.&n; *&n; * We probably reached this point because of an unlikely race condition&n; * between the command completing successfully and the abortion code,&n; * so we won&squot;t panic, but we will notify the user in case something really&n; * broke.&n; */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi%d: warning : SCSI command probably completed successfully&bslash;n&quot;
id|KERN_INFO
l_string|&quot;        before abortion&bslash;n&quot;
comma
id|HOSTNO
)paren
suffix:semicolon
multiline_comment|/* Maybe it is sufficient just to release the ST-DMA lock... (if&n; * possible at all) At least, we should check if the lock could be&n; * released after the abort, in case it is kept due to some bug.&n; */
id|falcon_release_lock_if_possible
c_func
(paren
id|hostdata
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
multiline_comment|/* &n; * Function : int NCR5380_reset (Scsi_Cmnd *cmd, unsigned int reset_flags)&n; * &n; * Purpose : reset the SCSI bus.&n; *&n; * Returns : SCSI_RESET_WAKEUP&n; *&n; */
DECL|function|NCR5380_reset
r_static
r_int
id|NCR5380_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_int
id|reset_flags
)paren
(brace
id|SETUP_HOSTDATA
c_func
(paren
id|cmd-&gt;host
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if 1
id|Scsi_Cmnd
op_star
id|connected
comma
op_star
id|disconnected_queue
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|IS_A_TT
c_func
(paren
)paren
op_logical_and
op_logical_neg
id|falcon_got_lock
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi%d: !!BINGO!! Falcon has no lock in NCR5380_reset&bslash;n&quot;
comma
id|H_NO
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|NCR5380_print_status
(paren
id|cmd-&gt;host
)paren
suffix:semicolon
multiline_comment|/* get in phase */
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
id|PHASE_SR_TO_TCR
c_func
(paren
id|NCR5380_read
c_func
(paren
id|STATUS_REG
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* assert RST */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
op_or
id|ICR_ASSERT_RST
)paren
suffix:semicolon
id|udelay
(paren
l_int|40
)paren
suffix:semicolon
multiline_comment|/* reset NCR registers */
id|NCR5380_write
c_func
(paren
id|INITIATOR_COMMAND_REG
comma
id|ICR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|MODE_REG
comma
id|MR_BASE
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|TARGET_COMMAND_REG
comma
l_int|0
)paren
suffix:semicolon
id|NCR5380_write
c_func
(paren
id|SELECT_ENABLE_REG
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* ++roman: reset interrupt condition! otherwise no interrupts don&squot;t get&n;     * through anymore ... */
(paren
r_void
)paren
id|NCR5380_read
c_func
(paren
id|RESET_PARITY_INTERRUPT_REG
)paren
suffix:semicolon
macro_line|#if 1 /* XXX Should now be done by midlevel code, but it&squot;s broken XXX */
multiline_comment|/* XXX see below                                            XXX */
multiline_comment|/* MSch: old-style reset: actually abort all command processing here */
multiline_comment|/* After the reset, there are no more connected or disconnected commands&n;     * and no busy units; to avoid problems with re-inserting the commands&n;     * into the issue_queue (via scsi_done()), the aborted commands are&n;     * remembered in local variables first.&n;     */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|connected
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;connected
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|disconnected_queue
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|hostdata-&gt;disconnected_queue
suffix:semicolon
id|hostdata-&gt;disconnected_queue
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef SUPPORT_TAGS
id|free_all_tags
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
(brace
id|hostdata-&gt;busy
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef REAL_DMA
id|hostdata-&gt;dma_len
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* In order to tell the mid-level code which commands were aborted, &n;     * set the command status to DID_RESET and call scsi_done() !!!&n;     * This ultimately aborts processing of these commands in the mid-level.&n;     */
r_if
c_cond
(paren
(paren
id|cmd
op_assign
id|connected
)paren
)paren
(brace
id|ABRT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: reset aborted a connected command&bslash;n&quot;
comma
id|H_NO
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|cmd-&gt;result
op_amp
l_int|0xffff
)paren
op_or
(paren
id|DID_RESET
op_lshift
l_int|16
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|cmd
op_assign
id|disconnected_queue
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
id|disconnected_queue
op_assign
id|NEXT
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|NEXT
c_func
(paren
id|cmd
)paren
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|cmd-&gt;result
op_amp
l_int|0xffff
)paren
op_or
(paren
id|DID_RESET
op_lshift
l_int|16
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
id|ABRT_PRINTK
c_func
(paren
l_string|&quot;scsi: reset aborted %d disconnected command(s)&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* The Falcon lock should be released after a reset...&n; */
multiline_comment|/* ++guenther: moved to atari_scsi_reset(), to prevent a race between&n; * unlocking and enabling dma interrupt.&n; */
multiline_comment|/*    falcon_release_lock_if_possible( hostdata );*/
multiline_comment|/* since all commands have been explicitly terminated, we need to tell&n;     * the midlevel code that the reset was SUCCESSFUL, and there is no &n;     * need to &squot;wake up&squot; the commands by a request_sense&n;     */
r_return
id|SCSI_RESET_SUCCESS
op_or
id|SCSI_RESET_BUS_RESET
suffix:semicolon
macro_line|#else /* 1 */
multiline_comment|/* MSch: new-style reset handling: let the mid-level do what it can */
multiline_comment|/* ++guenther: MID-LEVEL IS STILL BROKEN.&n;     * Mid-level is supposed to requeue all commands that were active on the&n;     * various low-level queues. In fact it does this, but that&squot;s not enough&n;     * because all these commands are subject to timeout. And if a timeout&n;     * happens for any removed command, *_abort() is called but all queues&n;     * are now empty. Abort then gives up the falcon lock, which is fatal,&n;     * since the mid-level will queue more commands and must have the lock&n;     * (it&squot;s all happening inside timer interrupt handler!!).&n;     * Even worse, abort will return NOT_RUNNING for all those commands not&n;     * on any queue, so they won&squot;t be retried ...&n;     *&n;     * Conclusion: either scsi.c disables timeout for all resetted commands&n;     * immediately, or we loose!  As of linux-2.0.20 it doesn&squot;t.&n;     */
multiline_comment|/* After the reset, there are no more connected or disconnected commands&n;     * and no busy units; so clear the low-level status here to avoid &n;     * conflicts when the mid-level code tries to wake up the affected &n;     * commands!&n;     */
r_if
c_cond
(paren
id|hostdata-&gt;issue_queue
)paren
id|ABRT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: reset aborted issued command(s)&bslash;n&quot;
comma
id|H_NO
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;connected
)paren
id|ABRT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: reset aborted a connected command&bslash;n&quot;
comma
id|H_NO
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hostdata-&gt;disconnected_queue
)paren
id|ABRT_PRINTK
c_func
(paren
l_string|&quot;scsi%d: reset aborted disconnected command(s)&bslash;n&quot;
comma
id|H_NO
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|hostdata-&gt;issue_queue
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;connected
op_assign
l_int|NULL
suffix:semicolon
id|hostdata-&gt;disconnected_queue
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef SUPPORT_TAGS
id|free_all_tags
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
(brace
id|hostdata-&gt;busy
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef REAL_DMA
id|hostdata-&gt;dma_len
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* we did no complete reset of all commands, so a wakeup is required */
r_return
id|SCSI_RESET_WAKEUP
op_or
id|SCSI_RESET_BUS_RESET
suffix:semicolon
macro_line|#endif /* 1 */
)brace
multiline_comment|/* Local Variables: */
multiline_comment|/* tab-width: 8     */
multiline_comment|/* End:             */
eof
