multiline_comment|/* $Id: scsi_debug.c,v 1.1 1992/07/24 06:27:38 root Exp root $&n; *  linux/kernel/scsi_debug.c&n; *&n; *  Copyright (C) 1992  Eric Youngdale&n; *  Simulate a host adapter with 2 disks attached.  Do a lot of checking&n; *  to make sure that we are not getting blocks mixed up, and panic if&n; *  anything out of the ordinary is seen.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include&lt;linux/stat.h&gt;
multiline_comment|/* A few options that we want selected */
DECL|macro|NR_HOSTS_PRESENT
mdefine_line|#define NR_HOSTS_PRESENT 1
DECL|macro|NR_FAKE_DISKS
mdefine_line|#define NR_FAKE_DISKS   3
DECL|macro|N_HEAD
mdefine_line|#define N_HEAD          255
DECL|macro|N_SECTOR
mdefine_line|#define N_SECTOR        63
DECL|macro|N_CYLINDER
mdefine_line|#define N_CYLINDER      524
DECL|macro|DISK_READONLY
mdefine_line|#define DISK_READONLY(TGT)      (0)
DECL|macro|DISK_REMOVEABLE
mdefine_line|#define DISK_REMOVEABLE(TGT)    (1)
DECL|macro|DEVICE_TYPE
mdefine_line|#define DEVICE_TYPE(TGT) (TGT == 2 ? TYPE_TAPE : TYPE_DISK);
multiline_comment|/* Do not attempt to use a timer to simulate a real disk with latency */
multiline_comment|/* Only use this in the actual kernel, not in the simulator. */
DECL|macro|IMMEDIATE
mdefine_line|#define IMMEDIATE
multiline_comment|/* Skip some consistency checking.  Good for benchmarking */
DECL|macro|SPEEDY
mdefine_line|#define SPEEDY
multiline_comment|/* Read return zeros. Undefine for benchmarking */
DECL|macro|CLEAR
mdefine_line|#define CLEAR
multiline_comment|/* Number of real scsi disks that will be detected ahead of time */
DECL|variable|NR_REAL
r_static
r_int
id|NR_REAL
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|macro|NR_BLK_DEV
mdefine_line|#define NR_BLK_DEV  12
macro_line|#ifndef MAJOR_NR
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR 8
macro_line|#endif
DECL|macro|START_PARTITION
mdefine_line|#define START_PARTITION 4
multiline_comment|/* Time to wait before completing a command */
DECL|macro|DISK_SPEED
mdefine_line|#define DISK_SPEED     (HZ/10)&t;/* 100ms */
DECL|macro|CAPACITY
mdefine_line|#define CAPACITY (N_HEAD * N_SECTOR * N_CYLINDER)
DECL|macro|SIZE
mdefine_line|#define SIZE(TGT) (TGT == 2 ? 2248 : 512)
DECL|variable|starts
r_static
r_int
id|starts
(braket
)braket
op_assign
(brace
id|N_SECTOR
comma
id|N_HEAD
op_star
id|N_SECTOR
comma
multiline_comment|/* Single cylinder */
id|N_HEAD
op_star
id|N_SECTOR
op_star
l_int|4
comma
id|CAPACITY
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|npart
r_static
r_int
id|npart
op_assign
l_int|0
suffix:semicolon
macro_line|#include &quot;scsi_debug.h&quot;
macro_line|#ifdef DEBUG
DECL|macro|DEB
mdefine_line|#define DEB(x) x
macro_line|#else
DECL|macro|DEB
mdefine_line|#define DEB(x)
macro_line|#endif
macro_line|#ifdef SPEEDY
DECL|macro|VERIFY1_DEBUG
mdefine_line|#define VERIFY1_DEBUG(RW)
DECL|macro|VERIFY_DEBUG
mdefine_line|#define VERIFY_DEBUG(RW)
macro_line|#else
DECL|macro|VERIFY1_DEBUG
mdefine_line|#define VERIFY1_DEBUG(RW)                           &bslash;&n;    if (bufflen != 1024) {printk(&quot;%d&quot;, bufflen); panic(&quot;(1)Bad bufflen&quot;);};         &bslash;&n;    start = 0;                          &bslash;&n;    if ((MINOR(SCpnt-&gt;request.rq_dev) &amp; 0xf) != 0) start = starts[(MINOR(SCpnt-&gt;request.rq_dev) &amp; 0xf) - 1];        &bslash;&n;    if (bh){                            &bslash;&n;&t;if (bh-&gt;b_size != 1024) panic (&quot;Wrong bh size&quot;);    &bslash;&n;&t;if ((bh-&gt;b_blocknr &lt;&lt; 1) + start != block)          &bslash;&n;&t;{   printk(&quot;Wrong bh block# %d %d &quot;,bh-&gt;b_blocknr, block);  &bslash;&n;&t;    panic (&quot;Wrong bh block#&quot;); &bslash;&n;&t;};  &bslash;&n;&t;if (bh-&gt;b_dev != SCpnt-&gt;request.rq_dev)  &bslash;&n;&t;    panic (&quot;Bad bh target&quot;); &bslash;&n;    };
DECL|macro|VERIFY_DEBUG
mdefine_line|#define VERIFY_DEBUG(RW)                            &bslash;&n;    if (bufflen != 1024 &amp;&amp; (!SCpnt-&gt;use_sg)) {printk(&quot;%x %d&bslash;n &quot;,bufflen, SCpnt-&gt;use_sg); panic(&quot;Bad bufflen&quot;);};    &bslash;&n;    start = 0;                          &bslash;&n;    if ((MINOR(SCpnt-&gt;request.rq_dev) &amp; 0xf) &gt; npart) panic (&quot;Bad partition&quot;);    &bslash;&n;    if ((MINOR(SCpnt-&gt;request.rq_dev) &amp; 0xf) != 0) start = starts[(MINOR(SCpnt-&gt;request.rq_dev) &amp; 0xf) - 1];        &bslash;&n;    if (SCpnt-&gt;request.cmd != RW) panic (&quot;Wrong  operation&quot;);       &bslash;&n;    if (SCpnt-&gt;request.sector + start != block) panic(&quot;Wrong block.&quot;);  &bslash;&n;    if (SCpnt-&gt;request.current_nr_sectors != 2 &amp;&amp; (!SCpnt-&gt;use_sg)) panic (&quot;Wrong # blocks&quot;);   &bslash;&n;    if (SCpnt-&gt;request.bh){                         &bslash;&n;&t;if (SCpnt-&gt;request.bh-&gt;b_size != 1024) panic (&quot;Wrong bh size&quot;); &bslash;&n;&t;if ((SCpnt-&gt;request.bh-&gt;b_blocknr &lt;&lt; 1) + start != block)           &bslash;&n;&t;{   printk(&quot;Wrong bh block# %d %d &quot;,SCpnt-&gt;request.bh-&gt;b_blocknr, block);  &bslash;&n;&t;    panic (&quot;Wrong bh block#&quot;); &bslash;&n;&t;};  &bslash;&n;&t;if (SCpnt-&gt;request.bh-&gt;b_dev != SCpnt-&gt;request.rq_dev) &bslash;&n;&t;    panic (&quot;Bad bh target&quot;);&bslash;&n;    };
macro_line|#endif
DECL|typedef|done_fct_t
r_typedef
r_void
(paren
op_star
id|done_fct_t
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
DECL|variable|do_done
r_static
r_volatile
id|done_fct_t
id|do_done
(braket
id|SCSI_DEBUG_MAILBOXES
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|SHpnt
r_struct
id|Scsi_Host
op_star
id|SHpnt
op_assign
l_int|NULL
suffix:semicolon
r_static
r_void
id|scsi_debug_send_self_command
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
suffix:semicolon
r_static
r_void
id|scsi_debug_intr_handle
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|variable|timeout
r_static
r_struct
id|timer_list
id|timeout
(braket
id|SCSI_DEBUG_MAILBOXES
)braket
suffix:semicolon
DECL|variable|SCint
id|Scsi_Cmnd
op_star
id|SCint
(braket
id|SCSI_DEBUG_MAILBOXES
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|SCrst
r_static
r_char
id|SCrst
(braket
id|SCSI_DEBUG_MAILBOXES
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Semaphore used to simulate bus lockups.&n; */
DECL|variable|scsi_debug_lockup
r_static
r_int
id|scsi_debug_lockup
op_assign
l_int|0
suffix:semicolon
DECL|variable|sense_buffer
r_static
r_char
id|sense_buffer
(braket
l_int|128
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|function|scsi_dump
r_static
r_void
id|scsi_dump
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|flag
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#if 0
r_int
r_char
op_star
id|pnt
suffix:semicolon
macro_line|#endif
r_int
r_int
op_star
id|lpnt
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sgpnt
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;use_sg: %d&quot;
comma
id|SCpnt-&gt;use_sg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lpnt
op_assign
(paren
r_int
op_star
)paren
id|sgpnt
(braket
id|i
)braket
dot
id|alt_address
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;:%p %p %d&bslash;n&quot;
comma
id|sgpnt
(braket
id|i
)braket
dot
id|alt_address
comma
id|sgpnt
(braket
id|i
)braket
dot
id|address
comma
id|sgpnt
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lpnt
)paren
id|printk
c_func
(paren
l_string|&quot; (Alt %x) &quot;
comma
id|lpnt
(braket
l_int|15
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;nosg: %p %p %d&bslash;n&quot;
comma
id|SCpnt-&gt;request.buffer
comma
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;bufflen
)paren
suffix:semicolon
id|lpnt
op_assign
(paren
r_int
op_star
)paren
id|SCpnt-&gt;request.buffer
suffix:semicolon
r_if
c_cond
(paren
id|lpnt
)paren
id|printk
c_func
(paren
l_string|&quot; (Alt %x) &quot;
comma
id|lpnt
(braket
l_int|15
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
id|lpnt
op_assign
(paren
r_int
r_int
op_star
)paren
id|SCpnt
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|Scsi_Cmnd
)paren
op_div
l_int|4
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|7
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%x &quot;
comma
op_star
id|lpnt
op_increment
)paren
suffix:semicolon
)brace
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|lpnt
op_assign
(paren
r_int
r_int
op_star
)paren
id|sgpnt
(braket
l_int|0
)braket
dot
id|alt_address
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|Scsi_Cmnd
)paren
op_div
l_int|4
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|7
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%x &quot;
comma
op_star
id|lpnt
op_increment
)paren
suffix:semicolon
)brace
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|lpnt
op_assign
(paren
r_int
r_int
op_star
)paren
id|sgpnt
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|Scsi_Cmnd
)paren
op_div
l_int|4
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|7
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%x &quot;
comma
op_star
id|lpnt
op_increment
)paren
suffix:semicolon
)brace
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;DMA free %d sectors.&bslash;n&quot;
comma
id|scsi_dma_free_sectors
)paren
suffix:semicolon
)brace
DECL|function|scsi_debug_queuecommand
r_int
id|scsi_debug_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|unchar
op_star
id|cmd
op_assign
(paren
id|unchar
op_star
)paren
id|SCpnt-&gt;cmnd
suffix:semicolon
r_struct
id|partition
op_star
id|p
suffix:semicolon
r_int
id|block
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|buff
suffix:semicolon
r_int
id|nbytes
comma
id|sgcount
suffix:semicolon
r_int
id|scsi_debug_errsts
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sgpnt
suffix:semicolon
r_int
id|target
op_assign
id|SCpnt-&gt;target
suffix:semicolon
r_int
id|bufflen
op_assign
id|SCpnt-&gt;request_bufflen
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|sgcount
op_assign
l_int|0
suffix:semicolon
id|sgpnt
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n;         * The io_request_lock *must* be held at this point.&n;         */
r_if
c_cond
(paren
id|io_request_lock.lock
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning - io_request_lock is not held in queuecommand&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * If we are being notified of the mid-level reposessing a command due to timeout,&n;&t; * just return.&n;&t; */
r_if
c_cond
(paren
id|done
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|DEB
c_func
(paren
r_if
(paren
id|target
op_ge
id|NR_FAKE_DISKS
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|DID_TIME_OUT
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)paren
suffix:semicolon
id|buff
op_assign
(paren
r_int
r_char
op_star
)paren
id|SCpnt-&gt;request_buffer
suffix:semicolon
multiline_comment|/*&n;         * If a command comes for the ID of the host itself, just print&n;         * a silly message and return.&n;         */
r_if
c_cond
(paren
id|target
op_eq
l_int|7
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;How do you do!&bslash;n&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
l_int|0
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|target
op_ge
id|NR_FAKE_DISKS
op_logical_or
id|SCpnt-&gt;lun
op_ne
l_int|0
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCrst
(braket
id|target
)braket
op_ne
l_int|0
op_logical_and
op_logical_neg
id|scsi_debug_lockup
)paren
(brace
id|SCrst
(braket
id|target
)braket
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x70
suffix:semicolon
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_assign
id|UNIT_ATTENTION
suffix:semicolon
id|SCpnt-&gt;result
op_assign
(paren
id|CHECK_CONDITION
op_lshift
l_int|1
)paren
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
op_star
id|cmd
)paren
(brace
r_case
id|REQUEST_SENSE
suffix:colon
id|SCSI_LOG_LLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Request sense...&bslash;n&quot;
)paren
)paren
suffix:semicolon
macro_line|#ifndef DEBUG
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi_debug: Requesting sense buffer (%p %p %p %d):&quot;
comma
id|SCpnt
comma
id|buff
comma
id|done
comma
id|bufflen
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|12
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%d &quot;
comma
id|sense_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
id|memset
c_func
(paren
id|buff
comma
l_int|0
comma
id|bufflen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|buff
comma
id|sense_buffer
comma
id|bufflen
)paren
suffix:semicolon
id|memset
c_func
(paren
id|sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|sense_buffer
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
l_int|0
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|START_STOP
suffix:colon
id|SCSI_LOG_LLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;START_STOP&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|scsi_debug_errsts
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ALLOW_MEDIUM_REMOVAL
suffix:colon
r_if
c_cond
(paren
id|cmd
(braket
l_int|4
)braket
)paren
(brace
id|SCSI_LOG_LLQUEUE
c_func
(paren
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;Medium removal inhibited...&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCSI_LOG_LLQUEUE
c_func
(paren
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;Medium removal enabled...&quot;
)paren
)paren
suffix:semicolon
)brace
id|scsi_debug_errsts
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INQUIRY
suffix:colon
id|SCSI_LOG_LLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Inquiry...(%p %d)&bslash;n&quot;
comma
id|buff
comma
id|bufflen
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|buff
comma
l_int|0
comma
id|bufflen
)paren
suffix:semicolon
id|buff
(braket
l_int|0
)braket
op_assign
id|DEVICE_TYPE
c_func
(paren
id|target
)paren
suffix:semicolon
id|buff
(braket
l_int|1
)braket
op_assign
id|DISK_REMOVEABLE
c_func
(paren
id|target
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* Removable disk */
id|buff
(braket
l_int|2
)braket
op_assign
l_int|1
suffix:semicolon
id|buff
(braket
l_int|4
)braket
op_assign
l_int|33
op_minus
l_int|5
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|buff
(braket
l_int|8
)braket
comma
l_string|&quot;Foo Inc&quot;
comma
l_int|7
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|buff
(braket
l_int|16
)braket
comma
l_string|&quot;XYZZY&quot;
comma
l_int|5
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|buff
(braket
l_int|32
)braket
comma
l_string|&quot;1&quot;
comma
l_int|1
)paren
suffix:semicolon
id|scsi_debug_errsts
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TEST_UNIT_READY
suffix:colon
id|SCSI_LOG_LLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Test unit ready(%p %d)&bslash;n&quot;
comma
id|buff
comma
id|bufflen
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
)paren
id|memset
c_func
(paren
id|buff
comma
l_int|0
comma
id|bufflen
)paren
suffix:semicolon
id|scsi_debug_errsts
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ_CAPACITY
suffix:colon
id|SCSI_LOG_LLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Read Capacity&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|SHpnt
op_assign
id|SCpnt-&gt;host
suffix:semicolon
r_if
c_cond
(paren
id|NR_REAL
OL
l_int|0
)paren
id|NR_REAL
op_assign
(paren
id|MINOR
c_func
(paren
id|SCpnt-&gt;request.rq_dev
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|memset
c_func
(paren
id|buff
comma
l_int|0
comma
id|bufflen
)paren
suffix:semicolon
id|buff
(braket
l_int|0
)braket
op_assign
(paren
id|CAPACITY
op_rshift
l_int|24
)paren
suffix:semicolon
id|buff
(braket
l_int|1
)braket
op_assign
(paren
id|CAPACITY
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|buff
(braket
l_int|2
)braket
op_assign
(paren
id|CAPACITY
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|buff
(braket
l_int|3
)braket
op_assign
id|CAPACITY
op_amp
l_int|0xff
suffix:semicolon
id|buff
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|buff
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|buff
(braket
l_int|6
)braket
op_assign
(paren
id|SIZE
c_func
(paren
id|target
)paren
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* 512 byte sectors */
id|buff
(braket
l_int|7
)braket
op_assign
id|SIZE
c_func
(paren
id|target
)paren
op_amp
l_int|0xff
suffix:semicolon
id|scsi_debug_errsts
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ_10
suffix:colon
r_case
id|READ_6
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Read...&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
op_star
id|cmd
)paren
op_eq
id|READ_10
)paren
id|block
op_assign
id|cmd
(braket
l_int|5
)braket
op_plus
(paren
id|cmd
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_plus
(paren
id|cmd
(braket
l_int|3
)braket
op_lshift
l_int|16
)paren
op_plus
(paren
id|cmd
(braket
l_int|2
)braket
op_lshift
l_int|24
)paren
suffix:semicolon
r_else
id|block
op_assign
id|cmd
(braket
l_int|3
)braket
op_plus
(paren
id|cmd
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_plus
(paren
(paren
id|cmd
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|VERIFY_DEBUG
c_func
(paren
id|READ
)paren
suffix:semicolon
macro_line|#if defined(SCSI_SETUP_LATENCY) || defined(SCSI_DATARATE)
(brace
r_int
id|delay
op_assign
id|SCSI_SETUP_LATENCY
suffix:semicolon
id|delay
op_add_assign
id|SCpnt-&gt;request.nr_sectors
op_star
id|SCSI_DATARATE
suffix:semicolon
r_if
c_cond
(paren
id|delay
)paren
id|usleep
c_func
(paren
id|delay
)paren
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;(r%d)&quot;
comma
id|SCpnt-&gt;request.nr_sectors
)paren
suffix:semicolon
macro_line|#endif
id|nbytes
op_assign
id|bufflen
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
id|sgcount
op_assign
l_int|0
suffix:semicolon
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|buff
suffix:semicolon
id|buff
op_assign
id|sgpnt
(braket
id|sgcount
)braket
dot
id|address
suffix:semicolon
id|bufflen
op_assign
id|sgpnt
(braket
id|sgcount
)braket
dot
id|length
suffix:semicolon
id|bh
op_assign
id|SCpnt-&gt;request.bh
suffix:semicolon
)brace
suffix:semicolon
id|scsi_debug_errsts
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|VERIFY1_DEBUG
c_func
(paren
id|READ
)paren
suffix:semicolon
multiline_comment|/* For the speedy test, we do not even want to fill the buffer with anything */
macro_line|#ifdef CLEAR
id|memset
c_func
(paren
id|buff
comma
l_int|0
comma
id|bufflen
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* If this is block 0, then we want to read the partition table for this&n;&t;&t;&t; * device.  Let&squot;s make one up */
r_if
c_cond
(paren
id|block
op_eq
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
id|memset
c_func
(paren
id|buff
comma
l_int|0
comma
id|bufflen
)paren
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|buff
op_plus
l_int|510
)paren
)paren
op_assign
l_int|0xAA55
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|partition
op_star
)paren
(paren
id|buff
op_plus
l_int|0x1be
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|starts
(braket
id|i
op_plus
l_int|1
)braket
)paren
(brace
r_int
id|start_cyl
comma
id|end_cyl
suffix:semicolon
id|start_cyl
op_assign
id|starts
(braket
id|i
)braket
op_div
id|N_HEAD
op_div
id|N_SECTOR
suffix:semicolon
id|end_cyl
op_assign
(paren
id|starts
(braket
id|i
op_plus
l_int|1
)braket
op_minus
l_int|1
)paren
op_div
id|N_HEAD
op_div
id|N_SECTOR
suffix:semicolon
id|p-&gt;boot_ind
op_assign
l_int|0
suffix:semicolon
id|p-&gt;head
op_assign
(paren
id|i
op_eq
l_int|0
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|p-&gt;sector
op_assign
l_int|1
op_or
(paren
(paren
id|start_cyl
op_rshift
l_int|8
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|p-&gt;cyl
op_assign
(paren
id|start_cyl
op_amp
l_int|0xff
)paren
suffix:semicolon
id|p-&gt;end_head
op_assign
id|N_HEAD
op_minus
l_int|1
suffix:semicolon
id|p-&gt;end_sector
op_assign
id|N_SECTOR
op_or
(paren
(paren
id|end_cyl
op_rshift
l_int|8
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|p-&gt;end_cyl
op_assign
(paren
id|end_cyl
op_amp
l_int|0xff
)paren
suffix:semicolon
id|p-&gt;start_sect
op_assign
id|starts
(braket
id|i
)braket
suffix:semicolon
id|p-&gt;nr_sects
op_assign
id|starts
(braket
id|i
op_plus
l_int|1
)braket
op_minus
id|starts
(braket
id|i
)braket
suffix:semicolon
id|p-&gt;sys_ind
op_assign
l_int|0x81
suffix:semicolon
multiline_comment|/* Linux partition */
id|p
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|npart
)paren
id|npart
op_assign
id|i
suffix:semicolon
id|scsi_debug_errsts
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
id|printk
c_func
(paren
l_string|&quot;Block %x (%d %d)&bslash;n&quot;
comma
id|block
comma
id|SCpnt-&gt;request.nr_sectors
comma
id|SCpnt-&gt;request.current_nr_sectors
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0
multiline_comment|/* Simulate a disk change */
r_if
c_cond
(paren
id|block
op_eq
l_int|0xfff0
)paren
(brace
id|sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x70
suffix:semicolon
id|sense_buffer
(braket
l_int|2
)braket
op_assign
id|UNIT_ATTENTION
suffix:semicolon
id|starts
(braket
l_int|0
)braket
op_add_assign
l_int|10
suffix:semicolon
id|starts
(braket
l_int|1
)braket
op_add_assign
l_int|10
suffix:semicolon
id|starts
(braket
l_int|2
)braket
op_add_assign
l_int|10
suffix:semicolon
macro_line|#ifdef DEBUG
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi_debug: Filling sense buffer:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|12
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%d &quot;
comma
id|sense_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
id|scsi_debug_errsts
op_assign
(paren
id|COMMAND_COMPLETE
op_lshift
l_int|8
)paren
op_or
(paren
id|CHECK_CONDITION
op_lshift
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* End phony disk change code */
macro_line|#endif
macro_line|#ifdef CLEAR
id|memcpy
c_func
(paren
id|buff
comma
op_amp
id|target
comma
r_sizeof
(paren
id|target
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|buff
op_plus
r_sizeof
(paren
id|target
)paren
comma
id|cmd
comma
l_int|24
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|buff
op_plus
l_int|60
comma
op_amp
id|block
comma
r_sizeof
(paren
id|block
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|buff
op_plus
l_int|64
comma
id|SCpnt
comma
r_sizeof
(paren
id|Scsi_Cmnd
)paren
)paren
suffix:semicolon
macro_line|#endif
id|nbytes
op_sub_assign
id|bufflen
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
macro_line|#ifdef CLEAR
id|memcpy
c_func
(paren
id|buff
op_plus
l_int|128
comma
id|bh
comma
r_sizeof
(paren
r_struct
id|buffer_head
)paren
)paren
suffix:semicolon
macro_line|#endif
id|block
op_add_assign
id|bufflen
op_rshift
l_int|9
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
id|sgcount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|nbytes
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
id|panic
c_func
(paren
l_string|&quot;Too few blocks for linked request.&quot;
)paren
suffix:semicolon
id|buff
op_assign
id|sgpnt
(braket
id|sgcount
)braket
dot
id|address
suffix:semicolon
id|bufflen
op_assign
id|sgpnt
(braket
id|sgcount
)braket
dot
id|length
suffix:semicolon
)brace
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|nbytes
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
l_int|0
suffix:semicolon
(paren
id|done
)paren
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
op_logical_and
op_logical_neg
id|scsi_debug_errsts
)paren
r_if
c_cond
(paren
id|bh
)paren
id|scsi_dump
c_func
(paren
id|SCpnt
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WRITE_10
suffix:colon
r_case
id|WRITE_6
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Write&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
op_star
id|cmd
)paren
op_eq
id|WRITE_10
)paren
id|block
op_assign
id|cmd
(braket
l_int|5
)braket
op_plus
(paren
id|cmd
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_plus
(paren
id|cmd
(braket
l_int|3
)braket
op_lshift
l_int|16
)paren
op_plus
(paren
id|cmd
(braket
l_int|2
)braket
op_lshift
l_int|24
)paren
suffix:semicolon
r_else
id|block
op_assign
id|cmd
(braket
l_int|3
)braket
op_plus
(paren
id|cmd
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_plus
(paren
(paren
id|cmd
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|VERIFY_DEBUG
c_func
(paren
id|WRITE
)paren
suffix:semicolon
multiline_comment|/*      printk(&quot;(w%d)&quot;,SCpnt-&gt;request.nr_sectors); */
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
r_if
c_cond
(paren
(paren
id|bufflen
op_rshift
l_int|9
)paren
op_ne
id|SCpnt-&gt;request.nr_sectors
)paren
id|panic
c_func
(paren
l_string|&quot;Trying to write wrong number of blocks&bslash;n&quot;
)paren
suffix:semicolon
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|buff
suffix:semicolon
id|buff
op_assign
id|sgpnt
(braket
id|sgcount
)braket
dot
id|address
suffix:semicolon
)brace
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|block
op_ne
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|buff
op_plus
l_int|60
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%x %x :&quot;
comma
id|block
comma
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|buff
op_plus
l_int|60
)paren
)paren
)paren
suffix:semicolon
id|scsi_dump
c_func
(paren
id|SCpnt
comma
l_int|1
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Bad block written.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
id|scsi_debug_errsts
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODE_SENSE
suffix:colon
multiline_comment|/*&n;&t;&t; * Used to detect write protected status.&n;&t;&t; */
id|scsi_debug_errsts
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|buff
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SCSI_LOG_LLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Unknown command %d&bslash;n&quot;
comma
op_star
id|cmd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCSI_DEBUG_MAILBOXES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|timeout
(braket
id|i
)braket
dot
id|function
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t; * If all of the slots are full, just return 1.  The new error handling scheme&n;&t; * allows this, and the mid-level should queue things.&n;&t; */
r_if
c_cond
(paren
id|i
op_ge
id|SCSI_DEBUG_MAILBOXES
op_logical_or
id|timeout
(braket
id|i
)braket
dot
id|function
op_ne
l_int|0
)paren
(brace
id|SCSI_LOG_LLQUEUE
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Command rejected - host busy&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|SCSI_LOG_LLQUEUE
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Command accepted - slot %d&bslash;n&quot;
comma
id|i
)paren
)paren
suffix:semicolon
macro_line|#ifdef IMMEDIATE
r_if
c_cond
(paren
op_logical_neg
id|scsi_debug_lockup
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|scsi_debug_errsts
suffix:semicolon
id|SCint
(braket
id|i
)braket
op_assign
id|SCpnt
suffix:semicolon
id|do_done
(braket
id|i
)braket
op_assign
id|done
suffix:semicolon
id|scsi_debug_intr_handle
c_func
(paren
id|i
)paren
suffix:semicolon
multiline_comment|/* No timer - do this one right away */
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#else
id|SCpnt-&gt;result
op_assign
id|scsi_debug_errsts
suffix:semicolon
id|timeout
(braket
id|i
)braket
dot
id|function
op_assign
id|scsi_debug_intr_handle
suffix:semicolon
id|timeout
(braket
id|i
)braket
dot
id|data
op_assign
id|i
suffix:semicolon
id|timeout
(braket
id|i
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
id|DISK_SPEED
suffix:semicolon
id|SCint
(braket
id|i
)braket
op_assign
id|SCpnt
suffix:semicolon
id|do_done
(braket
id|i
)braket
op_assign
id|done
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|timeout
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
id|panic
c_func
(paren
l_string|&quot;scsi_debug_queuecommand: done can&squot;t be NULL&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;Sending command (%d %x %d %d)...&quot;
comma
id|i
comma
id|done
comma
id|timeout
(braket
id|i
)braket
dot
id|expires
comma
id|jiffies
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scsi_debug_send_self_command
r_static
r_void
id|scsi_debug_send_self_command
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_static
r_int
r_char
id|cmd
(braket
l_int|6
)braket
op_assign
(brace
id|TEST_UNIT_READY
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|Scsi_Request
op_star
id|scp
suffix:semicolon
id|Scsi_Device
op_star
id|sdev
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Allocating host dev&bslash;n&quot;
)paren
suffix:semicolon
id|sdev
op_assign
id|scsi_get_host_dev
c_func
(paren
id|shpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Got %p. Allocating command block&bslash;n&quot;
comma
id|sdev
)paren
suffix:semicolon
id|scp
op_assign
id|scsi_allocate_request
c_func
(paren
id|sdev
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Got %p&bslash;n&quot;
comma
id|scp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scp
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|bail
suffix:semicolon
)brace
id|scp-&gt;sr_cmd_len
op_assign
l_int|6
suffix:semicolon
id|scp-&gt;sr_use_sg
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Sending command&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_wait_req
(paren
id|scp
comma
(paren
r_void
op_star
)paren
id|cmd
comma
(paren
r_void
op_star
)paren
l_int|NULL
comma
l_int|0
comma
l_int|100
comma
l_int|3
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Releasing command&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_release_request
c_func
(paren
id|scp
)paren
suffix:semicolon
id|bail
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Freeing device&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_free_host_dev
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
multiline_comment|/* A &quot;high&quot; level interrupt handler.  This should be called once per jiffy&n; * to simulate a regular scsi disk.  We use a timer to do this. */
DECL|function|scsi_debug_intr_handle
r_static
r_void
id|scsi_debug_intr_handle
c_func
(paren
r_int
r_int
id|indx
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCtmp
suffix:semicolon
r_void
(paren
op_star
id|my_done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_int
id|to
suffix:semicolon
macro_line|#endif
macro_line|#if 0
id|del_timer
c_func
(paren
op_amp
id|timeout
(braket
id|indx
)braket
)paren
suffix:semicolon
macro_line|#endif
id|SCtmp
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|SCint
(braket
id|indx
)braket
suffix:semicolon
id|my_done
op_assign
id|do_done
(braket
id|indx
)braket
suffix:semicolon
id|do_done
(braket
id|indx
)braket
op_assign
l_int|NULL
suffix:semicolon
id|timeout
(braket
id|indx
)braket
dot
id|function
op_assign
l_int|NULL
suffix:semicolon
id|SCint
(braket
id|indx
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|my_done
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi_debug_intr_handle: Unexpected interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;In intr_handle...&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;...done %d %x %d %d&bslash;n&quot;
comma
id|i
comma
id|my_done
comma
id|to
comma
id|jiffies
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;In intr_handle: %d %x %x&bslash;n&quot;
comma
id|i
comma
id|SCtmp
comma
id|my_done
)paren
suffix:semicolon
macro_line|#endif
id|my_done
c_func
(paren
id|SCtmp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Called done.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|scsi_debug_detect
r_int
id|scsi_debug_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HOSTS_PRESENT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tpnt-&gt;proc_name
op_assign
l_string|&quot;scsi_debug&quot;
suffix:semicolon
multiline_comment|/* Huh? In the loop??? */
id|scsi_register
c_func
(paren
id|tpnt
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|NR_HOSTS_PRESENT
suffix:semicolon
)brace
DECL|function|scsi_debug_abort
r_int
id|scsi_debug_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
macro_line|#if 0
r_int
id|j
suffix:semicolon
r_void
(paren
op_star
id|my_done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#endif
id|DEB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;scsi_debug_abort&bslash;n&quot;
)paren
)paren
suffix:semicolon
macro_line|#if 0
id|SCpnt-&gt;result
op_assign
id|SCpnt-&gt;abort_reason
op_lshift
l_int|16
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|SCSI_DEBUG_MAILBOXES
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|SCpnt
op_eq
id|SCint
(braket
id|j
)braket
)paren
(brace
id|my_done
op_assign
id|do_done
(braket
id|j
)braket
suffix:semicolon
id|my_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|timeout
(braket
id|j
)braket
op_assign
l_int|0
suffix:semicolon
id|SCint
(braket
id|j
)braket
op_assign
l_int|NULL
suffix:semicolon
id|do_done
(braket
id|j
)braket
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
DECL|function|scsi_debug_biosparam
r_int
id|scsi_debug_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
op_star
id|info
)paren
(brace
r_int
id|size
op_assign
id|disk-&gt;capacity
suffix:semicolon
id|info
(braket
l_int|0
)braket
op_assign
id|N_HEAD
suffix:semicolon
id|info
(braket
l_int|1
)braket
op_assign
id|N_SECTOR
suffix:semicolon
id|info
(braket
l_int|2
)braket
op_assign
id|N_CYLINDER
suffix:semicolon
r_if
c_cond
(paren
id|info
(braket
l_int|2
)braket
op_ge
l_int|1024
)paren
id|info
(braket
l_int|2
)braket
op_assign
l_int|1024
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scsi_debug_reset
r_int
id|scsi_debug_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_int
id|why
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_void
(paren
op_star
id|my_done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Bus unlocked by reset - %d&bslash;n&quot;
comma
id|why
)paren
suffix:semicolon
id|scsi_debug_lockup
op_assign
l_int|0
suffix:semicolon
id|DEB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;scsi_debug_reset called&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCSI_DEBUG_MAILBOXES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|SCint
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|SCint
(braket
id|i
)braket
op_member_access_from_pointer
id|result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|my_done
op_assign
id|do_done
(braket
id|i
)braket
suffix:semicolon
id|my_done
c_func
(paren
id|SCint
(braket
id|i
)braket
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|SCint
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|do_done
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|timeout
(braket
id|i
)braket
dot
id|function
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_return
id|SCSI_RESET_SUCCESS
suffix:semicolon
)brace
DECL|function|scsi_debug_info
r_const
r_char
op_star
id|scsi_debug_info
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|buffer
(braket
)braket
op_assign
l_string|&quot; &quot;
suffix:semicolon
multiline_comment|/* looks nicer without anything here */
r_return
id|buffer
suffix:semicolon
)brace
multiline_comment|/* scsi_debug_proc_info&n; * Used if the driver currently has no own support for /proc/scsi&n; */
DECL|function|scsi_debug_proc_info
r_int
id|scsi_debug_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|inode
comma
r_int
id|inout
)paren
(brace
r_int
id|len
comma
id|pos
comma
id|begin
suffix:semicolon
r_int
id|orig_length
suffix:semicolon
id|orig_length
op_assign
id|length
suffix:semicolon
r_if
c_cond
(paren
id|inout
op_eq
l_int|1
)paren
(brace
multiline_comment|/* First check for the Signature */
r_if
c_cond
(paren
id|length
op_ge
l_int|10
op_logical_and
id|strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;scsi_debug&quot;
comma
l_int|10
)paren
op_eq
l_int|0
)paren
(brace
id|buffer
op_add_assign
l_int|11
suffix:semicolon
id|length
op_sub_assign
l_int|11
suffix:semicolon
r_if
c_cond
(paren
id|buffer
(braket
id|length
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|buffer
(braket
id|length
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|length
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * OK, we are getting some kind of command.  Figure out&n;&t;&t;&t; * what we are supposed to do here.  Simulate bus lockups&n;&t;&t;&t; * to test our reset capability.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|length
op_eq
l_int|4
op_logical_and
id|strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;test&quot;
comma
id|length
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Testing send self command %p&bslash;n&quot;
comma
id|SHpnt
)paren
suffix:semicolon
id|scsi_debug_send_self_command
c_func
(paren
id|SHpnt
)paren
suffix:semicolon
r_return
id|orig_length
suffix:semicolon
)brace
r_if
c_cond
(paren
id|length
op_eq
l_int|6
op_logical_and
id|strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;lockup&quot;
comma
id|length
)paren
op_eq
l_int|0
)paren
(brace
id|scsi_debug_lockup
op_assign
l_int|1
suffix:semicolon
r_return
id|orig_length
suffix:semicolon
)brace
r_if
c_cond
(paren
id|length
op_eq
l_int|6
op_logical_and
id|strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;unlock&quot;
comma
id|length
)paren
op_eq
l_int|0
)paren
(brace
id|scsi_debug_lockup
op_assign
l_int|0
suffix:semicolon
r_return
id|orig_length
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Unknown command:%s (%d)&bslash;n&quot;
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Wrong Signature:%10s&bslash;n&quot;
comma
(paren
r_char
op_star
)paren
id|buffer
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|begin
op_assign
l_int|0
suffix:semicolon
id|pos
op_assign
id|len
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;This driver is not a real scsi driver, but it plays one on TV.&bslash;n&quot;
l_string|&quot;It is very handy for debugging specific problems because you&bslash;n&quot;
l_string|&quot;can simulate a variety of error conditions&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
multiline_comment|/* Start of wanted data */
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
(paren
id|len
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_USER_DEBUG
multiline_comment|/*&n; * This is a hack for the user space emulator.  It allows us to&n; * &quot;insert&quot; arbitrary numbers of additional drivers.&n; */
DECL|function|scsi_debug_get_handle
r_void
op_star
id|scsi_debug_get_handle
c_func
(paren
r_void
)paren
(brace
r_static
id|Scsi_Host_Template
id|driver_copy
op_assign
id|SCSI_DEBUG
suffix:semicolon
r_void
op_star
id|rtn
suffix:semicolon
id|rtn
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|driver_copy
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|rtn
comma
(paren
r_void
op_star
)paren
op_amp
id|driver_copy
comma
r_sizeof
(paren
id|driver_copy
)paren
)paren
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Eventually this will go into an include file, but this will be later */
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|SCSI_DEBUG
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
multiline_comment|/*&n; * Overrides for Emacs so that we almost follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: nil&n; * tab-width: 8&n; * End:&n; */
eof
