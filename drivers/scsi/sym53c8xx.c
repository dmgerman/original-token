multiline_comment|/******************************************************************************&n;**  High Performance device driver for the Symbios 53C896 controller.&n;**&n;**  Copyright (C) 1998-2000  Gerard Roudier &lt;groudier@club-internet.fr&gt;&n;**&n;**  This driver also supports all the Symbios 53C8XX controller family, &n;**  except 53C810 revisions &lt; 16, 53C825 revisions &lt; 16 and all &n;**  revisions of 53C815 controllers.&n;**&n;**  This driver is based on the Linux port of the FreeBSD ncr driver.&n;** &n;**  Copyright (C) 1994  Wolfgang Stanglmeier&n;**  &n;**-----------------------------------------------------------------------------&n;**  &n;**  This program is free software; you can redistribute it and/or modify&n;**  it under the terms of the GNU General Public License as published by&n;**  the Free Software Foundation; either version 2 of the License, or&n;**  (at your option) any later version.&n;**&n;**  This program is distributed in the hope that it will be useful,&n;**  but WITHOUT ANY WARRANTY; without even the implied warranty of&n;**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;**  GNU General Public License for more details.&n;**&n;**  You should have received a copy of the GNU General Public License&n;**  along with this program; if not, write to the Free Software&n;**  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;**&n;**-----------------------------------------------------------------------------&n;**&n;**  The Linux port of the FreeBSD ncr driver has been achieved in &n;**  november 1995 by:&n;**&n;**          Gerard Roudier              &lt;groudier@club-internet.fr&gt;&n;**&n;**  Being given that this driver originates from the FreeBSD version, and&n;**  in order to keep synergy on both, any suggested enhancements and corrections&n;**  received on Linux are automatically a potential candidate for the FreeBSD &n;**  version.&n;**&n;**  The original driver has been written for 386bsd and FreeBSD by&n;**          Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;&n;**          Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;&n;**&n;**-----------------------------------------------------------------------------&n;**&n;**  Major contributions:&n;**  --------------------&n;**&n;**  NVRAM detection and reading.&n;**    Copyright (C) 1997 Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;&n;**&n;*******************************************************************************&n;*/
multiline_comment|/*&n;**&t;May 11 2000, sym53c8xx 1.6b&n;**&n;**&t;Supported SCSI features:&n;**&t;    Synchronous data transfers&n;**&t;    Wide16 SCSI BUS&n;**&t;    Disconnection/Reselection&n;**&t;    Tagged command queuing&n;**&t;    SCSI Parity checking&n;**&n;**&t;Supported NCR/SYMBIOS chips:&n;**&t;&t;53C810A&t;  (8 bits, Fast 10,&t; no rom BIOS) &n;**&t;&t;53C825A&t;  (Wide,   Fast 10,&t; on-board rom BIOS)&n;**&t;&t;53C860&t;  (8 bits, Fast 20,&t; no rom BIOS)&n;**&t;&t;53C875&t;  (Wide,   Fast 20,&t; on-board rom BIOS)&n;**&t;&t;53C876&t;  (Wide,   Fast 20 Dual, on-board rom BIOS)&n;**&t;&t;53C895&t;  (Wide,   Fast 40,&t; on-board rom BIOS)&n;**&t;&t;53C895A&t;  (Wide,   Fast 40,&t; on-board rom BIOS)&n;**&t;&t;53C896&t;  (Wide,   Fast 40 Dual, on-board rom BIOS)&n;**&t;&t;53C897&t;  (Wide,   Fast 40 Dual, on-board rom BIOS)&n;**&t;&t;53C1510D  (Wide,   Fast 40 Dual, on-board rom BIOS)&n;**&t;&t;53C1010&t;  (Wide,   Fast 80 Dual, on-board rom BIOS)&n;**&t;&t;53C1010_66(Wide,   Fast 80 Dual, on-board rom BIOS, 33/66MHz PCI)&n;**&n;**&t;Other features:&n;**&t;&t;Memory mapped IO&n;**&t;&t;Module&n;**&t;&t;Shared IRQ&n;*/
multiline_comment|/*&n;**&t;Name and version of the driver&n;*/
DECL|macro|SCSI_NCR_DRIVER_NAME
mdefine_line|#define SCSI_NCR_DRIVER_NAME&t;&quot;sym53c8xx - version 1.6b&quot;
multiline_comment|/* #define DEBUG_896R1 */
DECL|macro|SCSI_NCR_OPTIMIZE_896
mdefine_line|#define SCSI_NCR_OPTIMIZE_896
multiline_comment|/* #define SCSI_NCR_OPTIMIZE_896_1 */
DECL|macro|SCSI_NCR_DEBUG_FLAGS
mdefine_line|#define SCSI_NCR_DEBUG_FLAGS&t;(0)
DECL|macro|NAME53C
mdefine_line|#define NAME53C&t;&t;&quot;sym53c&quot;
DECL|macro|NAME53C8XX
mdefine_line|#define NAME53C8XX&t;&quot;sym53c8xx&quot;
multiline_comment|/*==========================================================&n;**&n;**      Include files&n;**&n;**==========================================================&n;*/
DECL|macro|LinuxVersionCode
mdefine_line|#define LinuxVersionCode(v, p, s) (((v)&lt;&lt;16)+((p)&lt;&lt;8)+(s))
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,3,17)
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#elif LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,93)
macro_line|#include &lt;asm/spinlock.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,35)
macro_line|#include &lt;linux/init.h&gt;
macro_line|#endif
macro_line|#ifndef&t;__init
DECL|macro|__init
mdefine_line|#define&t;__init
macro_line|#endif
macro_line|#ifndef&t;__initdata
DECL|macro|__initdata
mdefine_line|#define&t;__initdata
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &lt;= LinuxVersionCode(2,1,92)
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#endif
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &lt;linux/types.h&gt;
multiline_comment|/*&n;**&t;Define BITS_PER_LONG for earlier linux versions.&n;*/
macro_line|#ifndef&t;BITS_PER_LONG
macro_line|#if (~0UL) == 0xffffffffUL
DECL|macro|BITS_PER_LONG
mdefine_line|#define&t;BITS_PER_LONG&t;32
macro_line|#else
DECL|macro|BITS_PER_LONG
mdefine_line|#define&t;BITS_PER_LONG&t;64
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n;**&t;Define the BSD style u_int32 and u_int64 type.&n;**&t;Are in fact u_int32_t and u_int64_t :-)&n;*/
DECL|typedef|u_int32
r_typedef
id|u32
id|u_int32
suffix:semicolon
DECL|typedef|u_int64
r_typedef
id|u64
id|u_int64
suffix:semicolon
macro_line|#include &quot;sym53c8xx.h&quot;
multiline_comment|/*&n;**&t;Donnot compile integrity checking code for Linux-2.3.0 &n;**&t;and above since SCSI data structures are not ready yet.&n;*/
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,3,0)
DECL|macro|SCSI_NCR_INTEGRITY_CHECKING
mdefine_line|#define&t;SCSI_NCR_INTEGRITY_CHECKING
macro_line|#endif
DECL|macro|MIN
mdefine_line|#define MIN(a,b)        (((a) &lt; (b)) ? (a) : (b))
DECL|macro|MAX
mdefine_line|#define MAX(a,b)        (((a) &gt; (b)) ? (a) : (b))
multiline_comment|/*&n;**&t;Hmmm... What complex some PCI-HOST bridges actually are, &n;**&t;despite the fact that the PCI specifications are looking &n;**&t;so smart and simple! ;-)&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,3,47)
DECL|macro|SCSI_NCR_DYNAMIC_DMA_MAPPING
mdefine_line|#define SCSI_NCR_DYNAMIC_DMA_MAPPING
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;A la VMS/CAM-3 queue management.&n;**&t;Implemented from linux list management.&n;**&n;**==========================================================&n;*/
DECL|struct|xpt_quehead
r_typedef
r_struct
id|xpt_quehead
(brace
DECL|member|flink
r_struct
id|xpt_quehead
op_star
id|flink
suffix:semicolon
multiline_comment|/* Forward  pointer */
DECL|member|blink
r_struct
id|xpt_quehead
op_star
id|blink
suffix:semicolon
multiline_comment|/* Backward pointer */
DECL|typedef|XPT_QUEHEAD
)brace
id|XPT_QUEHEAD
suffix:semicolon
DECL|macro|xpt_que_init
mdefine_line|#define xpt_que_init(ptr) do { &bslash;&n;&t;(ptr)-&gt;flink = (ptr); (ptr)-&gt;blink = (ptr); &bslash;&n;} while (0)
DECL|function|__xpt_que_add
r_static
r_inline
r_void
id|__xpt_que_add
c_func
(paren
r_struct
id|xpt_quehead
op_star
r_new
comma
r_struct
id|xpt_quehead
op_star
id|blink
comma
r_struct
id|xpt_quehead
op_star
id|flink
)paren
(brace
id|flink-&gt;blink
op_assign
r_new
suffix:semicolon
r_new
op_member_access_from_pointer
id|flink
op_assign
id|flink
suffix:semicolon
r_new
op_member_access_from_pointer
id|blink
op_assign
id|blink
suffix:semicolon
id|blink-&gt;flink
op_assign
r_new
suffix:semicolon
)brace
DECL|function|__xpt_que_del
r_static
r_inline
r_void
id|__xpt_que_del
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|blink
comma
r_struct
id|xpt_quehead
op_star
id|flink
)paren
(brace
id|flink-&gt;blink
op_assign
id|blink
suffix:semicolon
id|blink-&gt;flink
op_assign
id|flink
suffix:semicolon
)brace
DECL|function|xpt_que_empty
r_static
r_inline
r_int
id|xpt_que_empty
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|head
)paren
(brace
r_return
id|head-&gt;flink
op_eq
id|head
suffix:semicolon
)brace
DECL|function|xpt_que_splice
r_static
r_inline
r_void
id|xpt_que_splice
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|list
comma
r_struct
id|xpt_quehead
op_star
id|head
)paren
(brace
r_struct
id|xpt_quehead
op_star
id|first
op_assign
id|list-&gt;flink
suffix:semicolon
r_if
c_cond
(paren
id|first
op_ne
id|list
)paren
(brace
r_struct
id|xpt_quehead
op_star
id|last
op_assign
id|list-&gt;blink
suffix:semicolon
r_struct
id|xpt_quehead
op_star
id|at
op_assign
id|head-&gt;flink
suffix:semicolon
id|first-&gt;blink
op_assign
id|head
suffix:semicolon
id|head-&gt;flink
op_assign
id|first
suffix:semicolon
id|last-&gt;flink
op_assign
id|at
suffix:semicolon
id|at-&gt;blink
op_assign
id|last
suffix:semicolon
)brace
)brace
DECL|macro|xpt_que_entry
mdefine_line|#define xpt_que_entry(ptr, type, member) &bslash;&n;&t;((type *)((char *)(ptr)-(unsigned long)(&amp;((type *)0)-&gt;member)))
DECL|macro|xpt_insque
mdefine_line|#define xpt_insque(new, pos)&t;&t;__xpt_que_add(new, pos, (pos)-&gt;flink)
DECL|macro|xpt_remque
mdefine_line|#define xpt_remque(el)&t;&t;&t;__xpt_que_del((el)-&gt;blink, (el)-&gt;flink)
DECL|macro|xpt_insque_head
mdefine_line|#define xpt_insque_head(new, head)&t;__xpt_que_add(new, head, (head)-&gt;flink)
DECL|function|xpt_remque_head
r_static
r_inline
r_struct
id|xpt_quehead
op_star
id|xpt_remque_head
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|head
)paren
(brace
r_struct
id|xpt_quehead
op_star
id|elem
op_assign
id|head-&gt;flink
suffix:semicolon
r_if
c_cond
(paren
id|elem
op_ne
id|head
)paren
id|__xpt_que_del
c_func
(paren
id|head
comma
id|elem-&gt;flink
)paren
suffix:semicolon
r_else
id|elem
op_assign
l_int|0
suffix:semicolon
r_return
id|elem
suffix:semicolon
)brace
DECL|macro|xpt_insque_tail
mdefine_line|#define xpt_insque_tail(new, head)&t;__xpt_que_add(new, (head)-&gt;blink, head)
DECL|function|xpt_remque_tail
r_static
r_inline
r_struct
id|xpt_quehead
op_star
id|xpt_remque_tail
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|head
)paren
(brace
r_struct
id|xpt_quehead
op_star
id|elem
op_assign
id|head-&gt;blink
suffix:semicolon
r_if
c_cond
(paren
id|elem
op_ne
id|head
)paren
id|__xpt_que_del
c_func
(paren
id|elem-&gt;blink
comma
id|head
)paren
suffix:semicolon
r_else
id|elem
op_assign
l_int|0
suffix:semicolon
r_return
id|elem
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;On x86 architecture, write buffers management does &n;**&t;not reorder writes to memory. So, using compiler &n;**&t;optimization barriers is enough to guarantee some &n;**&t;ordering when the CPU is writing data accessed by &n;**&t;the NCR.&n;**&t;On Alpha architecture, explicit memory barriers have &n;**&t;to be used.&n;**&t;Other architectures are defaulted to mb() macro if  &n;**&t;defined, otherwise use compiler barrier.&n;**&n;**==========================================================&n;*/
macro_line|#if defined(__i386__)
DECL|macro|MEMORY_BARRIER
mdefine_line|#define MEMORY_BARRIER()&t;barrier()
macro_line|#elif defined(__alpha__)
DECL|macro|MEMORY_BARRIER
mdefine_line|#define MEMORY_BARRIER()&t;mb()
macro_line|#else
macro_line|#  ifdef mb
DECL|macro|MEMORY_BARRIER
macro_line|#  define MEMORY_BARRIER()&t;mb()
macro_line|#  else
DECL|macro|MEMORY_BARRIER
macro_line|#  define MEMORY_BARRIER()&t;barrier()
macro_line|#  endif
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;Configuration and Debugging&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**    SCSI address of this device.&n;**    The boot routines should have set it.&n;**    If not, use this.&n;*/
macro_line|#ifndef SCSI_NCR_MYADDR
DECL|macro|SCSI_NCR_MYADDR
mdefine_line|#define SCSI_NCR_MYADDR      (7)
macro_line|#endif
multiline_comment|/*&n;**    The maximum number of tags per logic unit.&n;**    Used only for devices that support tags.&n;*/
macro_line|#ifndef SCSI_NCR_MAX_TAGS
DECL|macro|SCSI_NCR_MAX_TAGS
mdefine_line|#define SCSI_NCR_MAX_TAGS    (8)
macro_line|#endif
multiline_comment|/*&n;**    TAGS are actually unlimited (256 tags/lun).&n;**    But Linux only supports 255. :)&n;*/
macro_line|#if&t;SCSI_NCR_MAX_TAGS &gt; 255
DECL|macro|MAX_TAGS
mdefine_line|#define&t;MAX_TAGS&t;255
macro_line|#else
DECL|macro|MAX_TAGS
mdefine_line|#define&t;MAX_TAGS SCSI_NCR_MAX_TAGS
macro_line|#endif
multiline_comment|/*&n;**    Since the ncr chips only have a 8 bit ALU, we try to be clever &n;**    about offset calculation in the TASK TABLE per LUN that is an &n;**    array of DWORDS = 4 bytes.&n;*/
macro_line|#if&t;MAX_TAGS &gt; (512/4)
DECL|macro|MAX_TASKS
mdefine_line|#define MAX_TASKS  (1024/4)
macro_line|#elif&t;MAX_TAGS &gt; (256/4) 
DECL|macro|MAX_TASKS
mdefine_line|#define MAX_TASKS  (512/4)
macro_line|#else
DECL|macro|MAX_TASKS
mdefine_line|#define MAX_TASKS  (256/4)
macro_line|#endif
multiline_comment|/*&n;**    This one means &squot;NO TAG for this job&squot;&n;*/
DECL|macro|NO_TAG
mdefine_line|#define NO_TAG&t;(256)
multiline_comment|/*&n;**    Number of targets supported by the driver.&n;**    n permits target numbers 0..n-1.&n;**    Default is 16, meaning targets #0..#15.&n;**    #7 .. is myself.&n;*/
macro_line|#ifdef SCSI_NCR_MAX_TARGET
DECL|macro|MAX_TARGET
mdefine_line|#define MAX_TARGET  (SCSI_NCR_MAX_TARGET)
macro_line|#else
DECL|macro|MAX_TARGET
mdefine_line|#define MAX_TARGET  (16)
macro_line|#endif
multiline_comment|/*&n;**    Number of logic units supported by the driver.&n;**    n enables logic unit numbers 0..n-1.&n;**    The common SCSI devices require only&n;**    one lun, so take 1 as the default.&n;*/
macro_line|#ifdef SCSI_NCR_MAX_LUN
DECL|macro|MAX_LUN
mdefine_line|#define MAX_LUN    64
macro_line|#else
DECL|macro|MAX_LUN
mdefine_line|#define MAX_LUN    (1)
macro_line|#endif
multiline_comment|/*&n;**    Asynchronous pre-scaler (ns). Shall be 40 for &n;**    the SCSI timings to be compliant.&n;*/
macro_line|#ifndef SCSI_NCR_MIN_ASYNC
DECL|macro|SCSI_NCR_MIN_ASYNC
mdefine_line|#define SCSI_NCR_MIN_ASYNC (40)
macro_line|#endif
multiline_comment|/*&n;**    The maximum number of jobs scheduled for starting.&n;**    We allocate 4 entries more than the value we announce &n;**    to the SCSI upper layer. Guess why ! :-)&n;*/
macro_line|#ifdef SCSI_NCR_CAN_QUEUE
DECL|macro|MAX_START
mdefine_line|#define MAX_START   (SCSI_NCR_CAN_QUEUE + 4)
macro_line|#else
DECL|macro|MAX_START
mdefine_line|#define MAX_START   (MAX_TARGET + 7 * MAX_TAGS)
macro_line|#endif
multiline_comment|/*&n;**    We donnot want to allocate more than 1 PAGE for the &n;**    the start queue and the done queue. We hard-code entry &n;**    size to 8 in order to let cpp do the checking.&n;**    Allows 512-4=508 pending IOs for i386 but Linux seems for &n;**    now not able to provide the driver with this amount of IOs.&n;*/
macro_line|#if&t;MAX_START &gt; PAGE_SIZE/8
DECL|macro|MAX_START
macro_line|#undef&t;MAX_START
DECL|macro|MAX_START
mdefine_line|#define MAX_START (PAGE_SIZE/8)
macro_line|#endif
multiline_comment|/*&n;**    The maximum number of segments a transfer is split into.&n;**    We support up to 127 segments for both read and write.&n;*/
DECL|macro|MAX_SCATTER
mdefine_line|#define MAX_SCATTER (SCSI_NCR_MAX_SCATTER)
DECL|macro|SCR_SG_SIZE
mdefine_line|#define&t;SCR_SG_SIZE&t;(2)
multiline_comment|/*&n;**    Io mapped or memory mapped.&n;*/
macro_line|#if defined(SCSI_NCR_IOMAPPED) || defined(SCSI_NCR_PCI_MEM_NOT_SUPPORTED)
DECL|macro|NCR_IOMAPPED
mdefine_line|#define NCR_IOMAPPED
macro_line|#endif
multiline_comment|/*&n;**&t;other&n;*/
DECL|macro|NCR_SNOOP_TIMEOUT
mdefine_line|#define NCR_SNOOP_TIMEOUT (1000000)
multiline_comment|/*==========================================================&n;**&n;**&t;Miscallaneous BSDish defines.&n;**&n;**==========================================================&n;*/
DECL|macro|u_char
mdefine_line|#define u_char&t;&t;unsigned char
DECL|macro|u_short
mdefine_line|#define u_short&t;&t;unsigned short
DECL|macro|u_int
mdefine_line|#define u_int&t;&t;unsigned int
DECL|macro|u_long
mdefine_line|#define u_long&t;&t;unsigned long
macro_line|#ifndef bcopy
DECL|macro|bcopy
mdefine_line|#define bcopy(s, d, n)&t;memcpy((d), (s), (n))
macro_line|#endif
macro_line|#ifndef bzero
DECL|macro|bzero
mdefine_line|#define bzero(d, n)&t;memset((d), 0, (n))
macro_line|#endif
macro_line|#ifndef offsetof
DECL|macro|offsetof
mdefine_line|#define offsetof(t, m)&t;((size_t) (&amp;((t *)0)-&gt;m))
macro_line|#endif
multiline_comment|/*&n;**&t;Simple Wrapper to kernel PCI bus interface.&n;**&n;**&t;This wrapper allows to get rid of old kernel PCI interface &n;**&t;and still allows to preserve linux-2.0 compatibilty.&n;**&t;In fact, it is mostly an incomplete emulation of the new &n;**&t;PCI code for pre-2.2 kernels. When kernel-2.0 support &n;**&t;will be dropped, we will just have to remove most of this &n;**&t;code.&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,2,0)
DECL|typedef|pcidev_t
r_typedef
r_struct
id|pci_dev
op_star
id|pcidev_t
suffix:semicolon
DECL|macro|PCIDEV_NULL
mdefine_line|#define PCIDEV_NULL&t;&t;(0)
DECL|macro|PciBusNumber
mdefine_line|#define PciBusNumber(d)&t;&t;(d)-&gt;bus-&gt;number
DECL|macro|PciDeviceFn
mdefine_line|#define PciDeviceFn(d)&t;&t;(d)-&gt;devfn
DECL|macro|PciVendorId
mdefine_line|#define PciVendorId(d)&t;&t;(d)-&gt;vendor
DECL|macro|PciDeviceId
mdefine_line|#define PciDeviceId(d)&t;&t;(d)-&gt;device
DECL|macro|PciIrqLine
mdefine_line|#define PciIrqLine(d)&t;&t;(d)-&gt;irq
macro_line|#if LINUX_VERSION_CODE &gt; LinuxVersionCode(2,3,12)
r_static
r_int
id|__init
DECL|function|pci_get_base_address
id|pci_get_base_address
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_int
id|index
comma
id|u_long
op_star
id|base
)paren
(brace
op_star
id|base
op_assign
id|pdev-&gt;resource
(braket
id|index
)braket
dot
id|start
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pdev-&gt;resource
(braket
id|index
)braket
dot
id|flags
op_amp
l_int|0x7
)paren
op_eq
l_int|0x4
)paren
op_increment
id|index
suffix:semicolon
r_return
op_increment
id|index
suffix:semicolon
)brace
macro_line|#else
r_static
r_int
id|__init
DECL|function|pci_get_base_address
id|pci_get_base_address
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_int
id|index
comma
id|u_long
op_star
id|base
)paren
(brace
op_star
id|base
op_assign
id|pdev-&gt;base_address
(braket
id|index
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|base
op_amp
l_int|0x7
)paren
op_eq
l_int|0x4
)paren
(brace
macro_line|#if BITS_PER_LONG &gt; 32
op_star
id|base
op_or_assign
(paren
(paren
(paren
id|u_long
)paren
id|pdev-&gt;base_address
(braket
id|index
)braket
)paren
op_lshift
l_int|32
)paren
suffix:semicolon
macro_line|#endif
op_increment
id|index
suffix:semicolon
)brace
r_return
id|index
suffix:semicolon
)brace
macro_line|#endif
macro_line|#else&t;/* Incomplete emulation of current PCI code for pre-2.2 kernels */
DECL|typedef|pcidev_t
r_typedef
r_int
r_int
id|pcidev_t
suffix:semicolon
DECL|macro|PCIDEV_NULL
mdefine_line|#define PCIDEV_NULL&t;&t;(~0u)
DECL|macro|PciBusNumber
mdefine_line|#define PciBusNumber(d)&t;&t;((d)&gt;&gt;8)
DECL|macro|PciDeviceFn
mdefine_line|#define PciDeviceFn(d)&t;&t;((d)&amp;0xff)
DECL|macro|__PciDev
mdefine_line|#define __PciDev(busn, devfn)&t;(((busn)&lt;&lt;8)+(devfn))
DECL|macro|pci_present
mdefine_line|#define pci_present pcibios_present
DECL|macro|pci_read_config_byte
mdefine_line|#define pci_read_config_byte(d, w, v) &bslash;&n;&t;pcibios_read_config_byte(PciBusNumber(d), PciDeviceFn(d), w, v)
DECL|macro|pci_read_config_word
mdefine_line|#define pci_read_config_word(d, w, v) &bslash;&n;&t;pcibios_read_config_word(PciBusNumber(d), PciDeviceFn(d), w, v)
DECL|macro|pci_read_config_dword
mdefine_line|#define pci_read_config_dword(d, w, v) &bslash;&n;&t;pcibios_read_config_dword(PciBusNumber(d), PciDeviceFn(d), w, v)
DECL|macro|pci_write_config_byte
mdefine_line|#define pci_write_config_byte(d, w, v) &bslash;&n;&t;pcibios_write_config_byte(PciBusNumber(d), PciDeviceFn(d), w, v)
DECL|macro|pci_write_config_word
mdefine_line|#define pci_write_config_word(d, w, v) &bslash;&n;&t;pcibios_write_config_word(PciBusNumber(d), PciDeviceFn(d), w, v)
DECL|macro|pci_write_config_dword
mdefine_line|#define pci_write_config_dword(d, w, v) &bslash;&n;&t;pcibios_write_config_dword(PciBusNumber(d), PciDeviceFn(d), w, v)
r_static
id|pcidev_t
id|__init
DECL|function|pci_find_device
id|pci_find_device
c_func
(paren
r_int
r_int
id|vendor
comma
r_int
r_int
id|device
comma
id|pcidev_t
id|prev
)paren
(brace
r_static
r_int
r_int
id|pci_index
suffix:semicolon
r_int
id|retv
suffix:semicolon
r_int
r_char
id|bus_number
comma
id|device_fn
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_eq
id|PCIDEV_NULL
)paren
id|pci_index
op_assign
l_int|0
suffix:semicolon
r_else
op_increment
id|pci_index
suffix:semicolon
id|retv
op_assign
id|pcibios_find_device
(paren
id|vendor
comma
id|device
comma
id|pci_index
comma
op_amp
id|bus_number
comma
op_amp
id|device_fn
)paren
suffix:semicolon
r_return
id|retv
ques
c_cond
id|PCIDEV_NULL
suffix:colon
id|__PciDev
c_func
(paren
id|bus_number
comma
id|device_fn
)paren
suffix:semicolon
)brace
DECL|function|PciVendorId
r_static
id|u_short
id|__init
id|PciVendorId
c_func
(paren
id|pcidev_t
id|dev
)paren
(brace
id|u_short
id|vendor_id
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_VENDOR_ID
comma
op_amp
id|vendor_id
)paren
suffix:semicolon
r_return
id|vendor_id
suffix:semicolon
)brace
DECL|function|PciDeviceId
r_static
id|u_short
id|__init
id|PciDeviceId
c_func
(paren
id|pcidev_t
id|dev
)paren
(brace
id|u_short
id|device_id
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_DEVICE_ID
comma
op_amp
id|device_id
)paren
suffix:semicolon
r_return
id|device_id
suffix:semicolon
)brace
DECL|function|PciIrqLine
r_static
id|u_int
id|__init
id|PciIrqLine
c_func
(paren
id|pcidev_t
id|dev
)paren
(brace
id|u_char
id|irq
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_INTERRUPT_LINE
comma
op_amp
id|irq
)paren
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|pci_get_base_address
id|pci_get_base_address
c_func
(paren
id|pcidev_t
id|dev
comma
r_int
id|offset
comma
id|u_long
op_star
id|base
)paren
(brace
id|u_int32
id|tmp
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PCI_BASE_ADDRESS_0
op_plus
id|offset
comma
op_amp
id|tmp
)paren
suffix:semicolon
op_star
id|base
op_assign
id|tmp
suffix:semicolon
id|offset
op_add_assign
r_sizeof
(paren
id|u_int32
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
l_int|0x7
)paren
op_eq
l_int|0x4
)paren
(brace
macro_line|#if BITS_PER_LONG &gt; 32
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PCI_BASE_ADDRESS_0
op_plus
id|offset
comma
op_amp
id|tmp
)paren
suffix:semicolon
op_star
id|base
op_or_assign
(paren
(paren
(paren
id|u_long
)paren
id|tmp
)paren
op_lshift
l_int|32
)paren
suffix:semicolon
macro_line|#endif
id|offset
op_add_assign
r_sizeof
(paren
id|u_int32
)paren
suffix:semicolon
)brace
r_return
id|offset
suffix:semicolon
)brace
macro_line|#endif&t;/* LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,2,0) */
multiline_comment|/*==========================================================&n;**&n;**&t;Debugging tags&n;**&n;**==========================================================&n;*/
DECL|macro|DEBUG_ALLOC
mdefine_line|#define DEBUG_ALLOC    (0x0001)
DECL|macro|DEBUG_PHASE
mdefine_line|#define DEBUG_PHASE    (0x0002)
DECL|macro|DEBUG_QUEUE
mdefine_line|#define DEBUG_QUEUE    (0x0008)
DECL|macro|DEBUG_RESULT
mdefine_line|#define DEBUG_RESULT   (0x0010)
DECL|macro|DEBUG_POINTER
mdefine_line|#define DEBUG_POINTER  (0x0020)
DECL|macro|DEBUG_SCRIPT
mdefine_line|#define DEBUG_SCRIPT   (0x0040)
DECL|macro|DEBUG_TINY
mdefine_line|#define DEBUG_TINY     (0x0080)
DECL|macro|DEBUG_TIMING
mdefine_line|#define DEBUG_TIMING   (0x0100)
DECL|macro|DEBUG_NEGO
mdefine_line|#define DEBUG_NEGO     (0x0200)
DECL|macro|DEBUG_TAGS
mdefine_line|#define DEBUG_TAGS     (0x0400)
DECL|macro|DEBUG_IC
mdefine_line|#define DEBUG_IC       (0x0800)
multiline_comment|/*&n;**    Enable/Disable debug messages.&n;**    Can be changed at runtime too.&n;*/
macro_line|#ifdef SCSI_NCR_DEBUG_INFO_SUPPORT
DECL|variable|ncr_debug
r_static
r_int
id|ncr_debug
op_assign
id|SCSI_NCR_DEBUG_FLAGS
suffix:semicolon
DECL|macro|DEBUG_FLAGS
mdefine_line|#define DEBUG_FLAGS ncr_debug
macro_line|#else
DECL|macro|DEBUG_FLAGS
mdefine_line|#define DEBUG_FLAGS&t;SCSI_NCR_DEBUG_FLAGS
macro_line|#endif
multiline_comment|/*&n;**&t;SMP threading.&n;**&n;**&t;Assuming that SMP systems are generally high end systems and may &n;**&t;use several SCSI adapters, we are using one lock per controller &n;**&t;instead of some global one. For the moment (linux-2.1.95), driver&squot;s &n;**&t;entry points are called with the &squot;io_request_lock&squot; lock held, so:&n;**&t;- We are uselessly loosing a couple of micro-seconds to lock the &n;**&t;  controller data structure.&n;**&t;- But the driver is not broken by design for SMP and so can be &n;**&t;  more resistant to bugs or bad changes in the IO sub-system code.&n;**&t;- A small advantage could be that the interrupt code is grained as &n;**&t;  wished (e.g.: threaded by controller).&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,93)
DECL|variable|sym53c8xx_lock
id|spinlock_t
id|sym53c8xx_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|macro|NCR_LOCK_DRIVER
mdefine_line|#define&t;NCR_LOCK_DRIVER(flags)     spin_lock_irqsave(&amp;sym53c8xx_lock, flags)
DECL|macro|NCR_UNLOCK_DRIVER
mdefine_line|#define&t;NCR_UNLOCK_DRIVER(flags)   spin_unlock_irqrestore(&amp;sym53c8xx_lock,flags)
DECL|macro|NCR_INIT_LOCK_NCB
mdefine_line|#define NCR_INIT_LOCK_NCB(np)      spin_lock_init(&amp;np-&gt;smp_lock);
DECL|macro|NCR_LOCK_NCB
mdefine_line|#define&t;NCR_LOCK_NCB(np, flags)    spin_lock_irqsave(&amp;np-&gt;smp_lock, flags)
DECL|macro|NCR_UNLOCK_NCB
mdefine_line|#define&t;NCR_UNLOCK_NCB(np, flags)  spin_unlock_irqrestore(&amp;np-&gt;smp_lock, flags)
DECL|macro|NCR_LOCK_SCSI_DONE
mdefine_line|#define&t;NCR_LOCK_SCSI_DONE(np, flags) &bslash;&n;&t;&t;spin_lock_irqsave(&amp;io_request_lock, flags)
DECL|macro|NCR_UNLOCK_SCSI_DONE
mdefine_line|#define&t;NCR_UNLOCK_SCSI_DONE(np, flags) &bslash;&n;&t;&t;spin_unlock_irqrestore(&amp;io_request_lock, flags)
macro_line|#else
DECL|macro|NCR_LOCK_DRIVER
mdefine_line|#define&t;NCR_LOCK_DRIVER(flags)     do { save_flags(flags); cli(); } while (0)
DECL|macro|NCR_UNLOCK_DRIVER
mdefine_line|#define&t;NCR_UNLOCK_DRIVER(flags)   do { restore_flags(flags); } while (0)
DECL|macro|NCR_INIT_LOCK_NCB
mdefine_line|#define&t;NCR_INIT_LOCK_NCB(np)      do { } while (0)
DECL|macro|NCR_LOCK_NCB
mdefine_line|#define&t;NCR_LOCK_NCB(np, flags)    do { save_flags(flags); cli(); } while (0)
DECL|macro|NCR_UNLOCK_NCB
mdefine_line|#define&t;NCR_UNLOCK_NCB(np, flags)  do { restore_flags(flags); } while (0)
DECL|macro|NCR_LOCK_SCSI_DONE
mdefine_line|#define&t;NCR_LOCK_SCSI_DONE(np, flags)    do {;} while (0)
DECL|macro|NCR_UNLOCK_SCSI_DONE
mdefine_line|#define&t;NCR_UNLOCK_SCSI_DONE(np, flags)  do {;} while (0)
macro_line|#endif
multiline_comment|/*&n;**&t;Memory mapped IO&n;**&n;**&t;Since linux-2.1, we must use ioremap() to map the io memory space.&n;**&t;iounmap() to unmap it. That allows portability.&n;**&t;Linux 1.3.X and 2.0.X allow to remap physical pages addresses greater &n;**&t;than the highest physical memory address to kernel virtual pages with &n;**&t;vremap() / vfree(). That was not portable but worked with i386 &n;**&t;architecture.&n;*/
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,1,0)
DECL|macro|ioremap
mdefine_line|#define ioremap vremap
DECL|macro|iounmap
mdefine_line|#define iounmap vfree
macro_line|#endif
macro_line|#ifdef __sparc__
macro_line|#  include &lt;asm/irq.h&gt;
DECL|macro|pcivtobus
macro_line|#  define pcivtobus(p)&t;&t;&t;bus_dvma_to_mem(p)
DECL|macro|memcpy_to_pci
macro_line|#  define memcpy_to_pci(a, b, c)&t;memcpy_toio((a), (b), (c))
macro_line|#elif defined(__alpha__)
DECL|macro|pcivtobus
macro_line|#  define pcivtobus(p)&t;&t;&t;((p) &amp; 0xfffffffful)
DECL|macro|memcpy_to_pci
macro_line|#  define memcpy_to_pci(a, b, c)&t;memcpy_toio((a), (b), (c))
macro_line|#elif defined(CONFIG_PPC)
DECL|macro|pcivtobus
macro_line|#  define pcivtobus(p)&t;&t;&t;phys_to_bus(p)
DECL|macro|memcpy_to_pci
macro_line|#  define memcpy_to_pci(a, b, c)&t;memcpy_toio((a), (b), (c))
macro_line|#else&t;/* others */
DECL|macro|pcivtobus
macro_line|#  define pcivtobus(p)&t;&t;&t;(p)
DECL|macro|memcpy_to_pci
macro_line|#  define memcpy_to_pci(a, b, c)&t;memcpy_toio((a), (b), (c))
macro_line|#endif
macro_line|#ifndef SCSI_NCR_PCI_MEM_NOT_SUPPORTED
DECL|function|remap_pci_mem
r_static
id|u_long
id|__init
id|remap_pci_mem
c_func
(paren
id|u_long
id|base
comma
id|u_long
id|size
)paren
(brace
id|u_long
id|page_base
op_assign
(paren
(paren
id|u_long
)paren
id|base
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|u_long
id|page_offs
op_assign
(paren
(paren
id|u_long
)paren
id|base
)paren
op_minus
id|page_base
suffix:semicolon
id|u_long
id|page_remapped
op_assign
(paren
id|u_long
)paren
id|ioremap
c_func
(paren
id|page_base
comma
id|page_offs
op_plus
id|size
)paren
suffix:semicolon
r_return
id|page_remapped
ques
c_cond
(paren
id|page_remapped
op_plus
id|page_offs
)paren
suffix:colon
l_int|0UL
suffix:semicolon
)brace
DECL|function|unmap_pci_mem
r_static
r_void
id|__init
id|unmap_pci_mem
c_func
(paren
id|u_long
id|vaddr
comma
id|u_long
id|size
)paren
(brace
r_if
c_cond
(paren
id|vaddr
)paren
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|vaddr
op_amp
id|PAGE_MASK
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* not def SCSI_NCR_PCI_MEM_NOT_SUPPORTED */
multiline_comment|/*&n;**&t;Insert a delay in micro-seconds and milli-seconds.&n;**&t;-------------------------------------------------&n;**&t;Under Linux, udelay() is restricted to delay &lt; 1 milli-second.&n;**&t;In fact, it generally works for up to 1 second delay.&n;**&t;Since 2.1.105, the mdelay() function is provided for delays &n;**&t;in milli-seconds.&n;**&t;Under 2.0 kernels, udelay() is an inline function that is very &n;**&t;inaccurate on Pentium processors.&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,105)
DECL|macro|UDELAY
mdefine_line|#define UDELAY udelay
DECL|macro|MDELAY
mdefine_line|#define MDELAY mdelay
macro_line|#else
DECL|function|UDELAY
r_static
r_void
id|UDELAY
c_func
(paren
r_int
id|us
)paren
(brace
id|udelay
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
DECL|function|MDELAY
r_static
r_void
id|MDELAY
c_func
(paren
r_int
id|ms
)paren
(brace
r_while
c_loop
(paren
id|ms
op_decrement
)paren
id|UDELAY
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;**&t;Simple power of two buddy-like allocator&n;**&t;----------------------------------------&n;**&t;This simple code is not intended to be fast, but to provide &n;**&t;power of 2 aligned memory allocations.&n;**&t;Since the SCRIPTS processor only supplies 8 bit arithmetic,&n;**&t;this allocator allows simple and fast address calculations  &n;**&t;from the SCRIPTS code. In addition, cache line alignment &n;**&t;is guaranteed for power of 2 cache line size.&n;**&t;Enhanced in linux-2.3.44 to provide a memory pool per pcidev &n;**&t;to support dynamic dma mapping. (I would have preferred a &n;**&t;real bus astraction, btw).&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,0)
DECL|macro|__GetFreePages
mdefine_line|#define __GetFreePages(flags, order) __get_free_pages(flags, order)
macro_line|#else
DECL|macro|__GetFreePages
mdefine_line|#define __GetFreePages(flags, order) __get_free_pages(flags, order, 0)
macro_line|#endif
DECL|macro|MEMO_SHIFT
mdefine_line|#define MEMO_SHIFT&t;4&t;/* 16 bytes minimum memory chunk */
macro_line|#if PAGE_SIZE &gt;= 8192
DECL|macro|MEMO_PAGE_ORDER
mdefine_line|#define MEMO_PAGE_ORDER&t;0&t;/* 1 PAGE  maximum */
macro_line|#else
DECL|macro|MEMO_PAGE_ORDER
mdefine_line|#define MEMO_PAGE_ORDER&t;1&t;/* 2 PAGES maximum */
macro_line|#endif
DECL|macro|MEMO_FREE_UNUSED
mdefine_line|#define MEMO_FREE_UNUSED&t;/* Free unused pages immediately */
DECL|macro|MEMO_WARN
mdefine_line|#define MEMO_WARN&t;1
DECL|macro|MEMO_GFP_FLAGS
mdefine_line|#define MEMO_GFP_FLAGS&t;GFP_ATOMIC
DECL|macro|MEMO_CLUSTER_SHIFT
mdefine_line|#define MEMO_CLUSTER_SHIFT&t;(PAGE_SHIFT+MEMO_PAGE_ORDER)
DECL|macro|MEMO_CLUSTER_SIZE
mdefine_line|#define MEMO_CLUSTER_SIZE&t;(1UL &lt;&lt; MEMO_CLUSTER_SHIFT)
DECL|macro|MEMO_CLUSTER_MASK
mdefine_line|#define MEMO_CLUSTER_MASK&t;(MEMO_CLUSTER_SIZE-1)
DECL|typedef|m_addr_t
r_typedef
id|u_long
id|m_addr_t
suffix:semicolon
multiline_comment|/* Enough bits to bit-hack addresses */
DECL|typedef|m_bush_t
r_typedef
id|pcidev_t
id|m_bush_t
suffix:semicolon
multiline_comment|/* Something that addresses DMAable */
DECL|struct|m_link
r_typedef
r_struct
id|m_link
(brace
multiline_comment|/* Link between free memory chunks */
DECL|member|next
r_struct
id|m_link
op_star
id|next
suffix:semicolon
DECL|typedef|m_link_s
)brace
id|m_link_s
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_DYNAMIC_DMA_MAPPING
DECL|struct|m_vtob
r_typedef
r_struct
id|m_vtob
(brace
multiline_comment|/* Virtual to Bus address translation */
DECL|member|next
r_struct
id|m_vtob
op_star
id|next
suffix:semicolon
DECL|member|vaddr
id|m_addr_t
id|vaddr
suffix:semicolon
DECL|member|baddr
id|m_addr_t
id|baddr
suffix:semicolon
DECL|typedef|m_vtob_s
)brace
id|m_vtob_s
suffix:semicolon
DECL|macro|VTOB_HASH_SHIFT
mdefine_line|#define VTOB_HASH_SHIFT&t;&t;5
DECL|macro|VTOB_HASH_SIZE
mdefine_line|#define VTOB_HASH_SIZE&t;&t;(1UL &lt;&lt; VTOB_HASH_SHIFT)
DECL|macro|VTOB_HASH_MASK
mdefine_line|#define VTOB_HASH_MASK&t;&t;(VTOB_HASH_SIZE-1)
DECL|macro|VTOB_HASH_CODE
mdefine_line|#define VTOB_HASH_CODE(m)&t;&bslash;&n;&t;((((m_addr_t) (m)) &gt;&gt; MEMO_CLUSTER_SHIFT) &amp; VTOB_HASH_MASK)
macro_line|#endif
DECL|struct|m_pool
r_typedef
r_struct
id|m_pool
(brace
multiline_comment|/* Memory pool of a given kind */
macro_line|#ifdef&t;SCSI_NCR_DYNAMIC_DMA_MAPPING
DECL|member|bush
id|m_bush_t
id|bush
suffix:semicolon
DECL|member|getp
id|m_addr_t
(paren
op_star
id|getp
)paren
(paren
r_struct
id|m_pool
op_star
)paren
suffix:semicolon
DECL|member|freep
r_void
(paren
op_star
id|freep
)paren
(paren
r_struct
id|m_pool
op_star
comma
id|m_addr_t
)paren
suffix:semicolon
DECL|macro|M_GETP
mdefine_line|#define M_GETP()&t;&t;mp-&gt;getp(mp)
DECL|macro|M_FREEP
mdefine_line|#define M_FREEP(p)&t;&t;mp-&gt;freep(mp, p)
DECL|macro|GetPages
mdefine_line|#define GetPages()&t;&t;__GetFreePages(MEMO_GFP_FLAGS, MEMO_PAGE_ORDER)
DECL|macro|FreePages
mdefine_line|#define FreePages(p)&t;&t;free_pages(p, MEMO_PAGE_ORDER)
DECL|member|nump
r_int
id|nump
suffix:semicolon
DECL|member|vtob
id|m_vtob_s
op_star
(paren
id|vtob
(braket
id|VTOB_HASH_SIZE
)braket
)paren
suffix:semicolon
DECL|member|next
r_struct
id|m_pool
op_star
id|next
suffix:semicolon
macro_line|#else
mdefine_line|#define M_GETP()&t;&t;__GetFreePages(MEMO_GFP_FLAGS, MEMO_PAGE_ORDER)
mdefine_line|#define M_FREEP(p)&t;&t;free_pages(p, MEMO_PAGE_ORDER)
macro_line|#endif&t;/* SCSI_NCR_DYNAMIC_DMA_MAPPING */
DECL|member|h
r_struct
id|m_link
id|h
(braket
id|PAGE_SHIFT
op_minus
id|MEMO_SHIFT
op_plus
id|MEMO_PAGE_ORDER
op_plus
l_int|1
)braket
suffix:semicolon
DECL|typedef|m_pool_s
)brace
id|m_pool_s
suffix:semicolon
DECL|function|___m_alloc
r_static
r_void
op_star
id|___m_alloc
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
r_int
id|size
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|s
op_assign
(paren
l_int|1
op_lshift
id|MEMO_SHIFT
)paren
suffix:semicolon
r_int
id|j
suffix:semicolon
id|m_addr_t
id|a
suffix:semicolon
id|m_link_s
op_star
id|h
op_assign
id|mp-&gt;h
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
(paren
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
id|s
)paren
(brace
id|s
op_lshift_assign
l_int|1
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|j
op_assign
id|i
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|h
(braket
id|j
)braket
dot
id|next
)paren
(brace
r_if
c_cond
(paren
id|s
op_eq
(paren
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
)paren
)paren
(brace
id|h
(braket
id|j
)braket
dot
id|next
op_assign
(paren
id|m_link_s
op_star
)paren
id|M_GETP
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|h
(braket
id|j
)braket
dot
id|next
)paren
id|h
(braket
id|j
)braket
dot
id|next-&gt;next
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
op_increment
id|j
suffix:semicolon
id|s
op_lshift_assign
l_int|1
suffix:semicolon
)brace
id|a
op_assign
(paren
id|m_addr_t
)paren
id|h
(braket
id|j
)braket
dot
id|next
suffix:semicolon
r_if
c_cond
(paren
id|a
)paren
(brace
id|h
(braket
id|j
)braket
dot
id|next
op_assign
id|h
(braket
id|j
)braket
dot
id|next-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|j
OG
id|i
)paren
(brace
id|j
op_sub_assign
l_int|1
suffix:semicolon
id|s
op_rshift_assign
l_int|1
suffix:semicolon
id|h
(braket
id|j
)braket
dot
id|next
op_assign
(paren
id|m_link_s
op_star
)paren
(paren
id|a
op_plus
id|s
)paren
suffix:semicolon
id|h
(braket
id|j
)braket
dot
id|next-&gt;next
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;___m_alloc(%d) = %p&bslash;n&quot;
comma
id|size
comma
(paren
r_void
op_star
)paren
id|a
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
r_void
op_star
)paren
id|a
suffix:semicolon
)brace
DECL|function|___m_free
r_static
r_void
id|___m_free
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
r_void
op_star
id|ptr
comma
r_int
id|size
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|s
op_assign
(paren
l_int|1
op_lshift
id|MEMO_SHIFT
)paren
suffix:semicolon
id|m_link_s
op_star
id|q
suffix:semicolon
id|m_addr_t
id|a
comma
id|b
suffix:semicolon
id|m_link_s
op_star
id|h
op_assign
id|mp-&gt;h
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;___m_free(%p, %d)&bslash;n&quot;
comma
id|ptr
comma
id|size
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|size
OG
(paren
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
)paren
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
id|s
)paren
(brace
id|s
op_lshift_assign
l_int|1
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|a
op_assign
(paren
id|m_addr_t
)paren
id|ptr
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
macro_line|#ifdef MEMO_FREE_UNUSED
r_if
c_cond
(paren
id|s
op_eq
(paren
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
)paren
)paren
(brace
id|M_FREEP
c_func
(paren
id|a
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
id|b
op_assign
id|a
op_xor
id|s
suffix:semicolon
id|q
op_assign
op_amp
id|h
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
id|q-&gt;next
op_logical_and
id|q-&gt;next
op_ne
(paren
id|m_link_s
op_star
)paren
id|b
)paren
(brace
id|q
op_assign
id|q-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;next
)paren
(brace
(paren
(paren
id|m_link_s
op_star
)paren
id|a
)paren
op_member_access_from_pointer
id|next
op_assign
id|h
(braket
id|i
)braket
dot
id|next
suffix:semicolon
id|h
(braket
id|i
)braket
dot
id|next
op_assign
(paren
id|m_link_s
op_star
)paren
id|a
suffix:semicolon
r_break
suffix:semicolon
)brace
id|q-&gt;next
op_assign
id|q-&gt;next-&gt;next
suffix:semicolon
id|a
op_assign
id|a
op_amp
id|b
suffix:semicolon
id|s
op_lshift_assign
l_int|1
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
)brace
DECL|function|__m_calloc2
r_static
r_void
op_star
id|__m_calloc2
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
r_int
id|size
comma
r_char
op_star
id|name
comma
r_int
id|uflags
)paren
(brace
r_void
op_star
id|p
suffix:semicolon
id|p
op_assign
id|___m_alloc
c_func
(paren
id|mp
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_ALLOC
)paren
id|printk
(paren
l_string|&quot;new %-10s[%4d] @%p.&bslash;n&quot;
comma
id|name
comma
id|size
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|bzero
c_func
(paren
id|p
comma
id|size
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|uflags
op_amp
id|MEMO_WARN
)paren
id|printk
(paren
id|NAME53C8XX
l_string|&quot;: failed to allocate %s[%d]&bslash;n&quot;
comma
id|name
comma
id|size
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|macro|__m_calloc
mdefine_line|#define __m_calloc(mp, s, n)&t;__m_calloc2(mp, s, n, MEMO_WARN)
DECL|function|__m_free
r_static
r_void
id|__m_free
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
r_void
op_star
id|ptr
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_ALLOC
)paren
id|printk
(paren
l_string|&quot;freeing %-10s[%4d] @%p.&bslash;n&quot;
comma
id|name
comma
id|size
comma
id|ptr
)paren
suffix:semicolon
id|___m_free
c_func
(paren
id|mp
comma
id|ptr
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * With pci bus iommu support, we use a default pool of unmapped memory &n; * for memory we donnot need to DMA from/to and one pool per pcidev for &n; * memory accessed by the PCI chip. `mp0&squot; is the default not DMAable pool.&n; */
macro_line|#ifndef&t;SCSI_NCR_DYNAMIC_DMA_MAPPING
DECL|variable|mp0
r_static
id|m_pool_s
id|mp0
suffix:semicolon
macro_line|#else
DECL|function|___mp0_getp
r_static
id|m_addr_t
id|___mp0_getp
c_func
(paren
id|m_pool_s
op_star
id|mp
)paren
(brace
id|m_addr_t
id|m
op_assign
id|GetPages
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
)paren
op_increment
id|mp-&gt;nump
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
DECL|function|___mp0_freep
r_static
r_void
id|___mp0_freep
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
id|m_addr_t
id|m
)paren
(brace
id|FreePages
c_func
(paren
id|m
)paren
suffix:semicolon
op_decrement
id|mp-&gt;nump
suffix:semicolon
)brace
DECL|variable|mp0
r_static
id|m_pool_s
id|mp0
op_assign
(brace
l_int|0
comma
id|___mp0_getp
comma
id|___mp0_freep
)brace
suffix:semicolon
macro_line|#endif&t;/* SCSI_NCR_DYNAMIC_DMA_MAPPING */
DECL|function|m_calloc
r_static
r_void
op_star
id|m_calloc
c_func
(paren
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
id|u_long
id|flags
suffix:semicolon
r_void
op_star
id|m
suffix:semicolon
id|NCR_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|m
op_assign
id|__m_calloc
c_func
(paren
op_amp
id|mp0
comma
id|size
comma
id|name
)paren
suffix:semicolon
id|NCR_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
DECL|function|m_free
r_static
r_void
id|m_free
c_func
(paren
r_void
op_star
id|ptr
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
id|u_long
id|flags
suffix:semicolon
id|NCR_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__m_free
c_func
(paren
op_amp
id|mp0
comma
id|ptr
comma
id|size
comma
id|name
)paren
suffix:semicolon
id|NCR_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * DMAable pools.&n; */
macro_line|#ifndef&t;SCSI_NCR_DYNAMIC_DMA_MAPPING
multiline_comment|/* Without pci bus iommu support, all the memory is assumed DMAable */
DECL|macro|__m_calloc_dma
mdefine_line|#define __m_calloc_dma(b, s, n)&t;&t;m_calloc(s, n)
DECL|macro|__m_free_dma
mdefine_line|#define __m_free_dma(b, p, s, n)&t;m_free(p, s, n)
DECL|macro|__vtobus
mdefine_line|#define __vtobus(b, p)&t;&t;&t;virt_to_bus(p)
macro_line|#else
multiline_comment|/*&n; * With pci bus iommu support, we maintain one pool per pcidev and a &n; * hashed reverse table for virtual to bus physical address translations.&n; */
DECL|function|___dma_getp
r_static
id|m_addr_t
id|___dma_getp
c_func
(paren
id|m_pool_s
op_star
id|mp
)paren
(brace
id|m_addr_t
id|vp
suffix:semicolon
id|m_vtob_s
op_star
id|vbp
suffix:semicolon
id|vbp
op_assign
id|__m_calloc
c_func
(paren
op_amp
id|mp0
comma
r_sizeof
(paren
op_star
id|vbp
)paren
comma
l_string|&quot;VTOB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vbp
)paren
(brace
id|dma_addr_t
id|daddr
suffix:semicolon
id|vp
op_assign
(paren
id|m_addr_t
)paren
id|pci_alloc_consistent
c_func
(paren
id|mp-&gt;bush
comma
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
comma
op_amp
id|daddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vp
)paren
(brace
r_int
id|hc
op_assign
id|VTOB_HASH_CODE
c_func
(paren
id|vp
)paren
suffix:semicolon
id|vbp-&gt;vaddr
op_assign
id|vp
suffix:semicolon
id|vbp-&gt;baddr
op_assign
id|daddr
suffix:semicolon
id|vbp-&gt;next
op_assign
id|mp-&gt;vtob
(braket
id|hc
)braket
suffix:semicolon
id|mp-&gt;vtob
(braket
id|hc
)braket
op_assign
id|vbp
suffix:semicolon
op_increment
id|mp-&gt;nump
suffix:semicolon
r_return
id|vp
suffix:semicolon
)brace
r_else
id|__m_free
c_func
(paren
op_amp
id|mp0
comma
id|vbp
comma
r_sizeof
(paren
op_star
id|vbp
)paren
comma
l_string|&quot;VTOB&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|___dma_freep
r_static
r_void
id|___dma_freep
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
id|m_addr_t
id|m
)paren
(brace
id|m_vtob_s
op_star
op_star
id|vbpp
comma
op_star
id|vbp
suffix:semicolon
r_int
id|hc
op_assign
id|VTOB_HASH_CODE
c_func
(paren
id|m
)paren
suffix:semicolon
id|vbpp
op_assign
op_amp
id|mp-&gt;vtob
(braket
id|hc
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|vbpp
op_logical_and
(paren
op_star
id|vbpp
)paren
op_member_access_from_pointer
id|vaddr
op_ne
id|m
)paren
id|vbpp
op_assign
op_amp
(paren
op_star
id|vbpp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
op_star
id|vbpp
)paren
(brace
id|vbp
op_assign
op_star
id|vbpp
suffix:semicolon
op_star
id|vbpp
op_assign
(paren
op_star
id|vbpp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|mp-&gt;bush
comma
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
comma
(paren
r_void
op_star
)paren
id|vbp-&gt;vaddr
comma
(paren
id|dma_addr_t
)paren
id|vbp-&gt;baddr
)paren
suffix:semicolon
id|__m_free
c_func
(paren
op_amp
id|mp0
comma
id|vbp
comma
r_sizeof
(paren
op_star
id|vbp
)paren
comma
l_string|&quot;VTOB&quot;
)paren
suffix:semicolon
op_decrement
id|mp-&gt;nump
suffix:semicolon
)brace
)brace
DECL|function|___get_dma_pool
r_static
r_inline
id|m_pool_s
op_star
id|___get_dma_pool
c_func
(paren
id|m_bush_t
id|bush
)paren
(brace
id|m_pool_s
op_star
id|mp
suffix:semicolon
r_for
c_loop
(paren
id|mp
op_assign
id|mp0.next
suffix:semicolon
id|mp
op_logical_and
id|mp-&gt;bush
op_ne
id|bush
suffix:semicolon
id|mp
op_assign
id|mp-&gt;next
)paren
suffix:semicolon
r_return
id|mp
suffix:semicolon
)brace
DECL|function|___cre_dma_pool
r_static
id|m_pool_s
op_star
id|___cre_dma_pool
c_func
(paren
id|m_bush_t
id|bush
)paren
(brace
id|m_pool_s
op_star
id|mp
suffix:semicolon
id|mp
op_assign
id|__m_calloc
c_func
(paren
op_amp
id|mp0
comma
r_sizeof
(paren
op_star
id|mp
)paren
comma
l_string|&quot;MPOOL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
(brace
id|bzero
c_func
(paren
id|mp
comma
r_sizeof
(paren
op_star
id|mp
)paren
)paren
suffix:semicolon
id|mp-&gt;bush
op_assign
id|bush
suffix:semicolon
id|mp-&gt;getp
op_assign
id|___dma_getp
suffix:semicolon
id|mp-&gt;freep
op_assign
id|___dma_freep
suffix:semicolon
id|mp-&gt;next
op_assign
id|mp0.next
suffix:semicolon
id|mp0.next
op_assign
id|mp
suffix:semicolon
)brace
r_return
id|mp
suffix:semicolon
)brace
DECL|function|___del_dma_pool
r_static
r_void
id|___del_dma_pool
c_func
(paren
id|m_pool_s
op_star
id|p
)paren
(brace
r_struct
id|m_pool
op_star
op_star
id|pp
op_assign
op_amp
id|mp0.next
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pp
op_logical_and
op_star
id|pp
op_ne
id|p
)paren
id|pp
op_assign
op_amp
(paren
op_star
id|pp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pp
)paren
(brace
op_star
id|pp
op_assign
(paren
op_star
id|pp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|__m_free
c_func
(paren
op_amp
id|mp0
comma
id|p
comma
r_sizeof
(paren
op_star
id|p
)paren
comma
l_string|&quot;MPOOL&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|__m_calloc_dma
r_static
r_void
op_star
id|__m_calloc_dma
c_func
(paren
id|m_bush_t
id|bush
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
id|u_long
id|flags
suffix:semicolon
r_struct
id|m_pool
op_star
id|mp
suffix:semicolon
r_void
op_star
id|m
op_assign
l_int|0
suffix:semicolon
id|NCR_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|mp
op_assign
id|___get_dma_pool
c_func
(paren
id|bush
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mp
)paren
id|mp
op_assign
id|___cre_dma_pool
c_func
(paren
id|bush
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
id|m
op_assign
id|__m_calloc
c_func
(paren
id|mp
comma
id|size
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_logical_and
op_logical_neg
id|mp-&gt;nump
)paren
id|___del_dma_pool
c_func
(paren
id|mp
)paren
suffix:semicolon
id|NCR_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
DECL|function|__m_free_dma
r_static
r_void
id|__m_free_dma
c_func
(paren
id|m_bush_t
id|bush
comma
r_void
op_star
id|m
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
id|u_long
id|flags
suffix:semicolon
r_struct
id|m_pool
op_star
id|mp
suffix:semicolon
id|NCR_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|mp
op_assign
id|___get_dma_pool
c_func
(paren
id|bush
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
id|__m_free
c_func
(paren
id|mp
comma
id|m
comma
id|size
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_logical_and
op_logical_neg
id|mp-&gt;nump
)paren
id|___del_dma_pool
c_func
(paren
id|mp
)paren
suffix:semicolon
id|NCR_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__vtobus
r_static
id|m_addr_t
id|__vtobus
c_func
(paren
id|m_bush_t
id|bush
comma
r_void
op_star
id|m
)paren
(brace
id|u_long
id|flags
suffix:semicolon
id|m_pool_s
op_star
id|mp
suffix:semicolon
r_int
id|hc
op_assign
id|VTOB_HASH_CODE
c_func
(paren
id|m
)paren
suffix:semicolon
id|m_vtob_s
op_star
id|vp
op_assign
l_int|0
suffix:semicolon
id|m_addr_t
id|a
op_assign
(paren
(paren
id|m_addr_t
)paren
id|m
)paren
op_amp
op_complement
id|MEMO_CLUSTER_MASK
suffix:semicolon
id|NCR_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|mp
op_assign
id|___get_dma_pool
c_func
(paren
id|bush
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
(brace
id|vp
op_assign
id|mp-&gt;vtob
(braket
id|hc
)braket
suffix:semicolon
r_while
c_loop
(paren
id|vp
op_logical_and
(paren
id|m_addr_t
)paren
id|vp-&gt;vaddr
op_ne
id|a
)paren
id|vp
op_assign
id|vp-&gt;next
suffix:semicolon
)brace
id|NCR_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|vp
ques
c_cond
id|vp-&gt;baddr
op_plus
(paren
(paren
(paren
id|m_addr_t
)paren
id|m
)paren
op_minus
id|a
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_NCR_DYNAMIC_DMA_MAPPING */
DECL|macro|_m_calloc_dma
mdefine_line|#define _m_calloc_dma(np, s, n)&t;&t;__m_calloc_dma(np-&gt;pdev, s, n)
DECL|macro|_m_free_dma
mdefine_line|#define _m_free_dma(np, p, s, n)&t;__m_free_dma(np-&gt;pdev, p, s, n)
DECL|macro|m_calloc_dma
mdefine_line|#define m_calloc_dma(s, n)&t;&t;_m_calloc_dma(np, s, n)
DECL|macro|m_free_dma
mdefine_line|#define m_free_dma(p, s, n)&t;&t;_m_free_dma(np, p, s, n)
DECL|macro|_vtobus
mdefine_line|#define _vtobus(np, p)&t;&t;&t;__vtobus(np-&gt;pdev, p)
DECL|macro|vtobus
mdefine_line|#define vtobus(p)&t;&t;&t;_vtobus(np, p)
multiline_comment|/*&n; *  Deal with DMA mapping/unmapping.&n; */
macro_line|#ifndef SCSI_NCR_DYNAMIC_DMA_MAPPING
multiline_comment|/* Linux versions prior to pci bus iommu kernel interface */
DECL|macro|__unmap_scsi_data
mdefine_line|#define __unmap_scsi_data(pdev, cmd)&t;do {; } while (0)
DECL|macro|__map_scsi_single_data
mdefine_line|#define __map_scsi_single_data(pdev, cmd) (__vtobus(pdev,(cmd)-&gt;request_buffer))
DECL|macro|__map_scsi_sg_data
mdefine_line|#define __map_scsi_sg_data(pdev, cmd)&t;((cmd)-&gt;use_sg)
DECL|macro|__sync_scsi_data
mdefine_line|#define __sync_scsi_data(pdev, cmd)&t;do {; } while (0)
DECL|macro|scsi_sg_dma_address
mdefine_line|#define scsi_sg_dma_address(sc)&t;&t;vtobus((sc)-&gt;address)
DECL|macro|scsi_sg_dma_len
mdefine_line|#define scsi_sg_dma_len(sc)&t;&t;((sc)-&gt;length)
macro_line|#else
multiline_comment|/* Linux version with pci bus iommu kernel interface */
multiline_comment|/* To keep track of the dma mapping (sg/single) that has been set */
DECL|macro|__data_mapped
mdefine_line|#define __data_mapped&t;SCp.phase
DECL|macro|__data_mapping
mdefine_line|#define __data_mapping&t;SCp.have_data_in
DECL|function|__unmap_scsi_data
r_static
r_void
id|__unmap_scsi_data
c_func
(paren
id|pcidev_t
id|pdev
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|dma_dir
op_assign
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;__data_mapped
)paren
(brace
r_case
l_int|2
suffix:colon
id|pci_unmap_sg
c_func
(paren
id|pdev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|pci_unmap_single
c_func
(paren
id|pdev
comma
id|cmd-&gt;__data_mapping
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cmd-&gt;__data_mapped
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|__map_scsi_single_data
r_static
id|u_long
id|__map_scsi_single_data
c_func
(paren
id|pcidev_t
id|pdev
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|dma_addr_t
id|mapping
suffix:semicolon
r_int
id|dma_dir
op_assign
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|mapping
op_assign
id|pci_map_single
c_func
(paren
id|pdev
comma
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
id|cmd-&gt;__data_mapped
op_assign
l_int|1
suffix:semicolon
id|cmd-&gt;__data_mapping
op_assign
id|mapping
suffix:semicolon
r_return
id|mapping
suffix:semicolon
)brace
DECL|function|__map_scsi_sg_data
r_static
r_int
id|__map_scsi_sg_data
c_func
(paren
id|pcidev_t
id|pdev
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|use_sg
suffix:semicolon
r_int
id|dma_dir
op_assign
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|use_sg
op_assign
id|pci_map_sg
c_func
(paren
id|pdev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
id|cmd-&gt;__data_mapped
op_assign
l_int|2
suffix:semicolon
id|cmd-&gt;__data_mapping
op_assign
id|use_sg
suffix:semicolon
r_return
id|use_sg
suffix:semicolon
)brace
DECL|function|__sync_scsi_data
r_static
r_void
id|__sync_scsi_data
c_func
(paren
id|pcidev_t
id|pdev
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|dma_dir
op_assign
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;__data_mapped
)paren
(brace
r_case
l_int|2
suffix:colon
id|pci_dma_sync_sg
c_func
(paren
id|pdev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|pci_dma_sync_single
c_func
(paren
id|pdev
comma
id|cmd-&gt;__data_mapping
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|macro|scsi_sg_dma_address
mdefine_line|#define scsi_sg_dma_address(sc)&t;&t;sg_dma_address(sc)
DECL|macro|scsi_sg_dma_len
mdefine_line|#define scsi_sg_dma_len(sc)&t;&t;sg_dma_len(sc)
macro_line|#endif&t;/* SCSI_NCR_DYNAMIC_DMA_MAPPING */
DECL|macro|unmap_scsi_data
mdefine_line|#define unmap_scsi_data(np, cmd)&t;__unmap_scsi_data(np-&gt;pdev, cmd)
DECL|macro|map_scsi_single_data
mdefine_line|#define map_scsi_single_data(np, cmd)&t;__map_scsi_single_data(np-&gt;pdev, cmd)
DECL|macro|map_scsi_sg_data
mdefine_line|#define map_scsi_sg_data(np, cmd)&t;__map_scsi_sg_data(np-&gt;pdev, cmd)
DECL|macro|sync_scsi_data
mdefine_line|#define sync_scsi_data(np, cmd)&t;&t;__sync_scsi_data(np-&gt;pdev, cmd)
multiline_comment|/*&n; * Print out some buffer.&n; */
DECL|function|ncr_print_hex
r_static
r_void
id|ncr_print_hex
c_func
(paren
id|u_char
op_star
id|p
comma
r_int
id|n
)paren
(brace
r_while
c_loop
(paren
id|n
op_decrement
OG
l_int|0
)paren
id|printk
(paren
l_string|&quot; %x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
)brace
DECL|function|ncr_printl_hex
r_static
r_void
id|ncr_printl_hex
c_func
(paren
r_char
op_star
id|label
comma
id|u_char
op_star
id|p
comma
r_int
id|n
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|label
)paren
suffix:semicolon
id|ncr_print_hex
c_func
(paren
id|p
comma
id|n
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Transfer direction&n;**&n;**&t;Until some linux kernel version near 2.3.40, low-level scsi &n;**&t;drivers were not told about data transfer direction.&n;**&t;We check the existence of this feature that has been expected &n;**&t;for a _long_ time by all SCSI driver developers by just &n;**&t;testing against the definition of SCSI_DATA_UNKNOWN. Indeed &n;**&t;this is a hack, but testing against a kernel version would &n;**&t;have been a shame. ;-)&n;*/
macro_line|#ifdef&t;SCSI_DATA_UNKNOWN
DECL|macro|scsi_data_direction
mdefine_line|#define scsi_data_direction(cmd)&t;(cmd-&gt;sc_data_direction)
macro_line|#else
DECL|macro|SCSI_DATA_UNKNOWN
mdefine_line|#define&t;SCSI_DATA_UNKNOWN&t;0
DECL|macro|SCSI_DATA_WRITE
mdefine_line|#define&t;SCSI_DATA_WRITE&t;&t;1
DECL|macro|SCSI_DATA_READ
mdefine_line|#define&t;SCSI_DATA_READ&t;&t;2
DECL|macro|SCSI_DATA_NONE
mdefine_line|#define&t;SCSI_DATA_NONE&t;&t;3
DECL|function|scsi_data_direction
r_static
id|__inline__
r_int
id|scsi_data_direction
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|direction
suffix:semicolon
r_switch
c_cond
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/*&t;READ(6)&t;&t;&t;&t;08 */
r_case
l_int|0x28
suffix:colon
multiline_comment|/*&t;READ(10)&t;&t;&t;28 */
r_case
l_int|0xA8
suffix:colon
multiline_comment|/*&t;READ(12)&t;&t;&t;A8 */
id|direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0A
suffix:colon
multiline_comment|/*&t;WRITE(6)&t;&t;&t;0A */
r_case
l_int|0x2A
suffix:colon
multiline_comment|/*&t;WRITE(10)&t;&t;&t;2A */
r_case
l_int|0xAA
suffix:colon
multiline_comment|/*&t;WRITE(12)&t;&t;&t;AA */
id|direction
op_assign
id|SCSI_DATA_WRITE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|direction
op_assign
id|SCSI_DATA_UNKNOWN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|direction
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_DATA_UNKNOWN */
multiline_comment|/*&n;**&t;Head of list of NCR boards&n;**&n;**&t;For kernel version &lt; 1.3.70, host is retrieved by its irq level.&n;**&t;For later kernels, the internal host control block address &n;**&t;(struct ncb) is used as device id parameter of the irq stuff.&n;*/
DECL|variable|first_host
r_static
r_struct
id|Scsi_Host
op_star
id|first_host
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;**&t;/proc directory entry and proc_info function&n;*/
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,3,27)
DECL|variable|proc_scsi_sym53c8xx
r_static
r_struct
id|proc_dir_entry
id|proc_scsi_sym53c8xx
op_assign
(brace
id|PROC_SCSI_SYM53C8XX
comma
l_int|9
comma
id|NAME53C8XX
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
l_int|2
)brace
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SCSI_NCR_PROC_INFO_SUPPORT
r_static
r_int
id|sym53c8xx_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|func
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;**&t;Driver setup.&n;**&n;**&t;This structure is initialized from linux config options.&n;**&t;It can be overridden at boot-up by the boot command line.&n;*/
r_static
r_struct
id|ncr_driver_setup
DECL|variable|driver_setup
id|driver_setup
op_assign
id|SCSI_NCR_DRIVER_SETUP
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT
r_static
r_struct
id|ncr_driver_setup
DECL|variable|__initdata
id|driver_safe_setup
id|__initdata
op_assign
id|SCSI_NCR_DRIVER_SAFE_SETUP
suffix:semicolon
macro_line|# ifdef&t;MODULE
DECL|variable|sym53c8xx
r_char
op_star
id|sym53c8xx
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* command line passed by insmod */
macro_line|#  if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,30)
id|MODULE_PARM
c_func
(paren
id|sym53c8xx
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
macro_line|#  endif
macro_line|# endif
macro_line|#endif
multiline_comment|/*&n;**&t;Other Linux definitions&n;*/
DECL|macro|SetScsiResult
mdefine_line|#define SetScsiResult(cmd, h_sts, s_sts) &bslash;&n;&t;cmd-&gt;result = (((h_sts) &lt;&lt; 16) + ((s_sts) &amp; 0x7f))
multiline_comment|/* We may have to remind our amnesiac SCSI layer of the reason of the abort */
macro_line|#if 0
mdefine_line|#define SetScsiAbortResult(cmd)&t;&bslash;&n;&t;  SetScsiResult(&t;&bslash;&n;&t;    cmd, &t;&t;&bslash;&n;&t;    (cmd)-&gt;abort_reason == DID_TIME_OUT ? DID_TIME_OUT : DID_ABORT, &bslash;&n;&t;    0xff)
macro_line|#else
DECL|macro|SetScsiAbortResult
mdefine_line|#define SetScsiAbortResult(cmd) SetScsiResult(cmd, DID_ABORT, 0xff)
macro_line|#endif
r_static
r_void
id|sym53c8xx_select_queue_depths
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|scsi_device
op_star
id|devlist
)paren
suffix:semicolon
r_static
r_void
id|sym53c8xx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|sym53c8xx_timeout
c_func
(paren
r_int
r_int
id|np
)paren
suffix:semicolon
DECL|macro|initverbose
mdefine_line|#define initverbose (driver_setup.verbose)
DECL|macro|bootverbose
mdefine_line|#define bootverbose (np-&gt;verbose)
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
DECL|variable|__initdata
r_static
id|u_char
id|Tekram_sync
(braket
l_int|16
)braket
id|__initdata
op_assign
(brace
l_int|25
comma
l_int|31
comma
l_int|37
comma
l_int|43
comma
l_int|50
comma
l_int|62
comma
l_int|75
comma
l_int|125
comma
l_int|12
comma
l_int|15
comma
l_int|18
comma
l_int|21
comma
l_int|6
comma
l_int|7
comma
l_int|9
comma
l_int|10
)brace
suffix:semicolon
macro_line|#endif /* SCSI_NCR_NVRAM_SUPPORT */
multiline_comment|/*&n;**&t;Structures used by sym53c8xx_detect/sym53c8xx_pci_init to &n;**&t;transmit device configuration to the ncr_attach() function.&n;*/
r_typedef
r_struct
(brace
DECL|member|bus
r_int
id|bus
suffix:semicolon
DECL|member|device_fn
id|u_char
id|device_fn
suffix:semicolon
DECL|member|base
id|u_long
id|base
suffix:semicolon
DECL|member|base_2
id|u_long
id|base_2
suffix:semicolon
DECL|member|io_port
id|u_long
id|io_port
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* port and reg fields to use INB, OUTB macros */
DECL|member|base_io
id|u_long
id|base_io
suffix:semicolon
DECL|member|reg
r_volatile
r_struct
id|ncr_reg
op_star
id|reg
suffix:semicolon
DECL|typedef|ncr_slot
)brace
id|ncr_slot
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|type
r_int
id|type
suffix:semicolon
DECL|macro|SCSI_NCR_SYMBIOS_NVRAM
mdefine_line|#define&t;SCSI_NCR_SYMBIOS_NVRAM&t;(1)
DECL|macro|SCSI_NCR_TEKRAM_NVRAM
mdefine_line|#define&t;SCSI_NCR_TEKRAM_NVRAM&t;(2)
macro_line|#ifdef&t;SCSI_NCR_NVRAM_SUPPORT
r_union
(brace
DECL|member|Symbios
id|Symbios_nvram
id|Symbios
suffix:semicolon
DECL|member|Tekram
id|Tekram_nvram
id|Tekram
suffix:semicolon
DECL|member|data
)brace
id|data
suffix:semicolon
macro_line|#endif
DECL|typedef|ncr_nvram
)brace
id|ncr_nvram
suffix:semicolon
multiline_comment|/*&n;**&t;Structure used by sym53c8xx_detect/sym53c8xx_pci_init&n;**&t;to save data on each detected board for ncr_attach().&n;*/
r_typedef
r_struct
(brace
DECL|member|pdev
id|pcidev_t
id|pdev
suffix:semicolon
DECL|member|slot
id|ncr_slot
id|slot
suffix:semicolon
DECL|member|chip
id|ncr_chip
id|chip
suffix:semicolon
DECL|member|nvram
id|ncr_nvram
op_star
id|nvram
suffix:semicolon
DECL|member|host_id
id|u_char
id|host_id
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_PQS_PDS_SUPPORT
DECL|member|pqs_pds
id|u_char
id|pqs_pds
suffix:semicolon
macro_line|#endif
DECL|member|attach_done
r_int
id|attach_done
suffix:semicolon
DECL|typedef|ncr_device
)brace
id|ncr_device
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&t;assert ()&n;**&n;**==========================================================&n;**&n;**&t;modified copy from 386bsd:/usr/include/sys/assert.h&n;**&n;**----------------------------------------------------------&n;*/
DECL|macro|assert
mdefine_line|#define&t;assert(expression) { &bslash;&n;&t;if (!(expression)) { &bslash;&n;&t;&t;(void)panic( &bslash;&n;&t;&t;&t;&quot;assertion &bslash;&quot;%s&bslash;&quot; failed: file &bslash;&quot;%s&bslash;&quot;, line %d&bslash;n&quot;, &bslash;&n;&t;&t;&t;#expression, &bslash;&n;&t;&t;&t;__FILE__, __LINE__); &bslash;&n;&t;} &bslash;&n;}
multiline_comment|/*==========================================================&n;**&n;**&t;Big/Little endian support.&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**&t;If the NCR uses big endian addressing mode over the &n;**&t;PCI, actual io register addresses for byte and word &n;**&t;accesses must be changed according to lane routing.&n;**&t;Btw, ncr_offb() and ncr_offw() macros only apply to &n;**&t;constants and so donnot generate bloated code.&n;*/
macro_line|#if&t;defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|ncr_offb
mdefine_line|#define ncr_offb(o)&t;(((o)&amp;~3)+((~((o)&amp;3))&amp;3))
DECL|macro|ncr_offw
mdefine_line|#define ncr_offw(o)&t;(((o)&amp;~3)+((~((o)&amp;3))&amp;2))
macro_line|#else
DECL|macro|ncr_offb
mdefine_line|#define ncr_offb(o)&t;(o)
DECL|macro|ncr_offw
mdefine_line|#define ncr_offw(o)&t;(o)
macro_line|#endif
multiline_comment|/*&n;**&t;If the CPU and the NCR use same endian-ness adressing,&n;**&t;no byte reordering is needed for script patching.&n;**&t;Macro cpu_to_scr() is to be used for script patching.&n;**&t;Macro scr_to_cpu() is to be used for getting a DWORD &n;**&t;from the script.&n;*/
macro_line|#if&t;defined(__BIG_ENDIAN) &amp;&amp; !defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|cpu_to_scr
mdefine_line|#define cpu_to_scr(dw)&t;cpu_to_le32(dw)
DECL|macro|scr_to_cpu
mdefine_line|#define scr_to_cpu(dw)&t;le32_to_cpu(dw)
macro_line|#elif&t;defined(__LITTLE_ENDIAN) &amp;&amp; defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|cpu_to_scr
mdefine_line|#define cpu_to_scr(dw)&t;cpu_to_be32(dw)
DECL|macro|scr_to_cpu
mdefine_line|#define scr_to_cpu(dw)&t;be32_to_cpu(dw)
macro_line|#else
DECL|macro|cpu_to_scr
mdefine_line|#define cpu_to_scr(dw)&t;(dw)
DECL|macro|scr_to_cpu
mdefine_line|#define scr_to_cpu(dw)&t;(dw)
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;Access to the controller chip.&n;**&n;**&t;If NCR_IOMAPPED is defined, the driver will use &n;**&t;normal IOs instead of the MEMORY MAPPED IO method  &n;**&t;recommended by PCI specifications.&n;**&t;If all PCI bridges, host brigdes and architectures &n;**&t;would have been correctly designed for PCI, this &n;**&t;option would be useless.&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**&t;If the CPU and the NCR use same endian-ness adressing,&n;**&t;no byte reordering is needed for accessing chip io &n;**&t;registers. Functions suffixed by &squot;_raw&squot; are assumed &n;**&t;to access the chip over the PCI without doing byte &n;**&t;reordering. Functions suffixed by &squot;_l2b&squot; are &n;**&t;assumed to perform little-endian to big-endian byte &n;**&t;reordering, those suffixed by &squot;_b2l&squot; blah, blah,&n;**&t;blah, ...&n;*/
macro_line|#if defined(NCR_IOMAPPED)
multiline_comment|/*&n;**&t;IO mapped only input / ouput&n;*/
DECL|macro|INB_OFF
mdefine_line|#define&t;INB_OFF(o)&t;&t;inb (np-&gt;base_io + ncr_offb(o))
DECL|macro|OUTB_OFF
mdefine_line|#define&t;OUTB_OFF(o, val)&t;outb ((val), np-&gt;base_io + ncr_offb(o))
macro_line|#if&t;defined(__BIG_ENDIAN) &amp;&amp; !defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|INW_OFF
mdefine_line|#define&t;INW_OFF(o)&t;&t;inw_l2b (np-&gt;base_io + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define&t;INL_OFF(o)&t;&t;inl_l2b (np-&gt;base_io + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define&t;OUTW_OFF(o, val)&t;outw_b2l ((val), np-&gt;base_io + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define&t;OUTL_OFF(o, val)&t;outl_b2l ((val), np-&gt;base_io + (o))
macro_line|#elif&t;defined(__LITTLE_ENDIAN) &amp;&amp; defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|INW_OFF
mdefine_line|#define&t;INW_OFF(o)&t;&t;inw_b2l (np-&gt;base_io + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define&t;INL_OFF(o)&t;&t;inl_b2l (np-&gt;base_io + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define&t;OUTW_OFF(o, val)&t;outw_l2b ((val), np-&gt;base_io + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define&t;OUTL_OFF(o, val)&t;outl_l2b ((val), np-&gt;base_io + (o))
macro_line|#else
DECL|macro|INW_OFF
mdefine_line|#define&t;INW_OFF(o)&t;&t;inw_raw (np-&gt;base_io + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define&t;INL_OFF(o)&t;&t;inl_raw (np-&gt;base_io + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define&t;OUTW_OFF(o, val)&t;outw_raw ((val), np-&gt;base_io + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define&t;OUTL_OFF(o, val)&t;outl_raw ((val), np-&gt;base_io + (o))
macro_line|#endif&t;/* ENDIANs */
macro_line|#else&t;/* defined NCR_IOMAPPED */
multiline_comment|/*&n;**&t;MEMORY mapped IO input / output&n;*/
DECL|macro|INB_OFF
mdefine_line|#define INB_OFF(o)&t;&t;readb((char *)np-&gt;reg + ncr_offb(o))
DECL|macro|OUTB_OFF
mdefine_line|#define OUTB_OFF(o, val)&t;writeb((val), (char *)np-&gt;reg + ncr_offb(o))
macro_line|#if&t;defined(__BIG_ENDIAN) &amp;&amp; !defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|INW_OFF
mdefine_line|#define INW_OFF(o)&t;&t;readw_l2b((char *)np-&gt;reg + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define INL_OFF(o)&t;&t;readl_l2b((char *)np-&gt;reg + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define OUTW_OFF(o, val)&t;writew_b2l((val), (char *)np-&gt;reg + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define OUTL_OFF(o, val)&t;writel_b2l((val), (char *)np-&gt;reg + (o))
macro_line|#elif&t;defined(__LITTLE_ENDIAN) &amp;&amp; defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|INW_OFF
mdefine_line|#define INW_OFF(o)&t;&t;readw_b2l((char *)np-&gt;reg + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define INL_OFF(o)&t;&t;readl_b2l((char *)np-&gt;reg + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define OUTW_OFF(o, val)&t;writew_l2b((val), (char *)np-&gt;reg + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define OUTL_OFF(o, val)&t;writel_l2b((val), (char *)np-&gt;reg + (o))
macro_line|#else
DECL|macro|INW_OFF
mdefine_line|#define INW_OFF(o)&t;&t;readw_raw((char *)np-&gt;reg + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define INL_OFF(o)&t;&t;readl_raw((char *)np-&gt;reg + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define OUTW_OFF(o, val)&t;writew_raw((val), (char *)np-&gt;reg + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define OUTL_OFF(o, val)&t;writel_raw((val), (char *)np-&gt;reg + (o))
macro_line|#endif
macro_line|#endif&t;/* defined NCR_IOMAPPED */
DECL|macro|INB
mdefine_line|#define INB(r)&t;&t;INB_OFF (offsetof(struct ncr_reg,r))
DECL|macro|INW
mdefine_line|#define INW(r)&t;&t;INW_OFF (offsetof(struct ncr_reg,r))
DECL|macro|INL
mdefine_line|#define INL(r)&t;&t;INL_OFF (offsetof(struct ncr_reg,r))
DECL|macro|OUTB
mdefine_line|#define OUTB(r, val)&t;OUTB_OFF (offsetof(struct ncr_reg,r), (val))
DECL|macro|OUTW
mdefine_line|#define OUTW(r, val)&t;OUTW_OFF (offsetof(struct ncr_reg,r), (val))
DECL|macro|OUTL
mdefine_line|#define OUTL(r, val)&t;OUTL_OFF (offsetof(struct ncr_reg,r), (val))
multiline_comment|/*&n;**&t;Set bit field ON, OFF &n;*/
DECL|macro|OUTONB
mdefine_line|#define OUTONB(r, m)&t;OUTB(r, INB(r) | (m))
DECL|macro|OUTOFFB
mdefine_line|#define OUTOFFB(r, m)&t;OUTB(r, INB(r) &amp; ~(m))
DECL|macro|OUTONW
mdefine_line|#define OUTONW(r, m)&t;OUTW(r, INW(r) | (m))
DECL|macro|OUTOFFW
mdefine_line|#define OUTOFFW(r, m)&t;OUTW(r, INW(r) &amp; ~(m))
DECL|macro|OUTONL
mdefine_line|#define OUTONL(r, m)&t;OUTL(r, INL(r) | (m))
DECL|macro|OUTOFFL
mdefine_line|#define OUTOFFL(r, m)&t;OUTL(r, INL(r) &amp; ~(m))
multiline_comment|/*==========================================================&n;**&n;**&t;Command control block states.&n;**&n;**==========================================================&n;*/
DECL|macro|HS_IDLE
mdefine_line|#define HS_IDLE&t;&t;(0)
DECL|macro|HS_BUSY
mdefine_line|#define HS_BUSY&t;&t;(1)
DECL|macro|HS_NEGOTIATE
mdefine_line|#define HS_NEGOTIATE&t;(2)&t;/* sync/wide data transfer*/
DECL|macro|HS_DISCONNECT
mdefine_line|#define HS_DISCONNECT&t;(3)&t;/* Disconnected by target */
DECL|macro|HS_DONEMASK
mdefine_line|#define HS_DONEMASK&t;(0x80)
DECL|macro|HS_COMPLETE
mdefine_line|#define HS_COMPLETE&t;(4|HS_DONEMASK)
DECL|macro|HS_SEL_TIMEOUT
mdefine_line|#define HS_SEL_TIMEOUT&t;(5|HS_DONEMASK)&t;/* Selection timeout      */
DECL|macro|HS_RESET
mdefine_line|#define HS_RESET&t;(6|HS_DONEMASK)&t;/* SCSI reset&t;          */
DECL|macro|HS_ABORTED
mdefine_line|#define HS_ABORTED&t;(7|HS_DONEMASK)&t;/* Transfer aborted       */
DECL|macro|HS_TIMEOUT
mdefine_line|#define HS_TIMEOUT&t;(8|HS_DONEMASK)&t;/* Software timeout       */
DECL|macro|HS_FAIL
mdefine_line|#define HS_FAIL&t;&t;(9|HS_DONEMASK)&t;/* SCSI or PCI bus errors */
DECL|macro|HS_UNEXPECTED
mdefine_line|#define HS_UNEXPECTED&t;(10|HS_DONEMASK)/* Unexpected disconnect  */
DECL|macro|DSA_INVALID
mdefine_line|#define DSA_INVALID 0xffffffff
multiline_comment|/*==========================================================&n;**&n;**&t;Software Interrupt Codes&n;**&n;**==========================================================&n;*/
DECL|macro|SIR_BAD_STATUS
mdefine_line|#define&t;SIR_BAD_STATUS&t;&t;(1)
DECL|macro|SIR_SEL_ATN_NO_MSG_OUT
mdefine_line|#define&t;SIR_SEL_ATN_NO_MSG_OUT&t;(2)
DECL|macro|SIR_MSG_RECEIVED
mdefine_line|#define&t;SIR_MSG_RECEIVED&t;(3)
DECL|macro|SIR_MSG_WEIRD
mdefine_line|#define&t;SIR_MSG_WEIRD&t;&t;(4)
DECL|macro|SIR_NEGO_FAILED
mdefine_line|#define&t;SIR_NEGO_FAILED&t;&t;(5)
DECL|macro|SIR_NEGO_PROTO
mdefine_line|#define&t;SIR_NEGO_PROTO&t;&t;(6)
DECL|macro|SIR_SCRIPT_STOPPED
mdefine_line|#define&t;SIR_SCRIPT_STOPPED&t;(7)
DECL|macro|SIR_REJECT_TO_SEND
mdefine_line|#define&t;SIR_REJECT_TO_SEND&t;(8)
DECL|macro|SIR_SWIDE_OVERRUN
mdefine_line|#define&t;SIR_SWIDE_OVERRUN&t;(9)
DECL|macro|SIR_SODL_UNDERRUN
mdefine_line|#define&t;SIR_SODL_UNDERRUN&t;(10)
DECL|macro|SIR_RESEL_NO_MSG_IN
mdefine_line|#define&t;SIR_RESEL_NO_MSG_IN&t;(11)
DECL|macro|SIR_RESEL_NO_IDENTIFY
mdefine_line|#define&t;SIR_RESEL_NO_IDENTIFY&t;(12)
DECL|macro|SIR_RESEL_BAD_LUN
mdefine_line|#define&t;SIR_RESEL_BAD_LUN&t;(13)
DECL|macro|SIR_TARGET_SELECTED
mdefine_line|#define&t;SIR_TARGET_SELECTED&t;(14)
DECL|macro|SIR_RESEL_BAD_I_T_L
mdefine_line|#define&t;SIR_RESEL_BAD_I_T_L&t;(15)
DECL|macro|SIR_RESEL_BAD_I_T_L_Q
mdefine_line|#define&t;SIR_RESEL_BAD_I_T_L_Q&t;(16)
DECL|macro|SIR_ABORT_SENT
mdefine_line|#define&t;SIR_ABORT_SENT&t;&t;(17)
DECL|macro|SIR_RESEL_ABORTED
mdefine_line|#define&t;SIR_RESEL_ABORTED&t;(18)
DECL|macro|SIR_MSG_OUT_DONE
mdefine_line|#define&t;SIR_MSG_OUT_DONE&t;(19)
DECL|macro|SIR_AUTO_SENSE_DONE
mdefine_line|#define&t;SIR_AUTO_SENSE_DONE&t;(20)
DECL|macro|SIR_DUMMY_INTERRUPT
mdefine_line|#define&t;SIR_DUMMY_INTERRUPT&t;(21)
DECL|macro|SIR_MAX
mdefine_line|#define&t;SIR_MAX&t;&t;&t;(21)
multiline_comment|/*==========================================================&n;**&n;**&t;Extended error bits.&n;**&t;xerr_status field of struct ccb.&n;**&n;**==========================================================&n;*/
DECL|macro|XE_EXTRA_DATA
mdefine_line|#define&t;XE_EXTRA_DATA&t;(1)&t;/* unexpected data phase&t; */
DECL|macro|XE_BAD_PHASE
mdefine_line|#define&t;XE_BAD_PHASE&t;(2)&t;/* illegal phase (4/5)&t;&t; */
DECL|macro|XE_PARITY_ERR
mdefine_line|#define&t;XE_PARITY_ERR&t;(4)&t;/* unrecovered SCSI parity error */
DECL|macro|XE_SODL_UNRUN
mdefine_line|#define XE_SODL_UNRUN   (1&lt;&lt;3)
DECL|macro|XE_SWIDE_OVRUN
mdefine_line|#define XE_SWIDE_OVRUN  (1&lt;&lt;4)
multiline_comment|/*==========================================================&n;**&n;**&t;Negotiation status.&n;**&t;nego_status field&t;of struct ccb.&n;**&n;**==========================================================&n;*/
DECL|macro|NS_NOCHANGE
mdefine_line|#define NS_NOCHANGE&t;(0)
DECL|macro|NS_SYNC
mdefine_line|#define NS_SYNC&t;&t;(1)
DECL|macro|NS_WIDE
mdefine_line|#define NS_WIDE&t;&t;(2)
DECL|macro|NS_PPR
mdefine_line|#define NS_PPR&t;&t;(4)
multiline_comment|/*==========================================================&n;**&n;**&t;&quot;Special features&quot; of targets.&n;**&t;quirks field&t;&t;of struct tcb.&n;**&t;actualquirks field&t;of struct ccb.&n;**&n;**==========================================================&n;*/
DECL|macro|QUIRK_AUTOSAVE
mdefine_line|#define&t;QUIRK_AUTOSAVE&t;(0x01)
multiline_comment|/*==========================================================&n;**&n;**&t;Capability bits in Inquire response byte 7.&n;**&n;**==========================================================&n;*/
DECL|macro|INQ7_QUEUE
mdefine_line|#define&t;INQ7_QUEUE&t;(0x02)
DECL|macro|INQ7_SYNC
mdefine_line|#define&t;INQ7_SYNC&t;(0x10)
DECL|macro|INQ7_WIDE16
mdefine_line|#define&t;INQ7_WIDE16&t;(0x20)
multiline_comment|/*==========================================================&n;**&n;**&t;A CCB hashed table is used to retrieve CCB address &n;**&t;from DSA value.&n;**&n;**==========================================================&n;*/
DECL|macro|CCB_HASH_SHIFT
mdefine_line|#define CCB_HASH_SHIFT&t;&t;8
DECL|macro|CCB_HASH_SIZE
mdefine_line|#define CCB_HASH_SIZE&t;&t;(1UL &lt;&lt; CCB_HASH_SHIFT)
DECL|macro|CCB_HASH_MASK
mdefine_line|#define CCB_HASH_MASK&t;&t;(CCB_HASH_SIZE-1)
DECL|macro|CCB_HASH_CODE
mdefine_line|#define CCB_HASH_CODE(dsa)&t;(((dsa) &gt;&gt; 11) &amp; CCB_HASH_MASK)
multiline_comment|/*==========================================================&n;**&n;**&t;Declaration of structs.&n;**&n;**==========================================================&n;*/
r_struct
id|tcb
suffix:semicolon
r_struct
id|lcb
suffix:semicolon
r_struct
id|ccb
suffix:semicolon
r_struct
id|ncb
suffix:semicolon
r_struct
id|script
suffix:semicolon
DECL|typedef|ncb_p
r_typedef
r_struct
id|ncb
op_star
id|ncb_p
suffix:semicolon
DECL|typedef|tcb_p
r_typedef
r_struct
id|tcb
op_star
id|tcb_p
suffix:semicolon
DECL|typedef|lcb_p
r_typedef
r_struct
id|lcb
op_star
id|lcb_p
suffix:semicolon
DECL|typedef|ccb_p
r_typedef
r_struct
id|ccb
op_star
id|ccb_p
suffix:semicolon
DECL|struct|link
r_struct
id|link
(brace
DECL|member|l_cmd
id|ncrcmd
id|l_cmd
suffix:semicolon
DECL|member|l_paddr
id|ncrcmd
id|l_paddr
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|usrcmd
r_struct
id|usrcmd
(brace
DECL|member|target
id|u_long
id|target
suffix:semicolon
DECL|member|lun
id|u_long
id|lun
suffix:semicolon
DECL|member|data
id|u_long
id|data
suffix:semicolon
DECL|member|cmd
id|u_long
id|cmd
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|UC_SETSYNC
mdefine_line|#define UC_SETSYNC      10
DECL|macro|UC_SETTAGS
mdefine_line|#define UC_SETTAGS&t;11
DECL|macro|UC_SETDEBUG
mdefine_line|#define UC_SETDEBUG&t;12
DECL|macro|UC_SETORDER
mdefine_line|#define UC_SETORDER&t;13
DECL|macro|UC_SETWIDE
mdefine_line|#define UC_SETWIDE&t;14
DECL|macro|UC_SETFLAG
mdefine_line|#define UC_SETFLAG&t;15
DECL|macro|UC_CLEARPROF
mdefine_line|#define UC_CLEARPROF&t;16
DECL|macro|UC_SETVERBOSE
mdefine_line|#define UC_SETVERBOSE&t;17
DECL|macro|UC_RESETDEV
mdefine_line|#define UC_RESETDEV&t;18
DECL|macro|UC_CLEARDEV
mdefine_line|#define UC_CLEARDEV&t;19
DECL|macro|UF_TRACE
mdefine_line|#define&t;UF_TRACE&t;(0x01)
DECL|macro|UF_NODISC
mdefine_line|#define&t;UF_NODISC&t;(0x02)
DECL|macro|UF_NOSCAN
mdefine_line|#define&t;UF_NOSCAN&t;(0x04)
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
multiline_comment|/*&n;**&t;profiling data (per host)&n;*/
DECL|struct|profile
r_struct
id|profile
(brace
DECL|member|num_trans
id|u_long
id|num_trans
suffix:semicolon
DECL|member|num_disc
id|u_long
id|num_disc
suffix:semicolon
DECL|member|num_disc0
id|u_long
id|num_disc0
suffix:semicolon
DECL|member|num_break
id|u_long
id|num_break
suffix:semicolon
DECL|member|num_int
id|u_long
id|num_int
suffix:semicolon
DECL|member|num_fly
id|u_long
id|num_fly
suffix:semicolon
DECL|member|num_kbytes
id|u_long
id|num_kbytes
suffix:semicolon
macro_line|#if 000
id|u_long
id|num_br1k
suffix:semicolon
id|u_long
id|num_br2k
suffix:semicolon
id|u_long
id|num_br4k
suffix:semicolon
id|u_long
id|num_br8k
suffix:semicolon
id|u_long
id|num_brnk
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*========================================================================&n;**&n;**&t;Declaration of structs:&t;&t;target control block&n;**&n;**========================================================================&n;*/
DECL|struct|tcb
r_struct
id|tcb
(brace
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;LUN tables.&n;&t;**&t;An array of bus addresses is used on reselection by &n;&t;**&t;the SCRIPT.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|luntbl
id|u_int32
op_star
id|luntbl
suffix:semicolon
multiline_comment|/* lcbs bus address table&t;*/
DECL|member|b_luntbl
id|u_int32
id|b_luntbl
suffix:semicolon
multiline_comment|/* bus address of this table&t;*/
DECL|member|b_lun0
id|u_int32
id|b_lun0
suffix:semicolon
multiline_comment|/* bus address of lun0&t;&t;*/
DECL|member|l0p
id|lcb_p
id|l0p
suffix:semicolon
multiline_comment|/* lcb of LUN #0 (normal case)&t;*/
macro_line|#if MAX_LUN &gt; 1
DECL|member|lmp
id|lcb_p
op_star
id|lmp
suffix:semicolon
multiline_comment|/* Other lcb&squot;s [1..MAX_LUN]&t;*/
macro_line|#endif
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Target capabilities.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|inq_done
id|u_char
id|inq_done
suffix:semicolon
multiline_comment|/* Target capabilities received&t;*/
DECL|member|inq_byte7
id|u_char
id|inq_byte7
suffix:semicolon
multiline_comment|/* Contains these capabilities&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Some flags.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|to_reset
id|u_char
id|to_reset
suffix:semicolon
multiline_comment|/* This target is to be reset&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Pointer to the ccb used for negotiation.&n;&t;**&t;Prevent from starting a negotiation for all queued commands &n;&t;**&t;when tagged command queuing is enabled.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|nego_cp
id|ccb_p
id|nego_cp
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;statistical data&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|transfers
id|u_long
id|transfers
suffix:semicolon
DECL|member|bytes
id|u_long
id|bytes
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;negotiation of wide and synch transfer and device quirks.&n;&t;**&t;sval, wval and uval are read from SCRIPTS and so have alignment &n;&t;**&t;constraints.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|minsync
multiline_comment|/*0*/
id|u_char
id|minsync
suffix:semicolon
DECL|member|sval
multiline_comment|/*1*/
id|u_char
id|sval
suffix:semicolon
DECL|member|period
multiline_comment|/*2*/
id|u_short
id|period
suffix:semicolon
DECL|member|maxoffs
multiline_comment|/*0*/
id|u_char
id|maxoffs
suffix:semicolon
DECL|member|quirks
multiline_comment|/*1*/
id|u_char
id|quirks
suffix:semicolon
DECL|member|widedone
multiline_comment|/*2*/
id|u_char
id|widedone
suffix:semicolon
DECL|member|wval
multiline_comment|/*3*/
id|u_char
id|wval
suffix:semicolon
DECL|member|uval
multiline_comment|/*0*/
id|u_char
id|uval
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_INTEGRITY_CHECKING
DECL|member|ic_min_sync
id|u_char
id|ic_min_sync
suffix:semicolon
DECL|member|ic_max_width
id|u_char
id|ic_max_width
suffix:semicolon
DECL|member|ic_done
id|u_char
id|ic_done
suffix:semicolon
macro_line|#endif
DECL|member|ic_maximums_set
id|u_char
id|ic_maximums_set
suffix:semicolon
DECL|member|ppr_negotiation
id|u_char
id|ppr_negotiation
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;User settable limits and options.&n;&t;**&t;These limits are read from the NVRAM if present.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|usrsync
id|u_char
id|usrsync
suffix:semicolon
DECL|member|usrwide
id|u_char
id|usrwide
suffix:semicolon
DECL|member|usrtags
id|u_short
id|usrtags
suffix:semicolon
DECL|member|usrflag
id|u_char
id|usrflag
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*========================================================================&n;**&n;**&t;Declaration of structs:&t;&t;lun control block&n;**&n;**========================================================================&n;*/
DECL|struct|lcb
r_struct
id|lcb
(brace
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;On reselection, SCRIPTS use this value as a JUMP address &n;&t;**&t;after the IDENTIFY has been successfully received.&n;&t;**&t;This field is set to &squot;resel_tag&squot; if TCQ is enabled and &n;&t;**&t;to &squot;resel_notag&squot; if TCQ is disabled.&n;&t;**&t;(Must be at zero due to bad lun handling on reselection)&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|resel_task
multiline_comment|/*0*/
id|u_int32
id|resel_task
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Task table used by the script processor to retrieve the &n;&t;**&t;task corresponding to a reselected nexus. The TAG is used &n;&t;**&t;as offset to determine the corresponding entry.&n;&t;**&t;Each entry contains the associated CCB bus address.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|tasktbl_0
id|u_int32
id|tasktbl_0
suffix:semicolon
multiline_comment|/* Used if TCQ not enabled&t;*/
DECL|member|tasktbl
id|u_int32
op_star
id|tasktbl
suffix:semicolon
DECL|member|b_tasktbl
id|u_int32
id|b_tasktbl
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;CCB queue management.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|busy_ccbq
id|XPT_QUEHEAD
id|busy_ccbq
suffix:semicolon
multiline_comment|/* Queue of busy CCBs&t;&t;*/
DECL|member|wait_ccbq
id|XPT_QUEHEAD
id|wait_ccbq
suffix:semicolon
multiline_comment|/* Queue of waiting for IO CCBs&t;*/
DECL|member|busyccbs
id|u_short
id|busyccbs
suffix:semicolon
multiline_comment|/* CCBs busy for this lun&t;*/
DECL|member|queuedccbs
id|u_short
id|queuedccbs
suffix:semicolon
multiline_comment|/* CCBs queued to the controller*/
DECL|member|queuedepth
id|u_short
id|queuedepth
suffix:semicolon
multiline_comment|/* Queue depth for this lun&t;*/
DECL|member|scdev_depth
id|u_short
id|scdev_depth
suffix:semicolon
multiline_comment|/* SCSI device queue depth&t;*/
DECL|member|maxnxs
id|u_short
id|maxnxs
suffix:semicolon
multiline_comment|/* Max possible nexuses&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Control of tagged command queuing.&n;&t;**&t;Tags allocation is performed using a circular buffer.&n;&t;**&t;This avoids using a loop for tag allocation.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|ia_tag
id|u_short
id|ia_tag
suffix:semicolon
multiline_comment|/* Tag allocation index&t;&t;*/
DECL|member|if_tag
id|u_short
id|if_tag
suffix:semicolon
multiline_comment|/* Tag release index&t;&t;*/
DECL|member|cb_tags
id|u_char
op_star
id|cb_tags
suffix:semicolon
multiline_comment|/* Circular tags buffer&t;&t;*/
DECL|member|inq_byte7
id|u_char
id|inq_byte7
suffix:semicolon
multiline_comment|/* Store unit CmdQ capability&t;*/
DECL|member|usetags
id|u_char
id|usetags
suffix:semicolon
multiline_comment|/* Command queuing is active&t;*/
DECL|member|to_clear
id|u_char
id|to_clear
suffix:semicolon
multiline_comment|/* User wants to clear all tasks*/
DECL|member|maxtags
id|u_short
id|maxtags
suffix:semicolon
multiline_comment|/* Max NR of tags asked by user&t;*/
DECL|member|numtags
id|u_short
id|numtags
suffix:semicolon
multiline_comment|/* Current number of tags&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;QUEUE FULL and ORDERED tag control.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|num_good
id|u_short
id|num_good
suffix:semicolon
multiline_comment|/* Nr of GOOD since QUEUE FULL&t;*/
DECL|member|tags_sum
id|u_short
id|tags_sum
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Tags sum counters&t;&t;*/
DECL|member|tags_si
id|u_char
id|tags_si
suffix:semicolon
multiline_comment|/* Current index to tags sum&t;*/
DECL|member|tags_stime
id|u_long
id|tags_stime
suffix:semicolon
multiline_comment|/* Last time we switch tags_sum&t;*/
)brace
suffix:semicolon
multiline_comment|/*========================================================================&n;**&n;**      Declaration of structs: actions for a task.&n;**&n;**========================================================================&n;**&n;**&t;It is part of the CCB and is called by the scripts processor to &n;**&t;start or restart the data structure (nexus).&n;**&n;**------------------------------------------------------------------------&n;*/
DECL|struct|action
r_struct
id|action
(brace
DECL|member|start
id|u_int32
id|start
suffix:semicolon
DECL|member|restart
id|u_int32
id|restart
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*========================================================================&n;**&n;**      Declaration of structs: Phase mismatch context.&n;**&n;**========================================================================&n;**&n;**&t;It is part of the CCB and is used as parameters for the DATA &n;**&t;pointer. We need two contexts to handle correctly the SAVED &n;**&t;DATA POINTER.&n;**&n;**------------------------------------------------------------------------&n;*/
DECL|struct|pm_ctx
r_struct
id|pm_ctx
(brace
DECL|member|sg
r_struct
id|scr_tblmove
id|sg
suffix:semicolon
multiline_comment|/* Updated interrupted SG block&t;*/
DECL|member|ret
id|u_int32
id|ret
suffix:semicolon
multiline_comment|/* SCRIPT return address&t;*/
)brace
suffix:semicolon
multiline_comment|/*========================================================================&n;**&n;**      Declaration of structs:     global HEADER.&n;**&n;**========================================================================&n;**&n;**&t;In earlier driver versions, this substructure was copied from the &n;**&t;ccb to a global address after selection (or reselection) and copied &n;**&t;back before disconnect. Since we are now using LOAD/STORE DSA &n;**&t;RELATIVE instructions, the script is able to access directly these &n;**&t;fields, and so, this header is no more copied.&n;**&n;**------------------------------------------------------------------------&n;*/
DECL|struct|head
r_struct
id|head
(brace
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Start and restart SCRIPTS addresses (must be at 0).&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|go
r_struct
id|action
id|go
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Saved data pointer.&n;&t;**&t;Points to the position in the script responsible for the&n;&t;**&t;actual transfer of data.&n;&t;**&t;It&squot;s written after reception of a SAVE_DATA_POINTER message.&n;&t;**&t;The goalpointer points after the last transfer command.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|savep
id|u_int32
id|savep
suffix:semicolon
DECL|member|lastp
id|u_int32
id|lastp
suffix:semicolon
DECL|member|goalp
id|u_int32
id|goalp
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Alternate data pointer.&n;&t;**&t;They are copied back to savep/lastp/goalp by the SCRIPTS &n;&t;**&t;when the direction is unknown and the device claims data out.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|wlastp
id|u_int32
id|wlastp
suffix:semicolon
DECL|member|wgoalp
id|u_int32
id|wgoalp
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Status fields.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|scr_st
id|u_char
id|scr_st
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* script status&t;&t;*/
DECL|member|status
id|u_char
id|status
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* host status&t;&t;&t;*/
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;LUN control block lookup.&n;**&t;We use a direct pointer for LUN #0, and a table of pointers &n;**&t;which is only allocated for devices that support LUN(s) &gt; 0.&n;*/
macro_line|#if MAX_LUN &lt;= 1
DECL|macro|ncr_lp
mdefine_line|#define ncr_lp(np, tp, lun) (!lun) ? (tp)-&gt;l0p : 0
macro_line|#else
DECL|macro|ncr_lp
mdefine_line|#define ncr_lp(np, tp, lun) &bslash;&n;&t;(!lun) ? (tp)-&gt;l0p : (tp)-&gt;lmp ? (tp)-&gt;lmp[(lun)] : 0
macro_line|#endif
multiline_comment|/*&n;**&t;The status bytes are used by the host and the script processor.&n;**&n;**&t;The last four bytes (status[4]) are copied to the scratchb register&n;**&t;(declared as scr0..scr3 in ncr_reg.h) just after the select/reselect,&n;**&t;and copied back just after disconnecting.&n;**&t;Inside the script the XX_REG are used.&n;**&n;**&t;The first four bytes (scr_st[4]) are used inside the script by &n;**&t;&quot;LOAD/STORE&quot; commands.&n;**&t;Because source and destination must have the same alignment&n;**&t;in a DWORD, the fields HAVE to be at the choosen offsets.&n;**&t;&t;xerr_st&t;&t;0&t;(0x34)&t;scratcha&n;**&t;&t;sync_st&t;&t;1&t;(0x05)&t;sxfer&n;**&t;&t;wide_st&t;&t;3&t;(0x03)&t;scntl3&n;*/
multiline_comment|/*&n;**&t;Last four bytes (script)&n;*/
DECL|macro|QU_REG
mdefine_line|#define  QU_REG&t;scr0
DECL|macro|HS_REG
mdefine_line|#define  HS_REG&t;scr1
DECL|macro|HS_PRT
mdefine_line|#define  HS_PRT&t;nc_scr1
DECL|macro|SS_REG
mdefine_line|#define  SS_REG&t;scr2
DECL|macro|SS_PRT
mdefine_line|#define  SS_PRT&t;nc_scr2
DECL|macro|HF_REG
mdefine_line|#define  HF_REG&t;scr3
DECL|macro|HF_PRT
mdefine_line|#define  HF_PRT&t;nc_scr3
multiline_comment|/*&n;**&t;Last four bytes (host)&n;*/
DECL|macro|actualquirks
mdefine_line|#define  actualquirks  phys.header.status[0]
DECL|macro|host_status
mdefine_line|#define  host_status   phys.header.status[1]
DECL|macro|scsi_status
mdefine_line|#define  scsi_status   phys.header.status[2]
DECL|macro|host_flags
mdefine_line|#define  host_flags    phys.header.status[3]
multiline_comment|/*&n;**&t;Host flags&n;*/
DECL|macro|HF_IN_PM0
mdefine_line|#define HF_IN_PM0&t;1u
DECL|macro|HF_IN_PM1
mdefine_line|#define HF_IN_PM1&t;(1u&lt;&lt;1)
DECL|macro|HF_ACT_PM
mdefine_line|#define HF_ACT_PM&t;(1u&lt;&lt;2)
DECL|macro|HF_DP_SAVED
mdefine_line|#define HF_DP_SAVED&t;(1u&lt;&lt;3)
DECL|macro|HF_AUTO_SENSE
mdefine_line|#define HF_AUTO_SENSE&t;(1u&lt;&lt;4)
DECL|macro|HF_DATA_IN
mdefine_line|#define HF_DATA_IN&t;(1u&lt;&lt;5)
DECL|macro|HF_PM_TO_C
mdefine_line|#define HF_PM_TO_C&t;(1u&lt;&lt;6)
DECL|macro|HF_EXT_ERR
mdefine_line|#define HF_EXT_ERR&t;(1u&lt;&lt;7)
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
DECL|macro|HF_HINT_IARB
mdefine_line|#define HF_HINT_IARB&t;(1u&lt;&lt;7)
macro_line|#endif
multiline_comment|/*&n;**&t;This one is stolen from QU_REG.:)&n;*/
DECL|macro|HF_DATA_ST
mdefine_line|#define HF_DATA_ST&t;(1u&lt;&lt;7)
multiline_comment|/*&n;**&t;First four bytes (script)&n;*/
DECL|macro|xerr_st
mdefine_line|#define  xerr_st       header.scr_st[0]
DECL|macro|sync_st
mdefine_line|#define  sync_st       header.scr_st[1]
DECL|macro|nego_st
mdefine_line|#define  nego_st       header.scr_st[2]
DECL|macro|wide_st
mdefine_line|#define  wide_st       header.scr_st[3]
multiline_comment|/*&n;**&t;First four bytes (host)&n;*/
DECL|macro|xerr_status
mdefine_line|#define  xerr_status   phys.xerr_st
DECL|macro|nego_status
mdefine_line|#define  nego_status   phys.nego_st
multiline_comment|/*==========================================================&n;**&n;**      Declaration of structs:     Data structure block&n;**&n;**==========================================================&n;**&n;**&t;During execution of a ccb by the script processor,&n;**&t;the DSA (data structure address) register points&n;**&t;to this substructure of the ccb.&n;**&t;This substructure contains the header with&n;**&t;the script-processor-changable data and&n;**&t;data blocks for the indirect move commands.&n;**&n;**----------------------------------------------------------&n;*/
DECL|struct|dsb
r_struct
id|dsb
(brace
multiline_comment|/*&n;&t;**&t;Header.&n;&t;*/
DECL|member|header
r_struct
id|head
id|header
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Table data for Script&n;&t;*/
DECL|member|select
r_struct
id|scr_tblsel
id|select
suffix:semicolon
DECL|member|smsg
r_struct
id|scr_tblmove
id|smsg
suffix:semicolon
DECL|member|smsg_ext
r_struct
id|scr_tblmove
id|smsg_ext
suffix:semicolon
DECL|member|cmd
r_struct
id|scr_tblmove
id|cmd
suffix:semicolon
DECL|member|sense
r_struct
id|scr_tblmove
id|sense
suffix:semicolon
DECL|member|wresid
r_struct
id|scr_tblmove
id|wresid
suffix:semicolon
DECL|member|data
r_struct
id|scr_tblmove
id|data
(braket
id|MAX_SCATTER
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Phase mismatch contexts.&n;&t;**&t;We need two to handle correctly the&n;&t;**&t;SAVED DATA POINTER.&n;&t;*/
DECL|member|pm0
r_struct
id|pm_ctx
id|pm0
suffix:semicolon
DECL|member|pm1
r_struct
id|pm_ctx
id|pm1
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Extra bytes count transferred &n;&t;**&t;in case of data overrun.&n;&t;*/
DECL|member|extra_bytes
id|u_int32
id|extra_bytes
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
multiline_comment|/*&n;&t;**&t;Disconnection counter&n;&t;*/
DECL|member|num_disc
id|u_int32
id|num_disc
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/*========================================================================&n;**&n;**      Declaration of structs:     Command control block.&n;**&n;**========================================================================&n;*/
DECL|struct|ccb
r_struct
id|ccb
(brace
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;This is the data structure which is pointed by the DSA &n;&t;**&t;register when it is executed by the script processor.&n;&t;**&t;It must be the first entry.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|phys
r_struct
id|dsb
id|phys
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;The general SCSI driver provides a&n;&t;**&t;pointer to a control block.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|cmd
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
multiline_comment|/* SCSI command &t;&t;*/
DECL|member|cdb_buf
id|u_char
id|cdb_buf
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Copy of CDB&t;&t;&t;*/
DECL|member|sense_buf
id|u_char
id|sense_buf
(braket
l_int|64
)braket
suffix:semicolon
DECL|member|data_len
r_int
id|data_len
suffix:semicolon
multiline_comment|/* Total data length&t;&t;*/
DECL|member|segments
r_int
id|segments
suffix:semicolon
multiline_comment|/* Number of SG segments&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Message areas.&n;&t;**&t;We prepare a message to be sent after selection.&n;&t;**&t;We may use a second one if the command is rescheduled &n;&t;**&t;due to CHECK_CONDITION or QUEUE FULL status.&n;&t;**      Contents are IDENTIFY and SIMPLE_TAG.&n;&t;**&t;While negotiating sync or wide transfer,&n;&t;**&t;a SDTR or WDTR message is appended.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|scsi_smsg
id|u_char
id|scsi_smsg
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|scsi_smsg2
id|u_char
id|scsi_smsg2
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Saved info for auto-sense&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|sv_scsi_status
id|u_char
id|sv_scsi_status
suffix:semicolon
DECL|member|sv_xerr_status
id|u_char
id|sv_xerr_status
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Other fields.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|p_ccb
id|u_long
id|p_ccb
suffix:semicolon
multiline_comment|/* BUS address of this CCB&t;*/
DECL|member|sensecmd
id|u_char
id|sensecmd
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* Sense command&t;&t;*/
DECL|member|to_abort
id|u_char
id|to_abort
suffix:semicolon
multiline_comment|/* This CCB is to be aborted&t;*/
DECL|member|tag
id|u_short
id|tag
suffix:semicolon
multiline_comment|/* Tag for this transfer&t;*/
multiline_comment|/*  NO_TAG means no tag&t;&t;*/
DECL|member|tags_si
id|u_char
id|tags_si
suffix:semicolon
multiline_comment|/* Lun tags sum index (0,1)&t;*/
DECL|member|target
id|u_char
id|target
suffix:semicolon
DECL|member|lun
id|u_char
id|lun
suffix:semicolon
DECL|member|queued
id|u_short
id|queued
suffix:semicolon
DECL|member|link_ccb
id|ccb_p
id|link_ccb
suffix:semicolon
multiline_comment|/* Host adapter CCB chain&t;*/
DECL|member|link_ccbh
id|ccb_p
id|link_ccbh
suffix:semicolon
multiline_comment|/* Host adapter CCB hash chain&t;*/
DECL|member|link_ccbq
id|XPT_QUEHEAD
id|link_ccbq
suffix:semicolon
multiline_comment|/* Link to unit CCB queue&t;*/
DECL|member|startp
id|u_int32
id|startp
suffix:semicolon
multiline_comment|/* Initial data pointer&t;&t;*/
DECL|member|lastp0
id|u_int32
id|lastp0
suffix:semicolon
multiline_comment|/* Initial &squot;lastp&squot;&t;&t;*/
DECL|member|ext_sg
r_int
id|ext_sg
suffix:semicolon
multiline_comment|/* Extreme data pointer, used&t;*/
DECL|member|ext_ofs
r_int
id|ext_ofs
suffix:semicolon
multiline_comment|/*  to calculate the residual.&t;*/
DECL|member|resid
r_int
id|resid
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|CCB_PHYS
mdefine_line|#define CCB_PHYS(cp,lbl)&t;(cp-&gt;p_ccb + offsetof(struct ccb, lbl))
multiline_comment|/*========================================================================&n;**&n;**      Declaration of structs:     NCR device descriptor&n;**&n;**========================================================================&n;*/
DECL|struct|ncb
r_struct
id|ncb
(brace
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Idle task and invalid task actions and their bus&n;&t;**&t;addresses.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|idletask
r_struct
id|action
id|idletask
suffix:semicolon
DECL|member|notask
r_struct
id|action
id|notask
suffix:semicolon
DECL|member|bad_i_t_l
r_struct
id|action
id|bad_i_t_l
suffix:semicolon
DECL|member|bad_i_t_l_q
r_struct
id|action
id|bad_i_t_l_q
suffix:semicolon
DECL|member|p_idletask
id|u_long
id|p_idletask
suffix:semicolon
DECL|member|p_notask
id|u_long
id|p_notask
suffix:semicolon
DECL|member|p_bad_i_t_l
id|u_long
id|p_bad_i_t_l
suffix:semicolon
DECL|member|p_bad_i_t_l_q
id|u_long
id|p_bad_i_t_l_q
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Dummy lun table to protect us against target returning bad  &n;&t;**&t;lun number on reselection.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|badluntbl
id|u_int32
op_star
id|badluntbl
suffix:semicolon
multiline_comment|/* Table physical address&t;*/
DECL|member|resel_badlun
id|u_int32
id|resel_badlun
suffix:semicolon
multiline_comment|/* SCRIPT handler BUS address&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Bit 32-63 of the on-chip RAM bus address in LE format.&n;&t;**&t;The START_RAM64 script loads the MMRS and MMWS from this &n;&t;**&t;field.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|scr_ram_seg
id|u_int32
id|scr_ram_seg
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;CCBs management queues.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|waiting_list
id|Scsi_Cmnd
op_star
id|waiting_list
suffix:semicolon
multiline_comment|/* Commands waiting for a CCB&t;*/
multiline_comment|/*  when lcb is not allocated.&t;*/
DECL|member|done_list
id|Scsi_Cmnd
op_star
id|done_list
suffix:semicolon
multiline_comment|/* Commands waiting for done()  */
multiline_comment|/* callback to be invoked.      */
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,93)
DECL|member|smp_lock
id|spinlock_t
id|smp_lock
suffix:semicolon
multiline_comment|/* Lock for SMP threading       */
macro_line|#endif
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Chip and controller indentification.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|unit
r_int
id|unit
suffix:semicolon
multiline_comment|/* Unit number&t;&t;&t;*/
DECL|member|chip_name
r_char
id|chip_name
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Chip name&t;&t;&t;*/
DECL|member|inst_name
r_char
id|inst_name
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* ncb instance name&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Initial value of some IO register bits.&n;&t;**&t;These values are assumed to have been set by BIOS, and may &n;&t;**&t;be used for probing adapter implementation differences.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|sv_scntl0
DECL|member|sv_scntl3
DECL|member|sv_dmode
DECL|member|sv_dcntl
DECL|member|sv_ctest3
DECL|member|sv_ctest4
id|u_char
id|sv_scntl0
comma
id|sv_scntl3
comma
id|sv_dmode
comma
id|sv_dcntl
comma
id|sv_ctest3
comma
id|sv_ctest4
comma
DECL|member|sv_ctest5
DECL|member|sv_gpcntl
DECL|member|sv_stest2
DECL|member|sv_stest4
DECL|member|sv_stest1
DECL|member|sv_scntl4
id|sv_ctest5
comma
id|sv_gpcntl
comma
id|sv_stest2
comma
id|sv_stest4
comma
id|sv_stest1
comma
id|sv_scntl4
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Actual initial value of IO register bits used by the &n;&t;**&t;driver. They are loaded at initialisation according to  &n;&t;**&t;features that are to be enabled.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|rv_scntl0
DECL|member|rv_scntl3
DECL|member|rv_dmode
DECL|member|rv_dcntl
DECL|member|rv_ctest3
DECL|member|rv_ctest4
id|u_char
id|rv_scntl0
comma
id|rv_scntl3
comma
id|rv_dmode
comma
id|rv_dcntl
comma
id|rv_ctest3
comma
id|rv_ctest4
comma
DECL|member|rv_ctest5
DECL|member|rv_stest2
DECL|member|rv_ccntl0
DECL|member|rv_ccntl1
DECL|member|rv_scntl4
id|rv_ctest5
comma
id|rv_stest2
comma
id|rv_ccntl0
comma
id|rv_ccntl1
comma
id|rv_scntl4
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Target data.&n;&t;**&t;Target control block bus address array used by the SCRIPT &n;&t;**&t;on reselection.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|target
r_struct
id|tcb
id|target
(braket
id|MAX_TARGET
)braket
suffix:semicolon
DECL|member|targtbl
id|u_int32
op_star
id|targtbl
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Virtual and physical bus addresses of the chip.&n;&t;**----------------------------------------------------------------&n;&t;*/
macro_line|#ifndef SCSI_NCR_PCI_MEM_NOT_SUPPORTED
DECL|member|base_va
id|u_long
id|base_va
suffix:semicolon
multiline_comment|/* MMIO base virtual address&t;*/
DECL|member|base2_va
id|u_long
id|base2_va
suffix:semicolon
multiline_comment|/* On-chip RAM virtual address&t;*/
macro_line|#endif
DECL|member|base_ba
id|u_long
id|base_ba
suffix:semicolon
multiline_comment|/* MMIO base bus address&t;*/
DECL|member|base_io
id|u_long
id|base_io
suffix:semicolon
multiline_comment|/* IO space base address&t;*/
DECL|member|base_ws
id|u_long
id|base_ws
suffix:semicolon
multiline_comment|/* (MM)IO window size&t;&t;*/
DECL|member|base2_ba
id|u_long
id|base2_ba
suffix:semicolon
multiline_comment|/* On-chip RAM bus address&t;*/
DECL|member|base2_ws
id|u_long
id|base2_ws
suffix:semicolon
multiline_comment|/* On-chip RAM window size&t;*/
DECL|member|irq
id|u_int
id|irq
suffix:semicolon
multiline_comment|/* IRQ number&t;&t;&t;*/
r_volatile
multiline_comment|/* Pointer to volatile for &t;*/
DECL|member|reg
r_struct
id|ncr_reg
op_star
id|reg
suffix:semicolon
multiline_comment|/*  memory mapped IO.&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;SCRIPTS virtual and physical bus addresses.&n;&t;**&t;&squot;script&squot;  is loaded in the on-chip RAM if present.&n;&t;**&t;&squot;scripth&squot; stays in main memory for all chips except the &n;&t;**&t;53C895A and 53C896 that provide 8K on-chip RAM.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|script0
r_struct
id|script
op_star
id|script0
suffix:semicolon
multiline_comment|/* Copies of script and scripth&t;*/
DECL|member|scripth0
r_struct
id|scripth
op_star
id|scripth0
suffix:semicolon
multiline_comment|/*  relocated for this ncb.&t;*/
DECL|member|p_script
id|u_long
id|p_script
suffix:semicolon
multiline_comment|/* Actual script and scripth&t;*/
DECL|member|p_scripth
id|u_long
id|p_scripth
suffix:semicolon
multiline_comment|/*  bus addresses.&t;&t;*/
DECL|member|p_scripth0
id|u_long
id|p_scripth0
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;General controller parameters and configuration.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|pdev
id|pcidev_t
id|pdev
suffix:semicolon
DECL|member|device_id
id|u_short
id|device_id
suffix:semicolon
multiline_comment|/* PCI device id&t;&t;*/
DECL|member|revision_id
id|u_char
id|revision_id
suffix:semicolon
multiline_comment|/* PCI device revision id&t;*/
DECL|member|bus
id|u_char
id|bus
suffix:semicolon
multiline_comment|/* PCI BUS number&t;&t;*/
DECL|member|device_fn
id|u_char
id|device_fn
suffix:semicolon
multiline_comment|/* PCI BUS device and function&t;*/
DECL|member|myaddr
id|u_char
id|myaddr
suffix:semicolon
multiline_comment|/* SCSI id of the adapter&t;*/
DECL|member|maxburst
id|u_char
id|maxburst
suffix:semicolon
multiline_comment|/* log base 2 of dwords burst&t;*/
DECL|member|maxwide
id|u_char
id|maxwide
suffix:semicolon
multiline_comment|/* Maximum transfer width&t;*/
DECL|member|minsync
id|u_char
id|minsync
suffix:semicolon
multiline_comment|/* Minimum sync period factor&t;*/
DECL|member|maxsync
id|u_char
id|maxsync
suffix:semicolon
multiline_comment|/* Maximum sync period factor&t;*/
DECL|member|maxoffs
id|u_char
id|maxoffs
suffix:semicolon
multiline_comment|/* Max scsi offset&t;&t;*/
DECL|member|multiplier
id|u_char
id|multiplier
suffix:semicolon
multiline_comment|/* Clock multiplier (1,2,4)&t;*/
DECL|member|clock_divn
id|u_char
id|clock_divn
suffix:semicolon
multiline_comment|/* Number of clock divisors&t;*/
DECL|member|clock_khz
id|u_long
id|clock_khz
suffix:semicolon
multiline_comment|/* SCSI clock frequency in KHz&t;*/
DECL|member|features
id|u_int
id|features
suffix:semicolon
multiline_comment|/* Chip features map&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Range for the PCI clock frequency measurement result&n;&t;**&t;that ensures the algorithm used by the driver can be &n;&t;**&t;trusted for the SCSI clock frequency measurement.&n;&t;**&t;(Assuming a PCI clock frequency of 33 MHz).&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|pciclock_min
id|u_int
id|pciclock_min
suffix:semicolon
DECL|member|pciclock_max
id|u_int
id|pciclock_max
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Start queue management.&n;&t;**&t;It is filled up by the host processor and accessed by the &n;&t;**&t;SCRIPTS processor in order to start SCSI commands.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|p_squeue
id|u_long
id|p_squeue
suffix:semicolon
multiline_comment|/* Start queue BUS address&t;*/
DECL|member|squeue
id|u_int32
op_star
id|squeue
suffix:semicolon
multiline_comment|/* Start queue virtual address&t;*/
DECL|member|squeueput
id|u_short
id|squeueput
suffix:semicolon
multiline_comment|/* Next free slot of the queue&t;*/
DECL|member|actccbs
id|u_short
id|actccbs
suffix:semicolon
multiline_comment|/* Number of allocated CCBs&t;*/
DECL|member|queuedepth
id|u_short
id|queuedepth
suffix:semicolon
multiline_comment|/* Start queue depth&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Command completion queue.&n;&t;**&t;It is the same size as the start queue to avoid overflow.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|dqueueget
id|u_short
id|dqueueget
suffix:semicolon
multiline_comment|/* Next position to scan&t;*/
DECL|member|dqueue
id|u_int32
op_star
id|dqueue
suffix:semicolon
multiline_comment|/* Completion (done) queue&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Timeout handler.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* Timer handler link header&t;*/
DECL|member|lasttime
id|u_long
id|lasttime
suffix:semicolon
DECL|member|settle_time
id|u_long
id|settle_time
suffix:semicolon
multiline_comment|/* Resetting the SCSI BUS&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Debugging and profiling.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|regdump
r_struct
id|ncr_reg
id|regdump
suffix:semicolon
multiline_comment|/* Register dump&t;&t;*/
DECL|member|regtime
id|u_long
id|regtime
suffix:semicolon
multiline_comment|/* Time it has been done&t;*/
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
DECL|member|profile
r_struct
id|profile
id|profile
suffix:semicolon
multiline_comment|/* Profiling data&t;&t;*/
macro_line|#endif
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Miscellaneous buffers accessed by the scripts-processor.&n;&t;**&t;They shall be DWORD aligned, because they may be read or &n;&t;**&t;written with a script command.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|msgout
id|u_char
id|msgout
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* Buffer for MESSAGE OUT &t;*/
DECL|member|msgin
id|u_char
id|msgin
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* Buffer for MESSAGE IN&t;*/
DECL|member|lastmsg
id|u_int32
id|lastmsg
suffix:semicolon
multiline_comment|/* Last SCSI message sent&t;*/
DECL|member|scratch
id|u_char
id|scratch
suffix:semicolon
multiline_comment|/* Scratch for SCSI receive&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Miscellaneous configuration and status parameters.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|scsi_mode
id|u_char
id|scsi_mode
suffix:semicolon
multiline_comment|/* Current SCSI BUS mode&t;*/
DECL|member|order
id|u_char
id|order
suffix:semicolon
multiline_comment|/* Tag order to use&t;&t;*/
DECL|member|verbose
id|u_char
id|verbose
suffix:semicolon
multiline_comment|/* Verbosity for this controller*/
DECL|member|ncr_cache
id|u_int32
id|ncr_cache
suffix:semicolon
multiline_comment|/* Used for cache test at init.&t;*/
DECL|member|p_ncb
id|u_long
id|p_ncb
suffix:semicolon
multiline_comment|/* BUS address of this NCB&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;CCB lists and queue.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|ccbh
id|ccb_p
id|ccbh
(braket
id|CCB_HASH_SIZE
)braket
suffix:semicolon
multiline_comment|/* CCB hashed by DSA value&t;*/
DECL|member|ccbc
r_struct
id|ccb
op_star
id|ccbc
suffix:semicolon
multiline_comment|/* CCB chain&t;&t;&t;*/
DECL|member|free_ccbq
id|XPT_QUEHEAD
id|free_ccbq
suffix:semicolon
multiline_comment|/* Queue of available CCBs&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;IMMEDIATE ARBITRATION (IARB) control.&n;&t;**&t;We keep track in &squot;last_cp&squot; of the last CCB that has been &n;&t;**&t;queued to the SCRIPTS processor and clear &squot;last_cp&squot; when &n;&t;**&t;this CCB completes. If last_cp is not zero at the moment &n;&t;**&t;we queue a new CCB, we set a flag in &squot;last_cp&squot; that is &n;&t;**&t;used by the SCRIPTS as a hint for setting IARB.&n;&t;**&t;We donnot set more than &squot;iarb_max&squot; consecutive hints for &n;&t;**&t;IARB in order to leave devices a chance to reselect.&n;&t;**&t;By the way, any non zero value of &squot;iarb_max&squot; is unfair. :)&n;&t;**----------------------------------------------------------------&n;&t;*/
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
DECL|member|last_cp
r_struct
id|ccb
op_star
id|last_cp
suffix:semicolon
multiline_comment|/* Last queud CCB used for IARB&t;*/
DECL|member|iarb_max
id|u_short
id|iarb_max
suffix:semicolon
multiline_comment|/* Max. # consecutive IARB hints*/
DECL|member|iarb_count
id|u_short
id|iarb_count
suffix:semicolon
multiline_comment|/* Actual # of these hints&t;*/
macro_line|#endif
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;We need the LCB in order to handle disconnections and &n;&t;**&t;to count active CCBs for task management. So, we use &n;&t;**&t;a unique CCB for LUNs we donnot have the LCB yet.&n;&t;**&t;This queue normally should have at most 1 element.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|b0_ccbq
id|XPT_QUEHEAD
id|b0_ccbq
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;We use a different scatter function for 896 rev 1.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|scatter
r_int
(paren
op_star
id|scatter
)paren
(paren
id|ncb_p
comma
id|ccb_p
comma
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Command abort handling.&n;&t;**&t;We need to synchronize tightly with the SCRIPTS &n;&t;**&t;processor in order to handle things correctly.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|abrt_msg
id|u_char
id|abrt_msg
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Message to send buffer&t;*/
DECL|member|abrt_tbl
r_struct
id|scr_tblmove
id|abrt_tbl
suffix:semicolon
multiline_comment|/* Table for the MOV of it &t;*/
DECL|member|abrt_sel
r_struct
id|scr_tblsel
id|abrt_sel
suffix:semicolon
multiline_comment|/* Sync params for selection&t;*/
DECL|member|istat_sem
id|u_char
id|istat_sem
suffix:semicolon
multiline_comment|/* Tells the chip to stop (SEM)&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Fields that should be removed or changed.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|user
r_struct
id|usrcmd
id|user
suffix:semicolon
multiline_comment|/* Command from user&t;&t;*/
DECL|member|release_stage
id|u_char
id|release_stage
suffix:semicolon
multiline_comment|/* Synchronisation stage on release  */
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Fields that are used (primarily) for integrity check&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|check_integrity
r_int
r_char
id|check_integrity
suffix:semicolon
multiline_comment|/* Enable midlayer integ. check on&n;&t;&t;&t;&t;&t; * bus scan. */
macro_line|#ifdef&t;SCSI_NCR_INTEGRITY_CHECKING
DECL|member|check_integ_par
r_int
r_char
id|check_integ_par
suffix:semicolon
multiline_comment|/* Set if par or Init. Det. error&n;&t;&t;&t;&t;&t; * used only during integ check */
macro_line|#endif
)brace
suffix:semicolon
DECL|macro|NCB_PHYS
mdefine_line|#define NCB_PHYS(np, lbl)&t; (np-&gt;p_ncb + offsetof(struct ncb, lbl))
DECL|macro|NCB_SCRIPT_PHYS
mdefine_line|#define NCB_SCRIPT_PHYS(np,lbl)&t; (np-&gt;p_script  + offsetof (struct script, lbl))
DECL|macro|NCB_SCRIPTH_PHYS
mdefine_line|#define NCB_SCRIPTH_PHYS(np,lbl) (np-&gt;p_scripth + offsetof (struct scripth,lbl))
DECL|macro|NCB_SCRIPTH0_PHYS
mdefine_line|#define NCB_SCRIPTH0_PHYS(np,lbl) (np-&gt;p_scripth0+offsetof (struct scripth,lbl))
multiline_comment|/*==========================================================&n;**&n;**&n;**      Script for NCR-Processor.&n;**&n;**&t;Use ncr_script_fill() to create the variable parts.&n;**&t;Use ncr_script_copy_and_bind() to make a copy and&n;**&t;bind to physical addresses.&n;**&n;**&n;**==========================================================&n;**&n;**&t;We have to know the offsets of all labels before&n;**&t;we reach them (for forward jumps).&n;**&t;Therefore we declare a struct here.&n;**&t;If you make changes inside the script,&n;**&t;DONT FORGET TO CHANGE THE LENGTHS HERE!&n;**&n;**----------------------------------------------------------&n;*/
multiline_comment|/*&n;**&t;Script fragments which are loaded into the on-chip RAM &n;**&t;of 825A, 875, 876, 895, 895A and 896 chips.&n;*/
DECL|struct|script
r_struct
id|script
(brace
DECL|member|start
id|ncrcmd
id|start
(braket
l_int|14
)braket
suffix:semicolon
DECL|member|getjob_begin
id|ncrcmd
id|getjob_begin
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|getjob_end
id|ncrcmd
id|getjob_end
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|select
id|ncrcmd
id|select
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|wf_sel_done
id|ncrcmd
id|wf_sel_done
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|send_ident
id|ncrcmd
id|send_ident
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
DECL|member|select2
id|ncrcmd
id|select2
(braket
l_int|8
)braket
suffix:semicolon
macro_line|#else
DECL|member|select2
id|ncrcmd
id|select2
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#endif
DECL|member|command
id|ncrcmd
id|command
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|dispatch
id|ncrcmd
id|dispatch
(braket
l_int|30
)braket
suffix:semicolon
DECL|member|sel_no_cmd
id|ncrcmd
id|sel_no_cmd
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|init
id|ncrcmd
id|init
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|clrack
id|ncrcmd
id|clrack
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|disp_status
id|ncrcmd
id|disp_status
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|datai_done
id|ncrcmd
id|datai_done
(braket
l_int|26
)braket
suffix:semicolon
DECL|member|datao_done
id|ncrcmd
id|datao_done
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|ign_i_w_r_msg
id|ncrcmd
id|ign_i_w_r_msg
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
DECL|member|datai_phase
id|ncrcmd
id|datai_phase
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#else
DECL|member|datai_phase
id|ncrcmd
id|datai_phase
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#endif
DECL|member|datao_phase
id|ncrcmd
id|datao_phase
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_in
id|ncrcmd
id|msg_in
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|msg_in2
id|ncrcmd
id|msg_in2
(braket
l_int|10
)braket
suffix:semicolon
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
DECL|member|status
id|ncrcmd
id|status
(braket
l_int|14
)braket
suffix:semicolon
macro_line|#else
DECL|member|status
id|ncrcmd
id|status
(braket
l_int|10
)braket
suffix:semicolon
macro_line|#endif
DECL|member|complete
id|ncrcmd
id|complete
(braket
l_int|8
)braket
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PCIQ_MAY_REORDER_WRITES
DECL|member|complete2
id|ncrcmd
id|complete2
(braket
l_int|12
)braket
suffix:semicolon
macro_line|#else
DECL|member|complete2
id|ncrcmd
id|complete2
(braket
l_int|10
)braket
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SCSI_NCR_PCIQ_SYNC_ON_INTR
DECL|member|done
id|ncrcmd
id|done
(braket
l_int|18
)braket
suffix:semicolon
macro_line|#else
DECL|member|done
id|ncrcmd
id|done
(braket
l_int|14
)braket
suffix:semicolon
macro_line|#endif
DECL|member|done_end
id|ncrcmd
id|done_end
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|save_dp
id|ncrcmd
id|save_dp
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|restore_dp
id|ncrcmd
id|restore_dp
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
DECL|member|disconnect
id|ncrcmd
id|disconnect
(braket
l_int|32
)braket
suffix:semicolon
macro_line|#else
DECL|member|disconnect
id|ncrcmd
id|disconnect
(braket
l_int|20
)braket
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
DECL|member|idle
id|ncrcmd
id|idle
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#else
DECL|member|idle
id|ncrcmd
id|idle
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
DECL|member|ungetjob
id|ncrcmd
id|ungetjob
(braket
l_int|6
)braket
suffix:semicolon
macro_line|#else
DECL|member|ungetjob
id|ncrcmd
id|ungetjob
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#endif
DECL|member|reselect
id|ncrcmd
id|reselect
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|reselected
id|ncrcmd
id|reselected
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|resel_scntl4
id|ncrcmd
id|resel_scntl4
(braket
l_int|30
)braket
suffix:semicolon
macro_line|#if   MAX_TASKS*4 &gt; 512
DECL|member|resel_tag
id|ncrcmd
id|resel_tag
(braket
l_int|18
)braket
suffix:semicolon
macro_line|#elif MAX_TASKS*4 &gt; 256
DECL|member|resel_tag
id|ncrcmd
id|resel_tag
(braket
l_int|12
)braket
suffix:semicolon
macro_line|#else
DECL|member|resel_tag
id|ncrcmd
id|resel_tag
(braket
l_int|8
)braket
suffix:semicolon
macro_line|#endif
DECL|member|resel_go
id|ncrcmd
id|resel_go
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|resel_notag
id|ncrcmd
id|resel_notag
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|resel_dsa
id|ncrcmd
id|resel_dsa
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|data_in
id|ncrcmd
id|data_in
(braket
id|MAX_SCATTER
op_star
id|SCR_SG_SIZE
)braket
suffix:semicolon
DECL|member|data_in2
id|ncrcmd
id|data_in2
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|data_out
id|ncrcmd
id|data_out
(braket
id|MAX_SCATTER
op_star
id|SCR_SG_SIZE
)braket
suffix:semicolon
DECL|member|data_out2
id|ncrcmd
id|data_out2
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|pm0_data
id|ncrcmd
id|pm0_data
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|pm0_data_out
id|ncrcmd
id|pm0_data_out
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|pm0_data_end
id|ncrcmd
id|pm0_data_end
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|pm1_data
id|ncrcmd
id|pm1_data
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|pm1_data_out
id|ncrcmd
id|pm1_data_out
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|pm1_data_end
id|ncrcmd
id|pm1_data_end
(braket
l_int|6
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;Script fragments which stay in main memory for all chips &n;**&t;except for the 895A and 896 that support 8K on-chip RAM.&n;*/
DECL|struct|scripth
r_struct
id|scripth
(brace
DECL|member|start64
id|ncrcmd
id|start64
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|no_data
id|ncrcmd
id|no_data
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|sel_for_abort
id|ncrcmd
id|sel_for_abort
(braket
l_int|18
)braket
suffix:semicolon
DECL|member|sel_for_abort_1
id|ncrcmd
id|sel_for_abort_1
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|select_no_atn
id|ncrcmd
id|select_no_atn
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|wf_sel_done_no_atn
id|ncrcmd
id|wf_sel_done_no_atn
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_in_etc
id|ncrcmd
id|msg_in_etc
(braket
l_int|14
)braket
suffix:semicolon
DECL|member|msg_received
id|ncrcmd
id|msg_received
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_weird_seen
id|ncrcmd
id|msg_weird_seen
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_extended
id|ncrcmd
id|msg_extended
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|msg_bad
id|ncrcmd
id|msg_bad
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|msg_weird
id|ncrcmd
id|msg_weird
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_weird1
id|ncrcmd
id|msg_weird1
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|wdtr_resp
id|ncrcmd
id|wdtr_resp
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|send_wdtr
id|ncrcmd
id|send_wdtr
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|sdtr_resp
id|ncrcmd
id|sdtr_resp
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|send_sdtr
id|ncrcmd
id|send_sdtr
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|ppr_resp
id|ncrcmd
id|ppr_resp
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|send_ppr
id|ncrcmd
id|send_ppr
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|nego_bad_phase
id|ncrcmd
id|nego_bad_phase
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_out
id|ncrcmd
id|msg_out
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_out_done
id|ncrcmd
id|msg_out_done
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|data_ovrun
id|ncrcmd
id|data_ovrun
(braket
l_int|18
)braket
suffix:semicolon
DECL|member|data_ovrun1
id|ncrcmd
id|data_ovrun1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|abort_resel
id|ncrcmd
id|abort_resel
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|resend_ident
id|ncrcmd
id|resend_ident
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|ident_break
id|ncrcmd
id|ident_break
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|ident_break_atn
id|ncrcmd
id|ident_break_atn
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|sdata_in
id|ncrcmd
id|sdata_in
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|data_io
id|ncrcmd
id|data_io
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|data_io_com
id|ncrcmd
id|data_io_com
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|data_io_out
id|ncrcmd
id|data_io_out
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|resel_bad_lun
id|ncrcmd
id|resel_bad_lun
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|bad_i_t_l
id|ncrcmd
id|bad_i_t_l
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|bad_i_t_l_q
id|ncrcmd
id|bad_i_t_l_q
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|bad_status
id|ncrcmd
id|bad_status
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|tweak_pmj
id|ncrcmd
id|tweak_pmj
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|pm_handle
id|ncrcmd
id|pm_handle
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|pm_handle1
id|ncrcmd
id|pm_handle1
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|pm_save
id|ncrcmd
id|pm_save
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|pm0_save
id|ncrcmd
id|pm0_save
(braket
l_int|14
)braket
suffix:semicolon
DECL|member|pm1_save
id|ncrcmd
id|pm1_save
(braket
l_int|14
)braket
suffix:semicolon
multiline_comment|/* WSR handling */
macro_line|#ifdef SYM_DEBUG_PM_WITH_WSR
DECL|member|pm_wsr_handle
id|ncrcmd
id|pm_wsr_handle
(braket
l_int|44
)braket
suffix:semicolon
macro_line|#else
DECL|member|pm_wsr_handle
id|ncrcmd
id|pm_wsr_handle
(braket
l_int|42
)braket
suffix:semicolon
macro_line|#endif
DECL|member|wsr_ma_helper
id|ncrcmd
id|wsr_ma_helper
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Data area */
DECL|member|zero
id|ncrcmd
id|zero
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|scratch
id|ncrcmd
id|scratch
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|scratch1
id|ncrcmd
id|scratch1
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|pm0_data_addr
id|ncrcmd
id|pm0_data_addr
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|pm1_data_addr
id|ncrcmd
id|pm1_data_addr
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|saved_dsa
id|ncrcmd
id|saved_dsa
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|saved_drs
id|ncrcmd
id|saved_drs
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|done_pos
id|ncrcmd
id|done_pos
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|startpos
id|ncrcmd
id|startpos
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|targtbl
id|ncrcmd
id|targtbl
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* End of data area */
macro_line|#ifdef SCSI_NCR_PCI_MEM_NOT_SUPPORTED
DECL|member|start_ram
id|ncrcmd
id|start_ram
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|script0_ba
id|ncrcmd
id|script0_ba
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|start_ram64
id|ncrcmd
id|start_ram64
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|script0_ba64
id|ncrcmd
id|script0_ba64
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|scripth0_ba64
id|ncrcmd
id|scripth0_ba64
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|ram_seg64
id|ncrcmd
id|ram_seg64
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#endif
DECL|member|snooptest
id|ncrcmd
id|snooptest
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|snoopend
id|ncrcmd
id|snoopend
(braket
l_int|2
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&n;**      Function headers.&n;**&n;**&n;**==========================================================&n;*/
r_static
id|ccb_p
id|ncr_alloc_ccb
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_complete
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
r_static
r_void
id|ncr_exception
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_free_ccb
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
r_static
id|ccb_p
id|ncr_ccb_from_dsa
c_func
(paren
id|ncb_p
id|np
comma
id|u_long
id|dsa
)paren
suffix:semicolon
r_static
r_void
id|ncr_init_tcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
)paren
suffix:semicolon
r_static
id|lcb_p
id|ncr_alloc_lcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
suffix:semicolon
r_static
id|lcb_p
id|ncr_setup_lcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
comma
id|u_char
op_star
id|inq_data
)paren
suffix:semicolon
r_static
r_void
id|ncr_getclock
(paren
id|ncb_p
id|np
comma
r_int
id|mult
)paren
suffix:semicolon
r_static
id|u_int
id|ncr_getpciclock
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_selectclock
(paren
id|ncb_p
id|np
comma
id|u_char
id|scntl3
)paren
suffix:semicolon
r_static
id|ccb_p
id|ncr_get_ccb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
suffix:semicolon
r_static
r_void
id|ncr_init
(paren
id|ncb_p
id|np
comma
r_int
id|reset
comma
r_char
op_star
id|msg
comma
id|u_long
id|code
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_sbmc
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_par
(paren
id|ncb_p
id|np
comma
id|u_short
id|sist
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_ma
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_sir
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_sto
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_udc
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_negotiate
(paren
id|ncb_p
id|np
comma
id|tcb_p
id|tp
)paren
suffix:semicolon
r_static
r_int
id|ncr_prepare_nego
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
op_star
id|msgptr
)paren
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_INTEGRITY_CHECKING
r_static
r_int
id|ncr_ic_nego
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
id|u_char
op_star
id|msgptr
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
r_static
r_void
id|ncb_profile
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|ncr_script_copy_and_bind
(paren
id|ncb_p
id|np
comma
id|ncrcmd
op_star
id|src
comma
id|ncrcmd
op_star
id|dst
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_void
id|ncr_script_fill
(paren
r_struct
id|script
op_star
id|scr
comma
r_struct
id|scripth
op_star
id|scripth
)paren
suffix:semicolon
r_static
r_int
id|ncr_scatter_896R1
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|ncr_scatter
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|ncr_getsync
(paren
id|ncb_p
id|np
comma
id|u_char
id|sfac
comma
id|u_char
op_star
id|fakp
comma
id|u_char
op_star
id|scntl3p
)paren
suffix:semicolon
r_static
r_void
id|ncr_get_xfer_info
c_func
(paren
id|ncb_p
id|np
comma
id|tcb_p
id|tp
comma
id|u_char
op_star
id|factor
comma
id|u_char
op_star
id|offset
comma
id|u_char
op_star
id|width
)paren
suffix:semicolon
r_static
r_void
id|ncr_setsync
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|scntl3
comma
id|u_char
id|sxfer
comma
id|u_char
id|scntl4
)paren
suffix:semicolon
r_static
r_void
id|ncr_set_sync_wide_status
(paren
id|ncb_p
id|np
comma
id|u_char
id|target
)paren
suffix:semicolon
r_static
r_void
id|ncr_setup_tags
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
suffix:semicolon
r_static
r_void
id|ncr_setwide
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|wide
comma
id|u_char
id|ack
)paren
suffix:semicolon
r_static
r_void
id|ncr_setsyncwide
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|scntl3
comma
id|u_char
id|sxfer
comma
id|u_char
id|scntl4
comma
id|u_char
id|wide
)paren
suffix:semicolon
r_static
r_int
id|ncr_show_msg
(paren
id|u_char
op_star
id|msg
)paren
suffix:semicolon
r_static
r_void
id|ncr_print_msg
(paren
id|ccb_p
id|cp
comma
r_char
op_star
id|label
comma
id|u_char
op_star
id|msg
)paren
suffix:semicolon
r_static
r_int
id|ncr_snooptest
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_timeout
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_wakeup
(paren
id|ncb_p
id|np
comma
id|u_long
id|code
)paren
suffix:semicolon
r_static
r_int
id|ncr_wakeup_done
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_start_next_ccb
(paren
id|ncb_p
id|np
comma
id|lcb_p
id|lp
comma
r_int
id|maxn
)paren
suffix:semicolon
r_static
r_void
id|ncr_put_start_queue
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
r_static
r_void
id|ncr_chip_reset
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_soft_reset
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_start_reset
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_int
id|ncr_reset_scsi_bus
(paren
id|ncb_p
id|np
comma
r_int
id|enab_int
comma
r_int
id|settle_delay
)paren
suffix:semicolon
r_static
r_int
id|ncr_compute_residual
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_USER_COMMAND_SUPPORT
r_static
r_void
id|ncr_usercmd
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|ncr_attach
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|unit
comma
id|ncr_device
op_star
id|device
)paren
suffix:semicolon
r_static
r_void
id|ncr_free_resources
c_func
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|insert_into_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
id|Scsi_Cmnd
op_star
id|retrieve_from_waiting_list
c_func
(paren
r_int
id|to_remove
comma
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|process_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|sts
)paren
suffix:semicolon
DECL|macro|remove_from_waiting_list
mdefine_line|#define remove_from_waiting_list(np, cmd) &bslash;&n;&t;&t;retrieve_from_waiting_list(1, (np), (cmd))
DECL|macro|requeue_waiting_list
mdefine_line|#define requeue_waiting_list(np) process_waiting_list((np), DID_OK)
DECL|macro|reset_waiting_list
mdefine_line|#define reset_waiting_list(np) process_waiting_list((np), DID_RESET)
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_static
r_void
id|ncr_get_nvram
(paren
id|ncr_device
op_star
id|devp
comma
id|ncr_nvram
op_star
id|nvp
)paren
suffix:semicolon
r_static
r_int
id|sym_read_Tekram_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
id|device_id
comma
id|Tekram_nvram
op_star
id|nvram
)paren
suffix:semicolon
r_static
r_int
id|sym_read_Symbios_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|Symbios_nvram
op_star
id|nvram
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&n;**      Global static data.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_name
r_static
r_inline
r_char
op_star
id|ncr_name
(paren
id|ncb_p
id|np
)paren
(brace
r_return
id|np-&gt;inst_name
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      Scripts for NCR-Processor.&n;**&n;**      Use ncr_script_bind for binding to physical addresses.&n;**&n;**&n;**==========================================================&n;**&n;**&t;NADDR generates a reference to a field of the controller data.&n;**&t;PADDR generates a reference to another part of the script.&n;**&t;RADDR generates a reference to a script processor register.&n;**&t;FADDR generates a reference to a script processor register&n;**&t;&t;with offset.&n;**&n;**----------------------------------------------------------&n;*/
DECL|macro|RELOC_SOFTC
mdefine_line|#define&t;RELOC_SOFTC&t;0x40000000
DECL|macro|RELOC_LABEL
mdefine_line|#define&t;RELOC_LABEL&t;0x50000000
DECL|macro|RELOC_REGISTER
mdefine_line|#define&t;RELOC_REGISTER&t;0x60000000
macro_line|#if 0
mdefine_line|#define&t;RELOC_KVAR&t;0x70000000
macro_line|#endif
DECL|macro|RELOC_LABELH
mdefine_line|#define&t;RELOC_LABELH&t;0x80000000
DECL|macro|RELOC_MASK
mdefine_line|#define&t;RELOC_MASK&t;0xf0000000
DECL|macro|NADDR
mdefine_line|#define&t;NADDR(label)&t;(RELOC_SOFTC | offsetof(struct ncb, label))
DECL|macro|PADDR
mdefine_line|#define PADDR(label)    (RELOC_LABEL | offsetof(struct script, label))
DECL|macro|PADDRH
mdefine_line|#define PADDRH(label)   (RELOC_LABELH | offsetof(struct scripth, label))
DECL|macro|RADDR
mdefine_line|#define&t;RADDR(label)&t;(RELOC_REGISTER | REG(label))
DECL|macro|FADDR
mdefine_line|#define&t;FADDR(label,ofs)(RELOC_REGISTER | ((REG(label))+(ofs)))
DECL|macro|KVAR
mdefine_line|#define&t;KVAR(which)&t;(RELOC_KVAR | (which))
DECL|macro|SCR_DATA_ZERO
mdefine_line|#define SCR_DATA_ZERO&t;0xf00ff00f
macro_line|#ifdef&t;RELOC_KVAR
DECL|macro|SCRIPT_KVAR_JIFFIES
mdefine_line|#define&t;SCRIPT_KVAR_JIFFIES&t;(0)
DECL|macro|SCRIPT_KVAR_FIRST
mdefine_line|#define&t;SCRIPT_KVAR_FIRST&t;SCRIPT_KVAR_JIFFIES
DECL|macro|SCRIPT_KVAR_LAST
mdefine_line|#define&t;SCRIPT_KVAR_LAST&t;SCRIPT_KVAR_JIFFIES
multiline_comment|/*&n; * Kernel variables referenced in the scripts.&n; * THESE MUST ALL BE ALIGNED TO A 4-BYTE BOUNDARY.&n; */
DECL|variable|__initdata
r_static
r_void
op_star
id|script_kvars
(braket
)braket
id|__initdata
op_assign
(brace
(paren
r_void
op_star
)paren
op_amp
id|jiffies
)brace
suffix:semicolon
macro_line|#endif
DECL|variable|__initdata
r_static
r_struct
id|script
id|script0
id|__initdata
op_assign
(brace
multiline_comment|/*--------------------------&lt; START &gt;-----------------------*/
(brace
multiline_comment|/*&n;&t;**&t;This NOP will be patched with LED ON&n;&t;**&t;SCR_REG_REG (gpreg, SCR_AND, 0xfe)&n;&t;*/
id|SCR_NO_OP
comma
l_int|0
comma
multiline_comment|/*&n;&t;**      Clear SIGP.&n;&t;*/
id|SCR_FROM_REG
(paren
id|ctest2
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Stop here if the C code wants to perform &n;&t;**&t;some error recovery procedure manually.&n;&t;**&t;(Indicate this by setting SEM in ISTAT)&n;&t;*/
id|SCR_FROM_REG
(paren
id|istat
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Report to the C code the next position in &n;&t;**&t;the start queue the SCRIPTS will schedule.&n;&t;**&t;The C code must not change SCRATCHA.&n;&t;*/
id|SCR_LOAD_ABS
(paren
id|scratcha
comma
l_int|4
)paren
comma
id|PADDRH
(paren
id|startpos
)paren
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|SEM
comma
id|SEM
)paren
)paren
comma
id|SIR_SCRIPT_STOPPED
comma
multiline_comment|/*&n;&t;**&t;Start the next job.&n;&t;**&n;&t;**&t;@DSA&t; = start point for this job.&n;&t;**&t;SCRATCHA = address of this job in the start queue.&n;&t;**&n;&t;**&t;We will restore startpos with SCRATCHA if we fails the &n;&t;**&t;arbitration or if it is the idle job.&n;&t;**&n;&t;**&t;The below GETJOB_BEGIN to GETJOB_END section of SCRIPTS &n;&t;**&t;is a critical path. If it is partially executed, it then &n;&t;**&t;may happen that the job address is not yet in the DSA &n;&t;**&t;and the the next queue position points to the next JOB.&n;&t;*/
id|SCR_LOAD_ABS
(paren
id|dsa
comma
l_int|4
)paren
comma
id|PADDRH
(paren
id|startpos
)paren
comma
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
l_int|4
comma
)brace
multiline_comment|/*-------------------------&lt; GETJOB_BEGIN &gt;------------------*/
comma
(brace
id|SCR_STORE_ABS
(paren
id|temp
comma
l_int|4
)paren
comma
id|PADDRH
(paren
id|startpos
)paren
comma
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; GETJOB_END &gt;--------------------*/
comma
(brace
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
l_int|0
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; SELECT &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;DSA&t;contains the address of a scheduled&n;&t;**&t;&t;data structure.&n;&t;**&n;&t;**&t;SCRATCHA contains the address of the start queue  &n;&t;**&t;&t;entry which points to the next job.&n;&t;**&n;&t;**&t;Set Initiator mode.&n;&t;**&n;&t;**&t;(Target mode is left as an exercise for the reader)&n;&t;*/
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**      And try to select this target.&n;&t;*/
id|SCR_SEL_TBL_ATN
op_xor
m_offsetof
(paren
r_struct
id|dsb
comma
id|select
)paren
comma
id|PADDR
(paren
id|ungetjob
)paren
comma
multiline_comment|/*&n;&t;**&t;Now there are 4 possibilities:&n;&t;**&n;&t;**&t;(1) The ncr looses arbitration.&n;&t;**&t;This is ok, because it will try again,&n;&t;**&t;when the bus becomes idle.&n;&t;**&t;(But beware of the timeout function!)&n;&t;**&n;&t;**&t;(2) The ncr is reselected.&n;&t;**&t;Then the script processor takes the jump&n;&t;**&t;to the RESELECT label.&n;&t;**&n;&t;**&t;(3) The ncr wins arbitration.&n;&t;**&t;Then it will execute SCRIPTS instruction until &n;&t;**&t;the next instruction that checks SCSI phase.&n;&t;**&t;Then will stop and wait for selection to be &n;&t;**&t;complete or selection time-out to occur.&n;&t;**&n;&t;**&t;After having won arbitration, the ncr SCRIPTS  &n;&t;**&t;processor is able to execute instructions while &n;&t;**&t;the SCSI core is performing SCSI selection. But &n;&t;**&t;some script instruction that is not waiting for &n;&t;**&t;a valid phase (or selection timeout) to occur &n;&t;**&t;breaks the selection procedure, by probably &n;&t;**&t;affecting timing requirements.&n;&t;**&t;So we have to wait immediately for the next phase &n;&t;**&t;or the selection to complete or time-out.&n;&t;*/
multiline_comment|/*&n;&t;**      load the savep (saved pointer) into&n;&t;**      the actual data pointer.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.savep
)paren
comma
multiline_comment|/*&n;&t;**      Initialize the status registers&n;&t;*/
id|SCR_LOAD_REL
(paren
id|scr0
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.status
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; WF_SEL_DONE &gt;----------------------*/
comma
(brace
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|SIR_SEL_ATN_NO_MSG_OUT
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_IDENT &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Selection complete.&n;&t;**&t;Send the IDENTIFY and SIMPLE_TAG messages&n;&t;**&t;(and the M_X_SYNC_REQ / M_X_WIDE_REQ message)&n;&t;*/
id|SCR_MOVE_TBL
op_xor
id|SCR_MSG_OUT
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|smsg
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SELECT2 &gt;----------------------*/
comma
(brace
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
multiline_comment|/*&n;&t;**&t;Set IMMEDIATE ARBITRATION if we have been given &n;&t;**&t;a hint to do so. (Some job to do after this one).&n;&t;*/
id|SCR_FROM_REG
(paren
id|HF_REG
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|HF_HINT_IARB
comma
id|HF_HINT_IARB
)paren
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|scntl1
comma
id|SCR_OR
comma
id|IARB
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Anticipate the COMMAND phase.&n;&t;**&t;This is the PHASE we expect at this point.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_COMMAND
)paren
)paren
comma
id|PADDR
(paren
id|sel_no_cmd
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; COMMAND &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;... and send the command&n;&t;*/
id|SCR_MOVE_TBL
op_xor
id|SCR_COMMAND
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|cmd
)paren
comma
)brace
multiline_comment|/*-----------------------&lt; DISPATCH &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;MSG_IN is the only phase that shall be &n;&t;**&t;entered at least once for each (re)selection.&n;&t;**&t;So we test it first.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|msg_in
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
id|PADDR
(paren
id|datao_phase
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_DATA_IN
)paren
)paren
comma
id|PADDR
(paren
id|datai_phase
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_STATUS
)paren
)paren
comma
id|PADDR
(paren
id|status
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_COMMAND
)paren
)paren
comma
id|PADDR
(paren
id|command
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDRH
(paren
id|msg_out
)paren
comma
multiline_comment|/*&n;&t; *  Set the extended error flag.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_EXT_ERR
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**      Discard one illegal phase byte, if required.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|1
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|xerr_status
)paren
comma
id|SCR_REG_REG
(paren
id|scratcha
comma
id|SCR_OR
comma
id|XE_BAD_PHASE
)paren
comma
l_int|0
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|1
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|xerr_status
)paren
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|IF
(paren
id|SCR_ILG_OUT
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_ILG_OUT
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|IF
(paren
id|SCR_ILG_IN
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_ILG_IN
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*---------------------&lt; SEL_NO_CMD &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The target does not switch to command &n;&t;**&t;phase after IDENTIFY has been sent.&n;&t;**&n;&t;**&t;If it stays in MSG OUT phase send it &n;&t;**&t;the IDENTIFY again.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDRH
(paren
id|resend_ident
)paren
comma
multiline_comment|/*&n;&t;**&t;If target does not switch to MSG IN phase &n;&t;**&t;and we sent a negotiation, assert the &n;&t;**&t;failure immediately.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
id|SCR_FROM_REG
(paren
id|HS_REG
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|HS_NEGOTIATE
)paren
)paren
comma
id|SIR_NEGO_FAILED
comma
multiline_comment|/*&n;&t;**&t;Jump to dispatcher.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; INIT &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Wait for the SCSI RESET signal to be &n;&t;**&t;inactive before restarting operations, &n;&t;**&t;since the chip may hang on SEL_ATN &n;&t;**&t;if SCSI RESET is active.&n;&t;*/
id|SCR_FROM_REG
(paren
id|sstat0
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|IRST
comma
id|IRST
)paren
)paren
comma
op_minus
l_int|16
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; CLRACK &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Terminate possible pending message phase.&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DISP_STATUS &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Anticipate STATUS phase.&n;&t;**&n;&t;**&t;Does spare 3 SCRIPTS instructions when we have &n;&t;**&t;completed the INPUT of the data.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_STATUS
)paren
)paren
comma
id|PADDR
(paren
id|status
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATAI_DONE &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  If the device wants us to send more data,&n;&t; *  we must count the extra bytes.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
comma
id|PADDRH
(paren
id|data_ovrun
)paren
comma
multiline_comment|/*&n;&t;**&t;If the SWIDE is not full, jump to dispatcher.&n;&t;**&t;We anticipate a STATUS phase.&n;&t;**&t;If we get later an IGNORE WIDE RESIDUE, we &n;&t;**&t;will alias it as a MODIFY DP (-1).&n;&t;*/
id|SCR_FROM_REG
(paren
id|scntl2
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|WSR
comma
id|WSR
)paren
)paren
comma
id|PADDR
(paren
id|disp_status
)paren
comma
multiline_comment|/*&n;&t;**&t;The SWIDE is full.&n;&t;**&t;Clear this condition.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_OR
comma
id|WSR
)paren
comma
l_int|0
comma
multiline_comment|/*&n;         *&t;We are expecting an IGNORE RESIDUE message&n;         *&t;from the device, otherwise we are in data&n;         *&t;overrun condition. Check against MSG_IN phase.&n;&t;*/
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|SIR_SWIDE_OVERRUN
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|disp_status
)paren
comma
multiline_comment|/*&n;&t; *&t;We are in MSG_IN phase,&n;&t; *&t;Read the first byte of the message.&n;&t; *&t;If it is not an IGNORE RESIDUE message,&n;&t; *&t;signal overrun and jump to message&n;&t; *&t;processing.&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|0
)braket
)paren
comma
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|M_IGN_RESIDUE
)paren
)paren
comma
id|SIR_SWIDE_OVERRUN
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|M_IGN_RESIDUE
)paren
)paren
comma
id|PADDR
(paren
id|msg_in2
)paren
comma
multiline_comment|/*&n;&t; *&t;We got the message we expected.&n;&t; *&t;Read the 2nd byte, and jump to dispatcher.&n;&t; */
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|1
)braket
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|disp_status
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATAO_DONE &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  If the device wants us to send more data,&n;&t; *  we must count the extra bytes.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
id|PADDRH
(paren
id|data_ovrun
)paren
comma
multiline_comment|/*&n;&t;**&t;If the SODL is not full jump to dispatcher.&n;&t;**&t;We anticipate a MSG IN phase or a STATUS phase.&n;&t;*/
id|SCR_FROM_REG
(paren
id|scntl2
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|WSS
comma
id|WSS
)paren
)paren
comma
id|PADDR
(paren
id|disp_status
)paren
comma
multiline_comment|/*&n;&t;**&t;The SODL is full, clear this condition.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_OR
comma
id|WSS
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;And signal a DATA UNDERRUN condition &n;&t;**&t;to the C code.&n;&t;*/
id|SCR_INT
comma
id|SIR_SODL_UNDERRUN
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; IGN_I_W_R_MSG &gt;--------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;We jump here from the phase mismatch interrupt, &n;&t;**&t;When we have a SWIDE and the device has presented &n;&t;**&t;a IGNORE WIDE RESIDUE message on the BUS.&n;&t;**&t;We just have to throw away this message and then &n;&t;**&t;to jump to dispatcher.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|2
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|scratch
)paren
comma
multiline_comment|/*&n;&t;**&t;Clear ACK and jump to dispatcher.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATAI_PHASE &gt;------------------*/
comma
(brace
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|SCR_REG_REG
(paren
id|QU_REG
comma
id|SCR_OR
comma
id|HF_DATA_ST
)paren
comma
l_int|0
comma
macro_line|#endif
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; DATAO_PHASE &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Patch for 53c1010_66 only - to allow A0 part&n;&t;**&t;to operate properly in a 33MHz PCI bus.&n;&t;**&n;&t;** &t;SCR_REG_REG(scntl4, SCR_OR, 0x0c),&n;&t;**&t;&t;0,&n;&t;*/
id|SCR_NO_OP
comma
l_int|0
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IN &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Get the first byte of the message.&n;&t;**&n;&t;**&t;The script processor doesn&squot;t negate the&n;&t;**&t;ACK signal after this transfer.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|0
)braket
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IN2 &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Check first against 1 byte messages &n;&t;**&t;that we handle from SCRIPTS.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_COMPLETE
)paren
)paren
comma
id|PADDR
(paren
id|complete
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_DISCONNECT
)paren
)paren
comma
id|PADDR
(paren
id|disconnect
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_SAVE_DP
)paren
)paren
comma
id|PADDR
(paren
id|save_dp
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_RESTORE_DP
)paren
)paren
comma
id|PADDR
(paren
id|restore_dp
)paren
comma
multiline_comment|/*&n;&t;**&t;We handle all other messages from the &n;&t;**&t;C code, so no need to waste on-chip RAM &n;&t;**&t;for those ones.&n;&t;*/
id|SCR_JUMP
comma
id|PADDRH
(paren
id|msg_in_etc
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; STATUS &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;get the status&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_STATUS
comma
id|NADDR
(paren
id|scratch
)paren
comma
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
multiline_comment|/*&n;&t;**&t;If STATUS is not GOOD, clear IMMEDIATE ARBITRATION, &n;&t;**&t;since we may have to tamper the start queue from &n;&t;**&t;the C code.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|S_GOOD
)paren
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|scntl1
comma
id|SCR_AND
comma
op_complement
id|IARB
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t;**&t;save status to scsi_status.&n;&t;**&t;mark as complete.&n;&t;*/
id|SCR_TO_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_COMPLETE
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Anticipate the MESSAGE PHASE for &n;&t;**&t;the TASK COMPLETE message.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|msg_in
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; COMPLETE &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Complete message.&n;&t;**&n;&t;**&t;Copy the data pointer to LASTP in header.&n;&t;*/
id|SCR_STORE_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.lastp
)paren
comma
multiline_comment|/*&n;&t;**&t;When we terminate the cycle by clearing ACK,&n;&t;**&t;the target may disconnect immediately.&n;&t;**&n;&t;**&t;We don&squot;t want to be told of an&n;&t;**&t;&quot;unexpected disconnect&quot;,&n;&t;**&t;so we disable this feature.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Terminate cycle ...&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;... and wait for the disconnect.&n;&t;*/
id|SCR_WAIT_DISC
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; COMPLETE2 &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Save host status to header.&n;&t;*/
id|SCR_STORE_REL
(paren
id|scr0
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.status
)paren
comma
macro_line|#ifdef SCSI_NCR_PCIQ_MAY_REORDER_WRITES
multiline_comment|/*&n;&t;**&t;Some bridges may reorder DMA writes to memory.&n;&t;**&t;We donnot want the CPU to deal with completions  &n;&t;**&t;without all the posted write having been flushed &n;&t;**&t;to memory. This DUMMY READ should flush posted &n;&t;**&t;buffers prior to the CPU having to deal with &n;&t;**&t;completions.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|scr0
comma
l_int|4
)paren
comma
multiline_comment|/* DUMMY READ */
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.status
)paren
comma
macro_line|#endif
multiline_comment|/*&n;&t;**&t;If command resulted in not GOOD status,&n;&t;**&t;call the C code if needed.&n;&t;*/
id|SCR_FROM_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|S_GOOD
)paren
)paren
comma
id|PADDRH
(paren
id|bad_status
)paren
comma
multiline_comment|/*&n;&t;**&t;If we performed an auto-sense, call &n;&t;**&t;the C code to synchronyze task aborts &n;&t;**&t;with UNIT ATTENTION conditions.&n;&t;*/
id|SCR_FROM_REG
(paren
id|HF_REG
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|HF_AUTO_SENSE
comma
id|HF_AUTO_SENSE
)paren
)paren
comma
id|SIR_AUTO_SENSE_DONE
comma
)brace
multiline_comment|/*------------------------&lt; DONE &gt;-----------------*/
comma
(brace
macro_line|#ifdef SCSI_NCR_PCIQ_SYNC_ON_INTR
multiline_comment|/*&n;&t;**&t;It seems that some bridges flush everything &n;&t;**&t;when the INTR line is raised. For these ones, &n;&t;**&t;we can just ensure that the INTR line will be &n;&t;**&t;raised before each completion. So, if it happens &n;&t;**&t;that we have been faster that the CPU, we just &n;&t;**&t;have to synchronize with it. A dummy programmed &n;&t;**&t;interrupt will do the trick.&n;&t;**&t;Note that we overlap at most 1 IO with the CPU &n;&t;**&t;in this situation and that the IRQ line must not &n;&t;**&t;be shared.&n;&t;*/
id|SCR_FROM_REG
(paren
id|istat
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|INTF
comma
id|INTF
)paren
)paren
comma
id|SIR_DUMMY_INTERRUPT
comma
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Copy the DSA to the DONE QUEUE and &n;&t;**&t;signal completion to the host.&n;&t;**&t;If we are interrupted between DONE &n;&t;**&t;and DONE_END, we must reset, otherwise &n;&t;**&t;the completed CCB will be lost.&n;&t;*/
id|SCR_STORE_ABS
(paren
id|dsa
comma
l_int|4
)paren
comma
id|PADDRH
(paren
id|saved_dsa
)paren
comma
id|SCR_LOAD_ABS
(paren
id|dsa
comma
l_int|4
)paren
comma
id|PADDRH
(paren
id|done_pos
)paren
comma
id|SCR_LOAD_ABS
(paren
id|scratcha
comma
l_int|4
)paren
comma
id|PADDRH
(paren
id|saved_dsa
)paren
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;The instruction below reads the DONE QUEUE next &n;&t;**&t;free position from memory.&n;&t;**&t;In addition it ensures that all PCI posted writes  &n;&t;**&t;are flushed and so the DSA value of the done &n;&t;**&t;CCB is visible by the CPU before INTFLY is raised.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
l_int|4
comma
id|SCR_INT_FLY
comma
l_int|0
comma
id|SCR_STORE_ABS
(paren
id|temp
comma
l_int|4
)paren
comma
id|PADDRH
(paren
id|done_pos
)paren
comma
)brace
multiline_comment|/*------------------------&lt; DONE_END &gt;-----------------*/
comma
(brace
id|SCR_JUMP
comma
id|PADDR
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SAVE_DP &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Clear ACK immediately.&n;&t;**&t;No need to delay it.&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Keep track we received a SAVE DP, so &n;&t;**&t;we will switch to the other PM context &n;&t;**&t;on the next PM since the DP may point &n;&t;**&t;to the current PM context.&n;&t;*/
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_DP_SAVED
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;SAVE_DP message:&n;&t;**&t;Copy the data pointer to SAVEP in header.&n;&t;*/
id|SCR_STORE_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.savep
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESTORE_DP &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;RESTORE_DP message:&n;&t;**&t;Copy SAVEP in header to actual data pointer.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.savep
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DISCONNECT &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;DISCONNECTing  ...&n;&t;**&n;&t;**&t;disable the &quot;unexpected disconnect&quot; feature,&n;&t;**&t;and remove the ACK signal.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Wait for the disconnect.&n;&t;*/
id|SCR_WAIT_DISC
comma
l_int|0
comma
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
multiline_comment|/*&n;&t;**&t;Count the disconnects.&n;&t;**&t;Disconnect without DATA PHASE having been &n;&t;**&t;entered are counted in bits 8..15.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.num_disc
)paren
comma
id|SCR_FROM_REG
(paren
id|QU_REG
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|HF_DATA_ST
comma
id|HF_DATA_ST
)paren
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|scratcha1
comma
id|SCR_ADD
comma
l_int|0x01
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|scratcha
comma
id|SCR_ADD
comma
l_int|0x01
)paren
comma
l_int|0
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.num_disc
)paren
comma
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Status is: DISCONNECTED.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_DISCONNECT
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Save host status to header.&n;&t;*/
id|SCR_STORE_REL
(paren
id|scr0
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.status
)paren
comma
multiline_comment|/*&n;&t;**&t;If QUIRK_AUTOSAVE is set,&n;&t;**&t;do an &quot;save pointer&quot; operation.&n;&t;*/
id|SCR_FROM_REG
(paren
id|QU_REG
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|QUIRK_AUTOSAVE
comma
id|QUIRK_AUTOSAVE
)paren
)paren
comma
id|PADDR
(paren
id|start
)paren
comma
multiline_comment|/*&n;&t;**&t;like SAVE_DP message:&n;&t;**&t;Remember we saved the data pointer.&n;&t;**&t;Copy data pointer to SAVEP in header.&n;&t;*/
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_DP_SAVED
)paren
comma
l_int|0
comma
id|SCR_STORE_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.savep
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; IDLE &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Nothing to do?&n;&t;**&t;Wait for reselect.&n;&t;**&t;This NOP will be patched with LED OFF&n;&t;**&t;SCR_REG_REG (gpreg, SCR_OR, 0x01)&n;&t;*/
id|SCR_NO_OP
comma
l_int|0
comma
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
id|SCR_JUMPR
comma
l_int|8
comma
macro_line|#endif
)brace
multiline_comment|/*-------------------------&lt; UNGETJOB &gt;-----------------*/
comma
(brace
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
multiline_comment|/*&n;&t;**&t;Set IMMEDIATE ARBITRATION, for the next time.&n;&t;**&t;This will give us better chance to win arbitration &n;&t;**&t;for the job we just wanted to do.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl1
comma
id|SCR_OR
comma
id|IARB
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t;**&t;We are not able to restart the SCRIPTS if we are &n;&t;**&t;interrupted and these instruction haven&squot;t been &n;&t;**&t;all executed. BTW, this is very unlikely to &n;&t;**&t;happen, but we check that from the C code.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|dsa
comma
l_int|0xff
)paren
comma
l_int|0
comma
id|SCR_STORE_ABS
(paren
id|scratcha
comma
l_int|4
)paren
comma
id|PADDRH
(paren
id|startpos
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESELECT &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;make the host status invalid.&n;&t;*/
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Sleep waiting for a reselection.&n;&t;**&t;If SIGP is set, special treatment.&n;&t;**&n;&t;**&t;Zu allem bereit ..&n;&t;*/
id|SCR_WAIT_RESEL
comma
id|PADDR
c_func
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESELECTED &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;This NOP will be patched with LED ON&n;&t;**&t;SCR_REG_REG (gpreg, SCR_AND, 0xfe)&n;&t;*/
id|SCR_NO_OP
comma
l_int|0
comma
multiline_comment|/*&n;&t;**      load the target id into the sdid&n;&t;*/
id|SCR_REG_SFBR
(paren
id|ssid
comma
id|SCR_AND
comma
l_int|0x8F
)paren
comma
l_int|0
comma
id|SCR_TO_REG
(paren
id|sdid
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;load the target control block address&n;&t;*/
id|SCR_LOAD_ABS
(paren
id|dsa
comma
l_int|4
)paren
comma
id|PADDRH
(paren
id|targtbl
)paren
comma
id|SCR_SFBR_REG
(paren
id|dsa
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|dsa
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|dsa
comma
id|SCR_AND
comma
l_int|0x3c
)paren
comma
l_int|0
comma
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Load the synchronous transfer registers.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|scntl3
comma
l_int|1
)paren
comma
m_offsetof
(paren
r_struct
id|tcb
comma
id|wval
)paren
comma
id|SCR_LOAD_REL
(paren
id|sxfer
comma
l_int|1
)paren
comma
m_offsetof
(paren
r_struct
id|tcb
comma
id|sval
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_SCNTL4 &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Write with uval value. Patch if device&n;&t;**&t;does not support Ultra3.&n;&t;**&t;&n;&t;**&t;SCR_LOAD_REL (scntl4, 1),&n;&t;**&t;&t;offsetof(struct tcb, uval),&n;&t;*/
id|SCR_NO_OP
comma
l_int|0
comma
multiline_comment|/*&n;         *  We expect MESSAGE IN phase.&n;         *  If not, get help from the C code.&n;         */
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|SIR_RESEL_NO_MSG_IN
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
)paren
comma
multiline_comment|/*&n;&t; *  If IDENTIFY LUN #0, use a faster path &n;&t; *  to find the LCB structure.&n;&t; */
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0x80
comma
l_int|0xbf
)paren
)paren
comma
l_int|56
comma
multiline_comment|/*&n;&t; *  If message isn&squot;t an IDENTIFY, &n;&t; *  tell the C code about.&n;&t; */
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|MASK
(paren
l_int|0x80
comma
l_int|0x80
)paren
)paren
comma
id|SIR_RESEL_NO_IDENTIFY
comma
multiline_comment|/*&n;&t; *  It is an IDENTIFY message,&n;&t; *  Load the LUN control block address.&n;&t; */
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|tcb
comma
id|b_luntbl
)paren
comma
id|SCR_SFBR_REG
(paren
id|dsa
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|dsa
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|dsa
comma
id|SCR_AND
comma
l_int|0xfc
)paren
comma
l_int|0
comma
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
l_int|0
comma
id|SCR_JUMPR
comma
l_int|8
comma
multiline_comment|/*&n;&t;**&t;LUN 0 special case (but usual one :))&n;&t;*/
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|tcb
comma
id|b_lun0
)paren
comma
multiline_comment|/*&n;&t;**&t;Load the reselect task action for this LUN.&n;&t;**&t;Load the tasks DSA array for this LUN.&n;&t;**&t;Call the action.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|lcb
comma
id|resel_task
)paren
comma
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|lcb
comma
id|b_tasktbl
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_TAG &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;ACK the IDENTIFY or TAG previously received&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Read IDENTIFY + SIMPLE + TAG using a single MOVE.&n;&t;**&t;Agressive optimization, is&squot;nt it?&n;&t;**&t;No need to test the SIMPLE TAG message, since the &n;&t;**&t;driver only supports conformant devices for tags. ;-)&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|2
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
)paren
comma
multiline_comment|/*&n;&t;**&t;Read the TAG from the SIDL.&n;&t;**&t;Still an aggressive optimization. ;-)&n;&t;**&t;Compute the CCB indirect jump address which &n;&t;**&t;is (#TAG*2 &amp; 0xfc) due to tag numbering using &n;&t;**&t;1,3,5..MAXTAGS*2+1 actual values.&n;&t;*/
id|SCR_REG_SFBR
(paren
id|sidl
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
macro_line|#if MAX_TASKS*4 &gt; 512
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|CARRYSET
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|dsa1
comma
id|SCR_OR
comma
l_int|2
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|sfbr
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|CARRYSET
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|dsa1
comma
id|SCR_OR
comma
l_int|1
)paren
comma
l_int|0
comma
macro_line|#elif MAX_TASKS*4 &gt; 256
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|CARRYSET
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|dsa1
comma
id|SCR_OR
comma
l_int|1
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Retrieve the DSA of this task.&n;&t;**&t;JUMP indirectly to the restart point of the CCB.&n;&t;*/
id|SCR_SFBR_REG
(paren
id|dsa
comma
id|SCR_AND
comma
l_int|0xfc
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_GO &gt;-------------------*/
comma
(brace
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
l_int|0
comma
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.go.restart
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
multiline_comment|/* In normal situations we branch to RESEL_DSA */
)brace
multiline_comment|/*-------------------------&lt; RESEL_NOTAG &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;JUMP indirectly to the restart point of the CCB.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|resel_go
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_DSA &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Ack the IDENTIFY or TAG previously received.&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**      load the savep (saved pointer) into&n;&t;**      the actual data pointer.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.savep
)paren
comma
multiline_comment|/*&n;&t;**      Initialize the status registers&n;&t;*/
id|SCR_LOAD_REL
(paren
id|scr0
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.status
)paren
comma
multiline_comment|/*&n;&t;**&t;Jump to dispatcher.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IN &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;**&t;Because the size depends on the&n;**&t;#define MAX_SCATTER parameter,&n;**&t;it is filled in at runtime.&n;**&n;**  ##===========&lt; i=0; i&lt;MAX_SCATTER &gt;=========&n;**  ||&t;SCR_CHMOV_TBL ^ SCR_DATA_IN,&n;**  ||&t;&t;offsetof (struct dsb, data[ i]),&n;**  ##==========================================&n;**&n;**---------------------------------------------------------&n;*/
l_int|0
)brace
multiline_comment|/*-------------------------&lt; DATA_IN2 &gt;-------------------*/
comma
(brace
id|SCR_CALL
comma
id|PADDR
(paren
id|datai_done
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|data_ovrun
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_OUT &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;**&t;Because the size depends on the&n;**&t;#define MAX_SCATTER parameter,&n;**&t;it is filled in at runtime.&n;**&n;**  ##===========&lt; i=0; i&lt;MAX_SCATTER &gt;=========&n;**  ||&t;SCR_CHMOV_TBL ^ SCR_DATA_OUT,&n;**  ||&t;&t;offsetof (struct dsb, data[ i]),&n;**  ##==========================================&n;**&n;**---------------------------------------------------------&n;*/
l_int|0
)brace
multiline_comment|/*-------------------------&lt; DATA_OUT2 &gt;-------------------*/
comma
(brace
id|SCR_CALL
comma
id|PADDR
(paren
id|datao_done
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|data_ovrun
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM0_DATA &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Read our host flags to SFBR, so we will be able &n;&t;**&t;to check against the data direction we expect.&n;&t;*/
id|SCR_FROM_REG
(paren
id|HF_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Check against actual DATA PHASE.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
comma
id|PADDR
(paren
id|pm0_data_out
)paren
comma
multiline_comment|/*&n;&t;**&t;Actual phase is DATA IN.&n;&t;**&t;Check against expected direction.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|HF_DATA_IN
comma
id|HF_DATA_IN
)paren
)paren
comma
id|PADDRH
(paren
id|data_ovrun
)paren
comma
multiline_comment|/*&n;&t;**&t;Keep track we are moving data from the &n;&t;**&t;PM0 DATA mini-script.&n;&t;*/
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_IN_PM0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Move the data to memory.&n;&t;*/
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm0.sg
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|pm0_data_end
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM0_DATA_OUT &gt;----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Actual phase is DATA OUT.&n;&t;**&t;Check against expected direction.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|HF_DATA_IN
comma
id|HF_DATA_IN
)paren
)paren
comma
id|PADDRH
(paren
id|data_ovrun
)paren
comma
multiline_comment|/*&n;&t;**&t;Keep track we are moving data from the &n;&t;**&t;PM0 DATA mini-script.&n;&t;*/
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_IN_PM0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Move the data from memory.&n;&t;*/
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_OUT
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm0.sg
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM0_DATA_END &gt;----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Clear the flag that told we were moving  &n;&t;**&t;data from the PM0 DATA mini-script.&n;&t;*/
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_AND
comma
(paren
op_complement
id|HF_IN_PM0
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Return to the previous DATA script which &n;&t;**&t;is guaranteed by design (if no bug) to be &n;&t;**&t;the main DATA script for this transfer.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm0.ret
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; PM1_DATA &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Read our host flags to SFBR, so we will be able &n;&t;**&t;to check against the data direction we expect.&n;&t;*/
id|SCR_FROM_REG
(paren
id|HF_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Check against actual DATA PHASE.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
comma
id|PADDR
(paren
id|pm1_data_out
)paren
comma
multiline_comment|/*&n;&t;**&t;Actual phase is DATA IN.&n;&t;**&t;Check against expected direction.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|HF_DATA_IN
comma
id|HF_DATA_IN
)paren
)paren
comma
id|PADDRH
(paren
id|data_ovrun
)paren
comma
multiline_comment|/*&n;&t;**&t;Keep track we are moving data from the &n;&t;**&t;PM1 DATA mini-script.&n;&t;*/
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_IN_PM1
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Move the data to memory.&n;&t;*/
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm1.sg
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|pm1_data_end
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM1_DATA_OUT &gt;----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Actual phase is DATA OUT.&n;&t;**&t;Check against expected direction.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|HF_DATA_IN
comma
id|HF_DATA_IN
)paren
)paren
comma
id|PADDRH
(paren
id|data_ovrun
)paren
comma
multiline_comment|/*&n;&t;**&t;Keep track we are moving data from the &n;&t;**&t;PM1 DATA mini-script.&n;&t;*/
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_IN_PM1
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Move the data from memory.&n;&t;*/
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_OUT
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm1.sg
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM1_DATA_END &gt;----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Clear the flag that told we were moving  &n;&t;**&t;data from the PM1 DATA mini-script.&n;&t;*/
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_AND
comma
(paren
op_complement
id|HF_IN_PM1
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Return to the previous DATA script which &n;&t;**&t;is guaranteed by design (if no bug) to be &n;&t;**&t;the main DATA script for this transfer.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm1.ret
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*---------------------------------------------------------*/
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_struct
id|scripth
id|scripth0
id|__initdata
op_assign
(brace
multiline_comment|/*------------------------&lt; START64 &gt;-----------------------*/
(brace
multiline_comment|/*&n;&t;**&t;SCRIPT entry point for the 895A and the 896.&n;&t;**&t;For now, there is no specific stuff for that &n;&t;**&t;chip at this point, but this may come.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|init
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; NO_DATA &gt;-------------------*/
comma
(brace
id|SCR_JUMP
comma
id|PADDRH
(paren
id|data_ovrun
)paren
comma
)brace
multiline_comment|/*-----------------------&lt; SEL_FOR_ABORT &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;We are jumped here by the C code, if we have &n;&t;**&t;some target to reset or some disconnected &n;&t;**&t;job to abort. Since error recovery is a serious &n;&t;**&t;busyness, we will really reset the SCSI BUS, if &n;&t;**&t;case of a SCSI interrupt occuring in this path.&n;&t;*/
multiline_comment|/*&n;&t;**&t;Set initiator mode.&n;&t;*/
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**      And try to select this target.&n;&t;*/
id|SCR_SEL_TBL_ATN
op_xor
m_offsetof
(paren
r_struct
id|ncb
comma
id|abrt_sel
)paren
comma
id|PADDR
(paren
id|reselect
)paren
comma
multiline_comment|/*&n;&t;**&t;Wait for the selection to complete or &n;&t;**&t;the selection to time out.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
op_minus
l_int|8
comma
multiline_comment|/*&n;&t;**&t;Call the C code.&n;&t;*/
id|SCR_INT
comma
id|SIR_TARGET_SELECTED
comma
multiline_comment|/*&n;&t;**&t;The C code should let us continue here. &n;&t;**&t;Send the &squot;kiss of death&squot; message.&n;&t;**&t;We expect an immediate disconnect once &n;&t;**&t;the target has eaten the message.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_MOVE_TBL
op_xor
id|SCR_MSG_OUT
comma
m_offsetof
(paren
r_struct
id|ncb
comma
id|abrt_tbl
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_WAIT_DISC
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Tell the C code that we are done.&n;&t;*/
id|SCR_INT
comma
id|SIR_ABORT_SENT
comma
)brace
multiline_comment|/*-----------------------&lt; SEL_FOR_ABORT_1 &gt;--------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Jump at scheduler.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|start
)paren
comma
)brace
multiline_comment|/*------------------------&lt; SELECT_NO_ATN &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Set Initiator mode.&n;&t;**      And try to select this target without ATN.&n;&t;*/
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
id|SCR_SEL_TBL
op_xor
m_offsetof
(paren
r_struct
id|dsb
comma
id|select
)paren
comma
id|PADDR
(paren
id|ungetjob
)paren
comma
multiline_comment|/*&n;&t;**      load the savep (saved pointer) into&n;&t;**      the actual data pointer.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.savep
)paren
comma
multiline_comment|/*&n;&t;**      Initialize the status registers&n;&t;*/
id|SCR_LOAD_REL
(paren
id|scr0
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.status
)paren
comma
)brace
multiline_comment|/*------------------------&lt; WF_SEL_DONE_NO_ATN &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Wait immediately for the next phase or &n;&t;**&t;the selection to complete or time-out.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|select2
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IN_ETC &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If it is an EXTENDED (variable size message)&n;&t;**&t;Handle it.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_EXTENDED
)paren
)paren
comma
id|PADDRH
(paren
id|msg_extended
)paren
comma
multiline_comment|/*&n;&t;**&t;Let the C code handle any other &n;&t;**&t;1 byte message.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0x00
comma
l_int|0xf0
)paren
)paren
comma
id|PADDRH
(paren
id|msg_received
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0x10
comma
l_int|0xf0
)paren
)paren
comma
id|PADDRH
(paren
id|msg_received
)paren
comma
multiline_comment|/*&n;&t;**&t;We donnot handle 2 bytes messages from SCRIPTS.&n;&t;**&t;So, let the C code deal with these ones too.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
l_int|0x20
comma
l_int|0xf0
)paren
)paren
comma
id|PADDRH
(paren
id|msg_weird_seen
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|1
)braket
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|msg_received
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_RECEIVED &gt;--------------------*/
comma
(brace
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
multiline_comment|/* DUMMY READ */
l_int|0
comma
id|SCR_INT
comma
id|SIR_MSG_RECEIVED
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_WEIRD_SEEN &gt;------------------*/
comma
(brace
id|SCR_LOAD_REL
(paren
id|scratcha1
comma
l_int|4
)paren
comma
multiline_comment|/* DUMMY READ */
l_int|0
comma
id|SCR_INT
comma
id|SIR_MSG_WEIRD
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_EXTENDED &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Clear ACK and get the next byte &n;&t;**&t;assumed to be the message length.&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|1
)braket
)paren
comma
multiline_comment|/*&n;&t;**&t;Try to catch some unlikely situations as 0 length &n;&t;**&t;or too large the length.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
l_int|0
)paren
)paren
comma
id|PADDRH
(paren
id|msg_weird_seen
)paren
comma
id|SCR_TO_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|sfbr
comma
id|SCR_ADD
comma
(paren
l_int|256
op_minus
l_int|8
)paren
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|CARRYSET
)paren
comma
id|PADDRH
(paren
id|msg_weird_seen
)paren
comma
multiline_comment|/*&n;&t;**&t;We donnot handle extended messages from SCRIPTS.&n;&t;**&t;Read the amount of data correponding to the &n;&t;**&t;message length and call the C code.&n;&t;*/
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|1
)paren
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|smsg_ext.size
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_MOVE_TBL
op_xor
id|SCR_MSG_IN
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|smsg_ext
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|msg_received
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_BAD &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;unimplemented message - reject it.&n;&t;*/
id|SCR_INT
comma
id|SIR_REJECT_TO_SEND
comma
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_WEIRD &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;weird message received&n;&t;**&t;ignore all MSG IN phases and reject it.&n;&t;*/
id|SCR_INT
comma
id|SIR_REJECT_TO_SEND
comma
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_WEIRD1 &gt;--------------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|msg_weird1
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; WDTR_RESP &gt;----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;let the target fetch our answer.&n;&t;*/
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDRH
(paren
id|nego_bad_phase
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_WDTR &gt;----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Send the M_X_WIDE_REQ&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|4
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|msg_out_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SDTR_RESP &gt;-------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;let the target fetch our answer.&n;&t;*/
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDRH
(paren
id|nego_bad_phase
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_SDTR &gt;-------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Send the M_X_SYNC_REQ&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|5
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|msg_out_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PPR_RESP &gt;-------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;let the target fetch our answer.&n;&t;*/
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDRH
(paren
id|nego_bad_phase
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_PPR &gt;-------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Send the M_X_PPR_REQ&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|8
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|msg_out_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; NEGO_BAD_PHASE &gt;------------*/
comma
(brace
id|SCR_INT
comma
id|SIR_NEGO_PROTO
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The target requests a message.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
multiline_comment|/*&n;&t;**&t;... wait for the next phase&n;&t;**&t;if it&squot;s a message out, send it again, ...&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDRH
(paren
id|msg_out
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT_DONE &gt;--------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;... else clear the message ...&n;&t;*/
id|SCR_INT
comma
id|SIR_MSG_OUT_DONE
comma
multiline_comment|/*&n;&t;**&t;... and process the next phase&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_OVRUN &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  The target may want to transfer too much data.&n;&t; *&n;&t; *  If phase is DATA OUT write 1 byte and count it.&n;&t; */
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
l_int|16
comma
id|SCR_CHMOV_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_DATA_OUT
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|data_ovrun1
)paren
comma
multiline_comment|/*&n;&t; *  If WSR is set, clear this condition, and &n;&t; *  count this byte.&n;&t; */
id|SCR_FROM_REG
(paren
id|scntl2
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|WSR
comma
id|WSR
)paren
)paren
comma
l_int|16
comma
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_OR
comma
id|WSR
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|data_ovrun1
)paren
comma
multiline_comment|/*&n;&t; *  Finally check against DATA IN phase.&n;&t; *  Jump to dispatcher if not so.&n;&t; *  Read 1 byte otherwise and count it.&n;&t; */
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|IF
(paren
id|SCR_DATA_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
id|SCR_CHMOV_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_DATA_IN
comma
id|NADDR
(paren
id|scratch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_OVRUN1 &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Set the extended error flag.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_EXT_ERR
)paren
comma
l_int|0
comma
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|1
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|xerr_status
)paren
comma
id|SCR_REG_REG
(paren
id|scratcha
comma
id|SCR_OR
comma
id|XE_EXTRA_DATA
)paren
comma
l_int|0
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|1
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|xerr_status
)paren
comma
multiline_comment|/*&n;&t; *  Count this byte.&n;&t; *  This will allow to return a negative &n;&t; *  residual to user.&n;&t; */
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.extra_bytes
)paren
comma
id|SCR_REG_REG
(paren
id|scratcha
comma
id|SCR_ADD
comma
l_int|0x01
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|scratcha1
comma
id|SCR_ADDC
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|scratcha2
comma
id|SCR_ADDC
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.extra_bytes
)paren
comma
multiline_comment|/*&n;&t; *  .. and repeat as required.&n;&t; */
id|SCR_JUMP
comma
id|PADDRH
(paren
id|data_ovrun
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; ABORT_RESEL &gt;----------------*/
comma
(brace
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;send the abort/abortag/reset message&n;&t;**&t;we expect an immediate disconnect&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_WAIT_DISC
comma
l_int|0
comma
id|SCR_INT
comma
id|SIR_RESEL_ABORTED
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEND_IDENT &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The target stays in MSG OUT phase after having acked &n;&t;**&t;Identify [+ Tag [+ Extended message ]]. Targets shall&n;&t;**&t;behave this way on parity error.&n;&t;**&t;We must send it again all the messages.&n;&t;*/
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
multiline_comment|/* Shall be asserted 2 deskew delays before the  */
l_int|0
comma
multiline_comment|/* 1rst ACK = 90 ns. Hope the NCR is&squot;nt too fast */
id|SCR_JUMP
comma
id|PADDR
(paren
id|send_ident
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; IDENT_BREAK &gt;-------------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|select2
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; IDENT_BREAK_ATN &gt;----------------*/
comma
(brace
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|select2
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SDATA_IN &gt;-------------------*/
comma
(brace
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|sense
)paren
comma
id|SCR_CALL
comma
id|PADDR
(paren
id|datai_done
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|data_ovrun
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IO &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;We jump here if the data direction was unknown at the &n;&t;**&t;time we had to queue the command to the scripts processor.&n;&t;**&t;Pointers had been set as follow in this situation:&n;&t;**&t;  savep   --&gt;   DATA_IO&n;&t;**&t;  lastp   --&gt;   start pointer when DATA_IN&n;&t;**&t;  goalp   --&gt;   goal  pointer when DATA_IN&n;&t;**&t;  wlastp  --&gt;   start pointer when DATA_OUT&n;&t;**&t;  wgoalp  --&gt;   goal  pointer when DATA_OUT&n;&t;**&t;This script sets savep/lastp/goalp according to the &n;&t;**&t;direction chosen by the target.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
id|PADDRH
c_func
(paren
id|data_io_out
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IO_COM &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Direction is DATA IN.&n;&t;**&t;Warning: we jump here, even when phase is DATA OUT.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.lastp
)paren
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.savep
)paren
comma
multiline_comment|/*&n;&t;**&t;Jump to the SCRIPTS according to actual direction.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.savep
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IO_OUT &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Direction is DATA OUT.&n;&t;*/
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_AND
comma
(paren
op_complement
id|HF_DATA_IN
)paren
)paren
comma
l_int|0
comma
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.wlastp
)paren
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.lastp
)paren
comma
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.wgoalp
)paren
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.goalp
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
c_func
(paren
id|data_io_com
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_BAD_LUN &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Message is an IDENTIFY, but lun is unknown.&n;&t;**&t;Signal problem to C code for logging the event.&n;&t;**&t;Send a M_ABORT to clear all pending tasks.&n;&t;*/
id|SCR_INT
comma
id|SIR_RESEL_BAD_LUN
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|abort_resel
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_I_T_L &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;We donnot have a task for that I_T_L.&n;&t;**&t;Signal problem to C code for logging the event.&n;&t;**&t;Send a M_ABORT message.&n;&t;*/
id|SCR_INT
comma
id|SIR_RESEL_BAD_I_T_L
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|abort_resel
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_I_T_L_Q &gt;----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;We donnot have a task that matches the tag.&n;&t;**&t;Signal problem to C code for logging the event.&n;&t;**&t;Send a M_ABORTTAG message.&n;&t;*/
id|SCR_INT
comma
id|SIR_RESEL_BAD_I_T_L_Q
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|abort_resel
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_STATUS &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Anything different from INTERMEDIATE &n;&t;**&t;CONDITION MET should be a bad SCSI status, &n;&t;**&t;given that GOOD status has already been tested.&n;&t;**&t;Call the C code.&n;&t;*/
id|SCR_LOAD_ABS
(paren
id|scratcha
comma
l_int|4
)paren
comma
id|PADDRH
(paren
id|startpos
)paren
comma
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|S_COND_MET
)paren
)paren
comma
id|SIR_BAD_STATUS
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; TWEAK_PMJ &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Disable PM handling from SCRIPTS for the data phase &n;&t;**&t;and so force PM to be handled from C code if HF_PM_TO_C &n;&t;**&t;flag is set.&n;&t;*/
id|SCR_FROM_REG
c_func
(paren
id|HF_REG
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|HF_PM_TO_C
comma
id|HF_PM_TO_C
)paren
)paren
comma
l_int|16
comma
id|SCR_REG_REG
(paren
id|ccntl0
comma
id|SCR_OR
comma
id|ENPMJ
)paren
comma
l_int|0
comma
id|SCR_RETURN
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|ccntl0
comma
id|SCR_AND
comma
(paren
op_complement
id|ENPMJ
)paren
)paren
comma
l_int|0
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; PM_HANDLE &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Phase mismatch handling.&n;&t;**&n;&t;**&t;Since we have to deal with 2 SCSI data pointers  &n;&t;**&t;(current and saved), we need at least 2 contexts.&n;&t;**&t;Each context (pm0 and pm1) has a saved area, a &n;&t;**&t;SAVE mini-script and a DATA phase mini-script.&n;&t;*/
multiline_comment|/*&n;&t;**&t;Get the PM handling flags.&n;&t;*/
id|SCR_FROM_REG
(paren
id|HF_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;If no flags (1rst PM for example), avoid &n;&t;**&t;all the below heavy flags testing.&n;&t;**&t;This makes the normal case a bit faster.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0
comma
(paren
id|HF_IN_PM0
op_or
id|HF_IN_PM1
op_or
id|HF_DP_SAVED
)paren
)paren
)paren
comma
id|PADDRH
(paren
id|pm_handle1
)paren
comma
multiline_comment|/*&n;&t;**&t;If we received a SAVE DP, switch to the &n;&t;**&t;other PM context since the savep may point &n;&t;**&t;to the current PM context.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|HF_DP_SAVED
comma
id|HF_DP_SAVED
)paren
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|sfbr
comma
id|SCR_XOR
comma
id|HF_ACT_PM
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;If we have been interrupt in a PM DATA mini-script,&n;&t;**&t;we take the return address from the corresponding &n;&t;**&t;saved area.&n;&t;**&t;This ensure the return address always points to the &n;&t;**&t;main DATA script for this transfer.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0
comma
(paren
id|HF_IN_PM0
op_or
id|HF_IN_PM1
)paren
)paren
)paren
comma
id|PADDRH
(paren
id|pm_handle1
)paren
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|HF_IN_PM0
comma
id|HF_IN_PM0
)paren
)paren
comma
l_int|16
comma
id|SCR_LOAD_REL
(paren
id|ia
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm0.ret
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|pm_save
)paren
comma
id|SCR_LOAD_REL
(paren
id|ia
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm1.ret
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|pm_save
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM_HANDLE1 &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Normal case.&n;&t;**&t;Update the return address so that it &n;&t;**&t;will point after the interrupted MOVE.&n;&t;*/
id|SCR_REG_REG
(paren
id|ia
comma
id|SCR_ADD
comma
l_int|8
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|ia1
comma
id|SCR_ADDC
comma
l_int|0
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; PM_SAVE &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Clear all the flags that told us if we were &n;&t;**&t;interrupted in a PM DATA mini-script and/or &n;&t;**&t;we received a SAVE DP.&n;&t;*/
id|SCR_SFBR_REG
(paren
id|HF_REG
comma
id|SCR_AND
comma
(paren
op_complement
(paren
id|HF_IN_PM0
op_or
id|HF_IN_PM1
op_or
id|HF_DP_SAVED
)paren
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Choose the current PM context.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|HF_ACT_PM
comma
id|HF_ACT_PM
)paren
)paren
comma
id|PADDRH
(paren
id|pm1_save
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM0_SAVE &gt;-------------------*/
comma
(brace
id|SCR_STORE_REL
(paren
id|ia
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm0.ret
)paren
comma
multiline_comment|/*&n;&t;**&t;If WSR bit is set, either UA and RBC may &n;&t;**&t;have to be changed whatever the device wants &n;&t;**&t;to ignore this residue ot not.&n;&t;*/
id|SCR_FROM_REG
(paren
id|scntl2
)paren
comma
l_int|0
comma
id|SCR_CALL
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|WSR
comma
id|WSR
)paren
)paren
comma
id|PADDRH
(paren
id|pm_wsr_handle
)paren
comma
multiline_comment|/*&n;&t;**&t;Save the remaining byte count, the updated &n;&t;**&t;address and the return address.&n;&t;*/
id|SCR_STORE_REL
(paren
id|rbc
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm0.sg.size
)paren
comma
id|SCR_STORE_REL
(paren
id|ua
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm0.sg.addr
)paren
comma
multiline_comment|/*&n;&t;**&t;Set the current pointer at the PM0 DATA mini-script.&n;&t;*/
id|SCR_LOAD_ABS
(paren
id|temp
comma
l_int|4
)paren
comma
id|PADDRH
(paren
id|pm0_data_addr
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM1_SAVE &gt;-------------------*/
comma
(brace
id|SCR_STORE_REL
(paren
id|ia
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm1.ret
)paren
comma
multiline_comment|/*&n;&t;**&t;If WSR bit is set, either UA and RBC may &n;&t;**&t;have been changed whatever the device wants &n;&t;**&t;to ignore this residue or not.&n;&t;*/
id|SCR_FROM_REG
(paren
id|scntl2
)paren
comma
l_int|0
comma
id|SCR_CALL
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|WSR
comma
id|WSR
)paren
)paren
comma
id|PADDRH
(paren
id|pm_wsr_handle
)paren
comma
multiline_comment|/*&n;&t;**&t;Save the remaining byte count, the updated &n;&t;**&t;address and the return address.&n;&t;*/
id|SCR_STORE_REL
(paren
id|rbc
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm1.sg.size
)paren
comma
id|SCR_STORE_REL
(paren
id|ua
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm1.sg.addr
)paren
comma
multiline_comment|/*&n;&t;**&t;Set the current pointer at the PM1 DATA mini-script.&n;&t;*/
id|SCR_LOAD_ABS
(paren
id|temp
comma
l_int|4
)paren
comma
id|PADDRH
(paren
id|pm1_data_addr
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*--------------------------&lt; PM_WSR_HANDLE &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Phase mismatch handling from SCRIPT with WSR set.&n;&t; *  Such a condition can occur if the chip wants to &n;&t; *  execute a CHMOV(size &gt; 1) when the WSR bit is &n;&t; *  set and the target changes PHASE.&n;&t; */
macro_line|#ifdef&t;SYM_DEBUG_PM_WITH_WSR
multiline_comment|/*&n;&t; *  Some debugging may still be needed.:)&n;&t; */
id|SCR_INT
comma
id|SIR_PM_WITH_WSR
comma
macro_line|#endif
multiline_comment|/*&n;&t; *  We must move the residual byte to memory.&n;&t; *&n;&t; *  UA contains bit 0..31 of the address to &n;&t; *  move the residual byte.&n;&t; *  Move it to the table indirect.&n;&t; */
id|SCR_STORE_REL
(paren
id|ua
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.wresid.addr
)paren
comma
multiline_comment|/*&n;&t; *  Increment UA (move address to next position).&n;&t; */
id|SCR_REG_REG
(paren
id|ua
comma
id|SCR_ADD
comma
l_int|1
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|ua1
comma
id|SCR_ADDC
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|ua2
comma
id|SCR_ADDC
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|ua3
comma
id|SCR_ADDC
comma
l_int|0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Compute SCRATCHA as:&n;&t; *  - size to transfer = 1 byte.&n;&t; *  - bit 24..31 = high address bit [32...39].&n;&t; */
id|SCR_LOAD_ABS
(paren
id|scratcha
comma
l_int|4
)paren
comma
id|PADDRH
(paren
id|zero
)paren
comma
id|SCR_REG_REG
(paren
id|scratcha
comma
id|SCR_OR
comma
l_int|1
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|rbc3
)paren
comma
l_int|0
comma
id|SCR_TO_REG
(paren
id|scratcha3
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Move this value to the table indirect.&n;&t; */
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.wresid.size
)paren
comma
multiline_comment|/*&n;&t; *  Wait for a valid phase.&n;&t; *  While testing with bogus QUANTUM drives, the C1010 &n;&t; *  sometimes raised a spurious phase mismatch with &n;&t; *  WSR and the CHMOV(1) triggered another PM.&n;&t; *  Waiting explicitely for the PHASE seemed to avoid &n;&t; *  the nested phase mismatch. Btw, this didn&squot;t happen &n;&t; *  using my IBM drives.&n;&t; */
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Perform the move of the residual byte.&n;&t; */
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.wresid
)paren
comma
multiline_comment|/*&n;&t; *  We can now handle the phase mismatch with UA fixed.&n;&t; *  RBC[0..23]=0 is a special case that does not require &n;&t; *  a PM context. The C code also checks against this.&n;&t; */
id|SCR_FROM_REG
(paren
id|rbc
)paren
comma
l_int|0
comma
id|SCR_RETURN
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|0
)paren
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|rbc1
)paren
comma
l_int|0
comma
id|SCR_RETURN
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|0
)paren
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|rbc2
)paren
comma
l_int|0
comma
id|SCR_RETURN
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|0
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  RBC[0..23]=0.&n;&t; *  Not only we donnot need a PM context, but this would &n;&t; *  lead to a bogus CHMOV(0). This condition means that &n;&t; *  the residual was the last byte to move from this CHMOV.&n;&t; *  So, we just have to move the current data script pointer &n;&t; *  (i.e. TEMP) to the SCRIPTS address following the &n;&t; *  interrupted CHMOV and jump to dispatcher.&n;&t; */
id|SCR_STORE_ABS
(paren
id|ia
comma
l_int|4
)paren
comma
id|PADDRH
(paren
id|scratch
)paren
comma
id|SCR_LOAD_ABS
(paren
id|temp
comma
l_int|4
)paren
comma
id|PADDRH
(paren
id|scratch
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*--------------------------&lt; WSR_MA_HELPER &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Helper for the C code when WSR bit is set.&n;&t; *  Perform the move of the residual byte.&n;&t; */
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.wresid
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; ZERO &gt;------------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; SCRATCH &gt;---------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; SCRATCH1 &gt;--------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; PM0_DATA_ADDR &gt;---------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; PM1_DATA_ADDR &gt;---------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; SAVED_DSA &gt;-------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; SAVED_DRS &gt;-------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; DONE_POS &gt;--------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; STARTPOS &gt;--------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; TARGTBL &gt;---------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
multiline_comment|/*&n;** We may use MEMORY MOVE instructions to load the on chip-RAM,&n;** if it happens that mapping PCI memory is not possible.&n;** But writing the RAM from the CPU is the preferred method, &n;** since PCI 2.2 seems to disallow PCI self-mastering.&n;*/
macro_line|#ifdef SCSI_NCR_PCI_MEM_NOT_SUPPORTED
)brace
multiline_comment|/*-------------------------&lt; START_RAM &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Load the script into on-chip RAM, &n;&t;**&t;and jump to start point.&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|script
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SCRIPT0_BA &gt;--------------------*/
comma
(brace
l_int|0
comma
id|PADDR
(paren
id|start
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|init
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; START_RAM64 &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Load the RAM and start for 64 bit PCI (895A,896).&n;&t;**&t;Both scripts (script and scripth) are loaded into &n;&t;**&t;the RAM which is 8K (4K for 825A/875/895).&n;&t;**&t;We also need to load some 32-63 bit segments &n;&t;**&t;address of the SCRIPTS processor.&n;&t;**&t;LOAD/STORE ABSOLUTE always refers to on-chip RAM &n;&t;**&t;in our implementation. The main memory is &n;&t;**&t;accessed using LOAD/STORE DSA RELATIVE.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|mmws
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ncb
comma
id|scr_ram_seg
)paren
comma
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|script
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SCRIPT0_BA64 &gt;--------------------*/
comma
(brace
l_int|0
comma
id|PADDR
(paren
id|start
)paren
comma
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|scripth
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SCRIPTH0_BA64 &gt;--------------------*/
comma
(brace
l_int|0
comma
id|PADDRH
(paren
id|start64
)paren
comma
id|SCR_LOAD_REL
(paren
id|mmrs
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ncb
comma
id|scr_ram_seg
)paren
comma
id|SCR_JUMP64
comma
id|PADDRH
(paren
id|start64
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RAM_SEG64 &gt;--------------------*/
comma
(brace
l_int|0
comma
macro_line|#endif /* SCSI_NCR_PCI_MEM_NOT_SUPPORTED */
)brace
multiline_comment|/*-------------------------&lt; SNOOPTEST &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Read the variable.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ncb
comma
id|ncr_cache
)paren
comma
id|SCR_STORE_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ncb
comma
id|ncr_cache
)paren
comma
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ncb
comma
id|ncr_cache
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SNOOPEND &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;And stop.&n;&t;*/
id|SCR_INT
comma
l_int|99
comma
)brace
multiline_comment|/*--------------------------------------------------------*/
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Fill in #define dependent parts of the script&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_script_fill
r_void
id|__init
id|ncr_script_fill
(paren
r_struct
id|script
op_star
id|scr
comma
r_struct
id|scripth
op_star
id|scrh
)paren
(brace
r_int
id|i
suffix:semicolon
id|ncrcmd
op_star
id|p
suffix:semicolon
id|p
op_assign
id|scr-&gt;data_in
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SCATTER
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_IN
suffix:semicolon
op_star
id|p
op_increment
op_assign
m_offsetof
(paren
r_struct
id|dsb
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scr-&gt;data_in
op_plus
r_sizeof
(paren
id|scr-&gt;data_in
)paren
)paren
suffix:semicolon
id|p
op_assign
id|scr-&gt;data_out
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SCATTER
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_OUT
suffix:semicolon
op_star
id|p
op_increment
op_assign
m_offsetof
(paren
r_struct
id|dsb
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scr-&gt;data_out
op_plus
r_sizeof
(paren
id|scr-&gt;data_out
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Copy and rebind a script.&n;**&n;**&n;**==========================================================&n;*/
r_static
r_void
id|__init
DECL|function|ncr_script_copy_and_bind
id|ncr_script_copy_and_bind
(paren
id|ncb_p
id|np
comma
id|ncrcmd
op_star
id|src
comma
id|ncrcmd
op_star
id|dst
comma
r_int
id|len
)paren
(brace
id|ncrcmd
id|opcode
comma
r_new
comma
id|old
comma
id|tmp1
comma
id|tmp2
suffix:semicolon
id|ncrcmd
op_star
id|start
comma
op_star
id|end
suffix:semicolon
r_int
id|relocs
suffix:semicolon
r_int
id|opchanged
op_assign
l_int|0
suffix:semicolon
id|start
op_assign
id|src
suffix:semicolon
id|end
op_assign
id|src
op_plus
id|len
op_div
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|src
OL
id|end
)paren
(brace
id|opcode
op_assign
op_star
id|src
op_increment
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|cpu_to_scr
c_func
(paren
id|opcode
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;If we forget to change the length&n;&t;&t;**&t;in struct script, a field will be&n;&t;&t;**&t;padded with 0. This is an illegal&n;&t;&t;**&t;command.&n;&t;&t;*/
r_if
c_cond
(paren
id|opcode
op_eq
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: ERROR0 IN SCRIPT at %d.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
r_int
)paren
(paren
id|src
op_minus
id|start
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|MDELAY
(paren
l_int|10000
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;We use the bogus value 0xf00ff00f ;-)&n;&t;&t;**&t;to reserve data area in SCRIPTS.&n;&t;&t;*/
r_if
c_cond
(paren
id|opcode
op_eq
id|SCR_DATA_ZERO
)paren
(brace
id|dst
(braket
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_SCRIPT
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;%p:  &lt;%x&gt;&bslash;n&quot;
comma
(paren
id|src
op_minus
l_int|1
)paren
comma
(paren
r_int
)paren
id|opcode
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;We don&squot;t have to decode ALL commands&n;&t;&t;*/
r_switch
c_cond
(paren
id|opcode
op_rshift
l_int|28
)paren
(brace
r_case
l_int|0xf
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;LOAD / STORE DSA relative, don&squot;t relocate.&n;&t;&t;&t;*/
id|relocs
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xe
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;LOAD / STORE absolute.&n;&t;&t;&t;*/
id|relocs
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xc
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;COPY has TWO arguments.&n;&t;&t;&t;*/
id|relocs
op_assign
l_int|2
suffix:semicolon
id|tmp1
op_assign
id|src
(braket
l_int|0
)braket
suffix:semicolon
id|tmp2
op_assign
id|src
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#ifdef&t;RELOC_KVAR
r_if
c_cond
(paren
(paren
id|tmp1
op_amp
id|RELOC_MASK
)paren
op_eq
id|RELOC_KVAR
)paren
id|tmp1
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp2
op_amp
id|RELOC_MASK
)paren
op_eq
id|RELOC_KVAR
)paren
id|tmp2
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|tmp1
op_xor
id|tmp2
)paren
op_amp
l_int|3
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: ERROR1 IN SCRIPT at %d.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
r_int
)paren
(paren
id|src
op_minus
id|start
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|MDELAY
(paren
l_int|1000
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;**&t;If PREFETCH feature not enabled, remove &n;&t;&t;&t;**&t;the NO FLUSH bit if present.&n;&t;&t;&t;*/
r_if
c_cond
(paren
(paren
id|opcode
op_amp
id|SCR_NO_FLUSH
)paren
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_PFEN
)paren
)paren
(brace
id|dst
(braket
op_minus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|opcode
op_amp
op_complement
id|SCR_NO_FLUSH
)paren
suffix:semicolon
op_increment
id|opchanged
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x0
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;MOVE/CHMOV (absolute address)&n;&t;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_WIDE
)paren
)paren
id|dst
(braket
op_minus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|opcode
op_or
id|OPC_MOVE
)paren
suffix:semicolon
id|relocs
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;MOVE/CHMOV (table indirect)&n;&t;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_WIDE
)paren
)paren
id|dst
(braket
op_minus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|opcode
op_or
id|OPC_MOVE
)paren
suffix:semicolon
id|relocs
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x8
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;JUMP / CALL&n;&t;&t;&t;**&t;dont&squot;t relocate if relative :-)&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|opcode
op_amp
l_int|0x00800000
)paren
id|relocs
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|opcode
op_amp
l_int|0xf8400000
)paren
op_eq
l_int|0x80400000
)paren
multiline_comment|/*JUMP64*/
id|relocs
op_assign
l_int|2
suffix:semicolon
r_else
id|relocs
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4
suffix:colon
r_case
l_int|0x5
suffix:colon
r_case
l_int|0x6
suffix:colon
r_case
l_int|0x7
suffix:colon
id|relocs
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|relocs
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|relocs
)paren
(brace
op_star
id|dst
op_increment
op_assign
id|cpu_to_scr
c_func
(paren
op_star
id|src
op_increment
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_while
c_loop
(paren
id|relocs
op_decrement
)paren
(brace
id|old
op_assign
op_star
id|src
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|old
op_amp
id|RELOC_MASK
)paren
(brace
r_case
id|RELOC_REGISTER
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|pcivtobus
c_func
(paren
id|np-&gt;base_ba
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RELOC_LABEL
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|np-&gt;p_script
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RELOC_LABELH
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|np-&gt;p_scripth
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RELOC_SOFTC
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|np-&gt;p_ncb
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef&t;RELOC_KVAR
r_case
id|RELOC_KVAR
suffix:colon
r_new
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
OL
id|SCRIPT_KVAR_FIRST
)paren
op_logical_or
(paren
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
OG
id|SCRIPT_KVAR_LAST
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;ncr KVAR out of range&quot;
)paren
suffix:semicolon
r_new
op_assign
id|vtobus
c_func
(paren
id|script_kvars
(braket
id|old
op_amp
op_complement
id|RELOC_MASK
)braket
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* Don&squot;t relocate a 0 address. */
r_if
c_cond
(paren
id|old
op_eq
l_int|0
)paren
(brace
r_new
op_assign
id|old
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* fall through */
r_default
suffix:colon
r_new
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* For &squot;cc&squot; not to complain */
id|panic
c_func
(paren
l_string|&quot;ncr_script_copy_and_bind: &quot;
l_string|&quot;weird relocation %x&bslash;n&quot;
comma
id|old
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
id|dst
op_increment
op_assign
id|cpu_to_scr
c_func
(paren
r_new
)paren
suffix:semicolon
)brace
)brace
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      Auto configuration:  attach and init a host adapter.&n;**&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**&t;Linux host data structure.&n;*/
DECL|struct|host_data
r_struct
id|host_data
(brace
DECL|member|ncb
r_struct
id|ncb
op_star
id|ncb
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;Print something which allows to retrieve the controler type, unit,&n;**&t;target, lun concerned by a kernel message.&n;*/
DECL|function|PRINT_TARGET
r_static
r_void
id|PRINT_TARGET
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|target
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s-&lt;%d,*&gt;: &quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|target
)paren
suffix:semicolon
)brace
DECL|function|PRINT_LUN
r_static
r_void
id|PRINT_LUN
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|target
comma
r_int
id|lun
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s-&lt;%d,%d&gt;: &quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|target
comma
id|lun
)paren
suffix:semicolon
)brace
DECL|function|PRINT_ADDR
r_static
r_void
id|PRINT_ADDR
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|host_data
op_star
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|PRINT_LUN
c_func
(paren
id|host_data-&gt;ncb
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;NCR chip clock divisor table.&n;**&t;Divisors are multiplied by 10,000,000 in order to make &n;**&t;calculations more simple.&n;**&n;**==========================================================&n;*/
DECL|macro|_5M
mdefine_line|#define _5M 5000000
DECL|variable|div_10M
r_static
id|u_long
id|div_10M
(braket
)braket
op_assign
(brace
l_int|2
op_star
id|_5M
comma
l_int|3
op_star
id|_5M
comma
l_int|4
op_star
id|_5M
comma
l_int|6
op_star
id|_5M
comma
l_int|8
op_star
id|_5M
comma
l_int|12
op_star
id|_5M
comma
l_int|16
op_star
id|_5M
)brace
suffix:semicolon
multiline_comment|/*===============================================================&n;**&n;**&t;Prepare io register values used by ncr_init() according &n;**&t;to selected and supported features.&n;**&n;**&t;NCR/SYMBIOS chips allow burst lengths of 2, 4, 8, 16, 32, 64,&n;**&t;128 transfers. All chips support at least 16 transfers bursts. &n;**&t;The 825A, 875 and 895 chips support bursts of up to 128 &n;**&t;transfers and the 895A and 896 support bursts of up to 64 &n;**&t;transfers. All other chips support up to 16 transfers bursts.&n;**&n;**&t;For PCI 32 bit data transfers each transfer is a DWORD (4 bytes).&n;**&t;It is a QUADWORD (8 bytes) for PCI 64 bit data transfers.&n;**&t;Only the 896 is able to perform 64 bit data transfers.&n;**&n;**&t;We use log base 2 (burst length) as internal code, with &n;**&t;value 0 meaning &quot;burst disabled&quot;.&n;**&n;**===============================================================&n;*/
multiline_comment|/*&n; *&t;Burst length from burst code.&n; */
DECL|macro|burst_length
mdefine_line|#define burst_length(bc) (!(bc))? 0 : 1 &lt;&lt; (bc)
multiline_comment|/*&n; *&t;Burst code from io register bits.&n; */
DECL|macro|burst_code
mdefine_line|#define burst_code(dmode, ctest4, ctest5) &bslash;&n;&t;(ctest4) &amp; 0x80? 0 : (((dmode) &amp; 0xc0) &gt;&gt; 6) + ((ctest5) &amp; 0x04) + 1
multiline_comment|/*&n; *&t;Set initial io register bits from burst code.&n; */
DECL|function|ncr_init_burst
r_static
r_inline
r_void
id|ncr_init_burst
c_func
(paren
id|ncb_p
id|np
comma
id|u_char
id|bc
)paren
(brace
id|np-&gt;rv_ctest4
op_and_assign
op_complement
l_int|0x80
suffix:semicolon
id|np-&gt;rv_dmode
op_and_assign
op_complement
(paren
l_int|0x3
op_lshift
l_int|6
)paren
suffix:semicolon
id|np-&gt;rv_ctest5
op_and_assign
op_complement
l_int|0x4
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc
)paren
(brace
id|np-&gt;rv_ctest4
op_or_assign
l_int|0x80
suffix:semicolon
)brace
r_else
(brace
op_decrement
id|bc
suffix:semicolon
id|np-&gt;rv_dmode
op_or_assign
(paren
(paren
id|bc
op_amp
l_int|0x3
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|np-&gt;rv_ctest5
op_or_assign
(paren
id|bc
op_amp
l_int|0x4
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
multiline_comment|/*&n;**&t;Get target set-up from Symbios format NVRAM.&n;*/
r_static
r_void
id|__init
DECL|function|ncr_Symbios_setup_target
id|ncr_Symbios_setup_target
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|target
comma
id|Symbios_nvram
op_star
id|nvram
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|Symbios_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|tp-&gt;usrsync
op_assign
id|tn-&gt;sync_period
ques
c_cond
(paren
id|tn-&gt;sync_period
op_plus
l_int|3
)paren
op_div
l_int|4
suffix:colon
l_int|255
suffix:semicolon
id|tp-&gt;usrwide
op_assign
id|tn-&gt;bus_width
op_eq
l_int|0x10
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|tp-&gt;usrtags
op_assign
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_QUEUE_TAGS_ENABLED
)paren
ques
c_cond
id|MAX_TAGS
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_DISCONNECT_ENABLE
)paren
)paren
id|tp-&gt;usrflag
op_or_assign
id|UF_NODISC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_SCAN_AT_BOOT_TIME
)paren
)paren
id|tp-&gt;usrflag
op_or_assign
id|UF_NOSCAN
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Get target set-up from Tekram format NVRAM.&n;*/
r_static
r_void
id|__init
DECL|function|ncr_Tekram_setup_target
id|ncr_Tekram_setup_target
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|target
comma
id|Tekram_nvram
op_star
id|nvram
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_struct
id|Tekram_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_SYNC_NEGO
)paren
(brace
id|i
op_assign
id|tn-&gt;sync_index
op_amp
l_int|0xf
suffix:semicolon
id|tp-&gt;usrsync
op_assign
id|Tekram_sync
(braket
id|i
)braket
suffix:semicolon
)brace
id|tp-&gt;usrwide
op_assign
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_WIDE_NEGO
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_TAGGED_COMMANDS
)paren
(brace
id|tp-&gt;usrtags
op_assign
l_int|2
op_lshift
id|nvram-&gt;max_tags_index
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_DISCONNECT_ENABLE
)paren
)paren
id|tp-&gt;usrflag
op_assign
id|UF_NODISC
suffix:semicolon
multiline_comment|/* If any device does not support parity, we will not use this option */
r_if
c_cond
(paren
op_logical_neg
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_PARITY_CHECK
)paren
)paren
id|np-&gt;rv_scntl0
op_and_assign
op_complement
l_int|0x0a
suffix:semicolon
multiline_comment|/* SCSI parity checking disabled */
)brace
macro_line|#endif /* SCSI_NCR_NVRAM_SUPPORT */
multiline_comment|/*&n;**&t;Save initial settings of some IO registers.&n;**&t;Assumed to have been set by BIOS.&n;*/
DECL|function|ncr_save_initial_setting
r_static
r_void
id|__init
id|ncr_save_initial_setting
c_func
(paren
id|ncb_p
id|np
)paren
(brace
id|np-&gt;sv_scntl0
op_assign
id|INB
c_func
(paren
id|nc_scntl0
)paren
op_amp
l_int|0x0a
suffix:semicolon
id|np-&gt;sv_dmode
op_assign
id|INB
c_func
(paren
id|nc_dmode
)paren
op_amp
l_int|0xce
suffix:semicolon
id|np-&gt;sv_dcntl
op_assign
id|INB
c_func
(paren
id|nc_dcntl
)paren
op_amp
l_int|0xa8
suffix:semicolon
id|np-&gt;sv_ctest3
op_assign
id|INB
c_func
(paren
id|nc_ctest3
)paren
op_amp
l_int|0x01
suffix:semicolon
id|np-&gt;sv_ctest4
op_assign
id|INB
c_func
(paren
id|nc_ctest4
)paren
op_amp
l_int|0x80
suffix:semicolon
id|np-&gt;sv_gpcntl
op_assign
id|INB
c_func
(paren
id|nc_gpcntl
)paren
suffix:semicolon
id|np-&gt;sv_stest2
op_assign
id|INB
c_func
(paren
id|nc_stest2
)paren
op_amp
l_int|0x20
suffix:semicolon
id|np-&gt;sv_stest4
op_assign
id|INB
c_func
(paren
id|nc_stest4
)paren
suffix:semicolon
id|np-&gt;sv_stest1
op_assign
id|INB
c_func
(paren
id|nc_stest1
)paren
suffix:semicolon
id|np-&gt;sv_scntl3
op_assign
id|INB
c_func
(paren
id|nc_scntl3
)paren
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
(brace
multiline_comment|/*&n; &t;&t;** C1010 always uses large fifo, bit 5 rsvd&n; &t;&t;** scntl4 used ONLY with C1010&n; &t;&t;*/
id|np-&gt;sv_ctest5
op_assign
id|INB
c_func
(paren
id|nc_ctest5
)paren
op_amp
l_int|0x04
suffix:semicolon
id|np-&gt;sv_scntl4
op_assign
id|INB
c_func
(paren
id|nc_scntl4
)paren
suffix:semicolon
)brace
r_else
(brace
id|np-&gt;sv_ctest5
op_assign
id|INB
c_func
(paren
id|nc_ctest5
)paren
op_amp
l_int|0x24
suffix:semicolon
id|np-&gt;sv_scntl4
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;**&t;Prepare io register values used by ncr_init() &n;**&t;according to selected and supported features.&n;*/
DECL|function|ncr_prepare_setting
r_static
r_int
id|__init
id|ncr_prepare_setting
c_func
(paren
id|ncb_p
id|np
comma
id|ncr_nvram
op_star
id|nvram
)paren
(brace
id|u_char
id|burst_max
suffix:semicolon
id|u_long
id|period
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wide ?&n;&t;*/
id|np-&gt;maxwide
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_WIDE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Get the frequency of the chip&squot;s clock.&n;&t;**&t;Find the right value for scntl3.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_QUAD
)paren
id|np-&gt;multiplier
op_assign
l_int|4
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_DBLR
)paren
id|np-&gt;multiplier
op_assign
l_int|2
suffix:semicolon
r_else
id|np-&gt;multiplier
op_assign
l_int|1
suffix:semicolon
id|np-&gt;clock_khz
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_CLK80
)paren
ques
c_cond
l_int|80000
suffix:colon
l_int|40000
suffix:semicolon
id|np-&gt;clock_khz
op_mul_assign
id|np-&gt;multiplier
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;clock_khz
op_ne
l_int|40000
)paren
id|ncr_getclock
c_func
(paren
id|np
comma
id|np-&gt;multiplier
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Divisor to be used for async (timer pre-scaler).&n;&t; *&n;&t; * Note: For C1010 the async divisor is 2(8) if he&n;&t; * quadrupler is disabled (enabled).&n;&t; */
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
(brace
id|np-&gt;rv_scntl3
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|i
op_assign
id|np-&gt;clock_divn
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|i
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
l_int|10ul
op_star
id|SCSI_NCR_MIN_ASYNC
op_star
id|np-&gt;clock_khz
OG
id|div_10M
(braket
id|i
)braket
)paren
(brace
op_increment
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|np-&gt;rv_scntl3
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Save the ultra3 register for the C1010/C1010_66&n;&t; */
id|np-&gt;rv_scntl4
op_assign
id|np-&gt;sv_scntl4
suffix:semicolon
multiline_comment|/*&n;&t; * Minimum synchronous period factor supported by the chip.&n;&t; * Btw, &squot;period&squot; is in tenths of nanoseconds.&n;&t; */
id|period
op_assign
(paren
l_int|4
op_star
id|div_10M
(braket
l_int|0
)braket
op_plus
id|np-&gt;clock_khz
op_minus
l_int|1
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
r_if
c_cond
(paren
id|period
op_le
l_int|250
)paren
id|np-&gt;minsync
op_assign
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|period
op_le
l_int|303
)paren
id|np-&gt;minsync
op_assign
l_int|11
suffix:semicolon
r_else
r_if
c_cond
(paren
id|period
op_le
l_int|500
)paren
id|np-&gt;minsync
op_assign
l_int|12
suffix:semicolon
r_else
id|np-&gt;minsync
op_assign
(paren
id|period
op_plus
l_int|40
op_minus
l_int|1
)paren
op_div
l_int|40
suffix:semicolon
multiline_comment|/*&n;&t; * Fix up. If sync. factor is 10 (160000Khz clock) and chip&n;&t; * supports ultra3, then min. sync. period 12.5ns and the factor is 9 &n;&t; */
r_if
c_cond
(paren
(paren
id|np-&gt;minsync
op_eq
l_int|10
)paren
op_logical_and
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA3
)paren
)paren
id|np-&gt;minsync
op_assign
l_int|9
suffix:semicolon
multiline_comment|/*&n;&t; * Check against chip SCSI standard support (SCSI-2,ULTRA,ULTRA2).&n;&t; *&n;&t; * Transfer period minimums: SCSI-1 200 (50); Fast 100 (25)&n;&t; *&t;&t;&t;Ultra 50 (12); Ultra2 (6); Ultra3 (3)&t;&t;&n;&t; */
r_if
c_cond
(paren
id|np-&gt;minsync
OL
l_int|25
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
(paren
id|FE_ULTRA
op_or
id|FE_ULTRA2
op_or
id|FE_ULTRA3
)paren
)paren
)paren
id|np-&gt;minsync
op_assign
l_int|25
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;minsync
OL
l_int|12
op_logical_and
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA
)paren
)paren
id|np-&gt;minsync
op_assign
l_int|12
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;minsync
OL
l_int|10
op_logical_and
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA2
)paren
)paren
id|np-&gt;minsync
op_assign
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;minsync
OL
l_int|9
op_logical_and
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA3
)paren
)paren
id|np-&gt;minsync
op_assign
l_int|9
suffix:semicolon
multiline_comment|/*&n;&t; * Maximum synchronous period factor supported by the chip.&n;&t; */
id|period
op_assign
(paren
l_int|11
op_star
id|div_10M
(braket
id|np-&gt;clock_divn
op_minus
l_int|1
)braket
)paren
op_div
(paren
l_int|4
op_star
id|np-&gt;clock_khz
)paren
suffix:semicolon
id|np-&gt;maxsync
op_assign
id|period
OG
l_int|2540
ques
c_cond
l_int|254
suffix:colon
id|period
op_div
l_int|10
suffix:semicolon
multiline_comment|/*&n;&t;**&t;64 bit (53C895A or 53C896) ?&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_64BIT
)paren
macro_line|#ifdef SCSI_NCR_USE_64BIT_DAC
id|np-&gt;rv_ccntl1
op_or_assign
(paren
id|XTIMOD
op_or
id|EXTIBMV
)paren
suffix:semicolon
macro_line|#else
id|np-&gt;rv_ccntl1
op_or_assign
(paren
id|DDAC
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Phase mismatch handled by SCRIPTS (53C895A, 53C896 or C1010) ?&n;  &t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_NOPM
)paren
id|np-&gt;rv_ccntl0
op_or_assign
(paren
id|ENPMJ
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Prepare initial value of other IO registers&n;&t;*/
macro_line|#if defined SCSI_NCR_TRUST_BIOS_SETTING
id|np-&gt;rv_scntl0
op_assign
id|np-&gt;sv_scntl0
suffix:semicolon
id|np-&gt;rv_dmode
op_assign
id|np-&gt;sv_dmode
suffix:semicolon
id|np-&gt;rv_dcntl
op_assign
id|np-&gt;sv_dcntl
suffix:semicolon
id|np-&gt;rv_ctest3
op_assign
id|np-&gt;sv_ctest3
suffix:semicolon
id|np-&gt;rv_ctest4
op_assign
id|np-&gt;sv_ctest4
suffix:semicolon
id|np-&gt;rv_ctest5
op_assign
id|np-&gt;sv_ctest5
suffix:semicolon
id|burst_max
op_assign
id|burst_code
c_func
(paren
id|np-&gt;sv_dmode
comma
id|np-&gt;sv_ctest4
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;&t;**&t;Select burst length (dwords)&n;&t;*/
id|burst_max
op_assign
id|driver_setup.burst_max
suffix:semicolon
r_if
c_cond
(paren
id|burst_max
op_eq
l_int|255
)paren
id|burst_max
op_assign
id|burst_code
c_func
(paren
id|np-&gt;sv_dmode
comma
id|np-&gt;sv_ctest4
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|burst_max
OG
l_int|7
)paren
id|burst_max
op_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|burst_max
OG
id|np-&gt;maxburst
)paren
id|burst_max
op_assign
id|np-&gt;maxburst
suffix:semicolon
multiline_comment|/*&n;&t;**&t;DEL 352 - 53C810 Rev x11 - Part Number 609-0392140 - ITEM 2.&n;&t;**&t;This chip and the 860 Rev 1 may wrongly use PCI cache line &n;&t;**&t;based transactions on LOAD/STORE instructions. So we have &n;&t;**&t;to prevent these chips from using such PCI transactions in &n;&t;**&t;this driver. The generic sym53c8xx driver that does not use &n;&t;**&t;LOAD/STORE instructions does not need this work-around.&n;&t;*/
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_NCR_53C810
op_logical_and
id|np-&gt;revision_id
op_ge
l_int|0x10
op_logical_and
id|np-&gt;revision_id
op_le
l_int|0x11
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_NCR_53C860
op_logical_and
id|np-&gt;revision_id
op_le
l_int|0x1
)paren
)paren
id|np-&gt;features
op_and_assign
op_complement
(paren
id|FE_WRIE
op_or
id|FE_ERL
op_or
id|FE_ERMP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;DEL ? - 53C1010 Rev 1 - Part Number 609-0393638&n;&t;**&t;64-bit Slave Cycles must be disabled.&n;&t;*/
r_if
c_cond
(paren
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_and
(paren
id|np-&gt;revision_id
OL
l_int|0x02
)paren
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
id|np-&gt;rv_ccntl1
op_or_assign
l_int|0x10
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Select all supported special features.&n;&t;**&t;If we are using on-board RAM for scripts, prefetch (PFEN) &n;&t;**&t;does not help, but burst op fetch (BOF) does.&n;&t;**&t;Disabling PFEN makes sure BOF will be used.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ERL
)paren
id|np-&gt;rv_dmode
op_or_assign
id|ERL
suffix:semicolon
multiline_comment|/* Enable Read Line */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_BOF
)paren
id|np-&gt;rv_dmode
op_or_assign
id|BOF
suffix:semicolon
multiline_comment|/* Burst Opcode Fetch */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ERMP
)paren
id|np-&gt;rv_dmode
op_or_assign
id|ERMP
suffix:semicolon
multiline_comment|/* Enable Read Multiple */
macro_line|#ifdef SCSI_NCR_OPTIMIZE_896
r_if
c_cond
(paren
(paren
id|np-&gt;features
op_amp
id|FE_PFEN
)paren
op_logical_and
op_logical_neg
id|np-&gt;base2_ba
)paren
macro_line|#else
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_PFEN
)paren
macro_line|#endif
id|np-&gt;rv_dcntl
op_or_assign
id|PFEN
suffix:semicolon
multiline_comment|/* Prefetch Enable */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_CLSE
)paren
id|np-&gt;rv_dcntl
op_or_assign
id|CLSE
suffix:semicolon
multiline_comment|/* Cache Line Size Enable */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_WRIE
)paren
id|np-&gt;rv_ctest3
op_or_assign
id|WRIE
suffix:semicolon
multiline_comment|/* Write and Invalidate */
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_and
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
op_logical_and
(paren
id|np-&gt;features
op_amp
id|FE_DFS
)paren
)paren
id|np-&gt;rv_ctest5
op_or_assign
id|DFS
suffix:semicolon
multiline_comment|/* Dma Fifo Size */
multiline_comment|/* C1010/C1010_66 always large fifo */
multiline_comment|/*&n;&t;**&t;Select some other&n;&t;*/
r_if
c_cond
(paren
id|driver_setup.master_parity
)paren
id|np-&gt;rv_ctest4
op_or_assign
id|MPEE
suffix:semicolon
multiline_comment|/* Master parity checking */
r_if
c_cond
(paren
id|driver_setup.scsi_parity
)paren
id|np-&gt;rv_scntl0
op_or_assign
l_int|0x0a
suffix:semicolon
multiline_comment|/*  full arb., ena parity, par-&gt;ATN  */
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
multiline_comment|/*&n;&t;**&t;Get parity checking, host ID and verbose mode from NVRAM&n;&t;**/
r_if
c_cond
(paren
id|nvram
)paren
(brace
r_switch
c_cond
(paren
id|nvram-&gt;type
)paren
(brace
r_case
id|SCSI_NCR_TEKRAM_NVRAM
suffix:colon
id|np-&gt;myaddr
op_assign
id|nvram-&gt;data.Tekram.host_id
op_amp
l_int|0x0f
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|nvram-&gt;data.Symbios.flags
op_amp
id|SYMBIOS_PARITY_ENABLE
)paren
)paren
id|np-&gt;rv_scntl0
op_and_assign
op_complement
l_int|0x0a
suffix:semicolon
id|np-&gt;myaddr
op_assign
id|nvram-&gt;data.Symbios.host_id
op_amp
l_int|0x0f
suffix:semicolon
r_if
c_cond
(paren
id|nvram-&gt;data.Symbios.flags
op_amp
id|SYMBIOS_VERBOSE_MSGS
)paren
id|np-&gt;verbose
op_add_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**  Get SCSI addr of host adapter (set by bios?).&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;myaddr
op_eq
l_int|255
)paren
(brace
id|np-&gt;myaddr
op_assign
id|INB
c_func
(paren
id|nc_scid
)paren
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;myaddr
)paren
id|np-&gt;myaddr
op_assign
id|SCSI_NCR_MYADDR
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_TRUST_BIOS_SETTING */
multiline_comment|/*&n;&t; *&t;Prepare initial io register bits for burst length&n;&t; */
id|ncr_init_burst
c_func
(paren
id|np
comma
id|burst_max
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set SCSI BUS mode.&n;&t;**&n;&t;**&t;- ULTRA2 chips (895/895A/896) &n;&t;**&t;  and ULTRA 3 chips (1010) report the current &n;&t;**&t;  BUS mode through the STEST4 IO register.&n;&t;**&t;- For previous generation chips (825/825A/875), &n;&t;**&t;  user has to tell us how to check against HVD, &n;&t;**&t;  since a 100% safe algorithm is not possible.&n;&t;*/
id|np-&gt;scsi_mode
op_assign
id|SMODE_SE
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;features
op_amp
(paren
id|FE_ULTRA2
op_or
id|FE_ULTRA3
)paren
)paren
id|np-&gt;scsi_mode
op_assign
(paren
id|np-&gt;sv_stest4
op_amp
id|SMODE
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_DIFF
)paren
(brace
r_switch
c_cond
(paren
id|driver_setup.diff_support
)paren
(brace
r_case
l_int|4
suffix:colon
multiline_comment|/* Trust previous settings if present, then GPIO3 */
r_if
c_cond
(paren
id|np-&gt;sv_scntl3
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;sv_stest2
op_amp
l_int|0x20
)paren
id|np-&gt;scsi_mode
op_assign
id|SMODE_HVD
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|3
suffix:colon
multiline_comment|/* SYMBIOS controllers report HVD through GPIO3 */
r_if
c_cond
(paren
id|nvram
op_logical_and
id|nvram-&gt;type
op_ne
id|SCSI_NCR_SYMBIOS_NVRAM
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_gpreg
)paren
op_amp
l_int|0x08
)paren
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* Set HVD unconditionally */
id|np-&gt;scsi_mode
op_assign
id|SMODE_HVD
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* Trust previous settings for HVD */
r_if
c_cond
(paren
id|np-&gt;sv_stest2
op_amp
l_int|0x20
)paren
id|np-&gt;scsi_mode
op_assign
id|SMODE_HVD
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Don&squot;t care about HVD */
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|np-&gt;scsi_mode
op_eq
id|SMODE_HVD
)paren
id|np-&gt;rv_stest2
op_or_assign
l_int|0x20
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set LED support from SCRIPTS.&n;&t;**&t;Ignore this feature for boards known to use a &n;&t;**&t;specific GPIO wiring and for the 895A or 896 &n;&t;**&t;that drive the LED directly.&n;&t;**&t;Also probe initial setting of GPIO0 as output.&n;&t;*/
r_if
c_cond
(paren
(paren
id|driver_setup.led_pin
op_logical_or
(paren
id|nvram
op_logical_and
id|nvram-&gt;type
op_eq
id|SCSI_NCR_SYMBIOS_NVRAM
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_LEDC
)paren
op_logical_and
op_logical_neg
(paren
id|np-&gt;sv_gpcntl
op_amp
l_int|0x01
)paren
)paren
id|np-&gt;features
op_or_assign
id|FE_LED0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set irq mode.&n;&t;*/
r_switch
c_cond
(paren
id|driver_setup.irqm
op_amp
l_int|3
)paren
(brace
r_case
l_int|2
suffix:colon
id|np-&gt;rv_dcntl
op_or_assign
id|IRQM
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|np-&gt;rv_dcntl
op_or_assign
(paren
id|np-&gt;sv_dcntl
op_amp
id|IRQM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Configure targets according to driver setup.&n;&t;**&t;If NVRAM present get targets setup from NVRAM.&n;&t;**&t;Allow to override sync, wide and NOSCAN from &n;&t;**&t;boot command line.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|tp-&gt;usrsync
op_assign
l_int|255
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_if
c_cond
(paren
id|nvram
)paren
(brace
r_switch
c_cond
(paren
id|nvram-&gt;type
)paren
(brace
r_case
id|SCSI_NCR_TEKRAM_NVRAM
suffix:colon
id|ncr_Tekram_setup_target
c_func
(paren
id|np
comma
id|i
comma
op_amp
id|nvram-&gt;data.Tekram
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:colon
id|ncr_Symbios_setup_target
c_func
(paren
id|np
comma
id|i
comma
op_amp
id|nvram-&gt;data.Symbios
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x2
)paren
id|tp-&gt;usrsync
op_assign
id|driver_setup.default_sync
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x4
)paren
id|tp-&gt;usrwide
op_assign
id|driver_setup.max_wide
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x8
)paren
id|tp-&gt;usrflag
op_and_assign
op_complement
id|UF_NOSCAN
suffix:semicolon
)brace
r_else
(brace
macro_line|#else
r_if
c_cond
(paren
l_int|1
)paren
(brace
macro_line|#endif
id|tp-&gt;usrsync
op_assign
id|driver_setup.default_sync
suffix:semicolon
id|tp-&gt;usrwide
op_assign
id|driver_setup.max_wide
suffix:semicolon
id|tp-&gt;usrtags
op_assign
id|MAX_TAGS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver_setup.disconnection
)paren
id|np-&gt;target
(braket
id|i
)braket
dot
id|usrflag
op_assign
id|UF_NODISC
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;Announce all that stuff to user.&n;&t;*/
id|i
op_assign
id|nvram
ques
c_cond
id|nvram-&gt;type
suffix:colon
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %sID %d, Fast-%d%s%s&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|i
op_eq
id|SCSI_NCR_SYMBIOS_NVRAM
ques
c_cond
l_string|&quot;Symbios format NVRAM, &quot;
suffix:colon
(paren
id|i
op_eq
id|SCSI_NCR_TEKRAM_NVRAM
ques
c_cond
l_string|&quot;Tekram format NVRAM, &quot;
suffix:colon
l_string|&quot;&quot;
)paren
comma
id|np-&gt;myaddr
comma
id|np-&gt;minsync
OL
l_int|10
ques
c_cond
l_int|80
suffix:colon
(paren
id|np-&gt;minsync
OL
l_int|12
ques
c_cond
l_int|40
suffix:colon
(paren
id|np-&gt;minsync
OL
l_int|25
ques
c_cond
l_int|20
suffix:colon
l_int|10
)paren
)paren
comma
(paren
id|np-&gt;rv_scntl0
op_amp
l_int|0xa
)paren
ques
c_cond
l_string|&quot;, Parity Checking&quot;
suffix:colon
l_string|&quot;, NO Parity&quot;
comma
(paren
id|np-&gt;rv_stest2
op_amp
l_int|0x20
)paren
ques
c_cond
l_string|&quot;, Differential&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: initial SCNTL3/DMODE/DCNTL/CTEST3/4/5 = &quot;
l_string|&quot;(hex) %02x/%02x/%02x/%02x/%02x/%02x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;sv_scntl3
comma
id|np-&gt;sv_dmode
comma
id|np-&gt;sv_dcntl
comma
id|np-&gt;sv_ctest3
comma
id|np-&gt;sv_ctest4
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: final   SCNTL3/DMODE/DCNTL/CTEST3/4/5 = &quot;
l_string|&quot;(hex) %02x/%02x/%02x/%02x/%02x/%02x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;rv_scntl3
comma
id|np-&gt;rv_dmode
comma
id|np-&gt;rv_dcntl
comma
id|np-&gt;rv_ctest3
comma
id|np-&gt;rv_ctest4
comma
id|np-&gt;rv_ctest5
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bootverbose
op_logical_and
id|np-&gt;base2_ba
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: on-chip RAM at 0x%lx&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;base2_ba
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
DECL|function|ncr_display_Symbios_nvram
r_void
id|__init
id|ncr_display_Symbios_nvram
c_func
(paren
id|ncb_p
id|np
comma
id|Symbios_nvram
op_star
id|nvram
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* display Symbios nvram host data */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: HOST ID=%d%s%s%s%s%s&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|nvram-&gt;host_id
op_amp
l_int|0x0f
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_SCAM_ENABLE
)paren
ques
c_cond
l_string|&quot; SCAM&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_PARITY_ENABLE
)paren
ques
c_cond
l_string|&quot; PARITY&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_VERBOSE_MSGS
)paren
ques
c_cond
l_string|&quot; VERBOSE&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_CHS_MAPPING
)paren
ques
c_cond
l_string|&quot; CHS_ALT&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags1
op_amp
id|SYMBIOS_SCAN_HI_LO
)paren
ques
c_cond
l_string|&quot; HI_LO&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
multiline_comment|/* display Symbios nvram drive data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|Symbios_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s-%d:%s%s%s%s WIDTH=%d SYNC=%d TMO=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|i
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_DISCONNECT_ENABLE
)paren
ques
c_cond
l_string|&quot; DISC&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_SCAN_AT_BOOT_TIME
)paren
ques
c_cond
l_string|&quot; SCAN_BOOT&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_SCAN_LUNS
)paren
ques
c_cond
l_string|&quot; SCAN_LUNS&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_QUEUE_TAGS_ENABLED
)paren
ques
c_cond
l_string|&quot; TCQ&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|tn-&gt;bus_width
comma
id|tn-&gt;sync_period
op_div
l_int|4
comma
id|tn-&gt;timeout
)paren
suffix:semicolon
)brace
)brace
DECL|variable|__initdata
r_static
id|u_char
id|Tekram_boot_delay
(braket
l_int|7
)braket
id|__initdata
op_assign
(brace
l_int|3
comma
l_int|5
comma
l_int|10
comma
l_int|20
comma
l_int|30
comma
l_int|60
comma
l_int|120
)brace
suffix:semicolon
DECL|function|ncr_display_Tekram_nvram
r_void
id|__init
id|ncr_display_Tekram_nvram
c_func
(paren
id|ncb_p
id|np
comma
id|Tekram_nvram
op_star
id|nvram
)paren
(brace
r_int
id|i
comma
id|tags
comma
id|boot_delay
suffix:semicolon
r_char
op_star
id|rem
suffix:semicolon
multiline_comment|/* display Tekram nvram host data */
id|tags
op_assign
l_int|2
op_lshift
id|nvram-&gt;max_tags_index
suffix:semicolon
id|boot_delay
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nvram-&gt;boot_delay_index
OL
l_int|6
)paren
id|boot_delay
op_assign
id|Tekram_boot_delay
(braket
id|nvram-&gt;boot_delay_index
)braket
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_REMOVABLE_FLAGS
)paren
op_rshift
l_int|6
)paren
(brace
r_default
suffix:colon
r_case
l_int|0
suffix:colon
id|rem
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|rem
op_assign
l_string|&quot; REMOVABLE=boot device&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|rem
op_assign
l_string|&quot; REMOVABLE=all&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: HOST ID=%d%s%s%s%s%s%s%s%s%s BOOT DELAY=%d tags=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|nvram-&gt;host_id
op_amp
l_int|0x0f
comma
(paren
id|nvram-&gt;flags1
op_amp
id|SYMBIOS_SCAM_ENABLE
)paren
ques
c_cond
l_string|&quot; SCAM&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_MORE_THAN_2_DRIVES
)paren
ques
c_cond
l_string|&quot; &gt;2DRIVES&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_DRIVES_SUP_1GB
)paren
ques
c_cond
l_string|&quot; &gt;1GB&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_RESET_ON_POWER_ON
)paren
ques
c_cond
l_string|&quot; RESET&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_ACTIVE_NEGATION
)paren
ques
c_cond
l_string|&quot; ACT_NEG&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_IMMEDIATE_SEEK
)paren
ques
c_cond
l_string|&quot; IMM_SEEK&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_SCAN_LUNS
)paren
ques
c_cond
l_string|&quot; SCAN_LUNS&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags1
op_amp
id|TEKRAM_F2_F6_ENABLED
)paren
ques
c_cond
l_string|&quot; F2_F6&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|rem
comma
id|boot_delay
comma
id|tags
)paren
suffix:semicolon
multiline_comment|/* display Tekram nvram drive data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|sync
comma
id|j
suffix:semicolon
r_struct
id|Tekram_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|j
op_assign
id|tn-&gt;sync_index
op_amp
l_int|0xf
suffix:semicolon
id|sync
op_assign
id|Tekram_sync
(braket
id|j
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s-%d:%s%s%s%s%s%s PERIOD=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|i
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_PARITY_CHECK
)paren
ques
c_cond
l_string|&quot; PARITY&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_SYNC_NEGO
)paren
ques
c_cond
l_string|&quot; SYNC&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_DISCONNECT_ENABLE
)paren
ques
c_cond
l_string|&quot; DISC&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_START_CMD
)paren
ques
c_cond
l_string|&quot; START&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_TAGGED_COMMANDS
)paren
ques
c_cond
l_string|&quot; TCQ&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_WIDE_NEGO
)paren
ques
c_cond
l_string|&quot; WIDE&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|sync
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* SCSI_NCR_DEBUG_NVRAM */
multiline_comment|/*&n;**&t;Host attach and initialisations.&n;**&n;**&t;Allocate host data and ncb structure.&n;**&t;Request IO region and remap MMIO region.&n;**&t;Do chip initialization.&n;**&t;If all is OK, install interrupt handling and&n;**&t;start the timer daemon.&n;*/
r_static
r_int
id|__init
DECL|function|ncr_attach
id|ncr_attach
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|unit
comma
id|ncr_device
op_star
id|device
)paren
(brace
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
id|ncb_p
id|np
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
op_assign
l_int|0
suffix:semicolon
id|u_long
id|flags
op_assign
l_int|0
suffix:semicolon
id|ncr_nvram
op_star
id|nvram
op_assign
id|device-&gt;nvram
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|NAME53C
l_string|&quot;%s-%d: rev 0x%x on pci bus %d device %d function %d &quot;
macro_line|#ifdef __sparc__
l_string|&quot;irq %s&bslash;n&quot;
comma
macro_line|#else
l_string|&quot;irq %d&bslash;n&quot;
comma
macro_line|#endif
id|device-&gt;chip.name
comma
id|unit
comma
id|device-&gt;chip.revision_id
comma
id|device-&gt;slot.bus
comma
(paren
id|device-&gt;slot.device_fn
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
comma
id|device-&gt;slot.device_fn
op_amp
l_int|7
comma
macro_line|#ifdef __sparc__
id|__irq_itoa
c_func
(paren
id|device-&gt;slot.irq
)paren
)paren
suffix:semicolon
macro_line|#else
id|device-&gt;slot.irq
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Allocate host_data structure&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|instance
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
r_sizeof
(paren
op_star
id|host_data
)paren
)paren
)paren
)paren
r_goto
id|attach_error
suffix:semicolon
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate the host control block.&n;&t;*/
id|np
op_assign
id|__m_calloc_dma
c_func
(paren
id|device-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|ncb
)paren
comma
l_string|&quot;NCB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np
)paren
r_goto
id|attach_error
suffix:semicolon
id|NCR_INIT_LOCK_NCB
c_func
(paren
id|np
)paren
suffix:semicolon
id|np-&gt;pdev
op_assign
id|device-&gt;pdev
suffix:semicolon
id|np-&gt;p_ncb
op_assign
id|vtobus
c_func
(paren
id|np
)paren
suffix:semicolon
id|host_data-&gt;ncb
op_assign
id|np
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Store input informations in the host data structure.&n;&t;*/
id|strncpy
c_func
(paren
id|np-&gt;chip_name
comma
id|device-&gt;chip.name
comma
r_sizeof
(paren
id|np-&gt;chip_name
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|np-&gt;unit
op_assign
id|unit
suffix:semicolon
id|np-&gt;verbose
op_assign
id|driver_setup.verbose
suffix:semicolon
id|sprintf
c_func
(paren
id|np-&gt;inst_name
comma
id|NAME53C
l_string|&quot;%s-%d&quot;
comma
id|np-&gt;chip_name
comma
id|np-&gt;unit
)paren
suffix:semicolon
id|np-&gt;device_id
op_assign
id|device-&gt;chip.device_id
suffix:semicolon
id|np-&gt;revision_id
op_assign
id|device-&gt;chip.revision_id
suffix:semicolon
id|np-&gt;bus
op_assign
id|device-&gt;slot.bus
suffix:semicolon
id|np-&gt;device_fn
op_assign
id|device-&gt;slot.device_fn
suffix:semicolon
id|np-&gt;features
op_assign
id|device-&gt;chip.features
suffix:semicolon
id|np-&gt;clock_divn
op_assign
id|device-&gt;chip.nr_divisor
suffix:semicolon
id|np-&gt;maxoffs
op_assign
id|device-&gt;chip.offset_max
suffix:semicolon
id|np-&gt;maxburst
op_assign
id|device-&gt;chip.burst_max
suffix:semicolon
id|np-&gt;myaddr
op_assign
id|device-&gt;host_id
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate the start queue.&n;&t;*/
id|np-&gt;squeue
op_assign
(paren
id|ncrcmd
op_star
)paren
id|m_calloc_dma
c_func
(paren
r_sizeof
(paren
id|ncrcmd
)paren
op_star
(paren
id|MAX_START
op_star
l_int|2
)paren
comma
l_string|&quot;SQUEUE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;squeue
)paren
r_goto
id|attach_error
suffix:semicolon
id|np-&gt;p_squeue
op_assign
id|vtobus
c_func
(paren
id|np-&gt;squeue
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate the done queue.&n;&t;*/
id|np-&gt;dqueue
op_assign
(paren
id|ncrcmd
op_star
)paren
id|m_calloc_dma
c_func
(paren
r_sizeof
(paren
id|ncrcmd
)paren
op_star
(paren
id|MAX_START
op_star
l_int|2
)paren
comma
l_string|&quot;DQUEUE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;dqueue
)paren
r_goto
id|attach_error
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate the target bus address array.&n;&t;*/
id|np-&gt;targtbl
op_assign
(paren
id|u_int32
op_star
)paren
id|m_calloc_dma
c_func
(paren
l_int|256
comma
l_string|&quot;TARGTBL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;targtbl
)paren
r_goto
id|attach_error
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate SCRIPTS areas&n;&t;*/
id|np-&gt;script0
op_assign
(paren
r_struct
id|script
op_star
)paren
id|m_calloc_dma
c_func
(paren
r_sizeof
(paren
r_struct
id|script
)paren
comma
l_string|&quot;SCRIPT&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;script0
)paren
r_goto
id|attach_error
suffix:semicolon
id|np-&gt;scripth0
op_assign
(paren
r_struct
id|scripth
op_star
)paren
id|m_calloc_dma
c_func
(paren
r_sizeof
(paren
r_struct
id|scripth
)paren
comma
l_string|&quot;SCRIPTH&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;scripth0
)paren
r_goto
id|attach_error
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialyze the CCB free queue and,&n;&t;**&t;allocate some CCB. We need at least ONE.&n;&t;*/
id|xpt_que_init
c_func
(paren
op_amp
id|np-&gt;free_ccbq
)paren
suffix:semicolon
id|xpt_que_init
c_func
(paren
op_amp
id|np-&gt;b0_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ncr_alloc_ccb
c_func
(paren
id|np
)paren
)paren
r_goto
id|attach_error
suffix:semicolon
multiline_comment|/*&n;&t;**    Initialize timer structure&n;        **&n;        */
id|init_timer
c_func
(paren
op_amp
id|np-&gt;timer
)paren
suffix:semicolon
id|np-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|np
suffix:semicolon
id|np-&gt;timer.function
op_assign
id|sym53c8xx_timeout
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Try to map the controller chip to&n;&t;**&t;virtual and physical memory.&n;&t;*/
id|np-&gt;base_ba
op_assign
id|device-&gt;slot.base
suffix:semicolon
id|np-&gt;base_ws
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_IO256
)paren
ques
c_cond
l_int|256
suffix:colon
l_int|128
suffix:semicolon
id|np-&gt;base2_ba
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_RAM
)paren
ques
c_cond
id|device-&gt;slot.base_2
suffix:colon
l_int|0
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
id|np-&gt;base_va
op_assign
id|remap_pci_mem
c_func
(paren
id|np-&gt;base_ba
comma
id|np-&gt;base_ws
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;base_va
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: can&squot;t map PCI MMIO region&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: using memory mapped IO&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Make the controller&squot;s registers available.&n;&t;**&t;Now the INB INW INL OUTB OUTW OUTL macros&n;&t;**&t;can be used safely.&n;&t;*/
id|np-&gt;reg
op_assign
(paren
r_struct
id|ncr_reg
op_star
)paren
id|np-&gt;base_va
suffix:semicolon
macro_line|#endif /* !defined NCR_IOMAPPED */
multiline_comment|/*&n;&t;**&t;If on-chip RAM is used, make sure SCRIPTS isn&squot;t too large.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;base2_ba
op_logical_and
r_sizeof
(paren
r_struct
id|script
)paren
OG
l_int|4096
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: script too large.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Try to map the controller chip into iospace.&n;&t;*/
r_if
c_cond
(paren
id|device-&gt;slot.io_port
)paren
(brace
id|request_region
c_func
(paren
id|device-&gt;slot.io_port
comma
id|np-&gt;base_ws
comma
id|NAME53C8XX
)paren
suffix:semicolon
id|np-&gt;base_io
op_assign
id|device-&gt;slot.io_port
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_if
c_cond
(paren
id|nvram
)paren
(brace
r_switch
c_cond
(paren
id|nvram-&gt;type
)paren
(brace
r_case
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:colon
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
id|ncr_display_Symbios_nvram
c_func
(paren
id|np
comma
op_amp
id|nvram-&gt;data.Symbios
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|SCSI_NCR_TEKRAM_NVRAM
suffix:colon
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
id|ncr_display_Tekram_nvram
c_func
(paren
id|np
comma
op_amp
id|nvram-&gt;data.Tekram
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
id|nvram
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: NVRAM: None or invalid data.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Save setting of some IO registers, so we will &n;&t;**&t;be able to probe specific implementations.&n;&t;*/
id|ncr_save_initial_setting
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Reset the chip now, since it has been reported &n;&t;**&t;that SCSI clock calibration may not work properly &n;&t;**&t;if the chip is currently active.&n;&t;*/
id|ncr_chip_reset
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Do chip dependent initialization.&n;&t;*/
(paren
r_void
)paren
id|ncr_prepare_setting
c_func
(paren
id|np
comma
id|nvram
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Check the PCI clock frequency if needed.&n;&t;**&t;&n;&t;**&t;Must be done after ncr_prepare_setting since it destroys &n;&t;**&t;STEST1 that is used to probe for the clock multiplier.&n;&t;**&n;&t;**&t;The range is currently [22688 - 45375 Khz], given &n;&t;**&t;the values used by ncr_getclock().&n;&t;**&t;This calibration of the frequecy measurement &n;&t;**&t;algorithm against the PCI clock frequency is only &n;&t;**&t;performed if the driver has had to measure the SCSI &n;&t;**&t;clock due to other heuristics not having been enough &n;&t;**&t;to deduce the SCSI clock frequency.&n;&t;**&n;&t;**&t;When the chip has been initialized correctly by the &n;&t;**&t;SCSI BIOS, the driver deduces the presence of the &n;&t;**&t;clock multiplier and the value of the SCSI clock from &n;&t;**&t;initial values of IO registers, and therefore no &n;&t;**&t;clock measurement is performed.&n;&t;**&t;Normally the driver should never have to measure any &n;&t;**&t;clock, unless the controller may use a 80 MHz clock &n;&t;**&t;or has a clock multiplier and any of the following &n;&t;**&t;condition is met:&n;&t;**&n;&t;**&t;- No SCSI BIOS is present.&n;&t;**&t;- SCSI BIOS did&squot;nt enable the multiplier for some reason.&n;&t;**&t;- User has disabled the controller from the SCSI BIOS.&n;&t;**&t;- User booted the O/S from another O/S that did&squot;nt enable &n;&t;**&t;  the multiplier for some reason.&n;&t;**&n;&t;**&t;As a result, the driver may only have to measure some &n;&t;**&t;frequency in very unusual situations.&n;&t;**&n;&t;**&t;For this reality test against the PCI clock to really &n;&t;**&t;protect against flaws in the udelay() calibration or &n;&t;**&t;driver problem that affect the clock measurement &n;&t;**&t;algorithm, the actual PCI clock frequency must be 33 MHz.&n;&t;*/
id|i
op_assign
id|np-&gt;pciclock_max
ques
c_cond
id|ncr_getpciclock
c_func
(paren
id|np
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
(paren
id|i
template_param
id|np-&gt;pciclock_max
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: PCI clock (%u KHz) is out of range &quot;
l_string|&quot;[%u KHz - %u KHz].&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|i
comma
id|np-&gt;pciclock_min
comma
id|np-&gt;pciclock_max
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Patch script to physical addresses&n;&t;*/
id|ncr_script_fill
(paren
op_amp
id|script0
comma
op_amp
id|scripth0
)paren
suffix:semicolon
id|np-&gt;p_script
op_assign
id|vtobus
c_func
(paren
id|np-&gt;script0
)paren
suffix:semicolon
id|np-&gt;p_scripth
op_assign
id|vtobus
c_func
(paren
id|np-&gt;scripth0
)paren
suffix:semicolon
id|np-&gt;p_scripth0
op_assign
id|np-&gt;p_scripth
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;base2_ba
)paren
(brace
id|np-&gt;p_script
op_assign
id|pcivtobus
c_func
(paren
id|np-&gt;base2_ba
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_RAM8K
)paren
(brace
id|np-&gt;base2_ws
op_assign
l_int|8192
suffix:semicolon
id|np-&gt;p_scripth
op_assign
id|np-&gt;p_script
op_plus
l_int|4096
suffix:semicolon
macro_line|#if BITS_PER_LONG &gt; 32
id|np-&gt;scr_ram_seg
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;base2_ba
op_rshift
l_int|32
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
id|np-&gt;base2_ws
op_assign
l_int|4096
suffix:semicolon
macro_line|#ifndef SCSI_NCR_PCI_MEM_NOT_SUPPORTED
id|np-&gt;base2_va
op_assign
id|remap_pci_mem
c_func
(paren
id|np-&gt;base2_ba
comma
id|np-&gt;base2_ws
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;base2_va
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: can&squot;t map PCI MEMORY region&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
macro_line|#endif
)brace
id|ncr_script_copy_and_bind
(paren
id|np
comma
(paren
id|ncrcmd
op_star
)paren
op_amp
id|script0
comma
(paren
id|ncrcmd
op_star
)paren
id|np-&gt;script0
comma
r_sizeof
(paren
r_struct
id|script
)paren
)paren
suffix:semicolon
id|ncr_script_copy_and_bind
(paren
id|np
comma
(paren
id|ncrcmd
op_star
)paren
op_amp
id|scripth0
comma
(paren
id|ncrcmd
op_star
)paren
id|np-&gt;scripth0
comma
r_sizeof
(paren
r_struct
id|scripth
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Patch some variables in SCRIPTS&n;&t;*/
id|np-&gt;scripth0-&gt;pm0_data_addr
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
c_func
(paren
id|np
comma
id|pm0_data
)paren
)paren
suffix:semicolon
id|np-&gt;scripth0-&gt;pm1_data_addr
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
c_func
(paren
id|np
comma
id|pm1_data
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Patch if not Ultra 3 - Do not write to scntl4&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA3
)paren
(brace
id|np-&gt;script0-&gt;resel_scntl4
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_LOAD_REL
(paren
id|scntl4
comma
l_int|1
)paren
)paren
suffix:semicolon
id|np-&gt;script0-&gt;resel_scntl4
(braket
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
m_offsetof
(paren
r_struct
id|tcb
comma
id|uval
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_PCI_MEM_NOT_SUPPORTED
id|np-&gt;scripth0-&gt;script0_ba
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|np-&gt;script0
)paren
)paren
suffix:semicolon
id|np-&gt;scripth0-&gt;script0_ba64
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|np-&gt;script0
)paren
)paren
suffix:semicolon
id|np-&gt;scripth0-&gt;scripth0_ba64
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|np-&gt;scripth0
)paren
)paren
suffix:semicolon
id|np-&gt;scripth0-&gt;ram_seg64
(braket
l_int|0
)braket
op_assign
id|np-&gt;scr_ram_seg
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Prepare the idle and invalid task actions.&n;&t;*/
id|np-&gt;idletask.start
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
id|np-&gt;idletask.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|bad_i_t_l
)paren
)paren
suffix:semicolon
id|np-&gt;p_idletask
op_assign
id|NCB_PHYS
c_func
(paren
id|np
comma
id|idletask
)paren
suffix:semicolon
id|np-&gt;notask.start
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
id|np-&gt;notask.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|bad_i_t_l
)paren
)paren
suffix:semicolon
id|np-&gt;p_notask
op_assign
id|NCB_PHYS
c_func
(paren
id|np
comma
id|notask
)paren
suffix:semicolon
id|np-&gt;bad_i_t_l.start
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
id|np-&gt;bad_i_t_l.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|bad_i_t_l
)paren
)paren
suffix:semicolon
id|np-&gt;p_bad_i_t_l
op_assign
id|NCB_PHYS
c_func
(paren
id|np
comma
id|bad_i_t_l
)paren
suffix:semicolon
id|np-&gt;bad_i_t_l_q.start
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
id|np-&gt;bad_i_t_l_q.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|bad_i_t_l_q
)paren
)paren
suffix:semicolon
id|np-&gt;p_bad_i_t_l_q
op_assign
id|NCB_PHYS
c_func
(paren
id|np
comma
id|bad_i_t_l_q
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate and prepare the bad lun table.&n;&t;*/
id|np-&gt;badluntbl
op_assign
id|m_calloc_dma
c_func
(paren
l_int|256
comma
l_string|&quot;BADLUNTBL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;badluntbl
)paren
r_goto
id|attach_error
suffix:semicolon
m_assert
(paren
m_offsetof
(paren
r_struct
id|lcb
comma
id|resel_task
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|np-&gt;resel_badlun
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
c_func
(paren
id|np
comma
id|resel_bad_lun
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
id|np-&gt;badluntbl
(braket
id|i
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_PHYS
c_func
(paren
id|np
comma
id|resel_badlun
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Prepare the target bus address array.&n;&t;*/
id|np-&gt;scripth0-&gt;targtbl
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|np-&gt;targtbl
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|np-&gt;targtbl
(braket
id|i
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_PHYS
c_func
(paren
id|np
comma
id|target
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|np-&gt;target
(braket
id|i
)braket
dot
id|b_luntbl
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|np-&gt;badluntbl
)paren
)paren
suffix:semicolon
id|np-&gt;target
(braket
id|i
)braket
dot
id|b_lun0
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_PHYS
c_func
(paren
id|np
comma
id|resel_badlun
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    Patch the script for LED support.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_LED0
)paren
(brace
id|np-&gt;script0-&gt;idle
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_REG_REG
c_func
(paren
id|gpreg
comma
id|SCR_OR
comma
l_int|0x01
)paren
)paren
suffix:semicolon
id|np-&gt;script0-&gt;reselected
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_REG_REG
c_func
(paren
id|gpreg
comma
id|SCR_AND
comma
l_int|0xfe
)paren
)paren
suffix:semicolon
id|np-&gt;script0-&gt;start
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_REG_REG
c_func
(paren
id|gpreg
comma
id|SCR_AND
comma
l_int|0xfe
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Patch the script to provide an extra clock cycle on&n;&t;**&t;data out phase - 53C1010_66MHz part only.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
(brace
id|np-&gt;script0-&gt;datao_phase
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_REG_REG
c_func
(paren
id|scntl4
comma
id|SCR_OR
comma
l_int|0x0c
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
multiline_comment|/*&n;&t;**    If user does not want to use IMMEDIATE ARBITRATION&n;&t;**    when we are reselected while attempting to arbitrate,&n;&t;**    patch the SCRIPTS accordingly with a SCRIPT NO_OP.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver_setup.iarb
op_amp
l_int|1
)paren
)paren
id|np-&gt;script0-&gt;ungetjob
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_NO_OP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**    If user wants IARB to be set when we win arbitration &n;&t;**    and have other jobs, compute the max number of consecutive &n;&t;**    settings of IARB hint before we leave devices a chance to &n;&t;**    arbitrate for reselection.&n;&t;*/
id|np-&gt;iarb_max
op_assign
(paren
id|driver_setup.iarb
op_rshift
l_int|4
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;DEL 472 - 53C896 Rev 1 - Part Number 609-0393055 - ITEM 5.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_NCR_53C896
op_logical_and
id|np-&gt;revision_id
op_le
l_int|0x1
op_logical_and
(paren
id|np-&gt;features
op_amp
id|FE_NOPM
)paren
)paren
(brace
id|np-&gt;scatter
op_assign
id|ncr_scatter_896R1
suffix:semicolon
macro_line|#ifndef SCSI_NCR_PROFILE_SUPPORT
DECL|macro|XXX
mdefine_line|#define XXX&t;0
macro_line|#else
mdefine_line|#define XXX&t;2
macro_line|#endif
id|np-&gt;script0-&gt;datai_phase
(braket
id|XXX
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_JUMP
)paren
suffix:semicolon
id|np-&gt;script0-&gt;datai_phase
(braket
id|XXX
op_plus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|tweak_pmj
)paren
)paren
suffix:semicolon
id|np-&gt;script0-&gt;datao_phase
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_JUMP
)paren
suffix:semicolon
id|np-&gt;script0-&gt;datao_phase
(braket
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|tweak_pmj
)paren
)paren
suffix:semicolon
DECL|macro|XXX
macro_line|#undef XXX
)brace
r_else
macro_line|#ifdef DEBUG_896R1
id|np-&gt;scatter
op_assign
id|ncr_scatter_896R1
suffix:semicolon
macro_line|#else
id|np-&gt;scatter
op_assign
id|ncr_scatter
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Reset chip.&n;&t;**&t;We should use ncr_soft_reset(), but we donnot want to do &n;&t;**&t;so, since we may not be safe if ABRT interrupt occurs due &n;&t;**&t;to the BIOS or previous O/S having enable this interrupt.&n;&t;**&n;&t;**&t;For C1010 need to set ABRT bit prior to SRST if SCRIPTs&n;&t;**&t;are running. Not true in this case.&n;&t;*/
id|ncr_chip_reset
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Now check the cache handling of the pci chipset.&n;&t;*/
r_if
c_cond
(paren
id|ncr_snooptest
(paren
id|np
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;CACHE INCORRECTLY CONFIGURED.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Install the interrupt handler.&n;&t;**&t;If we synchonize the C code with SCRIPTS on interrupt, &n;&t;**&t;we donnot want to share the INTR line at all.&n;&t;*/
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|device-&gt;slot.irq
comma
id|sym53c8xx_intr
comma
macro_line|#ifdef SCSI_NCR_PCIQ_SYNC_ON_INTR
(paren
(paren
id|driver_setup.irqm
op_amp
l_int|0x20
)paren
ques
c_cond
l_int|0
suffix:colon
id|SA_INTERRUPT
)paren
comma
macro_line|#else
(paren
(paren
id|driver_setup.irqm
op_amp
l_int|0x10
)paren
ques
c_cond
l_int|0
suffix:colon
id|SA_SHIRQ
)paren
op_or
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,2,0)
(paren
(paren
id|driver_setup.irqm
op_amp
l_int|0x20
)paren
ques
c_cond
l_int|0
suffix:colon
id|SA_INTERRUPT
)paren
comma
macro_line|#else
l_int|0
comma
macro_line|#endif
macro_line|#endif
id|NAME53C8XX
comma
id|np
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: request irq %d failure&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|device-&gt;slot.irq
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
id|np-&gt;irq
op_assign
id|device-&gt;slot.irq
suffix:semicolon
multiline_comment|/*&n;&t;**&t;After SCSI devices have been opened, we cannot&n;&t;**&t;reset the bus safely, so we do it here.&n;&t;**&t;Interrupt handler does the real work.&n;&t;**&t;Process the reset exception,&n;&t;**&t;if interrupts are not enabled yet.&n;&t;**&t;Then enable disconnects.&n;&t;*/
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ncr_reset_scsi_bus
c_func
(paren
id|np
comma
l_int|0
comma
id|driver_setup.settle_delay
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: FATAL ERROR: CHECK SCSI BUS - CABLES, TERMINATION, DEVICE POWER etc.!&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
id|ncr_exception
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The middle-level SCSI driver does not&n;&t;**&t;wait for devices to settle.&n;&t;**&t;Wait synchronously if more than 2 seconds.&n;&t;*/
r_if
c_cond
(paren
id|driver_setup.settle_delay
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: waiting %d seconds for scsi devices to settle...&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|driver_setup.settle_delay
)paren
suffix:semicolon
id|MDELAY
(paren
l_int|1000
op_star
id|driver_setup.settle_delay
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;start the timeout daemon&n;&t;*/
id|np-&gt;lasttime
op_assign
l_int|0
suffix:semicolon
id|ncr_timeout
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**  use SIMPLE TAG messages by default&n;&t;*/
macro_line|#ifdef SCSI_NCR_ALWAYS_SIMPLE_TAG
id|np-&gt;order
op_assign
id|M_SIMPLE_TAG
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**  Done.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|first_host
)paren
id|first_host
op_assign
id|instance
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Fill Linux host instance structure&n;&t;**&t;and return success.&n;&t;*/
id|instance-&gt;max_channel
op_assign
l_int|0
suffix:semicolon
id|instance-&gt;this_id
op_assign
id|np-&gt;myaddr
suffix:semicolon
id|instance-&gt;max_id
op_assign
id|np-&gt;maxwide
ques
c_cond
l_int|16
suffix:colon
l_int|8
suffix:semicolon
id|instance-&gt;max_lun
op_assign
id|MAX_LUN
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,3,29)
id|instance-&gt;base
op_assign
(paren
r_int
r_int
)paren
id|np-&gt;reg
suffix:semicolon
macro_line|#else
id|instance-&gt;base
op_assign
(paren
r_char
op_star
)paren
id|np-&gt;reg
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|instance-&gt;irq
op_assign
id|np-&gt;irq
suffix:semicolon
id|instance-&gt;unique_id
op_assign
id|np-&gt;base_io
suffix:semicolon
id|instance-&gt;io_port
op_assign
id|np-&gt;base_io
suffix:semicolon
id|instance-&gt;n_io_port
op_assign
id|np-&gt;base_ws
suffix:semicolon
id|instance-&gt;dma_channel
op_assign
l_int|0
suffix:semicolon
id|instance-&gt;cmd_per_lun
op_assign
id|MAX_TAGS
suffix:semicolon
id|instance-&gt;can_queue
op_assign
(paren
id|MAX_START
op_minus
l_int|4
)paren
suffix:semicolon
id|np-&gt;check_integrity
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_INTEGRITY_CHECKING
id|instance-&gt;check_integrity
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SCSI_NCR_ENABLE_INTEGRITY_CHECK
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver_setup.bus_check
op_amp
l_int|0x04
)paren
)paren
(brace
id|np-&gt;check_integrity
op_assign
l_int|1
suffix:semicolon
id|instance-&gt;check_integrity
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif
id|instance-&gt;select_queue_depths
op_assign
id|sym53c8xx_select_queue_depths
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Now let the generic SCSI driver&n;&t;**&t;look for the SCSI devices on the bus ..&n;&t;*/
r_return
l_int|0
suffix:semicolon
id|attach_error
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: giving up ...&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np
)paren
id|ncr_free_resources
c_func
(paren
id|np
)paren
suffix:semicolon
id|scsi_unregister
c_func
(paren
id|instance
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Free controller resources.&n;*/
DECL|function|ncr_free_resources
r_static
r_void
id|ncr_free_resources
c_func
(paren
id|ncb_p
id|np
)paren
(brace
id|ccb_p
id|cp
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
r_int
id|target
comma
id|lun
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;irq
)paren
id|free_irq
c_func
(paren
id|np-&gt;irq
comma
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;base_io
)paren
id|release_region
c_func
(paren
id|np-&gt;base_io
comma
id|np-&gt;base_ws
)paren
suffix:semicolon
macro_line|#ifndef SCSI_NCR_PCI_MEM_NOT_SUPPORTED
r_if
c_cond
(paren
id|np-&gt;base_va
)paren
id|unmap_pci_mem
c_func
(paren
id|np-&gt;base_va
comma
id|np-&gt;base_ws
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;base2_va
)paren
id|unmap_pci_mem
c_func
(paren
id|np-&gt;base2_va
comma
id|np-&gt;base2_ws
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|np-&gt;scripth0
)paren
id|m_free_dma
c_func
(paren
id|np-&gt;scripth0
comma
r_sizeof
(paren
r_struct
id|scripth
)paren
comma
l_string|&quot;SCRIPTH&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;script0
)paren
id|m_free_dma
c_func
(paren
id|np-&gt;script0
comma
r_sizeof
(paren
r_struct
id|script
)paren
comma
l_string|&quot;SCRIPT&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;squeue
)paren
id|m_free_dma
c_func
(paren
id|np-&gt;squeue
comma
r_sizeof
(paren
id|ncrcmd
)paren
op_star
(paren
id|MAX_START
op_star
l_int|2
)paren
comma
l_string|&quot;SQUEUE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;dqueue
)paren
id|m_free_dma
c_func
(paren
id|np-&gt;dqueue
comma
r_sizeof
(paren
id|ncrcmd
)paren
op_star
(paren
id|MAX_START
op_star
l_int|2
)paren
comma
l_string|&quot;DQUEUE&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cp
op_assign
id|np-&gt;ccbc
)paren
op_ne
l_int|NULL
)paren
(brace
id|np-&gt;ccbc
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
id|m_free_dma
c_func
(paren
id|cp
comma
r_sizeof
(paren
op_star
id|cp
)paren
comma
l_string|&quot;CCB&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|np-&gt;badluntbl
)paren
id|m_free_dma
c_func
(paren
id|np-&gt;badluntbl
comma
l_int|256
comma
l_string|&quot;BADLUNTBL&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
OL
id|MAX_TARGET
suffix:semicolon
id|target
op_increment
)paren
(brace
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
id|MAX_LUN
suffix:semicolon
id|lun
op_increment
)paren
(brace
id|lp
op_assign
id|ncr_lp
c_func
(paren
id|np
comma
id|tp
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tasktbl
op_ne
op_amp
id|lp-&gt;tasktbl_0
)paren
id|m_free_dma
c_func
(paren
id|lp-&gt;tasktbl
comma
id|MAX_TASKS
op_star
l_int|4
comma
l_string|&quot;TASKTBL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;cb_tags
)paren
id|m_free
c_func
(paren
id|lp-&gt;cb_tags
comma
id|MAX_TAGS
comma
l_string|&quot;CB_TAGS&quot;
)paren
suffix:semicolon
id|m_free_dma
c_func
(paren
id|lp
comma
r_sizeof
(paren
op_star
id|lp
)paren
comma
l_string|&quot;LCB&quot;
)paren
suffix:semicolon
)brace
macro_line|#if MAX_LUN &gt; 1
r_if
c_cond
(paren
id|tp-&gt;lmp
)paren
id|m_free
c_func
(paren
id|tp-&gt;lmp
comma
id|MAX_LUN
op_star
r_sizeof
(paren
id|lcb_p
)paren
comma
l_string|&quot;LMP&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;luntbl
)paren
id|m_free_dma
c_func
(paren
id|tp-&gt;luntbl
comma
l_int|256
comma
l_string|&quot;LUNTBL&quot;
)paren
suffix:semicolon
macro_line|#endif 
)brace
r_if
c_cond
(paren
id|np-&gt;targtbl
)paren
id|m_free_dma
c_func
(paren
id|np-&gt;targtbl
comma
l_int|256
comma
l_string|&quot;TARGTBL&quot;
)paren
suffix:semicolon
id|m_free_dma
c_func
(paren
id|np
comma
r_sizeof
(paren
op_star
id|np
)paren
comma
l_string|&quot;NCB&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Done SCSI commands list management.&n;**&n;**&t;We donnot enter the scsi_done() callback immediately &n;**&t;after a command has been seen as completed but we &n;**&t;insert it into a list which is flushed outside any kind &n;**&t;of driver critical section.&n;**&t;This allows to do minimal stuff under interrupt and &n;**&t;inside critical sections and to also avoid locking up &n;**&t;on recursive calls to driver entry points under SMP.&n;**&t;In fact, the only kernel point which is entered by the &n;**&t;driver with a driver lock set is get_free_pages(GFP_ATOMIC...) &n;**&t;that shall not reenter the driver under any circumstance.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_queue_done_cmd
r_static
r_inline
r_void
id|ncr_queue_done_cmd
c_func
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|unmap_scsi_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
(paren
r_char
op_star
)paren
id|np-&gt;done_list
suffix:semicolon
id|np-&gt;done_list
op_assign
id|cmd
suffix:semicolon
)brace
DECL|function|ncr_flush_done_cmds
r_static
r_inline
r_void
id|ncr_flush_done_cmds
c_func
(paren
id|Scsi_Cmnd
op_star
id|lcmd
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_while
c_loop
(paren
id|lcmd
)paren
(brace
id|cmd
op_assign
id|lcmd
suffix:semicolon
id|lcmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Prepare the next negotiation message for integrity check,&n;**&t;if needed.&n;**&n;**&t;Fill in the part of message buffer that contains the &n;**&t;negotiation and the nego_status field of the CCB.&n;**&t;Returns the size of the message in bytes.&n;**&n;**&t;If tp-&gt;ppr_negotiation is 1 and a M_REJECT occurs, then&n;**&t;we disable ppr_negotiation.  If the first ppr_negotiation is&n;**&t;successful, set this flag to 2.&n;**&n;**==========================================================&n;*/
macro_line|#ifdef&t;SCSI_NCR_INTEGRITY_CHECKING
DECL|function|ncr_ic_nego
r_static
r_int
id|ncr_ic_nego
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
id|u_char
op_star
id|msgptr
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
r_int
id|msglen
op_assign
l_int|0
suffix:semicolon
r_int
id|nego
op_assign
l_int|0
suffix:semicolon
id|u_char
id|new_width
comma
id|new_offset
comma
id|new_period
suffix:semicolon
id|u_char
id|no_increase
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ppr_negotiation
op_eq
l_int|1
)paren
multiline_comment|/* PPR message successful */
id|tp-&gt;ppr_negotiation
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;inq_done
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;ic_maximums_set
)paren
(brace
id|tp-&gt;ic_maximums_set
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * Check against target, host and user limits  &n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|tp-&gt;inq_byte7
op_amp
id|INQ7_WIDE16
)paren
op_logical_and
id|np-&gt;maxwide
op_logical_and
id|tp-&gt;usrwide
)paren
id|tp-&gt;ic_max_width
op_assign
l_int|1
suffix:semicolon
r_else
id|tp-&gt;ic_max_width
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;inq_byte7
op_amp
id|INQ7_SYNC
)paren
op_logical_and
id|tp-&gt;maxoffs
)paren
id|tp-&gt;ic_min_sync
op_assign
(paren
id|tp-&gt;minsync
OL
id|np-&gt;minsync
)paren
ques
c_cond
id|np-&gt;minsync
suffix:colon
id|tp-&gt;minsync
suffix:semicolon
r_else
id|tp-&gt;ic_min_sync
op_assign
l_int|255
suffix:semicolon
id|tp-&gt;period
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;widedone
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Enable PPR negotiation - only if Ultra3 support&n;&t;&t;&t; * is accessible.&n;&t;&t;&t; */
macro_line|#if 0
r_if
c_cond
(paren
id|tp-&gt;ic_max_width
op_logical_and
(paren
id|tp-&gt;ic_min_sync
op_ne
l_int|255
)paren
)paren
id|tp-&gt;ppr_negotiation
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|tp-&gt;ppr_negotiation
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA3
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;ic_max_width
op_logical_and
(paren
id|tp-&gt;ic_min_sync
op_eq
l_int|0x09
)paren
)paren
id|tp-&gt;ppr_negotiation
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;ppr_negotiation
)paren
id|cmd-&gt;ic_nego
op_and_assign
op_complement
id|NS_PPR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_IC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: cmd-&gt;ic_nego %d, 1st byte 0x%2X&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|cmd-&gt;ic_nego
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Previous command recorded a parity or an initiator&n;&t;&t; * detected error condition. Force bus to narrow for this&n;&t;&t; * target. Clear flag. Negotation on request sense.&n;&t;&t; * Note: kernel forces 2 bus resets :o( but clears itself out. &n;&t;&t; * Minor bug? in scsi_obsolete.c (ugly)&n;&t;&t; */
r_if
c_cond
(paren
id|np-&gt;check_integ_par
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Parity Error. Target set to narrow.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|tp-&gt;ic_max_width
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;widedone
op_assign
id|tp-&gt;period
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Initializing:&n;&t;&t; * If ic_nego == NS_PPR, we are in the initial test for&n;&t;&t; * PPR messaging support. If driver flag is clear, then&n;&t;&t; * either we don&squot;t support PPR nego (narrow or async device)&n;&t;&t; * or this is the second TUR and we have had a M. REJECT &n;&t;&t; * or unexpected disconnect on the first PPR negotiation.  &n;&t;&t; * Do not negotiate, reset nego flags (in case a reset has&n;&t;&t; * occurred), clear ic_nego and return.&n;&t;&t; * General case: Kernel will clear flag on a fallback. &n;&t;&t; * Do only SDTR or WDTR in the future.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;ppr_negotiation
op_logical_and
(paren
id|cmd-&gt;ic_nego
op_eq
id|NS_PPR
)paren
)paren
(brace
id|tp-&gt;ppr_negotiation
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;ic_nego
op_and_assign
op_complement
id|NS_PPR
suffix:semicolon
id|tp-&gt;widedone
op_assign
id|tp-&gt;period
op_assign
l_int|1
suffix:semicolon
r_return
id|msglen
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|tp-&gt;ppr_negotiation
op_logical_and
op_logical_neg
(paren
id|cmd-&gt;ic_nego
op_amp
id|NS_PPR
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|tp-&gt;ppr_negotiation
op_logical_and
(paren
id|cmd-&gt;ic_nego
op_amp
id|NS_PPR
)paren
)paren
)paren
(brace
id|tp-&gt;ppr_negotiation
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;ic_nego
op_and_assign
op_complement
id|NS_PPR
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Always check the PPR nego. flag bit if ppr_negotiation&n;&t;&t; * is set.  If the ic_nego PPR bit is clear,&n;&t;&t; * there must have been a fallback. Do only&n;&t;&t; * WDTR / SDTR in the future.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|tp-&gt;ppr_negotiation
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|cmd-&gt;ic_nego
op_amp
id|NS_PPR
)paren
)paren
)paren
id|tp-&gt;ppr_negotiation
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* In case of a bus reset, ncr_negotiate will reset &n;                 * the flags tp-&gt;widedone and tp-&gt;period to 0, forcing&n;&t;&t; * a new negotiation.  Do WDTR then SDTR. If PPR, do both.&n;&t;&t; * Do NOT increase the period.  It is possible for the Scsi_Cmnd&n;&t;&t; * flags to be set to increase the period when a bus reset &n;&t;&t; * occurs - we don&squot;t want to change anything.&n;&t;&t; */
id|no_increase
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ppr_negotiation
op_logical_and
(paren
op_logical_neg
id|tp-&gt;widedone
)paren
op_logical_and
(paren
op_logical_neg
id|tp-&gt;period
)paren
)paren
(brace
id|cmd-&gt;ic_nego
op_assign
id|NS_PPR
suffix:semicolon
id|tp-&gt;widedone
op_assign
id|tp-&gt;period
op_assign
l_int|1
suffix:semicolon
id|no_increase
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;widedone
)paren
(brace
id|cmd-&gt;ic_nego
op_assign
id|NS_WIDE
suffix:semicolon
id|tp-&gt;widedone
op_assign
l_int|1
suffix:semicolon
id|no_increase
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;period
)paren
(brace
id|cmd-&gt;ic_nego
op_assign
id|NS_SYNC
suffix:semicolon
id|tp-&gt;period
op_assign
l_int|1
suffix:semicolon
id|no_increase
op_assign
l_int|1
suffix:semicolon
)brace
id|new_width
op_assign
id|cmd-&gt;ic_nego_width
op_amp
id|tp-&gt;ic_max_width
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;ic_nego_sync
)paren
(brace
r_case
l_int|2
suffix:colon
multiline_comment|/* increase the period */
r_if
c_cond
(paren
op_logical_neg
id|no_increase
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;ic_min_sync
op_le
l_int|0x09
)paren
id|tp-&gt;ic_min_sync
op_assign
l_int|0x0A
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;ic_min_sync
op_le
l_int|0x0A
)paren
id|tp-&gt;ic_min_sync
op_assign
l_int|0x0C
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;ic_min_sync
op_le
l_int|0x0C
)paren
id|tp-&gt;ic_min_sync
op_assign
l_int|0x19
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;ic_min_sync
op_le
l_int|0x19
)paren
id|tp-&gt;ic_min_sync
op_mul_assign
l_int|2
suffix:semicolon
r_else
(brace
id|tp-&gt;ic_min_sync
op_assign
l_int|255
suffix:semicolon
id|cmd-&gt;ic_nego_sync
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;maxoffs
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|new_period
op_assign
id|tp-&gt;maxoffs
ques
c_cond
id|tp-&gt;ic_min_sync
suffix:colon
l_int|0
suffix:semicolon
id|new_offset
op_assign
id|tp-&gt;maxoffs
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* nego. to maximum */
id|new_period
op_assign
id|tp-&gt;maxoffs
ques
c_cond
id|tp-&gt;ic_min_sync
suffix:colon
l_int|0
suffix:semicolon
id|new_offset
op_assign
id|tp-&gt;maxoffs
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* nego to async */
r_default
suffix:colon
id|new_period
op_assign
l_int|0
suffix:semicolon
id|new_offset
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|nego
op_assign
id|NS_NOCHANGE
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ppr_negotiation
)paren
(brace
id|u_char
id|options_byte
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** Must make sure data is consistent.&n;&t;&t;&t;** If period is 9 and sync, must be wide and DT bit set.&n;&t;&t;&t;** else period must be larger. If the width is 0, &n;&t;&t;&t;** reset bus to wide but increase the period to 0x0A.&n;&t;&t;&t;** Note: The strange else clause is due to the integrity check.&n;&t;&t;&t;** If fails at 0x09, wide, the I.C. code will redo at the same&n;&t;&t;&t;** speed but a narrow bus. The driver must take care of slowing&n;&t;&t;&t;** the bus speed down.&n;&t;&t;&t;**&n;&t;&t;&t;** The maximum offset in ST mode is 31, in DT mode 62 (1010/1010_66 only)&n;&t;&t;&t;*/
r_if
c_cond
(paren
(paren
id|new_period
op_eq
l_int|0x09
)paren
op_logical_and
id|new_offset
)paren
(brace
r_if
c_cond
(paren
id|new_width
)paren
id|options_byte
op_assign
l_int|0x02
suffix:semicolon
r_else
(brace
id|tp-&gt;ic_min_sync
op_assign
l_int|0x0A
suffix:semicolon
id|new_period
op_assign
l_int|0x0A
suffix:semicolon
id|cmd-&gt;ic_nego_width
op_assign
l_int|1
suffix:semicolon
id|new_width
op_assign
l_int|1
suffix:semicolon
id|new_offset
op_and_assign
l_int|0x1f
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|new_period
OG
l_int|0x09
)paren
id|new_offset
op_and_assign
l_int|0x1f
suffix:semicolon
id|nego
op_assign
id|NS_PPR
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|6
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_PPR_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|new_period
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|new_offset
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|new_width
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|options_byte
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|cmd-&gt;ic_nego
op_amp
op_complement
id|NS_PPR
)paren
(brace
r_case
id|NS_WIDE
suffix:colon
multiline_comment|/*&n;&t;&t;&t;    **&t;WDTR negotiation on if device supports&n;&t;&t;&t;    **  wide or if wide device forced narrow&n;&t;&t;&t;    **&t;due to a parity error. &n;&t;&t;&t;    */
id|cmd-&gt;ic_nego_width
op_and_assign
id|tp-&gt;ic_max_width
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ic_max_width
op_or
id|np-&gt;check_integ_par
)paren
(brace
id|nego
op_assign
id|NS_WIDE
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|2
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_WIDE_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|new_width
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|NS_SYNC
suffix:colon
multiline_comment|/*&n;&t;&t;&t;    **&t;negotiate synchronous transfers&n;&t;&t;&t;    **&t;Target must support sync transfers.&n;&t;&t;&t;    **  Min. period = 0x0A, maximum offset of 31=0x1f.&n;&t;&t;    &t;    */
r_if
c_cond
(paren
id|tp-&gt;inq_byte7
op_amp
id|INQ7_SYNC
)paren
(brace
r_if
c_cond
(paren
id|new_offset
op_logical_and
(paren
id|new_period
OL
l_int|0x0A
)paren
)paren
(brace
id|tp-&gt;ic_min_sync
op_assign
l_int|0x0A
suffix:semicolon
id|new_period
op_assign
l_int|0x0A
suffix:semicolon
)brace
id|nego
op_assign
id|NS_SYNC
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|3
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_SYNC_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|new_period
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|new_offset
op_amp
l_int|0x1f
suffix:semicolon
)brace
r_else
id|cmd-&gt;ic_nego_sync
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_NOCHANGE
suffix:colon
r_break
suffix:semicolon
)brace
)brace
)brace
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|nego
suffix:semicolon
id|np-&gt;check_integ_par
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nego
)paren
(brace
id|tp-&gt;nego_cp
op_assign
id|cp
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|ncr_print_msg
c_func
(paren
id|cp
comma
id|nego
op_eq
id|NS_WIDE
ques
c_cond
l_string|&quot;wide/narrow msgout&quot;
suffix:colon
(paren
id|nego
op_eq
id|NS_SYNC
ques
c_cond
l_string|&quot;sync/async msgout&quot;
suffix:colon
l_string|&quot;ppr msgout&quot;
)paren
comma
id|msgptr
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
r_return
id|msglen
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_NCR_INTEGRITY_CHECKING */
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Prepare the next negotiation message if needed.&n;**&n;**&t;Fill in the part of message buffer that contains the &n;**&t;negotiation and the nego_status field of the CCB.&n;**&t;Returns the size of the message in bytes.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_prepare_nego
r_static
r_int
id|ncr_prepare_nego
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
op_star
id|msgptr
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
r_int
id|msglen
op_assign
l_int|0
suffix:semicolon
r_int
id|nego
op_assign
l_int|0
suffix:semicolon
id|u_char
id|width
comma
id|offset
comma
id|factor
comma
id|last_byte
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;check_integrity
)paren
(brace
multiline_comment|/* If integrity checking disabled, enable PPR messaging&n;&t;&t; * if device supports wide, sync and ultra 3&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;ppr_negotiation
op_eq
l_int|1
)paren
multiline_comment|/* PPR message successful */
id|tp-&gt;ppr_negotiation
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;inq_done
)paren
op_logical_and
(paren
op_logical_neg
id|tp-&gt;ic_maximums_set
)paren
)paren
(brace
id|tp-&gt;ic_maximums_set
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Issue PPR only if board is capable&n;&t;&t;&t; * and set-up for Ultra3 transfers.&n;&t;&t;&t; */
id|tp-&gt;ppr_negotiation
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA3
)paren
op_logical_and
(paren
id|tp-&gt;usrwide
)paren
op_logical_and
(paren
id|tp-&gt;maxoffs
)paren
op_logical_and
(paren
id|tp-&gt;minsync
op_eq
l_int|0x09
)paren
)paren
id|tp-&gt;ppr_negotiation
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tp-&gt;inq_done
)paren
(brace
multiline_comment|/*&n;&t;&t; * Get the current width, offset and period&n;&t;&t; */
id|ncr_get_xfer_info
c_func
(paren
id|np
comma
id|tp
comma
op_amp
id|factor
comma
op_amp
id|offset
comma
op_amp
id|width
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;negotiate wide transfers ?&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;widedone
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;inq_byte7
op_amp
id|INQ7_WIDE16
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;ppr_negotiation
)paren
id|nego
op_assign
id|NS_PPR
suffix:semicolon
r_else
id|nego
op_assign
id|NS_WIDE
suffix:semicolon
id|width
op_assign
id|tp-&gt;usrwide
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_INTEGRITY_CHECKING
r_if
c_cond
(paren
id|tp-&gt;ic_done
)paren
id|width
op_and_assign
id|tp-&gt;ic_max_width
suffix:semicolon
macro_line|#endif
)brace
r_else
id|tp-&gt;widedone
op_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;negotiate synchronous transfers?&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|nego
op_ne
id|NS_WIDE
)paren
op_logical_and
op_logical_neg
id|tp-&gt;period
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;inq_byte7
op_amp
id|INQ7_SYNC
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;ppr_negotiation
)paren
id|nego
op_assign
id|NS_PPR
suffix:semicolon
r_else
id|nego
op_assign
id|NS_SYNC
suffix:semicolon
multiline_comment|/* Check for async flag */
r_if
c_cond
(paren
id|tp-&gt;maxoffs
op_eq
l_int|0
)paren
(brace
id|offset
op_assign
l_int|0
suffix:semicolon
id|factor
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|offset
op_assign
id|tp-&gt;maxoffs
suffix:semicolon
id|factor
op_assign
id|tp-&gt;minsync
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_INTEGRITY_CHECKING
r_if
c_cond
(paren
(paren
id|tp-&gt;ic_done
)paren
op_logical_and
(paren
id|factor
OL
id|tp-&gt;ic_min_sync
)paren
)paren
id|factor
op_assign
id|tp-&gt;ic_min_sync
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
(brace
id|offset
op_assign
l_int|0
suffix:semicolon
id|factor
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;period
op_assign
l_int|0xffff
suffix:semicolon
id|PRINT_TARGET
c_func
(paren
id|np
comma
id|cp-&gt;target
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;target did not report SYNC.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
r_switch
c_cond
(paren
id|nego
)paren
(brace
r_case
id|NS_PPR
suffix:colon
multiline_comment|/*&n;&t;&t;** Must make sure data is consistent.&n;&t;&t;** If period is 9 and sync, must be wide and DT bit set&n;&t;&t;** else period must be larger. &n;&t;&t;** Maximum offset is 31=0x1f is ST mode, 62 if DT mode&n;&t;&t;*/
id|last_byte
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|factor
op_eq
l_int|9
)paren
op_logical_and
id|offset
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|width
)paren
(brace
id|factor
op_assign
l_int|0x0A
suffix:semicolon
id|offset
op_and_assign
l_int|0x1f
suffix:semicolon
)brace
r_else
id|last_byte
op_assign
l_int|0x02
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|factor
OG
l_int|0x09
)paren
id|offset
op_and_assign
l_int|0x1f
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|6
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_PPR_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|factor
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|offset
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|width
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|last_byte
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_SYNC
suffix:colon
multiline_comment|/*&n;&t;&t;** Never negotiate faster than Ultra 2 (25ns periods)&n;&t;&t;*/
r_if
c_cond
(paren
id|offset
op_logical_and
(paren
id|factor
OL
l_int|0x0A
)paren
)paren
(brace
id|factor
op_assign
l_int|0x0A
suffix:semicolon
id|tp-&gt;minsync
op_assign
l_int|0x0A
suffix:semicolon
)brace
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|3
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_SYNC_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|factor
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|offset
op_amp
l_int|0x1f
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|2
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_WIDE_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|width
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|nego
suffix:semicolon
r_if
c_cond
(paren
id|nego
)paren
(brace
id|tp-&gt;nego_cp
op_assign
id|cp
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|ncr_print_msg
c_func
(paren
id|cp
comma
id|nego
op_eq
id|NS_WIDE
ques
c_cond
l_string|&quot;wide msgout&quot;
suffix:colon
(paren
id|nego
op_eq
id|NS_SYNC
ques
c_cond
l_string|&quot;sync msgout&quot;
suffix:colon
l_string|&quot;ppr msgout&quot;
)paren
comma
id|msgptr
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
r_return
id|msglen
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Start execution of a SCSI command.&n;**&t;This is called from the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_queue_command
r_static
r_int
id|ncr_queue_command
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/*&t;Scsi_Device        *device    = cmd-&gt;device; */
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cmd-&gt;target
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|ncr_lp
c_func
(paren
id|np
comma
id|tp
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
id|u_char
id|idmsg
comma
op_star
id|msgptr
suffix:semicolon
id|u_int
id|msglen
suffix:semicolon
r_int
id|direction
suffix:semicolon
id|u_int32
id|lastp
comma
id|goalp
suffix:semicolon
multiline_comment|/*---------------------------------------------&n;&t;**&n;&t;**      Some shortcuts ...&n;&t;**&n;&t;**---------------------------------------------&n;&t;*/
r_if
c_cond
(paren
(paren
id|cmd-&gt;target
op_eq
id|np-&gt;myaddr
)paren
op_logical_or
(paren
id|cmd-&gt;target
op_ge
id|MAX_TARGET
)paren
op_logical_or
(paren
id|cmd-&gt;lun
op_ge
id|MAX_LUN
)paren
)paren
(brace
r_return
id|DID_BAD_TARGET
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------&n;&t;**&n;&t;**&t;Complete the 1st TEST UNIT READY command&n;&t;**&t;with error condition if the device is &n;&t;**&t;flagged NOSCAN, in order to speed up &n;&t;**&t;the boot.&n;&t;**&n;&t;**---------------------------------------------&n;&t;*/
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_and
(paren
id|tp-&gt;usrflag
op_amp
id|UF_NOSCAN
)paren
)paren
(brace
id|tp-&gt;usrflag
op_and_assign
op_complement
id|UF_NOSCAN
suffix:semicolon
r_return
id|DID_BAD_TARGET
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;CMD=%x &quot;
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;Assign a ccb / bind cmd.&n;&t;**&t;If resetting, shorten settle_time if necessary&n;&t;**&t;in order to avoid spurious timeouts.&n;&t;**&t;If resetting or no free ccb,&n;&t;**&t;insert cmd into the waiting list.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;settle_time
op_logical_and
id|cmd-&gt;timeout_per_command
op_ge
id|HZ
)paren
(brace
id|u_long
id|tlimit
op_assign
id|ktime_get
c_func
(paren
id|cmd-&gt;timeout_per_command
op_minus
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ktime_dif
c_func
(paren
id|np-&gt;settle_time
comma
id|tlimit
)paren
OG
l_int|0
)paren
id|np-&gt;settle_time
op_assign
id|tlimit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|np-&gt;settle_time
op_logical_or
op_logical_neg
(paren
id|cp
op_assign
id|ncr_get_ccb
(paren
id|np
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
)paren
)paren
(brace
id|insert_into_waiting_list
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_return
id|DID_OK
suffix:semicolon
)brace
id|cp-&gt;cmd
op_assign
id|cmd
suffix:semicolon
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;Enable tagged queue if asked by scsi ioctl&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
macro_line|#if 0&t;/* This stuff was only usefull for linux-1.2.13 */
r_if
c_cond
(paren
id|lp
op_logical_and
op_logical_neg
id|lp-&gt;numtags
op_logical_and
id|cmd-&gt;device
op_logical_and
id|cmd-&gt;device-&gt;tagged_queue
)paren
(brace
id|lp-&gt;numtags
op_assign
id|tp-&gt;usrtags
suffix:semicolon
id|ncr_setup_tags
(paren
id|np
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|cp-&gt;phys.num_disc
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Build the identify / tag / sdtr message&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
id|idmsg
op_assign
id|M_IDENTIFY
op_or
id|cp-&gt;lun
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_member_access_from_pointer
id|tag
op_ne
id|NO_TAG
op_logical_or
(paren
id|lp
op_logical_and
op_logical_neg
(paren
id|tp-&gt;usrflag
op_amp
id|UF_NODISC
)paren
)paren
)paren
id|idmsg
op_or_assign
l_int|0x40
suffix:semicolon
id|msgptr
op_assign
id|cp-&gt;scsi_smsg
suffix:semicolon
id|msglen
op_assign
l_int|0
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|idmsg
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;tag
op_ne
id|NO_TAG
)paren
(brace
r_char
id|order
op_assign
id|np-&gt;order
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Force ordered tag if necessary to avoid timeouts &n;&t;&t;**&t;and to preserve interactivity.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp
op_logical_and
id|ktime_exp
c_func
(paren
id|lp-&gt;tags_stime
)paren
)paren
(brace
id|lp-&gt;tags_si
op_assign
op_logical_neg
(paren
id|lp-&gt;tags_si
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tags_sum
(braket
id|lp-&gt;tags_si
)braket
)paren
(brace
id|order
op_assign
id|M_ORDERED_TAG
suffix:semicolon
r_if
c_cond
(paren
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
op_logical_or
id|bootverbose
OG
l_int|0
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ordered tag forced.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|lp-&gt;tags_stime
op_assign
id|ktime_get
c_func
(paren
l_int|3
op_star
id|HZ
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|order
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;**&t;Ordered write ops, unordered read ops.&n;&t;&t;&t;*/
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/* READ_SMALL (6) */
r_case
l_int|0x28
suffix:colon
multiline_comment|/* READ_BIG  (10) */
r_case
l_int|0xa8
suffix:colon
multiline_comment|/* READ_HUGE (12) */
id|order
op_assign
id|M_SIMPLE_TAG
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|order
op_assign
id|M_ORDERED_TAG
suffix:semicolon
)brace
)brace
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|order
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;For less than 128 tags, actual tags are numbered &n;&t;&t;**&t;1,3,5,..2*MAXTAGS+1,since we may have to deal &n;&t;&t;**&t;with devices that have problems with #TAG 0 or too &n;&t;&t;**&t;great #TAG numbers. For more tags (up to 256), &n;&t;&t;**&t;we use directly our tag number.&n;&t;&t;*/
macro_line|#if MAX_TASKS &gt; (512/4)
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|cp-&gt;tag
suffix:semicolon
macro_line|#else
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
(paren
id|cp-&gt;tag
op_lshift
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
macro_line|#endif
)brace
id|cp-&gt;host_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Build the data descriptors&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
id|direction
op_assign
id|scsi_data_direction
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_ne
id|SCSI_DATA_NONE
)paren
(brace
id|cp-&gt;segments
op_assign
id|np-&gt;scatter
(paren
id|np
comma
id|cp
comma
id|cp-&gt;cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;segments
OL
l_int|0
)paren
(brace
id|ncr_free_ccb
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_return
id|DID_ERROR
suffix:semicolon
)brace
)brace
r_else
(brace
id|cp-&gt;data_len
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;segments
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;negotiation required?&n;&t;**&n;&t;**&t;(nego_status is filled by ncr_prepare_nego())&n;&t;**&n;&t;**---------------------------------------------------&n;&t;*/
id|cp-&gt;nego_status
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_INTEGRITY_CHECKING
r_if
c_cond
(paren
(paren
id|np-&gt;check_integrity
op_logical_and
id|tp-&gt;ic_done
)paren
op_logical_or
op_logical_neg
id|np-&gt;check_integrity
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|tp-&gt;widedone
op_logical_or
op_logical_neg
id|tp-&gt;period
)paren
op_logical_and
op_logical_neg
id|tp-&gt;nego_cp
op_logical_and
id|lp
)paren
(brace
id|msglen
op_add_assign
id|ncr_prepare_nego
(paren
id|np
comma
id|cp
comma
id|msgptr
op_plus
id|msglen
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|np-&gt;check_integrity
op_logical_and
(paren
id|cmd-&gt;ic_in_progress
)paren
)paren
(brace
id|msglen
op_add_assign
id|ncr_ic_nego
(paren
id|np
comma
id|cp
comma
id|cmd
comma
id|msgptr
op_plus
id|msglen
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|np-&gt;check_integrity
op_logical_and
id|cmd-&gt;ic_complete
)paren
(brace
id|u_long
id|current_period
suffix:semicolon
id|u_char
id|current_offset
comma
id|current_width
comma
id|current_factor
suffix:semicolon
id|ncr_get_xfer_info
(paren
id|np
comma
id|tp
comma
op_amp
id|current_factor
comma
op_amp
id|current_offset
comma
op_amp
id|current_width
)paren
suffix:semicolon
id|tp-&gt;ic_max_width
op_assign
id|current_width
suffix:semicolon
id|tp-&gt;ic_min_sync
op_assign
id|current_factor
suffix:semicolon
r_if
c_cond
(paren
id|current_factor
op_eq
l_int|9
)paren
id|current_period
op_assign
l_int|125
suffix:semicolon
r_else
r_if
c_cond
(paren
id|current_factor
op_eq
l_int|10
)paren
id|current_period
op_assign
l_int|250
suffix:semicolon
r_else
r_if
c_cond
(paren
id|current_factor
op_eq
l_int|11
)paren
id|current_period
op_assign
l_int|303
suffix:semicolon
r_else
r_if
c_cond
(paren
id|current_factor
op_eq
l_int|12
)paren
id|current_period
op_assign
l_int|500
suffix:semicolon
r_else
id|current_period
op_assign
id|current_factor
op_star
l_int|40
suffix:semicolon
multiline_comment|/*&n;                 * Negotiation for this target is complete. Update flags.&n;                 */
id|tp-&gt;period
op_assign
id|current_period
suffix:semicolon
id|tp-&gt;widedone
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;ic_done
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Integrity Check Complete: &bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s %s SCSI&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|current_offset
ques
c_cond
l_string|&quot;SYNC&quot;
suffix:colon
l_string|&quot;ASYNC&quot;
comma
id|tp-&gt;ic_max_width
ques
c_cond
l_string|&quot;WIDE&quot;
suffix:colon
l_string|&quot;NARROW&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_offset
)paren
(brace
id|u_long
id|mbs
op_assign
l_int|10000
op_star
(paren
id|tp-&gt;ic_max_width
op_plus
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %d.%d  MB/s&quot;
comma
(paren
r_int
)paren
(paren
id|mbs
op_div
id|current_period
)paren
comma
(paren
r_int
)paren
(paren
id|mbs
op_mod
id|current_period
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; (%d ns, %d offset)&bslash;n&quot;
comma
(paren
r_int
)paren
id|current_period
op_div
l_int|10
comma
id|current_offset
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot; %d MB/s. &bslash;n &quot;
comma
(paren
id|tp-&gt;ic_max_width
op_plus
l_int|1
)paren
op_star
l_int|5
)paren
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
(paren
op_logical_neg
id|tp-&gt;widedone
op_logical_or
op_logical_neg
id|tp-&gt;period
)paren
op_logical_and
op_logical_neg
id|tp-&gt;nego_cp
op_logical_and
id|lp
)paren
(brace
id|msglen
op_add_assign
id|ncr_prepare_nego
(paren
id|np
comma
id|cp
comma
id|msgptr
op_plus
id|msglen
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_NCR_INTEGRITY_CHECKING */
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Determine xfer direction.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;data_len
)paren
id|direction
op_assign
id|SCSI_DATA_NONE
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If data direction is UNKNOWN, speculate DATA_READ &n;&t;**&t;but prepare alternate pointers for WRITE in case &n;&t;**&t;of our speculation will be just wrong.&n;&t;**&t;SCRIPTS will swap values if needed.&n;&t;*/
r_switch
c_cond
(paren
id|direction
)paren
(brace
r_case
id|SCSI_DATA_UNKNOWN
suffix:colon
r_case
id|SCSI_DATA_WRITE
suffix:colon
id|goalp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|data_out2
)paren
op_plus
l_int|8
suffix:semicolon
id|lastp
op_assign
id|goalp
op_minus
l_int|8
op_minus
(paren
id|cp-&gt;segments
op_star
(paren
id|SCR_SG_SIZE
op_star
l_int|4
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_ne
id|SCSI_DATA_UNKNOWN
)paren
r_break
suffix:semicolon
id|cp-&gt;phys.header.wgoalp
op_assign
id|cpu_to_scr
c_func
(paren
id|goalp
)paren
suffix:semicolon
id|cp-&gt;phys.header.wlastp
op_assign
id|cpu_to_scr
c_func
(paren
id|lastp
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SCSI_DATA_READ
suffix:colon
id|cp-&gt;host_flags
op_or_assign
id|HF_DATA_IN
suffix:semicolon
id|goalp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|data_in2
)paren
op_plus
l_int|8
suffix:semicolon
id|lastp
op_assign
id|goalp
op_minus
l_int|8
op_minus
(paren
id|cp-&gt;segments
op_star
(paren
id|SCR_SG_SIZE
op_star
l_int|4
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_case
id|SCSI_DATA_NONE
suffix:colon
id|lastp
op_assign
id|goalp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|no_data
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Set all pointers values needed by SCRIPTS.&n;&t;**&t;If direction is unknown, start at data_io.&n;&t;*/
id|cp-&gt;phys.header.lastp
op_assign
id|cpu_to_scr
c_func
(paren
id|lastp
)paren
suffix:semicolon
id|cp-&gt;phys.header.goalp
op_assign
id|cpu_to_scr
c_func
(paren
id|goalp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|SCSI_DATA_UNKNOWN
)paren
id|cp-&gt;phys.header.savep
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|data_io
)paren
)paren
suffix:semicolon
r_else
id|cp-&gt;phys.header.savep
op_assign
id|cpu_to_scr
c_func
(paren
id|lastp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Save the initial data pointer in order to be able &n;&t;**&t;to redo the command.&n;&t;**&t;We also have to save the initial lastp, since it &n;&t;**&t;will be changed to DATA_IO if we don&squot;t know the data &n;&t;**&t;direction and the device completes the command with &n;&t;**&t;QUEUE FULL status (without entering the data phase).&n;&t;*/
id|cp-&gt;startp
op_assign
id|cp-&gt;phys.header.savep
suffix:semicolon
id|cp-&gt;lastp0
op_assign
id|cp-&gt;phys.header.lastp
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;fill in ccb&n;&t;**&n;&t;**----------------------------------------------------&n;&t;**&n;&t;**&n;&t;**&t;physical -&gt; virtual backlink&n;&t;**&t;Generic SCSI command&n;&t;*/
multiline_comment|/*&n;&t;**&t;Startqueue&n;&t;*/
id|cp-&gt;phys.header.go.start
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|select
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.header.go.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|resel_dsa
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;select&n;&t;*/
id|cp-&gt;phys.select.sel_id
op_assign
id|cp-&gt;target
suffix:semicolon
id|cp-&gt;phys.select.sel_scntl3
op_assign
id|tp-&gt;wval
suffix:semicolon
id|cp-&gt;phys.select.sel_sxfer
op_assign
id|tp-&gt;sval
suffix:semicolon
id|cp-&gt;phys.select.sel_scntl4
op_assign
id|tp-&gt;uval
suffix:semicolon
multiline_comment|/*&n;&t;**&t;message&n;&t;*/
id|cp-&gt;phys.smsg.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|scsi_smsg
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.smsg.size
op_assign
id|cpu_to_scr
c_func
(paren
id|msglen
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;command&n;&t;*/
id|memcpy
c_func
(paren
id|cp-&gt;cdb_buf
comma
id|cmd-&gt;cmnd
comma
id|MIN
c_func
(paren
id|cmd-&gt;cmd_len
comma
r_sizeof
(paren
id|cp-&gt;cdb_buf
)paren
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.cmd.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|cdb_buf
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.cmd.size
op_assign
id|cpu_to_scr
c_func
(paren
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;status&n;&t;*/
id|cp-&gt;actualquirks
op_assign
id|tp-&gt;quirks
suffix:semicolon
id|cp-&gt;host_status
op_assign
id|cp-&gt;nego_status
ques
c_cond
id|HS_NEGOTIATE
suffix:colon
id|HS_BUSY
suffix:semicolon
id|cp-&gt;scsi_status
op_assign
id|S_ILLEGAL
suffix:semicolon
id|cp-&gt;xerr_status
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;phys.extra_bytes
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;extreme data pointer.&n;&t;**&t;shall be positive, so -1 is lower than lowest.:)&n;&t;*/
id|cp-&gt;ext_sg
op_assign
op_minus
l_int|1
suffix:semicolon
id|cp-&gt;ext_ofs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Critical region: start this job.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
multiline_comment|/*&n;&t;**&t;activate this job.&n;&t;*/
multiline_comment|/*&n;&t;**&t;insert next CCBs into start queue.&n;&t;**&t;2 max at a time is enough to flush the CCB wait queue.&n;&t;*/
r_if
c_cond
(paren
id|lp
)paren
id|ncr_start_next_ccb
c_func
(paren
id|np
comma
id|lp
comma
l_int|2
)paren
suffix:semicolon
r_else
id|ncr_put_start_queue
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Command is successfully queued.&n;&t;*/
r_return
id|DID_OK
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Insert a CCB into the start queue and wake up the &n;**&t;SCRIPTS processor.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_start_next_ccb
r_static
r_void
id|ncr_start_next_ccb
c_func
(paren
id|ncb_p
id|np
comma
id|lcb_p
id|lp
comma
r_int
id|maxn
)paren
(brace
id|XPT_QUEHEAD
op_star
id|qp
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
r_while
c_loop
(paren
id|maxn
op_decrement
op_logical_and
id|lp-&gt;queuedccbs
OL
id|lp-&gt;queuedepth
)paren
(brace
id|qp
op_assign
id|xpt_remque_head
c_func
(paren
op_amp
id|lp-&gt;wait_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qp
)paren
r_break
suffix:semicolon
op_increment
id|lp-&gt;queuedccbs
suffix:semicolon
id|cp
op_assign
id|xpt_que_entry
c_func
(paren
id|qp
comma
r_struct
id|ccb
comma
id|link_ccbq
)paren
suffix:semicolon
id|xpt_insque_tail
c_func
(paren
id|qp
comma
op_amp
id|lp-&gt;busy_ccbq
)paren
suffix:semicolon
id|lp-&gt;tasktbl
(braket
id|cp-&gt;tag
op_eq
id|NO_TAG
ques
c_cond
l_int|0
suffix:colon
id|cp-&gt;tag
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|cp-&gt;p_ccb
)paren
suffix:semicolon
id|ncr_put_start_queue
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
)brace
)brace
DECL|function|ncr_put_start_queue
r_static
r_void
id|ncr_put_start_queue
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
id|u_short
id|qidx
suffix:semicolon
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
multiline_comment|/*&n;&t;**&t;If the previously queued CCB is not yet done, &n;&t;**&t;set the IARB hint. The SCRIPTS will go with IARB &n;&t;**&t;for this job when starting the previous one.&n;&t;**&t;We leave devices a chance to win arbitration by &n;&t;**&t;not using more than &squot;iarb_max&squot; consecutive &n;&t;**&t;immediate arbitrations.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;last_cp
op_logical_and
id|np-&gt;iarb_count
OL
id|np-&gt;iarb_max
)paren
(brace
id|np-&gt;last_cp-&gt;host_flags
op_or_assign
id|HF_HINT_IARB
suffix:semicolon
op_increment
id|np-&gt;iarb_count
suffix:semicolon
)brace
r_else
id|np-&gt;iarb_count
op_assign
l_int|0
suffix:semicolon
id|np-&gt;last_cp
op_assign
id|cp
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;insert into start queue.&n;&t;*/
id|qidx
op_assign
id|np-&gt;squeueput
op_plus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|qidx
op_ge
id|MAX_START
op_star
l_int|2
)paren
id|qidx
op_assign
l_int|0
suffix:semicolon
id|np-&gt;squeue
(braket
id|qidx
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;p_idletask
)paren
suffix:semicolon
id|MEMORY_BARRIER
c_func
(paren
)paren
suffix:semicolon
id|np-&gt;squeue
(braket
id|np-&gt;squeueput
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|cp-&gt;p_ccb
)paren
suffix:semicolon
id|np-&gt;squeueput
op_assign
id|qidx
suffix:semicolon
id|cp-&gt;queued
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_QUEUE
)paren
id|printk
(paren
l_string|&quot;%s: queuepos=%d.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|np-&gt;squeueput
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Script processor may be waiting for reselect.&n;&t;**&t;Wake it up.&n;&t;*/
id|MEMORY_BARRIER
c_func
(paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
op_or
id|np-&gt;istat_sem
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Soft reset the chip.&n;**&n;**&t;Some 896 and 876 chip revisions may hang-up if we set &n;**&t;the SRST (soft reset) bit at the wrong time when SCRIPTS &n;**&t;are running.&n;**&t;So, we need to abort the current operation prior to &n;**&t;soft resetting the chip.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_chip_reset
r_static
r_void
id|ncr_chip_reset
(paren
id|ncb_p
id|np
)paren
(brace
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|10
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|ncr_soft_reset
r_static
r_void
id|ncr_soft_reset
c_func
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|istat
suffix:semicolon
r_int
id|i
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|CABRT
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1000000
suffix:semicolon
id|i
suffix:semicolon
op_decrement
id|i
)paren
(brace
id|istat
op_assign
id|INB
(paren
id|nc_istat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|istat
op_amp
id|SIP
)paren
(brace
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|istat
op_amp
id|DIP
)paren
(brace
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
id|INB
(paren
id|nc_dstat
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;%s: unable to abort current chip operation.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|ncr_chip_reset
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Start reset process.&n;**&t;The interrupt handler will reinitialize the chip.&n;**&t;The timeout handler will wait for settle_time before &n;**&t;clearing it and so resuming command processing.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_start_reset
r_static
r_void
id|ncr_start_reset
c_func
(paren
id|ncb_p
id|np
)paren
(brace
(paren
r_void
)paren
id|ncr_reset_scsi_bus
c_func
(paren
id|np
comma
l_int|1
comma
id|driver_setup.settle_delay
)paren
suffix:semicolon
)brace
DECL|function|ncr_reset_scsi_bus
r_static
r_int
id|ncr_reset_scsi_bus
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|enab_int
comma
r_int
id|settle_delay
)paren
(brace
id|u_int32
id|term
suffix:semicolon
r_int
id|retv
op_assign
l_int|0
suffix:semicolon
id|np-&gt;settle_time
op_assign
id|ktime_get
c_func
(paren
id|settle_delay
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: resetting, &quot;
l_string|&quot;command processing suspended for %d seconds&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|settle_delay
)paren
suffix:semicolon
id|ncr_soft_reset
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/* Soft reset the chip */
id|UDELAY
(paren
l_int|2000
)paren
suffix:semicolon
multiline_comment|/* The 895/6 need time for the bus mode to settle */
r_if
c_cond
(paren
id|enab_int
)paren
id|OUTW
(paren
id|nc_sien
comma
id|RST
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Enable Tolerant, reset IRQD if present and &n;&t;**&t;properly set IRQ mode, prior to resetting the bus.&n;&t;*/
id|OUTB
(paren
id|nc_stest3
comma
id|TE
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_dcntl
comma
(paren
id|np-&gt;rv_dcntl
op_amp
id|IRQM
)paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_scntl1
comma
id|CRST
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|200
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver_setup.bus_check
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Check for no terminators or SCSI bus shorts to ground.&n;&t;**&t;Read SCSI data bus, data parity bits and control signals.&n;&t;**&t;We are expecting RESET to be TRUE and other signals to be &n;&t;**&t;FALSE.&n;&t;*/
id|term
op_assign
id|INB
c_func
(paren
id|nc_sstat0
)paren
suffix:semicolon
id|term
op_assign
(paren
(paren
id|term
op_amp
l_int|2
)paren
op_lshift
l_int|7
)paren
op_plus
(paren
(paren
id|term
op_amp
l_int|1
)paren
op_lshift
l_int|17
)paren
suffix:semicolon
multiline_comment|/* rst sdp0 */
id|term
op_or_assign
(paren
(paren
id|INB
c_func
(paren
id|nc_sstat2
)paren
op_amp
l_int|0x01
)paren
op_lshift
l_int|26
)paren
op_or
multiline_comment|/* sdp1     */
(paren
(paren
id|INW
c_func
(paren
id|nc_sbdl
)paren
op_amp
l_int|0xff
)paren
op_lshift
l_int|9
)paren
op_or
multiline_comment|/* d7-0     */
(paren
(paren
id|INW
c_func
(paren
id|nc_sbdl
)paren
op_amp
l_int|0xff00
)paren
op_lshift
l_int|10
)paren
op_or
multiline_comment|/* d15-8    */
id|INB
c_func
(paren
id|nc_sbcl
)paren
suffix:semicolon
multiline_comment|/* req ack bsy sel atn msg cd io    */
r_if
c_cond
(paren
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_WIDE
)paren
)paren
id|term
op_and_assign
l_int|0x3ffff
suffix:semicolon
r_if
c_cond
(paren
id|term
op_ne
(paren
l_int|2
op_lshift
l_int|7
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: suspicious SCSI data while resetting the BUS.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %sdp0,d7-0,rst,req,ack,bsy,sel,atn,msg,c/d,i/o = &quot;
l_string|&quot;0x%lx, expecting 0x%lx&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|np-&gt;features
op_amp
id|FE_WIDE
)paren
ques
c_cond
l_string|&quot;dp1,d15-8,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|u_long
)paren
id|term
comma
(paren
id|u_long
)paren
(paren
l_int|2
op_lshift
l_int|7
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.bus_check
op_eq
l_int|1
)paren
id|retv
op_assign
l_int|1
suffix:semicolon
)brace
id|out
suffix:colon
id|OUTB
(paren
id|nc_scntl1
comma
l_int|0
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Reset the SCSI BUS.&n;**&t;This is called from the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_reset_bus
r_static
r_int
id|ncr_reset_bus
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|sync_reset
)paren
(brace
multiline_comment|/*&t;Scsi_Device        *device    = cmd-&gt;device; */
id|ccb_p
id|cp
suffix:semicolon
r_int
id|found
suffix:semicolon
multiline_comment|/*&n; * Return immediately if reset is in progress.&n; */
r_if
c_cond
(paren
id|np-&gt;settle_time
)paren
(brace
r_return
id|SCSI_RESET_PUNT
suffix:semicolon
)brace
multiline_comment|/*&n; * Start the reset process.&n; * The script processor is then assumed to be stopped.&n; * Commands will now be queued in the waiting list until a settle &n; * delay of 2 seconds will be completed.&n; */
id|ncr_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n; * First, look in the wakeup list&n; */
r_for
c_loop
(paren
id|found
op_assign
l_int|0
comma
id|cp
op_assign
id|np-&gt;ccbc
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;look for the ccb of this command.&n;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_IDLE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cmd
op_eq
id|cmd
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Then, look in the waiting list&n; */
r_if
c_cond
(paren
op_logical_neg
id|found
op_logical_and
id|retrieve_from_waiting_list
c_func
(paren
l_int|0
comma
id|np
comma
id|cmd
)paren
)paren
id|found
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Wake-up all awaiting commands with DID_RESET.&n; */
id|reset_waiting_list
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n; * Wake-up all pending commands with HS_RESET -&gt; DID_RESET.&n; */
id|ncr_wakeup
c_func
(paren
id|np
comma
id|HS_RESET
)paren
suffix:semicolon
multiline_comment|/*&n; * If the involved command was not in a driver queue, and the &n; * scsi driver told us reset is synchronous, and the command is not &n; * currently in the waiting list, complete it with DID_RESET status,&n; * in order to keep it alive.&n; */
r_if
c_cond
(paren
op_logical_neg
id|found
op_logical_and
id|sync_reset
op_logical_and
op_logical_neg
id|retrieve_from_waiting_list
c_func
(paren
l_int|0
comma
id|np
comma
id|cmd
)paren
)paren
(brace
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|DID_RESET
comma
l_int|0
)paren
suffix:semicolon
id|ncr_queue_done_cmd
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
)brace
r_return
id|SCSI_RESET_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Abort an SCSI command.&n;**&t;This is called from the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_abort_command
r_static
r_int
id|ncr_abort_command
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/*&t;Scsi_Device        *device    = cmd-&gt;device; */
id|ccb_p
id|cp
suffix:semicolon
multiline_comment|/*&n; * First, look for the scsi command in the waiting list&n; */
r_if
c_cond
(paren
id|remove_from_waiting_list
c_func
(paren
id|np
comma
id|cmd
)paren
)paren
(brace
id|SetScsiAbortResult
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|ncr_queue_done_cmd
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Then, look in the wakeup list&n; */
r_for
c_loop
(paren
id|cp
op_assign
id|np-&gt;ccbc
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;look for the ccb of this command.&n;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_IDLE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cmd
op_eq
id|cmd
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
(brace
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Keep track we have to abort this job.&n;&t;*/
id|cp-&gt;to_abort
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Tell the SCRIPTS processor to stop &n;&t;**&t;and synchronize with us.&n;&t;*/
id|np-&gt;istat_sem
op_assign
id|SEM
suffix:semicolon
multiline_comment|/*&n;&t;**      If there are no requests, the script&n;&t;**      processor will sleep on SEL_WAIT_RESEL.&n;&t;**      Let&squot;s wake it up, since it may have to work.&n;&t;*/
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
op_or
id|SEM
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Tell user we are working for him.&n;&t;*/
r_return
id|SCSI_ABORT_PENDING
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Linux release module stuff.&n;**&n;**&t;Called before unloading the module&n;**&t;Detach the host.&n;**&t;We have to free resources and halt the NCR chip&n;**&n;**==========================================================&n;*/
macro_line|#ifdef MODULE
DECL|function|ncr_detach
r_static
r_int
id|ncr_detach
c_func
(paren
id|ncb_p
id|np
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: detaching ...&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;**&t;Stop the ncr_timeout process&n;**&t;Set release_stage to 1 and wait that ncr_timeout() set it to 2.&n;*/
id|np-&gt;release_stage
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|50
suffix:semicolon
id|i
op_logical_and
id|np-&gt;release_stage
op_ne
l_int|2
suffix:semicolon
id|i
op_decrement
)paren
id|MDELAY
(paren
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;release_stage
op_ne
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;%s: the timer seems to be already stopped&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_else
id|np-&gt;release_stage
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;**&t;Reset NCR chip.&n;**&t;We should use ncr_soft_reset(), but we donnot want to do &n;**&t;so, since we may not be safe if interrupts occur.&n;*/
id|printk
c_func
(paren
l_string|&quot;%s: resetting chip&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|ncr_chip_reset
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;**&t;Restore bios setting for automatic clock detection.&n;*/
id|OUTB
c_func
(paren
id|nc_dmode
comma
id|np-&gt;sv_dmode
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_dcntl
comma
id|np-&gt;sv_dcntl
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_ctest3
comma
id|np-&gt;sv_ctest3
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_ctest4
comma
id|np-&gt;sv_ctest4
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_ctest5
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_gpcntl
comma
id|np-&gt;sv_gpcntl
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest2
comma
id|np-&gt;sv_stest2
)paren
suffix:semicolon
id|ncr_selectclock
c_func
(paren
id|np
comma
id|np-&gt;sv_scntl3
)paren
suffix:semicolon
multiline_comment|/*&n;**&t;Free host resources&n;*/
id|ncr_free_resources
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Complete execution of a SCSI command.&n;**&t;Signal completion to the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_complete
r_void
id|ncr_complete
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Sanity check&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|cp
op_logical_or
op_logical_neg
id|cp-&gt;cmd
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Gather profiling data&n;&t;*/
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|ncb_profile
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;CCB=%lx STAT=%x/%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cp
comma
id|cp-&gt;host_status
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Get command, target and lun pointers.&n;&t;*/
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
id|cp-&gt;cmd
op_assign
l_int|NULL
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
id|lp
op_assign
id|ncr_lp
c_func
(paren
id|np
comma
id|tp
comma
id|cp-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;We donnot queue more than 1 ccb per target &n;&t;**&t;with negotiation at any time. If this ccb was &n;&t;**&t;used for negotiation, clear this info in the tcb.&n;&t;*/
r_if
c_cond
(paren
id|cp
op_eq
id|tp-&gt;nego_cp
)paren
id|tp-&gt;nego_cp
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
multiline_comment|/*&n;&t;**&t;We just complete the last queued CCB.&n;&t;**&t;Clear this info that is no more relevant.&n;&t;*/
r_if
c_cond
(paren
id|cp
op_eq
id|np-&gt;last_cp
)paren
id|np-&gt;last_cp
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;If auto-sense performed, change scsi status, &n;&t;**&t;Otherwise, compute the residual.&n;&t;*/
r_if
c_cond
(paren
id|cp-&gt;host_flags
op_amp
id|HF_AUTO_SENSE
)paren
(brace
id|cp-&gt;scsi_status
op_assign
id|cp-&gt;sv_scsi_status
suffix:semicolon
id|cp-&gt;xerr_status
op_assign
id|cp-&gt;sv_xerr_status
suffix:semicolon
)brace
r_else
(brace
id|cp-&gt;resid
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;phys.header.lastp
op_ne
id|cp-&gt;phys.header.goalp
)paren
id|cp-&gt;resid
op_assign
id|ncr_compute_residual
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Check for extended errors.&n;&t;*/
r_if
c_cond
(paren
id|cp-&gt;xerr_status
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_amp
id|XE_PARITY_ERR
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;unrecovered SCSI parity error.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_amp
id|XE_EXTRA_DATA
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;extraneous data discarded.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_amp
id|XE_BAD_PHASE
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;illegal scsi phase (4/5).&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_amp
id|XE_SODL_UNRUN
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ODD transfer in DATA OUT phase.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_amp
id|XE_SWIDE_OVRUN
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ODD transfer in DATA IN phase.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
id|cp-&gt;host_status
op_assign
id|HS_FAIL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Print out any error for debugging purpose.&n;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
(paren
id|DEBUG_RESULT
op_or
id|DEBUG_TINY
)paren
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_ne
id|HS_COMPLETE
op_logical_or
id|cp-&gt;scsi_status
op_ne
id|S_GOOD
op_logical_or
id|cp-&gt;resid
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ERROR: cmd=%x host_status=%x scsi_status=%x &quot;
l_string|&quot;data_len=%d residual=%d&bslash;n&quot;
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|cp-&gt;host_status
comma
id|cp-&gt;scsi_status
comma
id|cp-&gt;data_len
comma
op_minus
id|cp-&gt;resid
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;Check the status.&n;&t;*/
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_GOOD
op_logical_or
id|cp-&gt;scsi_status
op_eq
id|S_COND_MET
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;All went well (GOOD status).&n;&t;&t;**&t;CONDITION MET status is returned on &n;                **&t;`Pre-Fetch&squot; or `Search data&squot; success.&n;                */
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|DID_OK
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Allocate the lcb if not yet.&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
id|ncr_alloc_lcb
(paren
id|np
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;On standard INQUIRY response (EVPD and CmDt &n;&t;&t;**&t;not set), setup logical unit according to &n;&t;&t;**&t;announced capabilities (we need the 1rst 7 bytes).&n;&t;&t;*/
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0x12
op_logical_and
op_logical_neg
(paren
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
op_amp
l_int|0x3
)paren
op_logical_and
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
op_ge
l_int|7
op_logical_and
op_logical_neg
id|cmd-&gt;use_sg
)paren
(brace
id|sync_scsi_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/* SYNC the data */
id|ncr_setup_lcb
(paren
id|np
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
comma
(paren
r_char
op_star
)paren
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
)brace
id|tp-&gt;bytes
op_add_assign
id|cp-&gt;data_len
suffix:semicolon
id|tp-&gt;transfers
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;If tags was reduced due to queue full,&n;&t;&t;**&t;increase tags if 1000 good status received.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp
op_logical_and
id|lp-&gt;usetags
op_logical_and
id|lp-&gt;numtags
OL
id|lp-&gt;maxtags
)paren
(brace
op_increment
id|lp-&gt;num_good
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;num_good
op_ge
l_int|1000
)paren
(brace
id|lp-&gt;num_good
op_assign
l_int|0
suffix:semicolon
op_increment
id|lp-&gt;numtags
suffix:semicolon
id|ncr_setup_tags
(paren
id|np
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_CHECK_COND
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Check condition code&n;&t;&t;*/
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|DID_OK
comma
id|S_CHECK_COND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
(paren
id|DEBUG_RESULT
op_or
id|DEBUG_TINY
)paren
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|ncr_printl_hex
c_func
(paren
l_string|&quot;sense data:&quot;
comma
id|cmd-&gt;sense_buffer
comma
l_int|14
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_CONFLICT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Reservation Conflict condition code&n;&t;&t;*/
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|DID_OK
comma
id|S_CONFLICT
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_BUSY
op_logical_or
id|cp-&gt;scsi_status
op_eq
id|S_QUEUE_FULL
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Target is busy.&n;&t;&t;*/
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|DID_OK
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_SEL_TIMEOUT
)paren
op_logical_or
(paren
id|cp-&gt;host_status
op_eq
id|HS_TIMEOUT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   No response&n;&t;&t;*/
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|DID_TIME_OUT
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_RESET
)paren
(brace
multiline_comment|/*&n;&t;&t;**   SCSI bus reset&n;&t;&t;*/
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|DID_RESET
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_ABORTED
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Transfer aborted&n;&t;&t;*/
id|SetScsiAbortResult
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|did_status
suffix:semicolon
multiline_comment|/*&n;&t;&t;**  Other protocol messes&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;COMMAND FAILED (%x %x) @%p.&bslash;n&quot;
comma
id|cp-&gt;host_status
comma
id|cp-&gt;scsi_status
comma
id|cp
)paren
suffix:semicolon
id|did_status
op_assign
id|DID_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_amp
id|XE_PARITY_ERR
)paren
id|did_status
op_assign
id|DID_PARITY
suffix:semicolon
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|did_status
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;trace output&n;&t;*/
r_if
c_cond
(paren
id|tp-&gt;usrflag
op_amp
id|UF_TRACE
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot; CMD:&quot;
)paren
suffix:semicolon
id|ncr_print_hex
c_func
(paren
id|cmd-&gt;cmnd
comma
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
(brace
r_switch
c_cond
(paren
id|cp-&gt;scsi_status
)paren
(brace
r_case
id|S_GOOD
suffix:colon
id|printk
(paren
l_string|&quot;  GOOD&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_CHECK_COND
suffix:colon
id|printk
(paren
l_string|&quot;  SENSE:&quot;
)paren
suffix:semicolon
id|ncr_print_hex
c_func
(paren
id|cmd-&gt;sense_buffer
comma
l_int|14
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;  STAT: %x&bslash;n&quot;
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
id|printk
(paren
l_string|&quot;  HOSTERROR: %x&quot;
comma
id|cp-&gt;host_status
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Free this ccb&n;&t;*/
id|ncr_free_ccb
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;requeue awaiting scsi commands for this lun.&n;&t;*/
r_if
c_cond
(paren
id|lp
op_logical_and
id|lp-&gt;queuedccbs
OL
id|lp-&gt;queuedepth
op_logical_and
op_logical_neg
id|xpt_que_empty
c_func
(paren
op_amp
id|lp-&gt;wait_ccbq
)paren
)paren
id|ncr_start_next_ccb
c_func
(paren
id|np
comma
id|lp
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;requeue awaiting scsi commands for this controller.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;waiting_list
)paren
id|requeue_waiting_list
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;signal completion to generic driver.&n;&t;*/
id|ncr_queue_done_cmd
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Signal all (or one) control block done.&n;**&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**&t;The NCR has completed CCBs.&n;**&t;Look at the DONE QUEUE.&n;*/
DECL|function|ncr_wakeup_done
r_int
id|ncr_wakeup_done
(paren
id|ncb_p
id|np
)paren
(brace
id|ccb_p
id|cp
suffix:semicolon
r_int
id|i
comma
id|n
suffix:semicolon
id|u_long
id|dsa
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|np-&gt;dqueueget
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|dsa
op_assign
id|scr_to_cpu
c_func
(paren
id|np-&gt;dqueue
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dsa
)paren
r_break
suffix:semicolon
id|np-&gt;dqueue
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|i
op_plus
l_int|2
)paren
op_ge
id|MAX_START
op_star
l_int|2
)paren
id|i
op_assign
l_int|0
suffix:semicolon
id|cp
op_assign
id|ncr_ccb_from_dsa
c_func
(paren
id|np
comma
id|dsa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
)paren
(brace
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
op_increment
id|n
suffix:semicolon
)brace
r_else
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: bad DSA (%lx) in done queue.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|dsa
)paren
suffix:semicolon
)brace
id|np-&gt;dqueueget
op_assign
id|i
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Complete all active CCBs.&n;*/
DECL|function|ncr_wakeup
r_void
id|ncr_wakeup
(paren
id|ncb_p
id|np
comma
id|u_long
id|code
)paren
(brace
id|ccb_p
id|cp
op_assign
id|np-&gt;ccbc
suffix:semicolon
r_while
c_loop
(paren
id|cp
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_ne
id|HS_IDLE
)paren
(brace
id|cp-&gt;host_status
op_assign
id|code
suffix:semicolon
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
)brace
id|cp
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
)brace
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Start NCR chip.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_init
r_void
id|ncr_init
(paren
id|ncb_p
id|np
comma
r_int
id|reset
comma
r_char
op_star
id|msg
comma
id|u_long
id|code
)paren
(brace
r_int
id|i
suffix:semicolon
id|u_long
id|phys
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Reset chip if asked, otherwise just clear fifos.&n; &t;*/
r_if
c_cond
(paren
id|reset
)paren
id|ncr_soft_reset
c_func
(paren
id|np
)paren
suffix:semicolon
r_else
(brace
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
id|OUTONB
(paren
id|nc_ctest3
comma
id|CLF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Message.&n;&t;*/
r_if
c_cond
(paren
id|msg
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: restart (%s).&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|msg
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Clear Start Queue&n;&t;*/
id|phys
op_assign
id|np-&gt;p_squeue
suffix:semicolon
id|np-&gt;queuedepth
op_assign
id|MAX_START
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* 1 entry needed as end marker */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_START
op_star
l_int|2
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|np-&gt;squeue
(braket
id|i
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;p_idletask
)paren
suffix:semicolon
id|np-&gt;squeue
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|phys
op_plus
(paren
id|i
op_plus
l_int|2
)paren
op_star
l_int|4
)paren
suffix:semicolon
)brace
id|np-&gt;squeue
(braket
id|MAX_START
op_star
l_int|2
op_minus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|phys
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Start at first entry.&n;&t;*/
id|np-&gt;squeueput
op_assign
l_int|0
suffix:semicolon
id|np-&gt;scripth0-&gt;startpos
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|phys
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Clear Done Queue&n;&t;*/
id|phys
op_assign
id|vtobus
c_func
(paren
id|np-&gt;dqueue
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_START
op_star
l_int|2
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|np-&gt;dqueue
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|np-&gt;dqueue
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|phys
op_plus
(paren
id|i
op_plus
l_int|2
)paren
op_star
l_int|4
)paren
suffix:semicolon
)brace
id|np-&gt;dqueue
(braket
id|MAX_START
op_star
l_int|2
op_minus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|phys
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Start at first entry.&n;&t;*/
id|np-&gt;scripth0-&gt;done_pos
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|phys
)paren
suffix:semicolon
id|np-&gt;dqueueget
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wakeup all pending jobs.&n;&t;*/
id|ncr_wakeup
(paren
id|np
comma
id|code
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Init chip.&n;&t;*/
id|OUTB
(paren
id|nc_istat
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/*  Remove Reset, abort */
id|UDELAY
(paren
l_int|2000
)paren
suffix:semicolon
multiline_comment|/* The 895 needs time for the bus mode to settle */
id|OUTB
(paren
id|nc_scntl0
comma
id|np-&gt;rv_scntl0
op_or
l_int|0xc0
)paren
suffix:semicolon
multiline_comment|/*  full arb., ena parity, par-&gt;ATN  */
id|OUTB
(paren
id|nc_scntl1
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/*  odd parity, and remove CRST!! */
id|ncr_selectclock
c_func
(paren
id|np
comma
id|np-&gt;rv_scntl3
)paren
suffix:semicolon
multiline_comment|/* Select SCSI clock */
id|OUTB
(paren
id|nc_scid
comma
id|RRE
op_or
id|np-&gt;myaddr
)paren
suffix:semicolon
multiline_comment|/* Adapter SCSI address */
id|OUTW
(paren
id|nc_respid
comma
l_int|1ul
op_lshift
id|np-&gt;myaddr
)paren
suffix:semicolon
multiline_comment|/* Id to respond to */
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
)paren
suffix:semicolon
multiline_comment|/*  Signal Process */
id|OUTB
(paren
id|nc_dmode
comma
id|np-&gt;rv_dmode
)paren
suffix:semicolon
multiline_comment|/* Burst length, dma mode */
id|OUTB
(paren
id|nc_ctest5
comma
id|np-&gt;rv_ctest5
)paren
suffix:semicolon
multiline_comment|/* Large fifo + large burst */
id|OUTB
(paren
id|nc_dcntl
comma
id|NOCOM
op_or
id|np-&gt;rv_dcntl
)paren
suffix:semicolon
multiline_comment|/* Protect SFBR */
id|OUTB
(paren
id|nc_ctest3
comma
id|np-&gt;rv_ctest3
)paren
suffix:semicolon
multiline_comment|/* Write and invalidate */
id|OUTB
(paren
id|nc_ctest4
comma
id|np-&gt;rv_ctest4
)paren
suffix:semicolon
multiline_comment|/* Master parity checking */
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_and
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
(brace
id|OUTB
(paren
id|nc_stest2
comma
id|EXT
op_or
id|np-&gt;rv_stest2
)paren
suffix:semicolon
multiline_comment|/* Extended Sreq/Sack filtering, not supported in C1010/C1010_66 */
)brace
id|OUTB
(paren
id|nc_stest3
comma
id|TE
)paren
suffix:semicolon
multiline_comment|/* TolerANT enable */
id|OUTB
(paren
id|nc_stime0
comma
l_int|0x0c
)paren
suffix:semicolon
multiline_comment|/* HTH disabled  STO 0.25 sec */
multiline_comment|/*&n;&t;**&t;DEL 441 - 53C876 Rev 5 - Part Number 609-0392787/2788 - ITEM 2.&n;&t;**&t;Disable overlapped arbitration for all dual-function &n;&t;**&t;devices, regardless revision id.&n;&t;**&t;We may consider it is a post-chip-design feature. ;-)&n; &t;**&n; &t;**&t;Errata applies to all 896 and 1010 parts.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_NCR_53C875
)paren
id|OUTB
(paren
id|nc_ctest0
comma
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_NCR_53C896
op_logical_or
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
op_logical_or
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
id|np-&gt;rv_ccntl0
op_or_assign
id|DPR
suffix:semicolon
multiline_comment|/*&n;&t;**&t;C1010_66MHz rev 0 part requies AIPCNTL1 bit 3 to be set.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
id|OUTB
c_func
(paren
id|nc_aipcntl1
comma
(paren
l_int|1
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If 64 bit (895A/896/1010/1010_66) write the CCNTL1 register to &n;&t;**&t;enable 40 bit address table indirect addressing for MOVE.&n;&t;**&t;Also write CCNTL0 if 64 bit chip, since this register seems &n;&t;**&t;to only be used by 64 bit cores.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_64BIT
)paren
(brace
id|OUTB
(paren
id|nc_ccntl0
comma
id|np-&gt;rv_ccntl0
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_ccntl1
comma
id|np-&gt;rv_ccntl1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; &t;**&t;If phase mismatch handled by scripts (53C895A or 53C896 &n; &t;**&t;or 53C1010 or 53C1010_66), set PM jump addresses. &n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_NOPM
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: handling phase mismatch from SCRIPTS.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_pmjad1
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|pm_handle
)paren
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_pmjad2
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|pm_handle
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    Enable GPIO0 pin for writing if LED support from SCRIPTS.&n;&t;**    Also set GPIO5 and clear GPIO6 if hardware LED control.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_LED0
)paren
id|OUTB
c_func
(paren
id|nc_gpcntl
comma
id|INB
c_func
(paren
id|nc_gpcntl
)paren
op_amp
op_complement
l_int|0x01
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_LEDC
)paren
id|OUTB
c_func
(paren
id|nc_gpcntl
comma
(paren
id|INB
c_func
(paren
id|nc_gpcntl
)paren
op_amp
op_complement
l_int|0x41
)paren
op_or
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**      enable ints&n;&t;*/
id|OUTW
(paren
id|nc_sien
comma
id|STO
op_or
id|HTH
op_or
id|MA
op_or
id|SGE
op_or
id|UDC
op_or
id|RST
op_or
id|PAR
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_dien
comma
id|MDPE
op_or
id|BF
op_or
id|SSI
op_or
id|SIR
op_or
id|IID
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;For 895/895A/896/c1010&n;&t;**&t;Enable SBMC interrupt and save current SCSI bus mode.&n;&t;*/
r_if
c_cond
(paren
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA2
)paren
op_logical_or
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA3
)paren
)paren
(brace
id|OUTONW
(paren
id|nc_sien
comma
id|SBMC
)paren
suffix:semicolon
id|np-&gt;scsi_mode
op_assign
id|INB
(paren
id|nc_stest4
)paren
op_amp
id|SMODE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Fill in target structure.&n;&t;**&t;Reinitialize usrsync.&n;&t;**&t;Reinitialize usrwide.&n;&t;**&t;Prepare sync negotiation according to actual SCSI bus mode.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|tp-&gt;to_reset
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;sval
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;wval
op_assign
id|np-&gt;rv_scntl3
suffix:semicolon
id|tp-&gt;uval
op_assign
id|np-&gt;rv_scntl4
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;usrsync
op_ne
l_int|255
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;usrsync
op_le
id|np-&gt;maxsync
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;usrsync
OL
id|np-&gt;minsync
)paren
(brace
id|tp-&gt;usrsync
op_assign
id|np-&gt;minsync
suffix:semicolon
)brace
)brace
r_else
id|tp-&gt;usrsync
op_assign
l_int|255
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;usrwide
OG
id|np-&gt;maxwide
)paren
id|tp-&gt;usrwide
op_assign
id|np-&gt;maxwide
suffix:semicolon
id|ncr_negotiate
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    Download SCSI SCRIPTS to on-chip RAM if present,&n;&t;**    and start script processor.&n;&t;**    We do the download preferently from the CPU.&n;&t;**    For platforms that may not support PCI memory mapping,&n;&t;**    we use a simple SCRIPTS that performs MEMORY MOVEs.&n;&t;*/
id|MEMORY_BARRIER
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;base2_ba
)paren
(brace
r_if
c_cond
(paren
id|bootverbose
)paren
id|printk
(paren
l_string|&quot;%s: Downloading SCSI SCRIPTS.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PCI_MEM_NOT_SUPPORTED
r_if
c_cond
(paren
id|np-&gt;base2_ws
op_eq
l_int|8192
)paren
id|phys
op_assign
id|NCB_SCRIPTH0_PHYS
(paren
id|np
comma
id|start_ram64
)paren
suffix:semicolon
r_else
id|phys
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|start_ram
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|np-&gt;base2_ws
op_eq
l_int|8192
)paren
(brace
id|memcpy_to_pci
c_func
(paren
id|np-&gt;base2_va
op_plus
l_int|4096
comma
id|np-&gt;scripth0
comma
r_sizeof
(paren
r_struct
id|scripth
)paren
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_mmws
comma
id|np-&gt;scr_ram_seg
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_mmrs
comma
id|np-&gt;scr_ram_seg
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_sfs
comma
id|np-&gt;scr_ram_seg
)paren
suffix:semicolon
id|phys
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|start64
)paren
suffix:semicolon
)brace
r_else
id|phys
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|init
)paren
suffix:semicolon
id|memcpy_to_pci
c_func
(paren
id|np-&gt;base2_va
comma
id|np-&gt;script0
comma
r_sizeof
(paren
r_struct
id|script
)paren
)paren
suffix:semicolon
macro_line|#endif /* SCSI_NCR_PCI_MEM_NOT_SUPPORTED */
)brace
r_else
id|phys
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|init
)paren
suffix:semicolon
id|np-&gt;istat_sem
op_assign
l_int|0
suffix:semicolon
id|OUTL
(paren
id|nc_dsa
comma
id|np-&gt;p_ncb
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|phys
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Prepare the negotiation values for wide and&n;**&t;synchronous transfers.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_negotiate
r_static
r_void
id|ncr_negotiate
(paren
r_struct
id|ncb
op_star
id|np
comma
r_struct
id|tcb
op_star
id|tp
)paren
(brace
multiline_comment|/*&n;&t;**&t;minsync unit is 4ns !&n;&t;*/
id|u_long
id|minsync
op_assign
id|tp-&gt;usrsync
suffix:semicolon
multiline_comment|/*&n;&t;**&t;SCSI bus mode limit&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;scsi_mode
op_logical_and
id|np-&gt;scsi_mode
op_eq
id|SMODE_SE
)paren
(brace
r_if
c_cond
(paren
id|minsync
OL
l_int|12
)paren
id|minsync
op_assign
l_int|12
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;our limit ..&n;&t;*/
r_if
c_cond
(paren
id|minsync
OL
id|np-&gt;minsync
)paren
id|minsync
op_assign
id|np-&gt;minsync
suffix:semicolon
multiline_comment|/*&n;&t;**&t;divider limit&n;&t;*/
r_if
c_cond
(paren
id|minsync
OG
id|np-&gt;maxsync
)paren
id|minsync
op_assign
l_int|255
suffix:semicolon
id|tp-&gt;minsync
op_assign
id|minsync
suffix:semicolon
id|tp-&gt;maxoffs
op_assign
(paren
id|minsync
OL
l_int|255
ques
c_cond
id|np-&gt;maxoffs
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;period=0: has to negotiate sync transfer&n;&t;*/
id|tp-&gt;period
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;widedone=0: has to negotiate wide transfer&n;&t;*/
id|tp-&gt;widedone
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Get clock factor and sync divisor for a given &n;**&t;synchronous factor period.&n;**&t;Returns the clock factor (in sxfer) and scntl3 &n;**&t;synchronous divisor field.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_getsync
r_static
r_void
id|ncr_getsync
c_func
(paren
id|ncb_p
id|np
comma
id|u_char
id|sfac
comma
id|u_char
op_star
id|fakp
comma
id|u_char
op_star
id|scntl3p
)paren
(brace
id|u_long
id|clk
op_assign
id|np-&gt;clock_khz
suffix:semicolon
multiline_comment|/* SCSI clock frequency in kHz&t;*/
r_int
id|div
op_assign
id|np-&gt;clock_divn
suffix:semicolon
multiline_comment|/* Number of divisors supported&t;*/
id|u_long
id|fak
suffix:semicolon
multiline_comment|/* Sync factor in sxfer&t;&t;*/
id|u_long
id|per
suffix:semicolon
multiline_comment|/* Period in tenths of ns&t;*/
id|u_long
id|kpc
suffix:semicolon
multiline_comment|/* (per * clk)&t;&t;&t;*/
multiline_comment|/*&n;&t;**&t;Compute the synchronous period in tenths of nano-seconds&n;&t;**&t;from sfac.&n;&t;**&n;&t;**&t;Note, if sfac == 9, DT is being used. Double the period of 125&n;&t;**&t;to 250. &n;&t;*/
r_if
c_cond
(paren
id|sfac
op_le
l_int|10
)paren
id|per
op_assign
l_int|250
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sfac
op_eq
l_int|11
)paren
id|per
op_assign
l_int|303
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sfac
op_eq
l_int|12
)paren
id|per
op_assign
l_int|500
suffix:semicolon
r_else
id|per
op_assign
l_int|40
op_star
id|sfac
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Look for the greatest clock divisor that allows an &n;&t;**&t;input speed faster than the period.&n;&t;*/
id|kpc
op_assign
id|per
op_star
id|clk
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|div
op_ge
l_int|0
)paren
r_if
c_cond
(paren
id|kpc
op_ge
(paren
id|div_10M
(braket
id|div
)braket
op_lshift
l_int|2
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Calculate the lowest clock factor that allows an output &n;&t;**&t;speed not faster than the period.&n;&t;*/
id|fak
op_assign
(paren
id|kpc
op_minus
l_int|1
)paren
op_div
id|div_10M
(braket
id|div
)braket
op_plus
l_int|1
suffix:semicolon
macro_line|#if 0&t;/* This optimization does not seem very usefull */
id|per
op_assign
(paren
id|fak
op_star
id|div_10M
(braket
id|div
)braket
)paren
op_div
id|clk
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Why not to try the immediate lower divisor and to choose &n;&t;**&t;the one that allows the fastest output speed ?&n;&t;**&t;We dont want input speed too much greater than output speed.&n;&t;*/
r_if
c_cond
(paren
id|div
op_ge
l_int|1
op_logical_and
id|fak
OL
l_int|8
)paren
(brace
id|u_long
id|fak2
comma
id|per2
suffix:semicolon
id|fak2
op_assign
(paren
id|kpc
op_minus
l_int|1
)paren
op_div
id|div_10M
(braket
id|div
op_minus
l_int|1
)braket
op_plus
l_int|1
suffix:semicolon
id|per2
op_assign
(paren
id|fak2
op_star
id|div_10M
(braket
id|div
op_minus
l_int|1
)braket
)paren
op_div
id|clk
suffix:semicolon
r_if
c_cond
(paren
id|per2
OL
id|per
op_logical_and
id|fak2
op_le
l_int|8
)paren
(brace
id|fak
op_assign
id|fak2
suffix:semicolon
id|per
op_assign
id|per2
suffix:semicolon
op_decrement
id|div
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|fak
OL
l_int|4
)paren
id|fak
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* Should never happen, too bad ... */
multiline_comment|/*&n;&t;**&t;Compute and return sync parameters for the ncr&n;&t;*/
op_star
id|fakp
op_assign
id|fak
op_minus
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t;** If sfac &lt; 25, and 8xx parts, desire that the chip operate at &n;&t;** least at Ultra speeds.  Must set bit 7 of scntl3.&n;&t;** For C1010, do not set this bit. If operating at Ultra3 speeds,&n;&t;**&t;set the U3EN bit instead.&n;&t;*/
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
(brace
op_star
id|scntl3p
op_assign
(paren
id|div
op_plus
l_int|1
)paren
op_lshift
l_int|4
suffix:semicolon
op_star
id|fakp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_star
id|scntl3p
op_assign
(paren
(paren
id|div
op_plus
l_int|1
)paren
op_lshift
l_int|4
)paren
op_plus
(paren
id|sfac
OL
l_int|25
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
)paren
suffix:semicolon
op_star
id|fakp
op_assign
id|fak
op_minus
l_int|4
suffix:semicolon
)brace
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Utility routine to return the current bus width&t;&n;**&t;synchronous period and offset.&n;**&t;Utilizes target sval, wval and uval  &n;**&n;**==========================================================&n;*/
DECL|function|ncr_get_xfer_info
r_static
r_void
id|ncr_get_xfer_info
c_func
(paren
id|ncb_p
id|np
comma
id|tcb_p
id|tp
comma
id|u_char
op_star
id|factor
comma
id|u_char
op_star
id|offset
comma
id|u_char
op_star
id|width
)paren
(brace
id|u_char
id|idiv
suffix:semicolon
id|u_long
id|period
suffix:semicolon
op_star
id|width
op_assign
(paren
id|tp-&gt;wval
op_amp
id|EWS
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
op_star
id|offset
op_assign
(paren
id|tp-&gt;sval
op_amp
l_int|0x3f
)paren
suffix:semicolon
r_else
op_star
id|offset
op_assign
(paren
id|tp-&gt;sval
op_amp
l_int|0x1f
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Midlayer signal to the driver that all of the scsi commands&n;&t; * for the integrity check have completed. Save the negotiated&n; &t; * parameters (extracted from sval, wval and uval). &n;&t; * See ncr_setsync for alg. details.&n;&t; */
id|idiv
op_assign
(paren
id|tp-&gt;wval
op_rshift
l_int|4
)paren
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
op_star
id|offset
op_logical_and
id|idiv
)paren
(brace
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;uval
op_amp
l_int|0x80
)paren
id|period
op_assign
(paren
l_int|2
op_star
id|div_10M
(braket
id|idiv
op_minus
l_int|1
)braket
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
r_else
id|period
op_assign
(paren
l_int|4
op_star
id|div_10M
(braket
id|idiv
op_minus
l_int|1
)braket
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
)brace
r_else
id|period
op_assign
(paren
(paren
(paren
id|tp-&gt;sval
op_rshift
l_int|5
)paren
op_plus
l_int|4
)paren
op_star
id|div_10M
(braket
id|idiv
op_minus
l_int|1
)braket
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
)brace
r_else
id|period
op_assign
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|period
op_le
l_int|125
)paren
op_star
id|factor
op_assign
l_int|9
suffix:semicolon
r_else
r_if
c_cond
(paren
id|period
op_le
l_int|250
)paren
op_star
id|factor
op_assign
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|period
op_le
l_int|303
)paren
op_star
id|factor
op_assign
l_int|11
suffix:semicolon
r_else
r_if
c_cond
(paren
id|period
op_le
l_int|500
)paren
op_star
id|factor
op_assign
l_int|12
suffix:semicolon
r_else
op_star
id|factor
op_assign
(paren
id|period
op_plus
l_int|40
op_minus
l_int|1
)paren
op_div
l_int|40
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Set actual values, sync status and patch all ccbs of &n;**&t;a target according to new sync/wide agreement.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_set_sync_wide_status
r_static
r_void
id|ncr_set_sync_wide_status
(paren
id|ncb_p
id|np
comma
id|u_char
id|target
)paren
(brace
id|ccb_p
id|cp
op_assign
id|np-&gt;ccbc
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;set actual value and sync_status&n;&t;**&n;&t;**&t;TEMP register contains current scripts address&n;&t;**&t;which is data type/direction/dependent.&n;&t;*/
id|OUTB
(paren
id|nc_sxfer
comma
id|tp-&gt;sval
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_scntl3
comma
id|tp-&gt;wval
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
id|OUTB
(paren
id|nc_scntl4
comma
id|tp-&gt;uval
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;patch ALL ccbs of this target.&n;&t;*/
r_for
c_loop
(paren
id|cp
op_assign
id|np-&gt;ccbc
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_IDLE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;target
op_ne
id|target
)paren
r_continue
suffix:semicolon
id|cp-&gt;phys.select.sel_scntl3
op_assign
id|tp-&gt;wval
suffix:semicolon
id|cp-&gt;phys.select.sel_sxfer
op_assign
id|tp-&gt;sval
suffix:semicolon
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
id|cp-&gt;phys.select.sel_scntl4
op_assign
id|tp-&gt;uval
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Switch sync mode for current job and it&squot;s target&n;**&n;**==========================================================&n;*/
DECL|function|ncr_setsync
r_static
r_void
id|ncr_setsync
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|scntl3
comma
id|u_char
id|sxfer
comma
id|u_char
id|scntl4
)paren
(brace
id|tcb_p
id|tp
suffix:semicolon
id|u_char
id|target
op_assign
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|u_char
id|idiv
suffix:semicolon
id|u_char
id|offset
suffix:semicolon
m_assert
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
suffix:semicolon
m_assert
(paren
id|target
op_eq
(paren
id|cp-&gt;target
op_amp
l_int|0xf
)paren
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
(brace
id|offset
op_assign
id|sxfer
op_amp
l_int|0x3f
suffix:semicolon
multiline_comment|/* bits 5-0 */
id|scntl3
op_assign
(paren
id|scntl3
op_amp
l_int|0xf0
)paren
op_or
(paren
id|tp-&gt;wval
op_amp
id|EWS
)paren
suffix:semicolon
id|scntl4
op_assign
(paren
id|scntl4
op_amp
l_int|0x80
)paren
suffix:semicolon
)brace
r_else
(brace
id|offset
op_assign
id|sxfer
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* bits 4-0 */
r_if
c_cond
(paren
op_logical_neg
id|scntl3
op_logical_or
op_logical_neg
id|offset
)paren
id|scntl3
op_assign
id|np-&gt;rv_scntl3
suffix:semicolon
id|scntl3
op_assign
(paren
id|scntl3
op_amp
l_int|0xf0
)paren
op_or
(paren
id|tp-&gt;wval
op_amp
id|EWS
)paren
op_or
(paren
id|np-&gt;rv_scntl3
op_amp
l_int|0x07
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Deduce the value of controller sync period from scntl3.&n;&t;**&t;period is in tenths of nano-seconds.&n;&t;*/
id|idiv
op_assign
(paren
(paren
id|scntl3
op_rshift
l_int|4
)paren
op_amp
l_int|0x7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_logical_and
id|idiv
)paren
(brace
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
(brace
multiline_comment|/* Note: If extra data hold clocks are used,&n;&t;&t;&t; * the formulas below must be modified.&n;&t;&t;&t; * When scntl4 == 0, ST mode.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|scntl4
op_amp
l_int|0x80
)paren
id|tp-&gt;period
op_assign
(paren
l_int|2
op_star
id|div_10M
(braket
id|idiv
op_minus
l_int|1
)braket
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
r_else
id|tp-&gt;period
op_assign
(paren
l_int|4
op_star
id|div_10M
(braket
id|idiv
op_minus
l_int|1
)braket
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
)brace
r_else
id|tp-&gt;period
op_assign
(paren
(paren
(paren
id|sxfer
op_rshift
l_int|5
)paren
op_plus
l_int|4
)paren
op_star
id|div_10M
(braket
id|idiv
op_minus
l_int|1
)braket
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
)brace
r_else
id|tp-&gt;period
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/*&n;&t;**&t; Stop there if sync parameters are unchanged&n;&t;*/
r_if
c_cond
(paren
id|tp-&gt;sval
op_eq
id|sxfer
op_logical_and
id|tp-&gt;wval
op_eq
id|scntl3
op_logical_and
id|tp-&gt;uval
op_eq
id|scntl4
)paren
r_return
suffix:semicolon
id|tp-&gt;sval
op_assign
id|sxfer
suffix:semicolon
id|tp-&gt;wval
op_assign
id|scntl3
suffix:semicolon
id|tp-&gt;uval
op_assign
id|scntl4
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Bells and whistles   ;-)&n;&t;**&t;Donnot announce negotiations due to auto-sense, &n;&t;**&t;unless user really want us to be verbose. :)&n;&t;*/
r_if
c_cond
(paren
id|bootverbose
OL
l_int|2
op_logical_and
(paren
id|cp-&gt;host_flags
op_amp
id|HF_AUTO_SENSE
)paren
)paren
r_goto
id|next
suffix:semicolon
id|PRINT_TARGET
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
(brace
r_int
id|f10
op_assign
l_int|100000
op_lshift
(paren
id|tp-&gt;widedone
ques
c_cond
id|tp-&gt;widedone
op_minus
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_int
id|mb10
op_assign
(paren
id|f10
op_plus
id|tp-&gt;period
op_div
l_int|2
)paren
op_div
id|tp-&gt;period
suffix:semicolon
r_char
op_star
id|scsi
suffix:semicolon
multiline_comment|/*&n;&t;&t;**  Disable extended Sreq/Sack filtering&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|tp-&gt;period
op_le
l_int|2000
)paren
op_logical_and
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_and
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
id|OUTOFFB
(paren
id|nc_stest2
comma
id|EXT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Bells and whistles   ;-)&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;period
OL
l_int|250
)paren
id|scsi
op_assign
l_string|&quot;FAST-80&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;period
OL
l_int|500
)paren
id|scsi
op_assign
l_string|&quot;FAST-40&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;period
OL
l_int|1000
)paren
id|scsi
op_assign
l_string|&quot;FAST-20&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;period
OL
l_int|2000
)paren
id|scsi
op_assign
l_string|&quot;FAST-10&quot;
suffix:semicolon
r_else
id|scsi
op_assign
l_string|&quot;FAST-5&quot;
suffix:semicolon
id|printk
(paren
l_string|&quot;%s %sSCSI %d.%d MB/s (%d ns, offset %d)&bslash;n&quot;
comma
id|scsi
comma
id|tp-&gt;widedone
OG
l_int|1
ques
c_cond
l_string|&quot;WIDE &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|mb10
op_div
l_int|10
comma
id|mb10
op_mod
l_int|10
comma
id|tp-&gt;period
op_div
l_int|10
comma
id|offset
)paren
suffix:semicolon
)brace
r_else
id|printk
(paren
l_string|&quot;%sasynchronous.&bslash;n&quot;
comma
id|tp-&gt;widedone
OG
l_int|1
ques
c_cond
l_string|&quot;wide &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|next
suffix:colon
multiline_comment|/*&n;&t;**&t;set actual value and sync_status&n;&t;**&t;patch ALL ccbs of this target.&n;&t;*/
id|ncr_set_sync_wide_status
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Switch wide mode for current job and it&squot;s target&n;**&t;SCSI specs say: a SCSI device that accepts a WDTR &n;**&t;message shall reset the synchronous agreement to &n;**&t;asynchronous mode.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_setwide
r_static
r_void
id|ncr_setwide
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|wide
comma
id|u_char
id|ack
)paren
(brace
id|u_short
id|target
op_assign
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|u_char
id|scntl3
suffix:semicolon
id|u_char
id|sxfer
suffix:semicolon
m_assert
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
suffix:semicolon
m_assert
(paren
id|target
op_eq
(paren
id|cp-&gt;target
op_amp
l_int|0xf
)paren
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|tp-&gt;widedone
op_assign
id|wide
op_plus
l_int|1
suffix:semicolon
id|scntl3
op_assign
(paren
id|tp-&gt;wval
op_amp
(paren
op_complement
id|EWS
)paren
)paren
op_or
(paren
id|wide
ques
c_cond
id|EWS
suffix:colon
l_int|0
)paren
suffix:semicolon
id|sxfer
op_assign
id|ack
ques
c_cond
l_int|0
suffix:colon
id|tp-&gt;sval
suffix:semicolon
multiline_comment|/*&n;&t;**&t; Stop there if sync/wide parameters are unchanged&n;&t;*/
r_if
c_cond
(paren
id|tp-&gt;sval
op_eq
id|sxfer
op_logical_and
id|tp-&gt;wval
op_eq
id|scntl3
)paren
r_return
suffix:semicolon
id|tp-&gt;sval
op_assign
id|sxfer
suffix:semicolon
id|tp-&gt;wval
op_assign
id|scntl3
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Bells and whistles   ;-)&n;&t;*/
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
(brace
id|PRINT_TARGET
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scntl3
op_amp
id|EWS
)paren
id|printk
(paren
l_string|&quot;WIDE SCSI (16 bit) enabled.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;WIDE SCSI disabled.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;set actual value and sync_status&n;&t;**&t;patch ALL ccbs of this target.&n;&t;*/
id|ncr_set_sync_wide_status
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Switch sync/wide mode for current job and it&squot;s target&n;**&t;PPR negotiations only&n;**&n;**==========================================================&n;*/
DECL|function|ncr_setsyncwide
r_static
r_void
id|ncr_setsyncwide
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|scntl3
comma
id|u_char
id|sxfer
comma
id|u_char
id|scntl4
comma
id|u_char
id|wide
)paren
(brace
id|tcb_p
id|tp
suffix:semicolon
id|u_char
id|target
op_assign
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|u_char
id|idiv
suffix:semicolon
id|u_char
id|offset
suffix:semicolon
m_assert
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
suffix:semicolon
m_assert
(paren
id|target
op_eq
(paren
id|cp-&gt;target
op_amp
l_int|0xf
)paren
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|tp-&gt;widedone
op_assign
id|wide
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
(brace
id|offset
op_assign
id|sxfer
op_amp
l_int|0x3f
suffix:semicolon
multiline_comment|/* bits 5-0 */
id|scntl3
op_assign
(paren
id|scntl3
op_amp
l_int|0xf0
)paren
op_or
(paren
id|wide
ques
c_cond
id|EWS
suffix:colon
l_int|0
)paren
suffix:semicolon
id|scntl4
op_assign
(paren
id|scntl4
op_amp
l_int|0x80
)paren
suffix:semicolon
)brace
r_else
(brace
id|offset
op_assign
id|sxfer
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* bits 4-0 */
r_if
c_cond
(paren
op_logical_neg
id|scntl3
op_logical_or
op_logical_neg
id|offset
)paren
id|scntl3
op_assign
id|np-&gt;rv_scntl3
suffix:semicolon
id|scntl3
op_assign
(paren
id|scntl3
op_amp
l_int|0xf0
)paren
op_or
(paren
id|wide
ques
c_cond
id|EWS
suffix:colon
l_int|0
)paren
op_or
(paren
id|np-&gt;rv_scntl3
op_amp
l_int|0x07
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Deduce the value of controller sync period from scntl3.&n;&t;**&t;period is in tenths of nano-seconds.&n;&t;*/
id|idiv
op_assign
(paren
(paren
id|scntl3
op_rshift
l_int|4
)paren
op_amp
l_int|0x7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_logical_and
id|idiv
)paren
(brace
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
(brace
multiline_comment|/* Note: If extra data hold clocks are used,&n;&t;&t;&t; * the formulas below must be modified.&n;&t;&t;&t; * When scntl4 == 0, ST mode.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|scntl4
op_amp
l_int|0x80
)paren
id|tp-&gt;period
op_assign
(paren
l_int|2
op_star
id|div_10M
(braket
id|idiv
op_minus
l_int|1
)braket
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
r_else
id|tp-&gt;period
op_assign
(paren
l_int|4
op_star
id|div_10M
(braket
id|idiv
op_minus
l_int|1
)braket
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
)brace
r_else
id|tp-&gt;period
op_assign
(paren
(paren
(paren
id|sxfer
op_rshift
l_int|5
)paren
op_plus
l_int|4
)paren
op_star
id|div_10M
(braket
id|idiv
op_minus
l_int|1
)braket
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
)brace
r_else
id|tp-&gt;period
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/*&n;&t;**&t; Stop there if sync parameters are unchanged&n;&t;*/
r_if
c_cond
(paren
id|tp-&gt;sval
op_eq
id|sxfer
op_logical_and
id|tp-&gt;wval
op_eq
id|scntl3
op_logical_and
id|tp-&gt;uval
op_eq
id|scntl4
)paren
r_return
suffix:semicolon
id|tp-&gt;sval
op_assign
id|sxfer
suffix:semicolon
id|tp-&gt;wval
op_assign
id|scntl3
suffix:semicolon
id|tp-&gt;uval
op_assign
id|scntl4
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Bells and whistles   ;-)&n;&t;**&t;Donnot announce negotiations due to auto-sense, &n;&t;**&t;unless user really want us to be verbose. :)&n;&t;*/
r_if
c_cond
(paren
id|bootverbose
OL
l_int|2
op_logical_and
(paren
id|cp-&gt;host_flags
op_amp
id|HF_AUTO_SENSE
)paren
)paren
r_goto
id|next
suffix:semicolon
id|PRINT_TARGET
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
(brace
r_int
id|f10
op_assign
l_int|100000
op_lshift
(paren
id|tp-&gt;widedone
ques
c_cond
id|tp-&gt;widedone
op_minus
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_int
id|mb10
op_assign
(paren
id|f10
op_plus
id|tp-&gt;period
op_div
l_int|2
)paren
op_div
id|tp-&gt;period
suffix:semicolon
r_char
op_star
id|scsi
suffix:semicolon
multiline_comment|/*&n;&t;&t;**  Disable extended Sreq/Sack filtering&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|tp-&gt;period
op_le
l_int|2000
)paren
op_logical_and
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_and
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
id|OUTOFFB
(paren
id|nc_stest2
comma
id|EXT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Bells and whistles   ;-)&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;period
OL
l_int|250
)paren
id|scsi
op_assign
l_string|&quot;FAST-80&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;period
OL
l_int|500
)paren
id|scsi
op_assign
l_string|&quot;FAST-40&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;period
OL
l_int|1000
)paren
id|scsi
op_assign
l_string|&quot;FAST-20&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;period
OL
l_int|2000
)paren
id|scsi
op_assign
l_string|&quot;FAST-10&quot;
suffix:semicolon
r_else
id|scsi
op_assign
l_string|&quot;FAST-5&quot;
suffix:semicolon
id|printk
(paren
l_string|&quot;%s %sSCSI %d.%d MB/s (%d ns, offset %d)&bslash;n&quot;
comma
id|scsi
comma
id|tp-&gt;widedone
OG
l_int|1
ques
c_cond
l_string|&quot;WIDE &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|mb10
op_div
l_int|10
comma
id|mb10
op_mod
l_int|10
comma
id|tp-&gt;period
op_div
l_int|10
comma
id|offset
)paren
suffix:semicolon
)brace
r_else
id|printk
(paren
l_string|&quot;%sasynchronous.&bslash;n&quot;
comma
id|tp-&gt;widedone
OG
l_int|1
ques
c_cond
l_string|&quot;wide &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|next
suffix:colon
multiline_comment|/*&n;&t;**&t;set actual value and sync_status&n;&t;**&t;patch ALL ccbs of this target.&n;&t;*/
id|ncr_set_sync_wide_status
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Switch tagged mode for a target.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_setup_tags
r_static
r_void
id|ncr_setup_tags
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|ncr_lp
c_func
(paren
id|np
comma
id|tp
comma
id|ln
)paren
suffix:semicolon
id|u_short
id|reqtags
comma
id|maxdepth
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Just in case ...&n;&t;*/
r_if
c_cond
(paren
(paren
op_logical_neg
id|tp
)paren
op_logical_or
(paren
op_logical_neg
id|lp
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If SCSI device queue depth is not yet set, leave here.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;scdev_depth
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Donnot allow more tags than the SCSI driver can queue &n;&t;**&t;for this device.&n;&t;**&t;Donnot allow more tags than we can handle.&n;&t;*/
id|maxdepth
op_assign
id|lp-&gt;scdev_depth
suffix:semicolon
r_if
c_cond
(paren
id|maxdepth
OG
id|lp-&gt;maxnxs
)paren
id|maxdepth
op_assign
id|lp-&gt;maxnxs
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;maxtags
OG
id|maxdepth
)paren
id|lp-&gt;maxtags
op_assign
id|maxdepth
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;numtags
OG
id|maxdepth
)paren
id|lp-&gt;numtags
op_assign
id|maxdepth
suffix:semicolon
multiline_comment|/*&n;&t;**&t;only devices conformant to ANSI Version &gt;= 2&n;&t;**&t;only devices capable of tagged commands&n;&t;**&t;only if enabled by user ..&n;&t;*/
r_if
c_cond
(paren
(paren
id|lp-&gt;inq_byte7
op_amp
id|INQ7_QUEUE
)paren
op_logical_and
id|lp-&gt;numtags
OG
l_int|1
)paren
(brace
id|reqtags
op_assign
id|lp-&gt;numtags
suffix:semicolon
)brace
r_else
(brace
id|reqtags
op_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Update max number of tags&n;&t;*/
id|lp-&gt;numtags
op_assign
id|reqtags
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;numtags
OG
id|lp-&gt;maxtags
)paren
id|lp-&gt;maxtags
op_assign
id|lp-&gt;numtags
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If we want to switch tag mode, we must wait &n;&t;**&t;for no CCB to be active.&n;&t;*/
r_if
c_cond
(paren
id|reqtags
OG
l_int|1
op_logical_and
id|lp-&gt;usetags
)paren
(brace
multiline_comment|/* Stay in tagged mode    */
r_if
c_cond
(paren
id|lp-&gt;queuedepth
op_eq
id|reqtags
)paren
multiline_comment|/* Already announced&t;   */
r_return
suffix:semicolon
id|lp-&gt;queuedepth
op_assign
id|reqtags
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reqtags
op_le
l_int|1
op_logical_and
op_logical_neg
id|lp-&gt;usetags
)paren
(brace
multiline_comment|/* Stay in untagged mode  */
id|lp-&gt;queuedepth
op_assign
id|reqtags
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Want to switch tag mode */
r_if
c_cond
(paren
id|lp-&gt;busyccbs
)paren
multiline_comment|/* If not yet safe, return */
r_return
suffix:semicolon
id|lp-&gt;queuedepth
op_assign
id|reqtags
suffix:semicolon
id|lp-&gt;usetags
op_assign
id|reqtags
OG
l_int|1
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Patch the lun mini-script, according to tag mode.&n;&t;*/
id|lp-&gt;resel_task
op_assign
id|lp-&gt;usetags
ques
c_cond
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
c_func
(paren
id|np
comma
id|resel_tag
)paren
)paren
suffix:colon
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
c_func
(paren
id|np
comma
id|resel_notag
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Announce change to user.&n;&t;*/
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;usetags
)paren
id|printk
c_func
(paren
l_string|&quot;tagged command queue depth set to %d&bslash;n&quot;
comma
id|reqtags
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;tagged command queueing disabled&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*----------------------------------------------------&n;**&n;**&t;handle user commands&n;**&n;**----------------------------------------------------&n;*/
macro_line|#ifdef SCSI_NCR_USER_COMMAND_SUPPORT
DECL|function|ncr_usercmd
r_static
r_void
id|ncr_usercmd
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|t
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
r_int
id|ln
suffix:semicolon
id|u_long
id|size
suffix:semicolon
r_switch
c_cond
(paren
id|np-&gt;user.cmd
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
suffix:semicolon
r_case
id|UC_SETDEBUG
suffix:colon
macro_line|#ifdef SCSI_NCR_DEBUG_INFO_SUPPORT
id|ncr_debug
op_assign
id|np-&gt;user.data
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|UC_SETORDER
suffix:colon
id|np-&gt;order
op_assign
id|np-&gt;user.data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETVERBOSE
suffix:colon
id|np-&gt;verbose
op_assign
id|np-&gt;user.data
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
r_case
id|UC_CLEARPROF
suffix:colon
id|bzero
c_func
(paren
op_amp
id|np-&gt;profile
comma
r_sizeof
(paren
id|np-&gt;profile
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n;&t;&t;**&t;We assume that other commands apply to targets.&n;&t;&t;**&t;This should always be the case and avoid the below &n;&t;&t;**&t;4 lines to be repeated 5 times.&n;&t;&t;*/
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|np-&gt;user.target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|t
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|np-&gt;user.cmd
)paren
(brace
r_case
id|UC_SETSYNC
suffix:colon
id|tp-&gt;usrsync
op_assign
id|np-&gt;user.data
suffix:semicolon
id|ncr_negotiate
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETWIDE
suffix:colon
id|size
op_assign
id|np-&gt;user.data
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|np-&gt;maxwide
)paren
id|size
op_assign
id|np-&gt;maxwide
suffix:semicolon
id|tp-&gt;usrwide
op_assign
id|size
suffix:semicolon
id|ncr_negotiate
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETTAGS
suffix:colon
id|tp-&gt;usrtags
op_assign
id|np-&gt;user.data
suffix:semicolon
r_for
c_loop
(paren
id|ln
op_assign
l_int|0
suffix:semicolon
id|ln
OL
id|MAX_LUN
suffix:semicolon
id|ln
op_increment
)paren
(brace
id|lcb_p
id|lp
suffix:semicolon
id|lp
op_assign
id|ncr_lp
c_func
(paren
id|np
comma
id|tp
comma
id|ln
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_continue
suffix:semicolon
id|lp-&gt;numtags
op_assign
id|np-&gt;user.data
suffix:semicolon
id|lp-&gt;maxtags
op_assign
id|lp-&gt;numtags
suffix:semicolon
id|ncr_setup_tags
(paren
id|np
comma
id|t
comma
id|ln
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|UC_RESETDEV
suffix:colon
id|tp-&gt;to_reset
op_assign
l_int|1
suffix:semicolon
id|np-&gt;istat_sem
op_assign
id|SEM
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
op_or
id|SEM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_CLEARDEV
suffix:colon
r_for
c_loop
(paren
id|ln
op_assign
l_int|0
suffix:semicolon
id|ln
OL
id|MAX_LUN
suffix:semicolon
id|ln
op_increment
)paren
(brace
id|lcb_p
id|lp
suffix:semicolon
id|lp
op_assign
id|ncr_lp
c_func
(paren
id|np
comma
id|tp
comma
id|ln
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp
)paren
id|lp-&gt;to_clear
op_assign
l_int|1
suffix:semicolon
)brace
id|np-&gt;istat_sem
op_assign
id|SEM
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
op_or
id|SEM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETFLAG
suffix:colon
id|tp-&gt;usrflag
op_assign
id|np-&gt;user.data
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
id|np-&gt;user.cmd
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;ncr timeout handler.&n;**&n;**&n;**==========================================================&n;**&n;**&t;Misused to keep the driver running when&n;**&t;interrupts are not configured correctly.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_timeout
r_static
r_void
id|ncr_timeout
(paren
id|ncb_p
id|np
)paren
(brace
id|u_long
id|thistime
op_assign
id|ktime_get
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If release process in progress, let&squot;s go&n;&t;**&t;Set the release stage from 1 to 2 to synchronize&n;&t;**&t;with the release process.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;release_stage
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;release_stage
op_eq
l_int|1
)paren
id|np-&gt;release_stage
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_PCIQ_BROKEN_INTR
id|np-&gt;timer.expires
op_assign
id|ktime_get
c_func
(paren
(paren
id|HZ
op_plus
l_int|9
)paren
op_div
l_int|10
)paren
suffix:semicolon
macro_line|#else
id|np-&gt;timer.expires
op_assign
id|ktime_get
c_func
(paren
id|SCSI_NCR_TIMER_INTERVAL
)paren
suffix:semicolon
macro_line|#endif
id|add_timer
c_func
(paren
op_amp
id|np-&gt;timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If we are resetting the ncr, wait for settle_time before &n;&t;**&t;clearing it. Then command processing will be resumed.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;settle_time
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;settle_time
op_le
id|thistime
)paren
(brace
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: command processing resumed&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;settle_time
op_assign
l_int|0
suffix:semicolon
id|requeue_waiting_list
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Nothing to do for now, but that may come.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;lasttime
op_plus
l_int|4
op_star
id|HZ
OL
id|thistime
)paren
(brace
id|np-&gt;lasttime
op_assign
id|thistime
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_PCIQ_MAY_MISS_COMPLETIONS
multiline_comment|/*&n;&t;**&t;Some way-broken PCI bridges may lead to &n;&t;**&t;completions being lost when the clearing &n;&t;**&t;of the INTFLY flag by the CPU occurs &n;&t;**&t;concurrently with the chip raising this flag.&n;&t;**&t;If this ever happen, lost completions will &n;&t;**&t;be reaped here.&n;&t;*/
id|ncr_wakeup_done
c_func
(paren
id|np
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SCSI_NCR_PCIQ_BROKEN_INTR
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_istat
)paren
op_amp
(paren
id|INTF
op_or
id|SIP
op_or
id|DIP
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;Process pending interrupts.&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;{&quot;
)paren
suffix:semicolon
id|ncr_exception
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_PCIQ_BROKEN_INTR */
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;log message for real hard errors&n;**&n;**&t;&quot;ncr0 targ 0?: ERROR (ds:si) (so-si-sd) (sxfer/scntl3) @ name (dsp:dbc).&quot;&n;**&t;&quot;&t;      reg: r0 r1 r2 r3 r4 r5 r6 ..... rf.&quot;&n;**&n;**&t;exception register:&n;**&t;&t;ds:&t;dstat&n;**&t;&t;si:&t;sist&n;**&n;**&t;SCSI bus lines:&n;**&t;&t;so:&t;control lines as driver by NCR.&n;**&t;&t;si:&t;control lines as seen by NCR.&n;**&t;&t;sd:&t;scsi data lines as seen by NCR.&n;**&n;**&t;wide/fastmode:&n;**&t;&t;sxfer:&t;(see the manual)&n;**&t;&t;scntl3:&t;(see the manual)&n;**&n;**&t;current script command:&n;**&t;&t;dsp:&t;script adress (relative to start of script).&n;**&t;&t;dbc:&t;first word of script command.&n;**&n;**&t;First 24 register of the chip:&n;**&t;&t;r0..rf&n;**&n;**==========================================================&n;*/
DECL|function|ncr_log_hard_error
r_static
r_void
id|ncr_log_hard_error
c_func
(paren
id|ncb_p
id|np
comma
id|u_short
id|sist
comma
id|u_char
id|dstat
)paren
(brace
id|u_int32
id|dsp
suffix:semicolon
r_int
id|script_ofs
suffix:semicolon
r_int
id|script_size
suffix:semicolon
r_char
op_star
id|script_name
suffix:semicolon
id|u_char
op_star
id|script_base
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dsp
OG
id|np-&gt;p_script
op_logical_and
id|dsp
op_le
id|np-&gt;p_script
op_plus
r_sizeof
(paren
r_struct
id|script
)paren
)paren
(brace
id|script_ofs
op_assign
id|dsp
op_minus
id|np-&gt;p_script
suffix:semicolon
id|script_size
op_assign
r_sizeof
(paren
r_struct
id|script
)paren
suffix:semicolon
id|script_base
op_assign
(paren
id|u_char
op_star
)paren
id|np-&gt;script0
suffix:semicolon
id|script_name
op_assign
l_string|&quot;script&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|np-&gt;p_scripth
OL
id|dsp
op_logical_and
id|dsp
op_le
id|np-&gt;p_scripth
op_plus
r_sizeof
(paren
r_struct
id|scripth
)paren
)paren
(brace
id|script_ofs
op_assign
id|dsp
op_minus
id|np-&gt;p_scripth
suffix:semicolon
id|script_size
op_assign
r_sizeof
(paren
r_struct
id|scripth
)paren
suffix:semicolon
id|script_base
op_assign
(paren
id|u_char
op_star
)paren
id|np-&gt;scripth0
suffix:semicolon
id|script_name
op_assign
l_string|&quot;scripth&quot;
suffix:semicolon
)brace
r_else
(brace
id|script_ofs
op_assign
id|dsp
suffix:semicolon
id|script_size
op_assign
l_int|0
suffix:semicolon
id|script_base
op_assign
l_int|0
suffix:semicolon
id|script_name
op_assign
l_string|&quot;mem&quot;
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0x0f
comma
id|dstat
comma
id|sist
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_socl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sbcl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sbdl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sxfer
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_scntl3
)paren
comma
id|script_name
comma
id|script_ofs
comma
(paren
r_int
)paren
id|INL
(paren
id|nc_dbc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|script_ofs
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
r_int
)paren
id|script_ofs
OL
id|script_size
)paren
(brace
id|printk
(paren
l_string|&quot;%s: script cmd = %08x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|scr_to_cpu
c_func
(paren
(paren
r_int
)paren
op_star
(paren
id|ncrcmd
op_star
)paren
(paren
id|script_base
op_plus
id|script_ofs
)paren
)paren
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;%s: regdump:&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|24
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot; %02x&quot;
comma
(paren
r_int
)paren
id|INB_OFF
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*============================================================&n;**&n;**&t;ncr chip exception handler.&n;**&n;**============================================================&n;**&n;**&t;In normal situations, interrupt conditions occur one at &n;**&t;a time. But when something bad happens on the SCSI BUS, &n;**&t;the chip may raise several interrupt flags before &n;**&t;stopping and interrupting the CPU. The additionnal &n;**&t;interrupt flags are stacked in some extra registers &n;**&t;after the SIP and/or DIP flag has been raised in the &n;**&t;ISTAT. After the CPU has read the interrupt condition &n;**&t;flag from SIST or DSTAT, the chip unstacks the other &n;**&t;interrupt flags and sets the corresponding bits in &n;**&t;SIST or DSTAT. Since the chip starts stacking once the &n;**&t;SIP or DIP flag is set, there is a small window of time &n;**&t;where the stacking does not occur.&n;**&n;**&t;Typically, multiple interrupt conditions may happen in &n;**&t;the following situations:&n;**&n;**&t;- SCSI parity error + Phase mismatch  (PAR|MA)&n;**&t;  When an parity error is detected in input phase &n;**&t;  and the device switches to msg-in phase inside a &n;**&t;  block MOV.&n;**&t;- SCSI parity error + Unexpected disconnect (PAR|UDC)&n;**&t;  When a stupid device does not want to handle the &n;**&t;  recovery of an SCSI parity error.&n;**&t;- Some combinations of STO, PAR, UDC, ...&n;**&t;  When using non compliant SCSI stuff, when user is &n;**&t;  doing non compliant hot tampering on the BUS, when &n;**&t;  something really bad happens to a device, etc ...&n;**&n;**&t;The heuristic suggested by SYMBIOS to handle &n;**&t;multiple interrupts is to try unstacking all &n;**&t;interrupts conditions and to handle them on some &n;**&t;priority based on error severity.&n;**&t;This will work when the unstacking has been &n;**&t;successful, but we cannot be 100 % sure of that, &n;**&t;since the CPU may have been faster to unstack than &n;**&t;the chip is able to stack. Hmmm ... But it seems that &n;**&t;such a situation is very unlikely to happen.&n;**&n;**&t;If this happen, for example STO catched by the CPU &n;**&t;then UDC happenning before the CPU have restarted &n;**&t;the SCRIPTS, the driver may wrongly complete the &n;**&t;same command on UDC, since the SCRIPTS didn&squot;t restart &n;**&t;and the DSA still points to the same command.&n;**&t;We avoid this situation by setting the DSA to an &n;**&t;invalid value when the CCB is completed and before &n;**&t;restarting the SCRIPTS.&n;**&n;**&t;Another issue is that we need some section of our &n;**&t;recovery procedures to be somehow uninterruptible and &n;**&t;that the SCRIPTS processor does not provides such a &n;**&t;feature. For this reason, we handle recovery preferently &n;**&t;from the C code&t;and check against some SCRIPTS &n;**&t;critical sections from the C code.&n;**&n;**&t;Hopefully, the interrupt handling of the driver is now &n;**&t;able to resist to weird BUS error conditions, but donnot &n;**&t;ask me for any guarantee that it will never fail. :-)&n;**&t;Use at your own decision and risk.&n;**&n;**============================================================&n;*/
DECL|function|ncr_exception
r_void
id|ncr_exception
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|istat
comma
id|istatc
suffix:semicolon
id|u_char
id|dstat
suffix:semicolon
id|u_short
id|sist
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef SCSI_NCR_OPTIMIZE_896_1
multiline_comment|/*&n;&t;**&t;This optimization when used with a 896 that handles &n;&t;**&t;phase mismatch from the SCRIPTS allows to only do &n;&t;**&t;PCI memory writes transactions from the CPU and so to &n;&t;**&t;take advantage of PCI posted writes.&n;&t;**&t;Who wants his 500 MHz CPU to wait several micro-seconds &n;&t;**&t;for the PCI BUS to be granted when this can be avoided?&n;&t;**&t;I don&squot;t, even for my slow 233 MHz PII. :-)&n;&t;**&n;&t;**&t;We assume we have been called for command completion.&n;&t;**&t;If no completion found, go with normal handling.&n;&t;**&t;Ordering is ensured by the SCRIPTS performing a read &n;&t;**&t;from main memory prior to raising INTFLY.&n;&t;**&t;We have to raise SIGP since the chip may be currently &n;&t;**&t;going to a wait reselect instruction. IMO, SIGP should &n;&t;**&t;not be clearable in ISTAT since it can be polled and &n;&t;**&t;cleared by reading CTEST2. This tiny chip misdesign is a &n;&t;**&t;penalty here.&n;&t;**&n;&t;**&t;The MA interrupt and interrupt sharing may also have &n;&t;**&t;adverse effects on this optimization, so we only want &n;&t;**&t;to use it if it is enabled by user.&n;&t;**&t;(BTW, this optimization seems to even have some goodness &n;&t;**&t;with my 895 that unfortunately suffers of the MA int.).&n;&t;*/
r_if
c_cond
(paren
id|driver_setup.optimize
op_amp
l_int|1
)paren
(brace
id|OUTB
c_func
(paren
id|nc_istat
comma
(paren
id|INTF
op_or
id|SIGP
op_or
id|np-&gt;istat_sem
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ncr_wakeup_done
(paren
id|np
)paren
)paren
(brace
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
op_increment
id|np-&gt;profile.num_fly
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif /* SCSI_NCR_OPTIMIZE_896_1 */
multiline_comment|/*&n;&t;**&t;interrupt on the fly ?&n;&t;**&n;&t;**&t;For bridges that donnot flush posted writes &n;&t;**&t;in the reverse direction on read, a dummy read &n;&t;**&t;may help not to miss completions.&n;&t;*/
id|istat
op_assign
id|INB
(paren
id|nc_istat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|istat
op_amp
id|INTF
)paren
(brace
id|OUTB
(paren
id|nc_istat
comma
(paren
id|istat
op_amp
id|SIGP
)paren
op_or
id|INTF
op_or
id|np-&gt;istat_sem
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PCIQ_MAY_NOT_FLUSH_PW_UPSTREAM
id|istat
op_assign
id|INB
(paren
id|nc_istat
)paren
suffix:semicolon
multiline_comment|/* DUMMY READ */
macro_line|#endif
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;F &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_wakeup_done
(paren
id|np
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
op_increment
id|np-&gt;profile.num_fly
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|istat
op_amp
(paren
id|SIP
op_or
id|DIP
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
op_increment
id|np-&gt;profile.num_int
suffix:semicolon
macro_line|#endif
macro_line|#if 0&t;/* We should never get this one */
r_if
c_cond
(paren
id|istat
op_amp
id|CABRT
)paren
id|OUTB
(paren
id|nc_istat
comma
id|CABRT
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Steinbach&squot;s Guideline for Systems Programming:&n;&t;**&t;Never test for an error condition you don&squot;t know how to handle.&n;&t;*/
multiline_comment|/*========================================================&n;&t;**&t;PAR and MA interrupts may occur at the same time,&n;&t;**&t;and we need to know of both in order to handle &n;&t;**&t;this situation properly. We try to unstack SCSI &n;&t;**&t;interrupts for that reason. BTW, I dislike a LOT &n;&t;**&t;such a loop inside the interrupt routine.&n;&t;**&t;Even if DMA interrupt stacking is very unlikely to &n;&t;**&t;happen, we also try unstacking these ones, since &n;&t;**&t;this has no performance impact.&n;&t;**=========================================================&n;&t;*/
id|sist
op_assign
l_int|0
suffix:semicolon
id|dstat
op_assign
l_int|0
suffix:semicolon
id|istatc
op_assign
id|istat
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|istatc
op_amp
id|SIP
)paren
id|sist
op_or_assign
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|istatc
op_amp
id|DIP
)paren
id|dstat
op_or_assign
id|INB
(paren
id|nc_dstat
)paren
suffix:semicolon
id|istatc
op_assign
id|INB
(paren
id|nc_istat
)paren
suffix:semicolon
id|istat
op_or_assign
id|istatc
suffix:semicolon
)brace
r_while
c_loop
(paren
id|istatc
op_amp
(paren
id|SIP
op_or
id|DIP
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;&lt;%d|%x:%x|%x:%x&gt;&quot;
comma
(paren
r_int
)paren
id|INB
c_func
(paren
id|nc_scr0
)paren
comma
id|dstat
comma
id|sist
comma
(paren
r_int
)paren
id|INL
c_func
(paren
id|nc_dsp
)paren
comma
(paren
r_int
)paren
id|INL
c_func
(paren
id|nc_dbc
)paren
)paren
suffix:semicolon
multiline_comment|/*========================================================&n;&t;**&t;First, interrupts we want to service cleanly.&n;&t;**&n;&t;**&t;Phase mismatch (MA) is the most frequent interrupt &n;&t;**&t;for chip earlier than the 896 and so we have to service &n;&t;**&t;it as quickly as possible.&n;&t;**&t;A SCSI parity error (PAR) may be combined with a phase &n;&t;**&t;mismatch condition (MA).&n;&t;**&t;Programmed interrupts (SIR) are used to call the C code &n;&t;**&t;from SCRIPTS.&n;&t;**&t;The single step interrupt (SSI) is not used in this &n;&t;**&t;driver.&n;&t;**=========================================================&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|sist
op_amp
(paren
id|STO
op_or
id|GEN
op_or
id|HTH
op_or
id|SGE
op_or
id|UDC
op_or
id|SBMC
op_or
id|RST
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|IID
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|sist
op_amp
id|PAR
)paren
id|ncr_int_par
(paren
id|np
comma
id|sist
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sist
op_amp
id|MA
)paren
id|ncr_int_ma
(paren
id|np
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dstat
op_amp
id|SIR
)paren
id|ncr_int_sir
(paren
id|np
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dstat
op_amp
id|SSI
)paren
id|OUTONB
(paren
id|nc_dcntl
comma
(paren
id|STD
op_or
id|NOCOM
)paren
)paren
suffix:semicolon
r_else
r_goto
id|unknown_int
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*========================================================&n;&t;**&t;Now, interrupts that donnot happen in normal &n;&t;**&t;situations and that we may need to recover from.&n;&t;**&n;&t;**&t;On SCSI RESET (RST), we reset everything.&n;&t;**&t;On SCSI BUS MODE CHANGE (SBMC), we complete all &n;&t;**&t;active CCBs with RESET status, prepare all devices &n;&t;**&t;for negotiating again and restart the SCRIPTS.&n;&t;**&t;On STO and UDC, we complete the CCB with the corres- &n;&t;**&t;ponding status and restart the SCRIPTS.&n;&t;**=========================================================&n;&t;*/
r_if
c_cond
(paren
id|sist
op_amp
id|RST
)paren
(brace
id|ncr_init
(paren
id|np
comma
l_int|1
comma
id|bootverbose
ques
c_cond
l_string|&quot;scsi reset&quot;
suffix:colon
l_int|NULL
comma
id|HS_RESET
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
id|OUTB
(paren
id|nc_ctest3
comma
id|np-&gt;rv_ctest3
op_or
id|CLF
)paren
suffix:semicolon
multiline_comment|/* clear dma fifo  */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
multiline_comment|/* clear scsi fifo */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sist
op_amp
(paren
id|GEN
op_or
id|HTH
op_or
id|SGE
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|IID
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|sist
op_amp
id|SBMC
)paren
id|ncr_int_sbmc
(paren
id|np
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sist
op_amp
id|STO
)paren
id|ncr_int_sto
(paren
id|np
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sist
op_amp
id|UDC
)paren
id|ncr_int_udc
(paren
id|np
)paren
suffix:semicolon
r_else
r_goto
id|unknown_int
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*=========================================================&n;&t;**&t;Now, interrupts we are not able to recover cleanly.&n;&t;**&n;&t;**&t;Do the register dump.&n;&t;**&t;Log message for hard errors.&n;&t;**&t;Reset everything.&n;&t;**=========================================================&n;&t;*/
r_if
c_cond
(paren
id|ktime_exp
c_func
(paren
id|np-&gt;regtime
)paren
)paren
(brace
id|np-&gt;regtime
op_assign
id|ktime_get
c_func
(paren
l_int|10
op_star
id|HZ
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|np-&gt;regdump
)paren
suffix:semicolon
id|i
op_increment
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|np-&gt;regdump
)paren
(braket
id|i
)braket
op_assign
id|INB_OFF
c_func
(paren
id|i
)paren
suffix:semicolon
id|np-&gt;regdump.nc_dstat
op_assign
id|dstat
suffix:semicolon
id|np-&gt;regdump.nc_sist
op_assign
id|sist
suffix:semicolon
)brace
suffix:semicolon
id|ncr_log_hard_error
c_func
(paren
id|np
comma
id|sist
comma
id|dstat
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
(brace
id|u_char
id|ctest4_o
comma
id|ctest4_m
suffix:semicolon
id|u_char
id|shadow
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Get shadow register data &n;&t;&t; * Write 1 to ctest4&n;&t;&t; */
id|ctest4_o
op_assign
id|INB
c_func
(paren
id|nc_ctest4
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_ctest4
comma
id|ctest4_o
op_or
l_int|0x10
)paren
suffix:semicolon
id|ctest4_m
op_assign
id|INB
c_func
(paren
id|nc_ctest4
)paren
suffix:semicolon
id|shadow
op_assign
id|INW_OFF
c_func
(paren
l_int|0x42
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_ctest4
comma
id|ctest4_o
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: ctest4/sist original 0x%x/0x%X  mod: 0x%X/0x%x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|ctest4_o
comma
id|sist
comma
id|ctest4_m
comma
id|shadow
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sist
op_amp
(paren
id|GEN
op_or
id|HTH
op_or
id|SGE
)paren
)paren
op_logical_or
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|IID
)paren
)paren
)paren
(brace
id|ncr_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
id|unknown_int
suffix:colon
multiline_comment|/*=========================================================&n;&t;**&t;We just miss the cause of the interrupt. :(&n;&t;**&t;Print a message. The timeout will do the real work.&n;&t;**=========================================================&n;&t;*/
id|printk
c_func
(paren
l_string|&quot;%s: unknown interrupt(s) ignored, &quot;
l_string|&quot;ISTAT=0x%x DSTAT=0x%x SIST=0x%x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|istat
comma
id|dstat
comma
id|sist
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;generic recovery from scsi interrupt&n;**&n;**==========================================================&n;**&n;**&t;The doc says that when the chip gets an SCSI interrupt,&n;**&t;it tries to stop in an orderly fashion, by completing &n;**&t;an instruction fetch that had started or by flushing &n;**&t;the DMA fifo for a write to memory that was executing.&n;**&t;Such a fashion is not enough to know if the instruction &n;**&t;that was just before the current DSP value has been &n;**&t;executed or not.&n;**&n;**&t;There are 3 small SCRIPTS sections that deal with the &n;**&t;start queue and the done queue that may break any &n;**&t;assomption from the C code if we are interrupted &n;**&t;inside, so we reset if it happens. Btw, since these &n;**&t;SCRIPTS sections are executed while the SCRIPTS hasn&squot;t &n;**&t;started SCSI operations, it is very unlikely to happen.&n;**&n;**&t;All the driver data structures are supposed to be &n;**&t;allocated from the same 4 GB memory window, so there &n;**&t;is a 1 to 1 relationship between DSA and driver data &n;**&t;structures. Since we are careful :) to invalidate the &n;**&t;DSA when we complete a command or when the SCRIPTS &n;**&t;pushes a DSA into a queue, we can trust it when it &n;**&t;points to a CCB.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_recover_scsi_int
r_static
r_void
id|ncr_recover_scsi_int
(paren
id|ncb_p
id|np
comma
id|u_char
id|hsts
)paren
(brace
id|u_int32
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
id|u_int32
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|ccb_p
id|cp
op_assign
id|ncr_ccb_from_dsa
c_func
(paren
id|np
comma
id|dsa
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If we haven&squot;t been interrupted inside the SCRIPTS &n;&t;**&t;critical pathes, we can safely restart the SCRIPTS &n;&t;**&t;and trust the DSA value if it matches a CCB.&n;&t;*/
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|dsp
OG
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|getjob_begin
)paren
op_logical_and
id|dsp
OL
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|getjob_end
)paren
op_plus
l_int|1
)paren
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|dsp
OG
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|ungetjob
)paren
op_logical_and
id|dsp
OL
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|reselect
)paren
op_plus
l_int|1
)paren
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|dsp
OG
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|sel_for_abort
)paren
op_logical_and
id|dsp
OL
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|sel_for_abort_1
)paren
op_plus
l_int|1
)paren
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|dsp
OG
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|done
)paren
op_logical_and
id|dsp
OL
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|done_end
)paren
op_plus
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|cp
)paren
(brace
id|cp-&gt;host_status
op_assign
id|hsts
suffix:semicolon
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
)brace
id|OUTL
(paren
id|nc_dsa
comma
id|DSA_INVALID
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_ctest3
comma
id|np-&gt;rv_ctest3
op_or
id|CLF
)paren
suffix:semicolon
multiline_comment|/* clear dma fifo  */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
multiline_comment|/* clear scsi fifo */
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|start
)paren
)paren
suffix:semicolon
)brace
r_else
r_goto
id|reset_all
suffix:semicolon
r_return
suffix:semicolon
id|reset_all
suffix:colon
id|ncr_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip exception handler for selection timeout&n;**&n;**==========================================================&n;**&n;**&t;There seems to be a bug in the 53c810.&n;**&t;Although a STO-Interrupt is pending,&n;**&t;it continues executing script commands.&n;**&t;But it will fail and interrupt (IID) on&n;**&t;the next instruction where it&squot;s looking&n;**&t;for a valid phase.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_sto
r_void
id|ncr_int_sto
(paren
id|ncb_p
id|np
)paren
(brace
id|u_int32
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;T&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dsp
op_eq
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|wf_sel_done
)paren
op_plus
l_int|8
op_logical_or
op_logical_neg
(paren
id|driver_setup.recovery
op_amp
l_int|1
)paren
)paren
id|ncr_recover_scsi_int
c_func
(paren
id|np
comma
id|HS_SEL_TIMEOUT
)paren
suffix:semicolon
r_else
id|ncr_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip exception handler for unexpected disconnect&n;**&n;**==========================================================&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_udc
r_void
id|ncr_int_udc
(paren
id|ncb_p
id|np
)paren
(brace
id|u_int32
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|ccb_p
id|cp
op_assign
id|ncr_ccb_from_dsa
c_func
(paren
id|np
comma
id|dsa
)paren
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Fix Up. Some disks respond to a PPR negotation with&n;&t; * a bus free instead of a message reject. &n;&t; * Disable ppr negotiation if this is first time&n;&t; * tried ppr negotiation.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;ppr_negotiation
op_eq
l_int|1
)paren
id|tp-&gt;ppr_negotiation
op_assign
l_int|0
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: unexpected disconnect&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|ncr_recover_scsi_int
c_func
(paren
id|np
comma
id|HS_UNEXPECTED
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip exception handler for SCSI bus mode change&n;**&n;**==========================================================&n;**&n;**&t;spi2-r12 11.2.3 says a transceiver mode change must &n;**&t;generate a reset event and a device that detects a reset &n;**&t;event shall initiate a hard reset. It says also that a&n;**&t;device that detects a mode change shall set data transfer &n;**&t;mode to eight bit asynchronous, etc...&n;**&t;So, just resetting should be enough.&n;**&t; &n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_sbmc
r_static
r_void
id|ncr_int_sbmc
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|scsi_mode
op_assign
id|INB
(paren
id|nc_stest4
)paren
op_amp
id|SMODE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: SCSI bus mode change from %x to %x.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;scsi_mode
comma
id|scsi_mode
)paren
suffix:semicolon
id|np-&gt;scsi_mode
op_assign
id|scsi_mode
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Suspend command processing for 1 second and &n;&t;**&t;reinitialize all except the chip.&n;&t;*/
id|np-&gt;settle_time
op_assign
id|ktime_get
c_func
(paren
l_int|1
op_star
id|HZ
)paren
suffix:semicolon
id|ncr_init
(paren
id|np
comma
l_int|0
comma
id|bootverbose
ques
c_cond
l_string|&quot;scsi mode change&quot;
suffix:colon
l_int|NULL
comma
id|HS_RESET
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip exception handler for SCSI parity error.&n;**&n;**==========================================================&n;**&n;**&t;When the chip detects a SCSI parity error and is &n;**&t;currently executing a (CH)MOV instruction, it does &n;**&t;not interrupt immediately, but tries to finish the &n;**&t;transfer of the current scatter entry before &n;**&t;interrupting. The following situations may occur:&n;**&n;**&t;- The complete scatter entry has been transferred &n;**&t;  without the device having changed phase.&n;**&t;  The chip will then interrupt with the DSP pointing &n;**&t;  to the instruction that follows the MOV.&n;**&n;**&t;- A phase mismatch occurs before the MOV finished &n;**&t;  and phase errors are to be handled by the C code.&n;**&t;  The chip will then interrupt with both PAR and MA &n;**&t;  conditions set.&n;**&n;**&t;- A phase mismatch occurs before the MOV finished and &n;**&t;  phase errors are to be handled by SCRIPTS (895A or 896).&n;**&t;  The chip will load the DSP with the phase mismatch &n;**&t;  JUMP address and interrupt the host processor.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_par
r_static
r_void
id|ncr_int_par
(paren
id|ncb_p
id|np
comma
id|u_short
id|sist
)paren
(brace
id|u_char
id|hsts
op_assign
id|INB
(paren
id|HS_PRT
)paren
suffix:semicolon
id|u_int32
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
id|u_int32
id|dbc
op_assign
id|INL
(paren
id|nc_dbc
)paren
suffix:semicolon
id|u_int32
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|u_char
id|sbcl
op_assign
id|INB
(paren
id|nc_sbcl
)paren
suffix:semicolon
id|u_char
id|cmd
op_assign
id|dbc
op_rshift
l_int|24
suffix:semicolon
r_int
id|phase
op_assign
id|cmd
op_amp
l_int|7
suffix:semicolon
id|ccb_p
id|cp
op_assign
id|ncr_ccb_from_dsa
c_func
(paren
id|np
comma
id|dsa
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: SCSI parity error detected: SCR1=%d DBC=%x SBCL=%x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|hsts
comma
id|dbc
comma
id|sbcl
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Check that the chip is connected to the SCSI BUS.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|INB
(paren
id|nc_scntl1
)paren
op_amp
id|ISCON
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver_setup.recovery
op_amp
l_int|1
)paren
)paren
(brace
id|ncr_recover_scsi_int
c_func
(paren
id|np
comma
id|HS_FAIL
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_goto
id|reset_all
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If the nexus is not clearly identified, reset the bus.&n;&t;**&t;We will try to do better later.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_goto
id|reset_all
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Check instruction was a MOV, direction was INPUT and &n;&t;**&t;ATN is asserted.&n;&t;*/
r_if
c_cond
(paren
(paren
id|cmd
op_amp
l_int|0xc0
)paren
op_logical_or
op_logical_neg
(paren
id|phase
op_amp
l_int|1
)paren
op_logical_or
op_logical_neg
(paren
id|sbcl
op_amp
l_int|0x8
)paren
)paren
r_goto
id|reset_all
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Keep track of the parity error.&n;&t;*/
id|OUTONB
(paren
id|HF_PRT
comma
id|HF_EXT_ERR
)paren
suffix:semicolon
id|cp-&gt;xerr_status
op_or_assign
id|XE_PARITY_ERR
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Prepare the message to send to the device.&n;&t;*/
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
(paren
id|phase
op_eq
l_int|7
)paren
ques
c_cond
id|M_PARITY
suffix:colon
id|M_ID_ERROR
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_INTEGRITY_CHECKING
multiline_comment|/*&n;&t;**&t;Save error message. For integrity check use only.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;check_integrity
)paren
id|np-&gt;check_integ_par
op_assign
id|np-&gt;msgout
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;If the old phase was DATA IN or DT DATA IN phase, &n;&t;** &t;we have to deal with the 3 situations described above.&n;&t;**&t;For other input phases (MSG IN and STATUS), the device &n;&t;**&t;must resend the whole thing that failed parity checking &n;&t;**&t;or signal error. So, jumping to dispatcher should be OK.&n;&t;*/
r_if
c_cond
(paren
(paren
id|phase
op_eq
l_int|1
)paren
op_logical_or
(paren
id|phase
op_eq
l_int|5
)paren
)paren
(brace
multiline_comment|/* Phase mismatch handled by SCRIPTS */
r_if
c_cond
(paren
id|dsp
op_eq
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|pm_handle
)paren
)paren
id|OUTL
(paren
id|nc_dsp
comma
id|dsp
)paren
suffix:semicolon
multiline_comment|/* Phase mismatch handled by the C code */
r_else
r_if
c_cond
(paren
id|sist
op_amp
id|MA
)paren
id|ncr_int_ma
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/* No phase mismatch occurred */
r_else
(brace
id|OUTL
(paren
id|nc_temp
comma
id|dsp
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|dispatch
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|reset_all
suffix:colon
id|ncr_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;ncr chip exception handler for phase errors.&n;**&n;**&n;**==========================================================&n;**&n;**&t;We have to construct a new transfer descriptor,&n;**&t;to transfer the rest of the current block.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_ma
r_static
r_void
id|ncr_int_ma
(paren
id|ncb_p
id|np
)paren
(brace
id|u_int32
id|dbc
suffix:semicolon
id|u_int32
id|rest
suffix:semicolon
id|u_int32
id|dsp
suffix:semicolon
id|u_int32
id|dsa
suffix:semicolon
id|u_int32
id|nxtdsp
suffix:semicolon
id|u_int32
op_star
id|vdsp
suffix:semicolon
id|u_int32
id|oadr
comma
id|olen
suffix:semicolon
id|u_int32
op_star
id|tblp
suffix:semicolon
id|u_int32
id|newcmd
suffix:semicolon
id|u_int
id|delta
suffix:semicolon
id|u_char
id|cmd
suffix:semicolon
id|u_char
id|hflags
comma
id|hflags0
suffix:semicolon
r_struct
id|pm_ctx
op_star
id|pm
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
op_increment
id|np-&gt;profile.num_break
suffix:semicolon
macro_line|#endif
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
id|dbc
op_assign
id|INL
(paren
id|nc_dbc
)paren
suffix:semicolon
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|cmd
op_assign
id|dbc
op_rshift
l_int|24
suffix:semicolon
id|rest
op_assign
id|dbc
op_amp
l_int|0xffffff
suffix:semicolon
id|delta
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;locate matching cp.&n;&t;*/
id|cp
op_assign
id|ncr_ccb_from_dsa
c_func
(paren
id|np
comma
id|dsa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
id|printk
c_func
(paren
l_string|&quot;CCB = %2x %2x %2x %2x %2x %2x&bslash;n&quot;
comma
id|cp-&gt;cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|cp-&gt;cmd-&gt;cmnd
(braket
l_int|1
)braket
comma
id|cp-&gt;cmd-&gt;cmnd
(braket
l_int|2
)braket
comma
id|cp-&gt;cmd-&gt;cmnd
(braket
l_int|3
)braket
comma
id|cp-&gt;cmd-&gt;cmnd
(braket
l_int|4
)braket
comma
id|cp-&gt;cmd-&gt;cmnd
(braket
l_int|5
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Donnot take into account dma fifo and various buffers in &n;&t;**&t;INPUT phase since the chip flushes everything before &n;&t;**&t;raising the MA interrupt for interrupted INPUT phases.&n;&t;**&t;For DATA IN phase, we will check for the SWIDE later.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
id|cmd
op_amp
l_int|7
)paren
op_eq
l_int|1
)paren
op_logical_or
(paren
(paren
id|cmd
op_amp
l_int|7
)paren
op_eq
l_int|5
)paren
)paren
)paren
(brace
id|u_int32
id|dfifo
suffix:semicolon
id|u_char
id|ss0
comma
id|ss2
suffix:semicolon
multiline_comment|/*&n;&t;&t;**  If C1010, DFBC contains number of bytes in DMA fifo.&n;&t;&t;**  else read DFIFO, CTEST[4-6] using 1 PCI bus ownership.&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
id|delta
op_assign
id|INL
c_func
(paren
id|nc_dfbc
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_else
(brace
id|dfifo
op_assign
id|INL
c_func
(paren
id|nc_dfifo
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;**&t;Calculate remaining bytes in DMA fifo.&n;&t;&t;&t;**&t;C1010 - always large fifo, value in dfbc&n;&t;&t;&t;**&t;Otherwise, (CTEST5 = dfifo &gt;&gt; 16)&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|dfifo
op_amp
(paren
id|DFS
op_lshift
l_int|16
)paren
)paren
id|delta
op_assign
(paren
(paren
(paren
(paren
id|dfifo
op_rshift
l_int|8
)paren
op_amp
l_int|0x300
)paren
op_or
(paren
id|dfifo
op_amp
l_int|0xff
)paren
)paren
op_minus
id|rest
)paren
op_amp
l_int|0x3ff
suffix:semicolon
r_else
id|delta
op_assign
(paren
(paren
id|dfifo
op_amp
l_int|0xff
)paren
op_minus
id|rest
)paren
op_amp
l_int|0x7f
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;**&t;The data in the dma fifo has not been &n;&t;&t;&t;**&t;transferred to the target -&gt; add the amount &n;&t;&t;&t;**&t;to the rest and clear the data.&n;&t;&t;&t;**&t;Check the sstat2 register in case of wide&n;&t;&t;&t;**&t;transfer.&n;&t;&t;&t;*/
)brace
id|rest
op_add_assign
id|delta
suffix:semicolon
id|ss0
op_assign
id|INB
(paren
id|nc_sstat0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss0
op_amp
id|OLF
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_and
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
op_logical_and
(paren
id|ss0
op_amp
id|ORF
)paren
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_logical_and
(paren
id|cp-&gt;phys.select.sel_scntl3
op_amp
id|EWS
)paren
)paren
(brace
id|ss2
op_assign
id|INB
(paren
id|nc_sstat2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss2
op_amp
id|OLF1
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_and
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
op_logical_and
(paren
id|ss2
op_amp
id|ORF
)paren
)paren
id|rest
op_increment
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Clear fifos.&n;&t;&t;*/
id|OUTB
(paren
id|nc_ctest3
comma
id|np-&gt;rv_ctest3
op_or
id|CLF
)paren
suffix:semicolon
multiline_comment|/* dma fifo  */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
multiline_comment|/* scsi fifo */
)brace
multiline_comment|/*&n;&t;**&t;log the information&n;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
(paren
id|DEBUG_TINY
op_or
id|DEBUG_PHASE
)paren
)paren
id|printk
(paren
l_string|&quot;P%x%x RL=%d D=%d &quot;
comma
id|cmd
op_amp
l_int|7
comma
id|INB
c_func
(paren
id|nc_sbcl
)paren
op_amp
l_int|7
comma
(paren
r_int
)paren
id|rest
comma
(paren
r_int
)paren
id|delta
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;try to find the interrupted script command,&n;&t;**&t;and the address at which to continue.&n;&t;*/
id|vdsp
op_assign
l_int|0
suffix:semicolon
id|nxtdsp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dsp
OG
id|np-&gt;p_script
op_logical_and
id|dsp
op_le
id|np-&gt;p_script
op_plus
r_sizeof
(paren
r_struct
id|script
)paren
)paren
(brace
id|vdsp
op_assign
(paren
id|u_int32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|np-&gt;script0
op_plus
(paren
id|dsp
op_minus
id|np-&gt;p_script
op_minus
l_int|8
)paren
)paren
suffix:semicolon
id|nxtdsp
op_assign
id|dsp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dsp
OG
id|np-&gt;p_scripth
op_logical_and
id|dsp
op_le
id|np-&gt;p_scripth
op_plus
r_sizeof
(paren
r_struct
id|scripth
)paren
)paren
(brace
id|vdsp
op_assign
(paren
id|u_int32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|np-&gt;scripth0
op_plus
(paren
id|dsp
op_minus
id|np-&gt;p_scripth
op_minus
l_int|8
)paren
)paren
suffix:semicolon
id|nxtdsp
op_assign
id|dsp
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;log the information&n;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|printk
(paren
l_string|&quot;&bslash;nCP=%p DSP=%x NXT=%x VDSP=%p CMD=%x &quot;
comma
id|cp
comma
(paren
r_int
)paren
id|dsp
comma
(paren
r_int
)paren
id|nxtdsp
comma
id|vdsp
comma
id|cmd
)paren
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vdsp
)paren
(brace
id|printk
(paren
l_string|&quot;%s: interrupted SCRIPT address not found.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|reset_all
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
(brace
id|printk
(paren
l_string|&quot;%s: SCSI phase error fixup: CCB already dequeued.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|reset_all
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;get old startaddress and old length.&n;&t;*/
id|oadr
op_assign
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* Table indirect */
id|tblp
op_assign
(paren
id|u_int32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|cp-&gt;phys
op_plus
id|oadr
)paren
suffix:semicolon
id|olen
op_assign
id|scr_to_cpu
c_func
(paren
id|tblp
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|oadr
op_assign
id|scr_to_cpu
c_func
(paren
id|tblp
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|tblp
op_assign
(paren
id|u_int32
op_star
)paren
l_int|0
suffix:semicolon
id|olen
op_assign
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|0
)braket
)paren
op_amp
l_int|0xffffff
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|printk
(paren
l_string|&quot;OCMD=%x&bslash;nTBLP=%p OLEN=%x OADR=%x&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|0
)braket
)paren
op_rshift
l_int|24
)paren
comma
id|tblp
comma
(paren
r_int
)paren
id|olen
comma
(paren
r_int
)paren
id|oadr
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;check cmd against assumed interrupted script command.&n;&t;*/
r_if
c_cond
(paren
id|cmd
op_ne
(paren
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|0
)braket
)paren
op_rshift
l_int|24
)paren
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;internal error: cmd=%02x != %02x=(vdsp[0] &gt;&gt; 24)&bslash;n&quot;
comma
(paren
r_int
)paren
id|cmd
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|0
)braket
)paren
op_rshift
l_int|24
)paren
suffix:semicolon
r_goto
id|reset_all
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;if old phase not dataphase, leave here.&n;&t;**&t;C/D line is low if data.&n;&t;*/
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x02
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;phase change %x-%x %d@%08x resid=%d.&bslash;n&quot;
comma
id|cmd
op_amp
l_int|7
comma
id|INB
c_func
(paren
id|nc_sbcl
)paren
op_amp
l_int|7
comma
(paren
r_int
)paren
id|olen
comma
(paren
r_int
)paren
id|oadr
comma
(paren
r_int
)paren
id|rest
)paren
suffix:semicolon
r_goto
id|unexpected_phase
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Choose the correct PM save area.&n;&t;**&n;&t;**&t;Look at the PM_SAVE SCRIPT if you want to understand &n;&t;**&t;this stuff. The equivalent code is implemented in &n;&t;**&t;SCRIPTS for the 895A and 896 that are able to handle &n;&t;**&t;PM from the SCRIPTS processor.&n;&t;*/
id|hflags0
op_assign
id|INB
(paren
id|HF_PRT
)paren
suffix:semicolon
id|hflags
op_assign
id|hflags0
suffix:semicolon
r_if
c_cond
(paren
id|hflags
op_amp
(paren
id|HF_IN_PM0
op_or
id|HF_IN_PM1
op_or
id|HF_DP_SAVED
)paren
)paren
(brace
r_if
c_cond
(paren
id|hflags
op_amp
id|HF_IN_PM0
)paren
id|nxtdsp
op_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.pm0.ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hflags
op_amp
id|HF_IN_PM1
)paren
id|nxtdsp
op_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.pm1.ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hflags
op_amp
id|HF_DP_SAVED
)paren
id|hflags
op_xor_assign
id|HF_ACT_PM
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hflags
op_amp
id|HF_ACT_PM
)paren
)paren
(brace
id|pm
op_assign
op_amp
id|cp-&gt;phys.pm0
suffix:semicolon
id|newcmd
op_assign
id|NCB_SCRIPT_PHYS
c_func
(paren
id|np
comma
id|pm0_data
)paren
suffix:semicolon
)brace
r_else
(brace
id|pm
op_assign
op_amp
id|cp-&gt;phys.pm1
suffix:semicolon
id|newcmd
op_assign
id|NCB_SCRIPT_PHYS
c_func
(paren
id|np
comma
id|pm1_data
)paren
suffix:semicolon
)brace
id|hflags
op_and_assign
op_complement
(paren
id|HF_IN_PM0
op_or
id|HF_IN_PM1
op_or
id|HF_DP_SAVED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hflags
op_ne
id|hflags0
)paren
id|OUTB
(paren
id|HF_PRT
comma
id|hflags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;fillin the phase mismatch context&n;&t;*/
id|pm-&gt;sg.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|oadr
op_plus
id|olen
op_minus
id|rest
)paren
suffix:semicolon
id|pm-&gt;sg.size
op_assign
id|cpu_to_scr
c_func
(paren
id|rest
)paren
suffix:semicolon
id|pm-&gt;ret
op_assign
id|cpu_to_scr
c_func
(paren
id|nxtdsp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If we have a SWIDE,&n;&t;**&t;- prepare the address to write the SWIDE from SCRIPTS,&n;&t;**&t;- compute the SCRIPTS address to restart from,&n;&t;**&t;- move current data pointer context by one byte.&n;&t;*/
id|nxtdsp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|dispatch
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|cmd
op_amp
l_int|7
)paren
op_eq
l_int|1
op_logical_or
(paren
id|cmd
op_amp
l_int|7
)paren
op_eq
l_int|5
)paren
op_logical_and
id|cp
op_logical_and
(paren
id|cp-&gt;phys.select.sel_scntl3
op_amp
id|EWS
)paren
op_logical_and
(paren
id|INB
(paren
id|nc_scntl2
)paren
op_amp
id|WSR
)paren
)paren
(brace
id|u32
id|tmp
suffix:semicolon
macro_line|#ifdef  SYM_DEBUG_PM_WITH_WSR
id|PRINT_ADDR
c_func
(paren
id|cp
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;MA interrupt with WSR set - &quot;
l_string|&quot;pm-&gt;sg.addr=%x - pm-&gt;sg.size=%d&bslash;n&quot;
comma
id|pm-&gt;sg.addr
comma
id|pm-&gt;sg.size
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; *  Set up the table indirect for the MOVE&n;&t;&t; *  of the residual byte and adjust the data&n;&t;&t; *  pointer context.&n;&t;&t; */
id|tmp
op_assign
id|scr_to_cpu
c_func
(paren
id|pm-&gt;sg.addr
)paren
suffix:semicolon
id|cp-&gt;phys.wresid.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|pm-&gt;sg.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|tmp
op_plus
l_int|1
)paren
suffix:semicolon
id|tmp
op_assign
id|scr_to_cpu
c_func
(paren
id|pm-&gt;sg.size
)paren
suffix:semicolon
id|cp-&gt;phys.wresid.size
op_assign
id|cpu_to_scr
c_func
(paren
(paren
id|tmp
op_amp
l_int|0xff000000
)paren
op_or
l_int|1
)paren
suffix:semicolon
id|pm-&gt;sg.size
op_assign
id|cpu_to_scr
c_func
(paren
id|tmp
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  If only the residual byte is to be moved,&n;&t;&t; *  no PM context is needed.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|tmp
op_amp
l_int|0xffffff
)paren
op_eq
l_int|1
)paren
id|newcmd
op_assign
id|pm-&gt;ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Prepare the address of SCRIPTS that will&n;&t;&t; *  move the residual byte to memory.&n;&t;&t; */
id|nxtdsp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|wsr_ma_helper
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;PM %x %x %x / %x %x %x.&bslash;n&quot;
comma
id|hflags0
comma
id|hflags
comma
id|newcmd
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|pm-&gt;sg.addr
)paren
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|pm-&gt;sg.size
)paren
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|pm-&gt;ret
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Restart the SCRIPTS processor.&n;&t;*/
id|OUTL
(paren
id|nc_temp
comma
id|newcmd
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|nxtdsp
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Unexpected phase changes that occurs when the current phase &n;&t;**&t;is not a DATA IN or DATA OUT phase are due to error conditions.&n;&t;**&t;Such event may only happen when the SCRIPTS is using a &n;&t;**&t;multibyte SCSI MOVE.&n;&t;**&n;&t;**&t;Phase change&t;&t;Some possible cause&n;&t;**&n;&t;**&t;COMMAND  --&gt; MSG IN&t;SCSI parity error detected by target.&n;&t;**&t;COMMAND  --&gt; STATUS&t;Bad command or refused by target.&n;&t;**&t;MSG OUT  --&gt; MSG IN     Message rejected by target.&n;&t;**&t;MSG OUT  --&gt; COMMAND    Bogus target that discards extended&n;&t;**&t;&t;&t;&t;negotiation messages.&n;&t;**&n;&t;**&t;The code below does not care of the new phase and so &n;&t;**&t;trusts the target. Why to annoy it ?&n;&t;**&t;If the interrupted phase is COMMAND phase, we restart at&n;&t;**&t;dispatcher.&n;&t;**&t;If a target does not get all the messages after selection, &n;&t;**&t;the code assumes blindly that the target discards extended &n;&t;**&t;messages and clears the negotiation status.&n;&t;**&t;If the target does not want all our response to negotiation,&n;&t;**&t;we force a SIR_NEGO_PROTO interrupt (it is a hack that avoids &n;&t;**&t;bloat for such a should_not_happen situation).&n;&t;**&t;In all other situation, we reset the BUS.&n;&t;**&t;Are these assumptions reasonnable ? (Wait and see ...)&n;&t;*/
id|unexpected_phase
suffix:colon
id|dsp
op_sub_assign
l_int|8
suffix:semicolon
id|nxtdsp
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
op_amp
l_int|7
)paren
(brace
r_case
l_int|2
suffix:colon
multiline_comment|/* COMMAND phase */
id|nxtdsp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|dispatch
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if 0
r_case
l_int|3
suffix:colon
multiline_comment|/* STATUS  phase */
id|nxtdsp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|dispatch
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
l_int|6
suffix:colon
multiline_comment|/* MSG OUT phase */
multiline_comment|/*&n;&t;&t;**&t;If the device may want to use untagged when we want &n;&t;&t;**&t;tagged, we prepare an IDENTIFY without disc. granted, &n;&t;&t;**&t;since we will not be able to handle reselect.&n;&t;&t;**&t;Otherwise, we just don&squot;t care.&n;&t;&t;*/
r_if
c_cond
(paren
id|dsp
op_eq
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|send_ident
)paren
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;tag
op_ne
id|NO_TAG
op_logical_and
id|olen
op_minus
id|rest
op_le
l_int|3
)paren
(brace
id|cp-&gt;host_status
op_assign
id|HS_BUSY
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_IDENTIFY
op_or
id|cp-&gt;lun
suffix:semicolon
id|nxtdsp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|ident_break_atn
)paren
suffix:semicolon
)brace
r_else
id|nxtdsp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|ident_break
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dsp
op_eq
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|send_wdtr
)paren
op_logical_or
id|dsp
op_eq
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|send_sdtr
)paren
op_logical_or
id|dsp
op_eq
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|send_ppr
)paren
)paren
(brace
id|nxtdsp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|nego_bad_phase
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#if 0
r_case
l_int|7
suffix:colon
multiline_comment|/* MSG IN  phase */
id|nxtdsp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|nxtdsp
)paren
(brace
id|OUTL
(paren
id|nc_dsp
comma
id|nxtdsp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|reset_all
suffix:colon
id|ncr_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip handler for QUEUE FULL and CHECK CONDITION&n;**&n;**==========================================================&n;**&n;**&t;On QUEUE FULL status, we set the actual tagged command &n;**&t;queue depth to the number of disconnected CCBs that is &n;**&t;hopefully a good value to avoid further QUEUE FULL.&n;**&n;**&t;On CHECK CONDITION or COMMAND TERMINATED, we use the  &n;**&t;CCB of the failed command for performing a REQUEST &n;**&t;SENSE SCSI command.&n;**&n;**&t;We do not want to change the order commands will be &n;**&t;actually queued to the device after we received a &n;**&t;QUEUE FULL status. We also want to properly deal with &n;**&t;contingent allegiance condition. For these reasons, &n;**&t;we remove from the start queue all commands for this &n;**&t;LUN that haven&squot;t been yet queued to the device and &n;**&t;put them back in the correponding LUN queue, then  &n;**&t;requeue the CCB that failed in front of the LUN queue.&n;**&t;I just hope this not to be performed too often. :)&n;**&n;**&t;If we are using IMMEDIATE ARBITRATION, we clear the &n;**&t;IARB hint for every commands we encounter in order not &n;**&t;to be stuck with a won arbitration and no job to queue &n;**&t;to a device.&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_sir_to_redo
r_static
r_void
id|ncr_sir_to_redo
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|num
comma
id|ccb_p
id|cp
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|ncr_lp
c_func
(paren
id|np
comma
id|tp
comma
id|cp-&gt;lun
)paren
suffix:semicolon
id|ccb_p
id|cp2
suffix:semicolon
r_int
id|busyccbs
op_assign
l_int|1
suffix:semicolon
id|u_int32
id|startp
suffix:semicolon
id|u_char
id|s_status
op_assign
id|INB
(paren
id|SS_PRT
)paren
suffix:semicolon
r_int
id|msglen
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If the LCB is not yet available, then only &n;&t;**&t;1 IO is accepted, so we should have it.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_goto
id|next
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Remove all CCBs queued to the chip for that LUN and put &n;&t;**&t;them back in the LUN CCB wait queue.&n;&t;*/
id|busyccbs
op_assign
id|lp-&gt;queuedccbs
suffix:semicolon
id|i
op_assign
(paren
id|INL
(paren
id|nc_scratcha
)paren
op_minus
id|np-&gt;p_squeue
)paren
op_div
l_int|4
suffix:semicolon
id|j
op_assign
id|i
suffix:semicolon
r_while
c_loop
(paren
id|i
op_ne
id|np-&gt;squeueput
)paren
(brace
id|cp2
op_assign
id|ncr_ccb_from_dsa
c_func
(paren
id|np
comma
id|scr_to_cpu
c_func
(paren
id|np-&gt;squeue
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
m_assert
(paren
id|cp2
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
multiline_comment|/* IARB hints may not be relevant any more. Forget them. */
id|cp2-&gt;host_flags
op_and_assign
op_complement
id|HF_HINT_IARB
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cp2
op_logical_and
id|cp2-&gt;target
op_eq
id|cp-&gt;target
op_logical_and
id|cp2-&gt;lun
op_eq
id|cp-&gt;lun
)paren
(brace
id|xpt_remque
c_func
(paren
op_amp
id|cp2-&gt;link_ccbq
)paren
suffix:semicolon
id|xpt_insque_head
c_func
(paren
op_amp
id|cp2-&gt;link_ccbq
comma
op_amp
id|lp-&gt;wait_ccbq
)paren
suffix:semicolon
op_decrement
id|lp-&gt;queuedccbs
suffix:semicolon
id|cp2-&gt;queued
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|i
op_ne
id|j
)paren
id|np-&gt;squeue
(braket
id|j
)braket
op_assign
id|np-&gt;squeue
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|j
op_add_assign
l_int|2
)paren
op_ge
id|MAX_START
op_star
l_int|2
)paren
id|j
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|i
op_add_assign
l_int|2
)paren
op_ge
id|MAX_START
op_star
l_int|2
)paren
id|i
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
id|j
)paren
multiline_comment|/* Copy back the idle task if needed */
id|np-&gt;squeue
(braket
id|j
)braket
op_assign
id|np-&gt;squeue
(braket
id|i
)braket
suffix:semicolon
id|np-&gt;squeueput
op_assign
id|j
suffix:semicolon
multiline_comment|/* Update our current start queue pointer */
multiline_comment|/*&n;&t;**&t;Requeue the interrupted CCB in front of the &n;&t;**&t;LUN CCB wait queue to preserve ordering.&n;&t;*/
id|xpt_remque
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
)paren
suffix:semicolon
id|xpt_insque_head
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|lp-&gt;wait_ccbq
)paren
suffix:semicolon
op_decrement
id|lp-&gt;queuedccbs
suffix:semicolon
id|cp-&gt;queued
op_assign
l_int|0
suffix:semicolon
id|next
suffix:colon
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
multiline_comment|/* IARB hint may not be relevant any more. Forget it. */
id|cp-&gt;host_flags
op_and_assign
op_complement
id|HF_HINT_IARB
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;last_cp
)paren
id|np-&gt;last_cp
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Now we can restart the SCRIPTS processor safely.&n;&t;*/
id|MEMORY_BARRIER
c_func
(paren
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|start
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|s_status
)paren
(brace
r_default
suffix:colon
r_case
id|S_BUSY
suffix:colon
id|ncr_complete
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_QUEUE_FULL
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|lp
op_logical_or
op_logical_neg
id|lp-&gt;queuedccbs
)paren
(brace
id|ncr_complete
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|1
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;QUEUE FULL! %d busy, %d disconnected CCBs&bslash;n&quot;
comma
id|busyccbs
comma
id|lp-&gt;queuedccbs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Decrease number of tags to the number of &n;&t;&t;**&t;disconnected commands.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp-&gt;queuedccbs
OL
id|lp-&gt;numtags
)paren
(brace
id|lp-&gt;numtags
op_assign
id|lp-&gt;queuedccbs
suffix:semicolon
id|lp-&gt;num_good
op_assign
l_int|0
suffix:semicolon
id|ncr_setup_tags
(paren
id|np
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Repair the offending CCB.&n;&t;&t;*/
id|cp-&gt;phys.header.savep
op_assign
id|cp-&gt;startp
suffix:semicolon
id|cp-&gt;phys.header.lastp
op_assign
id|cp-&gt;lastp0
suffix:semicolon
id|cp-&gt;host_status
op_assign
id|HS_BUSY
suffix:semicolon
id|cp-&gt;scsi_status
op_assign
id|S_ILLEGAL
suffix:semicolon
id|cp-&gt;xerr_status
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;phys.extra_bytes
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;host_flags
op_and_assign
(paren
id|HF_PM_TO_C
op_or
id|HF_DATA_IN
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_TERMINATED
suffix:colon
r_case
id|S_CHECK_COND
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;If we were requesting sense, give up.&n;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;host_flags
op_amp
id|HF_AUTO_SENSE
)paren
(brace
id|ncr_complete
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Save SCSI status and extended error.&n;&t;&t;**&t;Compute the data residual now.&n;&t;&t;*/
id|cp-&gt;sv_scsi_status
op_assign
id|cp-&gt;scsi_status
suffix:semicolon
id|cp-&gt;sv_xerr_status
op_assign
id|cp-&gt;xerr_status
suffix:semicolon
id|cp-&gt;resid
op_assign
id|ncr_compute_residual
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Device returned CHECK CONDITION status.&n;&t;&t;**&t;Prepare all needed data strutures for getting &n;&t;&t;**&t;sense data.&n;&t;&t;*/
multiline_comment|/*&n;&t;&t;**&t;identify message&n;&t;&t;*/
id|cp-&gt;scsi_smsg2
(braket
l_int|0
)braket
op_assign
id|M_IDENTIFY
op_or
id|cp-&gt;lun
suffix:semicolon
id|msglen
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;If we are currently using anything different from &n;&t;&t;**&t;async. 8 bit data transfers with that target,&n;&t;&t;**&t;start a negotiation, since the device may want &n;&t;&t;**&t;to report us a UNIT ATTENTION condition due to &n;&t;&t;**&t;a cause we currently ignore, and we donnot want &n;&t;&t;**&t;to be stuck with WIDE and/or SYNC data transfer.&n;&t;&t;**&n;&t;&t;**&t;cp-&gt;nego_status is filled by ncr_prepare_nego().&n;&t;&t;**&n;&t;&t;**&t;Do NOT negotiate if performing integrity check&n;&t;&t;**&t;or if integrity check has completed, all check&n;&t;&t;**&t;conditions will have been cleared.&n;&t;&t;*/
macro_line|#ifdef&t;SCSI_NCR_INTEGRITY_CHECKING
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_IC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: ncr_sir_to_redo: ic_done %2X, in_progress %2X&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|tp-&gt;ic_done
comma
id|cp-&gt;cmd-&gt;ic_in_progress
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;If parity error during integrity check,&n;&t;&t;**&t;set the target width to narrow. Otherwise,&n;&t;&t;**&t;do not negotiate on a request sense.&n;&t;&t;*/
r_if
c_cond
(paren
id|np-&gt;check_integ_par
op_logical_and
id|np-&gt;check_integrity
op_logical_and
id|cp-&gt;cmd-&gt;ic_in_progress
)paren
(brace
id|cp-&gt;nego_status
op_assign
l_int|0
suffix:semicolon
id|msglen
op_add_assign
id|ncr_ic_nego
(paren
id|np
comma
id|cp
comma
id|cmd
comma
op_amp
id|cp-&gt;scsi_smsg2
(braket
id|msglen
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;check_integrity
op_logical_or
(paren
id|np-&gt;check_integrity
op_logical_and
(paren
op_logical_neg
id|cp-&gt;cmd-&gt;ic_in_progress
op_logical_and
op_logical_neg
id|tp-&gt;ic_done
)paren
)paren
)paren
(brace
id|ncr_negotiate
c_func
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
id|cp-&gt;nego_status
op_assign
l_int|0
suffix:semicolon
(brace
id|u_char
id|sync_offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
id|sync_offset
op_assign
id|tp-&gt;sval
op_amp
l_int|0x3f
suffix:semicolon
r_else
id|sync_offset
op_assign
id|tp-&gt;sval
op_amp
l_int|0x1f
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;wval
op_amp
id|EWS
)paren
op_logical_or
id|sync_offset
)paren
id|msglen
op_add_assign
id|ncr_prepare_nego
(paren
id|np
comma
id|cp
comma
op_amp
id|cp-&gt;scsi_smsg2
(braket
id|msglen
)braket
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
id|ncr_negotiate
c_func
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
id|cp-&gt;nego_status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;wval
op_amp
id|EWS
)paren
op_logical_or
(paren
id|tp-&gt;sval
op_amp
l_int|0x1f
)paren
)paren
id|msglen
op_add_assign
id|ncr_prepare_nego
(paren
id|np
comma
id|cp
comma
op_amp
id|cp-&gt;scsi_smsg2
(braket
id|msglen
)braket
)paren
suffix:semicolon
macro_line|#endif&t;/* SCSI_NCR_INTEGRITY_CHECKING */
multiline_comment|/*&n;&t;&t;**&t;Message table indirect structure.&n;&t;&t;*/
id|cp-&gt;phys.smsg.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|scsi_smsg2
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.smsg.size
op_assign
id|cpu_to_scr
c_func
(paren
id|msglen
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;sense command&n;&t;&t;*/
id|cp-&gt;phys.cmd.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|sensecmd
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.cmd.size
op_assign
id|cpu_to_scr
c_func
(paren
l_int|6
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;patch requested size into sense command&n;&t;&t;*/
id|cp-&gt;sensecmd
(braket
l_int|0
)braket
op_assign
l_int|0x03
suffix:semicolon
id|cp-&gt;sensecmd
(braket
l_int|1
)braket
op_assign
id|cp-&gt;lun
op_lshift
l_int|5
suffix:semicolon
id|cp-&gt;sensecmd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|cp-&gt;sense_buf
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;sense data&n;&t;&t;*/
id|bzero
c_func
(paren
id|cp-&gt;sense_buf
comma
r_sizeof
(paren
id|cp-&gt;sense_buf
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.sense.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_PHYS
c_func
(paren
id|cp
comma
id|sense_buf
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.sense.size
op_assign
id|cpu_to_scr
c_func
(paren
r_sizeof
(paren
id|cp-&gt;sense_buf
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;requeue the command.&n;&t;&t;*/
id|startp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|sdata_in
)paren
suffix:semicolon
id|cp-&gt;phys.header.savep
op_assign
id|cpu_to_scr
c_func
(paren
id|startp
)paren
suffix:semicolon
id|cp-&gt;phys.header.goalp
op_assign
id|cpu_to_scr
c_func
(paren
id|startp
op_plus
l_int|16
)paren
suffix:semicolon
id|cp-&gt;phys.header.lastp
op_assign
id|cpu_to_scr
c_func
(paren
id|startp
)paren
suffix:semicolon
id|cp-&gt;phys.header.wgoalp
op_assign
id|cpu_to_scr
c_func
(paren
id|startp
op_plus
l_int|16
)paren
suffix:semicolon
id|cp-&gt;phys.header.wlastp
op_assign
id|cpu_to_scr
c_func
(paren
id|startp
)paren
suffix:semicolon
id|cp-&gt;host_status
op_assign
id|cp-&gt;nego_status
ques
c_cond
id|HS_NEGOTIATE
suffix:colon
id|HS_BUSY
suffix:semicolon
id|cp-&gt;scsi_status
op_assign
id|S_ILLEGAL
suffix:semicolon
id|cp-&gt;host_flags
op_assign
(paren
id|HF_AUTO_SENSE
op_or
id|HF_DATA_IN
)paren
suffix:semicolon
id|cp-&gt;phys.header.go.start
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|select
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;If lp not yet allocated, requeue the command.&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
id|ncr_put_start_queue
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;requeue awaiting scsi commands for this lun.&n;&t;*/
r_if
c_cond
(paren
id|lp
)paren
id|ncr_start_next_ccb
c_func
(paren
id|np
comma
id|lp
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------------&n;**&n;**&t;After a device has accepted some management message &n;**&t;as BUS DEVICE RESET, ABORT TASK, etc ..., or when &n;**&t;a device signals a UNIT ATTENTION condition, some &n;**&t;tasks are thrown away by the device. We are required &n;**&t;to reflect that on our tasks list since the device &n;**&t;will never complete these tasks.&n;**&n;**&t;This function completes all disconnected CCBs for a &n;**&t;given target that matches the following criteria:&n;**&t;- lun=-1  means any logical UNIT otherwise a given one.&n;**&t;- task=-1 means any task, otherwise a given one.&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_clear_tasks
r_static
r_int
id|ncr_clear_tasks
c_func
(paren
id|ncb_p
id|np
comma
id|u_char
id|hsts
comma
r_int
id|target
comma
r_int
id|lun
comma
r_int
id|task
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
r_for
c_loop
(paren
id|cp
op_assign
id|np-&gt;ccbc
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_ne
id|HS_DISCONNECT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;target
op_ne
id|target
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|lun
op_ne
op_minus
l_int|1
op_logical_and
id|cp-&gt;lun
op_ne
id|lun
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|task
op_ne
op_minus
l_int|1
op_logical_and
id|cp-&gt;tag
op_ne
id|NO_TAG
op_logical_and
id|cp-&gt;scsi_smsg
(braket
l_int|2
)braket
op_ne
id|task
)paren
r_continue
suffix:semicolon
id|cp-&gt;host_status
op_assign
id|hsts
suffix:semicolon
id|cp-&gt;scsi_status
op_assign
id|S_ILLEGAL
suffix:semicolon
id|ncr_complete
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip handler for TASKS recovery.&n;**&n;**==========================================================&n;**&n;**&t;We cannot safely abort a command, while the SCRIPTS &n;**&t;processor is running, since we just would be in race &n;**&t;with it.&n;**&n;**&t;As long as we have tasks to abort, we keep the SEM &n;**&t;bit set in the ISTAT. When this bit is set, the &n;**&t;SCRIPTS processor interrupts (SIR_SCRIPT_STOPPED) &n;**&t;each time it enters the scheduler.&n;**&n;**&t;If we have to reset a target, clear tasks of a unit,&n;**&t;or to perform the abort of a disconnected job, we &n;**&t;restart the SCRIPTS for selecting the target. Once &n;**&t;selected, the SCRIPTS interrupts (SIR_TARGET_SELECTED).&n;**&t;If it loses arbitration, the SCRIPTS will interrupt again &n;**&t;the next time it will enter its scheduler, and so on ...&n;**&n;**&t;On SIR_TARGET_SELECTED, we scan for the more &n;**&t;appropriate thing to do:&n;**&n;**&t;- If nothing, we just sent a M_ABORT message to the &n;**&t;  target to get rid of the useless SCSI bus ownership.&n;**&t;  According to the specs, no tasks shall be affected.&n;**&t;- If the target is to be reset, we send it a M_RESET &n;**&t;  message.&n;**&t;- If a logical UNIT is to be cleared , we send the &n;**&t;  IDENTIFY(lun) + M_ABORT.&n;**&t;- If an untagged task is to be aborted, we send the &n;**&t;  IDENTIFY(lun) + M_ABORT.&n;**&t;- If a tagged task is to be aborted, we send the &n;**&t;  IDENTIFY(lun) + task attributes + M_ABORT_TAG.&n;**&n;**&t;Once our &squot;kiss of death&squot; :) message has been accepted &n;**&t;by the target, the SCRIPTS interrupts again &n;**&t;(SIR_ABORT_SENT). On this interrupt, we complete &n;**&t;all the CCBs that should have been aborted by the &n;**&t;target according to our message.&n;**&t;&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_sir_task_recovery
r_static
r_void
id|ncr_sir_task_recovery
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|num
)paren
(brace
id|ccb_p
id|cp
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
r_int
id|target
op_assign
op_minus
l_int|1
comma
id|lun
op_assign
op_minus
l_int|1
comma
id|task
suffix:semicolon
r_int
id|i
comma
id|k
suffix:semicolon
id|u_char
op_star
id|p
suffix:semicolon
r_switch
c_cond
(paren
id|num
)paren
(brace
multiline_comment|/*&n;&t;**&t;The SCRIPTS processor stopped before starting&n;&t;**&t;the next command in order to allow us to perform &n;&t;**&t;some task recovery.&n;&t;*/
r_case
id|SIR_SCRIPT_STOPPED
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;Do we have any target to reset or unit to clear ?&n;&t;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;to_reset
op_logical_or
(paren
id|tp-&gt;l0p
op_logical_and
id|tp-&gt;l0p-&gt;to_clear
)paren
)paren
(brace
id|target
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;lmp
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|1
suffix:semicolon
id|k
OL
id|MAX_LUN
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;lmp
(braket
id|k
)braket
op_logical_and
id|tp-&gt;lmp
(braket
id|k
)braket
op_member_access_from_pointer
id|to_clear
)paren
(brace
id|target
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|target
op_ne
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;If not, look at the CCB list for any &n;&t;&t;**&t;disconnected CCB to be aborted.&n;&t;&t;*/
r_if
c_cond
(paren
id|target
op_eq
op_minus
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|cp
op_assign
id|np-&gt;ccbc
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_ne
id|HS_DISCONNECT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;to_abort
)paren
(brace
id|target
op_assign
id|cp-&gt;target
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t;**&t;If some target is to be selected, &n;&t;&t;**&t;prepare and start the selection.&n;&t;&t;*/
r_if
c_cond
(paren
id|target
op_ne
op_minus
l_int|1
)paren
(brace
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|np-&gt;abrt_sel.sel_id
op_assign
id|target
suffix:semicolon
id|np-&gt;abrt_sel.sel_scntl3
op_assign
id|tp-&gt;wval
suffix:semicolon
id|np-&gt;abrt_sel.sel_sxfer
op_assign
id|tp-&gt;sval
suffix:semicolon
id|np-&gt;abrt_sel.sel_scntl4
op_assign
id|tp-&gt;uval
suffix:semicolon
id|OUTL
c_func
(paren
id|nc_dsa
comma
id|np-&gt;p_ncb
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|sel_for_abort
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Nothing is to be selected, so we donnot need &n;&t;&t;**&t;to synchronize with the SCRIPTS anymore.&n;&t;&t;**&t;Remove the SEM flag from the ISTAT.&n;&t;&t;*/
id|np-&gt;istat_sem
op_assign
l_int|0
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Now look at CCBs to abort that haven&squot;t started yet.&n;&t;&t;**&t;Remove all those CCBs from the start queue and &n;&t;&t;**&t;complete them with appropriate status.&n;&t;&t;**&t;Btw, the SCRIPTS processor is still stopped, so &n;&t;&t;**&t;we are not in race.&n;&t;&t;*/
r_for
c_loop
(paren
id|cp
op_assign
id|np-&gt;ccbc
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_ne
id|HS_BUSY
op_logical_and
id|cp-&gt;host_status
op_ne
id|HS_NEGOTIATE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;to_abort
)paren
r_continue
suffix:semicolon
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
multiline_comment|/*&n;&t;&t;&t;**    If we are using IMMEDIATE ARBITRATION, we donnot &n;&t;&t;&t;**    want to cancel the last queued CCB, since the &n;&t;&t;&t;**    SCRIPTS may have anticipated the selection.&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|cp
op_eq
id|np-&gt;last_cp
)paren
(brace
id|cp-&gt;to_abort
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t;**&t;Compute index of next position in the start &n;&t;&t;&t;**&t;queue the SCRIPTS will schedule.&n;&t;&t;&t;*/
id|i
op_assign
(paren
id|INL
(paren
id|nc_scratcha
)paren
op_minus
id|np-&gt;p_squeue
)paren
op_div
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;**&t;Remove the job from the start queue.&n;&t;&t;&t;*/
id|k
op_assign
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|np-&gt;squeueput
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|k
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Not found yet */
r_if
c_cond
(paren
id|cp
op_eq
id|ncr_ccb_from_dsa
c_func
(paren
id|np
comma
id|scr_to_cpu
c_func
(paren
id|np-&gt;squeue
(braket
id|i
)braket
)paren
)paren
)paren
id|k
op_assign
id|i
suffix:semicolon
multiline_comment|/* Found */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;**    Once found, we have to move &n;&t;&t;&t;&t;&t;**    back all jobs by 1 position.&n;&t;&t;&t;&t;&t;*/
id|np-&gt;squeue
(braket
id|k
)braket
op_assign
id|np-&gt;squeue
(braket
id|i
)braket
suffix:semicolon
id|k
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|k
op_ge
id|MAX_START
op_star
l_int|2
)paren
id|k
op_assign
l_int|0
suffix:semicolon
)brace
id|i
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|MAX_START
op_star
l_int|2
)paren
id|i
op_assign
l_int|0
suffix:semicolon
)brace
m_assert
(paren
id|k
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
op_ne
l_int|1
)paren
(brace
id|np-&gt;squeue
(braket
id|k
)braket
op_assign
id|np-&gt;squeue
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Idle task */
id|np-&gt;squeueput
op_assign
id|k
suffix:semicolon
multiline_comment|/* Start queue pointer */
id|cp-&gt;host_status
op_assign
id|HS_ABORTED
suffix:semicolon
id|cp-&gt;scsi_status
op_assign
id|S_ILLEGAL
suffix:semicolon
id|ncr_complete
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The SCRIPTS processor has selected a target &n;&t;**&t;we may have some manual recovery to perform for.&n;&t;*/
r_case
id|SIR_TARGET_SELECTED
suffix:colon
id|target
op_assign
(paren
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|np-&gt;abrt_tbl.addr
op_assign
id|vtobus
c_func
(paren
id|np-&gt;abrt_msg
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;If the target is to be reset, prepare a &n;&t;&t;**&t;M_RESET message and clear the to_reset flag &n;&t;&t;**&t;since we donnot expect this operation to fail.&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;to_reset
)paren
(brace
id|np-&gt;abrt_msg
(braket
l_int|0
)braket
op_assign
id|M_RESET
suffix:semicolon
id|np-&gt;abrt_tbl.size
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;to_reset
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Otherwise, look for some logical unit to be cleared.&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;l0p
op_logical_and
id|tp-&gt;l0p-&gt;to_clear
)paren
id|lun
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;lmp
)paren
(brace
r_for
c_loop
(paren
id|k
op_assign
l_int|1
suffix:semicolon
id|k
OL
id|MAX_LUN
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;lmp
(braket
id|k
)braket
op_logical_and
id|tp-&gt;lmp
(braket
id|k
)braket
op_member_access_from_pointer
id|to_clear
)paren
(brace
id|lun
op_assign
id|k
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t;**&t;If a logical unit is to be cleared, prepare &n;&t;&t;**&t;an IDENTIFY(lun) + ABORT MESSAGE.&n;&t;&t;*/
r_if
c_cond
(paren
id|lun
op_ne
op_minus
l_int|1
)paren
(brace
id|lcb_p
id|lp
op_assign
id|ncr_lp
c_func
(paren
id|np
comma
id|tp
comma
id|lun
)paren
suffix:semicolon
id|lp-&gt;to_clear
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We donnot expect to fail here */
id|np-&gt;abrt_msg
(braket
l_int|0
)braket
op_assign
id|M_IDENTIFY
op_or
id|lun
suffix:semicolon
id|np-&gt;abrt_msg
(braket
l_int|1
)braket
op_assign
id|M_ABORT
suffix:semicolon
id|np-&gt;abrt_tbl.size
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Otherwise, look for some disconnected job to &n;&t;&t;**&t;abort for this target.&n;&t;&t;*/
r_for
c_loop
(paren
id|cp
op_assign
id|np-&gt;ccbc
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_ne
id|HS_DISCONNECT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;target
op_ne
id|target
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;to_abort
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;If we have none, probably since the device has &n;&t;&t;**&t;completed the command before we won abitration,&n;&t;&t;**&t;send a M_ABORT message without IDENTIFY.&n;&t;&t;**&t;According to the specs, the device must just &n;&t;&t;**&t;disconnect the BUS and not abort any task.&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
(brace
id|np-&gt;abrt_msg
(braket
l_int|0
)braket
op_assign
id|M_ABORT
suffix:semicolon
id|np-&gt;abrt_tbl.size
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;We have some task to abort.&n;&t;&t;**&t;Set the IDENTIFY(lun)&n;&t;&t;*/
id|np-&gt;abrt_msg
(braket
l_int|0
)braket
op_assign
id|M_IDENTIFY
op_or
id|cp-&gt;lun
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;If we want to abort an untagged command, we &n;&t;&t;**&t;will send a IDENTIFY + M_ABORT.&n;&t;&t;**&t;Otherwise (tagged command), we will send &n;&t;&t;**&t;a IDENTITFY + task attributes + ABORT TAG.&n;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;tag
op_eq
id|NO_TAG
)paren
(brace
id|np-&gt;abrt_msg
(braket
l_int|1
)braket
op_assign
id|M_ABORT
suffix:semicolon
id|np-&gt;abrt_tbl.size
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|np-&gt;abrt_msg
(braket
l_int|1
)braket
op_assign
id|cp-&gt;scsi_smsg
(braket
l_int|1
)braket
suffix:semicolon
id|np-&gt;abrt_msg
(braket
l_int|2
)braket
op_assign
id|cp-&gt;scsi_smsg
(braket
l_int|2
)braket
suffix:semicolon
id|np-&gt;abrt_msg
(braket
l_int|3
)braket
op_assign
id|M_ABORT_TAG
suffix:semicolon
id|np-&gt;abrt_tbl.size
op_assign
l_int|4
suffix:semicolon
)brace
id|cp-&gt;to_abort
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We donnot expect to fail here */
r_break
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The target has accepted our message and switched &n;&t;**&t;to BUS FREE phase as we expected.&n;&t;*/
r_case
id|SIR_ABORT_SENT
suffix:colon
id|target
op_assign
(paren
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;If we didn&squot;t abort anything, leave here.&n;&t;&t;*/
r_if
c_cond
(paren
id|np-&gt;abrt_msg
(braket
l_int|0
)braket
op_eq
id|M_ABORT
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;If we sent a M_RESET, then a hardware reset has &n;&t;&t;**&t;been performed by the target.&n;&t;&t;**&t;- Reset everything to async 8 bit&n;&t;&t;**&t;- Tell ourself to negotiate next time :-)&n;&t;&t;**&t;- Prepare to clear all disconnected CCBs for &n;&t;&t;**&t;  this target from our task list (lun=task=-1)&n;&t;&t;*/
id|lun
op_assign
op_minus
l_int|1
suffix:semicolon
id|task
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;abrt_msg
(braket
l_int|0
)braket
op_eq
id|M_RESET
)paren
(brace
id|tp-&gt;sval
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;wval
op_assign
id|np-&gt;rv_scntl3
suffix:semicolon
id|tp-&gt;uval
op_assign
id|np-&gt;rv_scntl4
suffix:semicolon
id|ncr_set_sync_wide_status
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
id|ncr_negotiate
c_func
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Otherwise, check for the LUN and TASK(s) &n;&t;&t;**&t;concerned by the cancelation.&n;&t;&t;**&t;If it is not ABORT_TAG then it is CLEAR_QUEUE &n;&t;&t;**&t;or an ABORT message :-)&n;&t;&t;*/
r_else
(brace
id|lun
op_assign
id|np-&gt;abrt_msg
(braket
l_int|0
)braket
op_amp
l_int|0x3f
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;abrt_msg
(braket
l_int|1
)braket
op_eq
id|M_ABORT_TAG
)paren
id|task
op_assign
id|np-&gt;abrt_msg
(braket
l_int|2
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Complete all the CCBs the device should have &n;&t;&t;**&t;aborted due to our &squot;kiss of death&squot; message.&n;&t;&t;*/
(paren
r_void
)paren
id|ncr_clear_tasks
c_func
(paren
id|np
comma
id|HS_ABORTED
comma
id|target
comma
id|lun
comma
id|task
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;**&t;We have performed a auto-sense that succeeded.&n;&t;**&t;If the device reports a UNIT ATTENTION condition &n;&t;**&t;due to a RESET condition, we must complete all &n;&t;**&t;disconnect CCBs for this unit since the device &n;&t;**&t;shall have thrown them away.&n;&t;**&t;Since I haven&squot;t time to guess what the specs are &n;&t;**&t;expecting for other UNIT ATTENTION conditions, I &n;&t;**&t;decided to only care about RESET conditions. :)&n;&t;*/
r_case
id|SIR_AUTO_SENSE_DONE
suffix:colon
id|cp
op_assign
id|ncr_ccb_from_dsa
c_func
(paren
id|np
comma
id|INL
(paren
id|nc_dsa
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_break
suffix:semicolon
id|memcpy
c_func
(paren
id|cp-&gt;cmd-&gt;sense_buffer
comma
id|cp-&gt;sense_buf
comma
r_sizeof
(paren
id|cp-&gt;cmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|p
op_assign
op_amp
id|cp-&gt;cmd-&gt;sense_buffer
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_ne
l_int|0x70
op_logical_or
id|p
(braket
l_int|2
)braket
op_ne
l_int|0x6
op_logical_or
id|p
(braket
l_int|12
)braket
op_ne
l_int|0x29
)paren
r_break
suffix:semicolon
macro_line|#if 0
(paren
r_void
)paren
id|ncr_clear_tasks
c_func
(paren
id|np
comma
id|HS_RESET
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
comma
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Print to the log the message we intend to send.&n;&t;*/
r_if
c_cond
(paren
id|num
op_eq
id|SIR_TARGET_SELECTED
)paren
(brace
id|PRINT_TARGET
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
id|ncr_printl_hex
c_func
(paren
l_string|&quot;control msgout:&quot;
comma
id|np-&gt;abrt_msg
comma
id|np-&gt;abrt_tbl.size
)paren
suffix:semicolon
id|np-&gt;abrt_tbl.size
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;abrt_tbl.size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Let the SCRIPTS processor continue.&n;&t;*/
id|OUTONB
(paren
id|nc_dcntl
comma
(paren
id|STD
op_or
id|NOCOM
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;G&#xfffd;rard&squot;s alchemy:) that deals with with the data &n;**&t;pointer for both MDP and the residual calculation.&n;**&n;**==========================================================&n;**&n;**&t;I didn&squot;t want to bloat the code by more than 200 &n;**&t;lignes for the handling of both MDP and the residual.&n;**&t;This has been achieved by using a data pointer &n;**&t;representation consisting in an index in the data &n;**&t;array (dp_sg) and a negative offset (dp_ofs) that &n;**&t;have the following meaning:&n;**&n;**&t;- dp_sg = MAX_SCATTER&n;**&t;  we are at the end of the data script.&n;**&t;- dp_sg &lt; MAX_SCATTER&n;**&t;  dp_sg points to the next entry of the scatter array &n;**&t;  we want to transfer.&n;**&t;- dp_ofs &lt; 0&n;**&t;  dp_ofs represents the residual of bytes of the &n;**&t;  previous entry scatter entry we will send first.&n;**&t;- dp_ofs = 0&n;**&t;  no residual to send first.&n;**&n;**&t;The function ncr_evaluate_dp() accepts an arbitray &n;**&t;offset (basically from the MDP message) and returns &n;**&t;the corresponding values of dp_sg and dp_ofs.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_evaluate_dp
r_static
r_int
id|ncr_evaluate_dp
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_int32
id|scr
comma
r_int
op_star
id|ofs
)paren
(brace
id|u_int32
id|dp_scr
suffix:semicolon
r_int
id|dp_ofs
comma
id|dp_sg
comma
id|dp_sgmin
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_struct
id|pm_ctx
op_star
id|pm
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Compute the resulted data pointer in term of a script &n;&t;**&t;address within some DATA script and a signed byte offset.&n;&t;*/
id|dp_scr
op_assign
id|scr
suffix:semicolon
id|dp_ofs
op_assign
op_star
id|ofs
suffix:semicolon
r_if
c_cond
(paren
id|dp_scr
op_eq
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|pm0_data
)paren
)paren
id|pm
op_assign
op_amp
id|cp-&gt;phys.pm0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dp_scr
op_eq
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|pm1_data
)paren
)paren
id|pm
op_assign
op_amp
id|cp-&gt;phys.pm1
suffix:semicolon
r_else
id|pm
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pm
)paren
(brace
id|dp_scr
op_assign
id|scr_to_cpu
c_func
(paren
id|pm-&gt;ret
)paren
suffix:semicolon
id|dp_ofs
op_sub_assign
id|scr_to_cpu
c_func
(paren
id|pm-&gt;sg.size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Deduce the index of the sg entry.&n;&t;**&t;Keep track of the index of the first valid entry.&n;&t;**&t;If result is dp_sg = MAX_SCATTER, then we are at the &n;&t;**&t;end of the data and vice-versa.&n;&t;*/
id|tmp
op_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.header.goalp
)paren
suffix:semicolon
id|dp_sg
op_assign
id|MAX_SCATTER
suffix:semicolon
r_if
c_cond
(paren
id|dp_scr
op_ne
id|tmp
)paren
id|dp_sg
op_sub_assign
(paren
id|tmp
op_minus
l_int|8
op_minus
(paren
r_int
)paren
id|dp_scr
)paren
op_div
(paren
id|SCR_SG_SIZE
op_star
l_int|4
)paren
suffix:semicolon
id|dp_sgmin
op_assign
id|MAX_SCATTER
op_minus
id|cp-&gt;segments
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Move to the sg entry the data pointer belongs to.&n;&t;**&n;&t;**&t;If we are inside the data area, we expect result to be:&n;&t;**&n;&t;**&t;Either,&n;&t;**&t;    dp_ofs = 0 and dp_sg is the index of the sg entry&n;&t;**&t;    the data pointer belongs to (or the end of the data)&n;&t;**&t;Or,&n;&t;**&t;    dp_ofs &lt; 0 and dp_sg is the index of the sg entry &n;&t;**&t;    the data pointer belongs to + 1.&n;&t;*/
r_if
c_cond
(paren
id|dp_ofs
OL
l_int|0
)paren
(brace
r_int
id|n
suffix:semicolon
r_while
c_loop
(paren
id|dp_sg
OG
id|dp_sgmin
)paren
(brace
op_decrement
id|dp_sg
suffix:semicolon
id|tmp
op_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.data
(braket
id|dp_sg
)braket
dot
id|size
)paren
suffix:semicolon
id|n
op_assign
id|dp_ofs
op_plus
(paren
id|tmp
op_amp
l_int|0xffffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|0
)paren
(brace
op_increment
id|dp_sg
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dp_ofs
op_assign
id|n
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|dp_ofs
OG
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|dp_sg
OL
id|MAX_SCATTER
)paren
(brace
id|tmp
op_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.data
(braket
id|dp_sg
)braket
dot
id|size
)paren
suffix:semicolon
id|dp_ofs
op_sub_assign
(paren
id|tmp
op_amp
l_int|0xffffff
)paren
suffix:semicolon
op_increment
id|dp_sg
suffix:semicolon
r_if
c_cond
(paren
id|dp_ofs
op_le
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;Make sure the data pointer is inside the data area.&n;&t;**&t;If not, return some error.&n;&t;*/
r_if
c_cond
(paren
id|dp_sg
OL
id|dp_sgmin
op_logical_or
(paren
id|dp_sg
op_eq
id|dp_sgmin
op_logical_and
id|dp_ofs
OL
l_int|0
)paren
)paren
r_goto
id|out_err
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dp_sg
OG
id|MAX_SCATTER
op_logical_or
(paren
id|dp_sg
op_eq
id|MAX_SCATTER
op_logical_and
id|dp_ofs
OG
l_int|0
)paren
)paren
r_goto
id|out_err
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Save the extreme pointer if needed.&n;&t;*/
r_if
c_cond
(paren
id|dp_sg
OG
id|cp-&gt;ext_sg
op_logical_or
(paren
id|dp_sg
op_eq
id|cp-&gt;ext_sg
op_logical_and
id|dp_ofs
OG
id|cp-&gt;ext_ofs
)paren
)paren
(brace
id|cp-&gt;ext_sg
op_assign
id|dp_sg
suffix:semicolon
id|cp-&gt;ext_ofs
op_assign
id|dp_ofs
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Return data.&n;&t;*/
op_star
id|ofs
op_assign
id|dp_ofs
suffix:semicolon
r_return
id|dp_sg
suffix:semicolon
id|out_err
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip handler for MODIFY DATA POINTER MESSAGE&n;**&n;**==========================================================&n;**&n;**&t;We also call this function on IGNORE WIDE RESIDUE &n;**&t;messages that do not match a SWIDE full condition.&n;**&t;Btw, we assume in that situation that such a message &n;**&t;is equivalent to a MODIFY DATA POINTER (offset=-1).&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_modify_dp
r_static
r_void
id|ncr_modify_dp
c_func
(paren
id|ncb_p
id|np
comma
id|tcb_p
id|tp
comma
id|ccb_p
id|cp
comma
r_int
id|ofs
)paren
(brace
r_int
id|dp_ofs
op_assign
id|ofs
suffix:semicolon
id|u_int32
id|dp_scr
op_assign
id|INL
(paren
id|nc_temp
)paren
suffix:semicolon
id|u_int32
id|dp_ret
suffix:semicolon
id|u_int32
id|tmp
suffix:semicolon
id|u_char
id|hflags
suffix:semicolon
r_int
id|dp_sg
suffix:semicolon
r_struct
id|pm_ctx
op_star
id|pm
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Not supported for auto_sense;&n;&t;*/
r_if
c_cond
(paren
id|cp-&gt;host_flags
op_amp
id|HF_AUTO_SENSE
)paren
r_goto
id|out_reject
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Apply our alchemy:) (see comments in ncr_evaluate_dp()), &n;&t;**&t;to the resulted data pointer.&n;&t;*/
id|dp_sg
op_assign
id|ncr_evaluate_dp
c_func
(paren
id|np
comma
id|cp
comma
id|dp_scr
comma
op_amp
id|dp_ofs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dp_sg
OL
l_int|0
)paren
r_goto
id|out_reject
suffix:semicolon
multiline_comment|/*&n;&t;**&t;And our alchemy:) allows to easily calculate the data &n;&t;**&t;script address we want to return for the next data phase.&n;&t;*/
id|dp_ret
op_assign
id|cpu_to_scr
c_func
(paren
id|cp-&gt;phys.header.goalp
)paren
suffix:semicolon
id|dp_ret
op_assign
id|dp_ret
op_minus
l_int|8
op_minus
(paren
id|MAX_SCATTER
op_minus
id|dp_sg
)paren
op_star
(paren
id|SCR_SG_SIZE
op_star
l_int|4
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If offset / scatter entry is zero we donnot need &n;&t;**&t;a context for the new current data pointer.&n;&t;*/
r_if
c_cond
(paren
id|dp_ofs
op_eq
l_int|0
)paren
(brace
id|dp_scr
op_assign
id|dp_ret
suffix:semicolon
r_goto
id|out_ok
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Get a context for the new current data pointer.&n;&t;*/
id|hflags
op_assign
id|INB
(paren
id|HF_PRT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hflags
op_amp
id|HF_DP_SAVED
)paren
id|hflags
op_xor_assign
id|HF_ACT_PM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hflags
op_amp
id|HF_ACT_PM
)paren
)paren
(brace
id|pm
op_assign
op_amp
id|cp-&gt;phys.pm0
suffix:semicolon
id|dp_scr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|pm0_data
)paren
suffix:semicolon
)brace
r_else
(brace
id|pm
op_assign
op_amp
id|cp-&gt;phys.pm1
suffix:semicolon
id|dp_scr
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|pm1_data
)paren
suffix:semicolon
)brace
id|hflags
op_and_assign
op_complement
(paren
id|HF_DP_SAVED
)paren
suffix:semicolon
id|OUTB
(paren
id|HF_PRT
comma
id|hflags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set up the new current data pointer.&n;&t;**&t;ofs &lt; 0 there, and for the next data phase, we &n;&t;**&t;want to transfer part of the data of the sg entry &n;&t;**&t;corresponding to index dp_sg-1 prior to returning &n;&t;**&t;to the main data script.&n;&t;*/
id|pm-&gt;ret
op_assign
id|cpu_to_scr
c_func
(paren
id|dp_ret
)paren
suffix:semicolon
id|tmp
op_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.data
(braket
id|dp_sg
op_minus
l_int|1
)braket
dot
id|addr
)paren
suffix:semicolon
id|tmp
op_add_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.data
(braket
id|dp_sg
op_minus
l_int|1
)braket
dot
id|size
)paren
op_plus
id|dp_ofs
suffix:semicolon
id|pm-&gt;sg.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|pm-&gt;sg.size
op_assign
id|cpu_to_scr
c_func
(paren
op_minus
id|dp_ofs
)paren
suffix:semicolon
id|out_ok
suffix:colon
id|OUTL
(paren
id|nc_temp
comma
id|dp_scr
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|out_reject
suffix:colon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip calculation of the data residual.&n;**&n;**==========================================================&n;**&n;**&t;As I used to say, the requirement of data residual &n;**&t;in SCSI is broken, useless and cannot be achieved &n;**&t;without huge complexity.&n;**&t;But most OSes and even the official CAM require it.&n;**&t;When stupidity happens to be so widely spread inside &n;**&t;a community, it gets hard to convince.&n;**&n;**&t;Anyway, I don&squot;t care, since I am not going to use &n;**&t;any software that considers this data residual as &n;**&t;a relevant information. :)&n;**&t;&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_compute_residual
r_static
r_int
id|ncr_compute_residual
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
r_int
id|dp_sg
comma
id|dp_sgmin
comma
id|tmp
suffix:semicolon
r_int
id|resid
op_assign
l_int|0
suffix:semicolon
r_int
id|dp_ofs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Check for some data lost or just thrown away.&n;&t; *&t;We are not required to be quite accurate in this&n;&t; *&t;situation. Btw, if we are odd for output and the&n;&t; *&t;device claims some more data, it may well happen&n;&t; *&t;than our residual be zero. :-)&n;&t; */
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_amp
(paren
id|XE_EXTRA_DATA
op_or
id|XE_SODL_UNRUN
op_or
id|XE_SWIDE_OVRUN
)paren
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_amp
id|XE_EXTRA_DATA
)paren
id|resid
op_sub_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.extra_bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_amp
id|XE_SODL_UNRUN
)paren
op_increment
id|resid
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_amp
id|XE_SWIDE_OVRUN
)paren
op_decrement
id|resid
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If all data has been transferred,&n;&t;**&t;there is no residual.&n;&t;*/
r_if
c_cond
(paren
id|cp-&gt;phys.header.lastp
op_eq
id|cp-&gt;phys.header.goalp
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If the last data pointer is data_io (direction &n;&t;**&t;unknown), then no data transfer should have &n;&t;**&t;taken place.&n;&t;*/
r_if
c_cond
(paren
id|cp-&gt;phys.header.lastp
op_eq
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|data_io
)paren
)paren
r_return
op_minus
id|cp-&gt;data_len
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If the device asked for more data than available, &n;&t;**&t;return a positive residual value.&n;&t;*/
r_if
c_cond
(paren
id|cp-&gt;phys.extra_bytes
)paren
r_return
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.extra_bytes
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Evaluate the pointer saved on message COMPLETE.&n;&t;**&t;According to our alchemy:), the extreme data &n;&t;**&t;pointer will also be updated if needed.&n;&t;**&t;On error, assume no data transferred (this may &n;&t;**&t;happen if the data direction is unknown).&n;&t;*/
id|tmp
op_assign
id|cpu_to_scr
c_func
(paren
id|cp-&gt;phys.header.lastp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ncr_evaluate_dp
c_func
(paren
id|np
comma
id|cp
comma
id|tmp
comma
op_amp
id|dp_ofs
)paren
OL
l_int|0
)paren
r_return
op_minus
id|cp-&gt;data_len
suffix:semicolon
multiline_comment|/*&n;&t;**&t;We are now full comfortable in the computation &n;&t;**&t;of the data residual (2&squot;s complement).&n;&t;*/
id|dp_sgmin
op_assign
id|MAX_SCATTER
op_minus
id|cp-&gt;segments
suffix:semicolon
id|resid
op_assign
id|cp-&gt;ext_ofs
suffix:semicolon
r_for
c_loop
(paren
id|dp_sg
op_assign
id|cp-&gt;ext_sg
suffix:semicolon
id|dp_sg
OL
id|MAX_SCATTER
suffix:semicolon
op_increment
id|dp_sg
)paren
(brace
id|tmp
op_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.data
(braket
id|dp_sg
)braket
dot
id|size
)paren
suffix:semicolon
id|resid
op_sub_assign
(paren
id|tmp
op_amp
l_int|0xffffff
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Hopefully, the result is not too wrong.&n;&t;*/
r_return
id|resid
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Print out the containt of a SCSI message.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_show_msg
r_static
r_int
id|ncr_show_msg
(paren
id|u_char
op_star
id|msg
)paren
(brace
id|u_char
id|i
suffix:semicolon
id|printk
(paren
l_string|&quot;%x&quot;
comma
op_star
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|msg
op_eq
id|M_EXTENDED
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_minus
l_int|1
OG
id|msg
(braket
l_int|1
)braket
)paren
r_break
suffix:semicolon
id|printk
(paren
l_string|&quot;-%x&quot;
comma
id|msg
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
id|i
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
op_star
id|msg
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
(brace
id|printk
(paren
l_string|&quot;-%x&quot;
comma
id|msg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
(paren
l_int|2
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|ncr_print_msg
r_static
r_void
id|ncr_print_msg
(paren
id|ccb_p
id|cp
comma
r_char
op_star
id|label
comma
id|u_char
op_star
id|msg
)paren
(brace
r_if
c_cond
(paren
id|cp
)paren
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|label
)paren
id|printk
(paren
l_string|&quot;%s: &quot;
comma
id|label
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|msg
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*===================================================================&n;**&n;**&t;Negotiation for WIDE and SYNCHRONOUS DATA TRANSFER.&n;**&n;**===================================================================&n;**&n;**&t;Was Sie schon immer ueber transfermode negotiation wissen wollten ...&n;**&n;**&t;We try to negotiate sync and wide transfer only after&n;**&t;a successfull inquire command. We look at byte 7 of the&n;**&t;inquire data to determine the capabilities of the target.&n;**&n;**&t;When we try to negotiate, we append the negotiation message&n;**&t;to the identify and (maybe) simple tag message.&n;**&t;The host status field is set to HS_NEGOTIATE to mark this&n;**&t;situation.&n;**&n;**&t;If the target doesn&squot;t answer this message immediately&n;**&t;(as required by the standard), the SIR_NEGO_FAILED interrupt&n;**&t;will be raised eventually.&n;**&t;The handler removes the HS_NEGOTIATE status, and sets the&n;**&t;negotiated value to the default (async / nowide).&n;**&n;**&t;If we receive a matching answer immediately, we check it&n;**&t;for validity, and set the values.&n;**&n;**&t;If we receive a Reject message immediately, we assume the&n;**&t;negotiation has failed, and fall back to standard values.&n;**&n;**&t;If we receive a negotiation message while not in HS_NEGOTIATE&n;**&t;state, it&squot;s a target initiated negotiation. We prepare a&n;**&t;(hopefully) valid answer, set our parameters, and send back &n;**&t;this answer to the target.&n;**&n;**&t;If the target doesn&squot;t fetch the answer (no message out phase),&n;**&t;we assume the negotiation has failed, and fall back to default&n;**&t;settings (SIR_NEGO_PROTO interrupt).&n;**&n;**&t;When we set the values, we adjust them in all ccbs belonging &n;**&t;to this target, in the controller&squot;s register, and in the &quot;phys&quot;&n;**&t;field of the controller&squot;s struct ncb.&n;**&n;**---------------------------------------------------------------------&n;*/
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip handler for SYNCHRONOUS DATA TRANSFER &n;**&t;REQUEST (SDTR) message.&n;**&n;**==========================================================&n;**&n;**&t;Read comments above.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_sync_nego
r_static
r_void
id|ncr_sync_nego
c_func
(paren
id|ncb_p
id|np
comma
id|tcb_p
id|tp
comma
id|ccb_p
id|cp
)paren
(brace
id|u_char
id|scntl3
comma
id|scntl4
suffix:semicolon
id|u_char
id|chg
comma
id|ofs
comma
id|per
comma
id|fak
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Synchronous request message received.&n;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|ncr_print_msg
c_func
(paren
id|cp
comma
l_string|&quot;sync msg in&quot;
comma
id|np-&gt;msgin
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;get requested values.&n;&t;*/
id|chg
op_assign
l_int|0
suffix:semicolon
id|per
op_assign
id|np-&gt;msgin
(braket
l_int|3
)braket
suffix:semicolon
id|ofs
op_assign
id|np-&gt;msgin
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_eq
l_int|0
)paren
id|per
op_assign
l_int|255
suffix:semicolon
multiline_comment|/*&n;&t;**      if target sends SDTR message,&n;&t;**&t;      it CAN transfer synch.&n;&t;*/
r_if
c_cond
(paren
id|ofs
)paren
id|tp-&gt;inq_byte7
op_or_assign
id|INQ7_SYNC
suffix:semicolon
multiline_comment|/*&n;&t;**&t;check values against driver limits.&n;&t;*/
r_if
c_cond
(paren
id|per
OL
id|np-&gt;minsync
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|per
op_assign
id|np-&gt;minsync
suffix:semicolon
)brace
r_if
c_cond
(paren
id|per
OL
id|tp-&gt;minsync
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|per
op_assign
id|tp-&gt;minsync
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ofs
OG
id|tp-&gt;maxoffs
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
id|tp-&gt;maxoffs
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Check against controller limits.&n;&t;*/
id|fak
op_assign
l_int|7
suffix:semicolon
id|scntl3
op_assign
l_int|0
suffix:semicolon
id|scntl4
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_ne
l_int|0
)paren
(brace
id|ncr_getsync
c_func
(paren
id|np
comma
id|per
comma
op_amp
id|fak
comma
op_amp
id|scntl3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fak
OG
l_int|7
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ofs
op_eq
l_int|0
)paren
(brace
id|fak
op_assign
l_int|7
suffix:semicolon
id|per
op_assign
l_int|0
suffix:semicolon
id|scntl3
op_assign
l_int|0
suffix:semicolon
id|scntl4
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;minsync
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;sync: per=%d scntl3=0x%x scntl4=0x%x ofs=%d fak=%d chg=%d.&bslash;n&quot;
comma
id|per
comma
id|scntl3
comma
id|scntl4
comma
id|ofs
comma
id|fak
comma
id|chg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INB
(paren
id|HS_PRT
)paren
op_eq
id|HS_NEGOTIATE
)paren
(brace
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;nego_status
)paren
(brace
r_case
id|NS_SYNC
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**      This was an answer message&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|chg
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;**&t;Answer wasn&squot;t acceptable.&n;&t;&t;&t;&t;*/
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0xe0
comma
l_int|0
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;**&t;Answer is ok.&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_and
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
id|scntl3
comma
(paren
id|fak
op_lshift
l_int|5
)paren
op_or
id|ofs
comma
l_int|0
)paren
suffix:semicolon
r_else
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
id|scntl3
comma
id|ofs
comma
id|scntl4
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;It was a request. Set value and&n;&t;**      prepare an answer message&n;&t;*/
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_and
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
id|scntl3
comma
(paren
id|fak
op_lshift
l_int|5
)paren
op_or
id|ofs
comma
l_int|0
)paren
suffix:semicolon
r_else
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
id|scntl3
comma
id|ofs
comma
id|scntl4
)paren
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|1
)braket
op_assign
l_int|3
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|2
)braket
op_assign
id|M_X_SYNC_REQ
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|3
)braket
op_assign
id|per
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|4
)braket
op_assign
id|ofs
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|NS_SYNC
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|ncr_print_msg
c_func
(paren
id|cp
comma
l_string|&quot;sync msgout&quot;
comma
id|np-&gt;msgout
)paren
suffix:semicolon
)brace
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ofs
)paren
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
r_else
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|sdtr_resp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip handler for WIDE DATA TRANSFER REQUEST &n;**&t;(WDTR) message.&n;**&n;**==========================================================&n;**&n;**&t;Read comments above.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_wide_nego
r_static
r_void
id|ncr_wide_nego
c_func
(paren
id|ncb_p
id|np
comma
id|tcb_p
id|tp
comma
id|ccb_p
id|cp
)paren
(brace
id|u_char
id|chg
comma
id|wide
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wide request message received.&n;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|ncr_print_msg
c_func
(paren
id|cp
comma
l_string|&quot;wide msgin&quot;
comma
id|np-&gt;msgin
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;get requested values.&n;&t;*/
id|chg
op_assign
l_int|0
suffix:semicolon
id|wide
op_assign
id|np-&gt;msgin
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**      if target sends WDTR message,&n;&t;**&t;      it CAN transfer wide.&n;&t;*/
r_if
c_cond
(paren
id|wide
)paren
id|tp-&gt;inq_byte7
op_or_assign
id|INQ7_WIDE16
suffix:semicolon
multiline_comment|/*&n;&t;**&t;check values against driver limits.&n;&t;*/
r_if
c_cond
(paren
id|wide
OG
id|tp-&gt;usrwide
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|wide
op_assign
id|tp-&gt;usrwide
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;wide: wide=%d chg=%d.&bslash;n&quot;
comma
id|wide
comma
id|chg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INB
(paren
id|HS_PRT
)paren
op_eq
id|HS_NEGOTIATE
)paren
(brace
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;nego_status
)paren
(brace
r_case
id|NS_WIDE
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**      This was an answer message&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|chg
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;**&t;Answer wasn&squot;t acceptable.&n;&t;&t;&t;&t;*/
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;**&t;Answer is ok.&n;&t;&t;&t;&t;*/
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
id|wide
comma
l_int|1
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
r_case
id|NS_SYNC
suffix:colon
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0xe0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;It was a request, set value and&n;&t;**      prepare an answer message&n;&t;*/
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
id|wide
comma
l_int|1
)paren
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|2
)braket
op_assign
id|M_X_WIDE_REQ
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|3
)braket
op_assign
id|wide
suffix:semicolon
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|NS_WIDE
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|ncr_print_msg
c_func
(paren
id|cp
comma
l_string|&quot;wide msgout&quot;
comma
id|np-&gt;msgout
)paren
suffix:semicolon
)brace
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|wdtr_resp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip handler for PARALLEL PROTOCOL REQUEST &n;**&t;(PPR) message.&n;**&n;**==========================================================&n;**&n;**&t;Read comments above.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_ppr_nego
r_static
r_void
id|ncr_ppr_nego
c_func
(paren
id|ncb_p
id|np
comma
id|tcb_p
id|tp
comma
id|ccb_p
id|cp
)paren
(brace
id|u_char
id|scntl3
comma
id|scntl4
suffix:semicolon
id|u_char
id|chg
comma
id|ofs
comma
id|per
comma
id|fak
comma
id|wth
comma
id|dt
suffix:semicolon
multiline_comment|/*&n;&t;**&t;PPR message received.&n;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|ncr_print_msg
c_func
(paren
id|cp
comma
l_string|&quot;ppr msg in&quot;
comma
id|np-&gt;msgin
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;get requested values.&n;&t;*/
id|chg
op_assign
l_int|0
suffix:semicolon
id|per
op_assign
id|np-&gt;msgin
(braket
l_int|3
)braket
suffix:semicolon
id|ofs
op_assign
id|np-&gt;msgin
(braket
l_int|5
)braket
suffix:semicolon
id|wth
op_assign
id|np-&gt;msgin
(braket
l_int|6
)braket
suffix:semicolon
id|dt
op_assign
id|np-&gt;msgin
(braket
l_int|7
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_eq
l_int|0
)paren
id|per
op_assign
l_int|255
suffix:semicolon
multiline_comment|/*&n;&t;**      if target sends sync (wide),&n;&t;**&t;      it CAN transfer synch (wide).&n;&t;*/
r_if
c_cond
(paren
id|ofs
)paren
id|tp-&gt;inq_byte7
op_or_assign
id|INQ7_SYNC
suffix:semicolon
r_if
c_cond
(paren
id|wth
)paren
id|tp-&gt;inq_byte7
op_or_assign
id|INQ7_WIDE16
suffix:semicolon
multiline_comment|/*&n;&t;**&t;check values against driver limits.&n;&t;*/
r_if
c_cond
(paren
id|wth
OG
id|tp-&gt;usrwide
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|wth
op_assign
id|tp-&gt;usrwide
suffix:semicolon
)brace
r_if
c_cond
(paren
id|per
OL
id|np-&gt;minsync
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|per
op_assign
id|np-&gt;minsync
suffix:semicolon
)brace
r_if
c_cond
(paren
id|per
OL
id|tp-&gt;minsync
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|per
op_assign
id|tp-&gt;minsync
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ofs
OG
id|tp-&gt;maxoffs
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
id|tp-&gt;maxoffs
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Check against controller limits.&n;&t;*/
id|fak
op_assign
l_int|7
suffix:semicolon
id|scntl3
op_assign
l_int|0
suffix:semicolon
id|scntl4
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_ne
l_int|0
)paren
(brace
id|scntl4
op_assign
id|dt
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
suffix:semicolon
id|ncr_getsync
c_func
(paren
id|np
comma
id|per
comma
op_amp
id|fak
comma
op_amp
id|scntl3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fak
OG
l_int|7
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ofs
op_eq
l_int|0
)paren
(brace
id|fak
op_assign
l_int|7
suffix:semicolon
id|per
op_assign
l_int|0
suffix:semicolon
id|scntl3
op_assign
l_int|0
suffix:semicolon
id|scntl4
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;minsync
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If target responds with Ultra 3 speed&n;&t;**&t;but narrow or not DT, reject.&n;&t;**&t;If target responds with DT request &n;&t;**&t;but not Ultra3 speeds, reject message,&n;&t;**&t;reset min sync for target to 0x0A and&n;&t;**&t;set flags to re-negotiate.&n;&t;*/
r_if
c_cond
(paren
(paren
id|per
op_eq
l_int|0x09
)paren
op_logical_and
id|ofs
op_logical_and
(paren
op_logical_neg
id|wth
op_logical_or
op_logical_neg
id|dt
)paren
)paren
id|chg
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
(paren
id|per
OG
l_int|0x09
)paren
op_logical_and
id|dt
)paren
)paren
id|chg
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ppr: wth=%d per=%d scntl3=0x%x scntl4=0x%x ofs=%d fak=%d chg=%d.&bslash;n&quot;
comma
id|wth
comma
id|per
comma
id|scntl3
comma
id|scntl4
comma
id|ofs
comma
id|fak
comma
id|chg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INB
(paren
id|HS_PRT
)paren
op_eq
id|HS_NEGOTIATE
)paren
(brace
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;nego_status
)paren
(brace
r_case
id|NS_PPR
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**      This was an answer message&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|chg
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;**&t;Answer wasn&squot;t acceptable.&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|chg
op_eq
l_int|2
)paren
(brace
multiline_comment|/* Send message reject and reset flags for&n;&t;&t;&t;&t;&t;** host to re-negotiate with min period 0x0A.&n;&t;&t;&t;&t;&t;*/
id|tp-&gt;minsync
op_assign
l_int|0x0A
suffix:semicolon
id|tp-&gt;period
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;widedone
op_assign
l_int|0
suffix:semicolon
)brace
id|ncr_setsyncwide
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0xe0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;**&t;Answer is ok.&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_and
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
id|ncr_setsyncwide
(paren
id|np
comma
id|cp
comma
id|scntl3
comma
(paren
id|fak
op_lshift
l_int|5
)paren
op_or
id|ofs
comma
l_int|0
comma
id|wth
)paren
suffix:semicolon
r_else
id|ncr_setsyncwide
(paren
id|np
comma
id|cp
comma
id|scntl3
comma
id|ofs
comma
id|scntl4
comma
id|wth
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
r_case
id|NS_SYNC
suffix:colon
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0xe0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;It was a request. Set value and&n;&t;**      prepare an answer message&n;&t;**&n;&t;**&t;If narrow or not DT and requesting Ultra3&n;&t;**&t;slow the bus down and force ST. If not&n;&t;**&t;requesting Ultra3, force ST.&n;&t;**&t;Max offset is 31=0x1f if ST mode.&n;&t;*/
r_if
c_cond
(paren
(paren
id|per
op_eq
l_int|0x09
)paren
op_logical_and
id|ofs
op_logical_and
(paren
op_logical_neg
id|wth
op_logical_or
op_logical_neg
id|dt
)paren
)paren
(brace
id|per
op_assign
l_int|0x0A
suffix:semicolon
id|dt
op_assign
l_int|0
suffix:semicolon
id|ofs
op_and_assign
l_int|0x1f
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|per
OG
l_int|0x09
)paren
op_logical_and
id|dt
)paren
(brace
id|dt
op_assign
l_int|0
suffix:semicolon
id|ofs
op_and_assign
l_int|0x1f
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_and
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
id|ncr_setsyncwide
(paren
id|np
comma
id|cp
comma
id|scntl3
comma
(paren
id|fak
op_lshift
l_int|5
)paren
op_or
id|ofs
comma
l_int|0
comma
id|wth
)paren
suffix:semicolon
r_else
id|ncr_setsyncwide
(paren
id|np
comma
id|cp
comma
id|scntl3
comma
id|ofs
comma
id|scntl4
comma
id|wth
)paren
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|1
)braket
op_assign
l_int|6
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|2
)braket
op_assign
id|M_X_PPR_REQ
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|3
)braket
op_assign
id|per
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|5
)braket
op_assign
id|ofs
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|6
)braket
op_assign
id|wth
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|7
)braket
op_assign
id|dt
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|NS_PPR
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|ncr_print_msg
c_func
(paren
id|cp
comma
l_string|&quot;ppr msgout&quot;
comma
id|np-&gt;msgout
)paren
suffix:semicolon
)brace
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ofs
)paren
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
r_else
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|ppr_resp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Reset SYNC or WIDE to default settings.&n;**&t;Called when a negotiation does not succeed either &n;**&t;on rejection or on protocol error.&n;*/
DECL|function|ncr_nego_default
r_static
r_void
id|ncr_nego_default
c_func
(paren
id|ncb_p
id|np
comma
id|tcb_p
id|tp
comma
id|ccb_p
id|cp
)paren
(brace
multiline_comment|/*&n;&t;**&t;any error in negotiation:&n;&t;**&t;fall back to default mode.&n;&t;*/
r_switch
c_cond
(paren
id|cp-&gt;nego_status
)paren
(brace
r_case
id|NS_SYNC
suffix:colon
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0xe0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_PPR
suffix:colon
multiline_comment|/*&n;&t;&t; * ppr_negotiation is set to 1 on the first ppr nego command.&n;&t;&t; * If ppr is successful, it is reset to 2.&n;&t;&t; * If unsuccessful it is reset to 0.&n;&t;&t; */
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
id|u_char
id|factor
comma
id|offset
comma
id|width
suffix:semicolon
id|ncr_get_xfer_info
(paren
id|np
comma
id|tp
comma
op_amp
id|factor
comma
op_amp
id|offset
comma
op_amp
id|width
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Current factor %d offset %d width %d&bslash;n&quot;
comma
id|factor
comma
id|offset
comma
id|width
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;ppr_negotiation
op_eq
l_int|2
)paren
id|ncr_setsyncwide
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0xe0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;ppr_negotiation
op_eq
l_int|1
)paren
(brace
multiline_comment|/* First ppr command has received a  M REJECT.&n;&t;&t;&t; * Do not change the existing wide/sync parameter&n;&t;&t;&t; * values (asyn/narrow if this as the first nego;&n;&t;&t;&t; * may be different if target initiates nego.).&n;&t;&t;&t; */
id|tp-&gt;ppr_negotiation
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|tp-&gt;ppr_negotiation
op_assign
l_int|0
suffix:semicolon
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
suffix:semicolon
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|cp-&gt;nego_status
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip handler for MESSAGE REJECT received for &n;**&t;a WIDE or SYNCHRONOUS negotiation.&n;**&n;**&t;clear the PPR negotiation flag, all future nego.&n;**&t;will be SDTR and WDTR&n;**&n;**==========================================================&n;**&n;**&t;Read comments above.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_nego_rejected
r_static
r_void
id|ncr_nego_rejected
c_func
(paren
id|ncb_p
id|np
comma
id|tcb_p
id|tp
comma
id|ccb_p
id|cp
)paren
(brace
id|ncr_nego_default
c_func
(paren
id|np
comma
id|tp
comma
id|cp
)paren
suffix:semicolon
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      ncr chip exception handler for programmed interrupts.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_int_sir
r_void
id|ncr_int_sir
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|num
op_assign
id|INB
(paren
id|nc_dsps
)paren
suffix:semicolon
id|u_long
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|ccb_p
id|cp
op_assign
id|ncr_ccb_from_dsa
c_func
(paren
id|np
comma
id|dsa
)paren
suffix:semicolon
id|u_char
id|target
op_assign
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;I#%d&quot;
comma
id|num
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|num
)paren
(brace
multiline_comment|/*&n;&t;**&t;See comments in the SCRIPTS code.&n;&t;*/
macro_line|#ifdef SCSI_NCR_PCIQ_SYNC_ON_INTR
r_case
id|SIR_DUMMY_INTERRUPT
suffix:colon
r_goto
id|out
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;The C code is currently trying to recover from something.&n;&t;**&t;Typically, user want to abort some command.&n;&t;*/
r_case
id|SIR_SCRIPT_STOPPED
suffix:colon
r_case
id|SIR_TARGET_SELECTED
suffix:colon
r_case
id|SIR_ABORT_SENT
suffix:colon
r_case
id|SIR_AUTO_SENSE_DONE
suffix:colon
id|ncr_sir_task_recovery
c_func
(paren
id|np
comma
id|num
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The device didn&squot;t go to MSG OUT phase after having &n;&t;**&t;been selected with ATN. We donnot want to handle &n;&t;**&t;that.&n;&t;*/
r_case
id|SIR_SEL_ATN_NO_MSG_OUT
suffix:colon
id|printk
(paren
l_string|&quot;%s:%d: No MSG OUT phase after selection with ATN.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|target
)paren
suffix:semicolon
r_goto
id|out_stuck
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The device didn&squot;t switch to MSG IN phase after &n;&t;**&t;having reseleted the initiator.&n;&t;*/
r_case
id|SIR_RESEL_NO_MSG_IN
suffix:colon
multiline_comment|/*&n;&t;**&t;After reselection, the device sent a message that wasn&squot;t &n;&t;**&t;an IDENTIFY.&n;&t;*/
r_case
id|SIR_RESEL_NO_IDENTIFY
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;If devices reselecting without sending an IDENTIFY &n;&t;&t;**&t;message still exist, this should help.&n;&t;&t;**&t;We just assume lun=0, 1 CCB, no tag.&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;l0p
)paren
(brace
id|OUTL
(paren
id|nc_dsa
comma
id|scr_to_cpu
c_func
(paren
id|tp-&gt;l0p-&gt;tasktbl
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|resel_go
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;The device reselected a LUN we donnot know of.&n;&t;*/
r_case
id|SIR_RESEL_BAD_LUN
suffix:colon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_RESET
suffix:semicolon
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The device reselected for an untagged nexus and we &n;&t;**&t;haven&squot;t any.&n;&t;*/
r_case
id|SIR_RESEL_BAD_I_T_L
suffix:colon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_ABORT
suffix:semicolon
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The device reselected for a tagged nexus that we donnot &n;&t;**&t;have.&n;&t;*/
r_case
id|SIR_RESEL_BAD_I_T_L_Q
suffix:colon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_ABORT_TAG
suffix:semicolon
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The SCRIPTS let us know that the device has grabbed &n;&t;**&t;our message and will abort the job.&n;&t;*/
r_case
id|SIR_RESEL_ABORTED
suffix:colon
id|np-&gt;lastmsg
op_assign
id|np-&gt;msgout
(braket
l_int|0
)braket
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|printk
(paren
l_string|&quot;%s:%d: message %x sent on bad reselection.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|target
comma
id|np-&gt;lastmsg
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The SCRIPTS let us know that a message has been &n;&t;**&t;successfully sent to the device.&n;&t;*/
r_case
id|SIR_MSG_OUT_DONE
suffix:colon
id|np-&gt;lastmsg
op_assign
id|np-&gt;msgout
(braket
l_int|0
)braket
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
multiline_comment|/* Should we really care of that */
r_if
c_cond
(paren
id|np-&gt;lastmsg
op_eq
id|M_PARITY
op_logical_or
id|np-&gt;lastmsg
op_eq
id|M_ID_ERROR
)paren
(brace
r_if
c_cond
(paren
id|cp
)paren
(brace
id|cp-&gt;xerr_status
op_and_assign
op_complement
id|XE_PARITY_ERR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;xerr_status
)paren
id|OUTOFFB
(paren
id|HF_PRT
comma
id|HF_EXT_ERR
)paren
suffix:semicolon
)brace
)brace
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The device didn&squot;t send a GOOD SCSI status.&n;&t;**&t;We may have some work to do prior to allow &n;&t;**&t;the SCRIPTS processor to continue.&n;&t;*/
r_case
id|SIR_BAD_STATUS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_goto
id|out
suffix:semicolon
id|ncr_sir_to_redo
c_func
(paren
id|np
comma
id|num
comma
id|cp
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;We are asked by the SCRIPTS to prepare a &n;&t;**&t;REJECT message.&n;&t;*/
r_case
id|SIR_REJECT_TO_SEND
suffix:colon
id|ncr_print_msg
c_func
(paren
id|cp
comma
l_string|&quot;M_REJECT to send for &quot;
comma
id|np-&gt;msgin
)paren
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_REJECT
suffix:semicolon
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;**&t;We have been ODD at the end of a DATA IN &n;&t;**&t;transfer and the device didn&squot;t send a &n;&t;**&t;IGNORE WIDE RESIDUE message.&n;&t;**&t;It is a data overrun condition.&n;&t;*/
r_case
id|SIR_SWIDE_OVERRUN
suffix:colon
r_if
c_cond
(paren
id|cp
)paren
(brace
id|OUTONB
(paren
id|HF_PRT
comma
id|HF_EXT_ERR
)paren
suffix:semicolon
id|cp-&gt;xerr_status
op_or_assign
id|XE_SWIDE_OVRUN
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;**&t;We have been ODD at the end of a DATA OUT &n;&t;**&t;transfer.&n;&t;**&t;It is a data underrun condition.&n;&t;*/
r_case
id|SIR_SODL_UNDERRUN
suffix:colon
r_if
c_cond
(paren
id|cp
)paren
(brace
id|OUTONB
(paren
id|HF_PRT
comma
id|HF_EXT_ERR
)paren
suffix:semicolon
id|cp-&gt;xerr_status
op_or_assign
id|XE_SODL_UNRUN
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;**&t;We received a message.&n;&t;*/
r_case
id|SIR_MSG_RECEIVED
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_goto
id|out_stuck
suffix:semicolon
r_switch
c_cond
(paren
id|np-&gt;msgin
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;We received an extended message.&n;&t;&t;**&t;We handle MODIFY DATA POINTER, SDTR, WDTR &n;&t;&t;**&t;and reject all other extended messages.&n;&t;&t;*/
r_case
id|M_EXTENDED
suffix:colon
r_switch
c_cond
(paren
id|np-&gt;msgin
(braket
l_int|2
)braket
)paren
(brace
r_case
id|M_X_MODIFY_DP
suffix:colon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_POINTER
)paren
id|ncr_print_msg
c_func
(paren
id|cp
comma
l_string|&quot;modify DP&quot;
comma
id|np-&gt;msgin
)paren
suffix:semicolon
id|tmp
op_assign
(paren
id|np-&gt;msgin
(braket
l_int|3
)braket
op_lshift
l_int|24
)paren
op_plus
(paren
id|np-&gt;msgin
(braket
l_int|4
)braket
op_lshift
l_int|16
)paren
op_plus
(paren
id|np-&gt;msgin
(braket
l_int|5
)braket
op_lshift
l_int|8
)paren
op_plus
(paren
id|np-&gt;msgin
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|ncr_modify_dp
c_func
(paren
id|np
comma
id|tp
comma
id|cp
comma
id|tmp
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|M_X_SYNC_REQ
suffix:colon
id|ncr_sync_nego
c_func
(paren
id|np
comma
id|tp
comma
id|cp
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|M_X_WIDE_REQ
suffix:colon
id|ncr_wide_nego
c_func
(paren
id|np
comma
id|tp
comma
id|cp
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|M_X_PPR_REQ
suffix:colon
id|ncr_ppr_nego
c_func
(paren
id|np
comma
id|tp
comma
id|cp
)paren
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
r_goto
id|out_reject
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;We received a 1/2 byte message not handled from SCRIPTS.&n;&t;&t;**&t;We are only expecting MESSAGE REJECT and IGNORE WIDE &n;&t;&t;**&t;RESIDUE messages that haven&squot;t been anticipated by &n;&t;&t;**&t;SCRIPTS on SWIDE full condition. Unanticipated IGNORE &n;&t;&t;**&t;WIDE RESIDUE messages are aliased as MODIFY DP (-1).&n;&t;&t;*/
r_case
id|M_IGN_RESIDUE
suffix:colon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_POINTER
)paren
id|ncr_print_msg
c_func
(paren
id|cp
comma
l_string|&quot;ign wide residue&quot;
comma
id|np-&gt;msgin
)paren
suffix:semicolon
id|ncr_modify_dp
c_func
(paren
id|np
comma
id|tp
comma
id|cp
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|M_REJECT
suffix:colon
r_if
c_cond
(paren
id|INB
(paren
id|HS_PRT
)paren
op_eq
id|HS_NEGOTIATE
)paren
id|ncr_nego_rejected
c_func
(paren
id|np
comma
id|tp
comma
id|cp
)paren
suffix:semicolon
r_else
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;M_REJECT received (%x:%x).&bslash;n&quot;
comma
id|scr_to_cpu
c_func
(paren
id|np-&gt;lastmsg
)paren
comma
id|np-&gt;msgout
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_goto
id|out_clrack
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|out_reject
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*&n;&t;**&t;We received an unknown message.&n;&t;**&t;Ignore all MSG IN phases and reject it.&n;&t;*/
r_case
id|SIR_MSG_WEIRD
suffix:colon
id|ncr_print_msg
c_func
(paren
id|cp
comma
l_string|&quot;WEIRD message received&quot;
comma
id|np-&gt;msgin
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|msg_weird
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Negotiation failed.&n;&t;**&t;Target does not send us the reply.&n;&t;**&t;Remove the HS_NEGOTIATE status.&n;&t;*/
r_case
id|SIR_NEGO_FAILED
suffix:colon
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Negotiation failed.&n;&t;**&t;Target does not want answer message.&n;&t;*/
r_case
id|SIR_NEGO_PROTO
suffix:colon
id|ncr_nego_default
c_func
(paren
id|np
comma
id|tp
comma
id|cp
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
suffix:semicolon
id|out
suffix:colon
id|OUTONB
(paren
id|nc_dcntl
comma
(paren
id|STD
op_or
id|NOCOM
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|out_reject
suffix:colon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|out_clrack
suffix:colon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|out_stuck
suffix:colon
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Aquire a control block&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_get_ccb
r_static
id|ccb_p
id|ncr_get_ccb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|ncr_lp
c_func
(paren
id|np
comma
id|tp
comma
id|ln
)paren
suffix:semicolon
id|u_short
id|tag
op_assign
id|NO_TAG
suffix:semicolon
id|XPT_QUEHEAD
op_star
id|qp
suffix:semicolon
id|ccb_p
id|cp
op_assign
(paren
id|ccb_p
)paren
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate a new CCB if needed.&n;&t;*/
r_if
c_cond
(paren
id|xpt_que_empty
c_func
(paren
op_amp
id|np-&gt;free_ccbq
)paren
)paren
(paren
r_void
)paren
id|ncr_alloc_ccb
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Look for a free CCB&n;&t;*/
id|qp
op_assign
id|xpt_remque_head
c_func
(paren
op_amp
id|np-&gt;free_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qp
)paren
r_goto
id|out
suffix:semicolon
id|cp
op_assign
id|xpt_que_entry
c_func
(paren
id|qp
comma
r_struct
id|ccb
comma
id|link_ccbq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If the LCB is not yet available and we already &n;&t;**&t;have queued a CCB for a LUN without LCB,&n;&t;**&t;give up. Otherwise all is fine. :-)&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
(brace
r_if
c_cond
(paren
id|xpt_que_empty
c_func
(paren
op_amp
id|np-&gt;b0_ccbq
)paren
)paren
id|xpt_insque_head
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;b0_ccbq
)paren
suffix:semicolon
r_else
r_goto
id|out_free
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;**&t;Tune tag mode if asked by user.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp-&gt;queuedepth
op_ne
id|lp-&gt;numtags
)paren
(brace
id|ncr_setup_tags
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Get a tag for this nexus if required.&n;&t;&t;**&t;Keep from using more tags than we can handle.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp-&gt;usetags
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;busyccbs
OL
id|lp-&gt;maxnxs
)paren
(brace
id|tag
op_assign
id|lp-&gt;cb_tags
(braket
id|lp-&gt;ia_tag
)braket
suffix:semicolon
op_increment
id|lp-&gt;ia_tag
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;ia_tag
op_eq
id|MAX_TAGS
)paren
id|lp-&gt;ia_tag
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;tags_si
op_assign
id|lp-&gt;tags_si
suffix:semicolon
op_increment
id|lp-&gt;tags_sum
(braket
id|cp-&gt;tags_si
)braket
suffix:semicolon
)brace
r_else
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Put the CCB in the LUN wait queue and &n;&t;&t;**&t;count it as busy.&n;&t;&t;*/
id|xpt_insque_tail
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|lp-&gt;wait_ccbq
)paren
suffix:semicolon
op_increment
id|lp-&gt;busyccbs
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Remember all informations needed to free this CCB.&n;&t;*/
id|cp-&gt;to_abort
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;tag
op_assign
id|tag
suffix:semicolon
id|cp-&gt;target
op_assign
id|tn
suffix:semicolon
id|cp-&gt;lun
op_assign
id|ln
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ccb @%p using tag %d.&bslash;n&quot;
comma
id|cp
comma
id|tag
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|cp
suffix:semicolon
id|out_free
suffix:colon
id|xpt_insque_head
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;free_ccbq
)paren
suffix:semicolon
r_return
(paren
id|ccb_p
)paren
l_int|0
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Release one control block&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_free_ccb
r_static
r_void
id|ncr_free_ccb
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|ncr_lp
c_func
(paren
id|np
comma
id|tp
comma
id|cp-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ccb @%p freeing tag %d.&bslash;n&quot;
comma
id|cp
comma
id|cp-&gt;tag
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If lun control block available, make available &n;&t;**&t;the task slot and the tag if any.&n;&t;**&t;Decrement counters.&n;&t;*/
r_if
c_cond
(paren
id|lp
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;tag
op_ne
id|NO_TAG
)paren
(brace
id|lp-&gt;cb_tags
(braket
id|lp-&gt;if_tag
op_increment
)braket
op_assign
id|cp-&gt;tag
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;if_tag
op_eq
id|MAX_TAGS
)paren
id|lp-&gt;if_tag
op_assign
l_int|0
suffix:semicolon
op_decrement
id|lp-&gt;tags_sum
(braket
id|cp-&gt;tags_si
)braket
suffix:semicolon
id|lp-&gt;tasktbl
(braket
id|cp-&gt;tag
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;p_bad_i_t_l_q
)paren
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;tasktbl
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;p_bad_i_t_l
)paren
suffix:semicolon
)brace
op_decrement
id|lp-&gt;busyccbs
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;queued
)paren
(brace
op_decrement
id|lp-&gt;queuedccbs
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;Make this CCB available.&n;&t;*/
id|xpt_remque
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
)paren
suffix:semicolon
id|xpt_insque_head
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;free_ccbq
)paren
suffix:semicolon
id|cp
op_member_access_from_pointer
id|host_status
op_assign
id|HS_IDLE
suffix:semicolon
id|cp
op_member_access_from_pointer
id|queued
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------------&n;**&t;Allocate a CCB and initialize its fixed part.&n;**------------------------------------------------------------------------&n;**------------------------------------------------------------------------&n;*/
DECL|function|ncr_alloc_ccb
r_static
id|ccb_p
id|ncr_alloc_ccb
c_func
(paren
id|ncb_p
id|np
)paren
(brace
id|ccb_p
id|cp
op_assign
l_int|0
suffix:semicolon
r_int
id|hcode
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate memory for this CCB.&n;&t;*/
id|cp
op_assign
id|m_calloc_dma
c_func
(paren
r_sizeof
(paren
r_struct
id|ccb
)paren
comma
l_string|&quot;CCB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Count it and initialyze it.&n;&t;*/
id|np-&gt;actccbs
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Remember virtual and bus address of this ccb.&n;&t;*/
id|cp-&gt;p_ccb
op_assign
id|vtobus
c_func
(paren
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Insert this ccb into the hashed list.&n;&t;*/
id|hcode
op_assign
id|CCB_HASH_CODE
c_func
(paren
id|cp-&gt;p_ccb
)paren
suffix:semicolon
id|cp-&gt;link_ccbh
op_assign
id|np-&gt;ccbh
(braket
id|hcode
)braket
suffix:semicolon
id|np-&gt;ccbh
(braket
id|hcode
)braket
op_assign
id|cp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialyze the start and restart actions.&n;&t;*/
id|cp-&gt;phys.header.go.start
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.header.go.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
c_func
(paren
id|np
comma
id|bad_i_t_l
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initilialyze some other fields.&n;&t;*/
id|cp-&gt;phys.smsg_ext.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_PHYS
c_func
(paren
id|np
comma
id|msgin
(braket
l_int|2
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Chain into wakeup list and free ccb queue.&n;&t;*/
id|cp-&gt;link_ccb
op_assign
id|np-&gt;ccbc
suffix:semicolon
id|np-&gt;ccbc
op_assign
id|cp
suffix:semicolon
id|xpt_insque_head
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;free_ccbq
)paren
suffix:semicolon
r_return
id|cp
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------------&n;**&t;Look up a CCB from a DSA value.&n;**------------------------------------------------------------------------&n;**------------------------------------------------------------------------&n;*/
DECL|function|ncr_ccb_from_dsa
r_static
id|ccb_p
id|ncr_ccb_from_dsa
c_func
(paren
id|ncb_p
id|np
comma
id|u_long
id|dsa
)paren
(brace
r_int
id|hcode
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
id|hcode
op_assign
id|CCB_HASH_CODE
c_func
(paren
id|dsa
)paren
suffix:semicolon
id|cp
op_assign
id|np-&gt;ccbh
(braket
id|hcode
)braket
suffix:semicolon
r_while
c_loop
(paren
id|cp
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;p_ccb
op_eq
id|dsa
)paren
r_break
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccbh
suffix:semicolon
)brace
r_return
id|cp
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      Allocation of resources for Targets/Luns/Tags.&n;**&n;**&n;**==========================================================&n;*/
multiline_comment|/*------------------------------------------------------------------------&n;**&t;Target control block initialisation.&n;**------------------------------------------------------------------------&n;**&t;This data structure is fully initialized after a SCSI command &n;**&t;has been successfully completed for this target.&n;**------------------------------------------------------------------------&n;*/
DECL|function|ncr_init_tcb
r_static
r_void
id|ncr_init_tcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
)paren
(brace
multiline_comment|/*&n;&t;**&t;Check some alignments required by the chip.&n;&t;*/
m_assert
(paren
(paren
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_sxfer
)paren
op_xor
m_offsetof
(paren
r_struct
id|tcb
comma
id|sval
)paren
)paren
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
m_assert
(paren
(paren
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_scntl3
)paren
op_xor
m_offsetof
(paren
r_struct
id|tcb
comma
id|wval
)paren
)paren
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
(brace
m_assert
(paren
(paren
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_scntl4
)paren
op_xor
m_offsetof
(paren
r_struct
id|tcb
comma
id|uval
)paren
)paren
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*------------------------------------------------------------------------&n;**&t;Lun control block allocation and initialization.&n;**------------------------------------------------------------------------&n;**&t;This data structure is allocated and initialized after a SCSI &n;**&t;command has been successfully completed for this target/lun.&n;**------------------------------------------------------------------------&n;*/
DECL|function|ncr_alloc_lcb
r_static
id|lcb_p
id|ncr_alloc_lcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|ncr_lp
c_func
(paren
id|np
comma
id|tp
comma
id|ln
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Already done, return.&n;&t;*/
r_if
c_cond
(paren
id|lp
)paren
r_return
id|lp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialize the target control block if not yet.&n;&t;*/
id|ncr_init_tcb
c_func
(paren
id|np
comma
id|tn
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate the lcb bus address array.&n;&t;**&t;Compute the bus address of this table.&n;&t;*/
r_if
c_cond
(paren
id|ln
op_logical_and
op_logical_neg
id|tp-&gt;luntbl
)paren
(brace
r_int
id|i
suffix:semicolon
id|tp-&gt;luntbl
op_assign
id|m_calloc_dma
c_func
(paren
l_int|256
comma
l_string|&quot;LUNTBL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;luntbl
)paren
r_goto
id|fail
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
id|tp-&gt;luntbl
(braket
id|i
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_PHYS
c_func
(paren
id|np
comma
id|resel_badlun
)paren
)paren
suffix:semicolon
id|tp-&gt;b_luntbl
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|tp-&gt;luntbl
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Allocate the table of pointers for LUN(s) &gt; 0, if needed.&n;&t;*/
r_if
c_cond
(paren
id|ln
op_logical_and
op_logical_neg
id|tp-&gt;lmp
)paren
(brace
id|tp-&gt;lmp
op_assign
id|m_calloc
c_func
(paren
id|MAX_LUN
op_star
r_sizeof
(paren
id|lcb_p
)paren
comma
l_string|&quot;LMP&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;lmp
)paren
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Allocate the lcb.&n;&t;**&t;Make it available to the chip.&n;&t;*/
id|lp
op_assign
id|m_calloc_dma
c_func
(paren
r_sizeof
(paren
r_struct
id|lcb
)paren
comma
l_string|&quot;LCB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
id|ln
)paren
(brace
id|tp-&gt;lmp
(braket
id|ln
)braket
op_assign
id|lp
suffix:semicolon
id|tp-&gt;luntbl
(braket
id|ln
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|lp
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|tp-&gt;l0p
op_assign
id|lp
suffix:semicolon
id|tp-&gt;b_lun0
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|lp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Initialize the CCB queue headers.&n;&t;*/
id|xpt_que_init
c_func
(paren
op_amp
id|lp-&gt;busy_ccbq
)paren
suffix:semicolon
id|xpt_que_init
c_func
(paren
op_amp
id|lp-&gt;wait_ccbq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set max CCBs to 1 and use the default task array &n;&t;**&t;by default.&n;&t;*/
id|lp-&gt;maxnxs
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;tasktbl
op_assign
op_amp
id|lp-&gt;tasktbl_0
suffix:semicolon
id|lp-&gt;b_tasktbl
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|lp-&gt;tasktbl
)paren
)paren
suffix:semicolon
id|lp-&gt;tasktbl
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;p_notask
)paren
suffix:semicolon
id|lp-&gt;resel_task
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
c_func
(paren
id|np
comma
id|resel_notag
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialize command queuing control.&n;&t;*/
id|lp-&gt;busyccbs
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;queuedccbs
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;queuedepth
op_assign
l_int|1
suffix:semicolon
id|fail
suffix:colon
r_return
id|lp
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------------&n;**&t;Lun control block setup on INQUIRY data received.&n;**------------------------------------------------------------------------&n;**&t;We only support WIDE, SYNC for targets and CMDQ for logical units.&n;**&t;This setup is done on each INQUIRY since we are expecting user &n;**&t;will play with CHANGE DEFINITION commands. :-)&n;**------------------------------------------------------------------------&n;*/
DECL|function|ncr_setup_lcb
r_static
id|lcb_p
id|ncr_setup_lcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
comma
id|u_char
op_star
id|inq_data
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|ncr_lp
c_func
(paren
id|np
comma
id|tp
comma
id|ln
)paren
suffix:semicolon
id|u_char
id|inq_byte7
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If no lcb, try to allocate it.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|lp
op_logical_and
op_logical_neg
(paren
id|lp
op_assign
id|ncr_alloc_lcb
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
)paren
)paren
r_goto
id|fail
suffix:semicolon
macro_line|#if 0&t;/* No more used. Left here as provision */
multiline_comment|/*&n;&t;**&t;Get device quirks.&n;&t;*/
id|tp-&gt;quirks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;quirks
op_logical_and
id|bootverbose
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;quirks=%x.&bslash;n&quot;
comma
id|tp-&gt;quirks
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Evaluate trustable target/unit capabilities.&n;&t;**&t;We only believe device version &gt;= SCSI-2 that &n;&t;**&t;use appropriate response data format (2).&n;&t;**&t;But it seems that some CCS devices also &n;&t;**&t;support SYNC and I donnot want to frustrate &n;&t;**&t;anybody. ;-)&n;&t;*/
id|inq_byte7
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inq_data
(braket
l_int|2
)braket
op_amp
l_int|0x7
)paren
op_ge
l_int|2
op_logical_and
(paren
id|inq_data
(braket
l_int|3
)braket
op_amp
l_int|0xf
)paren
op_eq
l_int|2
)paren
id|inq_byte7
op_assign
id|inq_data
(braket
l_int|7
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|inq_data
(braket
l_int|2
)braket
op_amp
l_int|0x7
)paren
op_eq
l_int|1
op_logical_and
(paren
id|inq_data
(braket
l_int|3
)braket
op_amp
l_int|0xf
)paren
op_eq
l_int|1
)paren
id|inq_byte7
op_assign
id|INQ7_SYNC
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Throw away announced LUN capabilities if we are told &n;&t;**&t;that there is no real device supported by the logical unit.&n;&t;*/
r_if
c_cond
(paren
(paren
id|inq_data
(braket
l_int|0
)braket
op_amp
l_int|0xe0
)paren
OG
l_int|0x20
op_logical_or
(paren
id|inq_data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
op_eq
l_int|0x1f
)paren
id|inq_byte7
op_and_assign
(paren
id|INQ7_SYNC
op_or
id|INQ7_WIDE16
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If user is wanting SYNC, force this feature.&n;&t;*/
r_if
c_cond
(paren
id|driver_setup.force_sync_nego
)paren
id|inq_byte7
op_or_assign
id|INQ7_SYNC
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Prepare negotiation if SIP capabilities have changed.&n;&t;*/
id|tp-&gt;inq_done
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inq_byte7
op_xor
id|tp-&gt;inq_byte7
)paren
op_amp
(paren
id|INQ7_SYNC
op_or
id|INQ7_WIDE16
)paren
)paren
(brace
id|tp-&gt;inq_byte7
op_assign
id|inq_byte7
suffix:semicolon
id|ncr_negotiate
c_func
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If unit supports tagged commands, allocate and &n;&t;**&t;initialyze the task table if not yet.&n;&t;*/
r_if
c_cond
(paren
(paren
id|inq_byte7
op_amp
id|INQ7_QUEUE
)paren
op_logical_and
id|lp-&gt;tasktbl
op_eq
op_amp
id|lp-&gt;tasktbl_0
)paren
(brace
id|lp-&gt;tasktbl
op_assign
id|m_calloc_dma
c_func
(paren
id|MAX_TASKS
op_star
l_int|4
comma
l_string|&quot;TASKTBL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;tasktbl
)paren
(brace
id|lp-&gt;tasktbl
op_assign
op_amp
id|lp-&gt;tasktbl_0
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|lp-&gt;b_tasktbl
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|lp-&gt;tasktbl
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TASKS
suffix:semicolon
id|i
op_increment
)paren
id|lp-&gt;tasktbl
(braket
id|i
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;p_notask
)paren
suffix:semicolon
id|lp-&gt;cb_tags
op_assign
id|m_calloc
c_func
(paren
id|MAX_TAGS
comma
l_string|&quot;CB_TAGS&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;cb_tags
)paren
r_goto
id|fail
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TAGS
suffix:semicolon
id|i
op_increment
)paren
id|lp-&gt;cb_tags
(braket
id|i
)braket
op_assign
id|i
suffix:semicolon
id|lp-&gt;maxnxs
op_assign
id|MAX_TAGS
suffix:semicolon
id|lp-&gt;tags_stime
op_assign
id|ktime_get
c_func
(paren
l_int|3
op_star
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Adjust tagged queueing status if needed.&n;&t;*/
r_if
c_cond
(paren
(paren
id|inq_byte7
op_xor
id|lp-&gt;inq_byte7
)paren
op_amp
id|INQ7_QUEUE
)paren
(brace
id|lp-&gt;inq_byte7
op_assign
id|inq_byte7
suffix:semicolon
id|lp-&gt;numtags
op_assign
id|lp-&gt;maxtags
suffix:semicolon
id|ncr_setup_tags
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
)brace
id|fail
suffix:colon
r_return
id|lp
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Build Scatter Gather Block&n;**&n;**&n;**==========================================================&n;**&n;**&t;The transfer area may be scattered among&n;**&t;several non adjacent physical pages.&n;**&n;**&t;We may use MAX_SCATTER blocks.&n;**&n;**----------------------------------------------------------&n;*/
multiline_comment|/*&n;**&t;We try to reduce the number of interrupts caused&n;**&t;by unexpected phase changes due to disconnects.&n;**&t;A typical harddisk may disconnect before ANY block.&n;**&t;If we wanted to avoid unexpected phase changes at all&n;**&t;we had to use a break point every 512 bytes.&n;**&t;Of course the number of scatter/gather blocks is&n;**&t;limited.&n;**&t;Under Linux, the scatter/gatter blocks are provided by &n;**&t;the generic driver. We just have to copy addresses and &n;**&t;sizes to the data segment array.&n;*/
multiline_comment|/*&n;**&t;For 64 bit systems, we use the 8 upper bits of the size field &n;**&t;to provide bus address bits 32-39 to the SCRIPTS processor.&n;**&t;This allows the 895A and 896 to address up to 1 TB of memory.&n;**&t;For 32 bit chips on 64 bit systems, we must be provided with &n;**&t;memory addresses that fit into the first 32 bit bus address &n;**&t;range and so, this does not matter and we expect an error from &n;**&t;the chip if this ever happen.&n;**&n;**&t;We use a separate function for the case Linux does not provide &n;**&t;a scatter list in order to allow better code optimization &n;**&t;for the case we have a scatter list (BTW, for now this just wastes  &n;**&t;about 40 bytes of code for x86, but my guess is that the scatter &n;**&t;code will get more complex later).&n;*/
macro_line|#ifdef SCSI_NCR_USE_64BIT_DAC
DECL|macro|SCATTER_ONE
mdefine_line|#define SCATTER_ONE(data, badd, len)&t;&t;&t;&t;&t;&bslash;&n;&t;(data)-&gt;addr = cpu_to_scr(badd);&t;&t;&t;&t;&bslash;&n;&t;(data)-&gt;size = cpu_to_scr((((badd) &gt;&gt; 8) &amp; 0xff000000) + len);
macro_line|#else
DECL|macro|SCATTER_ONE
mdefine_line|#define SCATTER_ONE(data, badd, len)&t;&t;&bslash;&n;&t;(data)-&gt;addr = cpu_to_scr(badd);&t;&bslash;&n;&t;(data)-&gt;size = cpu_to_scr(len);
macro_line|#endif
DECL|macro|CROSS_16MB
mdefine_line|#define CROSS_16MB(p, n) (((((u_long) p) + n - 1) ^ ((u_long) p)) &amp; ~0xffffff)
DECL|function|ncr_scatter_no_sglist
r_static
r_int
id|ncr_scatter_no_sglist
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|scr_tblmove
op_star
id|data
op_assign
op_amp
id|cp-&gt;phys.data
(braket
id|MAX_SCATTER
op_minus
l_int|1
)braket
suffix:semicolon
r_int
id|segment
suffix:semicolon
id|cp-&gt;data_len
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
)paren
(brace
id|u_long
id|baddr
op_assign
id|map_scsi_single_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
id|SCATTER_ONE
c_func
(paren
id|data
comma
id|baddr
comma
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CROSS_16MB
c_func
(paren
id|baddr
comma
id|cmd-&gt;request_bufflen
)paren
)paren
(brace
id|cp-&gt;host_flags
op_or_assign
id|HF_PM_TO_C
suffix:semicolon
macro_line|#ifdef DEBUG_896R1
id|printk
c_func
(paren
l_string|&quot;He! we are crossing a 16 MB boundary (0x%lx, 0x%x)&bslash;n&quot;
comma
id|baddr
comma
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
macro_line|#endif
)brace
id|segment
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|segment
op_assign
l_int|0
suffix:semicolon
r_return
id|segment
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;DEL 472 - 53C896 Rev 1 - Part Number 609-0393055 - ITEM 5.&n;**&n;**&t;We disable data phase mismatch handling from SCRIPTS for data &n;**&t;transfers that contains scatter/gather entries that cross  &n;**&t;a 16 MB boundary.&n;**&t;We use a different scatter function for 896 rev. 1 that needs &n;**&t;such a work-around. Doing so, we do not affect performance for &n;**&t;other chips.&n;**&t;This problem should not be triggered for disk IOs under Linux, &n;**&t;since such IOs are performed using pages and buffers that are &n;**&t;nicely power-of-two sized and aligned. But, since this may change &n;**&t;at any time, a work-around was required.&n;*/
DECL|function|ncr_scatter_896R1
r_static
r_int
id|ncr_scatter_896R1
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|segn
suffix:semicolon
r_int
id|use_sg
op_assign
(paren
r_int
)paren
id|cmd-&gt;use_sg
suffix:semicolon
id|cp-&gt;data_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
id|segn
op_assign
id|ncr_scatter_no_sglist
c_func
(paren
id|np
comma
id|cp
comma
id|cmd
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|use_sg
OG
id|MAX_SCATTER
)paren
id|segn
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
(brace
r_struct
id|scatterlist
op_star
id|scatter
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
r_struct
id|scr_tblmove
op_star
id|data
suffix:semicolon
id|use_sg
op_assign
id|map_scsi_sg_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
id|data
op_assign
op_amp
id|cp-&gt;phys.data
(braket
id|MAX_SCATTER
op_minus
id|use_sg
)braket
suffix:semicolon
r_for
c_loop
(paren
id|segn
op_assign
l_int|0
suffix:semicolon
id|segn
OL
id|use_sg
suffix:semicolon
id|segn
op_increment
)paren
(brace
id|u_long
id|baddr
op_assign
id|scsi_sg_dma_address
c_func
(paren
op_amp
id|scatter
(braket
id|segn
)braket
)paren
suffix:semicolon
r_int
r_int
id|len
op_assign
id|scsi_sg_dma_len
c_func
(paren
op_amp
id|scatter
(braket
id|segn
)braket
)paren
suffix:semicolon
id|SCATTER_ONE
c_func
(paren
op_amp
id|data
(braket
id|segn
)braket
comma
id|baddr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CROSS_16MB
c_func
(paren
id|baddr
comma
id|scatter
(braket
id|segn
)braket
dot
id|length
)paren
)paren
(brace
id|cp-&gt;host_flags
op_or_assign
id|HF_PM_TO_C
suffix:semicolon
macro_line|#ifdef DEBUG_896R1
id|printk
c_func
(paren
l_string|&quot;He! we are crossing a 16 MB boundary (0x%lx, 0x%x)&bslash;n&quot;
comma
id|baddr
comma
id|scatter
(braket
id|segn
)braket
dot
id|length
)paren
suffix:semicolon
macro_line|#endif
)brace
id|cp-&gt;data_len
op_add_assign
id|len
suffix:semicolon
)brace
)brace
r_return
id|segn
suffix:semicolon
)brace
DECL|function|ncr_scatter
r_static
r_int
id|ncr_scatter
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|segment
suffix:semicolon
r_int
id|use_sg
op_assign
(paren
r_int
)paren
id|cmd-&gt;use_sg
suffix:semicolon
id|cp-&gt;data_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
id|segment
op_assign
id|ncr_scatter_no_sglist
c_func
(paren
id|np
comma
id|cp
comma
id|cmd
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|use_sg
OG
id|MAX_SCATTER
)paren
id|segment
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
(brace
r_struct
id|scatterlist
op_star
id|scatter
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
r_struct
id|scr_tblmove
op_star
id|data
suffix:semicolon
id|use_sg
op_assign
id|map_scsi_sg_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
id|data
op_assign
op_amp
id|cp-&gt;phys.data
(braket
id|MAX_SCATTER
op_minus
id|use_sg
)braket
suffix:semicolon
r_for
c_loop
(paren
id|segment
op_assign
l_int|0
suffix:semicolon
id|segment
OL
id|use_sg
suffix:semicolon
id|segment
op_increment
)paren
(brace
id|u_long
id|baddr
op_assign
id|scsi_sg_dma_address
c_func
(paren
op_amp
id|scatter
(braket
id|segment
)braket
)paren
suffix:semicolon
r_int
r_int
id|len
op_assign
id|scsi_sg_dma_len
c_func
(paren
op_amp
id|scatter
(braket
id|segment
)braket
)paren
suffix:semicolon
id|SCATTER_ONE
c_func
(paren
op_amp
id|data
(braket
id|segment
)braket
comma
id|baddr
comma
id|len
)paren
suffix:semicolon
id|cp-&gt;data_len
op_add_assign
id|len
suffix:semicolon
)brace
)brace
r_return
id|segment
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Test the pci bus snoop logic :-(&n;**&n;**&t;Has to be called with interrupts disabled.&n;**&n;**&n;**==========================================================&n;*/
macro_line|#ifndef NCR_IOMAPPED
DECL|function|ncr_regtest
r_static
r_int
id|__init
id|ncr_regtest
(paren
r_struct
id|ncb
op_star
id|np
)paren
(brace
r_register
r_volatile
id|u_int32
id|data
suffix:semicolon
multiline_comment|/*&n;&t;**&t;ncr registers may NOT be cached.&n;&t;**&t;write 0xffffffff to a read only register area,&n;&t;**&t;and try to read it back.&n;&t;*/
id|data
op_assign
l_int|0xffffffff
suffix:semicolon
id|OUTL_OFF
c_func
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_dstat
)paren
comma
id|data
)paren
suffix:semicolon
id|data
op_assign
id|INL_OFF
c_func
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_dstat
)paren
)paren
suffix:semicolon
macro_line|#if 1
r_if
c_cond
(paren
id|data
op_eq
l_int|0xffffffff
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
(paren
id|data
op_amp
l_int|0xe2f0fffd
)paren
op_ne
l_int|0x02000080
)paren
(brace
macro_line|#endif
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: reg dstat-sstat2 readback %x.&bslash;n&quot;
comma
(paren
r_int
)paren
id|data
)paren
suffix:semicolon
r_return
(paren
l_int|0x10
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|ncr_snooptest
r_static
r_int
id|__init
id|ncr_snooptest
(paren
r_struct
id|ncb
op_star
id|np
)paren
(brace
id|u_int32
id|ncr_rd
comma
id|ncr_wr
comma
id|ncr_bk
comma
id|host_rd
comma
id|host_wr
comma
id|pc
suffix:semicolon
r_int
id|i
comma
id|err
op_assign
l_int|0
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
r_if
c_cond
(paren
id|np-&gt;reg
)paren
(brace
id|err
op_or_assign
id|ncr_regtest
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
(paren
id|err
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**&t;init&n;&t;*/
id|pc
op_assign
id|NCB_SCRIPTH0_PHYS
(paren
id|np
comma
id|snooptest
)paren
suffix:semicolon
id|host_wr
op_assign
l_int|1
suffix:semicolon
id|ncr_wr
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set memory and register.&n;&t;*/
id|np-&gt;ncr_cache
op_assign
id|cpu_to_scr
c_func
(paren
id|host_wr
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_temp
comma
id|ncr_wr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Start script (exchange values)&n;&t;*/
id|OUTL
(paren
id|nc_dsa
comma
id|np-&gt;p_ncb
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|pc
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wait &squot;til done (with timeout)&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NCR_SNOOP_TIMEOUT
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_istat
)paren
op_amp
(paren
id|INTF
op_or
id|SIP
op_or
id|DIP
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Save termination position.&n;&t;*/
id|pc
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Read memory and register.&n;&t;*/
id|host_rd
op_assign
id|scr_to_cpu
c_func
(paren
id|np-&gt;ncr_cache
)paren
suffix:semicolon
id|ncr_rd
op_assign
id|INL
(paren
id|nc_scratcha
)paren
suffix:semicolon
id|ncr_bk
op_assign
id|INL
(paren
id|nc_temp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;check for timeout&n;&t;*/
r_if
c_cond
(paren
id|i
op_ge
id|NCR_SNOOP_TIMEOUT
)paren
(brace
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: timeout.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0x20
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Check termination position.&n;&t;*/
r_if
c_cond
(paren
id|pc
op_ne
id|NCB_SCRIPTH0_PHYS
(paren
id|np
comma
id|snoopend
)paren
op_plus
l_int|8
)paren
(brace
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: script execution failed.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;start=%08lx, pc=%08lx, end=%08lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
id|NCB_SCRIPTH0_PHYS
(paren
id|np
comma
id|snooptest
)paren
comma
(paren
id|u_long
)paren
id|pc
comma
(paren
id|u_long
)paren
id|NCB_SCRIPTH0_PHYS
(paren
id|np
comma
id|snoopend
)paren
op_plus
l_int|8
)paren
suffix:semicolon
r_return
(paren
l_int|0x40
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Show results.&n;&t;*/
r_if
c_cond
(paren
id|host_wr
op_ne
id|ncr_rd
)paren
(brace
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: host wrote %d, ncr read %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|host_wr
comma
(paren
r_int
)paren
id|ncr_rd
)paren
suffix:semicolon
id|err
op_or_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|host_rd
op_ne
id|ncr_wr
)paren
(brace
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: ncr wrote %d, host read %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|ncr_wr
comma
(paren
r_int
)paren
id|host_rd
)paren
suffix:semicolon
id|err
op_or_assign
l_int|2
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|ncr_bk
op_ne
id|ncr_wr
)paren
(brace
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: ncr wrote %d, read back %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|ncr_wr
comma
(paren
r_int
)paren
id|ncr_bk
)paren
suffix:semicolon
id|err
op_or_assign
l_int|4
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Profiling the drivers and targets performance.&n;**&n;**&n;**==========================================================&n;*/
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
DECL|function|ncb_profile
r_static
r_void
id|ncb_profile
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
r_int
id|num_disc
op_assign
(paren
id|cp-&gt;phys.num_disc
op_amp
l_int|0xff
)paren
suffix:semicolon
r_int
id|num_disc0
op_assign
(paren
id|cp-&gt;phys.num_disc
op_rshift
l_int|8
)paren
suffix:semicolon
op_increment
id|np-&gt;profile.num_trans
suffix:semicolon
id|np-&gt;profile.num_disc
op_add_assign
id|num_disc
suffix:semicolon
id|np-&gt;profile.num_disc0
op_add_assign
id|num_disc0
suffix:semicolon
id|np-&gt;profile.num_kbytes
op_add_assign
(paren
id|cp-&gt;data_len
op_rshift
l_int|10
)paren
suffix:semicolon
macro_line|#if 000
r_if
c_cond
(paren
id|num_disc
OG
id|num_disc0
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;data_len
op_le
l_int|1024
)paren
id|np-&gt;profile.num_br1k
op_add_assign
(paren
id|num_disc
op_minus
id|num_disc0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cp-&gt;data_len
op_le
l_int|2048
)paren
id|np-&gt;profile.num_br2k
op_add_assign
(paren
id|num_disc
op_minus
id|num_disc0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cp-&gt;data_len
op_le
l_int|4096
)paren
id|np-&gt;profile.num_br4k
op_add_assign
(paren
id|num_disc
op_minus
id|num_disc0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cp-&gt;data_len
op_le
l_int|8192
)paren
id|np-&gt;profile.num_br8k
op_add_assign
(paren
id|num_disc
op_minus
id|num_disc0
)paren
suffix:semicolon
r_else
id|np-&gt;profile.num_brnk
op_add_assign
(paren
id|num_disc
op_minus
id|num_disc0
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
macro_line|#endif /* SCSI_NCR_PROFILE_SUPPORT */
multiline_comment|/*==========================================================&n;**&n;**&t;Determine the ncr&squot;s clock frequency.&n;**&t;This is essential for the negotiation&n;**&t;of the synchronous transfer rate.&n;**&n;**==========================================================&n;**&n;**&t;Note: we have to return the correct value.&n;**&t;THERE IS NO SAFE DEFAULT VALUE.&n;**&n;**&t;Most NCR/SYMBIOS boards are delivered with a 40 Mhz clock.&n;**&t;53C860 and 53C875 rev. 1 support fast20 transfers but &n;**&t;do not have a clock doubler and so are provided with a &n;**&t;80 MHz clock. All other fast20 boards incorporate a doubler &n;**&t;and so should be delivered with a 40 MHz clock.&n;**&t;The recent fast40 chips  (895/896/895A) and the&n;**&t;fast80 chip (C1010) use a 40 Mhz base clock &n;**&t;and provide a clock quadrupler (160 Mhz). The code below &n;**&t;tries to deal as cleverly as possible with all this stuff.&n;**&n;**----------------------------------------------------------&n;*/
multiline_comment|/*&n; *&t;Select NCR SCSI clock frequency&n; */
DECL|function|ncr_selectclock
r_static
r_void
id|ncr_selectclock
c_func
(paren
id|ncb_p
id|np
comma
id|u_char
id|scntl3
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;multiplier
OL
l_int|2
)paren
(brace
id|OUTB
c_func
(paren
id|nc_scntl3
comma
id|scntl3
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
id|printk
(paren
l_string|&quot;%s: enabling clock multiplier&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest1
comma
id|DBLEN
)paren
suffix:semicolon
multiline_comment|/* Enable clock multiplier&t;&t;  */
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_and
(paren
id|np-&gt;device_id
op_ne
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
op_logical_and
(paren
id|np-&gt;multiplier
OG
l_int|2
)paren
)paren
(brace
r_int
id|i
op_assign
l_int|20
suffix:semicolon
multiline_comment|/* Poll bit 5 of stest4 for quadrupler */
r_while
c_loop
(paren
op_logical_neg
(paren
id|INB
c_func
(paren
id|nc_stest4
)paren
op_amp
id|LCKFRQ
)paren
op_logical_and
op_decrement
id|i
OG
l_int|0
)paren
id|UDELAY
(paren
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;%s: the chip cannot lock the frequency&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Wait 120 micro-seconds for multiplier*/
id|UDELAY
(paren
l_int|120
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest3
comma
id|HSC
)paren
suffix:semicolon
multiline_comment|/* Halt the scsi clock&t;&t;*/
id|OUTB
c_func
(paren
id|nc_scntl3
comma
id|scntl3
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest1
comma
(paren
id|DBLEN
op_or
id|DBLSEL
)paren
)paren
suffix:semicolon
multiline_comment|/* Select clock multiplier&t;*/
id|OUTB
c_func
(paren
id|nc_stest3
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* Restart scsi clock &t;&t;*/
)brace
multiline_comment|/*&n; *&t;calculate NCR SCSI clock frequency (in KHz)&n; */
DECL|function|ncrgetfreq
r_static
r_int
id|__init
id|ncrgetfreq
(paren
id|ncb_p
id|np
comma
r_int
id|gen
)paren
(brace
r_int
r_int
id|ms
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|f
suffix:semicolon
r_int
id|count
suffix:semicolon
multiline_comment|/*&n;&t; * Measure GEN timer delay in order &n;&t; * to calculate SCSI clock frequency&n;&t; *&n;&t; * This code will never execute too&n;&t; * many loop iterations (if DELAY is &n;&t; * reasonably correct). It could get&n;&t; * too low a delay (too high a freq.)&n;&t; * if the CPU is slow executing the &n;&t; * loop for some reason (an NMI, for&n;&t; * example). For this reason we will&n;&t; * if multiple measurements are to be &n;&t; * performed trust the higher delay &n;&t; * (lower frequency returned).&n;&t; */
id|OUTW
(paren
id|nc_sien
comma
l_int|0x0
)paren
suffix:semicolon
multiline_comment|/* mask all scsi interrupts */
multiline_comment|/* enable general purpose timer */
(paren
r_void
)paren
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
multiline_comment|/* clear pending scsi interrupt */
id|OUTB
(paren
id|nc_dien
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* mask all dma interrupts */
(paren
r_void
)paren
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
multiline_comment|/* another one, just to be sure :) */
id|OUTB
(paren
id|nc_scntl3
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* set pre-scaler to divide by 3 */
id|OUTB
(paren
id|nc_stime1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable general purpose timer */
id|OUTB
(paren
id|nc_stime1
comma
id|gen
)paren
suffix:semicolon
multiline_comment|/* set to nominal delay of 1&lt;&lt;gen * 125us */
multiline_comment|/* Temporary fix for udelay issue with Alpha&n;&t;&t;&t;&t;&t;platform */
r_while
c_loop
(paren
op_logical_neg
(paren
id|INW
c_func
(paren
id|nc_sist
)paren
op_amp
id|GEN
)paren
op_logical_and
id|ms
op_increment
OL
l_int|100000
)paren
(brace
multiline_comment|/* count 1ms */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|10
suffix:semicolon
id|count
op_increment
)paren
id|UDELAY
(paren
l_int|100
)paren
suffix:semicolon
)brace
id|OUTB
(paren
id|nc_stime1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable general purpose timer */
multiline_comment|/*&n; &t; * set prescaler to divide by whatever 0 means&n; &t; * 0 ought to choose divide by 2, but appears&n; &t; * to set divide by 3.5 mode in my 53c810 ...&n; &t; */
id|OUTB
(paren
id|nc_scntl3
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n; &t; * adjust for prescaler, and convert into KHz &n;&t; * scale values derived empirically. C1010 uses&n;&t; * different dividers&n;  &t; */
macro_line|#if 0
r_if
c_cond
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
id|f
op_assign
id|ms
ques
c_cond
(paren
(paren
l_int|1
op_lshift
id|gen
)paren
op_star
l_int|2866
)paren
op_div
id|ms
suffix:colon
l_int|0
suffix:semicolon
r_else
macro_line|#endif
id|f
op_assign
id|ms
ques
c_cond
(paren
(paren
l_int|1
op_lshift
id|gen
)paren
op_star
l_int|4340
)paren
op_div
id|ms
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
id|printk
(paren
l_string|&quot;%s: Delay (GEN=%d): %u msec, %u KHz&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|gen
comma
id|ms
comma
id|f
)paren
suffix:semicolon
r_return
id|f
suffix:semicolon
)brace
DECL|function|ncr_getfreq
r_static
r_int
id|__init
id|ncr_getfreq
(paren
id|ncb_p
id|np
)paren
(brace
id|u_int
id|f1
comma
id|f2
suffix:semicolon
r_int
id|gen
op_assign
l_int|11
suffix:semicolon
(paren
r_void
)paren
id|ncrgetfreq
(paren
id|np
comma
id|gen
)paren
suffix:semicolon
multiline_comment|/* throw away first result */
id|f1
op_assign
id|ncrgetfreq
(paren
id|np
comma
id|gen
)paren
suffix:semicolon
id|f2
op_assign
id|ncrgetfreq
(paren
id|np
comma
id|gen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f1
OG
id|f2
)paren
id|f1
op_assign
id|f2
suffix:semicolon
multiline_comment|/* trust lower result&t;*/
r_return
id|f1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get/probe NCR SCSI clock frequency&n; */
DECL|function|ncr_getclock
r_static
r_void
id|__init
id|ncr_getclock
(paren
id|ncb_p
id|np
comma
r_int
id|mult
)paren
(brace
r_int
r_char
id|scntl3
op_assign
id|np-&gt;sv_scntl3
suffix:semicolon
r_int
r_char
id|stest1
op_assign
id|np-&gt;sv_stest1
suffix:semicolon
r_int
id|f1
suffix:semicolon
id|np-&gt;multiplier
op_assign
l_int|1
suffix:semicolon
id|f1
op_assign
l_int|40000
suffix:semicolon
multiline_comment|/*&n;&t;**&t;True with 875/895/896/895A with clock multiplier selected&n;&t;*/
r_if
c_cond
(paren
id|mult
OG
l_int|1
op_logical_and
(paren
id|stest1
op_amp
(paren
id|DBLEN
op_plus
id|DBLSEL
)paren
)paren
op_eq
id|DBLEN
op_plus
id|DBLSEL
)paren
(brace
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
id|printk
(paren
l_string|&quot;%s: clock multiplier found&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;multiplier
op_assign
id|mult
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If multiplier not found but a C1010, assume a mult of 4.&n;&t;**&t;If multiplier not found or scntl3 not 7,5,3,&n;&t;**&t;reset chip and get frequency from general purpose timer.&n;&t;**&t;Otherwise trust scntl3 BIOS setting.&n;&t;*/
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_LSI_53C1010_66
)paren
)paren
(brace
id|f1
op_assign
l_int|40000
suffix:semicolon
id|np-&gt;multiplier
op_assign
id|mult
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
id|printk
(paren
l_string|&quot;%s: clock multiplier assumed&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|np-&gt;multiplier
op_ne
id|mult
op_logical_or
(paren
id|scntl3
op_amp
l_int|7
)paren
OL
l_int|3
op_logical_or
op_logical_neg
(paren
id|scntl3
op_amp
l_int|1
)paren
)paren
(brace
id|OUTB
(paren
id|nc_stest1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* make sure doubler is OFF */
id|f1
op_assign
id|ncr_getfreq
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
id|printk
(paren
l_string|&quot;%s: NCR clock is %uKHz&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|f1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f1
OL
l_int|55000
)paren
id|f1
op_assign
l_int|40000
suffix:semicolon
r_else
id|f1
op_assign
l_int|80000
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Suggest to also check the PCI clock frequency &n;&t;&t;**&t;to make sure our frequency calculation algorithm &n;&t;&t;**&t;is not too biased.&n;&t;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_66MHZ
)paren
(brace
id|np-&gt;pciclock_min
op_assign
(paren
l_int|66000
op_star
l_int|55
op_plus
l_int|80
op_minus
l_int|1
)paren
op_div
l_int|80
suffix:semicolon
id|np-&gt;pciclock_max
op_assign
(paren
l_int|66000
op_star
l_int|55
)paren
op_div
l_int|40
suffix:semicolon
)brace
r_else
(brace
id|np-&gt;pciclock_min
op_assign
(paren
l_int|33000
op_star
l_int|55
op_plus
l_int|80
op_minus
l_int|1
)paren
op_div
l_int|80
suffix:semicolon
id|np-&gt;pciclock_max
op_assign
(paren
l_int|33000
op_star
l_int|55
)paren
op_div
l_int|40
suffix:semicolon
)brace
r_if
c_cond
(paren
id|f1
op_eq
l_int|40000
op_logical_and
id|mult
OG
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
id|printk
(paren
l_string|&quot;%s: clock multiplier assumed&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;multiplier
op_assign
id|mult
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|scntl3
op_amp
l_int|7
)paren
op_eq
l_int|3
)paren
id|f1
op_assign
l_int|40000
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|scntl3
op_amp
l_int|7
)paren
op_eq
l_int|5
)paren
id|f1
op_assign
l_int|80000
suffix:semicolon
r_else
id|f1
op_assign
l_int|160000
suffix:semicolon
id|f1
op_div_assign
id|np-&gt;multiplier
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Compute controller synchronous parameters.&n;&t;*/
id|f1
op_mul_assign
id|np-&gt;multiplier
suffix:semicolon
id|np-&gt;clock_khz
op_assign
id|f1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get/probe PCI clock frequency&n; */
DECL|function|ncr_getpciclock
r_static
id|u_int
id|__init
id|ncr_getpciclock
(paren
id|ncb_p
id|np
)paren
(brace
r_static
id|u_int
id|f
suffix:semicolon
id|OUTB
(paren
id|nc_stest1
comma
id|SCLK
)paren
suffix:semicolon
multiline_comment|/* Use the PCI clock as SCSI clock */
id|f
op_assign
id|ncr_getfreq
(paren
id|np
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_stest1
comma
l_int|0
)paren
suffix:semicolon
r_return
id|f
suffix:semicolon
)brace
multiline_comment|/*===================== LINUX ENTRY POINTS SECTION ==========================*/
macro_line|#ifndef uchar
DECL|macro|uchar
mdefine_line|#define uchar unsigned char
macro_line|#endif
macro_line|#ifndef ushort
DECL|macro|ushort
mdefine_line|#define ushort unsigned short
macro_line|#endif
macro_line|#ifndef ulong
DECL|macro|ulong
mdefine_line|#define ulong unsigned long
macro_line|#endif
multiline_comment|/* ---------------------------------------------------------------------&n;**&n;**&t;Driver setup from the boot command line&n;**&n;** ---------------------------------------------------------------------&n;*/
macro_line|#ifdef MODULE
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot; &squot;
macro_line|#else
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot;,&squot;
macro_line|#endif
DECL|macro|OPT_TAGS
mdefine_line|#define OPT_TAGS&t;&t;1
DECL|macro|OPT_MASTER_PARITY
mdefine_line|#define OPT_MASTER_PARITY&t;2
DECL|macro|OPT_SCSI_PARITY
mdefine_line|#define OPT_SCSI_PARITY&t;&t;3
DECL|macro|OPT_DISCONNECTION
mdefine_line|#define OPT_DISCONNECTION&t;4
DECL|macro|OPT_SPECIAL_FEATURES
mdefine_line|#define OPT_SPECIAL_FEATURES&t;5
DECL|macro|OPT_ULTRA_SCSI
mdefine_line|#define OPT_ULTRA_SCSI&t;&t;6
DECL|macro|OPT_FORCE_SYNC_NEGO
mdefine_line|#define OPT_FORCE_SYNC_NEGO&t;7
DECL|macro|OPT_REVERSE_PROBE
mdefine_line|#define OPT_REVERSE_PROBE&t;8
DECL|macro|OPT_DEFAULT_SYNC
mdefine_line|#define OPT_DEFAULT_SYNC&t;9
DECL|macro|OPT_VERBOSE
mdefine_line|#define OPT_VERBOSE&t;&t;10
DECL|macro|OPT_DEBUG
mdefine_line|#define OPT_DEBUG&t;&t;11
DECL|macro|OPT_BURST_MAX
mdefine_line|#define OPT_BURST_MAX&t;&t;12
DECL|macro|OPT_LED_PIN
mdefine_line|#define OPT_LED_PIN&t;&t;13
DECL|macro|OPT_MAX_WIDE
mdefine_line|#define OPT_MAX_WIDE&t;&t;14
DECL|macro|OPT_SETTLE_DELAY
mdefine_line|#define OPT_SETTLE_DELAY&t;15
DECL|macro|OPT_DIFF_SUPPORT
mdefine_line|#define OPT_DIFF_SUPPORT&t;16
DECL|macro|OPT_IRQM
mdefine_line|#define OPT_IRQM&t;&t;17
DECL|macro|OPT_PCI_FIX_UP
mdefine_line|#define OPT_PCI_FIX_UP&t;&t;18
DECL|macro|OPT_BUS_CHECK
mdefine_line|#define OPT_BUS_CHECK&t;&t;19
DECL|macro|OPT_OPTIMIZE
mdefine_line|#define OPT_OPTIMIZE&t;&t;20
DECL|macro|OPT_RECOVERY
mdefine_line|#define OPT_RECOVERY&t;&t;21
DECL|macro|OPT_SAFE_SETUP
mdefine_line|#define OPT_SAFE_SETUP&t;&t;22
DECL|macro|OPT_USE_NVRAM
mdefine_line|#define OPT_USE_NVRAM&t;&t;23
DECL|macro|OPT_EXCLUDE
mdefine_line|#define OPT_EXCLUDE&t;&t;24
DECL|macro|OPT_HOST_ID
mdefine_line|#define OPT_HOST_ID&t;&t;25
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
DECL|macro|OPT_IARB
mdefine_line|#define OPT_IARB&t;&t;26
macro_line|#endif
DECL|variable|__initdata
r_static
r_char
id|setup_token
(braket
)braket
id|__initdata
op_assign
l_string|&quot;tags:&quot;
l_string|&quot;mpar:&quot;
l_string|&quot;spar:&quot;
l_string|&quot;disc:&quot;
l_string|&quot;specf:&quot;
l_string|&quot;ultra:&quot;
l_string|&quot;fsn:&quot;
l_string|&quot;revprob:&quot;
l_string|&quot;sync:&quot;
l_string|&quot;verb:&quot;
l_string|&quot;debug:&quot;
l_string|&quot;burst:&quot;
l_string|&quot;led:&quot;
l_string|&quot;wide:&quot;
l_string|&quot;settle:&quot;
l_string|&quot;diff:&quot;
l_string|&quot;irqm:&quot;
l_string|&quot;pcifix:&quot;
l_string|&quot;buschk:&quot;
l_string|&quot;optim:&quot;
l_string|&quot;recovery:&quot;
l_string|&quot;safe:&quot;
l_string|&quot;nvram:&quot;
l_string|&quot;excl:&quot;
l_string|&quot;hostid:&quot;
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
l_string|&quot;iarb:&quot;
macro_line|#endif
suffix:semicolon
multiline_comment|/* DONNOT REMOVE THIS &squot;;&squot; */
macro_line|#ifdef MODULE
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot; &squot;
macro_line|#else
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot;,&squot;
macro_line|#endif
DECL|function|get_setup_token
r_static
r_int
id|__init
id|get_setup_token
c_func
(paren
r_char
op_star
id|p
)paren
(brace
r_char
op_star
id|cur
op_assign
id|setup_token
suffix:semicolon
r_char
op_star
id|pc
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_ne
l_int|NULL
op_logical_and
(paren
id|pc
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;:&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
op_increment
id|pc
suffix:semicolon
op_increment
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|p
comma
id|cur
comma
id|pc
op_minus
id|cur
)paren
)paren
r_return
id|i
suffix:semicolon
id|cur
op_assign
id|pc
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sym53c8xx_setup
r_int
id|__init
id|sym53c8xx_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
macro_line|#ifdef SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT
r_char
op_star
id|cur
op_assign
id|str
suffix:semicolon
r_char
op_star
id|pc
comma
op_star
id|pv
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_int
id|i
comma
id|c
suffix:semicolon
r_int
id|xi
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_ne
l_int|NULL
op_logical_and
(paren
id|pc
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;:&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_char
op_star
id|pe
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
id|pv
op_assign
id|pc
suffix:semicolon
id|c
op_assign
op_star
op_increment
id|pv
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;n&squot;
)paren
id|val
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;y&squot;
)paren
id|val
op_assign
l_int|1
suffix:semicolon
r_else
id|val
op_assign
(paren
r_int
)paren
id|simple_strtoul
c_func
(paren
id|pv
comma
op_amp
id|pe
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|get_setup_token
c_func
(paren
id|cur
)paren
)paren
(brace
r_case
id|OPT_TAGS
suffix:colon
id|driver_setup.default_tags
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|pe
op_logical_and
op_star
id|pe
op_eq
l_char|&squot;/&squot;
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pe
op_logical_and
op_star
id|pe
op_ne
id|ARG_SEP
op_logical_and
id|i
OL
r_sizeof
(paren
id|driver_setup.tag_ctrl
)paren
op_minus
l_int|1
)paren
(brace
id|driver_setup.tag_ctrl
(braket
id|i
op_increment
)braket
op_assign
op_star
id|pe
op_increment
suffix:semicolon
)brace
id|driver_setup.tag_ctrl
(braket
id|i
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OPT_MASTER_PARITY
suffix:colon
id|driver_setup.master_parity
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SCSI_PARITY
suffix:colon
id|driver_setup.scsi_parity
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_DISCONNECTION
suffix:colon
id|driver_setup.disconnection
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SPECIAL_FEATURES
suffix:colon
id|driver_setup.special_features
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_ULTRA_SCSI
suffix:colon
id|driver_setup.ultra_scsi
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_FORCE_SYNC_NEGO
suffix:colon
id|driver_setup.force_sync_nego
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_REVERSE_PROBE
suffix:colon
id|driver_setup.reverse_probe
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_DEFAULT_SYNC
suffix:colon
id|driver_setup.default_sync
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_VERBOSE
suffix:colon
id|driver_setup.verbose
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_DEBUG
suffix:colon
id|driver_setup.debug
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_BURST_MAX
suffix:colon
id|driver_setup.burst_max
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_LED_PIN
suffix:colon
id|driver_setup.led_pin
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_MAX_WIDE
suffix:colon
id|driver_setup.max_wide
op_assign
id|val
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SETTLE_DELAY
suffix:colon
id|driver_setup.settle_delay
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_DIFF_SUPPORT
suffix:colon
id|driver_setup.diff_support
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_IRQM
suffix:colon
id|driver_setup.irqm
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_PCI_FIX_UP
suffix:colon
id|driver_setup.pci_fix_up
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_BUS_CHECK
suffix:colon
id|driver_setup.bus_check
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_OPTIMIZE
suffix:colon
id|driver_setup.optimize
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_RECOVERY
suffix:colon
id|driver_setup.recovery
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_USE_NVRAM
suffix:colon
id|driver_setup.use_nvram
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SAFE_SETUP
suffix:colon
id|memcpy
c_func
(paren
op_amp
id|driver_setup
comma
op_amp
id|driver_safe_setup
comma
r_sizeof
(paren
id|driver_setup
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_EXCLUDE
suffix:colon
r_if
c_cond
(paren
id|xi
OL
id|SCSI_NCR_MAX_EXCLUDES
)paren
id|driver_setup.excludes
(braket
id|xi
op_increment
)braket
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_HOST_ID
suffix:colon
id|driver_setup.host_id
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
r_case
id|OPT_IARB
suffix:colon
id|driver_setup.iarb
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_setup: unexpected boot option &squot;%.*s&squot; ignored&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|pc
op_minus
id|cur
op_plus
l_int|1
)paren
comma
id|cur
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cur
op_assign
id|strchr
c_func
(paren
id|cur
comma
id|ARG_SEP
)paren
)paren
op_ne
l_int|NULL
)paren
op_increment
id|cur
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT */
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,3,13)
macro_line|#ifndef MODULE
id|__setup
c_func
(paren
l_string|&quot;sym53c8xx=&quot;
comma
id|sym53c8xx_setup
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_static
r_int
id|sym53c8xx_pci_init
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
id|pcidev_t
id|pdev
comma
id|ncr_device
op_star
id|device
)paren
suffix:semicolon
multiline_comment|/*&n;**   Linux entry point for SYM53C8XX devices detection routine.&n;**&n;**   Called by the middle-level scsi drivers at initialization time,&n;**   or at module installation.&n;**&n;**   Read the PCI configuration and try to attach each&n;**   detected NCR board.&n;**&n;**   If NVRAM is present, try to attach boards according to &n;**   the used defined boot order.&n;**&n;**   Returns the number of boards successfully attached.&n;*/
DECL|function|ncr_print_driver_setup
r_static
r_void
id|__init
id|ncr_print_driver_setup
c_func
(paren
r_void
)paren
(brace
DECL|macro|YesNo
mdefine_line|#define YesNo(y)&t;y ? &squot;y&squot; : &squot;n&squot;
id|printk
(paren
id|NAME53C8XX
l_string|&quot;: setup=disc:%c,specf:%d,ultra:%d,tags:%d,sync:%d,&quot;
l_string|&quot;burst:%d,wide:%c,diff:%d,revprob:%c,buschk:0x%x&bslash;n&quot;
comma
id|YesNo
c_func
(paren
id|driver_setup.disconnection
)paren
comma
id|driver_setup.special_features
comma
id|driver_setup.ultra_scsi
comma
id|driver_setup.default_tags
comma
id|driver_setup.default_sync
comma
id|driver_setup.burst_max
comma
id|YesNo
c_func
(paren
id|driver_setup.max_wide
)paren
comma
id|driver_setup.diff_support
comma
id|YesNo
c_func
(paren
id|driver_setup.reverse_probe
)paren
comma
id|driver_setup.bus_check
)paren
suffix:semicolon
id|printk
(paren
id|NAME53C8XX
l_string|&quot;: setup=mpar:%c,spar:%c,fsn=%c,verb:%d,debug:0x%x,&quot;
l_string|&quot;led:%c,settle:%d,irqm:0x%x,nvram:0x%x,pcifix:0x%x&bslash;n&quot;
comma
id|YesNo
c_func
(paren
id|driver_setup.master_parity
)paren
comma
id|YesNo
c_func
(paren
id|driver_setup.scsi_parity
)paren
comma
id|YesNo
c_func
(paren
id|driver_setup.force_sync_nego
)paren
comma
id|driver_setup.verbose
comma
id|driver_setup.debug
comma
id|YesNo
c_func
(paren
id|driver_setup.led_pin
)paren
comma
id|driver_setup.settle_delay
comma
id|driver_setup.irqm
comma
id|driver_setup.use_nvram
comma
id|driver_setup.pci_fix_up
)paren
suffix:semicolon
DECL|macro|YesNo
macro_line|#undef YesNo
)brace
multiline_comment|/*===================================================================&n;**   SYM53C8XX devices description table and chip ids list.&n;**===================================================================&n;*/
DECL|variable|__initdata
r_static
id|ncr_chip
id|ncr_chip_table
(braket
)braket
id|__initdata
op_assign
id|SCSI_NCR_CHIP_TABLE
suffix:semicolon
DECL|variable|__initdata
r_static
id|ushort
id|ncr_chip_ids
(braket
)braket
id|__initdata
op_assign
id|SCSI_NCR_CHIP_IDS
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_PQS_PDS_SUPPORT
multiline_comment|/*===================================================================&n;**    Detect all NCR PQS/PDS boards and keep track of their bus nr.&n;**&n;**    The NCR PQS or PDS card is constructed as a DEC bridge&n;**    behind which sit a proprietary NCR memory controller and&n;**    four or two 53c875s as separate devices.  In its usual mode&n;**    of operation, the 875s are slaved to the memory controller&n;**    for all transfers.  We can tell if an 875 is part of a&n;**    PQS/PDS or not since if it is, it will be on the same bus&n;**    as the memory controller.  To operate with the Linux&n;**    driver, the memory controller is disabled and the 875s&n;**    freed to function independently.  The only wrinkle is that&n;**    the preset SCSI ID (which may be zero) must be read in from&n;**    a special configuration space register of the 875&n;**===================================================================&n;*/
DECL|macro|SCSI_NCR_MAX_PQS_BUS
mdefine_line|#define&t;SCSI_NCR_MAX_PQS_BUS&t;16
DECL|variable|__initdata
r_static
r_int
id|pqs_bus
(braket
id|SCSI_NCR_MAX_PQS_BUS
)braket
id|__initdata
op_assign
(brace
l_int|0
)brace
suffix:semicolon
DECL|function|ncr_detect_pqs_pds
r_static
r_void
id|__init
id|ncr_detect_pqs_pds
c_func
(paren
r_void
)paren
(brace
r_int
id|index
suffix:semicolon
id|pcidev_t
id|dev
op_assign
id|PCIDEV_NULL
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|SCSI_NCR_MAX_PQS_BUS
suffix:semicolon
id|index
op_increment
)paren
(brace
id|u_char
id|tmp
suffix:semicolon
id|dev
op_assign
id|pci_find_device
c_func
(paren
l_int|0x101a
comma
l_int|0x0009
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
id|PCIDEV_NULL
)paren
(brace
id|pqs_bus
(braket
id|index
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
id|NAME53C8XX
l_string|&quot;: NCR PQS/PDS memory controller detected on bus %d&bslash;n&quot;
comma
id|PciBusNumber
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
l_int|0x44
comma
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* bit 1: allow individual 875 configuration */
id|tmp
op_or_assign
l_int|0x2
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|dev
comma
l_int|0x44
comma
id|tmp
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
l_int|0x45
comma
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* bit 2: drive individual 875 interrupts to the bus */
id|tmp
op_or_assign
l_int|0x4
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|dev
comma
l_int|0x45
comma
id|tmp
)paren
suffix:semicolon
id|pqs_bus
(braket
id|index
)braket
op_assign
id|PciBusNumber
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* SCSI_NCR_PQS_PDS_SUPPORT */
multiline_comment|/*===================================================================&n;**    Detect all 53c8xx hosts and then attach them.&n;**&n;**    If we are using NVRAM, once all hosts are detected, we need to &n;**    check any NVRAM for boot order in case detect and boot order &n;**    differ and attach them using the order in the NVRAM.&n;**&n;**    If no NVRAM is found or data appears invalid attach boards in &n;**    the the order they are detected.&n;**===================================================================&n;*/
DECL|function|sym53c8xx_detect
r_int
id|__init
id|sym53c8xx_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
id|pcidev_t
id|pcidev
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|chips
comma
id|hosts
comma
id|count
suffix:semicolon
r_int
id|attach_count
op_assign
l_int|0
suffix:semicolon
id|ncr_device
op_star
id|devtbl
comma
op_star
id|devp
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
id|ncr_nvram
id|nvram0
comma
id|nvram
comma
op_star
id|nvp
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**    PCI is required.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**    Initialize driver general stuff.&n;&t;*/
macro_line|#ifdef SCSI_NCR_PROC_INFO_SUPPORT
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,3,27)
id|tpnt-&gt;proc_dir
op_assign
op_amp
id|proc_scsi_sym53c8xx
suffix:semicolon
macro_line|#else
id|tpnt-&gt;proc_name
op_assign
id|NAME53C8XX
suffix:semicolon
macro_line|#endif
id|tpnt-&gt;proc_info
op_assign
id|sym53c8xx_proc_info
suffix:semicolon
macro_line|#endif
macro_line|#if&t;defined(SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT) &amp;&amp; defined(MODULE)
r_if
c_cond
(paren
id|sym53c8xx
)paren
id|sym53c8xx_setup
c_func
(paren
id|sym53c8xx
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SCSI_NCR_DEBUG_INFO_SUPPORT
id|ncr_debug
op_assign
id|driver_setup.debug
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|initverbose
op_ge
l_int|2
)paren
id|ncr_print_driver_setup
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate the device table since we donnot want to &n;&t;**&t;overflow the kernel stack.&n;&t;**&t;1 x 4K PAGE is enough for more than 40 devices for i386.&n;&t;*/
id|devtbl
op_assign
id|m_calloc
c_func
(paren
id|PAGE_SIZE
comma
l_string|&quot;devtbl&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devtbl
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**    Detect all NCR PQS/PDS memory controllers.&n;&t;*/
macro_line|#ifdef&t;SCSI_NCR_PQS_PDS_SUPPORT
id|ncr_detect_pqs_pds
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t;**    Detect all 53c8xx hosts.&n;&t;**    Save the first Symbios NVRAM content if any &n;&t;**    for the boot order.&n;&t;*/
id|chips
op_assign
r_sizeof
(paren
id|ncr_chip_ids
)paren
op_div
r_sizeof
(paren
id|ncr_chip_ids
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|hosts
op_assign
id|PAGE_SIZE
op_div
r_sizeof
(paren
op_star
id|devtbl
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
id|nvp
op_assign
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x1
)paren
ques
c_cond
op_amp
id|nvram0
suffix:colon
l_int|0
suffix:semicolon
macro_line|#endif
id|j
op_assign
l_int|0
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
id|pcidev
op_assign
id|PCIDEV_NULL
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_char
op_star
id|msg
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
id|hosts
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|j
op_ge
id|chips
)paren
r_break
suffix:semicolon
id|i
op_assign
id|driver_setup.reverse_probe
ques
c_cond
id|chips
op_minus
l_int|1
op_minus
id|j
suffix:colon
id|j
suffix:semicolon
id|pcidev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_NCR
comma
id|ncr_chip_ids
(braket
id|i
)braket
comma
id|pcidev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcidev
op_eq
id|PCIDEV_NULL
)paren
(brace
op_increment
id|j
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Some HW as the HP LH4 may report twice PCI devices */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|devtbl
(braket
id|i
)braket
dot
id|slot.bus
op_eq
id|PciBusNumber
c_func
(paren
id|pcidev
)paren
op_logical_and
id|devtbl
(braket
id|i
)braket
dot
id|slot.device_fn
op_eq
id|PciDeviceFn
c_func
(paren
id|pcidev
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
id|count
)paren
multiline_comment|/* Ignore this device if we already have it */
r_continue
suffix:semicolon
id|devp
op_assign
op_amp
id|devtbl
(braket
id|count
)braket
suffix:semicolon
id|devp-&gt;host_id
op_assign
id|driver_setup.host_id
suffix:semicolon
id|devp-&gt;attach_done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sym53c8xx_pci_init
c_func
(paren
id|tpnt
comma
id|pcidev
comma
id|devp
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
op_increment
id|count
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_if
c_cond
(paren
id|nvp
)paren
(brace
id|ncr_get_nvram
c_func
(paren
id|devp
comma
id|nvp
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|nvp-&gt;type
)paren
(brace
r_case
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; *   Switch to the other nvram buffer, so that &n;&t;&t;&t;&t; *   nvram0 will contain the first Symbios &n;&t;&t;&t;&t; *   format NVRAM content with boot order.&n;&t;&t;&t;&t; */
id|nvp
op_assign
op_amp
id|nvram
suffix:semicolon
id|msg
op_assign
l_string|&quot;with Symbios NVRAM&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCSI_NCR_TEKRAM_NVRAM
suffix:colon
id|msg
op_assign
l_string|&quot;with Tekram NVRAM&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef&t;SCSI_NCR_PQS_PDS_SUPPORT
r_if
c_cond
(paren
id|devp-&gt;pqs_pds
)paren
id|msg
op_assign
l_string|&quot;(NCR PQS/PDS)&quot;
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
id|NAME53C8XX
l_string|&quot;: 53c%s detected %s&bslash;n&quot;
comma
id|devp-&gt;chip.name
comma
id|msg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    If we have found a SYMBIOS NVRAM, use first the NVRAM boot &n;&t;**    sequence as device boot order.&n;&t;**    check devices in the boot record against devices detected. &n;&t;**    attach devices if we find a match. boot table records that &n;&t;**    do not match any detected devices will be ignored. &n;&t;**    devices that do not match any boot table will not be attached&n;&t;**    here but will attempt to be attached during the device table &n;&t;**    rescan.&n;&t;*/
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_if
c_cond
(paren
op_logical_neg
id|nvp
op_logical_or
id|nvram0.type
op_ne
id|SCSI_NCR_SYMBIOS_NVRAM
)paren
r_goto
id|next
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Symbios_host
op_star
id|h
op_assign
op_amp
id|nvram0.data.Symbios.host
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|count
suffix:semicolon
id|j
op_increment
)paren
(brace
id|devp
op_assign
op_amp
id|devtbl
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|h-&gt;device_fn
op_ne
id|devp-&gt;slot.device_fn
op_logical_or
id|h-&gt;bus_nr
op_ne
id|devp-&gt;slot.bus
op_logical_or
id|h-&gt;device_id
op_ne
id|devp-&gt;chip.device_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|devp-&gt;attach_done
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|h-&gt;flags
op_amp
id|SYMBIOS_INIT_SCAN_AT_BOOT
)paren
(brace
id|ncr_get_nvram
c_func
(paren
id|devp
comma
id|nvp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ncr_attach
(paren
id|tpnt
comma
id|attach_count
comma
id|devp
)paren
)paren
id|attach_count
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x80
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
id|NAME53C8XX
l_string|&quot;: 53c%s state OFF thus not attached&bslash;n&quot;
comma
id|devp-&gt;chip.name
)paren
suffix:semicolon
r_else
r_continue
suffix:semicolon
id|devp-&gt;attach_done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|next
suffix:colon
macro_line|#endif
multiline_comment|/* &n;&t;**    Rescan device list to make sure all boards attached.&n;&t;**    Devices without boot records will not be attached yet&n;&t;**    so try to attach them here.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|devp
op_assign
op_amp
id|devtbl
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devp-&gt;attach_done
)paren
(brace
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
id|ncr_get_nvram
c_func
(paren
id|devp
comma
id|nvp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|ncr_attach
(paren
id|tpnt
comma
id|attach_count
comma
id|devp
)paren
)paren
id|attach_count
op_increment
suffix:semicolon
)brace
)brace
id|m_free
c_func
(paren
id|devtbl
comma
id|PAGE_SIZE
comma
l_string|&quot;devtbl&quot;
)paren
suffix:semicolon
r_return
id|attach_count
suffix:semicolon
)brace
multiline_comment|/*===================================================================&n;**   Read and check the PCI configuration for any detected NCR &n;**   boards and save data for attaching after all boards have &n;**   been detected.&n;**===================================================================&n;*/
r_static
r_int
id|__init
DECL|function|sym53c8xx_pci_init
id|sym53c8xx_pci_init
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
id|pcidev_t
id|pdev
comma
id|ncr_device
op_star
id|device
)paren
(brace
id|u_short
id|vendor_id
comma
id|device_id
comma
id|command
comma
id|status_reg
suffix:semicolon
id|u_char
id|cache_line_size
comma
id|latency_timer
suffix:semicolon
id|u_char
id|suggested_cache_line_size
op_assign
l_int|0
suffix:semicolon
id|u_char
id|pci_fix_up
op_assign
id|driver_setup.pci_fix_up
suffix:semicolon
id|u_char
id|revision
suffix:semicolon
id|u_int
id|irq
suffix:semicolon
id|u_long
id|base
comma
id|base_2
comma
id|io_port
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ncr_chip
op_star
id|chip
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|NAME53C8XX
l_string|&quot;: at PCI bus %d, device %d, function %d&bslash;n&quot;
comma
id|PciBusNumber
c_func
(paren
id|pdev
)paren
comma
(paren
r_int
)paren
(paren
id|PciDeviceFn
c_func
(paren
id|pdev
)paren
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
comma
(paren
r_int
)paren
(paren
id|PciDeviceFn
c_func
(paren
id|pdev
)paren
op_amp
l_int|7
)paren
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_DYNAMIC_DMA_MAPPING
r_if
c_cond
(paren
op_logical_neg
id|pci_dma_supported
c_func
(paren
id|pdev
comma
(paren
id|dma_addr_t
)paren
(paren
l_int|0xffffffffUL
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|NAME53C8XX
l_string|&quot;32 BIT PCI BUS DMA ADDRESSING NOT SUPPORTED&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**    Read info from the PCI config space.&n;&t;**    pci_read_config_xxx() functions are assumed to be used for &n;&t;**    successfully detected PCI devices.&n;&t;*/
id|vendor_id
op_assign
id|PciVendorId
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|device_id
op_assign
id|PciDeviceId
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|irq
op_assign
id|PciIrqLine
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|pci_get_base_address
c_func
(paren
id|pdev
comma
id|i
comma
op_amp
id|io_port
)paren
suffix:semicolon
id|i
op_assign
id|pci_get_base_address
c_func
(paren
id|pdev
comma
id|i
comma
op_amp
id|base
)paren
suffix:semicolon
(paren
r_void
)paren
id|pci_get_base_address
c_func
(paren
id|pdev
comma
id|i
comma
op_amp
id|base_2
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
op_amp
id|command
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|revision
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CACHE_LINE_SIZE
comma
op_amp
id|cache_line_size
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|latency_timer
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_STATUS
comma
op_amp
id|status_reg
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PQS_PDS_SUPPORT
multiline_comment|/*&n;&t;**    Match the BUS number for PQS/PDS devices.&n;&t;**    Read the SCSI ID from a special register mapped&n;&t;**    into the configuration space of the individual&n;&t;**    875s.  This register is set up by the PQS bios&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCSI_NCR_MAX_PQS_BUS
op_logical_and
id|pqs_bus
(braket
id|i
)braket
op_ne
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u_char
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|pqs_bus
(braket
id|i
)braket
op_eq
id|PciBusNumber
c_func
(paren
id|pdev
)paren
)paren
(brace
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
l_int|0x84
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|device-&gt;pqs_pds
op_assign
l_int|1
suffix:semicolon
id|device-&gt;host_id
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif /* SCSI_NCR_PQS_PDS_SUPPORT */
multiline_comment|/*&n;&t;**&t;If user excludes this chip, donnot initialize it.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCSI_NCR_MAX_EXCLUDES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|driver_setup.excludes
(braket
id|i
)braket
op_eq
(paren
id|io_port
op_amp
id|PCI_BASE_ADDRESS_IO_MASK
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    Check if the chip is supported&n;&t;*/
id|chip
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|ncr_chip_table
)paren
op_div
r_sizeof
(paren
id|ncr_chip_table
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|device_id
op_ne
id|ncr_chip_table
(braket
id|i
)braket
dot
id|device_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|revision
OG
id|ncr_chip_table
(braket
id|i
)braket
dot
id|revision_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ncr_chip_table
(braket
id|i
)braket
dot
id|features
op_amp
id|FE_LDSTR
)paren
)paren
r_break
suffix:semicolon
id|chip
op_assign
op_amp
id|device-&gt;chip
suffix:semicolon
id|memcpy
c_func
(paren
id|chip
comma
op_amp
id|ncr_chip_table
(braket
id|i
)braket
comma
r_sizeof
(paren
op_star
id|chip
)paren
)paren
suffix:semicolon
id|chip-&gt;revision_id
op_assign
id|revision
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Ignore Symbios chips controlled by SISL RAID controller.&n;&t;**&t;This controller sets value 0x52414944 at RAM end - 16.&n;&t;*/
macro_line|#if defined(__i386__) &amp;&amp; !defined(SCSI_NCR_PCI_MEM_NOT_SUPPORTED)
r_if
c_cond
(paren
id|chip
op_logical_and
(paren
id|base_2
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
)paren
(brace
r_int
r_int
id|ram_size
comma
id|ram_val
suffix:semicolon
id|u_long
id|ram_ptr
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;features
op_amp
id|FE_RAM8K
)paren
id|ram_size
op_assign
l_int|8192
suffix:semicolon
r_else
id|ram_size
op_assign
l_int|4096
suffix:semicolon
id|ram_ptr
op_assign
id|remap_pci_mem
c_func
(paren
id|base_2
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
comma
id|ram_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ram_ptr
)paren
(brace
id|ram_val
op_assign
id|readl_raw
c_func
(paren
id|ram_ptr
op_plus
id|ram_size
op_minus
l_int|16
)paren
suffix:semicolon
id|unmap_pci_mem
c_func
(paren
id|ram_ptr
comma
id|ram_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ram_val
op_eq
l_int|0x52414944
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: not initializing, &quot;
l_string|&quot;driven by SISL RAID controller.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* i386 and PCI MEMORY accessible */
r_if
c_cond
(paren
op_logical_neg
id|chip
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: not initializing, device not supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef __powerpc__
multiline_comment|/*&n;&t;**&t;Fix-up for power/pc.&n;&t;**&t;Should not be performed by the driver.&n;&t;*/
r_if
c_cond
(paren
(paren
id|command
op_amp
(paren
id|PCI_COMMAND_IO
op_or
id|PCI_COMMAND_MEMORY
)paren
)paren
op_ne
(paren
id|PCI_COMMAND_IO
op_or
id|PCI_COMMAND_MEMORY
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: setting%s%s...&bslash;n&quot;
comma
(paren
id|command
op_amp
id|PCI_COMMAND_IO
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; PCI_COMMAND_IO&quot;
comma
(paren
id|command
op_amp
id|PCI_COMMAND_MEMORY
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; PCI_COMMAND_MEMORY&quot;
)paren
suffix:semicolon
id|command
op_or_assign
(paren
id|PCI_COMMAND_IO
op_or
id|PCI_COMMAND_MEMORY
)paren
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,2,0)
r_if
c_cond
(paren
id|is_prep
)paren
(brace
r_if
c_cond
(paren
id|io_port
op_ge
l_int|0x10000000
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: reallocating io_port (Wacky IBM)&quot;
)paren
suffix:semicolon
id|io_port
op_assign
(paren
id|io_port
op_amp
l_int|0x00FFFFFF
)paren
op_or
l_int|0x01000000
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|pdev
comma
id|PCI_BASE_ADDRESS_0
comma
id|io_port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base
op_ge
l_int|0x10000000
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: reallocating base (Wacky IBM)&quot;
)paren
suffix:semicolon
id|base
op_assign
(paren
id|base
op_amp
l_int|0x00FFFFFF
)paren
op_or
l_int|0x01000000
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|pdev
comma
id|PCI_BASE_ADDRESS_1
comma
id|base
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base_2
op_ge
l_int|0x10000000
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: reallocating base2 (Wacky IBM)&quot;
)paren
suffix:semicolon
id|base_2
op_assign
(paren
id|base_2
op_amp
l_int|0x00FFFFFF
)paren
op_or
l_int|0x01000000
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|pdev
comma
id|PCI_BASE_ADDRESS_2
comma
id|base_2
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#endif&t;/* __powerpc__ */
macro_line|#if defined(__i386__) &amp;&amp; !defined(MODULE)
r_if
c_cond
(paren
op_logical_neg
id|cache_line_size
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,1,75)
r_extern
r_char
id|x86
suffix:semicolon
r_switch
c_cond
(paren
id|x86
)paren
(brace
macro_line|#else
r_switch
c_cond
(paren
id|boot_cpu_data.x86
)paren
(brace
macro_line|#endif
r_case
l_int|4
suffix:colon
id|suggested_cache_line_size
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
r_case
l_int|5
suffix:colon
id|suggested_cache_line_size
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* __i386__ */
multiline_comment|/*&n;&t;**    Check availability of IO space, memory space.&n;&t;**    Enable master capability if not yet.&n;&t;**&n;&t;**    We shouldn&squot;t have to care about the IO region when &n;&t;**    we are using MMIO. But calling check_region() from &n;&t;**    both the ncr53c8xx and the sym53c8xx drivers prevents &n;&t;**    from attaching devices from the both drivers.&n;&t;**    If you have a better idea, let me know.&n;&t;*/
multiline_comment|/* #ifdef NCR_IOMAPPED */
macro_line|#if 1
r_if
c_cond
(paren
op_logical_neg
(paren
id|command
op_amp
id|PCI_COMMAND_IO
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: I/O base address (0x%lx) disabled.&bslash;n&quot;
comma
(paren
r_int
)paren
id|io_port
)paren
suffix:semicolon
id|io_port
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|command
op_amp
id|PCI_COMMAND_MEMORY
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: PCI_COMMAND_MEMORY not set.&bslash;n&quot;
)paren
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
id|base_2
op_assign
l_int|0
suffix:semicolon
)brace
id|io_port
op_and_assign
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
id|base
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|base_2
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
multiline_comment|/* #ifdef NCR_IOMAPPED */
macro_line|#if 1
r_if
c_cond
(paren
id|io_port
op_logical_and
id|check_region
(paren
id|io_port
comma
l_int|128
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: IO region 0x%lx[0..127] is in use&bslash;n&quot;
comma
(paren
r_int
)paren
id|io_port
)paren
suffix:semicolon
id|io_port
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|io_port
)paren
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifndef NCR_IOMAPPED
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: MMIO base address disabled.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**    Set MASTER capable and PARITY bit, if not yet.&n;&t;*/
r_if
c_cond
(paren
(paren
id|command
op_amp
(paren
id|PCI_COMMAND_MASTER
op_or
id|PCI_COMMAND_PARITY
)paren
)paren
op_ne
(paren
id|PCI_COMMAND_MASTER
op_or
id|PCI_COMMAND_PARITY
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: setting%s%s...(fix-up)&bslash;n&quot;
comma
(paren
id|command
op_amp
id|PCI_COMMAND_MASTER
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; PCI_COMMAND_MASTER&quot;
comma
(paren
id|command
op_amp
id|PCI_COMMAND_PARITY
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; PCI_COMMAND_PARITY&quot;
)paren
suffix:semicolon
id|command
op_or_assign
(paren
id|PCI_COMMAND_MASTER
op_or
id|PCI_COMMAND_PARITY
)paren
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    Fix some features according to driver setup.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver_setup.special_features
op_amp
l_int|1
)paren
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_SPECIAL_SET
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|driver_setup.special_features
op_amp
l_int|2
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_WRIE
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.special_features
op_amp
l_int|4
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_NOPM
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Work around for errant bit in 895A. The 66Mhz&n;&t;** capable bit is set erroneously. Clear this bit.&n;&t;** (Item 1 DEL 533)&n;&t;**&n;&t;** Make sure Config space and Features agree.&n;&t;**&n;&t;** Recall: writes are not normal to status register -&n;&t;** write a 1 to clear and a 0 to leave unchanged.&n;&t;** Can only reset bits.&n;&t;*/
r_if
c_cond
(paren
id|chip-&gt;features
op_amp
id|FE_66MHZ
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|status_reg
op_amp
id|PCI_STATUS_66MHZ
)paren
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_66MHZ
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|status_reg
op_amp
id|PCI_STATUS_66MHZ
)paren
(brace
id|status_reg
op_assign
id|PCI_STATUS_66MHZ
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|pdev
comma
id|PCI_STATUS
comma
id|status_reg
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_STATUS
comma
op_amp
id|status_reg
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|driver_setup.ultra_scsi
OL
l_int|3
op_logical_and
(paren
id|chip-&gt;features
op_amp
id|FE_ULTRA3
)paren
)paren
(brace
id|chip-&gt;features
op_or_assign
id|FE_ULTRA2
suffix:semicolon
id|chip-&gt;features
op_and_assign
op_complement
id|FE_ULTRA3
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver_setup.ultra_scsi
OL
l_int|2
op_logical_and
(paren
id|chip-&gt;features
op_amp
id|FE_ULTRA2
)paren
)paren
(brace
id|chip-&gt;features
op_or_assign
id|FE_ULTRA
suffix:semicolon
id|chip-&gt;features
op_and_assign
op_complement
id|FE_ULTRA2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver_setup.ultra_scsi
OL
l_int|1
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_ULTRA
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver_setup.max_wide
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_WIDE
suffix:semicolon
multiline_comment|/*&n;&t; * C1010 Ultra3 support requires 16 bit data transfers.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|driver_setup.max_wide
op_logical_and
(paren
id|chip-&gt;features
op_amp
id|FE_ULTRA3
)paren
)paren
(brace
id|chip-&gt;features
op_or_assign
id|FE_ULTRA2
suffix:semicolon
id|chip-&gt;features
op_or_assign
op_complement
id|FE_ULTRA3
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Some features are required to be enabled in order to &n;&t;**&t;work around some chip problems. :) ;)&n;&t;**&t;(ITEM 12 of a DEL about the 896 I haven&squot;t yet).&n;&t;**&t;We must ensure the chip will use WRITE AND INVALIDATE.&n;&t;**&t;The revision number limit is for now arbitrary.&n;&t;*/
r_if
c_cond
(paren
id|device_id
op_eq
id|PCI_DEVICE_ID_NCR_53C896
op_logical_and
id|revision
op_le
l_int|0x10
)paren
(brace
id|chip-&gt;features
op_or_assign
(paren
id|FE_WRIE
op_or
id|FE_CLSE
)paren
suffix:semicolon
id|pci_fix_up
op_or_assign
l_int|3
suffix:semicolon
multiline_comment|/* Force appropriate PCI fix-up */
)brace
macro_line|#ifdef&t;SCSI_NCR_PCI_FIX_UP_SUPPORT
multiline_comment|/*&n;&t;**    Try to fix up PCI config according to wished features.&n;&t;*/
r_if
c_cond
(paren
(paren
id|pci_fix_up
op_amp
l_int|1
)paren
op_logical_and
(paren
id|chip-&gt;features
op_amp
id|FE_CLSE
)paren
op_logical_and
op_logical_neg
id|cache_line_size
op_logical_and
id|suggested_cache_line_size
)paren
(brace
id|cache_line_size
op_assign
id|suggested_cache_line_size
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CACHE_LINE_SIZE
comma
id|cache_line_size
)paren
suffix:semicolon
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: PCI_CACHE_LINE_SIZE set to %d (fix-up).&bslash;n&quot;
comma
id|cache_line_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pci_fix_up
op_amp
l_int|2
)paren
op_logical_and
id|cache_line_size
op_logical_and
(paren
id|chip-&gt;features
op_amp
id|FE_WRIE
)paren
op_logical_and
op_logical_neg
(paren
id|command
op_amp
id|PCI_COMMAND_INVALIDATE
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: setting PCI_COMMAND_INVALIDATE (fix-up)&bslash;n&quot;
)paren
suffix:semicolon
id|command
op_or_assign
id|PCI_COMMAND_INVALIDATE
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    Tune PCI LATENCY TIMER according to burst max length transfer.&n;&t;**    (latency timer &gt;= burst length + 6, we add 10 to be quite sure)&n;&t;*/
r_if
c_cond
(paren
id|chip-&gt;burst_max
op_logical_and
(paren
id|latency_timer
op_eq
l_int|0
op_logical_or
(paren
id|pci_fix_up
op_amp
l_int|4
)paren
)paren
)paren
(brace
id|uchar
id|lt
op_assign
(paren
l_int|1
op_lshift
id|chip-&gt;burst_max
)paren
op_plus
l_int|6
op_plus
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|latency_timer
OL
id|lt
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: changing PCI_LATENCY_TIMER from %d to %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|latency_timer
comma
(paren
r_int
)paren
id|lt
)paren
suffix:semicolon
id|latency_timer
op_assign
id|lt
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|pdev
comma
id|PCI_LATENCY_TIMER
comma
id|latency_timer
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* SCSI_NCR_PCI_FIX_UP_SUPPORT */
multiline_comment|/*&n;&t;**    Initialise ncr_device structure with items required by ncr_attach.&n;&t;*/
id|device-&gt;pdev
op_assign
id|pdev
suffix:semicolon
id|device-&gt;slot.bus
op_assign
id|PciBusNumber
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|device-&gt;slot.device_fn
op_assign
id|PciDeviceFn
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|device-&gt;slot.base
op_assign
id|base
suffix:semicolon
id|device-&gt;slot.base_2
op_assign
id|base_2
suffix:semicolon
id|device-&gt;slot.io_port
op_assign
id|io_port
suffix:semicolon
id|device-&gt;slot.irq
op_assign
id|irq
suffix:semicolon
id|device-&gt;attach_done
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*===================================================================&n;**    Detect and try to read SYMBIOS and TEKRAM NVRAM.&n;**&n;**    Data can be used to order booting of boards.&n;**&n;**    Data is saved in ncr_device structure if NVRAM found. This&n;**    is then used to find drive boot order for ncr_attach().&n;**&n;**    NVRAM data is passed to Scsi_Host_Template later during &n;**    ncr_attach() for any device set up.&n;*===================================================================&n;*/
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
DECL|function|ncr_get_nvram
r_static
r_void
id|__init
id|ncr_get_nvram
c_func
(paren
id|ncr_device
op_star
id|devp
comma
id|ncr_nvram
op_star
id|nvp
)paren
(brace
id|devp-&gt;nvram
op_assign
id|nvp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nvp
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**    Get access to chip IO registers&n;&t;*/
macro_line|#ifdef NCR_IOMAPPED
id|request_region
c_func
(paren
id|devp-&gt;slot.io_port
comma
l_int|128
comma
id|NAME53C8XX
)paren
suffix:semicolon
id|devp-&gt;slot.base_io
op_assign
id|devp-&gt;slot.io_port
suffix:semicolon
macro_line|#else
id|devp-&gt;slot.reg
op_assign
(paren
r_struct
id|ncr_reg
op_star
)paren
id|remap_pci_mem
c_func
(paren
id|devp-&gt;slot.base
comma
l_int|128
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devp-&gt;slot.reg
)paren
r_return
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**    Try to read SYMBIOS nvram.&n;&t;**    Try to read TEKRAM nvram if Symbios nvram not found.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|sym_read_Symbios_nvram
c_func
(paren
op_amp
id|devp-&gt;slot
comma
op_amp
id|nvp-&gt;data.Symbios
)paren
)paren
id|nvp-&gt;type
op_assign
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|sym_read_Tekram_nvram
c_func
(paren
op_amp
id|devp-&gt;slot
comma
id|devp-&gt;chip.device_id
comma
op_amp
id|nvp-&gt;data.Tekram
)paren
)paren
id|nvp-&gt;type
op_assign
id|SCSI_NCR_TEKRAM_NVRAM
suffix:semicolon
r_else
(brace
id|nvp-&gt;type
op_assign
l_int|0
suffix:semicolon
id|devp-&gt;nvram
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Release access to chip IO registers&n;&t;*/
macro_line|#ifdef NCR_IOMAPPED
id|release_region
c_func
(paren
id|devp-&gt;slot.base_io
comma
l_int|128
)paren
suffix:semicolon
macro_line|#else
id|unmap_pci_mem
c_func
(paren
(paren
id|u_long
)paren
id|devp-&gt;slot.reg
comma
l_int|128ul
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif&t;/* SCSI_NCR_NVRAM_SUPPORT */
multiline_comment|/*&n;**   Linux select queue depths function&n;*/
DECL|macro|DEF_DEPTH
mdefine_line|#define DEF_DEPTH&t;(driver_setup.default_tags)
DECL|macro|ALL_TARGETS
mdefine_line|#define ALL_TARGETS&t;-2
DECL|macro|NO_TARGET
mdefine_line|#define NO_TARGET&t;-1
DECL|macro|ALL_LUNS
mdefine_line|#define ALL_LUNS&t;-2
DECL|macro|NO_LUN
mdefine_line|#define NO_LUN&t;&t;-1
DECL|function|device_queue_depth
r_static
r_int
id|device_queue_depth
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|target
comma
r_int
id|lun
)paren
(brace
r_int
id|c
comma
id|h
comma
id|t
comma
id|u
comma
id|v
suffix:semicolon
r_char
op_star
id|p
op_assign
id|driver_setup.tag_ctrl
suffix:semicolon
r_char
op_star
id|ep
suffix:semicolon
id|h
op_assign
op_minus
l_int|1
suffix:semicolon
id|t
op_assign
id|NO_TARGET
suffix:semicolon
id|u
op_assign
id|NO_LUN
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|p
op_increment
)paren
op_ne
l_int|0
)paren
(brace
id|v
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|ep
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;/&squot;
suffix:colon
op_increment
id|h
suffix:semicolon
id|t
op_assign
id|ALL_TARGETS
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
r_if
c_cond
(paren
id|t
op_ne
id|target
)paren
id|t
op_assign
(paren
id|target
op_eq
id|v
)paren
ques
c_cond
id|v
suffix:colon
id|NO_TARGET
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;u&squot;
suffix:colon
r_if
c_cond
(paren
id|u
op_ne
id|lun
)paren
id|u
op_assign
(paren
id|lun
op_eq
id|v
)paren
ques
c_cond
id|v
suffix:colon
id|NO_LUN
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;q&squot;
suffix:colon
r_if
c_cond
(paren
id|h
op_eq
id|np-&gt;unit
op_logical_and
(paren
id|t
op_eq
id|ALL_TARGETS
op_logical_or
id|t
op_eq
id|target
)paren
op_logical_and
(paren
id|u
op_eq
id|ALL_LUNS
op_logical_or
id|u
op_eq
id|lun
)paren
)paren
r_return
id|v
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;-&squot;
suffix:colon
id|t
op_assign
id|ALL_TARGETS
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|p
op_assign
id|ep
suffix:semicolon
)brace
r_return
id|DEF_DEPTH
suffix:semicolon
)brace
DECL|function|sym53c8xx_select_queue_depths
r_static
r_void
id|sym53c8xx_select_queue_depths
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|scsi_device
op_star
id|devlist
)paren
(brace
r_struct
id|scsi_device
op_star
id|device
suffix:semicolon
r_for
c_loop
(paren
id|device
op_assign
id|devlist
suffix:semicolon
id|device
suffix:semicolon
id|device
op_assign
id|device-&gt;next
)paren
(brace
id|ncb_p
id|np
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
r_int
id|numtags
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;host
op_ne
id|host
)paren
r_continue
suffix:semicolon
id|np
op_assign
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|device-&gt;id
)braket
suffix:semicolon
id|lp
op_assign
id|ncr_lp
c_func
(paren
id|np
comma
id|tp
comma
id|device-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Select queue depth from driver setup.&n;&t;&t;**&t;Donnot use more than configured by user.&n;&t;&t;**&t;Use at least 2.&n;&t;&t;**&t;Donnot use more than our maximum.&n;&t;&t;*/
id|numtags
op_assign
id|device_queue_depth
c_func
(paren
id|np
comma
id|device-&gt;id
comma
id|device-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|numtags
OG
id|tp-&gt;usrtags
)paren
id|numtags
op_assign
id|tp-&gt;usrtags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;tagged_supported
)paren
id|numtags
op_assign
l_int|1
suffix:semicolon
id|device-&gt;queue_depth
op_assign
id|numtags
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;queue_depth
OL
l_int|2
)paren
id|device-&gt;queue_depth
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;queue_depth
OG
id|MAX_TAGS
)paren
id|device-&gt;queue_depth
op_assign
id|MAX_TAGS
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Since the queue depth is not tunable under Linux,&n;&t;&t;**&t;we need to know this value in order not to &n;&t;&t;**&t;announce stupid things to user.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp
)paren
(brace
id|lp-&gt;numtags
op_assign
id|lp-&gt;maxtags
op_assign
id|numtags
suffix:semicolon
id|lp-&gt;scdev_depth
op_assign
id|device-&gt;queue_depth
suffix:semicolon
)brace
id|ncr_setup_tags
(paren
id|np
comma
id|device-&gt;id
comma
id|device-&gt;lun
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SYM53C8XX
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_select_queue_depth: host=%d, id=%d, lun=%d, depth=%d&bslash;n&quot;
comma
id|np-&gt;unit
comma
id|device-&gt;id
comma
id|device-&gt;lun
comma
id|device-&gt;queue_depth
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*&n;**   Linux entry point for info() function&n;*/
DECL|function|sym53c8xx_info
r_const
r_char
op_star
id|sym53c8xx_info
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_return
id|SCSI_NCR_DRIVER_NAME
suffix:semicolon
)brace
multiline_comment|/*&n;**   Linux entry point of queuecommand() function&n;*/
DECL|function|sym53c8xx_queue_command
r_int
id|sym53c8xx_queue_command
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|ncb_p
id|np
op_assign
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|sts
suffix:semicolon
macro_line|#ifdef DEBUG_SYM53C8XX
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_queue_command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef SCSI_NCR_DYNAMIC_DMA_MAPPING
id|cmd-&gt;__data_mapped
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;__data_mapping
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sts
op_assign
id|ncr_queue_command
c_func
(paren
id|np
comma
id|cmd
)paren
)paren
op_ne
id|DID_OK
)paren
(brace
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|sts
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SYM53C8XX
id|printk
c_func
(paren
l_string|&quot;sym53c8xx : command not queued - result=%d&bslash;n&quot;
comma
id|sts
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef DEBUG_SYM53C8XX
r_else
id|printk
c_func
(paren
l_string|&quot;sym53c8xx : command successfully queued&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
op_ne
id|DID_OK
)paren
(brace
id|unmap_scsi_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
r_return
id|sts
suffix:semicolon
)brace
multiline_comment|/*&n;**   Linux entry point of the interrupt handler.&n;**   Since linux versions &gt; 1.3.70, we trust the kernel for &n;**   passing the internal host descriptor as &squot;dev_id&squot;.&n;**   Otherwise, we scan the host list and call the interrupt &n;**   routine for each host that uses this IRQ.&n;*/
DECL|function|sym53c8xx_intr
r_static
r_void
id|sym53c8xx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ncb_p
id|np
op_assign
(paren
id|ncb_p
)paren
id|dev_id
suffix:semicolon
id|Scsi_Cmnd
op_star
id|done_list
suffix:semicolon
macro_line|#ifdef DEBUG_SYM53C8XX
id|printk
c_func
(paren
l_string|&quot;sym53c8xx : interrupt received&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;[&quot;
)paren
suffix:semicolon
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_exception
c_func
(paren
id|np
)paren
suffix:semicolon
id|done_list
op_assign
id|np-&gt;done_list
suffix:semicolon
id|np-&gt;done_list
op_assign
l_int|0
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done_list
)paren
(brace
id|NCR_LOCK_SCSI_DONE
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_flush_done_cmds
c_func
(paren
id|done_list
)paren
suffix:semicolon
id|NCR_UNLOCK_SCSI_DONE
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;**   Linux entry point of the timer handler&n;*/
DECL|function|sym53c8xx_timeout
r_static
r_void
id|sym53c8xx_timeout
c_func
(paren
r_int
r_int
id|npref
)paren
(brace
id|ncb_p
id|np
op_assign
(paren
id|ncb_p
)paren
id|npref
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Cmnd
op_star
id|done_list
suffix:semicolon
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_timeout
c_func
(paren
(paren
id|ncb_p
)paren
id|np
)paren
suffix:semicolon
id|done_list
op_assign
id|np-&gt;done_list
suffix:semicolon
id|np-&gt;done_list
op_assign
l_int|0
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done_list
)paren
(brace
id|NCR_LOCK_SCSI_DONE
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_flush_done_cmds
c_func
(paren
id|done_list
)paren
suffix:semicolon
id|NCR_UNLOCK_SCSI_DONE
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;**   Linux entry point of reset() function&n;*/
macro_line|#if defined SCSI_RESET_SYNCHRONOUS &amp;&amp; defined SCSI_RESET_ASYNCHRONOUS
DECL|function|sym53c8xx_reset
r_int
id|sym53c8xx_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_int
id|reset_flags
)paren
macro_line|#else
r_int
id|sym53c8xx_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
macro_line|#endif
(brace
id|ncb_p
id|np
op_assign
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
suffix:semicolon
r_int
id|sts
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Cmnd
op_star
id|done_list
suffix:semicolon
macro_line|#if defined SCSI_RESET_SYNCHRONOUS &amp;&amp; defined SCSI_RESET_ASYNCHRONOUS
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_reset: pid=%lu reset_flags=%x serial_number=%ld serial_number_at_timeout=%ld&bslash;n&quot;
comma
id|cmd-&gt;pid
comma
id|reset_flags
comma
id|cmd-&gt;serial_number
comma
id|cmd-&gt;serial_number_at_timeout
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_reset: command pid %lu&bslash;n&quot;
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
macro_line|#endif
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have to just ignore reset requests in some situations.&n;&t; */
macro_line|#if defined SCSI_RESET_NOT_RUNNING
r_if
c_cond
(paren
id|cmd-&gt;serial_number
op_ne
id|cmd-&gt;serial_number_at_timeout
)paren
(brace
id|sts
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * If the mid-level driver told us reset is synchronous, it seems &n;&t; * that we must call the done() callback for the involved command, &n;&t; * even if this command was not queued to the low-level driver, &n;&t; * before returning SCSI_RESET_SUCCESS.&n;&t; */
macro_line|#if defined SCSI_RESET_SYNCHRONOUS &amp;&amp; defined SCSI_RESET_ASYNCHRONOUS
id|sts
op_assign
id|ncr_reset_bus
c_func
(paren
id|np
comma
id|cmd
comma
(paren
id|reset_flags
op_amp
(paren
id|SCSI_RESET_SYNCHRONOUS
op_or
id|SCSI_RESET_ASYNCHRONOUS
)paren
)paren
op_eq
id|SCSI_RESET_SYNCHRONOUS
)paren
suffix:semicolon
macro_line|#else
id|sts
op_assign
id|ncr_reset_bus
c_func
(paren
id|np
comma
id|cmd
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Since we always reset the controller, when we return success, &n;&t; * we add this information to the return code.&n;&t; */
macro_line|#if defined SCSI_RESET_HOST_RESET
r_if
c_cond
(paren
id|sts
op_eq
id|SCSI_RESET_SUCCESS
)paren
id|sts
op_or_assign
id|SCSI_RESET_HOST_RESET
suffix:semicolon
macro_line|#endif
id|out
suffix:colon
id|done_list
op_assign
id|np-&gt;done_list
suffix:semicolon
id|np-&gt;done_list
op_assign
l_int|0
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_flush_done_cmds
c_func
(paren
id|done_list
)paren
suffix:semicolon
r_return
id|sts
suffix:semicolon
)brace
multiline_comment|/*&n;**   Linux entry point of abort() function&n;*/
DECL|function|sym53c8xx_abort
r_int
id|sym53c8xx_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|ncb_p
id|np
op_assign
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
suffix:semicolon
r_int
id|sts
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Cmnd
op_star
id|done_list
suffix:semicolon
macro_line|#if defined SCSI_RESET_SYNCHRONOUS &amp;&amp; defined SCSI_RESET_ASYNCHRONOUS
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_abort: pid=%lu serial_number=%ld serial_number_at_timeout=%ld&bslash;n&quot;
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;serial_number
comma
id|cmd-&gt;serial_number_at_timeout
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_abort: command pid %lu&bslash;n&quot;
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
macro_line|#endif
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
macro_line|#if defined SCSI_RESET_SYNCHRONOUS &amp;&amp; defined SCSI_RESET_ASYNCHRONOUS
multiline_comment|/*&n;&t; * We have to just ignore abort requests in some situations.&n;&t; */
r_if
c_cond
(paren
id|cmd-&gt;serial_number
op_ne
id|cmd-&gt;serial_number_at_timeout
)paren
(brace
id|sts
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#endif
id|sts
op_assign
id|ncr_abort_command
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
id|out
suffix:colon
id|done_list
op_assign
id|np-&gt;done_list
suffix:semicolon
id|np-&gt;done_list
op_assign
l_int|0
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_flush_done_cmds
c_func
(paren
id|done_list
)paren
suffix:semicolon
r_return
id|sts
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|sym53c8xx_release
r_int
id|sym53c8xx_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
macro_line|#ifdef DEBUG_SYM53C8XX
id|printk
c_func
(paren
l_string|&quot;sym53c8xx : release&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|ncr_detach
c_func
(paren
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;**&t;Scsi command waiting list management.&n;**&n;**&t;It may happen that we cannot insert a scsi command into the start queue,&n;**&t;in the following circumstances.&n;** &t;&t;Too few preallocated ccb(s), &n;**&t;&t;maxtags &lt; cmd_per_lun of the Linux host control block,&n;**&t;&t;etc...&n;**&t;Such scsi commands are inserted into a waiting list.&n;**&t;When a scsi command complete, we try to requeue the commands of the&n;**&t;waiting list.&n;*/
DECL|macro|next_wcmd
mdefine_line|#define next_wcmd host_scribble
DECL|function|insert_into_waiting_list
r_static
r_void
id|insert_into_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|Scsi_Cmnd
op_star
id|wcmd
suffix:semicolon
macro_line|#ifdef DEBUG_WAITING_LIST
id|printk
c_func
(paren
l_string|&quot;%s: cmd %lx inserted into waiting list&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|cmd-&gt;next_wcmd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|wcmd
op_assign
id|np-&gt;waiting_list
)paren
)paren
id|np-&gt;waiting_list
op_assign
id|cmd
suffix:semicolon
r_else
(brace
r_while
c_loop
(paren
(paren
id|wcmd-&gt;next_wcmd
)paren
op_ne
l_int|0
)paren
id|wcmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|wcmd-&gt;next_wcmd
suffix:semicolon
id|wcmd-&gt;next_wcmd
op_assign
(paren
r_char
op_star
)paren
id|cmd
suffix:semicolon
)brace
)brace
DECL|function|retrieve_from_waiting_list
r_static
id|Scsi_Cmnd
op_star
id|retrieve_from_waiting_list
c_func
(paren
r_int
id|to_remove
comma
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|Scsi_Cmnd
op_star
op_star
id|pcmd
op_assign
op_amp
id|np-&gt;waiting_list
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pcmd
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_eq
op_star
id|pcmd
)paren
(brace
r_if
c_cond
(paren
id|to_remove
)paren
(brace
op_star
id|pcmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;next_wcmd
suffix:semicolon
id|cmd-&gt;next_wcmd
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_WAITING_LIST
id|printk
c_func
(paren
l_string|&quot;%s: cmd %lx retrieved from waiting list&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|cmd
)paren
suffix:semicolon
macro_line|#endif
r_return
id|cmd
suffix:semicolon
)brace
id|pcmd
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
op_star
id|pcmd
)paren
op_member_access_from_pointer
id|next_wcmd
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|process_waiting_list
r_static
r_void
id|process_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|sts
)paren
(brace
id|Scsi_Cmnd
op_star
id|waiting_list
comma
op_star
id|wcmd
suffix:semicolon
id|waiting_list
op_assign
id|np-&gt;waiting_list
suffix:semicolon
id|np-&gt;waiting_list
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_WAITING_LIST
r_if
c_cond
(paren
id|waiting_list
)paren
id|printk
c_func
(paren
l_string|&quot;%s: waiting_list=%lx processing sts=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|waiting_list
comma
id|sts
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
(paren
id|wcmd
op_assign
id|waiting_list
)paren
op_ne
l_int|0
)paren
(brace
id|waiting_list
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|wcmd-&gt;next_wcmd
suffix:semicolon
id|wcmd-&gt;next_wcmd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sts
op_eq
id|DID_OK
)paren
(brace
macro_line|#ifdef DEBUG_WAITING_LIST
id|printk
c_func
(paren
l_string|&quot;%s: cmd %lx trying to requeue&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|wcmd
)paren
suffix:semicolon
macro_line|#endif
id|sts
op_assign
id|ncr_queue_command
c_func
(paren
id|np
comma
id|wcmd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sts
op_ne
id|DID_OK
)paren
(brace
macro_line|#ifdef DEBUG_WAITING_LIST
id|printk
c_func
(paren
l_string|&quot;%s: cmd %lx done forced sts=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|wcmd
comma
id|sts
)paren
suffix:semicolon
macro_line|#endif
id|SetScsiResult
c_func
(paren
id|wcmd
comma
id|sts
comma
l_int|0
)paren
suffix:semicolon
id|ncr_queue_done_cmd
c_func
(paren
id|np
comma
id|wcmd
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|macro|next_wcmd
macro_line|#undef next_wcmd
macro_line|#ifdef SCSI_NCR_PROC_INFO_SUPPORT
multiline_comment|/*=========================================================================&n;**&t;Proc file system stuff&n;**&n;**&t;A read operation returns profile information.&n;**&t;A write operation is a control command.&n;**&t;The string is parsed in the driver code and the command is passed &n;**&t;to the ncr_usercmd() function.&n;**=========================================================================&n;*/
macro_line|#ifdef SCSI_NCR_USER_COMMAND_SUPPORT
DECL|macro|is_digit
mdefine_line|#define is_digit(c)&t;((c) &gt;= &squot;0&squot; &amp;&amp; (c) &lt;= &squot;9&squot;)
DECL|macro|digit_to_bin
mdefine_line|#define digit_to_bin(c)&t;((c) - &squot;0&squot;)
DECL|macro|is_space
mdefine_line|#define is_space(c)&t;((c) == &squot; &squot; || (c) == &squot;&bslash;t&squot;)
DECL|function|skip_spaces
r_static
r_int
id|skip_spaces
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
)paren
(brace
r_int
id|cnt
comma
id|c
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
id|len
suffix:semicolon
id|cnt
OG
l_int|0
op_logical_and
(paren
id|c
op_assign
op_star
id|ptr
op_increment
)paren
op_logical_and
id|is_space
c_func
(paren
id|c
)paren
suffix:semicolon
id|cnt
op_decrement
)paren
suffix:semicolon
r_return
(paren
id|len
op_minus
id|cnt
)paren
suffix:semicolon
)brace
DECL|function|get_int_arg
r_static
r_int
id|get_int_arg
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
comma
id|u_long
op_star
id|pv
)paren
(brace
r_int
id|cnt
comma
id|c
suffix:semicolon
id|u_long
id|v
suffix:semicolon
r_for
c_loop
(paren
id|v
op_assign
l_int|0
comma
id|cnt
op_assign
id|len
suffix:semicolon
id|cnt
OG
l_int|0
op_logical_and
(paren
id|c
op_assign
op_star
id|ptr
op_increment
)paren
op_logical_and
id|is_digit
c_func
(paren
id|c
)paren
suffix:semicolon
id|cnt
op_decrement
)paren
(brace
id|v
op_assign
(paren
id|v
op_star
l_int|10
)paren
op_plus
id|digit_to_bin
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pv
)paren
op_star
id|pv
op_assign
id|v
suffix:semicolon
r_return
(paren
id|len
op_minus
id|cnt
)paren
suffix:semicolon
)brace
DECL|function|is_keyword
r_static
r_int
id|is_keyword
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
comma
r_char
op_star
id|verb
)paren
(brace
r_int
id|verb_len
op_assign
id|strlen
c_func
(paren
id|verb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|strlen
c_func
(paren
id|verb
)paren
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|verb
comma
id|ptr
comma
id|verb_len
)paren
)paren
r_return
id|verb_len
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SKIP_SPACES
mdefine_line|#define SKIP_SPACES(min_spaces)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if ((arg_len = skip_spaces(ptr, len)) &lt; (min_spaces))&t;&t;&bslash;&n;&t;&t;return -EINVAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ptr += arg_len; len -= arg_len;
DECL|macro|GET_INT_ARG
mdefine_line|#define GET_INT_ARG(v)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!(arg_len = get_int_arg(ptr, len, &amp;(v))))&t;&t;&t;&bslash;&n;&t;&t;return -EINVAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ptr += arg_len; len -= arg_len;
multiline_comment|/*&n;**&t;Parse a control command&n;*/
DECL|function|ncr_user_command
r_static
r_int
id|ncr_user_command
c_func
(paren
id|ncb_p
id|np
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_char
op_star
id|ptr
op_assign
id|buffer
suffix:semicolon
r_int
id|len
op_assign
id|length
suffix:semicolon
r_struct
id|usrcmd
op_star
id|uc
op_assign
op_amp
id|np-&gt;user
suffix:semicolon
r_int
id|arg_len
suffix:semicolon
id|u_long
id|target
suffix:semicolon
id|bzero
c_func
(paren
id|uc
comma
r_sizeof
(paren
op_star
id|uc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
op_logical_and
id|ptr
(braket
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
op_decrement
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setsync&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETSYNC
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;settags&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETTAGS
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setorder&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETORDER
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setverbose&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETVERBOSE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setwide&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETWIDE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setdebug&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETDEBUG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setflag&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETFLAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;resetdev&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_RESETDEV
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;cleardev&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_CLEARDEV
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;clearprof&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_CLEARPROF
suffix:semicolon
macro_line|#endif
r_else
id|arg_len
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;ncr_user_command: arg_len=%d, cmd=%ld&bslash;n&quot;
comma
id|arg_len
comma
id|uc-&gt;cmd
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|arg_len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETSYNC
suffix:colon
r_case
id|UC_SETTAGS
suffix:colon
r_case
id|UC_SETWIDE
suffix:colon
r_case
id|UC_SETFLAG
suffix:colon
r_case
id|UC_RESETDEV
suffix:colon
r_case
id|UC_CLEARDEV
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;all&quot;
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
id|uc-&gt;target
op_assign
op_complement
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|GET_INT_ARG
c_func
(paren
id|target
)paren
suffix:semicolon
id|uc-&gt;target
op_assign
(paren
l_int|1
op_lshift
id|target
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;ncr_user_command: target=%ld&bslash;n&quot;
comma
id|target
)paren
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETVERBOSE
suffix:colon
r_case
id|UC_SETSYNC
suffix:colon
r_case
id|UC_SETTAGS
suffix:colon
r_case
id|UC_SETWIDE
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|GET_INT_ARG
c_func
(paren
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;ncr_user_command: data=%ld&bslash;n&quot;
comma
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|UC_SETORDER
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;simple&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
id|M_SIMPLE_TAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;ordered&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
id|M_ORDERED_TAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;default&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
l_int|0
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETDEBUG
suffix:colon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;alloc&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_ALLOC
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;phase&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_PHASE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;queue&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_QUEUE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;result&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_RESULT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;pointer&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_POINTER
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;script&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_SCRIPT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;tiny&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TINY
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;timing&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TIMING
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;nego&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_NEGO
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;tags&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TAGS
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;ncr_user_command: data=%ld&bslash;n&quot;
comma
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|UC_SETFLAG
suffix:colon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;trace&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|UF_TRACE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;no_disc&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|UF_NODISC
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
(brace
r_int
id|flags
suffix:semicolon
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_usercmd
(paren
id|np
)paren
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|length
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_NCR_USER_COMMAND_SUPPORT */
macro_line|#ifdef SCSI_NCR_USER_INFO_SUPPORT
DECL|struct|info_str
r_struct
id|info_str
(brace
DECL|member|buffer
r_char
op_star
id|buffer
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|pos
r_int
id|pos
suffix:semicolon
)brace
suffix:semicolon
DECL|function|copy_mem_info
r_static
r_void
id|copy_mem_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OG
id|info-&gt;length
)paren
id|len
op_assign
id|info-&gt;length
op_minus
id|info-&gt;pos
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OL
id|info-&gt;offset
)paren
(brace
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;pos
OL
id|info-&gt;offset
)paren
(brace
id|data
op_add_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|info-&gt;buffer
op_plus
id|info-&gt;pos
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
)brace
)brace
DECL|function|copy_info
r_static
r_int
id|copy_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
l_int|81
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|len
op_assign
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
id|copy_mem_info
c_func
(paren
id|info
comma
id|buf
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Copy formatted profile information into the input buffer.&n;*/
DECL|macro|to_ms
mdefine_line|#define to_ms(t) ((t) * 1000 / HZ)
DECL|function|ncr_host_info
r_static
r_int
id|ncr_host_info
c_func
(paren
id|ncb_p
id|np
comma
r_char
op_star
id|ptr
comma
id|off_t
id|offset
comma
r_int
id|len
)paren
(brace
r_struct
id|info_str
id|info
suffix:semicolon
id|info.buffer
op_assign
id|ptr
suffix:semicolon
id|info.length
op_assign
id|len
suffix:semicolon
id|info.offset
op_assign
id|offset
suffix:semicolon
id|info.pos
op_assign
l_int|0
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;General information:&bslash;n&quot;
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Chip &quot;
id|NAME53C
l_string|&quot;%s, device id 0x%x, &quot;
l_string|&quot;revision id 0x%x&bslash;n&quot;
comma
id|np-&gt;chip_name
comma
id|np-&gt;device_id
comma
id|np-&gt;revision_id
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  On PCI bus %d, device %d, function %d, &quot;
macro_line|#ifdef __sparc__
l_string|&quot;IRQ %s&bslash;n&quot;
comma
macro_line|#else
l_string|&quot;IRQ %d&bslash;n&quot;
comma
macro_line|#endif
id|np-&gt;bus
comma
(paren
id|np-&gt;device_fn
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
comma
id|np-&gt;device_fn
op_amp
l_int|7
comma
macro_line|#ifdef __sparc__
id|__irq_itoa
c_func
(paren
id|np-&gt;irq
)paren
)paren
suffix:semicolon
macro_line|#else
(paren
r_int
)paren
id|np-&gt;irq
)paren
suffix:semicolon
macro_line|#endif
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Synchronous period factor %d, &quot;
l_string|&quot;max commands per lun %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|np-&gt;minsync
comma
id|MAX_TAGS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.debug
op_logical_or
id|driver_setup.verbose
OG
l_int|1
)paren
(brace
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Debug flags 0x%x, verbosity level %d&bslash;n&quot;
comma
id|driver_setup.debug
comma
id|driver_setup.verbose
)paren
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Profiling information:&bslash;n&quot;
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_fly&quot;
comma
id|np-&gt;profile.num_fly
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_trans&quot;
comma
id|np-&gt;profile.num_trans
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_disc&quot;
comma
id|np-&gt;profile.num_disc
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_disc0&quot;
comma
id|np-&gt;profile.num_disc0
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_break&quot;
comma
id|np-&gt;profile.num_break
)paren
suffix:semicolon
macro_line|#if 000
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_br1k&quot;
comma
id|np-&gt;profile.num_br1k
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_br2k&quot;
comma
id|np-&gt;profile.num_br2k
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_br4k&quot;
comma
id|np-&gt;profile.num_br4k
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_br8k&quot;
comma
id|np-&gt;profile.num_br8k
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_brnk&quot;
comma
id|np-&gt;profile.num_brnk
)paren
suffix:semicolon
macro_line|#endif
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_int&quot;
comma
id|np-&gt;profile.num_int
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_kbytes&quot;
comma
id|np-&gt;profile.num_kbytes
)paren
suffix:semicolon
macro_line|#endif
r_return
id|info.pos
OG
id|info.offset
ques
c_cond
id|info.pos
op_minus
id|info.offset
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_USER_INFO_SUPPORT */
multiline_comment|/*&n;**&t;Entry point of the scsi proc fs of the driver.&n;**&t;- func = 0 means read  (returns profile data)&n;**&t;- func = 1 means write (parse user control command)&n;*/
DECL|function|sym53c8xx_proc_info
r_static
r_int
id|sym53c8xx_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|func
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
id|ncb_p
id|ncb
op_assign
l_int|0
suffix:semicolon
r_int
id|retv
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_proc_info: hostno=%d, func=%d&bslash;n&quot;
comma
id|hostno
comma
id|func
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|host
op_assign
id|first_host
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|host-&gt;hostt
op_ne
id|first_host-&gt;hostt
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;host_no
op_eq
id|hostno
)paren
(brace
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|ncb
op_assign
id|host_data-&gt;ncb
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ncb
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|func
)paren
(brace
macro_line|#ifdef&t;SCSI_NCR_USER_COMMAND_SUPPORT
id|retv
op_assign
id|ncr_user_command
c_func
(paren
id|ncb
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
macro_line|#else
id|retv
op_assign
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
id|start
)paren
op_star
id|start
op_assign
id|buffer
suffix:semicolon
macro_line|#ifdef SCSI_NCR_USER_INFO_SUPPORT
id|retv
op_assign
id|ncr_host_info
c_func
(paren
id|ncb
comma
id|buffer
comma
id|offset
comma
id|length
)paren
suffix:semicolon
macro_line|#else
id|retv
op_assign
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*=========================================================================&n;**&t;End of proc file system stuff&n;**=========================================================================&n;*/
macro_line|#endif
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
multiline_comment|/*&n; *  24C16 EEPROM reading.&n; *&n; *  GPOI0 - data in/data out&n; *  GPIO1 - clock&n; *  Symbios NVRAM wiring now also used by Tekram.&n; */
DECL|macro|SET_BIT
mdefine_line|#define SET_BIT 0
DECL|macro|CLR_BIT
mdefine_line|#define CLR_BIT 1
DECL|macro|SET_CLK
mdefine_line|#define SET_CLK 2
DECL|macro|CLR_CLK
mdefine_line|#define CLR_CLK 3
multiline_comment|/*&n; *  Set/clear data/clock bit in GPIO0&n; */
r_static
r_void
id|__init
DECL|function|S24C16_set_bit
id|S24C16_set_bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
comma
r_int
id|bit_mode
)paren
(brace
id|UDELAY
(paren
l_int|5
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bit_mode
)paren
(brace
r_case
id|SET_BIT
suffix:colon
op_star
id|gpreg
op_or_assign
id|write_bit
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLR_BIT
suffix:colon
op_star
id|gpreg
op_and_assign
l_int|0xfe
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SET_CLK
suffix:colon
op_star
id|gpreg
op_or_assign
l_int|0x02
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLR_CLK
suffix:colon
op_star
id|gpreg
op_and_assign
l_int|0xfd
suffix:semicolon
r_break
suffix:semicolon
)brace
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|5
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Send START condition to NVRAM to wake it up.&n; */
DECL|function|S24C16_start
r_static
r_void
id|__init
id|S24C16_start
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|1
comma
id|gpreg
comma
id|SET_BIT
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|SET_CLK
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_BIT
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_CLK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Send STOP condition to NVRAM - puts NVRAM to sleep... ZZzzzz!!&n; */
DECL|function|S24C16_stop
r_static
r_void
id|__init
id|S24C16_stop
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|SET_CLK
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|1
comma
id|gpreg
comma
id|SET_BIT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Read or write a bit to the NVRAM,&n; *  read if GPIO0 input else write if GPIO0 output&n; */
r_static
r_void
id|__init
DECL|function|S24C16_do_bit
id|S24C16_do_bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|S24C16_set_bit
c_func
(paren
id|np
comma
id|write_bit
comma
id|gpreg
comma
id|SET_BIT
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|SET_CLK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_bit
)paren
op_star
id|read_bit
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_CLK
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_BIT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Output an ACK to the NVRAM after reading,&n; *  change GPIO0 to output and when done back to an input&n; */
r_static
r_void
id|__init
DECL|function|S24C16_write_ack
id|S24C16_write_ack
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
(brace
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
op_amp
l_int|0xfe
)paren
suffix:semicolon
id|S24C16_do_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|write_bit
comma
id|gpreg
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Input an ACK from NVRAM after writing,&n; *  change GPIO0 to input and when done back to an output&n; */
r_static
r_void
id|__init
DECL|function|S24C16_read_ack
id|S24C16_read_ack
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
(brace
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
op_or
l_int|0x01
)paren
suffix:semicolon
id|S24C16_do_bit
c_func
(paren
id|np
comma
id|read_bit
comma
l_int|1
comma
id|gpreg
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  WRITE a byte to the NVRAM and then get an ACK to see it was accepted OK,&n; *  GPIO0 must already be set as an output&n; */
r_static
r_void
id|__init
DECL|function|S24C16_write_byte
id|S24C16_write_byte
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|ack_data
comma
id|u_char
id|write_data
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
(brace
r_int
id|x
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|8
suffix:semicolon
id|x
op_increment
)paren
id|S24C16_do_bit
c_func
(paren
id|np
comma
l_int|0
comma
(paren
id|write_data
op_rshift
(paren
l_int|7
op_minus
id|x
)paren
)paren
op_amp
l_int|0x01
comma
id|gpreg
)paren
suffix:semicolon
id|S24C16_read_ack
c_func
(paren
id|np
comma
id|ack_data
comma
id|gpreg
comma
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  READ a byte from the NVRAM and then send an ACK to say we have got it,&n; *  GPIO0 must already be set as an input&n; */
r_static
r_void
id|__init
DECL|function|S24C16_read_byte
id|S24C16_read_byte
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_data
comma
id|u_char
id|ack_data
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
(brace
r_int
id|x
suffix:semicolon
id|u_char
id|read_bit
suffix:semicolon
op_star
id|read_data
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|8
suffix:semicolon
id|x
op_increment
)paren
(brace
id|S24C16_do_bit
c_func
(paren
id|np
comma
op_amp
id|read_bit
comma
l_int|1
comma
id|gpreg
)paren
suffix:semicolon
op_star
id|read_data
op_or_assign
(paren
(paren
id|read_bit
op_amp
l_int|0x01
)paren
op_lshift
(paren
l_int|7
op_minus
id|x
)paren
)paren
suffix:semicolon
)brace
id|S24C16_write_ack
c_func
(paren
id|np
comma
id|ack_data
comma
id|gpreg
comma
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Read &squot;len&squot; bytes starting at &squot;offset&squot;.&n; */
r_static
r_int
id|__init
DECL|function|sym_read_S24C16_nvram
id|sym_read_S24C16_nvram
(paren
id|ncr_slot
op_star
id|np
comma
r_int
id|offset
comma
id|u_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
id|u_char
id|gpcntl
comma
id|gpreg
suffix:semicolon
id|u_char
id|old_gpcntl
comma
id|old_gpreg
suffix:semicolon
id|u_char
id|ack_data
suffix:semicolon
r_int
id|retv
op_assign
l_int|1
suffix:semicolon
r_int
id|x
suffix:semicolon
multiline_comment|/* save current state of GPCNTL and GPREG */
id|old_gpreg
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
id|old_gpcntl
op_assign
id|INB
(paren
id|nc_gpcntl
)paren
suffix:semicolon
id|gpcntl
op_assign
id|old_gpcntl
op_amp
l_int|0xfc
suffix:semicolon
multiline_comment|/* set up GPREG &amp; GPCNTL to set GPIO0 and GPIO1 in to known state */
id|OUTB
(paren
id|nc_gpreg
comma
id|old_gpreg
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* this is to set NVRAM into a known state with GPIO0/1 both low */
id|gpreg
op_assign
id|old_gpreg
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
op_amp
id|gpreg
comma
id|CLR_CLK
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
op_amp
id|gpreg
comma
id|CLR_BIT
)paren
suffix:semicolon
multiline_comment|/* now set NVRAM inactive with GPIO0/1 both high */
id|S24C16_stop
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* activate NVRAM */
id|S24C16_start
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* write device code and random address MSB */
id|S24C16_write_byte
c_func
(paren
id|np
comma
op_amp
id|ack_data
comma
l_int|0xa0
op_or
(paren
(paren
id|offset
op_rshift
l_int|7
)paren
op_amp
l_int|0x0e
)paren
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack_data
op_amp
l_int|0x01
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* write random address LSB */
id|S24C16_write_byte
c_func
(paren
id|np
comma
op_amp
id|ack_data
comma
id|offset
op_amp
l_int|0xff
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack_data
op_amp
l_int|0x01
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* regenerate START state to set up for reading */
id|S24C16_start
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* rewrite device code and address MSB with read bit set (lsb = 0x01) */
id|S24C16_write_byte
c_func
(paren
id|np
comma
op_amp
id|ack_data
comma
l_int|0xa1
op_or
(paren
(paren
id|offset
op_rshift
l_int|7
)paren
op_amp
l_int|0x0e
)paren
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack_data
op_amp
l_int|0x01
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* now set up GPIO0 for inputting data */
id|gpcntl
op_or_assign
l_int|0x01
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* input all requested data - only part of total NVRAM */
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
suffix:semicolon
id|x
op_increment
)paren
id|S24C16_read_byte
c_func
(paren
id|np
comma
op_amp
id|data
(braket
id|x
)braket
comma
(paren
id|x
op_eq
(paren
id|len
op_minus
l_int|1
)paren
)paren
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* finally put NVRAM back in inactive mode */
id|gpcntl
op_and_assign
l_int|0xfe
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
id|S24C16_stop
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
id|retv
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* return GPIO0/1 to original states after having accessed NVRAM */
id|OUTB
(paren
id|nc_gpcntl
comma
id|old_gpcntl
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
id|old_gpreg
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
DECL|macro|SET_BIT
macro_line|#undef SET_BIT /* 0 */
DECL|macro|CLR_BIT
macro_line|#undef CLR_BIT /* 1 */
DECL|macro|SET_CLK
macro_line|#undef SET_CLK /* 2 */
DECL|macro|CLR_CLK
macro_line|#undef CLR_CLK /* 3 */
multiline_comment|/*&n; *  Try reading Symbios NVRAM.&n; *  Return 0 if OK.&n; */
DECL|function|sym_read_Symbios_nvram
r_static
r_int
id|__init
id|sym_read_Symbios_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|Symbios_nvram
op_star
id|nvram
)paren
(brace
r_static
id|u_char
id|Symbios_trailer
(braket
l_int|6
)braket
op_assign
(brace
l_int|0xfe
comma
l_int|0xfe
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|u_char
op_star
id|data
op_assign
(paren
id|u_char
op_star
)paren
id|nvram
suffix:semicolon
r_int
id|len
op_assign
r_sizeof
(paren
op_star
id|nvram
)paren
suffix:semicolon
id|u_short
id|csum
suffix:semicolon
r_int
id|x
suffix:semicolon
multiline_comment|/* probe the 24c16 and read the SYMBIOS 24c16 area */
r_if
c_cond
(paren
id|sym_read_S24C16_nvram
(paren
id|np
comma
id|SYMBIOS_NVRAM_ADDRESS
comma
id|data
comma
id|len
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* check valid NVRAM signature, verify byte count and checksum */
r_if
c_cond
(paren
id|nvram-&gt;type
op_ne
l_int|0
op_logical_or
id|memcmp
c_func
(paren
id|nvram-&gt;trailer
comma
id|Symbios_trailer
comma
l_int|6
)paren
op_logical_or
id|nvram-&gt;byte_count
op_ne
id|len
op_minus
l_int|12
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* verify checksum */
r_for
c_loop
(paren
id|x
op_assign
l_int|6
comma
id|csum
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
op_minus
l_int|6
suffix:semicolon
id|x
op_increment
)paren
id|csum
op_add_assign
id|data
(braket
id|x
)braket
suffix:semicolon
r_if
c_cond
(paren
id|csum
op_ne
id|nvram-&gt;checksum
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  93C46 EEPROM reading.&n; *&n; *  GPOI0 - data in&n; *  GPIO1 - data out&n; *  GPIO2 - clock&n; *  GPIO4 - chip select&n; *&n; *  Used by Tekram.&n; */
multiline_comment|/*&n; *  Pulse clock bit in GPIO0&n; */
DECL|function|T93C46_Clk
r_static
r_void
id|__init
id|T93C46_Clk
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
op_or
l_int|0x04
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|2
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; *  Read bit from NVRAM&n; */
DECL|function|T93C46_Read_Bit
r_static
r_void
id|__init
id|T93C46_Read_Bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|UDELAY
(paren
l_int|2
)paren
suffix:semicolon
id|T93C46_Clk
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
op_star
id|read_bit
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Write bit to GPIO0&n; */
DECL|function|T93C46_Write_Bit
r_static
r_void
id|__init
id|T93C46_Write_Bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
)paren
(brace
r_if
c_cond
(paren
id|write_bit
op_amp
l_int|0x01
)paren
op_star
id|gpreg
op_or_assign
l_int|0x02
suffix:semicolon
r_else
op_star
id|gpreg
op_and_assign
l_int|0xfd
suffix:semicolon
op_star
id|gpreg
op_or_assign
l_int|0x10
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|2
)paren
suffix:semicolon
id|T93C46_Clk
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Send STOP condition to NVRAM - puts NVRAM to sleep... ZZZzzz!!&n; */
DECL|function|T93C46_Stop
r_static
r_void
id|__init
id|T93C46_Stop
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
(brace
op_star
id|gpreg
op_and_assign
l_int|0xef
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|2
)paren
suffix:semicolon
id|T93C46_Clk
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Send read command and address to NVRAM&n; */
r_static
r_void
id|__init
DECL|function|T93C46_Send_Command
id|T93C46_Send_Command
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
id|write_data
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
)paren
(brace
r_int
id|x
suffix:semicolon
multiline_comment|/* send 9 bits, start bit (1), command (2), address (6)  */
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|9
suffix:semicolon
id|x
op_increment
)paren
id|T93C46_Write_Bit
c_func
(paren
id|np
comma
(paren
id|u_char
)paren
(paren
id|write_data
op_rshift
(paren
l_int|8
op_minus
id|x
)paren
)paren
comma
id|gpreg
)paren
suffix:semicolon
op_star
id|read_bit
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  READ 2 bytes from the NVRAM&n; */
r_static
r_void
id|__init
DECL|function|T93C46_Read_Word
id|T93C46_Read_Word
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
op_star
id|nvram_data
comma
id|u_char
op_star
id|gpreg
)paren
(brace
r_int
id|x
suffix:semicolon
id|u_char
id|read_bit
suffix:semicolon
op_star
id|nvram_data
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|16
suffix:semicolon
id|x
op_increment
)paren
(brace
id|T93C46_Read_Bit
c_func
(paren
id|np
comma
op_amp
id|read_bit
comma
id|gpreg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_bit
op_amp
l_int|0x01
)paren
op_star
id|nvram_data
op_or_assign
(paren
l_int|0x01
op_lshift
(paren
l_int|15
op_minus
id|x
)paren
)paren
suffix:semicolon
r_else
op_star
id|nvram_data
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
(paren
l_int|15
op_minus
id|x
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  Read Tekram NvRAM data.&n; */
r_static
r_int
id|__init
DECL|function|T93C46_Read_Data
id|T93C46_Read_Data
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
op_star
id|data
comma
r_int
id|len
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|u_char
id|read_bit
suffix:semicolon
r_int
id|x
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
suffix:semicolon
id|x
op_increment
)paren
(brace
multiline_comment|/* output read command and address */
id|T93C46_Send_Command
c_func
(paren
id|np
comma
l_int|0x180
op_or
id|x
comma
op_amp
id|read_bit
comma
id|gpreg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_bit
op_amp
l_int|0x01
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Bad */
id|T93C46_Read_Word
c_func
(paren
id|np
comma
op_amp
id|data
(braket
id|x
)braket
comma
id|gpreg
)paren
suffix:semicolon
id|T93C46_Stop
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Try reading 93C46 Tekram NVRAM.&n; */
r_static
r_int
id|__init
DECL|function|sym_read_T93C46_nvram
id|sym_read_T93C46_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|Tekram_nvram
op_star
id|nvram
)paren
(brace
id|u_char
id|gpcntl
comma
id|gpreg
suffix:semicolon
id|u_char
id|old_gpcntl
comma
id|old_gpreg
suffix:semicolon
r_int
id|retv
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* save current state of GPCNTL and GPREG */
id|old_gpreg
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
id|old_gpcntl
op_assign
id|INB
(paren
id|nc_gpcntl
)paren
suffix:semicolon
multiline_comment|/* set up GPREG &amp; GPCNTL to set GPIO0/1/2/4 in to known state, 0 in,&n;&t;   1/2/4 out */
id|gpreg
op_assign
id|old_gpreg
op_amp
l_int|0xe9
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
id|gpreg
)paren
suffix:semicolon
id|gpcntl
op_assign
(paren
id|old_gpcntl
op_amp
l_int|0xe9
)paren
op_or
l_int|0x09
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* input all of NVRAM, 64 words */
id|retv
op_assign
id|T93C46_Read_Data
c_func
(paren
id|np
comma
(paren
id|u_short
op_star
)paren
id|nvram
comma
r_sizeof
(paren
op_star
id|nvram
)paren
op_div
r_sizeof
(paren
r_int
)paren
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* return GPIO0/1/2/4 to original states after having accessed NVRAM */
id|OUTB
(paren
id|nc_gpcntl
comma
id|old_gpcntl
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
id|old_gpreg
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*&n; *  Try reading Tekram NVRAM.&n; *  Return 0 if OK.&n; */
r_static
r_int
id|__init
DECL|function|sym_read_Tekram_nvram
id|sym_read_Tekram_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
id|device_id
comma
id|Tekram_nvram
op_star
id|nvram
)paren
(brace
id|u_char
op_star
id|data
op_assign
(paren
id|u_char
op_star
)paren
id|nvram
suffix:semicolon
r_int
id|len
op_assign
r_sizeof
(paren
op_star
id|nvram
)paren
suffix:semicolon
id|u_short
id|csum
suffix:semicolon
r_int
id|x
suffix:semicolon
r_switch
c_cond
(paren
id|device_id
)paren
(brace
r_case
id|PCI_DEVICE_ID_NCR_53C885
suffix:colon
r_case
id|PCI_DEVICE_ID_NCR_53C895
suffix:colon
r_case
id|PCI_DEVICE_ID_NCR_53C896
suffix:colon
id|x
op_assign
id|sym_read_S24C16_nvram
c_func
(paren
id|np
comma
id|TEKRAM_24C16_NVRAM_ADDRESS
comma
id|data
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCI_DEVICE_ID_NCR_53C875
suffix:colon
id|x
op_assign
id|sym_read_S24C16_nvram
c_func
(paren
id|np
comma
id|TEKRAM_24C16_NVRAM_ADDRESS
comma
id|data
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|x
)paren
r_break
suffix:semicolon
r_default
suffix:colon
id|x
op_assign
id|sym_read_T93C46_nvram
c_func
(paren
id|np
comma
id|nvram
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* verify checksum */
r_for
c_loop
(paren
id|x
op_assign
l_int|0
comma
id|csum
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
op_minus
l_int|1
suffix:semicolon
id|x
op_add_assign
l_int|2
)paren
id|csum
op_add_assign
id|data
(braket
id|x
)braket
op_plus
(paren
id|data
(braket
id|x
op_plus
l_int|1
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csum
op_ne
l_int|0x1234
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_NCR_NVRAM_SUPPORT */
multiline_comment|/*&n;**&t;Module stuff&n;*/
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|SYM53C8XX
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
eof
