multiline_comment|/******************************************************************************&n;**  High Performance device driver for the Symbios 53C896 controller.&n;**&n;**  Copyright (C) 1998  Gerard Roudier &lt;groudier@club-internet.fr&gt;&n;**&n;**  This driver also supports all the Symbios 53C8XX controller family, &n;**  except 53C810 revisions &lt; 16, 53C825 revisions &lt; 16 and all &n;**  revisions of 53C815 controllers.&n;**&n;**  This driver is based on the Linux port of the FreeBSD ncr driver.&n;** &n;**  Copyright (C) 1994  Wolfgang Stanglmeier&n;**  &n;**-----------------------------------------------------------------------------&n;**  &n;**  This program is free software; you can redistribute it and/or modify&n;**  it under the terms of the GNU General Public License as published by&n;**  the Free Software Foundation; either version 2 of the License, or&n;**  (at your option) any later version.&n;**&n;**  This program is distributed in the hope that it will be useful,&n;**  but WITHOUT ANY WARRANTY; without even the implied warranty of&n;**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;**  GNU General Public License for more details.&n;**&n;**  You should have received a copy of the GNU General Public License&n;**  along with this program; if not, write to the Free Software&n;**  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;**&n;**-----------------------------------------------------------------------------&n;**&n;**  The Linux port of the FreeBSD ncr driver has been achieved in &n;**  november 1995 by:&n;**&n;**          Gerard Roudier              &lt;groudier@club-internet.fr&gt;&n;**&n;**  Being given that this driver originates from the FreeBSD version, and&n;**  in order to keep synergy on both, any suggested enhancements and corrections&n;**  received on Linux are automatically a potential candidate for the FreeBSD &n;**  version.&n;**&n;**  The original driver has been written for 386bsd and FreeBSD by&n;**          Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;&n;**          Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;&n;**&n;**-----------------------------------------------------------------------------&n;**&n;**  Major contributions:&n;**  --------------------&n;**&n;**  NVRAM detection and reading.&n;**    Copyright (C) 1997 Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;&n;**&n;*******************************************************************************&n;*/
multiline_comment|/*&n;**&t;April 2 1999, sym53c8xx version 1.3c&n;**&n;**&t;Supported SCSI features:&n;**&t;    Synchronous data transfers&n;**&t;    Wide16 SCSI BUS&n;**&t;    Disconnection/Reselection&n;**&t;    Tagged command queuing&n;**&t;    SCSI Parity checking&n;**&n;**&t;Supported NCR chips:&n;**&t;&t;53C810A&t;  (8 bits, Fast 10,&t; no rom BIOS) &n;**&t;&t;53C825A&t;  (Wide,   Fast 10,&t; on-board rom BIOS)&n;**&t;&t;53C860&t;  (8 bits, Fast 20,&t; no rom BIOS)&n;**&t;&t;53C875&t;  (Wide,   Fast 20,&t; on-board rom BIOS)&n;**&t;&t;53C876&t;  (Wide,   Fast 20 Dual, on-board rom BIOS)&n;**&t;&t;53C895&t;  (Wide,   Fast 40,&t; on-board rom BIOS)&n;**&t;&t;53C896&t;  (Wide,   Fast 40 Dual, on-board rom BIOS)&n;**&n;**&t;Other features:&n;**&t;&t;Memory mapped IO&n;**&t;&t;Module&n;**&t;&t;Shared IRQ&n;*/
multiline_comment|/*&n;**&t;Name and version of the driver&n;*/
DECL|macro|SCSI_NCR_DRIVER_NAME
mdefine_line|#define SCSI_NCR_DRIVER_NAME&t;&quot;sym53c8xx - version 1.3c&quot;
multiline_comment|/* #define DEBUG_896R1 */
DECL|macro|SCSI_NCR_OPTIMIZE_896
mdefine_line|#define SCSI_NCR_OPTIMIZE_896
multiline_comment|/* #define SCSI_NCR_OPTIMIZE_896_1 */
DECL|macro|SCSI_NCR_DEBUG_FLAGS
mdefine_line|#define SCSI_NCR_DEBUG_FLAGS&t;(0)
DECL|macro|NAME53C
mdefine_line|#define NAME53C&t;&t;&quot;sym53c&quot;
DECL|macro|NAME53C8XX
mdefine_line|#define NAME53C8XX&t;&quot;sym53c8xx&quot;
multiline_comment|/*==========================================================&n;**&n;**      Include files&n;**&n;**==========================================================&n;*/
DECL|macro|LinuxVersionCode
mdefine_line|#define LinuxVersionCode(v, p, s) (((v)&lt;&lt;16)+((p)&lt;&lt;8)+(s))
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,93)
macro_line|#include &lt;asm/spinlock.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,35)
macro_line|#include &lt;linux/init.h&gt;
macro_line|#else
macro_line|#ifndef&t;__initdata
DECL|macro|__initdata
mdefine_line|#define&t;__initdata
macro_line|#endif
macro_line|#ifndef&t;__init
DECL|macro|__init
mdefine_line|#define&t;__init
macro_line|#endif
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &lt;= LinuxVersionCode(2,1,92)
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#endif
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &lt;linux/types.h&gt;
multiline_comment|/*&n;**&t;Define BITS_PER_LONG for earlier linux versions.&n;*/
macro_line|#ifndef&t;BITS_PER_LONG
macro_line|#if (~0UL) == 0xffffffffUL
DECL|macro|BITS_PER_LONG
mdefine_line|#define&t;BITS_PER_LONG&t;32
macro_line|#else
DECL|macro|BITS_PER_LONG
mdefine_line|#define&t;BITS_PER_LONG&t;64
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n;**&t;Define the BSD style u_int32 and u_int64 type.&n;**&t;Are in fact u_int32_t and u_int64_t :-)&n;*/
DECL|typedef|u_int32
r_typedef
id|u32
id|u_int32
suffix:semicolon
DECL|typedef|u_int64
r_typedef
id|u64
id|u_int64
suffix:semicolon
macro_line|#include &quot;sym53c8xx.h&quot;
multiline_comment|/*==========================================================&n;**&n;**&t;A la VMS/CAM-3 queue management.&n;**&t;Implemented from linux list management.&n;**&n;**==========================================================&n;*/
DECL|struct|xpt_quehead
r_typedef
r_struct
id|xpt_quehead
(brace
DECL|member|flink
r_struct
id|xpt_quehead
op_star
id|flink
suffix:semicolon
multiline_comment|/* Forward  pointer */
DECL|member|blink
r_struct
id|xpt_quehead
op_star
id|blink
suffix:semicolon
multiline_comment|/* Backward pointer */
DECL|typedef|XPT_QUEHEAD
)brace
id|XPT_QUEHEAD
suffix:semicolon
DECL|macro|xpt_que_init
mdefine_line|#define xpt_que_init(ptr) do { &bslash;&n;&t;(ptr)-&gt;flink = (ptr); (ptr)-&gt;blink = (ptr); &bslash;&n;} while (0)
DECL|function|__xpt_que_add
r_static
r_inline
r_void
id|__xpt_que_add
c_func
(paren
r_struct
id|xpt_quehead
op_star
r_new
comma
r_struct
id|xpt_quehead
op_star
id|blink
comma
r_struct
id|xpt_quehead
op_star
id|flink
)paren
(brace
id|flink-&gt;blink
op_assign
r_new
suffix:semicolon
r_new
op_member_access_from_pointer
id|flink
op_assign
id|flink
suffix:semicolon
r_new
op_member_access_from_pointer
id|blink
op_assign
id|blink
suffix:semicolon
id|blink-&gt;flink
op_assign
r_new
suffix:semicolon
)brace
DECL|function|__xpt_que_del
r_static
r_inline
r_void
id|__xpt_que_del
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|blink
comma
r_struct
id|xpt_quehead
op_star
id|flink
)paren
(brace
id|flink-&gt;blink
op_assign
id|blink
suffix:semicolon
id|blink-&gt;flink
op_assign
id|flink
suffix:semicolon
)brace
DECL|function|xpt_que_empty
r_static
r_inline
r_int
id|xpt_que_empty
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|head
)paren
(brace
r_return
id|head-&gt;flink
op_eq
id|head
suffix:semicolon
)brace
DECL|function|xpt_que_splice
r_static
r_inline
r_void
id|xpt_que_splice
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|list
comma
r_struct
id|xpt_quehead
op_star
id|head
)paren
(brace
r_struct
id|xpt_quehead
op_star
id|first
op_assign
id|list-&gt;flink
suffix:semicolon
r_if
c_cond
(paren
id|first
op_ne
id|list
)paren
(brace
r_struct
id|xpt_quehead
op_star
id|last
op_assign
id|list-&gt;blink
suffix:semicolon
r_struct
id|xpt_quehead
op_star
id|at
op_assign
id|head-&gt;flink
suffix:semicolon
id|first-&gt;blink
op_assign
id|head
suffix:semicolon
id|head-&gt;flink
op_assign
id|first
suffix:semicolon
id|last-&gt;flink
op_assign
id|at
suffix:semicolon
id|at-&gt;blink
op_assign
id|last
suffix:semicolon
)brace
)brace
DECL|macro|xpt_que_entry
mdefine_line|#define xpt_que_entry(ptr, type, member) &bslash;&n;&t;((type *)((char *)(ptr)-(unsigned long)(&amp;((type *)0)-&gt;member)))
DECL|macro|xpt_insque
mdefine_line|#define xpt_insque(new, pos)&t;&t;__xpt_que_add(new, pos, (pos)-&gt;flink)
DECL|macro|xpt_remque
mdefine_line|#define xpt_remque(el)&t;&t;&t;__xpt_que_del((el)-&gt;blink, (el)-&gt;flink)
DECL|macro|xpt_insque_head
mdefine_line|#define xpt_insque_head(new, head)&t;__xpt_que_add(new, head, (head)-&gt;flink)
DECL|function|xpt_remque_head
r_static
r_inline
r_struct
id|xpt_quehead
op_star
id|xpt_remque_head
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|head
)paren
(brace
r_struct
id|xpt_quehead
op_star
id|elem
op_assign
id|head-&gt;flink
suffix:semicolon
r_if
c_cond
(paren
id|elem
op_ne
id|head
)paren
id|__xpt_que_del
c_func
(paren
id|head
comma
id|elem-&gt;flink
)paren
suffix:semicolon
r_else
id|elem
op_assign
l_int|0
suffix:semicolon
r_return
id|elem
suffix:semicolon
)brace
DECL|macro|xpt_insque_tail
mdefine_line|#define xpt_insque_tail(new, head)&t;__xpt_que_add(new, (head)-&gt;blink, head)
DECL|function|xpt_remque_tail
r_static
r_inline
r_struct
id|xpt_quehead
op_star
id|xpt_remque_tail
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|head
)paren
(brace
r_struct
id|xpt_quehead
op_star
id|elem
op_assign
id|head-&gt;blink
suffix:semicolon
r_if
c_cond
(paren
id|elem
op_ne
id|head
)paren
id|__xpt_que_del
c_func
(paren
id|elem-&gt;blink
comma
id|head
)paren
suffix:semicolon
r_else
id|elem
op_assign
l_int|0
suffix:semicolon
r_return
id|elem
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;On x86 architecture, write buffers management does &n;**&t;not reorder writes to memory. So, using compiler &n;**&t;optimization barriers is enough to guarantee some &n;**&t;ordering when the CPU is writing data accessed by &n;**&t;the NCR.&n;**&t;On Alpha architecture, explicit memory barriers have &n;**&t;to be used.&n;**&t;Other architectures are defaulted to mb() macro if  &n;**&t;defined, otherwise use compiler barrier.&n;**&n;**==========================================================&n;*/
macro_line|#if defined(__i386__)
DECL|macro|MEMORY_BARRIER
mdefine_line|#define MEMORY_BARRIER()&t;barrier()
macro_line|#elif defined(__alpha__)
DECL|macro|MEMORY_BARRIER
mdefine_line|#define MEMORY_BARRIER()&t;mb()
macro_line|#else
macro_line|#  ifdef mb
DECL|macro|MEMORY_BARRIER
macro_line|#  define MEMORY_BARRIER()&t;mb()
macro_line|#  else
DECL|macro|MEMORY_BARRIER
macro_line|#  define MEMORY_BARRIER()&t;barrier()
macro_line|#  endif
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;Configuration and Debugging&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**    SCSI address of this device.&n;**    The boot routines should have set it.&n;**    If not, use this.&n;*/
macro_line|#ifndef SCSI_NCR_MYADDR
DECL|macro|SCSI_NCR_MYADDR
mdefine_line|#define SCSI_NCR_MYADDR      (7)
macro_line|#endif
multiline_comment|/*&n;**    The maximum number of tags per logic unit.&n;**    Used only for devices that support tags.&n;*/
macro_line|#ifndef SCSI_NCR_MAX_TAGS
DECL|macro|SCSI_NCR_MAX_TAGS
mdefine_line|#define SCSI_NCR_MAX_TAGS    (8)
macro_line|#endif
multiline_comment|/*&n;**    TAGS are actually limited to 64 tags/lun.&n;**    We need to deal with power of 2, for alignment constraints.&n;*/
macro_line|#if&t;SCSI_NCR_MAX_TAGS &gt; 64
DECL|macro|SCSI_NCR_MAX_TAGS
macro_line|#undef&t;SCSI_NCR_MAX_TAGS
DECL|macro|SCSI_NCR_MAX_TAGS
mdefine_line|#define&t;SCSI_NCR_MAX_TAGS (64)
macro_line|#endif
DECL|macro|NO_TAG
mdefine_line|#define NO_TAG&t;(255)
multiline_comment|/*&n;**&t;Choose appropriate type for tag bitmap.&n;*/
macro_line|#if&t;SCSI_NCR_MAX_TAGS &gt; 32
DECL|typedef|tagmap_t
r_typedef
id|u_int64
id|tagmap_t
suffix:semicolon
macro_line|#else
DECL|typedef|tagmap_t
r_typedef
id|u_int32
id|tagmap_t
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;**    Number of targets supported by the driver.&n;**    n permits target numbers 0..n-1.&n;**    Default is 16, meaning targets #0..#15.&n;**    #7 .. is myself.&n;*/
macro_line|#ifdef SCSI_NCR_MAX_TARGET
DECL|macro|MAX_TARGET
mdefine_line|#define MAX_TARGET  (SCSI_NCR_MAX_TARGET)
macro_line|#else
DECL|macro|MAX_TARGET
mdefine_line|#define MAX_TARGET  (16)
macro_line|#endif
multiline_comment|/*&n;**    Number of logic units supported by the driver.&n;**    n enables logic unit numbers 0..n-1.&n;**    The common SCSI devices require only&n;**    one lun, so take 1 as the default.&n;*/
macro_line|#ifdef SCSI_NCR_MAX_LUN
DECL|macro|MAX_LUN
mdefine_line|#define MAX_LUN    SCSI_NCR_MAX_LUN
macro_line|#else
DECL|macro|MAX_LUN
mdefine_line|#define MAX_LUN    (1)
macro_line|#endif
multiline_comment|/*&n;**    Asynchronous pre-scaler (ns). Shall be 40 for &n;**    the SCSI timings to be compliant.&n;*/
macro_line|#ifndef SCSI_NCR_MIN_ASYNC
DECL|macro|SCSI_NCR_MIN_ASYNC
mdefine_line|#define SCSI_NCR_MIN_ASYNC (40)
macro_line|#endif
multiline_comment|/*&n;**    The maximum number of jobs scheduled for starting.&n;**    We allocate 4 entries more than the value we announce &n;**    to the SCSI upper layer. Guess why ! :-)&n;*/
macro_line|#ifdef SCSI_NCR_CAN_QUEUE
DECL|macro|MAX_START
mdefine_line|#define MAX_START   (SCSI_NCR_CAN_QUEUE + 4)
macro_line|#else
DECL|macro|MAX_START
mdefine_line|#define MAX_START   (MAX_TARGET + 7 * SCSI_NCR_MAX_TAGS)
macro_line|#endif
multiline_comment|/*&n;**    The maximum number of segments a transfer is split into.&n;**    We support up to 127 segments for both read and write.&n;**    Since we try to avoid phase mismatches by testing the PHASE &n;**    before each MOV, the both DATA_IN and DATA_OUT scripts do &n;**    not fit in the 4K on-chip RAM. For this reason, the data &n;**    scripts are broken into 2 sub-scripts.&n;**    80 (MAX_SCATTERL) segments are moved from a sub-script &n;**    in on-chip RAM. This makes data transfers shorter than &n;**    80k (assuming 1k fs) as fast as possible.&n;**    The 896 allows to handle phase mismatches from SCRIPTS.&n;**    So, for this chip, we use a simple array of MOV&squot;s.&n;**    Perhaps, using a simple array of MOV&squot;s and going with &n;**    the phase mismatch interrupt is also the best solution &n;**    for the 895 in Ultra2-mode, since the PHASE test + MOV &n;**    latency may be enough to fill the SCSI offset for very  &n;**    fast disks like the Cheatah Wide LVD and so, may waste &n;**    SCSI BUS bandwitch.&n;*/
DECL|macro|MAX_SCATTER
mdefine_line|#define MAX_SCATTER (SCSI_NCR_MAX_SCATTER)
macro_line|#ifdef&t;SCSI_NCR_OPTIMIZE_896
DECL|macro|SCR_SG_SIZE
mdefine_line|#define&t;SCR_SG_SIZE&t;(2)
DECL|macro|MAX_SCATTERL
mdefine_line|#define MAX_SCATTERL&t;MAX_SCATTER
DECL|macro|MAX_SCATTERH
mdefine_line|#define MAX_SCATTERH&t;0
macro_line|#else
macro_line|#if (MAX_SCATTER &gt; 80)
DECL|macro|SCR_SG_SIZE
mdefine_line|#define&t;SCR_SG_SIZE&t;(4)
DECL|macro|MAX_SCATTERL
mdefine_line|#define MAX_SCATTERL&t;80
DECL|macro|MAX_SCATTERH
mdefine_line|#define&t;MAX_SCATTERH&t;(MAX_SCATTER - MAX_SCATTERL)
macro_line|#else
DECL|macro|MAX_SCATTERL
mdefine_line|#define MAX_SCATTERL&t;MAX_SCATTER
DECL|macro|MAX_SCATTERH
mdefine_line|#define&t;MAX_SCATTERH&t;0
macro_line|#endif
macro_line|#endif&t;/* SCSI_NCR_OPTIMIZE_896 */
multiline_comment|/*&n;**    Io mapped or memory mapped.&n;*/
macro_line|#if defined(SCSI_NCR_IOMAPPED)
DECL|macro|NCR_IOMAPPED
mdefine_line|#define NCR_IOMAPPED
macro_line|#endif
multiline_comment|/*&n;**&t;other&n;*/
DECL|macro|NCR_SNOOP_TIMEOUT
mdefine_line|#define NCR_SNOOP_TIMEOUT (1000000)
multiline_comment|/*==========================================================&n;**&n;**&t;Miscallaneous BSDish defines.&n;**&n;**==========================================================&n;*/
DECL|macro|u_char
mdefine_line|#define u_char&t;&t;unsigned char
DECL|macro|u_short
mdefine_line|#define u_short&t;&t;unsigned short
DECL|macro|u_int
mdefine_line|#define u_int&t;&t;unsigned int
DECL|macro|u_long
mdefine_line|#define u_long&t;&t;unsigned long
macro_line|#ifndef bcopy
DECL|macro|bcopy
mdefine_line|#define bcopy(s, d, n)&t;memcpy((d), (s), (n))
macro_line|#endif
macro_line|#ifndef bzero
DECL|macro|bzero
mdefine_line|#define bzero(d, n)&t;memset((d), 0, (n))
macro_line|#endif
macro_line|#ifndef offsetof
DECL|macro|offsetof
mdefine_line|#define offsetof(t, m)&t;((size_t) (&amp;((t *)0)-&gt;m))
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;Debugging tags&n;**&n;**==========================================================&n;*/
DECL|macro|DEBUG_ALLOC
mdefine_line|#define DEBUG_ALLOC    (0x0001)
DECL|macro|DEBUG_PHASE
mdefine_line|#define DEBUG_PHASE    (0x0002)
DECL|macro|DEBUG_POLL
mdefine_line|#define DEBUG_POLL     (0x0004)
DECL|macro|DEBUG_QUEUE
mdefine_line|#define DEBUG_QUEUE    (0x0008)
DECL|macro|DEBUG_RESULT
mdefine_line|#define DEBUG_RESULT   (0x0010)
DECL|macro|DEBUG_SCATTER
mdefine_line|#define DEBUG_SCATTER  (0x0020)
DECL|macro|DEBUG_SCRIPT
mdefine_line|#define DEBUG_SCRIPT   (0x0040)
DECL|macro|DEBUG_TINY
mdefine_line|#define DEBUG_TINY     (0x0080)
DECL|macro|DEBUG_TIMING
mdefine_line|#define DEBUG_TIMING   (0x0100)
DECL|macro|DEBUG_NEGO
mdefine_line|#define DEBUG_NEGO     (0x0200)
DECL|macro|DEBUG_TAGS
mdefine_line|#define DEBUG_TAGS     (0x0400)
DECL|macro|DEBUG_FREEZE
mdefine_line|#define DEBUG_FREEZE   (0x0800)
DECL|macro|DEBUG_RESTART
mdefine_line|#define DEBUG_RESTART  (0x1000)
multiline_comment|/*&n;**    Enable/Disable debug messages.&n;**    Can be changed at runtime too.&n;*/
macro_line|#ifdef SCSI_NCR_DEBUG_INFO_SUPPORT
DECL|variable|ncr_debug
r_static
r_int
id|ncr_debug
op_assign
id|SCSI_NCR_DEBUG_FLAGS
suffix:semicolon
DECL|macro|DEBUG_FLAGS
mdefine_line|#define DEBUG_FLAGS ncr_debug
macro_line|#else
DECL|macro|DEBUG_FLAGS
mdefine_line|#define DEBUG_FLAGS&t;SCSI_NCR_DEBUG_FLAGS
macro_line|#endif
multiline_comment|/*&n;**&t;SMP threading.&n;**&n;**&t;Assuming that SMP systems are generally high end systems and may &n;**&t;use several SCSI adapters, we are using one lock per controller &n;**&t;instead of some global one. For the moment (linux-2.1.95), driver&squot;s &n;**&t;entry points are called with the &squot;io_request_lock&squot; lock held, so:&n;**&t;- We are uselessly loosing a couple of micro-seconds to lock the &n;**&t;  controller data structure.&n;**&t;- But the driver is not broken by design for SMP and so can be &n;**&t;  more resistant to bugs or bad changes in the IO sub-system code.&n;**&t;- A small advantage could be that the interrupt code is grained as &n;**&t;  wished (e.g.: threaded by controller).&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,93)
DECL|variable|sym53c8xx_lock
id|spinlock_t
id|sym53c8xx_lock
suffix:semicolon
DECL|macro|NCR_LOCK_DRIVER
mdefine_line|#define&t;NCR_LOCK_DRIVER(flags)     spin_lock_irqsave(&amp;sym53c8xx_lock, flags)
DECL|macro|NCR_UNLOCK_DRIVER
mdefine_line|#define&t;NCR_UNLOCK_DRIVER(flags)   spin_unlock_irqrestore(&amp;sym53c8xx_lock,flags)
DECL|macro|NCR_INIT_LOCK_NCB
mdefine_line|#define NCR_INIT_LOCK_NCB(np)      spin_lock_init(&amp;np-&gt;smp_lock);
DECL|macro|NCR_LOCK_NCB
mdefine_line|#define&t;NCR_LOCK_NCB(np, flags)    spin_lock_irqsave(&amp;np-&gt;smp_lock, flags)
DECL|macro|NCR_UNLOCK_NCB
mdefine_line|#define&t;NCR_UNLOCK_NCB(np, flags)  spin_unlock_irqrestore(&amp;np-&gt;smp_lock, flags)
macro_line|#&t;if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,3,99)
DECL|macro|NCR_LOCK_SCSI_DONE
macro_line|#&t;define&t;NCR_LOCK_SCSI_DONE(np, flags) &bslash;&n;&t;&t;spin_lock_irqsave(&amp;io_request_lock, flags)
DECL|macro|NCR_UNLOCK_SCSI_DONE
macro_line|#&t;define&t;NCR_UNLOCK_SCSI_DONE(np, flags) &bslash;&n;&t;&t;spin_unlock_irqrestore(&amp;io_request_lock, flags)
macro_line|#&t;else
DECL|macro|NCR_LOCK_SCSI_DONE
macro_line|#&t;define&t;NCR_LOCK_SCSI_DONE(np, flags)    do {;} while (0)
DECL|macro|NCR_UNLOCK_SCSI_DONE
macro_line|#&t;define&t;NCR_UNLOCK_SCSI_DONE(np, flags)  do {;} while (0)
macro_line|#&t;endif
macro_line|#else
DECL|macro|NCR_LOCK_DRIVER
mdefine_line|#define&t;NCR_LOCK_DRIVER(flags)     do { save_flags(flags); cli(); } while (0)
DECL|macro|NCR_UNLOCK_DRIVER
mdefine_line|#define&t;NCR_UNLOCK_DRIVER(flags)   do { restore_flags(flags); } while (0)
DECL|macro|NCR_INIT_LOCK_NCB
mdefine_line|#define&t;NCR_INIT_LOCK_NCB(np)      do { } while (0)
DECL|macro|NCR_LOCK_NCB
mdefine_line|#define&t;NCR_LOCK_NCB(np, flags)    do { save_flags(flags); cli(); } while (0)
DECL|macro|NCR_UNLOCK_NCB
mdefine_line|#define&t;NCR_UNLOCK_NCB(np, flags)  do { restore_flags(flags); } while (0)
DECL|macro|NCR_LOCK_SCSI_DONE
mdefine_line|#define&t;NCR_LOCK_SCSI_DONE(np, flags)    do {;} while (0)
DECL|macro|NCR_UNLOCK_SCSI_DONE
mdefine_line|#define&t;NCR_UNLOCK_SCSI_DONE(np, flags)  do {;} while (0)
macro_line|#endif
multiline_comment|/*&n;**&t;Address translation&n;**&n;**&t;The driver has to provide bus memory addresses to &n;**&t;the script processor. Because some architectures use &n;**&t;different physical addressing scheme from the PCI BUS, &n;**&t;we use virt_to_bus() instead of virt_to_phys().&n;*/
DECL|macro|vtobus
mdefine_line|#define vtobus(p)&t;virt_to_bus(p)
multiline_comment|/*&n;**&t;Memory mapped IO&n;**&n;**&t;Since linux-2.1, we must use ioremap() to map the io memory space.&n;**&t;iounmap() to unmap it. That allows portability.&n;**&t;Linux 1.3.X and 2.0.X allow to remap physical pages addresses greater &n;**&t;than the highest physical memory address to kernel virtual pages with &n;**&t;vremap() / vfree(). That was not portable but worked with i386 &n;**&t;architecture.&n;*/
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,1,0)
DECL|macro|ioremap
mdefine_line|#define ioremap vremap
DECL|macro|iounmap
mdefine_line|#define iounmap vfree
macro_line|#endif
macro_line|#ifdef __sparc__
DECL|macro|pcivtobus
mdefine_line|#define pcivtobus(p)&t;&t;&t;((p) &amp; pci_dvma_mask)
macro_line|#else&t;/* __sparc__ */
DECL|macro|pcivtobus
mdefine_line|#define pcivtobus(p)&t;&t;&t;(p)
macro_line|#endif
macro_line|#if !defined(NCR_IOMAPPED) || defined(__i386__)
DECL|function|remap_pci_mem
r_static
id|u_long
id|__init
id|remap_pci_mem
c_func
(paren
id|u_long
id|base
comma
id|u_long
id|size
)paren
(brace
id|u_long
id|page_base
op_assign
(paren
(paren
id|u_long
)paren
id|base
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|u_long
id|page_offs
op_assign
(paren
(paren
id|u_long
)paren
id|base
)paren
op_minus
id|page_base
suffix:semicolon
id|u_long
id|page_remapped
op_assign
(paren
id|u_long
)paren
id|ioremap
c_func
(paren
id|page_base
comma
id|page_offs
op_plus
id|size
)paren
suffix:semicolon
r_return
id|page_remapped
ques
c_cond
(paren
id|page_remapped
op_plus
id|page_offs
)paren
suffix:colon
l_int|0UL
suffix:semicolon
)brace
DECL|function|unmap_pci_mem
r_static
r_void
id|__init
id|unmap_pci_mem
c_func
(paren
id|u_long
id|vaddr
comma
id|u_long
id|size
)paren
(brace
r_if
c_cond
(paren
id|vaddr
)paren
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|vaddr
op_amp
id|PAGE_MASK
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* !NCR_IOMAPPED || __i386__ */
multiline_comment|/*&n;**&t;Insert a delay in micro-seconds and milli-seconds.&n;**&t;-------------------------------------------------&n;**&t;Under Linux, udelay() is restricted to delay &lt; 1 milli-second.&n;**&t;In fact, it generally works for up to 1 second delay.&n;**&t;Since 2.1.105, the mdelay() function is provided for delays &n;**&t;in milli-seconds.&n;**&t;Under 2.0 kernels, udelay() is an inline function that is very &n;**&t;inaccurate on Pentium processors.&n;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,105)
DECL|macro|UDELAY
mdefine_line|#define UDELAY udelay
DECL|macro|MDELAY
mdefine_line|#define MDELAY mdelay
macro_line|#else
DECL|function|UDELAY
r_static
r_void
id|UDELAY
c_func
(paren
r_int
id|us
)paren
(brace
id|udelay
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
DECL|function|MDELAY
r_static
r_void
id|MDELAY
c_func
(paren
r_int
id|ms
)paren
(brace
r_while
c_loop
(paren
id|ms
op_decrement
)paren
id|UDELAY
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;**&t;Simple power of two buddy-like allocator&n;**&t;----------------------------------------&n;**&t;This simple code is not intended to be fast, but to provide &n;**&t;power of 2 aligned memory allocations.&n;**&t;Since the SCRIPTS processor only supplies 8 bit arithmetic,&n;**&t;this allocator allows simple and fast address calculations  &n;**&t;from the SCRIPTS code. In addition, cache line alignment &n;**&t;is guaranteed for power of 2 cache line size.&n;*/
DECL|macro|MEMO_SHIFT
mdefine_line|#define MEMO_SHIFT&t;4&t;/* 16 bytes minimum memory chunk */
DECL|macro|MEMO_PAGE_ORDER
mdefine_line|#define MEMO_PAGE_ORDER&t;0&t;/* 1 PAGE maximum (for now (ever?) */
DECL|typedef|addr
r_typedef
r_int
r_int
id|addr
suffix:semicolon
multiline_comment|/* Enough bits to bit-hack addresses */
DECL|macro|MEMO_FREE_UNUSED
mdefine_line|#define MEMO_FREE_UNUSED&t;/* Free unused pages immediately */
DECL|struct|m_link
r_struct
id|m_link
(brace
DECL|member|next
r_struct
id|m_link
op_star
id|next
suffix:semicolon
multiline_comment|/* Simple links are enough */
)brace
suffix:semicolon
macro_line|#ifndef GFP_DMA_32BIT
DECL|macro|GFP_DMA_32BIT
mdefine_line|#define GFP_DMA_32BIT&t;0&t;/* Will this flag ever exist */
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,0)
DECL|macro|get_pages
mdefine_line|#define get_pages(order) __get_free_pages(GFP_ATOMIC | GFP_DMA_32BIT, order)
macro_line|#else
DECL|macro|get_pages
mdefine_line|#define get_pages(order) __get_free_pages(GFP_ATOMIC | GFP_DMA_32BIT, order, 0)
macro_line|#endif
multiline_comment|/*&n;**&t;Lists of available memory chunks.&n;**&t;Starts with 16 bytes chunks until 1 PAGE chunks.&n;*/
DECL|variable|h
r_static
r_struct
id|m_link
id|h
(braket
id|PAGE_SHIFT
op_minus
id|MEMO_SHIFT
op_plus
id|MEMO_PAGE_ORDER
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/*&n;**&t;Allocate a memory area aligned on the lowest power of 2 &n;**&t;greater than the requested size.&n;*/
DECL|function|__m_alloc
r_static
r_void
op_star
id|__m_alloc
c_func
(paren
r_int
id|size
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|s
op_assign
(paren
l_int|1
op_lshift
id|MEMO_SHIFT
)paren
suffix:semicolon
r_int
id|j
suffix:semicolon
id|addr
id|a
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
(paren
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
id|s
)paren
(brace
id|s
op_lshift_assign
l_int|1
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|j
op_assign
id|i
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|h
(braket
id|j
)braket
dot
id|next
)paren
(brace
r_if
c_cond
(paren
id|s
op_eq
(paren
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
)paren
)paren
(brace
id|h
(braket
id|j
)braket
dot
id|next
op_assign
(paren
r_struct
id|m_link
op_star
)paren
id|get_pages
c_func
(paren
id|MEMO_PAGE_ORDER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|h
(braket
id|j
)braket
dot
id|next
)paren
id|h
(braket
id|j
)braket
dot
id|next-&gt;next
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
op_increment
id|j
suffix:semicolon
id|s
op_lshift_assign
l_int|1
suffix:semicolon
)brace
id|a
op_assign
(paren
id|addr
)paren
id|h
(braket
id|j
)braket
dot
id|next
suffix:semicolon
r_if
c_cond
(paren
id|a
)paren
(brace
id|h
(braket
id|j
)braket
dot
id|next
op_assign
id|h
(braket
id|j
)braket
dot
id|next-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|j
OG
id|i
)paren
(brace
id|j
op_sub_assign
l_int|1
suffix:semicolon
id|s
op_rshift_assign
l_int|1
suffix:semicolon
id|h
(braket
id|j
)braket
dot
id|next
op_assign
(paren
r_struct
id|m_link
op_star
)paren
(paren
id|a
op_plus
id|s
)paren
suffix:semicolon
id|h
(braket
id|j
)braket
dot
id|next-&gt;next
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;m_alloc(%d) = %p&bslash;n&quot;
comma
id|size
comma
(paren
r_void
op_star
)paren
id|a
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
r_void
op_star
)paren
id|a
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Free a memory area allocated using m_alloc().&n;**&t;Coalesce buddies.&n;**&t;Free pages that become unused if MEMO_FREE_UNUSED is defined.&n;*/
DECL|function|__m_free
r_static
r_void
id|__m_free
c_func
(paren
r_void
op_star
id|ptr
comma
r_int
id|size
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|s
op_assign
(paren
l_int|1
op_lshift
id|MEMO_SHIFT
)paren
suffix:semicolon
r_struct
id|m_link
op_star
id|q
suffix:semicolon
id|addr
id|a
comma
id|b
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;m_free(%p, %d)&bslash;n&quot;
comma
id|ptr
comma
id|size
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|size
OG
(paren
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
)paren
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
id|s
)paren
(brace
id|s
op_lshift_assign
l_int|1
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|a
op_assign
(paren
id|addr
)paren
id|ptr
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
macro_line|#ifdef MEMO_FREE_UNUSED
r_if
c_cond
(paren
id|s
op_eq
(paren
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
)paren
)paren
(brace
id|free_pages
c_func
(paren
id|a
comma
id|MEMO_PAGE_ORDER
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
id|b
op_assign
id|a
op_xor
id|s
suffix:semicolon
id|q
op_assign
op_amp
id|h
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
id|q-&gt;next
op_logical_and
id|q-&gt;next
op_ne
(paren
r_struct
id|m_link
op_star
)paren
id|b
)paren
(brace
id|q
op_assign
id|q-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;next
)paren
(brace
(paren
(paren
r_struct
id|m_link
op_star
)paren
id|a
)paren
op_member_access_from_pointer
id|next
op_assign
id|h
(braket
id|i
)braket
dot
id|next
suffix:semicolon
id|h
(braket
id|i
)braket
dot
id|next
op_assign
(paren
r_struct
id|m_link
op_star
)paren
id|a
suffix:semicolon
r_break
suffix:semicolon
)brace
id|q-&gt;next
op_assign
id|q-&gt;next-&gt;next
suffix:semicolon
id|a
op_assign
id|a
op_amp
id|b
suffix:semicolon
id|s
op_lshift_assign
l_int|1
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
)brace
DECL|macro|MEMO_WARN
mdefine_line|#define MEMO_WARN&t;1
multiline_comment|/*&n;**&t;The memory pool is shared by all instances.&n;**&t;We use a global SMP LOCK to be SMP safe.&n;*/
DECL|function|m_calloc
r_static
r_void
op_star
id|m_calloc
c_func
(paren
r_int
id|size
comma
r_char
op_star
id|name
comma
r_int
id|uflags
)paren
(brace
id|u_long
id|flags
suffix:semicolon
r_void
op_star
id|p
suffix:semicolon
id|NCR_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|p
op_assign
id|__m_alloc
c_func
(paren
id|size
)paren
suffix:semicolon
id|NCR_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_ALLOC
)paren
id|printk
(paren
l_string|&quot;new %s[%d] @%p.&bslash;n&quot;
comma
id|name
comma
id|size
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|uflags
op_amp
id|MEMO_WARN
)paren
id|printk
(paren
id|NAME53C8XX
l_string|&quot;: failed to allocate %s[%d]&bslash;n&quot;
comma
id|name
comma
id|size
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|m_free
r_static
r_void
id|m_free
c_func
(paren
r_void
op_star
id|ptr
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
id|u_long
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_ALLOC
)paren
id|printk
(paren
l_string|&quot;freeing %s[%d] @%p.&bslash;n&quot;
comma
id|name
comma
id|size
comma
id|ptr
)paren
suffix:semicolon
id|NCR_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__m_free
c_func
(paren
id|ptr
comma
id|size
)paren
suffix:semicolon
id|NCR_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Transfer direction&n;**&n;**&t;Low-level scsi drivers under Linux do not receive the expected &n;**&t;data transfer direction from upper scsi drivers.&n;**&t;The driver will only check actual data direction for common &n;**&t;scsi opcodes. Other ones may cause problem, since they may &n;**&t;depend on device type or be vendor specific.&n;**&t;I would prefer to never trust the device for data direction, &n;**&t;but that is not possible.&n;**&n;**&t;The original driver requires the expected direction to be known.&n;**&t;The Linux version of the driver has been enhanced in order to &n;**&t;be able to transfer data in the direction choosen by the target. &n;*/
DECL|macro|XFER_IN
mdefine_line|#define XFER_IN&t;&t;(1)
DECL|macro|XFER_OUT
mdefine_line|#define XFER_OUT&t;(2)
multiline_comment|/*&n;**&t;Head of list of NCR boards&n;**&n;**&t;For kernel version &lt; 1.3.70, host is retrieved by its irq level.&n;**&t;For later kernels, the internal host control block address &n;**&t;(struct ncb) is used as device id parameter of the irq stuff.&n;*/
DECL|variable|first_host
r_static
r_struct
id|Scsi_Host
op_star
id|first_host
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;**&t;/proc directory entry and proc_info function&n;*/
DECL|variable|proc_scsi_sym53c8xx
r_static
r_struct
id|proc_dir_entry
id|proc_scsi_sym53c8xx
op_assign
(brace
id|PROC_SCSI_SYM53C8XX
comma
l_int|9
comma
id|NAME53C8XX
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
l_int|2
)brace
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROC_INFO_SUPPORT
r_static
r_int
id|sym53c8xx_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|func
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;**&t;Driver setup.&n;**&n;**&t;This structure is initialized from linux config options.&n;**&t;It can be overridden at boot-up by the boot command line.&n;*/
DECL|macro|SCSI_NCR_MAX_EXCLUDES
mdefine_line|#define SCSI_NCR_MAX_EXCLUDES 8
DECL|struct|ncr_driver_setup
r_struct
id|ncr_driver_setup
(brace
DECL|member|master_parity
id|u_char
id|master_parity
suffix:semicolon
DECL|member|scsi_parity
id|u_char
id|scsi_parity
suffix:semicolon
DECL|member|disconnection
id|u_char
id|disconnection
suffix:semicolon
DECL|member|special_features
id|u_char
id|special_features
suffix:semicolon
DECL|member|ultra_scsi
id|u_char
id|ultra_scsi
suffix:semicolon
DECL|member|force_sync_nego
id|u_char
id|force_sync_nego
suffix:semicolon
DECL|member|reverse_probe
id|u_char
id|reverse_probe
suffix:semicolon
DECL|member|pci_fix_up
id|u_char
id|pci_fix_up
suffix:semicolon
DECL|member|use_nvram
id|u_char
id|use_nvram
suffix:semicolon
DECL|member|verbose
id|u_char
id|verbose
suffix:semicolon
DECL|member|default_tags
id|u_char
id|default_tags
suffix:semicolon
DECL|member|default_sync
id|u_short
id|default_sync
suffix:semicolon
DECL|member|debug
id|u_short
id|debug
suffix:semicolon
DECL|member|burst_max
id|u_char
id|burst_max
suffix:semicolon
DECL|member|led_pin
id|u_char
id|led_pin
suffix:semicolon
DECL|member|max_wide
id|u_char
id|max_wide
suffix:semicolon
DECL|member|settle_delay
id|u_char
id|settle_delay
suffix:semicolon
DECL|member|diff_support
id|u_char
id|diff_support
suffix:semicolon
DECL|member|irqm
id|u_char
id|irqm
suffix:semicolon
DECL|member|bus_check
id|u_char
id|bus_check
suffix:semicolon
DECL|member|optimize
id|u_char
id|optimize
suffix:semicolon
DECL|member|recovery
id|u_char
id|recovery
suffix:semicolon
DECL|member|excludes
id|u_int
id|excludes
(braket
id|SCSI_NCR_MAX_EXCLUDES
)braket
suffix:semicolon
DECL|member|tag_ctrl
r_char
id|tag_ctrl
(braket
l_int|100
)braket
suffix:semicolon
)brace
suffix:semicolon
r_static
r_struct
id|ncr_driver_setup
DECL|variable|driver_setup
id|driver_setup
op_assign
id|SCSI_NCR_DRIVER_SETUP
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT
r_static
r_struct
id|ncr_driver_setup
DECL|variable|__initdata
id|driver_safe_setup
id|__initdata
op_assign
id|SCSI_NCR_DRIVER_SAFE_SETUP
suffix:semicolon
macro_line|# ifdef&t;MODULE
DECL|variable|sym53c8xx
r_char
op_star
id|sym53c8xx
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* command line passed by insmod */
macro_line|#  if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,30)
id|MODULE_PARM
c_func
(paren
id|sym53c8xx
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
macro_line|#  endif
macro_line|# endif
macro_line|#endif
multiline_comment|/*&n;**&t;Other Linux definitions&n;*/
DECL|macro|SetScsiResult
mdefine_line|#define SetScsiResult(cmd, h_sts, s_sts) &bslash;&n;&t;cmd-&gt;result = (((h_sts) &lt;&lt; 16) + ((s_sts) &amp; 0x7f))
r_static
r_void
id|sym53c8xx_select_queue_depths
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|scsi_device
op_star
id|devlist
)paren
suffix:semicolon
r_static
r_void
id|sym53c8xx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|sym53c8xx_timeout
c_func
(paren
r_int
r_int
id|np
)paren
suffix:semicolon
DECL|macro|initverbose
mdefine_line|#define initverbose (driver_setup.verbose)
DECL|macro|bootverbose
mdefine_line|#define bootverbose (np-&gt;verbose)
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
multiline_comment|/*&n;**&t;Symbios NvRAM data format&n;*/
DECL|macro|SYMBIOS_NVRAM_SIZE
mdefine_line|#define SYMBIOS_NVRAM_SIZE 368
DECL|macro|SYMBIOS_NVRAM_ADDRESS
mdefine_line|#define SYMBIOS_NVRAM_ADDRESS 0x100
DECL|struct|Symbios_nvram
r_struct
id|Symbios_nvram
(brace
multiline_comment|/* Header 6 bytes */
DECL|member|type
id|u_short
id|type
suffix:semicolon
multiline_comment|/* 0x0000 */
DECL|member|byte_count
id|u_short
id|byte_count
suffix:semicolon
multiline_comment|/* excluding header/trailer */
DECL|member|checksum
id|u_short
id|checksum
suffix:semicolon
multiline_comment|/* Controller set up 20 bytes */
DECL|member|v_major
id|u_char
id|v_major
suffix:semicolon
multiline_comment|/* 0x00 */
DECL|member|v_minor
id|u_char
id|v_minor
suffix:semicolon
multiline_comment|/* 0x30 */
DECL|member|boot_crc
id|u_int32
id|boot_crc
suffix:semicolon
DECL|member|flags
id|u_short
id|flags
suffix:semicolon
DECL|macro|SYMBIOS_SCAM_ENABLE
mdefine_line|#define SYMBIOS_SCAM_ENABLE&t;(1)
DECL|macro|SYMBIOS_PARITY_ENABLE
mdefine_line|#define SYMBIOS_PARITY_ENABLE&t;(1&lt;&lt;1)
DECL|macro|SYMBIOS_VERBOSE_MSGS
mdefine_line|#define SYMBIOS_VERBOSE_MSGS&t;(1&lt;&lt;2)
DECL|macro|SYMBIOS_CHS_MAPPING
mdefine_line|#define SYMBIOS_CHS_MAPPING&t;(1&lt;&lt;3)
DECL|macro|SYMBIOS_NO_NVRAM
mdefine_line|#define SYMBIOS_NO_NVRAM&t;(1&lt;&lt;3)&t;/* ??? */
DECL|member|flags1
id|u_short
id|flags1
suffix:semicolon
DECL|macro|SYMBIOS_SCAN_HI_LO
mdefine_line|#define SYMBIOS_SCAN_HI_LO&t;(1)
DECL|member|term_state
id|u_short
id|term_state
suffix:semicolon
DECL|macro|SYMBIOS_TERM_CANT_PROGRAM
mdefine_line|#define SYMBIOS_TERM_CANT_PROGRAM&t;(0)
DECL|macro|SYMBIOS_TERM_ENABLED
mdefine_line|#define SYMBIOS_TERM_ENABLED&t;&t;(1)
DECL|macro|SYMBIOS_TERM_DISABLED
mdefine_line|#define SYMBIOS_TERM_DISABLED&t;&t;(2)
DECL|member|rmvbl_flags
id|u_short
id|rmvbl_flags
suffix:semicolon
DECL|macro|SYMBIOS_RMVBL_NO_SUPPORT
mdefine_line|#define SYMBIOS_RMVBL_NO_SUPPORT&t;(0)
DECL|macro|SYMBIOS_RMVBL_BOOT_DEVICE
mdefine_line|#define SYMBIOS_RMVBL_BOOT_DEVICE&t;(1)
DECL|macro|SYMBIOS_RMVBL_MEDIA_INSTALLED
mdefine_line|#define SYMBIOS_RMVBL_MEDIA_INSTALLED&t;(2)
DECL|member|host_id
id|u_char
id|host_id
suffix:semicolon
DECL|member|num_hba
id|u_char
id|num_hba
suffix:semicolon
multiline_comment|/* 0x04 */
DECL|member|num_devices
id|u_char
id|num_devices
suffix:semicolon
multiline_comment|/* 0x10 */
DECL|member|max_scam_devices
id|u_char
id|max_scam_devices
suffix:semicolon
multiline_comment|/* 0x04 */
DECL|member|num_valid_scam_devives
id|u_char
id|num_valid_scam_devives
suffix:semicolon
multiline_comment|/* 0x00 */
DECL|member|rsvd
id|u_char
id|rsvd
suffix:semicolon
multiline_comment|/* Boot order 14 bytes * 4 */
DECL|struct|Symbios_host
r_struct
id|Symbios_host
(brace
DECL|member|type
id|u_short
id|type
suffix:semicolon
multiline_comment|/* 4:8xx / 0:nok */
DECL|member|device_id
id|u_short
id|device_id
suffix:semicolon
multiline_comment|/* PCI device id */
DECL|member|vendor_id
id|u_short
id|vendor_id
suffix:semicolon
multiline_comment|/* PCI vendor id */
DECL|member|bus_nr
id|u_char
id|bus_nr
suffix:semicolon
multiline_comment|/* PCI bus number */
DECL|member|device_fn
id|u_char
id|device_fn
suffix:semicolon
multiline_comment|/* PCI device/function number &lt;&lt; 3*/
DECL|member|word8
id|u_short
id|word8
suffix:semicolon
DECL|member|flags
id|u_short
id|flags
suffix:semicolon
DECL|macro|SYMBIOS_INIT_SCAN_AT_BOOT
mdefine_line|#define&t;SYMBIOS_INIT_SCAN_AT_BOOT&t;(1)
DECL|member|io_port
id|u_short
id|io_port
suffix:semicolon
multiline_comment|/* PCI io_port address */
DECL|member|host
)brace
id|host
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Targets 8 bytes * 16 */
DECL|struct|Symbios_target
r_struct
id|Symbios_target
(brace
DECL|member|flags
id|u_char
id|flags
suffix:semicolon
DECL|macro|SYMBIOS_DISCONNECT_ENABLE
mdefine_line|#define SYMBIOS_DISCONNECT_ENABLE&t;(1)
DECL|macro|SYMBIOS_SCAN_AT_BOOT_TIME
mdefine_line|#define SYMBIOS_SCAN_AT_BOOT_TIME&t;(1&lt;&lt;1)
DECL|macro|SYMBIOS_SCAN_LUNS
mdefine_line|#define SYMBIOS_SCAN_LUNS&t;&t;(1&lt;&lt;2)
DECL|macro|SYMBIOS_QUEUE_TAGS_ENABLED
mdefine_line|#define SYMBIOS_QUEUE_TAGS_ENABLED&t;(1&lt;&lt;3)
DECL|member|rsvd
id|u_char
id|rsvd
suffix:semicolon
DECL|member|bus_width
id|u_char
id|bus_width
suffix:semicolon
multiline_comment|/* 0x08/0x10 */
DECL|member|sync_offset
id|u_char
id|sync_offset
suffix:semicolon
DECL|member|sync_period
id|u_short
id|sync_period
suffix:semicolon
multiline_comment|/* 4*period factor */
DECL|member|timeout
id|u_short
id|timeout
suffix:semicolon
DECL|member|target
)brace
id|target
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Scam table 8 bytes * 4 */
DECL|struct|Symbios_scam
r_struct
id|Symbios_scam
(brace
DECL|member|id
id|u_short
id|id
suffix:semicolon
DECL|member|method
id|u_short
id|method
suffix:semicolon
DECL|macro|SYMBIOS_SCAM_DEFAULT_METHOD
mdefine_line|#define SYMBIOS_SCAM_DEFAULT_METHOD&t;(0)
DECL|macro|SYMBIOS_SCAM_DONT_ASSIGN
mdefine_line|#define SYMBIOS_SCAM_DONT_ASSIGN&t;(1)
DECL|macro|SYMBIOS_SCAM_SET_SPECIFIC_ID
mdefine_line|#define SYMBIOS_SCAM_SET_SPECIFIC_ID&t;(2)
DECL|macro|SYMBIOS_SCAM_USE_ORDER_GIVEN
mdefine_line|#define SYMBIOS_SCAM_USE_ORDER_GIVEN&t;(3)
DECL|member|status
id|u_short
id|status
suffix:semicolon
DECL|macro|SYMBIOS_SCAM_UNKNOWN
mdefine_line|#define SYMBIOS_SCAM_UNKNOWN&t;&t;(0)
DECL|macro|SYMBIOS_SCAM_DEVICE_NOT_FOUND
mdefine_line|#define SYMBIOS_SCAM_DEVICE_NOT_FOUND&t;(1)
DECL|macro|SYMBIOS_SCAM_ID_NOT_SET
mdefine_line|#define SYMBIOS_SCAM_ID_NOT_SET&t;&t;(2)
DECL|macro|SYMBIOS_SCAM_ID_VALID
mdefine_line|#define SYMBIOS_SCAM_ID_VALID&t;&t;(3)
DECL|member|target_id
id|u_char
id|target_id
suffix:semicolon
DECL|member|rsvd
id|u_char
id|rsvd
suffix:semicolon
DECL|member|scam
)brace
id|scam
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|spare_devices
id|u_char
id|spare_devices
(braket
l_int|15
op_star
l_int|8
)braket
suffix:semicolon
DECL|member|trailer
id|u_char
id|trailer
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* 0xfe 0xfe 0x00 0x00 0x00 0x00 */
)brace
suffix:semicolon
DECL|typedef|Symbios_nvram
r_typedef
r_struct
id|Symbios_nvram
id|Symbios_nvram
suffix:semicolon
DECL|typedef|Symbios_host
r_typedef
r_struct
id|Symbios_host
id|Symbios_host
suffix:semicolon
DECL|typedef|Symbios_target
r_typedef
r_struct
id|Symbios_target
id|Symbios_target
suffix:semicolon
DECL|typedef|Symbios_scam
r_typedef
r_struct
id|Symbios_scam
id|Symbios_scam
suffix:semicolon
multiline_comment|/*&n;**&t;Tekram NvRAM data format.&n;*/
DECL|macro|TEKRAM_NVRAM_SIZE
mdefine_line|#define TEKRAM_NVRAM_SIZE 64
DECL|macro|TEKRAM_NVRAM_ADDRESS
mdefine_line|#define TEKRAM_NVRAM_ADDRESS 0
DECL|struct|Tekram_nvram
r_struct
id|Tekram_nvram
(brace
DECL|struct|Tekram_target
r_struct
id|Tekram_target
(brace
DECL|member|flags
id|u_char
id|flags
suffix:semicolon
DECL|macro|TEKRAM_PARITY_CHECK
mdefine_line|#define&t;TEKRAM_PARITY_CHECK&t;&t;(1)
DECL|macro|TEKRAM_SYNC_NEGO
mdefine_line|#define TEKRAM_SYNC_NEGO&t;&t;(1&lt;&lt;1)
DECL|macro|TEKRAM_DISCONNECT_ENABLE
mdefine_line|#define TEKRAM_DISCONNECT_ENABLE&t;(1&lt;&lt;2)
DECL|macro|TEKRAM_START_CMD
mdefine_line|#define&t;TEKRAM_START_CMD&t;&t;(1&lt;&lt;3)
DECL|macro|TEKRAM_TAGGED_COMMANDS
mdefine_line|#define TEKRAM_TAGGED_COMMANDS&t;&t;(1&lt;&lt;4)
DECL|macro|TEKRAM_WIDE_NEGO
mdefine_line|#define TEKRAM_WIDE_NEGO&t;&t;(1&lt;&lt;5)
DECL|member|sync_index
id|u_char
id|sync_index
suffix:semicolon
DECL|member|word2
id|u_short
id|word2
suffix:semicolon
DECL|member|target
)brace
id|target
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|host_id
id|u_char
id|host_id
suffix:semicolon
DECL|member|flags
id|u_char
id|flags
suffix:semicolon
DECL|macro|TEKRAM_MORE_THAN_2_DRIVES
mdefine_line|#define TEKRAM_MORE_THAN_2_DRIVES&t;(1)
DECL|macro|TEKRAM_DRIVES_SUP_1GB
mdefine_line|#define TEKRAM_DRIVES_SUP_1GB&t;&t;(1&lt;&lt;1)
DECL|macro|TEKRAM_RESET_ON_POWER_ON
mdefine_line|#define&t;TEKRAM_RESET_ON_POWER_ON&t;(1&lt;&lt;2)
DECL|macro|TEKRAM_ACTIVE_NEGATION
mdefine_line|#define TEKRAM_ACTIVE_NEGATION&t;&t;(1&lt;&lt;3)
DECL|macro|TEKRAM_IMMEDIATE_SEEK
mdefine_line|#define TEKRAM_IMMEDIATE_SEEK&t;&t;(1&lt;&lt;4)
DECL|macro|TEKRAM_SCAN_LUNS
mdefine_line|#define&t;TEKRAM_SCAN_LUNS&t;&t;(1&lt;&lt;5)
DECL|macro|TEKRAM_REMOVABLE_FLAGS
mdefine_line|#define&t;TEKRAM_REMOVABLE_FLAGS&t;&t;(3&lt;&lt;6)&t;/* 0: disable; 1: boot device; 2:all */
DECL|member|boot_delay_index
id|u_char
id|boot_delay_index
suffix:semicolon
DECL|member|max_tags_index
id|u_char
id|max_tags_index
suffix:semicolon
DECL|member|flags1
id|u_short
id|flags1
suffix:semicolon
DECL|macro|TEKRAM_F2_F6_ENABLED
mdefine_line|#define TEKRAM_F2_F6_ENABLED&t;&t;(1)
DECL|member|spare
id|u_short
id|spare
(braket
l_int|29
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|Tekram_nvram
r_typedef
r_struct
id|Tekram_nvram
id|Tekram_nvram
suffix:semicolon
DECL|typedef|Tekram_target
r_typedef
r_struct
id|Tekram_target
id|Tekram_target
suffix:semicolon
DECL|variable|__initdata
r_static
id|u_char
id|Tekram_sync
(braket
l_int|12
)braket
id|__initdata
op_assign
(brace
l_int|25
comma
l_int|31
comma
l_int|37
comma
l_int|43
comma
l_int|50
comma
l_int|62
comma
l_int|75
comma
l_int|125
comma
l_int|12
comma
l_int|15
comma
l_int|18
comma
l_int|21
)brace
suffix:semicolon
macro_line|#endif /* SCSI_NCR_NVRAM_SUPPORT */
multiline_comment|/*&n;**&t;Structures used by sym53c8xx_detect/sym53c8xx_pci_init to &n;**&t;transmit device configuration to the ncr_attach() function.&n;*/
r_typedef
r_struct
(brace
DECL|member|bus
r_int
id|bus
suffix:semicolon
DECL|member|device_fn
id|u_char
id|device_fn
suffix:semicolon
DECL|member|base
id|u_long
id|base
suffix:semicolon
DECL|member|base_2
id|u_long
id|base_2
suffix:semicolon
DECL|member|io_port
id|u_long
id|io_port
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* port and reg fields to use INB, OUTB macros */
DECL|member|base_io
id|u_long
id|base_io
suffix:semicolon
DECL|member|reg
r_volatile
r_struct
id|ncr_reg
op_star
id|reg
suffix:semicolon
DECL|typedef|ncr_slot
)brace
id|ncr_slot
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|type
r_int
id|type
suffix:semicolon
DECL|macro|SCSI_NCR_SYMBIOS_NVRAM
mdefine_line|#define&t;SCSI_NCR_SYMBIOS_NVRAM&t;(1)
DECL|macro|SCSI_NCR_TEKRAM_NVRAM
mdefine_line|#define&t;SCSI_NCR_TEKRAM_NVRAM&t;(2)
macro_line|#ifdef&t;SCSI_NCR_NVRAM_SUPPORT
r_union
(brace
DECL|member|Symbios
id|Symbios_nvram
id|Symbios
suffix:semicolon
DECL|member|Tekram
id|Tekram_nvram
id|Tekram
suffix:semicolon
DECL|member|data
)brace
id|data
suffix:semicolon
macro_line|#endif
DECL|typedef|ncr_nvram
)brace
id|ncr_nvram
suffix:semicolon
multiline_comment|/*&n;**&t;Structure used by sym53c8xx_detect/sym53c8xx_pci_init&n;**&t;to save data on each detected board for ncr_attach().&n;*/
r_typedef
r_struct
(brace
DECL|member|slot
id|ncr_slot
id|slot
suffix:semicolon
DECL|member|chip
id|ncr_chip
id|chip
suffix:semicolon
DECL|member|nvram
id|ncr_nvram
op_star
id|nvram
suffix:semicolon
DECL|member|host_id
id|u_char
id|host_id
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_PQS_PDS_SUPPORT
DECL|member|pqs_pds
id|u_char
id|pqs_pds
suffix:semicolon
macro_line|#endif
DECL|member|attach_done
r_int
id|attach_done
suffix:semicolon
DECL|typedef|ncr_device
)brace
id|ncr_device
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&t;assert ()&n;**&n;**==========================================================&n;**&n;**&t;modified copy from 386bsd:/usr/include/sys/assert.h&n;**&n;**----------------------------------------------------------&n;*/
DECL|macro|assert
mdefine_line|#define&t;assert(expression) { &bslash;&n;&t;if (!(expression)) { &bslash;&n;&t;&t;(void)panic( &bslash;&n;&t;&t;&t;&quot;assertion &bslash;&quot;%s&bslash;&quot; failed: file &bslash;&quot;%s&bslash;&quot;, line %d&bslash;n&quot;, &bslash;&n;&t;&t;&t;#expression, &bslash;&n;&t;&t;&t;__FILE__, __LINE__); &bslash;&n;&t;} &bslash;&n;}
multiline_comment|/*==========================================================&n;**&n;**&t;Big/Little endian support.&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**&t;If the NCR uses big endian addressing mode over the &n;**&t;PCI, actual io register addresses for byte and word &n;**&t;accesses must be changed according to lane routing.&n;**&t;Btw, ncr_offb() and ncr_offw() macros only apply to &n;**&t;constants and so donnot generate bloated code.&n;*/
macro_line|#if&t;defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|ncr_offb
mdefine_line|#define ncr_offb(o)&t;(((o)&amp;~3)+((~((o)&amp;3))&amp;3))
DECL|macro|ncr_offw
mdefine_line|#define ncr_offw(o)&t;(((o)&amp;~3)+((~((o)&amp;3))&amp;2))
macro_line|#else
DECL|macro|ncr_offb
mdefine_line|#define ncr_offb(o)&t;(o)
DECL|macro|ncr_offw
mdefine_line|#define ncr_offw(o)&t;(o)
macro_line|#endif
multiline_comment|/*&n;**&t;If the CPU and the NCR use same endian-ness adressing,&n;**&t;no byte reordering is needed for script patching.&n;**&t;Macro cpu_to_scr() is to be used for script patching.&n;**&t;Macro scr_to_cpu() is to be used for getting a DWORD &n;**&t;from the script.&n;*/
macro_line|#if&t;defined(__BIG_ENDIAN) &amp;&amp; !defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|cpu_to_scr
mdefine_line|#define cpu_to_scr(dw)&t;cpu_to_le32(dw)
DECL|macro|scr_to_cpu
mdefine_line|#define scr_to_cpu(dw)&t;le32_to_cpu(dw)
macro_line|#elif&t;defined(__LITTLE_ENDIAN) &amp;&amp; defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|cpu_to_scr
mdefine_line|#define cpu_to_scr(dw)&t;cpu_to_be32(dw)
DECL|macro|scr_to_cpu
mdefine_line|#define scr_to_cpu(dw)&t;be32_to_cpu(dw)
macro_line|#else
DECL|macro|cpu_to_scr
mdefine_line|#define cpu_to_scr(dw)&t;(dw)
DECL|macro|scr_to_cpu
mdefine_line|#define scr_to_cpu(dw)&t;(dw)
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;Access to the controller chip.&n;**&n;**&t;If NCR_IOMAPPED is defined, the driver will use &n;**&t;normal IOs instead of the MEMORY MAPPED IO method  &n;**&t;recommended by PCI specifications.&n;**&t;If all PCI bridges, host brigdes and architectures &n;**&t;would have been correctly designed for PCI, this &n;**&t;option would be useless.&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**&t;If the CPU and the NCR use same endian-ness adressing,&n;**&t;no byte reordering is needed for accessing chip io &n;**&t;registers. Functions suffixed by &squot;_raw&squot; are assumed &n;**&t;to access the chip over the PCI without doing byte &n;**&t;reordering. Functions suffixed by &squot;_l2b&squot; are &n;**&t;assumed to perform little-endian to big-endian byte &n;**&t;reordering, those suffixed by &squot;_b2l&squot; blah, blah,&n;**&t;blah, ...&n;*/
macro_line|#if defined(NCR_IOMAPPED)
multiline_comment|/*&n;**&t;IO mapped only input / ouput&n;*/
DECL|macro|INB_OFF
mdefine_line|#define&t;INB_OFF(o)&t;&t;inb (np-&gt;base_io + ncr_offb(o))
DECL|macro|OUTB_OFF
mdefine_line|#define&t;OUTB_OFF(o, val)&t;outb ((val), np-&gt;base_io + ncr_offb(o))
macro_line|#if&t;defined(__BIG_ENDIAN) &amp;&amp; !defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|INW_OFF
mdefine_line|#define&t;INW_OFF(o)&t;&t;inw_l2b (np-&gt;base_io + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define&t;INL_OFF(o)&t;&t;inl_l2b (np-&gt;base_io + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define&t;OUTW_OFF(o, val)&t;outw_b2l ((val), np-&gt;base_io + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define&t;OUTL_OFF(o, val)&t;outl_b2l ((val), np-&gt;base_io + (o))
macro_line|#elif&t;defined(__LITTLE_ENDIAN) &amp;&amp; defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|INW_OFF
mdefine_line|#define&t;INW_OFF(o)&t;&t;inw_b2l (np-&gt;base_io + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define&t;INL_OFF(o)&t;&t;inl_b2l (np-&gt;base_io + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define&t;OUTW_OFF(o, val)&t;outw_l2b ((val), np-&gt;base_io + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define&t;OUTL_OFF(o, val)&t;outl_l2b ((val), np-&gt;base_io + (o))
macro_line|#else
DECL|macro|INW_OFF
mdefine_line|#define&t;INW_OFF(o)&t;&t;inw_raw (np-&gt;base_io + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define&t;INL_OFF(o)&t;&t;inl_raw (np-&gt;base_io + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define&t;OUTW_OFF(o, val)&t;outw_raw ((val), np-&gt;base_io + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define&t;OUTL_OFF(o, val)&t;outl_raw ((val), np-&gt;base_io + (o))
macro_line|#endif&t;/* ENDIANs */
macro_line|#else&t;/* defined NCR_IOMAPPED */
multiline_comment|/*&n;**&t;MEMORY mapped IO input / output&n;*/
DECL|macro|INB_OFF
mdefine_line|#define INB_OFF(o)&t;&t;readb((char *)np-&gt;reg + ncr_offb(o))
DECL|macro|OUTB_OFF
mdefine_line|#define OUTB_OFF(o, val)&t;writeb((val), (char *)np-&gt;reg + ncr_offb(o))
macro_line|#if&t;defined(__BIG_ENDIAN) &amp;&amp; !defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|INW_OFF
mdefine_line|#define INW_OFF(o)&t;&t;readw_l2b((char *)np-&gt;reg + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define INL_OFF(o)&t;&t;readl_l2b((char *)np-&gt;reg + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define OUTW_OFF(o, val)&t;writew_b2l((val), (char *)np-&gt;reg + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define OUTL_OFF(o, val)&t;writel_b2l((val), (char *)np-&gt;reg + (o))
macro_line|#elif&t;defined(__LITTLE_ENDIAN) &amp;&amp; defined(SCSI_NCR_BIG_ENDIAN)
DECL|macro|INW_OFF
mdefine_line|#define INW_OFF(o)&t;&t;readw_b2l((char *)np-&gt;reg + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define INL_OFF(o)&t;&t;readl_b2l((char *)np-&gt;reg + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define OUTW_OFF(o, val)&t;writew_l2b((val), (char *)np-&gt;reg + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define OUTL_OFF(o, val)&t;writel_l2b((val), (char *)np-&gt;reg + (o))
macro_line|#else
DECL|macro|INW_OFF
mdefine_line|#define INW_OFF(o)&t;&t;readw_raw((char *)np-&gt;reg + ncr_offw(o))
DECL|macro|INL_OFF
mdefine_line|#define INL_OFF(o)&t;&t;readl_raw((char *)np-&gt;reg + (o))
DECL|macro|OUTW_OFF
mdefine_line|#define OUTW_OFF(o, val)&t;writew_raw((val), (char *)np-&gt;reg + ncr_offw(o))
DECL|macro|OUTL_OFF
mdefine_line|#define OUTL_OFF(o, val)&t;writel_raw((val), (char *)np-&gt;reg + (o))
macro_line|#endif
macro_line|#endif&t;/* defined NCR_IOMAPPED */
DECL|macro|INB
mdefine_line|#define INB(r)&t;&t;INB_OFF (offsetof(struct ncr_reg,r))
DECL|macro|INW
mdefine_line|#define INW(r)&t;&t;INW_OFF (offsetof(struct ncr_reg,r))
DECL|macro|INL
mdefine_line|#define INL(r)&t;&t;INL_OFF (offsetof(struct ncr_reg,r))
DECL|macro|OUTB
mdefine_line|#define OUTB(r, val)&t;OUTB_OFF (offsetof(struct ncr_reg,r), (val))
DECL|macro|OUTW
mdefine_line|#define OUTW(r, val)&t;OUTW_OFF (offsetof(struct ncr_reg,r), (val))
DECL|macro|OUTL
mdefine_line|#define OUTL(r, val)&t;OUTL_OFF (offsetof(struct ncr_reg,r), (val))
multiline_comment|/*&n;**&t;Set bit field ON, OFF &n;*/
DECL|macro|OUTONB
mdefine_line|#define OUTONB(r, m)&t;OUTB(r, INB(r) | (m))
DECL|macro|OUTOFFB
mdefine_line|#define OUTOFFB(r, m)&t;OUTB(r, INB(r) &amp; ~(m))
DECL|macro|OUTONW
mdefine_line|#define OUTONW(r, m)&t;OUTW(r, INW(r) | (m))
DECL|macro|OUTOFFW
mdefine_line|#define OUTOFFW(r, m)&t;OUTW(r, INW(r) &amp; ~(m))
DECL|macro|OUTONL
mdefine_line|#define OUTONL(r, m)&t;OUTL(r, INL(r) | (m))
DECL|macro|OUTOFFL
mdefine_line|#define OUTOFFL(r, m)&t;OUTL(r, INL(r) &amp; ~(m))
multiline_comment|/*==========================================================&n;**&n;**&t;Command control block states.&n;**&n;**==========================================================&n;*/
DECL|macro|HS_IDLE
mdefine_line|#define HS_IDLE&t;&t;(0)
DECL|macro|HS_BUSY
mdefine_line|#define HS_BUSY&t;&t;(1)
DECL|macro|HS_NEGOTIATE
mdefine_line|#define HS_NEGOTIATE&t;(2)&t;/* sync/wide data transfer*/
DECL|macro|HS_DISCONNECT
mdefine_line|#define HS_DISCONNECT&t;(3)&t;/* Disconnected by target */
DECL|macro|HS_DONEMASK
mdefine_line|#define HS_DONEMASK&t;(0x80)
DECL|macro|HS_COMPLETE
mdefine_line|#define HS_COMPLETE&t;(4|HS_DONEMASK)
DECL|macro|HS_SEL_TIMEOUT
mdefine_line|#define HS_SEL_TIMEOUT&t;(5|HS_DONEMASK)&t;/* Selection timeout      */
DECL|macro|HS_RESET
mdefine_line|#define HS_RESET&t;(6|HS_DONEMASK)&t;/* SCSI reset&t;          */
DECL|macro|HS_ABORTED
mdefine_line|#define HS_ABORTED&t;(7|HS_DONEMASK)&t;/* Transfer aborted       */
DECL|macro|HS_TIMEOUT
mdefine_line|#define HS_TIMEOUT&t;(8|HS_DONEMASK)&t;/* Software timeout       */
DECL|macro|HS_FAIL
mdefine_line|#define HS_FAIL&t;&t;(9|HS_DONEMASK)&t;/* SCSI or PCI bus errors */
DECL|macro|HS_UNEXPECTED
mdefine_line|#define HS_UNEXPECTED&t;(10|HS_DONEMASK)/* Unexpected disconnect  */
DECL|macro|DSA_INVALID
mdefine_line|#define DSA_INVALID 0xffffffff
multiline_comment|/*==========================================================&n;**&n;**&t;Software Interrupt Codes&n;**&n;**==========================================================&n;*/
DECL|macro|SIR_BAD_STATUS
mdefine_line|#define&t;SIR_BAD_STATUS&t;&t;(1)
DECL|macro|SIR_SEL_ATN_NO_MSG_OUT
mdefine_line|#define&t;SIR_SEL_ATN_NO_MSG_OUT&t;(2)
DECL|macro|SIR_NEGO_SYNC
mdefine_line|#define&t;SIR_NEGO_SYNC&t;&t;(3)
DECL|macro|SIR_NEGO_WIDE
mdefine_line|#define&t;SIR_NEGO_WIDE&t;&t;(4)
DECL|macro|SIR_NEGO_FAILED
mdefine_line|#define&t;SIR_NEGO_FAILED&t;&t;(5)
DECL|macro|SIR_NEGO_PROTO
mdefine_line|#define&t;SIR_NEGO_PROTO&t;&t;(6)
DECL|macro|SIR_REJECT_RECEIVED
mdefine_line|#define&t;SIR_REJECT_RECEIVED&t;(7)
DECL|macro|SIR_REJECT_TO_SEND
mdefine_line|#define&t;SIR_REJECT_TO_SEND&t;(8)
DECL|macro|SIR_IGN_RESIDUE
mdefine_line|#define&t;SIR_IGN_RESIDUE&t;&t;(9)
DECL|macro|SIR_MISSING_SAVE
mdefine_line|#define&t;SIR_MISSING_SAVE&t;(10)
DECL|macro|SIR_RESEL_NO_MSG_IN
mdefine_line|#define&t;SIR_RESEL_NO_MSG_IN&t;(11)
DECL|macro|SIR_RESEL_NO_IDENTIFY
mdefine_line|#define&t;SIR_RESEL_NO_IDENTIFY&t;(12)
DECL|macro|SIR_RESEL_BAD_LUN
mdefine_line|#define&t;SIR_RESEL_BAD_LUN&t;(13)
DECL|macro|SIR_UNUSED_14
mdefine_line|#define&t;SIR_UNUSED_14&t;&t;(14)
DECL|macro|SIR_RESEL_BAD_I_T_L
mdefine_line|#define&t;SIR_RESEL_BAD_I_T_L&t;(15)
DECL|macro|SIR_RESEL_BAD_I_T_L_Q
mdefine_line|#define&t;SIR_RESEL_BAD_I_T_L_Q&t;(16)
DECL|macro|SIR_UNUSED_17
mdefine_line|#define&t;SIR_UNUSED_17&t;&t;(17)
DECL|macro|SIR_RESEL_ABORTED
mdefine_line|#define&t;SIR_RESEL_ABORTED&t;(18)
DECL|macro|SIR_MSG_OUT_DONE
mdefine_line|#define&t;SIR_MSG_OUT_DONE&t;(19)
DECL|macro|SIR_MAX
mdefine_line|#define&t;SIR_MAX&t;&t;&t;(19)
multiline_comment|/*==========================================================&n;**&n;**&t;Extended error codes.&n;**&t;xerr_status field of struct ccb.&n;**&n;**==========================================================&n;*/
DECL|macro|XE_OK
mdefine_line|#define&t;XE_OK&t;&t;(0)
DECL|macro|XE_EXTRA_DATA
mdefine_line|#define&t;XE_EXTRA_DATA&t;(1)&t;/* unexpected data phase */
DECL|macro|XE_BAD_PHASE
mdefine_line|#define&t;XE_BAD_PHASE&t;(2)&t;/* illegal phase (4/5)   */
multiline_comment|/*==========================================================&n;**&n;**&t;Negotiation status.&n;**&t;nego_status field&t;of struct ccb.&n;**&n;**==========================================================&n;*/
DECL|macro|NS_SYNC
mdefine_line|#define NS_SYNC&t;&t;(1)
DECL|macro|NS_WIDE
mdefine_line|#define NS_WIDE&t;&t;(2)
multiline_comment|/*==========================================================&n;**&n;**&t;&quot;Special features&quot; of targets.&n;**&t;quirks field&t;&t;of struct tcb.&n;**&t;actualquirks field&t;of struct ccb.&n;**&n;**==========================================================&n;*/
DECL|macro|QUIRK_AUTOSAVE
mdefine_line|#define&t;QUIRK_AUTOSAVE&t;(0x01)
DECL|macro|QUIRK_NOMSG
mdefine_line|#define&t;QUIRK_NOMSG&t;(0x02)
DECL|macro|QUIRK_NOSYNC
mdefine_line|#define QUIRK_NOSYNC&t;(0x10)
DECL|macro|QUIRK_NOWIDE16
mdefine_line|#define QUIRK_NOWIDE16&t;(0x20)
multiline_comment|/*==========================================================&n;**&n;**&t;Capability bits in Inquire response byte 7.&n;**&n;**==========================================================&n;*/
DECL|macro|INQ7_QUEUE
mdefine_line|#define&t;INQ7_QUEUE&t;(0x02)
DECL|macro|INQ7_SYNC
mdefine_line|#define&t;INQ7_SYNC&t;(0x10)
DECL|macro|INQ7_WIDE16
mdefine_line|#define&t;INQ7_WIDE16&t;(0x20)
multiline_comment|/*==========================================================&n;**&n;**&t;A CCB hashed table is used to retrieve CCB address &n;**&t;from DSA value.&n;**&n;**==========================================================&n;*/
DECL|macro|CCB_HASH_SHIFT
mdefine_line|#define CCB_HASH_SHIFT&t;&t;8
DECL|macro|CCB_HASH_SIZE
mdefine_line|#define CCB_HASH_SIZE&t;&t;(1UL &lt;&lt; CCB_HASH_SHIFT)
DECL|macro|CCB_HASH_MASK
mdefine_line|#define CCB_HASH_MASK&t;&t;(CCB_HASH_SIZE-1)
DECL|macro|CCB_HASH_CODE
mdefine_line|#define CCB_HASH_CODE(dsa)&t;(((dsa) &gt;&gt; 11) &amp; CCB_HASH_MASK)
multiline_comment|/*==========================================================&n;**&n;**&t;Declaration of structs.&n;**&n;**==========================================================&n;*/
r_struct
id|tcb
suffix:semicolon
r_struct
id|lcb
suffix:semicolon
r_struct
id|ccb
suffix:semicolon
r_struct
id|ncb
suffix:semicolon
r_struct
id|script
suffix:semicolon
DECL|typedef|ncb_p
r_typedef
r_struct
id|ncb
op_star
id|ncb_p
suffix:semicolon
DECL|typedef|tcb_p
r_typedef
r_struct
id|tcb
op_star
id|tcb_p
suffix:semicolon
DECL|typedef|lcb_p
r_typedef
r_struct
id|lcb
op_star
id|lcb_p
suffix:semicolon
DECL|typedef|ccb_p
r_typedef
r_struct
id|ccb
op_star
id|ccb_p
suffix:semicolon
DECL|struct|link
r_struct
id|link
(brace
DECL|member|l_cmd
id|ncrcmd
id|l_cmd
suffix:semicolon
DECL|member|l_paddr
id|ncrcmd
id|l_paddr
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|usrcmd
r_struct
id|usrcmd
(brace
DECL|member|target
id|u_long
id|target
suffix:semicolon
DECL|member|lun
id|u_long
id|lun
suffix:semicolon
DECL|member|data
id|u_long
id|data
suffix:semicolon
DECL|member|cmd
id|u_long
id|cmd
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|UC_SETSYNC
mdefine_line|#define UC_SETSYNC      10
DECL|macro|UC_SETTAGS
mdefine_line|#define UC_SETTAGS&t;11
DECL|macro|UC_SETDEBUG
mdefine_line|#define UC_SETDEBUG&t;12
DECL|macro|UC_SETORDER
mdefine_line|#define UC_SETORDER&t;13
DECL|macro|UC_SETWIDE
mdefine_line|#define UC_SETWIDE&t;14
DECL|macro|UC_SETFLAG
mdefine_line|#define UC_SETFLAG&t;15
DECL|macro|UC_CLEARPROF
mdefine_line|#define UC_CLEARPROF&t;16
DECL|macro|UC_SETVERBOSE
mdefine_line|#define UC_SETVERBOSE&t;17
DECL|macro|UF_TRACE
mdefine_line|#define&t;UF_TRACE&t;(0x01)
DECL|macro|UF_NODISC
mdefine_line|#define&t;UF_NODISC&t;(0x02)
DECL|macro|UF_NOSCAN
mdefine_line|#define&t;UF_NOSCAN&t;(0x04)
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
multiline_comment|/*&n;**&t;profiling data (per host)&n;*/
DECL|struct|profile
r_struct
id|profile
(brace
DECL|member|num_trans
id|u_long
id|num_trans
suffix:semicolon
DECL|member|num_disc
id|u_long
id|num_disc
suffix:semicolon
DECL|member|num_disc0
id|u_long
id|num_disc0
suffix:semicolon
DECL|member|num_break
id|u_long
id|num_break
suffix:semicolon
DECL|member|num_int
id|u_long
id|num_int
suffix:semicolon
DECL|member|num_fly
id|u_long
id|num_fly
suffix:semicolon
DECL|member|num_kbytes
id|u_long
id|num_kbytes
suffix:semicolon
macro_line|#if 000
id|u_long
id|num_br1k
suffix:semicolon
id|u_long
id|num_br2k
suffix:semicolon
id|u_long
id|num_br4k
suffix:semicolon
id|u_long
id|num_br8k
suffix:semicolon
id|u_long
id|num_brnk
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*========================================================================&n;**&n;**&t;Declaration of structs:&t;&t;target control block&n;**&n;**========================================================================&n;*/
DECL|struct|tcb
r_struct
id|tcb
(brace
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;LUN tables.&n;&t;**&t;An array of bus addresses is used on reselection by &n;&t;**&t;the SCRIPT.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|luntbl
id|u_int32
op_star
id|luntbl
suffix:semicolon
multiline_comment|/* lcbs bus address table&t;*/
DECL|member|b_luntbl
id|u_int32
id|b_luntbl
suffix:semicolon
multiline_comment|/* bus address of this table&t;*/
DECL|member|lp
id|lcb_p
id|lp
(braket
id|MAX_LUN
)braket
suffix:semicolon
multiline_comment|/* The lcb&squot;s of this tcb&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Target capabilities.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|inq_done
id|u_char
id|inq_done
suffix:semicolon
multiline_comment|/* Target capabilities received&t;*/
DECL|member|inq_byte7
id|u_char
id|inq_byte7
suffix:semicolon
multiline_comment|/* Contains these capabilities&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Pointer to the ccb used for negotiation.&n;&t;**&t;Prevent from starting a negotiation for all queued commands &n;&t;**&t;when tagged command queuing is enabled.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|nego_cp
id|ccb_p
id|nego_cp
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;statistical data&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|transfers
id|u_long
id|transfers
suffix:semicolon
DECL|member|bytes
id|u_long
id|bytes
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;negotiation of wide and synch transfer and device quirks.&n;&t;**&t;sval and wval are read from SCRIPTS and so have alignment &n;&t;**&t;constraints.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|minsync
multiline_comment|/*0*/
id|u_char
id|minsync
suffix:semicolon
DECL|member|sval
multiline_comment|/*1*/
id|u_char
id|sval
suffix:semicolon
DECL|member|period
multiline_comment|/*2*/
id|u_short
id|period
suffix:semicolon
DECL|member|maxoffs
multiline_comment|/*0*/
id|u_char
id|maxoffs
suffix:semicolon
DECL|member|quirks
multiline_comment|/*1*/
id|u_char
id|quirks
suffix:semicolon
DECL|member|widedone
multiline_comment|/*2*/
id|u_char
id|widedone
suffix:semicolon
DECL|member|wval
multiline_comment|/*3*/
id|u_char
id|wval
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;User settable limits and options.&n;&t;**&t;These limits are read from the NVRAM if present.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|usrsync
id|u_char
id|usrsync
suffix:semicolon
DECL|member|usrwide
id|u_char
id|usrwide
suffix:semicolon
DECL|member|usrtags
id|u_char
id|usrtags
suffix:semicolon
DECL|member|usrflag
id|u_char
id|usrflag
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*========================================================================&n;**&n;**&t;Declaration of structs:&t;&t;lun control block&n;**&n;**========================================================================&n;*/
DECL|struct|lcb
r_struct
id|lcb
(brace
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;On reselection, SCRIPTS use this value as a JUMP address &n;&t;**&t;after the IDENTIFY has been successfully received.&n;&t;**&t;This field is set to &squot;resel_tag&squot; if TCQ is enabled and &n;&t;**&t;to &squot;resel_notag&squot; if TCQ is disabled.&n;&t;**&t;(Must be at zero due to bad lun handling on reselection)&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|resel_task
multiline_comment|/*0*/
id|u_int32
id|resel_task
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Task table used by the script processor to retrieve the &n;&t;**&t;task corresponding to a reselected nexus. The TAG is used &n;&t;**&t;as offset to determine the corresponding entry.&n;&t;**&t;Each entry contains the associated CCB bus address.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|tasktbl_0
id|u_int32
id|tasktbl_0
suffix:semicolon
multiline_comment|/* Used if TCQ not enabled&t;*/
DECL|member|tasktbl
id|u_int32
op_star
id|tasktbl
suffix:semicolon
DECL|member|b_tasktbl
id|u_int32
id|b_tasktbl
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;CCB queue management.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|busy_ccbq
id|XPT_QUEHEAD
id|busy_ccbq
suffix:semicolon
multiline_comment|/* Queue of busy CCBs&t;&t;*/
DECL|member|wait_ccbq
id|XPT_QUEHEAD
id|wait_ccbq
suffix:semicolon
multiline_comment|/* Queue of waiting for IO CCBs&t;*/
DECL|member|busyccbs
id|u_char
id|busyccbs
suffix:semicolon
multiline_comment|/* CCBs busy for this lun&t;*/
DECL|member|queuedccbs
id|u_char
id|queuedccbs
suffix:semicolon
multiline_comment|/* CCBs queued to the controller*/
DECL|member|queuedepth
id|u_char
id|queuedepth
suffix:semicolon
multiline_comment|/* Queue depth for this lun&t;*/
DECL|member|scdev_depth
id|u_char
id|scdev_depth
suffix:semicolon
multiline_comment|/* SCSI device queue depth&t;*/
DECL|member|maxnxs
id|u_char
id|maxnxs
suffix:semicolon
multiline_comment|/* Max possible nexuses&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Control of tagged command queuing.&n;&t;**&t;Tags allocation is performed using a circular buffer.&n;&t;**&t;This avoids using a loop for tag allocation.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|ia_tag
id|u_char
id|ia_tag
suffix:semicolon
multiline_comment|/* Tag allocation index&t;&t;*/
DECL|member|if_tag
id|u_char
id|if_tag
suffix:semicolon
multiline_comment|/* Tag release index&t;&t;*/
DECL|member|cb_tags
id|u_char
id|cb_tags
(braket
id|SCSI_NCR_MAX_TAGS
)braket
suffix:semicolon
multiline_comment|/* Circular tags buffer&t;*/
DECL|member|usetags
id|u_char
id|usetags
suffix:semicolon
multiline_comment|/* Command queuing is active&t;*/
DECL|member|maxtags
id|u_char
id|maxtags
suffix:semicolon
multiline_comment|/* Max NR of tags asked by user&t;*/
DECL|member|numtags
id|u_char
id|numtags
suffix:semicolon
multiline_comment|/* Current number of tags&t;*/
DECL|member|inq_byte7
id|u_char
id|inq_byte7
suffix:semicolon
multiline_comment|/* Store unit CmdQ capabitility&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;QUEUE FULL and ORDERED tag control.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|num_good
id|u_short
id|num_good
suffix:semicolon
multiline_comment|/* Nr of GOOD since QUEUE FULL&t;*/
DECL|member|tags_umap
id|tagmap_t
id|tags_umap
suffix:semicolon
multiline_comment|/* Used tags bitmap&t;&t;*/
DECL|member|tags_smap
id|tagmap_t
id|tags_smap
suffix:semicolon
multiline_comment|/* Tags in use at &squot;tag_stime&squot;&t;*/
DECL|member|tags_stime
id|u_long
id|tags_stime
suffix:semicolon
multiline_comment|/* Last time we set smap=umap&t;*/
)brace
suffix:semicolon
multiline_comment|/*========================================================================&n;**&n;**      Declaration of structs: actions for a task.&n;**&n;**========================================================================&n;**&n;**&t;It is part of the CCB and is called by the scripts processor to &n;**&t;start or restart the data structure (nexus).&n;**&n;**------------------------------------------------------------------------&n;*/
DECL|struct|action
r_struct
id|action
(brace
DECL|member|start
id|u_int32
id|start
suffix:semicolon
DECL|member|restart
id|u_int32
id|restart
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*========================================================================&n;**&n;**      Declaration of structs: Phase mismatch context.&n;**&n;**========================================================================&n;**&n;**&t;It is part of the CCB and is used as parameters for the DATA &n;**&t;pointer. We need two contexts to handle correctly the SAVED &n;**&t;DATA POINTER.&n;**&n;**------------------------------------------------------------------------&n;*/
DECL|struct|pm_ctx
r_struct
id|pm_ctx
(brace
DECL|member|sg
r_struct
id|scr_tblmove
id|sg
suffix:semicolon
multiline_comment|/* Updated interrupted SG block&t;*/
DECL|member|ret
id|u_int32
id|ret
suffix:semicolon
multiline_comment|/* SCRIPT return address&t;*/
)brace
suffix:semicolon
multiline_comment|/*========================================================================&n;**&n;**      Declaration of structs:     global HEADER.&n;**&n;**========================================================================&n;**&n;**&t;In earlier driver versions, this substructure was copied from the &n;**&t;ccb to a global address after selection (or reselection) and copied &n;**&t;back before disconnect. Since we are now using LOAD/STORE DSA &n;**&t;RELATIVE instructions, the script is able to access directly these &n;**&t;fields, and so, this header is no more copied.&n;**&n;**------------------------------------------------------------------------&n;*/
DECL|struct|head
r_struct
id|head
(brace
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Start and restart SCRIPTS addresses (must be at 0).&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|go
r_struct
id|action
id|go
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Saved data pointer.&n;&t;**&t;Points to the position in the script responsible for the&n;&t;**&t;actual transfer of data.&n;&t;**&t;It&squot;s written after reception of a SAVE_DATA_POINTER message.&n;&t;**&t;The goalpointer points after the last transfer command.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|savep
id|u_int32
id|savep
suffix:semicolon
DECL|member|lastp
id|u_int32
id|lastp
suffix:semicolon
DECL|member|goalp
id|u_int32
id|goalp
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Alternate data pointer.&n;&t;**&t;They are copied back to savep/lastp/goalp by the SCRIPTS &n;&t;**&t;when the direction is unknown and the device claims data out.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|wlastp
id|u_int32
id|wlastp
suffix:semicolon
DECL|member|wgoalp
id|u_int32
id|wgoalp
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Status fields.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|scr_st
id|u_char
id|scr_st
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* script status&t;&t;*/
DECL|member|status
id|u_char
id|status
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* host status&t;&t;&t;*/
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;The status bytes are used by the host and the script processor.&n;**&n;**&t;The last four bytes (status[4]) are copied to the scratchb register&n;**&t;(declared as scr0..scr3 in ncr_reg.h) just after the select/reselect,&n;**&t;and copied back just after disconnecting.&n;**&t;Inside the script the XX_REG are used.&n;**&n;**&t;The first four bytes (scr_st[4]) are used inside the script by &n;**&t;&quot;LOAD/STORE&quot; commands.&n;**&t;Because source and destination must have the same alignment&n;**&t;in a DWORD, the fields HAVE to be at the choosen offsets.&n;**&t;&t;xerr_st&t;&t;0&t;(0x34)&t;scratcha&n;**&t;&t;sync_st&t;&t;1&t;(0x05)&t;sxfer&n;**&t;&t;wide_st&t;&t;3&t;(0x03)&t;scntl3&n;*/
multiline_comment|/*&n;**&t;Last four bytes (script)&n;*/
DECL|macro|QU_REG
mdefine_line|#define  QU_REG&t;scr0
DECL|macro|HS_REG
mdefine_line|#define  HS_REG&t;scr1
DECL|macro|HS_PRT
mdefine_line|#define  HS_PRT&t;nc_scr1
DECL|macro|SS_REG
mdefine_line|#define  SS_REG&t;scr2
DECL|macro|SS_PRT
mdefine_line|#define  SS_PRT&t;nc_scr2
DECL|macro|HF_REG
mdefine_line|#define  HF_REG&t;scr3
DECL|macro|HF_PRT
mdefine_line|#define  HF_PRT&t;nc_scr3
multiline_comment|/*&n;**&t;Last four bytes (host)&n;*/
DECL|macro|actualquirks
mdefine_line|#define  actualquirks  phys.header.status[0]
DECL|macro|host_status
mdefine_line|#define  host_status   phys.header.status[1]
DECL|macro|scsi_status
mdefine_line|#define  scsi_status   phys.header.status[2]
DECL|macro|host_flags
mdefine_line|#define  host_flags    phys.header.status[3]
multiline_comment|/*&n;**&t;Host flags&n;*/
DECL|macro|HF_IN_PM0
mdefine_line|#define HF_IN_PM0&t;1u
DECL|macro|HF_IN_PM1
mdefine_line|#define HF_IN_PM1&t;(1u&lt;&lt;1)
DECL|macro|HF_ACT_PM
mdefine_line|#define HF_ACT_PM&t;(1u&lt;&lt;2)
DECL|macro|HF_DP_SAVED
mdefine_line|#define HF_DP_SAVED&t;(1u&lt;&lt;3)
DECL|macro|HF_PAR_ERR
mdefine_line|#define HF_PAR_ERR&t;(1u&lt;&lt;4)
DECL|macro|HF_DATA_ST
mdefine_line|#define HF_DATA_ST&t;(1u&lt;&lt;5)
DECL|macro|HF_PM_TO_C
mdefine_line|#define HF_PM_TO_C&t;(1u&lt;&lt;6)
multiline_comment|/*&n;**&t;First four bytes (script)&n;*/
DECL|macro|xerr_st
mdefine_line|#define  xerr_st       header.scr_st[0]
DECL|macro|sync_st
mdefine_line|#define  sync_st       header.scr_st[1]
DECL|macro|nego_st
mdefine_line|#define  nego_st       header.scr_st[2]
DECL|macro|wide_st
mdefine_line|#define  wide_st       header.scr_st[3]
multiline_comment|/*&n;**&t;First four bytes (host)&n;*/
DECL|macro|xerr_status
mdefine_line|#define  xerr_status   phys.xerr_st
DECL|macro|nego_status
mdefine_line|#define  nego_status   phys.nego_st
multiline_comment|/*==========================================================&n;**&n;**      Declaration of structs:     Data structure block&n;**&n;**==========================================================&n;**&n;**&t;During execution of a ccb by the script processor,&n;**&t;the DSA (data structure address) register points&n;**&t;to this substructure of the ccb.&n;**&t;This substructure contains the header with&n;**&t;the script-processor-changable data and&n;**&t;data blocks for the indirect move commands.&n;**&n;**----------------------------------------------------------&n;*/
DECL|struct|dsb
r_struct
id|dsb
(brace
multiline_comment|/*&n;&t;**&t;Header.&n;&t;*/
DECL|member|header
r_struct
id|head
id|header
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Table data for Script&n;&t;*/
DECL|member|select
r_struct
id|scr_tblsel
id|select
suffix:semicolon
DECL|member|smsg
r_struct
id|scr_tblmove
id|smsg
suffix:semicolon
DECL|member|cmd
r_struct
id|scr_tblmove
id|cmd
suffix:semicolon
DECL|member|sense
r_struct
id|scr_tblmove
id|sense
suffix:semicolon
DECL|member|data
r_struct
id|scr_tblmove
id|data
(braket
id|MAX_SCATTER
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Phase mismatch contexts.&n;&t;**&t;We need two to handle correctly the&n;&t;**&t;SAVED DATA POINTER.&n;&t;*/
DECL|member|pm0
r_struct
id|pm_ctx
id|pm0
suffix:semicolon
DECL|member|pm1
r_struct
id|pm_ctx
id|pm1
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
multiline_comment|/*&n;&t;**&t;Disconnection counter&n;&t;*/
DECL|member|num_disc
id|u_int32
id|num_disc
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/*========================================================================&n;**&n;**      Declaration of structs:     Command control block.&n;**&n;**========================================================================&n;*/
DECL|struct|ccb
r_struct
id|ccb
(brace
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;This is the data structure which is pointed by the DSA &n;&t;**&t;register when it is executed by the script processor.&n;&t;**&t;It must be the first entry.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|phys
r_struct
id|dsb
id|phys
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;The general SCSI driver provides a&n;&t;**&t;pointer to a control block.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|cmd
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
multiline_comment|/* SCSI command &t;&t;*/
DECL|member|tlimit
id|u_long
id|tlimit
suffix:semicolon
multiline_comment|/* Deadline for this job&t;*/
DECL|member|data_len
r_int
id|data_len
suffix:semicolon
multiline_comment|/* Total data length&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Message areas.&n;&t;**&t;We prepare a message to be sent after selection.&n;&t;**&t;We may use a second one if the command is rescheduled &n;&t;**&t;due to CHECK_CONDITION or QUEUE FULL status.&n;&t;**      Contents are IDENTIFY and SIMPLE_TAG.&n;&t;**&t;While negotiating sync or wide transfer,&n;&t;**&t;a SDTR or WDTR message is appended.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|scsi_smsg
id|u_char
id|scsi_smsg
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|scsi_smsg2
id|u_char
id|scsi_smsg2
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Other fields.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|p_ccb
id|u_long
id|p_ccb
suffix:semicolon
multiline_comment|/* BUS address of this CCB&t;*/
DECL|member|sensecmd
id|u_char
id|sensecmd
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* Sense command&t;&t;*/
DECL|member|tag
id|u_char
id|tag
suffix:semicolon
multiline_comment|/* Tag for this transfer&t;*/
multiline_comment|/*  255 means no tag&t;&t;*/
DECL|member|target
id|u_char
id|target
suffix:semicolon
DECL|member|lun
id|u_char
id|lun
suffix:semicolon
DECL|member|queued
id|u_char
id|queued
suffix:semicolon
DECL|member|auto_sense
id|u_char
id|auto_sense
suffix:semicolon
DECL|member|link_ccb
id|ccb_p
id|link_ccb
suffix:semicolon
multiline_comment|/* Host adapter CCB chain&t;*/
DECL|member|link_ccbh
id|ccb_p
id|link_ccbh
suffix:semicolon
multiline_comment|/* Host adapter CCB hash chain&t;*/
DECL|member|link_ccbq
id|XPT_QUEHEAD
id|link_ccbq
suffix:semicolon
multiline_comment|/* Link to unit CCB queue&t;*/
DECL|member|startp
id|u_int32
id|startp
suffix:semicolon
multiline_comment|/* Initial data pointer&t;&t;*/
)brace
suffix:semicolon
DECL|macro|CCB_PHYS
mdefine_line|#define CCB_PHYS(cp,lbl)&t;(cp-&gt;p_ccb + offsetof(struct ccb, lbl))
multiline_comment|/*========================================================================&n;**&n;**      Declaration of structs:     NCR device descriptor&n;**&n;**========================================================================&n;*/
DECL|struct|ncb
r_struct
id|ncb
(brace
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Idle task and invalid task actions and their bus&n;&t;**&t;addresses.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|idletask
r_struct
id|action
id|idletask
suffix:semicolon
DECL|member|notask
r_struct
id|action
id|notask
suffix:semicolon
DECL|member|bad_i_t_l
r_struct
id|action
id|bad_i_t_l
suffix:semicolon
DECL|member|bad_i_t_l_q
r_struct
id|action
id|bad_i_t_l_q
suffix:semicolon
DECL|member|p_idletask
id|u_long
id|p_idletask
suffix:semicolon
DECL|member|p_notask
id|u_long
id|p_notask
suffix:semicolon
DECL|member|p_bad_i_t_l
id|u_long
id|p_bad_i_t_l
suffix:semicolon
DECL|member|p_bad_i_t_l_q
id|u_long
id|p_bad_i_t_l_q
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Dummy lun table to protect us against target returning bad  &n;&t;**&t;lun number on reselection.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|badluntbl
id|u_int32
op_star
id|badluntbl
suffix:semicolon
multiline_comment|/* Table physical address&t;*/
DECL|member|resel_badlun
id|u_int32
id|resel_badlun
suffix:semicolon
multiline_comment|/* SCRIPT handler BUS address&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Bit 32-63 of the on-chip RAM bus address in LE format.&n;&t;**&t;The START_RAM64 script loads the MMRS and MMWS from this &n;&t;**&t;field.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|scr_ram_seg
id|u_int32
id|scr_ram_seg
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;CCBs management queues.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|waiting_list
id|Scsi_Cmnd
op_star
id|waiting_list
suffix:semicolon
multiline_comment|/* Commands waiting for a CCB&t;*/
multiline_comment|/*  when lcb is not allocated.&t;*/
DECL|member|done_list
id|Scsi_Cmnd
op_star
id|done_list
suffix:semicolon
multiline_comment|/* Commands waiting for done()  */
multiline_comment|/* callback to be invoked.      */
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,93)
DECL|member|smp_lock
id|spinlock_t
id|smp_lock
suffix:semicolon
multiline_comment|/* Lock for SMP threading       */
macro_line|#endif
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Chip and controller indentification.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|unit
r_int
id|unit
suffix:semicolon
multiline_comment|/* Unit number&t;&t;&t;*/
DECL|member|chip_name
r_char
id|chip_name
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Chip name&t;&t;&t;*/
DECL|member|inst_name
r_char
id|inst_name
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* ncb instance name&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Initial value of some IO register bits.&n;&t;**&t;These values are assumed to have been set by BIOS, and may &n;&t;**&t;be used for probing adapter implementation differences.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|sv_scntl0
DECL|member|sv_scntl3
DECL|member|sv_dmode
DECL|member|sv_dcntl
DECL|member|sv_ctest3
DECL|member|sv_ctest4
id|u_char
id|sv_scntl0
comma
id|sv_scntl3
comma
id|sv_dmode
comma
id|sv_dcntl
comma
id|sv_ctest3
comma
id|sv_ctest4
comma
DECL|member|sv_ctest5
DECL|member|sv_gpcntl
DECL|member|sv_stest2
DECL|member|sv_stest4
id|sv_ctest5
comma
id|sv_gpcntl
comma
id|sv_stest2
comma
id|sv_stest4
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Actual initial value of IO register bits used by the &n;&t;**&t;driver. They are loaded at initialisation according to  &n;&t;**&t;features that are to be enabled.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|rv_scntl0
DECL|member|rv_scntl3
DECL|member|rv_dmode
DECL|member|rv_dcntl
DECL|member|rv_ctest3
DECL|member|rv_ctest4
id|u_char
id|rv_scntl0
comma
id|rv_scntl3
comma
id|rv_dmode
comma
id|rv_dcntl
comma
id|rv_ctest3
comma
id|rv_ctest4
comma
DECL|member|rv_ctest5
DECL|member|rv_stest2
DECL|member|rv_ccntl0
DECL|member|rv_ccntl1
id|rv_ctest5
comma
id|rv_stest2
comma
id|rv_ccntl0
comma
id|rv_ccntl1
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Target data.&n;&t;**&t;Target control block bus address array used by the SCRIPT &n;&t;**&t;on reselection.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|target
r_struct
id|tcb
id|target
(braket
id|MAX_TARGET
)braket
suffix:semicolon
DECL|member|targtbl
id|u_int32
op_star
id|targtbl
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Virtual and physical bus addresses of the chip.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|base_va
id|u_long
id|base_va
suffix:semicolon
multiline_comment|/* MMIO base virtual address&t;*/
DECL|member|base_ba
id|u_long
id|base_ba
suffix:semicolon
multiline_comment|/* MMIO base bus address&t;*/
DECL|member|base_io
id|u_long
id|base_io
suffix:semicolon
multiline_comment|/* IO space base address&t;*/
DECL|member|base_ws
id|u_long
id|base_ws
suffix:semicolon
multiline_comment|/* (MM)IO window size&t;&t;*/
DECL|member|base2_ba
id|u_long
id|base2_ba
suffix:semicolon
multiline_comment|/* On-chip RAM bus address.&t;*/
DECL|member|irq
id|u_int
id|irq
suffix:semicolon
multiline_comment|/* IRQ number&t;&t;&t;*/
r_volatile
multiline_comment|/* Pointer to volatile for &t;*/
DECL|member|reg
r_struct
id|ncr_reg
op_star
id|reg
suffix:semicolon
multiline_comment|/*  memory mapped IO.&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;SCRIPTS virtual and physical bus addresses.&n;&t;**&t;&squot;script&squot;  is loaded in the on-chip RAM if present.&n;&t;**&t;&squot;scripth&squot; stays in main memory for all chips except the &n;&t;**&t;53C896 that provides 8K on-chip RAM.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|script0
r_struct
id|script
op_star
id|script0
suffix:semicolon
multiline_comment|/* Copies of script and scripth&t;*/
DECL|member|scripth0
r_struct
id|scripth
op_star
id|scripth0
suffix:semicolon
multiline_comment|/*  relocated for this ncb.&t;*/
DECL|member|p_script
id|u_long
id|p_script
suffix:semicolon
multiline_comment|/* Actual script and scripth&t;*/
DECL|member|p_scripth
id|u_long
id|p_scripth
suffix:semicolon
multiline_comment|/*  bus addresses.&t;&t;*/
DECL|member|p_scripth0
id|u_long
id|p_scripth0
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;General controller parameters and configuration.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|device_id
id|u_short
id|device_id
suffix:semicolon
multiline_comment|/* PCI device id&t;&t;*/
DECL|member|revision_id
id|u_char
id|revision_id
suffix:semicolon
multiline_comment|/* PCI device revision id&t;*/
DECL|member|features
id|u_int
id|features
suffix:semicolon
multiline_comment|/* Chip features map&t;&t;*/
DECL|member|myaddr
id|u_char
id|myaddr
suffix:semicolon
multiline_comment|/* SCSI id of the adapter&t;*/
DECL|member|maxburst
id|u_char
id|maxburst
suffix:semicolon
multiline_comment|/* log base 2 of dwords burst&t;*/
DECL|member|maxwide
id|u_char
id|maxwide
suffix:semicolon
multiline_comment|/* Maximum transfer width&t;*/
DECL|member|minsync
id|u_char
id|minsync
suffix:semicolon
multiline_comment|/* Minimum sync period factor&t;*/
DECL|member|maxsync
id|u_char
id|maxsync
suffix:semicolon
multiline_comment|/* Maximum sync period factor&t;*/
DECL|member|maxoffs
id|u_char
id|maxoffs
suffix:semicolon
multiline_comment|/* Max scsi offset&t;&t;*/
DECL|member|multiplier
id|u_char
id|multiplier
suffix:semicolon
multiline_comment|/* Clock multiplier (1,2,4)&t;*/
DECL|member|clock_divn
id|u_char
id|clock_divn
suffix:semicolon
multiline_comment|/* Number of clock divisors&t;*/
DECL|member|clock_khz
id|u_long
id|clock_khz
suffix:semicolon
multiline_comment|/* SCSI clock frequency in KHz&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Start queue management.&n;&t;**&t;It is filled up by the host processor and accessed by the &n;&t;**&t;SCRIPTS processor in order to start SCSI commands.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|squeue
id|u_int32
op_star
id|squeue
suffix:semicolon
multiline_comment|/* Start queue&t;&t;&t;*/
DECL|member|squeueput
id|u_short
id|squeueput
suffix:semicolon
multiline_comment|/* Next free slot of the queue&t;*/
DECL|member|actccbs
id|u_short
id|actccbs
suffix:semicolon
multiline_comment|/* Number of allocated CCBs&t;*/
DECL|member|queuedepth
id|u_short
id|queuedepth
suffix:semicolon
multiline_comment|/* Start queue depth&t;&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Command completion queue.&n;&t;**&t;It is the same size as the start queue to avoid overflow.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|dqueueget
id|u_short
id|dqueueget
suffix:semicolon
multiline_comment|/* Next position to scan&t;*/
DECL|member|dqueue
id|u_int32
op_star
id|dqueue
suffix:semicolon
multiline_comment|/* Completion (done) queue&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Timeout handler.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* Timer handler link header&t;*/
DECL|member|lasttime
id|u_long
id|lasttime
suffix:semicolon
DECL|member|settle_time
id|u_long
id|settle_time
suffix:semicolon
multiline_comment|/* Resetting the SCSI BUS&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Debugging and profiling.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|regdump
r_struct
id|ncr_reg
id|regdump
suffix:semicolon
multiline_comment|/* Register dump&t;&t;*/
DECL|member|regtime
id|u_long
id|regtime
suffix:semicolon
multiline_comment|/* Time it has been done&t;*/
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
DECL|member|profile
r_struct
id|profile
id|profile
suffix:semicolon
multiline_comment|/* Profiling data&t;&t;*/
macro_line|#endif
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Miscellaneous buffers accessed by the scripts-processor.&n;&t;**&t;They shall be DWORD aligned, because they may be read or &n;&t;**&t;written with a script command.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|msgout
id|u_char
id|msgout
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Buffer for MESSAGE OUT &t;*/
DECL|member|msgin
id|u_char
id|msgin
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Buffer for MESSAGE IN&t;*/
DECL|member|lastmsg
id|u_int32
id|lastmsg
suffix:semicolon
multiline_comment|/* Last SCSI message sent&t;*/
DECL|member|scratch
id|u_char
id|scratch
suffix:semicolon
multiline_comment|/* Scratch for SCSI receive&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Miscellaneous configuration and status parameters.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|scsi_mode
id|u_char
id|scsi_mode
suffix:semicolon
multiline_comment|/* Current SCSI BUS mode&t;*/
DECL|member|order
id|u_char
id|order
suffix:semicolon
multiline_comment|/* Tag order to use&t;&t;*/
DECL|member|verbose
id|u_char
id|verbose
suffix:semicolon
multiline_comment|/* Verbosity for this controller*/
DECL|member|ncr_cache
id|u_int32
id|ncr_cache
suffix:semicolon
multiline_comment|/* Used for cache test at init.&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;CCB lists and queue.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|ccbh
id|ccb_p
id|ccbh
(braket
id|CCB_HASH_SIZE
)braket
suffix:semicolon
multiline_comment|/* CCB hashed by DSA value&t;*/
DECL|member|ccbc
r_struct
id|ccb
op_star
id|ccbc
suffix:semicolon
multiline_comment|/* CCB chain&t;&t;&t;*/
DECL|member|free_ccbq
id|XPT_QUEHEAD
id|free_ccbq
suffix:semicolon
multiline_comment|/* Queue of available CCBs&t;*/
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;We need the LCB in order to handle disconnections and &n;&t;**&t;to count active CCBs for task management. So, we use &n;&t;**&t;a unique CCB for LUNs we donnot have the LCB yet.&n;&t;**&t;This queue normally should have at most 1 element.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|b0_ccbq
id|XPT_QUEHEAD
id|b0_ccbq
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;We use a different scatter function for 896 rev 1.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|scatter
r_int
(paren
op_star
id|scatter
)paren
(paren
id|ccb_p
comma
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------&n;&t;**&t;Fields that should be removed or changed.&n;&t;**----------------------------------------------------------------&n;&t;*/
DECL|member|user
r_struct
id|usrcmd
id|user
suffix:semicolon
multiline_comment|/* Command from user&t;&t;*/
DECL|member|release_stage
id|u_char
id|release_stage
suffix:semicolon
multiline_comment|/* Synchronisation stage on release  */
)brace
suffix:semicolon
DECL|macro|NCB_SCRIPT_PHYS
mdefine_line|#define NCB_SCRIPT_PHYS(np,lbl)&t; (np-&gt;p_script  + offsetof (struct script, lbl))
DECL|macro|NCB_SCRIPTH_PHYS
mdefine_line|#define NCB_SCRIPTH_PHYS(np,lbl) (np-&gt;p_scripth + offsetof (struct scripth,lbl))
DECL|macro|NCB_SCRIPTH0_PHYS
mdefine_line|#define NCB_SCRIPTH0_PHYS(np,lbl) (np-&gt;p_scripth0+offsetof (struct scripth,lbl))
multiline_comment|/*==========================================================&n;**&n;**&n;**      Script for NCR-Processor.&n;**&n;**&t;Use ncr_script_fill() to create the variable parts.&n;**&t;Use ncr_script_copy_and_bind() to make a copy and&n;**&t;bind to physical addresses.&n;**&n;**&n;**==========================================================&n;**&n;**&t;We have to know the offsets of all labels before&n;**&t;we reach them (for forward jumps).&n;**&t;Therefore we declare a struct here.&n;**&t;If you make changes inside the script,&n;**&t;DONT FORGET TO CHANGE THE LENGTHS HERE!&n;**&n;**----------------------------------------------------------&n;*/
multiline_comment|/*&n;**&t;Script fragments which are loaded into the on-chip RAM &n;**&t;of 825A, 875, 876, 895 and 896 chips.&n;*/
DECL|struct|script
r_struct
id|script
(brace
DECL|member|start
id|ncrcmd
id|start
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|getjob_begin
id|ncrcmd
id|getjob_begin
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|getjob_end
id|ncrcmd
id|getjob_end
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|select
id|ncrcmd
id|select
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|wf_sel_done
id|ncrcmd
id|wf_sel_done
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|send_ident
id|ncrcmd
id|send_ident
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|select2
id|ncrcmd
id|select2
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|command
id|ncrcmd
id|command
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|dispatch
id|ncrcmd
id|dispatch
(braket
l_int|26
)braket
suffix:semicolon
DECL|member|sel_no_cmd
id|ncrcmd
id|sel_no_cmd
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|init
id|ncrcmd
id|init
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|clrack
id|ncrcmd
id|clrack
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|databreak
id|ncrcmd
id|databreak
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
DECL|member|dataphase
id|ncrcmd
id|dataphase
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#else
DECL|member|dataphase
id|ncrcmd
id|dataphase
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#endif
DECL|member|status
id|ncrcmd
id|status
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|msg_in
id|ncrcmd
id|msg_in
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|msg_in2
id|ncrcmd
id|msg_in2
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|msg_bad
id|ncrcmd
id|msg_bad
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|complete
id|ncrcmd
id|complete
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|complete2
id|ncrcmd
id|complete2
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|done
id|ncrcmd
id|done
(braket
l_int|14
)braket
suffix:semicolon
DECL|member|done_end
id|ncrcmd
id|done_end
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|save_dp
id|ncrcmd
id|save_dp
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|restore_dp
id|ncrcmd
id|restore_dp
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
DECL|member|disconnect
id|ncrcmd
id|disconnect
(braket
l_int|32
)braket
suffix:semicolon
macro_line|#else
DECL|member|disconnect
id|ncrcmd
id|disconnect
(braket
l_int|20
)braket
suffix:semicolon
macro_line|#endif
DECL|member|idle
id|ncrcmd
id|idle
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|ungetjob
id|ncrcmd
id|ungetjob
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|reselect
id|ncrcmd
id|reselect
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|reselected
id|ncrcmd
id|reselected
(braket
l_int|44
)braket
suffix:semicolon
DECL|member|resel_tag
id|ncrcmd
id|resel_tag
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|resel_go
id|ncrcmd
id|resel_go
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|resel_notag
id|ncrcmd
id|resel_notag
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|resel_dsa
id|ncrcmd
id|resel_dsa
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|data_in
id|ncrcmd
id|data_in
(braket
id|MAX_SCATTERL
op_star
id|SCR_SG_SIZE
)braket
suffix:semicolon
DECL|member|data_in2
id|ncrcmd
id|data_in2
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|data_out
id|ncrcmd
id|data_out
(braket
id|MAX_SCATTERL
op_star
id|SCR_SG_SIZE
)braket
suffix:semicolon
DECL|member|data_out2
id|ncrcmd
id|data_out2
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|pm0_data
id|ncrcmd
id|pm0_data
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|pm1_data
id|ncrcmd
id|pm1_data
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Data area */
DECL|member|saved_dsa
id|ncrcmd
id|saved_dsa
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|done_pos
id|ncrcmd
id|done_pos
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|startpos
id|ncrcmd
id|startpos
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|targtbl
id|ncrcmd
id|targtbl
(braket
l_int|1
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;Script fragments which stay in main memory for all chips &n;**&t;except for the 896 that support 8K on-chip RAM.&n;*/
DECL|struct|scripth
r_struct
id|scripth
(brace
DECL|member|start64
id|ncrcmd
id|start64
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|select_no_atn
id|ncrcmd
id|select_no_atn
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|wf_sel_done_no_atn
id|ncrcmd
id|wf_sel_done_no_atn
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|cancel
id|ncrcmd
id|cancel
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_reject
id|ncrcmd
id|msg_reject
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|msg_ign_residue
id|ncrcmd
id|msg_ign_residue
(braket
l_int|24
)braket
suffix:semicolon
DECL|member|msg_extended
id|ncrcmd
id|msg_extended
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|msg_ext_2
id|ncrcmd
id|msg_ext_2
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|msg_wdtr
id|ncrcmd
id|msg_wdtr
(braket
l_int|14
)braket
suffix:semicolon
DECL|member|send_wdtr
id|ncrcmd
id|send_wdtr
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_ext_3
id|ncrcmd
id|msg_ext_3
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|msg_sdtr
id|ncrcmd
id|msg_sdtr
(braket
l_int|14
)braket
suffix:semicolon
DECL|member|send_sdtr
id|ncrcmd
id|send_sdtr
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|nego_bad_phase
id|ncrcmd
id|nego_bad_phase
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_out_abort
id|ncrcmd
id|msg_out_abort
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|msg_out
id|ncrcmd
id|msg_out
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|msg_out_done
id|ncrcmd
id|msg_out_done
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|no_data
id|ncrcmd
id|no_data
(braket
l_int|16
)braket
suffix:semicolon
macro_line|#if&t;MAX_SCATTERH != 0
DECL|member|hdata_in
id|ncrcmd
id|hdata_in
(braket
id|MAX_SCATTERH
op_star
id|SCR_SG_SIZE
)braket
suffix:semicolon
DECL|member|hdata_in2
id|ncrcmd
id|hdata_in2
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|hdata_out
id|ncrcmd
id|hdata_out
(braket
id|MAX_SCATTERH
op_star
id|SCR_SG_SIZE
)braket
suffix:semicolon
DECL|member|hdata_out2
id|ncrcmd
id|hdata_out2
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#endif
DECL|member|abort_resel
id|ncrcmd
id|abort_resel
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|resend_ident
id|ncrcmd
id|resend_ident
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|ident_break
id|ncrcmd
id|ident_break
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|ident_break_atn
id|ncrcmd
id|ident_break_atn
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|sdata_in
id|ncrcmd
id|sdata_in
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|data_io
id|ncrcmd
id|data_io
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|data_io_com
id|ncrcmd
id|data_io_com
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|data_io_out
id|ncrcmd
id|data_io_out
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|bad_identify
id|ncrcmd
id|bad_identify
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|bad_i_t_l
id|ncrcmd
id|bad_i_t_l
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|bad_i_t_l_q
id|ncrcmd
id|bad_i_t_l_q
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|bad_status
id|ncrcmd
id|bad_status
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|tweak_pmj
id|ncrcmd
id|tweak_pmj
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|pm_handle
id|ncrcmd
id|pm_handle
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|pm_handle1
id|ncrcmd
id|pm_handle1
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|pm_save
id|ncrcmd
id|pm_save
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|pm0_save
id|ncrcmd
id|pm0_save
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|pm1_save
id|ncrcmd
id|pm1_save
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/* Data area */
DECL|member|pm0_data_addr
id|ncrcmd
id|pm0_data_addr
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|pm1_data_addr
id|ncrcmd
id|pm1_data_addr
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* End of data area */
DECL|member|start_ram
id|ncrcmd
id|start_ram
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|script0_ba
id|ncrcmd
id|script0_ba
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|start_ram64
id|ncrcmd
id|start_ram64
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|script0_ba64
id|ncrcmd
id|script0_ba64
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|scripth0_ba64
id|ncrcmd
id|scripth0_ba64
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|ram_seg64
id|ncrcmd
id|ram_seg64
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|snooptest
id|ncrcmd
id|snooptest
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|snoopend
id|ncrcmd
id|snoopend
(braket
l_int|2
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&n;**      Function headers.&n;**&n;**&n;**==========================================================&n;*/
r_static
id|ccb_p
id|ncr_alloc_ccb
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_complete
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
r_static
r_void
id|ncr_exception
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_free_ccb
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
r_static
id|ccb_p
id|ncr_ccb_from_dsa
c_func
(paren
id|ncb_p
id|np
comma
id|u_long
id|dsa
)paren
suffix:semicolon
r_static
r_void
id|ncr_init_tcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
)paren
suffix:semicolon
r_static
id|lcb_p
id|ncr_alloc_lcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
suffix:semicolon
r_static
id|lcb_p
id|ncr_setup_lcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
comma
id|u_char
op_star
id|inq_data
)paren
suffix:semicolon
r_static
r_void
id|ncr_getclock
(paren
id|ncb_p
id|np
comma
r_int
id|mult
)paren
suffix:semicolon
r_static
r_void
id|ncr_selectclock
(paren
id|ncb_p
id|np
comma
id|u_char
id|scntl3
)paren
suffix:semicolon
r_static
id|ccb_p
id|ncr_get_ccb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
suffix:semicolon
r_static
r_void
id|ncr_init
(paren
id|ncb_p
id|np
comma
r_int
id|reset
comma
r_char
op_star
id|msg
comma
id|u_long
id|code
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_sbmc
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_par
(paren
id|ncb_p
id|np
comma
id|u_short
id|sist
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_ma
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_sir
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_sto
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_int_udc
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
id|u_long
id|ncr_lookup
(paren
r_char
op_star
id|id
)paren
suffix:semicolon
r_static
r_void
id|ncr_negotiate
(paren
r_struct
id|ncb
op_star
id|np
comma
r_struct
id|tcb
op_star
id|tp
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
r_static
r_void
id|ncb_profile
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|ncr_script_copy_and_bind
(paren
id|ncb_p
id|np
comma
id|ncrcmd
op_star
id|src
comma
id|ncrcmd
op_star
id|dst
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_void
id|ncr_script_fill
(paren
r_struct
id|script
op_star
id|scr
comma
r_struct
id|scripth
op_star
id|scripth
)paren
suffix:semicolon
r_static
r_int
id|ncr_scatter_896R1
(paren
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|ncr_scatter
(paren
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|ncr_getsync
(paren
id|ncb_p
id|np
comma
id|u_char
id|sfac
comma
id|u_char
op_star
id|fakp
comma
id|u_char
op_star
id|scntl3p
)paren
suffix:semicolon
r_static
r_void
id|ncr_setsync
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|scntl3
comma
id|u_char
id|sxfer
)paren
suffix:semicolon
r_static
r_void
id|ncr_setup_tags
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
suffix:semicolon
r_static
r_void
id|ncr_setwide
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|wide
comma
id|u_char
id|ack
)paren
suffix:semicolon
r_static
r_int
id|ncr_show_msg
(paren
id|u_char
op_star
id|msg
)paren
suffix:semicolon
r_static
r_int
id|ncr_snooptest
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_timeout
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_wakeup
(paren
id|ncb_p
id|np
comma
id|u_long
id|code
)paren
suffix:semicolon
r_static
r_int
id|ncr_wakeup_done
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_start_next_ccb
(paren
id|ncb_p
id|np
comma
id|lcb_p
id|lp
comma
r_int
id|maxn
)paren
suffix:semicolon
r_static
r_void
id|ncr_put_start_queue
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
r_static
r_void
id|ncr_soft_reset
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|ncr_start_reset
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_int
id|ncr_reset_scsi_bus
(paren
id|ncb_p
id|np
comma
r_int
id|enab_int
comma
r_int
id|settle_delay
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_USER_COMMAND_SUPPORT
r_static
r_void
id|ncr_usercmd
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|ncr_attach
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|unit
comma
id|ncr_device
op_star
id|device
)paren
suffix:semicolon
r_static
r_void
id|ncr_free_resources
c_func
(paren
id|ncb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|insert_into_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
id|Scsi_Cmnd
op_star
id|retrieve_from_waiting_list
c_func
(paren
r_int
id|to_remove
comma
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|process_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|sts
)paren
suffix:semicolon
DECL|macro|remove_from_waiting_list
mdefine_line|#define remove_from_waiting_list(np, cmd) &bslash;&n;&t;&t;retrieve_from_waiting_list(1, (np), (cmd))
DECL|macro|requeue_waiting_list
mdefine_line|#define requeue_waiting_list(np) process_waiting_list((np), DID_OK)
DECL|macro|reset_waiting_list
mdefine_line|#define reset_waiting_list(np) process_waiting_list((np), DID_RESET)
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_static
r_void
id|ncr_get_nvram
(paren
id|ncr_device
op_star
id|devp
comma
id|ncr_nvram
op_star
id|nvp
)paren
suffix:semicolon
r_static
r_int
id|ncr_get_Symbios_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|Symbios_nvram
op_star
id|nvram
)paren
suffix:semicolon
r_static
r_int
id|ncr_get_Tekram_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|Tekram_nvram
op_star
id|nvram
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&n;**      Global static data.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_name
r_static
r_inline
r_char
op_star
id|ncr_name
(paren
id|ncb_p
id|np
)paren
(brace
r_return
id|np-&gt;inst_name
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      Scripts for NCR-Processor.&n;**&n;**      Use ncr_script_bind for binding to physical addresses.&n;**&n;**&n;**==========================================================&n;**&n;**&t;NADDR generates a reference to a field of the controller data.&n;**&t;PADDR generates a reference to another part of the script.&n;**&t;RADDR generates a reference to a script processor register.&n;**&t;FADDR generates a reference to a script processor register&n;**&t;&t;with offset.&n;**&n;**----------------------------------------------------------&n;*/
DECL|macro|RELOC_SOFTC
mdefine_line|#define&t;RELOC_SOFTC&t;0x40000000
DECL|macro|RELOC_LABEL
mdefine_line|#define&t;RELOC_LABEL&t;0x50000000
DECL|macro|RELOC_REGISTER
mdefine_line|#define&t;RELOC_REGISTER&t;0x60000000
macro_line|#if 0
mdefine_line|#define&t;RELOC_KVAR&t;0x70000000
macro_line|#endif
DECL|macro|RELOC_LABELH
mdefine_line|#define&t;RELOC_LABELH&t;0x80000000
DECL|macro|RELOC_MASK
mdefine_line|#define&t;RELOC_MASK&t;0xf0000000
DECL|macro|NADDR
mdefine_line|#define&t;NADDR(label)&t;(RELOC_SOFTC | offsetof(struct ncb, label))
DECL|macro|PADDR
mdefine_line|#define PADDR(label)    (RELOC_LABEL | offsetof(struct script, label))
DECL|macro|PADDRH
mdefine_line|#define PADDRH(label)   (RELOC_LABELH | offsetof(struct scripth, label))
DECL|macro|RADDR
mdefine_line|#define&t;RADDR(label)&t;(RELOC_REGISTER | REG(label))
DECL|macro|FADDR
mdefine_line|#define&t;FADDR(label,ofs)(RELOC_REGISTER | ((REG(label))+(ofs)))
DECL|macro|KVAR
mdefine_line|#define&t;KVAR(which)&t;(RELOC_KVAR | (which))
DECL|macro|SCR_DATA_ZERO
mdefine_line|#define SCR_DATA_ZERO&t;0xf00ff00f
macro_line|#ifdef&t;RELOC_KVAR
DECL|macro|SCRIPT_KVAR_JIFFIES
mdefine_line|#define&t;SCRIPT_KVAR_JIFFIES&t;(0)
DECL|macro|SCRIPT_KVAR_FIRST
mdefine_line|#define&t;SCRIPT_KVAR_FIRST&t;SCRIPT_KVAR_JIFFIES
DECL|macro|SCRIPT_KVAR_LAST
mdefine_line|#define&t;SCRIPT_KVAR_LAST&t;SCRIPT_KVAR_JIFFIES
multiline_comment|/*&n; * Kernel variables referenced in the scripts.&n; * THESE MUST ALL BE ALIGNED TO A 4-BYTE BOUNDARY.&n; */
DECL|variable|__initdata
r_static
r_void
op_star
id|script_kvars
(braket
)braket
id|__initdata
op_assign
(brace
(paren
r_void
op_star
)paren
op_amp
id|jiffies
)brace
suffix:semicolon
macro_line|#endif
DECL|variable|__initdata
r_static
r_struct
id|script
id|script0
id|__initdata
op_assign
(brace
multiline_comment|/*--------------------------&lt; START &gt;-----------------------*/
(brace
multiline_comment|/*&n;&t;**&t;This NOP will be patched with LED ON&n;&t;**&t;SCR_REG_REG (gpreg, SCR_AND, 0xfe)&n;&t;*/
id|SCR_NO_OP
comma
l_int|0
comma
multiline_comment|/*&n;&t;**      Clear SIGP.&n;&t;*/
id|SCR_FROM_REG
(paren
id|ctest2
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Start the next job.&n;&t;**&n;&t;**&t;@DSA&t; = start point for this job.&n;&t;**&t;SCRATCHA = address of this job in the start queue.&n;&t;**&n;&t;**&t;We will restore startpos with SCRATCHA if we fails the &n;&t;**&t;arbitration or if it is the idle job.&n;&t;**&n;&t;**&t;The below GETJOB_BEGIN to GETJOB_END section of SCRIPTS &n;&t;**&t;is a critical path. If it is partially executed, it then &n;&t;**&t;may happen that the job address is not yet in the DSA &n;&t;**&t;and the the next queue position points to the next JOB.&n;&t;*/
id|SCR_LOAD_ABS
(paren
id|scratcha
comma
l_int|4
)paren
comma
id|PADDR
(paren
id|startpos
)paren
comma
id|SCR_LOAD_ABS
(paren
id|dsa
comma
l_int|4
)paren
comma
id|PADDR
(paren
id|startpos
)paren
comma
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
l_int|4
comma
)brace
multiline_comment|/*-------------------------&lt; GETJOB_BEGIN &gt;------------------*/
comma
(brace
id|SCR_STORE_ABS
(paren
id|temp
comma
l_int|4
)paren
comma
id|PADDR
(paren
id|startpos
)paren
comma
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; GETJOB_END &gt;--------------------*/
comma
(brace
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
l_int|0
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; SELECT &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;DSA&t;contains the address of a scheduled&n;&t;**&t;&t;data structure.&n;&t;**&n;&t;**&t;SCRATCHA contains the address of the start queue  &n;&t;**&t;&t;entry which points to the next job.&n;&t;**&n;&t;**&t;Set Initiator mode.&n;&t;**&n;&t;**&t;(Target mode is left as an exercise for the reader)&n;&t;*/
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**      And try to select this target.&n;&t;*/
id|SCR_SEL_TBL_ATN
op_xor
m_offsetof
(paren
r_struct
id|dsb
comma
id|select
)paren
comma
id|PADDR
(paren
id|ungetjob
)paren
comma
multiline_comment|/*&n;&t;**&t;Now there are 4 possibilities:&n;&t;**&n;&t;**&t;(1) The ncr looses arbitration.&n;&t;**&t;This is ok, because it will try again,&n;&t;**&t;when the bus becomes idle.&n;&t;**&t;(But beware of the timeout function!)&n;&t;**&n;&t;**&t;(2) The ncr is reselected.&n;&t;**&t;Then the script processor takes the jump&n;&t;**&t;to the RESELECT label.&n;&t;**&n;&t;**&t;(3) The ncr wins arbitration.&n;&t;**&t;Then it will execute SCRIPTS instruction until &n;&t;**&t;the next instruction that checks SCSI phase.&n;&t;**&t;Then will stop and wait for selection to be &n;&t;**&t;complete or selection time-out to occur.&n;&t;**&n;&t;**&t;After having won arbitration, the ncr SCRIPTS  &n;&t;**&t;processor is able to execute instructions while &n;&t;**&t;the SCSI core is performing SCSI selection. But &n;&t;**&t;some script instruction that is not waiting for &n;&t;**&t;a valid phase (or selection timeout) to occur &n;&t;**&t;breaks the selection procedure, by probably &n;&t;**&t;affecting timing requirements.&n;&t;**&t;So we have to wait immediately for the next phase &n;&t;**&t;or the selection to complete or time-out.&n;&t;*/
)brace
multiline_comment|/*-------------------------&lt; WF_SEL_DONE &gt;----------------------*/
comma
(brace
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|SIR_SEL_ATN_NO_MSG_OUT
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_IDENT &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Selection complete.&n;&t;**&t;Send the IDENTIFY and SIMPLE_TAG messages&n;&t;**&t;(and the M_X_SYNC_REQ / M_X_WIDE_REQ message)&n;&t;*/
id|SCR_MOVE_TBL
op_xor
id|SCR_MSG_OUT
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|smsg
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SELECT2 &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**      load the savep (saved pointer) into&n;&t;**      the actual data pointer.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.savep
)paren
comma
multiline_comment|/*&n;&t;**      Initialize the status registers&n;&t;*/
id|SCR_LOAD_REL
(paren
id|scr0
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.status
)paren
comma
multiline_comment|/*&n;&t;**&t;Anticipate the COMMAND phase.&n;&t;**&t;This is the PHASE we expect at this point.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_COMMAND
)paren
)paren
comma
id|PADDR
(paren
id|sel_no_cmd
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; COMMAND &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;... and send the command&n;&t;*/
id|SCR_MOVE_TBL
op_xor
id|SCR_COMMAND
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|cmd
)paren
comma
)brace
multiline_comment|/*-----------------------&lt; DISPATCH &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;MSG_IN is the only phase that shall be &n;&t;**&t;entered at least once for each (re)selection.&n;&t;**&t;So we test it first.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|msg_in
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
id|PADDR
(paren
id|dataphase
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_DATA_IN
)paren
)paren
comma
id|PADDR
(paren
id|dataphase
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_STATUS
)paren
)paren
comma
id|PADDR
(paren
id|status
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_COMMAND
)paren
)paren
comma
id|PADDR
(paren
id|command
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDRH
(paren
id|msg_out
)paren
comma
multiline_comment|/*&n;&t;**      Discard one illegal phase byte, if required.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|XE_BAD_PHASE
)paren
comma
l_int|0
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|1
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|xerr_status
)paren
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|IF
(paren
id|SCR_ILG_OUT
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_ILG_OUT
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|IF
(paren
id|SCR_ILG_IN
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_ILG_IN
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*---------------------&lt; SEL_NO_CMD &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The target does not switch to command &n;&t;**&t;phase after IDENTIFY has been sent.&n;&t;**&n;&t;**&t;If it stays in MSG OUT phase send it &n;&t;**&t;the IDENTIFY again.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDRH
(paren
id|resend_ident
)paren
comma
multiline_comment|/*&n;&t;**&t;If target does not switch to MSG IN phase &n;&t;**&t;and we sent a negotiation, assert the &n;&t;**&t;failure immediately.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
id|SCR_FROM_REG
(paren
id|HS_REG
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|HS_NEGOTIATE
)paren
)paren
comma
id|SIR_NEGO_FAILED
comma
multiline_comment|/*&n;&t;**&t;Jump to dispatcher.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; INIT &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Wait for the SCSI RESET signal to be &n;&t;**&t;inactive before restarting operations, &n;&t;**&t;since the chip may hang on SEL_ATN &n;&t;**&t;if SCSI RESET is active.&n;&t;*/
id|SCR_FROM_REG
(paren
id|sstat0
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|IRST
comma
id|IRST
)paren
)paren
comma
op_minus
l_int|8
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; CLRACK &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Terminate possible pending message phase.&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATABREAK &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Jump to dispatcher.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATAPHASE &gt;------------------*/
comma
(brace
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_DATA_ST
)paren
comma
l_int|0
comma
macro_line|#endif
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; STATUS &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;get the status&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_STATUS
comma
id|NADDR
(paren
id|scratch
)paren
comma
multiline_comment|/*&n;&t;**&t;save status to scsi_status.&n;&t;**&t;mark as complete.&n;&t;*/
id|SCR_TO_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_COMPLETE
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IN &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Get the first byte of the message.&n;&t;**&n;&t;**&t;The script processor doesn&squot;t negate the&n;&t;**&t;ACK signal after this transfer.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|0
)braket
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IN2 &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Handle this message.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_COMPLETE
)paren
)paren
comma
id|PADDR
(paren
id|complete
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_DISCONNECT
)paren
)paren
comma
id|PADDR
(paren
id|disconnect
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_SAVE_DP
)paren
)paren
comma
id|PADDR
(paren
id|save_dp
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_RESTORE_DP
)paren
)paren
comma
id|PADDR
(paren
id|restore_dp
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_EXTENDED
)paren
)paren
comma
id|PADDRH
(paren
id|msg_extended
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_NOOP
)paren
)paren
comma
id|PADDR
(paren
id|clrack
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_REJECT
)paren
)paren
comma
id|PADDRH
(paren
id|msg_reject
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_IGN_RESIDUE
)paren
)paren
comma
id|PADDRH
(paren
id|msg_ign_residue
)paren
comma
multiline_comment|/*&n;&t;**&t;Rest of the messages left as&n;&t;**&t;an exercise ...&n;&t;**&n;&t;**&t;Unimplemented messages:&n;&t;**&t;fall through to MSG_BAD.&n;&t;*/
)brace
multiline_comment|/*-------------------------&lt; MSG_BAD &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;unimplemented message - reject it.&n;&t;*/
id|SCR_INT
comma
id|SIR_REJECT_TO_SEND
comma
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; COMPLETE &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Complete message.&n;&t;**&n;&t;**&t;Copy the data pointer to LASTP in header.&n;&t;*/
id|SCR_STORE_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.lastp
)paren
comma
multiline_comment|/*&n;&t;**&t;When we terminate the cycle by clearing ACK,&n;&t;**&t;the target may disconnect immediately.&n;&t;**&n;&t;**&t;We don&squot;t want to be told of an&n;&t;**&t;&quot;unexpected disconnect&quot;,&n;&t;**&t;so we disable this feature.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Terminate cycle ...&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;... and wait for the disconnect.&n;&t;*/
id|SCR_WAIT_DISC
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; COMPLETE2 &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Save host status to header.&n;&t;*/
id|SCR_STORE_REL
(paren
id|scr0
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.status
)paren
comma
multiline_comment|/*&n;&t;**&t;If command resulted in not GOOD status,&n;&t;**&t;call the C code if needed.&n;&t;*/
id|SCR_FROM_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|S_GOOD
)paren
)paren
comma
id|PADDRH
(paren
id|bad_status
)paren
comma
)brace
multiline_comment|/*------------------------&lt; DONE &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Copy the DSA to the DONE QUEUE and &n;&t;**&t;signal completion to the host.&n;&t;**&t;If we are interrupted between DONE &n;&t;**&t;and DONE_END, we must reset, otherwise &n;&t;**&t;the completed CCB will be lost.&n;&t;*/
id|SCR_STORE_ABS
(paren
id|dsa
comma
l_int|4
)paren
comma
id|PADDR
(paren
id|saved_dsa
)paren
comma
id|SCR_LOAD_ABS
(paren
id|dsa
comma
l_int|4
)paren
comma
id|PADDR
(paren
id|done_pos
)paren
comma
id|SCR_LOAD_ABS
(paren
id|scratcha
comma
l_int|4
)paren
comma
id|PADDR
c_func
(paren
id|saved_dsa
)paren
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;The instruction below reads the DONE QUEUE next &n;&t;**&t;free position from memory.&n;&t;**&t;In addition it ensures that all PCI posted writes  &n;&t;**&t;are flushed and so the DSA value of the done &n;&t;**&t;CCB is visible by the CPU before INTFLY is raised.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
l_int|4
comma
id|SCR_INT_FLY
comma
l_int|0
comma
id|SCR_STORE_ABS
(paren
id|temp
comma
l_int|4
)paren
comma
id|PADDR
(paren
id|done_pos
)paren
comma
)brace
multiline_comment|/*------------------------&lt; DONE_END &gt;-----------------*/
comma
(brace
id|SCR_JUMP
comma
id|PADDR
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SAVE_DP &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Clear ACK immediately.&n;&t;**&t;No need to delay it.&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Keep track we received a SAVE DP, so &n;&t;**&t;we will switch to the other PM context &n;&t;**&t;on the next PM since the DP may point &n;&t;**&t;to the current PM context.&n;&t;*/
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_DP_SAVED
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;SAVE_DP message:&n;&t;**&t;Copy the data pointer to SAVEP in header.&n;&t;*/
id|SCR_STORE_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.savep
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESTORE_DP &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;RESTORE_DP message:&n;&t;**&t;Copy SAVEP in header to actual data pointer.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.savep
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DISCONNECT &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;DISCONNECTing  ...&n;&t;**&n;&t;**&t;disable the &quot;unexpected disconnect&quot; feature,&n;&t;**&t;and remove the ACK signal.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Wait for the disconnect.&n;&t;*/
id|SCR_WAIT_DISC
comma
l_int|0
comma
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
multiline_comment|/*&n;&t;**&t;Count the disconnects.&n;&t;**&t;Disconnect without DATA PHASE having been &n;&t;**&t;entered are counted in bits 8..15.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.num_disc
)paren
comma
id|SCR_FROM_REG
(paren
id|HF_REG
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|HF_DATA_ST
comma
id|HF_DATA_ST
)paren
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|scratcha1
comma
id|SCR_ADD
comma
l_int|0x01
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|scratcha
comma
id|SCR_ADD
comma
l_int|0x01
)paren
comma
l_int|0
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.num_disc
)paren
comma
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Status is: DISCONNECTED.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_DISCONNECT
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Save host status to header.&n;&t;*/
id|SCR_STORE_REL
(paren
id|scr0
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.status
)paren
comma
multiline_comment|/*&n;&t;**&t;If QUIRK_AUTOSAVE is set,&n;&t;**&t;do an &quot;save pointer&quot; operation.&n;&t;*/
id|SCR_FROM_REG
(paren
id|QU_REG
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|QUIRK_AUTOSAVE
comma
id|QUIRK_AUTOSAVE
)paren
)paren
comma
id|PADDR
(paren
id|start
)paren
comma
multiline_comment|/*&n;&t;**&t;like SAVE_DP message:&n;&t;**&t;Remember we saved the data pointer.&n;&t;**&t;Copy data pointer to SAVEP in header.&n;&t;*/
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_DP_SAVED
)paren
comma
l_int|0
comma
id|SCR_STORE_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.savep
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; IDLE &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Nothing to do?&n;&t;**&t;Wait for reselect.&n;&t;**&t;This NOP will be patched with LED OFF&n;&t;**&t;SCR_REG_REG (gpreg, SCR_OR, 0x01)&n;&t;*/
id|SCR_NO_OP
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; UNGETJOB &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;We are not able to restart the SCRIPTS if we are &n;&t;**&t;interrupted and these instruction haven&squot;t been &n;&t;**&t;all executed. BTW, this is very unlikely to &n;&t;**&t;happen, but we check that from the C code.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|dsa
comma
l_int|0xff
)paren
comma
l_int|0
comma
id|SCR_STORE_ABS
(paren
id|scratcha
comma
l_int|4
)paren
comma
id|PADDR
(paren
id|startpos
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESELECT &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;make the host status invalid.&n;&t;*/
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Sleep waiting for a reselection.&n;&t;**&t;If SIGP is set, special treatment.&n;&t;**&n;&t;**&t;Zu allem bereit ..&n;&t;*/
id|SCR_WAIT_RESEL
comma
id|PADDR
c_func
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESELECTED &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;This NOP will be patched with LED ON&n;&t;**&t;SCR_REG_REG (gpreg, SCR_AND, 0xfe)&n;&t;*/
id|SCR_NO_OP
comma
l_int|0
comma
multiline_comment|/*&n;&t;**      load the target id into the sdid&n;&t;*/
id|SCR_REG_SFBR
(paren
id|ssid
comma
id|SCR_AND
comma
l_int|0x8F
)paren
comma
l_int|0
comma
id|SCR_TO_REG
(paren
id|sdid
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;load the target control block address&n;&t;*/
id|SCR_LOAD_ABS
(paren
id|dsa
comma
l_int|4
)paren
comma
id|PADDR
(paren
id|targtbl
)paren
comma
id|SCR_SFBR_REG
(paren
id|dsa
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|dsa
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|dsa
comma
id|SCR_AND
comma
l_int|0x3c
)paren
comma
l_int|0
comma
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Load the synchronous transfer registers.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|scntl3
comma
l_int|1
)paren
comma
m_offsetof
(paren
r_struct
id|tcb
comma
id|wval
)paren
comma
id|SCR_LOAD_REL
(paren
id|sxfer
comma
l_int|1
)paren
comma
m_offsetof
(paren
r_struct
id|tcb
comma
id|sval
)paren
comma
multiline_comment|/*&n;&t;**&t;If MESSAGE IN  phase as expected,&n;&t;**&t;read the data directly from the BUS DATA lines.&n;&t;**&t;This helps to support very old SCSI devices that &n;&t;**&t;may reselect without sending an IDENTIFY.&n;&t;*/
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|SIR_RESEL_NO_MSG_IN
comma
id|SCR_FROM_REG
(paren
id|sbdl
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;If message phase but not an IDENTIFY,&n;&t;**&t;get some help from the C code.&n;&t;**&t;Old SCSI device may behave so.&n;&t;*/
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|MASK
(paren
l_int|0x80
comma
l_int|0x80
)paren
)paren
comma
id|SIR_RESEL_NO_IDENTIFY
comma
multiline_comment|/*&n;&t;**&t;It is an IDENTIFY message,&n;&t;**&t;Load the LUN control block address.&n;&t;**&t;Avoid nasty address calculation if LUN #0.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|tcb
comma
id|b_luntbl
)paren
comma
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0x0
comma
l_int|0x3f
)paren
)paren
comma
l_int|24
comma
id|SCR_SFBR_REG
(paren
id|dsa
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|dsa
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|dsa
comma
id|SCR_AND
comma
l_int|0xfc
)paren
comma
l_int|0
comma
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Load the reselect task action for this LUN.&n;&t;**&t;Load the tasks DSA array for this LUN.&n;&t;**&t;Call the action.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|lcb
comma
id|resel_task
)paren
comma
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|lcb
comma
id|b_tasktbl
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_TAG &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Read IDENTIFY + SIMPLE + TAG using a single MOVE.&n;&t;**&t;Agressive optimization, is&squot;nt it?&n;&t;**&t;No need to test the SIMPLE TAG message, since the &n;&t;**&t;driver only supports conformant devices for tags. ;-)&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|3
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
)paren
comma
multiline_comment|/*&n;&t;**&t;Read the TAG from the SIDL.&n;&t;**&t;Still an aggressive optimization. ;-)&n;&t;**&t;Compute the CCB indirect jump address which &n;&t;**&t;is (#TAG*2 &amp; 0xfc) due to tag numbering using &n;&t;**&t;1,3,5..MAXTAGS*2+1 actual values.&n;&t;*/
id|SCR_REG_SFBR
(paren
id|sidl
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Retrieve the DSA of this task.&n;&t;**&t;JUMP indirectly to the restart point of the CCB.&n;&t;*/
id|SCR_SFBR_REG
(paren
id|dsa
comma
id|SCR_AND
comma
l_int|0xfc
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_GO &gt;-------------------*/
comma
(brace
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
l_int|0
comma
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.go.restart
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_NOTAG &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;No tag expected.&n;&t;**&t;Read an throw away the IDENTIFY.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
)paren
comma
multiline_comment|/*&n;&t;**&t;JUMP indirectly to the restart point of the CCB.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|resel_go
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_DSA &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Ack the IDENTIFY or TAG previously received.&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**      load the savep (saved pointer) into&n;&t;**      the actual data pointer.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.savep
)paren
comma
multiline_comment|/*&n;&t;**      Initialize the status registers&n;&t;*/
id|SCR_LOAD_REL
(paren
id|scr0
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.status
)paren
comma
multiline_comment|/*&n;&t;**&t;Jump to dispatcher.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IN &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;**&t;Because the size depends on the&n;**&t;#define MAX_SCATTERL parameter,&n;**&t;it is filled in at runtime.&n;**&n;**  ##===========&lt; i=0; i&lt;MAX_SCATTERL &gt;=========&n;**  ||&t;SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)),&n;**  ||&t;&t;PADDR (databreak),&n;**  ||&t;SCR_MOVE_TBL ^ SCR_DATA_IN,&n;**  ||&t;&t;offsetof (struct dsb, data[ i]),&n;**  ##==========================================&n;**&n;**---------------------------------------------------------&n;*/
l_int|0
)brace
multiline_comment|/*-------------------------&lt; DATA_IN2 &gt;-------------------*/
comma
(brace
id|SCR_CALL
comma
id|PADDR
(paren
id|databreak
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|no_data
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_OUT &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;**&t;Because the size depends on the&n;**&t;#define MAX_SCATTERL parameter,&n;**&t;it is filled in at runtime.&n;**&n;**  ##===========&lt; i=0; i&lt;MAX_SCATTERL &gt;=========&n;**  ||&t;SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT)),&n;**  ||&t;&t;PADDR (databreak),&n;**  ||&t;SCR_MOVE_TBL ^ SCR_DATA_OUT,&n;**  ||&t;&t;offsetof (struct dsb, data[ i]),&n;**  ##==========================================&n;**&n;**---------------------------------------------------------&n;*/
l_int|0
)brace
multiline_comment|/*-------------------------&lt; DATA_OUT2 &gt;-------------------*/
comma
(brace
id|SCR_CALL
comma
id|PADDR
(paren
id|databreak
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|no_data
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM0_DATA &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Keep track we are executing the PM0 DATA &n;&t;**&t;mini-script.&n;&t;*/
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_IN_PM0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;MOVE the data according to the actual &n;&t;**&t;DATA direction.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
comma
l_int|16
comma
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm0.sg
)paren
comma
id|SCR_JUMPR
comma
l_int|8
comma
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_OUT
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm0.sg
)paren
comma
multiline_comment|/*&n;&t;**&t;Clear the flag that told we were in &n;&t;**&t;the PM0 DATA mini-script.&n;&t;*/
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_AND
comma
(paren
op_complement
id|HF_IN_PM0
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Return to the previous DATA script which &n;&t;**&t;is guaranteed by design (if no bug) to be &n;&t;**&t;the main DATA script for this transfer.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm0.ret
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; PM1_DATA &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Keep track we are executing the PM1 DATA &n;&t;**&t;mini-script.&n;&t;*/
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_IN_PM1
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;MOVE the data according to the actual &n;&t;**&t;DATA direction.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
comma
l_int|16
comma
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm1.sg
)paren
comma
id|SCR_JUMPR
comma
l_int|8
comma
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_OUT
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm1.sg
)paren
comma
multiline_comment|/*&n;&t;**&t;Clear the flag that told we were in &n;&t;**&t;the PM1 DATA mini-script.&n;&t;*/
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_AND
comma
(paren
op_complement
id|HF_IN_PM1
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Return to the previous DATA script which &n;&t;**&t;is guaranteed by design (if no bug) to be &n;&t;**&t;the main DATA script for this transfer.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm1.ret
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; SAVED_DSA &gt;-------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; DONE_POS &gt;--------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; STARTPOS &gt;--------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; TARGTBL &gt;---------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*--------------------------------------------------------*/
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_struct
id|scripth
id|scripth0
id|__initdata
op_assign
(brace
multiline_comment|/*------------------------&lt; START64 &gt;-----------------------*/
(brace
multiline_comment|/*&n;&t;**&t;SCRIPT entry point for the 896.&n;&t;**&t;For now, there is no specific stuff for that &n;&t;**&t;chip at this point, but this may come.&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|init
)paren
comma
)brace
multiline_comment|/*------------------------&lt; SELECT_NO_ATN &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Set Initiator mode.&n;&t;**      And try to select this target without ATN.&n;&t;*/
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
id|SCR_SEL_TBL
op_xor
m_offsetof
(paren
r_struct
id|dsb
comma
id|select
)paren
comma
id|PADDR
(paren
id|ungetjob
)paren
comma
)brace
multiline_comment|/*------------------------&lt; WF_SEL_DONE_NO_ATN &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Wait immediately for the next phase or &n;&t;**&t;the selection to complete or time-out.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|select2
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; CANCEL &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Load the host status.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_ABORTED
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|complete2
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_REJECT &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If a negotiation was in progress,&n;&t;**&t;negotiation failed.&n;&t;**&t;Otherwise just make host log this message&n;&t;*/
id|SCR_FROM_REG
(paren
id|HS_REG
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|HS_NEGOTIATE
)paren
)paren
comma
id|SIR_REJECT_RECEIVED
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|HS_NEGOTIATE
)paren
)paren
comma
id|SIR_NEGO_FAILED
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IGN_RESIDUE &gt;----------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Terminate cycle&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get residue size.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|1
)braket
)paren
comma
multiline_comment|/*&n;&t;**&t;Size is 0 .. ignore message.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
l_int|0
)paren
)paren
comma
id|PADDR
(paren
id|clrack
)paren
comma
multiline_comment|/*&n;&t;**&t;Size is not 1 .. have to interrupt.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|1
)paren
)paren
comma
l_int|40
comma
multiline_comment|/*&n;&t;**&t;Check for residue byte in swide register&n;&t;*/
id|SCR_FROM_REG
(paren
id|scntl2
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|WSR
comma
id|WSR
)paren
)paren
comma
l_int|16
comma
multiline_comment|/*&n;&t;**&t;There IS data in the swide register.&n;&t;**&t;Discard it.&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_OR
comma
id|WSR
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
multiline_comment|/*&n;&t;**&t;Load again the size to the sfbr register.&n;&t;*/
id|SCR_FROM_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_INT
comma
id|SIR_IGN_RESIDUE
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_EXTENDED &gt;-------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Terminate cycle&n;&t;*/
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get length.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|1
)braket
)paren
comma
multiline_comment|/*&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
l_int|3
)paren
)paren
comma
id|PADDRH
(paren
id|msg_ext_3
)paren
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|2
)paren
)paren
comma
id|PADDR
(paren
id|msg_bad
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_EXT_2 &gt;----------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get extended message code.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|2
)braket
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_X_WIDE_REQ
)paren
)paren
comma
id|PADDRH
(paren
id|msg_wdtr
)paren
comma
multiline_comment|/*&n;&t;**&t;unknown extended message&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|msg_bad
)paren
)brace
multiline_comment|/*-------------------------&lt; MSG_WDTR &gt;-----------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get data bus width&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|3
)braket
)paren
comma
multiline_comment|/*&n;&t;**&t;let the host do the real work.&n;&t;*/
id|SCR_INT
comma
id|SIR_NEGO_WIDE
comma
multiline_comment|/*&n;&t;**&t;let the target fetch our answer.&n;&t;*/
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDRH
(paren
id|nego_bad_phase
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_WDTR &gt;----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Send the M_X_WIDE_REQ&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|4
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|msg_out_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_EXT_3 &gt;----------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get extended message code.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|2
)braket
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_X_SYNC_REQ
)paren
)paren
comma
id|PADDRH
(paren
id|msg_sdtr
)paren
comma
multiline_comment|/*&n;&t;**&t;unknown extended message&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|msg_bad
)paren
)brace
multiline_comment|/*-------------------------&lt; MSG_SDTR &gt;-----------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t;**&t;get period and offset&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|2
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
(braket
l_int|3
)braket
)paren
comma
multiline_comment|/*&n;&t;**&t;let the host do the real work.&n;&t;*/
id|SCR_INT
comma
id|SIR_NEGO_SYNC
comma
multiline_comment|/*&n;&t;**&t;let the target fetch our answer.&n;&t;*/
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDRH
(paren
id|nego_bad_phase
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_SDTR &gt;-------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Send the M_X_SYNC_REQ&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|5
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|msg_out_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; NEGO_BAD_PHASE &gt;------------*/
comma
(brace
id|SCR_INT
comma
id|SIR_NEGO_PROTO
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT_ABORT &gt;-------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;After ABORT message,&n;&t;**&n;&t;**&t;expect an immediate disconnect, ...&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_WAIT_DISC
comma
l_int|0
comma
id|SCR_INT
comma
id|SIR_MSG_OUT_DONE
comma
multiline_comment|/*&n;&t;**&t;... and set the status to &quot;ABORTED&quot;&n;&t;*/
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_ABORTED
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|complete2
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The target requests a message.&n;&t;*/
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
multiline_comment|/*&n;&t;**&t;If it was no ABORT message ...&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_ABORT
)paren
)paren
comma
id|PADDRH
(paren
id|msg_out_abort
)paren
comma
multiline_comment|/*&n;&t;**&t;... wait for the next phase&n;&t;**&t;if it&squot;s a message out, send it again, ...&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDRH
(paren
id|msg_out
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT_DONE &gt;--------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;... else clear the message ...&n;&t;*/
id|SCR_INT
comma
id|SIR_MSG_OUT_DONE
comma
multiline_comment|/*&n;&t;**&t;... and process the next phase&n;&t;*/
id|SCR_JUMP
comma
id|PADDR
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; NO_DATA &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The target wants to tranfer too much data&n;&t;**&t;or in the wrong direction.&n;&t;**      Remember that in extended error.&n;&t;*/
id|SCR_LOAD_REG
(paren
id|scratcha
comma
id|XE_EXTRA_DATA
)paren
comma
l_int|0
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|1
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|xerr_status
)paren
comma
multiline_comment|/*&n;&t;**      Discard one data byte, if required.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_DATA_OUT
comma
id|NADDR
(paren
id|scratch
)paren
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|IF
(paren
id|SCR_DATA_IN
)paren
)paren
comma
l_int|8
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_DATA_IN
comma
id|NADDR
(paren
id|scratch
)paren
comma
multiline_comment|/*&n;&t;**      .. and repeat as required.&n;&t;*/
id|SCR_CALL
comma
id|PADDR
(paren
id|databreak
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|no_data
)paren
comma
macro_line|#if&t;MAX_SCATTERH != 0
)brace
multiline_comment|/*-------------------------&lt; HDATA_IN &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;**&t;Because the size depends on the&n;**&t;#define MAX_SCATTERH parameter,&n;**&t;it is filled in at runtime.&n;**&n;**  ##==&lt; i=MAX_SCATTERL; i&lt;MAX_SCATTERL+MAX_SCATTERH &gt;==&n;**  ||&t;SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)),&n;**  ||&t;&t;PADDR (databreak),&n;**  ||&t;SCR_MOVE_TBL ^ SCR_DATA_IN,&n;**  ||&t;&t;offsetof (struct dsb, data[ i]),&n;**  ##===================================================&n;**&n;**---------------------------------------------------------&n;*/
l_int|0
)brace
multiline_comment|/*-------------------------&lt; HDATA_IN2 &gt;------------------*/
comma
(brace
id|SCR_JUMP
comma
id|PADDR
(paren
id|data_in
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; HDATA_OUT &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;**&t;Because the size depends on the&n;**&t;#define MAX_SCATTERH parameter,&n;**&t;it is filled in at runtime.&n;**&n;**  ##==&lt; i=MAX_SCATTERL; i&lt;MAX_SCATTERL+MAX_SCATTERH &gt;==&n;**  ||&t;SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT)),&n;**  ||&t;&t;PADDR (databreak),&n;**  ||&t;SCR_MOVE_TBL ^ SCR_DATA_OUT,&n;**  ||&t;&t;offsetof (struct dsb, data[ i]),&n;**  ##===================================================&n;**&n;**---------------------------------------------------------&n;*/
l_int|0
)brace
multiline_comment|/*-------------------------&lt; HDATA_OUT2 &gt;------------------*/
comma
(brace
id|SCR_JUMP
comma
id|PADDR
(paren
id|data_out
)paren
comma
macro_line|#endif&t;/* MAX_SCATTERH */
)brace
multiline_comment|/*-------------------------&lt; ABORT_RESEL &gt;----------------*/
comma
(brace
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;send the abort/abortag/reset message&n;&t;**&t;we expect an immediate disconnect&n;&t;*/
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_OUT
comma
id|NADDR
(paren
id|msgout
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_WAIT_DISC
comma
l_int|0
comma
id|SCR_INT
comma
id|SIR_RESEL_ABORTED
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEND_IDENT &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;The target stays in MSG OUT phase after having acked &n;&t;**&t;Identify [+ Tag [+ Extended message ]]. Targets shall&n;&t;**&t;behave this way on parity error.&n;&t;**&t;We must send it again all the messages.&n;&t;*/
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
multiline_comment|/* Shall be asserted 2 deskew delays before the  */
l_int|0
comma
multiline_comment|/* 1rst ACK = 90 ns. Hope the NCR is&squot;nt too fast */
id|SCR_JUMP
comma
id|PADDR
(paren
id|send_ident
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; IDENT_BREAK &gt;-------------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|select2
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; IDENT_BREAK_ATN &gt;----------------*/
comma
(brace
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|select2
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SDATA_IN &gt;-------------------*/
comma
(brace
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|dsb
comma
id|sense
)paren
comma
id|SCR_CALL
comma
id|PADDR
(paren
id|databreak
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|no_data
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IO &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;We jump here if the data direction was unknown at the &n;&t;**&t;time we had to queue the command to the scripts processor.&n;&t;**&t;Pointers had been set as follow in this situation:&n;&t;**&t;  savep   --&gt;   DATA_IO&n;&t;**&t;  lastp   --&gt;   start pointer when DATA_IN&n;&t;**&t;  goalp   --&gt;   goal  pointer when DATA_IN&n;&t;**&t;  wlastp  --&gt;   start pointer when DATA_OUT&n;&t;**&t;  wgoalp  --&gt;   goal  pointer when DATA_OUT&n;&t;**&t;This script sets savep/lastp/goalp according to the &n;&t;**&t;direction chosen by the target.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
id|PADDRH
c_func
(paren
id|data_io_out
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IO_COM &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Direction is DATA IN.&n;&t;**&t;Warning: we jump here, even when phase is DATA OUT.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.lastp
)paren
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.savep
)paren
comma
multiline_comment|/*&n;&t;**&t;Jump to the SCRIPTS according to actual direction.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.savep
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IO_OUT &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Direction is DATA OUT.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.wlastp
)paren
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.lastp
)paren
comma
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.wgoalp
)paren
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.header.goalp
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
c_func
(paren
id|data_io_com
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_IDENTIFY &gt;---------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If message phase but not an IDENTIFY,&n;&t;**&t;get some help from the C code.&n;&t;**&t;Old SCSI device may behave so.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0x80
comma
l_int|0x80
)paren
)paren
comma
l_int|16
comma
id|SCR_INT
comma
id|SIR_RESEL_NO_IDENTIFY
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|abort_resel
)paren
comma
multiline_comment|/*&n;&t;**&t;Message is an IDENTIFY, but lun is unknown.&n;&t;**&t;Read the message, since we got it directly &n;&t;**&t;from the SCSI BUS data lines.&n;&t;**&t;Signal problem to C code for logging the event.&n;&t;**&t;Send a M_ABORT to clear all pending tasks.&n;&t;*/
id|SCR_INT
comma
id|SIR_RESEL_BAD_LUN
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|NADDR
(paren
id|msgin
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|abort_resel
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_I_T_L &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;We donnot have a task for that I_T_L.&n;&t;**&t;Signal problem to C code for logging the event.&n;&t;**&t;Send a M_ABORT message.&n;&t;*/
id|SCR_INT
comma
id|SIR_RESEL_BAD_I_T_L
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|abort_resel
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_I_T_L_Q &gt;----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;We donnot have a task that matches the tag.&n;&t;**&t;Signal problem to C code for logging the event.&n;&t;**&t;Send a M_ABORTTAG message.&n;&t;*/
id|SCR_INT
comma
id|SIR_RESEL_BAD_I_T_L_Q
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|abort_resel
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_STATUS &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;If command resulted in either QUEUE FULL,&n;&t;**&t;CHECK CONDITION or COMMAND TERMINATED,&n;&t;**&t;call the C code.&n;&t;*/
id|SCR_LOAD_ABS
(paren
id|scratcha
comma
l_int|4
)paren
comma
id|PADDR
(paren
id|startpos
)paren
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|S_QUEUE_FULL
)paren
)paren
comma
id|SIR_BAD_STATUS
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|S_CHECK_COND
)paren
)paren
comma
id|SIR_BAD_STATUS
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|S_TERMINATED
)paren
)paren
comma
id|SIR_BAD_STATUS
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; TWEAK_PMJ &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Disable PM handling from SCRIPTS for the data phase &n;&t;**&t;and so force PM to be handled from C code if HF_PM_TO_C &n;&t;**&t;flag is set.&n;&t;*/
id|SCR_FROM_REG
c_func
(paren
id|HF_REG
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|HF_PM_TO_C
comma
id|HF_PM_TO_C
)paren
)paren
comma
l_int|16
comma
id|SCR_REG_REG
(paren
id|ccntl0
comma
id|SCR_OR
comma
id|ENPMJ
)paren
comma
l_int|0
comma
id|SCR_RETURN
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|ccntl0
comma
id|SCR_AND
comma
(paren
op_complement
id|ENPMJ
)paren
)paren
comma
l_int|0
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; PM_HANDLE &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Phase mismatch handling.&n;&t;**&n;&t;**&t;Since we have to deal with 2 SCSI data pointers  &n;&t;**&t;(current and saved), we need at least 2 contexts.&n;&t;**&t;Each context (pm0 and pm1) has a saved area, a &n;&t;**&t;SAVE mini-script and a DATA phase mini-script.&n;&t;*/
multiline_comment|/*&n;&t;**&t;Get the PM handling flags.&n;&t;*/
id|SCR_FROM_REG
(paren
id|HF_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;If no flags (1rst PM for example), avoid &n;&t;**&t;all the below heavy flags testing.&n;&t;**&t;This makes the normal case a bit faster.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0
comma
(paren
id|HF_IN_PM0
op_or
id|HF_IN_PM1
op_or
id|HF_DP_SAVED
)paren
)paren
)paren
comma
id|PADDRH
(paren
id|pm_handle1
)paren
comma
multiline_comment|/*&n;&t;**&t;If we received a SAVE DP, switch to the &n;&t;**&t;other PM context since the savep may point &n;&t;**&t;to the current PM context.&n;&t;*/
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|HF_DP_SAVED
comma
id|HF_DP_SAVED
)paren
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|sfbr
comma
id|SCR_XOR
comma
id|HF_ACT_PM
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;If we have been interrupt in a PM DATA mini-script,&n;&t;**&t;we take the return address from the corresponding &n;&t;**&t;saved area.&n;&t;**&t;This ensure the return address always points to the &n;&t;**&t;main DATA script for this transfer.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0
comma
(paren
id|HF_IN_PM0
op_or
id|HF_IN_PM1
)paren
)paren
)paren
comma
id|PADDRH
(paren
id|pm_handle1
)paren
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|HF_IN_PM0
comma
id|HF_IN_PM0
)paren
)paren
comma
l_int|16
comma
id|SCR_LOAD_REL
(paren
id|ia
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm0.ret
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|pm_save
)paren
comma
id|SCR_LOAD_REL
(paren
id|ia
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm1.ret
)paren
comma
id|SCR_JUMP
comma
id|PADDRH
(paren
id|pm_save
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM_HANDLE1 &gt;-----------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Normal case.&n;&t;**&t;Update the return address so that it &n;&t;**&t;will point after the interrupted MOVE.&n;&t;*/
id|SCR_REG_REG
(paren
id|ia
comma
id|SCR_ADD
comma
l_int|8
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|ia1
comma
id|SCR_ADDC
comma
l_int|0
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; PM_SAVE &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Clear all the flags that told us if we were &n;&t;**&t;interrupted in a PM DATA mini-script and/or &n;&t;**&t;we received a SAVE DP.&n;&t;*/
id|SCR_SFBR_REG
(paren
id|HF_REG
comma
id|SCR_AND
comma
(paren
op_complement
(paren
id|HF_IN_PM0
op_or
id|HF_IN_PM1
op_or
id|HF_DP_SAVED
)paren
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t;**&t;Choose the current PM context.&n;&t;*/
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|HF_ACT_PM
comma
id|HF_ACT_PM
)paren
)paren
comma
id|PADDRH
(paren
id|pm1_save
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM0_SAVE &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Save the remaining byte count, the updated &n;&t;**&t;address and the return address.&n;&t;*/
id|SCR_STORE_REL
(paren
id|rbc
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm0.sg.size
)paren
comma
id|SCR_STORE_REL
(paren
id|ua
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm0.sg.addr
)paren
comma
id|SCR_STORE_REL
(paren
id|ia
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm0.ret
)paren
comma
multiline_comment|/*&n;&t;**&t;Set the current pointer at the PM0 DATA mini-script.&n;&t;*/
id|SCR_LOAD_ABS
(paren
id|temp
comma
l_int|4
)paren
comma
id|PADDRH
(paren
id|pm0_data_addr
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|databreak
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM1_SAVE &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Save the remaining byte count, the updated &n;&t;**&t;address and the return address.&n;&t;*/
id|SCR_STORE_REL
(paren
id|rbc
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm1.sg.size
)paren
comma
id|SCR_STORE_REL
(paren
id|ua
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm1.sg.addr
)paren
comma
id|SCR_STORE_REL
(paren
id|ia
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ccb
comma
id|phys.pm1.ret
)paren
comma
multiline_comment|/*&n;&t;**&t;Set the current pointer at the PM1 DATA mini-script.&n;&t;*/
id|SCR_LOAD_ABS
(paren
id|temp
comma
l_int|4
)paren
comma
id|PADDRH
(paren
id|pm1_data_addr
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|databreak
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM0_DATA_ADDR &gt;---------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; PM1_DATA_ADDR &gt;---------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; START_RAM &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Load the script into on-chip RAM, &n;&t;**&t;and jump to start point.&n;&t;*/
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|script
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SCRIPT0_BA &gt;--------------------*/
comma
(brace
l_int|0
comma
id|PADDR
(paren
id|start
)paren
comma
id|SCR_JUMP
comma
id|PADDR
(paren
id|init
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; START_RAM64 &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Load the RAM and start for 64 bit PCI (896).&n;&t;**&t;Both scripts (script and scripth) are loaded into &n;&t;**&t;the RAM which is 8K (4K for 825A/875/895).&n;&t;**&t;We also need to load some 32-63 bit segments &n;&t;**&t;address of the SCRIPTS processor.&n;&t;**&t;LOAD/STORE ABSOLUTE always refers to on-chip RAM &n;&t;**&t;in our implementation. The main memory is &n;&t;**&t;accessed using LOAD/STORE DSA RELATIVE.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|mmws
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ncb
comma
id|scr_ram_seg
)paren
comma
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|script
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SCRIPT0_BA64 &gt;--------------------*/
comma
(brace
l_int|0
comma
id|PADDR
(paren
id|start
)paren
comma
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|scripth
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SCRIPTH0_BA64 &gt;--------------------*/
comma
(brace
l_int|0
comma
id|PADDRH
(paren
id|start64
)paren
comma
id|SCR_LOAD_REL
(paren
id|mmrs
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ncb
comma
id|scr_ram_seg
)paren
comma
id|SCR_JUMP64
comma
id|PADDRH
(paren
id|start64
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RAM_SEG64 &gt;--------------------*/
comma
(brace
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; SNOOPTEST &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;Read the variable.&n;&t;*/
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ncb
comma
id|ncr_cache
)paren
comma
id|SCR_STORE_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ncb
comma
id|ncr_cache
)paren
comma
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|ncb
comma
id|ncr_cache
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SNOOPEND &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t;**&t;And stop.&n;&t;*/
id|SCR_INT
comma
l_int|99
comma
)brace
multiline_comment|/*--------------------------------------------------------*/
)brace
suffix:semicolon
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Fill in #define dependent parts of the script&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_script_fill
r_void
id|__init
id|ncr_script_fill
(paren
r_struct
id|script
op_star
id|scr
comma
r_struct
id|scripth
op_star
id|scrh
)paren
(brace
r_int
id|i
suffix:semicolon
id|ncrcmd
op_star
id|p
suffix:semicolon
macro_line|#if&t;MAX_SCATTERH != 0
id|p
op_assign
id|scrh-&gt;hdata_in
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SCATTERH
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#if&t;SCR_SG_SIZE == 4
op_star
id|p
op_increment
op_assign
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|databreak
)paren
suffix:semicolon
macro_line|#endif
op_star
id|p
op_increment
op_assign
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_IN
suffix:semicolon
op_star
id|p
op_increment
op_assign
m_offsetof
(paren
r_struct
id|dsb
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scrh-&gt;hdata_in
op_plus
r_sizeof
(paren
id|scrh-&gt;hdata_in
)paren
)paren
suffix:semicolon
macro_line|#endif
id|p
op_assign
id|scr-&gt;data_in
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|MAX_SCATTERH
suffix:semicolon
id|i
OL
id|MAX_SCATTERH
op_plus
id|MAX_SCATTERL
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#if&t;SCR_SG_SIZE == 4
op_star
id|p
op_increment
op_assign
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|databreak
)paren
suffix:semicolon
macro_line|#endif
op_star
id|p
op_increment
op_assign
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_IN
suffix:semicolon
op_star
id|p
op_increment
op_assign
m_offsetof
(paren
r_struct
id|dsb
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scr-&gt;data_in
op_plus
r_sizeof
(paren
id|scr-&gt;data_in
)paren
)paren
suffix:semicolon
macro_line|#if&t;MAX_SCATTERH != 0
id|p
op_assign
id|scrh-&gt;hdata_out
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SCATTERH
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#if&t;SCR_SG_SIZE == 4
op_star
id|p
op_increment
op_assign
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|databreak
)paren
suffix:semicolon
macro_line|#endif
op_star
id|p
op_increment
op_assign
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_OUT
suffix:semicolon
op_star
id|p
op_increment
op_assign
m_offsetof
(paren
r_struct
id|dsb
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scrh-&gt;hdata_out
op_plus
r_sizeof
(paren
id|scrh-&gt;hdata_out
)paren
)paren
suffix:semicolon
macro_line|#endif
id|p
op_assign
id|scr-&gt;data_out
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|MAX_SCATTERH
suffix:semicolon
id|i
OL
id|MAX_SCATTERH
op_plus
id|MAX_SCATTERL
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#if SCR_SG_SIZE == 4
op_star
id|p
op_increment
op_assign
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|PADDR
(paren
id|databreak
)paren
suffix:semicolon
macro_line|#endif
op_star
id|p
op_increment
op_assign
id|SCR_MOVE_TBL
op_xor
id|SCR_DATA_OUT
suffix:semicolon
op_star
id|p
op_increment
op_assign
m_offsetof
(paren
r_struct
id|dsb
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
m_assert
(paren
(paren
id|u_long
)paren
id|p
op_eq
(paren
id|u_long
)paren
op_amp
id|scr-&gt;data_out
op_plus
r_sizeof
(paren
id|scr-&gt;data_out
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Copy and rebind a script.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_script_copy_and_bind
r_static
r_void
id|__init
id|ncr_script_copy_and_bind
(paren
id|ncb_p
id|np
comma
id|ncrcmd
op_star
id|src
comma
id|ncrcmd
op_star
id|dst
comma
r_int
id|len
)paren
(brace
id|ncrcmd
id|opcode
comma
r_new
comma
id|old
comma
id|tmp1
comma
id|tmp2
suffix:semicolon
id|ncrcmd
op_star
id|start
comma
op_star
id|end
suffix:semicolon
r_int
id|relocs
suffix:semicolon
r_int
id|opchanged
op_assign
l_int|0
suffix:semicolon
id|start
op_assign
id|src
suffix:semicolon
id|end
op_assign
id|src
op_plus
id|len
op_div
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|src
OL
id|end
)paren
(brace
id|opcode
op_assign
op_star
id|src
op_increment
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|cpu_to_scr
c_func
(paren
id|opcode
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;If we forget to change the length&n;&t;&t;**&t;in struct script, a field will be&n;&t;&t;**&t;padded with 0. This is an illegal&n;&t;&t;**&t;command.&n;&t;&t;*/
r_if
c_cond
(paren
id|opcode
op_eq
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: ERROR0 IN SCRIPT at %d.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
r_int
)paren
(paren
id|src
op_minus
id|start
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|MDELAY
(paren
l_int|10000
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;We use the bogus value 0xf00ff00f ;-)&n;&t;&t;**&t;to reserve data area in SCRIPTS.&n;&t;&t;*/
r_if
c_cond
(paren
id|opcode
op_eq
id|SCR_DATA_ZERO
)paren
(brace
id|dst
(braket
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_SCRIPT
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;%p:  &lt;%x&gt;&bslash;n&quot;
comma
(paren
id|src
op_minus
l_int|1
)paren
comma
(paren
r_int
)paren
id|opcode
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;We don&squot;t have to decode ALL commands&n;&t;&t;*/
r_switch
c_cond
(paren
id|opcode
op_rshift
l_int|28
)paren
(brace
r_case
l_int|0xf
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;LOAD / STORE DSA relative, don&squot;t relocate.&n;&t;&t;&t;*/
id|relocs
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xe
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;LOAD / STORE absolute.&n;&t;&t;&t;*/
id|relocs
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xc
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;COPY has TWO arguments.&n;&t;&t;&t;*/
id|relocs
op_assign
l_int|2
suffix:semicolon
id|tmp1
op_assign
id|src
(braket
l_int|0
)braket
suffix:semicolon
id|tmp2
op_assign
id|src
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#ifdef&t;RELOC_KVAR
r_if
c_cond
(paren
(paren
id|tmp1
op_amp
id|RELOC_MASK
)paren
op_eq
id|RELOC_KVAR
)paren
id|tmp1
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp2
op_amp
id|RELOC_MASK
)paren
op_eq
id|RELOC_KVAR
)paren
id|tmp2
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|tmp1
op_xor
id|tmp2
)paren
op_amp
l_int|3
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: ERROR1 IN SCRIPT at %d.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
r_int
)paren
(paren
id|src
op_minus
id|start
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|MDELAY
(paren
l_int|1000
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;**&t;If PREFETCH feature not enabled, remove &n;&t;&t;&t;**&t;the NO FLUSH bit if present.&n;&t;&t;&t;*/
r_if
c_cond
(paren
(paren
id|opcode
op_amp
id|SCR_NO_FLUSH
)paren
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_PFEN
)paren
)paren
(brace
id|dst
(braket
op_minus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|opcode
op_amp
op_complement
id|SCR_NO_FLUSH
)paren
suffix:semicolon
op_increment
id|opchanged
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x0
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;MOVE (absolute address)&n;&t;&t;&t;*/
id|relocs
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x8
suffix:colon
multiline_comment|/*&n;&t;&t;&t;**&t;JUMP / CALL&n;&t;&t;&t;**&t;dont&squot;t relocate if relative :-)&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|opcode
op_amp
l_int|0x00800000
)paren
id|relocs
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|opcode
op_amp
l_int|0xf8400000
)paren
op_eq
l_int|0x80400000
)paren
multiline_comment|/*JUMP64*/
id|relocs
op_assign
l_int|2
suffix:semicolon
r_else
id|relocs
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4
suffix:colon
r_case
l_int|0x5
suffix:colon
r_case
l_int|0x6
suffix:colon
r_case
l_int|0x7
suffix:colon
id|relocs
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|relocs
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|relocs
)paren
(brace
op_star
id|dst
op_increment
op_assign
id|cpu_to_scr
c_func
(paren
op_star
id|src
op_increment
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_while
c_loop
(paren
id|relocs
op_decrement
)paren
(brace
id|old
op_assign
op_star
id|src
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|old
op_amp
id|RELOC_MASK
)paren
(brace
r_case
id|RELOC_REGISTER
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|pcivtobus
c_func
(paren
id|np-&gt;base_ba
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RELOC_LABEL
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|np-&gt;p_script
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RELOC_LABELH
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|np-&gt;p_scripth
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RELOC_SOFTC
suffix:colon
r_new
op_assign
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
op_plus
id|vtobus
c_func
(paren
id|np
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef&t;RELOC_KVAR
r_case
id|RELOC_KVAR
suffix:colon
r_if
c_cond
(paren
(paren
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
OL
id|SCRIPT_KVAR_FIRST
)paren
op_logical_or
(paren
(paren
id|old
op_amp
op_complement
id|RELOC_MASK
)paren
OG
id|SCRIPT_KVAR_LAST
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;ncr KVAR out of range&quot;
)paren
suffix:semicolon
r_new
op_assign
id|vtobus
c_func
(paren
id|script_kvars
(braket
id|old
op_amp
op_complement
id|RELOC_MASK
)braket
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* Don&squot;t relocate a 0 address. */
r_if
c_cond
(paren
id|old
op_eq
l_int|0
)paren
(brace
r_new
op_assign
id|old
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* fall through */
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;ncr_script_copy_and_bind: &quot;
l_string|&quot;weird relocation %x&bslash;n&quot;
comma
id|old
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
id|dst
op_increment
op_assign
id|cpu_to_scr
c_func
(paren
r_new
)paren
suffix:semicolon
)brace
)brace
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      Auto configuration:  attach and init a host adapter.&n;**&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**&t;Linux host data structure.&n;*/
DECL|struct|host_data
r_struct
id|host_data
(brace
DECL|member|ncb
r_struct
id|ncb
op_star
id|ncb
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;**&t;Print something which allows to retrieve the controler type, unit,&n;**&t;target, lun concerned by a kernel message.&n;*/
DECL|function|PRINT_TARGET
r_static
r_void
id|PRINT_TARGET
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|target
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s-&lt;%d,*&gt;: &quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|target
)paren
suffix:semicolon
)brace
DECL|function|PRINT_LUN
r_static
r_void
id|PRINT_LUN
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|target
comma
r_int
id|lun
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s-&lt;%d,%d&gt;: &quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|target
comma
id|lun
)paren
suffix:semicolon
)brace
DECL|function|PRINT_ADDR
r_static
r_void
id|PRINT_ADDR
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|host_data
op_star
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|PRINT_LUN
c_func
(paren
id|host_data-&gt;ncb
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;NCR chip clock divisor table.&n;**&t;Divisors are multiplied by 10,000,000 in order to make &n;**&t;calculations more simple.&n;**&n;**==========================================================&n;*/
DECL|macro|_5M
mdefine_line|#define _5M 5000000
DECL|variable|div_10M
r_static
id|u_long
id|div_10M
(braket
)braket
op_assign
(brace
l_int|2
op_star
id|_5M
comma
l_int|3
op_star
id|_5M
comma
l_int|4
op_star
id|_5M
comma
l_int|6
op_star
id|_5M
comma
l_int|8
op_star
id|_5M
comma
l_int|12
op_star
id|_5M
comma
l_int|16
op_star
id|_5M
)brace
suffix:semicolon
multiline_comment|/*===============================================================&n;**&n;**&t;Prepare io register values used by ncr_init() according &n;**&t;to selected and supported features.&n;**&n;**&t;NCR chips allow burst lengths of 2, 4, 8, 16, 32, 64, 128 &n;**&t;transfers. 32,64,128 are only supported by 825A, 875, 895 &n;**&t;and 896 chips.&n;**&t;We use log base 2 (burst length) as internal code, with &n;**&t;value 0 meaning &quot;burst disabled&quot;.&n;**&n;**===============================================================&n;*/
multiline_comment|/*&n; *&t;Burst length from burst code.&n; */
DECL|macro|burst_length
mdefine_line|#define burst_length(bc) (!(bc))? 0 : 1 &lt;&lt; (bc)
multiline_comment|/*&n; *&t;Burst code from io register bits.&n; */
DECL|macro|burst_code
mdefine_line|#define burst_code(dmode, ctest4, ctest5) &bslash;&n;&t;(ctest4) &amp; 0x80? 0 : (((dmode) &amp; 0xc0) &gt;&gt; 6) + ((ctest5) &amp; 0x04) + 1
multiline_comment|/*&n; *&t;Set initial io register bits from burst code.&n; */
DECL|function|ncr_init_burst
r_static
r_inline
r_void
id|ncr_init_burst
c_func
(paren
id|ncb_p
id|np
comma
id|u_char
id|bc
)paren
(brace
id|np-&gt;rv_ctest4
op_and_assign
op_complement
l_int|0x80
suffix:semicolon
id|np-&gt;rv_dmode
op_and_assign
op_complement
(paren
l_int|0x3
op_lshift
l_int|6
)paren
suffix:semicolon
id|np-&gt;rv_ctest5
op_and_assign
op_complement
l_int|0x4
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc
)paren
(brace
id|np-&gt;rv_ctest4
op_or_assign
l_int|0x80
suffix:semicolon
)brace
r_else
(brace
op_decrement
id|bc
suffix:semicolon
id|np-&gt;rv_dmode
op_or_assign
(paren
(paren
id|bc
op_amp
l_int|0x3
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|np-&gt;rv_ctest5
op_or_assign
(paren
id|bc
op_amp
l_int|0x4
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
multiline_comment|/*&n;**&t;Get target set-up from Symbios format NVRAM.&n;*/
r_static
r_void
id|__init
DECL|function|ncr_Symbios_setup_target
id|ncr_Symbios_setup_target
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|target
comma
id|Symbios_nvram
op_star
id|nvram
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|Symbios_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|tp-&gt;usrsync
op_assign
id|tn-&gt;sync_period
ques
c_cond
(paren
id|tn-&gt;sync_period
op_plus
l_int|3
)paren
op_div
l_int|4
suffix:colon
l_int|255
suffix:semicolon
id|tp-&gt;usrwide
op_assign
id|tn-&gt;bus_width
op_eq
l_int|0x10
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|tp-&gt;usrtags
op_assign
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_QUEUE_TAGS_ENABLED
)paren
ques
c_cond
id|SCSI_NCR_MAX_TAGS
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_DISCONNECT_ENABLE
)paren
)paren
id|tp-&gt;usrflag
op_or_assign
id|UF_NODISC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_SCAN_AT_BOOT_TIME
)paren
)paren
id|tp-&gt;usrflag
op_or_assign
id|UF_NOSCAN
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Get target set-up from Tekram format NVRAM.&n;*/
r_static
r_void
id|__init
DECL|function|ncr_Tekram_setup_target
id|ncr_Tekram_setup_target
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|target
comma
id|Tekram_nvram
op_star
id|nvram
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_struct
id|Tekram_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_SYNC_NEGO
)paren
(brace
id|i
op_assign
id|tn-&gt;sync_index
op_amp
l_int|0xf
suffix:semicolon
id|tp-&gt;usrsync
op_assign
id|i
OL
l_int|12
ques
c_cond
id|Tekram_sync
(braket
id|i
)braket
suffix:colon
l_int|255
suffix:semicolon
)brace
id|tp-&gt;usrwide
op_assign
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_WIDE_NEGO
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_TAGGED_COMMANDS
)paren
(brace
id|tp-&gt;usrtags
op_assign
l_int|2
op_lshift
id|nvram-&gt;max_tags_index
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_DISCONNECT_ENABLE
)paren
)paren
id|tp-&gt;usrflag
op_assign
id|UF_NODISC
suffix:semicolon
multiline_comment|/* If any device does not support parity, we will not use this option */
r_if
c_cond
(paren
op_logical_neg
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_PARITY_CHECK
)paren
)paren
id|np-&gt;rv_scntl0
op_and_assign
op_complement
l_int|0x0a
suffix:semicolon
multiline_comment|/* SCSI parity checking disabled */
)brace
macro_line|#endif /* SCSI_NCR_NVRAM_SUPPORT */
DECL|function|ncr_prepare_setting
r_static
r_int
id|__init
id|ncr_prepare_setting
c_func
(paren
id|ncb_p
id|np
comma
id|ncr_nvram
op_star
id|nvram
)paren
(brace
id|u_char
id|burst_max
suffix:semicolon
id|u_long
id|period
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Save assumed BIOS setting&n;&t;*/
id|np-&gt;sv_scntl0
op_assign
id|INB
c_func
(paren
id|nc_scntl0
)paren
op_amp
l_int|0x0a
suffix:semicolon
id|np-&gt;sv_scntl3
op_assign
id|INB
c_func
(paren
id|nc_scntl3
)paren
op_amp
l_int|0x07
suffix:semicolon
id|np-&gt;sv_dmode
op_assign
id|INB
c_func
(paren
id|nc_dmode
)paren
op_amp
l_int|0xce
suffix:semicolon
id|np-&gt;sv_dcntl
op_assign
id|INB
c_func
(paren
id|nc_dcntl
)paren
op_amp
l_int|0xa8
suffix:semicolon
id|np-&gt;sv_ctest3
op_assign
id|INB
c_func
(paren
id|nc_ctest3
)paren
op_amp
l_int|0x01
suffix:semicolon
id|np-&gt;sv_ctest4
op_assign
id|INB
c_func
(paren
id|nc_ctest4
)paren
op_amp
l_int|0x80
suffix:semicolon
id|np-&gt;sv_ctest5
op_assign
id|INB
c_func
(paren
id|nc_ctest5
)paren
op_amp
l_int|0x24
suffix:semicolon
id|np-&gt;sv_gpcntl
op_assign
id|INB
c_func
(paren
id|nc_gpcntl
)paren
suffix:semicolon
id|np-&gt;sv_stest2
op_assign
id|INB
c_func
(paren
id|nc_stest2
)paren
op_amp
l_int|0x20
suffix:semicolon
id|np-&gt;sv_stest4
op_assign
id|INB
c_func
(paren
id|nc_stest4
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wide ?&n;&t;*/
id|np-&gt;maxwide
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_WIDE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Get the frequency of the chip&squot;s clock.&n;&t;**&t;Find the right value for scntl3.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_QUAD
)paren
id|np-&gt;multiplier
op_assign
l_int|4
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_DBLR
)paren
id|np-&gt;multiplier
op_assign
l_int|2
suffix:semicolon
r_else
id|np-&gt;multiplier
op_assign
l_int|1
suffix:semicolon
id|np-&gt;clock_khz
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_CLK80
)paren
ques
c_cond
l_int|80000
suffix:colon
l_int|40000
suffix:semicolon
id|np-&gt;clock_khz
op_mul_assign
id|np-&gt;multiplier
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;clock_khz
op_ne
l_int|40000
)paren
id|ncr_getclock
c_func
(paren
id|np
comma
id|np-&gt;multiplier
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Divisor to be used for async (timer pre-scaler).&n;&t; */
id|i
op_assign
id|np-&gt;clock_divn
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|i
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
l_int|10ul
op_star
id|SCSI_NCR_MIN_ASYNC
op_star
id|np-&gt;clock_khz
OG
id|div_10M
(braket
id|i
)braket
)paren
(brace
op_increment
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|np-&gt;rv_scntl3
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Minimum synchronous period factor supported by the chip.&n;&t; * Btw, &squot;period&squot; is in tenths of nanoseconds.&n;&t; */
id|period
op_assign
(paren
l_int|4
op_star
id|div_10M
(braket
l_int|0
)braket
op_plus
id|np-&gt;clock_khz
op_minus
l_int|1
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
r_if
c_cond
(paren
id|period
op_le
l_int|250
)paren
id|np-&gt;minsync
op_assign
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|period
op_le
l_int|303
)paren
id|np-&gt;minsync
op_assign
l_int|11
suffix:semicolon
r_else
r_if
c_cond
(paren
id|period
op_le
l_int|500
)paren
id|np-&gt;minsync
op_assign
l_int|12
suffix:semicolon
r_else
id|np-&gt;minsync
op_assign
(paren
id|period
op_plus
l_int|40
op_minus
l_int|1
)paren
op_div
l_int|40
suffix:semicolon
multiline_comment|/*&n;&t; * Check against chip SCSI standard support (SCSI-2,ULTRA,ULTRA2).&n;&t; */
r_if
c_cond
(paren
id|np-&gt;minsync
OL
l_int|25
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
(paren
id|FE_ULTRA
op_or
id|FE_ULTRA2
)paren
)paren
)paren
id|np-&gt;minsync
op_assign
l_int|25
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;minsync
OL
l_int|12
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA2
)paren
)paren
id|np-&gt;minsync
op_assign
l_int|12
suffix:semicolon
multiline_comment|/*&n;&t; * Maximum synchronous period factor supported by the chip.&n;&t; */
id|period
op_assign
(paren
l_int|11
op_star
id|div_10M
(braket
id|np-&gt;clock_divn
op_minus
l_int|1
)braket
)paren
op_div
(paren
l_int|4
op_star
id|np-&gt;clock_khz
)paren
suffix:semicolon
id|np-&gt;maxsync
op_assign
id|period
OG
l_int|2540
ques
c_cond
l_int|254
suffix:colon
id|period
op_div
l_int|10
suffix:semicolon
multiline_comment|/*&n;&t;**&t;64 bit (53C896) ?&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_64BIT
)paren
macro_line|#if BITS_PER_LONG &gt; 32
id|np-&gt;rv_ccntl1
op_or_assign
(paren
id|XTIMOD
op_or
id|EXTIBMV
)paren
suffix:semicolon
macro_line|#else
id|np-&gt;rv_ccntl1
op_or_assign
(paren
id|DDAC
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Phase mismatch handled by SCRIPTS (53C896) ?&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_NOPM
)paren
id|np-&gt;rv_ccntl0
op_or_assign
(paren
id|ENPMJ
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Prepare initial value of other IO registers&n;&t;*/
macro_line|#if defined SCSI_NCR_TRUST_BIOS_SETTING
id|np-&gt;rv_scntl0
op_assign
id|np-&gt;sv_scntl0
suffix:semicolon
id|np-&gt;rv_dmode
op_assign
id|np-&gt;sv_dmode
suffix:semicolon
id|np-&gt;rv_dcntl
op_assign
id|np-&gt;sv_dcntl
suffix:semicolon
id|np-&gt;rv_ctest3
op_assign
id|np-&gt;sv_ctest3
suffix:semicolon
id|np-&gt;rv_ctest4
op_assign
id|np-&gt;sv_ctest4
suffix:semicolon
id|np-&gt;rv_ctest5
op_assign
id|np-&gt;sv_ctest5
suffix:semicolon
id|burst_max
op_assign
id|burst_code
c_func
(paren
id|np-&gt;sv_dmode
comma
id|np-&gt;sv_ctest4
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;&t;**&t;Select burst length (dwords)&n;&t;*/
id|burst_max
op_assign
id|driver_setup.burst_max
suffix:semicolon
r_if
c_cond
(paren
id|burst_max
op_eq
l_int|255
)paren
id|burst_max
op_assign
id|burst_code
c_func
(paren
id|np-&gt;sv_dmode
comma
id|np-&gt;sv_ctest4
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|burst_max
OG
l_int|7
)paren
id|burst_max
op_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|burst_max
OG
id|np-&gt;maxburst
)paren
id|burst_max
op_assign
id|np-&gt;maxburst
suffix:semicolon
multiline_comment|/*&n;&t;**&t;DEL 352 - 53C810 Rev x11 - Part Number 609-0392140 - ITEM 2.&n;&t;**&t;This chip and the 860 Rev 1 may wrongly use PCI cache line &n;&t;**&t;based transactions on LOAD/STORE instructions. So we have &n;&t;**&t;to prevent these chips from using such PCI transactions in &n;&t;**&t;this driver. The generic sym53c8xx driver that does not use &n;&t;**&t;LOAD/STORE instructions does not need this work-around.&n;&t;*/
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_NCR_53C810
op_logical_and
id|np-&gt;revision_id
op_ge
l_int|0x10
op_logical_and
id|np-&gt;revision_id
op_le
l_int|0x11
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_NCR_53C860
op_logical_and
id|np-&gt;revision_id
op_le
l_int|0x1
)paren
)paren
id|np-&gt;features
op_and_assign
op_complement
(paren
id|FE_WRIE
op_or
id|FE_ERL
op_or
id|FE_ERMP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Select all supported special features.&n;&t;**&t;If we are using on-board RAM for scripts, prefetch (PFEN) &n;&t;**&t;does not help, but burst op fetch (BOF) does.&n;&t;**&t;Disabling PFEN makes sure BOF will be used.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ERL
)paren
id|np-&gt;rv_dmode
op_or_assign
id|ERL
suffix:semicolon
multiline_comment|/* Enable Read Line */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_BOF
)paren
id|np-&gt;rv_dmode
op_or_assign
id|BOF
suffix:semicolon
multiline_comment|/* Burst Opcode Fetch */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ERMP
)paren
id|np-&gt;rv_dmode
op_or_assign
id|ERMP
suffix:semicolon
multiline_comment|/* Enable Read Multiple */
macro_line|#ifdef SCSI_NCR_OPTIMIZE_896
r_if
c_cond
(paren
(paren
id|np-&gt;features
op_amp
id|FE_PFEN
)paren
op_logical_and
op_logical_neg
id|np-&gt;base2_ba
)paren
macro_line|#else
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_PFEN
)paren
macro_line|#endif
id|np-&gt;rv_dcntl
op_or_assign
id|PFEN
suffix:semicolon
multiline_comment|/* Prefetch Enable */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_CLSE
)paren
id|np-&gt;rv_dcntl
op_or_assign
id|CLSE
suffix:semicolon
multiline_comment|/* Cache Line Size Enable */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_WRIE
)paren
id|np-&gt;rv_ctest3
op_or_assign
id|WRIE
suffix:semicolon
multiline_comment|/* Write and Invalidate */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_DFS
)paren
id|np-&gt;rv_ctest5
op_or_assign
id|DFS
suffix:semicolon
multiline_comment|/* Dma Fifo Size */
multiline_comment|/*&n;&t;**&t;Select some other&n;&t;*/
r_if
c_cond
(paren
id|driver_setup.master_parity
)paren
id|np-&gt;rv_ctest4
op_or_assign
id|MPEE
suffix:semicolon
multiline_comment|/* Master parity checking */
r_if
c_cond
(paren
id|driver_setup.scsi_parity
)paren
id|np-&gt;rv_scntl0
op_or_assign
l_int|0x0a
suffix:semicolon
multiline_comment|/*  full arb., ena parity, par-&gt;ATN  */
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
multiline_comment|/*&n;&t;**&t;Get parity checking, host ID and verbose mode from NVRAM&n;&t;**/
r_if
c_cond
(paren
id|nvram
)paren
(brace
r_switch
c_cond
(paren
id|nvram-&gt;type
)paren
(brace
r_case
id|SCSI_NCR_TEKRAM_NVRAM
suffix:colon
id|np-&gt;myaddr
op_assign
id|nvram-&gt;data.Tekram.host_id
op_amp
l_int|0x0f
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|nvram-&gt;data.Symbios.flags
op_amp
id|SYMBIOS_PARITY_ENABLE
)paren
)paren
id|np-&gt;rv_scntl0
op_and_assign
op_complement
l_int|0x0a
suffix:semicolon
id|np-&gt;myaddr
op_assign
id|nvram-&gt;data.Symbios.host_id
op_amp
l_int|0x0f
suffix:semicolon
r_if
c_cond
(paren
id|nvram-&gt;data.Symbios.flags
op_amp
id|SYMBIOS_VERBOSE_MSGS
)paren
id|np-&gt;verbose
op_add_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**  Get SCSI addr of host adapter (set by bios?).&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;myaddr
op_eq
l_int|255
)paren
(brace
id|np-&gt;myaddr
op_assign
id|INB
c_func
(paren
id|nc_scid
)paren
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;myaddr
)paren
id|np-&gt;myaddr
op_assign
id|SCSI_NCR_MYADDR
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_TRUST_BIOS_SETTING */
multiline_comment|/*&n;&t; *&t;Prepare initial io register bits for burst length&n;&t; */
id|ncr_init_burst
c_func
(paren
id|np
comma
id|burst_max
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set differential mode and LED support.&n;&t;**&t;Ignore these features for boards known to use a &n;&t;**&t;specific GPIO wiring (Tekram only for now) and &n;&t;**&t;for the 896 that drives the LED directly.&n;&t;**&t;Probe initial setting of GPREG and GPCNTL for &n;&t;**&t;other ones.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|nvram
op_logical_or
id|nvram-&gt;type
op_ne
id|SCSI_NCR_TEKRAM_NVRAM
)paren
(brace
r_switch
c_cond
(paren
id|driver_setup.diff_support
)paren
(brace
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_gpreg
)paren
op_amp
l_int|0x08
)paren
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|np-&gt;rv_stest2
op_or_assign
l_int|0x20
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|np-&gt;rv_stest2
op_or_assign
(paren
id|np-&gt;sv_stest2
op_amp
l_int|0x20
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|driver_setup.led_pin
op_logical_or
(paren
id|nvram
op_logical_and
id|nvram-&gt;type
op_eq
id|SCSI_NCR_SYMBIOS_NVRAM
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_LEDC
)paren
op_logical_and
op_logical_neg
(paren
id|np-&gt;sv_gpcntl
op_amp
l_int|0x01
)paren
)paren
id|np-&gt;features
op_or_assign
id|FE_LED0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set irq mode.&n;&t;*/
r_switch
c_cond
(paren
id|driver_setup.irqm
op_amp
l_int|3
)paren
(brace
r_case
l_int|2
suffix:colon
id|np-&gt;rv_dcntl
op_or_assign
id|IRQM
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|np-&gt;rv_dcntl
op_or_assign
(paren
id|np-&gt;sv_dcntl
op_amp
id|IRQM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Configure targets according to driver setup.&n;&t;**&t;If NVRAM present get targets setup from NVRAM.&n;&t;**&t;Allow to override sync, wide and NOSCAN from &n;&t;**&t;boot command line.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|tp-&gt;usrsync
op_assign
l_int|255
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_if
c_cond
(paren
id|nvram
)paren
(brace
r_switch
c_cond
(paren
id|nvram-&gt;type
)paren
(brace
r_case
id|SCSI_NCR_TEKRAM_NVRAM
suffix:colon
id|ncr_Tekram_setup_target
c_func
(paren
id|np
comma
id|i
comma
op_amp
id|nvram-&gt;data.Tekram
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:colon
id|ncr_Symbios_setup_target
c_func
(paren
id|np
comma
id|i
comma
op_amp
id|nvram-&gt;data.Symbios
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x2
)paren
id|tp-&gt;usrsync
op_assign
id|driver_setup.default_sync
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x4
)paren
id|tp-&gt;usrwide
op_assign
id|driver_setup.max_wide
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x8
)paren
id|tp-&gt;usrflag
op_and_assign
op_complement
id|UF_NOSCAN
suffix:semicolon
)brace
r_else
(brace
macro_line|#else
r_if
c_cond
(paren
l_int|1
)paren
(brace
macro_line|#endif
id|tp-&gt;usrsync
op_assign
id|driver_setup.default_sync
suffix:semicolon
id|tp-&gt;usrwide
op_assign
id|driver_setup.max_wide
suffix:semicolon
id|tp-&gt;usrtags
op_assign
id|SCSI_NCR_MAX_TAGS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver_setup.disconnection
)paren
id|np-&gt;target
(braket
id|i
)braket
dot
id|usrflag
op_assign
id|UF_NODISC
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;Announce all that stuff to user.&n;&t;*/
id|i
op_assign
id|nvram
ques
c_cond
id|nvram-&gt;type
suffix:colon
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %sID %d, Fast-%d%s%s&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|i
op_eq
id|SCSI_NCR_SYMBIOS_NVRAM
ques
c_cond
l_string|&quot;Symbios format NVRAM, &quot;
suffix:colon
(paren
id|i
op_eq
id|SCSI_NCR_TEKRAM_NVRAM
ques
c_cond
l_string|&quot;Tekram format NVRAM, &quot;
suffix:colon
l_string|&quot;&quot;
)paren
comma
id|np-&gt;myaddr
comma
id|np-&gt;minsync
OL
l_int|12
ques
c_cond
l_int|40
suffix:colon
(paren
id|np-&gt;minsync
OL
l_int|25
ques
c_cond
l_int|20
suffix:colon
l_int|10
)paren
comma
(paren
id|np-&gt;rv_scntl0
op_amp
l_int|0xa
)paren
ques
c_cond
l_string|&quot;, Parity Checking&quot;
suffix:colon
l_string|&quot;, NO Parity&quot;
comma
(paren
id|np-&gt;rv_stest2
op_amp
l_int|0x20
)paren
ques
c_cond
l_string|&quot;, Differential&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: initial SCNTL3/DMODE/DCNTL/CTEST3/4/5 = &quot;
l_string|&quot;(hex) %02x/%02x/%02x/%02x/%02x/%02x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;sv_scntl3
comma
id|np-&gt;sv_dmode
comma
id|np-&gt;sv_dcntl
comma
id|np-&gt;sv_ctest3
comma
id|np-&gt;sv_ctest4
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: final   SCNTL3/DMODE/DCNTL/CTEST3/4/5 = &quot;
l_string|&quot;(hex) %02x/%02x/%02x/%02x/%02x/%02x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;rv_scntl3
comma
id|np-&gt;rv_dmode
comma
id|np-&gt;rv_dcntl
comma
id|np-&gt;rv_ctest3
comma
id|np-&gt;rv_ctest4
comma
id|np-&gt;rv_ctest5
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bootverbose
op_logical_and
id|np-&gt;base2_ba
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: on-chip RAM at 0x%lx&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;base2_ba
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
DECL|function|ncr_display_Symbios_nvram
r_void
id|__init
id|ncr_display_Symbios_nvram
c_func
(paren
id|ncb_p
id|np
comma
id|Symbios_nvram
op_star
id|nvram
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* display Symbios nvram host data */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: HOST ID=%d%s%s%s%s%s&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|nvram-&gt;host_id
op_amp
l_int|0x0f
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_SCAM_ENABLE
)paren
ques
c_cond
l_string|&quot; SCAM&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_PARITY_ENABLE
)paren
ques
c_cond
l_string|&quot; PARITY&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_VERBOSE_MSGS
)paren
ques
c_cond
l_string|&quot; VERBOSE&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_CHS_MAPPING
)paren
ques
c_cond
l_string|&quot; CHS_ALT&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags1
op_amp
id|SYMBIOS_SCAN_HI_LO
)paren
ques
c_cond
l_string|&quot; HI_LO&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
multiline_comment|/* display Symbios nvram drive data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|Symbios_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s-%d:%s%s%s%s WIDTH=%d SYNC=%d TMO=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|i
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_DISCONNECT_ENABLE
)paren
ques
c_cond
l_string|&quot; DISC&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_SCAN_AT_BOOT_TIME
)paren
ques
c_cond
l_string|&quot; SCAN_BOOT&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_SCAN_LUNS
)paren
ques
c_cond
l_string|&quot; SCAN_LUNS&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_QUEUE_TAGS_ENABLED
)paren
ques
c_cond
l_string|&quot; TCQ&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|tn-&gt;bus_width
comma
id|tn-&gt;sync_period
op_div
l_int|4
comma
id|tn-&gt;timeout
)paren
suffix:semicolon
)brace
)brace
DECL|variable|__initdata
r_static
id|u_char
id|Tekram_boot_delay
(braket
l_int|7
)braket
id|__initdata
op_assign
(brace
l_int|3
comma
l_int|5
comma
l_int|10
comma
l_int|20
comma
l_int|30
comma
l_int|60
comma
l_int|120
)brace
suffix:semicolon
DECL|function|ncr_display_Tekram_nvram
r_void
id|__init
id|ncr_display_Tekram_nvram
c_func
(paren
id|ncb_p
id|np
comma
id|Tekram_nvram
op_star
id|nvram
)paren
(brace
r_int
id|i
comma
id|tags
comma
id|boot_delay
suffix:semicolon
r_char
op_star
id|rem
suffix:semicolon
multiline_comment|/* display Tekram nvram host data */
id|tags
op_assign
l_int|2
op_lshift
id|nvram-&gt;max_tags_index
suffix:semicolon
id|boot_delay
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nvram-&gt;boot_delay_index
OL
l_int|6
)paren
id|boot_delay
op_assign
id|Tekram_boot_delay
(braket
id|nvram-&gt;boot_delay_index
)braket
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_REMOVABLE_FLAGS
)paren
op_rshift
l_int|6
)paren
(brace
r_default
suffix:colon
r_case
l_int|0
suffix:colon
id|rem
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|rem
op_assign
l_string|&quot; REMOVABLE=boot device&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|rem
op_assign
l_string|&quot; REMOVABLE=all&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: HOST ID=%d%s%s%s%s%s%s%s%s%s BOOT DELAY=%d tags=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|nvram-&gt;host_id
op_amp
l_int|0x0f
comma
(paren
id|nvram-&gt;flags1
op_amp
id|SYMBIOS_SCAM_ENABLE
)paren
ques
c_cond
l_string|&quot; SCAM&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_MORE_THAN_2_DRIVES
)paren
ques
c_cond
l_string|&quot; &gt;2DRIVES&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_DRIVES_SUP_1GB
)paren
ques
c_cond
l_string|&quot; &gt;1GB&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_RESET_ON_POWER_ON
)paren
ques
c_cond
l_string|&quot; RESET&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_ACTIVE_NEGATION
)paren
ques
c_cond
l_string|&quot; ACT_NEG&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_IMMEDIATE_SEEK
)paren
ques
c_cond
l_string|&quot; IMM_SEEK&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_SCAN_LUNS
)paren
ques
c_cond
l_string|&quot; SCAN_LUNS&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags1
op_amp
id|TEKRAM_F2_F6_ENABLED
)paren
ques
c_cond
l_string|&quot; F2_F6&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|rem
comma
id|boot_delay
comma
id|tags
)paren
suffix:semicolon
multiline_comment|/* display Tekram nvram drive data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|sync
comma
id|j
suffix:semicolon
r_struct
id|Tekram_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|j
op_assign
id|tn-&gt;sync_index
op_amp
l_int|0xf
suffix:semicolon
id|sync
op_assign
id|j
OL
l_int|12
ques
c_cond
id|Tekram_sync
(braket
id|j
)braket
suffix:colon
l_int|255
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s-%d:%s%s%s%s%s%s PERIOD=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|i
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_PARITY_CHECK
)paren
ques
c_cond
l_string|&quot; PARITY&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_SYNC_NEGO
)paren
ques
c_cond
l_string|&quot; SYNC&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_DISCONNECT_ENABLE
)paren
ques
c_cond
l_string|&quot; DISC&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_START_CMD
)paren
ques
c_cond
l_string|&quot; START&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_TAGGED_COMMANDS
)paren
ques
c_cond
l_string|&quot; TCQ&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_WIDE_NEGO
)paren
ques
c_cond
l_string|&quot; WIDE&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|sync
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* SCSI_NCR_DEBUG_NVRAM */
multiline_comment|/*&n;**&t;Host attach and initialisations.&n;**&n;**&t;Allocate host data and ncb structure.&n;**&t;Request IO region and remap MMIO region.&n;**&t;Do chip initialization.&n;**&t;If all is OK, install interrupt handling and&n;**&t;start the timer daemon.&n;*/
DECL|function|ncr_attach
r_static
r_int
id|__init
id|ncr_attach
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|unit
comma
id|ncr_device
op_star
id|device
)paren
(brace
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
id|ncb_p
id|np
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
op_assign
l_int|0
suffix:semicolon
id|u_long
id|flags
op_assign
l_int|0
suffix:semicolon
id|ncr_nvram
op_star
id|nvram
op_assign
id|device-&gt;nvram
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef __sparc__
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ncr53c%s-%d: rev=0x%02x, base=0x%lx, io_port=0x%lx, irq=0x%x&bslash;n&quot;
comma
id|device-&gt;chip.name
comma
id|unit
comma
id|device-&gt;chip.revision_id
comma
id|device-&gt;slot.base
comma
id|device-&gt;slot.io_port
comma
id|device-&gt;slot.irq
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_INFO
id|NAME53C
l_string|&quot;%s-%d: rev=0x%02x, base=0x%lx, io_port=0x%lx, irq=%d&bslash;n&quot;
comma
id|device-&gt;chip.name
comma
id|unit
comma
id|device-&gt;chip.revision_id
comma
id|device-&gt;slot.base
comma
id|device-&gt;slot.io_port
comma
id|device-&gt;slot.irq
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Allocate host_data structure&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|instance
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
r_sizeof
(paren
op_star
id|host_data
)paren
)paren
)paren
)paren
r_goto
id|attach_error
suffix:semicolon
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate the host control block.&n;&t;*/
id|np
op_assign
id|m_calloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ncb
)paren
comma
l_string|&quot;NCB&quot;
comma
id|MEMO_WARN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np
)paren
r_goto
id|attach_error
suffix:semicolon
id|NCR_INIT_LOCK_NCB
c_func
(paren
id|np
)paren
suffix:semicolon
id|host_data-&gt;ncb
op_assign
id|np
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Store input informations in the host data structure.&n;&t;*/
id|strncpy
c_func
(paren
id|np-&gt;chip_name
comma
id|device-&gt;chip.name
comma
r_sizeof
(paren
id|np-&gt;chip_name
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|np-&gt;unit
op_assign
id|unit
suffix:semicolon
id|np-&gt;verbose
op_assign
id|driver_setup.verbose
suffix:semicolon
id|sprintf
c_func
(paren
id|np-&gt;inst_name
comma
id|NAME53C
l_string|&quot;%s-%d&quot;
comma
id|np-&gt;chip_name
comma
id|np-&gt;unit
)paren
suffix:semicolon
id|np-&gt;device_id
op_assign
id|device-&gt;chip.device_id
suffix:semicolon
id|np-&gt;revision_id
op_assign
id|device-&gt;chip.revision_id
suffix:semicolon
id|np-&gt;features
op_assign
id|device-&gt;chip.features
suffix:semicolon
id|np-&gt;clock_divn
op_assign
id|device-&gt;chip.nr_divisor
suffix:semicolon
id|np-&gt;maxoffs
op_assign
id|device-&gt;chip.offset_max
suffix:semicolon
id|np-&gt;maxburst
op_assign
id|device-&gt;chip.burst_max
suffix:semicolon
id|np-&gt;myaddr
op_assign
id|device-&gt;host_id
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate the start queue.&n;&t;*/
id|np-&gt;squeue
op_assign
(paren
id|ncrcmd
op_star
)paren
id|m_calloc
c_func
(paren
r_sizeof
(paren
id|ncrcmd
)paren
op_star
(paren
id|MAX_START
op_star
l_int|2
)paren
comma
l_string|&quot;SQUEUE&quot;
comma
id|MEMO_WARN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;squeue
)paren
r_goto
id|attach_error
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate the done queue.&n;&t;*/
id|np-&gt;dqueue
op_assign
(paren
id|ncrcmd
op_star
)paren
id|m_calloc
c_func
(paren
r_sizeof
(paren
id|ncrcmd
)paren
op_star
(paren
id|MAX_START
op_star
l_int|2
)paren
comma
l_string|&quot;DQUEUE&quot;
comma
id|MEMO_WARN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;dqueue
)paren
r_goto
id|attach_error
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate the target bus address array.&n;&t;*/
id|np-&gt;targtbl
op_assign
(paren
id|u_int32
op_star
)paren
id|m_calloc
c_func
(paren
l_int|256
comma
l_string|&quot;TARGTBL&quot;
comma
id|MEMO_WARN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;targtbl
)paren
r_goto
id|attach_error
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate SCRIPTS areas&n;&t;*/
id|np-&gt;script0
op_assign
(paren
r_struct
id|script
op_star
)paren
id|m_calloc
c_func
(paren
r_sizeof
(paren
r_struct
id|script
)paren
comma
l_string|&quot;SCRIPT&quot;
comma
id|MEMO_WARN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;script0
)paren
r_goto
id|attach_error
suffix:semicolon
id|np-&gt;scripth0
op_assign
(paren
r_struct
id|scripth
op_star
)paren
id|m_calloc
c_func
(paren
r_sizeof
(paren
r_struct
id|scripth
)paren
comma
l_string|&quot;SCRIPTH&quot;
comma
id|MEMO_WARN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;scripth0
)paren
r_goto
id|attach_error
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialyze the CCB free queue and,&n;&t;**&t;allocate some CCB. We need at least ONE.&n;&t;*/
id|xpt_que_init
c_func
(paren
op_amp
id|np-&gt;free_ccbq
)paren
suffix:semicolon
id|xpt_que_init
c_func
(paren
op_amp
id|np-&gt;b0_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ncr_alloc_ccb
c_func
(paren
id|np
)paren
)paren
r_goto
id|attach_error
suffix:semicolon
multiline_comment|/*&n;&t;**    Initialize timer structure&n;        **&n;        */
id|init_timer
c_func
(paren
op_amp
id|np-&gt;timer
)paren
suffix:semicolon
id|np-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|np
suffix:semicolon
id|np-&gt;timer.function
op_assign
id|sym53c8xx_timeout
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Try to map the controller chip to&n;&t;**&t;virtual and physical memory.&n;&t;*/
id|np-&gt;base_ba
op_assign
id|device-&gt;slot.base
suffix:semicolon
id|np-&gt;base_ws
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_IO256
)paren
ques
c_cond
l_int|256
suffix:colon
l_int|128
suffix:semicolon
id|np-&gt;base2_ba
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_RAM
)paren
ques
c_cond
id|device-&gt;slot.base_2
suffix:colon
l_int|0
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
id|np-&gt;base_va
op_assign
id|remap_pci_mem
c_func
(paren
id|np-&gt;base_ba
comma
id|np-&gt;base_ws
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;base_va
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: can&squot;t map PCI MMIO region&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: using memory mapped IO&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Make the controller&squot;s registers available.&n;&t;**&t;Now the INB INW INL OUTB OUTW OUTL macros&n;&t;**&t;can be used safely.&n;&t;*/
id|np-&gt;reg
op_assign
(paren
r_struct
id|ncr_reg
op_star
)paren
id|np-&gt;base_va
suffix:semicolon
macro_line|#endif /* !defined NCR_IOMAPPED */
multiline_comment|/*&n;&t;**&t;Try to map the controller chip into iospace.&n;&t;*/
r_if
c_cond
(paren
id|device-&gt;slot.io_port
)paren
(brace
id|request_region
c_func
(paren
id|device-&gt;slot.io_port
comma
id|np-&gt;base_ws
comma
id|NAME53C8XX
)paren
suffix:semicolon
id|np-&gt;base_io
op_assign
id|device-&gt;slot.io_port
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_if
c_cond
(paren
id|nvram
)paren
(brace
r_switch
c_cond
(paren
id|nvram-&gt;type
)paren
(brace
r_case
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:colon
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
id|ncr_display_Symbios_nvram
c_func
(paren
id|np
comma
op_amp
id|nvram-&gt;data.Symbios
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|SCSI_NCR_TEKRAM_NVRAM
suffix:colon
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
id|ncr_display_Tekram_nvram
c_func
(paren
id|np
comma
op_amp
id|nvram-&gt;data.Tekram
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
id|nvram
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: NVRAM: None or invalid data.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Do chip dependent initialization.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;base2_ba
op_logical_and
r_sizeof
(paren
r_struct
id|script
)paren
OG
l_int|4096
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: script too large.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
(paren
r_void
)paren
id|ncr_prepare_setting
c_func
(paren
id|np
comma
id|nvram
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Patch script to physical addresses&n;&t;*/
id|ncr_script_fill
(paren
op_amp
id|script0
comma
op_amp
id|scripth0
)paren
suffix:semicolon
id|np-&gt;p_script
op_assign
id|vtobus
c_func
(paren
id|np-&gt;script0
)paren
suffix:semicolon
id|np-&gt;p_scripth
op_assign
id|vtobus
c_func
(paren
id|np-&gt;scripth0
)paren
suffix:semicolon
id|np-&gt;p_scripth0
op_assign
id|np-&gt;p_scripth
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;base2_ba
)paren
(brace
id|np-&gt;p_script
op_assign
id|pcivtobus
c_func
(paren
id|np-&gt;base2_ba
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_RAM8K
)paren
(brace
id|np-&gt;p_scripth
op_assign
id|np-&gt;p_script
op_plus
l_int|4096
suffix:semicolon
macro_line|#if BITS_PER_LONG &gt; 32
id|np-&gt;scr_ram_seg
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;base2_ba
op_rshift
l_int|32
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
id|ncr_script_copy_and_bind
(paren
id|np
comma
(paren
id|ncrcmd
op_star
)paren
op_amp
id|script0
comma
(paren
id|ncrcmd
op_star
)paren
id|np-&gt;script0
comma
r_sizeof
(paren
r_struct
id|script
)paren
)paren
suffix:semicolon
id|ncr_script_copy_and_bind
(paren
id|np
comma
(paren
id|ncrcmd
op_star
)paren
op_amp
id|scripth0
comma
(paren
id|ncrcmd
op_star
)paren
id|np-&gt;scripth0
comma
r_sizeof
(paren
r_struct
id|scripth
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Patch some variables in SCRIPTS&n;&t;*/
id|np-&gt;scripth0-&gt;pm0_data_addr
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
c_func
(paren
id|np
comma
id|pm0_data
)paren
)paren
suffix:semicolon
id|np-&gt;scripth0-&gt;pm1_data_addr
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
c_func
(paren
id|np
comma
id|pm1_data
)paren
)paren
suffix:semicolon
id|np-&gt;scripth0-&gt;script0_ba
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|np-&gt;script0
)paren
)paren
suffix:semicolon
id|np-&gt;scripth0-&gt;script0_ba64
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|np-&gt;script0
)paren
)paren
suffix:semicolon
id|np-&gt;scripth0-&gt;scripth0_ba64
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|np-&gt;scripth0
)paren
)paren
suffix:semicolon
id|np-&gt;scripth0-&gt;ram_seg64
(braket
l_int|0
)braket
op_assign
id|np-&gt;scr_ram_seg
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Prepare the idle and invalid task actions.&n;&t;*/
id|np-&gt;idletask.start
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
id|np-&gt;idletask.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|bad_i_t_l
)paren
)paren
suffix:semicolon
id|np-&gt;p_idletask
op_assign
id|vtobus
c_func
(paren
op_amp
id|np-&gt;idletask
)paren
suffix:semicolon
id|np-&gt;notask.start
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
id|np-&gt;notask.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|bad_i_t_l
)paren
)paren
suffix:semicolon
id|np-&gt;p_notask
op_assign
id|vtobus
c_func
(paren
op_amp
id|np-&gt;notask
)paren
suffix:semicolon
id|np-&gt;bad_i_t_l.start
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
id|np-&gt;bad_i_t_l.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|bad_i_t_l
)paren
)paren
suffix:semicolon
id|np-&gt;p_bad_i_t_l
op_assign
id|vtobus
c_func
(paren
op_amp
id|np-&gt;bad_i_t_l
)paren
suffix:semicolon
id|np-&gt;bad_i_t_l_q.start
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
id|np-&gt;bad_i_t_l_q.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|bad_i_t_l_q
)paren
)paren
suffix:semicolon
id|np-&gt;p_bad_i_t_l_q
op_assign
id|vtobus
c_func
(paren
op_amp
id|np-&gt;bad_i_t_l_q
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate and prepare the bad lun table.&n;&t;*/
id|np-&gt;badluntbl
op_assign
id|m_calloc
c_func
(paren
l_int|256
comma
l_string|&quot;BADLUNTBL&quot;
comma
id|MEMO_WARN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;badluntbl
)paren
r_goto
id|attach_error
suffix:semicolon
m_assert
(paren
m_offsetof
(paren
r_struct
id|lcb
comma
id|resel_task
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|np-&gt;resel_badlun
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
c_func
(paren
id|np
comma
id|bad_identify
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
id|np-&gt;badluntbl
(braket
id|i
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
op_amp
id|np-&gt;resel_badlun
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Prepare the target bus address array.&n;&t;*/
id|np-&gt;script0-&gt;targtbl
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|np-&gt;targtbl
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|np-&gt;targtbl
(braket
id|i
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
op_amp
id|np-&gt;target
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|np-&gt;target
(braket
id|i
)braket
dot
id|b_luntbl
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|np-&gt;badluntbl
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    Patch the script for LED support.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_LED0
)paren
(brace
id|np-&gt;script0-&gt;idle
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_REG_REG
c_func
(paren
id|gpreg
comma
id|SCR_OR
comma
l_int|0x01
)paren
)paren
suffix:semicolon
id|np-&gt;script0-&gt;reselected
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_REG_REG
c_func
(paren
id|gpreg
comma
id|SCR_AND
comma
l_int|0xfe
)paren
)paren
suffix:semicolon
id|np-&gt;script0-&gt;start
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_REG_REG
c_func
(paren
id|gpreg
comma
id|SCR_AND
comma
l_int|0xfe
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;DEL 472 - 53C896 Rev 1 - Part Number 609-0393055 - ITEM 5.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_NCR_53C896
op_logical_and
id|np-&gt;revision_id
op_le
l_int|0x1
op_logical_and
(paren
id|np-&gt;features
op_amp
id|FE_NOPM
)paren
)paren
(brace
id|np-&gt;scatter
op_assign
id|ncr_scatter_896R1
suffix:semicolon
macro_line|#ifndef SCSI_NCR_PROFILE_SUPPORT
DECL|macro|XXX
mdefine_line|#define XXX&t;0
macro_line|#else
mdefine_line|#define XXX&t;3
macro_line|#endif
id|np-&gt;script0-&gt;dataphase
(braket
id|XXX
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|SCR_JUMP
)paren
suffix:semicolon
id|np-&gt;script0-&gt;dataphase
(braket
id|XXX
op_plus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|tweak_pmj
)paren
)paren
suffix:semicolon
DECL|macro|XXX
macro_line|#undef XXX
)brace
r_else
macro_line|#ifdef DEBUG_896R1
id|np-&gt;scatter
op_assign
id|ncr_scatter_896R1
suffix:semicolon
macro_line|#else
id|np-&gt;scatter
op_assign
id|ncr_scatter
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Reset chip.&n;&t;**&t;We should use ncr_soft_reset(), but we donnot want to do &n;&t;**&t;so, since we may not be safe if ABRT interrupt occurs due &n;&t;**&t;to the BIOS or previous O/S having enable this interrupt.&n;&t;*/
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|UDELAY
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Now check the cache handling of the pci chipset.&n;&t;*/
r_if
c_cond
(paren
id|ncr_snooptest
(paren
id|np
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;CACHE INCORRECTLY CONFIGURED.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Install the interrupt handler.&n;&t;*/
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|device-&gt;slot.irq
comma
id|sym53c8xx_intr
comma
(paren
(paren
id|driver_setup.irqm
op_amp
l_int|0x10
)paren
ques
c_cond
l_int|0
suffix:colon
id|SA_SHIRQ
)paren
op_or
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,2,0)
(paren
(paren
id|driver_setup.irqm
op_amp
l_int|0x20
)paren
ques
c_cond
l_int|0
suffix:colon
id|SA_INTERRUPT
)paren
comma
macro_line|#else
l_int|0
comma
macro_line|#endif
id|NAME53C8XX
comma
id|np
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: request irq %d failure&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|device-&gt;slot.irq
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
id|np-&gt;irq
op_assign
id|device-&gt;slot.irq
suffix:semicolon
multiline_comment|/*&n;&t;**&t;After SCSI devices have been opened, we cannot&n;&t;**&t;reset the bus safely, so we do it here.&n;&t;**&t;Interrupt handler does the real work.&n;&t;**&t;Process the reset exception,&n;&t;**&t;if interrupts are not enabled yet.&n;&t;**&t;Then enable disconnects.&n;&t;*/
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ncr_reset_scsi_bus
c_func
(paren
id|np
comma
l_int|0
comma
id|driver_setup.settle_delay
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: FATAL ERROR: CHECK SCSI BUS - CABLES, TERMINATION, DEVICE POWER etc.!&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_goto
id|attach_error
suffix:semicolon
)brace
id|ncr_exception
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;The middle-level SCSI driver does not&n;&t;**&t;wait for devices to settle.&n;&t;**&t;Wait synchronously if more than 2 seconds.&n;&t;*/
r_if
c_cond
(paren
id|driver_setup.settle_delay
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: waiting %d seconds for scsi devices to settle...&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|driver_setup.settle_delay
)paren
suffix:semicolon
id|MDELAY
(paren
l_int|1000
op_star
id|driver_setup.settle_delay
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;start the timeout daemon&n;&t;*/
id|np-&gt;lasttime
op_assign
l_int|0
suffix:semicolon
id|ncr_timeout
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**  use SIMPLE TAG messages by default&n;&t;*/
macro_line|#ifdef SCSI_NCR_ALWAYS_SIMPLE_TAG
id|np-&gt;order
op_assign
id|M_SIMPLE_TAG
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**  Done.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|first_host
)paren
id|first_host
op_assign
id|instance
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Fill Linux host instance structure&n;&t;**&t;and return success.&n;&t;*/
id|instance-&gt;max_channel
op_assign
l_int|0
suffix:semicolon
id|instance-&gt;max_id
op_assign
id|np-&gt;maxwide
ques
c_cond
l_int|16
suffix:colon
l_int|8
suffix:semicolon
id|instance-&gt;max_lun
op_assign
id|SCSI_NCR_MAX_LUN
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
id|instance-&gt;base
op_assign
(paren
r_char
op_star
)paren
id|np-&gt;reg
suffix:semicolon
macro_line|#endif
id|instance-&gt;irq
op_assign
id|np-&gt;irq
suffix:semicolon
id|instance-&gt;unique_id
op_assign
id|np-&gt;base_io
suffix:semicolon
id|instance-&gt;io_port
op_assign
id|np-&gt;base_io
suffix:semicolon
id|instance-&gt;n_io_port
op_assign
id|np-&gt;base_ws
suffix:semicolon
id|instance-&gt;dma_channel
op_assign
l_int|0
suffix:semicolon
id|instance-&gt;select_queue_depths
op_assign
id|sym53c8xx_select_queue_depths
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Now let the generic SCSI driver&n;&t;**&t;look for the SCSI devices on the bus ..&n;&t;*/
r_return
l_int|0
suffix:semicolon
id|attach_error
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: giving up ...&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np
)paren
id|ncr_free_resources
c_func
(paren
id|np
)paren
suffix:semicolon
id|scsi_unregister
c_func
(paren
id|instance
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Free controller resources.&n;*/
DECL|function|ncr_free_resources
r_static
r_void
id|ncr_free_resources
c_func
(paren
id|ncb_p
id|np
)paren
(brace
id|ccb_p
id|cp
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
r_int
id|target
comma
id|lun
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;irq
)paren
id|free_irq
c_func
(paren
id|np-&gt;irq
comma
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;base_io
)paren
id|release_region
c_func
(paren
id|np-&gt;base_io
comma
id|np-&gt;base_ws
)paren
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
r_if
c_cond
(paren
id|np-&gt;base_va
)paren
id|unmap_pci_mem
c_func
(paren
id|np-&gt;base_va
comma
id|np-&gt;base_ws
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|np-&gt;scripth0
)paren
id|m_free
c_func
(paren
id|np-&gt;scripth0
comma
r_sizeof
(paren
r_struct
id|scripth
)paren
comma
l_string|&quot;SCRIPTH&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;script0
)paren
id|m_free
c_func
(paren
id|np-&gt;script0
comma
r_sizeof
(paren
r_struct
id|script
)paren
comma
l_string|&quot;SCRIPT&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;squeue
)paren
id|m_free
c_func
(paren
id|np-&gt;squeue
comma
r_sizeof
(paren
id|ncrcmd
)paren
op_star
(paren
id|MAX_START
op_star
l_int|2
)paren
comma
l_string|&quot;SQUEUE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;dqueue
)paren
id|m_free
c_func
(paren
id|np-&gt;dqueue
comma
r_sizeof
(paren
id|ncrcmd
)paren
op_star
(paren
id|MAX_START
op_star
l_int|2
)paren
comma
l_string|&quot;DQUEUE&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cp
op_assign
id|np-&gt;ccbc
)paren
op_ne
l_int|NULL
)paren
(brace
id|np-&gt;ccbc
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
id|m_free
c_func
(paren
id|cp
comma
r_sizeof
(paren
op_star
id|cp
)paren
comma
l_string|&quot;CCB&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|np-&gt;badluntbl
)paren
id|m_free
c_func
(paren
id|np-&gt;badluntbl
comma
l_int|256
comma
l_string|&quot;BADLUNTBL&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
OL
id|MAX_TARGET
suffix:semicolon
id|target
op_increment
)paren
(brace
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
id|MAX_LUN
suffix:semicolon
id|lun
op_increment
)paren
(brace
id|lp
op_assign
id|tp-&gt;lp
(braket
id|lun
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tasktbl
op_ne
op_amp
id|lp-&gt;tasktbl_0
)paren
id|m_free
c_func
(paren
id|lp-&gt;tasktbl
comma
l_int|256
comma
l_string|&quot;TASKTBL&quot;
)paren
suffix:semicolon
id|m_free
c_func
(paren
id|lp
comma
r_sizeof
(paren
op_star
id|lp
)paren
comma
l_string|&quot;LCB&quot;
)paren
suffix:semicolon
)brace
)brace
id|m_free
c_func
(paren
id|np
comma
r_sizeof
(paren
op_star
id|np
)paren
comma
l_string|&quot;NCB&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Done SCSI commands list management.&n;**&n;**&t;We donnot enter the scsi_done() callback immediately &n;**&t;after a command has been seen as completed but we &n;**&t;insert it into a list which is flushed outside any kind &n;**&t;of driver critical section.&n;**&t;This allows to do minimal stuff under interrupt and &n;**&t;inside critical sections and to also avoid locking up &n;**&t;on recursive calls to driver entry points under SMP.&n;**&t;In fact, the only kernel point which is entered by the &n;**&t;driver with a driver lock set is get_free_pages(GFP_ATOMIC...) &n;**&t;that shall not reenter the driver under any circumstance.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_queue_done_cmd
r_static
r_inline
r_void
id|ncr_queue_done_cmd
c_func
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|cmd-&gt;host_scribble
op_assign
(paren
r_char
op_star
)paren
id|np-&gt;done_list
suffix:semicolon
id|np-&gt;done_list
op_assign
id|cmd
suffix:semicolon
)brace
DECL|function|ncr_flush_done_cmds
r_static
r_inline
r_void
id|ncr_flush_done_cmds
c_func
(paren
id|Scsi_Cmnd
op_star
id|lcmd
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_while
c_loop
(paren
id|lcmd
)paren
(brace
id|cmd
op_assign
id|lcmd
suffix:semicolon
id|lcmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;host_scribble
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Start execution of a SCSI command.&n;**&t;This is called from the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_queue_command
r_static
r_int
id|ncr_queue_command
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/*&t;Scsi_Device        *device    = cmd-&gt;device; */
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cmd-&gt;target
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|tp-&gt;lp
(braket
id|cmd-&gt;lun
)braket
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
r_int
id|segments
suffix:semicolon
id|u_char
id|nego
comma
id|idmsg
comma
op_star
id|msgptr
suffix:semicolon
id|u_int
id|msglen
suffix:semicolon
r_int
id|direction
suffix:semicolon
id|u_int32
id|lastp
comma
id|goalp
suffix:semicolon
multiline_comment|/*---------------------------------------------&n;&t;**&n;&t;**      Some shortcuts ...&n;&t;**&n;&t;**---------------------------------------------&n;&t;*/
r_if
c_cond
(paren
(paren
id|cmd-&gt;target
op_eq
id|np-&gt;myaddr
)paren
op_logical_or
(paren
id|cmd-&gt;target
op_ge
id|MAX_TARGET
)paren
op_logical_or
(paren
id|cmd-&gt;lun
op_ge
id|MAX_LUN
)paren
)paren
(brace
r_return
id|DID_BAD_TARGET
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------&n;&t;**&n;&t;**&t;Complete the 1st TEST UNIT READY command&n;&t;**&t;with error condition if the device is &n;&t;**&t;flagged NOSCAN, in order to speed up &n;&t;**&t;the boot.&n;&t;**&n;&t;**---------------------------------------------&n;&t;*/
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_and
(paren
id|tp-&gt;usrflag
op_amp
id|UF_NOSCAN
)paren
)paren
(brace
id|tp-&gt;usrflag
op_and_assign
op_complement
id|UF_NOSCAN
suffix:semicolon
r_return
id|DID_BAD_TARGET
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;CMD=%x &quot;
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;Assign a ccb / bind cmd.&n;&t;**&t;If resetting, shorten settle_time if necessary&n;&t;**&t;in order to avoid spurious timeouts.&n;&t;**&t;If resetting or no free ccb,&n;&t;**&t;insert cmd into the waiting list.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;settle_time
op_logical_and
id|cmd-&gt;timeout_per_command
op_ge
id|HZ
op_logical_and
id|np-&gt;settle_time
OG
id|jiffies
op_plus
id|cmd-&gt;timeout_per_command
op_minus
id|HZ
)paren
(brace
id|np-&gt;settle_time
op_assign
id|jiffies
op_plus
id|cmd-&gt;timeout_per_command
op_minus
id|HZ
suffix:semicolon
)brace
r_if
c_cond
(paren
id|np-&gt;settle_time
op_logical_or
op_logical_neg
(paren
id|cp
op_assign
id|ncr_get_ccb
(paren
id|np
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
)paren
)paren
(brace
id|insert_into_waiting_list
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_return
id|DID_OK
suffix:semicolon
)brace
id|cp-&gt;cmd
op_assign
id|cmd
suffix:semicolon
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;Enable tagged queue if asked by scsi ioctl&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
macro_line|#if 0&t;/* This stuff was only usefull for linux-1.2.13 */
r_if
c_cond
(paren
id|lp
op_logical_and
op_logical_neg
id|lp-&gt;numtags
op_logical_and
id|cmd-&gt;device
op_logical_and
id|cmd-&gt;device-&gt;tagged_queue
)paren
(brace
id|lp-&gt;numtags
op_assign
id|tp-&gt;usrtags
suffix:semicolon
id|ncr_setup_tags
(paren
id|np
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|cp-&gt;phys.num_disc
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*---------------------------------------------------&n;&t;**&n;&t;**&t;negotiation required?&n;&t;**&n;&t;**---------------------------------------------------&n;&t;*/
id|nego
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|tp-&gt;widedone
op_logical_or
op_logical_neg
id|tp-&gt;period
)paren
op_logical_and
op_logical_neg
id|tp-&gt;nego_cp
op_logical_and
id|tp-&gt;inq_done
op_logical_and
id|lp
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;negotiate wide transfers ?&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;widedone
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;inq_byte7
op_amp
id|INQ7_WIDE16
)paren
(brace
id|nego
op_assign
id|NS_WIDE
suffix:semicolon
)brace
r_else
id|tp-&gt;widedone
op_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;negotiate synchronous transfers?&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|nego
op_logical_and
op_logical_neg
id|tp-&gt;period
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;inq_byte7
op_amp
id|INQ7_SYNC
)paren
(brace
id|nego
op_assign
id|NS_SYNC
suffix:semicolon
)brace
r_else
(brace
id|tp-&gt;period
op_assign
l_int|0xffff
suffix:semicolon
id|PRINT_TARGET
c_func
(paren
id|np
comma
id|cp-&gt;target
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;target did not report SYNC.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;remember nego is pending for the target.&n;&t;&t;**&t;Avoid to start a nego for all queued commands &n;&t;&t;**&t;when tagged command queuing is enabled.&n;&t;&t;*/
r_if
c_cond
(paren
id|nego
)paren
id|tp-&gt;nego_cp
op_assign
id|cp
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Build the identify / tag / sdtr message&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
id|idmsg
op_assign
id|M_IDENTIFY
op_or
id|cp-&gt;lun
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_member_access_from_pointer
id|tag
op_ne
id|NO_TAG
op_logical_or
(paren
id|lp
op_logical_and
op_logical_neg
(paren
id|tp-&gt;usrflag
op_amp
id|UF_NODISC
)paren
)paren
)paren
id|idmsg
op_or_assign
l_int|0x40
suffix:semicolon
id|msgptr
op_assign
id|cp-&gt;scsi_smsg
suffix:semicolon
id|msglen
op_assign
l_int|0
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|idmsg
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;tag
op_ne
id|NO_TAG
)paren
(brace
r_char
id|order
op_assign
id|np-&gt;order
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Force ordered tag if necessary to avoid timeouts &n;&t;&t;**&t;and to preserve interactivity.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp
op_logical_and
id|lp-&gt;tags_stime
op_plus
(paren
l_int|3
op_star
id|HZ
)paren
op_le
id|jiffies
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;tags_smap
)paren
(brace
id|order
op_assign
id|M_ORDERED_TAG
suffix:semicolon
r_if
c_cond
(paren
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
op_logical_or
id|bootverbose
OG
l_int|2
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ordered tag forced.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|lp-&gt;tags_stime
op_assign
id|jiffies
suffix:semicolon
id|lp-&gt;tags_smap
op_assign
id|lp-&gt;tags_umap
suffix:semicolon
)brace
r_if
c_cond
(paren
id|order
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;**&t;Ordered write ops, unordered read ops.&n;&t;&t;&t;*/
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/* READ_SMALL (6) */
r_case
l_int|0x28
suffix:colon
multiline_comment|/* READ_BIG  (10) */
r_case
l_int|0xa8
suffix:colon
multiline_comment|/* READ_HUGE (12) */
id|order
op_assign
id|M_SIMPLE_TAG
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|order
op_assign
id|M_ORDERED_TAG
suffix:semicolon
)brace
)brace
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|order
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Actual tags are numbered 1,3,5,..2*MAXTAGS+1,&n;&t;&t;**&t;since we may have to deal with devices that have &n;&t;&t;**&t;problems with #TAG 0 or too great #TAG numbers.&n;&t;&t;*/
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
(paren
id|cp-&gt;tag
op_lshift
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|nego
)paren
(brace
r_case
id|NS_SYNC
suffix:colon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|3
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_SYNC_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;maxoffs
ques
c_cond
id|tp-&gt;minsync
suffix:colon
l_int|0
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;maxoffs
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;sync msgout: &quot;
)paren
suffix:semicolon
id|ncr_show_msg
(paren
op_amp
id|cp-&gt;scsi_smsg
(braket
id|msglen
op_minus
l_int|5
)braket
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|2
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_WIDE_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;usrwide
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;wide msgout: &quot;
)paren
suffix:semicolon
id|ncr_show_msg
(paren
op_amp
id|cp-&gt;scsi_smsg
(braket
id|msglen
op_minus
l_int|4
)braket
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|cp-&gt;host_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Build the data descriptors&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
id|segments
op_assign
id|np-&gt;scatter
(paren
id|cp
comma
id|cp-&gt;cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|segments
OL
l_int|0
)paren
(brace
id|ncr_free_ccb
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_return
id|DID_ERROR
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Determine xfer direction.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;data_len
)paren
id|direction
op_assign
l_int|0
suffix:semicolon
r_else
(brace
r_switch
c_cond
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/*&t;READ(6)&t;&t;&t;&t;08 */
r_case
l_int|0x28
suffix:colon
multiline_comment|/*&t;READ(10)&t;&t;&t;28 */
r_case
l_int|0xA8
suffix:colon
multiline_comment|/*&t;READ(12)&t;&t;&t;A8 */
id|direction
op_assign
id|XFER_IN
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0A
suffix:colon
multiline_comment|/*&t;WRITE(6)&t;&t;&t;0A */
r_case
l_int|0x2A
suffix:colon
multiline_comment|/*&t;WRITE(10)&t;&t;&t;2A */
r_case
l_int|0xAA
suffix:colon
multiline_comment|/*&t;WRITE(12)&t;&t;&t;AA */
id|direction
op_assign
id|XFER_OUT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|direction
op_assign
(paren
id|XFER_IN
op_or
id|XFER_OUT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Set the DATA POINTER.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
multiline_comment|/*&n;&t;**&t;Default to no data transfer.&n;&t;*/
id|lastp
op_assign
id|goalp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|no_data
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Compute data out pointers, if needed.&n;&t;*/
r_if
c_cond
(paren
id|direction
op_amp
id|XFER_OUT
)paren
(brace
id|goalp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|data_out2
)paren
op_plus
l_int|8
suffix:semicolon
macro_line|#if&t;MAX_SCATTERH != 0
r_if
c_cond
(paren
id|segments
op_le
id|MAX_SCATTERL
)paren
id|lastp
op_assign
id|goalp
op_minus
l_int|8
op_minus
(paren
id|segments
op_star
(paren
id|SCR_SG_SIZE
op_star
l_int|4
)paren
)paren
suffix:semicolon
r_else
(brace
id|lastp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|hdata_out2
)paren
suffix:semicolon
id|lastp
op_sub_assign
(paren
id|segments
op_minus
id|MAX_SCATTERL
)paren
op_star
(paren
id|SCR_SG_SIZE
op_star
l_int|4
)paren
suffix:semicolon
)brace
macro_line|#else
id|lastp
op_assign
id|goalp
op_minus
l_int|8
op_minus
(paren
id|segments
op_star
(paren
id|SCR_SG_SIZE
op_star
l_int|4
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;**&t;If actual data direction is unknown, save pointers &n;&t;&t;**&t;in header. The SCRIPTS will swap them to current &n;&t;&t;**&t;if target decision will be data out.&n;&t;&t;*/
r_if
c_cond
(paren
id|direction
op_amp
id|XFER_IN
)paren
(brace
id|cp-&gt;phys.header.wgoalp
op_assign
id|cpu_to_scr
c_func
(paren
id|goalp
)paren
suffix:semicolon
id|cp-&gt;phys.header.wlastp
op_assign
id|cpu_to_scr
c_func
(paren
id|lastp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;Compute data in pointers, if needed.&n;&t;*/
r_if
c_cond
(paren
id|direction
op_amp
id|XFER_IN
)paren
(brace
id|goalp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|data_in2
)paren
op_plus
l_int|8
suffix:semicolon
macro_line|#if&t;MAX_SCATTERH != 0
r_if
c_cond
(paren
id|segments
op_le
id|MAX_SCATTERL
)paren
id|lastp
op_assign
id|goalp
op_minus
l_int|8
op_minus
(paren
id|segments
op_star
(paren
id|SCR_SG_SIZE
op_star
l_int|4
)paren
)paren
suffix:semicolon
r_else
(brace
id|lastp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|hdata_in2
)paren
suffix:semicolon
id|lastp
op_sub_assign
(paren
id|segments
op_minus
id|MAX_SCATTERL
)paren
op_star
(paren
id|SCR_SG_SIZE
op_star
l_int|4
)paren
suffix:semicolon
)brace
macro_line|#else
id|lastp
op_assign
id|goalp
op_minus
l_int|8
op_minus
(paren
id|segments
op_star
(paren
id|SCR_SG_SIZE
op_star
l_int|4
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t;**&t;Set all pointers values needed by SCRIPTS.&n;&t;**&t;If direction is unknown, start at data_io.&n;&t;*/
id|cp-&gt;phys.header.lastp
op_assign
id|cpu_to_scr
c_func
(paren
id|lastp
)paren
suffix:semicolon
id|cp-&gt;phys.header.goalp
op_assign
id|cpu_to_scr
c_func
(paren
id|goalp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|direction
op_amp
(paren
id|XFER_IN
op_or
id|XFER_OUT
)paren
)paren
op_eq
(paren
id|XFER_IN
op_or
id|XFER_OUT
)paren
)paren
id|cp-&gt;phys.header.savep
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|data_io
)paren
)paren
suffix:semicolon
r_else
id|cp-&gt;phys.header.savep
op_assign
id|cpu_to_scr
c_func
(paren
id|lastp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Save the initial data pointer in order to be able &n;&t;**&t;to redo the command.&n;&t;*/
id|cp-&gt;startp
op_assign
id|cp-&gt;phys.header.savep
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;fill in ccb&n;&t;**&n;&t;**----------------------------------------------------&n;&t;**&n;&t;**&n;&t;**&t;physical -&gt; virtual backlink&n;&t;**&t;Generic SCSI command&n;&t;*/
multiline_comment|/*&n;&t;**&t;Startqueue&n;&t;*/
id|cp-&gt;phys.header.go.start
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|select
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.header.go.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|resel_dsa
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;select&n;&t;*/
id|cp-&gt;phys.select.sel_id
op_assign
id|cp-&gt;target
suffix:semicolon
id|cp-&gt;phys.select.sel_scntl3
op_assign
id|tp-&gt;wval
suffix:semicolon
id|cp-&gt;phys.select.sel_sxfer
op_assign
id|tp-&gt;sval
suffix:semicolon
multiline_comment|/*&n;&t;**&t;message&n;&t;*/
id|cp-&gt;phys.smsg.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|scsi_smsg
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.smsg.size
op_assign
id|cpu_to_scr
c_func
(paren
id|msglen
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;command&n;&t;*/
id|cp-&gt;phys.cmd.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
(paren
op_amp
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.cmd.size
op_assign
id|cpu_to_scr
c_func
(paren
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;status&n;&t;*/
id|cp-&gt;actualquirks
op_assign
id|tp-&gt;quirks
suffix:semicolon
id|cp-&gt;host_status
op_assign
id|nego
ques
c_cond
id|HS_NEGOTIATE
suffix:colon
id|HS_BUSY
suffix:semicolon
id|cp-&gt;scsi_status
op_assign
id|S_ILLEGAL
suffix:semicolon
id|cp-&gt;xerr_status
op_assign
id|XE_OK
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|nego
suffix:semicolon
multiline_comment|/*----------------------------------------------------&n;&t;**&n;&t;**&t;Critical region: start this job.&n;&t;**&n;&t;**----------------------------------------------------&n;&t;*/
multiline_comment|/*&n;&t;**&t;activate this job.&n;&t;*/
multiline_comment|/* Compute a time limit greater than the middle-level driver one */
r_if
c_cond
(paren
id|cmd-&gt;timeout_per_command
OG
l_int|0
)paren
id|cp-&gt;tlimit
op_assign
id|jiffies
op_plus
id|cmd-&gt;timeout_per_command
op_plus
id|HZ
suffix:semicolon
r_else
id|cp-&gt;tlimit
op_assign
id|jiffies
op_plus
l_int|86400
op_star
id|HZ
suffix:semicolon
multiline_comment|/* No timeout=24 hours */
multiline_comment|/*&n;&t;**&t;insert next CCBs into start queue.&n;&t;**&t;2 max at a time is enough to flush the CCB wait queue.&n;&t;*/
id|cp-&gt;auto_sense
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lp
)paren
id|ncr_start_next_ccb
c_func
(paren
id|np
comma
id|lp
comma
l_int|2
)paren
suffix:semicolon
r_else
id|ncr_put_start_queue
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Command is successfully queued.&n;&t;*/
r_return
id|DID_OK
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Insert a CCB into the start queue and wake up the &n;**&t;SCRIPTS processor.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_start_next_ccb
r_static
r_void
id|ncr_start_next_ccb
c_func
(paren
id|ncb_p
id|np
comma
id|lcb_p
id|lp
comma
r_int
id|maxn
)paren
(brace
id|XPT_QUEHEAD
op_star
id|qp
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
r_while
c_loop
(paren
id|maxn
op_decrement
op_logical_and
id|lp-&gt;queuedccbs
OL
id|lp-&gt;queuedepth
)paren
(brace
id|qp
op_assign
id|xpt_remque_head
c_func
(paren
op_amp
id|lp-&gt;wait_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qp
)paren
r_break
suffix:semicolon
op_increment
id|lp-&gt;queuedccbs
suffix:semicolon
id|cp
op_assign
id|xpt_que_entry
c_func
(paren
id|qp
comma
r_struct
id|ccb
comma
id|link_ccbq
)paren
suffix:semicolon
id|xpt_insque_tail
c_func
(paren
id|qp
comma
op_amp
id|lp-&gt;busy_ccbq
)paren
suffix:semicolon
id|lp-&gt;tasktbl
(braket
id|cp-&gt;tag
op_eq
id|NO_TAG
ques
c_cond
l_int|0
suffix:colon
id|cp-&gt;tag
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|cp-&gt;p_ccb
)paren
suffix:semicolon
id|ncr_put_start_queue
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
)brace
)brace
DECL|function|ncr_put_start_queue
r_static
r_void
id|ncr_put_start_queue
c_func
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
id|u_short
id|qidx
suffix:semicolon
multiline_comment|/*&n;&t;**&t;insert into start queue.&n;&t;*/
id|qidx
op_assign
id|np-&gt;squeueput
op_plus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|qidx
op_ge
id|MAX_START
op_star
l_int|2
)paren
id|qidx
op_assign
l_int|0
suffix:semicolon
id|np-&gt;squeue
(braket
id|qidx
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;p_idletask
)paren
suffix:semicolon
id|MEMORY_BARRIER
c_func
(paren
)paren
suffix:semicolon
id|np-&gt;squeue
(braket
id|np-&gt;squeueput
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|cp-&gt;p_ccb
)paren
suffix:semicolon
id|np-&gt;squeueput
op_assign
id|qidx
suffix:semicolon
id|cp-&gt;queued
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_QUEUE
)paren
id|printk
(paren
l_string|&quot;%s: queuepos=%d.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|np-&gt;squeueput
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Script processor may be waiting for reselect.&n;&t;**&t;Wake it up.&n;&t;*/
id|MEMORY_BARRIER
c_func
(paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Soft reset the chip.&n;**&n;**&t;Some 896 and 876 chip revisions may hang-up if we set &n;**&t;the SRST (soft reset) bit at the wrong time when SCRIPTS &n;**&t;are running.&n;**&t;So, we need to abort the current operation prior to &n;**&t;soft resetting the chip.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_soft_reset
r_static
r_void
id|ncr_soft_reset
c_func
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|istat
suffix:semicolon
r_int
id|i
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|CABRT
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1000000
suffix:semicolon
id|i
suffix:semicolon
op_decrement
id|i
)paren
(brace
id|istat
op_assign
id|INB
(paren
id|nc_istat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|istat
op_amp
id|SIP
)paren
(brace
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|istat
op_amp
id|DIP
)paren
(brace
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
id|INB
(paren
id|nc_dstat
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;%s: unable to abort current chip operation.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|UDELAY
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Start reset process.&n;**&t;If reset in progress do nothing.&n;**&t;The interrupt handler will reinitialize the chip.&n;**&t;The timeout handler will wait for settle_time before &n;**&t;clearing it and so resuming command processing.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_start_reset
r_static
r_void
id|ncr_start_reset
c_func
(paren
id|ncb_p
id|np
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;settle_time
)paren
(brace
(paren
r_void
)paren
id|ncr_reset_scsi_bus
c_func
(paren
id|np
comma
l_int|1
comma
id|driver_setup.settle_delay
)paren
suffix:semicolon
)brace
)brace
DECL|function|ncr_reset_scsi_bus
r_static
r_int
id|ncr_reset_scsi_bus
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|enab_int
comma
r_int
id|settle_delay
)paren
(brace
id|u_int32
id|term
suffix:semicolon
r_int
id|retv
op_assign
l_int|0
suffix:semicolon
id|np-&gt;settle_time
op_assign
id|jiffies
op_plus
id|settle_delay
op_star
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: resetting, &quot;
l_string|&quot;command processing suspended for %d seconds&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|settle_delay
)paren
suffix:semicolon
id|ncr_soft_reset
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/* Soft reset the chip */
id|UDELAY
(paren
l_int|2000
)paren
suffix:semicolon
multiline_comment|/* The 895/6 need time for the bus mode to settle */
r_if
c_cond
(paren
id|enab_int
)paren
id|OUTW
(paren
id|nc_sien
comma
id|RST
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Enable Tolerant, reset IRQD if present and &n;&t;**&t;properly set IRQ mode, prior to resetting the bus.&n;&t;*/
id|OUTB
(paren
id|nc_stest3
comma
id|TE
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_dcntl
comma
(paren
id|np-&gt;rv_dcntl
op_amp
id|IRQM
)paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_scntl1
comma
id|CRST
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|200
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver_setup.bus_check
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Check for no terminators or SCSI bus shorts to ground.&n;&t;**&t;Read SCSI data bus, data parity bits and control signals.&n;&t;**&t;We are expecting RESET to be TRUE and other signals to be &n;&t;**&t;FALSE.&n;&t;*/
id|term
op_assign
id|INB
c_func
(paren
id|nc_sstat0
)paren
suffix:semicolon
multiline_comment|/* rst, sdp0 */
id|term
op_assign
(paren
(paren
id|term
op_amp
l_int|2
)paren
op_lshift
l_int|7
)paren
op_plus
(paren
(paren
id|term
op_amp
l_int|1
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|term
op_or_assign
(paren
(paren
id|INB
c_func
(paren
id|nc_sstat2
)paren
op_amp
l_int|0x01
)paren
op_lshift
l_int|25
)paren
op_or
multiline_comment|/* sdp1 */
(paren
id|INW
c_func
(paren
id|nc_sbdl
)paren
op_lshift
l_int|9
)paren
op_or
multiline_comment|/* d15-0 */
id|INB
c_func
(paren
id|nc_sbcl
)paren
suffix:semicolon
multiline_comment|/* req, ack, bsy, sel, atn, msg, cd, io */
r_if
c_cond
(paren
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_WIDE
)paren
)paren
id|term
op_and_assign
l_int|0x3ffff
suffix:semicolon
r_if
c_cond
(paren
id|term
op_ne
(paren
l_int|2
op_lshift
l_int|7
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: suspicious SCSI data while resetting the BUS.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %sdp0,d7-0,rst,req,ack,bsy,sel,atn,msg,c/d,i/o = &quot;
l_string|&quot;0x%lx, expecting 0x%lx&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|np-&gt;features
op_amp
id|FE_WIDE
)paren
ques
c_cond
l_string|&quot;dp1,d15-8,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|u_long
)paren
id|term
comma
(paren
id|u_long
)paren
(paren
l_int|2
op_lshift
l_int|7
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.bus_check
op_eq
l_int|1
)paren
id|retv
op_assign
l_int|1
suffix:semicolon
)brace
id|out
suffix:colon
id|OUTB
(paren
id|nc_scntl1
comma
l_int|0
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Reset the SCSI BUS.&n;**&t;This is called from the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_reset_bus
r_static
r_int
id|ncr_reset_bus
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|sync_reset
)paren
(brace
multiline_comment|/*&t;Scsi_Device        *device    = cmd-&gt;device; */
id|ccb_p
id|cp
suffix:semicolon
r_int
id|found
suffix:semicolon
multiline_comment|/*&n; * Return immediately if reset is in progress.&n; */
r_if
c_cond
(paren
id|np-&gt;settle_time
)paren
(brace
r_return
id|SCSI_RESET_PUNT
suffix:semicolon
)brace
multiline_comment|/*&n; * Start the reset process.&n; * The script processor is then assumed to be stopped.&n; * Commands will now be queued in the waiting list until a settle &n; * delay of 2 seconds will be completed.&n; */
id|ncr_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n; * First, look in the wakeup list&n; */
r_for
c_loop
(paren
id|found
op_assign
l_int|0
comma
id|cp
op_assign
id|np-&gt;ccbc
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;look for the ccb of this command.&n;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_IDLE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cmd
op_eq
id|cmd
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Then, look in the waiting list&n; */
r_if
c_cond
(paren
op_logical_neg
id|found
op_logical_and
id|retrieve_from_waiting_list
c_func
(paren
l_int|0
comma
id|np
comma
id|cmd
)paren
)paren
id|found
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Wake-up all awaiting commands with DID_RESET.&n; */
id|reset_waiting_list
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n; * Wake-up all pending commands with HS_RESET -&gt; DID_RESET.&n; */
id|ncr_wakeup
c_func
(paren
id|np
comma
id|HS_RESET
)paren
suffix:semicolon
multiline_comment|/*&n; * If the involved command was not in a driver queue, and the &n; * scsi driver told us reset is synchronous, and the command is not &n; * currently in the waiting list, complete it with DID_RESET status,&n; * in order to keep it alive.&n; */
r_if
c_cond
(paren
op_logical_neg
id|found
op_logical_and
id|sync_reset
op_logical_and
op_logical_neg
id|retrieve_from_waiting_list
c_func
(paren
l_int|0
comma
id|np
comma
id|cmd
)paren
)paren
(brace
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|DID_RESET
comma
l_int|0
)paren
suffix:semicolon
id|ncr_queue_done_cmd
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
)brace
r_return
id|SCSI_RESET_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Abort an SCSI command.&n;**&t;This is called from the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_abort_command
r_static
r_int
id|ncr_abort_command
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/*&t;Scsi_Device        *device    = cmd-&gt;device; */
id|ccb_p
id|cp
suffix:semicolon
r_int
id|found
suffix:semicolon
r_int
id|retv
suffix:semicolon
multiline_comment|/*&n; * First, look for the scsi command in the waiting list&n; */
r_if
c_cond
(paren
id|remove_from_waiting_list
c_func
(paren
id|np
comma
id|cmd
)paren
)paren
(brace
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|DID_ABORT
comma
l_int|0
)paren
suffix:semicolon
id|ncr_queue_done_cmd
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Then, look in the wakeup list&n; */
r_for
c_loop
(paren
id|found
op_assign
l_int|0
comma
id|cp
op_assign
id|np-&gt;ccbc
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;look for the ccb of this command.&n;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_IDLE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cmd
op_eq
id|cmd
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
r_return
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
)brace
r_if
c_cond
(paren
id|np-&gt;settle_time
)paren
(brace
r_return
id|SCSI_ABORT_SNOOZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If the CCB is active, patch schedule jumps for the &n;&t;**&t;script to abort the command.&n;&t;*/
id|cp-&gt;tlimit
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;host_status
)paren
(brace
r_case
id|HS_BUSY
suffix:colon
r_case
id|HS_NEGOTIATE
suffix:colon
id|printk
(paren
l_string|&quot;%s: abort ccb=%p (cancel)&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|cp
)paren
suffix:semicolon
id|cp-&gt;phys.header.go.start
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|cancel
)paren
)paren
suffix:semicolon
id|retv
op_assign
id|SCSI_ABORT_PENDING
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HS_DISCONNECT
suffix:colon
id|cp-&gt;phys.header.go.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|bad_i_t_l_q
)paren
)paren
suffix:semicolon
id|retv
op_assign
id|SCSI_ABORT_PENDING
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|retv
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**      If there are no requests, the script&n;&t;**      processor will sleep on SEL_WAIT_RESEL.&n;&t;**      Let&squot;s wake it up, since it may have to work.&n;&t;*/
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Linux release module stuff.&n;**&n;**&t;Called before unloading the module&n;**&t;Detach the host.&n;**&t;We have to free resources and halt the NCR chip&n;**&n;**==========================================================&n;*/
macro_line|#ifdef MODULE
DECL|function|ncr_detach
r_static
r_int
id|ncr_detach
c_func
(paren
id|ncb_p
id|np
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: detaching ...&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;**&t;Stop the ncr_timeout process&n;**&t;Set release_stage to 1 and wait that ncr_timeout() set it to 2.&n;*/
id|np-&gt;release_stage
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|50
suffix:semicolon
id|i
op_logical_and
id|np-&gt;release_stage
op_ne
l_int|2
suffix:semicolon
id|i
op_decrement
)paren
id|MDELAY
(paren
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;release_stage
op_ne
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;%s: the timer seems to be already stopped&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_else
id|np-&gt;release_stage
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;**&t;Reset NCR chip.&n;**&t;We should use ncr_soft_reset(), but we donnot want to do &n;**&t;so, since we may not be safe if interrupts occur.&n;*/
id|printk
c_func
(paren
l_string|&quot;%s: resetting chip&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|100
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;**&t;Restore bios setting for automatic clock detection.&n;*/
id|OUTB
c_func
(paren
id|nc_dmode
comma
id|np-&gt;sv_dmode
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_dcntl
comma
id|np-&gt;sv_dcntl
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_ctest3
comma
id|np-&gt;sv_ctest3
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_ctest4
comma
id|np-&gt;sv_ctest4
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_ctest5
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_gpcntl
comma
id|np-&gt;sv_gpcntl
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest2
comma
id|np-&gt;sv_stest2
)paren
suffix:semicolon
id|ncr_selectclock
c_func
(paren
id|np
comma
id|np-&gt;sv_scntl3
)paren
suffix:semicolon
multiline_comment|/*&n;**&t;Free host resources&n;*/
id|ncr_free_resources
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Complete execution of a SCSI command.&n;**&t;Signal completion to the generic SCSI driver.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_complete
r_void
id|ncr_complete
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Sanity check&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|cp
op_logical_or
op_logical_neg
id|cp-&gt;cmd
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Gather profiling data&n;&t;*/
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|ncb_profile
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;CCB=%lx STAT=%x/%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cp
comma
id|cp-&gt;host_status
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Get command, target and lun pointers.&n;&t;*/
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
id|cp-&gt;cmd
op_assign
l_int|NULL
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
id|lp
op_assign
id|tp-&gt;lp
(braket
id|cp-&gt;lun
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;We donnot queue more than 1 ccb per target &n;&t;**&t;with negotiation at any time. If this ccb was &n;&t;**&t;used for negotiation, clear this info in the tcb.&n;&t;*/
r_if
c_cond
(paren
id|cp
op_eq
id|tp-&gt;nego_cp
)paren
id|tp-&gt;nego_cp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If auto-sense performed, change scsi status.&n;&t;*/
r_if
c_cond
(paren
id|cp-&gt;auto_sense
)paren
(brace
id|cp-&gt;scsi_status
op_assign
id|cp-&gt;auto_sense
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Check for parity errors.&n;&t;*/
r_if
c_cond
(paren
id|cp-&gt;host_flags
op_amp
id|HF_PAR_ERR
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;unrecovered SCSI parity error.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
id|cp-&gt;host_status
op_assign
id|HS_FAIL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Check for extended errors.&n;&t;*/
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_ne
id|XE_OK
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;xerr_status
)paren
(brace
r_case
id|XE_EXTRA_DATA
suffix:colon
id|printk
(paren
l_string|&quot;extraneous data discarded.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XE_BAD_PHASE
suffix:colon
id|printk
(paren
l_string|&quot;illegal scsi phase (4/5).&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;extended error %d.&bslash;n&quot;
comma
id|cp-&gt;xerr_status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
id|cp-&gt;host_status
op_assign
id|HS_FAIL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Print out any error for debugging purpose.&n;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
(paren
id|DEBUG_RESULT
op_or
id|DEBUG_TINY
)paren
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_ne
id|HS_COMPLETE
op_logical_or
id|cp-&gt;scsi_status
op_ne
id|S_GOOD
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ERROR: cmd=%x host_status=%x scsi_status=%x&bslash;n&quot;
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|cp-&gt;host_status
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;Check the status.&n;&t;*/
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_GOOD
op_logical_or
id|cp-&gt;scsi_status
op_eq
id|S_COND_MET
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;All went well (GOOD status).&n;&t;&t;**&t;CONDITION MET status is returned on &n;                **&t;`Pre-Fetch&squot; or `Search data&squot; success.&n;                */
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|DID_OK
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;@RESID@&n;&t;&t;**&t;Could dig out the correct value for resid,&n;&t;&t;**&t;but it would be quite complicated.&n;&t;&t;*/
multiline_comment|/* if (cp-&gt;phys.header.lastp != cp-&gt;phys.header.goalp) */
multiline_comment|/*&n;&t;&t;**&t;Allocate the lcb if not yet.&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
id|ncr_alloc_lcb
(paren
id|np
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;On standard INQUIRY response (EVPD and CmDt &n;&t;&t;**&t;not set), setup logical unit according to &n;&t;&t;**&t;announced capabilities (we need the 1rst 7 bytes).&n;&t;&t;*/
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0x12
op_logical_and
op_logical_neg
(paren
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
op_amp
l_int|0x3
)paren
op_logical_and
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
op_ge
l_int|7
op_logical_and
op_logical_neg
id|cmd-&gt;use_sg
)paren
(brace
id|ncr_setup_lcb
(paren
id|np
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
comma
(paren
r_char
op_star
)paren
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
)brace
id|tp-&gt;bytes
op_add_assign
id|cp-&gt;data_len
suffix:semicolon
id|tp-&gt;transfers
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;If tags was reduced due to queue full,&n;&t;&t;**&t;increase tags if 1000 good status received.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp
op_logical_and
id|lp-&gt;usetags
op_logical_and
id|lp-&gt;numtags
OL
id|lp-&gt;maxtags
)paren
(brace
op_increment
id|lp-&gt;num_good
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;num_good
op_ge
l_int|1000
)paren
(brace
id|lp-&gt;num_good
op_assign
l_int|0
suffix:semicolon
op_increment
id|lp-&gt;numtags
suffix:semicolon
id|ncr_setup_tags
(paren
id|np
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_CHECK_COND
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Check condition code&n;&t;&t;*/
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|DID_OK
comma
id|S_CHECK_COND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
(paren
id|DEBUG_RESULT
op_or
id|DEBUG_TINY
)paren
)paren
(brace
id|u_char
op_star
id|p
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|cmd-&gt;sense_buffer
suffix:semicolon
r_int
id|i
suffix:semicolon
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;sense data:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|14
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot; %x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
op_logical_and
(paren
id|cp-&gt;scsi_status
op_eq
id|S_BUSY
op_logical_or
id|cp-&gt;scsi_status
op_eq
id|S_QUEUE_FULL
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Target is busy.&n;&t;&t;*/
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|DID_OK
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|cp-&gt;host_status
op_eq
id|HS_SEL_TIMEOUT
)paren
op_logical_or
(paren
id|cp-&gt;host_status
op_eq
id|HS_TIMEOUT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**   No response&n;&t;&t;*/
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|DID_TIME_OUT
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_RESET
)paren
(brace
multiline_comment|/*&n;&t;&t;**   SCSI bus reset&n;&t;&t;*/
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|DID_RESET
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_ABORTED
)paren
(brace
multiline_comment|/*&n;&t;&t;**   Transfer aborted&n;&t;&t;*/
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|DID_ABORT
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;**  Other protocol messes&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;COMMAND FAILED (%x %x) @%p.&bslash;n&quot;
comma
id|cp-&gt;host_status
comma
id|cp-&gt;scsi_status
comma
id|cp
)paren
suffix:semicolon
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|DID_ERROR
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;trace output&n;&t;*/
r_if
c_cond
(paren
id|tp-&gt;usrflag
op_amp
id|UF_TRACE
)paren
(brace
id|u_char
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot; CMD:&quot;
)paren
suffix:semicolon
id|p
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot; %x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
(brace
r_switch
c_cond
(paren
id|cp-&gt;scsi_status
)paren
(brace
r_case
id|S_GOOD
suffix:colon
id|printk
(paren
l_string|&quot;  GOOD&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_CHECK_COND
suffix:colon
id|printk
(paren
l_string|&quot;  SENSE:&quot;
)paren
suffix:semicolon
id|p
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|cmd-&gt;sense_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|14
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot; %x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;  STAT: %x&bslash;n&quot;
comma
id|cp-&gt;scsi_status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
id|printk
(paren
l_string|&quot;  HOSTERROR: %x&quot;
comma
id|cp-&gt;host_status
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Free this ccb&n;&t;*/
id|ncr_free_ccb
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;requeue awaiting scsi commands for this lun.&n;&t;*/
r_if
c_cond
(paren
id|lp
op_logical_and
id|lp-&gt;queuedccbs
OL
id|lp-&gt;queuedepth
op_logical_and
op_logical_neg
id|xpt_que_empty
c_func
(paren
op_amp
id|lp-&gt;wait_ccbq
)paren
)paren
id|ncr_start_next_ccb
c_func
(paren
id|np
comma
id|lp
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;requeue awaiting scsi commands for this controller.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;waiting_list
)paren
id|requeue_waiting_list
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;signal completion to generic driver.&n;&t;*/
id|ncr_queue_done_cmd
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Signal all (or one) control block done.&n;**&n;**&n;**==========================================================&n;*/
multiline_comment|/*&n;**&t;The NCR has completed CCBs.&n;**&t;Look at the DONE QUEUE.&n;*/
DECL|function|ncr_wakeup_done
r_int
id|ncr_wakeup_done
(paren
id|ncb_p
id|np
)paren
(brace
id|ccb_p
id|cp
suffix:semicolon
r_int
id|i
comma
id|n
suffix:semicolon
id|u_long
id|dsa
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|np-&gt;dqueueget
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|dsa
op_assign
id|scr_to_cpu
c_func
(paren
id|np-&gt;dqueue
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dsa
)paren
r_break
suffix:semicolon
id|np-&gt;dqueue
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|i
op_plus
l_int|2
)paren
op_ge
id|MAX_START
op_star
l_int|2
)paren
id|i
op_assign
l_int|0
suffix:semicolon
id|cp
op_assign
id|ncr_ccb_from_dsa
c_func
(paren
id|np
comma
id|dsa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
)paren
(brace
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
op_increment
id|n
suffix:semicolon
)brace
r_else
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: bad DSA (%lx) in done queue.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|dsa
)paren
suffix:semicolon
)brace
id|np-&gt;dqueueget
op_assign
id|i
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Complete all active CCBs.&n;*/
DECL|function|ncr_wakeup
r_void
id|ncr_wakeup
(paren
id|ncb_p
id|np
comma
id|u_long
id|code
)paren
(brace
id|ccb_p
id|cp
op_assign
id|np-&gt;ccbc
suffix:semicolon
r_while
c_loop
(paren
id|cp
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_ne
id|HS_IDLE
)paren
(brace
id|cp-&gt;host_status
op_assign
id|code
suffix:semicolon
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
)brace
id|cp
op_assign
id|cp-&gt;link_ccb
suffix:semicolon
)brace
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Start NCR chip.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_init
r_void
id|ncr_init
(paren
id|ncb_p
id|np
comma
r_int
id|reset
comma
r_char
op_star
id|msg
comma
id|u_long
id|code
)paren
(brace
r_int
id|i
suffix:semicolon
id|u_long
id|phys
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Reset chip if asked, otherwise just clear fifos.&n; &t;*/
r_if
c_cond
(paren
id|reset
)paren
id|ncr_soft_reset
c_func
(paren
id|np
)paren
suffix:semicolon
r_else
(brace
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
id|OUTONB
(paren
id|nc_ctest3
comma
id|CLF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Message.&n;&t;*/
r_if
c_cond
(paren
id|msg
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: restart (%s).&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|msg
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Clear Start Queue&n;&t;*/
id|phys
op_assign
id|vtobus
c_func
(paren
id|np-&gt;squeue
)paren
suffix:semicolon
id|np-&gt;queuedepth
op_assign
id|MAX_START
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* 1 entry needed as end marker */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_START
op_star
l_int|2
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|np-&gt;squeue
(braket
id|i
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;p_idletask
)paren
suffix:semicolon
id|np-&gt;squeue
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|phys
op_plus
(paren
id|i
op_plus
l_int|2
)paren
op_star
l_int|4
)paren
suffix:semicolon
)brace
id|np-&gt;squeue
(braket
id|MAX_START
op_star
l_int|2
op_minus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|phys
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Start at first entry.&n;&t;*/
id|np-&gt;squeueput
op_assign
l_int|0
suffix:semicolon
id|np-&gt;script0-&gt;startpos
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|phys
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Clear Done Queue&n;&t;*/
id|phys
op_assign
id|vtobus
c_func
(paren
id|np-&gt;dqueue
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_START
op_star
l_int|2
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|np-&gt;dqueue
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|np-&gt;dqueue
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|phys
op_plus
(paren
id|i
op_plus
l_int|2
)paren
op_star
l_int|4
)paren
suffix:semicolon
)brace
id|np-&gt;dqueue
(braket
id|MAX_START
op_star
l_int|2
op_minus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|phys
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Start at first entry.&n;&t;*/
id|np-&gt;script0-&gt;done_pos
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|phys
)paren
suffix:semicolon
id|np-&gt;dqueueget
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wakeup all pending jobs.&n;&t;*/
id|ncr_wakeup
(paren
id|np
comma
id|code
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Init chip.&n;&t;*/
id|OUTB
(paren
id|nc_istat
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/*  Remove Reset, abort */
id|UDELAY
(paren
l_int|2000
)paren
suffix:semicolon
multiline_comment|/* The 895 needs time for the bus mode to settle */
id|OUTB
(paren
id|nc_scntl0
comma
id|np-&gt;rv_scntl0
op_or
l_int|0xc0
)paren
suffix:semicolon
multiline_comment|/*  full arb., ena parity, par-&gt;ATN  */
id|OUTB
(paren
id|nc_scntl1
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/*  odd parity, and remove CRST!! */
id|ncr_selectclock
c_func
(paren
id|np
comma
id|np-&gt;rv_scntl3
)paren
suffix:semicolon
multiline_comment|/* Select SCSI clock */
id|OUTB
(paren
id|nc_scid
comma
id|RRE
op_or
id|np-&gt;myaddr
)paren
suffix:semicolon
multiline_comment|/* Adapter SCSI address */
id|OUTW
(paren
id|nc_respid
comma
l_int|1ul
op_lshift
id|np-&gt;myaddr
)paren
suffix:semicolon
multiline_comment|/* Id to respond to */
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
)paren
suffix:semicolon
multiline_comment|/*  Signal Process */
id|OUTB
(paren
id|nc_dmode
comma
id|np-&gt;rv_dmode
)paren
suffix:semicolon
multiline_comment|/* Burst length, dma mode */
id|OUTB
(paren
id|nc_ctest5
comma
id|np-&gt;rv_ctest5
)paren
suffix:semicolon
multiline_comment|/* Large fifo + large burst */
id|OUTB
(paren
id|nc_dcntl
comma
id|NOCOM
op_or
id|np-&gt;rv_dcntl
)paren
suffix:semicolon
multiline_comment|/* Protect SFBR */
id|OUTB
(paren
id|nc_ctest3
comma
id|np-&gt;rv_ctest3
)paren
suffix:semicolon
multiline_comment|/* Write and invalidate */
id|OUTB
(paren
id|nc_ctest4
comma
id|np-&gt;rv_ctest4
)paren
suffix:semicolon
multiline_comment|/* Master parity checking */
id|OUTB
(paren
id|nc_stest2
comma
id|EXT
op_or
id|np-&gt;rv_stest2
)paren
suffix:semicolon
multiline_comment|/* Extended Sreq/Sack filtering */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
)paren
suffix:semicolon
multiline_comment|/* TolerANT enable */
id|OUTB
(paren
id|nc_stime0
comma
l_int|0x0c
)paren
suffix:semicolon
multiline_comment|/* HTH disabled  STO 0.25 sec */
multiline_comment|/*&n;&t;**&t;DEL 441 - 53C876 Rev 5 - Part Number 609-0392787/2788 - ITEM 2.&n;&t;**&t;Disable overlapped arbitration.&n;&t;**&t;The 896 Rev 1 needs also this work-around to be applied.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_NCR_53C875
op_logical_and
id|np-&gt;revision_id
op_ge
l_int|0x10
op_logical_and
id|np-&gt;revision_id
op_le
l_int|0x15
)paren
id|OUTB
(paren
id|nc_ctest0
comma
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;device_id
op_eq
id|PCI_DEVICE_ID_NCR_53C896
op_logical_and
id|np-&gt;revision_id
op_le
l_int|0x1
)paren
id|np-&gt;rv_ccntl0
op_or_assign
id|DPR
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If 64 bit (53C896) enable 40 bit address table &n;&t;**&t;indirect addressing for MOVE.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_64BIT
)paren
(brace
id|OUTB
(paren
id|nc_ccntl1
comma
id|np-&gt;rv_ccntl1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If phase mismatch handled by scripts (53C896),&n;&t;**&t;set PM jump addresses.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_NOPM
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: handling phase mismatch from SCRIPTS.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_ccntl0
comma
id|np-&gt;rv_ccntl0
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_pmjad1
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|pm_handle
)paren
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_pmjad2
comma
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|pm_handle
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    Enable GPIO0 pin for writing if LED support from SCRIPTS.&n;&t;**    Also set GPIO5 and clear GPIO6 if hardware LED control.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_LED0
)paren
id|OUTB
c_func
(paren
id|nc_gpcntl
comma
id|INB
c_func
(paren
id|nc_gpcntl
)paren
op_amp
op_complement
l_int|0x01
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_LEDC
)paren
id|OUTB
c_func
(paren
id|nc_gpcntl
comma
(paren
id|INB
c_func
(paren
id|nc_gpcntl
)paren
op_amp
op_complement
l_int|0x41
)paren
op_or
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**      enable ints&n;&t;*/
id|OUTW
(paren
id|nc_sien
comma
id|STO
op_or
id|HTH
op_or
id|MA
op_or
id|SGE
op_or
id|UDC
op_or
id|RST
op_or
id|PAR
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_dien
comma
id|MDPE
op_or
id|BF
op_or
id|SSI
op_or
id|SIR
op_or
id|IID
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;For 895/6 enable SBMC interrupt and save current SCSI bus mode.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA2
)paren
(brace
id|OUTONW
(paren
id|nc_sien
comma
id|SBMC
)paren
suffix:semicolon
id|np-&gt;scsi_mode
op_assign
id|INB
(paren
id|nc_stest4
)paren
op_amp
id|SMODE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Fill in target structure.&n;&t;**&t;Reinitialize usrsync.&n;&t;**&t;Reinitialize usrwide.&n;&t;**&t;Prepare sync negotiation according to actual SCSI bus mode.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|tp-&gt;sval
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;wval
op_assign
id|np-&gt;rv_scntl3
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;usrsync
op_ne
l_int|255
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;usrsync
op_le
id|np-&gt;maxsync
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;usrsync
OL
id|np-&gt;minsync
)paren
(brace
id|tp-&gt;usrsync
op_assign
id|np-&gt;minsync
suffix:semicolon
)brace
)brace
r_else
id|tp-&gt;usrsync
op_assign
l_int|255
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;usrwide
OG
id|np-&gt;maxwide
)paren
id|tp-&gt;usrwide
op_assign
id|np-&gt;maxwide
suffix:semicolon
id|ncr_negotiate
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    Start script processor.&n;&t;*/
id|MEMORY_BARRIER
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;base2_ba
)paren
(brace
r_if
c_cond
(paren
id|bootverbose
)paren
id|printk
(paren
l_string|&quot;%s: Downloading SCSI SCRIPTS.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_RAM8K
)paren
id|phys
op_assign
id|NCB_SCRIPTH0_PHYS
(paren
id|np
comma
id|start_ram64
)paren
suffix:semicolon
r_else
id|phys
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|start_ram
)paren
suffix:semicolon
)brace
r_else
id|phys
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|init
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsa
comma
id|vtobus
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|phys
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Prepare the negotiation values for wide and&n;**&t;synchronous transfers.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_negotiate
r_static
r_void
id|ncr_negotiate
(paren
r_struct
id|ncb
op_star
id|np
comma
r_struct
id|tcb
op_star
id|tp
)paren
(brace
multiline_comment|/*&n;&t;**&t;minsync unit is 4ns !&n;&t;*/
id|u_long
id|minsync
op_assign
id|tp-&gt;usrsync
suffix:semicolon
multiline_comment|/*&n;&t;**&t;SCSI bus mode limit&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;scsi_mode
op_logical_and
id|np-&gt;scsi_mode
op_eq
id|SMODE_SE
)paren
(brace
r_if
c_cond
(paren
id|minsync
OL
l_int|12
)paren
id|minsync
op_assign
l_int|12
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;our limit ..&n;&t;*/
r_if
c_cond
(paren
id|minsync
OL
id|np-&gt;minsync
)paren
id|minsync
op_assign
id|np-&gt;minsync
suffix:semicolon
multiline_comment|/*&n;&t;**&t;divider limit&n;&t;*/
r_if
c_cond
(paren
id|minsync
OG
id|np-&gt;maxsync
)paren
id|minsync
op_assign
l_int|255
suffix:semicolon
id|tp-&gt;minsync
op_assign
id|minsync
suffix:semicolon
id|tp-&gt;maxoffs
op_assign
(paren
id|minsync
OL
l_int|255
ques
c_cond
id|np-&gt;maxoffs
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;period=0: has to negotiate sync transfer&n;&t;*/
id|tp-&gt;period
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;widedone=0: has to negotiate wide transfer&n;&t;*/
id|tp-&gt;widedone
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Get clock factor and sync divisor for a given &n;**&t;synchronous factor period.&n;**&t;Returns the clock factor (in sxfer) and scntl3 &n;**&t;synchronous divisor field.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_getsync
r_static
r_void
id|ncr_getsync
c_func
(paren
id|ncb_p
id|np
comma
id|u_char
id|sfac
comma
id|u_char
op_star
id|fakp
comma
id|u_char
op_star
id|scntl3p
)paren
(brace
id|u_long
id|clk
op_assign
id|np-&gt;clock_khz
suffix:semicolon
multiline_comment|/* SCSI clock frequency in kHz&t;*/
r_int
id|div
op_assign
id|np-&gt;clock_divn
suffix:semicolon
multiline_comment|/* Number of divisors supported&t;*/
id|u_long
id|fak
suffix:semicolon
multiline_comment|/* Sync factor in sxfer&t;&t;*/
id|u_long
id|per
suffix:semicolon
multiline_comment|/* Period in tenths of ns&t;*/
id|u_long
id|kpc
suffix:semicolon
multiline_comment|/* (per * clk)&t;&t;&t;*/
multiline_comment|/*&n;&t;**&t;Compute the synchronous period in tenths of nano-seconds&n;&t;*/
r_if
c_cond
(paren
id|sfac
op_le
l_int|10
)paren
id|per
op_assign
l_int|250
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sfac
op_eq
l_int|11
)paren
id|per
op_assign
l_int|303
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sfac
op_eq
l_int|12
)paren
id|per
op_assign
l_int|500
suffix:semicolon
r_else
id|per
op_assign
l_int|40
op_star
id|sfac
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Look for the greatest clock divisor that allows an &n;&t;**&t;input speed faster than the period.&n;&t;*/
id|kpc
op_assign
id|per
op_star
id|clk
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|div
op_ge
l_int|0
)paren
r_if
c_cond
(paren
id|kpc
op_ge
(paren
id|div_10M
(braket
id|div
)braket
op_lshift
l_int|2
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Calculate the lowest clock factor that allows an output &n;&t;**&t;speed not faster than the period.&n;&t;*/
id|fak
op_assign
(paren
id|kpc
op_minus
l_int|1
)paren
op_div
id|div_10M
(braket
id|div
)braket
op_plus
l_int|1
suffix:semicolon
macro_line|#if 0&t;/* This optimization does not seem very usefull */
id|per
op_assign
(paren
id|fak
op_star
id|div_10M
(braket
id|div
)braket
)paren
op_div
id|clk
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Why not to try the immediate lower divisor and to choose &n;&t;**&t;the one that allows the fastest output speed ?&n;&t;**&t;We dont want input speed too much greater than output speed.&n;&t;*/
r_if
c_cond
(paren
id|div
op_ge
l_int|1
op_logical_and
id|fak
OL
l_int|8
)paren
(brace
id|u_long
id|fak2
comma
id|per2
suffix:semicolon
id|fak2
op_assign
(paren
id|kpc
op_minus
l_int|1
)paren
op_div
id|div_10M
(braket
id|div
op_minus
l_int|1
)braket
op_plus
l_int|1
suffix:semicolon
id|per2
op_assign
(paren
id|fak2
op_star
id|div_10M
(braket
id|div
op_minus
l_int|1
)braket
)paren
op_div
id|clk
suffix:semicolon
r_if
c_cond
(paren
id|per2
OL
id|per
op_logical_and
id|fak2
op_le
l_int|8
)paren
(brace
id|fak
op_assign
id|fak2
suffix:semicolon
id|per
op_assign
id|per2
suffix:semicolon
op_decrement
id|div
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|fak
OL
l_int|4
)paren
id|fak
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* Should never happen, too bad ... */
multiline_comment|/*&n;&t;**&t;Compute and return sync parameters for the ncr&n;&t;*/
op_star
id|fakp
op_assign
id|fak
op_minus
l_int|4
suffix:semicolon
op_star
id|scntl3p
op_assign
(paren
(paren
id|div
op_plus
l_int|1
)paren
op_lshift
l_int|4
)paren
op_plus
(paren
id|sfac
OL
l_int|25
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Set actual values, sync status and patch all ccbs of &n;**&t;a target according to new sync/wide agreement.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_set_sync_wide_status
r_static
r_void
id|ncr_set_sync_wide_status
(paren
id|ncb_p
id|np
comma
id|u_char
id|target
)paren
(brace
id|ccb_p
id|cp
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;set actual value and sync_status&n;&t;*/
id|OUTB
(paren
id|nc_sxfer
comma
id|tp-&gt;sval
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_scntl3
comma
id|tp-&gt;wval
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;patch ALL ccbs of this target.&n;&t;*/
r_for
c_loop
(paren
id|cp
op_assign
id|np-&gt;ccbc
suffix:semicolon
id|cp
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccb
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_IDLE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;target
op_ne
id|target
)paren
r_continue
suffix:semicolon
id|cp-&gt;phys.select.sel_scntl3
op_assign
id|tp-&gt;wval
suffix:semicolon
id|cp-&gt;phys.select.sel_sxfer
op_assign
id|tp-&gt;sval
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Switch sync mode for current job and it&squot;s target&n;**&n;**==========================================================&n;*/
DECL|function|ncr_setsync
r_static
r_void
id|ncr_setsync
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|scntl3
comma
id|u_char
id|sxfer
)paren
(brace
id|tcb_p
id|tp
suffix:semicolon
id|u_char
id|target
op_assign
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|u_char
id|idiv
suffix:semicolon
m_assert
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
suffix:semicolon
m_assert
(paren
id|target
op_eq
(paren
id|cp-&gt;target
op_amp
l_int|0xf
)paren
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scntl3
op_logical_or
op_logical_neg
(paren
id|sxfer
op_amp
l_int|0x1f
)paren
)paren
id|scntl3
op_assign
id|np-&gt;rv_scntl3
suffix:semicolon
id|scntl3
op_assign
(paren
id|scntl3
op_amp
l_int|0xf0
)paren
op_or
(paren
id|tp-&gt;wval
op_amp
id|EWS
)paren
op_or
(paren
id|np-&gt;rv_scntl3
op_amp
l_int|0x07
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Deduce the value of controller sync period from scntl3.&n;&t;**&t;period is in tenths of nano-seconds.&n;&t;*/
id|idiv
op_assign
(paren
(paren
id|scntl3
op_rshift
l_int|4
)paren
op_amp
l_int|0x7
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sxfer
op_amp
l_int|0x1f
)paren
op_logical_and
id|idiv
)paren
id|tp-&gt;period
op_assign
(paren
(paren
(paren
id|sxfer
op_rshift
l_int|5
)paren
op_plus
l_int|4
)paren
op_star
id|div_10M
(braket
id|idiv
op_minus
l_int|1
)braket
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
r_else
id|tp-&gt;period
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/*&n;&t;**&t; Stop there if sync parameters are unchanged&n;&t;*/
r_if
c_cond
(paren
id|tp-&gt;sval
op_eq
id|sxfer
op_logical_and
id|tp-&gt;wval
op_eq
id|scntl3
)paren
r_return
suffix:semicolon
id|tp-&gt;sval
op_assign
id|sxfer
suffix:semicolon
id|tp-&gt;wval
op_assign
id|scntl3
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Bells and whistles   ;-)&n;&t;*/
id|PRINT_TARGET
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sxfer
op_amp
l_int|0x01f
)paren
(brace
r_int
id|f10
op_assign
l_int|100000
op_lshift
(paren
id|tp-&gt;widedone
ques
c_cond
id|tp-&gt;widedone
op_minus
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_int
id|mb10
op_assign
(paren
id|f10
op_plus
id|tp-&gt;period
op_div
l_int|2
)paren
op_div
id|tp-&gt;period
suffix:semicolon
r_char
op_star
id|scsi
suffix:semicolon
multiline_comment|/*&n;&t;&t;**  Disable extended Sreq/Sack filtering&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;period
op_le
l_int|2000
)paren
id|OUTOFFB
(paren
id|nc_stest2
comma
id|EXT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Bells and whistles   ;-)&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;period
OL
l_int|500
)paren
id|scsi
op_assign
l_string|&quot;FAST-40&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;period
OL
l_int|1000
)paren
id|scsi
op_assign
l_string|&quot;FAST-20&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;period
OL
l_int|2000
)paren
id|scsi
op_assign
l_string|&quot;FAST-10&quot;
suffix:semicolon
r_else
id|scsi
op_assign
l_string|&quot;FAST-5&quot;
suffix:semicolon
id|printk
(paren
l_string|&quot;%s %sSCSI %d.%d MB/s (%d ns, offset %d)&bslash;n&quot;
comma
id|scsi
comma
id|tp-&gt;widedone
OG
l_int|1
ques
c_cond
l_string|&quot;WIDE &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|mb10
op_div
l_int|10
comma
id|mb10
op_mod
l_int|10
comma
id|tp-&gt;period
op_div
l_int|10
comma
id|sxfer
op_amp
l_int|0x1f
)paren
suffix:semicolon
)brace
r_else
id|printk
(paren
l_string|&quot;%sasynchronous.&bslash;n&quot;
comma
id|tp-&gt;widedone
OG
l_int|1
ques
c_cond
l_string|&quot;wide &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;set actual value and sync_status&n;&t;**&t;patch ALL ccbs of this target.&n;&t;*/
id|ncr_set_sync_wide_status
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Switch wide mode for current job and it&squot;s target&n;**&t;SCSI specs say: a SCSI device that accepts a WDTR &n;**&t;message shall reset the synchronous agreement to &n;**&t;asynchronous mode.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_setwide
r_static
r_void
id|ncr_setwide
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u_char
id|wide
comma
id|u_char
id|ack
)paren
(brace
id|u_short
id|target
op_assign
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|u_char
id|scntl3
suffix:semicolon
id|u_char
id|sxfer
suffix:semicolon
m_assert
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
suffix:semicolon
m_assert
(paren
id|target
op_eq
(paren
id|cp-&gt;target
op_amp
l_int|0xf
)paren
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|tp-&gt;widedone
op_assign
id|wide
op_plus
l_int|1
suffix:semicolon
id|scntl3
op_assign
(paren
id|tp-&gt;wval
op_amp
(paren
op_complement
id|EWS
)paren
)paren
op_or
(paren
id|wide
ques
c_cond
id|EWS
suffix:colon
l_int|0
)paren
suffix:semicolon
id|sxfer
op_assign
id|ack
ques
c_cond
l_int|0
suffix:colon
id|tp-&gt;sval
suffix:semicolon
multiline_comment|/*&n;&t;**&t; Stop there if sync/wide parameters are unchanged&n;&t;*/
r_if
c_cond
(paren
id|tp-&gt;sval
op_eq
id|sxfer
op_logical_and
id|tp-&gt;wval
op_eq
id|scntl3
)paren
r_return
suffix:semicolon
id|tp-&gt;sval
op_assign
id|sxfer
suffix:semicolon
id|tp-&gt;wval
op_assign
id|scntl3
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Bells and whistles   ;-)&n;&t;*/
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
(brace
id|PRINT_TARGET
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scntl3
op_amp
id|EWS
)paren
id|printk
(paren
l_string|&quot;WIDE SCSI (16 bit) enabled.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;WIDE SCSI disabled.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;set actual value and sync_status&n;&t;**&t;patch ALL ccbs of this target.&n;&t;*/
id|ncr_set_sync_wide_status
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Switch tagged mode for a target.&n;**&n;**==========================================================&n;*/
DECL|function|ncr_setup_tags
r_static
r_void
id|ncr_setup_tags
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|tp-&gt;lp
(braket
id|ln
)braket
suffix:semicolon
id|u_char
id|reqtags
comma
id|maxdepth
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Just in case ...&n;&t;*/
r_if
c_cond
(paren
(paren
op_logical_neg
id|tp
)paren
op_logical_or
(paren
op_logical_neg
id|lp
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If SCSI device queue depth is not yet set, leave here.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;scdev_depth
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Donnot allow more tags than the SCSI driver can queue &n;&t;**&t;for this device.&n;&t;**&t;Donnot allow more tags than we can handle.&n;&t;*/
id|maxdepth
op_assign
id|lp-&gt;scdev_depth
suffix:semicolon
r_if
c_cond
(paren
id|maxdepth
OG
id|lp-&gt;maxnxs
)paren
id|maxdepth
op_assign
id|lp-&gt;maxnxs
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;maxtags
OG
id|maxdepth
)paren
id|lp-&gt;maxtags
op_assign
id|maxdepth
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;numtags
OG
id|maxdepth
)paren
id|lp-&gt;numtags
op_assign
id|maxdepth
suffix:semicolon
multiline_comment|/*&n;&t;**&t;only devices conformant to ANSI Version &gt;= 2&n;&t;**&t;only devices capable of tagged commands&n;&t;**&t;only if enabled by user ..&n;&t;*/
r_if
c_cond
(paren
(paren
id|lp-&gt;inq_byte7
op_amp
id|INQ7_QUEUE
)paren
op_logical_and
id|lp-&gt;numtags
OG
l_int|1
)paren
(brace
id|reqtags
op_assign
id|lp-&gt;numtags
suffix:semicolon
)brace
r_else
(brace
id|reqtags
op_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Update max number of tags&n;&t;*/
id|lp-&gt;numtags
op_assign
id|reqtags
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;numtags
OG
id|lp-&gt;maxtags
)paren
id|lp-&gt;maxtags
op_assign
id|lp-&gt;numtags
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If we want to switch tag mode, we must wait &n;&t;**&t;for no CCB to be active.&n;&t;*/
r_if
c_cond
(paren
id|reqtags
OG
l_int|1
op_logical_and
id|lp-&gt;usetags
)paren
(brace
multiline_comment|/* Stay in tagged mode    */
r_if
c_cond
(paren
id|lp-&gt;queuedepth
op_eq
id|reqtags
)paren
multiline_comment|/* Already announced&t;   */
r_return
suffix:semicolon
id|lp-&gt;queuedepth
op_assign
id|reqtags
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reqtags
op_le
l_int|1
op_logical_and
op_logical_neg
id|lp-&gt;usetags
)paren
(brace
multiline_comment|/* Stay in untagged mode  */
id|lp-&gt;queuedepth
op_assign
id|reqtags
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Want to switch tag mode */
r_if
c_cond
(paren
id|lp-&gt;busyccbs
)paren
multiline_comment|/* If not yet safe, return */
r_return
suffix:semicolon
id|lp-&gt;queuedepth
op_assign
id|reqtags
suffix:semicolon
id|lp-&gt;usetags
op_assign
id|reqtags
OG
l_int|1
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Patch the lun mini-script, according to tag mode.&n;&t;*/
id|lp-&gt;resel_task
op_assign
id|lp-&gt;usetags
ques
c_cond
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
c_func
(paren
id|np
comma
id|resel_tag
)paren
)paren
suffix:colon
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
c_func
(paren
id|np
comma
id|resel_notag
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Announce change to user.&n;&t;*/
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;usetags
)paren
id|printk
c_func
(paren
l_string|&quot;tagged command queue depth set to %d&bslash;n&quot;
comma
id|reqtags
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;tagged command queueing disabled&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*----------------------------------------------------&n;**&n;**&t;handle user commands&n;**&n;**----------------------------------------------------&n;*/
macro_line|#ifdef SCSI_NCR_USER_COMMAND_SUPPORT
DECL|function|ncr_usercmd
r_static
r_void
id|ncr_usercmd
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|t
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
r_switch
c_cond
(paren
id|np-&gt;user.cmd
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
suffix:semicolon
r_case
id|UC_SETSYNC
suffix:colon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|np-&gt;user.target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|t
)braket
suffix:semicolon
id|tp-&gt;usrsync
op_assign
id|np-&gt;user.data
suffix:semicolon
id|ncr_negotiate
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETTAGS
suffix:colon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
r_int
id|ln
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|np-&gt;user.target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|np-&gt;target
(braket
id|t
)braket
dot
id|usrtags
op_assign
id|np-&gt;user.data
suffix:semicolon
r_for
c_loop
(paren
id|ln
op_assign
l_int|0
suffix:semicolon
id|ln
OL
id|MAX_LUN
suffix:semicolon
id|ln
op_increment
)paren
(brace
id|lcb_p
id|lp
op_assign
id|np-&gt;target
(braket
id|t
)braket
dot
id|lp
(braket
id|ln
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_continue
suffix:semicolon
id|lp-&gt;maxtags
op_assign
id|lp-&gt;numtags
op_assign
id|np-&gt;user.data
suffix:semicolon
id|ncr_setup_tags
(paren
id|np
comma
id|t
comma
id|ln
)paren
suffix:semicolon
)brace
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETDEBUG
suffix:colon
macro_line|#ifdef SCSI_NCR_DEBUG_INFO_SUPPORT
id|ncr_debug
op_assign
id|np-&gt;user.data
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|UC_SETORDER
suffix:colon
id|np-&gt;order
op_assign
id|np-&gt;user.data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETVERBOSE
suffix:colon
id|np-&gt;verbose
op_assign
id|np-&gt;user.data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETWIDE
suffix:colon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
id|u_long
id|size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|np-&gt;user.target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|t
)braket
suffix:semicolon
id|size
op_assign
id|np-&gt;user.data
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|np-&gt;maxwide
)paren
id|size
op_assign
id|np-&gt;maxwide
suffix:semicolon
id|tp-&gt;usrwide
op_assign
id|size
suffix:semicolon
id|ncr_negotiate
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETFLAG
suffix:colon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|np-&gt;user.target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|t
)braket
suffix:semicolon
id|tp-&gt;usrflag
op_assign
id|np-&gt;user.data
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
r_case
id|UC_CLEARPROF
suffix:colon
id|bzero
c_func
(paren
op_amp
id|np-&gt;profile
comma
r_sizeof
(paren
id|np-&gt;profile
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
)brace
id|np-&gt;user.cmd
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;ncr timeout handler.&n;**&n;**&n;**==========================================================&n;**&n;**&t;Misused to keep the driver running when&n;**&t;interrupts are not configured correctly.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_timeout
r_static
r_void
id|ncr_timeout
(paren
id|ncb_p
id|np
)paren
(brace
id|u_long
id|thistime
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If release process in progress, let&squot;s go&n;&t;**&t;Set the release stage from 1 to 2 to synchronize&n;&t;**&t;with the release process.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;release_stage
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;release_stage
op_eq
l_int|1
)paren
id|np-&gt;release_stage
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
id|np-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|SCSI_NCR_TIMER_INTERVAL
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|np-&gt;timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If we are resetting the ncr, wait for settle_time before &n;&t;**&t;clearing it. Then command processing will be resumed.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;settle_time
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;settle_time
op_le
id|thistime
)paren
(brace
r_if
c_cond
(paren
id|bootverbose
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: command processing resumed&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;settle_time
op_assign
l_int|0
suffix:semicolon
id|requeue_waiting_list
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Nothing to do for now, but that may come.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;lasttime
op_plus
l_int|4
op_star
id|HZ
OL
id|thistime
)paren
(brace
id|np-&gt;lasttime
op_assign
id|thistime
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_BROKEN_INTR
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_istat
)paren
op_amp
(paren
id|INTF
op_or
id|SIP
op_or
id|DIP
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;Process pending interrupts.&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;{&quot;
)paren
suffix:semicolon
id|ncr_exception
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_BROKEN_INTR */
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;log message for real hard errors&n;**&n;**&t;&quot;ncr0 targ 0?: ERROR (ds:si) (so-si-sd) (sxfer/scntl3) @ name (dsp:dbc).&quot;&n;**&t;&quot;&t;      reg: r0 r1 r2 r3 r4 r5 r6 ..... rf.&quot;&n;**&n;**&t;exception register:&n;**&t;&t;ds:&t;dstat&n;**&t;&t;si:&t;sist&n;**&n;**&t;SCSI bus lines:&n;**&t;&t;so:&t;control lines as driver by NCR.&n;**&t;&t;si:&t;control lines as seen by NCR.&n;**&t;&t;sd:&t;scsi data lines as seen by NCR.&n;**&n;**&t;wide/fastmode:&n;**&t;&t;sxfer:&t;(see the manual)&n;**&t;&t;scntl3:&t;(see the manual)&n;**&n;**&t;current script command:&n;**&t;&t;dsp:&t;script adress (relative to start of script).&n;**&t;&t;dbc:&t;first word of script command.&n;**&n;**&t;First 16 register of the chip:&n;**&t;&t;r0..rf&n;**&n;**==========================================================&n;*/
DECL|function|ncr_log_hard_error
r_static
r_void
id|ncr_log_hard_error
c_func
(paren
id|ncb_p
id|np
comma
id|u_short
id|sist
comma
id|u_char
id|dstat
)paren
(brace
id|u_int32
id|dsp
suffix:semicolon
r_int
id|script_ofs
suffix:semicolon
r_int
id|script_size
suffix:semicolon
r_char
op_star
id|script_name
suffix:semicolon
id|u_char
op_star
id|script_base
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dsp
OG
id|np-&gt;p_script
op_logical_and
id|dsp
op_le
id|np-&gt;p_script
op_plus
r_sizeof
(paren
r_struct
id|script
)paren
)paren
(brace
id|script_ofs
op_assign
id|dsp
op_minus
id|np-&gt;p_script
suffix:semicolon
id|script_size
op_assign
r_sizeof
(paren
r_struct
id|script
)paren
suffix:semicolon
id|script_base
op_assign
(paren
id|u_char
op_star
)paren
id|np-&gt;script0
suffix:semicolon
id|script_name
op_assign
l_string|&quot;script&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|np-&gt;p_scripth
OL
id|dsp
op_logical_and
id|dsp
op_le
id|np-&gt;p_scripth
op_plus
r_sizeof
(paren
r_struct
id|scripth
)paren
)paren
(brace
id|script_ofs
op_assign
id|dsp
op_minus
id|np-&gt;p_scripth
suffix:semicolon
id|script_size
op_assign
r_sizeof
(paren
r_struct
id|scripth
)paren
suffix:semicolon
id|script_base
op_assign
(paren
id|u_char
op_star
)paren
id|np-&gt;scripth0
suffix:semicolon
id|script_name
op_assign
l_string|&quot;scripth&quot;
suffix:semicolon
)brace
r_else
(brace
id|script_ofs
op_assign
id|dsp
suffix:semicolon
id|script_size
op_assign
l_int|0
suffix:semicolon
id|script_base
op_assign
l_int|0
suffix:semicolon
id|script_name
op_assign
l_string|&quot;mem&quot;
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0x0f
comma
id|dstat
comma
id|sist
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_socl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sbcl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sbdl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sxfer
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_scntl3
)paren
comma
id|script_name
comma
id|script_ofs
comma
(paren
r_int
)paren
id|INL
(paren
id|nc_dbc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|script_ofs
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
r_int
)paren
id|script_ofs
OL
id|script_size
)paren
(brace
id|printk
(paren
l_string|&quot;%s: script cmd = %08x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|scr_to_cpu
c_func
(paren
(paren
r_int
)paren
op_star
(paren
id|ncrcmd
op_star
)paren
(paren
id|script_base
op_plus
id|script_ofs
)paren
)paren
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;%s: regdump:&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot; %02x&quot;
comma
(paren
r_int
)paren
id|INB_OFF
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*============================================================&n;**&n;**&t;ncr chip exception handler.&n;**&n;**============================================================&n;**&n;**&t;In normal situations, interrupt conditions occur one at &n;**&t;a time. But when something bad happens on the SCSI BUS, &n;**&t;the chip may raise several interrupt flags before &n;**&t;stopping and interrupting the CPU. The additionnal &n;**&t;interrupt flags are stacked in some extra registers &n;**&t;after the SIP and/or DIP flag has been raised in the &n;**&t;ISTAT. After the CPU has read the interrupt condition &n;**&t;flag from SIST or DSTAT, the chip unstacks the other &n;**&t;interrupt flags and sets the corresponding bits in &n;**&t;SIST or DSTAT. Since the chip starts stacking once the &n;**&t;SIP or DIP flag is set, there is a small window of time &n;**&t;where the stacking does not occur.&n;**&n;**&t;Typically, multiple interrupt conditions may happen in &n;**&t;the following situations:&n;**&n;**&t;- SCSI parity error + Phase mismatch  (PAR|MA)&n;**&t;  When an parity error is detected in input phase &n;**&t;  and the device switches to msg-in phase inside a &n;**&t;  block MOV.&n;**&t;- SCSI parity error + Unexpected disconnect (PAR|UDC)&n;**&t;  When a stupid device does not want to handle the &n;**&t;  recovery of an SCSI parity error.&n;**&t;- Some combinations of STO, PAR, UDC, ...&n;**&t;  When using non compliant SCSI stuff, when user is &n;**&t;  doing non compliant hot tampering on the BUS, when &n;**&t;  something really bad happens to a device, etc ...&n;**&n;**&t;The heuristic suggested by SYMBIOS to handle &n;**&t;multiple interrupts is to try unstacking all &n;**&t;interrupts conditions and to handle them on some &n;**&t;priority based on error severity.&n;**&t;This will work when the unstacking has been &n;**&t;successful, but we cannot be 100 % sure of that, &n;**&t;since the CPU may have been faster to unstack than &n;**&t;the chip is able to stack. Hmmm ... But it seems that &n;**&t;such a situation is very unlikely to happen.&n;**&n;**&t;If this happen, for example STO catched by the CPU &n;**&t;then UDC happenning before the CPU have restarted &n;**&t;the SCRIPTS, the driver may wrongly complete the &n;**&t;same command on UDC, since the SCRIPTS didn&squot;t restart &n;**&t;and the DSA still points to the same command.&n;**&t;We avoid this situation by setting the DSA to an &n;**&t;invalid value when the CCB is completed and before &n;**&t;restarting the SCRIPTS.&n;**&n;**&t;Another issue is that we need some section of our &n;**&t;recovery procedures to be somehow uninterruptible and &n;**&t;that the SCRIPTS processor does not provides such a &n;**&t;feature. For this reason, we handle recovery preferently &n;**&t;from the C code&t;and check against some SCRIPTS &n;**&t;critical sections from the C code.&n;**&n;**&t;Hopefully, the interrupt handling of the driver is now &n;**&t;able to resist to weird BUS error conditions, but donnot &n;**&t;ask me for any guarantee that it will never fail. :-)&n;**&t;Use at your own decision and risk.&n;**&n;**============================================================&n;*/
DECL|function|ncr_exception
r_void
id|ncr_exception
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|istat
comma
id|istatc
suffix:semicolon
id|u_char
id|dstat
suffix:semicolon
id|u_short
id|sist
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef SCSI_NCR_OPTIMIZE_896_1
multiline_comment|/*&n;&t;**&t;This optimization when used with a 896 that handles &n;&t;**&t;phase mismatch from the SCRIPTS allows to only do &n;&t;**&t;PCI memory writes transactions from the CPU and so to &n;&t;**&t;take advantage of PCI posted writes.&n;&t;**&t;Who wants his 500 MHz CPU to wait several micro-seconds &n;&t;**&t;for the PCI BUS to be granted when this can be avoided?&n;&t;**&t;I don&squot;t, even for my slow 233 MHz PII. :-)&n;&t;**&n;&t;**&t;We assume we have been called for command completion.&n;&t;**&t;If no completion found, go with normal handling.&n;&t;**&t;Ordering is ensured by the SCRIPTS performing a read &n;&t;**&t;from main memory prior to raising INTFLY.&n;&t;**&t;We have to raise SIGP since the chip may be currently &n;&t;**&t;going to a wait reselect instruction. IMO, SIGP should &n;&t;**&t;not be clearable in ISTAT since it can be polled and &n;&t;**&t;cleared by reading CTEST2. This tiny chip misdesign is a &n;&t;**&t;penalty here.&n;&t;**&n;&t;**&t;The MA interrupt and interrupt sharing may also have &n;&t;**&t;adverse effects on this optimization, so we only want &n;&t;**&t;to use it if it is enabled by user.&n;&t;**&t;(BTW, this optimization seems to even have some goodness &n;&t;**&t;with my 895 that unfortunately suffers of the MA int.).&n;&t;*/
r_if
c_cond
(paren
id|driver_setup.optimize
op_amp
l_int|1
)paren
(brace
id|OUTB
c_func
(paren
id|nc_istat
comma
(paren
id|INTF
op_or
id|SIGP
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ncr_wakeup_done
(paren
id|np
)paren
)paren
(brace
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
op_increment
id|np-&gt;profile.num_fly
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif /* SCSI_NCR_OPTIMIZE_896_1 */
multiline_comment|/*&n;&t;**&t;interrupt on the fly ?&n;&t;*/
id|istat
op_assign
id|INB
(paren
id|nc_istat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|istat
op_amp
id|INTF
)paren
(brace
id|OUTB
(paren
id|nc_istat
comma
(paren
id|istat
op_amp
id|SIGP
)paren
op_or
id|INTF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;F &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_wakeup_done
(paren
id|np
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
op_increment
id|np-&gt;profile.num_fly
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|istat
op_amp
(paren
id|SIP
op_or
id|DIP
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
op_increment
id|np-&gt;profile.num_int
suffix:semicolon
macro_line|#endif
macro_line|#if 0&t;/* We should never get this one */
r_if
c_cond
(paren
id|istat
op_amp
id|CABRT
)paren
id|OUTB
(paren
id|nc_istat
comma
id|CABRT
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**&t;Steinbach&squot;s Guideline for Systems Programming:&n;&t;**&t;Never test for an error condition you don&squot;t know how to handle.&n;&t;*/
multiline_comment|/*========================================================&n;&t;**&t;PAR and MA interrupts may occur at the same time,&n;&t;**&t;and we need to know of both in order to handle &n;&t;**&t;this situation properly. We try to unstack SCSI &n;&t;**&t;interrupts for that reason. BTW, I dislike a LOT &n;&t;**&t;such a loop inside the interrupt routine.&n;&t;**&t;Even if DMA interrupt stacking is very unlikely to &n;&t;**&t;happen, we also try unstacking these ones, since &n;&t;**&t;this has no performance impact.&n;&t;**=========================================================&n;&t;*/
id|sist
op_assign
l_int|0
suffix:semicolon
id|dstat
op_assign
l_int|0
suffix:semicolon
id|istatc
op_assign
id|istat
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|istatc
op_amp
id|SIP
)paren
id|sist
op_or_assign
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|istatc
op_amp
id|DIP
)paren
id|dstat
op_or_assign
id|INB
(paren
id|nc_dstat
)paren
suffix:semicolon
id|istatc
op_assign
id|INB
(paren
id|nc_istat
)paren
suffix:semicolon
id|istat
op_or_assign
id|istatc
suffix:semicolon
)brace
r_while
c_loop
(paren
id|istatc
op_amp
(paren
id|SIP
op_or
id|DIP
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;&lt;%d|%x:%x|%x:%x&gt;&quot;
comma
(paren
r_int
)paren
id|INB
c_func
(paren
id|nc_scr0
)paren
comma
id|dstat
comma
id|sist
comma
(paren
r_int
)paren
id|INL
c_func
(paren
id|nc_dsp
)paren
comma
(paren
r_int
)paren
id|INL
c_func
(paren
id|nc_dbc
)paren
)paren
suffix:semicolon
multiline_comment|/*========================================================&n;&t;**&t;First, interrupts we want to service cleanly.&n;&t;**&n;&t;**&t;Phase mismatch (MA) is the most frequent interrupt &n;&t;**&t;for chip earlier than the 896 and so we have to service &n;&t;**&t;it as quickly as possible.&n;&t;**&t;A SCSI parity error (PAR) may be combined with a phase &n;&t;**&t;mismatch condition (MA).&n;&t;**&t;Programmed interrupts (SIR) are used to call the C code &n;&t;**&t;from SCRIPTS.&n;&t;**&t;The single step interrupt (SSI) is not used in this &n;&t;**&t;driver.&n;&t;**=========================================================&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|sist
op_amp
(paren
id|STO
op_or
id|GEN
op_or
id|HTH
op_or
id|SGE
op_or
id|UDC
op_or
id|SBMC
op_or
id|RST
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|IID
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|sist
op_amp
id|PAR
)paren
id|ncr_int_par
(paren
id|np
comma
id|sist
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sist
op_amp
id|MA
)paren
id|ncr_int_ma
(paren
id|np
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dstat
op_amp
id|SIR
)paren
id|ncr_int_sir
(paren
id|np
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dstat
op_amp
id|SSI
)paren
id|OUTONB
(paren
id|nc_dcntl
comma
(paren
id|STD
op_or
id|NOCOM
)paren
)paren
suffix:semicolon
r_else
r_goto
id|unknown_int
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*========================================================&n;&t;**&t;Now, interrupts that donnot happen in normal &n;&t;**&t;situations and that we may need to recover from.&n;&t;**&n;&t;**&t;On SCSI RESET (RST), we reset everything.&n;&t;**&t;On SCSI BUS MODE CHANGE (SBMC), we complete all &n;&t;**&t;active CCBs with RESET status, prepare all devices &n;&t;**&t;for negotiating again and restart the SCRIPTS.&n;&t;**&t;On STO and UDC, we complete the CCB with the corres- &n;&t;**&t;ponding status and restart the SCRIPTS.&n;&t;**=========================================================&n;&t;*/
r_if
c_cond
(paren
id|sist
op_amp
id|RST
)paren
(brace
id|ncr_init
(paren
id|np
comma
l_int|1
comma
id|bootverbose
ques
c_cond
l_string|&quot;scsi reset&quot;
suffix:colon
l_int|NULL
comma
id|HS_RESET
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
id|OUTB
(paren
id|nc_ctest3
comma
id|np-&gt;rv_ctest3
op_or
id|CLF
)paren
suffix:semicolon
multiline_comment|/* clear dma fifo  */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
multiline_comment|/* clear scsi fifo */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sist
op_amp
(paren
id|GEN
op_or
id|HTH
op_or
id|SGE
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|IID
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|sist
op_amp
id|SBMC
)paren
id|ncr_int_sbmc
(paren
id|np
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sist
op_amp
id|STO
)paren
id|ncr_int_sto
(paren
id|np
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sist
op_amp
id|UDC
)paren
id|ncr_int_udc
(paren
id|np
)paren
suffix:semicolon
r_else
r_goto
id|unknown_int
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*=========================================================&n;&t;**&t;Now, interrupts we are not able to recover cleanly.&n;&t;**&n;&t;**&t;Do the register dump.&n;&t;**&t;Log message for hard errors.&n;&t;**&t;Reset everything.&n;&t;**=========================================================&n;&t;*/
r_if
c_cond
(paren
id|jiffies
op_minus
id|np-&gt;regtime
OG
l_int|10
op_star
id|HZ
)paren
(brace
id|np-&gt;regtime
op_assign
id|jiffies
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|np-&gt;regdump
)paren
suffix:semicolon
id|i
op_increment
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|np-&gt;regdump
)paren
(braket
id|i
)braket
op_assign
id|INB_OFF
c_func
(paren
id|i
)paren
suffix:semicolon
id|np-&gt;regdump.nc_dstat
op_assign
id|dstat
suffix:semicolon
id|np-&gt;regdump.nc_sist
op_assign
id|sist
suffix:semicolon
)brace
suffix:semicolon
id|ncr_log_hard_error
c_func
(paren
id|np
comma
id|sist
comma
id|dstat
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sist
op_amp
(paren
id|GEN
op_or
id|HTH
op_or
id|SGE
)paren
)paren
op_logical_or
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|IID
)paren
)paren
)paren
(brace
id|ncr_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
id|unknown_int
suffix:colon
multiline_comment|/*=========================================================&n;&t;**&t;We just miss the cause of the interrupt. :(&n;&t;**&t;Print a message. The timeout will do the real work.&n;&t;**=========================================================&n;&t;*/
id|printk
c_func
(paren
l_string|&quot;%s: unknown interrupt(s) ignored, &quot;
l_string|&quot;ISTAT=0x%x DSTAT=0x%x SIST=0x%x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|istat
comma
id|dstat
comma
id|sist
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;generic recovery from scsi interrupt&n;**&n;**==========================================================&n;**&n;**&t;The doc says that when the chip gets an SCSI interrupt,&n;**&t;it tries to stop in an orderly fashion, by completing &n;**&t;an instruction fetch that had started or by flushing &n;**&t;the DMA fifo for a write to memory that was executing.&n;**&t;Such a fashion is not enough to know if the instruction &n;**&t;that was just before the current DSP value has been &n;**&t;executed or not.&n;**&n;**&t;There are 3 small SCRIPTS sections that deal with the &n;**&t;start queue and the done queue that may break any &n;**&t;assomption from the C code if we are interrupted &n;**&t;inside, so we reset if it happens. Btw, since these &n;**&t;SCRIPTS sections are executed while the SCRIPTS hasn&squot;t &n;**&t;started SCSI operations, it is very unlikely to happen.&n;**&n;**&t;All the driver data structures are supposed to be &n;**&t;allocated from the same 4 GB memory window, so there &n;**&t;is a 1 to 1 relationship between DSA and driver data &n;**&t;structures. Since we are careful :) to invalidate the &n;**&t;DSA when we complete a command or when the SCRIPTS &n;**&t;pushes a DSA into a queue, we can trust it when it &n;**&t;points to a CCB.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_recover_scsi_int
r_static
r_void
id|ncr_recover_scsi_int
(paren
id|ncb_p
id|np
comma
id|u_char
id|hsts
)paren
(brace
id|u_int32
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
id|u_int32
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|u_char
id|scntl1
op_assign
id|INB
(paren
id|nc_scntl1
)paren
suffix:semicolon
id|ccb_p
id|cp
op_assign
id|ncr_ccb_from_dsa
c_func
(paren
id|np
comma
id|dsa
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If we are connected to the SCSI BUS, we only &n;&t;**&t;can reset the BUS.&n;&t;*/
r_if
c_cond
(paren
id|scntl1
op_amp
id|ISCON
)paren
r_goto
id|reset_all
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If we haven&squot;t been interrupted inside the SCRIPTS &n;&t;**&t;critical pathes, we can safely restart the SCRIPTS &n;&t;**&t;and trust the DSA value if it matches a CCB.&n;&t;*/
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|dsp
OG
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|getjob_begin
)paren
op_logical_and
id|dsp
OL
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|getjob_end
)paren
op_plus
l_int|1
)paren
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|dsp
OG
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|ungetjob
)paren
op_logical_and
id|dsp
OL
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|reselect
)paren
op_plus
l_int|1
)paren
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|dsp
OG
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|done
)paren
op_logical_and
id|dsp
OL
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|done_end
)paren
op_plus
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|cp
)paren
(brace
id|cp-&gt;host_status
op_assign
id|hsts
suffix:semicolon
id|ncr_complete
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
)brace
id|OUTL
(paren
id|nc_dsa
comma
id|DSA_INVALID
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_ctest3
comma
id|np-&gt;rv_ctest3
op_or
id|CLF
)paren
suffix:semicolon
multiline_comment|/* clear dma fifo  */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
multiline_comment|/* clear scsi fifo */
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|start
)paren
)paren
suffix:semicolon
)brace
r_else
r_goto
id|reset_all
suffix:semicolon
r_return
suffix:semicolon
id|reset_all
suffix:colon
id|ncr_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip exception handler for selection timeout&n;**&n;**==========================================================&n;**&n;**&t;There seems to be a bug in the 53c810.&n;**&t;Although a STO-Interrupt is pending,&n;**&t;it continues executing script commands.&n;**&t;But it will fail and interrupt (IID) on&n;**&t;the next instruction where it&squot;s looking&n;**&t;for a valid phase.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_sto
r_void
id|ncr_int_sto
(paren
id|ncb_p
id|np
)paren
(brace
id|u_int32
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;T&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dsp
op_eq
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|wf_sel_done
)paren
op_plus
l_int|8
op_logical_or
id|dsp
op_eq
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|wf_sel_done_no_atn
)paren
op_plus
l_int|8
op_logical_or
op_logical_neg
(paren
id|driver_setup.recovery
op_amp
l_int|1
)paren
)paren
id|ncr_recover_scsi_int
c_func
(paren
id|np
comma
id|HS_SEL_TIMEOUT
)paren
suffix:semicolon
r_else
id|ncr_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip exception handler for unexpected disconnect&n;**&n;**==========================================================&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_udc
r_void
id|ncr_int_udc
(paren
id|ncb_p
id|np
)paren
(brace
id|printk
(paren
l_string|&quot;%s: unexpected disconnect&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|ncr_recover_scsi_int
c_func
(paren
id|np
comma
id|HS_UNEXPECTED
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip exception handler for SCSI bus mode change&n;**&n;**==========================================================&n;**&n;**&t;spi2-r12 11.2.3 says a transceiver mode change must &n;**&t;generate a reset event and a device that detects a reset &n;**&t;event shall initiate a hard reset. It says also that a&n;**&t;device that detects a mode change shall set data transfer &n;**&t;mode to eight bit asynchronous, etc...&n;**&t;So, just resetting should be enough.&n;**&t; &n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_sbmc
r_static
r_void
id|ncr_int_sbmc
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|scsi_mode
op_assign
id|INB
(paren
id|nc_stest4
)paren
op_amp
id|SMODE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: SCSI bus mode change from %x to %x.&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;scsi_mode
comma
id|scsi_mode
)paren
suffix:semicolon
id|np-&gt;scsi_mode
op_assign
id|scsi_mode
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Suspend command processing for 1 second and &n;&t;**&t;reinitialize all except the chip.&n;&t;*/
id|np-&gt;settle_time
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|ncr_init
(paren
id|np
comma
l_int|0
comma
id|bootverbose
ques
c_cond
l_string|&quot;scsi mode change&quot;
suffix:colon
l_int|NULL
comma
id|HS_RESET
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip exception handler for SCSI parity error.&n;**&n;**==========================================================&n;**&n;**&t;When the chip detects a SCSI parity error and is &n;**&t;currently executing a (CH)MOV instruction, it does &n;**&t;not interrupt immediately, but tries to finish the &n;**&t;transfer of the current scatter entry before &n;**&t;interrupting. The following situations may occur:&n;**&n;**&t;- The complete scatter entry has been transferred &n;**&t;  without the device having changed phase.&n;**&t;  The chip will then interrupt with the DSP pointing &n;**&t;  to the instruction that follows the MOV.&n;**&n;**&t;- A phase mismatch occurs before the MOV finished &n;**&t;  and phase errors are to be handled by the C code.&n;**&t;  The chip will then interrupt with both PAR and MA &n;**&t;  conditions set.&n;**&n;**&t;- A phase mismatch occurs before the MOV finished &n;**&t;  and phase errors are to be handled by SCRIPTS (896).&n;**&t;  The chip will load the DSP with the phase mismatch &n;**&t;  JUMP address and interrupt the host processor.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_par
r_static
r_void
id|ncr_int_par
(paren
id|ncb_p
id|np
comma
id|u_short
id|sist
)paren
(brace
id|u_char
id|hsts
op_assign
id|INB
(paren
id|HS_PRT
)paren
suffix:semicolon
id|u_int32
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
id|u_int32
id|dbc
op_assign
id|INL
(paren
id|nc_dbc
)paren
suffix:semicolon
id|u_int32
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|u_char
id|sbcl
op_assign
id|INB
(paren
id|nc_sbcl
)paren
suffix:semicolon
id|u_char
id|cmd
op_assign
id|dbc
op_rshift
l_int|24
suffix:semicolon
r_int
id|phase
op_assign
id|cmd
op_amp
l_int|7
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: SCSI parity error detected: SCR1=%d DBC=%x SBCL=%x&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|hsts
comma
id|dbc
comma
id|sbcl
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Check that the chip is connected to the SCSI BUS.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|INB
(paren
id|nc_scntl1
)paren
op_amp
id|ISCON
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver_setup.recovery
op_amp
l_int|1
)paren
)paren
(brace
id|ncr_recover_scsi_int
c_func
(paren
id|np
comma
id|HS_FAIL
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_goto
id|reset_all
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If the nexus is not clearly identified, reset the bus.&n;&t;**&t;We will try to do better later.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|ncr_ccb_from_dsa
c_func
(paren
id|np
comma
id|dsa
)paren
)paren
r_goto
id|reset_all
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Check instruction was a MOV, direction was INPUT and &n;&t;**&t;ATN is asserted.&n;&t;*/
r_if
c_cond
(paren
(paren
id|cmd
op_amp
l_int|0xc0
)paren
op_logical_or
op_logical_neg
(paren
id|phase
op_amp
l_int|1
)paren
op_logical_or
op_logical_neg
(paren
id|sbcl
op_amp
l_int|0x8
)paren
)paren
r_goto
id|reset_all
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Keep track of the parity error.&n;&t;*/
id|OUTONB
(paren
id|HF_PRT
comma
id|HF_PAR_ERR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Prepare the message to send to the device.&n;&t;*/
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
(paren
id|phase
op_eq
l_int|7
)paren
ques
c_cond
id|M_PARITY
suffix:colon
id|M_ID_ERROR
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If the old phase was DATA IN phase, we have to deal with&n;&t;**&t;the 3 situations described above.&n;&t;**&t;For other input phases (MSG IN and STATUS), the device &n;&t;**&t;must resend the whole thing that failed parity checking &n;&t;**&t;or signal error. So, jumping to dispatcher should be OK.&n;&t;*/
r_if
c_cond
(paren
id|phase
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Phase mismatch handled by SCRIPTS */
r_if
c_cond
(paren
id|dsp
op_eq
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|pm_handle
)paren
)paren
id|OUTL
(paren
id|nc_dsp
comma
id|dsp
)paren
suffix:semicolon
multiline_comment|/* Phase mismatch handled by the C code */
r_else
r_if
c_cond
(paren
id|sist
op_amp
id|MA
)paren
id|ncr_int_ma
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/* No phase mismatch occurred */
r_else
(brace
id|OUTL
(paren
id|nc_temp
comma
id|dsp
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|databreak
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|reset_all
suffix:colon
id|ncr_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;ncr chip exception handler for phase errors.&n;**&n;**&n;**==========================================================&n;**&n;**&t;We have to construct a new transfer descriptor,&n;**&t;to transfer the rest of the current block.&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_int_ma
r_static
r_void
id|ncr_int_ma
(paren
id|ncb_p
id|np
)paren
(brace
id|u_int32
id|dbc
suffix:semicolon
id|u_int32
id|rest
suffix:semicolon
id|u_int32
id|dsp
suffix:semicolon
id|u_int32
id|dsa
suffix:semicolon
id|u_int32
id|nxtdsp
suffix:semicolon
id|u_int32
op_star
id|vdsp
suffix:semicolon
id|u_int32
id|oadr
comma
id|olen
suffix:semicolon
id|u_int32
op_star
id|tblp
suffix:semicolon
id|u_int32
id|newcmd
suffix:semicolon
id|u_int
id|delta
suffix:semicolon
id|u_char
id|cmd
suffix:semicolon
id|u_char
id|hflags
comma
id|hflags0
suffix:semicolon
r_struct
id|pm_ctx
op_star
id|pm
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
op_increment
id|np-&gt;profile.num_break
suffix:semicolon
macro_line|#endif
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
id|dbc
op_assign
id|INL
(paren
id|nc_dbc
)paren
suffix:semicolon
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|cmd
op_assign
id|dbc
op_rshift
l_int|24
suffix:semicolon
id|rest
op_assign
id|dbc
op_amp
l_int|0xffffff
suffix:semicolon
id|delta
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;locate matching cp.&n;&t;*/
id|cp
op_assign
id|ncr_ccb_from_dsa
c_func
(paren
id|np
comma
id|dsa
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Donnot take into account dma fifo and various buffers in &n;&t;**&t;DATA IN phase since the chip flushes everything before &n;&t;**&t;raising the MA interrupt for interrupted INPUT phases.&n;&t;*/
r_if
c_cond
(paren
(paren
id|cmd
op_amp
l_int|7
)paren
op_ne
l_int|1
)paren
(brace
id|u_int32
id|dfifo
suffix:semicolon
id|u_char
id|ss0
comma
id|ss2
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Read DFIFO, CTEST[4-6] using 1 PCI bus ownership.&n;&t;&t;*/
id|dfifo
op_assign
id|INL
c_func
(paren
id|nc_dfifo
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Calculate remaining bytes in DMA fifo.&n;&t;&t;**&t;(CTEST5 = dfifo &gt;&gt; 16)&n;&t;&t;*/
r_if
c_cond
(paren
id|dfifo
op_amp
(paren
id|DFS
op_lshift
l_int|16
)paren
)paren
id|delta
op_assign
(paren
(paren
(paren
(paren
id|dfifo
op_rshift
l_int|8
)paren
op_amp
l_int|0x300
)paren
op_or
(paren
id|dfifo
op_amp
l_int|0xff
)paren
)paren
op_minus
id|rest
)paren
op_amp
l_int|0x3ff
suffix:semicolon
r_else
id|delta
op_assign
(paren
(paren
id|dfifo
op_amp
l_int|0xff
)paren
op_minus
id|rest
)paren
op_amp
l_int|0x7f
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;The data in the dma fifo has not been transfered to&n;&t;&t;**&t;the target -&gt; add the amount to the rest&n;&t;&t;**&t;and clear the data.&n;&t;&t;**&t;Check the sstat2 register in case of wide transfer.&n;&t;&t;*/
id|rest
op_add_assign
id|delta
suffix:semicolon
id|ss0
op_assign
id|INB
(paren
id|nc_sstat0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss0
op_amp
id|OLF
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ss0
op_amp
id|ORF
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_logical_and
(paren
id|cp-&gt;phys.select.sel_scntl3
op_amp
id|EWS
)paren
)paren
(brace
id|ss2
op_assign
id|INB
(paren
id|nc_sstat2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss2
op_amp
id|OLF1
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ss2
op_amp
id|ORF1
)paren
id|rest
op_increment
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Clear fifos.&n;&t;&t;*/
id|OUTB
(paren
id|nc_ctest3
comma
id|np-&gt;rv_ctest3
op_or
id|CLF
)paren
suffix:semicolon
multiline_comment|/* dma fifo  */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
multiline_comment|/* scsi fifo */
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;log the information&n;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
(paren
id|DEBUG_TINY
op_or
id|DEBUG_PHASE
)paren
)paren
id|printk
(paren
l_string|&quot;P%x%x RL=%d D=%d &quot;
comma
id|cmd
op_amp
l_int|7
comma
id|INB
c_func
(paren
id|nc_sbcl
)paren
op_amp
l_int|7
comma
(paren
r_int
)paren
id|rest
comma
(paren
r_int
)paren
id|delta
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;try to find the interrupted script command,&n;&t;**&t;and the address at which to continue.&n;&t;*/
id|vdsp
op_assign
l_int|0
suffix:semicolon
id|nxtdsp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dsp
OG
id|np-&gt;p_script
op_logical_and
id|dsp
op_le
id|np-&gt;p_script
op_plus
r_sizeof
(paren
r_struct
id|script
)paren
)paren
(brace
id|vdsp
op_assign
(paren
id|u_int32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|np-&gt;script0
op_plus
(paren
id|dsp
op_minus
id|np-&gt;p_script
op_minus
l_int|8
)paren
)paren
suffix:semicolon
id|nxtdsp
op_assign
id|dsp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dsp
OG
id|np-&gt;p_scripth
op_logical_and
id|dsp
op_le
id|np-&gt;p_scripth
op_plus
r_sizeof
(paren
r_struct
id|scripth
)paren
)paren
(brace
id|vdsp
op_assign
(paren
id|u_int32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|np-&gt;scripth0
op_plus
(paren
id|dsp
op_minus
id|np-&gt;p_scripth
op_minus
l_int|8
)paren
)paren
suffix:semicolon
id|nxtdsp
op_assign
id|dsp
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;log the information&n;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|printk
(paren
l_string|&quot;&bslash;nCP=%p DSP=%x NXT=%x VDSP=%p CMD=%x &quot;
comma
id|cp
comma
(paren
r_int
)paren
id|dsp
comma
(paren
r_int
)paren
id|nxtdsp
comma
id|vdsp
comma
id|cmd
)paren
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vdsp
)paren
(brace
id|printk
(paren
l_string|&quot;%s: interrupted SCRIPT address not found.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|reset_all
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
(brace
id|printk
(paren
l_string|&quot;%s: SCSI phase error fixup: CCB already dequeued.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|reset_all
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;get old startaddress and old length.&n;&t;*/
id|oadr
op_assign
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* Table indirect */
id|tblp
op_assign
(paren
id|u_int32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|cp-&gt;phys
op_plus
id|oadr
)paren
suffix:semicolon
id|olen
op_assign
id|scr_to_cpu
c_func
(paren
id|tblp
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|oadr
op_assign
id|scr_to_cpu
c_func
(paren
id|tblp
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|tblp
op_assign
(paren
id|u_int32
op_star
)paren
l_int|0
suffix:semicolon
id|olen
op_assign
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|0
)braket
)paren
op_amp
l_int|0xffffff
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|printk
(paren
l_string|&quot;OCMD=%x&bslash;nTBLP=%p OLEN=%x OADR=%x&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|0
)braket
)paren
op_rshift
l_int|24
)paren
comma
id|tblp
comma
(paren
r_int
)paren
id|olen
comma
(paren
r_int
)paren
id|oadr
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;check cmd against assumed interrupted script command.&n;&t;*/
r_if
c_cond
(paren
id|cmd
op_ne
(paren
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|0
)braket
)paren
op_rshift
l_int|24
)paren
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;internal error: cmd=%02x != %02x=(vdsp[0] &gt;&gt; 24)&bslash;n&quot;
comma
(paren
r_int
)paren
id|cmd
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|0
)braket
)paren
op_rshift
l_int|24
)paren
suffix:semicolon
r_goto
id|reset_all
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;if old phase not dataphase, leave here.&n;&t;*/
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x06
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;phase change %x-%x %d@%08x resid=%d.&bslash;n&quot;
comma
id|cmd
op_amp
l_int|7
comma
id|INB
c_func
(paren
id|nc_sbcl
)paren
op_amp
l_int|7
comma
(paren
r_int
)paren
id|olen
comma
(paren
r_int
)paren
id|oadr
comma
(paren
r_int
)paren
id|rest
)paren
suffix:semicolon
r_goto
id|unexpected_phase
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Choose the correct PM save area.&n;&t;**&n;&t;**&t;Look at the PM_SAVE SCRIPT if you want to understand &n;&t;**&t;this stuff. The equivalent code is implemented in &n;&t;**&t;SCRIPTS for the 896 that is able to handle PM from &n;&t;**&t;the SCRIPTS processor.&n;&t;*/
id|hflags0
op_assign
id|INB
(paren
id|HF_PRT
)paren
suffix:semicolon
id|hflags
op_assign
id|hflags0
suffix:semicolon
r_if
c_cond
(paren
id|hflags
op_amp
(paren
id|HF_IN_PM0
op_or
id|HF_IN_PM1
op_or
id|HF_DP_SAVED
)paren
)paren
(brace
r_if
c_cond
(paren
id|hflags
op_amp
id|HF_IN_PM0
)paren
id|nxtdsp
op_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.pm0.ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hflags
op_amp
id|HF_IN_PM1
)paren
id|nxtdsp
op_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.pm1.ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hflags
op_amp
id|HF_DP_SAVED
)paren
id|hflags
op_xor_assign
id|HF_ACT_PM
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hflags
op_amp
id|HF_ACT_PM
)paren
)paren
(brace
id|pm
op_assign
op_amp
id|cp-&gt;phys.pm0
suffix:semicolon
id|newcmd
op_assign
id|NCB_SCRIPT_PHYS
c_func
(paren
id|np
comma
id|pm0_data
)paren
suffix:semicolon
)brace
r_else
(brace
id|pm
op_assign
op_amp
id|cp-&gt;phys.pm1
suffix:semicolon
id|newcmd
op_assign
id|NCB_SCRIPT_PHYS
c_func
(paren
id|np
comma
id|pm1_data
)paren
suffix:semicolon
)brace
id|hflags
op_and_assign
op_complement
(paren
id|HF_IN_PM0
op_or
id|HF_IN_PM1
op_or
id|HF_DP_SAVED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hflags
op_ne
id|hflags0
)paren
id|OUTB
(paren
id|HF_PRT
comma
id|hflags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;fillin the phase mismatch context&n;&t;*/
id|pm-&gt;sg.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|oadr
op_plus
id|olen
op_minus
id|rest
)paren
suffix:semicolon
id|pm-&gt;sg.size
op_assign
id|cpu_to_scr
c_func
(paren
id|rest
)paren
suffix:semicolon
id|pm-&gt;ret
op_assign
id|cpu_to_scr
c_func
(paren
id|nxtdsp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;PM %x %x %x / %x %x %x.&bslash;n&quot;
comma
id|hflags0
comma
id|hflags
comma
id|newcmd
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|pm-&gt;sg.addr
)paren
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|pm-&gt;sg.size
)paren
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|pm-&gt;ret
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;fake the return address (to the patch).&n;&t;**&t;and restart script processor at dispatcher.&n;&t;*/
id|OUTL
(paren
id|nc_temp
comma
id|newcmd
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|databreak
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Unexpected phase changes that occurs when the current phase &n;&t;**&t;is not a DATA IN or DATA OUT phase are due to error conditions.&n;&t;**&t;Such event may only happen when the SCRIPTS is using a &n;&t;**&t;multibyte SCSI MOVE.&n;&t;**&n;&t;**&t;Phase change&t;&t;Some possible cause&n;&t;**&n;&t;**&t;COMMAND  --&gt; MSG IN&t;SCSI parity error detected by target.&n;&t;**&t;COMMAND  --&gt; STATUS&t;Bad command or refused by target.&n;&t;**&t;MSG OUT  --&gt; MSG IN     Message rejected by target.&n;&t;**&t;MSG OUT  --&gt; COMMAND    Bogus target that discards extended&n;&t;**&t;&t;&t;&t;negotiation messages.&n;&t;**&n;&t;**&t;The code below does not care of the new phase and so &n;&t;**&t;trusts the target. Why to annoy it ?&n;&t;**&t;If the interrupted phase is COMMAND phase, we restart at&n;&t;**&t;dispatcher.&n;&t;**&t;If a target does not get all the messages after selection, &n;&t;**&t;the code assumes blindly that the target discards extended &n;&t;**&t;messages and clears the negotiation status.&n;&t;**&t;If the target does not want all our response to negotiation,&n;&t;**&t;we force a SIR_NEGO_PROTO interrupt (it is a hack that avoids &n;&t;**&t;bloat for such a should_not_happen situation).&n;&t;**&t;In all other situation, we reset the BUS.&n;&t;**&t;Are these assumptions reasonnable ? (Wait and see ...)&n;&t;*/
id|unexpected_phase
suffix:colon
id|dsp
op_sub_assign
l_int|8
suffix:semicolon
id|nxtdsp
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
op_amp
l_int|7
)paren
(brace
r_case
l_int|2
suffix:colon
multiline_comment|/* COMMAND phase */
id|nxtdsp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|dispatch
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if 0
r_case
l_int|3
suffix:colon
multiline_comment|/* STATUS  phase */
id|nxtdsp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|dispatch
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
l_int|6
suffix:colon
multiline_comment|/* MSG OUT phase */
multiline_comment|/*&n;&t;&t;**&t;If the device may want to use untagged when we want &n;&t;&t;**&t;tagged, we prepare an IDENTIFY without disc. granted, &n;&t;&t;**&t;since we will not be able to handle reselect.&n;&t;&t;**&t;Otherwise, we just don&squot;t care.&n;&t;&t;*/
r_if
c_cond
(paren
id|dsp
op_eq
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|send_ident
)paren
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;tag
op_ne
id|NO_TAG
op_logical_and
id|olen
op_minus
id|rest
op_le
l_int|3
)paren
(brace
id|cp-&gt;host_status
op_assign
id|HS_BUSY
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_IDENTIFY
op_or
id|cp-&gt;lun
suffix:semicolon
id|nxtdsp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|ident_break_atn
)paren
suffix:semicolon
)brace
r_else
id|nxtdsp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|ident_break
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dsp
op_eq
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|send_wdtr
)paren
op_logical_or
id|dsp
op_eq
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|send_sdtr
)paren
)paren
(brace
id|nxtdsp
op_assign
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|nego_bad_phase
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#if 0
r_case
l_int|7
suffix:colon
multiline_comment|/* MSG IN  phase */
id|nxtdsp
op_assign
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|nxtdsp
)paren
(brace
id|OUTL
(paren
id|nc_dsp
comma
id|nxtdsp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|reset_all
suffix:colon
id|ncr_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;ncr chip handler for QUEUE FULL and CHECK CONDITION&n;**&n;**==========================================================&n;**&n;**&t;On QUEUE FULL status, we set the actual tagged command &n;**&t;queue depth to the number of disconnected CCBs that is &n;**&t;hopefully a good value to avoid further QUEUE FULL.&n;**&n;**&t;On CHECK CONDITION or COMMAND TERMINATED, we use the  &n;**&t;CCB of the failed command for performing a REQUEST &n;**&t;SENSE SCSI command.&n;**&n;**&t;We do not want to change the order commands will be &n;**&t;actually queued to the device after we received a &n;**&t;QUEUE FULL status. We also want to properly deal with &n;**&t;contingent allegiance condition. For these reasons, &n;**&t;we remove from the start queue all commands for this &n;**&t;LUN that haven&squot;t been yet queued to the device and &n;**&t;put them back in the correponding LUN queue, then  &n;**&t;requeue the CCB that failed in front of the LUN queue.&n;**&t;I just hope this not to be performed too often. :)&n;**&n;**----------------------------------------------------------&n;*/
DECL|function|ncr_sir_to_redo
r_static
r_void
id|ncr_sir_to_redo
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|num
comma
id|ccb_p
id|cp
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|tp-&gt;lp
(braket
id|cp-&gt;lun
)braket
suffix:semicolon
id|ccb_p
id|cp2
suffix:semicolon
r_int
id|busyccbs
op_assign
l_int|1
suffix:semicolon
id|u_int32
id|startp
suffix:semicolon
id|u_char
id|s_status
op_assign
id|INB
(paren
id|SS_PRT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Remove all CCBs queued to the chip for that LUN and put &n;&t;**&t;them back in the LUN CCB wait queue.&n;&t;*/
r_if
c_cond
(paren
id|lp
)paren
(brace
r_int
id|i
op_assign
id|np-&gt;squeueput
suffix:semicolon
r_int
id|j
op_assign
(paren
id|INL
(paren
id|nc_scratcha
)paren
op_minus
id|vtobus
c_func
(paren
id|np-&gt;squeue
)paren
)paren
op_div
l_int|4
suffix:semicolon
r_int
id|k
op_assign
id|np-&gt;squeueput
suffix:semicolon
id|busyccbs
op_assign
id|lp-&gt;queuedccbs
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|j
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|i
op_assign
id|MAX_START
op_star
l_int|2
suffix:semicolon
id|i
op_assign
id|i
op_minus
l_int|2
suffix:semicolon
id|cp2
op_assign
id|ncr_ccb_from_dsa
c_func
(paren
id|np
comma
id|scr_to_cpu
c_func
(paren
id|np-&gt;squeue
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp2
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp2-&gt;target
op_ne
id|cp-&gt;target
op_logical_or
id|cp2-&gt;lun
op_ne
id|cp-&gt;lun
)paren
r_continue
suffix:semicolon
id|xpt_remque
c_func
(paren
op_amp
id|cp2-&gt;link_ccbq
)paren
suffix:semicolon
id|xpt_insque_head
c_func
(paren
op_amp
id|cp2-&gt;link_ccbq
comma
op_amp
id|lp-&gt;wait_ccbq
)paren
suffix:semicolon
op_decrement
id|lp-&gt;queuedccbs
suffix:semicolon
id|cp2-&gt;queued
op_assign
l_int|0
suffix:semicolon
id|np-&gt;squeue
(braket
id|i
)braket
op_assign
id|DSA_INVALID
suffix:semicolon
id|k
op_assign
id|i
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Requeue the interrupted CCB in front of &n;&t;&t;**&t;the LUN CCB wait queue.&n;&t;&t;*/
id|xpt_remque
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
)paren
suffix:semicolon
id|xpt_insque_head
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|lp-&gt;wait_ccbq
)paren
suffix:semicolon
op_decrement
id|lp-&gt;queuedccbs
suffix:semicolon
id|cp-&gt;queued
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Repair the startqueue if necessary.&n;&t;&t;*/
r_if
c_cond
(paren
id|k
op_ne
id|np-&gt;squeueput
)paren
(brace
id|j
op_assign
id|k
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|j
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|j
op_ge
id|MAX_START
op_star
l_int|2
)paren
id|j
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;squeue
(braket
id|j
)braket
op_eq
id|DSA_INVALID
)paren
r_continue
suffix:semicolon
id|np-&gt;squeue
(braket
id|k
)braket
op_assign
id|np-&gt;squeue
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
id|np-&gt;squeueput
)paren
r_break
suffix:semicolon
id|k
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|k
op_ge
id|MAX_START
op_star
l_int|2
)paren
id|k
op_assign
l_int|0
suffix:semicolon
)brace
id|np-&gt;squeueput
op_assign
id|k
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;Now we can restart the SCRIPTS processor safely.&n;&t;*/
id|MEMORY_BARRIER
c_func
(paren
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|start
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|s_status
)paren
(brace
r_default
suffix:colon
(brace
)brace
multiline_comment|/* Just for safety, should never happen */
r_case
id|S_QUEUE_FULL
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|lp
op_logical_or
op_logical_neg
id|lp-&gt;queuedccbs
)paren
(brace
id|ncr_complete
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|1
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;QUEUE FULL! %d busy, %d disconnected CCBs&bslash;n&quot;
comma
id|busyccbs
comma
id|lp-&gt;queuedccbs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Decrease number of tags to the number of &n;&t;&t;**&t;disconnected commands.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp-&gt;queuedccbs
OL
id|lp-&gt;numtags
)paren
(brace
id|lp-&gt;numtags
op_assign
id|lp-&gt;queuedccbs
suffix:semicolon
id|lp-&gt;num_good
op_assign
l_int|0
suffix:semicolon
id|ncr_setup_tags
(paren
id|np
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Repair the offending CCB.&n;&t;&t;*/
id|cp-&gt;phys.header.savep
op_assign
id|cp-&gt;startp
suffix:semicolon
id|cp-&gt;host_status
op_assign
id|HS_BUSY
suffix:semicolon
id|cp-&gt;scsi_status
op_assign
id|S_ILLEGAL
suffix:semicolon
id|cp-&gt;host_flags
op_and_assign
id|HF_PM_TO_C
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_TERMINATED
suffix:colon
r_case
id|S_CHECK_COND
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;If we were requesting sense, give up.&n;&t;&t;*/
r_if
c_cond
(paren
id|cp-&gt;auto_sense
)paren
(brace
id|ncr_complete
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Device returned CHECK CONDITION status.&n;&t;&t;**&t;Prepare all needed data strutures for getting &n;&t;&t;**&t;sense data.&n;&t;&t;*/
multiline_comment|/*&n;&t;&t;**&t;identify message&n;&t;&t;*/
id|cp-&gt;scsi_smsg2
(braket
l_int|0
)braket
op_assign
id|M_IDENTIFY
op_or
id|cp-&gt;lun
suffix:semicolon
id|cp-&gt;phys.smsg.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|scsi_smsg2
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.smsg.size
op_assign
id|cpu_to_scr
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;sense command&n;&t;&t;*/
id|cp-&gt;phys.cmd.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_PHYS
(paren
id|cp
comma
id|sensecmd
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.cmd.size
op_assign
id|cpu_to_scr
c_func
(paren
l_int|6
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;patch requested size into sense command&n;&t;&t;*/
id|cp-&gt;sensecmd
(braket
l_int|0
)braket
op_assign
l_int|0x03
suffix:semicolon
id|cp-&gt;sensecmd
(braket
l_int|1
)braket
op_assign
id|cp-&gt;lun
op_lshift
l_int|5
suffix:semicolon
id|cp-&gt;sensecmd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;sense data&n;&t;&t;*/
id|cp-&gt;phys.sense.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
(paren
op_amp
id|cmd-&gt;sense_buffer
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.sense.size
op_assign
id|cpu_to_scr
c_func
(paren
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;requeue the command.&n;&t;&t;*/
id|startp
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|sdata_in
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.header.savep
op_assign
id|startp
suffix:semicolon
id|cp-&gt;phys.header.goalp
op_assign
id|startp
op_plus
l_int|24
suffix:semicolon
id|cp-&gt;phys.header.lastp
op_assign
id|startp
suffix:semicolon
id|cp-&gt;phys.header.wgoalp
op_assign
id|startp
op_plus
l_int|24
suffix:semicolon
id|cp-&gt;phys.header.wlastp
op_assign
id|startp
suffix:semicolon
id|cp-&gt;host_status
op_assign
id|HS_BUSY
suffix:semicolon
id|cp-&gt;scsi_status
op_assign
id|S_ILLEGAL
suffix:semicolon
id|cp-&gt;host_flags
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;auto_sense
op_assign
id|s_status
suffix:semicolon
id|cp-&gt;phys.header.go.start
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|select
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Select without ATN for quirky devices.&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;quirks
op_amp
id|QUIRK_NOMSG
)paren
id|cp-&gt;phys.header.go.start
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
(paren
id|np
comma
id|select_no_atn
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;If lp not yet allocated, requeue the command.&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
id|ncr_put_start_queue
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;requeue awaiting scsi commands for this lun.&n;&t;*/
r_if
c_cond
(paren
id|lp
)paren
id|ncr_start_next_ccb
c_func
(paren
id|np
comma
id|lp
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      ncr chip exception handler for programmed interrupts.&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_show_msg
r_static
r_int
id|ncr_show_msg
(paren
id|u_char
op_star
id|msg
)paren
(brace
id|u_char
id|i
suffix:semicolon
id|printk
(paren
l_string|&quot;%x&quot;
comma
op_star
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|msg
op_eq
id|M_EXTENDED
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_minus
l_int|1
OG
id|msg
(braket
l_int|1
)braket
)paren
r_break
suffix:semicolon
id|printk
(paren
l_string|&quot;-%x&quot;
comma
id|msg
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
id|i
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
op_star
id|msg
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
(brace
id|printk
(paren
l_string|&quot;-%x&quot;
comma
id|msg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
(paren
l_int|2
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|ncr_int_sir
r_void
id|ncr_int_sir
(paren
id|ncb_p
id|np
)paren
(brace
id|u_char
id|scntl3
suffix:semicolon
id|u_char
id|chg
comma
id|ofs
comma
id|per
comma
id|fak
comma
id|wide
suffix:semicolon
id|u_char
id|num
op_assign
id|INB
(paren
id|nc_dsps
)paren
suffix:semicolon
id|ccb_p
id|cp
op_assign
l_int|0
suffix:semicolon
id|u_long
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|u_char
id|target
op_assign
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;I#%d&quot;
comma
id|num
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|num
)paren
(brace
r_case
id|SIR_SEL_ATN_NO_MSG_OUT
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;The device didn&squot;t go to MSG OUT phase after having &n;&t;&t;**&t;been selected with ATN. We donnot want to handle &n;&t;&t;**&t;that.&n;&t;&t;*/
id|printk
(paren
l_string|&quot;%s:%d: No MSG OUT phase after selection with ATN.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|target
)paren
suffix:semicolon
r_goto
id|out_stuck
suffix:semicolon
r_case
id|SIR_RESEL_NO_MSG_IN
suffix:colon
r_case
id|SIR_RESEL_NO_IDENTIFY
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;If devices reselecting without sending an IDENTIFY &n;&t;&t;**&t;message still exist, this should help.&n;&t;&t;**&t;We just assume lun=0, 1 CCB, no tag.&n;&t;&t;*/
r_if
c_cond
(paren
id|tp-&gt;lp
(braket
l_int|0
)braket
)paren
(brace
id|OUTL
(paren
id|nc_dsa
comma
id|scr_to_cpu
c_func
(paren
id|tp-&gt;lp
(braket
l_int|0
)braket
op_member_access_from_pointer
id|tasktbl
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|resel_go
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_case
id|SIR_RESEL_BAD_LUN
suffix:colon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_RESET
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
id|SIR_RESEL_BAD_I_T_L
suffix:colon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_ABORT
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
id|SIR_RESEL_BAD_I_T_L_Q
suffix:colon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_ABORT_TAG
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
id|SIR_RESEL_ABORTED
suffix:colon
id|np-&gt;lastmsg
op_assign
id|np-&gt;msgout
(braket
l_int|0
)braket
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|printk
(paren
l_string|&quot;%s:%d: message %d sent on bad reselection.&bslash;n&quot;
comma
id|ncr_name
(paren
id|np
)paren
comma
id|target
comma
id|np-&gt;lastmsg
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
id|SIR_MSG_OUT_DONE
suffix:colon
id|np-&gt;lastmsg
op_assign
id|np-&gt;msgout
(braket
l_int|0
)braket
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
multiline_comment|/* Should we really care of that */
r_if
c_cond
(paren
id|np-&gt;lastmsg
op_eq
id|M_PARITY
op_logical_or
id|np-&gt;lastmsg
op_eq
id|M_ID_ERROR
)paren
id|OUTOFFB
(paren
id|HF_PRT
comma
id|HF_PAR_ERR
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
id|SIR_BAD_STATUS
suffix:colon
id|cp
op_assign
id|ncr_ccb_from_dsa
c_func
(paren
id|np
comma
id|dsa
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_goto
id|out
suffix:semicolon
id|ncr_sir_to_redo
c_func
(paren
id|np
comma
id|num
comma
id|cp
)paren
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;lookup the ccb&n;&t;&t;*/
id|cp
op_assign
id|ncr_ccb_from_dsa
c_func
(paren
id|np
comma
id|dsa
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_goto
id|out
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|num
)paren
(brace
multiline_comment|/*-----------------------------------------------------------------------------&n;**&n;**&t;Was Sie schon immer ueber transfermode negotiation wissen wollten ...&n;**&n;**&t;We try to negotiate sync and wide transfer only after&n;**&t;a successfull inquire command. We look at byte 7 of the&n;**&t;inquire data to determine the capabilities of the target.&n;**&n;**&t;When we try to negotiate, we append the negotiation message&n;**&t;to the identify and (maybe) simple tag message.&n;**&t;The host status field is set to HS_NEGOTIATE to mark this&n;**&t;situation.&n;**&n;**&t;If the target doesn&squot;t answer this message immidiately&n;**&t;(as required by the standard), the SIR_NEGO_FAIL interrupt&n;**&t;will be raised eventually.&n;**&t;The handler removes the HS_NEGOTIATE status, and sets the&n;**&t;negotiated value to the default (async / nowide).&n;**&n;**&t;If we receive a matching answer immediately, we check it&n;**&t;for validity, and set the values.&n;**&n;**&t;If we receive a Reject message immediately, we assume the&n;**&t;negotiation has failed, and fall back to standard values.&n;**&n;**&t;If we receive a negotiation message while not in HS_NEGOTIATE&n;**&t;state, it&squot;s a target initiated negotiation. We prepare a&n;**&t;(hopefully) valid answer, set our parameters, and send back &n;**&t;this answer to the target.&n;**&n;**&t;If the target doesn&squot;t fetch the answer (no message out phase),&n;**&t;we assume the negotiation has failed, and fall back to default&n;**&t;settings.&n;**&n;**&t;When we set the values, we adjust them in all ccbs belonging &n;**&t;to this target, in the controller&squot;s register, and in the &quot;phys&quot;&n;**&t;field of the controller&squot;s struct ncb.&n;**&n;**&t;Possible cases:&t;&t;   hs  sir   msg_in value  send   goto&n;**&t;We try to negotiate:&n;**&t;-&gt; target doesnt&squot;t msgin   NEG FAIL  noop   defa.  -      dispatch&n;**&t;-&gt; target rejected our msg NEG FAIL  reject defa.  -      dispatch&n;**&t;-&gt; target answered  (ok)   NEG SYNC  sdtr   set    -      clrack&n;**&t;-&gt; target answered (!ok)   NEG SYNC  sdtr   defa.  REJ---&gt;msg_bad&n;**&t;-&gt; target answered  (ok)   NEG WIDE  wdtr   set    -      clrack&n;**&t;-&gt; target answered (!ok)   NEG WIDE  wdtr   defa.  REJ---&gt;msg_bad&n;**&t;-&gt; any other msgin&t;   NEG FAIL  noop   defa.  -      dispatch&n;**&n;**&t;Target tries to negotiate:&n;**&t;-&gt; incoming message&t;   --- SYNC  sdtr   set    SDTR   -&n;**&t;-&gt; incoming message&t;   --- WIDE  wdtr   set    WDTR   -&n;**      We sent our answer:&n;**&t;-&gt; target doesn&squot;t msgout   --- PROTO ?      defa.  -      dispatch&n;**&n;**-----------------------------------------------------------------------------&n;*/
r_case
id|SIR_NEGO_FAILED
suffix:colon
multiline_comment|/*-------------------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;Negotiation failed.&n;&t;&t;**&t;Target doesn&squot;t send an answer message,&n;&t;&t;**&t;or target rejected our message.&n;&t;&t;**&n;&t;&t;**      Remove negotiation request.&n;&t;&t;**&n;&t;&t;**-------------------------------------------------------&n;&t;&t;*/
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SIR_NEGO_PROTO
suffix:colon
multiline_comment|/*-------------------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;Negotiation failed.&n;&t;&t;**&t;Target doesn&squot;t fetch the answer message.&n;&t;&t;**&n;&t;&t;**-------------------------------------------------------&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;negotiation failed sir=%x status=%x.&bslash;n&quot;
comma
id|num
comma
id|cp-&gt;nego_status
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;any error in negotiation:&n;&t;&t;**&t;fall back to default mode.&n;&t;&t;*/
r_switch
c_cond
(paren
id|cp-&gt;nego_status
)paren
(brace
r_case
id|NS_SYNC
suffix:colon
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0xe0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|cp-&gt;nego_status
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIR_NEGO_SYNC
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;Synchronous request message received.&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;sync msgin: &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgin
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;get requested values.&n;&t;&t;*/
id|chg
op_assign
l_int|0
suffix:semicolon
id|per
op_assign
id|np-&gt;msgin
(braket
l_int|3
)braket
suffix:semicolon
id|ofs
op_assign
id|np-&gt;msgin
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_eq
l_int|0
)paren
id|per
op_assign
l_int|255
suffix:semicolon
multiline_comment|/*&n;&t;&t;**      if target sends SDTR message,&n;&t;&t;**&t;      it CAN transfer synch.&n;&t;&t;*/
r_if
c_cond
(paren
id|ofs
)paren
id|tp-&gt;inq_byte7
op_or_assign
id|INQ7_SYNC
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;check values against driver limits.&n;&t;&t;*/
r_if
c_cond
(paren
id|per
OL
id|np-&gt;minsync
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|per
op_assign
id|np-&gt;minsync
suffix:semicolon
)brace
r_if
c_cond
(paren
id|per
OL
id|tp-&gt;minsync
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|per
op_assign
id|tp-&gt;minsync
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ofs
OG
id|tp-&gt;maxoffs
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
id|tp-&gt;maxoffs
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Check against controller limits.&n;&t;&t;*/
id|fak
op_assign
l_int|7
suffix:semicolon
id|scntl3
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_ne
l_int|0
)paren
(brace
id|ncr_getsync
c_func
(paren
id|np
comma
id|per
comma
op_amp
id|fak
comma
op_amp
id|scntl3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fak
OG
l_int|7
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ofs
op_eq
l_int|0
)paren
(brace
id|fak
op_assign
l_int|7
suffix:semicolon
id|per
op_assign
l_int|0
suffix:semicolon
id|scntl3
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;minsync
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;sync: per=%d scntl3=0x%x ofs=%d fak=%d chg=%d.&bslash;n&quot;
comma
id|per
comma
id|scntl3
comma
id|ofs
comma
id|fak
comma
id|chg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INB
(paren
id|HS_PRT
)paren
op_eq
id|HS_NEGOTIATE
)paren
(brace
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;nego_status
)paren
(brace
r_case
id|NS_SYNC
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;**      This was an answer message&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|chg
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;**&t;Answer wasn&squot;t acceptable.&n;&t;&t;&t;&t;&t;*/
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0xe0
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;**&t;Answer is ok.&n;&t;&t;&t;&t;&t;*/
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
id|scntl3
comma
(paren
id|fak
op_lshift
l_int|5
)paren
op_or
id|ofs
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;It was a request. Set value and&n;&t;&t;**      prepare an answer message&n;&t;&t;*/
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
id|scntl3
comma
(paren
id|fak
op_lshift
l_int|5
)paren
op_or
id|ofs
)paren
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|1
)braket
op_assign
l_int|3
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|2
)braket
op_assign
id|M_X_SYNC_REQ
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|3
)braket
op_assign
id|per
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|4
)braket
op_assign
id|ofs
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|NS_SYNC
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;sync msgout: &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgout
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ofs
)paren
(brace
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIR_NEGO_WIDE
suffix:colon
multiline_comment|/*&n;&t;&t;**&t;Wide request message received.&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;wide msgin: &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgin
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;get requested values.&n;&t;&t;*/
id|chg
op_assign
l_int|0
suffix:semicolon
id|wide
op_assign
id|np-&gt;msgin
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;**      if target sends WDTR message,&n;&t;&t;**&t;      it CAN transfer wide.&n;&t;&t;*/
r_if
c_cond
(paren
id|wide
)paren
id|tp-&gt;inq_byte7
op_or_assign
id|INQ7_WIDE16
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;check values against driver limits.&n;&t;&t;*/
r_if
c_cond
(paren
id|wide
OG
id|tp-&gt;usrwide
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|wide
op_assign
id|tp-&gt;usrwide
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;wide: wide=%d chg=%d.&bslash;n&quot;
comma
id|wide
comma
id|chg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INB
(paren
id|HS_PRT
)paren
op_eq
id|HS_NEGOTIATE
)paren
(brace
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cp-&gt;nego_status
)paren
(brace
r_case
id|NS_WIDE
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;**      This was an answer message&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|chg
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;**&t;Answer wasn&squot;t acceptable.&n;&t;&t;&t;&t;&t;*/
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;**&t;Answer is ok.&n;&t;&t;&t;&t;&t;*/
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
id|wide
comma
l_int|1
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
r_case
id|NS_SYNC
suffix:colon
id|ncr_setsync
(paren
id|np
comma
id|cp
comma
l_int|0
comma
l_int|0xe0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;It was a request, set value and&n;&t;&t;**      prepare an answer message&n;&t;&t;*/
id|ncr_setwide
(paren
id|np
comma
id|cp
comma
id|wide
comma
l_int|1
)paren
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|2
)braket
op_assign
id|M_X_WIDE_REQ
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|3
)braket
op_assign
id|wide
suffix:semicolon
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|NS_WIDE
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;wide msgout: &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgin
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*--------------------------------------------------------------------&n;**&n;**&t;Processing of special messages&n;**&n;**--------------------------------------------------------------------&n;*/
r_case
id|SIR_REJECT_RECEIVED
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;We received a M_REJECT message.&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;M_REJECT received (%x:%x).&bslash;n&quot;
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|np-&gt;lastmsg
)paren
comma
id|np-&gt;msgout
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIR_REJECT_TO_SEND
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;We received an unknown message&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;M_REJECT to send for &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|ncr_show_msg
(paren
id|np-&gt;msgin
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_REJECT
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*--------------------------------------------------------------------&n;**&n;**&t;Processing of special messages&n;**&n;**--------------------------------------------------------------------&n;*/
r_case
id|SIR_IGN_RESIDUE
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;We received an IGNORE RESIDUE message,&n;&t;&t;**&t;which couldn&squot;t be handled by the script.&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;M_IGN_RESIDUE received, but not yet implemented.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if 0
r_case
id|SIR_MISSING_SAVE
suffix:colon
multiline_comment|/*-----------------------------------------------&n;&t;&t;**&n;&t;&t;**&t;We received an DISCONNECT message,&n;&t;&t;**&t;but the datapointer wasn&squot;t saved before.&n;&t;&t;**&n;&t;&t;**-----------------------------------------------&n;&t;&t;*/
id|PRINT_ADDR
c_func
(paren
id|cp-&gt;cmd
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;M_DISCONNECT received, but datapointer not saved: &quot;
l_string|&quot;data=%x save=%x goal=%x.&bslash;n&quot;
comma
(paren
r_int
)paren
id|INL
(paren
id|nc_temp
)paren
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|np-&gt;header.savep
)paren
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|np-&gt;header.goalp
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
id|out
suffix:colon
id|OUTONB
(paren
id|nc_dcntl
comma
(paren
id|STD
op_or
id|NOCOM
)paren
)paren
suffix:semicolon
id|out_stuck
suffix:colon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Aquire a control block&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_get_ccb
r_static
id|ccb_p
id|ncr_get_ccb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|tp-&gt;lp
(braket
id|ln
)braket
suffix:semicolon
id|u_char
id|tag
op_assign
id|NO_TAG
suffix:semicolon
id|XPT_QUEHEAD
op_star
id|qp
suffix:semicolon
id|ccb_p
id|cp
op_assign
(paren
id|ccb_p
)paren
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate a new CCB if needed.&n;&t;*/
r_if
c_cond
(paren
id|xpt_que_empty
c_func
(paren
op_amp
id|np-&gt;free_ccbq
)paren
)paren
(paren
r_void
)paren
id|ncr_alloc_ccb
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Look for a free CCB&n;&t;*/
id|qp
op_assign
id|xpt_remque_head
c_func
(paren
op_amp
id|np-&gt;free_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qp
)paren
r_goto
id|out
suffix:semicolon
id|cp
op_assign
id|xpt_que_entry
c_func
(paren
id|qp
comma
r_struct
id|ccb
comma
id|link_ccbq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If the LCB is not yet available and we already &n;&t;**&t;have queued a CCB for a LUN without LCB,&n;&t;**&t;give up. Otherwise all is fine. :-)&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
(brace
r_if
c_cond
(paren
id|xpt_que_empty
c_func
(paren
op_amp
id|np-&gt;b0_ccbq
)paren
)paren
id|xpt_insque_head
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;b0_ccbq
)paren
suffix:semicolon
r_else
r_goto
id|out_free
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;**&t;Tune tag mode if asked by user.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp-&gt;queuedepth
op_ne
id|lp-&gt;numtags
)paren
(brace
id|ncr_setup_tags
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Get a tag for this nexus if required.&n;&t;&t;**&t;Keep from using more tags than we can handle.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp-&gt;usetags
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;busyccbs
OL
id|lp-&gt;maxnxs
)paren
(brace
id|tag
op_assign
id|lp-&gt;cb_tags
(braket
id|lp-&gt;ia_tag
)braket
suffix:semicolon
op_increment
id|lp-&gt;ia_tag
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;ia_tag
op_eq
id|SCSI_NCR_MAX_TAGS
)paren
id|lp-&gt;ia_tag
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tags_umap
op_or_assign
(paren
(paren
(paren
id|tagmap_t
)paren
l_int|1
)paren
op_lshift
id|tag
)paren
suffix:semicolon
)brace
r_else
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;**&t;Put the CCB in the LUN wait queue and &n;&t;&t;**&t;count it as busy.&n;&t;&t;*/
id|xpt_insque_tail
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|lp-&gt;wait_ccbq
)paren
suffix:semicolon
op_increment
id|lp-&gt;busyccbs
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Remember all informations needed to free this CCB.&n;&t;*/
id|cp-&gt;tag
op_assign
id|tag
suffix:semicolon
id|cp-&gt;target
op_assign
id|tn
suffix:semicolon
id|cp-&gt;lun
op_assign
id|ln
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ccb @%p using tag %d.&bslash;n&quot;
comma
id|cp
comma
id|tag
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|cp
suffix:semicolon
id|out_free
suffix:colon
id|xpt_insque_head
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;free_ccbq
)paren
suffix:semicolon
r_return
(paren
id|ccb_p
)paren
l_int|0
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Release one control block&n;**&n;**&n;**==========================================================&n;*/
DECL|function|ncr_free_ccb
r_static
r_void
id|ncr_free_ccb
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|tp-&gt;lp
(braket
id|cp-&gt;lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ccb @%p freeing tag %d.&bslash;n&quot;
comma
id|cp
comma
id|cp-&gt;tag
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If lun control block available, make available &n;&t;**&t;the task slot and the tag if any.&n;&t;**&t;Decrement counters.&n;&t;*/
r_if
c_cond
(paren
id|lp
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;tag
op_ne
id|NO_TAG
)paren
(brace
id|lp-&gt;cb_tags
(braket
id|lp-&gt;if_tag
op_increment
)braket
op_assign
id|cp-&gt;tag
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;if_tag
op_eq
id|SCSI_NCR_MAX_TAGS
)paren
id|lp-&gt;if_tag
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tags_umap
op_and_assign
op_complement
(paren
(paren
(paren
id|tagmap_t
)paren
l_int|1
)paren
op_lshift
id|cp-&gt;tag
)paren
suffix:semicolon
id|lp-&gt;tags_smap
op_and_assign
id|lp-&gt;tags_umap
suffix:semicolon
id|lp-&gt;tasktbl
(braket
id|cp-&gt;tag
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;p_bad_i_t_l_q
)paren
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;tasktbl
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;p_bad_i_t_l
)paren
suffix:semicolon
)brace
op_decrement
id|lp-&gt;busyccbs
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;queued
)paren
(brace
op_decrement
id|lp-&gt;queuedccbs
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;**&t;Make this CCB available.&n;&t;*/
id|xpt_remque
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
)paren
suffix:semicolon
id|xpt_insque_head
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;free_ccbq
)paren
suffix:semicolon
id|cp
op_member_access_from_pointer
id|host_status
op_assign
id|HS_IDLE
suffix:semicolon
id|cp
op_member_access_from_pointer
id|queued
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------------&n;**&t;Allocate a CCB and initialize its fixed part.&n;**------------------------------------------------------------------------&n;**------------------------------------------------------------------------&n;*/
DECL|function|ncr_alloc_ccb
r_static
id|ccb_p
id|ncr_alloc_ccb
c_func
(paren
id|ncb_p
id|np
)paren
(brace
id|ccb_p
id|cp
op_assign
l_int|0
suffix:semicolon
r_int
id|hcode
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate memory for this CCB.&n;&t;*/
id|cp
op_assign
id|m_calloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ccb
)paren
comma
l_string|&quot;CCB&quot;
comma
id|MEMO_WARN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Count it and initialyze it.&n;&t;*/
id|np-&gt;actccbs
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Remember virtual and bus address of this ccb.&n;&t;*/
id|cp-&gt;p_ccb
op_assign
id|vtobus
c_func
(paren
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Insert this ccb into the hashed list.&n;&t;*/
id|hcode
op_assign
id|CCB_HASH_CODE
c_func
(paren
id|cp-&gt;p_ccb
)paren
suffix:semicolon
id|cp-&gt;link_ccbh
op_assign
id|np-&gt;ccbh
(braket
id|hcode
)braket
suffix:semicolon
id|np-&gt;ccbh
(braket
id|hcode
)braket
op_assign
id|cp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialyze the start and restart actions.&n;&t;*/
id|cp-&gt;phys.header.go.start
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.header.go.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPTH_PHYS
c_func
(paren
id|np
comma
id|bad_i_t_l
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Chain into wakeup list and free ccb queue.&n;&t;*/
id|cp-&gt;link_ccb
op_assign
id|np-&gt;ccbc
suffix:semicolon
id|np-&gt;ccbc
op_assign
id|cp
suffix:semicolon
id|xpt_insque_head
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;free_ccbq
)paren
suffix:semicolon
r_return
id|cp
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------------&n;**&t;Look up a CCB from a DSA value.&n;**------------------------------------------------------------------------&n;**------------------------------------------------------------------------&n;*/
DECL|function|ncr_ccb_from_dsa
r_static
id|ccb_p
id|ncr_ccb_from_dsa
c_func
(paren
id|ncb_p
id|np
comma
id|u_long
id|dsa
)paren
(brace
r_int
id|hcode
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
id|hcode
op_assign
id|CCB_HASH_CODE
c_func
(paren
id|dsa
)paren
suffix:semicolon
id|cp
op_assign
id|np-&gt;ccbh
(braket
id|hcode
)braket
suffix:semicolon
r_while
c_loop
(paren
id|cp
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;p_ccb
op_eq
id|dsa
)paren
r_break
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccbh
suffix:semicolon
)brace
r_return
id|cp
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**      Allocation of resources for Targets/Luns/Tags.&n;**&n;**&n;**==========================================================&n;*/
multiline_comment|/*------------------------------------------------------------------------&n;**&t;Target control block initialisation.&n;**------------------------------------------------------------------------&n;**&t;This data structure is fully initialized after a SCSI command &n;**&t;has been successfully completed for this target.&n;**------------------------------------------------------------------------&n;*/
DECL|function|ncr_init_tcb
r_static
r_void
id|ncr_init_tcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Already bone.&n;&t;*/
r_if
c_cond
(paren
id|tp-&gt;luntbl
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate the lcb bus address array.&n;&t;*/
id|tp-&gt;luntbl
op_assign
id|m_calloc
c_func
(paren
l_int|256
comma
l_string|&quot;LUNTBL&quot;
comma
id|MEMO_WARN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;luntbl
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Compute the bus address of this table.&n;&t;*/
id|tp-&gt;b_luntbl
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|tp-&gt;luntbl
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Check some alignments required by the chip.&n;&t;*/
m_assert
(paren
(paren
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_sxfer
)paren
op_xor
m_offsetof
(paren
r_struct
id|tcb
comma
id|sval
)paren
)paren
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
m_assert
(paren
(paren
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_scntl3
)paren
op_xor
m_offsetof
(paren
r_struct
id|tcb
comma
id|wval
)paren
)paren
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------------&n;**&t;Lun control block allocation and initialization.&n;**------------------------------------------------------------------------&n;**&t;This data structure is allocated and initialized after a SCSI &n;**&t;command has been successfully completed for this target/lun.&n;**------------------------------------------------------------------------&n;*/
DECL|function|ncr_alloc_lcb
r_static
id|lcb_p
id|ncr_alloc_lcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|tp-&gt;lp
(braket
id|ln
)braket
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Already done, return.&n;&t;*/
r_if
c_cond
(paren
id|lp
)paren
r_return
id|lp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialize the target control block if not yet.&n;&t;*/
id|ncr_init_tcb
c_func
(paren
id|np
comma
id|tn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;luntbl
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate the lcb.&n;&t;*/
id|lp
op_assign
id|m_calloc
c_func
(paren
r_sizeof
(paren
r_struct
id|lcb
)paren
comma
l_string|&quot;LCB&quot;
comma
id|MEMO_WARN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_goto
id|fail
suffix:semicolon
id|tp-&gt;lp
(braket
id|ln
)braket
op_assign
id|lp
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Make it available to the chip.&n;&t;*/
id|tp-&gt;luntbl
(braket
id|ln
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|lp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialize the CCB queue headers.&n;&t;*/
id|xpt_que_init
c_func
(paren
op_amp
id|lp-&gt;busy_ccbq
)paren
suffix:semicolon
id|xpt_que_init
c_func
(paren
op_amp
id|lp-&gt;wait_ccbq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set max CCBs to 1 and use the default task array &n;&t;**&t;by default.&n;&t;*/
id|lp-&gt;maxnxs
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;tasktbl
op_assign
op_amp
id|lp-&gt;tasktbl_0
suffix:semicolon
id|lp-&gt;b_tasktbl
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|lp-&gt;tasktbl
)paren
)paren
suffix:semicolon
id|lp-&gt;tasktbl
(braket
l_int|0
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;p_notask
)paren
suffix:semicolon
id|lp-&gt;resel_task
op_assign
id|cpu_to_scr
c_func
(paren
id|NCB_SCRIPT_PHYS
c_func
(paren
id|np
comma
id|resel_notag
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Initialize command queuing control.&n;&t;*/
id|lp-&gt;busyccbs
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;queuedccbs
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;queuedepth
op_assign
l_int|1
suffix:semicolon
id|fail
suffix:colon
r_return
id|lp
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------------&n;**&t;Lun control block setup on INQUIRY data received.&n;**------------------------------------------------------------------------&n;**&t;We only support WIDE, SYNC for targets and CMDQ for logical units.&n;**&t;This setup is done on each INQUIRY since we are expecting user &n;**&t;will play with CHANGE DEFINITION commands. :-)&n;**------------------------------------------------------------------------&n;*/
DECL|function|ncr_setup_lcb
r_static
id|lcb_p
id|ncr_setup_lcb
(paren
id|ncb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
comma
id|u_char
op_star
id|inq_data
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|tp-&gt;lp
(braket
id|ln
)braket
suffix:semicolon
id|u_char
id|inq_byte7
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If no lcb, try to allocate it.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|lp
op_logical_and
op_logical_neg
(paren
id|lp
op_assign
id|ncr_alloc_lcb
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
)paren
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Get device quirks from a speciality table.&n;&t;*/
id|tp-&gt;quirks
op_assign
id|ncr_lookup
(paren
id|inq_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;quirks
op_logical_and
id|bootverbose
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;quirks=%x.&bslash;n&quot;
comma
id|tp-&gt;quirks
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Evaluate trustable target/unit capabilities.&n;&t;**&t;We only believe device version &gt;= SCSI-2 that &n;&t;**&t;use appropriate response data format (2).&n;&t;**&t;But it seems that some CCS devices also &n;&t;**&t;support SYNC and I donnot want to frustrate &n;&t;**&t;anybody. ;-)&n;&t;*/
id|inq_byte7
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inq_data
(braket
l_int|2
)braket
op_amp
l_int|0x7
)paren
op_ge
l_int|2
op_logical_and
(paren
id|inq_data
(braket
l_int|3
)braket
op_amp
l_int|0xf
)paren
op_eq
l_int|2
)paren
id|inq_byte7
op_assign
id|inq_data
(braket
l_int|7
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|inq_data
(braket
l_int|2
)braket
op_amp
l_int|0x7
)paren
op_eq
l_int|1
op_logical_and
(paren
id|inq_data
(braket
l_int|3
)braket
op_amp
l_int|0xf
)paren
op_eq
l_int|1
)paren
id|inq_byte7
op_assign
id|INQ7_SYNC
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Throw away announced LUN capabilities if we are told &n;&t;**&t;that there is no real device supported by the logical unit.&n;&t;*/
r_if
c_cond
(paren
(paren
id|inq_data
(braket
l_int|0
)braket
op_amp
l_int|0xe0
)paren
OG
l_int|0x20
op_logical_or
(paren
id|inq_data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
op_eq
l_int|0x1f
)paren
id|inq_byte7
op_and_assign
(paren
id|INQ7_SYNC
op_or
id|INQ7_WIDE16
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;If user is wanting SYNC, force this feature.&n;&t;*/
r_if
c_cond
(paren
id|driver_setup.force_sync_nego
)paren
id|inq_byte7
op_or_assign
id|INQ7_SYNC
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Prepare negotiation if SIP capabilities have changed.&n;&t;*/
id|tp-&gt;inq_done
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inq_byte7
op_xor
id|tp-&gt;inq_byte7
)paren
op_amp
(paren
id|INQ7_SYNC
op_or
id|INQ7_WIDE16
)paren
)paren
(brace
id|tp-&gt;inq_byte7
op_assign
id|inq_byte7
suffix:semicolon
id|ncr_negotiate
c_func
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If unit supports tagged commands, allocate and &n;&t;**&t;initialyze the task table if not yet.&n;&t;*/
r_if
c_cond
(paren
(paren
id|inq_byte7
op_amp
id|INQ7_QUEUE
)paren
op_logical_and
id|lp-&gt;tasktbl
op_eq
op_amp
id|lp-&gt;tasktbl_0
)paren
(brace
id|lp-&gt;tasktbl
op_assign
id|m_calloc
c_func
(paren
l_int|256
comma
l_string|&quot;TASKTBL&quot;
comma
id|MEMO_WARN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;tasktbl
)paren
(brace
id|lp-&gt;tasktbl
op_assign
op_amp
id|lp-&gt;tasktbl_0
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|lp-&gt;b_tasktbl
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|lp-&gt;tasktbl
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
id|lp-&gt;tasktbl
(braket
id|i
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;p_notask
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCSI_NCR_MAX_TAGS
suffix:semicolon
id|i
op_increment
)paren
id|lp-&gt;cb_tags
(braket
id|i
)braket
op_assign
id|i
suffix:semicolon
id|lp-&gt;maxnxs
op_assign
id|SCSI_NCR_MAX_TAGS
suffix:semicolon
id|lp-&gt;tags_stime
op_assign
id|jiffies
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Adjust tagged queueing status if needed.&n;&t;*/
r_if
c_cond
(paren
(paren
id|inq_byte7
op_xor
id|lp-&gt;inq_byte7
)paren
op_amp
id|INQ7_QUEUE
)paren
(brace
id|lp-&gt;inq_byte7
op_assign
id|inq_byte7
suffix:semicolon
id|lp-&gt;numtags
op_assign
id|lp-&gt;maxtags
suffix:semicolon
id|ncr_setup_tags
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
)brace
id|fail
suffix:colon
r_return
id|lp
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Build Scatter Gather Block&n;**&n;**&n;**==========================================================&n;**&n;**&t;The transfer area may be scattered among&n;**&t;several non adjacent physical pages.&n;**&n;**&t;We may use MAX_SCATTER blocks.&n;**&n;**----------------------------------------------------------&n;*/
multiline_comment|/*&n;**&t;We try to reduce the number of interrupts caused&n;**&t;by unexpected phase changes due to disconnects.&n;**&t;A typical harddisk may disconnect before ANY block.&n;**&t;If we wanted to avoid unexpected phase changes at all&n;**&t;we had to use a break point every 512 bytes.&n;**&t;Of course the number of scatter/gather blocks is&n;**&t;limited.&n;**&t;Under Linux, the scatter/gatter blocks are provided by &n;**&t;the generic driver. We just have to copy addresses and &n;**&t;sizes to the data segment array.&n;*/
multiline_comment|/*&n;**&t;For 64 bit systems, we use the 8 upper bits of the size field &n;**&t;to provide bus address bits 32-39 to the SCRIPTS processor.&n;**&t;This allows the 896 to access up to 1 tera-bytes of memory.&n;**&t;For 32 bit chips on 64 bit systems, we must be provided with &n;**&t;memory addresses that fit into the first 32 bit bus address &n;**&t;range and so, this does not matter and we expect an error from &n;**&t;the chip if this ever happen.&n;**&n;**&t;We use a separate function for the case Linux does not provide &n;**&t;a scatter list in order to allow better code optimization &n;**&t;for the case we have a scatter list (BTW, for now this just wastes  &n;**&t;about 40 bytes of code for x86, but my guess is that the scatter &n;**&t;code will get more complex later).&n;*/
macro_line|#if BITS_PER_LONG &gt; 32
DECL|macro|SCATTER_ONE
mdefine_line|#define SCATTER_ONE(data, badd, len)&t;&t;&t;&t;&t;&bslash;&n;&t;(data)-&gt;addr = cpu_to_scr(badd);&t;&t;&t;&t;&bslash;&n;&t;(data)-&gt;size = cpu_to_scr((((badd) &gt;&gt; 8) &amp; 0xff000000) + len);
macro_line|#else
DECL|macro|SCATTER_ONE
mdefine_line|#define SCATTER_ONE(data, badd, len)&t;&t;&bslash;&n;&t;(data)-&gt;addr = cpu_to_scr(badd);&t;&bslash;&n;&t;(data)-&gt;size = cpu_to_scr(len);
macro_line|#endif
DECL|macro|CROSS_16MB
mdefine_line|#define CROSS_16MB(p, n) (((((u_long) p) + n - 1) ^ ((u_long) p)) &amp; ~0xffffff)
DECL|function|ncr_scatter_no_sglist
r_static
r_int
id|ncr_scatter_no_sglist
c_func
(paren
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|scr_tblmove
op_star
id|data
op_assign
op_amp
id|cp-&gt;phys.data
(braket
id|MAX_SCATTER
op_minus
l_int|1
)braket
suffix:semicolon
r_int
id|segment
suffix:semicolon
id|cp-&gt;data_len
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
)paren
(brace
id|u_long
id|baddr
op_assign
id|vtobus
c_func
(paren
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
id|SCATTER_ONE
c_func
(paren
id|data
comma
id|baddr
comma
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CROSS_16MB
c_func
(paren
id|baddr
comma
id|cmd-&gt;request_bufflen
)paren
)paren
(brace
id|cp-&gt;host_flags
op_or_assign
id|HF_PM_TO_C
suffix:semicolon
macro_line|#ifdef DEBUG_896R1
id|printk
c_func
(paren
l_string|&quot;He! we are crossing a 16 MB boundary (0x%lx, 0x%x)&bslash;n&quot;
comma
id|baddr
comma
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
macro_line|#endif
)brace
id|segment
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|segment
op_assign
l_int|0
suffix:semicolon
r_return
id|segment
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;DEL 472 - 53C896 Rev 1 - Part Number 609-0393055 - ITEM 5.&n;**&n;**&t;We disable data phase mismatch handling from SCRIPTS for data &n;**&t;transfers that contains scatter/gather entries that cross  &n;**&t;a 16 MB boundary.&n;**&t;We use a different scatter function for 896 rev. 1 that needs &n;**&t;such a work-around. Doing so, we do not affect performance for &n;**&t;other chips.&n;**&t;This problem should not be triggered for disk IOs under Linux, &n;**&t;since such IOs are performed using pages and buffers that are &n;**&t;nicely power-of-two sized and aligned. But, since this may change &n;**&t;at any time, a work-around was required.&n;*/
DECL|function|ncr_scatter_896R1
r_static
r_int
id|ncr_scatter_896R1
c_func
(paren
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|segn
suffix:semicolon
r_int
id|use_sg
op_assign
(paren
r_int
)paren
id|cmd-&gt;use_sg
suffix:semicolon
id|cp-&gt;data_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
id|segn
op_assign
id|ncr_scatter_no_sglist
c_func
(paren
id|cp
comma
id|cmd
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|use_sg
OG
id|MAX_SCATTER
)paren
id|segn
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
(brace
r_struct
id|scatterlist
op_star
id|scatter
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
r_struct
id|scr_tblmove
op_star
id|data
op_assign
op_amp
id|cp-&gt;phys.data
(braket
id|MAX_SCATTER
op_minus
id|use_sg
)braket
suffix:semicolon
r_for
c_loop
(paren
id|segn
op_assign
l_int|0
suffix:semicolon
id|segn
OL
id|use_sg
suffix:semicolon
id|segn
op_increment
)paren
(brace
id|u_long
id|baddr
op_assign
id|vtobus
c_func
(paren
id|scatter
(braket
id|segn
)braket
dot
id|address
)paren
suffix:semicolon
id|SCATTER_ONE
c_func
(paren
op_amp
id|data
(braket
id|segn
)braket
comma
id|baddr
comma
id|scatter
(braket
id|segn
)braket
dot
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CROSS_16MB
c_func
(paren
id|baddr
comma
id|scatter
(braket
id|segn
)braket
dot
id|length
)paren
)paren
(brace
id|cp-&gt;host_flags
op_or_assign
id|HF_PM_TO_C
suffix:semicolon
macro_line|#ifdef DEBUG_896R1
id|printk
c_func
(paren
l_string|&quot;He! we are crossing a 16 MB boundary (0x%lx, 0x%x)&bslash;n&quot;
comma
id|baddr
comma
id|scatter
(braket
id|segn
)braket
dot
id|length
)paren
suffix:semicolon
macro_line|#endif
)brace
id|cp-&gt;data_len
op_add_assign
id|scatter
(braket
id|segn
)braket
dot
id|length
suffix:semicolon
)brace
)brace
r_return
id|segn
suffix:semicolon
)brace
DECL|function|ncr_scatter
r_static
r_int
id|ncr_scatter
c_func
(paren
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|segment
suffix:semicolon
r_int
id|use_sg
op_assign
(paren
r_int
)paren
id|cmd-&gt;use_sg
suffix:semicolon
id|cp-&gt;data_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
id|segment
op_assign
id|ncr_scatter_no_sglist
c_func
(paren
id|cp
comma
id|cmd
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|use_sg
OG
id|MAX_SCATTER
)paren
id|segment
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
(brace
r_struct
id|scatterlist
op_star
id|scatter
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
r_struct
id|scr_tblmove
op_star
id|data
op_assign
op_amp
id|cp-&gt;phys.data
(braket
id|MAX_SCATTER
op_minus
id|use_sg
)braket
suffix:semicolon
r_for
c_loop
(paren
id|segment
op_assign
l_int|0
suffix:semicolon
id|segment
OL
id|use_sg
suffix:semicolon
id|segment
op_increment
)paren
(brace
id|u_long
id|baddr
op_assign
id|vtobus
c_func
(paren
id|scatter
(braket
id|segment
)braket
dot
id|address
)paren
suffix:semicolon
id|SCATTER_ONE
c_func
(paren
op_amp
id|data
(braket
id|segment
)braket
comma
id|baddr
comma
id|scatter
(braket
id|segment
)braket
dot
id|length
)paren
suffix:semicolon
id|cp-&gt;data_len
op_add_assign
id|scatter
(braket
id|segment
)braket
dot
id|length
suffix:semicolon
)brace
)brace
r_return
id|segment
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Test the pci bus snoop logic :-(&n;**&n;**&t;Has to be called with interrupts disabled.&n;**&n;**&n;**==========================================================&n;*/
macro_line|#ifndef NCR_IOMAPPED
DECL|function|ncr_regtest
r_static
r_int
id|__init
id|ncr_regtest
(paren
r_struct
id|ncb
op_star
id|np
)paren
(brace
r_register
r_volatile
id|u_int32
id|data
suffix:semicolon
multiline_comment|/*&n;&t;**&t;ncr registers may NOT be cached.&n;&t;**&t;write 0xffffffff to a read only register area,&n;&t;**&t;and try to read it back.&n;&t;*/
id|data
op_assign
l_int|0xffffffff
suffix:semicolon
id|OUTL_OFF
c_func
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_dstat
)paren
comma
id|data
)paren
suffix:semicolon
id|data
op_assign
id|INL_OFF
c_func
(paren
m_offsetof
(paren
r_struct
id|ncr_reg
comma
id|nc_dstat
)paren
)paren
suffix:semicolon
macro_line|#if 1
r_if
c_cond
(paren
id|data
op_eq
l_int|0xffffffff
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
(paren
id|data
op_amp
l_int|0xe2f0fffd
)paren
op_ne
l_int|0x02000080
)paren
(brace
macro_line|#endif
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: reg dstat-sstat2 readback %x.&bslash;n&quot;
comma
(paren
r_int
)paren
id|data
)paren
suffix:semicolon
r_return
(paren
l_int|0x10
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|ncr_snooptest
r_static
r_int
id|__init
id|ncr_snooptest
(paren
r_struct
id|ncb
op_star
id|np
)paren
(brace
id|u_int32
id|ncr_rd
comma
id|ncr_wr
comma
id|ncr_bk
comma
id|host_rd
comma
id|host_wr
comma
id|pc
suffix:semicolon
r_int
id|i
comma
id|err
op_assign
l_int|0
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
r_if
c_cond
(paren
id|np-&gt;reg
)paren
(brace
id|err
op_or_assign
id|ncr_regtest
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
(paren
id|err
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**&t;init&n;&t;*/
id|pc
op_assign
id|NCB_SCRIPTH0_PHYS
(paren
id|np
comma
id|snooptest
)paren
suffix:semicolon
id|host_wr
op_assign
l_int|1
suffix:semicolon
id|ncr_wr
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Set memory and register.&n;&t;*/
id|np-&gt;ncr_cache
op_assign
id|cpu_to_scr
c_func
(paren
id|host_wr
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_temp
comma
id|ncr_wr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Start script (exchange values)&n;&t;*/
id|OUTL
(paren
id|nc_dsa
comma
id|vtobus
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_dsp
comma
id|pc
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Wait &squot;til done (with timeout)&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NCR_SNOOP_TIMEOUT
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_istat
)paren
op_amp
(paren
id|INTF
op_or
id|SIP
op_or
id|DIP
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Save termination position.&n;&t;*/
id|pc
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Read memory and register.&n;&t;*/
id|host_rd
op_assign
id|scr_to_cpu
c_func
(paren
id|np-&gt;ncr_cache
)paren
suffix:semicolon
id|ncr_rd
op_assign
id|INL
(paren
id|nc_scratcha
)paren
suffix:semicolon
id|ncr_bk
op_assign
id|INL
(paren
id|nc_temp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;check for timeout&n;&t;*/
r_if
c_cond
(paren
id|i
op_ge
id|NCR_SNOOP_TIMEOUT
)paren
(brace
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: timeout.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0x20
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Check termination position.&n;&t;*/
r_if
c_cond
(paren
id|pc
op_ne
id|NCB_SCRIPTH0_PHYS
(paren
id|np
comma
id|snoopend
)paren
op_plus
l_int|8
)paren
(brace
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: script execution failed.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;start=%08lx, pc=%08lx, end=%08lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
id|NCB_SCRIPTH0_PHYS
(paren
id|np
comma
id|snooptest
)paren
comma
(paren
id|u_long
)paren
id|pc
comma
(paren
id|u_long
)paren
id|NCB_SCRIPTH0_PHYS
(paren
id|np
comma
id|snoopend
)paren
op_plus
l_int|8
)paren
suffix:semicolon
r_return
(paren
l_int|0x40
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Show results.&n;&t;*/
r_if
c_cond
(paren
id|host_wr
op_ne
id|ncr_rd
)paren
(brace
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: host wrote %d, ncr read %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|host_wr
comma
(paren
r_int
)paren
id|ncr_rd
)paren
suffix:semicolon
id|err
op_or_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|host_rd
op_ne
id|ncr_wr
)paren
(brace
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: ncr wrote %d, host read %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|ncr_wr
comma
(paren
r_int
)paren
id|host_rd
)paren
suffix:semicolon
id|err
op_or_assign
l_int|2
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|ncr_bk
op_ne
id|ncr_wr
)paren
(brace
id|printk
(paren
l_string|&quot;CACHE TEST FAILED: ncr wrote %d, read back %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|ncr_wr
comma
(paren
r_int
)paren
id|ncr_bk
)paren
suffix:semicolon
id|err
op_or_assign
l_int|4
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Profiling the drivers and targets performance.&n;**&n;**&n;**==========================================================&n;*/
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
DECL|function|ncb_profile
r_static
r_void
id|ncb_profile
(paren
id|ncb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
r_int
id|num_disc
op_assign
(paren
id|cp-&gt;phys.num_disc
op_amp
l_int|0xff
)paren
suffix:semicolon
r_int
id|num_disc0
op_assign
(paren
id|cp-&gt;phys.num_disc
op_rshift
l_int|8
)paren
suffix:semicolon
op_increment
id|np-&gt;profile.num_trans
suffix:semicolon
id|np-&gt;profile.num_disc
op_add_assign
id|num_disc
suffix:semicolon
id|np-&gt;profile.num_disc0
op_add_assign
id|num_disc0
suffix:semicolon
id|np-&gt;profile.num_kbytes
op_add_assign
(paren
id|cp-&gt;data_len
op_rshift
l_int|10
)paren
suffix:semicolon
macro_line|#if 000
r_if
c_cond
(paren
id|num_disc
OG
id|num_disc0
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;data_len
op_le
l_int|1024
)paren
id|np-&gt;profile.num_br1k
op_add_assign
(paren
id|num_disc
op_minus
id|num_disc0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cp-&gt;data_len
op_le
l_int|2048
)paren
id|np-&gt;profile.num_br2k
op_add_assign
(paren
id|num_disc
op_minus
id|num_disc0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cp-&gt;data_len
op_le
l_int|4096
)paren
id|np-&gt;profile.num_br4k
op_add_assign
(paren
id|num_disc
op_minus
id|num_disc0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cp-&gt;data_len
op_le
l_int|8192
)paren
id|np-&gt;profile.num_br8k
op_add_assign
(paren
id|num_disc
op_minus
id|num_disc0
)paren
suffix:semicolon
r_else
id|np-&gt;profile.num_brnk
op_add_assign
(paren
id|num_disc
op_minus
id|num_disc0
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
macro_line|#endif /* SCSI_NCR_PROFILE_SUPPORT */
multiline_comment|/*==========================================================&n;**&n;**&n;**&t;Device lookup.&n;**&n;**&t;@GENSCSI@ should be integrated to scsiconf.c&n;**&n;**&n;**==========================================================&n;*/
DECL|struct|table_entry
r_struct
id|table_entry
(brace
DECL|member|manufacturer
r_char
op_star
id|manufacturer
suffix:semicolon
DECL|member|model
r_char
op_star
id|model
suffix:semicolon
DECL|member|version
r_char
op_star
id|version
suffix:semicolon
DECL|member|info
id|u_long
id|info
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|device_tab
r_static
r_struct
id|table_entry
id|device_tab
(braket
)braket
op_assign
(brace
macro_line|#if 0
(brace
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
id|QUIRK_NOMSG
)brace
comma
macro_line|#endif
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;SDT-5000&quot;
comma
l_string|&quot;3.17&quot;
comma
id|QUIRK_NOMSG
)brace
comma
(brace
l_string|&quot;WangDAT&quot;
comma
l_string|&quot;Model 2600&quot;
comma
l_string|&quot;01.7&quot;
comma
id|QUIRK_NOMSG
)brace
comma
(brace
l_string|&quot;WangDAT&quot;
comma
l_string|&quot;Model 3200&quot;
comma
l_string|&quot;02.2&quot;
comma
id|QUIRK_NOMSG
)brace
comma
(brace
l_string|&quot;WangDAT&quot;
comma
l_string|&quot;Model 1300&quot;
comma
l_string|&quot;02.4&quot;
comma
id|QUIRK_NOMSG
)brace
comma
(brace
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_int|0
)brace
multiline_comment|/* catch all: must be last entry. */
)brace
suffix:semicolon
DECL|function|ncr_lookup
r_static
id|u_long
id|ncr_lookup
c_func
(paren
r_char
op_star
id|id
)paren
(brace
r_struct
id|table_entry
op_star
id|p
op_assign
id|device_tab
suffix:semicolon
r_char
op_star
id|d
comma
op_star
id|r
comma
id|c
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|p
op_increment
)paren
(brace
id|d
op_assign
id|id
op_plus
l_int|8
suffix:semicolon
id|r
op_assign
id|p-&gt;manufacturer
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|r
op_increment
)paren
)paren
r_if
c_cond
(paren
id|c
op_ne
op_star
id|d
op_increment
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
r_continue
suffix:semicolon
id|d
op_assign
id|id
op_plus
l_int|16
suffix:semicolon
id|r
op_assign
id|p-&gt;model
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|r
op_increment
)paren
)paren
r_if
c_cond
(paren
id|c
op_ne
op_star
id|d
op_increment
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
r_continue
suffix:semicolon
id|d
op_assign
id|id
op_plus
l_int|32
suffix:semicolon
id|r
op_assign
id|p-&gt;version
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|r
op_increment
)paren
)paren
r_if
c_cond
(paren
id|c
op_ne
op_star
id|d
op_increment
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
r_continue
suffix:semicolon
r_return
(paren
id|p-&gt;info
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;Determine the ncr&squot;s clock frequency.&n;**&t;This is essential for the negotiation&n;**&t;of the synchronous transfer rate.&n;**&n;**==========================================================&n;**&n;**&t;Note: we have to return the correct value.&n;**&t;THERE IS NO SAFE DEFAULT VALUE.&n;**&n;**&t;Most NCR/SYMBIOS boards are delivered with a 40 Mhz clock.&n;**&t;53C860 and 53C875 rev. 1 support fast20 transfers but &n;**&t;do not have a clock doubler and so are provided with a &n;**&t;80 MHz clock. All other fast20 boards incorporate a doubler &n;**&t;and so should be delivered with a 40 MHz clock.&n;**&t;The recent fast40 chips (895/896) use a 40 Mhz base clock &n;**&t;and provide a clock quadrupler (160 Mhz). The code below &n;**&t;tries to deal as cleverly as possible with all this stuff.&n;**&n;**----------------------------------------------------------&n;*/
multiline_comment|/*&n; *&t;Select NCR SCSI clock frequency&n; */
DECL|function|ncr_selectclock
r_static
r_void
id|ncr_selectclock
c_func
(paren
id|ncb_p
id|np
comma
id|u_char
id|scntl3
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;multiplier
OL
l_int|2
)paren
(brace
id|OUTB
c_func
(paren
id|nc_scntl3
comma
id|scntl3
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
id|printk
(paren
l_string|&quot;%s: enabling clock multiplier&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest1
comma
id|DBLEN
)paren
suffix:semicolon
multiline_comment|/* Enable clock multiplier&t;&t;  */
r_if
c_cond
(paren
id|np-&gt;multiplier
OG
l_int|2
)paren
(brace
multiline_comment|/* Poll bit 5 of stest4 for quadrupler */
r_int
id|i
op_assign
l_int|20
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|INB
c_func
(paren
id|nc_stest4
)paren
op_amp
id|LCKFRQ
)paren
op_logical_and
op_decrement
id|i
OG
l_int|0
)paren
id|UDELAY
(paren
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;%s: the chip cannot lock the frequency&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Wait 20 micro-seconds for doubler&t;*/
id|UDELAY
(paren
l_int|20
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest3
comma
id|HSC
)paren
suffix:semicolon
multiline_comment|/* Halt the scsi clock&t;&t;*/
id|OUTB
c_func
(paren
id|nc_scntl3
comma
id|scntl3
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest1
comma
(paren
id|DBLEN
op_or
id|DBLSEL
)paren
)paren
suffix:semicolon
multiline_comment|/* Select clock multiplier&t;*/
id|OUTB
c_func
(paren
id|nc_stest3
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* Restart scsi clock &t;&t;*/
)brace
multiline_comment|/*&n; *&t;calculate NCR SCSI clock frequency (in KHz)&n; */
DECL|function|ncrgetfreq
r_static
r_int
id|__init
id|ncrgetfreq
(paren
id|ncb_p
id|np
comma
r_int
id|gen
)paren
(brace
r_int
id|ms
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Measure GEN timer delay in order &n;&t; * to calculate SCSI clock frequency&n;&t; *&n;&t; * This code will never execute too&n;&t; * many loop iterations (if DELAY is &n;&t; * reasonably correct). It could get&n;&t; * too low a delay (too high a freq.)&n;&t; * if the CPU is slow executing the &n;&t; * loop for some reason (an NMI, for&n;&t; * example). For this reason we will&n;&t; * if multiple measurements are to be &n;&t; * performed trust the higher delay &n;&t; * (lower frequency returned).&n;&t; */
id|OUTB
(paren
id|nc_stest1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* make sure clock doubler is OFF */
id|OUTW
(paren
id|nc_sien
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* mask all scsi interrupts */
(paren
r_void
)paren
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
multiline_comment|/* clear pending scsi interrupt */
id|OUTB
(paren
id|nc_dien
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* mask all dma interrupts */
(paren
r_void
)paren
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
multiline_comment|/* another one, just to be sure :) */
id|OUTB
(paren
id|nc_scntl3
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* set pre-scaler to divide by 3 */
id|OUTB
(paren
id|nc_stime1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable general purpose timer */
id|OUTB
(paren
id|nc_stime1
comma
id|gen
)paren
suffix:semicolon
multiline_comment|/* set to nominal delay of 1&lt;&lt;gen * 125us */
r_while
c_loop
(paren
op_logical_neg
(paren
id|INW
c_func
(paren
id|nc_sist
)paren
op_amp
id|GEN
)paren
op_logical_and
id|ms
op_increment
OL
l_int|100000
)paren
id|UDELAY
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* count ms */
id|OUTB
(paren
id|nc_stime1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable general purpose timer */
multiline_comment|/*&n; &t; * set prescaler to divide by whatever 0 means&n; &t; * 0 ought to choose divide by 2, but appears&n; &t; * to set divide by 3.5 mode in my 53c810 ...&n; &t; */
id|OUTB
(paren
id|nc_scntl3
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
id|printk
(paren
l_string|&quot;%s: Delay (GEN=%d): %u msec&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|gen
comma
id|ms
)paren
suffix:semicolon
multiline_comment|/*&n; &t; * adjust for prescaler, and convert into KHz &n;  &t; */
r_return
id|ms
ques
c_cond
(paren
(paren
l_int|1
op_lshift
id|gen
)paren
op_star
l_int|4340
)paren
op_div
id|ms
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get/probe NCR SCSI clock frequency&n; */
DECL|function|ncr_getclock
r_static
r_void
id|__init
id|ncr_getclock
(paren
id|ncb_p
id|np
comma
r_int
id|mult
)paren
(brace
r_int
r_char
id|scntl3
op_assign
id|INB
c_func
(paren
id|nc_scntl3
)paren
suffix:semicolon
r_int
r_char
id|stest1
op_assign
id|INB
c_func
(paren
id|nc_stest1
)paren
suffix:semicolon
r_int
id|f1
suffix:semicolon
id|np-&gt;multiplier
op_assign
l_int|1
suffix:semicolon
id|f1
op_assign
l_int|40000
suffix:semicolon
multiline_comment|/*&n;&t;**&t;True with 875/895/896 with clock multiplier selected&n;&t;*/
r_if
c_cond
(paren
id|mult
OG
l_int|1
op_logical_and
(paren
id|stest1
op_amp
(paren
id|DBLEN
op_plus
id|DBLSEL
)paren
)paren
op_eq
id|DBLEN
op_plus
id|DBLSEL
)paren
(brace
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
id|printk
(paren
l_string|&quot;%s: clock multiplier found&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;multiplier
op_assign
id|mult
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;If multiplier not found or scntl3 not 7,5,3,&n;&t;**&t;reset chip and get frequency from general purpose timer.&n;&t;**&t;Otherwise trust scntl3 BIOS setting.&n;&t;*/
r_if
c_cond
(paren
id|np-&gt;multiplier
op_ne
id|mult
op_logical_or
(paren
id|scntl3
op_amp
l_int|7
)paren
OL
l_int|3
op_logical_or
op_logical_neg
(paren
id|scntl3
op_amp
l_int|1
)paren
)paren
(brace
r_int
id|f2
suffix:semicolon
(paren
r_void
)paren
id|ncrgetfreq
(paren
id|np
comma
l_int|11
)paren
suffix:semicolon
multiline_comment|/* throw away first result */
id|f1
op_assign
id|ncrgetfreq
(paren
id|np
comma
l_int|11
)paren
suffix:semicolon
id|f2
op_assign
id|ncrgetfreq
(paren
id|np
comma
l_int|11
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
id|printk
(paren
l_string|&quot;%s: NCR clock is %uKHz, %uKHz&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
id|f1
comma
id|f2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f1
OG
id|f2
)paren
id|f1
op_assign
id|f2
suffix:semicolon
multiline_comment|/* trust lower result&t;*/
r_if
c_cond
(paren
id|f1
OL
l_int|45000
)paren
id|f1
op_assign
l_int|40000
suffix:semicolon
r_else
r_if
c_cond
(paren
id|f1
OL
l_int|55000
)paren
id|f1
op_assign
l_int|50000
suffix:semicolon
r_else
id|f1
op_assign
l_int|80000
suffix:semicolon
r_if
c_cond
(paren
id|f1
template_param
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|bootverbose
op_ge
l_int|2
)paren
id|printk
(paren
l_string|&quot;%s: clock multiplier assumed&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;multiplier
op_assign
id|mult
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|scntl3
op_amp
l_int|7
)paren
op_eq
l_int|3
)paren
id|f1
op_assign
l_int|40000
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|scntl3
op_amp
l_int|7
)paren
op_eq
l_int|5
)paren
id|f1
op_assign
l_int|80000
suffix:semicolon
r_else
id|f1
op_assign
l_int|160000
suffix:semicolon
id|f1
op_div_assign
id|np-&gt;multiplier
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**&t;Compute controller synchronous parameters.&n;&t;*/
id|f1
op_mul_assign
id|np-&gt;multiplier
suffix:semicolon
id|np-&gt;clock_khz
op_assign
id|f1
suffix:semicolon
)brace
multiline_comment|/*===================== LINUX ENTRY POINTS SECTION ==========================*/
macro_line|#ifndef uchar
DECL|macro|uchar
mdefine_line|#define uchar unsigned char
macro_line|#endif
macro_line|#ifndef ushort
DECL|macro|ushort
mdefine_line|#define ushort unsigned short
macro_line|#endif
macro_line|#ifndef ulong
DECL|macro|ulong
mdefine_line|#define ulong unsigned long
macro_line|#endif
multiline_comment|/* ---------------------------------------------------------------------&n;**&n;**&t;Driver setup from the boot command line&n;**&n;** ---------------------------------------------------------------------&n;*/
macro_line|#ifdef MODULE
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot; &squot;
macro_line|#else
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot;,&squot;
macro_line|#endif
DECL|macro|OPT_TAGS
mdefine_line|#define OPT_TAGS&t;&t;1
DECL|macro|OPT_MASTER_PARITY
mdefine_line|#define OPT_MASTER_PARITY&t;2
DECL|macro|OPT_SCSI_PARITY
mdefine_line|#define OPT_SCSI_PARITY&t;&t;3
DECL|macro|OPT_DISCONNECTION
mdefine_line|#define OPT_DISCONNECTION&t;4
DECL|macro|OPT_SPECIAL_FEATURES
mdefine_line|#define OPT_SPECIAL_FEATURES&t;5
DECL|macro|OPT_ULTRA_SCSI
mdefine_line|#define OPT_ULTRA_SCSI&t;&t;6
DECL|macro|OPT_FORCE_SYNC_NEGO
mdefine_line|#define OPT_FORCE_SYNC_NEGO&t;7
DECL|macro|OPT_REVERSE_PROBE
mdefine_line|#define OPT_REVERSE_PROBE&t;8
DECL|macro|OPT_DEFAULT_SYNC
mdefine_line|#define OPT_DEFAULT_SYNC&t;9
DECL|macro|OPT_VERBOSE
mdefine_line|#define OPT_VERBOSE&t;&t;10
DECL|macro|OPT_DEBUG
mdefine_line|#define OPT_DEBUG&t;&t;11
DECL|macro|OPT_BURST_MAX
mdefine_line|#define OPT_BURST_MAX&t;&t;12
DECL|macro|OPT_LED_PIN
mdefine_line|#define OPT_LED_PIN&t;&t;13
DECL|macro|OPT_MAX_WIDE
mdefine_line|#define OPT_MAX_WIDE&t;&t;14
DECL|macro|OPT_SETTLE_DELAY
mdefine_line|#define OPT_SETTLE_DELAY&t;15
DECL|macro|OPT_DIFF_SUPPORT
mdefine_line|#define OPT_DIFF_SUPPORT&t;16
DECL|macro|OPT_IRQM
mdefine_line|#define OPT_IRQM&t;&t;17
DECL|macro|OPT_PCI_FIX_UP
mdefine_line|#define OPT_PCI_FIX_UP&t;&t;18
DECL|macro|OPT_BUS_CHECK
mdefine_line|#define OPT_BUS_CHECK&t;&t;19
DECL|macro|OPT_OPTIMIZE
mdefine_line|#define OPT_OPTIMIZE&t;&t;20
DECL|macro|OPT_RECOVERY
mdefine_line|#define OPT_RECOVERY&t;&t;21
DECL|macro|OPT_SAFE_SETUP
mdefine_line|#define OPT_SAFE_SETUP&t;&t;22
DECL|macro|OPT_USE_NVRAM
mdefine_line|#define OPT_USE_NVRAM&t;&t;23
DECL|macro|OPT_EXCLUDE
mdefine_line|#define OPT_EXCLUDE&t;&t;24
DECL|variable|__initdata
r_static
r_char
id|setup_token
(braket
)braket
id|__initdata
op_assign
l_string|&quot;tags:&quot;
l_string|&quot;mpar:&quot;
l_string|&quot;spar:&quot;
l_string|&quot;disc:&quot;
l_string|&quot;specf:&quot;
l_string|&quot;ultra:&quot;
l_string|&quot;fsn:&quot;
l_string|&quot;revprob:&quot;
l_string|&quot;sync:&quot;
l_string|&quot;verb:&quot;
l_string|&quot;debug:&quot;
l_string|&quot;burst:&quot;
l_string|&quot;led:&quot;
l_string|&quot;wide:&quot;
l_string|&quot;settle:&quot;
l_string|&quot;diff:&quot;
l_string|&quot;irqm:&quot;
l_string|&quot;pcifix:&quot;
l_string|&quot;buschk:&quot;
l_string|&quot;optim:&quot;
l_string|&quot;recovery:&quot;
l_string|&quot;safe:&quot;
l_string|&quot;nvram:&quot;
l_string|&quot;excl:&quot;
suffix:semicolon
macro_line|#ifdef MODULE
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot; &squot;
macro_line|#else
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot;,&squot;
macro_line|#endif
DECL|function|get_setup_token
r_static
r_int
id|__init
id|get_setup_token
c_func
(paren
r_char
op_star
id|p
)paren
(brace
r_char
op_star
id|cur
op_assign
id|setup_token
suffix:semicolon
r_char
op_star
id|pc
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_ne
l_int|NULL
op_logical_and
(paren
id|pc
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;:&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
op_increment
id|pc
suffix:semicolon
op_increment
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|p
comma
id|cur
comma
id|pc
op_minus
id|cur
)paren
)paren
r_return
id|i
suffix:semicolon
id|cur
op_assign
id|pc
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sym53c8xx_setup
r_void
id|__init
id|sym53c8xx_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
macro_line|#ifdef SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT
r_char
op_star
id|cur
op_assign
id|str
suffix:semicolon
r_char
op_star
id|pc
comma
op_star
id|pv
suffix:semicolon
r_int
id|i
comma
id|val
comma
id|c
suffix:semicolon
r_int
id|xi
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_ne
l_int|NULL
op_logical_and
(paren
id|pc
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;:&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_char
op_star
id|pe
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
id|pv
op_assign
id|pc
suffix:semicolon
id|c
op_assign
op_star
op_increment
id|pv
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;n&squot;
)paren
id|val
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;y&squot;
)paren
id|val
op_assign
l_int|1
suffix:semicolon
r_else
id|val
op_assign
(paren
r_int
)paren
id|simple_strtoul
c_func
(paren
id|pv
comma
op_amp
id|pe
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|get_setup_token
c_func
(paren
id|cur
)paren
)paren
(brace
r_case
id|OPT_TAGS
suffix:colon
id|driver_setup.default_tags
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|pe
op_logical_and
op_star
id|pe
op_eq
l_char|&squot;/&squot;
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pe
op_logical_and
op_star
id|pe
op_ne
id|ARG_SEP
op_logical_and
id|i
OL
r_sizeof
(paren
id|driver_setup.tag_ctrl
)paren
op_minus
l_int|1
)paren
(brace
id|driver_setup.tag_ctrl
(braket
id|i
op_increment
)braket
op_assign
op_star
id|pe
op_increment
suffix:semicolon
)brace
id|driver_setup.tag_ctrl
(braket
id|i
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OPT_MASTER_PARITY
suffix:colon
id|driver_setup.master_parity
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SCSI_PARITY
suffix:colon
id|driver_setup.scsi_parity
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_DISCONNECTION
suffix:colon
id|driver_setup.disconnection
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SPECIAL_FEATURES
suffix:colon
id|driver_setup.special_features
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_ULTRA_SCSI
suffix:colon
id|driver_setup.ultra_scsi
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_FORCE_SYNC_NEGO
suffix:colon
id|driver_setup.force_sync_nego
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_REVERSE_PROBE
suffix:colon
id|driver_setup.reverse_probe
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_DEFAULT_SYNC
suffix:colon
id|driver_setup.default_sync
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_VERBOSE
suffix:colon
id|driver_setup.verbose
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_DEBUG
suffix:colon
id|driver_setup.debug
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_BURST_MAX
suffix:colon
id|driver_setup.burst_max
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_LED_PIN
suffix:colon
id|driver_setup.led_pin
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_MAX_WIDE
suffix:colon
id|driver_setup.max_wide
op_assign
id|val
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SETTLE_DELAY
suffix:colon
id|driver_setup.settle_delay
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_DIFF_SUPPORT
suffix:colon
id|driver_setup.diff_support
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_IRQM
suffix:colon
id|driver_setup.irqm
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_PCI_FIX_UP
suffix:colon
id|driver_setup.pci_fix_up
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_BUS_CHECK
suffix:colon
id|driver_setup.bus_check
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_OPTIMIZE
suffix:colon
id|driver_setup.optimize
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_RECOVERY
suffix:colon
id|driver_setup.recovery
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_USE_NVRAM
suffix:colon
id|driver_setup.use_nvram
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SAFE_SETUP
suffix:colon
id|memcpy
c_func
(paren
op_amp
id|driver_setup
comma
op_amp
id|driver_safe_setup
comma
r_sizeof
(paren
id|driver_setup
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_EXCLUDE
suffix:colon
r_if
c_cond
(paren
id|xi
OL
id|SCSI_NCR_MAX_EXCLUDES
)paren
id|driver_setup.excludes
(braket
id|xi
op_increment
)braket
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_setup: unexpected boot option &squot;%.*s&squot; ignored&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|pc
op_minus
id|cur
op_plus
l_int|1
)paren
comma
id|cur
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cur
op_assign
id|strchr
c_func
(paren
id|cur
comma
id|ARG_SEP
)paren
)paren
op_ne
l_int|NULL
)paren
op_increment
id|cur
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT */
)brace
r_static
r_int
id|sym53c8xx_pci_init
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
id|uchar
id|bus
comma
id|uchar
id|device_fn
comma
id|ncr_device
op_star
id|device
)paren
suffix:semicolon
multiline_comment|/*&n;**   Linux entry point for SYM53C8XX devices detection routine.&n;**&n;**   Called by the middle-level scsi drivers at initialization time,&n;**   or at module installation.&n;**&n;**   Read the PCI configuration and try to attach each&n;**   detected NCR board.&n;**&n;**   If NVRAM is present, try to attach boards according to &n;**   the used defined boot order.&n;**&n;**   Returns the number of boards successfully attached.&n;*/
DECL|function|ncr_print_driver_setup
r_static
r_void
id|__init
id|ncr_print_driver_setup
c_func
(paren
r_void
)paren
(brace
DECL|macro|YesNo
mdefine_line|#define YesNo(y)&t;y ? &squot;y&squot; : &squot;n&squot;
id|printk
(paren
id|NAME53C8XX
l_string|&quot;: setup=disc:%c,specf:%d,ultra:%d,tags:%d,sync:%d,&quot;
l_string|&quot;burst:%d,wide:%c,diff:%d,revprob:%c,buschk:0x%x&bslash;n&quot;
comma
id|YesNo
c_func
(paren
id|driver_setup.disconnection
)paren
comma
id|driver_setup.special_features
comma
id|driver_setup.ultra_scsi
comma
id|driver_setup.default_tags
comma
id|driver_setup.default_sync
comma
id|driver_setup.burst_max
comma
id|YesNo
c_func
(paren
id|driver_setup.max_wide
)paren
comma
id|driver_setup.diff_support
comma
id|YesNo
c_func
(paren
id|driver_setup.reverse_probe
)paren
comma
id|driver_setup.bus_check
)paren
suffix:semicolon
id|printk
(paren
id|NAME53C8XX
l_string|&quot;: setup=mpar:%c,spar:%c,fsn=%c,verb:%d,debug:0x%x,&quot;
l_string|&quot;led:%c,settle:%d,irqm:0x%x,nvram:0x%x,pcifix:0x%x&bslash;n&quot;
comma
id|YesNo
c_func
(paren
id|driver_setup.master_parity
)paren
comma
id|YesNo
c_func
(paren
id|driver_setup.scsi_parity
)paren
comma
id|YesNo
c_func
(paren
id|driver_setup.force_sync_nego
)paren
comma
id|driver_setup.verbose
comma
id|driver_setup.debug
comma
id|YesNo
c_func
(paren
id|driver_setup.led_pin
)paren
comma
id|driver_setup.settle_delay
comma
id|driver_setup.irqm
comma
id|driver_setup.use_nvram
comma
id|driver_setup.pci_fix_up
)paren
suffix:semicolon
DECL|macro|YesNo
macro_line|#undef YesNo
)brace
multiline_comment|/*===================================================================&n;**   SYM53C8XX devices description table and chip ids list.&n;**===================================================================&n;*/
DECL|variable|__initdata
r_static
id|ncr_chip
id|ncr_chip_table
(braket
)braket
id|__initdata
op_assign
id|SCSI_NCR_CHIP_TABLE
suffix:semicolon
DECL|variable|__initdata
r_static
id|ushort
id|ncr_chip_ids
(braket
)braket
id|__initdata
op_assign
id|SCSI_NCR_CHIP_IDS
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_PQS_PDS_SUPPORT
multiline_comment|/*===================================================================&n;**    Detect all NCR PQS/PDS boards and keep track of their bus nr.&n;**&n;**    The NCR PQS or PDS card is constructed as a DEC bridge&n;**    behind which sit a proprietary NCR memory controller and&n;**    four or two 53c875s as separate devices.  In its usual mode&n;**    of operation, the 875s are slaved to the memory controller&n;**    for all transfers.  We can tell if an 875 is part of a&n;**    PQS/PDS or not since if it is, it will be on the same bus&n;**    as the memory controller.  To operate with the Linux&n;**    driver, the memory controller is disabled and the 875s&n;**    freed to function independently.  The only wrinkle is that&n;**    the preset SCSI ID (which may be zero) must be read in from&n;**    a special configuration space register of the 875&n;**===================================================================&n;*/
DECL|macro|SCSI_NCR_MAX_PQS_BUS
mdefine_line|#define&t;SCSI_NCR_MAX_PQS_BUS&t;16
DECL|variable|__initdata
r_static
r_int
id|pqs_bus
(braket
id|SCSI_NCR_MAX_PQS_BUS
)braket
id|__initdata
op_assign
(brace
l_int|0
)brace
suffix:semicolon
DECL|function|ncr_detect_pqs_pds
r_static
r_void
id|__init
id|ncr_detect_pqs_pds
c_func
(paren
r_void
)paren
(brace
r_int
id|index
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|SCSI_NCR_MAX_PQS_BUS
suffix:semicolon
id|index
op_increment
)paren
(brace
id|u_char
id|tmp
comma
id|bus
comma
id|device_fn
suffix:semicolon
r_if
c_cond
(paren
id|pcibios_find_device
c_func
(paren
l_int|0x101a
comma
l_int|0x0009
comma
id|index
comma
op_amp
id|bus
comma
op_amp
id|device_fn
)paren
op_ne
id|PCIBIOS_SUCCESSFUL
)paren
(brace
id|pqs_bus
(braket
id|index
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
id|NAME53C8XX
l_string|&quot;: NCR PQS/PDS memory controller detected on bus %d&bslash;n&quot;
comma
id|bus
)paren
suffix:semicolon
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
l_int|0x44
comma
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* bit 1: allow individual 875 configuration */
id|tmp
op_or_assign
l_int|0x2
suffix:semicolon
id|pcibios_write_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
l_int|0x44
comma
id|tmp
)paren
suffix:semicolon
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
l_int|0x45
comma
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* bit 2: drive individual 875 interrupts to the bus */
id|tmp
op_or_assign
l_int|0x4
suffix:semicolon
id|pcibios_write_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
l_int|0x45
comma
id|tmp
)paren
suffix:semicolon
id|pqs_bus
(braket
id|index
)braket
op_assign
id|bus
suffix:semicolon
)brace
)brace
macro_line|#endif /* SCSI_NCR_PQS_PDS_SUPPORT */
multiline_comment|/*===================================================================&n;**    Detect all 53c8xx hosts and then attach them.&n;**&n;**    If we are using NVRAM, once all hosts are detected, we need to &n;**    check any NVRAM for boot order in case detect and boot order &n;**    differ and attach them using the order in the NVRAM.&n;**&n;**    If no NVRAM is found or data appears invalid attach boards in &n;**    the the order they are detected.&n;**===================================================================&n;*/
DECL|function|sym53c8xx_detect
r_int
id|__init
id|sym53c8xx_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_int
id|i
comma
id|j
comma
id|chips
comma
id|hosts
comma
id|count
suffix:semicolon
id|u_char
id|bus
comma
id|device_fn
suffix:semicolon
r_int
id|index
suffix:semicolon
r_int
id|attach_count
op_assign
l_int|0
suffix:semicolon
id|ncr_device
op_star
id|devtbl
comma
op_star
id|devp
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
id|ncr_nvram
id|nvram0
comma
id|nvram
comma
op_star
id|nvp
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**    PCI is required.&n;&t;*/
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,1,92)
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|pcibios_present
c_func
(paren
)paren
)paren
macro_line|#endif
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**    Initialize driver general stuff.&n;&t;*/
macro_line|#ifdef SCSI_NCR_PROC_INFO_SUPPORT
id|tpnt-&gt;proc_dir
op_assign
op_amp
id|proc_scsi_sym53c8xx
suffix:semicolon
id|tpnt-&gt;proc_info
op_assign
id|sym53c8xx_proc_info
suffix:semicolon
macro_line|#endif
macro_line|#if&t;defined(SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT) &amp;&amp; defined(MODULE)
r_if
c_cond
(paren
id|sym53c8xx
)paren
id|sym53c8xx_setup
c_func
(paren
id|sym53c8xx
comma
(paren
r_int
op_star
)paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SCSI_NCR_DEBUG_INFO_SUPPORT
id|ncr_debug
op_assign
id|driver_setup.debug
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|initverbose
op_ge
l_int|2
)paren
id|ncr_print_driver_setup
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**&t;Allocate the device table since we donnot want to &n;&t;**&t;overflow the kernel stack.&n;&t;**&t;1 x 4K PAGE is enough for more than 40 devices for i386.&n;&t;*/
id|devtbl
op_assign
id|m_calloc
c_func
(paren
id|PAGE_SIZE
comma
l_string|&quot;devtbl&quot;
comma
id|MEMO_WARN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devtbl
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;**    Detect all NCR PQS/PDS memory controllers.&n;&t;*/
macro_line|#ifdef&t;SCSI_NCR_PQS_PDS_SUPPORT
id|ncr_detect_pqs_pds
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t;**    Detect all 53c8xx hosts.&n;&t;**    Save the first Symbios NVRAM content if any &n;&t;**    for the boot order.&n;&t;*/
id|chips
op_assign
r_sizeof
(paren
id|ncr_chip_ids
)paren
op_div
r_sizeof
(paren
id|ncr_chip_ids
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|hosts
op_assign
id|PAGE_SIZE
op_div
r_sizeof
(paren
op_star
id|devtbl
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
id|nvp
op_assign
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x1
)paren
ques
c_cond
op_amp
id|nvram0
suffix:colon
l_int|0
suffix:semicolon
macro_line|#endif
id|j
op_assign
l_int|0
suffix:semicolon
id|index
op_assign
l_int|0
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_char
op_star
id|msg
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
id|hosts
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|j
op_ge
id|chips
)paren
r_break
suffix:semicolon
id|i
op_assign
id|driver_setup.reverse_probe
ques
c_cond
id|chips
op_minus
l_int|1
op_minus
id|j
suffix:colon
id|j
suffix:semicolon
r_if
c_cond
(paren
id|pcibios_find_device
c_func
(paren
id|PCI_VENDOR_ID_NCR
comma
id|ncr_chip_ids
(braket
id|i
)braket
comma
id|index
comma
op_amp
id|bus
comma
op_amp
id|device_fn
)paren
)paren
(brace
op_increment
id|j
suffix:semicolon
id|index
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
op_increment
id|index
suffix:semicolon
id|devp
op_assign
op_amp
id|devtbl
(braket
id|count
)braket
suffix:semicolon
id|devp-&gt;host_id
op_assign
l_int|255
suffix:semicolon
id|devp-&gt;attach_done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sym53c8xx_pci_init
c_func
(paren
id|tpnt
comma
id|bus
comma
id|device_fn
comma
id|devp
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
op_increment
id|count
suffix:semicolon
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_if
c_cond
(paren
id|nvp
)paren
(brace
id|ncr_get_nvram
c_func
(paren
id|devp
comma
id|nvp
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|nvp-&gt;type
)paren
(brace
r_case
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; *   Switch to the other nvram buffer, so that &n;&t;&t;&t;&t; *   nvram0 will contain the first Symbios &n;&t;&t;&t;&t; *   format NVRAM content with boot order.&n;&t;&t;&t;&t; */
id|nvp
op_assign
op_amp
id|nvram
suffix:semicolon
id|msg
op_assign
l_string|&quot;with Symbios NVRAM&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCSI_NCR_TEKRAM_NVRAM
suffix:colon
id|msg
op_assign
l_string|&quot;with Tekram NVRAM&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef&t;SCSI_NCR_PQS_PDS_SUPPORT
r_if
c_cond
(paren
id|devp-&gt;pqs_pds
)paren
id|msg
op_assign
l_string|&quot;(NCR PQS/PDS)&quot;
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
id|NAME53C8XX
l_string|&quot;: 53c%s detected %s&bslash;n&quot;
comma
id|devp-&gt;chip.name
comma
id|msg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    If we have found a SYMBIOS NVRAM, use first the NVRAM boot &n;&t;**    sequence as device boot order.&n;&t;**    check devices in the boot record against devices detected. &n;&t;**    attach devices if we find a match. boot table records that &n;&t;**    do not match any detected devices will be ignored. &n;&t;**    devices that do not match any boot table will not be attached&n;&t;**    here but will attempt to be attached during the device table &n;&t;**    rescan.&n;&t;*/
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
r_if
c_cond
(paren
op_logical_neg
id|nvp
op_logical_or
id|nvram0.type
op_ne
id|SCSI_NCR_SYMBIOS_NVRAM
)paren
r_goto
id|next
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Symbios_host
op_star
id|h
op_assign
op_amp
id|nvram0.data.Symbios.host
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|count
suffix:semicolon
id|j
op_increment
)paren
(brace
id|devp
op_assign
op_amp
id|devtbl
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|h-&gt;device_fn
op_ne
id|devp-&gt;slot.device_fn
op_logical_or
id|h-&gt;bus_nr
op_ne
id|devp-&gt;slot.bus
op_logical_or
id|h-&gt;device_id
op_ne
id|devp-&gt;chip.device_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|devp-&gt;attach_done
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|h-&gt;flags
op_amp
id|SYMBIOS_INIT_SCAN_AT_BOOT
)paren
(brace
id|ncr_get_nvram
c_func
(paren
id|devp
comma
id|nvp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ncr_attach
(paren
id|tpnt
comma
id|attach_count
comma
id|devp
)paren
)paren
id|attach_count
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver_setup.use_nvram
op_amp
l_int|0x80
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
id|NAME53C8XX
l_string|&quot;: 53c%s state OFF thus not attached&bslash;n&quot;
comma
id|devp-&gt;chip.name
)paren
suffix:semicolon
r_else
r_continue
suffix:semicolon
id|devp-&gt;attach_done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|next
suffix:colon
macro_line|#endif
multiline_comment|/* &n;&t;**    Rescan device list to make sure all boards attached.&n;&t;**    Devices without boot records will not be attached yet&n;&t;**    so try to attach them here.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|devp
op_assign
op_amp
id|devtbl
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devp-&gt;attach_done
)paren
(brace
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
id|ncr_get_nvram
c_func
(paren
id|devp
comma
id|nvp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|ncr_attach
(paren
id|tpnt
comma
id|attach_count
comma
id|devp
)paren
)paren
id|attach_count
op_increment
suffix:semicolon
)brace
)brace
id|m_free
c_func
(paren
id|devtbl
comma
id|PAGE_SIZE
comma
l_string|&quot;devtbl&quot;
)paren
suffix:semicolon
r_return
id|attach_count
suffix:semicolon
)brace
multiline_comment|/*===================================================================&n;**   Generically read a base address from the PCI configuration space.&n;**   Return the offset immediately after the base address that has &n;**   been read. Btw, we blindly assume that the high 32 bits of 64 bit &n;**   base addresses are set to zero on 32 bit architectures.&n;**===================================================================&n;*/
macro_line|#if LINUX_VERSION_CODE &lt;= LinuxVersionCode(2,1,92)
r_static
r_int
id|__init
DECL|function|pci_read_base_address
id|pci_read_base_address
c_func
(paren
id|u_char
id|bus
comma
id|u_char
id|device_fn
comma
r_int
id|offset
comma
id|u_long
op_star
id|base
)paren
(brace
id|u_int32
id|tmp
suffix:semicolon
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|device_fn
comma
id|offset
comma
op_amp
id|tmp
)paren
suffix:semicolon
op_star
id|base
op_assign
id|tmp
suffix:semicolon
id|offset
op_add_assign
r_sizeof
(paren
id|u_int32
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
l_int|0x7
)paren
op_eq
l_int|0x4
)paren
(brace
macro_line|#if BITS_PER_LONG &gt; 32
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|device_fn
comma
id|offset
comma
op_amp
id|tmp
)paren
suffix:semicolon
op_star
id|base
op_or_assign
(paren
(paren
(paren
id|u_long
)paren
id|tmp
)paren
op_lshift
l_int|32
)paren
suffix:semicolon
macro_line|#endif
id|offset
op_add_assign
r_sizeof
(paren
id|u_int32
)paren
suffix:semicolon
)brace
r_return
id|offset
suffix:semicolon
)brace
macro_line|#else&t;/* LINUX_VERSION_CODE &gt; LinuxVersionCode(2,1,92) */
r_static
r_int
id|__init
DECL|function|pci_get_base_address
id|pci_get_base_address
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_int
id|index
comma
id|u_long
op_star
id|base
)paren
(brace
multiline_comment|/* FIXME! This is just unbelieably horrible backwards compatibility code */
r_struct
id|resource
op_star
id|res
op_assign
id|pdev-&gt;resource
op_plus
id|index
suffix:semicolon
op_star
id|base
op_assign
id|res-&gt;start
op_or
(paren
id|res-&gt;flags
op_amp
l_int|0xf
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res-&gt;flags
op_amp
l_int|0x7
)paren
op_eq
l_int|0x4
)paren
(brace
op_increment
id|index
suffix:semicolon
)brace
r_return
id|index
op_plus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*===================================================================&n;**   Read and check the PCI configuration for any detected NCR &n;**   boards and save data for attaching after all boards have &n;**   been detected.&n;**===================================================================&n;*/
DECL|function|sym53c8xx_pci_init
r_static
r_int
id|__init
id|sym53c8xx_pci_init
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
id|uchar
id|bus
comma
id|uchar
id|device_fn
comma
id|ncr_device
op_star
id|device
)paren
(brace
id|u_short
id|vendor_id
comma
id|device_id
comma
id|command
suffix:semicolon
id|u_char
id|cache_line_size
comma
id|latency_timer
suffix:semicolon
id|u_char
id|suggested_cache_line_size
op_assign
l_int|0
suffix:semicolon
id|u_char
id|revision
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt; LinuxVersionCode(2,1,92)
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
id|u_int
id|irq
suffix:semicolon
macro_line|#else
id|u_char
id|irq
suffix:semicolon
macro_line|#endif
id|u_long
id|base
comma
id|base_2
comma
id|io_port
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ncr_chip
op_star
id|chip
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|NAME53C8XX
l_string|&quot;: at PCI bus %d, device %d, function %d&bslash;n&quot;
comma
id|bus
comma
(paren
r_int
)paren
(paren
id|device_fn
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
comma
(paren
r_int
)paren
id|device_fn
op_amp
l_int|7
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**    Read info from the PCI config space.&n;&t;**    pcibios_read_config_xxx() functions are assumed to be used for &n;&t;**    successfully detected PCI devices.&n;&t;*/
macro_line|#if LINUX_VERSION_CODE &gt; LinuxVersionCode(2,1,92)
id|pdev
op_assign
id|pci_find_slot
c_func
(paren
id|bus
comma
id|device_fn
)paren
suffix:semicolon
id|vendor_id
op_assign
id|pdev-&gt;vendor
suffix:semicolon
id|device_id
op_assign
id|pdev-&gt;device
suffix:semicolon
id|irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|pci_get_base_address
c_func
(paren
id|pdev
comma
id|i
comma
op_amp
id|io_port
)paren
suffix:semicolon
id|i
op_assign
id|pci_get_base_address
c_func
(paren
id|pdev
comma
id|i
comma
op_amp
id|base
)paren
suffix:semicolon
(paren
r_void
)paren
id|pci_get_base_address
c_func
(paren
id|pdev
comma
id|i
comma
op_amp
id|base_2
)paren
suffix:semicolon
macro_line|#else
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_VENDOR_ID
comma
op_amp
id|vendor_id
)paren
suffix:semicolon
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_DEVICE_ID
comma
op_amp
id|device_id
)paren
suffix:semicolon
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_INTERRUPT_LINE
comma
op_amp
id|irq
)paren
suffix:semicolon
id|i
op_assign
id|PCI_BASE_ADDRESS_0
suffix:semicolon
id|i
op_assign
id|pci_read_base_address
c_func
(paren
id|bus
comma
id|device_fn
comma
id|i
comma
op_amp
id|io_port
)paren
suffix:semicolon
id|i
op_assign
id|pci_read_base_address
c_func
(paren
id|bus
comma
id|device_fn
comma
id|i
comma
op_amp
id|base
)paren
suffix:semicolon
(paren
r_void
)paren
id|pci_read_base_address
c_func
(paren
id|bus
comma
id|device_fn
comma
id|i
comma
op_amp
id|base_2
)paren
suffix:semicolon
macro_line|#endif
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_COMMAND
comma
op_amp
id|command
)paren
suffix:semicolon
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|revision
)paren
suffix:semicolon
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_CACHE_LINE_SIZE
comma
op_amp
id|cache_line_size
)paren
suffix:semicolon
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|latency_timer
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_PQS_PDS_SUPPORT
multiline_comment|/*&n;&t;**    Match the BUS number for PQS/PDS devices.&n;&t;**    Read the SCSI ID from a special register mapped&n;&t;**    into the configuration space of the individual&n;&t;**    875s.  This register is set up by the PQS bios&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCSI_NCR_MAX_PQS_BUS
op_logical_and
id|pqs_bus
(braket
id|i
)braket
op_ne
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u_char
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|pqs_bus
(braket
id|i
)braket
op_eq
id|bus
)paren
(brace
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
l_int|0x84
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|device-&gt;pqs_pds
op_assign
l_int|1
suffix:semicolon
id|device-&gt;host_id
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif /* SCSI_NCR_PQS_PDS_SUPPORT */
multiline_comment|/*&n;&t;**&t;If user excludes this chip, donnot initialize it.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCSI_NCR_MAX_EXCLUDES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|driver_setup.excludes
(braket
id|i
)braket
op_eq
(paren
id|io_port
op_amp
id|PCI_BASE_ADDRESS_IO_MASK
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    Check if the chip is supported&n;&t;*/
id|chip
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|ncr_chip_table
)paren
op_div
r_sizeof
(paren
id|ncr_chip_table
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|device_id
op_ne
id|ncr_chip_table
(braket
id|i
)braket
dot
id|device_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|revision
OG
id|ncr_chip_table
(braket
id|i
)braket
dot
id|revision_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ncr_chip_table
(braket
id|i
)braket
dot
id|features
op_amp
id|FE_LDSTR
)paren
)paren
r_continue
suffix:semicolon
id|chip
op_assign
op_amp
id|device-&gt;chip
suffix:semicolon
id|memcpy
c_func
(paren
id|chip
comma
op_amp
id|ncr_chip_table
(braket
id|i
)braket
comma
r_sizeof
(paren
op_star
id|chip
)paren
)paren
suffix:semicolon
id|chip-&gt;revision_id
op_assign
id|revision
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#if defined(__i386__)
multiline_comment|/*&n;&t;**&t;Ignore Symbios chips controlled by SISL RAID controller.&n;&t;**&t;This controller sets value 0x52414944 at RAM end - 16.&n;&t;*/
r_if
c_cond
(paren
id|chip
op_logical_and
(paren
id|base_2
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
)paren
(brace
r_int
r_int
id|ram_size
comma
id|ram_val
suffix:semicolon
id|u_long
id|ram_ptr
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;features
op_amp
id|FE_RAM8K
)paren
id|ram_size
op_assign
l_int|8192
suffix:semicolon
r_else
id|ram_size
op_assign
l_int|4096
suffix:semicolon
id|ram_ptr
op_assign
id|remap_pci_mem
c_func
(paren
id|base_2
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
comma
id|ram_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ram_ptr
)paren
(brace
id|ram_val
op_assign
id|readl_raw
c_func
(paren
id|ram_ptr
op_plus
id|ram_size
op_minus
l_int|16
)paren
suffix:semicolon
id|unmap_pci_mem
c_func
(paren
id|ram_ptr
comma
id|ram_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ram_val
op_eq
l_int|0x52414944
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: not initializing, &quot;
l_string|&quot;driven by SISL RAID controller.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|chip
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: not initializing, device not supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef __powerpc__
multiline_comment|/*&n;&t;**&t;Fix-up for power/pc.&n;&t;**&t;Should not be performed by the driver.&n;&t;*/
r_if
c_cond
(paren
(paren
id|command
op_amp
(paren
id|PCI_COMMAND_IO
op_or
id|PCI_COMMAND_MEMORY
)paren
)paren
op_ne
(paren
id|PCI_COMMAND_IO
op_or
id|PCI_COMMAND_MEMORY
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: setting%s%s...&bslash;n&quot;
comma
(paren
id|command
op_amp
id|PCI_COMMAND_IO
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; PCI_COMMAND_IO&quot;
comma
(paren
id|command
op_amp
id|PCI_COMMAND_MEMORY
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; PCI_COMMAND_MEMORY&quot;
)paren
suffix:semicolon
id|command
op_or_assign
(paren
id|PCI_COMMAND_IO
op_or
id|PCI_COMMAND_MEMORY
)paren
suffix:semicolon
id|pcibios_write_config_word
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,2,0)
r_if
c_cond
(paren
id|is_prep
)paren
(brace
r_if
c_cond
(paren
id|io_port
op_ge
l_int|0x10000000
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: reallocating io_port (Wacky IBM)&quot;
)paren
suffix:semicolon
id|io_port
op_assign
(paren
id|io_port
op_amp
l_int|0x00FFFFFF
)paren
op_or
l_int|0x01000000
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_BASE_ADDRESS_0
comma
id|io_port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base
op_ge
l_int|0x10000000
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: reallocating base (Wacky IBM)&quot;
)paren
suffix:semicolon
id|base
op_assign
(paren
id|base
op_amp
l_int|0x00FFFFFF
)paren
op_or
l_int|0x01000000
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_BASE_ADDRESS_1
comma
id|base
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base_2
op_ge
l_int|0x10000000
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: reallocating base2 (Wacky IBM)&quot;
)paren
suffix:semicolon
id|base_2
op_assign
(paren
id|base_2
op_amp
l_int|0x00FFFFFF
)paren
op_or
l_int|0x01000000
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_BASE_ADDRESS_2
comma
id|base_2
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#endif&t;/* __powerpc__ */
macro_line|#ifdef __sparc__
multiline_comment|/*&n;&t;**    Fix-ups for sparc.&n;&t;**&n;&t;**    I wrote:&t;   Should not be performed by the driver,&n;&t;**    Guy wrote:   but how can OBP know each and every PCI card,&n;&t;** &t;&t;   if they don&squot;t use Fcode?&n;&t;**    I replied:   no need to know each and every PCI card, just &n;&t;**&t;           be skilled enough to understand the PCI specs.&n;&t;*/
multiline_comment|/*&n;&t;**    PCI configuration is based on configuration registers being&n;&t;**    coherent with hardware and software resource identifications.&n;&t;**    This is fairly simple, but seems still too complex for Sparc.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|cache_line_size
)paren
id|suggested_cache_line_size
op_assign
l_int|16
suffix:semicolon
macro_line|#endif&t;/* __sparc__ */
macro_line|#if defined(__i386__) &amp;&amp; !defined(MODULE)
r_if
c_cond
(paren
op_logical_neg
id|cache_line_size
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,1,75)
r_extern
r_char
id|x86
suffix:semicolon
r_switch
c_cond
(paren
id|x86
)paren
(brace
macro_line|#else
r_switch
c_cond
(paren
id|boot_cpu_data.x86
)paren
(brace
macro_line|#endif
r_case
l_int|4
suffix:colon
id|suggested_cache_line_size
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
r_case
l_int|5
suffix:colon
id|suggested_cache_line_size
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* __i386__ */
multiline_comment|/*&n;&t;**    Check availability of IO space, memory space.&n;&t;**    Enable master capability if not yet.&n;&t;*/
macro_line|#ifdef NCR_IOMAPPED
r_if
c_cond
(paren
op_logical_neg
(paren
id|command
op_amp
id|PCI_COMMAND_IO
)paren
op_logical_or
op_logical_neg
(paren
id|io_port
op_amp
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: I/O base address (0x%lx) disabled.&bslash;n&quot;
comma
(paren
r_int
)paren
id|io_port
)paren
suffix:semicolon
id|io_port
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|command
op_amp
id|PCI_COMMAND_MEMORY
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: PCI_COMMAND_MEMORY not set.&bslash;n&quot;
)paren
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
id|base_2
op_assign
l_int|0
suffix:semicolon
)brace
id|io_port
op_and_assign
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
id|base
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|base_2
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
macro_line|#ifdef NCR_IOMAPPED
r_if
c_cond
(paren
id|io_port
op_logical_and
id|check_region
(paren
id|io_port
comma
l_int|128
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: IO region 0x%lx[0..127] is in use&bslash;n&quot;
comma
(paren
r_int
)paren
id|io_port
)paren
suffix:semicolon
id|io_port
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|io_port
)paren
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: MMIO base address disabled.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**    Set MASTER capable and PARITY bit, if not yet.&n;&t;*/
r_if
c_cond
(paren
(paren
id|command
op_amp
(paren
id|PCI_COMMAND_MASTER
op_or
id|PCI_COMMAND_PARITY
)paren
)paren
op_ne
(paren
id|PCI_COMMAND_MASTER
op_or
id|PCI_COMMAND_PARITY
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: setting%s%s...(fix-up)&bslash;n&quot;
comma
(paren
id|command
op_amp
id|PCI_COMMAND_MASTER
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; PCI_COMMAND_MASTER&quot;
comma
(paren
id|command
op_amp
id|PCI_COMMAND_PARITY
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; PCI_COMMAND_PARITY&quot;
)paren
suffix:semicolon
id|command
op_or_assign
(paren
id|PCI_COMMAND_MASTER
op_or
id|PCI_COMMAND_PARITY
)paren
suffix:semicolon
id|pcibios_write_config_word
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    Fix some features according to driver setup.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver_setup.special_features
op_amp
l_int|1
)paren
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_SPECIAL_SET
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|driver_setup.special_features
op_amp
l_int|2
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_WRIE
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.special_features
op_amp
l_int|4
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_NOPM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver_setup.ultra_scsi
OL
l_int|2
op_logical_and
(paren
id|chip-&gt;features
op_amp
id|FE_ULTRA2
)paren
)paren
(brace
id|chip-&gt;features
op_or_assign
id|FE_ULTRA
suffix:semicolon
id|chip-&gt;features
op_and_assign
op_complement
id|FE_ULTRA2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver_setup.ultra_scsi
OL
l_int|1
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_ULTRA
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver_setup.max_wide
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_WIDE
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_PCI_FIX_UP_SUPPORT
multiline_comment|/*&n;&t;**    Try to fix up PCI config according to wished features.&n;&t;*/
r_if
c_cond
(paren
(paren
id|driver_setup.pci_fix_up
op_amp
l_int|1
)paren
op_logical_and
(paren
id|chip-&gt;features
op_amp
id|FE_CLSE
)paren
op_logical_and
op_logical_neg
id|cache_line_size
op_logical_and
id|suggested_cache_line_size
)paren
(brace
id|cache_line_size
op_assign
id|suggested_cache_line_size
suffix:semicolon
id|pcibios_write_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_CACHE_LINE_SIZE
comma
id|cache_line_size
)paren
suffix:semicolon
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: PCI_CACHE_LINE_SIZE set to %d (fix-up).&bslash;n&quot;
comma
id|cache_line_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|driver_setup.pci_fix_up
op_amp
l_int|2
)paren
op_logical_and
id|cache_line_size
op_logical_and
(paren
id|chip-&gt;features
op_amp
id|FE_WRIE
)paren
op_logical_and
op_logical_neg
(paren
id|command
op_amp
id|PCI_COMMAND_INVALIDATE
)paren
)paren
(brace
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: setting PCI_COMMAND_INVALIDATE (fix-up)&bslash;n&quot;
)paren
suffix:semicolon
id|command
op_or_assign
id|PCI_COMMAND_INVALIDATE
suffix:semicolon
id|pcibios_write_config_word
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;**    Tune PCI LATENCY TIMER according to burst max length transfer.&n;&t;**    (latency timer &gt;= burst length + 6, we add 10 to be quite sure)&n;&t;*/
r_if
c_cond
(paren
(paren
id|driver_setup.pci_fix_up
op_amp
l_int|4
)paren
op_logical_and
id|chip-&gt;burst_max
)paren
(brace
id|uchar
id|lt
op_assign
(paren
l_int|1
op_lshift
id|chip-&gt;burst_max
)paren
op_plus
l_int|6
op_plus
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|latency_timer
OL
id|lt
)paren
(brace
id|latency_timer
op_assign
id|lt
suffix:semicolon
id|printk
c_func
(paren
id|NAME53C8XX
l_string|&quot;: setting PCI_LATENCY_TIMER to %d (fix-up).&bslash;n&quot;
comma
id|latency_timer
)paren
suffix:semicolon
id|pcibios_write_config_byte
c_func
(paren
id|bus
comma
id|device_fn
comma
id|PCI_LATENCY_TIMER
comma
id|latency_timer
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* SCSI_NCR_PCI_FIX_UP_SUPPORT */
multiline_comment|/*&n;&t;**    Initialise ncr_device structure with items required by ncr_attach.&n;&t;*/
id|device-&gt;slot.bus
op_assign
id|bus
suffix:semicolon
id|device-&gt;slot.device_fn
op_assign
id|device_fn
suffix:semicolon
id|device-&gt;slot.base
op_assign
id|base
suffix:semicolon
id|device-&gt;slot.base_2
op_assign
id|base_2
suffix:semicolon
id|device-&gt;slot.io_port
op_assign
id|io_port
suffix:semicolon
id|device-&gt;slot.irq
op_assign
id|irq
suffix:semicolon
id|device-&gt;attach_done
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*===================================================================&n;**    Detect and try to read SYMBIOS and TEKRAM NVRAM.&n;**&n;**    Data can be used to order booting of boards.&n;**&n;**    Data is saved in ncr_device structure if NVRAM found. This&n;**    is then used to find drive boot order for ncr_attach().&n;**&n;**    NVRAM data is passed to Scsi_Host_Template later during &n;**    ncr_attach() for any device set up.&n;*===================================================================&n;*/
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
DECL|function|ncr_get_nvram
r_static
r_void
id|__init
id|ncr_get_nvram
c_func
(paren
id|ncr_device
op_star
id|devp
comma
id|ncr_nvram
op_star
id|nvp
)paren
(brace
id|devp-&gt;nvram
op_assign
id|nvp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nvp
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**    Get access to chip IO registers&n;&t;*/
macro_line|#ifdef NCR_IOMAPPED
id|request_region
c_func
(paren
id|devp-&gt;slot.io_port
comma
l_int|128
comma
id|NAME53C8XX
)paren
suffix:semicolon
id|devp-&gt;slot.base_io
op_assign
id|devp-&gt;slot.io_port
suffix:semicolon
macro_line|#else
id|devp-&gt;slot.reg
op_assign
(paren
r_struct
id|ncr_reg
op_star
)paren
id|remap_pci_mem
c_func
(paren
id|devp-&gt;slot.base
comma
l_int|128
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devp-&gt;slot.reg
)paren
r_return
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**    Try to read SYMBIOS nvram.&n;&t;**    Try to read TEKRAM nvram if Symbios nvram not found.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|ncr_get_Symbios_nvram
c_func
(paren
op_amp
id|devp-&gt;slot
comma
op_amp
id|nvp-&gt;data.Symbios
)paren
)paren
id|nvp-&gt;type
op_assign
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|ncr_get_Tekram_nvram
c_func
(paren
op_amp
id|devp-&gt;slot
comma
op_amp
id|nvp-&gt;data.Tekram
)paren
)paren
id|nvp-&gt;type
op_assign
id|SCSI_NCR_TEKRAM_NVRAM
suffix:semicolon
r_else
(brace
id|nvp-&gt;type
op_assign
l_int|0
suffix:semicolon
id|devp-&gt;nvram
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Release access to chip IO registers&n;&t;*/
macro_line|#ifdef NCR_IOMAPPED
id|release_region
c_func
(paren
id|devp-&gt;slot.base_io
comma
l_int|128
)paren
suffix:semicolon
macro_line|#else
id|unmap_pci_mem
c_func
(paren
(paren
id|u_long
)paren
id|devp-&gt;slot.reg
comma
l_int|128ul
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif&t;/* SCSI_NCR_NVRAM_SUPPORT */
multiline_comment|/*&n;**   Linux select queue depths function&n;*/
DECL|macro|DEF_DEPTH
mdefine_line|#define DEF_DEPTH&t;(driver_setup.default_tags)
DECL|macro|ALL_TARGETS
mdefine_line|#define ALL_TARGETS&t;-2
DECL|macro|NO_TARGET
mdefine_line|#define NO_TARGET&t;-1
DECL|macro|ALL_LUNS
mdefine_line|#define ALL_LUNS&t;-2
DECL|macro|NO_LUN
mdefine_line|#define NO_LUN&t;&t;-1
DECL|function|device_queue_depth
r_static
r_int
id|device_queue_depth
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|target
comma
r_int
id|lun
)paren
(brace
r_int
id|c
comma
id|h
comma
id|t
comma
id|u
comma
id|v
suffix:semicolon
r_char
op_star
id|p
op_assign
id|driver_setup.tag_ctrl
suffix:semicolon
r_char
op_star
id|ep
suffix:semicolon
id|h
op_assign
op_minus
l_int|1
suffix:semicolon
id|t
op_assign
id|NO_TARGET
suffix:semicolon
id|u
op_assign
id|NO_LUN
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|p
op_increment
)paren
op_ne
l_int|0
)paren
(brace
id|v
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|ep
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;/&squot;
suffix:colon
op_increment
id|h
suffix:semicolon
id|t
op_assign
id|ALL_TARGETS
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
r_if
c_cond
(paren
id|t
op_ne
id|target
)paren
id|t
op_assign
(paren
id|target
op_eq
id|v
)paren
ques
c_cond
id|v
suffix:colon
id|NO_TARGET
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;u&squot;
suffix:colon
r_if
c_cond
(paren
id|u
op_ne
id|lun
)paren
id|u
op_assign
(paren
id|lun
op_eq
id|v
)paren
ques
c_cond
id|v
suffix:colon
id|NO_LUN
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;q&squot;
suffix:colon
r_if
c_cond
(paren
id|h
op_eq
id|np-&gt;unit
op_logical_and
(paren
id|t
op_eq
id|ALL_TARGETS
op_logical_or
id|t
op_eq
id|target
)paren
op_logical_and
(paren
id|u
op_eq
id|ALL_LUNS
op_logical_or
id|u
op_eq
id|lun
)paren
)paren
r_return
id|v
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;-&squot;
suffix:colon
id|t
op_assign
id|ALL_TARGETS
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|p
op_assign
id|ep
suffix:semicolon
)brace
r_return
id|DEF_DEPTH
suffix:semicolon
)brace
DECL|function|sym53c8xx_select_queue_depths
r_static
r_void
id|sym53c8xx_select_queue_depths
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|scsi_device
op_star
id|devlist
)paren
(brace
r_struct
id|scsi_device
op_star
id|device
suffix:semicolon
r_for
c_loop
(paren
id|device
op_assign
id|devlist
suffix:semicolon
id|device
suffix:semicolon
id|device
op_assign
id|device-&gt;next
)paren
(brace
id|ncb_p
id|np
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
r_int
id|numtags
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;host
op_ne
id|host
)paren
r_continue
suffix:semicolon
id|np
op_assign
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|device-&gt;id
)braket
suffix:semicolon
id|lp
op_assign
id|tp-&gt;lp
(braket
id|device-&gt;lun
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Select queue depth from driver setup.&n;&t;&t;**&t;Donnot use more than configured by user.&n;&t;&t;**&t;Use at least 2.&n;&t;&t;**&t;Donnot use more than our maximum.&n;&t;&t;*/
id|numtags
op_assign
id|device_queue_depth
c_func
(paren
id|np
comma
id|device-&gt;id
comma
id|device-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|numtags
OG
id|tp-&gt;usrtags
)paren
id|numtags
op_assign
id|tp-&gt;usrtags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;tagged_supported
)paren
id|numtags
op_assign
l_int|1
suffix:semicolon
id|device-&gt;queue_depth
op_assign
id|numtags
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;queue_depth
OL
l_int|2
)paren
id|device-&gt;queue_depth
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;queue_depth
OG
id|SCSI_NCR_MAX_TAGS
)paren
id|device-&gt;queue_depth
op_assign
id|SCSI_NCR_MAX_TAGS
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;Since the queue depth is not tunable under Linux,&n;&t;&t;**&t;we need to know this value in order not to &n;&t;&t;**&t;announce stupid things to user.&n;&t;&t;*/
r_if
c_cond
(paren
id|lp
)paren
(brace
id|lp-&gt;numtags
op_assign
id|lp-&gt;maxtags
op_assign
id|numtags
suffix:semicolon
id|lp-&gt;scdev_depth
op_assign
id|device-&gt;queue_depth
suffix:semicolon
)brace
id|ncr_setup_tags
(paren
id|np
comma
id|device-&gt;id
comma
id|device-&gt;lun
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SYM53C8XX
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_select_queue_depth: host=%d, id=%d, lun=%d, depth=%d&bslash;n&quot;
comma
id|np-&gt;unit
comma
id|device-&gt;id
comma
id|device-&gt;lun
comma
id|device-&gt;queue_depth
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*&n;**   Linux entry point for info() function&n;*/
DECL|function|sym53c8xx_info
r_const
r_char
op_star
id|sym53c8xx_info
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_return
id|SCSI_NCR_DRIVER_NAME
suffix:semicolon
)brace
multiline_comment|/*&n;**   Linux entry point of queuecommand() function&n;*/
DECL|function|sym53c8xx_queue_command
r_int
id|sym53c8xx_queue_command
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|ncb_p
id|np
op_assign
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|sts
suffix:semicolon
macro_line|#ifdef DEBUG_SYM53C8XX
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_queue_command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sts
op_assign
id|ncr_queue_command
c_func
(paren
id|np
comma
id|cmd
)paren
)paren
op_ne
id|DID_OK
)paren
(brace
id|SetScsiResult
c_func
(paren
id|cmd
comma
id|sts
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SYM53C8XX
id|printk
c_func
(paren
l_string|&quot;sym53c8xx : command not queued - result=%d&bslash;n&quot;
comma
id|sts
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef DEBUG_SYM53C8XX
r_else
id|printk
c_func
(paren
l_string|&quot;sym53c8xx : command successfully queued&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
op_ne
id|DID_OK
)paren
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
id|sts
suffix:semicolon
)brace
multiline_comment|/*&n;**   Linux entry point of the interrupt handler.&n;**   Since linux versions &gt; 1.3.70, we trust the kernel for &n;**   passing the internal host descriptor as &squot;dev_id&squot;.&n;**   Otherwise, we scan the host list and call the interrupt &n;**   routine for each host that uses this IRQ.&n;*/
DECL|function|sym53c8xx_intr
r_static
r_void
id|sym53c8xx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ncb_p
id|np
op_assign
(paren
id|ncb_p
)paren
id|dev_id
suffix:semicolon
id|Scsi_Cmnd
op_star
id|done_list
suffix:semicolon
macro_line|#ifdef DEBUG_SYM53C8XX
id|printk
c_func
(paren
l_string|&quot;sym53c8xx : interrupt received&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;[&quot;
)paren
suffix:semicolon
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_exception
c_func
(paren
id|np
)paren
suffix:semicolon
id|done_list
op_assign
id|np-&gt;done_list
suffix:semicolon
id|np-&gt;done_list
op_assign
l_int|0
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done_list
)paren
(brace
id|NCR_LOCK_SCSI_DONE
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_flush_done_cmds
c_func
(paren
id|done_list
)paren
suffix:semicolon
id|NCR_UNLOCK_SCSI_DONE
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;**   Linux entry point of the timer handler&n;*/
DECL|function|sym53c8xx_timeout
r_static
r_void
id|sym53c8xx_timeout
c_func
(paren
r_int
r_int
id|npref
)paren
(brace
id|ncb_p
id|np
op_assign
(paren
id|ncb_p
)paren
id|npref
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Cmnd
op_star
id|done_list
suffix:semicolon
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_timeout
c_func
(paren
(paren
id|ncb_p
)paren
id|np
)paren
suffix:semicolon
id|done_list
op_assign
id|np-&gt;done_list
suffix:semicolon
id|np-&gt;done_list
op_assign
l_int|0
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done_list
)paren
(brace
id|NCR_LOCK_SCSI_DONE
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_flush_done_cmds
c_func
(paren
id|done_list
)paren
suffix:semicolon
id|NCR_UNLOCK_SCSI_DONE
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;**   Linux entry point of reset() function&n;*/
macro_line|#if defined SCSI_RESET_SYNCHRONOUS &amp;&amp; defined SCSI_RESET_ASYNCHRONOUS
DECL|function|sym53c8xx_reset
r_int
id|sym53c8xx_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
r_int
id|reset_flags
)paren
macro_line|#else
r_int
id|sym53c8xx_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
macro_line|#endif
(brace
id|ncb_p
id|np
op_assign
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
suffix:semicolon
r_int
id|sts
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Cmnd
op_star
id|done_list
suffix:semicolon
macro_line|#if defined SCSI_RESET_SYNCHRONOUS &amp;&amp; defined SCSI_RESET_ASYNCHRONOUS
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_reset: pid=%lu reset_flags=%x serial_number=%ld serial_number_at_timeout=%ld&bslash;n&quot;
comma
id|cmd-&gt;pid
comma
id|reset_flags
comma
id|cmd-&gt;serial_number
comma
id|cmd-&gt;serial_number_at_timeout
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_reset: command pid %lu&bslash;n&quot;
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
macro_line|#endif
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have to just ignore reset requests in some situations.&n;&t; */
macro_line|#if defined SCSI_RESET_NOT_RUNNING
r_if
c_cond
(paren
id|cmd-&gt;serial_number
op_ne
id|cmd-&gt;serial_number_at_timeout
)paren
(brace
id|sts
op_assign
id|SCSI_RESET_NOT_RUNNING
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * If the mid-level driver told us reset is synchronous, it seems &n;&t; * that we must call the done() callback for the involved command, &n;&t; * even if this command was not queued to the low-level driver, &n;&t; * before returning SCSI_RESET_SUCCESS.&n;&t; */
macro_line|#if defined SCSI_RESET_SYNCHRONOUS &amp;&amp; defined SCSI_RESET_ASYNCHRONOUS
id|sts
op_assign
id|ncr_reset_bus
c_func
(paren
id|np
comma
id|cmd
comma
(paren
id|reset_flags
op_amp
(paren
id|SCSI_RESET_SYNCHRONOUS
op_or
id|SCSI_RESET_ASYNCHRONOUS
)paren
)paren
op_eq
id|SCSI_RESET_SYNCHRONOUS
)paren
suffix:semicolon
macro_line|#else
id|sts
op_assign
id|ncr_reset_bus
c_func
(paren
id|np
comma
id|cmd
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Since we always reset the controller, when we return success, &n;&t; * we add this information to the return code.&n;&t; */
macro_line|#if defined SCSI_RESET_HOST_RESET
r_if
c_cond
(paren
id|sts
op_eq
id|SCSI_RESET_SUCCESS
)paren
id|sts
op_or_assign
id|SCSI_RESET_HOST_RESET
suffix:semicolon
macro_line|#endif
id|out
suffix:colon
id|done_list
op_assign
id|np-&gt;done_list
suffix:semicolon
id|np-&gt;done_list
op_assign
l_int|0
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_flush_done_cmds
c_func
(paren
id|done_list
)paren
suffix:semicolon
r_return
id|sts
suffix:semicolon
)brace
multiline_comment|/*&n;**   Linux entry point of abort() function&n;*/
DECL|function|sym53c8xx_abort
r_int
id|sym53c8xx_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|ncb_p
id|np
op_assign
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
suffix:semicolon
r_int
id|sts
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Cmnd
op_star
id|done_list
suffix:semicolon
macro_line|#if defined SCSI_RESET_SYNCHRONOUS &amp;&amp; defined SCSI_RESET_ASYNCHRONOUS
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_abort: pid=%lu serial_number=%ld serial_number_at_timeout=%ld&bslash;n&quot;
comma
id|cmd-&gt;pid
comma
id|cmd-&gt;serial_number
comma
id|cmd-&gt;serial_number_at_timeout
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_abort: command pid %lu&bslash;n&quot;
comma
id|cmd-&gt;pid
)paren
suffix:semicolon
macro_line|#endif
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
macro_line|#if defined SCSI_RESET_SYNCHRONOUS &amp;&amp; defined SCSI_RESET_ASYNCHRONOUS
multiline_comment|/*&n;&t; * We have to just ignore abort requests in some situations.&n;&t; */
r_if
c_cond
(paren
id|cmd-&gt;serial_number
op_ne
id|cmd-&gt;serial_number_at_timeout
)paren
(brace
id|sts
op_assign
id|SCSI_ABORT_NOT_RUNNING
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#endif
id|sts
op_assign
id|ncr_abort_command
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
id|out
suffix:colon
id|done_list
op_assign
id|np-&gt;done_list
suffix:semicolon
id|np-&gt;done_list
op_assign
l_int|0
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_flush_done_cmds
c_func
(paren
id|done_list
)paren
suffix:semicolon
r_return
id|sts
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|sym53c8xx_release
r_int
id|sym53c8xx_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
macro_line|#ifdef DEBUG_SYM53C8XX
id|printk
c_func
(paren
l_string|&quot;sym53c8xx : release&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|ncr_detach
c_func
(paren
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;**&t;Scsi command waiting list management.&n;**&n;**&t;It may happen that we cannot insert a scsi command into the start queue,&n;**&t;in the following circumstances.&n;** &t;&t;Too few preallocated ccb(s), &n;**&t;&t;maxtags &lt; cmd_per_lun of the Linux host control block,&n;**&t;&t;etc...&n;**&t;Such scsi commands are inserted into a waiting list.&n;**&t;When a scsi command complete, we try to requeue the commands of the&n;**&t;waiting list.&n;*/
DECL|macro|next_wcmd
mdefine_line|#define next_wcmd host_scribble
DECL|function|insert_into_waiting_list
r_static
r_void
id|insert_into_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|Scsi_Cmnd
op_star
id|wcmd
suffix:semicolon
macro_line|#ifdef DEBUG_WAITING_LIST
id|printk
c_func
(paren
l_string|&quot;%s: cmd %lx inserted into waiting list&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|cmd-&gt;next_wcmd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|wcmd
op_assign
id|np-&gt;waiting_list
)paren
)paren
id|np-&gt;waiting_list
op_assign
id|cmd
suffix:semicolon
r_else
(brace
r_while
c_loop
(paren
(paren
id|wcmd-&gt;next_wcmd
)paren
op_ne
l_int|0
)paren
id|wcmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|wcmd-&gt;next_wcmd
suffix:semicolon
id|wcmd-&gt;next_wcmd
op_assign
(paren
r_char
op_star
)paren
id|cmd
suffix:semicolon
)brace
)brace
DECL|function|retrieve_from_waiting_list
r_static
id|Scsi_Cmnd
op_star
id|retrieve_from_waiting_list
c_func
(paren
r_int
id|to_remove
comma
id|ncb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|Scsi_Cmnd
op_star
op_star
id|pcmd
op_assign
op_amp
id|np-&gt;waiting_list
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pcmd
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_eq
op_star
id|pcmd
)paren
(brace
r_if
c_cond
(paren
id|to_remove
)paren
(brace
op_star
id|pcmd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|cmd-&gt;next_wcmd
suffix:semicolon
id|cmd-&gt;next_wcmd
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_WAITING_LIST
id|printk
c_func
(paren
l_string|&quot;%s: cmd %lx retrieved from waiting list&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|cmd
)paren
suffix:semicolon
macro_line|#endif
r_return
id|cmd
suffix:semicolon
)brace
id|pcmd
op_assign
(paren
id|Scsi_Cmnd
op_star
op_star
)paren
op_amp
(paren
op_star
id|pcmd
)paren
op_member_access_from_pointer
id|next_wcmd
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|process_waiting_list
r_static
r_void
id|process_waiting_list
c_func
(paren
id|ncb_p
id|np
comma
r_int
id|sts
)paren
(brace
id|Scsi_Cmnd
op_star
id|waiting_list
comma
op_star
id|wcmd
suffix:semicolon
id|waiting_list
op_assign
id|np-&gt;waiting_list
suffix:semicolon
id|np-&gt;waiting_list
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_WAITING_LIST
r_if
c_cond
(paren
id|waiting_list
)paren
id|printk
c_func
(paren
l_string|&quot;%s: waiting_list=%lx processing sts=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|waiting_list
comma
id|sts
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
(paren
id|wcmd
op_assign
id|waiting_list
)paren
op_ne
l_int|0
)paren
(brace
id|waiting_list
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|wcmd-&gt;next_wcmd
suffix:semicolon
id|wcmd-&gt;next_wcmd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sts
op_eq
id|DID_OK
)paren
(brace
macro_line|#ifdef DEBUG_WAITING_LIST
id|printk
c_func
(paren
l_string|&quot;%s: cmd %lx trying to requeue&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|wcmd
)paren
suffix:semicolon
macro_line|#endif
id|sts
op_assign
id|ncr_queue_command
c_func
(paren
id|np
comma
id|wcmd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sts
op_ne
id|DID_OK
)paren
(brace
macro_line|#ifdef DEBUG_WAITING_LIST
id|printk
c_func
(paren
l_string|&quot;%s: cmd %lx done forced sts=%d&bslash;n&quot;
comma
id|ncr_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_long
)paren
id|wcmd
comma
id|sts
)paren
suffix:semicolon
macro_line|#endif
id|SetScsiResult
c_func
(paren
id|wcmd
comma
id|sts
comma
l_int|0
)paren
suffix:semicolon
id|ncr_queue_done_cmd
c_func
(paren
id|np
comma
id|wcmd
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|macro|next_wcmd
macro_line|#undef next_wcmd
macro_line|#ifdef SCSI_NCR_PROC_INFO_SUPPORT
multiline_comment|/*=========================================================================&n;**&t;Proc file system stuff&n;**&n;**&t;A read operation returns profile information.&n;**&t;A write operation is a control command.&n;**&t;The string is parsed in the driver code and the command is passed &n;**&t;to the ncr_usercmd() function.&n;**=========================================================================&n;*/
macro_line|#ifdef SCSI_NCR_USER_COMMAND_SUPPORT
DECL|macro|is_digit
mdefine_line|#define is_digit(c)&t;((c) &gt;= &squot;0&squot; &amp;&amp; (c) &lt;= &squot;9&squot;)
DECL|macro|digit_to_bin
mdefine_line|#define digit_to_bin(c)&t;((c) - &squot;0&squot;)
DECL|macro|is_space
mdefine_line|#define is_space(c)&t;((c) == &squot; &squot; || (c) == &squot;&bslash;t&squot;)
DECL|function|skip_spaces
r_static
r_int
id|skip_spaces
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
)paren
(brace
r_int
id|cnt
comma
id|c
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
id|len
suffix:semicolon
id|cnt
OG
l_int|0
op_logical_and
(paren
id|c
op_assign
op_star
id|ptr
op_increment
)paren
op_logical_and
id|is_space
c_func
(paren
id|c
)paren
suffix:semicolon
id|cnt
op_decrement
)paren
suffix:semicolon
r_return
(paren
id|len
op_minus
id|cnt
)paren
suffix:semicolon
)brace
DECL|function|get_int_arg
r_static
r_int
id|get_int_arg
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
comma
id|u_long
op_star
id|pv
)paren
(brace
r_int
id|cnt
comma
id|c
suffix:semicolon
id|u_long
id|v
suffix:semicolon
r_for
c_loop
(paren
id|v
op_assign
l_int|0
comma
id|cnt
op_assign
id|len
suffix:semicolon
id|cnt
OG
l_int|0
op_logical_and
(paren
id|c
op_assign
op_star
id|ptr
op_increment
)paren
op_logical_and
id|is_digit
c_func
(paren
id|c
)paren
suffix:semicolon
id|cnt
op_decrement
)paren
(brace
id|v
op_assign
(paren
id|v
op_star
l_int|10
)paren
op_plus
id|digit_to_bin
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pv
)paren
op_star
id|pv
op_assign
id|v
suffix:semicolon
r_return
(paren
id|len
op_minus
id|cnt
)paren
suffix:semicolon
)brace
DECL|function|is_keyword
r_static
r_int
id|is_keyword
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
comma
r_char
op_star
id|verb
)paren
(brace
r_int
id|verb_len
op_assign
id|strlen
c_func
(paren
id|verb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|strlen
c_func
(paren
id|verb
)paren
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|verb
comma
id|ptr
comma
id|verb_len
)paren
)paren
r_return
id|verb_len
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SKIP_SPACES
mdefine_line|#define SKIP_SPACES(min_spaces)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if ((arg_len = skip_spaces(ptr, len)) &lt; (min_spaces))&t;&t;&bslash;&n;&t;&t;return -EINVAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ptr += arg_len; len -= arg_len;
DECL|macro|GET_INT_ARG
mdefine_line|#define GET_INT_ARG(v)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!(arg_len = get_int_arg(ptr, len, &amp;(v))))&t;&t;&t;&bslash;&n;&t;&t;return -EINVAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ptr += arg_len; len -= arg_len;
multiline_comment|/*&n;**&t;Parse a control command&n;*/
DECL|function|ncr_user_command
r_static
r_int
id|ncr_user_command
c_func
(paren
id|ncb_p
id|np
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_char
op_star
id|ptr
op_assign
id|buffer
suffix:semicolon
r_int
id|len
op_assign
id|length
suffix:semicolon
r_struct
id|usrcmd
op_star
id|uc
op_assign
op_amp
id|np-&gt;user
suffix:semicolon
r_int
id|arg_len
suffix:semicolon
id|u_long
id|target
suffix:semicolon
id|bzero
c_func
(paren
id|uc
comma
r_sizeof
(paren
op_star
id|uc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
op_logical_and
id|ptr
(braket
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
op_decrement
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setsync&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETSYNC
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;settags&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETTAGS
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setorder&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETORDER
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setverbose&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETVERBOSE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setwide&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETWIDE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setdebug&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETDEBUG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setflag&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETFLAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;clearprof&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_CLEARPROF
suffix:semicolon
r_else
id|arg_len
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;ncr_user_command: arg_len=%d, cmd=%ld&bslash;n&quot;
comma
id|arg_len
comma
id|uc-&gt;cmd
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|arg_len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETSYNC
suffix:colon
r_case
id|UC_SETTAGS
suffix:colon
r_case
id|UC_SETWIDE
suffix:colon
r_case
id|UC_SETFLAG
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;all&quot;
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
id|uc-&gt;target
op_assign
op_complement
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|GET_INT_ARG
c_func
(paren
id|target
)paren
suffix:semicolon
id|uc-&gt;target
op_assign
(paren
l_int|1
op_lshift
id|target
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;ncr_user_command: target=%ld&bslash;n&quot;
comma
id|target
)paren
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETVERBOSE
suffix:colon
r_case
id|UC_SETSYNC
suffix:colon
r_case
id|UC_SETTAGS
suffix:colon
r_case
id|UC_SETWIDE
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|GET_INT_ARG
c_func
(paren
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;ncr_user_command: data=%ld&bslash;n&quot;
comma
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|UC_SETORDER
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;simple&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
id|M_SIMPLE_TAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;ordered&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
id|M_ORDERED_TAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;default&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_assign
l_int|0
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETDEBUG
suffix:colon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;alloc&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_ALLOC
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;phase&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_PHASE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;poll&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_POLL
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;queue&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_QUEUE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;result&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_RESULT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;scatter&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_SCATTER
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;script&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_SCRIPT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;tiny&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TINY
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;timing&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TIMING
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;nego&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_NEGO
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;tags&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TAGS
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;freeze&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_FREEZE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;restart&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_RESTART
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;ncr_user_command: data=%ld&bslash;n&quot;
comma
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|UC_SETFLAG
suffix:colon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;trace&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|UF_TRACE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;no_disc&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|UF_NODISC
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
(brace
r_int
id|flags
suffix:semicolon
id|NCR_LOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|ncr_usercmd
(paren
id|np
)paren
suffix:semicolon
id|NCR_UNLOCK_NCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|length
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_NCR_USER_COMMAND_SUPPORT */
macro_line|#ifdef SCSI_NCR_USER_INFO_SUPPORT
DECL|struct|info_str
r_struct
id|info_str
(brace
DECL|member|buffer
r_char
op_star
id|buffer
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|pos
r_int
id|pos
suffix:semicolon
)brace
suffix:semicolon
DECL|function|copy_mem_info
r_static
r_void
id|copy_mem_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OG
id|info-&gt;length
)paren
id|len
op_assign
id|info-&gt;length
op_minus
id|info-&gt;pos
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OL
id|info-&gt;offset
)paren
(brace
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;pos
OL
id|info-&gt;offset
)paren
(brace
id|data
op_add_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|info-&gt;buffer
op_plus
id|info-&gt;pos
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
)brace
)brace
DECL|function|copy_info
r_static
r_int
id|copy_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
l_int|81
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|len
op_assign
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
id|copy_mem_info
c_func
(paren
id|info
comma
id|buf
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n;**&t;Copy formatted profile information into the input buffer.&n;*/
DECL|macro|to_ms
mdefine_line|#define to_ms(t) ((t) * 1000 / HZ)
DECL|function|ncr_host_info
r_static
r_int
id|ncr_host_info
c_func
(paren
id|ncb_p
id|np
comma
r_char
op_star
id|ptr
comma
id|off_t
id|offset
comma
r_int
id|len
)paren
(brace
r_struct
id|info_str
id|info
suffix:semicolon
id|info.buffer
op_assign
id|ptr
suffix:semicolon
id|info.length
op_assign
id|len
suffix:semicolon
id|info.offset
op_assign
id|offset
suffix:semicolon
id|info.pos
op_assign
l_int|0
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;General information:&bslash;n&quot;
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Chip &quot;
id|NAME53C
l_string|&quot;%s, &quot;
comma
id|np-&gt;chip_name
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;device id 0x%x, &quot;
comma
id|np-&gt;device_id
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;revision id 0x%x&bslash;n&quot;
comma
id|np-&gt;revision_id
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  IO port address 0x%lx, &quot;
comma
(paren
id|u_long
)paren
id|np-&gt;base_io
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;IRQ number %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|np-&gt;irq
)paren
suffix:semicolon
macro_line|#ifndef NCR_IOMAPPED
r_if
c_cond
(paren
id|np-&gt;reg
)paren
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Using memory mapped IO at virtual address 0x%lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
id|np-&gt;reg
)paren
suffix:semicolon
macro_line|#endif
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Synchronous period factor %d, &quot;
comma
(paren
r_int
)paren
id|np-&gt;minsync
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;max commands per lun %d&bslash;n&quot;
comma
id|SCSI_NCR_MAX_TAGS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_setup.debug
op_logical_or
id|driver_setup.verbose
OG
l_int|1
)paren
(brace
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  Debug flags 0x%x, &quot;
comma
id|driver_setup.debug
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;verbosity level %d&bslash;n&quot;
comma
id|driver_setup.verbose
)paren
suffix:semicolon
)brace
macro_line|#ifdef SCSI_NCR_PROFILE_SUPPORT
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Profiling information:&bslash;n&quot;
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_fly&quot;
comma
id|np-&gt;profile.num_fly
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_trans&quot;
comma
id|np-&gt;profile.num_trans
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_disc&quot;
comma
id|np-&gt;profile.num_disc
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_disc0&quot;
comma
id|np-&gt;profile.num_disc0
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_break&quot;
comma
id|np-&gt;profile.num_break
)paren
suffix:semicolon
macro_line|#if 000
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_br1k&quot;
comma
id|np-&gt;profile.num_br1k
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_br2k&quot;
comma
id|np-&gt;profile.num_br2k
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_br4k&quot;
comma
id|np-&gt;profile.num_br4k
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_br8k&quot;
comma
id|np-&gt;profile.num_br8k
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_brnk&quot;
comma
id|np-&gt;profile.num_brnk
)paren
suffix:semicolon
macro_line|#endif
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_int&quot;
comma
id|np-&gt;profile.num_int
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;  %-12s = %lu&bslash;n&quot;
comma
l_string|&quot;num_kbytes&quot;
comma
id|np-&gt;profile.num_kbytes
)paren
suffix:semicolon
macro_line|#endif
r_return
id|info.pos
OG
id|info.offset
ques
c_cond
id|info.pos
op_minus
id|info.offset
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_USER_INFO_SUPPORT */
multiline_comment|/*&n;**&t;Entry point of the scsi proc fs of the driver.&n;**&t;- func = 0 means read  (returns profile data)&n;**&t;- func = 1 means write (parse user control command)&n;*/
DECL|function|sym53c8xx_proc_info
r_static
r_int
id|sym53c8xx_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|func
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
id|ncb_p
id|ncb
op_assign
l_int|0
suffix:semicolon
r_int
id|retv
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_proc_info: hostno=%d, func=%d&bslash;n&quot;
comma
id|hostno
comma
id|func
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|host
op_assign
id|first_host
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|host-&gt;hostt
op_ne
id|first_host-&gt;hostt
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;host_no
op_eq
id|hostno
)paren
(brace
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|ncb
op_assign
id|host_data-&gt;ncb
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ncb
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|func
)paren
(brace
macro_line|#ifdef&t;SCSI_NCR_USER_COMMAND_SUPPORT
id|retv
op_assign
id|ncr_user_command
c_func
(paren
id|ncb
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
macro_line|#else
id|retv
op_assign
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
id|start
)paren
op_star
id|start
op_assign
id|buffer
suffix:semicolon
macro_line|#ifdef SCSI_NCR_USER_INFO_SUPPORT
id|retv
op_assign
id|ncr_host_info
c_func
(paren
id|ncb
comma
id|buffer
comma
id|offset
comma
id|length
)paren
suffix:semicolon
macro_line|#else
id|retv
op_assign
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*=========================================================================&n;**&t;End of proc file system stuff&n;**=========================================================================&n;*/
macro_line|#endif
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
multiline_comment|/* ---------------------------------------------------------------------&n;**&n;**&t;Try reading Symbios format nvram&n;**&n;** ---------------------------------------------------------------------&n;**&n;** GPOI0 - data in/data out&n;** GPIO1 - clock&n;**&n;**&t;return 0 if NVRAM data OK, 1 if NVRAM data not OK&n;** ---------------------------------------------------------------------&n;*/
DECL|macro|SET_BIT
mdefine_line|#define SET_BIT 0
DECL|macro|CLR_BIT
mdefine_line|#define CLR_BIT 1
DECL|macro|SET_CLK
mdefine_line|#define SET_CLK 2
DECL|macro|CLR_CLK
mdefine_line|#define CLR_CLK 3
r_static
id|u_short
id|nvram_read_data
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|data
comma
r_int
id|len
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
suffix:semicolon
r_static
r_void
id|nvram_start
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|nvram_write_byte
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|ack_data
comma
id|u_char
id|write_data
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
suffix:semicolon
r_static
r_void
id|nvram_read_byte
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_data
comma
id|u_char
id|ack_data
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
suffix:semicolon
r_static
r_void
id|nvram_readAck
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
suffix:semicolon
r_static
r_void
id|nvram_writeAck
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
suffix:semicolon
r_static
r_void
id|nvram_doBit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|nvram_stop
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|nvram_setBit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
comma
r_int
id|bit_mode
)paren
suffix:semicolon
DECL|function|ncr_get_Symbios_nvram
r_static
r_int
id|__init
id|ncr_get_Symbios_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|Symbios_nvram
op_star
id|nvram
)paren
(brace
r_static
id|u_char
id|Symbios_trailer
(braket
l_int|6
)braket
op_assign
(brace
l_int|0xfe
comma
l_int|0xfe
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|u_char
id|gpcntl
comma
id|gpreg
suffix:semicolon
id|u_char
id|old_gpcntl
comma
id|old_gpreg
suffix:semicolon
id|u_short
id|csum
suffix:semicolon
id|u_char
id|ack_data
suffix:semicolon
r_int
id|retv
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* save current state of GPCNTL and GPREG */
id|old_gpreg
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
id|old_gpcntl
op_assign
id|INB
(paren
id|nc_gpcntl
)paren
suffix:semicolon
id|gpcntl
op_assign
id|old_gpcntl
op_amp
l_int|0xfc
suffix:semicolon
multiline_comment|/* set up GPREG &amp; GPCNTL to set GPIO0 and GPIO1 in to known state */
id|OUTB
(paren
id|nc_gpreg
comma
id|old_gpreg
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* this is to set NVRAM into a known state with GPIO0/1 both low */
id|gpreg
op_assign
id|old_gpreg
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
op_amp
id|gpreg
comma
id|CLR_CLK
)paren
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
op_amp
id|gpreg
comma
id|CLR_BIT
)paren
suffix:semicolon
multiline_comment|/* now set NVRAM inactive with GPIO0/1 both high */
id|nvram_stop
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* activate NVRAM */
id|nvram_start
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* write device code and random address MSB */
id|nvram_write_byte
c_func
(paren
id|np
comma
op_amp
id|ack_data
comma
l_int|0xa0
op_or
(paren
(paren
id|SYMBIOS_NVRAM_ADDRESS
op_rshift
l_int|7
)paren
op_amp
l_int|0x0e
)paren
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack_data
op_amp
l_int|0x01
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* write random address LSB */
id|nvram_write_byte
c_func
(paren
id|np
comma
op_amp
id|ack_data
comma
(paren
id|SYMBIOS_NVRAM_ADDRESS
op_amp
l_int|0x7f
)paren
op_lshift
l_int|1
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack_data
op_amp
l_int|0x01
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* regenerate START state to set up for reading */
id|nvram_start
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* rewrite device code and address MSB with read bit set (lsb = 0x01) */
id|nvram_write_byte
c_func
(paren
id|np
comma
op_amp
id|ack_data
comma
l_int|0xa1
op_or
(paren
(paren
id|SYMBIOS_NVRAM_ADDRESS
op_rshift
l_int|7
)paren
op_amp
l_int|0x0e
)paren
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack_data
op_amp
l_int|0x01
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* now set up GPIO0 for inputting data */
id|gpcntl
op_or_assign
l_int|0x01
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* input all active data - only part of total NVRAM */
id|csum
op_assign
id|nvram_read_data
c_func
(paren
id|np
comma
(paren
id|u_char
op_star
)paren
id|nvram
comma
r_sizeof
(paren
op_star
id|nvram
)paren
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* finally put NVRAM back in inactive mode */
id|gpcntl
op_and_assign
l_int|0xfe
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
id|nvram_stop
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
macro_line|#ifdef SCSI_NCR_DEBUG_NVRAM
id|printk
c_func
(paren
l_string|&quot;sym53c8xx: NvRAM marker=%x trailer=%x %x %x %x %x %x byte_count=%d/%d checksum=%x/%x&bslash;n&quot;
comma
id|nvram-&gt;start_marker
comma
id|nvram-&gt;trailer
(braket
l_int|0
)braket
comma
id|nvram-&gt;trailer
(braket
l_int|1
)braket
comma
id|nvram-&gt;trailer
(braket
l_int|2
)braket
comma
id|nvram-&gt;trailer
(braket
l_int|3
)braket
comma
id|nvram-&gt;trailer
(braket
l_int|4
)braket
comma
id|nvram-&gt;trailer
(braket
l_int|5
)braket
comma
id|nvram-&gt;byte_count
comma
r_sizeof
(paren
op_star
id|nvram
)paren
op_minus
l_int|12
comma
id|nvram-&gt;checksum
comma
id|csum
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* check valid NVRAM signature, verify byte count and checksum */
r_if
c_cond
(paren
id|nvram-&gt;type
op_eq
l_int|0
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|nvram-&gt;trailer
comma
id|Symbios_trailer
comma
l_int|6
)paren
op_logical_and
id|nvram-&gt;byte_count
op_eq
r_sizeof
(paren
op_star
id|nvram
)paren
op_minus
l_int|12
op_logical_and
id|csum
op_eq
id|nvram-&gt;checksum
)paren
id|retv
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* return GPIO0/1 to original states after having accessed NVRAM */
id|OUTB
(paren
id|nc_gpcntl
comma
id|old_gpcntl
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
id|old_gpreg
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*&n; * Read Symbios NvRAM data and compute checksum.&n; */
DECL|function|nvram_read_data
r_static
id|u_short
id|__init
id|nvram_read_data
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|data
comma
r_int
id|len
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
(brace
r_int
id|x
suffix:semicolon
id|u_short
id|csum
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
suffix:semicolon
id|x
op_increment
)paren
id|nvram_read_byte
c_func
(paren
id|np
comma
op_amp
id|data
(braket
id|x
)braket
comma
(paren
id|x
op_eq
(paren
id|len
op_minus
l_int|1
)paren
)paren
comma
id|gpreg
comma
id|gpcntl
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|6
comma
id|csum
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
op_minus
l_int|6
suffix:semicolon
id|x
op_increment
)paren
id|csum
op_add_assign
id|data
(braket
id|x
)braket
suffix:semicolon
r_return
id|csum
suffix:semicolon
)brace
multiline_comment|/*&n; * Send START condition to NVRAM to wake it up.&n; */
DECL|function|nvram_start
r_static
r_void
id|__init
id|nvram_start
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|1
comma
id|gpreg
comma
id|SET_BIT
)paren
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|SET_CLK
)paren
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_BIT
)paren
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_CLK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * WRITE a byte to the NVRAM and then get an ACK to see it was accepted OK,&n; * GPIO0 must already be set as an output&n; */
DECL|function|nvram_write_byte
r_static
r_void
id|__init
id|nvram_write_byte
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|ack_data
comma
id|u_char
id|write_data
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
(brace
r_int
id|x
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|8
suffix:semicolon
id|x
op_increment
)paren
id|nvram_doBit
c_func
(paren
id|np
comma
l_int|0
comma
(paren
id|write_data
op_rshift
(paren
l_int|7
op_minus
id|x
)paren
)paren
op_amp
l_int|0x01
comma
id|gpreg
)paren
suffix:semicolon
id|nvram_readAck
c_func
(paren
id|np
comma
id|ack_data
comma
id|gpreg
comma
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * READ a byte from the NVRAM and then send an ACK to say we have got it,&n; * GPIO0 must already be set as an input&n; */
DECL|function|nvram_read_byte
r_static
r_void
id|__init
id|nvram_read_byte
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_data
comma
id|u_char
id|ack_data
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
(brace
r_int
id|x
suffix:semicolon
id|u_char
id|read_bit
suffix:semicolon
op_star
id|read_data
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|8
suffix:semicolon
id|x
op_increment
)paren
(brace
id|nvram_doBit
c_func
(paren
id|np
comma
op_amp
id|read_bit
comma
l_int|1
comma
id|gpreg
)paren
suffix:semicolon
op_star
id|read_data
op_or_assign
(paren
(paren
id|read_bit
op_amp
l_int|0x01
)paren
op_lshift
(paren
l_int|7
op_minus
id|x
)paren
)paren
suffix:semicolon
)brace
id|nvram_writeAck
c_func
(paren
id|np
comma
id|ack_data
comma
id|gpreg
comma
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Output an ACK to the NVRAM after reading,&n; * change GPIO0 to output and when done back to an input&n; */
DECL|function|nvram_writeAck
r_static
r_void
id|__init
id|nvram_writeAck
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
(brace
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
op_amp
l_int|0xfe
)paren
suffix:semicolon
id|nvram_doBit
c_func
(paren
id|np
comma
l_int|0
comma
id|write_bit
comma
id|gpreg
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Input an ACK from NVRAM after writing,&n; * change GPIO0 to input and when done back to an output&n; */
DECL|function|nvram_readAck
r_static
r_void
id|__init
id|nvram_readAck
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
(brace
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
op_or
l_int|0x01
)paren
suffix:semicolon
id|nvram_doBit
c_func
(paren
id|np
comma
id|read_bit
comma
l_int|1
comma
id|gpreg
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read or write a bit to the NVRAM,&n; * read if GPIO0 input else write if GPIO0 output&n; */
DECL|function|nvram_doBit
r_static
r_void
id|__init
id|nvram_doBit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|nvram_setBit
c_func
(paren
id|np
comma
id|write_bit
comma
id|gpreg
comma
id|SET_BIT
)paren
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|SET_CLK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_bit
)paren
op_star
id|read_bit
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_CLK
)paren
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_BIT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Send STOP condition to NVRAM - puts NVRAM to sleep... ZZzzzz!!&n; */
DECL|function|nvram_stop
r_static
r_void
id|__init
id|nvram_stop
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|SET_CLK
)paren
suffix:semicolon
id|nvram_setBit
c_func
(paren
id|np
comma
l_int|1
comma
id|gpreg
comma
id|SET_BIT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set/clear data/clock bit in GPIO0&n; */
DECL|function|nvram_setBit
r_static
r_void
id|__init
id|nvram_setBit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
comma
r_int
id|bit_mode
)paren
(brace
id|UDELAY
(paren
l_int|5
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bit_mode
)paren
(brace
r_case
id|SET_BIT
suffix:colon
op_star
id|gpreg
op_or_assign
id|write_bit
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLR_BIT
suffix:colon
op_star
id|gpreg
op_and_assign
l_int|0xfe
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SET_CLK
suffix:colon
op_star
id|gpreg
op_or_assign
l_int|0x02
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLR_CLK
suffix:colon
op_star
id|gpreg
op_and_assign
l_int|0xfd
suffix:semicolon
r_break
suffix:semicolon
)brace
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|5
)paren
suffix:semicolon
)brace
DECL|macro|SET_BIT
macro_line|#undef SET_BIT 0
DECL|macro|CLR_BIT
macro_line|#undef CLR_BIT 1
DECL|macro|SET_CLK
macro_line|#undef SET_CLK 2
DECL|macro|CLR_CLK
macro_line|#undef CLR_CLK 3
multiline_comment|/* ---------------------------------------------------------------------&n;**&n;**&t;Try reading Tekram format nvram&n;**&n;** ---------------------------------------------------------------------&n;**&n;** GPOI0 - data in&n;** GPIO1 - data out&n;** GPIO2 - clock&n;** GPIO4 - chip select&n;**&n;**&t;return 0 if NVRAM data OK, 1 if NVRAM data not OK&n;** ---------------------------------------------------------------------&n;*/
r_static
id|u_short
id|Tnvram_read_data
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
op_star
id|data
comma
r_int
id|len
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|Tnvram_Send_Command
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
id|write_data
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|Tnvram_Read_Word
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
op_star
id|nvram_data
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|Tnvram_Read_Bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|Tnvram_Write_Bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|Tnvram_Stop
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
r_static
r_void
id|Tnvram_Clk
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
suffix:semicolon
DECL|function|ncr_get_Tekram_nvram
r_static
r_int
id|__init
id|ncr_get_Tekram_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|Tekram_nvram
op_star
id|nvram
)paren
(brace
id|u_char
id|gpcntl
comma
id|gpreg
suffix:semicolon
id|u_char
id|old_gpcntl
comma
id|old_gpreg
suffix:semicolon
id|u_short
id|csum
suffix:semicolon
multiline_comment|/* save current state of GPCNTL and GPREG */
id|old_gpreg
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
id|old_gpcntl
op_assign
id|INB
(paren
id|nc_gpcntl
)paren
suffix:semicolon
multiline_comment|/* set up GPREG &amp; GPCNTL to set GPIO0/1/2/4 in to known state, 0 in,&n;&t;   1/2/4 out */
id|gpreg
op_assign
id|old_gpreg
op_amp
l_int|0xe9
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
id|gpreg
)paren
suffix:semicolon
id|gpcntl
op_assign
(paren
id|old_gpcntl
op_amp
l_int|0xe9
)paren
op_or
l_int|0x09
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* input all of NVRAM, 64 words */
id|csum
op_assign
id|Tnvram_read_data
c_func
(paren
id|np
comma
(paren
id|u_short
op_star
)paren
id|nvram
comma
r_sizeof
(paren
op_star
id|nvram
)paren
op_div
r_sizeof
(paren
r_int
)paren
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* return GPIO0/1/2/4 to original states after having accessed NVRAM */
id|OUTB
(paren
id|nc_gpcntl
comma
id|old_gpcntl
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
id|old_gpreg
)paren
suffix:semicolon
multiline_comment|/* check data valid */
r_if
c_cond
(paren
id|csum
op_ne
l_int|0x1234
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read Tekram NvRAM data and compute checksum.&n; */
DECL|function|Tnvram_read_data
r_static
id|u_short
id|__init
id|Tnvram_read_data
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
op_star
id|data
comma
r_int
id|len
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|u_char
id|read_bit
suffix:semicolon
id|u_short
id|csum
suffix:semicolon
r_int
id|x
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
comma
id|csum
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
suffix:semicolon
id|x
op_increment
)paren
(brace
multiline_comment|/* output read command and address */
id|Tnvram_Send_Command
c_func
(paren
id|np
comma
l_int|0x180
op_or
id|x
comma
op_amp
id|read_bit
comma
id|gpreg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_bit
op_amp
l_int|0x01
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Force bad checksum */
id|Tnvram_Read_Word
c_func
(paren
id|np
comma
op_amp
id|data
(braket
id|x
)braket
comma
id|gpreg
)paren
suffix:semicolon
id|csum
op_add_assign
id|data
(braket
id|x
)braket
suffix:semicolon
id|Tnvram_Stop
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
)brace
r_return
id|csum
suffix:semicolon
)brace
multiline_comment|/*&n; * Send read command and address to NVRAM&n; */
DECL|function|Tnvram_Send_Command
r_static
r_void
id|__init
id|Tnvram_Send_Command
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
id|write_data
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
)paren
(brace
r_int
id|x
suffix:semicolon
multiline_comment|/* send 9 bits, start bit (1), command (2), address (6)  */
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|9
suffix:semicolon
id|x
op_increment
)paren
id|Tnvram_Write_Bit
c_func
(paren
id|np
comma
(paren
id|u_char
)paren
(paren
id|write_data
op_rshift
(paren
l_int|8
op_minus
id|x
)paren
)paren
comma
id|gpreg
)paren
suffix:semicolon
op_star
id|read_bit
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * READ a byte from the NVRAM&n; */
DECL|function|Tnvram_Read_Word
r_static
r_void
id|__init
id|Tnvram_Read_Word
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
op_star
id|nvram_data
comma
id|u_char
op_star
id|gpreg
)paren
(brace
r_int
id|x
suffix:semicolon
id|u_char
id|read_bit
suffix:semicolon
op_star
id|nvram_data
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|16
suffix:semicolon
id|x
op_increment
)paren
(brace
id|Tnvram_Read_Bit
c_func
(paren
id|np
comma
op_amp
id|read_bit
comma
id|gpreg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_bit
op_amp
l_int|0x01
)paren
op_star
id|nvram_data
op_or_assign
(paren
l_int|0x01
op_lshift
(paren
l_int|15
op_minus
id|x
)paren
)paren
suffix:semicolon
r_else
op_star
id|nvram_data
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
(paren
l_int|15
op_minus
id|x
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Read bit from NVRAM&n; */
DECL|function|Tnvram_Read_Bit
r_static
r_void
id|__init
id|Tnvram_Read_Bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|UDELAY
(paren
l_int|2
)paren
suffix:semicolon
id|Tnvram_Clk
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
op_star
id|read_bit
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write bit to GPIO0&n; */
DECL|function|Tnvram_Write_Bit
r_static
r_void
id|__init
id|Tnvram_Write_Bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
)paren
(brace
r_if
c_cond
(paren
id|write_bit
op_amp
l_int|0x01
)paren
op_star
id|gpreg
op_or_assign
l_int|0x02
suffix:semicolon
r_else
op_star
id|gpreg
op_and_assign
l_int|0xfd
suffix:semicolon
op_star
id|gpreg
op_or_assign
l_int|0x10
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|2
)paren
suffix:semicolon
id|Tnvram_Clk
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Send STOP condition to NVRAM - puts NVRAM to sleep... ZZZzzz!!&n; */
DECL|function|Tnvram_Stop
r_static
r_void
id|__init
id|Tnvram_Stop
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
(brace
op_star
id|gpreg
op_and_assign
l_int|0xef
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|2
)paren
suffix:semicolon
id|Tnvram_Clk
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Pulse clock bit in GPIO0&n; */
DECL|function|Tnvram_Clk
r_static
r_void
id|__init
id|Tnvram_Clk
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
op_or
l_int|0x04
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|2
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_NCR_NVRAM_SUPPORT */
multiline_comment|/*&n;**&t;Module stuff&n;*/
macro_line|#ifdef MODULE
DECL|variable|driver_template
id|Scsi_Host_Template
id|driver_template
op_assign
id|SYM53C8XX
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
macro_line|#endif
eof
