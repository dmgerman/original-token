multiline_comment|/* $Id: parport_ax.c,v 1.12 1998/07/26 03:03:31 davem Exp $&n; * Parallel-port routines for Sun Ultra/AX architecture&n; * &n; * Author: Eddie C. Dost &lt;ecd@skynet.be&gt;&n; *&n; * based on work by:&n; *          Phil Blundell &lt;Philip.Blundell@pobox.com&gt;&n; *          Tim Waugh &lt;tim@cyberelk.demon.co.uk&gt;&n; *&t;    Jose Renau &lt;renau@acm.org&gt;&n; *          David Campbell &lt;campbell@tirian.che.curtin.edu.au&gt;&n; *          Grant Guenther &lt;grant@torque.net&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/ebus.h&gt;
macro_line|#include &lt;asm/ns87303.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
multiline_comment|/*&n; * Define this if you have Devices which don&squot;t support short&n; * host read/write cycles.&n; */
DECL|macro|HAVE_SLOW_DEVICES
macro_line|#undef HAVE_SLOW_DEVICES
DECL|macro|DATA
mdefine_line|#define DATA&t;&t;0x00
DECL|macro|STATUS
mdefine_line|#define STATUS&t;&t;0x01
DECL|macro|CONTROL
mdefine_line|#define CONTROL&t;&t;0x02
DECL|macro|EPPADDR
mdefine_line|#define EPPADDR&t;&t;0x03
DECL|macro|EPPDATA
mdefine_line|#define EPPDATA&t;&t;0x04
DECL|macro|CFIFO
mdefine_line|#define CFIFO&t;&t;0x400
DECL|macro|DFIFO
mdefine_line|#define DFIFO&t;&t;0x400
DECL|macro|TFIFO
mdefine_line|#define TFIFO&t;&t;0x400
DECL|macro|CONFIGA
mdefine_line|#define CONFIGA&t;&t;0x400
DECL|macro|CONFIGB
mdefine_line|#define CONFIGB&t;&t;0x401
DECL|macro|ECONTROL
mdefine_line|#define ECONTROL&t;0x402
DECL|function|parport_ax_interrupt
r_static
r_void
id|parport_ax_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|parport_generic_irq
c_func
(paren
id|irq
comma
(paren
r_struct
id|parport
op_star
)paren
id|dev_id
comma
id|regs
)paren
suffix:semicolon
)brace
r_void
DECL|function|parport_ax_write_epp
id|parport_ax_write_epp
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|d
)paren
(brace
id|outb
c_func
(paren
id|d
comma
id|p-&gt;base
op_plus
id|EPPDATA
)paren
suffix:semicolon
)brace
r_int
r_char
DECL|function|parport_ax_read_epp
id|parport_ax_read_epp
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|EPPDATA
)paren
suffix:semicolon
)brace
r_void
DECL|function|parport_ax_write_epp_addr
id|parport_ax_write_epp_addr
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|d
)paren
(brace
id|outb
c_func
(paren
id|d
comma
id|p-&gt;base
op_plus
id|EPPADDR
)paren
suffix:semicolon
)brace
r_int
r_char
DECL|function|parport_ax_read_epp_addr
id|parport_ax_read_epp_addr
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|EPPADDR
)paren
suffix:semicolon
)brace
r_int
id|parport_ax_epp_clear_timeout
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
suffix:semicolon
r_int
DECL|function|parport_ax_check_epp_timeout
id|parport_ax_check_epp_timeout
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|STATUS
)paren
op_amp
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|parport_ax_epp_clear_timeout
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_int
r_char
DECL|function|parport_ax_read_configb
id|parport_ax_read_configb
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|CONFIGB
)paren
suffix:semicolon
)brace
r_void
DECL|function|parport_ax_write_data
id|parport_ax_write_data
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|d
)paren
(brace
id|outb
c_func
(paren
id|d
comma
id|p-&gt;base
op_plus
id|DATA
)paren
suffix:semicolon
)brace
r_int
r_char
DECL|function|parport_ax_read_data
id|parport_ax_read_data
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|DATA
)paren
suffix:semicolon
)brace
r_void
DECL|function|parport_ax_write_control
id|parport_ax_write_control
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|d
)paren
(brace
id|outb
c_func
(paren
id|d
comma
id|p-&gt;base
op_plus
id|CONTROL
)paren
suffix:semicolon
)brace
r_int
r_char
DECL|function|parport_ax_read_control
id|parport_ax_read_control
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|CONTROL
)paren
suffix:semicolon
)brace
r_int
r_char
DECL|function|parport_ax_frob_control
id|parport_ax_frob_control
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|mask
comma
r_int
r_char
id|val
)paren
(brace
r_int
r_char
id|old
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|CONTROL
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
(paren
id|old
op_amp
op_complement
id|mask
)paren
op_xor
id|val
)paren
comma
id|p-&gt;base
op_plus
id|CONTROL
)paren
suffix:semicolon
r_return
id|old
suffix:semicolon
)brace
r_void
DECL|function|parport_ax_write_status
id|parport_ax_write_status
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|d
)paren
(brace
id|outb
c_func
(paren
id|d
comma
id|p-&gt;base
op_plus
id|STATUS
)paren
suffix:semicolon
)brace
r_int
r_char
DECL|function|parport_ax_read_status
id|parport_ax_read_status
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|STATUS
)paren
suffix:semicolon
)brace
r_void
DECL|function|parport_ax_write_econtrol
id|parport_ax_write_econtrol
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|d
)paren
(brace
id|outb
c_func
(paren
id|d
comma
id|p-&gt;base
op_plus
id|ECONTROL
)paren
suffix:semicolon
)brace
r_int
r_char
DECL|function|parport_ax_read_econtrol
id|parport_ax_read_econtrol
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|ECONTROL
)paren
suffix:semicolon
)brace
r_int
r_char
DECL|function|parport_ax_frob_econtrol
id|parport_ax_frob_econtrol
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|mask
comma
r_int
r_char
id|val
)paren
(brace
r_int
r_char
id|old
op_assign
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|ECONTROL
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
(paren
id|old
op_amp
op_complement
id|mask
)paren
op_xor
id|val
)paren
comma
id|p-&gt;base
op_plus
id|ECONTROL
)paren
suffix:semicolon
r_return
id|old
suffix:semicolon
)brace
r_void
DECL|function|parport_ax_change_mode
id|parport_ax_change_mode
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
id|m
)paren
(brace
id|parport_ax_frob_econtrol
c_func
(paren
id|p
comma
l_int|0xe0
comma
id|m
op_lshift
l_int|5
)paren
suffix:semicolon
)brace
r_void
DECL|function|parport_ax_write_fifo
id|parport_ax_write_fifo
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|v
)paren
(brace
id|outb
c_func
(paren
id|v
comma
id|p-&gt;base
op_plus
id|DFIFO
)paren
suffix:semicolon
)brace
r_int
r_char
DECL|function|parport_ax_read_fifo
id|parport_ax_read_fifo
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|inb
c_func
(paren
id|p-&gt;base
op_plus
id|DFIFO
)paren
suffix:semicolon
)brace
r_void
DECL|function|parport_ax_disable_irq
id|parport_ax_disable_irq
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_struct
id|linux_ebus_dma
op_star
id|dma
op_assign
id|p-&gt;private_data
suffix:semicolon
r_int
r_int
id|dcsr
suffix:semicolon
id|dcsr
op_assign
id|readl
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|dma-&gt;dcsr
)paren
suffix:semicolon
id|dcsr
op_and_assign
op_complement
(paren
id|EBUS_DCSR_INT_EN
)paren
suffix:semicolon
id|writel
c_func
(paren
id|dcsr
comma
(paren
r_int
r_int
)paren
op_amp
id|dma-&gt;dcsr
)paren
suffix:semicolon
)brace
r_void
DECL|function|parport_ax_enable_irq
id|parport_ax_enable_irq
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_struct
id|linux_ebus_dma
op_star
id|dma
op_assign
id|p-&gt;private_data
suffix:semicolon
r_int
r_int
id|dcsr
suffix:semicolon
id|dcsr
op_assign
id|readl
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|dma-&gt;dcsr
)paren
suffix:semicolon
id|dcsr
op_or_assign
id|EBUS_DCSR_INT_EN
suffix:semicolon
id|writel
c_func
(paren
id|dcsr
comma
(paren
r_int
r_int
)paren
op_amp
id|dma-&gt;dcsr
)paren
suffix:semicolon
)brace
r_void
DECL|function|parport_ax_release_resources
id|parport_ax_release_resources
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
)paren
(brace
id|parport_ax_disable_irq
c_func
(paren
id|p
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|p-&gt;irq
comma
id|p
)paren
suffix:semicolon
)brace
id|release_region
c_func
(paren
id|p-&gt;base
comma
id|p-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
id|release_region
c_func
(paren
id|p-&gt;base
op_plus
l_int|0x400
comma
l_int|3
)paren
suffix:semicolon
id|release_region
c_func
(paren
(paren
r_int
r_int
)paren
id|p-&gt;private_data
comma
r_sizeof
(paren
r_struct
id|linux_ebus_dma
)paren
)paren
suffix:semicolon
)brace
r_int
DECL|function|parport_ax_claim_resources
id|parport_ax_claim_resources
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
multiline_comment|/* FIXME check that resources are free */
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
)paren
r_if
c_cond
(paren
(paren
id|err
op_assign
id|request_irq
c_func
(paren
id|p-&gt;irq
comma
id|parport_ax_interrupt
comma
l_int|0
comma
id|p-&gt;name
comma
id|p
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_else
id|parport_ax_enable_irq
c_func
(paren
id|p
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|p-&gt;base
comma
id|p-&gt;size
comma
id|p-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
id|request_region
c_func
(paren
id|p-&gt;base
op_plus
l_int|0x400
comma
l_int|3
comma
id|p-&gt;name
)paren
suffix:semicolon
id|request_region
c_func
(paren
(paren
r_int
r_int
)paren
id|p-&gt;private_data
comma
r_sizeof
(paren
r_struct
id|linux_ebus_dma
)paren
comma
id|p-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|parport_ax_init_state
id|parport_ax_init_state
c_func
(paren
r_struct
id|parport_state
op_star
id|s
)paren
(brace
id|s-&gt;u.pc.ctr
op_assign
l_int|0xc
suffix:semicolon
id|s-&gt;u.pc.ecr
op_assign
l_int|0x0
suffix:semicolon
)brace
r_void
DECL|function|parport_ax_save_state
id|parport_ax_save_state
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_struct
id|parport_state
op_star
id|s
)paren
(brace
id|s-&gt;u.pc.ctr
op_assign
id|parport_ax_read_control
c_func
(paren
id|p
)paren
suffix:semicolon
id|s-&gt;u.pc.ecr
op_assign
id|parport_ax_read_econtrol
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_void
DECL|function|parport_ax_restore_state
id|parport_ax_restore_state
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_struct
id|parport_state
op_star
id|s
)paren
(brace
id|parport_ax_write_control
c_func
(paren
id|p
comma
id|s-&gt;u.pc.ctr
)paren
suffix:semicolon
id|parport_ax_write_econtrol
c_func
(paren
id|p
comma
id|s-&gt;u.pc.ecr
)paren
suffix:semicolon
)brace
r_int
DECL|function|parport_ax_epp_read_block
id|parport_ax_epp_read_block
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_void
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* FIXME */
)brace
r_int
DECL|function|parport_ax_epp_write_block
id|parport_ax_epp_write_block
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_void
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* FIXME */
)brace
r_int
DECL|function|parport_ax_ecp_read_block
id|parport_ax_ecp_read_block
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_void
op_star
id|buf
comma
r_int
id|length
comma
r_void
(paren
op_star
id|fn
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
)paren
comma
r_void
op_star
id|handle
)paren
(brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* FIXME */
)brace
r_int
DECL|function|parport_ax_ecp_write_block
id|parport_ax_ecp_write_block
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_void
op_star
id|buf
comma
r_int
id|length
comma
r_void
(paren
op_star
id|fn
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
)paren
comma
r_void
op_star
id|handle
)paren
(brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* FIXME */
)brace
r_void
DECL|function|parport_ax_inc_use_count
id|parport_ax_inc_use_count
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|parport_ax_dec_use_count
id|parport_ax_dec_use_count
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
DECL|function|parport_ax_fill_inode
r_static
r_void
id|parport_ax_fill_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|fill
)paren
(brace
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|fill
)paren
id|MOD_INC_USE_COUNT
suffix:semicolon
r_else
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|parport_ax_ops
r_static
r_struct
id|parport_operations
id|parport_ax_ops
op_assign
(brace
id|parport_ax_write_data
comma
id|parport_ax_read_data
comma
id|parport_ax_write_control
comma
id|parport_ax_read_control
comma
id|parport_ax_frob_control
comma
id|parport_ax_write_econtrol
comma
id|parport_ax_read_econtrol
comma
id|parport_ax_frob_econtrol
comma
id|parport_ax_write_status
comma
id|parport_ax_read_status
comma
id|parport_ax_write_fifo
comma
id|parport_ax_read_fifo
comma
id|parport_ax_change_mode
comma
id|parport_ax_release_resources
comma
id|parport_ax_claim_resources
comma
id|parport_ax_write_epp
comma
id|parport_ax_read_epp
comma
id|parport_ax_write_epp_addr
comma
id|parport_ax_read_epp_addr
comma
id|parport_ax_check_epp_timeout
comma
id|parport_ax_epp_write_block
comma
id|parport_ax_epp_read_block
comma
id|parport_ax_ecp_write_block
comma
id|parport_ax_ecp_read_block
comma
id|parport_ax_init_state
comma
id|parport_ax_save_state
comma
id|parport_ax_restore_state
comma
id|parport_ax_enable_irq
comma
id|parport_ax_disable_irq
comma
id|parport_ax_interrupt
comma
id|parport_ax_inc_use_count
comma
id|parport_ax_dec_use_count
comma
id|parport_ax_fill_inode
)brace
suffix:semicolon
multiline_comment|/******************************************************&n; *  MODE detection section:&n; */
multiline_comment|/*&n; * Clear TIMEOUT BIT in EPP MODE&n; */
DECL|function|parport_ax_epp_clear_timeout
r_int
id|parport_ax_epp_clear_timeout
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
r_char
id|r
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|parport_ax_read_status
c_func
(paren
id|pb
)paren
op_amp
l_int|0x01
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* To clear timeout some chips require double read */
id|parport_ax_read_status
c_func
(paren
id|pb
)paren
suffix:semicolon
id|r
op_assign
id|parport_ax_read_status
c_func
(paren
id|pb
)paren
suffix:semicolon
id|parport_ax_write_status
c_func
(paren
id|pb
comma
id|r
op_or
l_int|0x01
)paren
suffix:semicolon
multiline_comment|/* Some reset by writing 1 */
id|parport_ax_write_status
c_func
(paren
id|pb
comma
id|r
op_amp
l_int|0xfe
)paren
suffix:semicolon
multiline_comment|/* Others by writing 0 */
id|r
op_assign
id|parport_ax_read_status
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
op_logical_neg
(paren
id|r
op_amp
l_int|0x01
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for ECP&n; *&n; * Old style XT ports alias io ports every 0x400, hence accessing ECONTROL&n; * on these cards actually accesses the CTR.&n; *&n; * Modern cards don&squot;t do this but reading from ECONTROL will return 0xff&n; * regardless of what is written here if the card does NOT support&n; * ECP.&n; *&n; * We will write 0x2c to ECONTROL and 0xcc to CTR since both of these&n; * values are &quot;safe&quot; on the CTR since bits 6-7 of CTR are unused.&n; */
DECL|function|parport_ECR_present
r_static
r_int
id|parport_ECR_present
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
r_int
id|r
suffix:semicolon
r_int
r_char
id|octr
op_assign
id|pb-&gt;ops
op_member_access_from_pointer
id|read_control
c_func
(paren
id|pb
)paren
comma
id|oecr
op_assign
id|pb-&gt;ops
op_member_access_from_pointer
id|read_econtrol
c_func
(paren
id|pb
)paren
suffix:semicolon
id|r
op_assign
id|pb-&gt;ops
op_member_access_from_pointer
id|read_control
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pb-&gt;ops
op_member_access_from_pointer
id|read_econtrol
c_func
(paren
id|pb
)paren
op_amp
l_int|0x3
)paren
op_eq
(paren
id|r
op_amp
l_int|0x3
)paren
)paren
(brace
id|pb-&gt;ops
op_member_access_from_pointer
id|write_control
c_func
(paren
id|pb
comma
id|r
op_xor
l_int|0x2
)paren
suffix:semicolon
multiline_comment|/* Toggle bit 1 */
id|r
op_assign
id|pb-&gt;ops
op_member_access_from_pointer
id|read_control
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pb-&gt;ops
op_member_access_from_pointer
id|read_econtrol
c_func
(paren
id|pb
)paren
op_amp
l_int|0x2
)paren
op_eq
(paren
id|r
op_amp
l_int|0x2
)paren
)paren
(brace
id|pb-&gt;ops
op_member_access_from_pointer
id|write_control
c_func
(paren
id|pb
comma
id|octr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Sure that no ECONTROL register exists */
)brace
)brace
r_if
c_cond
(paren
(paren
id|pb-&gt;ops
op_member_access_from_pointer
id|read_econtrol
c_func
(paren
id|pb
)paren
op_amp
l_int|0x3
)paren
op_ne
l_int|0x1
)paren
r_return
l_int|0
suffix:semicolon
id|pb-&gt;ops
op_member_access_from_pointer
id|write_econtrol
c_func
(paren
id|pb
comma
l_int|0x34
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;ops
op_member_access_from_pointer
id|read_econtrol
c_func
(paren
id|pb
)paren
op_ne
l_int|0x35
)paren
r_return
l_int|0
suffix:semicolon
id|pb-&gt;ops
op_member_access_from_pointer
id|write_econtrol
c_func
(paren
id|pb
comma
id|oecr
)paren
suffix:semicolon
id|pb-&gt;ops
op_member_access_from_pointer
id|write_control
c_func
(paren
id|pb
comma
id|octr
)paren
suffix:semicolon
r_return
id|PARPORT_MODE_PCECR
suffix:semicolon
)brace
DECL|function|parport_ECP_supported
r_static
r_int
id|parport_ECP_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|oecr
op_assign
id|pb-&gt;ops
op_member_access_from_pointer
id|read_econtrol
c_func
(paren
id|pb
)paren
suffix:semicolon
multiline_comment|/* If there is no ECONTROL, we have no hope of supporting ECP. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Using LGS chipset it uses ECONTROL register, but&n;&t; * it doesn&squot;t support ECP or FIFO MODE&n;&t; */
id|pb-&gt;ops
op_member_access_from_pointer
id|write_econtrol
c_func
(paren
id|pb
comma
l_int|0xc0
)paren
suffix:semicolon
multiline_comment|/* TEST FIFO */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1024
op_logical_and
(paren
id|pb-&gt;ops
op_member_access_from_pointer
id|read_econtrol
c_func
(paren
id|pb
)paren
op_amp
l_int|0x01
)paren
suffix:semicolon
id|i
op_increment
)paren
id|pb-&gt;ops
op_member_access_from_pointer
id|write_fifo
c_func
(paren
id|pb
comma
l_int|0xaa
)paren
suffix:semicolon
id|pb-&gt;ops
op_member_access_from_pointer
id|write_econtrol
c_func
(paren
id|pb
comma
id|oecr
)paren
suffix:semicolon
r_return
(paren
id|i
op_eq
l_int|1024
)paren
ques
c_cond
l_int|0
suffix:colon
id|PARPORT_MODE_PCECP
suffix:semicolon
)brace
multiline_comment|/* Detect PS/2 support.&n; *&n; * Bit 5 (0x20) sets the PS/2 data direction; setting this high&n; * allows us to read data from the data lines.  In theory we would get back&n; * 0xff but any peripheral attached to the port may drag some or all of the&n; * lines down to zero.  So if we get back anything that isn&squot;t the contents&n; * of the data register we deem PS/2 support to be present. &n; *&n; * Some SPP ports have &quot;half PS/2&quot; ability - you can&squot;t turn off the line&n; * drivers, but an external peripheral with sufficiently beefy drivers of&n; * its own can overpower them and assert its own levels onto the bus, from&n; * where they can then be read back as normal.  Ports with this property&n; * and the right type of device attached are likely to fail the SPP test,&n; * (as they will appear to have stuck bits) and so the fact that they might&n; * be misdetected here is rather academic. &n; */
DECL|function|parport_PS2_supported
r_static
r_int
id|parport_PS2_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|ok
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|octr
op_assign
id|pb-&gt;ops
op_member_access_from_pointer
id|read_control
c_func
(paren
id|pb
)paren
suffix:semicolon
id|pb-&gt;ops
op_member_access_from_pointer
id|write_control
c_func
(paren
id|pb
comma
id|octr
op_or
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/* try to tri-state buffer */
id|pb-&gt;ops
op_member_access_from_pointer
id|write_data
c_func
(paren
id|pb
comma
l_int|0x55
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;ops
op_member_access_from_pointer
id|read_data
c_func
(paren
id|pb
)paren
op_ne
l_int|0x55
)paren
id|ok
op_increment
suffix:semicolon
id|pb-&gt;ops
op_member_access_from_pointer
id|write_data
c_func
(paren
id|pb
comma
l_int|0xaa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;ops
op_member_access_from_pointer
id|read_data
c_func
(paren
id|pb
)paren
op_ne
l_int|0xaa
)paren
id|ok
op_increment
suffix:semicolon
id|pb-&gt;ops
op_member_access_from_pointer
id|write_control
c_func
(paren
id|pb
comma
id|octr
)paren
suffix:semicolon
multiline_comment|/* cancel input mode */
r_return
id|ok
ques
c_cond
id|PARPORT_MODE_PCPS2
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|parport_ECPPS2_supported
r_static
r_int
id|parport_ECPPS2_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|mode
suffix:semicolon
r_int
r_char
id|oecr
op_assign
id|pb-&gt;ops
op_member_access_from_pointer
id|read_econtrol
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|pb-&gt;ops
op_member_access_from_pointer
id|write_econtrol
c_func
(paren
id|pb
comma
l_int|0x20
)paren
suffix:semicolon
id|mode
op_assign
id|parport_PS2_supported
c_func
(paren
id|pb
)paren
suffix:semicolon
id|pb-&gt;ops
op_member_access_from_pointer
id|write_econtrol
c_func
(paren
id|pb
comma
id|oecr
)paren
suffix:semicolon
r_return
id|mode
ques
c_cond
id|PARPORT_MODE_PCECPPS2
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|macro|printmode
mdefine_line|#define printmode(x)&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (p-&gt;modes &amp; PARPORT_MODE_PC##x) {&t;&t;&bslash;&n;&t;&t;printk(&quot;%s%s&quot;, f ? &quot;,&quot; : &quot;&quot;, #x);&t;&bslash;&n;&t;&t;f++;&t;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;}
r_int
DECL|function|init_one_port
id|init_one_port
c_func
(paren
r_struct
id|linux_ebus_device
op_star
id|dev
)paren
(brace
r_struct
id|parport
id|tmpport
comma
op_star
id|p
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
r_int
id|config
suffix:semicolon
r_int
r_char
id|tmp
suffix:semicolon
r_int
id|irq
comma
id|dma
suffix:semicolon
multiline_comment|/* Pointer to NS87303 Configuration Registers */
id|config
op_assign
id|dev-&gt;base_address
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Setup temporary access to Device operations */
id|tmpport.base
op_assign
id|dev-&gt;base_address
(braket
l_int|0
)braket
suffix:semicolon
id|tmpport.ops
op_assign
op_amp
id|parport_ax_ops
suffix:semicolon
multiline_comment|/* Enable ECP mode, set bit 2 of the CTR first */
id|tmpport.ops
op_member_access_from_pointer
id|write_control
c_func
(paren
op_amp
id|tmpport
comma
l_int|0x04
)paren
suffix:semicolon
id|tmp
op_assign
id|ns87303_readb
c_func
(paren
id|config
comma
id|PCR
)paren
suffix:semicolon
id|tmp
op_or_assign
(paren
id|PCR_EPP_IEEE
op_or
id|PCR_ECP_ENABLE
op_or
id|PCR_ECP_CLK_ENA
)paren
suffix:semicolon
id|ns87303_writeb
c_func
(paren
id|config
comma
id|PCR
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* LPT CTR bit 5 controls direction of parallel port */
id|tmp
op_assign
id|ns87303_readb
c_func
(paren
id|config
comma
id|PTR
)paren
suffix:semicolon
id|tmp
op_or_assign
id|PTR_LPT_REG_DIR
suffix:semicolon
id|ns87303_writeb
c_func
(paren
id|config
comma
id|PTR
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* Configure IRQ to Push Pull, Level Low */
id|tmp
op_assign
id|ns87303_readb
c_func
(paren
id|config
comma
id|PCR
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
(paren
id|PCR_IRQ_ODRAIN
)paren
suffix:semicolon
id|tmp
op_or_assign
id|PCR_IRQ_POLAR
suffix:semicolon
id|ns87303_writeb
c_func
(paren
id|config
comma
id|PCR
comma
id|tmp
)paren
suffix:semicolon
macro_line|#ifndef HAVE_SLOW_DEVICES
multiline_comment|/* Enable Zero Wait State for ECP */
id|tmp
op_assign
id|ns87303_readb
c_func
(paren
id|config
comma
id|FCR
)paren
suffix:semicolon
id|tmp
op_or_assign
id|FCR_ZWS_ENA
suffix:semicolon
id|ns87303_writeb
c_func
(paren
id|config
comma
id|FCR
comma
id|tmp
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Now continue initializing the port&n;&t; */
id|base
op_assign
id|dev-&gt;base_address
(braket
l_int|0
)braket
suffix:semicolon
id|irq
op_assign
id|dev-&gt;irqs
(braket
l_int|0
)braket
suffix:semicolon
id|dma
op_assign
id|PARPORT_DMA_AUTO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_assign
id|parport_register_port
c_func
(paren
id|base
comma
id|irq
comma
id|dma
comma
op_amp
id|parport_ax_ops
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Save away pointer to our EBus DMA */
id|p-&gt;private_data
op_assign
(paren
r_void
op_star
)paren
id|dev-&gt;base_address
(braket
l_int|2
)braket
suffix:semicolon
id|p-&gt;modes
op_assign
id|PARPORT_MODE_PCSPP
op_or
id|parport_PS2_supported
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_region
c_func
(paren
id|p-&gt;base
op_plus
l_int|0x400
comma
l_int|3
)paren
)paren
(brace
id|p-&gt;modes
op_or_assign
id|parport_ECR_present
c_func
(paren
id|p
)paren
suffix:semicolon
id|p-&gt;modes
op_or_assign
id|parport_ECP_supported
c_func
(paren
id|p
)paren
suffix:semicolon
id|p-&gt;modes
op_or_assign
id|parport_ECPPS2_supported
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|p-&gt;size
op_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;dma
op_eq
id|PARPORT_DMA_AUTO
)paren
id|p-&gt;dma
op_assign
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_PCECP
)paren
ques
c_cond
l_int|0
suffix:colon
id|PARPORT_DMA_NONE
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: PC-style at 0x%lx&quot;
comma
id|p-&gt;name
comma
id|p-&gt;base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
)paren
id|printk
c_func
(paren
l_string|&quot;, irq %s&quot;
comma
id|__irq_itoa
c_func
(paren
id|p-&gt;irq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;dma
op_ne
id|PARPORT_DMA_NONE
)paren
id|printk
c_func
(paren
l_string|&quot;, dma %d&quot;
comma
id|p-&gt;dma
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; [&quot;
)paren
suffix:semicolon
(brace
r_int
id|f
op_assign
l_int|0
suffix:semicolon
id|printmode
c_func
(paren
id|SPP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|PS2
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|ECP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|ECPPS2
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef&t;CONFIG_PROC_FS
id|parport_proc_register
c_func
(paren
id|p
)paren
suffix:semicolon
macro_line|#endif
id|p-&gt;flags
op_or_assign
id|PARPORT_FLAG_COMA
suffix:semicolon
id|p-&gt;ops
op_member_access_from_pointer
id|write_control
c_func
(paren
id|p
comma
l_int|0x0c
)paren
suffix:semicolon
id|p-&gt;ops
op_member_access_from_pointer
id|write_data
c_func
(paren
id|p
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_probe_hook
)paren
(paren
op_star
id|parport_probe_hook
)paren
(paren
id|p
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|EXPORT_NO_SYMBOLS
suffix:semicolon
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
macro_line|#else
id|__initfunc
c_func
(paren
r_int
id|parport_ax_init
c_func
(paren
r_void
)paren
)paren
macro_line|#endif
(brace
r_struct
id|linux_ebus
op_star
id|ebus
suffix:semicolon
r_struct
id|linux_ebus_device
op_star
id|edev
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|for_each_ebus
c_func
(paren
id|ebus
)paren
(brace
id|for_each_ebusdev
c_func
(paren
id|edev
comma
id|ebus
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|edev-&gt;prom_name
comma
l_string|&quot;ecpp&quot;
)paren
)paren
id|count
op_add_assign
id|init_one_port
c_func
(paren
id|edev
)paren
suffix:semicolon
)brace
)brace
r_return
id|count
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#ifdef MODULE
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|parport
op_star
id|p
op_assign
id|parport_enumerate
c_func
(paren
)paren
comma
op_star
id|tmp
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
id|tmp
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_PCSPP
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|PARPORT_FLAG_COMA
)paren
)paren
id|parport_quiesce
c_func
(paren
id|p
)paren
suffix:semicolon
macro_line|#ifdef&t;CONFIG_PROC_FS
id|parport_proc_unregister
c_func
(paren
id|p
)paren
suffix:semicolon
macro_line|#endif
id|parport_unregister_port
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|p
op_assign
id|tmp
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
