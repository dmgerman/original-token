multiline_comment|/* Parallel port /proc interface code.&n; * &n; * Authors: David Campbell &lt;campbell@torque.net&gt;&n; *          Tim Waugh &lt;tim@cyberelk.demon.co.uk&gt;&n; *          Philip Blundell &lt;philb@gnu.org&gt;&n; *          Andrea Arcangeli &lt;arcangeli@mbox.queen.it&gt;&n; *          Riccardo Facchetti &lt;fizban@tin.it&gt;&n; *&n; * based on work by Grant Guenther &lt;grant@torque.net&gt;&n; *              and Philip Blundell&n; */
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/tasks.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
DECL|variable|base
r_struct
id|proc_dir_entry
op_star
id|base
op_assign
l_int|NULL
suffix:semicolon
r_extern
r_void
id|parport_null_intr_func
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|function|irq_write_proc
r_static
r_int
id|irq_write_proc
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_int
id|newirq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
r_struct
id|parport
op_star
id|pp
op_assign
(paren
r_struct
id|parport
op_star
)paren
id|data
suffix:semicolon
r_int
id|oldirq
op_assign
id|pp-&gt;irq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n; * We can have these valid cases:&n; * &t;&quot;none&quot; (count == 4 || count == 5)&n; * &t;decimal number (count == 2 || count == 3)&n; * &t;octal number (count == 3 || count == 4)&n; * &t;hex number (count == 4 || count == 5)&n; * all other cases are -EINVAL&n; *&n; * Note: newirq is alredy set up to NONE.&n; *&n; * -RF&n; */
r_if
c_cond
(paren
id|count
OG
l_int|5
op_logical_or
id|count
OL
l_int|1
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|isdigit
c_func
(paren
id|buffer
(braket
l_int|0
)braket
)paren
)paren
id|newirq
op_assign
id|simple_strtoul
c_func
(paren
id|buffer
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;none&quot;
comma
l_int|4
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|buffer
(braket
l_int|0
)braket
OL
l_int|32
)paren
multiline_comment|/* Things like &squot;&bslash;n&squot; are harmless */
id|retval
op_assign
id|count
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|retval
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|oldirq
op_eq
id|newirq
)paren
r_goto
id|out
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;flags
op_amp
id|PARPORT_FLAG_COMA
)paren
r_goto
id|out_ok
suffix:semicolon
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;cad
)paren
r_goto
id|out_unlock
suffix:semicolon
r_if
c_cond
(paren
id|newirq
op_ne
id|PARPORT_IRQ_NONE
)paren
(brace
id|retval
op_assign
id|request_irq
c_func
(paren
id|newirq
comma
id|parport_null_intr_func
comma
id|SA_INTERRUPT
comma
id|pp-&gt;name
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out_unlock
suffix:semicolon
r_else
id|retval
op_assign
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
id|oldirq
op_ne
id|PARPORT_IRQ_NONE
)paren
id|free_irq
c_func
(paren
id|oldirq
comma
l_int|NULL
)paren
suffix:semicolon
id|out_ok
suffix:colon
id|pp-&gt;irq
op_assign
id|newirq
suffix:semicolon
id|out_unlock
suffix:colon
id|spin_unlock_irqrestore
(paren
op_amp
id|pp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|irq_read_proc
r_static
r_int
id|irq_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|parport
op_star
id|pp
op_assign
(paren
r_struct
id|parport
op_star
)paren
id|data
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
)paren
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;none&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|pp-&gt;irq
)paren
suffix:semicolon
op_star
id|start
op_assign
l_int|0
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|devices_read_proc
r_static
r_int
id|devices_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|parport
op_star
id|pp
op_assign
(paren
r_struct
id|parport
op_star
)paren
id|data
suffix:semicolon
r_struct
id|pardevice
op_star
id|pd1
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|pd1
op_assign
id|pp-&gt;devices
suffix:semicolon
id|pd1
suffix:semicolon
id|pd1
op_assign
id|pd1-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|pd1
op_eq
id|pp-&gt;cad
)paren
id|page
(braket
id|len
op_increment
)braket
op_assign
l_char|&squot;+&squot;
suffix:semicolon
r_else
id|page
(braket
id|len
op_increment
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;%s&quot;
comma
id|pd1-&gt;name
)paren
suffix:semicolon
id|page
(braket
id|len
op_increment
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
)brace
op_star
id|start
op_assign
l_int|0
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|hardware_read_proc
r_static
r_int
id|hardware_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|parport
op_star
id|pp
op_assign
(paren
r_struct
id|parport
op_star
)paren
id|data
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;base:&bslash;t0x%lx&bslash;n&quot;
comma
id|pp-&gt;base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;irq:&bslash;tnone&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;irq:&bslash;t%d&bslash;n&quot;
comma
id|pp-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;dma
op_eq
id|PARPORT_DMA_NONE
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;dma:&bslash;tnone&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;dma:&bslash;t%d&bslash;n&quot;
comma
id|pp-&gt;dma
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;modes:&bslash;t&quot;
)paren
suffix:semicolon
(brace
DECL|macro|printmode
mdefine_line|#define printmode(x) {if(pp-&gt;modes&amp;PARPORT_MODE_PC##x){len+=sprintf(page+len,&quot;%s%s&quot;,f?&quot;,&quot;:&quot;&quot;,#x);f++;}}
r_int
id|f
op_assign
l_int|0
suffix:semicolon
id|printmode
c_func
(paren
id|SPP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|PS2
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|EPP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|ECP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|ECPEPP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|ECPPS2
)paren
suffix:semicolon
DECL|macro|printmode
macro_line|#undef printmode
)brace
id|page
(braket
id|len
op_increment
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
op_star
id|start
op_assign
l_int|0
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|destroy_proc_entry
r_static
r_inline
r_void
id|destroy_proc_entry
c_func
(paren
r_struct
id|proc_dir_entry
op_star
id|root
comma
r_struct
id|proc_dir_entry
op_star
op_star
id|d
)paren
(brace
id|proc_unregister
c_func
(paren
id|root
comma
(paren
op_star
id|d
)paren
op_member_access_from_pointer
id|low_ino
)paren
suffix:semicolon
id|kfree
c_func
(paren
op_star
id|d
)paren
suffix:semicolon
op_star
id|d
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|destroy_proc_tree
r_static
r_void
id|destroy_proc_tree
c_func
(paren
r_struct
id|parport
op_star
id|pp
)paren
(brace
r_if
c_cond
(paren
id|pp-&gt;pdir.entry
)paren
(brace
r_if
c_cond
(paren
id|pp-&gt;pdir.irq
)paren
id|destroy_proc_entry
c_func
(paren
id|pp-&gt;pdir.entry
comma
op_amp
id|pp-&gt;pdir.irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;pdir.devices
)paren
id|destroy_proc_entry
c_func
(paren
id|pp-&gt;pdir.entry
comma
op_amp
id|pp-&gt;pdir.devices
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;pdir.hardware
)paren
id|destroy_proc_entry
c_func
(paren
id|pp-&gt;pdir.entry
comma
op_amp
id|pp-&gt;pdir.hardware
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;pdir.probe
)paren
id|destroy_proc_entry
c_func
(paren
id|pp-&gt;pdir.entry
comma
op_amp
id|pp-&gt;pdir.probe
)paren
suffix:semicolon
id|destroy_proc_entry
c_func
(paren
id|base
comma
op_amp
id|pp-&gt;pdir.entry
)paren
suffix:semicolon
)brace
)brace
DECL|function|new_proc_entry
r_static
r_struct
id|proc_dir_entry
op_star
id|new_proc_entry
c_func
(paren
r_const
r_char
op_star
id|name
comma
id|mode_t
id|mode
comma
r_struct
id|proc_dir_entry
op_star
id|parent
comma
r_int
r_int
id|ino
comma
r_struct
id|parport
op_star
id|p
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|ent
suffix:semicolon
id|ent
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|proc_dir_entry
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ent
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|ent
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|proc_dir_entry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|S_IFDIR
)paren
id|mode
op_or_assign
id|S_IRUGO
op_or
id|S_IXUGO
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mode
op_eq
l_int|0
)paren
id|mode
op_assign
id|S_IFREG
op_or
id|S_IRUGO
suffix:semicolon
id|ent-&gt;low_ino
op_assign
id|ino
suffix:semicolon
id|ent-&gt;name
op_assign
id|name
suffix:semicolon
id|ent-&gt;namelen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|ent-&gt;mode
op_assign
id|mode
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|p
op_logical_and
id|p-&gt;ops
)paren
id|ent-&gt;fill_inode
op_assign
id|p-&gt;ops-&gt;fill_inode
suffix:semicolon
id|ent-&gt;nlink
op_assign
l_int|2
suffix:semicolon
)brace
r_else
id|ent-&gt;nlink
op_assign
l_int|1
suffix:semicolon
id|proc_register
c_func
(paren
id|parent
comma
id|ent
)paren
suffix:semicolon
r_return
id|ent
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called as the fill_inode function when an inode&n; * is going into (fill = 1) or out of service (fill = 0).&n; * We use it here to manage the module use counts.&n; *&n; * Note: only the top-level directory needs to do this; if&n; * a lower level is referenced, the parent will be as well.&n; */
DECL|function|parport_modcount
r_static
r_void
id|parport_modcount
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|fill
)paren
(brace
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|fill
)paren
id|inc_parport_count
c_func
(paren
)paren
suffix:semicolon
r_else
id|dec_parport_count
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|parport_proc_init
r_int
id|parport_proc_init
c_func
(paren
r_void
)paren
(brace
id|base
op_assign
id|new_proc_entry
c_func
(paren
l_string|&quot;parport&quot;
comma
id|S_IFDIR
comma
op_amp
id|proc_root
comma
id|PROC_PARPORT
comma
l_int|NULL
)paren
suffix:semicolon
id|base-&gt;fill_inode
op_assign
op_amp
id|parport_modcount
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to initialise /proc/parport.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|parport_proc_cleanup
r_void
id|parport_proc_cleanup
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|base
)paren
(brace
id|proc_unregister
c_func
(paren
op_amp
id|proc_root
comma
id|base-&gt;low_ino
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|base
)paren
suffix:semicolon
id|base
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|parport_proc_register
r_int
id|parport_proc_register
c_func
(paren
r_struct
id|parport
op_star
id|pp
)paren
(brace
id|memset
c_func
(paren
op_amp
id|pp-&gt;pdir
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|parport_dir
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;parport_proc not initialised yet.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|pp-&gt;pdir.name
comma
id|pp-&gt;name
op_plus
id|strlen
c_func
(paren
l_string|&quot;parport&quot;
)paren
comma
r_sizeof
(paren
id|pp-&gt;pdir.name
)paren
)paren
suffix:semicolon
id|pp-&gt;pdir.entry
op_assign
id|new_proc_entry
c_func
(paren
id|pp-&gt;pdir.name
comma
id|S_IFDIR
comma
id|base
comma
l_int|0
comma
id|pp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;pdir.entry
op_eq
l_int|NULL
)paren
r_goto
id|out_fail
suffix:semicolon
id|pp-&gt;pdir.irq
op_assign
id|new_proc_entry
c_func
(paren
l_string|&quot;irq&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|pp-&gt;pdir.entry
comma
l_int|0
comma
id|pp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;pdir.irq
op_eq
l_int|NULL
)paren
r_goto
id|out_fail
suffix:semicolon
id|pp-&gt;pdir.irq-&gt;read_proc
op_assign
id|irq_read_proc
suffix:semicolon
id|pp-&gt;pdir.irq-&gt;write_proc
op_assign
id|irq_write_proc
suffix:semicolon
id|pp-&gt;pdir.irq-&gt;data
op_assign
id|pp
suffix:semicolon
id|pp-&gt;pdir.devices
op_assign
id|new_proc_entry
c_func
(paren
l_string|&quot;devices&quot;
comma
l_int|0
comma
id|pp-&gt;pdir.entry
comma
l_int|0
comma
id|pp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;pdir.devices
op_eq
l_int|NULL
)paren
r_goto
id|out_fail
suffix:semicolon
id|pp-&gt;pdir.devices-&gt;read_proc
op_assign
id|devices_read_proc
suffix:semicolon
id|pp-&gt;pdir.devices-&gt;data
op_assign
id|pp
suffix:semicolon
id|pp-&gt;pdir.hardware
op_assign
id|new_proc_entry
c_func
(paren
l_string|&quot;hardware&quot;
comma
l_int|0
comma
id|pp-&gt;pdir.entry
comma
l_int|0
comma
id|pp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;pdir.hardware
op_eq
l_int|NULL
)paren
r_goto
id|out_fail
suffix:semicolon
id|pp-&gt;pdir.hardware-&gt;read_proc
op_assign
id|hardware_read_proc
suffix:semicolon
id|pp-&gt;pdir.hardware-&gt;data
op_assign
id|pp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_fail
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: failure registering /proc/ entry.&bslash;n&quot;
comma
id|pp-&gt;name
)paren
suffix:semicolon
id|destroy_proc_tree
c_func
(paren
id|pp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|parport_proc_unregister
r_int
id|parport_proc_unregister
c_func
(paren
r_struct
id|parport
op_star
id|pp
)paren
(brace
id|destroy_proc_tree
c_func
(paren
id|pp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
