multiline_comment|/* Parallel port /proc interface code.&n; * &n; * Authors: David Campbell &lt;campbell@torque.net&gt;&n; *          Tim Waugh &lt;tim@cyberelk.demon.co.uk&gt;&n; *          Philip Blundell &lt;philb@gnu.org&gt;&n; *          Andrea Arcangeli &lt;arcangeli@mbox.queen.it&gt;&n; *&n; * based on work by Grant Guenther &lt;grant@torque.net&gt;&n; *              and Philip Blundell&n; */
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/tasks.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
DECL|variable|base
r_struct
id|proc_dir_entry
op_star
id|base
op_assign
l_int|NULL
suffix:semicolon
r_extern
r_void
id|parport_null_intr_func
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|function|irq_write_proc
r_static
r_int
id|irq_write_proc
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|newirq
comma
id|oldirq
suffix:semicolon
r_struct
id|parport
op_star
id|pp
op_assign
(paren
r_struct
id|parport
op_star
)paren
id|data
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|5
)paren
multiline_comment|/* more than 4 digits + &bslash;n for a irq 0x?? 0?? ??  */
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|buffer
(braket
l_int|0
)braket
OL
l_int|32
op_logical_or
op_logical_neg
id|strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;none&quot;
comma
l_int|4
)paren
)paren
(brace
id|newirq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|buffer
(braket
l_int|0
)braket
op_eq
l_char|&squot;0&squot;
)paren
(brace
r_if
c_cond
(paren
id|buffer
(braket
l_int|1
)braket
op_eq
l_char|&squot;x&squot;
)paren
id|newirq
op_assign
id|simple_strtoul
c_func
(paren
op_amp
id|buffer
(braket
l_int|2
)braket
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
r_else
id|newirq
op_assign
id|simple_strtoul
c_func
(paren
op_amp
id|buffer
(braket
l_int|1
)braket
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
)brace
r_else
(brace
id|newirq
op_assign
id|simple_strtoul
c_func
(paren
id|buffer
comma
l_int|0
comma
l_int|10
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|newirq
op_ge
id|NR_IRQS
)paren
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
op_logical_and
op_logical_neg
(paren
id|pp-&gt;flags
op_amp
id|PARPORT_FLAG_COMA
)paren
)paren
(brace
r_if
c_cond
(paren
id|pp-&gt;cad
op_ne
l_int|NULL
op_logical_and
id|pp-&gt;cad-&gt;irq_func
op_ne
l_int|NULL
)paren
id|free_irq
c_func
(paren
id|pp-&gt;irq
comma
id|pp-&gt;cad
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_else
id|free_irq
c_func
(paren
id|pp-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|oldirq
op_assign
id|pp-&gt;irq
suffix:semicolon
id|pp-&gt;irq
op_assign
id|newirq
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
op_logical_and
op_logical_neg
(paren
id|pp-&gt;flags
op_amp
id|PARPORT_FLAG_COMA
)paren
)paren
(brace
r_struct
id|pardevice
op_star
id|cad
op_assign
id|pp-&gt;cad
suffix:semicolon
r_if
c_cond
(paren
id|cad
op_eq
l_int|NULL
)paren
id|request_irq
c_func
(paren
id|pp-&gt;irq
comma
id|parport_null_intr_func
comma
id|SA_INTERRUPT
comma
id|pp-&gt;name
comma
l_int|NULL
)paren
suffix:semicolon
r_else
id|request_irq
c_func
(paren
id|pp-&gt;irq
comma
id|cad-&gt;irq_func
ques
c_cond
id|cad-&gt;irq_func
suffix:colon
id|parport_null_intr_func
comma
id|SA_INTERRUPT
comma
id|cad-&gt;name
comma
id|cad
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|oldirq
op_ne
id|PARPORT_IRQ_NONE
op_logical_and
id|newirq
op_eq
id|PARPORT_IRQ_NONE
op_logical_and
id|pp-&gt;cad
op_ne
l_int|NULL
op_logical_and
id|pp-&gt;cad-&gt;irq_func
op_ne
l_int|NULL
)paren
id|pp-&gt;cad
op_member_access_from_pointer
id|irq_func
c_func
(paren
id|pp-&gt;irq
comma
id|pp-&gt;cad
op_member_access_from_pointer
r_private
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|irq_read_proc
r_static
r_int
id|irq_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|parport
op_star
id|pp
op_assign
(paren
r_struct
id|parport
op_star
)paren
id|data
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
)paren
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;none&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|pp-&gt;irq
)paren
suffix:semicolon
op_star
id|start
op_assign
l_int|0
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|devices_read_proc
r_static
r_int
id|devices_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|parport
op_star
id|pp
op_assign
(paren
r_struct
id|parport
op_star
)paren
id|data
suffix:semicolon
r_struct
id|pardevice
op_star
id|pd1
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|pd1
op_assign
id|pp-&gt;devices
suffix:semicolon
id|pd1
suffix:semicolon
id|pd1
op_assign
id|pd1-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|pd1
op_eq
id|pp-&gt;cad
)paren
id|page
(braket
id|len
op_increment
)braket
op_assign
l_char|&squot;+&squot;
suffix:semicolon
r_else
id|page
(braket
id|len
op_increment
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;%s&quot;
comma
id|pd1-&gt;name
)paren
suffix:semicolon
id|page
(braket
id|len
op_increment
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
)brace
op_star
id|start
op_assign
l_int|0
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|hardware_read_proc
r_static
r_int
id|hardware_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|parport
op_star
id|pp
op_assign
(paren
r_struct
id|parport
op_star
)paren
id|data
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;base:&bslash;t0x%lx&bslash;n&quot;
comma
id|pp-&gt;base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;irq:&bslash;tnone&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;irq:&bslash;t%d&bslash;n&quot;
comma
id|pp-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;dma
op_eq
id|PARPORT_DMA_NONE
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;dma:&bslash;tnone&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;dma:&bslash;t%d&bslash;n&quot;
comma
id|pp-&gt;dma
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;modes:&bslash;t&quot;
)paren
suffix:semicolon
(brace
DECL|macro|printmode
mdefine_line|#define printmode(x) {if(pp-&gt;modes&amp;PARPORT_MODE_PC##x){len+=sprintf(page+len,&quot;%s%s&quot;,f?&quot;,&quot;:&quot;&quot;,#x);f++;}}
r_int
id|f
op_assign
l_int|0
suffix:semicolon
id|printmode
c_func
(paren
id|SPP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|PS2
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|EPP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|ECP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|ECPEPP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|ECPPS2
)paren
suffix:semicolon
DECL|macro|printmode
macro_line|#undef printmode
)brace
id|page
(braket
id|len
op_increment
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
op_star
id|start
op_assign
l_int|0
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|destroy_proc_entry
r_static
r_inline
r_void
id|destroy_proc_entry
c_func
(paren
r_struct
id|proc_dir_entry
op_star
id|root
comma
r_struct
id|proc_dir_entry
op_star
op_star
id|d
)paren
(brace
id|proc_unregister
c_func
(paren
id|root
comma
(paren
op_star
id|d
)paren
op_member_access_from_pointer
id|low_ino
)paren
suffix:semicolon
id|kfree
c_func
(paren
op_star
id|d
)paren
suffix:semicolon
op_star
id|d
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|new_proc_entry
r_static
r_struct
id|proc_dir_entry
op_star
id|new_proc_entry
c_func
(paren
r_const
r_char
op_star
id|name
comma
id|mode_t
id|mode
comma
r_struct
id|proc_dir_entry
op_star
id|parent
comma
r_int
r_int
id|ino
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|ent
suffix:semicolon
id|ent
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|proc_dir_entry
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ent
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|ent
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|proc_dir_entry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|S_IFDIR
)paren
id|mode
op_or_assign
id|S_IRUGO
op_or
id|S_IXUGO
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mode
op_eq
l_int|0
)paren
id|mode
op_assign
id|S_IFREG
op_or
id|S_IRUGO
suffix:semicolon
id|ent-&gt;low_ino
op_assign
id|ino
suffix:semicolon
id|ent-&gt;name
op_assign
id|name
suffix:semicolon
id|ent-&gt;namelen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|ent-&gt;mode
op_assign
id|mode
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
)paren
id|ent-&gt;nlink
op_assign
l_int|2
suffix:semicolon
r_else
id|ent-&gt;nlink
op_assign
l_int|1
suffix:semicolon
id|proc_register
c_func
(paren
id|parent
comma
id|ent
)paren
suffix:semicolon
r_return
id|ent
suffix:semicolon
)brace
DECL|function|parport_proc_init
r_int
id|parport_proc_init
c_func
(paren
r_void
)paren
(brace
id|base
op_assign
id|new_proc_entry
c_func
(paren
l_string|&quot;parport&quot;
comma
id|S_IFDIR
comma
op_amp
id|proc_root
comma
id|PROC_PARPORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to initialise /proc/parport.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|parport_proc_cleanup
r_void
id|parport_proc_cleanup
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|base
)paren
id|proc_unregister
c_func
(paren
op_amp
id|proc_root
comma
id|base-&gt;low_ino
)paren
suffix:semicolon
id|base
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|parport_proc_register
r_int
id|parport_proc_register
c_func
(paren
r_struct
id|parport
op_star
id|pp
)paren
(brace
r_static
r_const
r_char
op_star
id|proc_msg
op_assign
id|KERN_ERR
l_string|&quot;%s: Trouble with /proc.&bslash;n&quot;
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pp-&gt;pdir
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|parport_dir
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;parport_proc not initialised yet.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|pp-&gt;pdir.name
comma
id|pp-&gt;name
op_plus
id|strlen
c_func
(paren
l_string|&quot;parport&quot;
)paren
comma
r_sizeof
(paren
id|pp-&gt;pdir.name
)paren
)paren
suffix:semicolon
id|pp-&gt;pdir.entry
op_assign
id|new_proc_entry
c_func
(paren
id|pp-&gt;pdir.name
comma
id|S_IFDIR
comma
id|base
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;pdir.entry
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|proc_msg
comma
id|pp-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|pp-&gt;pdir.irq
op_assign
id|new_proc_entry
c_func
(paren
l_string|&quot;irq&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|pp-&gt;pdir.entry
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;pdir.irq
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|proc_msg
comma
id|pp-&gt;name
)paren
suffix:semicolon
id|destroy_proc_entry
c_func
(paren
id|base
comma
op_amp
id|pp-&gt;pdir.entry
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|pp-&gt;pdir.irq-&gt;read_proc
op_assign
id|irq_read_proc
suffix:semicolon
id|pp-&gt;pdir.irq-&gt;write_proc
op_assign
id|irq_write_proc
suffix:semicolon
id|pp-&gt;pdir.irq-&gt;data
op_assign
id|pp
suffix:semicolon
id|pp-&gt;pdir.devices
op_assign
id|new_proc_entry
c_func
(paren
l_string|&quot;devices&quot;
comma
l_int|0
comma
id|pp-&gt;pdir.entry
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;pdir.devices
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|proc_msg
comma
id|pp-&gt;name
)paren
suffix:semicolon
id|destroy_proc_entry
c_func
(paren
id|pp-&gt;pdir.entry
comma
op_amp
id|pp-&gt;pdir.irq
)paren
suffix:semicolon
id|destroy_proc_entry
c_func
(paren
id|base
comma
op_amp
id|pp-&gt;pdir.entry
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|pp-&gt;pdir.devices-&gt;read_proc
op_assign
id|devices_read_proc
suffix:semicolon
id|pp-&gt;pdir.devices-&gt;data
op_assign
id|pp
suffix:semicolon
id|pp-&gt;pdir.hardware
op_assign
id|new_proc_entry
c_func
(paren
l_string|&quot;hardware&quot;
comma
l_int|0
comma
id|pp-&gt;pdir.entry
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;pdir.hardware
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|proc_msg
comma
id|pp-&gt;name
)paren
suffix:semicolon
id|destroy_proc_entry
c_func
(paren
id|pp-&gt;pdir.entry
comma
op_amp
id|pp-&gt;pdir.devices
)paren
suffix:semicolon
id|destroy_proc_entry
c_func
(paren
id|pp-&gt;pdir.entry
comma
op_amp
id|pp-&gt;pdir.irq
)paren
suffix:semicolon
id|destroy_proc_entry
c_func
(paren
id|base
comma
op_amp
id|pp-&gt;pdir.entry
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|pp-&gt;pdir.hardware-&gt;read_proc
op_assign
id|hardware_read_proc
suffix:semicolon
id|pp-&gt;pdir.hardware-&gt;data
op_assign
id|pp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parport_proc_unregister
r_int
id|parport_proc_unregister
c_func
(paren
r_struct
id|parport
op_star
id|pp
)paren
(brace
r_if
c_cond
(paren
id|pp-&gt;pdir.entry
)paren
(brace
r_if
c_cond
(paren
id|pp-&gt;pdir.irq
)paren
id|destroy_proc_entry
c_func
(paren
id|pp-&gt;pdir.entry
comma
op_amp
id|pp-&gt;pdir.irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;pdir.devices
)paren
id|destroy_proc_entry
c_func
(paren
id|pp-&gt;pdir.entry
comma
op_amp
id|pp-&gt;pdir.devices
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;pdir.hardware
)paren
id|destroy_proc_entry
c_func
(paren
id|pp-&gt;pdir.entry
comma
op_amp
id|pp-&gt;pdir.hardware
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;pdir.probe
)paren
id|destroy_proc_entry
c_func
(paren
id|pp-&gt;pdir.entry
comma
op_amp
id|pp-&gt;pdir.probe
)paren
suffix:semicolon
id|destroy_proc_entry
c_func
(paren
id|base
comma
op_amp
id|pp-&gt;pdir.entry
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
