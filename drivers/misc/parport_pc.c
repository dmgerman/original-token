multiline_comment|/* Low-level parallel-port routines for 8255-based PC-style hardware.&n; * &n; * Authors: Phil Blundell &lt;Philip.Blundell@pobox.com&gt;&n; *          Tim Waugh &lt;tim@cyberelk.demon.co.uk&gt;&n; *&t;    Jose Renau &lt;renau@acm.org&gt;&n; *          David Campbell &lt;campbell@torque.net&gt;&n; *          Andrea Arcangeli&n; *&n; * based on work by Grant Guenther &lt;grant@torque.net&gt; and Phil Blundell.&n; *&n; * Cleaned up include files - Russell King &lt;linux@arm.uk.linux.org&gt;&n; * Better EPP probing - Carlos Henrique Bauer &lt;chbauer@acm.org&gt;&n; */
multiline_comment|/* This driver should work with any hardware that is broadly compatible&n; * with that in the IBM PC.  This applies to the majority of integrated&n; * I/O chipsets that are commonly available.  The expected register&n; * layout is:&n; *&n; *&t;base+0&t;&t;data&n; *&t;base+1&t;&t;status&n; *&t;base+2&t;&t;control&n; *&n; * In addition, there are some optional registers:&n; *&n; *&t;base+3&t;&t;EPP address&n; *&t;base+4&t;&t;EPP data&n; *&t;base+0x400&t;ECP config A&n; *&t;base+0x401&t;ECP config B&n; *&t;base+0x402&t;ECP control&n; *&n; * All registers are 8 bits wide and read/write.  If your hardware differs&n; * only in register addresses (eg because your registers are on 32-bit&n; * word boundaries) then you can alter the constants in parport_pc.h to&n; * accomodate this.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
macro_line|#include &lt;linux/parport_pc.h&gt;
multiline_comment|/* Maximum number of ports to support.  It is useless to set this greater&n;   than PARPORT_MAX (in &lt;linux/parport.h&gt;).  */
DECL|macro|PARPORT_PC_MAX_PORTS
mdefine_line|#define PARPORT_PC_MAX_PORTS  8
DECL|variable|__initdata
r_static
r_int
id|user_specified
id|__initdata
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Clear TIMEOUT BIT in EPP MODE&n; */
DECL|function|parport_pc_epp_clear_timeout
r_int
id|parport_pc_epp_clear_timeout
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
r_char
id|r
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|parport_pc_read_status
c_func
(paren
id|pb
)paren
op_amp
l_int|0x01
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* To clear timeout some chips require double read */
id|parport_pc_read_status
c_func
(paren
id|pb
)paren
suffix:semicolon
id|r
op_assign
id|parport_pc_read_status
c_func
(paren
id|pb
)paren
suffix:semicolon
id|parport_pc_write_status
c_func
(paren
id|pb
comma
id|r
op_or
l_int|0x01
)paren
suffix:semicolon
multiline_comment|/* Some reset by writing 1 */
id|parport_pc_write_status
c_func
(paren
id|pb
comma
id|r
op_amp
l_int|0xfe
)paren
suffix:semicolon
multiline_comment|/* Others by writing 0 */
id|r
op_assign
id|parport_pc_read_status
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
op_logical_neg
(paren
id|r
op_amp
l_int|0x01
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_interrupt
r_static
r_void
id|parport_pc_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|parport_generic_irq
c_func
(paren
id|irq
comma
(paren
r_struct
id|parport
op_star
)paren
id|dev_id
comma
id|regs
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_write_epp
r_void
id|parport_pc_write_epp
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|d
)paren
(brace
id|outb
c_func
(paren
id|d
comma
id|EPPDATA
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_read_epp
r_int
r_char
id|parport_pc_read_epp
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|inb
c_func
(paren
id|EPPDATA
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_write_epp_addr
r_void
id|parport_pc_write_epp_addr
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|d
)paren
(brace
id|outb
c_func
(paren
id|d
comma
id|EPPADDR
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_read_epp_addr
r_int
r_char
id|parport_pc_read_epp_addr
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|inb
c_func
(paren
id|EPPADDR
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_check_epp_timeout
r_int
id|parport_pc_check_epp_timeout
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|STATUS
c_func
(paren
id|p
)paren
)paren
op_amp
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|parport_pc_epp_clear_timeout
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|parport_pc_read_configb
r_int
r_char
id|parport_pc_read_configb
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|inb
c_func
(paren
id|CONFIGB
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_write_data
r_void
id|parport_pc_write_data
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|d
)paren
(brace
id|outb
c_func
(paren
id|d
comma
id|DATA
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_read_data
r_int
r_char
id|parport_pc_read_data
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|inb
c_func
(paren
id|DATA
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_write_control
r_void
id|parport_pc_write_control
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|d
)paren
(brace
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|p-&gt;private_data
suffix:semicolon
id|priv-&gt;ctr
op_assign
id|d
suffix:semicolon
multiline_comment|/* update soft copy */
id|outb
c_func
(paren
id|d
comma
id|CONTROL
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_read_control
r_int
r_char
id|parport_pc_read_control
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|p-&gt;private_data
suffix:semicolon
r_return
id|priv-&gt;ctr
suffix:semicolon
)brace
DECL|function|parport_pc_frob_control
r_int
r_char
id|parport_pc_frob_control
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|mask
comma
r_int
r_char
id|val
)paren
(brace
r_struct
id|parport_pc_private
op_star
id|priv
op_assign
id|p-&gt;private_data
suffix:semicolon
r_int
r_char
id|ctr
op_assign
id|priv-&gt;ctr
suffix:semicolon
id|ctr
op_assign
(paren
id|ctr
op_amp
op_complement
id|mask
)paren
op_xor
id|val
suffix:semicolon
id|outb
(paren
id|ctr
comma
id|CONTROL
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
r_return
id|priv-&gt;ctr
op_assign
id|ctr
suffix:semicolon
multiline_comment|/* update soft copy */
)brace
DECL|function|parport_pc_write_status
r_void
id|parport_pc_write_status
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|d
)paren
(brace
id|outb
c_func
(paren
id|d
comma
id|STATUS
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_read_status
r_int
r_char
id|parport_pc_read_status
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|inb
c_func
(paren
id|STATUS
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_write_econtrol
r_void
id|parport_pc_write_econtrol
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|d
)paren
(brace
id|outb
c_func
(paren
id|d
comma
id|ECONTROL
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_read_econtrol
r_int
r_char
id|parport_pc_read_econtrol
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|inb
c_func
(paren
id|ECONTROL
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_frob_econtrol
r_int
r_char
id|parport_pc_frob_econtrol
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|mask
comma
r_int
r_char
id|val
)paren
(brace
r_int
r_char
id|old
op_assign
id|inb
c_func
(paren
id|ECONTROL
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
(paren
id|old
op_amp
op_complement
id|mask
)paren
op_xor
id|val
)paren
comma
id|ECONTROL
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
r_return
id|old
suffix:semicolon
)brace
DECL|function|parport_pc_change_mode
r_void
id|parport_pc_change_mode
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
id|m
)paren
(brace
multiline_comment|/* FIXME */
)brace
DECL|function|parport_pc_write_fifo
r_void
id|parport_pc_write_fifo
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_int
r_char
id|v
)paren
(brace
id|outb
(paren
id|v
comma
id|CONFIGA
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_read_fifo
r_int
r_char
id|parport_pc_read_fifo
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
r_return
id|inb
(paren
id|CONFIGA
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_disable_irq
r_void
id|parport_pc_disable_irq
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
id|parport_pc_frob_control
c_func
(paren
id|p
comma
l_int|0x10
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_enable_irq
r_void
id|parport_pc_enable_irq
c_func
(paren
r_struct
id|parport
op_star
id|p
)paren
(brace
id|parport_pc_frob_control
c_func
(paren
id|p
comma
l_int|0x10
comma
l_int|0x10
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_init_state
r_void
id|parport_pc_init_state
c_func
(paren
r_struct
id|parport_state
op_star
id|s
)paren
(brace
id|s-&gt;u.pc.ctr
op_assign
l_int|0xc
suffix:semicolon
id|s-&gt;u.pc.ecr
op_assign
l_int|0x0
suffix:semicolon
)brace
DECL|function|parport_pc_save_state
r_void
id|parport_pc_save_state
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_struct
id|parport_state
op_star
id|s
)paren
(brace
id|s-&gt;u.pc.ctr
op_assign
id|parport_pc_read_control
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
id|s-&gt;u.pc.ecr
op_assign
id|parport_pc_read_econtrol
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_restore_state
r_void
id|parport_pc_restore_state
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_struct
id|parport_state
op_star
id|s
)paren
(brace
id|parport_pc_write_control
c_func
(paren
id|p
comma
id|s-&gt;u.pc.ctr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
id|parport_pc_write_econtrol
c_func
(paren
id|p
comma
id|s-&gt;u.pc.ecr
)paren
suffix:semicolon
)brace
DECL|function|parport_pc_epp_read_block
r_int
id|parport_pc_epp_read_block
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_void
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_int
id|got
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|got
OL
id|length
suffix:semicolon
id|got
op_increment
)paren
(brace
op_star
(paren
(paren
r_char
op_star
)paren
id|buf
)paren
op_increment
op_assign
id|inb
(paren
id|EPPDATA
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
(paren
id|STATUS
c_func
(paren
id|p
)paren
)paren
op_amp
l_int|0x01
)paren
r_break
suffix:semicolon
)brace
r_return
id|got
suffix:semicolon
)brace
DECL|function|parport_pc_epp_write_block
r_int
id|parport_pc_epp_write_block
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_void
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_int
id|written
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|written
OL
id|length
suffix:semicolon
id|written
op_increment
)paren
(brace
id|outb
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|buf
)paren
op_increment
comma
id|EPPDATA
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
(paren
id|STATUS
c_func
(paren
id|p
)paren
)paren
op_amp
l_int|0x01
)paren
r_break
suffix:semicolon
)brace
r_return
id|written
suffix:semicolon
)brace
DECL|function|parport_pc_ecp_read_block
r_int
id|parport_pc_ecp_read_block
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_void
op_star
id|buf
comma
r_int
id|length
comma
r_void
(paren
op_star
id|fn
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
)paren
comma
r_void
op_star
id|handle
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* FIXME */
)brace
DECL|function|parport_pc_ecp_write_block
r_int
id|parport_pc_ecp_write_block
c_func
(paren
r_struct
id|parport
op_star
id|p
comma
r_void
op_star
id|buf
comma
r_int
id|length
comma
r_void
(paren
op_star
id|fn
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
)paren
comma
r_void
op_star
id|handle
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* FIXME */
)brace
DECL|function|parport_pc_inc_use_count
r_void
id|parport_pc_inc_use_count
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
DECL|function|parport_pc_dec_use_count
r_void
id|parport_pc_dec_use_count
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
DECL|function|parport_pc_fill_inode
r_static
r_void
id|parport_pc_fill_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|fill
)paren
(brace
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|fill
)paren
id|MOD_INC_USE_COUNT
suffix:semicolon
r_else
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|parport_pc_ops
r_struct
id|parport_operations
id|parport_pc_ops
op_assign
(brace
id|parport_pc_write_data
comma
id|parport_pc_read_data
comma
id|parport_pc_write_control
comma
id|parport_pc_read_control
comma
id|parport_pc_frob_control
comma
id|parport_pc_write_econtrol
comma
id|parport_pc_read_econtrol
comma
id|parport_pc_frob_econtrol
comma
id|parport_pc_write_status
comma
id|parport_pc_read_status
comma
id|parport_pc_write_fifo
comma
id|parport_pc_read_fifo
comma
id|parport_pc_change_mode
comma
id|parport_pc_write_epp
comma
id|parport_pc_read_epp
comma
id|parport_pc_write_epp_addr
comma
id|parport_pc_read_epp_addr
comma
id|parport_pc_check_epp_timeout
comma
id|parport_pc_epp_write_block
comma
id|parport_pc_epp_read_block
comma
id|parport_pc_ecp_write_block
comma
id|parport_pc_ecp_read_block
comma
id|parport_pc_init_state
comma
id|parport_pc_save_state
comma
id|parport_pc_restore_state
comma
id|parport_pc_enable_irq
comma
id|parport_pc_disable_irq
comma
id|parport_pc_interrupt
comma
id|parport_pc_inc_use_count
comma
id|parport_pc_dec_use_count
comma
id|parport_pc_fill_inode
)brace
suffix:semicolon
multiline_comment|/* --- Mode detection ------------------------------------- */
multiline_comment|/*&n; * Checks for port existence, all ports support SPP MODE&n; */
DECL|function|parport_SPP_supported
r_static
r_int
id|__init
id|parport_SPP_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
r_char
id|r
comma
id|w
suffix:semicolon
multiline_comment|/*&n;&t; * first clear an eventually pending EPP timeout &n;&t; * I (sailer@ife.ee.ethz.ch) have an SMSC chipset&n;&t; * that does not even respond to SPP cycles if an EPP&n;&t; * timeout is pending&n;&t; */
id|parport_pc_epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
multiline_comment|/* Do a simple read-write test to make sure the port exists. */
id|w
op_assign
l_int|0xc
suffix:semicolon
id|parport_pc_write_control
c_func
(paren
id|pb
comma
id|w
)paren
suffix:semicolon
multiline_comment|/* Can we read from the control register?  Some ports don&squot;t&n;&t; * allow reads, so read_control just returns a software&n;&t; * copy. Some ports _do_ allow reads, so bypass the software&n;&t; * copy here.  In addition, some bits aren&squot;t writable. */
id|r
op_assign
id|inb
(paren
id|CONTROL
(paren
id|pb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|0xf
)paren
op_eq
id|w
)paren
(brace
id|w
op_assign
l_int|0xe
suffix:semicolon
id|parport_pc_write_control
(paren
id|pb
comma
id|w
)paren
suffix:semicolon
id|r
op_assign
id|inb
(paren
id|CONTROL
c_func
(paren
id|pb
)paren
)paren
suffix:semicolon
id|parport_pc_write_control
(paren
id|pb
comma
l_int|0xc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|0xf
)paren
op_eq
id|w
)paren
r_return
id|PARPORT_MODE_PCSPP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|user_specified
)paren
multiline_comment|/* That didn&squot;t work, but the user thinks there&squot;s a&n;&t;&t; * port here. */
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;0x%lx: CTR: wrote 0x%02x, read 0x%02x&bslash;n&quot;
comma
id|pb-&gt;base
comma
id|w
comma
id|r
)paren
suffix:semicolon
multiline_comment|/* Try the data register.  The data lines aren&squot;t tri-stated at&n;&t; * this stage, so we expect back what we wrote. */
id|w
op_assign
l_int|0xaa
suffix:semicolon
id|parport_pc_write_data
(paren
id|pb
comma
id|w
)paren
suffix:semicolon
id|r
op_assign
id|parport_pc_read_data
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
id|w
)paren
(brace
id|w
op_assign
l_int|0x55
suffix:semicolon
id|parport_pc_write_data
(paren
id|pb
comma
id|w
)paren
suffix:semicolon
id|r
op_assign
id|parport_pc_read_data
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
id|w
)paren
r_return
id|PARPORT_MODE_PCSPP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|user_specified
)paren
multiline_comment|/* Didn&squot;t work with 0xaa, but the user is convinced&n;&t;&t; * this is the place. */
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;0x%lx: DATA: wrote 0x%02x, read 0x%02x&bslash;n&quot;
comma
id|pb-&gt;base
comma
id|w
comma
id|r
)paren
suffix:semicolon
multiline_comment|/* It&squot;s possible that we can&squot;t read the control register or&n;&t;   the data register.  In that case just believe the user. */
r_if
c_cond
(paren
id|user_specified
)paren
r_return
id|PARPORT_MODE_PCSPP
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Check for ECP&n; *&n; * Old style XT ports alias io ports every 0x400, hence accessing ECR&n; * on these cards actually accesses the CTR.&n; *&n; * Modern cards don&squot;t do this but reading from ECR will return 0xff&n; * regardless of what is written here if the card does NOT support&n; * ECP.&n; *&n; * We will write 0x2c to ECR and 0xcc to CTR since both of these&n; * values are &quot;safe&quot; on the CTR since bits 6-7 of CTR are unused.&n; */
DECL|function|parport_ECR_present
r_static
r_int
id|__init
id|parport_ECR_present
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
r_char
id|r
suffix:semicolon
id|parport_pc_write_control
(paren
id|pb
comma
l_int|0xc
)paren
suffix:semicolon
id|r
op_assign
id|parport_pc_read_control
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|parport_pc_read_econtrol
c_func
(paren
id|pb
)paren
op_amp
l_int|0x3
)paren
op_eq
(paren
id|r
op_amp
l_int|0x3
)paren
)paren
(brace
id|parport_pc_write_control
c_func
(paren
id|pb
comma
id|r
op_xor
l_int|0x2
)paren
suffix:semicolon
multiline_comment|/* Toggle bit 1 */
id|r
op_assign
id|parport_pc_read_control
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|parport_pc_read_econtrol
c_func
(paren
id|pb
)paren
op_amp
l_int|0x2
)paren
op_eq
(paren
id|r
op_amp
l_int|0x2
)paren
)paren
r_goto
id|no_reg
suffix:semicolon
multiline_comment|/* Sure that no ECR register exists */
)brace
r_if
c_cond
(paren
(paren
id|parport_pc_read_econtrol
c_func
(paren
id|pb
)paren
op_amp
l_int|0x3
)paren
op_ne
l_int|0x1
)paren
r_goto
id|no_reg
suffix:semicolon
id|parport_pc_write_econtrol
c_func
(paren
id|pb
comma
l_int|0x34
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_pc_read_econtrol
c_func
(paren
id|pb
)paren
op_ne
l_int|0x35
)paren
r_goto
id|no_reg
suffix:semicolon
id|parport_pc_write_control
c_func
(paren
id|pb
comma
l_int|0xc
)paren
suffix:semicolon
multiline_comment|/* Go to mode 000; SPP, reset FIFO */
id|parport_pc_frob_econtrol
(paren
id|pb
comma
l_int|0xe0
comma
l_int|0x00
)paren
suffix:semicolon
r_return
id|PARPORT_MODE_PCECR
suffix:semicolon
id|no_reg
suffix:colon
id|parport_pc_write_control
(paren
id|pb
comma
l_int|0xc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parport_ECP_supported
r_static
r_int
id|__init
id|parport_ECP_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|oecr
suffix:semicolon
multiline_comment|/* If there is no ECR, we have no hope of supporting ECP. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|oecr
op_assign
id|parport_pc_read_econtrol
c_func
(paren
id|pb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Using LGS chipset it uses ECR register, but&n;&t; * it doesn&squot;t support ECP or FIFO MODE&n;&t; */
id|parport_pc_write_econtrol
c_func
(paren
id|pb
comma
l_int|0xc0
)paren
suffix:semicolon
multiline_comment|/* TEST FIFO */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1024
op_logical_and
(paren
id|parport_pc_read_econtrol
c_func
(paren
id|pb
)paren
op_amp
l_int|0x01
)paren
suffix:semicolon
id|i
op_increment
)paren
id|parport_pc_write_fifo
c_func
(paren
id|pb
comma
l_int|0xaa
)paren
suffix:semicolon
id|parport_pc_write_econtrol
c_func
(paren
id|pb
comma
id|oecr
)paren
suffix:semicolon
r_return
(paren
id|i
op_eq
l_int|1024
)paren
ques
c_cond
l_int|0
suffix:colon
id|PARPORT_MODE_PCECP
suffix:semicolon
)brace
multiline_comment|/* EPP mode detection&n; * Theory:&n; *&t;Bit 0 of STR is the EPP timeout bit, this bit is 0&n; *&t;when EPP is possible and is set high when an EPP timeout&n; *&t;occurs (EPP uses the HALT line to stop the CPU while it does&n; *&t;the byte transfer, an EPP timeout occurs if the attached&n; *&t;device fails to respond after 10 micro seconds).&n; *&n; *&t;This bit is cleared by either reading it (National Semi)&n; *&t;or writing a 1 to the bit (SMC, UMC, WinBond), others ???&n; *&t;This bit is always high in non EPP modes.&n; */
DECL|function|parport_EPP_supported
r_static
r_int
id|__init
id|parport_EPP_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
multiline_comment|/* If EPP timeout bit clear then EPP available */
r_if
c_cond
(paren
op_logical_neg
id|parport_pc_epp_clear_timeout
c_func
(paren
id|pb
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* No way to clear timeout */
multiline_comment|/*&n;&t; * Theory:&n;&t; *&t;Bit 0 of STR is the EPP timeout bit, this bit is 0&n;&t; *&t;when EPP is possible and is set high when an EPP timeout&n;&t; *&t;occurs (EPP uses the HALT line to stop the CPU while it does&n;&t; *&t;the byte transfer, an EPP timeout occurs if the attached&n;&t; *&t;device fails to respond after 10 micro seconds).&n;&t; *&n;&t; *&t;This bit is cleared by either reading it (National Semi)&n;&t; *&t;or writing a 1 to the bit (SMC, UMC, WinBond), others ???&n;&t; *&t;This bit is always high in non EPP modes.&n;&t; */
id|parport_pc_write_control
c_func
(paren
id|pb
comma
id|parport_pc_read_control
c_func
(paren
id|pb
)paren
op_or
l_int|0x20
)paren
suffix:semicolon
id|parport_pc_write_control
c_func
(paren
id|pb
comma
id|parport_pc_read_control
c_func
(paren
id|pb
)paren
op_or
l_int|0x10
)paren
suffix:semicolon
id|parport_pc_epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
id|parport_pc_read_epp
c_func
(paren
id|pb
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|30
)paren
suffix:semicolon
multiline_comment|/* Wait for possible EPP timeout */
r_if
c_cond
(paren
id|parport_pc_read_status
c_func
(paren
id|pb
)paren
op_amp
l_int|0x01
)paren
(brace
id|parport_pc_epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
id|PARPORT_MODE_PCEPP
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Theory:&n;&t; *     Write two values to the EPP address register and&n;&t; *     read them back. When the transfer times out, the state of&n;&t; *     the EPP register is undefined in some cases (EPP 1.9?) but&n;&t; *     in others (EPP 1.7, ECPEPP?) it is possible to read back&n;&t; *     its value.&n;&t; */
id|parport_pc_epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|30
)paren
suffix:semicolon
multiline_comment|/* Wait for possible EPP timeout */
multiline_comment|/* Previous test left outputs disabled. */
id|outb
(paren
l_int|0x55
comma
id|EPPADDR
(paren
id|pb
)paren
)paren
suffix:semicolon
id|parport_pc_epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|30
)paren
suffix:semicolon
multiline_comment|/* Wait for possible EPP timeout */
multiline_comment|/* We must enable the outputs to be able to read the address&n;           register. */
id|parport_pc_frob_control
(paren
id|pb
comma
l_int|0x20
comma
l_int|0x00
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
(paren
id|EPPADDR
(paren
id|pb
)paren
)paren
op_eq
l_int|0x55
)paren
(brace
multiline_comment|/* wash ... */
id|parport_pc_frob_control
(paren
id|pb
comma
l_int|0x20
comma
l_int|0x20
)paren
suffix:semicolon
id|outb
(paren
l_int|0xaa
comma
id|EPPADDR
(paren
id|pb
)paren
)paren
suffix:semicolon
id|parport_pc_epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|30
)paren
suffix:semicolon
multiline_comment|/* Wait for possible EPP timeout */
multiline_comment|/* ... and repeat */
id|parport_pc_frob_control
(paren
id|pb
comma
l_int|0x20
comma
l_int|0x00
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
(paren
id|EPPADDR
(paren
id|pb
)paren
)paren
op_eq
l_int|0xaa
)paren
(brace
id|parport_pc_epp_clear_timeout
(paren
id|pb
)paren
suffix:semicolon
r_return
id|PARPORT_MODE_PCEPP
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parport_ECPEPP_supported
r_static
r_int
id|__init
id|parport_ECPEPP_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|mode
suffix:semicolon
r_int
r_char
id|oecr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|oecr
op_assign
id|parport_pc_read_econtrol
c_func
(paren
id|pb
)paren
suffix:semicolon
multiline_comment|/* Search for SMC style EPP+ECP mode */
id|parport_pc_write_econtrol
c_func
(paren
id|pb
comma
l_int|0x80
)paren
suffix:semicolon
id|mode
op_assign
id|parport_EPP_supported
c_func
(paren
id|pb
)paren
suffix:semicolon
id|parport_pc_write_econtrol
c_func
(paren
id|pb
comma
id|oecr
)paren
suffix:semicolon
r_return
id|mode
ques
c_cond
id|PARPORT_MODE_PCECPEPP
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Detect PS/2 support.&n; *&n; * Bit 5 (0x20) sets the PS/2 data direction; setting this high&n; * allows us to read data from the data lines.  In theory we would get back&n; * 0xff but any peripheral attached to the port may drag some or all of the&n; * lines down to zero.  So if we get back anything that isn&squot;t the contents&n; * of the data register we deem PS/2 support to be present. &n; *&n; * Some SPP ports have &quot;half PS/2&quot; ability - you can&squot;t turn off the line&n; * drivers, but an external peripheral with sufficiently beefy drivers of&n; * its own can overpower them and assert its own levels onto the bus, from&n; * where they can then be read back as normal.  Ports with this property&n; * and the right type of device attached are likely to fail the SPP test,&n; * (as they will appear to have stuck bits) and so the fact that they might&n; * be misdetected here is rather academic. &n; */
DECL|function|parport_PS2_supported
r_static
r_int
id|__init
id|parport_PS2_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|ok
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|octr
op_assign
id|parport_pc_read_control
c_func
(paren
id|pb
)paren
suffix:semicolon
id|parport_pc_epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
id|parport_pc_write_control
c_func
(paren
id|pb
comma
id|octr
op_or
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/* try to tri-state the buffer */
id|parport_pc_write_data
c_func
(paren
id|pb
comma
l_int|0x55
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_pc_read_data
c_func
(paren
id|pb
)paren
op_ne
l_int|0x55
)paren
id|ok
op_increment
suffix:semicolon
id|parport_pc_write_data
c_func
(paren
id|pb
comma
l_int|0xaa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_pc_read_data
c_func
(paren
id|pb
)paren
op_ne
l_int|0xaa
)paren
id|ok
op_increment
suffix:semicolon
id|parport_pc_write_control
c_func
(paren
id|pb
comma
id|octr
)paren
suffix:semicolon
multiline_comment|/* cancel input mode */
r_return
id|ok
ques
c_cond
id|PARPORT_MODE_PCPS2
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|parport_ECPPS2_supported
r_static
r_int
id|__init
id|parport_ECPPS2_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|mode
suffix:semicolon
r_int
r_char
id|oecr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|oecr
op_assign
id|parport_pc_read_econtrol
c_func
(paren
id|pb
)paren
suffix:semicolon
id|parport_pc_write_econtrol
c_func
(paren
id|pb
comma
l_int|0x20
)paren
suffix:semicolon
id|mode
op_assign
id|parport_PS2_supported
c_func
(paren
id|pb
)paren
suffix:semicolon
id|parport_pc_write_econtrol
c_func
(paren
id|pb
comma
id|oecr
)paren
suffix:semicolon
r_return
id|mode
ques
c_cond
id|PARPORT_MODE_PCECPPS2
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --- IRQ detection -------------------------------------- */
multiline_comment|/* Only if supports ECP mode */
DECL|function|programmable_irq_support
r_static
r_int
id|__init
id|programmable_irq_support
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|irq
comma
id|intrLine
suffix:semicolon
r_int
r_char
id|oecr
op_assign
id|parport_pc_read_econtrol
c_func
(paren
id|pb
)paren
suffix:semicolon
r_static
r_const
r_int
id|lookup
(braket
l_int|8
)braket
op_assign
(brace
id|PARPORT_IRQ_NONE
comma
l_int|7
comma
l_int|9
comma
l_int|10
comma
l_int|11
comma
l_int|14
comma
l_int|15
comma
l_int|5
)brace
suffix:semicolon
id|parport_pc_write_econtrol
c_func
(paren
id|pb
comma
l_int|0xE0
)paren
suffix:semicolon
multiline_comment|/* Configuration MODE */
id|intrLine
op_assign
(paren
id|parport_pc_read_configb
c_func
(paren
id|pb
)paren
op_rshift
l_int|3
)paren
op_amp
l_int|0x07
suffix:semicolon
id|irq
op_assign
id|lookup
(braket
id|intrLine
)braket
suffix:semicolon
id|parport_pc_write_econtrol
c_func
(paren
id|pb
comma
id|oecr
)paren
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
DECL|function|irq_probe_ECP
r_static
r_int
id|__init
id|irq_probe_ECP
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|irqs
comma
id|i
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|irqs
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
id|parport_pc_write_econtrol
c_func
(paren
id|pb
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* Reset FIFO */
id|parport_pc_write_econtrol
c_func
(paren
id|pb
comma
l_int|0xd0
)paren
suffix:semicolon
multiline_comment|/* TEST FIFO + nErrIntrEn */
multiline_comment|/* If Full FIFO sure that WriteIntrThresold is generated */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1024
op_logical_and
op_logical_neg
(paren
id|parport_pc_read_econtrol
c_func
(paren
id|pb
)paren
op_amp
l_int|0x02
)paren
suffix:semicolon
id|i
op_increment
)paren
id|parport_pc_write_fifo
c_func
(paren
id|pb
comma
l_int|0xaa
)paren
suffix:semicolon
id|pb-&gt;irq
op_assign
id|probe_irq_off
c_func
(paren
id|irqs
)paren
suffix:semicolon
id|parport_pc_write_econtrol
c_func
(paren
id|pb
comma
l_int|0x00
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_le
l_int|0
)paren
id|pb-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
r_return
id|pb-&gt;irq
suffix:semicolon
)brace
multiline_comment|/*&n; * This detection seems that only works in National Semiconductors&n; * This doesn&squot;t work in SMC, LGS, and Winbond &n; */
DECL|function|irq_probe_EPP
r_static
r_int
id|__init
id|irq_probe_EPP
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
macro_line|#ifndef ADVANCED_DETECT
r_return
id|PARPORT_IRQ_NONE
suffix:semicolon
macro_line|#else
r_int
id|irqs
suffix:semicolon
r_int
r_char
id|octr
op_assign
id|parport_pc_read_control
c_func
(paren
id|pb
)paren
suffix:semicolon
r_int
r_char
id|oecr
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
id|oecr
op_assign
id|parport_pc_read_econtrol
c_func
(paren
id|pb
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|irqs
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
id|parport_pc_frob_econtrol
(paren
id|pb
comma
l_int|0x10
comma
l_int|0x10
)paren
suffix:semicolon
id|parport_pc_epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
id|parport_pc_frob_control
(paren
id|pb
comma
l_int|0x20
comma
l_int|0x20
)paren
suffix:semicolon
id|parport_pc_frob_control
(paren
id|pb
comma
l_int|0x10
comma
l_int|0x10
)paren
suffix:semicolon
id|parport_pc_epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
multiline_comment|/* Device isn&squot;t expecting an EPP read&n;&t; * and generates an IRQ.&n;&t; */
id|parport_pc_read_epp
c_func
(paren
id|pb
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|pb-&gt;irq
op_assign
id|probe_irq_off
(paren
id|irqs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
id|parport_pc_write_econtrol
c_func
(paren
id|pb
comma
id|oecr
)paren
suffix:semicolon
id|parport_pc_write_control
c_func
(paren
id|pb
comma
id|octr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_le
l_int|0
)paren
id|pb-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
r_return
id|pb-&gt;irq
suffix:semicolon
macro_line|#endif /* Advanced detection. */
)brace
DECL|function|irq_probe_SPP
r_static
r_int
id|__init
id|irq_probe_SPP
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
macro_line|#ifndef ADVANCED_DETECT
multiline_comment|/* Don&squot;t even try to do this. */
r_return
id|PARPORT_IRQ_NONE
suffix:semicolon
macro_line|#else
r_int
id|irqs
suffix:semicolon
r_int
r_char
id|octr
op_assign
id|parport_pc_read_control
c_func
(paren
id|pb
)paren
suffix:semicolon
r_int
r_char
id|oecr
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
id|oecr
op_assign
id|parport_pc_read_econtrol
c_func
(paren
id|pb
)paren
suffix:semicolon
id|probe_irq_off
c_func
(paren
id|probe_irq_on
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear any interrupts */
id|irqs
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
id|parport_pc_write_econtrol
c_func
(paren
id|pb
comma
l_int|0x10
)paren
suffix:semicolon
id|parport_pc_write_data
c_func
(paren
id|pb
comma
l_int|0x00
)paren
suffix:semicolon
id|parport_pc_write_control
c_func
(paren
id|pb
comma
l_int|0x00
)paren
suffix:semicolon
id|parport_pc_write_control
c_func
(paren
id|pb
comma
l_int|0x0c
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|parport_pc_write_control
c_func
(paren
id|pb
comma
l_int|0x0d
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|parport_pc_write_control
c_func
(paren
id|pb
comma
l_int|0x0c
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|parport_pc_write_control
c_func
(paren
id|pb
comma
l_int|0x08
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|parport_pc_write_control
c_func
(paren
id|pb
comma
l_int|0x0c
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|pb-&gt;irq
op_assign
id|probe_irq_off
c_func
(paren
id|irqs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_le
l_int|0
)paren
id|pb-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
multiline_comment|/* No interrupt detected */
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
id|parport_pc_write_econtrol
c_func
(paren
id|pb
comma
id|oecr
)paren
suffix:semicolon
id|parport_pc_write_control
c_func
(paren
id|pb
comma
id|octr
)paren
suffix:semicolon
r_return
id|pb-&gt;irq
suffix:semicolon
macro_line|#endif /* Advanced detection. */
)brace
multiline_comment|/* We will attempt to share interrupt requests since other devices&n; * such as sound cards and network cards seem to like using the&n; * printer IRQs.&n; *&n; * When ECP is available we can autoprobe for IRQs.&n; * NOTE: If we can autoprobe it, we can register the IRQ.&n; */
DECL|function|parport_irq_probe
r_static
r_int
id|__init
id|parport_irq_probe
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
(brace
id|pb-&gt;irq
op_assign
id|programmable_irq_support
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
)paren
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCECP
)paren
id|pb-&gt;irq
op_assign
id|irq_probe_ECP
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
op_logical_and
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCECPEPP
)paren
)paren
id|pb-&gt;irq
op_assign
id|irq_probe_EPP
c_func
(paren
id|pb
)paren
suffix:semicolon
id|parport_pc_epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
op_logical_and
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCEPP
)paren
)paren
id|pb-&gt;irq
op_assign
id|irq_probe_EPP
c_func
(paren
id|pb
)paren
suffix:semicolon
id|parport_pc_epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
)paren
id|pb-&gt;irq
op_assign
id|irq_probe_SPP
c_func
(paren
id|pb
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|pb-&gt;irq
suffix:semicolon
)brace
multiline_comment|/* --- Initialisation code -------------------------------- */
DECL|function|probe_one_port
r_static
r_int
id|__init
id|probe_one_port
c_func
(paren
r_int
r_int
r_int
id|base
comma
r_int
r_int
r_int
id|base_hi
comma
r_int
id|irq
comma
r_int
id|dma
)paren
(brace
r_struct
id|parport_pc_private
op_star
id|priv
suffix:semicolon
r_struct
id|parport
id|tmp
suffix:semicolon
r_struct
id|parport
op_star
id|p
op_assign
op_amp
id|tmp
suffix:semicolon
r_int
id|probedirq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|base
comma
l_int|3
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|priv
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|parport_pc_private
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;parport (0x%lx): no memory!&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|priv-&gt;ctr
op_assign
l_int|0xc
suffix:semicolon
id|p-&gt;base
op_assign
id|base
suffix:semicolon
id|p-&gt;base_hi
op_assign
id|base_hi
suffix:semicolon
id|p-&gt;irq
op_assign
id|irq
suffix:semicolon
id|p-&gt;dma
op_assign
id|dma
suffix:semicolon
id|p-&gt;modes
op_assign
id|PARPORT_MODE_PCSPP
suffix:semicolon
id|p-&gt;ops
op_assign
op_amp
id|parport_pc_ops
suffix:semicolon
id|p-&gt;private_data
op_assign
id|priv
suffix:semicolon
r_if
c_cond
(paren
id|base_hi
op_logical_and
op_logical_neg
id|check_region
(paren
id|base_hi
comma
l_int|3
)paren
)paren
(brace
id|p-&gt;modes
op_or_assign
id|parport_ECR_present
(paren
id|p
)paren
suffix:semicolon
id|p-&gt;modes
op_or_assign
id|parport_ECP_supported
(paren
id|p
)paren
suffix:semicolon
id|p-&gt;modes
op_or_assign
id|parport_ECPPS2_supported
(paren
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;base
op_ne
l_int|0x3bc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|check_region
c_func
(paren
id|base
op_plus
l_int|0x3
comma
l_int|5
)paren
)paren
(brace
id|p-&gt;modes
op_or_assign
id|parport_EPP_supported
(paren
id|p
)paren
suffix:semicolon
id|p-&gt;modes
op_or_assign
id|parport_ECPEPP_supported
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|parport_SPP_supported
c_func
(paren
id|p
)paren
)paren
(brace
multiline_comment|/* No port. */
id|kfree
(paren
id|priv
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|p-&gt;modes
op_or_assign
id|parport_PS2_supported
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_assign
id|parport_register_port
(paren
id|base
comma
id|PARPORT_IRQ_NONE
comma
id|PARPORT_DMA_NONE
comma
op_amp
id|parport_pc_ops
)paren
)paren
)paren
(brace
id|kfree
(paren
id|priv
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|p-&gt;base_hi
op_assign
id|base_hi
suffix:semicolon
id|p-&gt;modes
op_assign
id|tmp.modes
suffix:semicolon
id|p-&gt;size
op_assign
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_PCEPP
)paren
ques
c_cond
l_int|8
suffix:colon
l_int|3
suffix:semicolon
id|p-&gt;private_data
op_assign
id|priv
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: PC-style at 0x%lx&quot;
comma
id|p-&gt;name
comma
id|p-&gt;base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;base_hi
op_logical_and
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
)paren
id|printk
(paren
l_string|&quot; (0x%lx)&quot;
comma
id|p-&gt;base_hi
)paren
suffix:semicolon
id|p-&gt;irq
op_assign
id|irq
suffix:semicolon
id|p-&gt;dma
op_assign
id|dma
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;irq
op_eq
id|PARPORT_IRQ_AUTO
)paren
(brace
id|p-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
id|parport_irq_probe
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;irq
op_eq
id|PARPORT_IRQ_PROBEONLY
)paren
(brace
id|p-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
id|parport_irq_probe
c_func
(paren
id|p
)paren
suffix:semicolon
id|probedirq
op_assign
id|p-&gt;irq
suffix:semicolon
id|p-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
)paren
id|printk
c_func
(paren
l_string|&quot;, irq %d&quot;
comma
id|p-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;dma
op_eq
id|PARPORT_DMA_AUTO
)paren
id|p-&gt;dma
op_assign
id|PARPORT_DMA_NONE
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;dma
op_ne
id|PARPORT_DMA_NONE
)paren
id|printk
c_func
(paren
l_string|&quot;, dma %d&quot;
comma
id|p-&gt;dma
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; [&quot;
)paren
suffix:semicolon
DECL|macro|printmode
mdefine_line|#define printmode(x) {if(p-&gt;modes&amp;PARPORT_MODE_PC##x){printk(&quot;%s%s&quot;,f?&quot;,&quot;:&quot;&quot;,#x);f++;}}
(brace
r_int
id|f
op_assign
l_int|0
suffix:semicolon
id|printmode
c_func
(paren
id|SPP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|PS2
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|EPP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|ECP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|ECPEPP
)paren
suffix:semicolon
id|printmode
c_func
(paren
id|ECPPS2
)paren
suffix:semicolon
)brace
DECL|macro|printmode
macro_line|#undef printmode
id|printk
c_func
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef&t;CONFIG_PROC_FS
r_if
c_cond
(paren
id|probedirq
op_ne
id|PARPORT_IRQ_NONE
)paren
id|printk
c_func
(paren
l_string|&quot;%s: detected irq %d; use procfs to enable interrupt-driven operation.&bslash;n&quot;
comma
id|p-&gt;name
comma
id|probedirq
)paren
suffix:semicolon
macro_line|#endif
id|parport_proc_register
c_func
(paren
id|p
)paren
suffix:semicolon
id|request_region
(paren
id|p-&gt;base
comma
id|p-&gt;size
comma
id|p-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
id|request_region
(paren
id|p-&gt;base_hi
comma
l_int|3
comma
id|p-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
)paren
(brace
r_if
c_cond
(paren
id|request_irq
(paren
id|p-&gt;irq
comma
id|parport_pc_interrupt
comma
l_int|0
comma
id|p-&gt;name
comma
id|p
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s: irq %d in use, &quot;
l_string|&quot;resorting to polled operation&bslash;n&quot;
comma
id|p-&gt;name
comma
id|p-&gt;irq
)paren
suffix:semicolon
id|p-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
id|p-&gt;dma
op_assign
id|PARPORT_DMA_NONE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;dma
op_ne
id|PARPORT_DMA_NONE
)paren
(brace
r_if
c_cond
(paren
id|request_dma
(paren
id|p-&gt;dma
comma
id|p-&gt;name
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s: dma %d in use, &quot;
l_string|&quot;resorting to PIO operation&bslash;n&quot;
comma
id|p-&gt;name
comma
id|p-&gt;dma
)paren
suffix:semicolon
id|p-&gt;dma
op_assign
id|PARPORT_DMA_NONE
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Done probing.  Now put the port into a sensible start-up state. */
r_if
c_cond
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_PCECR
)paren
multiline_comment|/*&n;&t;&t; * Put the ECP detected port in PS2 mode.&n;&t;&t; */
id|parport_pc_write_econtrol
c_func
(paren
id|p
comma
l_int|0x24
)paren
suffix:semicolon
id|parport_pc_write_data
c_func
(paren
id|p
comma
l_int|0
)paren
suffix:semicolon
id|parport_pc_write_control
c_func
(paren
id|p
comma
l_int|0x8
)paren
suffix:semicolon
id|udelay
(paren
l_int|50
)paren
suffix:semicolon
id|parport_pc_write_control
c_func
(paren
id|p
comma
l_int|0xc
)paren
suffix:semicolon
id|udelay
(paren
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_probe_hook
)paren
(paren
op_star
id|parport_probe_hook
)paren
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* Now that we&squot;ve told the sharing engine about the port, and&n;&t;   found out its characteristics, let the high-level drivers&n;&t;   know about it. */
id|parport_announce_port
(paren
id|p
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Look for PCI parallel port cards. */
DECL|function|parport_pc_init_pci
r_static
r_int
id|__init
id|parport_pc_init_pci
(paren
r_int
id|irq
comma
r_int
id|dma
)paren
(brace
multiline_comment|/* These need to go in pci.h: */
macro_line|#ifndef PCI_VENDOR_ID_SIIG
DECL|macro|PCI_VENDOR_ID_SIIG
mdefine_line|#define PCI_VENDOR_ID_SIIG              0x131f
DECL|macro|PCI_DEVICE_ID_SIIG_1S1P_10x_550
mdefine_line|#define PCI_DEVICE_ID_SIIG_1S1P_10x_550 0x1010
DECL|macro|PCI_DEVICE_ID_SIIG_1S1P_10x_650
mdefine_line|#define PCI_DEVICE_ID_SIIG_1S1P_10x_650 0x1011
DECL|macro|PCI_DEVICE_ID_SIIG_1S1P_10x_850
mdefine_line|#define PCI_DEVICE_ID_SIIG_1S1P_10x_850 0x1012
DECL|macro|PCI_DEVICE_ID_SIIG_1P_10x
mdefine_line|#define PCI_DEVICE_ID_SIIG_1P_10x       0x1020
DECL|macro|PCI_DEVICE_ID_SIIG_2P_10x
mdefine_line|#define PCI_DEVICE_ID_SIIG_2P_10x       0x1021
DECL|macro|PCI_DEVICE_ID_SIIG_2S1P_10x_550
mdefine_line|#define PCI_DEVICE_ID_SIIG_2S1P_10x_550 0x1034
DECL|macro|PCI_DEVICE_ID_SIIG_2S1P_10x_650
mdefine_line|#define PCI_DEVICE_ID_SIIG_2S1P_10x_650 0x1035
DECL|macro|PCI_DEVICE_ID_SIIG_2S1P_10x_850
mdefine_line|#define PCI_DEVICE_ID_SIIG_2S1P_10x_850 0x1036
DECL|macro|PCI_DEVICE_ID_SIIG_1P_20x
mdefine_line|#define PCI_DEVICE_ID_SIIG_1P_20x       0x2020
DECL|macro|PCI_DEVICE_ID_SIIG_2P_20x
mdefine_line|#define PCI_DEVICE_ID_SIIG_2P_20x       0x2021
DECL|macro|PCI_DEVICE_ID_SIIG_2P1S_20x_550
mdefine_line|#define PCI_DEVICE_ID_SIIG_2P1S_20x_550 0x2040
DECL|macro|PCI_DEVICE_ID_SIIG_2P1S_20x_650
mdefine_line|#define PCI_DEVICE_ID_SIIG_2P1S_20x_650 0x2041
DECL|macro|PCI_DEVICE_ID_SIIG_2P1S_20x_850
mdefine_line|#define PCI_DEVICE_ID_SIIG_2P1S_20x_850 0x2042
DECL|macro|PCI_DEVICE_ID_SIIG_1S1P_20x_550
mdefine_line|#define PCI_DEVICE_ID_SIIG_1S1P_20x_550 0x2010
DECL|macro|PCI_DEVICE_ID_SIIG_1S1P_20x_650
mdefine_line|#define PCI_DEVICE_ID_SIIG_1S1P_20x_650 0x2011
DECL|macro|PCI_DEVICE_ID_SIIG_1S1P_20x_850
mdefine_line|#define PCI_DEVICE_ID_SIIG_1S1P_20x_850 0x2012
DECL|macro|PCI_DEVICE_ID_SIIG_2S1P_20x_550
mdefine_line|#define PCI_DEVICE_ID_SIIG_2S1P_20x_550 0x2060
DECL|macro|PCI_DEVICE_ID_SIIG_2S1P_20x_650
mdefine_line|#define PCI_DEVICE_ID_SIIG_2S1P_20x_650 0x2061
DECL|macro|PCI_DEVICE_ID_SIIG_2S1P_20x_850
mdefine_line|#define PCI_DEVICE_ID_SIIG_2S1P_20x_850 0x2062
DECL|macro|PCI_VENDOR_ID_LAVA
mdefine_line|#define PCI_VENDOR_ID_LAVA              0x1407
DECL|macro|PCI_DEVICE_ID_LAVA_PARALLEL
mdefine_line|#define PCI_DEVICE_ID_LAVA_PARALLEL     0x8000
DECL|macro|PCI_DEVICE_ID_LAVA_DUAL_PAR_A
mdefine_line|#define PCI_DEVICE_ID_LAVA_DUAL_PAR_A   0x8001 /* The Lava Dual Parallel is */
DECL|macro|PCI_DEVICE_ID_LAVA_DUAL_PAR_B
mdefine_line|#define PCI_DEVICE_ID_LAVA_DUAL_PAR_B   0x8002 /* two PCI devices on a card */
macro_line|#endif /* IDs not defined */
r_int
id|count
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
r_int
id|i
suffix:semicolon
r_struct
(brace
r_int
r_int
id|vendor
suffix:semicolon
r_int
r_int
id|device
suffix:semicolon
r_int
r_int
id|numports
suffix:semicolon
r_struct
(brace
r_int
r_int
id|lo
suffix:semicolon
r_int
r_int
id|hi
suffix:semicolon
multiline_comment|/* -ve if not there */
)brace
id|addr
(braket
l_int|4
)braket
suffix:semicolon
)brace
id|cards
(braket
)braket
op_assign
(brace
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_1S1P_10x_550
comma
l_int|1
comma
(brace
(brace
l_int|3
comma
l_int|4
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_1S1P_10x_650
comma
l_int|1
comma
(brace
(brace
l_int|3
comma
l_int|4
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_1S1P_10x_850
comma
l_int|1
comma
(brace
(brace
l_int|3
comma
l_int|4
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_1P_10x
comma
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2P_10x
comma
l_int|2
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
(brace
l_int|4
comma
l_int|5
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2S1P_10x_550
comma
l_int|1
comma
(brace
(brace
l_int|4
comma
l_int|5
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2S1P_10x_650
comma
l_int|1
comma
(brace
(brace
l_int|4
comma
l_int|5
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2S1P_10x_850
comma
l_int|1
comma
(brace
(brace
l_int|4
comma
l_int|5
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_1P_20x
comma
l_int|1
comma
(brace
(brace
l_int|0
comma
l_int|1
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2P_20x
comma
l_int|2
comma
(brace
(brace
l_int|0
comma
l_int|1
)brace
comma
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2P1S_20x_550
comma
l_int|2
comma
(brace
(brace
l_int|1
comma
l_int|2
)brace
comma
(brace
l_int|3
comma
l_int|4
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2P1S_20x_650
comma
l_int|2
comma
(brace
(brace
l_int|1
comma
l_int|2
)brace
comma
(brace
l_int|3
comma
l_int|4
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2P1S_20x_850
comma
l_int|2
comma
(brace
(brace
l_int|1
comma
l_int|2
)brace
comma
(brace
l_int|3
comma
l_int|4
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_1S1P_20x_550
comma
l_int|1
comma
(brace
(brace
l_int|1
comma
l_int|2
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_1S1P_20x_650
comma
l_int|1
comma
(brace
(brace
l_int|1
comma
l_int|2
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_1S1P_20x_850
comma
l_int|1
comma
(brace
(brace
l_int|1
comma
l_int|2
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2S1P_20x_550
comma
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2S1P_20x_650
comma
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_SIIG
comma
id|PCI_DEVICE_ID_SIIG_2S1P_20x_850
comma
l_int|1
comma
(brace
(brace
l_int|2
comma
l_int|3
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_LAVA
comma
id|PCI_DEVICE_ID_LAVA_PARALLEL
comma
l_int|1
comma
(brace
(brace
l_int|0
comma
op_minus
l_int|1
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_LAVA
comma
id|PCI_DEVICE_ID_LAVA_DUAL_PAR_A
comma
l_int|1
comma
(brace
(brace
l_int|0
comma
op_minus
l_int|1
)brace
comma
)brace
)brace
comma
(brace
id|PCI_VENDOR_ID_LAVA
comma
id|PCI_DEVICE_ID_LAVA_DUAL_PAR_B
comma
l_int|1
comma
(brace
(brace
l_int|0
comma
op_minus
l_int|1
)brace
comma
)brace
)brace
comma
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_present
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|cards
(braket
id|i
)braket
dot
id|vendor
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|pci_dev
op_star
id|pcidev
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|pcidev
op_assign
id|pci_find_device
(paren
id|cards
(braket
id|i
)braket
dot
id|vendor
comma
id|cards
(braket
id|i
)braket
dot
id|device
comma
id|pcidev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|n
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|cards
(braket
id|i
)braket
dot
id|numports
suffix:semicolon
id|n
op_increment
)paren
(brace
r_int
id|lo
op_assign
id|cards
(braket
id|i
)braket
dot
id|addr
(braket
id|n
)braket
dot
id|lo
suffix:semicolon
r_int
id|hi
op_assign
id|cards
(braket
id|i
)braket
dot
id|addr
(braket
id|n
)braket
dot
id|hi
suffix:semicolon
r_int
id|io_lo
op_assign
id|pcidev-&gt;base_address
(braket
id|lo
)braket
suffix:semicolon
r_int
id|io_hi
op_assign
(paren
(paren
id|hi
OL
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
id|pcidev-&gt;base_address
(braket
id|hi
)braket
)paren
suffix:semicolon
id|io_lo
op_and_assign
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
id|io_hi
op_and_assign
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
id|count
op_add_assign
id|probe_one_port
(paren
id|io_lo
comma
id|io_hi
comma
id|irq
comma
id|dma
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* CONFIG_PCI */
r_return
id|count
suffix:semicolon
)brace
DECL|function|parport_pc_init
r_int
id|__init
id|parport_pc_init
c_func
(paren
r_int
op_star
id|io
comma
r_int
op_star
id|io_hi
comma
r_int
op_star
id|irq
comma
r_int
op_star
id|dma
)paren
(brace
r_int
id|count
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|io
op_logical_and
op_star
id|io
)paren
(brace
multiline_comment|/* Only probe the ports we were given. */
id|user_specified
op_assign
l_int|1
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|io_hi
)paren
op_star
id|io_hi
op_assign
l_int|0x400
op_plus
op_star
id|io
suffix:semicolon
id|count
op_add_assign
id|probe_one_port
c_func
(paren
op_star
(paren
id|io
op_increment
)paren
comma
op_star
(paren
id|io_hi
op_increment
)paren
comma
op_star
(paren
id|irq
op_increment
)paren
comma
op_star
(paren
id|dma
op_increment
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|io
op_logical_and
(paren
op_increment
id|i
OL
id|PARPORT_PC_MAX_PORTS
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Probe all the likely ports. */
id|count
op_add_assign
id|probe_one_port
c_func
(paren
l_int|0x3bc
comma
l_int|0x7bc
comma
id|irq
(braket
l_int|0
)braket
comma
id|dma
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|count
op_add_assign
id|probe_one_port
c_func
(paren
l_int|0x378
comma
l_int|0x778
comma
id|irq
(braket
l_int|0
)braket
comma
id|dma
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|count
op_add_assign
id|probe_one_port
c_func
(paren
l_int|0x278
comma
l_int|0x678
comma
id|irq
(braket
l_int|0
)braket
comma
id|dma
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|count
op_add_assign
id|parport_pc_init_pci
(paren
id|irq
(braket
l_int|0
)braket
comma
id|dma
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|io
r_static
r_int
id|io
(braket
id|PARPORT_PC_MAX_PORTS
op_plus
l_int|1
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|PARPORT_PC_MAX_PORTS
)braket
op_assign
l_int|0
)brace
suffix:semicolon
DECL|variable|io_hi
r_static
r_int
id|io_hi
(braket
id|PARPORT_PC_MAX_PORTS
op_plus
l_int|1
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|PARPORT_PC_MAX_PORTS
)braket
op_assign
l_int|0
)brace
suffix:semicolon
DECL|variable|dmaval
r_static
r_int
id|dmaval
(braket
id|PARPORT_PC_MAX_PORTS
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|PARPORT_PC_MAX_PORTS
op_minus
l_int|1
)braket
op_assign
id|PARPORT_DMA_AUTO
)brace
suffix:semicolon
DECL|variable|irqval
r_static
r_int
id|irqval
(braket
id|PARPORT_PC_MAX_PORTS
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|PARPORT_PC_MAX_PORTS
op_minus
l_int|1
)braket
op_assign
id|PARPORT_IRQ_PROBEONLY
)brace
suffix:semicolon
DECL|variable|irq
r_static
r_const
r_char
op_star
id|irq
(braket
id|PARPORT_PC_MAX_PORTS
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|dma
r_static
r_const
r_char
op_star
id|dma
(braket
id|PARPORT_PC_MAX_PORTS
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|io
comma
l_string|&quot;base address&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|PARPORT_PC_MAX_PORTS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|io_hi
comma
l_string|&quot;base address for ECR&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io_hi
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|PARPORT_PC_MAX_PORTS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|irq
comma
l_string|&quot;irq line to use (or &squot;auto&squot; or &squot;none&squot;)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|PARPORT_PC_MAX_PORTS
)paren
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|dma
comma
l_string|&quot;dma channel to use (or &squot;auto&squot; or &squot;none&squot;)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dma
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|PARPORT_PC_MAX_PORTS
)paren
l_string|&quot;s&quot;
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Work out how many ports we have, then get parport_share to parse&n;&t;   the irq values. */
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PARPORT_PC_MAX_PORTS
op_logical_and
id|io
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
r_if
c_cond
(paren
id|parport_parse_irqs
c_func
(paren
id|i
comma
id|irq
comma
id|irqval
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|parport_parse_dmas
c_func
(paren
id|i
comma
id|dma
comma
id|dmaval
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The user can make us use any IRQs or DMAs we find. */
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|irq
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|parport_parse_irqs
(paren
l_int|1
comma
id|irq
comma
op_amp
id|val
)paren
)paren
r_switch
c_cond
(paren
id|val
)paren
(brace
r_case
id|PARPORT_IRQ_NONE
suffix:colon
r_case
id|PARPORT_IRQ_AUTO
suffix:colon
id|irqval
(braket
l_int|0
)braket
op_assign
id|val
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dma
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|parport_parse_dmas
(paren
l_int|1
comma
id|dma
comma
op_amp
id|val
)paren
)paren
r_switch
c_cond
(paren
id|val
)paren
(brace
r_case
id|PARPORT_DMA_NONE
suffix:colon
r_case
id|PARPORT_DMA_AUTO
suffix:colon
id|dmaval
(braket
l_int|0
)braket
op_assign
id|val
suffix:semicolon
)brace
)brace
r_return
(paren
id|parport_pc_init
c_func
(paren
id|io
comma
id|io_hi
comma
id|irqval
comma
id|dmaval
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|parport
op_star
id|p
op_assign
id|parport_enumerate
c_func
(paren
)paren
comma
op_star
id|tmp
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
id|tmp
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_PCSPP
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;dma
op_ne
id|PARPORT_DMA_NONE
)paren
id|free_dma
(paren
id|p-&gt;dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
)paren
id|free_irq
(paren
id|p-&gt;irq
comma
id|p
)paren
suffix:semicolon
id|release_region
(paren
id|p-&gt;base
comma
id|p-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;modes
op_amp
id|PARPORT_MODE_PCECP
)paren
id|release_region
(paren
id|p-&gt;base_hi
comma
l_int|3
)paren
suffix:semicolon
id|parport_proc_unregister
c_func
(paren
id|p
)paren
suffix:semicolon
id|kfree
(paren
id|p-&gt;private_data
)paren
suffix:semicolon
id|parport_unregister_port
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|p
op_assign
id|tmp
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
