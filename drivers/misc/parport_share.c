multiline_comment|/* $Id: parport_share.c,v 1.8 1997/11/08 18:55:29 philip Exp $&n; * Parallel-port resource manager code.&n; * &n; * Authors: David Campbell &lt;campbell@tirian.che.curtin.edu.au&gt;&n; *          Tim Waugh &lt;tim@cyberelk.demon.co.uk&gt;&n; *&t;    Jose Renau &lt;renau@acm.org&gt;&n; *&n; * based on work by Grant Guenther &lt;grant@torque.net&gt;&n; *              and Philip Blundell &lt;Philip.Blundell@pobox.com&gt;&n; */
macro_line|#include &lt;linux/tasks.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef CONFIG_KERNELD
macro_line|#include &lt;linux/kerneld.h&gt;
macro_line|#endif
DECL|macro|PARPORT_PARANOID
macro_line|#undef PARPORT_PARANOID
DECL|variable|portlist
DECL|variable|portlist_tail
r_static
r_struct
id|parport
op_star
id|portlist
op_assign
l_int|NULL
comma
op_star
id|portlist_tail
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|portcount
r_static
r_int
id|portcount
op_assign
l_int|0
suffix:semicolon
DECL|variable|parport_probe_hook
r_void
(paren
op_star
id|parport_probe_hook
)paren
(paren
r_struct
id|parport
op_star
id|port
)paren
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Return a list of all the ports we know about. */
DECL|function|parport_enumerate
r_struct
id|parport
op_star
id|parport_enumerate
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_KERNELD
r_if
c_cond
(paren
id|portlist
op_eq
l_int|NULL
)paren
(brace
id|request_module
c_func
(paren
l_string|&quot;parport_lowlevel&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PNP_PARPORT_MODULE
id|request_module
c_func
(paren
l_string|&quot;parport_probe&quot;
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PNP_PARPORT_MODULE */
)brace
macro_line|#endif /* CONFIG_KERNELD */
r_return
id|portlist
suffix:semicolon
)brace
DECL|function|parport_null_intr_func
r_void
id|parport_null_intr_func
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* NULL function - Does nothing */
r_return
suffix:semicolon
)brace
DECL|function|parport_register_port
r_struct
id|parport
op_star
id|parport_register_port
c_func
(paren
r_int
r_int
id|base
comma
r_int
id|irq
comma
r_int
id|dma
comma
r_struct
id|parport_operations
op_star
id|ops
)paren
(brace
r_struct
id|parport
op_star
id|tmp
suffix:semicolon
multiline_comment|/* Check for a previously registered port.&n;&t; * NOTE: we will ignore irq and dma if we find a previously&n;&t; * registered device.&n;&t; */
r_for
c_loop
(paren
id|tmp
op_assign
id|portlist
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;base
op_eq
id|base
)paren
r_return
id|tmp
suffix:semicolon
)brace
id|tmp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|parport
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;parport: memory squeeze&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Init our structure */
id|memset
c_func
(paren
id|tmp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|parport
)paren
)paren
suffix:semicolon
id|tmp-&gt;base
op_assign
id|base
suffix:semicolon
id|tmp-&gt;irq
op_assign
id|irq
suffix:semicolon
id|tmp-&gt;dma
op_assign
id|dma
suffix:semicolon
id|tmp-&gt;modes
op_assign
l_int|0
suffix:semicolon
id|tmp-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;devices
op_assign
id|tmp-&gt;cad
op_assign
id|tmp-&gt;lurker
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|tmp-&gt;ops
op_assign
id|ops
suffix:semicolon
id|tmp-&gt;name
op_assign
id|kmalloc
c_func
(paren
l_int|15
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp-&gt;name
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;parport: memory squeeze&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|tmp-&gt;name
comma
l_string|&quot;parport%d&quot;
comma
id|portcount
)paren
suffix:semicolon
multiline_comment|/* Here we chain the entry to our list. */
r_if
c_cond
(paren
id|portlist_tail
)paren
id|portlist_tail-&gt;next
op_assign
id|tmp
suffix:semicolon
id|portlist_tail
op_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|portlist
)paren
id|portlist
op_assign
id|tmp
suffix:semicolon
id|portcount
op_increment
suffix:semicolon
id|tmp-&gt;probe_info
dot
r_class
op_assign
id|PARPORT_CLASS_LEGACY
suffix:semicolon
multiline_comment|/* assume the worst */
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|parport_unregister_port
r_void
id|parport_unregister_port
c_func
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
r_struct
id|parport
op_star
id|p
suffix:semicolon
id|kfree
c_func
(paren
id|port-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|portlist
op_eq
id|port
)paren
(brace
r_if
c_cond
(paren
(paren
id|portlist
op_assign
id|port-&gt;next
)paren
op_eq
l_int|NULL
)paren
id|portlist_tail
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|p
op_assign
id|portlist
suffix:semicolon
(paren
id|p
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|p-&gt;next
op_ne
id|port
)paren
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;next
op_assign
id|port-&gt;next
)paren
op_eq
l_int|NULL
)paren
id|portlist_tail
op_assign
id|p
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|port
)paren
suffix:semicolon
)brace
DECL|function|parport_quiesce
r_void
id|parport_quiesce
c_func
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;devices
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: attempt to quiesce active port.&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;flags
op_amp
id|PARPORT_FLAG_COMA
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: attempt to quiesce comatose port.&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|port-&gt;ops
op_member_access_from_pointer
id|release_resources
c_func
(paren
id|port
)paren
suffix:semicolon
id|port-&gt;flags
op_or_assign
id|PARPORT_FLAG_COMA
suffix:semicolon
)brace
DECL|function|parport_register_device
r_struct
id|pardevice
op_star
id|parport_register_device
c_func
(paren
r_struct
id|parport
op_star
id|port
comma
r_const
r_char
op_star
id|name
comma
r_int
(paren
op_star
id|pf
)paren
(paren
r_void
op_star
)paren
comma
r_void
(paren
op_star
id|kf
)paren
(paren
r_void
op_star
)paren
comma
r_void
(paren
op_star
id|irq_func
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
id|flags
comma
r_void
op_star
id|handle
)paren
(brace
r_struct
id|pardevice
op_star
id|tmp
suffix:semicolon
multiline_comment|/* We only allow one lurking device. */
r_if
c_cond
(paren
id|flags
op_amp
id|PARPORT_DEV_LURK
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;lurker
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: refused to register second lurker (%s)&bslash;n&quot;
comma
id|port-&gt;name
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pf
op_logical_or
op_logical_neg
id|kf
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: refused to register lurking device (%s) without callbacks&bslash;n&quot;
comma
id|port-&gt;name
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* We may need to claw back the port hardware. */
r_if
c_cond
(paren
id|port-&gt;flags
op_amp
id|PARPORT_FLAG_COMA
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;ops
op_member_access_from_pointer
id|claim_resources
c_func
(paren
id|port
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: unable to get hardware to register %s.&bslash;n&quot;
comma
id|port-&gt;name
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|port-&gt;flags
op_and_assign
op_complement
id|PARPORT_FLAG_COMA
suffix:semicolon
)brace
id|tmp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pardevice
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: memory squeeze, couldn&squot;t register %s.&bslash;n&quot;
comma
id|port-&gt;name
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|tmp-&gt;state
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|parport_state
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;state
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: memory squeeze, couldn&squot;t register %s.&bslash;n&quot;
comma
id|port-&gt;name
comma
id|name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|tmp-&gt;name
op_assign
(paren
r_char
op_star
)paren
id|name
suffix:semicolon
id|tmp-&gt;port
op_assign
id|port
suffix:semicolon
id|tmp-&gt;preempt
op_assign
id|pf
suffix:semicolon
id|tmp-&gt;wakeup
op_assign
id|kf
suffix:semicolon
id|tmp
op_member_access_from_pointer
r_private
op_assign
id|handle
suffix:semicolon
id|tmp-&gt;flags
op_assign
id|flags
suffix:semicolon
id|tmp-&gt;irq_func
op_assign
id|irq_func
suffix:semicolon
id|port-&gt;ops
op_member_access_from_pointer
id|save_state
c_func
(paren
id|port
comma
id|tmp-&gt;state
)paren
suffix:semicolon
multiline_comment|/* Chain this onto the list */
id|tmp-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;next
op_assign
id|port-&gt;devices
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;devices
)paren
id|port-&gt;devices-&gt;prev
op_assign
id|tmp
suffix:semicolon
id|port-&gt;devices
op_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PARPORT_DEV_LURK
)paren
id|port-&gt;lurker
op_assign
id|tmp
suffix:semicolon
id|inc_parport_count
c_func
(paren
)paren
suffix:semicolon
id|port-&gt;ops
op_member_access_from_pointer
id|inc_use_count
c_func
(paren
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|parport_unregister_device
r_void
id|parport_unregister_device
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
)paren
(brace
r_struct
id|parport
op_star
id|port
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;parport_unregister_device: passed NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|port
op_assign
id|dev-&gt;port
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;cad
op_eq
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: refused to unregister currently active device %s.&bslash;n&quot;
comma
id|port-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;lurker
op_eq
id|dev
)paren
id|port-&gt;lurker
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;next
)paren
id|dev-&gt;next-&gt;prev
op_assign
id|dev-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;prev
)paren
id|dev-&gt;prev-&gt;next
op_assign
id|dev-&gt;next
suffix:semicolon
r_else
id|port-&gt;devices
op_assign
id|dev-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|dev-&gt;state
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dec_parport_count
c_func
(paren
)paren
suffix:semicolon
id|port-&gt;ops
op_member_access_from_pointer
id|dec_use_count
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If there are no more devices, put the port to sleep. */
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;devices
)paren
id|parport_quiesce
c_func
(paren
id|port
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|parport_claim
r_int
id|parport_claim
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
)paren
(brace
r_struct
id|pardevice
op_star
id|pd1
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;port-&gt;cad
op_eq
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s already owner&bslash;n&quot;
comma
id|dev-&gt;port-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Preempt any current device */
id|pd1
op_assign
id|dev-&gt;port-&gt;cad
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;port-&gt;cad
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;port-&gt;cad-&gt;preempt
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;port-&gt;cad
op_member_access_from_pointer
id|preempt
c_func
(paren
id|dev-&gt;port-&gt;cad
op_member_access_from_pointer
r_private
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|dev-&gt;port-&gt;ops
op_member_access_from_pointer
id|save_state
c_func
(paren
id|dev-&gt;port
comma
id|dev-&gt;state
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* Watch out for bad things */
r_if
c_cond
(paren
id|dev-&gt;port-&gt;cad
op_ne
id|pd1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: death while preempting %s&bslash;n&quot;
comma
id|dev-&gt;port-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;port-&gt;cad
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* Now we do the change of devices */
id|dev-&gt;port-&gt;cad
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Swap the IRQ handlers. */
r_if
c_cond
(paren
id|dev-&gt;port-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
)paren
(brace
id|free_irq
c_func
(paren
id|dev-&gt;port-&gt;irq
comma
id|dev-&gt;port
)paren
suffix:semicolon
id|request_irq
c_func
(paren
id|dev-&gt;port-&gt;irq
comma
id|dev-&gt;irq_func
ques
c_cond
id|dev-&gt;irq_func
suffix:colon
id|parport_null_intr_func
comma
id|SA_INTERRUPT
comma
id|dev-&gt;name
comma
id|dev
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
)brace
multiline_comment|/* Restore control registers */
id|dev-&gt;port-&gt;ops
op_member_access_from_pointer
id|restore_state
c_func
(paren
id|dev-&gt;port
comma
id|dev-&gt;state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parport_release
r_void
id|parport_release
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
)paren
(brace
r_struct
id|pardevice
op_star
id|pd1
suffix:semicolon
multiline_comment|/* Make sure that dev is the current device */
r_if
c_cond
(paren
id|dev-&gt;port-&gt;cad
op_ne
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: %s tried to release parport when not owner&bslash;n&quot;
comma
id|dev-&gt;port-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev-&gt;port-&gt;cad
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Save control registers */
id|dev-&gt;port-&gt;ops
op_member_access_from_pointer
id|save_state
c_func
(paren
id|dev-&gt;port
comma
id|dev-&gt;state
)paren
suffix:semicolon
multiline_comment|/* Point IRQs somewhere harmless. */
r_if
c_cond
(paren
id|dev-&gt;port-&gt;irq
op_ne
id|PARPORT_IRQ_NONE
)paren
(brace
id|free_irq
c_func
(paren
id|dev-&gt;port-&gt;irq
comma
id|dev-&gt;port
)paren
suffix:semicolon
id|request_irq
c_func
(paren
id|dev-&gt;port-&gt;irq
comma
id|parport_null_intr_func
comma
id|SA_INTERRUPT
comma
id|dev-&gt;port-&gt;name
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Walk the list, offering a wakeup callback to everybody other&n;&t; * than the lurker and the device that called us.&n;&t; */
r_for
c_loop
(paren
id|pd1
op_assign
id|dev-&gt;next
suffix:semicolon
id|pd1
suffix:semicolon
id|pd1
op_assign
id|pd1-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pd1-&gt;flags
op_amp
id|PARPORT_DEV_LURK
)paren
)paren
(brace
r_if
c_cond
(paren
id|pd1-&gt;wakeup
)paren
(brace
id|pd1
op_member_access_from_pointer
id|wakeup
c_func
(paren
id|pd1
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;port-&gt;cad
)paren
r_return
suffix:semicolon
)brace
)brace
)brace
r_for
c_loop
(paren
id|pd1
op_assign
id|dev-&gt;port-&gt;devices
suffix:semicolon
id|pd1
op_logical_and
id|pd1
op_ne
id|dev
suffix:semicolon
id|pd1
op_assign
id|pd1-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pd1-&gt;flags
op_amp
id|PARPORT_DEV_LURK
)paren
)paren
(brace
r_if
c_cond
(paren
id|pd1-&gt;wakeup
)paren
(brace
id|pd1
op_member_access_from_pointer
id|wakeup
c_func
(paren
id|pd1
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;port-&gt;cad
)paren
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Now give the lurker a chance.&n;&t; * There must be a wakeup callback because we checked for it&n;&t; * at registration.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;port-&gt;lurker
op_logical_and
(paren
id|dev-&gt;port-&gt;lurker
op_ne
id|dev
)paren
)paren
(brace
id|dev-&gt;port-&gt;lurker
op_member_access_from_pointer
id|wakeup
c_func
(paren
id|dev-&gt;port-&gt;lurker
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
)brace
)brace
eof
