multiline_comment|/*&n;  Madge Ambassador ATM Adapter driver.&n;  Copyright (C) 1995-1999  Madge Networks Ltd.&n;&n;  This program is free software; you can redistribute it and/or modify&n;  it under the terms of the GNU General Public License as published by&n;  the Free Software Foundation; either version 2 of the License, or&n;  (at your option) any later version.&n;&n;  This program is distributed in the hope that it will be useful,&n;  but WITHOUT ANY WARRANTY; without even the implied warranty of&n;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;  GNU General Public License for more details.&n;&n;  You should have received a copy of the GNU General Public License&n;  along with this program; if not, write to the Free Software&n;  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n;&n;  The GNU GPL is contained in /usr/doc/copyright/GPL on a Debian&n;  system and in the file COPYING in the Linux kernel source.&n;*/
multiline_comment|/* * dedicated to the memory of Graham Gordon 1971-1998 * */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/atmdev.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &quot;ambassador.h&quot;
DECL|macro|maintainer_string
mdefine_line|#define maintainer_string &quot;Giuliano Procida at Madge Networks &lt;gprocida@madge.com&gt;&quot;
DECL|macro|description_string
mdefine_line|#define description_string &quot;Madge ATM Ambassador driver&quot;
DECL|macro|version_string
mdefine_line|#define version_string &quot;1.2.4&quot;
DECL|function|show_version
r_static
r_inline
r_void
id|__init
id|show_version
(paren
r_void
)paren
(brace
id|printk
(paren
l_string|&quot;%s version %s&bslash;n&quot;
comma
id|description_string
comma
id|version_string
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  &n;  Theory of Operation&n;  &n;  I Hardware, detection, initialisation and shutdown.&n;  &n;  1. Supported Hardware&n;  &n;  This driver is for the PCI ATMizer-based Ambassador card (except&n;  very early versions). It is not suitable for the similar EISA &quot;TR7&quot;&n;  card. Commercially, both cards are known as Collage Server ATM&n;  adapters.&n;  &n;  The loader supports image transfer to the card, image start and few&n;  other miscellaneous commands.&n;  &n;  Only AAL5 is supported with vpi = 0 and vci in the range 0 to 1023.&n;  &n;  The cards are big-endian.&n;  &n;  2. Detection&n;  &n;  Standard PCI stuff, the early cards are detected and rejected.&n;  &n;  3. Initialisation&n;  &n;  The cards are reset and the self-test results are checked. The&n;  microcode image is then transferred and started. This waits for a&n;  pointer to a descriptor containing details of the host-based queues&n;  and buffers and various parameters etc. Once they are processed&n;  normal operations may begin. The BIA is read using a microcode&n;  command.&n;  &n;  4. Shutdown&n;  &n;  This may be accomplished either by a card reset or via the microcode&n;  shutdown command. Further investigation required.&n;  &n;  5. Persistent state&n;  &n;  The card reset does not affect PCI configuration (good) or the&n;  contents of several other &quot;shared run-time registers&quot; (bad) which&n;  include doorbell and interrupt control as well as EEPROM and PCI&n;  control. The driver must be careful when modifying these registers&n;  not to touch bits it does not use and to undo any changes at exit.&n;  &n;  II Driver software&n;  &n;  0. Generalities&n;  &n;  The adapter is quite intelligent (fast) and has a simple interface&n;  (few features). VPI is always zero, 1024 VCIs are supported. There&n;  is limited cell rate support. UBR channels can be capped and ABR&n;  (explicit rate, but not EFCI) is supported. There is no CBR or VBR&n;  support.&n;  &n;  1. Driver &lt;-&gt; Adapter Communication&n;  &n;  Apart from the basic loader commands, the driver communicates&n;  through three entities: the command queue (CQ), the transmit queue&n;  pair (TXQ) and the receive queue pairs (RXQ). These three entities&n;  are set up by the host and passed to the microcode just after it has&n;  been started.&n;  &n;  All queues are host-based circular queues. They are contiguous and&n;  (due to hardware limitations) have some restrictions as to their&n;  locations in (bus) memory. They are of the &quot;full means the same as&n;  empty so don&squot;t do that&quot; variety since the adapter uses pointers&n;  internally.&n;  &n;  The queue pairs work as follows: one queue is for supply to the&n;  adapter, items in it are pending and are owned by the adapter; the&n;  other is the queue for return from the adapter, items in it have&n;  been dealt with by the adapter. The host adds items to the supply&n;  (TX descriptors and free RX buffer descriptors) and removes items&n;  from the return (TX and RX completions). The adapter deals with out&n;  of order completions.&n;  &n;  Interrupts (card to host) and the doorbell (host to card) are used&n;  for signalling.&n;  &n;  1. CQ&n;  &n;  This is to communicate &quot;open VC&quot;, &quot;close VC&quot;, &quot;get stats&quot; etc. to&n;  the adapter. At most one command is retired every millisecond by the&n;  card. There is no out of order completion or notification. The&n;  driver needs to check the return code of the command, waiting as&n;  appropriate.&n;  &n;  2. TXQ&n;  &n;  TX supply items are of variable length (scatter gather support) and&n;  so the queue items are (more or less) pointers to the real thing.&n;  Each TX supply item contains a unique, host-supplied handle (the skb&n;  bus address seems most sensible as this works for Alphas as well,&n;  there is no need to do any endian conversions on the handles).&n;  &n;  TX return items consist of just the handles above.&n;  &n;  3. RXQ (up to 4 of these with different lengths and buffer sizes)&n;  &n;  RX supply items consist of a unique, host-supplied handle (the skb&n;  bus address again) and a pointer to the buffer data area.&n;  &n;  RX return items consist of the handle above, the VC, length and a&n;  status word. This just screams &quot;oh so easy&quot; doesn&squot;t it?&n;&n;  Note on RX pool sizes:&n;   &n;  Each pool should have enough buffers to handle a back-to-back stream&n;  of minimum sized frames on a single VC. For example:&n;  &n;    frame spacing = 3us (about right)&n;    &n;    delay = IRQ lat + RX handling + RX buffer replenish = 20 (us)  (a guess)&n;    &n;    min number of buffers for one VC = 1 + delay/spacing (buffers)&n;&n;    delay/spacing = latency = (20+2)/3 = 7 (buffers)  (rounding up)&n;    &n;  The 20us delay assumes that there is no need to sleep; if we need to&n;  sleep to get buffers we are going to drop frames anyway.&n;  &n;  In fact, each pool should have enough buffers to support the&n;  simultaneous reassembly of a separate frame on each VC and cope with&n;  the case in which frames complete in round robin cell fashion on&n;  each VC.&n;  &n;  Only one frame can complete at each cell arrival, so if &quot;n&quot; VCs are&n;  open, the worst case is to have them all complete frames together&n;  followed by all starting new frames together.&n;  &n;    desired number of buffers = n + delay/spacing&n;    &n;  These are the extreme requirements, however, they are &quot;n+k&quot; for some&n;  &quot;k&quot; so we have only the constant to choose. This is the argument&n;  rx_lats which current defaults to 7.&n;  &n;  Actually, &quot;n ? n+k : 0&quot; is better and this is what is implemented,&n;  subject to the limit given by the pool size.&n;  &n;  4. Driver locking&n;  &n;  Simple spinlocks are used around the TX and RX queue mechanisms.&n;  Anyone with a faster, working method is welcome to implement it.&n;  &n;  The adapter command queue is protected with a spinlock. We always&n;  wait for commands to complete.&n;  &n;  A more complex form of locking is used around parts of the VC open&n;  and close functions. There are three reasons for a lock: 1. we need&n;  to do atomic rate reservation and release (not used yet), 2. Opening&n;  sometimes involves two adapter commands which must not be separated&n;  by another command on the same VC, 3. the changes to RX pool size&n;  must be atomic. The lock needs to work over context switches, so we&n;  use a semaphore.&n;  &n;  III Hardware Features and Microcode Bugs&n;  &n;  1. Byte Ordering&n;  &n;  *%^&quot;$&amp;%^$*&amp;^&quot;$(%^$#&amp;^%$(&amp;#%$*(&amp;^#%!&quot;!&quot;!*!&n;  &n;  2. Memory access&n;  &n;  All structures that are not accessed using DMA must be 4-byte&n;  aligned (not a problem) and must not cross 4MB boundaries.&n;  &n;  There is a DMA memory hole at E0000000-E00000FF (groan).&n;  &n;  TX fragments (DMA read) must not cross 4MB boundaries (would be 16MB&n;  but for a hardware bug).&n;  &n;  RX buffers (DMA write) must not cross 16MB boundaries and must&n;  include spare trailing bytes up to the next 4-byte boundary; they&n;  will be written with rubbish.&n;  &n;  The PLX likes to prefetch; if reading up to 4 u32 past the end of&n;  each TX fragment is not a problem, then TX can be made to go a&n;  little faster by passing a flag at init that disables a prefetch&n;  workaround. We do not pass this flag. (new microcode only)&n;  &n;  Now we:&n;  . Note that alloc_skb rounds up size to a 16byte boundary.  &n;  . Ensure all areas do not traverse 4MB boundaries.&n;  . Ensure all areas do not start at a E00000xx bus address.&n;  (I cannot be certain, but this may always hold with Linux)&n;  . Make all failures cause a loud message.&n;  . Discard non-conforming SKBs (causes TX failure or RX fill delay).&n;  . Discard non-conforming TX fragment descriptors (the TX fails).&n;  In the future we could:&n;  . Allow RX areas that traverse 4MB (but not 16MB) boundaries.&n;  . Segment TX areas into some/more fragments, when necessary.&n;  . Relax checks for non-DMA items (ignore hole).&n;  . Give scatter-gather (iovec) requirements using ???. (?)&n;  &n;  3. VC close is broken (only for new microcode)&n;  &n;  The VC close adapter microcode command fails to do anything if any&n;  frames have been received on the VC but none have been transmitted.&n;  Frames continue to be reassembled and passed (with IRQ) to the&n;  driver.&n;  &n;  IV To Do List&n;  &n;  . Fix bugs!&n;  &n;  . Timer code may be broken.&n;  &n;  . Deal with buggy VC close (somehow) in microcode 12.&n;  &n;  . Handle interrupted and/or non-blocking writes - is this a job for&n;    the protocol layer?&n;  &n;  . Add code to break up TX fragments when they span 4MB boundaries.&n;  &n;  . Add SUNI phy layer (need to know where SUNI lives on card).&n;  &n;  . Implement a tx_alloc fn to (a) satisfy TX alignment etc. and (b)&n;    leave extra headroom space for Ambassador TX descriptors.&n;  &n;  . Understand these elements of struct atm_vcc: recvq (proto?),&n;    sleep, callback, listenq, backlog_quota, reply and user_back.&n;  &n;  . Adjust TX/RX skb allocation to favour IP with LANE/CLIP (configurable).&n;  &n;  . Impose a TX-pending limit (2?) on each VC, help avoid TX q overflow.&n;  &n;  . Decide whether RX buffer recycling is or can be made completely safe;&n;    turn it back on. It looks like Werner is going to axe this.&n;  &n;  . Implement QoS changes on open VCs (involves extracting parts of VC open&n;    and close into separate functions and using them to make changes).&n;  &n;  . Hack on command queue so that someone can issue multiple commands and wait&n;    on the last one (OR only &quot;no-op&quot; or &quot;wait&quot; commands are waited for).&n;  &n;  . Eliminate need for while-schedule around do_command.&n;  &n;*/
multiline_comment|/********** microcode **********/
macro_line|#ifdef AMB_NEW_MICROCODE
DECL|macro|UCODE
mdefine_line|#define UCODE(x) UCODE1(atmsar12.,x)
macro_line|#else
DECL|macro|UCODE
mdefine_line|#define UCODE(x) UCODE1(atmsar11.,x)
macro_line|#endif
DECL|macro|UCODE2
mdefine_line|#define UCODE2(x) #x
DECL|macro|UCODE1
mdefine_line|#define UCODE1(x,y) UCODE2(x ## y)
DECL|variable|ucode_start
r_static
r_const
id|u32
id|__initdata
id|ucode_start
op_assign
macro_line|#include UCODE(start)
suffix:semicolon
DECL|variable|ucode_regions
r_static
r_const
id|region
id|__initdata
id|ucode_regions
(braket
)braket
op_assign
(brace
macro_line|#include UCODE(regions)
(brace
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|ucode_data
r_static
r_const
id|u32
id|__initdata
id|ucode_data
(braket
)braket
op_assign
(brace
macro_line|#include UCODE(data)
l_int|0xdeadbeef
)brace
suffix:semicolon
multiline_comment|/********** globals **********/
DECL|variable|amb_devs
r_static
id|amb_dev
op_star
id|amb_devs
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|housekeeping
r_static
r_struct
id|timer_list
id|housekeeping
suffix:semicolon
DECL|variable|debug
r_static
r_int
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
DECL|variable|cmds
r_static
r_int
r_int
id|cmds
op_assign
l_int|8
suffix:semicolon
DECL|variable|txs
r_static
r_int
r_int
id|txs
op_assign
l_int|32
suffix:semicolon
DECL|variable|rxs
r_static
r_int
r_int
id|rxs
(braket
id|NUM_RX_POOLS
)braket
op_assign
(brace
l_int|64
comma
l_int|64
comma
l_int|64
comma
l_int|64
)brace
suffix:semicolon
DECL|variable|rxs_bs
r_static
r_int
r_int
id|rxs_bs
(braket
id|NUM_RX_POOLS
)braket
op_assign
(brace
l_int|4080
comma
l_int|12240
comma
l_int|36720
comma
l_int|65535
)brace
suffix:semicolon
DECL|variable|rx_lats
r_static
r_int
r_int
id|rx_lats
op_assign
l_int|7
suffix:semicolon
DECL|variable|pci_lat
r_static
r_int
r_char
id|pci_lat
op_assign
l_int|0
suffix:semicolon
DECL|variable|onegigmask
r_static
r_const
r_int
r_int
id|onegigmask
op_assign
op_minus
l_int|1
op_lshift
l_int|30
suffix:semicolon
multiline_comment|/********** access to adapter **********/
DECL|function|wr_plain
r_static
r_inline
r_void
id|wr_plain
(paren
r_const
id|amb_dev
op_star
id|dev
comma
r_int
id|addr
comma
id|u32
id|data
)paren
(brace
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_REGS
comma
l_string|&quot;wr: %08x &lt;- %08x&quot;
comma
id|addr
comma
id|data
)paren
suffix:semicolon
macro_line|#ifdef AMB_MMIO
id|dev-&gt;membase
(braket
id|addr
op_div
r_sizeof
(paren
id|u32
)paren
)braket
op_assign
id|data
suffix:semicolon
macro_line|#else
id|outl
(paren
id|data
comma
id|dev-&gt;iobase
op_plus
id|addr
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|rd_plain
r_static
r_inline
id|u32
id|rd_plain
(paren
r_const
id|amb_dev
op_star
id|dev
comma
r_int
id|addr
)paren
(brace
macro_line|#ifdef AMB_MMIO
id|u32
id|data
op_assign
id|dev-&gt;membase
(braket
id|addr
op_div
r_sizeof
(paren
id|u32
)paren
)braket
suffix:semicolon
macro_line|#else
id|u32
id|data
op_assign
id|inl
(paren
id|dev-&gt;iobase
op_plus
id|addr
)paren
suffix:semicolon
macro_line|#endif
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_REGS
comma
l_string|&quot;rd: %08x -&gt; %08x&quot;
comma
id|addr
comma
id|data
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
DECL|function|wr_mem
r_static
r_inline
r_void
id|wr_mem
(paren
r_const
id|amb_dev
op_star
id|dev
comma
r_int
id|addr
comma
id|u32
id|data
)paren
(brace
id|u32
id|be
op_assign
id|cpu_to_be32
(paren
id|data
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_REGS
comma
l_string|&quot;wr: %08x &lt;- %08x b[%08x]&quot;
comma
id|addr
comma
id|data
comma
id|be
)paren
suffix:semicolon
macro_line|#ifdef AMB_MMIO
id|dev-&gt;membase
(braket
id|addr
op_div
r_sizeof
(paren
id|u32
)paren
)braket
op_assign
id|be
suffix:semicolon
macro_line|#else
id|outl
(paren
id|be
comma
id|dev-&gt;iobase
op_plus
id|addr
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|rd_mem
r_static
r_inline
id|u32
id|rd_mem
(paren
r_const
id|amb_dev
op_star
id|dev
comma
r_int
id|addr
)paren
(brace
macro_line|#ifdef AMB_MMIO
id|u32
id|be
op_assign
id|dev-&gt;membase
(braket
id|addr
op_div
r_sizeof
(paren
id|u32
)paren
)braket
suffix:semicolon
macro_line|#else
id|u32
id|be
op_assign
id|inl
(paren
id|dev-&gt;iobase
op_plus
id|addr
)paren
suffix:semicolon
macro_line|#endif
id|u32
id|data
op_assign
id|be32_to_cpu
(paren
id|be
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_REGS
comma
l_string|&quot;rd: %08x -&gt; %08x b[%08x]&quot;
comma
id|addr
comma
id|data
comma
id|be
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
multiline_comment|/********** dump routines **********/
DECL|function|dump_registers
r_static
r_inline
r_void
id|dump_registers
(paren
r_const
id|amb_dev
op_star
id|dev
)paren
(brace
macro_line|#ifdef DEBUG_AMBASSADOR
r_if
c_cond
(paren
id|debug
op_amp
id|DBG_REGS
)paren
(brace
r_int
id|i
suffix:semicolon
id|PRINTD
(paren
id|DBG_REGS
comma
l_string|&quot;reading PLX control: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x00
suffix:semicolon
id|i
OL
l_int|0x30
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|u32
)paren
)paren
id|rd_mem
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_REGS
comma
l_string|&quot;reading mailboxes: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x40
suffix:semicolon
id|i
OL
l_int|0x60
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|u32
)paren
)paren
id|rd_mem
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_REGS
comma
l_string|&quot;reading doorb irqev irqen reset:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x60
suffix:semicolon
id|i
OL
l_int|0x70
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|u32
)paren
)paren
id|rd_mem
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
)brace
macro_line|#else
(paren
r_void
)paren
id|dev
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|function|dump_loader_block
r_static
r_inline
r_void
id|dump_loader_block
(paren
r_volatile
id|loader_block
op_star
id|lb
)paren
(brace
macro_line|#ifdef DEBUG_AMBASSADOR
r_int
r_int
id|i
suffix:semicolon
id|PRINTDB
(paren
id|DBG_LOAD
comma
l_string|&quot;lb @ %p; res: %d, cmd: %d, pay:&quot;
comma
id|lb
comma
id|be32_to_cpu
(paren
id|lb-&gt;result
)paren
comma
id|be32_to_cpu
(paren
id|lb-&gt;command
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_COMMAND_DATA
suffix:semicolon
op_increment
id|i
)paren
id|PRINTDM
(paren
id|DBG_LOAD
comma
l_string|&quot; %08x&quot;
comma
id|be32_to_cpu
(paren
id|lb-&gt;payload.data
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|PRINTDE
(paren
id|DBG_LOAD
comma
l_string|&quot;, vld: %08x&quot;
comma
id|be32_to_cpu
(paren
id|lb-&gt;valid
)paren
)paren
suffix:semicolon
macro_line|#else
(paren
r_void
)paren
id|lb
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|function|dump_command
r_static
r_inline
r_void
id|dump_command
(paren
id|command
op_star
id|cmd
)paren
(brace
macro_line|#ifdef DEBUG_AMBASSADOR
r_int
r_int
id|i
suffix:semicolon
id|PRINTDB
(paren
id|DBG_CMD
comma
l_string|&quot;cmd @ %p, req: %08x, pars:&quot;
comma
id|cmd
comma
multiline_comment|/*be32_to_cpu*/
(paren
id|cmd-&gt;request
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
op_increment
id|i
)paren
id|PRINTDM
(paren
id|DBG_CMD
comma
l_string|&quot; %08x&quot;
comma
multiline_comment|/*be32_to_cpu*/
(paren
id|cmd-&gt;args.par
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|PRINTDE
(paren
id|DBG_CMD
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
macro_line|#else
(paren
r_void
)paren
id|cmd
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|function|dump_skb
r_static
r_inline
r_void
id|dump_skb
(paren
r_char
op_star
id|prefix
comma
r_int
r_int
id|vc
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
macro_line|#ifdef DEBUG_AMBASSADOR
r_int
r_int
id|i
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|skb-&gt;data
suffix:semicolon
id|PRINTDB
(paren
id|DBG_DATA
comma
l_string|&quot;%s(%u) &quot;
comma
id|prefix
comma
id|vc
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb-&gt;len
op_logical_and
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
id|PRINTDM
(paren
id|DBG_DATA
comma
l_string|&quot;%02x &quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
id|PRINTDE
(paren
id|DBG_DATA
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
macro_line|#else
(paren
r_void
)paren
id|prefix
suffix:semicolon
(paren
r_void
)paren
id|vc
suffix:semicolon
(paren
r_void
)paren
id|skb
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/********** check memory areas for use by Ambassador **********/
multiline_comment|/* see limitations under Hardware Features */
DECL|function|check_area
r_static
r_inline
r_int
id|check_area
(paren
r_void
op_star
id|start
comma
r_int
id|length
)paren
(brace
singleline_comment|// assumes length &gt; 0
r_const
id|u32
id|fourmegmask
op_assign
op_minus
l_int|1
op_lshift
l_int|22
suffix:semicolon
r_const
id|u32
id|twofivesixmask
op_assign
op_minus
l_int|1
op_lshift
l_int|8
suffix:semicolon
r_const
id|u32
id|starthole
op_assign
l_int|0xE0000000
suffix:semicolon
id|u32
id|startaddress
op_assign
id|virt_to_bus
(paren
id|start
)paren
suffix:semicolon
id|u32
id|lastaddress
op_assign
id|startaddress
op_plus
id|length
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|startaddress
op_xor
id|lastaddress
)paren
op_amp
id|fourmegmask
op_logical_or
(paren
id|startaddress
op_amp
id|twofivesixmask
)paren
op_eq
id|starthole
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;check_area failure: [%x,%x] - mail maintainer!&quot;
comma
id|startaddress
comma
id|lastaddress
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/********** free an skb (as per ATM device driver documentation) **********/
DECL|function|amb_kfree_skb
r_static
r_inline
r_void
id|amb_kfree_skb
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc-&gt;pop
)paren
(brace
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc-&gt;pop
(paren
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|dev_kfree_skb_any
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/********** TX completion **********/
DECL|function|tx_complete
r_static
r_inline
r_void
id|tx_complete
(paren
id|amb_dev
op_star
id|dev
comma
id|tx_out
op_star
id|tx
)paren
(brace
id|tx_simple
op_star
id|tx_descr
op_assign
id|bus_to_virt
(paren
id|tx-&gt;handle
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|tx_descr-&gt;skb
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_TX
comma
l_string|&quot;tx_complete %p %p&quot;
comma
id|dev
comma
id|tx
)paren
suffix:semicolon
singleline_comment|// VC layer stats
id|atomic_inc
c_func
(paren
op_amp
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc-&gt;stats-&gt;tx
)paren
suffix:semicolon
singleline_comment|// free the descriptor
id|kfree
(paren
id|tx_descr
)paren
suffix:semicolon
singleline_comment|// free the skb
id|amb_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
id|dev-&gt;stats.tx_ok
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/********** RX completion **********/
DECL|function|rx_complete
r_static
r_void
id|rx_complete
(paren
id|amb_dev
op_star
id|dev
comma
id|rx_out
op_star
id|rx
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|bus_to_virt
(paren
id|rx-&gt;handle
)paren
suffix:semicolon
id|u16
id|vc
op_assign
id|be16_to_cpu
(paren
id|rx-&gt;vc
)paren
suffix:semicolon
singleline_comment|// unused: u16 lec_id = be16_to_cpu (rx-&gt;lec_id);
id|u16
id|status
op_assign
id|be16_to_cpu
(paren
id|rx-&gt;status
)paren
suffix:semicolon
id|u16
id|rx_len
op_assign
id|be16_to_cpu
(paren
id|rx-&gt;length
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_RX
comma
l_string|&quot;rx_complete %p %p (len=%hu)&quot;
comma
id|dev
comma
id|rx
comma
id|rx_len
)paren
suffix:semicolon
singleline_comment|// XXX move this in and add to VC stats ???
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
r_struct
id|atm_vcc
op_star
id|atm_vcc
op_assign
id|dev-&gt;rxer
(braket
id|vc
)braket
suffix:semicolon
id|dev-&gt;stats.rx.ok
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|atm_vcc
)paren
(brace
r_if
c_cond
(paren
id|rx_len
op_le
id|atm_vcc-&gt;qos.rxtp.max_sdu
)paren
(brace
r_if
c_cond
(paren
id|atm_charge
(paren
id|atm_vcc
comma
id|skb-&gt;truesize
)paren
)paren
(brace
singleline_comment|// prepare socket buffer
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc
op_assign
id|atm_vcc
suffix:semicolon
id|skb_put
(paren
id|skb
comma
id|rx_len
)paren
suffix:semicolon
id|dump_skb
(paren
l_string|&quot;&lt;&lt;&lt;&quot;
comma
id|vc
comma
id|skb
)paren
suffix:semicolon
singleline_comment|// VC layer stats
id|atomic_inc
c_func
(paren
op_amp
id|atm_vcc-&gt;stats-&gt;rx
)paren
suffix:semicolon
id|skb-&gt;stamp
op_assign
id|xtime
suffix:semicolon
singleline_comment|// end of our responsability
id|atm_vcc-&gt;push
(paren
id|atm_vcc
comma
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// someone fix this (message), please!
id|PRINTD
(paren
id|DBG_INFO
op_or
id|DBG_RX
comma
l_string|&quot;dropped thanks to atm_charge (vc %hu, truesize %u)&quot;
comma
id|vc
comma
id|skb-&gt;truesize
)paren
suffix:semicolon
singleline_comment|// drop stats incremented in atm_charge
)brace
)brace
r_else
(brace
id|PRINTK
(paren
id|KERN_INFO
comma
l_string|&quot;dropped over-size frame&quot;
)paren
suffix:semicolon
singleline_comment|// should we count this?
id|atomic_inc
c_func
(paren
op_amp
id|atm_vcc-&gt;stats-&gt;rx_drop
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_WARN
op_or
id|DBG_RX
comma
l_string|&quot;got frame but RX closed for channel %hu&quot;
comma
id|vc
)paren
suffix:semicolon
singleline_comment|// this is an adapter bug, only in new version of microcode
)brace
)brace
r_else
(brace
id|dev-&gt;stats.rx.error
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|CRC_ERR
)paren
id|dev-&gt;stats.rx.badcrc
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|LEN_ERR
)paren
id|dev-&gt;stats.rx.toolong
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ABORT_ERR
)paren
id|dev-&gt;stats.rx.aborted
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UNUSED_ERR
)paren
id|dev-&gt;stats.rx.unused
op_increment
suffix:semicolon
)brace
id|dev_kfree_skb_any
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;  &n;  Note on queue handling.&n;  &n;  Here &quot;give&quot; and &quot;take&quot; refer to queue entries and a queue (pair)&n;  rather than frames to or from the host or adapter. Empty frame&n;  buffers are given to the RX queue pair and returned unused or&n;  containing RX frames. TX frames (well, pointers to TX fragment&n;  lists) are given to the TX queue pair, completions are returned.&n;  &n;*/
multiline_comment|/********** command queue **********/
singleline_comment|// I really don&squot;t like this, but it&squot;s the best I can do at the moment
singleline_comment|// also, the callers are responsible for byte order as the microcode
singleline_comment|// sometimes does 16-bit accesses (yuk yuk yuk)
DECL|function|command_do
r_static
r_int
id|command_do
(paren
id|amb_dev
op_star
id|dev
comma
id|command
op_star
id|cmd
)paren
(brace
id|amb_cq
op_star
id|cq
op_assign
op_amp
id|dev-&gt;cq
suffix:semicolon
r_volatile
id|amb_cq_ptrs
op_star
id|ptrs
op_assign
op_amp
id|cq-&gt;ptrs
suffix:semicolon
id|command
op_star
id|my_slot
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_CMD
comma
l_string|&quot;command_do %p&quot;
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
(paren
id|dead
comma
op_amp
id|dev-&gt;flags
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|spin_lock
(paren
op_amp
id|cq-&gt;lock
)paren
suffix:semicolon
singleline_comment|// if not full...
r_if
c_cond
(paren
id|cq-&gt;pending
OL
id|cq-&gt;maximum
)paren
(brace
singleline_comment|// remember my slot for later
id|my_slot
op_assign
id|ptrs-&gt;in
suffix:semicolon
id|PRINTD
(paren
id|DBG_CMD
comma
l_string|&quot;command in slot %p&quot;
comma
id|my_slot
)paren
suffix:semicolon
id|dump_command
(paren
id|cmd
)paren
suffix:semicolon
singleline_comment|// copy command in
op_star
id|ptrs-&gt;in
op_assign
op_star
id|cmd
suffix:semicolon
id|cq-&gt;pending
op_increment
suffix:semicolon
id|ptrs-&gt;in
op_assign
id|NEXTQ
(paren
id|ptrs-&gt;in
comma
id|ptrs-&gt;start
comma
id|ptrs-&gt;limit
)paren
suffix:semicolon
singleline_comment|// mail the command
id|wr_mem
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|mb.adapter.cmd_address
)paren
comma
id|virt_to_bus
(paren
id|ptrs-&gt;in
)paren
)paren
suffix:semicolon
singleline_comment|// prepare to wait for cq-&gt;pending milliseconds
singleline_comment|// effectively one centisecond on i386
id|timeout
op_assign
(paren
id|cq-&gt;pending
op_star
id|HZ
op_plus
l_int|999
)paren
op_div
l_int|1000
suffix:semicolon
r_if
c_cond
(paren
id|cq-&gt;pending
OG
id|cq-&gt;high
)paren
id|cq-&gt;high
op_assign
id|cq-&gt;pending
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|cq-&gt;lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|timeout
)paren
(brace
singleline_comment|// go to sleep
singleline_comment|// PRINTD (DBG_CMD, &quot;wait: sleeping %lu for command&quot;, timeout);
id|timeout
op_assign
id|schedule_timeout
(paren
id|timeout
)paren
suffix:semicolon
singleline_comment|// woken up by timeout or signal
)brace
singleline_comment|// wait for my slot to be reached (all waiters are here or above, until...)
r_while
c_loop
(paren
id|ptrs-&gt;out
op_ne
id|my_slot
)paren
(brace
id|PRINTD
(paren
id|DBG_CMD
comma
l_string|&quot;wait: command slot (now at %p)&quot;
comma
id|ptrs-&gt;out
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
singleline_comment|// wait on my slot (... one gets to its slot, and... )
r_while
c_loop
(paren
id|ptrs-&gt;out-&gt;request
op_ne
id|cpu_to_be32
(paren
id|SRB_COMPLETE
)paren
)paren
(brace
id|PRINTD
(paren
id|DBG_CMD
comma
l_string|&quot;wait: command slot completion&quot;
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|PRINTD
(paren
id|DBG_CMD
comma
l_string|&quot;command complete&quot;
)paren
suffix:semicolon
singleline_comment|// update queue (... moves the queue along to the next slot)
id|spin_lock
(paren
op_amp
id|cq-&gt;lock
)paren
suffix:semicolon
id|cq-&gt;pending
op_decrement
suffix:semicolon
singleline_comment|// copy command out
op_star
id|cmd
op_assign
op_star
id|ptrs-&gt;out
suffix:semicolon
id|ptrs-&gt;out
op_assign
id|NEXTQ
(paren
id|ptrs-&gt;out
comma
id|ptrs-&gt;start
comma
id|ptrs-&gt;limit
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|cq-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|cq-&gt;filled
op_increment
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|cq-&gt;lock
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
multiline_comment|/********** TX queue pair **********/
DECL|function|tx_give
r_static
r_inline
r_int
id|tx_give
(paren
id|amb_dev
op_star
id|dev
comma
id|tx_in
op_star
id|tx
)paren
(brace
id|amb_txq
op_star
id|txq
op_assign
op_amp
id|dev-&gt;txq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_TX
comma
l_string|&quot;tx_give %p&quot;
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
(paren
id|dead
comma
op_amp
id|dev-&gt;flags
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|txq-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|txq-&gt;pending
OL
id|txq-&gt;maximum
)paren
(brace
id|PRINTD
(paren
id|DBG_TX
comma
l_string|&quot;TX in slot %p&quot;
comma
id|txq-&gt;in.ptr
)paren
suffix:semicolon
op_star
id|txq-&gt;in.ptr
op_assign
op_star
id|tx
suffix:semicolon
id|txq-&gt;pending
op_increment
suffix:semicolon
id|txq-&gt;in.ptr
op_assign
id|NEXTQ
(paren
id|txq-&gt;in.ptr
comma
id|txq-&gt;in.start
comma
id|txq-&gt;in.limit
)paren
suffix:semicolon
singleline_comment|// hand over the TX and ring the bell
id|wr_mem
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|mb.adapter.tx_address
)paren
comma
id|virt_to_bus
(paren
id|txq-&gt;in.ptr
)paren
)paren
suffix:semicolon
id|wr_mem
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|doorbell
)paren
comma
id|TX_FRAME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|txq-&gt;pending
OG
id|txq-&gt;high
)paren
id|txq-&gt;high
op_assign
id|txq-&gt;pending
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|txq-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|txq-&gt;filled
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|txq-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
DECL|function|tx_take
r_static
r_inline
r_int
id|tx_take
(paren
id|amb_dev
op_star
id|dev
)paren
(brace
id|amb_txq
op_star
id|txq
op_assign
op_amp
id|dev-&gt;txq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_TX
comma
l_string|&quot;tx_take %p&quot;
comma
id|dev
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|txq-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|txq-&gt;pending
op_logical_and
id|txq-&gt;out.ptr-&gt;handle
)paren
(brace
singleline_comment|// deal with TX completion
id|tx_complete
(paren
id|dev
comma
id|txq-&gt;out.ptr
)paren
suffix:semicolon
singleline_comment|// mark unused again
id|txq-&gt;out.ptr-&gt;handle
op_assign
l_int|0
suffix:semicolon
singleline_comment|// remove item
id|txq-&gt;pending
op_decrement
suffix:semicolon
id|txq-&gt;out.ptr
op_assign
id|NEXTQ
(paren
id|txq-&gt;out.ptr
comma
id|txq-&gt;out.start
comma
id|txq-&gt;out.limit
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|txq-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|txq-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/********** RX queue pairs **********/
DECL|function|rx_give
r_static
r_inline
r_int
id|rx_give
(paren
id|amb_dev
op_star
id|dev
comma
id|rx_in
op_star
id|rx
comma
r_int
r_char
id|pool
)paren
(brace
id|amb_rxq
op_star
id|rxq
op_assign
op_amp
id|dev-&gt;rxq
(braket
id|pool
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_RX
comma
l_string|&quot;rx_give %p[%hu]&quot;
comma
id|dev
comma
id|pool
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|rxq-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rxq-&gt;pending
OL
id|rxq-&gt;maximum
)paren
(brace
id|PRINTD
(paren
id|DBG_RX
comma
l_string|&quot;RX in slot %p&quot;
comma
id|rxq-&gt;in.ptr
)paren
suffix:semicolon
op_star
id|rxq-&gt;in.ptr
op_assign
op_star
id|rx
suffix:semicolon
id|rxq-&gt;pending
op_increment
suffix:semicolon
id|rxq-&gt;in.ptr
op_assign
id|NEXTQ
(paren
id|rxq-&gt;in.ptr
comma
id|rxq-&gt;in.start
comma
id|rxq-&gt;in.limit
)paren
suffix:semicolon
singleline_comment|// hand over the RX buffer
id|wr_mem
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|mb.adapter.rx_address
(braket
id|pool
)braket
)paren
comma
id|virt_to_bus
(paren
id|rxq-&gt;in.ptr
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|rxq-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|rxq-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|rx_take
r_static
r_inline
r_int
id|rx_take
(paren
id|amb_dev
op_star
id|dev
comma
r_int
r_char
id|pool
)paren
(brace
id|amb_rxq
op_star
id|rxq
op_assign
op_amp
id|dev-&gt;rxq
(braket
id|pool
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_RX
comma
l_string|&quot;rx_take %p[%hu]&quot;
comma
id|dev
comma
id|pool
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|rxq-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rxq-&gt;pending
op_logical_and
(paren
id|rxq-&gt;out.ptr-&gt;status
op_logical_or
id|rxq-&gt;out.ptr-&gt;length
)paren
)paren
(brace
singleline_comment|// deal with RX completion
id|rx_complete
(paren
id|dev
comma
id|rxq-&gt;out.ptr
)paren
suffix:semicolon
singleline_comment|// mark unused again
id|rxq-&gt;out.ptr-&gt;status
op_assign
l_int|0
suffix:semicolon
id|rxq-&gt;out.ptr-&gt;length
op_assign
l_int|0
suffix:semicolon
singleline_comment|// remove item
id|rxq-&gt;pending
op_decrement
suffix:semicolon
id|rxq-&gt;out.ptr
op_assign
id|NEXTQ
(paren
id|rxq-&gt;out.ptr
comma
id|rxq-&gt;out.start
comma
id|rxq-&gt;out.limit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rxq-&gt;pending
OL
id|rxq-&gt;low
)paren
id|rxq-&gt;low
op_assign
id|rxq-&gt;pending
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|rxq-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|rxq-&gt;pending
op_logical_and
id|rxq-&gt;buffers_wanted
)paren
id|rxq-&gt;emptied
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|rxq-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/********** RX Pool handling **********/
multiline_comment|/* pre: buffers_wanted = 0, post: pending = 0 */
DECL|function|drain_rx_pool
r_static
r_inline
r_void
id|drain_rx_pool
(paren
id|amb_dev
op_star
id|dev
comma
r_int
r_char
id|pool
)paren
(brace
id|amb_rxq
op_star
id|rxq
op_assign
op_amp
id|dev-&gt;rxq
(braket
id|pool
)braket
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_POOL
comma
l_string|&quot;drain_rx_pool %p %hu&quot;
comma
id|dev
comma
id|pool
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
(paren
id|dead
comma
op_amp
id|dev-&gt;flags
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* we are not quite like the fill pool routines as we cannot just&n;     remove one buffer, we have to remove all of them, but we might as&n;     well pretend... */
r_if
c_cond
(paren
id|rxq-&gt;pending
OG
id|rxq-&gt;buffers_wanted
)paren
(brace
id|command
id|cmd
suffix:semicolon
id|cmd.request
op_assign
id|cpu_to_be32
(paren
id|SRB_FLUSH_BUFFER_Q
)paren
suffix:semicolon
id|cmd.args.flush.flags
op_assign
id|cpu_to_be32
(paren
id|pool
op_lshift
id|SRB_POOL_SHIFT
)paren
suffix:semicolon
r_while
c_loop
(paren
id|command_do
(paren
id|dev
comma
op_amp
id|cmd
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* the pool may also be emptied via the interrupt handler */
r_while
c_loop
(paren
id|rxq-&gt;pending
OG
id|rxq-&gt;buffers_wanted
)paren
r_if
c_cond
(paren
id|rx_take
(paren
id|dev
comma
id|pool
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|drain_rx_pools
r_static
r_void
id|drain_rx_pools
(paren
id|amb_dev
op_star
id|dev
)paren
(brace
r_int
r_char
id|pool
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_POOL
comma
l_string|&quot;drain_rx_pools %p&quot;
comma
id|dev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pool
op_assign
l_int|0
suffix:semicolon
id|pool
OL
id|NUM_RX_POOLS
suffix:semicolon
op_increment
id|pool
)paren
id|drain_rx_pool
(paren
id|dev
comma
id|pool
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
DECL|function|fill_rx_pool
r_static
r_inline
r_void
id|fill_rx_pool
(paren
id|amb_dev
op_star
id|dev
comma
r_int
r_char
id|pool
comma
r_int
id|priority
)paren
(brace
id|rx_in
id|rx
suffix:semicolon
id|amb_rxq
op_star
id|rxq
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_POOL
comma
l_string|&quot;fill_rx_pool %p %hu %x&quot;
comma
id|dev
comma
id|pool
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
(paren
id|dead
comma
op_amp
id|dev-&gt;flags
)paren
)paren
r_return
suffix:semicolon
id|rxq
op_assign
op_amp
id|dev-&gt;rxq
(braket
id|pool
)braket
suffix:semicolon
r_while
c_loop
(paren
id|rxq-&gt;pending
OL
id|rxq-&gt;maximum
op_logical_and
id|rxq-&gt;pending
OL
id|rxq-&gt;buffers_wanted
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|alloc_skb
(paren
id|rxq-&gt;buffer_size
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|PRINTD
(paren
id|DBG_SKB
op_or
id|DBG_POOL
comma
l_string|&quot;failed to allocate skb for RX pool %hu&quot;
comma
id|pool
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_area
(paren
id|skb-&gt;data
comma
id|skb-&gt;truesize
)paren
)paren
(brace
id|dev_kfree_skb_any
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|// cast needed as there is no %? for pointer differences
id|PRINTD
(paren
id|DBG_SKB
comma
l_string|&quot;allocated skb at %p, head %p, area %li&quot;
comma
id|skb
comma
id|skb-&gt;head
comma
(paren
r_int
)paren
(paren
id|skb-&gt;end
op_minus
id|skb-&gt;head
)paren
)paren
suffix:semicolon
id|rx.handle
op_assign
id|virt_to_bus
(paren
id|skb
)paren
suffix:semicolon
id|rx.host_address
op_assign
id|cpu_to_be32
(paren
id|virt_to_bus
(paren
id|skb-&gt;data
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rx_give
(paren
id|dev
comma
op_amp
id|rx
comma
id|pool
)paren
)paren
id|dev_kfree_skb_any
(paren
id|skb
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
singleline_comment|// top up all RX pools (can also be called as a bottom half)
DECL|function|fill_rx_pools
r_static
r_void
id|fill_rx_pools
(paren
id|amb_dev
op_star
id|dev
)paren
(brace
r_int
r_char
id|pool
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_POOL
comma
l_string|&quot;fill_rx_pools %p&quot;
comma
id|dev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pool
op_assign
l_int|0
suffix:semicolon
id|pool
OL
id|NUM_RX_POOLS
suffix:semicolon
op_increment
id|pool
)paren
id|fill_rx_pool
(paren
id|dev
comma
id|pool
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/********** enable host interrupts **********/
DECL|function|interrupts_on
r_static
r_inline
r_void
id|interrupts_on
(paren
id|amb_dev
op_star
id|dev
)paren
(brace
id|wr_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|interrupt_control
)paren
comma
id|rd_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|interrupt_control
)paren
)paren
op_or
id|AMB_INTERRUPT_BITS
)paren
suffix:semicolon
)brace
multiline_comment|/********** disable host interrupts **********/
DECL|function|interrupts_off
r_static
r_inline
r_void
id|interrupts_off
(paren
id|amb_dev
op_star
id|dev
)paren
(brace
id|wr_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|interrupt_control
)paren
comma
id|rd_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|interrupt_control
)paren
)paren
op_amp
op_complement
id|AMB_INTERRUPT_BITS
)paren
suffix:semicolon
)brace
multiline_comment|/********** interrupt handling **********/
DECL|function|interrupt_handler
r_static
r_void
id|interrupt_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|pt_regs
)paren
(brace
id|amb_dev
op_star
id|dev
op_assign
id|amb_devs
suffix:semicolon
(paren
r_void
)paren
id|pt_regs
suffix:semicolon
id|PRINTD
(paren
id|DBG_IRQ
op_or
id|DBG_FLOW
comma
l_string|&quot;interrupt_handler: %p&quot;
comma
id|dev_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev_id
)paren
(brace
id|PRINTD
(paren
id|DBG_IRQ
op_or
id|DBG_ERR
comma
l_string|&quot;irq with NULL dev_id: %d&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|// Did one of our cards generate the interrupt?
r_while
c_loop
(paren
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev
op_eq
id|dev_id
)paren
r_break
suffix:semicolon
id|dev
op_assign
id|dev-&gt;prev
suffix:semicolon
)brace
singleline_comment|// impossible - unless we add the device to our list after both
singleline_comment|// registering the IRQ handler for it and enabling interrupts, AND
singleline_comment|// the card generates an IRQ at startup - should not happen again
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|PRINTD
(paren
id|DBG_IRQ
comma
l_string|&quot;irq for unknown device: %d&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|// impossible - unless we have memory corruption of dev or kernel
r_if
c_cond
(paren
id|irq
op_ne
id|dev-&gt;irq
)paren
(brace
id|PRINTD
(paren
id|DBG_IRQ
op_or
id|DBG_ERR
comma
l_string|&quot;irq mismatch: %d&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
(brace
id|u32
id|interrupt
op_assign
id|rd_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|interrupt
)paren
)paren
suffix:semicolon
singleline_comment|// for us or someone else sharing the same interrupt
r_if
c_cond
(paren
op_logical_neg
id|interrupt
)paren
(brace
id|PRINTD
(paren
id|DBG_IRQ
comma
l_string|&quot;irq not for me: %d&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|// definitely for us
id|PRINTD
(paren
id|DBG_IRQ
comma
l_string|&quot;FYI: interrupt was %08x&quot;
comma
id|interrupt
)paren
suffix:semicolon
id|wr_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|interrupt
)paren
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
(brace
r_int
r_int
id|irq_work
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|pool
suffix:semicolon
r_for
c_loop
(paren
id|pool
op_assign
l_int|0
suffix:semicolon
id|pool
OL
id|NUM_RX_POOLS
suffix:semicolon
op_increment
id|pool
)paren
r_while
c_loop
(paren
op_logical_neg
id|rx_take
(paren
id|dev
comma
id|pool
)paren
)paren
op_increment
id|irq_work
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|tx_take
(paren
id|dev
)paren
)paren
op_increment
id|irq_work
suffix:semicolon
r_if
c_cond
(paren
id|irq_work
)paren
(brace
macro_line|#ifdef FILL_RX_POOLS_IN_BH
id|queue_task
(paren
op_amp
id|dev-&gt;bh
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
macro_line|#else
id|fill_rx_pools
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
id|PRINTD
(paren
id|DBG_IRQ
comma
l_string|&quot;work done: %u&quot;
comma
id|irq_work
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_IRQ
op_or
id|DBG_WARN
comma
l_string|&quot;no work done&quot;
)paren
suffix:semicolon
)brace
)brace
id|PRINTD
(paren
id|DBG_IRQ
op_or
id|DBG_FLOW
comma
l_string|&quot;interrupt_handler done: %p&quot;
comma
id|dev_id
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/********** don&squot;t panic... yeah, right **********/
macro_line|#ifdef DEBUG_AMBASSADOR
DECL|function|dont_panic
r_static
r_void
id|dont_panic
(paren
id|amb_dev
op_star
id|dev
)paren
(brace
id|amb_cq
op_star
id|cq
op_assign
op_amp
id|dev-&gt;cq
suffix:semicolon
r_volatile
id|amb_cq_ptrs
op_star
id|ptrs
op_assign
op_amp
id|cq-&gt;ptrs
suffix:semicolon
id|amb_txq
op_star
id|txq
suffix:semicolon
id|amb_rxq
op_star
id|rxq
suffix:semicolon
id|command
op_star
id|cmd
suffix:semicolon
id|tx_in
op_star
id|tx
suffix:semicolon
id|tx_simple
op_star
id|tx_descr
suffix:semicolon
r_int
r_char
id|pool
suffix:semicolon
id|rx_in
op_star
id|rx
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
(paren
id|KERN_INFO
comma
l_string|&quot;don&squot;t panic - putting adapter into reset&quot;
)paren
suffix:semicolon
id|wr_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|reset_control
)paren
comma
id|rd_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|reset_control
)paren
)paren
op_or
id|AMB_RESET_BITS
)paren
suffix:semicolon
id|PRINTK
(paren
id|KERN_INFO
comma
l_string|&quot;marking all commands complete&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cmd
op_assign
id|ptrs-&gt;start
suffix:semicolon
id|cmd
OL
id|ptrs-&gt;limit
suffix:semicolon
op_increment
id|cmd
)paren
id|cmd-&gt;request
op_assign
id|cpu_to_be32
(paren
id|SRB_COMPLETE
)paren
suffix:semicolon
id|PRINTK
(paren
id|KERN_INFO
comma
l_string|&quot;completing all TXs&quot;
)paren
suffix:semicolon
id|txq
op_assign
op_amp
id|dev-&gt;txq
suffix:semicolon
id|tx
op_assign
id|txq-&gt;in.ptr
suffix:semicolon
r_while
c_loop
(paren
id|txq-&gt;pending
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|tx
op_eq
id|txq-&gt;in.start
)paren
id|tx
op_assign
id|txq-&gt;in.limit
suffix:semicolon
op_decrement
id|tx
suffix:semicolon
id|tx_descr
op_assign
id|bus_to_virt
(paren
id|be32_to_cpu
(paren
id|tx-&gt;tx_descr_addr
)paren
)paren
suffix:semicolon
id|amb_kfree_skb
(paren
id|tx_descr-&gt;skb
)paren
suffix:semicolon
id|kfree
(paren
id|tx_descr
)paren
suffix:semicolon
)brace
id|PRINTK
(paren
id|KERN_INFO
comma
l_string|&quot;freeing all RX buffers&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pool
op_assign
l_int|0
suffix:semicolon
id|pool
OL
id|NUM_RX_POOLS
suffix:semicolon
op_increment
id|pool
)paren
(brace
id|rxq
op_assign
op_amp
id|dev-&gt;rxq
(braket
id|pool
)braket
suffix:semicolon
id|rx
op_assign
id|rxq-&gt;in.ptr
suffix:semicolon
r_while
c_loop
(paren
id|rxq-&gt;pending
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|rx
op_eq
id|rxq-&gt;in.start
)paren
id|rx
op_assign
id|rxq-&gt;in.limit
suffix:semicolon
op_decrement
id|rx
suffix:semicolon
id|dev_kfree_skb_any
(paren
id|bus_to_virt
(paren
id|rx-&gt;handle
)paren
)paren
suffix:semicolon
)brace
)brace
id|PRINTK
(paren
id|KERN_INFO
comma
l_string|&quot;don&squot;t panic over - close all VCs and rmmod&quot;
)paren
suffix:semicolon
id|set_bit
(paren
id|dead
comma
op_amp
id|dev-&gt;flags
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/********** make rate (not quite as much fun as Horizon) **********/
DECL|function|make_rate
r_static
r_int
r_int
id|make_rate
(paren
r_int
r_int
id|rate
comma
id|rounding
id|r
comma
id|u16
op_star
id|bits
comma
r_int
r_int
op_star
id|actual
)paren
(brace
r_int
r_char
id|exp
op_assign
op_minus
l_int|1
suffix:semicolon
singleline_comment|// hush gcc
r_int
r_int
id|man
op_assign
op_minus
l_int|1
suffix:semicolon
singleline_comment|// hush gcc
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_QOS
comma
l_string|&quot;make_rate %u&quot;
comma
id|rate
)paren
suffix:semicolon
singleline_comment|// rates in cells per second, ITU format (nasty 16-bit floating-point)
singleline_comment|// given 5-bit e and 9-bit m:
singleline_comment|// rate = EITHER (1+m/2^9)*2^e    OR 0
singleline_comment|// bits = EITHER 1&lt;&lt;14 | e&lt;&lt;9 | m OR 0
singleline_comment|// (bit 15 is &quot;reserved&quot;, bit 14 &quot;non-zero&quot;)
singleline_comment|// smallest rate is 0 (special representation)
singleline_comment|// largest rate is (1+511/512)*2^31 = 4290772992 (&lt; 2^32-1)
singleline_comment|// smallest non-zero rate is (1+0/512)*2^0 = 1 (&gt; 0)
singleline_comment|// simple algorithm:
singleline_comment|// find position of top bit, this gives e
singleline_comment|// remove top bit and shift (rounding if feeling clever) by 9-e
singleline_comment|// ucode bug: please don&squot;t set bit 14! so 0 rate not representable
r_if
c_cond
(paren
id|rate
OG
l_int|0xffc00000U
)paren
(brace
singleline_comment|// larger than largest representable rate
r_if
c_cond
(paren
id|r
op_eq
id|round_up
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
id|exp
op_assign
l_int|31
suffix:semicolon
id|man
op_assign
l_int|511
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|rate
)paren
(brace
singleline_comment|// representable rate
id|exp
op_assign
l_int|31
suffix:semicolon
id|man
op_assign
id|rate
suffix:semicolon
singleline_comment|// invariant: rate = man*2^(exp-31)
r_while
c_loop
(paren
op_logical_neg
(paren
id|man
op_amp
(paren
l_int|1
op_lshift
l_int|31
)paren
)paren
)paren
(brace
id|exp
op_assign
id|exp
op_minus
l_int|1
suffix:semicolon
id|man
op_assign
id|man
op_lshift
l_int|1
suffix:semicolon
)brace
singleline_comment|// man has top bit set
singleline_comment|// rate = (2^31+(man-2^31))*2^(exp-31)
singleline_comment|// rate = (1+(man-2^31)/2^31)*2^exp
id|man
op_assign
id|man
op_lshift
l_int|1
suffix:semicolon
id|man
op_and_assign
l_int|0xffffffffU
suffix:semicolon
singleline_comment|// a nop on 32-bit systems
singleline_comment|// rate = (1+man/2^32)*2^exp
singleline_comment|// exp is in the range 0 to 31, man is in the range 0 to 2^32-1
singleline_comment|// time to lose significance... we want m in the range 0 to 2^9-1
singleline_comment|// rounding presents a minor problem... we first decide which way
singleline_comment|// we are rounding (based on given rounding direction and possibly
singleline_comment|// the bits of the mantissa that are to be discarded).
r_switch
c_cond
(paren
id|r
)paren
(brace
r_case
id|round_down
suffix:colon
(brace
singleline_comment|// just truncate
id|man
op_assign
id|man
op_rshift
(paren
l_int|32
op_minus
l_int|9
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|round_up
suffix:colon
(brace
singleline_comment|// check all bits that we are discarding
r_if
c_cond
(paren
id|man
op_amp
(paren
op_minus
l_int|1
op_rshift
l_int|9
)paren
)paren
(brace
id|man
op_assign
(paren
id|man
op_rshift
(paren
l_int|32
op_minus
l_int|9
)paren
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|man
op_eq
(paren
l_int|1
op_lshift
l_int|9
)paren
)paren
(brace
singleline_comment|// no need to check for round up outside of range
id|man
op_assign
l_int|0
suffix:semicolon
id|exp
op_add_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|man
op_assign
(paren
id|man
op_rshift
(paren
l_int|32
op_minus
l_int|9
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|round_nearest
suffix:colon
(brace
singleline_comment|// check msb that we are discarding
r_if
c_cond
(paren
id|man
op_amp
(paren
l_int|1
op_lshift
(paren
l_int|32
op_minus
l_int|9
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|man
op_assign
(paren
id|man
op_rshift
(paren
l_int|32
op_minus
l_int|9
)paren
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|man
op_eq
(paren
l_int|1
op_lshift
l_int|9
)paren
)paren
(brace
singleline_comment|// no need to check for round up outside of range
id|man
op_assign
l_int|0
suffix:semicolon
id|exp
op_add_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|man
op_assign
(paren
id|man
op_rshift
(paren
l_int|32
op_minus
l_int|9
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
singleline_comment|// zero rate - not representable
r_if
c_cond
(paren
id|r
op_eq
id|round_down
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
id|exp
op_assign
l_int|0
suffix:semicolon
id|man
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;rate: man=%u, exp=%hu&quot;
comma
id|man
comma
id|exp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bits
)paren
op_star
id|bits
op_assign
multiline_comment|/* (1&lt;&lt;14) | */
(paren
id|exp
op_lshift
l_int|9
)paren
op_or
id|man
suffix:semicolon
r_if
c_cond
(paren
id|actual
)paren
op_star
id|actual
op_assign
(paren
id|exp
op_ge
l_int|9
)paren
ques
c_cond
(paren
l_int|1
op_lshift
id|exp
)paren
op_plus
(paren
id|man
op_lshift
(paren
id|exp
op_minus
l_int|9
)paren
)paren
suffix:colon
(paren
l_int|1
op_lshift
id|exp
)paren
op_plus
(paren
(paren
id|man
op_plus
(paren
l_int|1
op_lshift
(paren
l_int|9
op_minus
id|exp
op_minus
l_int|1
)paren
)paren
)paren
op_rshift
(paren
l_int|9
op_minus
id|exp
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/********** Linux ATM Operations **********/
singleline_comment|// some are not yet implemented while others do not make sense for
singleline_comment|// this device
multiline_comment|/********** Open a VC **********/
DECL|function|amb_open
r_static
r_int
id|amb_open
(paren
r_struct
id|atm_vcc
op_star
id|atm_vcc
comma
r_int
id|vpi
comma
r_int
id|vci
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|atm_qos
op_star
id|qos
suffix:semicolon
r_struct
id|atm_trafprm
op_star
id|txtp
suffix:semicolon
r_struct
id|atm_trafprm
op_star
id|rxtp
suffix:semicolon
id|u16
id|tx_rate_bits
suffix:semicolon
id|u16
id|tx_vc_bits
op_assign
op_minus
l_int|1
suffix:semicolon
singleline_comment|// hush gcc
id|u16
id|tx_frame_bits
op_assign
op_minus
l_int|1
suffix:semicolon
singleline_comment|// hush gcc
id|amb_dev
op_star
id|dev
op_assign
id|AMB_DEV
c_func
(paren
id|atm_vcc-&gt;dev
)paren
suffix:semicolon
id|amb_vcc
op_star
id|vcc
suffix:semicolon
r_int
r_char
id|pool
op_assign
op_minus
l_int|1
suffix:semicolon
singleline_comment|// hush gcc
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_VCC
comma
l_string|&quot;amb_open %x %x&quot;
comma
id|vpi
comma
id|vci
)paren
suffix:semicolon
macro_line|#ifdef ATM_VPI_UNSPEC
singleline_comment|// UNSPEC is deprecated, remove this code eventually
r_if
c_cond
(paren
id|vpi
op_eq
id|ATM_VPI_UNSPEC
op_logical_or
id|vci
op_eq
id|ATM_VCI_UNSPEC
)paren
(brace
id|PRINTK
(paren
id|KERN_WARNING
comma
l_string|&quot;rejecting open with unspecified VPI/VCI (deprecated)&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#endif
singleline_comment|// deal with possibly wildcarded VCs
id|error
op_assign
id|atm_find_ci
(paren
id|atm_vcc
comma
op_amp
id|vpi
comma
op_amp
id|vci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|PRINTD
(paren
id|DBG_WARN
op_or
id|DBG_VCC
comma
l_string|&quot;atm_find_ci failed!&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|PRINTD
(paren
id|DBG_VCC
comma
l_string|&quot;atm_find_ci gives %x %x&quot;
comma
id|vpi
comma
id|vci
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
l_int|0
op_le
id|vpi
op_logical_and
id|vpi
OL
(paren
l_int|1
op_lshift
id|NUM_VPI_BITS
)paren
op_logical_and
l_int|0
op_le
id|vci
op_logical_and
id|vci
OL
(paren
l_int|1
op_lshift
id|NUM_VCI_BITS
)paren
)paren
)paren
(brace
id|PRINTD
(paren
id|DBG_WARN
op_or
id|DBG_VCC
comma
l_string|&quot;VPI/VCI out of range: %hd/%d&quot;
comma
id|vpi
comma
id|vci
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|qos
op_assign
op_amp
id|atm_vcc-&gt;qos
suffix:semicolon
r_if
c_cond
(paren
id|qos-&gt;aal
op_ne
id|ATM_AAL5
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;AAL not supported&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
singleline_comment|// traffic parameters
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;TX:&quot;
)paren
suffix:semicolon
id|txtp
op_assign
op_amp
id|qos-&gt;txtp
suffix:semicolon
r_if
c_cond
(paren
id|txtp-&gt;traffic_class
op_ne
id|ATM_NONE
)paren
(brace
r_switch
c_cond
(paren
id|txtp-&gt;traffic_class
)paren
(brace
r_case
id|ATM_UBR
suffix:colon
(brace
singleline_comment|// we take &quot;the PCR&quot; as a rate-cap
r_int
id|pcr
op_assign
id|atm_pcr_goal
(paren
id|txtp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcr
)paren
(brace
singleline_comment|// no rate cap
id|tx_rate_bits
op_assign
l_int|0
suffix:semicolon
id|tx_vc_bits
op_assign
id|TX_UBR
suffix:semicolon
id|tx_frame_bits
op_assign
id|TX_FRAME_NOTCAP
suffix:semicolon
)brace
r_else
(brace
id|rounding
id|r
suffix:semicolon
r_if
c_cond
(paren
id|pcr
OL
l_int|0
)paren
(brace
id|r
op_assign
id|round_down
suffix:semicolon
id|pcr
op_assign
op_minus
id|pcr
suffix:semicolon
)brace
r_else
(brace
id|r
op_assign
id|round_up
suffix:semicolon
)brace
id|error
op_assign
id|make_rate
(paren
id|pcr
comma
id|r
comma
op_amp
id|tx_rate_bits
comma
l_int|0
)paren
suffix:semicolon
id|tx_vc_bits
op_assign
id|TX_UBR_CAPPED
suffix:semicolon
id|tx_frame_bits
op_assign
id|TX_FRAME_CAPPED
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
macro_line|#if 0
r_case
id|ATM_ABR
suffix:colon
(brace
id|pcr
op_assign
id|atm_pcr_goal
(paren
id|txtp
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;pcr goal = %d&quot;
comma
id|pcr
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
r_default
suffix:colon
(brace
)brace
(brace
singleline_comment|// PRINTD (DBG_QOS, &quot;request for non-UBR/ABR denied&quot;);
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;request for non-UBR denied&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;tx_rate_bits=%hx, tx_vc_bits=%hx&quot;
comma
id|tx_rate_bits
comma
id|tx_vc_bits
)paren
suffix:semicolon
)brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;RX:&quot;
)paren
suffix:semicolon
id|rxtp
op_assign
op_amp
id|qos-&gt;rxtp
suffix:semicolon
r_if
c_cond
(paren
id|rxtp-&gt;traffic_class
op_eq
id|ATM_NONE
)paren
(brace
singleline_comment|// do nothing
)brace
r_else
(brace
singleline_comment|// choose an RX pool (arranged in increasing size)
r_for
c_loop
(paren
id|pool
op_assign
l_int|0
suffix:semicolon
id|pool
OL
id|NUM_RX_POOLS
suffix:semicolon
op_increment
id|pool
)paren
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|rxtp-&gt;max_sdu
op_le
id|dev-&gt;rxq
(braket
id|pool
)braket
dot
id|buffer_size
)paren
(brace
id|PRINTD
(paren
id|DBG_VCC
op_or
id|DBG_QOS
op_or
id|DBG_POOL
comma
l_string|&quot;chose pool %hu (max_sdu %u &lt;= %u)&quot;
comma
id|pool
comma
id|rxtp-&gt;max_sdu
comma
id|dev-&gt;rxq
(braket
id|pool
)braket
dot
id|buffer_size
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pool
op_eq
id|NUM_RX_POOLS
)paren
(brace
id|PRINTD
(paren
id|DBG_WARN
op_or
id|DBG_VCC
op_or
id|DBG_QOS
op_or
id|DBG_POOL
comma
l_string|&quot;no pool suitable for VC (RX max_sdu %d is too large)&quot;
comma
id|rxtp-&gt;max_sdu
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|rxtp-&gt;traffic_class
)paren
(brace
r_case
id|ATM_UBR
suffix:colon
(brace
r_break
suffix:semicolon
)brace
macro_line|#if 0
r_case
id|ATM_ABR
suffix:colon
(brace
id|pcr
op_assign
id|atm_pcr_goal
(paren
id|rxtp
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;pcr goal = %d&quot;
comma
id|pcr
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
r_default
suffix:colon
(brace
)brace
(brace
singleline_comment|// PRINTD (DBG_QOS, &quot;request for non-UBR/ABR denied&quot;);
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;request for non-UBR denied&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
)brace
singleline_comment|// get space for our vcc stuff
id|vcc
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|amb_vcc
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vcc
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;out of memory!&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|atm_vcc-&gt;dev_data
op_assign
(paren
r_void
op_star
)paren
id|vcc
suffix:semicolon
singleline_comment|// no failures beyond this point
singleline_comment|// we are not really &quot;immediately before allocating the connection
singleline_comment|// identifier in hardware&quot;, but it will just have to do!
id|set_bit
c_func
(paren
id|ATM_VF_ADDR
comma
op_amp
id|atm_vcc-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|txtp-&gt;traffic_class
op_ne
id|ATM_NONE
)paren
(brace
id|command
id|cmd
suffix:semicolon
id|vcc-&gt;tx_frame_bits
op_assign
id|tx_frame_bits
suffix:semicolon
id|down
(paren
op_amp
id|dev-&gt;vcc_sf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;rxer
(braket
id|vci
)braket
)paren
(brace
singleline_comment|// RXer on the channel already, just modify rate...
id|cmd.request
op_assign
id|cpu_to_be32
(paren
id|SRB_MODIFY_VC_RATE
)paren
suffix:semicolon
id|cmd.args.modify_rate.vc
op_assign
id|cpu_to_be32
(paren
id|vci
)paren
suffix:semicolon
singleline_comment|// vpi 0
id|cmd.args.modify_rate.rate
op_assign
id|cpu_to_be32
(paren
id|tx_rate_bits
op_lshift
id|SRB_RATE_SHIFT
)paren
suffix:semicolon
r_while
c_loop
(paren
id|command_do
(paren
id|dev
comma
op_amp
id|cmd
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// ... and TX flags, preserving the RX pool
id|cmd.request
op_assign
id|cpu_to_be32
(paren
id|SRB_MODIFY_VC_FLAGS
)paren
suffix:semicolon
id|cmd.args.modify_flags.vc
op_assign
id|cpu_to_be32
(paren
id|vci
)paren
suffix:semicolon
singleline_comment|// vpi 0
id|cmd.args.modify_flags.flags
op_assign
id|cpu_to_be32
(paren
(paren
id|AMB_VCC
c_func
(paren
id|dev-&gt;rxer
(braket
id|vci
)braket
)paren
op_member_access_from_pointer
id|rx_info.pool
op_lshift
id|SRB_POOL_SHIFT
)paren
op_or
(paren
id|tx_vc_bits
op_lshift
id|SRB_FLAGS_SHIFT
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|command_do
(paren
id|dev
comma
op_amp
id|cmd
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// no RXer on the channel, just open (with pool zero)
id|cmd.request
op_assign
id|cpu_to_be32
(paren
id|SRB_OPEN_VC
)paren
suffix:semicolon
id|cmd.args.open.vc
op_assign
id|cpu_to_be32
(paren
id|vci
)paren
suffix:semicolon
singleline_comment|// vpi 0
id|cmd.args.open.flags
op_assign
id|cpu_to_be32
(paren
id|tx_vc_bits
op_lshift
id|SRB_FLAGS_SHIFT
)paren
suffix:semicolon
id|cmd.args.open.rate
op_assign
id|cpu_to_be32
(paren
id|tx_rate_bits
op_lshift
id|SRB_RATE_SHIFT
)paren
suffix:semicolon
r_while
c_loop
(paren
id|command_do
(paren
id|dev
comma
op_amp
id|cmd
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|dev-&gt;txer
(braket
id|vci
)braket
dot
id|tx_present
op_assign
l_int|1
suffix:semicolon
id|up
(paren
op_amp
id|dev-&gt;vcc_sf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rxtp-&gt;traffic_class
op_ne
id|ATM_NONE
)paren
(brace
id|command
id|cmd
suffix:semicolon
id|vcc-&gt;rx_info.pool
op_assign
id|pool
suffix:semicolon
id|down
(paren
op_amp
id|dev-&gt;vcc_sf
)paren
suffix:semicolon
multiline_comment|/* grow RX buffer pool */
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;rxq
(braket
id|pool
)braket
dot
id|buffers_wanted
)paren
id|dev-&gt;rxq
(braket
id|pool
)braket
dot
id|buffers_wanted
op_assign
id|rx_lats
suffix:semicolon
id|dev-&gt;rxq
(braket
id|pool
)braket
dot
id|buffers_wanted
op_add_assign
l_int|1
suffix:semicolon
id|fill_rx_pool
(paren
id|dev
comma
id|pool
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;txer
(braket
id|vci
)braket
dot
id|tx_present
)paren
(brace
singleline_comment|// TXer on the channel already
singleline_comment|// switch (from pool zero) to this pool, preserving the TX bits
id|cmd.request
op_assign
id|cpu_to_be32
(paren
id|SRB_MODIFY_VC_FLAGS
)paren
suffix:semicolon
id|cmd.args.modify_flags.vc
op_assign
id|cpu_to_be32
(paren
id|vci
)paren
suffix:semicolon
singleline_comment|// vpi 0
id|cmd.args.modify_flags.flags
op_assign
id|cpu_to_be32
(paren
(paren
id|pool
op_lshift
id|SRB_POOL_SHIFT
)paren
op_or
(paren
id|dev-&gt;txer
(braket
id|vci
)braket
dot
id|tx_vc_bits
op_lshift
id|SRB_FLAGS_SHIFT
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// no TXer on the channel, open the VC (with no rate info)
id|cmd.request
op_assign
id|cpu_to_be32
(paren
id|SRB_OPEN_VC
)paren
suffix:semicolon
id|cmd.args.open.vc
op_assign
id|cpu_to_be32
(paren
id|vci
)paren
suffix:semicolon
singleline_comment|// vpi 0
id|cmd.args.open.flags
op_assign
id|cpu_to_be32
(paren
id|pool
op_lshift
id|SRB_POOL_SHIFT
)paren
suffix:semicolon
id|cmd.args.open.rate
op_assign
id|cpu_to_be32
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|command_do
(paren
id|dev
comma
op_amp
id|cmd
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// this link allows RX frames through
id|dev-&gt;rxer
(braket
id|vci
)braket
op_assign
id|atm_vcc
suffix:semicolon
id|up
(paren
op_amp
id|dev-&gt;vcc_sf
)paren
suffix:semicolon
)brace
singleline_comment|// set elements of vcc
id|atm_vcc-&gt;vpi
op_assign
id|vpi
suffix:semicolon
singleline_comment|// 0
id|atm_vcc-&gt;vci
op_assign
id|vci
suffix:semicolon
singleline_comment|// indicate readiness
id|set_bit
c_func
(paren
id|ATM_VF_READY
comma
op_amp
id|atm_vcc-&gt;flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/********** Close a VC **********/
DECL|function|amb_close
r_static
r_void
id|amb_close
(paren
r_struct
id|atm_vcc
op_star
id|atm_vcc
)paren
(brace
id|amb_dev
op_star
id|dev
op_assign
id|AMB_DEV
(paren
id|atm_vcc-&gt;dev
)paren
suffix:semicolon
id|amb_vcc
op_star
id|vcc
op_assign
id|AMB_VCC
(paren
id|atm_vcc
)paren
suffix:semicolon
id|u16
id|vci
op_assign
id|atm_vcc-&gt;vci
suffix:semicolon
id|PRINTD
(paren
id|DBG_VCC
op_or
id|DBG_FLOW
comma
l_string|&quot;amb_close&quot;
)paren
suffix:semicolon
singleline_comment|// indicate unreadiness
id|clear_bit
c_func
(paren
id|ATM_VF_READY
comma
op_amp
id|atm_vcc-&gt;flags
)paren
suffix:semicolon
singleline_comment|// disable TXing
r_if
c_cond
(paren
id|atm_vcc-&gt;qos.txtp.traffic_class
op_ne
id|ATM_NONE
)paren
(brace
id|command
id|cmd
suffix:semicolon
id|down
(paren
op_amp
id|dev-&gt;vcc_sf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;rxer
(braket
id|vci
)braket
)paren
(brace
singleline_comment|// RXer still on the channel, just modify rate... XXX not really needed
id|cmd.request
op_assign
id|cpu_to_be32
(paren
id|SRB_MODIFY_VC_RATE
)paren
suffix:semicolon
id|cmd.args.modify_rate.vc
op_assign
id|cpu_to_be32
(paren
id|vci
)paren
suffix:semicolon
singleline_comment|// vpi 0
id|cmd.args.modify_rate.rate
op_assign
id|cpu_to_be32
(paren
l_int|0
)paren
suffix:semicolon
singleline_comment|// ... and clear TX rate flags (XXX to stop RM cell output?), preserving RX pool
)brace
r_else
(brace
singleline_comment|// no RXer on the channel, close channel
id|cmd.request
op_assign
id|cpu_to_be32
(paren
id|SRB_CLOSE_VC
)paren
suffix:semicolon
id|cmd.args.close.vc
op_assign
id|cpu_to_be32
(paren
id|vci
)paren
suffix:semicolon
singleline_comment|// vpi 0
)brace
id|dev-&gt;txer
(braket
id|vci
)braket
dot
id|tx_present
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|command_do
(paren
id|dev
comma
op_amp
id|cmd
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|up
(paren
op_amp
id|dev-&gt;vcc_sf
)paren
suffix:semicolon
)brace
singleline_comment|// disable RXing
r_if
c_cond
(paren
id|atm_vcc-&gt;qos.rxtp.traffic_class
op_ne
id|ATM_NONE
)paren
(brace
id|command
id|cmd
suffix:semicolon
singleline_comment|// this is (the?) one reason why we need the amb_vcc struct
r_int
r_char
id|pool
op_assign
id|vcc-&gt;rx_info.pool
suffix:semicolon
id|down
(paren
op_amp
id|dev-&gt;vcc_sf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;txer
(braket
id|vci
)braket
dot
id|tx_present
)paren
(brace
singleline_comment|// TXer still on the channel, just go to pool zero XXX not really needed
id|cmd.request
op_assign
id|cpu_to_be32
(paren
id|SRB_MODIFY_VC_FLAGS
)paren
suffix:semicolon
id|cmd.args.modify_flags.vc
op_assign
id|cpu_to_be32
(paren
id|vci
)paren
suffix:semicolon
singleline_comment|// vpi 0
id|cmd.args.modify_flags.flags
op_assign
id|cpu_to_be32
(paren
id|dev-&gt;txer
(braket
id|vci
)braket
dot
id|tx_vc_bits
op_lshift
id|SRB_FLAGS_SHIFT
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// no TXer on the channel, close the VC
id|cmd.request
op_assign
id|cpu_to_be32
(paren
id|SRB_CLOSE_VC
)paren
suffix:semicolon
id|cmd.args.close.vc
op_assign
id|cpu_to_be32
(paren
id|vci
)paren
suffix:semicolon
singleline_comment|// vpi 0
)brace
singleline_comment|// forget the rxer - no more skbs will be pushed
r_if
c_cond
(paren
id|atm_vcc
op_ne
id|dev-&gt;rxer
(braket
id|vci
)braket
)paren
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;%s vcc=%p rxer[vci]=%p&quot;
comma
l_string|&quot;arghhh! we&squot;re going to die!&quot;
comma
id|vcc
comma
id|dev-&gt;rxer
(braket
id|vci
)braket
)paren
suffix:semicolon
id|dev-&gt;rxer
(braket
id|vci
)braket
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|command_do
(paren
id|dev
comma
op_amp
id|cmd
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* shrink RX buffer pool */
id|dev-&gt;rxq
(braket
id|pool
)braket
dot
id|buffers_wanted
op_sub_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;rxq
(braket
id|pool
)braket
dot
id|buffers_wanted
op_eq
id|rx_lats
)paren
(brace
id|dev-&gt;rxq
(braket
id|pool
)braket
dot
id|buffers_wanted
op_assign
l_int|0
suffix:semicolon
id|drain_rx_pool
(paren
id|dev
comma
id|pool
)paren
suffix:semicolon
)brace
id|up
(paren
op_amp
id|dev-&gt;vcc_sf
)paren
suffix:semicolon
)brace
singleline_comment|// free our structure
id|kfree
(paren
id|vcc
)paren
suffix:semicolon
singleline_comment|// say the VPI/VCI is free again
id|clear_bit
c_func
(paren
id|ATM_VF_ADDR
comma
op_amp
id|atm_vcc-&gt;flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/********** Debug&#x17;Ioctl **********/
macro_line|#if 0
r_static
r_int
id|amb_ioctl
(paren
r_struct
id|atm_dev
op_star
id|dev
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_int
r_int
id|newdebug
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|AMB_SETDEBUG
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|newdebug
comma
id|arg
comma
r_sizeof
(paren
id|newdebug
)paren
)paren
)paren
(brace
singleline_comment|// moan
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
(brace
id|debug
op_assign
id|newdebug
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|cmd
op_eq
id|AMB_DONTPANIC
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|dont_panic
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// moan
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/********** Set socket options for a VC **********/
singleline_comment|// int amb_getsockopt (struct atm_vcc * atm_vcc, int level, int optname, void * optval, int optlen);
multiline_comment|/********** Set socket options for a VC **********/
singleline_comment|// int amb_setsockopt (struct atm_vcc * atm_vcc, int level, int optname, void * optval, int optlen);
multiline_comment|/********** Send **********/
DECL|function|amb_send
r_static
r_int
id|amb_send
(paren
r_struct
id|atm_vcc
op_star
id|atm_vcc
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|amb_dev
op_star
id|dev
op_assign
id|AMB_DEV
c_func
(paren
id|atm_vcc-&gt;dev
)paren
suffix:semicolon
id|amb_vcc
op_star
id|vcc
op_assign
id|AMB_VCC
c_func
(paren
id|atm_vcc
)paren
suffix:semicolon
id|u16
id|vc
op_assign
id|atm_vcc-&gt;vci
suffix:semicolon
r_int
r_int
id|tx_len
op_assign
id|skb-&gt;len
suffix:semicolon
r_int
r_char
op_star
id|tx_data
op_assign
id|skb-&gt;data
suffix:semicolon
id|tx_simple
op_star
id|tx_descr
suffix:semicolon
id|tx_in
id|tx
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
(paren
id|dead
comma
op_amp
id|dev-&gt;flags
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_TX
comma
l_string|&quot;amb_send vc %x data %p len %u&quot;
comma
id|vc
comma
id|tx_data
comma
id|tx_len
)paren
suffix:semicolon
id|dump_skb
(paren
l_string|&quot;&gt;&gt;&gt;&quot;
comma
id|vc
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;txer
(braket
id|vc
)braket
dot
id|tx_present
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;attempt to send on RX-only VC %x&quot;
comma
id|vc
)paren
suffix:semicolon
r_return
op_minus
id|EBADFD
suffix:semicolon
)brace
singleline_comment|// this is a driver private field so we have to set it ourselves,
singleline_comment|// despite the fact that we are _required_ to use it to check for a
singleline_comment|// pop function
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc
op_assign
id|atm_vcc
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OG
(paren
r_int
)paren
id|atm_vcc-&gt;qos.txtp.max_sdu
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;sk_buff length greater than agreed max_sdu, dropping...&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_area
(paren
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|atm_vcc-&gt;stats-&gt;tx_err
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
singleline_comment|// ?
)brace
singleline_comment|// allocate memory for fragments
id|tx_descr
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|tx_simple
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tx_descr
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;could not allocate TX descriptor&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_area
(paren
id|tx_descr
comma
r_sizeof
(paren
id|tx_simple
)paren
)paren
)paren
(brace
id|kfree
(paren
id|tx_descr
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|PRINTD
(paren
id|DBG_TX
comma
l_string|&quot;fragment list allocated at %p&quot;
comma
id|tx_descr
)paren
suffix:semicolon
id|tx_descr-&gt;skb
op_assign
id|skb
suffix:semicolon
id|tx_descr-&gt;tx_frag.bytes
op_assign
id|cpu_to_be32
(paren
id|tx_len
)paren
suffix:semicolon
id|tx_descr-&gt;tx_frag.address
op_assign
id|cpu_to_be32
(paren
id|virt_to_bus
(paren
id|tx_data
)paren
)paren
suffix:semicolon
id|tx_descr-&gt;tx_frag_end.handle
op_assign
id|virt_to_bus
(paren
id|tx_descr
)paren
suffix:semicolon
id|tx_descr-&gt;tx_frag_end.vc
op_assign
l_int|0
suffix:semicolon
id|tx_descr-&gt;tx_frag_end.next_descriptor_length
op_assign
l_int|0
suffix:semicolon
id|tx_descr-&gt;tx_frag_end.next_descriptor
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef AMB_NEW_MICROCODE
id|tx_descr-&gt;tx_frag_end.cpcs_uu
op_assign
l_int|0
suffix:semicolon
id|tx_descr-&gt;tx_frag_end.cpi
op_assign
l_int|0
suffix:semicolon
id|tx_descr-&gt;tx_frag_end.pad
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|tx.vc
op_assign
id|cpu_to_be16
(paren
id|vcc-&gt;tx_frame_bits
op_or
id|vc
)paren
suffix:semicolon
id|tx.tx_descr_length
op_assign
id|cpu_to_be16
(paren
r_sizeof
(paren
id|tx_frag
)paren
op_plus
r_sizeof
(paren
id|tx_frag_end
)paren
)paren
suffix:semicolon
id|tx.tx_descr_addr
op_assign
id|cpu_to_be32
(paren
id|virt_to_bus
(paren
op_amp
id|tx_descr-&gt;tx_frag
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_AMBASSADOR
multiline_comment|/* wey-hey! */
r_if
c_cond
(paren
id|vc
op_eq
l_int|1023
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|d
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|s
op_assign
id|skb-&gt;data
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|s
op_increment
)paren
(brace
r_case
l_char|&squot;D&squot;
suffix:colon
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
id|d
op_assign
(paren
id|d
op_lshift
l_int|4
)paren
op_or
(paren
(paren
op_star
id|s
op_le
l_char|&squot;9&squot;
)paren
ques
c_cond
(paren
op_star
id|s
op_minus
l_char|&squot;0&squot;
)paren
suffix:colon
(paren
op_star
id|s
op_minus
l_char|&squot;a&squot;
op_plus
l_int|10
)paren
)paren
suffix:semicolon
op_increment
id|s
suffix:semicolon
)brace
id|PRINTK
(paren
id|KERN_INFO
comma
l_string|&quot;debug bitmap is now %hx&quot;
comma
id|debug
op_assign
id|d
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_char|&squot;R&squot;
suffix:colon
(brace
r_if
c_cond
(paren
op_star
id|s
op_increment
op_eq
l_char|&squot;e&squot;
op_logical_and
op_star
id|s
op_increment
op_eq
l_char|&squot;s&squot;
op_logical_and
op_star
id|s
op_increment
op_eq
l_char|&squot;e&squot;
op_logical_and
op_star
id|s
op_increment
op_eq
l_char|&squot;t&squot;
)paren
id|dont_panic
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
(brace
)brace
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
r_while
c_loop
(paren
id|tx_give
(paren
id|dev
comma
op_amp
id|tx
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/********** Scatter Gather Send Capability **********/
DECL|function|amb_sg_send
r_static
r_int
id|amb_sg_send
(paren
r_struct
id|atm_vcc
op_star
id|atm_vcc
comma
r_int
r_int
id|start
comma
r_int
r_int
id|size
)paren
(brace
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_VCC
comma
l_string|&quot;amb_sg_send: never&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|atm_vcc-&gt;qos.aal
op_eq
id|ATM_AAL5
)paren
(brace
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_VCC
comma
l_string|&quot;amb_sg_send: yes&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_VCC
comma
l_string|&quot;amb_sg_send: no&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_VCC
comma
l_string|&quot;amb_sg_send: always&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/********** Send OAM **********/
singleline_comment|// static int amb_send_oam (struct atm_vcc * atm_vcc, void * cell, int flags);
multiline_comment|/********** Feedback to Driver **********/
singleline_comment|// void amb_feedback (struct atm_vcc * atm_vcc, struct sk_buff * skb,
singleline_comment|// unsigned long start, unsigned long dest, int len);
multiline_comment|/********** Change QoS on a VC **********/
singleline_comment|// int amb_change_qos (struct atm_vcc * atm_vcc, struct atm_qos * qos, int flags);
multiline_comment|/********** Free RX Socket Buffer **********/
macro_line|#if 0
r_static
r_void
id|amb_free_rx_skb
(paren
r_struct
id|atm_vcc
op_star
id|atm_vcc
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|amb_dev
op_star
id|dev
op_assign
id|AMB_DEV
(paren
id|atm_vcc-&gt;dev
)paren
suffix:semicolon
id|amb_vcc
op_star
id|vcc
op_assign
id|AMB_VCC
(paren
id|atm_vcc
)paren
suffix:semicolon
r_int
r_char
id|pool
op_assign
id|vcc-&gt;rx_info.pool
suffix:semicolon
id|rx_in
id|rx
suffix:semicolon
singleline_comment|// This may be unsafe for various reasons that I cannot really guess
singleline_comment|// at. However, I note that the ATM layer calls kfree_skb rather
singleline_comment|// than dev_kfree_skb at this point so we are least covered as far
singleline_comment|// as buffer locking goes. There may be bugs if pcap clones RX skbs.
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_SKB
comma
l_string|&quot;amb_rx_free skb %p (atm_vcc %p, vcc %p)&quot;
comma
id|skb
comma
id|atm_vcc
comma
id|vcc
)paren
suffix:semicolon
id|rx.handle
op_assign
id|virt_to_bus
(paren
id|skb
)paren
suffix:semicolon
id|rx.host_address
op_assign
id|cpu_to_be32
(paren
id|virt_to_bus
(paren
id|skb-&gt;data
)paren
)paren
suffix:semicolon
id|skb-&gt;data
op_assign
id|skb-&gt;head
suffix:semicolon
id|skb-&gt;tail
op_assign
id|skb-&gt;head
suffix:semicolon
id|skb-&gt;len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rx_give
(paren
id|dev
comma
op_amp
id|rx
comma
id|pool
)paren
)paren
(brace
singleline_comment|// success
id|PRINTD
(paren
id|DBG_SKB
op_or
id|DBG_POOL
comma
l_string|&quot;recycled skb for pool %hu&quot;
comma
id|pool
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|// just do what the ATM layer would have done
id|dev_kfree_skb_any
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/********** Proc File Output **********/
DECL|function|amb_proc_read
r_static
r_int
id|amb_proc_read
(paren
r_struct
id|atm_dev
op_star
id|atm_dev
comma
id|loff_t
op_star
id|pos
comma
r_char
op_star
id|page
)paren
(brace
id|amb_dev
op_star
id|dev
op_assign
id|AMB_DEV
(paren
id|atm_dev
)paren
suffix:semicolon
r_int
id|left
op_assign
op_star
id|pos
suffix:semicolon
r_int
r_char
id|pool
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
comma
l_string|&quot;amb_proc_read&quot;
)paren
suffix:semicolon
multiline_comment|/* more diagnostics here? */
r_if
c_cond
(paren
op_logical_neg
id|left
op_decrement
)paren
(brace
id|amb_stats
op_star
id|s
op_assign
op_amp
id|dev-&gt;stats
suffix:semicolon
r_return
id|sprintf
(paren
id|page
comma
l_string|&quot;frames: TX OK %lu, RX OK %lu, RX bad %lu &quot;
l_string|&quot;(CRC %lu, long %lu, aborted %lu, unused %lu).&bslash;n&quot;
comma
id|s-&gt;tx_ok
comma
id|s-&gt;rx.ok
comma
id|s-&gt;rx.error
comma
id|s-&gt;rx.badcrc
comma
id|s-&gt;rx.toolong
comma
id|s-&gt;rx.aborted
comma
id|s-&gt;rx.unused
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|left
op_decrement
)paren
(brace
id|amb_cq
op_star
id|c
op_assign
op_amp
id|dev-&gt;cq
suffix:semicolon
r_return
id|sprintf
(paren
id|page
comma
l_string|&quot;cmd queue [cur/hi/max]: %u/%u/%u. &quot;
comma
id|c-&gt;pending
comma
id|c-&gt;high
comma
id|c-&gt;maximum
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|left
op_decrement
)paren
(brace
id|amb_txq
op_star
id|t
op_assign
op_amp
id|dev-&gt;txq
suffix:semicolon
r_return
id|sprintf
(paren
id|page
comma
l_string|&quot;TX queue [cur/max high full]: %u/%u %u %u.&bslash;n&quot;
comma
id|t-&gt;pending
comma
id|t-&gt;maximum
comma
id|t-&gt;high
comma
id|t-&gt;filled
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|left
op_decrement
)paren
(brace
r_int
r_int
id|count
op_assign
id|sprintf
(paren
id|page
comma
l_string|&quot;RX queues [cur/max/req low empty]:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pool
op_assign
l_int|0
suffix:semicolon
id|pool
OL
id|NUM_RX_POOLS
suffix:semicolon
op_increment
id|pool
)paren
(brace
id|amb_rxq
op_star
id|r
op_assign
op_amp
id|dev-&gt;rxq
(braket
id|pool
)braket
suffix:semicolon
id|count
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|count
comma
l_string|&quot; %u/%u/%u %u %u&quot;
comma
id|r-&gt;pending
comma
id|r-&gt;maximum
comma
id|r-&gt;buffers_wanted
comma
id|r-&gt;low
comma
id|r-&gt;emptied
)paren
suffix:semicolon
)brace
id|count
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|count
comma
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|left
op_decrement
)paren
(brace
r_int
r_int
id|count
op_assign
id|sprintf
(paren
id|page
comma
l_string|&quot;RX buffer sizes:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pool
op_assign
l_int|0
suffix:semicolon
id|pool
OL
id|NUM_RX_POOLS
suffix:semicolon
op_increment
id|pool
)paren
(brace
id|amb_rxq
op_star
id|r
op_assign
op_amp
id|dev-&gt;rxq
(braket
id|pool
)braket
suffix:semicolon
id|count
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|count
comma
l_string|&quot; %u&quot;
comma
id|r-&gt;buffer_size
)paren
suffix:semicolon
)brace
id|count
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|count
comma
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
id|left
op_decrement
)paren
(brace
singleline_comment|// suni block etc?
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/********** Operation Structure **********/
DECL|variable|amb_ops
r_static
r_const
r_struct
id|atmdev_ops
id|amb_ops
op_assign
(brace
id|open
suffix:colon
id|amb_open
comma
id|close
suffix:colon
id|amb_close
comma
id|send
suffix:colon
id|amb_send
comma
id|sg_send
suffix:colon
id|amb_sg_send
comma
id|proc_read
suffix:colon
id|amb_proc_read
comma
id|owner
suffix:colon
id|THIS_MODULE
comma
)brace
suffix:semicolon
multiline_comment|/********** housekeeping **********/
DECL|function|set_timer
r_static
r_inline
r_void
id|set_timer
(paren
r_struct
id|timer_list
op_star
id|timer
comma
r_int
r_int
id|delay
)paren
(brace
id|timer-&gt;expires
op_assign
id|jiffies
op_plus
id|delay
suffix:semicolon
id|add_timer
(paren
id|timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|do_housekeeping
r_static
r_void
id|do_housekeeping
(paren
r_int
r_int
id|arg
)paren
(brace
id|amb_dev
op_star
id|dev
op_assign
id|amb_devs
suffix:semicolon
singleline_comment|// data is set to zero at module unload
(paren
r_void
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|housekeeping.data
)paren
(brace
r_while
c_loop
(paren
id|dev
)paren
(brace
singleline_comment|// could collect device-specific (not driver/atm-linux) stats here
singleline_comment|// last resort refill once every ten seconds
id|fill_rx_pools
(paren
id|dev
)paren
suffix:semicolon
id|dev
op_assign
id|dev-&gt;prev
suffix:semicolon
)brace
id|set_timer
(paren
op_amp
id|housekeeping
comma
l_int|10
op_star
id|HZ
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/********** creation of communication queues **********/
DECL|function|create_queues
r_static
r_int
id|__init
id|create_queues
(paren
id|amb_dev
op_star
id|dev
comma
r_int
r_int
id|cmds
comma
r_int
r_int
id|txs
comma
r_int
r_int
op_star
id|rxs
comma
r_int
r_int
op_star
id|rx_buffer_sizes
)paren
(brace
r_int
r_char
id|pool
suffix:semicolon
r_int
id|total
op_assign
l_int|0
suffix:semicolon
r_void
op_star
id|memory
suffix:semicolon
r_void
op_star
id|limit
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
comma
l_string|&quot;create_queues %p&quot;
comma
id|dev
)paren
suffix:semicolon
id|total
op_add_assign
id|cmds
op_star
r_sizeof
(paren
id|command
)paren
suffix:semicolon
id|total
op_add_assign
id|txs
op_star
(paren
r_sizeof
(paren
id|tx_in
)paren
op_plus
r_sizeof
(paren
id|tx_out
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pool
op_assign
l_int|0
suffix:semicolon
id|pool
OL
id|NUM_RX_POOLS
suffix:semicolon
op_increment
id|pool
)paren
id|total
op_add_assign
id|rxs
(braket
id|pool
)braket
op_star
(paren
r_sizeof
(paren
id|rx_in
)paren
op_plus
r_sizeof
(paren
id|rx_out
)paren
)paren
suffix:semicolon
id|memory
op_assign
id|kmalloc
(paren
id|total
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memory
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;could not allocate queues&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_area
(paren
id|memory
comma
id|total
)paren
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;queues allocated in nasty area&quot;
)paren
suffix:semicolon
id|kfree
(paren
id|memory
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|limit
op_assign
id|memory
op_plus
id|total
suffix:semicolon
id|PRINTD
(paren
id|DBG_INIT
comma
l_string|&quot;queues from %p to %p&quot;
comma
id|memory
comma
id|limit
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_CMD
comma
l_string|&quot;command queue at %p&quot;
comma
id|memory
)paren
suffix:semicolon
(brace
id|command
op_star
id|cmd
op_assign
id|memory
suffix:semicolon
id|amb_cq
op_star
id|cq
op_assign
op_amp
id|dev-&gt;cq
suffix:semicolon
id|cq-&gt;pending
op_assign
l_int|0
suffix:semicolon
id|cq-&gt;high
op_assign
l_int|0
suffix:semicolon
id|cq-&gt;maximum
op_assign
id|cmds
op_minus
l_int|1
suffix:semicolon
id|cq-&gt;ptrs.start
op_assign
id|cmd
suffix:semicolon
id|cq-&gt;ptrs.in
op_assign
id|cmd
suffix:semicolon
id|cq-&gt;ptrs.out
op_assign
id|cmd
suffix:semicolon
id|cq-&gt;ptrs.limit
op_assign
id|cmd
op_plus
id|cmds
suffix:semicolon
id|memory
op_assign
id|cq-&gt;ptrs.limit
suffix:semicolon
)brace
id|PRINTD
(paren
id|DBG_TX
comma
l_string|&quot;TX queue pair at %p&quot;
comma
id|memory
)paren
suffix:semicolon
(brace
id|tx_in
op_star
id|in
op_assign
id|memory
suffix:semicolon
id|tx_out
op_star
id|out
suffix:semicolon
id|amb_txq
op_star
id|txq
op_assign
op_amp
id|dev-&gt;txq
suffix:semicolon
id|txq-&gt;pending
op_assign
l_int|0
suffix:semicolon
id|txq-&gt;high
op_assign
l_int|0
suffix:semicolon
id|txq-&gt;filled
op_assign
l_int|0
suffix:semicolon
id|txq-&gt;maximum
op_assign
id|txs
op_minus
l_int|1
suffix:semicolon
id|txq-&gt;in.start
op_assign
id|in
suffix:semicolon
id|txq-&gt;in.ptr
op_assign
id|in
suffix:semicolon
id|txq-&gt;in.limit
op_assign
id|in
op_plus
id|txs
suffix:semicolon
id|memory
op_assign
id|txq-&gt;in.limit
suffix:semicolon
id|out
op_assign
id|memory
suffix:semicolon
id|txq-&gt;out.start
op_assign
id|out
suffix:semicolon
id|txq-&gt;out.ptr
op_assign
id|out
suffix:semicolon
id|txq-&gt;out.limit
op_assign
id|out
op_plus
id|txs
suffix:semicolon
id|memory
op_assign
id|txq-&gt;out.limit
suffix:semicolon
)brace
id|PRINTD
(paren
id|DBG_RX
comma
l_string|&quot;RX queue pairs at %p&quot;
comma
id|memory
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pool
op_assign
l_int|0
suffix:semicolon
id|pool
OL
id|NUM_RX_POOLS
suffix:semicolon
op_increment
id|pool
)paren
(brace
id|rx_in
op_star
id|in
op_assign
id|memory
suffix:semicolon
id|rx_out
op_star
id|out
suffix:semicolon
id|amb_rxq
op_star
id|rxq
op_assign
op_amp
id|dev-&gt;rxq
(braket
id|pool
)braket
suffix:semicolon
id|rxq-&gt;buffer_size
op_assign
id|rx_buffer_sizes
(braket
id|pool
)braket
suffix:semicolon
id|rxq-&gt;buffers_wanted
op_assign
l_int|0
suffix:semicolon
id|rxq-&gt;pending
op_assign
l_int|0
suffix:semicolon
id|rxq-&gt;low
op_assign
id|rxs
(braket
id|pool
)braket
op_minus
l_int|1
suffix:semicolon
id|rxq-&gt;emptied
op_assign
l_int|0
suffix:semicolon
id|rxq-&gt;maximum
op_assign
id|rxs
(braket
id|pool
)braket
op_minus
l_int|1
suffix:semicolon
id|rxq-&gt;in.start
op_assign
id|in
suffix:semicolon
id|rxq-&gt;in.ptr
op_assign
id|in
suffix:semicolon
id|rxq-&gt;in.limit
op_assign
id|in
op_plus
id|rxs
(braket
id|pool
)braket
suffix:semicolon
id|memory
op_assign
id|rxq-&gt;in.limit
suffix:semicolon
id|out
op_assign
id|memory
suffix:semicolon
id|rxq-&gt;out.start
op_assign
id|out
suffix:semicolon
id|rxq-&gt;out.ptr
op_assign
id|out
suffix:semicolon
id|rxq-&gt;out.limit
op_assign
id|out
op_plus
id|rxs
(braket
id|pool
)braket
suffix:semicolon
id|memory
op_assign
id|rxq-&gt;out.limit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memory
op_eq
id|limit
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;bad queue alloc %p != %p (tell maintainer)&quot;
comma
id|memory
comma
id|limit
)paren
suffix:semicolon
id|kfree
(paren
id|limit
op_minus
id|total
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
multiline_comment|/********** destruction of communication queues **********/
DECL|function|destroy_queues
r_static
r_void
id|destroy_queues
(paren
id|amb_dev
op_star
id|dev
)paren
(brace
singleline_comment|// all queues assumed empty
r_void
op_star
id|memory
op_assign
id|dev-&gt;cq.ptrs.start
suffix:semicolon
singleline_comment|// includes txq.in, txq.out, rxq[].in and rxq[].out
id|PRINTD
(paren
id|DBG_FLOW
comma
l_string|&quot;destroy_queues %p&quot;
comma
id|dev
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_INIT
comma
l_string|&quot;freeing queues at %p&quot;
comma
id|memory
)paren
suffix:semicolon
id|kfree
(paren
id|memory
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/********** basic loader commands and error handling **********/
DECL|function|do_loader_command
r_static
r_int
id|__init
id|do_loader_command
(paren
r_volatile
id|loader_block
op_star
id|lb
comma
r_const
id|amb_dev
op_star
id|dev
comma
id|loader_command
id|cmd
)paren
(brace
singleline_comment|// centisecond timeouts - guessing away here
r_int
r_int
id|command_timeouts
(braket
)braket
op_assign
(brace
(braket
id|host_memory_test
)braket
op_assign
l_int|15
comma
(braket
id|read_adapter_memory
)braket
op_assign
l_int|2
comma
(braket
id|write_adapter_memory
)braket
op_assign
l_int|2
comma
(braket
id|adapter_start
)braket
op_assign
l_int|50
comma
(braket
id|get_version_number
)braket
op_assign
l_int|10
comma
(braket
id|interrupt_host
)braket
op_assign
l_int|1
comma
(braket
id|flash_erase_sector
)braket
op_assign
l_int|1
comma
(braket
id|adap_download_block
)braket
op_assign
l_int|1
comma
(braket
id|adap_erase_flash
)braket
op_assign
l_int|1
comma
(braket
id|adap_run_in_iram
)braket
op_assign
l_int|1
comma
(braket
id|adap_end_download
)braket
op_assign
l_int|1
)brace
suffix:semicolon
r_int
r_int
id|command_successes
(braket
)braket
op_assign
(brace
(braket
id|host_memory_test
)braket
op_assign
id|COMMAND_PASSED_TEST
comma
(braket
id|read_adapter_memory
)braket
op_assign
id|COMMAND_READ_DATA_OK
comma
(braket
id|write_adapter_memory
)braket
op_assign
id|COMMAND_WRITE_DATA_OK
comma
(braket
id|adapter_start
)braket
op_assign
id|COMMAND_COMPLETE
comma
(braket
id|get_version_number
)braket
op_assign
id|COMMAND_COMPLETE
comma
(braket
id|interrupt_host
)braket
op_assign
id|COMMAND_COMPLETE
comma
(braket
id|flash_erase_sector
)braket
op_assign
id|COMMAND_COMPLETE
comma
(braket
id|adap_download_block
)braket
op_assign
id|COMMAND_COMPLETE
comma
(braket
id|adap_erase_flash
)braket
op_assign
id|COMMAND_COMPLETE
comma
(braket
id|adap_run_in_iram
)braket
op_assign
id|COMMAND_COMPLETE
comma
(braket
id|adap_end_download
)braket
op_assign
id|COMMAND_COMPLETE
)brace
suffix:semicolon
r_int
id|decode_loader_result
(paren
id|loader_command
id|cmd
comma
id|u32
id|result
)paren
(brace
r_int
id|res
suffix:semicolon
r_const
r_char
op_star
id|msg
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|command_successes
(braket
id|cmd
)braket
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|result
)paren
(brace
r_case
id|BAD_COMMAND
suffix:colon
id|res
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|msg
op_assign
l_string|&quot;bad command&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMMAND_IN_PROGRESS
suffix:colon
id|res
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
id|msg
op_assign
l_string|&quot;command in progress&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMMAND_PASSED_TEST
suffix:colon
id|res
op_assign
l_int|0
suffix:semicolon
id|msg
op_assign
l_string|&quot;command passed test&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMMAND_FAILED_TEST
suffix:colon
id|res
op_assign
op_minus
id|EIO
suffix:semicolon
id|msg
op_assign
l_string|&quot;command failed test&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMMAND_READ_DATA_OK
suffix:colon
id|res
op_assign
l_int|0
suffix:semicolon
id|msg
op_assign
l_string|&quot;command read data ok&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMMAND_READ_BAD_ADDRESS
suffix:colon
id|res
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|msg
op_assign
l_string|&quot;command read bad address&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMMAND_WRITE_DATA_OK
suffix:colon
id|res
op_assign
l_int|0
suffix:semicolon
id|msg
op_assign
l_string|&quot;command write data ok&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMMAND_WRITE_BAD_ADDRESS
suffix:colon
id|res
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|msg
op_assign
l_string|&quot;command write bad address&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMMAND_WRITE_FLASH_FAILURE
suffix:colon
id|res
op_assign
op_minus
id|EIO
suffix:semicolon
id|msg
op_assign
l_string|&quot;command write flash failure&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMMAND_COMPLETE
suffix:colon
id|res
op_assign
l_int|0
suffix:semicolon
id|msg
op_assign
l_string|&quot;command complete&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMMAND_FLASH_ERASE_FAILURE
suffix:colon
id|res
op_assign
op_minus
id|EIO
suffix:semicolon
id|msg
op_assign
l_string|&quot;command flash erase failure&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMMAND_WRITE_BAD_DATA
suffix:colon
id|res
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|msg
op_assign
l_string|&quot;command write bad data&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|res
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|msg
op_assign
l_string|&quot;unknown error&quot;
suffix:semicolon
id|PRINTD
(paren
id|DBG_LOAD
op_or
id|DBG_ERR
comma
l_string|&quot;decode_loader_result got %d=%x !&quot;
comma
id|result
comma
id|result
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;%s&quot;
comma
id|msg
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
r_int
r_int
id|timeout
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_LOAD
comma
l_string|&quot;do_loader_command&quot;
)paren
suffix:semicolon
multiline_comment|/* do a command&n;     &n;     Set the return value to zero, set the command type and set the&n;     valid entry to the right magic value. The payload is already&n;     correctly byte-ordered so we leave it alone. Hit the doorbell&n;     with the bus address of this structure.&n;     &n;  */
id|lb-&gt;result
op_assign
l_int|0
suffix:semicolon
id|lb-&gt;command
op_assign
id|cpu_to_be32
(paren
id|cmd
)paren
suffix:semicolon
id|lb-&gt;valid
op_assign
id|cpu_to_be32
(paren
id|DMA_VALID
)paren
suffix:semicolon
singleline_comment|// dump_registers (dev);
singleline_comment|// dump_loader_block (lb);
id|wr_mem
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|doorbell
)paren
comma
id|virt_to_bus
(paren
id|lb
)paren
op_amp
op_complement
id|onegigmask
)paren
suffix:semicolon
id|timeout
op_assign
id|command_timeouts
(braket
id|cmd
)braket
op_star
id|HZ
op_div
l_int|100
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|lb-&gt;result
op_logical_or
id|lb-&gt;result
op_eq
id|cpu_to_be32
(paren
id|COMMAND_IN_PROGRESS
)paren
)paren
r_if
c_cond
(paren
id|timeout
)paren
(brace
id|timeout
op_assign
id|schedule_timeout
(paren
id|timeout
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_LOAD
op_or
id|DBG_ERR
comma
l_string|&quot;command %d timed out&quot;
comma
id|cmd
)paren
suffix:semicolon
id|dump_registers
(paren
id|dev
)paren
suffix:semicolon
id|dump_loader_block
(paren
id|lb
)paren
suffix:semicolon
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|adapter_start
)paren
(brace
singleline_comment|// wait for start command to acknowledge...
id|timeout
op_assign
id|HZ
op_div
l_int|10
suffix:semicolon
r_while
c_loop
(paren
id|rd_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|doorbell
)paren
)paren
)paren
r_if
c_cond
(paren
id|timeout
)paren
(brace
id|timeout
op_assign
id|schedule_timeout
(paren
id|timeout
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_LOAD
op_or
id|DBG_ERR
comma
l_string|&quot;start command did not clear doorbell, res=%08x&quot;
comma
id|be32_to_cpu
(paren
id|lb-&gt;result
)paren
)paren
suffix:semicolon
id|dump_registers
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_return
id|decode_loader_result
(paren
id|cmd
comma
id|be32_to_cpu
(paren
id|lb-&gt;result
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* loader: determine loader version */
DECL|function|get_loader_version
r_static
r_int
id|__init
id|get_loader_version
(paren
id|loader_block
op_star
id|lb
comma
r_const
id|amb_dev
op_star
id|dev
comma
id|u32
op_star
id|version
)paren
(brace
r_int
id|res
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_LOAD
comma
l_string|&quot;get_loader_version&quot;
)paren
suffix:semicolon
id|res
op_assign
id|do_loader_command
(paren
id|lb
comma
id|dev
comma
id|get_version_number
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_return
id|res
suffix:semicolon
r_if
c_cond
(paren
id|version
)paren
op_star
id|version
op_assign
id|be32_to_cpu
(paren
id|lb-&gt;payload.version
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* loader: write memory data blocks */
DECL|function|loader_write
r_static
r_int
id|__init
id|loader_write
(paren
id|loader_block
op_star
id|lb
comma
r_const
id|amb_dev
op_star
id|dev
comma
r_const
id|u32
op_star
id|data
comma
id|u32
id|address
comma
r_int
r_int
id|count
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|transfer_block
op_star
id|tb
op_assign
op_amp
id|lb-&gt;payload.transfer
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_LOAD
comma
l_string|&quot;loader_write&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|MAX_TRANSFER_DATA
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|tb-&gt;address
op_assign
id|cpu_to_be32
(paren
id|address
)paren
suffix:semicolon
id|tb-&gt;count
op_assign
id|cpu_to_be32
(paren
id|count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
op_increment
id|i
)paren
id|tb-&gt;data
(braket
id|i
)braket
op_assign
id|cpu_to_be32
(paren
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
id|do_loader_command
(paren
id|lb
comma
id|dev
comma
id|write_adapter_memory
)paren
suffix:semicolon
)brace
multiline_comment|/* loader: verify memory data blocks */
DECL|function|loader_verify
r_static
r_int
id|__init
id|loader_verify
(paren
id|loader_block
op_star
id|lb
comma
r_const
id|amb_dev
op_star
id|dev
comma
r_const
id|u32
op_star
id|data
comma
id|u32
id|address
comma
r_int
r_int
id|count
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|transfer_block
op_star
id|tb
op_assign
op_amp
id|lb-&gt;payload.transfer
suffix:semicolon
r_int
id|res
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_LOAD
comma
l_string|&quot;loader_verify&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|MAX_TRANSFER_DATA
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|tb-&gt;address
op_assign
id|cpu_to_be32
(paren
id|address
)paren
suffix:semicolon
id|tb-&gt;count
op_assign
id|cpu_to_be32
(paren
id|count
)paren
suffix:semicolon
id|res
op_assign
id|do_loader_command
(paren
id|lb
comma
id|dev
comma
id|read_adapter_memory
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|tb-&gt;data
(braket
id|i
)braket
op_ne
id|cpu_to_be32
(paren
id|data
(braket
id|i
)braket
)paren
)paren
(brace
id|res
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* loader: start microcode */
DECL|function|loader_start
r_static
r_int
id|__init
id|loader_start
(paren
id|loader_block
op_star
id|lb
comma
r_const
id|amb_dev
op_star
id|dev
comma
id|u32
id|address
)paren
(brace
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_LOAD
comma
l_string|&quot;loader_start&quot;
)paren
suffix:semicolon
id|lb-&gt;payload.start
op_assign
id|cpu_to_be32
(paren
id|address
)paren
suffix:semicolon
r_return
id|do_loader_command
(paren
id|lb
comma
id|dev
comma
id|adapter_start
)paren
suffix:semicolon
)brace
multiline_comment|/********** reset card **********/
DECL|function|amb_reset
r_static
r_int
id|amb_reset
(paren
id|amb_dev
op_star
id|dev
comma
r_int
id|diags
)paren
(brace
id|u32
id|word
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_LOAD
comma
l_string|&quot;amb_reset&quot;
)paren
suffix:semicolon
id|word
op_assign
id|rd_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|reset_control
)paren
)paren
suffix:semicolon
singleline_comment|// put card into reset state
id|wr_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|reset_control
)paren
comma
id|word
op_or
id|AMB_RESET_BITS
)paren
suffix:semicolon
singleline_comment|// wait a short while
id|udelay
(paren
l_int|10
)paren
suffix:semicolon
macro_line|#if 1
singleline_comment|// put card into known good state
id|wr_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|interrupt_control
)paren
comma
id|AMB_DOORBELL_BITS
)paren
suffix:semicolon
singleline_comment|// clear all interrupts just in case
id|wr_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|interrupt
)paren
comma
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
singleline_comment|// clear self-test done flag
id|wr_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|mb.loader.ready
)paren
comma
l_int|0
)paren
suffix:semicolon
singleline_comment|// take card out of reset state
id|wr_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|reset_control
)paren
comma
id|word
op_amp
op_complement
id|AMB_RESET_BITS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diags
)paren
(brace
r_int
r_int
id|timeout
suffix:semicolon
singleline_comment|// 4.2 second wait
id|timeout
op_assign
id|HZ
op_star
l_int|42
op_div
l_int|10
suffix:semicolon
r_while
c_loop
(paren
id|timeout
)paren
id|timeout
op_assign
id|schedule_timeout
(paren
id|timeout
)paren
suffix:semicolon
singleline_comment|// half second time-out
id|timeout
op_assign
id|HZ
op_div
l_int|2
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|rd_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|mb.loader.ready
)paren
)paren
)paren
r_if
c_cond
(paren
id|timeout
)paren
(brace
id|timeout
op_assign
id|schedule_timeout
(paren
id|timeout
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_LOAD
op_or
id|DBG_ERR
comma
l_string|&quot;reset timed out&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
singleline_comment|// get results of self-test
singleline_comment|// XXX double check byte-order
id|word
op_assign
id|rd_mem
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|mb.loader.result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|word
op_amp
id|SELF_TEST_FAILURE
)paren
(brace
r_void
id|sf
(paren
r_const
r_char
op_star
id|msg
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;self-test failed: %s&quot;
comma
id|msg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|word
op_amp
id|GPINT_TST_FAILURE
)paren
id|sf
(paren
l_string|&quot;interrupt&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|word
op_amp
id|SUNI_DATA_PATTERN_FAILURE
)paren
id|sf
(paren
l_string|&quot;SUNI data pattern&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|word
op_amp
id|SUNI_DATA_BITS_FAILURE
)paren
id|sf
(paren
l_string|&quot;SUNI data bits&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|word
op_amp
id|SUNI_UTOPIA_FAILURE
)paren
id|sf
(paren
l_string|&quot;SUNI UTOPIA interface&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|word
op_amp
id|SUNI_FIFO_FAILURE
)paren
id|sf
(paren
l_string|&quot;SUNI cell buffer FIFO&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|word
op_amp
id|SRAM_FAILURE
)paren
id|sf
(paren
l_string|&quot;bad SRAM&quot;
)paren
suffix:semicolon
singleline_comment|// better return value?
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/********** transfer and start the microcode **********/
DECL|function|ucode_init
r_static
r_int
id|__init
id|ucode_init
(paren
id|loader_block
op_star
id|lb
comma
id|amb_dev
op_star
id|dev
)paren
(brace
r_int
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|total
op_assign
l_int|0
suffix:semicolon
r_const
id|u32
op_star
id|pointer
op_assign
id|ucode_data
suffix:semicolon
id|u32
id|address
suffix:semicolon
r_int
r_int
id|count
suffix:semicolon
r_int
id|res
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_LOAD
comma
l_string|&quot;ucode_init&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|address
op_assign
id|ucode_regions
(braket
id|i
)braket
dot
id|start
comma
id|count
op_assign
id|ucode_regions
(braket
id|i
)braket
dot
id|count
)paren
(brace
id|PRINTD
(paren
id|DBG_LOAD
comma
l_string|&quot;starting region (%x, %u)&quot;
comma
id|address
comma
id|count
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
r_int
r_int
id|words
suffix:semicolon
r_if
c_cond
(paren
id|count
op_le
id|MAX_TRANSFER_DATA
)paren
id|words
op_assign
id|count
suffix:semicolon
r_else
id|words
op_assign
id|MAX_TRANSFER_DATA
suffix:semicolon
id|total
op_add_assign
id|words
suffix:semicolon
id|res
op_assign
id|loader_write
(paren
id|lb
comma
id|dev
comma
id|pointer
comma
id|address
comma
id|words
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_return
id|res
suffix:semicolon
id|res
op_assign
id|loader_verify
(paren
id|lb
comma
id|dev
comma
id|pointer
comma
id|address
comma
id|words
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_return
id|res
suffix:semicolon
id|count
op_sub_assign
id|words
suffix:semicolon
id|address
op_add_assign
r_sizeof
(paren
id|u32
)paren
op_star
id|words
suffix:semicolon
id|pointer
op_add_assign
id|words
suffix:semicolon
)brace
id|i
op_add_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pointer
op_eq
l_int|0xdeadbeef
)paren
(brace
r_return
id|loader_start
(paren
id|lb
comma
id|dev
comma
id|ucode_start
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// cast needed as there is no %? for pointer differnces
id|PRINTD
(paren
id|DBG_LOAD
op_or
id|DBG_ERR
comma
l_string|&quot;offset=%li, *pointer=%x, address=%x, total=%u&quot;
comma
(paren
r_int
)paren
(paren
id|pointer
op_minus
id|ucode_data
)paren
comma
op_star
id|pointer
comma
id|address
comma
id|total
)paren
suffix:semicolon
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;incorrect microcode data&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
multiline_comment|/********** give adapter parameters **********/
DECL|function|amb_talk
r_static
r_int
id|__init
id|amb_talk
(paren
id|amb_dev
op_star
id|dev
)paren
(brace
id|adap_talk_block
id|a
suffix:semicolon
r_int
r_char
id|pool
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|u32
id|x
(paren
r_void
op_star
id|addr
)paren
(brace
r_return
id|cpu_to_be32
(paren
id|virt_to_bus
(paren
id|addr
)paren
)paren
suffix:semicolon
)brace
id|PRINTD
(paren
id|DBG_FLOW
comma
l_string|&quot;amb_talk %p&quot;
comma
id|dev
)paren
suffix:semicolon
id|a.command_start
op_assign
id|x
(paren
id|dev-&gt;cq.ptrs.start
)paren
suffix:semicolon
id|a.command_end
op_assign
id|x
(paren
id|dev-&gt;cq.ptrs.limit
)paren
suffix:semicolon
id|a.tx_start
op_assign
id|x
(paren
id|dev-&gt;txq.in.start
)paren
suffix:semicolon
id|a.tx_end
op_assign
id|x
(paren
id|dev-&gt;txq.in.limit
)paren
suffix:semicolon
id|a.txcom_start
op_assign
id|x
(paren
id|dev-&gt;txq.out.start
)paren
suffix:semicolon
id|a.txcom_end
op_assign
id|x
(paren
id|dev-&gt;txq.out.limit
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pool
op_assign
l_int|0
suffix:semicolon
id|pool
OL
id|NUM_RX_POOLS
suffix:semicolon
op_increment
id|pool
)paren
(brace
singleline_comment|// the other &quot;a&quot; items are set up by the adapter
id|a.rec_struct
(braket
id|pool
)braket
dot
id|buffer_start
op_assign
id|x
(paren
id|dev-&gt;rxq
(braket
id|pool
)braket
dot
id|in.start
)paren
suffix:semicolon
id|a.rec_struct
(braket
id|pool
)braket
dot
id|buffer_end
op_assign
id|x
(paren
id|dev-&gt;rxq
(braket
id|pool
)braket
dot
id|in.limit
)paren
suffix:semicolon
id|a.rec_struct
(braket
id|pool
)braket
dot
id|rx_start
op_assign
id|x
(paren
id|dev-&gt;rxq
(braket
id|pool
)braket
dot
id|out.start
)paren
suffix:semicolon
id|a.rec_struct
(braket
id|pool
)braket
dot
id|rx_end
op_assign
id|x
(paren
id|dev-&gt;rxq
(braket
id|pool
)braket
dot
id|out.limit
)paren
suffix:semicolon
id|a.rec_struct
(braket
id|pool
)braket
dot
id|buffer_size
op_assign
id|cpu_to_be32
(paren
id|dev-&gt;rxq
(braket
id|pool
)braket
dot
id|buffer_size
)paren
suffix:semicolon
)brace
macro_line|#ifdef AMB_NEW_MICROCODE
singleline_comment|// disable fast PLX prefetching
id|a.init_flags
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
singleline_comment|// pass the structure
id|wr_mem
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|doorbell
)paren
comma
id|virt_to_bus
(paren
op_amp
id|a
)paren
)paren
suffix:semicolon
singleline_comment|// 2.2 second wait (must not touch doorbell during 2 second DMA test)
id|timeout
op_assign
id|HZ
op_star
l_int|22
op_div
l_int|10
suffix:semicolon
r_while
c_loop
(paren
id|timeout
)paren
id|timeout
op_assign
id|schedule_timeout
(paren
id|timeout
)paren
suffix:semicolon
singleline_comment|// give the adapter another half second?
id|timeout
op_assign
id|HZ
op_div
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|rd_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|doorbell
)paren
)paren
)paren
r_if
c_cond
(paren
id|timeout
)paren
(brace
id|timeout
op_assign
id|schedule_timeout
(paren
id|timeout
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_INIT
op_or
id|DBG_ERR
comma
l_string|&quot;adapter init timed out&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// get microcode version
DECL|function|amb_ucode_version
r_static
r_void
id|__init
id|amb_ucode_version
(paren
id|amb_dev
op_star
id|dev
)paren
(brace
id|u32
id|major
suffix:semicolon
id|u32
id|minor
suffix:semicolon
id|command
id|cmd
suffix:semicolon
id|cmd.request
op_assign
id|cpu_to_be32
(paren
id|SRB_GET_VERSION
)paren
suffix:semicolon
r_while
c_loop
(paren
id|command_do
(paren
id|dev
comma
op_amp
id|cmd
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|major
op_assign
id|be32_to_cpu
(paren
id|cmd.args.version.major
)paren
suffix:semicolon
id|minor
op_assign
id|be32_to_cpu
(paren
id|cmd.args.version.minor
)paren
suffix:semicolon
id|PRINTK
(paren
id|KERN_INFO
comma
l_string|&quot;microcode version is %u.%u&quot;
comma
id|major
comma
id|minor
)paren
suffix:semicolon
)brace
singleline_comment|// get end station address
DECL|function|amb_esi
r_static
r_void
id|__init
id|amb_esi
(paren
id|amb_dev
op_star
id|dev
comma
id|u8
op_star
id|esi
)paren
(brace
id|u32
id|lower4
suffix:semicolon
id|u16
id|upper2
suffix:semicolon
id|command
id|cmd
suffix:semicolon
singleline_comment|// swap bits within byte to get Ethernet ordering
id|u8
id|bit_swap
(paren
id|u8
id|byte
)paren
(brace
r_const
id|u8
id|swap
(braket
)braket
op_assign
(brace
l_int|0x0
comma
l_int|0x8
comma
l_int|0x4
comma
l_int|0xc
comma
l_int|0x2
comma
l_int|0xa
comma
l_int|0x6
comma
l_int|0xe
comma
l_int|0x1
comma
l_int|0x9
comma
l_int|0x5
comma
l_int|0xd
comma
l_int|0x3
comma
l_int|0xb
comma
l_int|0x7
comma
l_int|0xf
)brace
suffix:semicolon
r_return
(paren
(paren
id|swap
(braket
id|byte
op_amp
l_int|0xf
)braket
op_lshift
l_int|4
)paren
op_or
id|swap
(braket
id|byte
op_rshift
l_int|4
)braket
)paren
suffix:semicolon
)brace
id|cmd.request
op_assign
id|cpu_to_be32
(paren
id|SRB_GET_BIA
)paren
suffix:semicolon
r_while
c_loop
(paren
id|command_do
(paren
id|dev
comma
op_amp
id|cmd
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|lower4
op_assign
id|be32_to_cpu
(paren
id|cmd.args.bia.lower4
)paren
suffix:semicolon
id|upper2
op_assign
id|be32_to_cpu
(paren
id|cmd.args.bia.upper2
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_LOAD
comma
l_string|&quot;BIA: lower4: %08x, upper2 %04x&quot;
comma
id|lower4
comma
id|upper2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|esi
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|PRINTDB
(paren
id|DBG_INIT
comma
l_string|&quot;ESI:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ESI_LEN
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|4
)paren
id|esi
(braket
id|i
)braket
op_assign
id|bit_swap
(paren
id|lower4
op_rshift
(paren
l_int|8
op_star
id|i
)paren
)paren
suffix:semicolon
r_else
id|esi
(braket
id|i
)braket
op_assign
id|bit_swap
(paren
id|upper2
op_rshift
(paren
l_int|8
op_star
(paren
id|i
op_minus
l_int|4
)paren
)paren
)paren
suffix:semicolon
id|PRINTDM
(paren
id|DBG_INIT
comma
l_string|&quot; %02x&quot;
comma
id|esi
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|PRINTDE
(paren
id|DBG_INIT
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|amb_init
r_static
r_int
id|__init
id|amb_init
(paren
id|amb_dev
op_star
id|dev
)paren
(brace
id|loader_block
id|lb
suffix:semicolon
r_void
id|fixup_plx_window
(paren
r_void
)paren
(brace
singleline_comment|// fix up the PLX-mapped window base address to match the block
r_int
r_int
id|blb
suffix:semicolon
id|u32
id|mapreg
suffix:semicolon
id|blb
op_assign
id|virt_to_bus
(paren
op_amp
id|lb
)paren
suffix:semicolon
singleline_comment|// the kernel stack had better not ever cross a 1Gb boundary!
id|mapreg
op_assign
id|rd_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|stuff
(braket
l_int|10
)braket
)paren
)paren
suffix:semicolon
id|mapreg
op_and_assign
op_complement
id|onegigmask
suffix:semicolon
id|mapreg
op_or_assign
id|blb
op_amp
id|onegigmask
suffix:semicolon
id|wr_plain
(paren
id|dev
comma
m_offsetof
(paren
id|amb_mem
comma
id|stuff
(braket
l_int|10
)braket
)paren
comma
id|mapreg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|u32
id|version
suffix:semicolon
r_if
c_cond
(paren
id|amb_reset
(paren
id|dev
comma
l_int|1
)paren
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;card reset failed!&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|fixup_plx_window
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_loader_version
(paren
op_amp
id|lb
comma
id|dev
comma
op_amp
id|version
)paren
)paren
(brace
id|PRINTK
(paren
id|KERN_INFO
comma
l_string|&quot;failed to get loader version&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTK
(paren
id|KERN_INFO
comma
l_string|&quot;loader version is %08x&quot;
comma
id|version
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ucode_init
(paren
op_amp
id|lb
comma
id|dev
)paren
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;microcode failure&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|create_queues
(paren
id|dev
comma
id|cmds
comma
id|txs
comma
id|rxs
comma
id|rxs_bs
)paren
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;failed to get memory for queues&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|amb_talk
(paren
id|dev
)paren
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;adapter did not accept queues&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|amb_ucode_version
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* amb_talk */
id|destroy_queues
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* create_queues, ucode_init */
id|amb_reset
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* get_loader_version */
)brace
multiline_comment|/* amb_reset */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|amb_probe
r_static
r_int
id|__init
id|amb_probe
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|pci_dev
suffix:semicolon
r_int
id|devs
suffix:semicolon
r_void
id|do_pci_device
(paren
r_void
)paren
(brace
id|amb_dev
op_star
id|dev
suffix:semicolon
singleline_comment|// read resources from PCI configuration space
id|u8
id|irq
op_assign
id|pci_dev-&gt;irq
suffix:semicolon
id|u32
op_star
id|membase
op_assign
id|bus_to_virt
(paren
id|pci_resource_start
(paren
id|pci_dev
comma
l_int|0
)paren
)paren
suffix:semicolon
id|u32
id|iobase
op_assign
id|pci_resource_start
(paren
id|pci_dev
comma
l_int|1
)paren
suffix:semicolon
r_void
id|setup_dev
(paren
r_void
)paren
(brace
r_int
r_char
id|pool
suffix:semicolon
id|memset
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
id|amb_dev
)paren
)paren
suffix:semicolon
singleline_comment|// set up known dev items straight away
id|dev-&gt;pci_dev
op_assign
id|pci_dev
suffix:semicolon
id|dev-&gt;iobase
op_assign
id|iobase
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
id|dev-&gt;membase
op_assign
id|membase
suffix:semicolon
singleline_comment|// flags (currently only dead)
id|dev-&gt;flags
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Allocate cell rates (fibre)
singleline_comment|// ATM_OC3_PCR = 1555200000/8/270*260/53 - 29/53
singleline_comment|// to be really pedantic, this should be ATM_OC3c_PCR
id|dev-&gt;tx_avail
op_assign
id|ATM_OC3_PCR
suffix:semicolon
id|dev-&gt;rx_avail
op_assign
id|ATM_OC3_PCR
suffix:semicolon
macro_line|#ifdef FILL_RX_POOLS_IN_BH
singleline_comment|// initialise bottom half
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dev-&gt;bh.list
)paren
suffix:semicolon
id|dev-&gt;bh.sync
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;bh.routine
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|fill_rx_pools
suffix:semicolon
id|dev-&gt;bh.data
op_assign
id|dev
suffix:semicolon
macro_line|#endif
singleline_comment|// semaphore for txer/rxer modifications - we cannot use a
singleline_comment|// spinlock as the critical region needs to switch processes
id|init_MUTEX
(paren
op_amp
id|dev-&gt;vcc_sf
)paren
suffix:semicolon
singleline_comment|// queue manipulation spinlocks; we want atomic reads and
singleline_comment|// writes to the queue descriptors (handles IRQ and SMP)
singleline_comment|// consider replacing &quot;int pending&quot; -&gt; &quot;atomic_t available&quot;
singleline_comment|// =&gt; problem related to who gets to move queue pointers
id|spin_lock_init
(paren
op_amp
id|dev-&gt;cq.lock
)paren
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|dev-&gt;txq.lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pool
op_assign
l_int|0
suffix:semicolon
id|pool
OL
id|NUM_RX_POOLS
suffix:semicolon
op_increment
id|pool
)paren
id|spin_lock_init
(paren
op_amp
id|dev-&gt;rxq
(braket
id|pool
)braket
dot
id|lock
)paren
suffix:semicolon
)brace
r_void
id|setup_pci_dev
(paren
r_void
)paren
(brace
r_int
r_char
id|lat
suffix:semicolon
multiline_comment|/* XXX check return value */
id|pci_enable_device
(paren
id|pci_dev
)paren
suffix:semicolon
singleline_comment|// enable bus master accesses
id|pci_set_master
(paren
id|pci_dev
)paren
suffix:semicolon
singleline_comment|// frobnicate latency (upwards, usually)
id|pci_read_config_byte
(paren
id|pci_dev
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|lat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_lat
)paren
(brace
id|PRINTD
(paren
id|DBG_INIT
comma
l_string|&quot;%s PCI latency timer from %hu to %hu&quot;
comma
l_string|&quot;changing&quot;
comma
id|lat
comma
id|pci_lat
)paren
suffix:semicolon
id|pci_write_config_byte
(paren
id|pci_dev
comma
id|PCI_LATENCY_TIMER
comma
id|pci_lat
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lat
OL
id|MIN_PCI_LATENCY
)paren
(brace
id|PRINTK
(paren
id|KERN_INFO
comma
l_string|&quot;%s PCI latency timer from %hu to %hu&quot;
comma
l_string|&quot;increasing&quot;
comma
id|lat
comma
id|MIN_PCI_LATENCY
)paren
suffix:semicolon
id|pci_write_config_byte
(paren
id|pci_dev
comma
id|PCI_LATENCY_TIMER
comma
id|MIN_PCI_LATENCY
)paren
suffix:semicolon
)brace
)brace
id|PRINTD
(paren
id|DBG_INFO
comma
l_string|&quot;found Madge ATM adapter (amb) at&quot;
l_string|&quot; IO %x, IRQ %u, MEM %p&quot;
comma
id|iobase
comma
id|irq
comma
id|membase
)paren
suffix:semicolon
singleline_comment|// check IO region
r_if
c_cond
(paren
id|check_region
(paren
id|iobase
comma
id|AMB_EXTENT
)paren
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;IO range already in use!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|amb_dev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
singleline_comment|// perhaps we should be nice: deregister all adapters and abort?
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;out of memory!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|setup_dev
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amb_init
(paren
id|dev
)paren
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;adapter initialisation failure&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|setup_pci_dev
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// grab (but share) IRQ and install handler
r_if
c_cond
(paren
id|request_irq
(paren
id|irq
comma
id|interrupt_handler
comma
id|SA_SHIRQ
comma
id|DEV_LABEL
comma
id|dev
)paren
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;request IRQ failed!&quot;
)paren
suffix:semicolon
singleline_comment|// free_irq is at &quot;endif&quot;
)brace
r_else
(brace
singleline_comment|// reserve IO region
id|request_region
(paren
id|iobase
comma
id|AMB_EXTENT
comma
id|DEV_LABEL
)paren
suffix:semicolon
id|dev-&gt;atm_dev
op_assign
id|atm_dev_register
(paren
id|DEV_LABEL
comma
op_amp
id|amb_ops
comma
op_minus
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;atm_dev
)paren
(brace
id|PRINTD
(paren
id|DBG_ERR
comma
l_string|&quot;failed to register Madge ATM adapter&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_INFO
comma
l_string|&quot;registered Madge ATM adapter (no. %d) (%p) at %p&quot;
comma
id|dev-&gt;atm_dev-&gt;number
comma
id|dev
comma
id|dev-&gt;atm_dev
)paren
suffix:semicolon
id|dev-&gt;atm_dev-&gt;dev_data
op_assign
(paren
r_void
op_star
)paren
id|dev
suffix:semicolon
singleline_comment|// register our address
id|amb_esi
(paren
id|dev
comma
id|dev-&gt;atm_dev-&gt;esi
)paren
suffix:semicolon
singleline_comment|// 0 bits for vpi, 10 bits for vci
id|dev-&gt;atm_dev-&gt;ci_range.vpi_bits
op_assign
id|NUM_VPI_BITS
suffix:semicolon
id|dev-&gt;atm_dev-&gt;ci_range.vci_bits
op_assign
id|NUM_VCI_BITS
suffix:semicolon
singleline_comment|// update count and linked list
op_increment
id|devs
suffix:semicolon
id|dev-&gt;prev
op_assign
id|amb_devs
suffix:semicolon
id|amb_devs
op_assign
id|dev
suffix:semicolon
singleline_comment|// enable host interrupts
id|interrupts_on
(paren
id|dev
)paren
suffix:semicolon
singleline_comment|// success
r_return
suffix:semicolon
singleline_comment|// not currently reached
id|atm_dev_deregister
(paren
id|dev-&gt;atm_dev
)paren
suffix:semicolon
)brace
multiline_comment|/* atm_dev_register */
id|release_region
(paren
id|iobase
comma
id|AMB_EXTENT
)paren
suffix:semicolon
id|free_irq
(paren
id|irq
comma
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* request_region, request_irq */
id|amb_reset
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* amb_init */
id|kfree
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* kmalloc, end-of-fn */
id|PRINTD
(paren
id|DBG_FLOW
comma
l_string|&quot;amb_probe&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|devs
op_assign
l_int|0
suffix:semicolon
id|pci_dev
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|pci_dev
op_assign
id|pci_find_device
(paren
id|PCI_VENDOR_ID_MADGE
comma
id|PCI_DEVICE_ID_MADGE_AMBASSADOR
comma
id|pci_dev
)paren
)paren
)paren
id|do_pci_device
c_func
(paren
)paren
suffix:semicolon
id|pci_dev
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|pci_dev
op_assign
id|pci_find_device
(paren
id|PCI_VENDOR_ID_MADGE
comma
id|PCI_DEVICE_ID_MADGE_AMBASSADOR_BAD
comma
id|pci_dev
)paren
)paren
)paren
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;skipped broken (PLX rev 2) card&quot;
)paren
suffix:semicolon
r_return
id|devs
suffix:semicolon
)brace
DECL|function|amb_check_args
r_static
r_void
id|__init
id|amb_check_args
(paren
r_void
)paren
(brace
r_int
r_char
id|pool
suffix:semicolon
r_int
r_int
id|max_rx_size
suffix:semicolon
macro_line|#ifdef DEBUG_AMBASSADOR
id|PRINTK
(paren
id|KERN_NOTICE
comma
l_string|&quot;debug bitmap is %hx&quot;
comma
id|debug
op_and_assign
id|DBG_MASK
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|debug
)paren
id|PRINTK
(paren
id|KERN_NOTICE
comma
l_string|&quot;no debugging support&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cmds
OL
id|MIN_QUEUE_SIZE
)paren
id|PRINTK
(paren
id|KERN_NOTICE
comma
l_string|&quot;cmds has been raised to %u&quot;
comma
id|cmds
op_assign
id|MIN_QUEUE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|txs
OL
id|MIN_QUEUE_SIZE
)paren
id|PRINTK
(paren
id|KERN_NOTICE
comma
l_string|&quot;txs has been raised to %u&quot;
comma
id|txs
op_assign
id|MIN_QUEUE_SIZE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pool
op_assign
l_int|0
suffix:semicolon
id|pool
OL
id|NUM_RX_POOLS
suffix:semicolon
op_increment
id|pool
)paren
r_if
c_cond
(paren
id|rxs
(braket
id|pool
)braket
OL
id|MIN_QUEUE_SIZE
)paren
id|PRINTK
(paren
id|KERN_NOTICE
comma
l_string|&quot;rxs[%hu] has been raised to %u&quot;
comma
id|pool
comma
id|rxs
(braket
id|pool
)braket
op_assign
id|MIN_QUEUE_SIZE
)paren
suffix:semicolon
singleline_comment|// buffers sizes should be greater than zero and strictly increasing
id|max_rx_size
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|pool
op_assign
l_int|0
suffix:semicolon
id|pool
OL
id|NUM_RX_POOLS
suffix:semicolon
op_increment
id|pool
)paren
r_if
c_cond
(paren
id|rxs_bs
(braket
id|pool
)braket
op_le
id|max_rx_size
)paren
id|PRINTK
(paren
id|KERN_NOTICE
comma
l_string|&quot;useless pool (rxs_bs[%hu] = %u)&quot;
comma
id|pool
comma
id|rxs_bs
(braket
id|pool
)braket
)paren
suffix:semicolon
r_else
id|max_rx_size
op_assign
id|rxs_bs
(braket
id|pool
)braket
suffix:semicolon
r_if
c_cond
(paren
id|rx_lats
OL
id|MIN_RX_BUFFERS
)paren
id|PRINTK
(paren
id|KERN_NOTICE
comma
l_string|&quot;rx_lats has been raised to %u&quot;
comma
id|rx_lats
op_assign
id|MIN_RX_BUFFERS
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/********** module stuff **********/
macro_line|#ifdef MODULE
id|EXPORT_NO_SYMBOLS
suffix:semicolon
DECL|variable|maintainer_string
id|MODULE_AUTHOR
c_func
(paren
id|maintainer_string
)paren
suffix:semicolon
DECL|variable|description_string
id|MODULE_DESCRIPTION
c_func
(paren
id|description_string
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;h&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|cmds
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|txs
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|rxs
comma
id|__MODULE_STRING
c_func
(paren
id|NUM_RX_POOLS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|rxs_bs
comma
id|__MODULE_STRING
c_func
(paren
id|NUM_RX_POOLS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|rx_lats
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|pci_lat
comma
l_string|&quot;b&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|debug
comma
l_string|&quot;debug bitmap, see .h file&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|cmds
comma
l_string|&quot;number of command queue entries&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|txs
comma
l_string|&quot;number of TX queue entries&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|rxs
comma
l_string|&quot;number of RX queue entries [&quot;
id|__MODULE_STRING
c_func
(paren
id|NUM_RX_POOLS
)paren
l_string|&quot;]&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|rxs_bs
comma
l_string|&quot;size of RX buffers [&quot;
id|__MODULE_STRING
c_func
(paren
id|NUM_RX_POOLS
)paren
l_string|&quot;]&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|rx_lats
comma
l_string|&quot;number of extra buffers to cope with RX latencies&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|pci_lat
comma
l_string|&quot;PCI latency in bus cycles&quot;
)paren
suffix:semicolon
multiline_comment|/********** module entry **********/
DECL|function|init_module
r_int
id|init_module
(paren
r_void
)paren
(brace
r_int
id|devs
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_INIT
comma
l_string|&quot;init_module&quot;
)paren
suffix:semicolon
singleline_comment|// sanity check - cast needed as printk does not support %Zu
r_if
c_cond
(paren
r_sizeof
(paren
id|amb_mem
)paren
op_ne
l_int|4
op_star
l_int|16
op_plus
l_int|4
op_star
l_int|12
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;Fix amb_mem (is %lu words).&quot;
comma
(paren
r_int
r_int
)paren
r_sizeof
(paren
id|amb_mem
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|show_version
c_func
(paren
)paren
suffix:semicolon
id|amb_check_args
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// get the juice
id|devs
op_assign
id|amb_probe
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devs
)paren
(brace
id|init_timer
(paren
op_amp
id|housekeeping
)paren
suffix:semicolon
id|housekeeping.function
op_assign
id|do_housekeeping
suffix:semicolon
singleline_comment|// paranoia
id|housekeeping.data
op_assign
l_int|1
suffix:semicolon
id|set_timer
(paren
op_amp
id|housekeeping
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTK
(paren
id|KERN_INFO
comma
l_string|&quot;no (usable) adapters found&quot;
)paren
suffix:semicolon
)brace
r_return
id|devs
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/********** module exit **********/
DECL|function|cleanup_module
r_void
id|cleanup_module
(paren
r_void
)paren
(brace
id|amb_dev
op_star
id|dev
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_INIT
comma
l_string|&quot;cleanup_module&quot;
)paren
suffix:semicolon
singleline_comment|// paranoia
id|housekeeping.data
op_assign
l_int|0
suffix:semicolon
id|del_timer
(paren
op_amp
id|housekeeping
)paren
suffix:semicolon
r_while
c_loop
(paren
id|amb_devs
)paren
(brace
id|dev
op_assign
id|amb_devs
suffix:semicolon
id|amb_devs
op_assign
id|dev-&gt;prev
suffix:semicolon
id|PRINTD
(paren
id|DBG_INFO
op_or
id|DBG_INIT
comma
l_string|&quot;closing %p (atm_dev = %p)&quot;
comma
id|dev
comma
id|dev-&gt;atm_dev
)paren
suffix:semicolon
singleline_comment|// the drain should not be necessary
id|drain_rx_pools
(paren
id|dev
)paren
suffix:semicolon
id|interrupts_off
(paren
id|dev
)paren
suffix:semicolon
id|amb_reset
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|destroy_queues
(paren
id|dev
)paren
suffix:semicolon
id|atm_dev_deregister
(paren
id|dev-&gt;atm_dev
)paren
suffix:semicolon
id|free_irq
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|release_region
(paren
id|dev-&gt;iobase
comma
id|AMB_EXTENT
)paren
suffix:semicolon
id|kfree
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/********** monolithic entry **********/
DECL|function|amb_detect
r_int
id|__init
id|amb_detect
(paren
r_void
)paren
(brace
r_int
id|devs
suffix:semicolon
singleline_comment|// sanity check - cast needed as printk does not support %Zu
r_if
c_cond
(paren
r_sizeof
(paren
id|amb_mem
)paren
op_ne
l_int|4
op_star
l_int|16
op_plus
l_int|4
op_star
l_int|12
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;Fix amb_mem (is %lu words).&quot;
comma
(paren
r_int
r_int
)paren
r_sizeof
(paren
id|amb_mem
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|show_version
c_func
(paren
)paren
suffix:semicolon
id|amb_check_args
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// get the juice
id|devs
op_assign
id|amb_probe
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devs
)paren
(brace
id|init_timer
(paren
op_amp
id|housekeeping
)paren
suffix:semicolon
id|housekeeping.function
op_assign
id|do_housekeeping
suffix:semicolon
singleline_comment|// paranoia
id|housekeeping.data
op_assign
l_int|1
suffix:semicolon
id|set_timer
(paren
op_amp
id|housekeeping
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTK
(paren
id|KERN_INFO
comma
l_string|&quot;no (usable) adapters found&quot;
)paren
suffix:semicolon
)brace
r_return
id|devs
suffix:semicolon
)brace
macro_line|#endif
eof
