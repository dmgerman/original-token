multiline_comment|/*&n;  Madge Horizon ATM Adapter driver.&n;  Copyright (C) 1995-1999  Madge Networks Ltd.&n;  &n;  This program is free software; you can redistribute it and/or modify&n;  it under the terms of the GNU General Public License as published by&n;  the Free Software Foundation; either version 2 of the License, or&n;  (at your option) any later version.&n;  &n;  This program is distributed in the hope that it will be useful,&n;  but WITHOUT ANY WARRANTY; without even the implied warranty of&n;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;  GNU General Public License for more details.&n;  &n;  You should have received a copy of the GNU General Public License&n;  along with this program; if not, write to the Free Software&n;  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n;  &n;  The GNU GPL is contained in /usr/doc/copyright/GPL on a Debian&n;  system and in the file COPYING in the Linux kernel source.&n;*/
multiline_comment|/*&n;  IMPORTANT NOTE: Madge Networks no longer makes the adapters&n;  supported by this driver and makes no commitment to maintain it.&n;*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/atm.h&gt;
macro_line|#include &lt;linux/atmdev.h&gt;
macro_line|#include &lt;linux/sonet.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/uio.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/string.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &quot;horizon.h&quot;
DECL|macro|maintainer_string
mdefine_line|#define maintainer_string &quot;Giuliano Procida at Madge Networks &lt;gprocida@madge.com&gt;&quot;
DECL|macro|description_string
mdefine_line|#define description_string &quot;Madge ATM Horizon [Ultra] driver&quot;
DECL|macro|version_string
mdefine_line|#define version_string &quot;1.2.1&quot;
DECL|function|show_version
r_static
r_inline
r_void
id|__init
id|show_version
(paren
r_void
)paren
(brace
id|printk
(paren
l_string|&quot;%s version %s&bslash;n&quot;
comma
id|description_string
comma
id|version_string
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  &n;  CREDITS&n;  &n;  Driver and documentation by:&n;  &n;  Chris Aston        Madge Networks&n;  Giuliano Procida   Madge Networks&n;  Simon Benham       Madge Networks&n;  Simon Johnson      Madge Networks&n;  Various Others     Madge Networks&n;  &n;  Some inspiration taken from other drivers by:&n;  &n;  Alexandru Cucos    UTBv&n;  Kari Mettinen      University of Helsinki&n;  Werner Almesberger EPFL LRC&n;  &n;  Theory of Operation&n;  &n;  I Hardware, detection, initialisation and shutdown.&n;  &n;  1. Supported Hardware&n;  &n;  This driver should handle all variants of the PCI Madge ATM adapters&n;  with the Horizon chipset. These are all PCI cards supporting PIO, BM&n;  DMA and a form of MMIO (registers only, not internal RAM).&n;  &n;  The driver is only known to work with SONET and UTP Horizon Ultra&n;  cards at 155Mb/s. However, code is in place to deal with both the&n;  original Horizon and 25Mb/s operation.&n;  &n;  There are two revisions of the Horizon ASIC: the original and the&n;  Ultra. Details of hardware bugs are in section III.&n;  &n;  The ASIC version can be distinguished by chip markings but is NOT&n;  indicated by the PCI revision (all adapters seem to have PCI rev 1).&n;  &n;  I believe that:&n;  &n;  Horizon       =&gt; Collage  25 PCI Adapter (UTP and STP)&n;  Horizon Ultra =&gt; Collage 155 PCI Client (UTP or SONET)&n;  Ambassador x  =&gt; Collage 155 PCI Server (completely different)&n;  &n;  Horizon (25Mb/s) is fitted with UTP and STP connectors. It seems to&n;  have a Madge B154 plus glue logic serializer. I have also found a&n;  really ancient version of this with slightly different glue. It&n;  comes with the revision 0 (140-025-01) ASIC.&n;  &n;  Horizon Ultra (155Mb/s) is fitted with either a Pulse Medialink&n;  output (UTP) or an HP HFBR 5205 output (SONET). It has either&n;  Madge&squot;s SAMBA framer or a SUNI-lite device (early versions). It&n;  comes with the revision 1 (140-027-01) ASIC.&n;  &n;  2. Detection&n;  &n;  All Horizon-based cards present with the same PCI Vendor and Device&n;  IDs. The standard Linux 2.2 PCI API is used to locate any cards and&n;  to enable bus-mastering (with appropriate latency).&n;  &n;  ATM_LAYER_STATUS in the control register distinguishes between the&n;  two possible physical layers (25 and 155). It is not clear whether&n;  the 155 cards can also operate at 25Mbps. We rely on the fact that a&n;  card operates at 155 if and only if it has the newer Horizon Ultra&n;  ASIC.&n;  &n;  For 155 cards the two possible framers are probed for and then set&n;  up for loop-timing.&n;  &n;  3. Initialisation&n;  &n;  The card is reset and then put into a known state. The physical&n;  layer is configured for normal operation at the appropriate speed;&n;  in the case of the 155 cards, the framer is initialised with&n;  line-based timing; the internal RAM is zeroed and the allocation of&n;  buffers for RX and TX is made; the Burnt In Address is read and&n;  copied to the ATM ESI; various policy settings for RX (VPI bits,&n;  unknown VCs, oam cells) are made. Ideally all policy items should be&n;  configurable at module load (if not actually on-demand), however,&n;  only the vpi vs vci bit allocation can be specified at insmod.&n;  &n;  4. Shutdown&n;  &n;  This is in response to module_cleaup. No VCs are in use and the card&n;  should be idle; it is reset.&n;  &n;  II Driver software (as it should be)&n;  &n;  0. Traffic Parameters&n;  &n;  The traffic classes (not an enumeration) are currently: ATM_NONE (no&n;  traffic), ATM_UBR, ATM_CBR, ATM_VBR and ATM_ABR, ATM_ANYCLASS&n;  (compatible with everything). Together with (perhaps only some of)&n;  the following items they make up the traffic specification.&n;  &n;  struct atm_trafprm {&n;    unsigned char traffic_class; traffic class (ATM_UBR, ...)&n;    int           max_pcr;       maximum PCR in cells per second&n;    int           pcr;           desired PCR in cells per second&n;    int           min_pcr;       minimum PCR in cells per second&n;    int           max_cdv;       maximum CDV in microseconds&n;    int           max_sdu;       maximum SDU in bytes&n;  };&n;  &n;  Note that these denote bandwidth available not bandwidth used; the&n;  possibilities according to ATMF are:&n;  &n;  Real Time (cdv and max CDT given)&n;  &n;  CBR(pcr)             pcr bandwidth always available&n;  rtVBR(pcr,scr,mbs)   scr bandwidth always available, upto pcr at mbs too&n;  &n;  Non Real Time&n;  &n;  nrtVBR(pcr,scr,mbs)  scr bandwidth always available, upto pcr at mbs too&n;  UBR()&n;  ABR(mcr,pcr)         mcr bandwidth always available, upto pcr (depending) too&n;  &n;  mbs is max burst size (bucket)&n;  pcr and scr have associated cdvt values&n;  mcr is like scr but has no cdtv&n;  cdtv may differ at each hop&n;  &n;  Some of the above items are qos items (as opposed to traffic&n;  parameters). We have nothing to do with qos. All except ABR can have&n;  their traffic parameters converted to GCRA parameters. The GCRA may&n;  be implemented as a (real-number) leaky bucket. The GCRA can be used&n;  in complicated ways by switches and in simpler ways by end-stations.&n;  It can be used both to filter incoming cells and shape out-going&n;  cells.&n;  &n;  ATM Linux actually supports:&n;  &n;  ATM_NONE() (no traffic in this direction)&n;  ATM_UBR(max_frame_size)&n;  ATM_CBR(max/min_pcr, max_cdv, max_frame_size)&n;  &n;  0 or ATM_MAX_PCR are used to indicate maximum available PCR&n;  &n;  A traffic specification consists of the AAL type and separate&n;  traffic specifications for either direction. In ATM Linux it is:&n;  &n;  struct atm_qos {&n;  struct atm_trafprm txtp;&n;  struct atm_trafprm rxtp;&n;  unsigned char aal;&n;  };&n;  &n;  AAL types are:&n;  &n;  ATM_NO_AAL    AAL not specified&n;  ATM_AAL0      &quot;raw&quot; ATM cells&n;  ATM_AAL1      AAL1 (CBR)&n;  ATM_AAL2      AAL2 (VBR)&n;  ATM_AAL34     AAL3/4 (data)&n;  ATM_AAL5      AAL5 (data)&n;  ATM_SAAL      signaling AAL&n;  &n;  The Horizon has support for AAL frame types: 0, 3/4 and 5. However,&n;  it does not implement AAL 3/4 SAR and it has a different notion of&n;  &quot;raw cell&quot; to ATM Linux&squot;s (48 bytes vs. 52 bytes) so neither are&n;  supported by this driver.&n;  &n;  The Horizon has limited support for ABR (including UBR), VBR and&n;  CBR. Each TX channel has a bucket (containing up to 31 cell units)&n;  and two timers (PCR and SCR) associated with it that can be used to&n;  govern cell emissions and host notification (in the case of ABR this&n;  is presumably so that RM cells may be emitted at appropriate times).&n;  The timers may either be disabled or may be set to any of 240 values&n;  (determined by the clock crystal, a fixed (?) per-device divider, a&n;  configurable divider and a configurable timer preload value).&n;  &n;  At the moment only UBR and CBR are supported by the driver. VBR will&n;  be supported as soon as ATM for Linux supports it. ABR support is&n;  very unlikely as RM cell handling is completely up to the driver.&n;  &n;  1. TX (TX channel setup and TX transfer)&n;  &n;  The TX half of the driver owns the TX Horizon registers. The TX&n;  component in the IRQ handler is the BM completion handler. This can&n;  only be entered when tx_busy is true (enforced by hardware). The&n;  other TX component can only be entered when tx_busy is false&n;  (enforced by driver). So TX is single-threaded.&n;  &n;  Apart from a minor optimisation to not re-select the last channel,&n;  the TX send component works as follows:&n;  &n;  Atomic test and set tx_busy until we succeed; we should implement&n;  some sort of timeout so that tx_busy will never be stuck at true.&n;  &n;  If no TX channel is set up for this VC we wait for an idle one (if&n;  necessary) and set it up.&n;  &n;  At this point we have a TX channel ready for use. We wait for enough&n;  buffers to become available then start a TX transmit (set the TX&n;  descriptor, schedule transfer, exit).&n;  &n;  The IRQ component handles TX completion (stats, free buffer, tx_busy&n;  unset, exit). We also re-schedule further transfers for the same&n;  frame if needed.&n;  &n;  TX setup in more detail:&n;  &n;  TX open is a nop, the relevant information is held in the hrz_vcc&n;  (vcc-&gt;dev_data) structure and is &quot;cached&quot; on the card.&n;  &n;  TX close gets the TX lock and clears the channel from the &quot;cache&quot;.&n;  &n;  2. RX (Data Available and RX transfer)&n;  &n;  The RX half of the driver owns the RX registers. There are two RX&n;  components in the IRQ handler: the data available handler deals with&n;  fresh data that has arrived on the card, the BM completion handler&n;  is very similar to the TX completion handler. The data available&n;  handler grabs the rx_lock and it is only released once the data has&n;  been discarded or completely transferred to the host. The BM&n;  completion handler only runs when the lock is held; the data&n;  available handler is locked out over the same period.&n;  &n;  Data available on the card triggers an interrupt. If the data is not&n;  suitable for our existing RX channels or we cannot allocate a buffer&n;  it is flushed. Otherwise an RX receive is scheduled. Multiple RX&n;  transfers may be scheduled for the same frame.&n;  &n;  RX setup in more detail:&n;  &n;  RX open...&n;  RX close...&n;  &n;  III Hardware Bugs&n;  &n;  0. Byte vs Word addressing of adapter RAM.&n;  &n;  A design feature; see the .h file (especially the memory map).&n;  &n;  1. Bus Master Data Transfers (original Horizon only, fixed in Ultra)&n;  &n;  The host must not start a transmit direction transfer at a&n;  non-four-byte boundary in host memory. Instead the host should&n;  perform a byte, or a two byte, or one byte followed by two byte&n;  transfer in order to start the rest of the transfer on a four byte&n;  boundary. RX is OK.&n;  &n;  Simultaneous transmit and receive direction bus master transfers are&n;  not allowed.&n;  &n;  The simplest solution to these two is to always do PIO (never DMA)&n;  in the TX direction on the original Horizon. More complicated&n;  solutions are likely to hurt my brain.&n;  &n;  2. Loss of buffer on close VC&n;  &n;  When a VC is being closed, the buffer associated with it is not&n;  returned to the pool. The host must store the reference to this&n;  buffer and when opening a new VC then give it to that new VC.&n;  &n;  The host intervention currently consists of stacking such a buffer&n;  pointer at VC close and checking the stack at VC open.&n;  &n;  3. Failure to close a VC&n;  &n;  If a VC is currently receiving a frame then closing the VC may fail&n;  and the frame continues to be received.&n;  &n;  The solution is to make sure any received frames are flushed when&n;  ready. This is currently done just before the solution to 2.&n;  &n;  4. PCI bus (original Horizon only, fixed in Ultra)&n;  &n;  Reading from the data port prior to initialisation will hang the PCI&n;  bus. Just don&squot;t do that then! We don&squot;t.&n;  &n;  IV To Do List&n;  &n;  . Timer code may be broken.&n;  &n;  . Allow users to specify buffer allocation split for TX and RX.&n;  &n;  . Deal once and for all with buggy VC close.&n;  &n;  . Handle interrupted and/or non-blocking operations.&n;  &n;  . Change some macros to functions and move from .h to .c.&n;  &n;  . Try to limit the number of TX frames each VC may have queued, in&n;    order to reduce the chances of TX buffer exhaustion.&n;  &n;  . Implement VBR (bucket and timers not understood) and ABR (need to&n;    do RM cells manually); also no Linux support for either.&n;  &n;  . Implement QoS changes on open VCs (involves extracting parts of VC open&n;    and close into separate functions and using them to make changes).&n;  &n;*/
multiline_comment|/********** globals **********/
DECL|variable|hrz_devs
r_static
id|hrz_dev
op_star
id|hrz_devs
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|housekeeping
r_static
r_struct
id|timer_list
id|housekeeping
suffix:semicolon
DECL|variable|debug
r_static
r_int
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
DECL|variable|vpi_bits
r_static
r_int
r_int
id|vpi_bits
op_assign
l_int|0
suffix:semicolon
DECL|variable|max_tx_size
r_static
r_int
r_int
id|max_tx_size
op_assign
l_int|9000
suffix:semicolon
DECL|variable|max_rx_size
r_static
r_int
r_int
id|max_rx_size
op_assign
l_int|9000
suffix:semicolon
DECL|variable|pci_lat
r_static
r_int
r_char
id|pci_lat
op_assign
l_int|0
suffix:semicolon
multiline_comment|/********** access functions **********/
multiline_comment|/* Read / Write Horizon registers */
DECL|function|wr_regl
r_static
r_inline
r_void
id|wr_regl
(paren
r_const
id|hrz_dev
op_star
id|dev
comma
r_int
r_char
id|reg
comma
id|u32
id|data
)paren
(brace
id|outl
(paren
id|cpu_to_le32
(paren
id|data
)paren
comma
id|dev-&gt;iobase
op_plus
id|reg
)paren
suffix:semicolon
)brace
DECL|function|rd_regl
r_static
r_inline
id|u32
id|rd_regl
(paren
r_const
id|hrz_dev
op_star
id|dev
comma
r_int
r_char
id|reg
)paren
(brace
r_return
id|le32_to_cpu
(paren
id|inl
(paren
id|dev-&gt;iobase
op_plus
id|reg
)paren
)paren
suffix:semicolon
)brace
DECL|function|wr_regw
r_static
r_inline
r_void
id|wr_regw
(paren
r_const
id|hrz_dev
op_star
id|dev
comma
r_int
r_char
id|reg
comma
id|u16
id|data
)paren
(brace
id|outw
(paren
id|cpu_to_le16
(paren
id|data
)paren
comma
id|dev-&gt;iobase
op_plus
id|reg
)paren
suffix:semicolon
)brace
DECL|function|rd_regw
r_static
r_inline
id|u16
id|rd_regw
(paren
r_const
id|hrz_dev
op_star
id|dev
comma
r_int
r_char
id|reg
)paren
(brace
r_return
id|le16_to_cpu
(paren
id|inw
(paren
id|dev-&gt;iobase
op_plus
id|reg
)paren
)paren
suffix:semicolon
)brace
DECL|function|wrs_regb
r_static
r_inline
r_void
id|wrs_regb
(paren
r_const
id|hrz_dev
op_star
id|dev
comma
r_int
r_char
id|reg
comma
r_void
op_star
id|addr
comma
id|u32
id|len
)paren
(brace
id|outsb
(paren
id|dev-&gt;iobase
op_plus
id|reg
comma
id|addr
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|rds_regb
r_static
r_inline
r_void
id|rds_regb
(paren
r_const
id|hrz_dev
op_star
id|dev
comma
r_int
r_char
id|reg
comma
r_void
op_star
id|addr
comma
id|u32
id|len
)paren
(brace
id|insb
(paren
id|dev-&gt;iobase
op_plus
id|reg
comma
id|addr
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/* Read / Write to a given address in Horizon buffer memory.&n;   Interrupts must be disabled between the address register and data&n;   port accesses as these must form an atomic operation. */
DECL|function|wr_mem
r_static
r_inline
r_void
id|wr_mem
(paren
r_const
id|hrz_dev
op_star
id|dev
comma
id|HDW
op_star
id|addr
comma
id|u32
id|data
)paren
(brace
singleline_comment|// wr_regl (dev, MEM_WR_ADDR_REG_OFF, (u32) addr);
id|wr_regl
(paren
id|dev
comma
id|MEM_WR_ADDR_REG_OFF
comma
(paren
id|addr
op_minus
(paren
id|HDW
op_star
)paren
l_int|0
)paren
op_star
r_sizeof
(paren
id|HDW
)paren
)paren
suffix:semicolon
id|wr_regl
(paren
id|dev
comma
id|MEMORY_PORT_OFF
comma
id|data
)paren
suffix:semicolon
)brace
DECL|function|rd_mem
r_static
r_inline
id|u32
id|rd_mem
(paren
r_const
id|hrz_dev
op_star
id|dev
comma
id|HDW
op_star
id|addr
)paren
(brace
singleline_comment|// wr_regl (dev, MEM_RD_ADDR_REG_OFF, (u32) addr);
id|wr_regl
(paren
id|dev
comma
id|MEM_RD_ADDR_REG_OFF
comma
(paren
id|addr
op_minus
(paren
id|HDW
op_star
)paren
l_int|0
)paren
op_star
r_sizeof
(paren
id|HDW
)paren
)paren
suffix:semicolon
r_return
id|rd_regl
(paren
id|dev
comma
id|MEMORY_PORT_OFF
)paren
suffix:semicolon
)brace
DECL|function|wr_framer
r_static
r_inline
r_void
id|wr_framer
(paren
r_const
id|hrz_dev
op_star
id|dev
comma
id|u32
id|addr
comma
id|u32
id|data
)paren
(brace
id|wr_regl
(paren
id|dev
comma
id|MEM_WR_ADDR_REG_OFF
comma
(paren
id|u32
)paren
id|addr
op_or
l_int|0x80000000
)paren
suffix:semicolon
id|wr_regl
(paren
id|dev
comma
id|MEMORY_PORT_OFF
comma
id|data
)paren
suffix:semicolon
)brace
DECL|function|rd_framer
r_static
r_inline
id|u32
id|rd_framer
(paren
r_const
id|hrz_dev
op_star
id|dev
comma
id|u32
id|addr
)paren
(brace
id|wr_regl
(paren
id|dev
comma
id|MEM_RD_ADDR_REG_OFF
comma
(paren
id|u32
)paren
id|addr
op_or
l_int|0x80000000
)paren
suffix:semicolon
r_return
id|rd_regl
(paren
id|dev
comma
id|MEMORY_PORT_OFF
)paren
suffix:semicolon
)brace
multiline_comment|/********** specialised access functions **********/
multiline_comment|/* RX */
DECL|function|FLUSH_RX_CHANNEL
r_static
r_inline
r_void
id|FLUSH_RX_CHANNEL
(paren
id|hrz_dev
op_star
id|dev
comma
id|u16
id|channel
)paren
(brace
id|wr_regw
(paren
id|dev
comma
id|RX_CHANNEL_PORT_OFF
comma
id|FLUSH_CHANNEL
op_or
id|channel
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|WAIT_FLUSH_RX_COMPLETE
r_static
r_inline
r_void
id|WAIT_FLUSH_RX_COMPLETE
(paren
id|hrz_dev
op_star
id|dev
)paren
(brace
r_while
c_loop
(paren
id|rd_regw
(paren
id|dev
comma
id|RX_CHANNEL_PORT_OFF
)paren
op_amp
id|FLUSH_CHANNEL
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|SELECT_RX_CHANNEL
r_static
r_inline
r_void
id|SELECT_RX_CHANNEL
(paren
id|hrz_dev
op_star
id|dev
comma
id|u16
id|channel
)paren
(brace
id|wr_regw
(paren
id|dev
comma
id|RX_CHANNEL_PORT_OFF
comma
id|channel
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|WAIT_UPDATE_COMPLETE
r_static
r_inline
r_void
id|WAIT_UPDATE_COMPLETE
(paren
id|hrz_dev
op_star
id|dev
)paren
(brace
r_while
c_loop
(paren
id|rd_regw
(paren
id|dev
comma
id|RX_CHANNEL_PORT_OFF
)paren
op_amp
id|RX_CHANNEL_UPDATE_IN_PROGRESS
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* TX */
DECL|function|SELECT_TX_CHANNEL
r_static
r_inline
r_void
id|SELECT_TX_CHANNEL
(paren
id|hrz_dev
op_star
id|dev
comma
id|u16
id|tx_channel
)paren
(brace
id|wr_regl
(paren
id|dev
comma
id|TX_CHANNEL_PORT_OFF
comma
id|tx_channel
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Update or query one configuration parameter of a particular channel. */
DECL|function|update_tx_channel_config
r_static
r_inline
r_void
id|update_tx_channel_config
(paren
id|hrz_dev
op_star
id|dev
comma
r_int
id|chan
comma
id|u8
id|mode
comma
id|u16
id|value
)paren
(brace
id|wr_regw
(paren
id|dev
comma
id|TX_CHANNEL_CONFIG_COMMAND_OFF
comma
id|chan
op_star
id|TX_CHANNEL_CONFIG_MULT
op_or
id|mode
)paren
suffix:semicolon
id|wr_regw
(paren
id|dev
comma
id|TX_CHANNEL_CONFIG_DATA_OFF
comma
id|value
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|query_tx_channel_config
r_static
r_inline
id|u16
id|query_tx_channel_config
(paren
id|hrz_dev
op_star
id|dev
comma
r_int
id|chan
comma
id|u8
id|mode
)paren
(brace
id|wr_regw
(paren
id|dev
comma
id|TX_CHANNEL_CONFIG_COMMAND_OFF
comma
id|chan
op_star
id|TX_CHANNEL_CONFIG_MULT
op_or
id|mode
)paren
suffix:semicolon
r_return
id|rd_regw
(paren
id|dev
comma
id|TX_CHANNEL_CONFIG_DATA_OFF
)paren
suffix:semicolon
)brace
multiline_comment|/********** dump functions **********/
DECL|function|dump_skb
r_static
r_inline
r_void
id|dump_skb
(paren
r_char
op_star
id|prefix
comma
r_int
r_int
id|vc
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
macro_line|#ifdef DEBUG_HORIZON
r_int
r_int
id|i
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|skb-&gt;data
suffix:semicolon
id|PRINTDB
(paren
id|DBG_DATA
comma
l_string|&quot;%s(%u) &quot;
comma
id|prefix
comma
id|vc
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb-&gt;len
op_logical_and
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
id|PRINTDM
(paren
id|DBG_DATA
comma
l_string|&quot;%02x &quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
id|PRINTDE
(paren
id|DBG_DATA
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
macro_line|#else
(paren
r_void
)paren
id|prefix
suffix:semicolon
(paren
r_void
)paren
id|vc
suffix:semicolon
(paren
r_void
)paren
id|skb
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|function|dump_regs
r_static
r_inline
r_void
id|dump_regs
(paren
id|hrz_dev
op_star
id|dev
)paren
(brace
macro_line|#ifdef DEBUG_HORIZON
id|PRINTD
(paren
id|DBG_REGS
comma
l_string|&quot;CONTROL 0: %#x&quot;
comma
id|rd_regl
(paren
id|dev
comma
id|CONTROL_0_REG
)paren
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_REGS
comma
l_string|&quot;RX CONFIG: %#x&quot;
comma
id|rd_regw
(paren
id|dev
comma
id|RX_CONFIG_OFF
)paren
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_REGS
comma
l_string|&quot;TX CONFIG: %#x&quot;
comma
id|rd_regw
(paren
id|dev
comma
id|TX_CONFIG_OFF
)paren
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_REGS
comma
l_string|&quot;TX STATUS: %#x&quot;
comma
id|rd_regw
(paren
id|dev
comma
id|TX_STATUS_OFF
)paren
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_REGS
comma
l_string|&quot;IRQ ENBLE: %#x&quot;
comma
id|rd_regl
(paren
id|dev
comma
id|INT_ENABLE_REG_OFF
)paren
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_REGS
comma
l_string|&quot;IRQ SORCE: %#x&quot;
comma
id|rd_regl
(paren
id|dev
comma
id|INT_SOURCE_REG_OFF
)paren
)paren
suffix:semicolon
macro_line|#else
(paren
r_void
)paren
id|dev
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|function|dump_framer
r_static
r_inline
r_void
id|dump_framer
(paren
id|hrz_dev
op_star
id|dev
)paren
(brace
macro_line|#ifdef DEBUG_HORIZON
r_int
r_int
id|i
suffix:semicolon
id|PRINTDB
(paren
id|DBG_REGS
comma
l_string|&quot;framer registers:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x10
suffix:semicolon
op_increment
id|i
)paren
id|PRINTDM
(paren
id|DBG_REGS
comma
l_string|&quot; %02x&quot;
comma
id|rd_framer
(paren
id|dev
comma
id|i
)paren
)paren
suffix:semicolon
id|PRINTDE
(paren
id|DBG_REGS
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
macro_line|#else
(paren
r_void
)paren
id|dev
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/********** VPI/VCI &lt;-&gt; (RX) channel conversions **********/
multiline_comment|/* RX channels are 10 bit integers, these fns are quite paranoid */
DECL|function|channel_to_vpivci
r_static
r_inline
r_int
id|channel_to_vpivci
(paren
r_const
id|u16
id|channel
comma
r_int
op_star
id|vpi
comma
r_int
op_star
id|vci
)paren
(brace
r_int
r_int
id|vci_bits
op_assign
l_int|10
op_minus
id|vpi_bits
suffix:semicolon
r_if
c_cond
(paren
(paren
id|channel
op_amp
id|RX_CHANNEL_MASK
)paren
op_eq
id|channel
)paren
(brace
op_star
id|vci
op_assign
id|channel
op_amp
(paren
(paren
op_complement
l_int|0
)paren
op_lshift
id|vci_bits
)paren
suffix:semicolon
op_star
id|vpi
op_assign
id|channel
op_rshift
id|vci_bits
suffix:semicolon
r_return
id|channel
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|vpivci_to_channel
r_static
r_inline
r_int
id|vpivci_to_channel
(paren
id|u16
op_star
id|channel
comma
r_const
r_int
id|vpi
comma
r_const
r_int
id|vci
)paren
(brace
r_int
r_int
id|vci_bits
op_assign
l_int|10
op_minus
id|vpi_bits
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|vpi
op_logical_and
id|vpi
OL
l_int|1
op_lshift
id|vpi_bits
op_logical_and
l_int|0
op_le
id|vci
op_logical_and
id|vci
OL
l_int|1
op_lshift
id|vci_bits
)paren
(brace
op_star
id|channel
op_assign
id|vpi
op_lshift
id|vci_bits
op_or
id|vci
suffix:semicolon
r_return
op_star
id|channel
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/********** decode RX queue entries **********/
DECL|function|rx_q_entry_to_length
r_static
r_inline
id|u16
id|rx_q_entry_to_length
(paren
id|u32
id|x
)paren
(brace
r_return
id|x
op_amp
id|RX_Q_ENTRY_LENGTH_MASK
suffix:semicolon
)brace
DECL|function|rx_q_entry_to_rx_channel
r_static
r_inline
id|u16
id|rx_q_entry_to_rx_channel
(paren
id|u32
id|x
)paren
(brace
r_return
(paren
id|x
op_rshift
id|RX_Q_ENTRY_CHANNEL_SHIFT
)paren
op_amp
id|RX_CHANNEL_MASK
suffix:semicolon
)brace
multiline_comment|/* Cell Transmit Rate Values&n; *&n; * the cell transmit rate (cells per sec) can be set to a variety of&n; * different values by specifying two parameters: a timer preload from&n; * 1 to 16 (stored as 0 to 15) and a clock divider (2 to the power of&n; * an exponent from 0 to 14; the special value 15 disables the timer).&n; *&n; * cellrate = baserate / (preload * 2^divider)&n; *&n; * The maximum cell rate that can be specified is therefore just the&n; * base rate. Halving the preload is equivalent to adding 1 to the&n; * divider and so values 1 to 8 of the preload are redundant except&n; * in the case of a maximal divider (14).&n; *&n; * Given a desired cell rate, an algorithm to determine the preload&n; * and divider is:&n; * &n; * a) x = baserate / cellrate, want p * 2^d = x (as far as possible)&n; * b) if x &gt; 16 * 2^14 then set p = 16, d = 14 (min rate), done&n; *    if x &lt;= 16 then set p = x, d = 0 (high rates), done&n; * c) now have 16 &lt; x &lt;= 2^18, or 1 &lt; x/16 &lt;= 2^14 and we want to&n; *    know n such that 2^(n-1) &lt; x/16 &lt;= 2^n, so slide a bit until&n; *    we find the range (n will be between 1 and 14), set d = n&n; * d) Also have 8 &lt; x/2^n &lt;= 16, so set p nearest x/2^n&n; *&n; * The algorithm used below is a minor variant of the above.&n; *&n; * The base rate is derived from the oscillator frequency (Hz) using a&n; * fixed divider:&n; *&n; * baserate = freq / 32 in the case of some Unknown Card&n; * baserate = freq / 8  in the case of the Horizon        25&n; * baserate = freq / 8  in the case of the Horizon Ultra 155&n; *&n; * The Horizon cards have oscillators and base rates as follows:&n; *&n; * Card               Oscillator  Base Rate&n; * Unknown Card       33 MHz      1.03125 MHz (33 MHz = PCI freq)&n; * Horizon        25  32 MHz      4       MHz&n; * Horizon Ultra 155  40 MHz      5       MHz&n; *&n; * The following defines give the base rates in Hz. These were&n; * previously a factor of 100 larger, no doubt someone was using&n; * cps*100.&n; */
DECL|macro|BR_UKN
mdefine_line|#define BR_UKN 1031250l
DECL|macro|BR_HRZ
mdefine_line|#define BR_HRZ 4000000l
DECL|macro|BR_ULT
mdefine_line|#define BR_ULT 5000000l
singleline_comment|// d is an exponent
DECL|macro|CR_MIND
mdefine_line|#define CR_MIND 0
DECL|macro|CR_MAXD
mdefine_line|#define CR_MAXD 14
singleline_comment|// p ranges from 1 to a power of 2
DECL|macro|CR_MAXPEXP
mdefine_line|#define CR_MAXPEXP 4
DECL|function|make_rate
r_static
r_int
id|make_rate
(paren
r_const
id|hrz_dev
op_star
id|dev
comma
id|u32
id|c
comma
id|rounding
id|r
comma
id|u16
op_star
id|bits
comma
r_int
r_int
op_star
id|actual
)paren
(brace
singleline_comment|// note: rounding the rate down means rounding &squot;p&squot; up
r_const
r_int
r_int
id|br
op_assign
id|test_bit
(paren
id|ultra
comma
(paren
id|hrz_flags
op_star
)paren
op_amp
id|dev-&gt;flags
)paren
ques
c_cond
id|BR_ULT
suffix:colon
id|BR_HRZ
suffix:semicolon
id|u32
id|div
op_assign
id|CR_MIND
suffix:semicolon
id|u32
id|pre
suffix:semicolon
singleline_comment|// local fn to build the timer bits
r_int
id|set_cr
(paren
r_void
)paren
(brace
singleline_comment|// paranoia
r_if
c_cond
(paren
id|div
OG
id|CR_MAXD
op_logical_or
(paren
op_logical_neg
id|pre
)paren
op_logical_or
id|pre
OG
l_int|1
op_lshift
id|CR_MAXPEXP
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;set_cr internal failure: d=%u p=%u&quot;
comma
id|div
comma
id|pre
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|bits
)paren
op_star
id|bits
op_assign
(paren
id|div
op_lshift
id|CLOCK_SELECT_SHIFT
)paren
op_or
(paren
id|pre
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|actual
)paren
(brace
op_star
id|actual
op_assign
(paren
id|br
op_plus
(paren
id|pre
op_lshift
id|div
)paren
op_minus
l_int|1
)paren
op_div
(paren
id|pre
op_lshift
id|div
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;actual rate: %u&quot;
comma
op_star
id|actual
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
singleline_comment|// br_exp and br_man are used to avoid overflowing (c*maxp*2^d) in
singleline_comment|// the tests below. We could think harder about exact possibilities
singleline_comment|// of failure...
r_int
r_int
id|br_man
op_assign
id|br
suffix:semicolon
r_int
r_int
id|br_exp
op_assign
l_int|0
suffix:semicolon
id|PRINTD
(paren
id|DBG_QOS
op_or
id|DBG_FLOW
comma
l_string|&quot;make_rate b=%lu, c=%u, %s&quot;
comma
id|br
comma
id|c
comma
(paren
id|r
op_eq
id|round_up
)paren
ques
c_cond
l_string|&quot;up&quot;
suffix:colon
(paren
id|r
op_eq
id|round_down
)paren
ques
c_cond
l_string|&quot;down&quot;
suffix:colon
l_string|&quot;nearest&quot;
)paren
suffix:semicolon
singleline_comment|// avoid div by zero
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
op_or
id|DBG_ERR
comma
l_string|&quot;zero rate is not allowed!&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_while
c_loop
(paren
id|br_exp
OL
id|CR_MAXPEXP
op_plus
id|CR_MIND
op_logical_and
(paren
id|br_man
op_mod
l_int|2
op_eq
l_int|0
)paren
)paren
(brace
id|br_man
op_assign
id|br_man
op_rshift
l_int|1
suffix:semicolon
op_increment
id|br_exp
suffix:semicolon
)brace
singleline_comment|// (br &gt;&gt;br_exp) &lt;&lt;br_exp == br and
singleline_comment|// br_exp &lt;= CR_MAXPEXP+CR_MIND
r_if
c_cond
(paren
id|br_man
op_le
(paren
id|c
op_lshift
(paren
id|CR_MAXPEXP
op_plus
id|CR_MIND
op_minus
id|br_exp
)paren
)paren
)paren
(brace
singleline_comment|// Equivalent to: B &lt;= (c &lt;&lt; (MAXPEXP+MIND))
singleline_comment|// take care of rounding
r_switch
c_cond
(paren
id|r
)paren
(brace
r_case
id|round_down
suffix:colon
id|pre
op_assign
(paren
id|br
op_plus
(paren
id|c
op_lshift
id|div
)paren
op_minus
l_int|1
)paren
op_div
(paren
id|c
op_lshift
id|div
)paren
suffix:semicolon
singleline_comment|// but p must be non-zero
r_if
c_cond
(paren
op_logical_neg
id|pre
)paren
id|pre
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|round_nearest
suffix:colon
id|pre
op_assign
(paren
id|br
op_plus
(paren
id|c
op_lshift
id|div
)paren
op_div
l_int|2
)paren
op_div
(paren
id|c
op_lshift
id|div
)paren
suffix:semicolon
singleline_comment|// but p must be non-zero
r_if
c_cond
(paren
op_logical_neg
id|pre
)paren
id|pre
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|round_up
suffix:colon
id|pre
op_assign
id|br
op_div
(paren
id|c
op_lshift
id|div
)paren
suffix:semicolon
singleline_comment|// but p must be non-zero
r_if
c_cond
(paren
op_logical_neg
id|pre
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;A: p=%u, d=%u&quot;
comma
id|pre
comma
id|div
)paren
suffix:semicolon
r_return
id|set_cr
(paren
)paren
suffix:semicolon
)brace
singleline_comment|// at this point we have
singleline_comment|// d == MIND and (c &lt;&lt; (MAXPEXP+MIND)) &lt; B
r_while
c_loop
(paren
id|div
OL
id|CR_MAXD
)paren
(brace
id|div
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|br_man
op_le
(paren
id|c
op_lshift
(paren
id|CR_MAXPEXP
op_plus
id|div
op_minus
id|br_exp
)paren
)paren
)paren
(brace
singleline_comment|// Equivalent to: B &lt;= (c &lt;&lt; (MAXPEXP+d))
singleline_comment|// c &lt;&lt; (MAXPEXP+d-1) &lt; B &lt;= c &lt;&lt; (MAXPEXP+d)
singleline_comment|// 1 &lt;&lt; (MAXPEXP-1) &lt; B/2^d/c &lt;= 1 &lt;&lt; MAXPEXP
singleline_comment|// MAXP/2 &lt; B/c2^d &lt;= MAXP
singleline_comment|// take care of rounding
r_switch
c_cond
(paren
id|r
)paren
(brace
r_case
id|round_down
suffix:colon
id|pre
op_assign
(paren
id|br
op_plus
(paren
id|c
op_lshift
id|div
)paren
op_minus
l_int|1
)paren
op_div
(paren
id|c
op_lshift
id|div
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|round_nearest
suffix:colon
id|pre
op_assign
(paren
id|br
op_plus
(paren
id|c
op_lshift
id|div
)paren
op_div
l_int|2
)paren
op_div
(paren
id|c
op_lshift
id|div
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|round_up
suffix:colon
id|pre
op_assign
id|br
op_div
(paren
id|c
op_lshift
id|div
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;B: p=%u, d=%u&quot;
comma
id|pre
comma
id|div
)paren
suffix:semicolon
r_return
id|set_cr
(paren
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// at this point we have
singleline_comment|// d == MAXD and (c &lt;&lt; (MAXPEXP+MAXD)) &lt; B
singleline_comment|// but we cannot go any higher
singleline_comment|// take care of rounding
r_switch
c_cond
(paren
id|r
)paren
(brace
r_case
id|round_down
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|round_nearest
suffix:colon
r_break
suffix:semicolon
r_case
id|round_up
suffix:colon
r_break
suffix:semicolon
)brace
id|pre
op_assign
l_int|1
op_lshift
id|CR_MAXPEXP
suffix:semicolon
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;C: p=%u, d=%u&quot;
comma
id|pre
comma
id|div
)paren
suffix:semicolon
r_return
id|set_cr
(paren
)paren
suffix:semicolon
)brace
DECL|function|make_rate_with_tolerance
r_static
r_int
id|make_rate_with_tolerance
(paren
r_const
id|hrz_dev
op_star
id|dev
comma
id|u32
id|c
comma
id|rounding
id|r
comma
r_int
r_int
id|tol
comma
id|u16
op_star
id|bit_pattern
comma
r_int
r_int
op_star
id|actual
)paren
(brace
r_int
r_int
id|my_actual
suffix:semicolon
id|PRINTD
(paren
id|DBG_QOS
op_or
id|DBG_FLOW
comma
l_string|&quot;make_rate_with_tolerance c=%u, %s, tol=%u&quot;
comma
id|c
comma
(paren
id|r
op_eq
id|round_up
)paren
ques
c_cond
l_string|&quot;up&quot;
suffix:colon
(paren
id|r
op_eq
id|round_down
)paren
ques
c_cond
l_string|&quot;down&quot;
suffix:colon
l_string|&quot;nearest&quot;
comma
id|tol
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|actual
)paren
singleline_comment|// actual rate is not returned
id|actual
op_assign
op_amp
id|my_actual
suffix:semicolon
r_if
c_cond
(paren
id|make_rate
(paren
id|dev
comma
id|c
comma
id|round_nearest
comma
id|bit_pattern
comma
id|actual
)paren
)paren
singleline_comment|// should never happen as round_nearest always succeeds
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|c
op_minus
id|tol
op_le
op_star
id|actual
op_logical_and
op_star
id|actual
op_le
id|c
op_plus
id|tol
)paren
singleline_comment|// within tolerance
r_return
l_int|0
suffix:semicolon
r_else
singleline_comment|// intolerant, try rounding instead
r_return
id|make_rate
(paren
id|dev
comma
id|c
comma
id|r
comma
id|bit_pattern
comma
id|actual
)paren
suffix:semicolon
)brace
multiline_comment|/********** Listen on a VC **********/
DECL|function|hrz_open_rx
r_static
r_int
id|hrz_open_rx
(paren
id|hrz_dev
op_star
id|dev
comma
id|u16
id|channel
)paren
(brace
singleline_comment|// is there any guarantee that we don&squot;t get two simulataneous
singleline_comment|// identical calls of this function from different processes? yes
singleline_comment|// rate_lock
r_int
r_int
id|flags
suffix:semicolon
id|u32
id|channel_type
suffix:semicolon
singleline_comment|// u16?
id|u16
id|buf_ptr
op_assign
id|RX_CHANNEL_IDLE
suffix:semicolon
id|rx_ch_desc
op_star
id|rx_desc
op_assign
op_amp
id|memmap-&gt;rx_descs
(braket
id|channel
)braket
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
comma
l_string|&quot;hrz_open_rx %x&quot;
comma
id|channel
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|dev-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
id|channel_type
op_assign
id|rd_mem
(paren
id|dev
comma
op_amp
id|rx_desc-&gt;wr_buf_type
)paren
op_amp
id|BUFFER_PTR_MASK
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|dev-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// very serious error, should never occur
r_if
c_cond
(paren
id|channel_type
op_ne
id|RX_CHANNEL_DISABLED
)paren
(brace
id|PRINTD
(paren
id|DBG_ERR
op_or
id|DBG_VCC
comma
l_string|&quot;RX channel for VC already open&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
singleline_comment|// clean up?
)brace
singleline_comment|// Give back spare buffer
r_if
c_cond
(paren
id|dev-&gt;noof_spare_buffers
)paren
(brace
id|buf_ptr
op_assign
id|dev-&gt;spare_buffers
(braket
op_decrement
id|dev-&gt;noof_spare_buffers
)braket
suffix:semicolon
id|PRINTD
(paren
id|DBG_VCC
comma
l_string|&quot;using a spare buffer: %u&quot;
comma
id|buf_ptr
)paren
suffix:semicolon
singleline_comment|// should never occur
r_if
c_cond
(paren
id|buf_ptr
op_eq
id|RX_CHANNEL_DISABLED
op_logical_or
id|buf_ptr
op_eq
id|RX_CHANNEL_IDLE
)paren
(brace
singleline_comment|// but easy to recover from
id|PRINTD
(paren
id|DBG_ERR
op_or
id|DBG_VCC
comma
l_string|&quot;bad spare buffer pointer, using IDLE&quot;
)paren
suffix:semicolon
id|buf_ptr
op_assign
id|RX_CHANNEL_IDLE
suffix:semicolon
)brace
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_VCC
comma
l_string|&quot;using IDLE buffer pointer&quot;
)paren
suffix:semicolon
)brace
singleline_comment|// Channel is currently disabled so change its status to idle
singleline_comment|// do we really need to save the flags again?
id|spin_lock_irqsave
(paren
op_amp
id|dev-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
id|wr_mem
(paren
id|dev
comma
op_amp
id|rx_desc-&gt;wr_buf_type
comma
id|buf_ptr
op_or
id|CHANNEL_TYPE_AAL5
op_or
id|FIRST_CELL_OF_AAL5_FRAME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf_ptr
op_ne
id|RX_CHANNEL_IDLE
)paren
id|wr_mem
(paren
id|dev
comma
op_amp
id|rx_desc-&gt;rd_buf_type
comma
id|buf_ptr
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|dev-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// rxer-&gt;rate = make_rate (qos-&gt;peak_cells);
id|PRINTD
(paren
id|DBG_FLOW
comma
l_string|&quot;hrz_open_rx ok&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/********** change vc rate for a given vc **********/
DECL|function|hrz_change_vc_qos
r_static
r_void
id|hrz_change_vc_qos
(paren
id|ATM_RXER
op_star
id|rxer
comma
id|MAAL_QOS
op_star
id|qos
)paren
(brace
id|rxer-&gt;rate
op_assign
id|make_rate
(paren
id|qos-&gt;peak_cells
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/********** free an skb (as per ATM device driver documentation) **********/
DECL|function|hrz_kfree_skb
r_static
r_inline
r_void
id|hrz_kfree_skb
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc-&gt;pop
)paren
(brace
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc-&gt;pop
(paren
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|dev_kfree_skb_any
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/********** cancel listen on a VC **********/
DECL|function|hrz_close_rx
r_static
r_void
id|hrz_close_rx
(paren
id|hrz_dev
op_star
id|dev
comma
id|u16
id|vc
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|u32
id|value
suffix:semicolon
id|u32
id|r1
comma
id|r2
suffix:semicolon
id|rx_ch_desc
op_star
id|rx_desc
op_assign
op_amp
id|memmap-&gt;rx_descs
(braket
id|vc
)braket
suffix:semicolon
r_int
id|was_idle
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|dev-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
id|value
op_assign
id|rd_mem
(paren
id|dev
comma
op_amp
id|rx_desc-&gt;wr_buf_type
)paren
op_amp
id|BUFFER_PTR_MASK
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|dev-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_eq
id|RX_CHANNEL_DISABLED
)paren
(brace
singleline_comment|// I suppose this could happen once we deal with _NONE traffic properly
id|PRINTD
(paren
id|DBG_VCC
comma
l_string|&quot;closing VC: RX channel %u already disabled&quot;
comma
id|vc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|value
op_eq
id|RX_CHANNEL_IDLE
)paren
id|was_idle
op_assign
l_int|1
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|dev-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|wr_mem
(paren
id|dev
comma
op_amp
id|rx_desc-&gt;wr_buf_type
comma
id|RX_CHANNEL_DISABLED
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rd_mem
(paren
id|dev
comma
op_amp
id|rx_desc-&gt;wr_buf_type
)paren
op_amp
id|BUFFER_PTR_MASK
)paren
op_eq
id|RX_CHANNEL_DISABLED
)paren
r_break
suffix:semicolon
id|was_idle
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|was_idle
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|dev-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|WAIT_FLUSH_RX_COMPLETE
c_func
(paren
id|dev
)paren
suffix:semicolon
singleline_comment|// XXX Is this all really necessary? We can rely on the rx_data_av
singleline_comment|// handler to discard frames that remain queued for delivery. If the
singleline_comment|// worry is that immediately reopening the channel (perhaps by a
singleline_comment|// different process) may cause some data to be mis-delivered then
singleline_comment|// there may still be a simpler solution (such as busy-waiting on
singleline_comment|// rx_busy once the channel is disabled or before a new one is
singleline_comment|// opened - does this leave any holes?). Arguably setting up and
singleline_comment|// tearing down the TX and RX halves of each virtual circuit could
singleline_comment|// most safely be done within ?x_busy protected regions.
singleline_comment|// OK, current changes are that Simon&squot;s marker is disabled and we DO
singleline_comment|// look for NULL rxer elsewhere. The code here seems flush frames
singleline_comment|// and then remember the last dead cell belonging to the channel
singleline_comment|// just disabled - the cell gets relinked at the next vc_open.
singleline_comment|// However, when all VCs are closed or only a few opened there are a
singleline_comment|// handful of buffers that are unusable.
singleline_comment|// Does anyone feel like documenting spare_buffers properly?
singleline_comment|// Does anyone feel like fixing this in a nicer way?
singleline_comment|// Flush any data which is left in the channel
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
singleline_comment|// Change the rx channel port to something different to the RX
singleline_comment|// channel we are trying to close to force Horizon to flush the rx
singleline_comment|// channel read and write pointers.
id|u16
id|other
op_assign
id|vc
op_xor
(paren
id|RX_CHANS
op_div
l_int|2
)paren
suffix:semicolon
id|SELECT_RX_CHANNEL
(paren
id|dev
comma
id|other
)paren
suffix:semicolon
id|WAIT_UPDATE_COMPLETE
(paren
id|dev
)paren
suffix:semicolon
id|r1
op_assign
id|rd_mem
(paren
id|dev
comma
op_amp
id|rx_desc-&gt;rd_buf_type
)paren
suffix:semicolon
singleline_comment|// Select this RX channel. Flush doesn&squot;t seem to work unless we
singleline_comment|// select an RX channel before hand
id|SELECT_RX_CHANNEL
(paren
id|dev
comma
id|vc
)paren
suffix:semicolon
id|WAIT_UPDATE_COMPLETE
(paren
id|dev
)paren
suffix:semicolon
singleline_comment|// Attempt to flush a frame on this RX channel
id|FLUSH_RX_CHANNEL
(paren
id|dev
comma
id|vc
)paren
suffix:semicolon
id|WAIT_FLUSH_RX_COMPLETE
(paren
id|dev
)paren
suffix:semicolon
singleline_comment|// Force Horizon to flush rx channel read and write pointers as before
id|SELECT_RX_CHANNEL
(paren
id|dev
comma
id|other
)paren
suffix:semicolon
id|WAIT_UPDATE_COMPLETE
(paren
id|dev
)paren
suffix:semicolon
id|r2
op_assign
id|rd_mem
(paren
id|dev
comma
op_amp
id|rx_desc-&gt;rd_buf_type
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_VCC
op_or
id|DBG_RX
comma
l_string|&quot;r1 = %u, r2 = %u&quot;
comma
id|r1
comma
id|r2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r1
op_eq
id|r2
)paren
(brace
id|dev-&gt;spare_buffers
(braket
id|dev-&gt;noof_spare_buffers
op_increment
)braket
op_assign
(paren
id|u16
)paren
id|r1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#if 0
(brace
id|rx_q_entry
op_star
id|wr_ptr
op_assign
op_amp
id|memmap-&gt;rx_q_entries
(braket
id|rd_regw
(paren
id|dev
comma
id|RX_QUEUE_WR_PTR_OFF
)paren
)braket
suffix:semicolon
id|rx_q_entry
op_star
id|rd_ptr
op_assign
id|dev-&gt;rx_q_entry
suffix:semicolon
id|PRINTD
(paren
id|DBG_VCC
op_or
id|DBG_RX
comma
l_string|&quot;rd_ptr = %u, wr_ptr = %u&quot;
comma
id|rd_ptr
comma
id|wr_ptr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|rd_ptr
op_ne
id|wr_ptr
)paren
(brace
id|u32
id|x
op_assign
id|rd_mem
(paren
id|dev
comma
(paren
id|HDW
op_star
)paren
id|rd_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vc
op_eq
id|rx_q_entry_to_rx_channel
(paren
id|x
)paren
)paren
(brace
id|x
op_or_assign
id|SIMONS_DODGEY_MARKER
suffix:semicolon
id|PRINTD
(paren
id|DBG_RX
op_or
id|DBG_VCC
op_or
id|DBG_WARN
comma
l_string|&quot;marking a frame as dodgey&quot;
)paren
suffix:semicolon
id|wr_mem
(paren
id|dev
comma
(paren
id|HDW
op_star
)paren
id|rd_ptr
comma
id|x
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rd_ptr
op_eq
id|dev-&gt;rx_q_wrap
)paren
id|rd_ptr
op_assign
id|dev-&gt;rx_q_reset
suffix:semicolon
r_else
id|rd_ptr
op_increment
suffix:semicolon
)brace
)brace
macro_line|#endif
id|spin_unlock_irqrestore
(paren
op_amp
id|dev-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/********** schedule RX transfers **********/
singleline_comment|// Note on tail recursion: a GCC developer said that it is not likely
singleline_comment|// to be fixed soon, so do not define TAILRECUSRIONWORKS unless you
singleline_comment|// are sure it does as you may otherwise overflow the kernel stack.
singleline_comment|// giving this fn a return value would help GCC, alledgedly
DECL|function|rx_schedule
r_static
r_void
id|rx_schedule
(paren
id|hrz_dev
op_star
id|dev
comma
r_int
id|irq
)paren
(brace
r_int
r_int
id|rx_bytes
suffix:semicolon
r_int
id|pio_instead
op_assign
l_int|0
suffix:semicolon
macro_line|#ifndef TAILRECURSIONWORKS
id|pio_instead
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|pio_instead
)paren
(brace
macro_line|#endif
singleline_comment|// bytes waiting for RX transfer
id|rx_bytes
op_assign
id|dev-&gt;rx_bytes
suffix:semicolon
macro_line|#if 0
id|spin_count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|rd_regl
(paren
id|dev
comma
id|MASTER_RX_COUNT_REG_OFF
)paren
)paren
(brace
id|PRINTD
(paren
id|DBG_RX
op_or
id|DBG_WARN
comma
l_string|&quot;RX error: other PCI Bus Master RX still in progress!&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|spin_count
OG
l_int|10
)paren
(brace
id|PRINTD
(paren
id|DBG_RX
op_or
id|DBG_ERR
comma
l_string|&quot;spun out waiting PCI Bus Master RX completion&quot;
)paren
suffix:semicolon
id|wr_regl
(paren
id|dev
comma
id|MASTER_RX_COUNT_REG_OFF
comma
l_int|0
)paren
suffix:semicolon
id|clear_bit
(paren
id|rx_busy
comma
op_amp
id|dev-&gt;flags
)paren
suffix:semicolon
id|hrz_kfree_skb
(paren
id|dev-&gt;rx_skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif
singleline_comment|// this code follows the TX code but (at the moment) there is only
singleline_comment|// one region - the skb itself. I don&squot;t know if this will change,
singleline_comment|// but it doesn&squot;t hurt to have the code here, disabled.
r_if
c_cond
(paren
id|rx_bytes
)paren
(brace
singleline_comment|// start next transfer within same region
r_if
c_cond
(paren
id|rx_bytes
op_le
id|MAX_PIO_COUNT
)paren
(brace
id|PRINTD
(paren
id|DBG_RX
op_or
id|DBG_BUS
comma
l_string|&quot;(pio)&quot;
)paren
suffix:semicolon
id|pio_instead
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rx_bytes
op_le
id|MAX_TRANSFER_COUNT
)paren
(brace
id|PRINTD
(paren
id|DBG_RX
op_or
id|DBG_BUS
comma
l_string|&quot;(simple or last multi)&quot;
)paren
suffix:semicolon
id|dev-&gt;rx_bytes
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_RX
op_or
id|DBG_BUS
comma
l_string|&quot;(continuing multi)&quot;
)paren
suffix:semicolon
id|dev-&gt;rx_bytes
op_assign
id|rx_bytes
op_minus
id|MAX_TRANSFER_COUNT
suffix:semicolon
id|rx_bytes
op_assign
id|MAX_TRANSFER_COUNT
suffix:semicolon
)brace
)brace
r_else
(brace
singleline_comment|// rx_bytes == 0 -- we&squot;re between regions
singleline_comment|// regions remaining to transfer
macro_line|#if 0
r_int
r_int
id|rx_regions
op_assign
id|dev-&gt;rx_regions
suffix:semicolon
macro_line|#else
r_int
r_int
id|rx_regions
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|rx_regions
)paren
(brace
macro_line|#if 0
singleline_comment|// start a new region
id|dev-&gt;rx_addr
op_assign
id|dev-&gt;rx_iovec-&gt;iov_base
suffix:semicolon
id|rx_bytes
op_assign
id|dev-&gt;rx_iovec-&gt;iov_len
suffix:semicolon
op_increment
id|dev-&gt;rx_iovec
suffix:semicolon
id|dev-&gt;rx_regions
op_assign
id|rx_regions
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|rx_bytes
op_le
id|MAX_PIO_COUNT
)paren
(brace
id|PRINTD
(paren
id|DBG_RX
op_or
id|DBG_BUS
comma
l_string|&quot;(pio)&quot;
)paren
suffix:semicolon
id|pio_instead
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rx_bytes
op_le
id|MAX_TRANSFER_COUNT
)paren
(brace
id|PRINTD
(paren
id|DBG_RX
op_or
id|DBG_BUS
comma
l_string|&quot;(full region)&quot;
)paren
suffix:semicolon
id|dev-&gt;rx_bytes
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_RX
op_or
id|DBG_BUS
comma
l_string|&quot;(start multi region)&quot;
)paren
suffix:semicolon
id|dev-&gt;rx_bytes
op_assign
id|rx_bytes
op_minus
id|MAX_TRANSFER_COUNT
suffix:semicolon
id|rx_bytes
op_assign
id|MAX_TRANSFER_COUNT
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
(brace
singleline_comment|// rx_regions == 0
singleline_comment|// that&squot;s all folks - end of frame
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|dev-&gt;rx_skb
suffix:semicolon
singleline_comment|// dev-&gt;rx_iovec = 0;
id|FLUSH_RX_CHANNEL
(paren
id|dev
comma
id|dev-&gt;rx_channel
)paren
suffix:semicolon
id|dump_skb
(paren
l_string|&quot;&lt;&lt;&lt;&quot;
comma
id|dev-&gt;rx_channel
comma
id|skb
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_RX
op_or
id|DBG_SKB
comma
l_string|&quot;push %p %u&quot;
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
(brace
r_struct
id|atm_vcc
op_star
id|vcc
op_assign
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc
suffix:semicolon
singleline_comment|// VC layer stats
id|atomic_inc
c_func
(paren
op_amp
id|vcc-&gt;stats-&gt;rx
)paren
suffix:semicolon
id|skb-&gt;stamp
op_assign
id|xtime
suffix:semicolon
singleline_comment|// end of our responsability
id|vcc-&gt;push
(paren
id|vcc
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
)brace
singleline_comment|// note: writing RX_COUNT clears any interrupt condition
r_if
c_cond
(paren
id|rx_bytes
)paren
(brace
r_if
c_cond
(paren
id|pio_instead
)paren
(brace
r_if
c_cond
(paren
id|irq
)paren
id|wr_regl
(paren
id|dev
comma
id|MASTER_RX_COUNT_REG_OFF
comma
l_int|0
)paren
suffix:semicolon
id|rds_regb
(paren
id|dev
comma
id|DATA_PORT_OFF
comma
id|dev-&gt;rx_addr
comma
id|rx_bytes
)paren
suffix:semicolon
)brace
r_else
(brace
id|wr_regl
(paren
id|dev
comma
id|MASTER_RX_ADDR_REG_OFF
comma
id|virt_to_bus
(paren
id|dev-&gt;rx_addr
)paren
)paren
suffix:semicolon
id|wr_regl
(paren
id|dev
comma
id|MASTER_RX_COUNT_REG_OFF
comma
id|rx_bytes
)paren
suffix:semicolon
)brace
id|dev-&gt;rx_addr
op_add_assign
id|rx_bytes
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|irq
)paren
id|wr_regl
(paren
id|dev
comma
id|MASTER_RX_COUNT_REG_OFF
comma
l_int|0
)paren
suffix:semicolon
singleline_comment|// allow another RX thread to start
id|YELLOW_LED_ON
c_func
(paren
id|dev
)paren
suffix:semicolon
id|clear_bit
(paren
id|rx_busy
comma
op_amp
id|dev-&gt;flags
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_RX
comma
l_string|&quot;cleared rx_busy for dev %p&quot;
comma
id|dev
)paren
suffix:semicolon
)brace
macro_line|#ifdef TAILRECURSIONWORKS
singleline_comment|// and we all bless optimised tail calls
r_if
c_cond
(paren
id|pio_instead
)paren
r_return
id|rx_schedule
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#else
singleline_comment|// grrrrrrr!
id|irq
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/********** handle RX bus master complete events **********/
DECL|function|rx_bus_master_complete_handler
r_static
r_inline
r_void
id|rx_bus_master_complete_handler
(paren
id|hrz_dev
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|test_bit
(paren
id|rx_busy
comma
op_amp
id|dev-&gt;flags
)paren
)paren
(brace
id|rx_schedule
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_RX
op_or
id|DBG_ERR
comma
l_string|&quot;unexpected RX bus master completion&quot;
)paren
suffix:semicolon
singleline_comment|// clear interrupt condition on adapter
id|wr_regl
(paren
id|dev
comma
id|MASTER_RX_COUNT_REG_OFF
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/********** (queue to) become the next TX thread **********/
DECL|function|tx_hold
r_static
r_inline
r_int
id|tx_hold
(paren
id|hrz_dev
op_star
id|dev
)paren
(brace
r_while
c_loop
(paren
id|test_and_set_bit
(paren
id|tx_busy
comma
op_amp
id|dev-&gt;flags
)paren
)paren
(brace
id|PRINTD
(paren
id|DBG_TX
comma
l_string|&quot;sleeping at tx lock %p %u&quot;
comma
id|dev
comma
id|dev-&gt;flags
)paren
suffix:semicolon
id|interruptible_sleep_on
(paren
op_amp
id|dev-&gt;tx_queue
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_TX
comma
l_string|&quot;woken at tx lock %p %u&quot;
comma
id|dev
comma
id|dev-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|PRINTD
(paren
id|DBG_TX
comma
l_string|&quot;set tx_busy for dev %p&quot;
comma
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/********** allow another TX thread to start **********/
DECL|function|tx_release
r_static
r_inline
r_void
id|tx_release
(paren
id|hrz_dev
op_star
id|dev
)paren
(brace
id|clear_bit
(paren
id|tx_busy
comma
op_amp
id|dev-&gt;flags
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_TX
comma
l_string|&quot;cleared tx_busy for dev %p&quot;
comma
id|dev
)paren
suffix:semicolon
id|wake_up_interruptible
(paren
op_amp
id|dev-&gt;tx_queue
)paren
suffix:semicolon
)brace
multiline_comment|/********** schedule TX transfers **********/
DECL|function|tx_schedule
r_static
r_void
id|tx_schedule
(paren
id|hrz_dev
op_star
r_const
id|dev
comma
r_int
id|irq
)paren
(brace
r_int
r_int
id|tx_bytes
suffix:semicolon
r_int
id|append_desc
op_assign
l_int|0
suffix:semicolon
r_int
id|pio_instead
op_assign
l_int|0
suffix:semicolon
macro_line|#ifndef TAILRECURSIONWORKS
id|pio_instead
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|pio_instead
)paren
(brace
macro_line|#endif
singleline_comment|// bytes in current region waiting for TX transfer
id|tx_bytes
op_assign
id|dev-&gt;tx_bytes
suffix:semicolon
macro_line|#if 0
id|spin_count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|rd_regl
(paren
id|dev
comma
id|MASTER_TX_COUNT_REG_OFF
)paren
)paren
(brace
id|PRINTD
(paren
id|DBG_TX
op_or
id|DBG_WARN
comma
l_string|&quot;TX error: other PCI Bus Master TX still in progress!&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|spin_count
OG
l_int|10
)paren
(brace
id|PRINTD
(paren
id|DBG_TX
op_or
id|DBG_ERR
comma
l_string|&quot;spun out waiting PCI Bus Master TX completion&quot;
)paren
suffix:semicolon
id|wr_regl
(paren
id|dev
comma
id|MASTER_TX_COUNT_REG_OFF
comma
l_int|0
)paren
suffix:semicolon
id|tx_release
(paren
id|dev
)paren
suffix:semicolon
id|hrz_kfree_skb
(paren
id|dev-&gt;tx_skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|tx_bytes
)paren
(brace
singleline_comment|// start next transfer within same region
r_if
c_cond
(paren
op_logical_neg
id|test_bit
(paren
id|ultra
comma
op_amp
id|dev-&gt;flags
)paren
op_logical_or
id|tx_bytes
op_le
id|MAX_PIO_COUNT
)paren
(brace
id|PRINTD
(paren
id|DBG_TX
op_or
id|DBG_BUS
comma
l_string|&quot;(pio)&quot;
)paren
suffix:semicolon
id|pio_instead
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tx_bytes
op_le
id|MAX_TRANSFER_COUNT
)paren
(brace
id|PRINTD
(paren
id|DBG_TX
op_or
id|DBG_BUS
comma
l_string|&quot;(simple or last multi)&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;tx_iovec
)paren
(brace
singleline_comment|// end of last region
id|append_desc
op_assign
l_int|1
suffix:semicolon
)brace
id|dev-&gt;tx_bytes
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_TX
op_or
id|DBG_BUS
comma
l_string|&quot;(continuing multi)&quot;
)paren
suffix:semicolon
id|dev-&gt;tx_bytes
op_assign
id|tx_bytes
op_minus
id|MAX_TRANSFER_COUNT
suffix:semicolon
id|tx_bytes
op_assign
id|MAX_TRANSFER_COUNT
suffix:semicolon
)brace
)brace
r_else
(brace
singleline_comment|// tx_bytes == 0 -- we&squot;re between regions
singleline_comment|// regions remaining to transfer
r_int
r_int
id|tx_regions
op_assign
id|dev-&gt;tx_regions
suffix:semicolon
r_if
c_cond
(paren
id|tx_regions
)paren
(brace
singleline_comment|// start a new region
id|dev-&gt;tx_addr
op_assign
id|dev-&gt;tx_iovec-&gt;iov_base
suffix:semicolon
id|tx_bytes
op_assign
id|dev-&gt;tx_iovec-&gt;iov_len
suffix:semicolon
op_increment
id|dev-&gt;tx_iovec
suffix:semicolon
id|dev-&gt;tx_regions
op_assign
id|tx_regions
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
(paren
id|ultra
comma
op_amp
id|dev-&gt;flags
)paren
op_logical_or
id|tx_bytes
op_le
id|MAX_PIO_COUNT
)paren
(brace
id|PRINTD
(paren
id|DBG_TX
op_or
id|DBG_BUS
comma
l_string|&quot;(pio)&quot;
)paren
suffix:semicolon
id|pio_instead
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tx_bytes
op_le
id|MAX_TRANSFER_COUNT
)paren
(brace
id|PRINTD
(paren
id|DBG_TX
op_or
id|DBG_BUS
comma
l_string|&quot;(full region)&quot;
)paren
suffix:semicolon
id|dev-&gt;tx_bytes
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_TX
op_or
id|DBG_BUS
comma
l_string|&quot;(start multi region)&quot;
)paren
suffix:semicolon
id|dev-&gt;tx_bytes
op_assign
id|tx_bytes
op_minus
id|MAX_TRANSFER_COUNT
suffix:semicolon
id|tx_bytes
op_assign
id|MAX_TRANSFER_COUNT
suffix:semicolon
)brace
)brace
r_else
(brace
singleline_comment|// tx_regions == 0
singleline_comment|// that&squot;s all folks - end of frame
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|dev-&gt;tx_skb
suffix:semicolon
id|dev-&gt;tx_iovec
op_assign
l_int|0
suffix:semicolon
singleline_comment|// VC layer stats
id|atomic_inc
c_func
(paren
op_amp
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc-&gt;stats-&gt;tx
)paren
suffix:semicolon
singleline_comment|// free the skb
id|hrz_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// note: writing TX_COUNT clears any interrupt condition
r_if
c_cond
(paren
id|tx_bytes
)paren
(brace
r_if
c_cond
(paren
id|pio_instead
)paren
(brace
r_if
c_cond
(paren
id|irq
)paren
id|wr_regl
(paren
id|dev
comma
id|MASTER_TX_COUNT_REG_OFF
comma
l_int|0
)paren
suffix:semicolon
id|wrs_regb
(paren
id|dev
comma
id|DATA_PORT_OFF
comma
id|dev-&gt;tx_addr
comma
id|tx_bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|append_desc
)paren
id|wr_regl
(paren
id|dev
comma
id|TX_DESCRIPTOR_PORT_OFF
comma
id|cpu_to_be32
(paren
id|dev-&gt;tx_skb-&gt;len
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|wr_regl
(paren
id|dev
comma
id|MASTER_TX_ADDR_REG_OFF
comma
id|virt_to_bus
(paren
id|dev-&gt;tx_addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|append_desc
)paren
id|wr_regl
(paren
id|dev
comma
id|TX_DESCRIPTOR_REG_OFF
comma
id|cpu_to_be32
(paren
id|dev-&gt;tx_skb-&gt;len
)paren
)paren
suffix:semicolon
id|wr_regl
(paren
id|dev
comma
id|MASTER_TX_COUNT_REG_OFF
comma
id|append_desc
ques
c_cond
id|tx_bytes
op_or
id|MASTER_TX_AUTO_APPEND_DESC
suffix:colon
id|tx_bytes
)paren
suffix:semicolon
)brace
id|dev-&gt;tx_addr
op_add_assign
id|tx_bytes
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|irq
)paren
id|wr_regl
(paren
id|dev
comma
id|MASTER_TX_COUNT_REG_OFF
comma
l_int|0
)paren
suffix:semicolon
id|YELLOW_LED_ON
c_func
(paren
id|dev
)paren
suffix:semicolon
id|tx_release
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#ifdef TAILRECURSIONWORKS
singleline_comment|// and we all bless optimised tail calls
r_if
c_cond
(paren
id|pio_instead
)paren
r_return
id|tx_schedule
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#else
singleline_comment|// grrrrrrr!
id|irq
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/********** handle TX bus master complete events **********/
DECL|function|tx_bus_master_complete_handler
r_static
r_inline
r_void
id|tx_bus_master_complete_handler
(paren
id|hrz_dev
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|test_bit
(paren
id|tx_busy
comma
op_amp
id|dev-&gt;flags
)paren
)paren
(brace
id|tx_schedule
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_TX
op_or
id|DBG_ERR
comma
l_string|&quot;unexpected TX bus master completion&quot;
)paren
suffix:semicolon
singleline_comment|// clear interrupt condition on adapter
id|wr_regl
(paren
id|dev
comma
id|MASTER_TX_COUNT_REG_OFF
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/********** move RX Q pointer to next item in circular buffer **********/
singleline_comment|// called only from IRQ sub-handler
DECL|function|rx_queue_entry_next
r_static
r_inline
id|u32
id|rx_queue_entry_next
(paren
id|hrz_dev
op_star
id|dev
)paren
(brace
id|u32
id|rx_queue_entry
suffix:semicolon
id|spin_lock
(paren
op_amp
id|dev-&gt;mem_lock
)paren
suffix:semicolon
id|rx_queue_entry
op_assign
id|rd_mem
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_q_entry-&gt;entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;rx_q_entry
op_eq
id|dev-&gt;rx_q_wrap
)paren
id|dev-&gt;rx_q_entry
op_assign
id|dev-&gt;rx_q_reset
suffix:semicolon
r_else
id|dev-&gt;rx_q_entry
op_increment
suffix:semicolon
id|wr_regw
(paren
id|dev
comma
id|RX_QUEUE_RD_PTR_OFF
comma
id|dev-&gt;rx_q_entry
op_minus
id|dev-&gt;rx_q_reset
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|dev-&gt;mem_lock
)paren
suffix:semicolon
r_return
id|rx_queue_entry
suffix:semicolon
)brace
multiline_comment|/********** handle RX disabled by device **********/
DECL|function|rx_disabled_handler
r_static
r_inline
r_void
id|rx_disabled_handler
(paren
id|hrz_dev
op_star
id|dev
)paren
(brace
id|wr_regw
(paren
id|dev
comma
id|RX_CONFIG_OFF
comma
id|rd_regw
(paren
id|dev
comma
id|RX_CONFIG_OFF
)paren
op_or
id|RX_ENABLE
)paren
suffix:semicolon
singleline_comment|// count me please
id|PRINTK
(paren
id|KERN_WARNING
comma
l_string|&quot;RX was disabled!&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/********** handle RX data received by device **********/
singleline_comment|// called from IRQ handler
DECL|function|rx_data_av_handler
r_static
r_inline
r_void
id|rx_data_av_handler
(paren
id|hrz_dev
op_star
id|dev
)paren
(brace
id|u32
id|rx_queue_entry
suffix:semicolon
id|u32
id|rx_queue_entry_flags
suffix:semicolon
id|u16
id|rx_len
suffix:semicolon
id|u16
id|rx_channel
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
comma
l_string|&quot;hrz_data_av_handler&quot;
)paren
suffix:semicolon
singleline_comment|// try to grab rx lock (not possible during RX bus mastering)
r_if
c_cond
(paren
id|test_and_set_bit
(paren
id|rx_busy
comma
op_amp
id|dev-&gt;flags
)paren
)paren
(brace
id|PRINTD
(paren
id|DBG_RX
comma
l_string|&quot;locked out of rx lock&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|PRINTD
(paren
id|DBG_RX
comma
l_string|&quot;set rx_busy for dev %p&quot;
comma
id|dev
)paren
suffix:semicolon
singleline_comment|// lock is cleared if we fail now, o/w after bus master completion
id|YELLOW_LED_OFF
c_func
(paren
id|dev
)paren
suffix:semicolon
id|rx_queue_entry
op_assign
id|rx_queue_entry_next
(paren
id|dev
)paren
suffix:semicolon
id|rx_len
op_assign
id|rx_q_entry_to_length
(paren
id|rx_queue_entry
)paren
suffix:semicolon
id|rx_channel
op_assign
id|rx_q_entry_to_rx_channel
(paren
id|rx_queue_entry
)paren
suffix:semicolon
id|WAIT_FLUSH_RX_COMPLETE
(paren
id|dev
)paren
suffix:semicolon
id|SELECT_RX_CHANNEL
(paren
id|dev
comma
id|rx_channel
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_RX
comma
l_string|&quot;rx_queue_entry is: %#x&quot;
comma
id|rx_queue_entry
)paren
suffix:semicolon
id|rx_queue_entry_flags
op_assign
id|rx_queue_entry
op_amp
(paren
id|RX_CRC_32_OK
op_or
id|RX_COMPLETE_FRAME
op_or
id|SIMONS_DODGEY_MARKER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rx_len
)paren
(brace
singleline_comment|// (at least) bus-mastering breaks if we try to handle a
singleline_comment|// zero-length frame, besides AAL5 does not support them
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;zero-length frame!&quot;
)paren
suffix:semicolon
id|rx_queue_entry_flags
op_and_assign
op_complement
id|RX_COMPLETE_FRAME
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rx_queue_entry_flags
op_amp
id|SIMONS_DODGEY_MARKER
)paren
(brace
id|PRINTD
(paren
id|DBG_RX
op_or
id|DBG_ERR
comma
l_string|&quot;Simon&squot;s marker detected!&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rx_queue_entry_flags
op_eq
(paren
id|RX_CRC_32_OK
op_or
id|RX_COMPLETE_FRAME
)paren
)paren
(brace
r_struct
id|atm_vcc
op_star
id|atm_vcc
suffix:semicolon
id|PRINTD
(paren
id|DBG_RX
comma
l_string|&quot;got a frame on rx_channel %x len %u&quot;
comma
id|rx_channel
comma
id|rx_len
)paren
suffix:semicolon
id|atm_vcc
op_assign
id|dev-&gt;rxer
(braket
id|rx_channel
)braket
suffix:semicolon
singleline_comment|// if no vcc is assigned to this channel, we should drop the frame
singleline_comment|// (is this what SIMONS etc. was trying to achieve?)
r_if
c_cond
(paren
id|atm_vcc
)paren
(brace
r_if
c_cond
(paren
id|atm_vcc-&gt;qos.rxtp.traffic_class
op_ne
id|ATM_NONE
)paren
(brace
r_if
c_cond
(paren
id|rx_len
op_le
id|atm_vcc-&gt;qos.rxtp.max_sdu
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|atm_alloc_charge
(paren
id|atm_vcc
comma
id|rx_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
singleline_comment|// remember this so we can push it later
id|dev-&gt;rx_skb
op_assign
id|skb
suffix:semicolon
singleline_comment|// remember this so we can flush it later
id|dev-&gt;rx_channel
op_assign
id|rx_channel
suffix:semicolon
singleline_comment|// prepare socket buffer
id|skb_put
(paren
id|skb
comma
id|rx_len
)paren
suffix:semicolon
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc
op_assign
id|atm_vcc
suffix:semicolon
singleline_comment|// simple transfer
singleline_comment|// dev-&gt;rx_regions = 0;
singleline_comment|// dev-&gt;rx_iovec = 0;
id|dev-&gt;rx_bytes
op_assign
id|rx_len
suffix:semicolon
id|dev-&gt;rx_addr
op_assign
id|skb-&gt;data
suffix:semicolon
id|PRINTD
(paren
id|DBG_RX
comma
l_string|&quot;RX start simple transfer (addr %p, len %d)&quot;
comma
id|skb-&gt;data
comma
id|rx_len
)paren
suffix:semicolon
singleline_comment|// do the business
id|rx_schedule
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_SKB
op_or
id|DBG_WARN
comma
l_string|&quot;failed to get skb&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|PRINTK
(paren
id|KERN_INFO
comma
l_string|&quot;frame received on TX-only VC %x&quot;
comma
id|rx_channel
)paren
suffix:semicolon
singleline_comment|// do we count this?
)brace
)brace
r_else
(brace
id|PRINTK
(paren
id|KERN_WARNING
comma
l_string|&quot;dropped over-size frame&quot;
)paren
suffix:semicolon
singleline_comment|// do we count this?
)brace
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_WARN
op_or
id|DBG_VCC
op_or
id|DBG_RX
comma
l_string|&quot;no VCC for this frame (VC closed)&quot;
)paren
suffix:semicolon
singleline_comment|// do we count this?
)brace
)brace
r_else
(brace
singleline_comment|// Wait update complete ? SPONG
)brace
singleline_comment|// RX was aborted
id|YELLOW_LED_ON
c_func
(paren
id|dev
)paren
suffix:semicolon
id|FLUSH_RX_CHANNEL
(paren
id|dev
comma
id|rx_channel
)paren
suffix:semicolon
id|clear_bit
(paren
id|rx_busy
comma
op_amp
id|dev-&gt;flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/********** interrupt handler **********/
DECL|function|interrupt_handler
r_static
r_void
id|interrupt_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|pt_regs
)paren
(brace
id|hrz_dev
op_star
id|dev
op_assign
id|hrz_devs
suffix:semicolon
id|u32
id|int_source
suffix:semicolon
r_int
r_int
id|irq_ok
suffix:semicolon
(paren
r_void
)paren
id|pt_regs
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
comma
l_string|&quot;interrupt_handler: %p&quot;
comma
id|dev_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev_id
)paren
(brace
id|PRINTD
(paren
id|DBG_IRQ
op_or
id|DBG_ERR
comma
l_string|&quot;irq with NULL dev_id: %d&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|// Did one of our cards generate the interrupt?
r_while
c_loop
(paren
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev
op_eq
id|dev_id
)paren
r_break
suffix:semicolon
id|dev
op_assign
id|dev-&gt;prev
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|PRINTD
(paren
id|DBG_IRQ
comma
l_string|&quot;irq not for me: %d&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq
op_ne
id|dev-&gt;irq
)paren
(brace
id|PRINTD
(paren
id|DBG_IRQ
op_or
id|DBG_ERR
comma
l_string|&quot;irq mismatch: %d&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|// definitely for us
id|irq_ok
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|int_source
op_assign
id|rd_regl
(paren
id|dev
comma
id|INT_SOURCE_REG_OFF
)paren
op_amp
id|INTERESTING_INTERRUPTS
)paren
)paren
(brace
singleline_comment|// In the interests of fairness, the (inline) handlers below are
singleline_comment|// called in sequence and without immediate return to the head of
singleline_comment|// the while loop. This is only of issue for slow hosts (or when
singleline_comment|// debugging messages are on). Really slow hosts may find a fast
singleline_comment|// sender keeps them permanently in the IRQ handler. :(
singleline_comment|// (only an issue for slow hosts) RX completion goes before
singleline_comment|// rx_data_av as the former implies rx_busy and so the latter
singleline_comment|// would just abort. If it reschedules another transfer
singleline_comment|// (continuing the same frame) then it will not clear rx_busy.
singleline_comment|// (only an issue for slow hosts) TX completion goes before RX
singleline_comment|// data available as it is a much shorter routine - there is the
singleline_comment|// chance that any further transfers it schedules will be complete
singleline_comment|// by the time of the return to the head of the while loop
r_if
c_cond
(paren
id|int_source
op_amp
id|RX_BUS_MASTER_COMPLETE
)paren
(brace
op_increment
id|irq_ok
suffix:semicolon
id|PRINTD
(paren
id|DBG_IRQ
op_or
id|DBG_BUS
op_or
id|DBG_RX
comma
l_string|&quot;rx_bus_master_complete asserted&quot;
)paren
suffix:semicolon
id|rx_bus_master_complete_handler
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|int_source
op_amp
id|TX_BUS_MASTER_COMPLETE
)paren
(brace
op_increment
id|irq_ok
suffix:semicolon
id|PRINTD
(paren
id|DBG_IRQ
op_or
id|DBG_BUS
op_or
id|DBG_TX
comma
l_string|&quot;tx_bus_master_complete asserted&quot;
)paren
suffix:semicolon
id|tx_bus_master_complete_handler
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|int_source
op_amp
id|RX_DATA_AV
)paren
(brace
op_increment
id|irq_ok
suffix:semicolon
id|PRINTD
(paren
id|DBG_IRQ
op_or
id|DBG_RX
comma
l_string|&quot;rx_data_av asserted&quot;
)paren
suffix:semicolon
id|rx_data_av_handler
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|irq_ok
)paren
(brace
id|PRINTD
(paren
id|DBG_IRQ
comma
l_string|&quot;work done: %u&quot;
comma
id|irq_ok
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_IRQ
op_or
id|DBG_WARN
comma
l_string|&quot;spurious interrupt source: %#x&quot;
comma
id|int_source
)paren
suffix:semicolon
)brace
id|PRINTD
(paren
id|DBG_IRQ
op_or
id|DBG_FLOW
comma
l_string|&quot;interrupt_handler done: %p&quot;
comma
id|dev_id
)paren
suffix:semicolon
)brace
multiline_comment|/********** housekeeping **********/
DECL|function|set_timer
r_static
r_void
id|set_timer
(paren
r_struct
id|timer_list
op_star
id|timer
comma
r_int
r_int
id|delay
)paren
(brace
id|timer-&gt;expires
op_assign
id|jiffies
op_plus
id|delay
suffix:semicolon
id|add_timer
(paren
id|timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|do_housekeeping
r_static
r_void
id|do_housekeeping
(paren
r_int
r_int
id|arg
)paren
(brace
singleline_comment|// just stats at the moment
id|hrz_dev
op_star
id|dev
op_assign
id|hrz_devs
suffix:semicolon
(paren
r_void
)paren
id|arg
suffix:semicolon
singleline_comment|// data is set to zero at module unload
r_if
c_cond
(paren
id|housekeeping.data
)paren
(brace
r_while
c_loop
(paren
id|dev
)paren
(brace
singleline_comment|// collect device-specific (not driver/atm-linux) stats here
id|dev-&gt;tx_cell_count
op_add_assign
id|rd_regw
(paren
id|dev
comma
id|TX_CELL_COUNT_OFF
)paren
suffix:semicolon
id|dev-&gt;rx_cell_count
op_add_assign
id|rd_regw
(paren
id|dev
comma
id|RX_CELL_COUNT_OFF
)paren
suffix:semicolon
id|dev-&gt;hec_error_count
op_add_assign
id|rd_regw
(paren
id|dev
comma
id|HEC_ERROR_COUNT_OFF
)paren
suffix:semicolon
id|dev-&gt;unassigned_cell_count
op_add_assign
id|rd_regw
(paren
id|dev
comma
id|UNASSIGNED_CELL_COUNT_OFF
)paren
suffix:semicolon
id|dev
op_assign
id|dev-&gt;prev
suffix:semicolon
)brace
id|set_timer
(paren
op_amp
id|housekeeping
comma
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/********** find an idle channel for TX and set it up **********/
singleline_comment|// called with tx_busy set
DECL|function|setup_idle_tx_channel
r_static
r_inline
r_int
id|setup_idle_tx_channel
(paren
id|hrz_dev
op_star
id|dev
comma
id|hrz_vcc
op_star
id|vcc
)paren
(brace
r_int
r_int
id|idle_channels
suffix:semicolon
r_int
id|tx_channel
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|spin_count
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_TX
comma
l_string|&quot;setup_idle_tx_channel %p&quot;
comma
id|dev
)paren
suffix:semicolon
singleline_comment|// better would be to fail immediately, the caller can then decide whether
singleline_comment|// to wait or drop (depending on whether this is UBR etc.)
id|spin_count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|idle_channels
op_assign
id|rd_regw
(paren
id|dev
comma
id|TX_STATUS_OFF
)paren
op_amp
id|IDLE_CHANNELS_MASK
)paren
)paren
(brace
id|PRINTD
(paren
id|DBG_TX
op_or
id|DBG_WARN
comma
l_string|&quot;waiting for idle TX channel&quot;
)paren
suffix:semicolon
singleline_comment|// delay a bit here
r_if
c_cond
(paren
op_increment
id|spin_count
OG
l_int|100
)paren
(brace
id|PRINTD
(paren
id|DBG_TX
op_or
id|DBG_ERR
comma
l_string|&quot;spun out waiting for idle TX channel&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
singleline_comment|// got an idle channel
(brace
singleline_comment|// tx_idle ensures we look for idle channels in RR order
r_int
id|chan
op_assign
id|dev-&gt;tx_idle
suffix:semicolon
r_int
id|keep_going
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|keep_going
)paren
(brace
r_if
c_cond
(paren
id|idle_channels
op_amp
(paren
l_int|1
op_lshift
id|chan
)paren
)paren
(brace
id|tx_channel
op_assign
id|chan
suffix:semicolon
id|keep_going
op_assign
l_int|0
suffix:semicolon
)brace
op_increment
id|chan
suffix:semicolon
r_if
c_cond
(paren
id|chan
op_eq
id|TX_CHANS
)paren
id|chan
op_assign
l_int|0
suffix:semicolon
)brace
id|dev-&gt;tx_idle
op_assign
id|chan
suffix:semicolon
)brace
singleline_comment|// set up the channel we found
(brace
singleline_comment|// Initialise the cell header in the transmit channel descriptor
singleline_comment|// a.k.a. prepare the channel and remember that we have done so.
id|tx_ch_desc
op_star
id|tx_desc
op_assign
op_amp
id|memmap-&gt;tx_descs
(braket
id|tx_channel
)braket
suffix:semicolon
id|u16
id|rd_ptr
suffix:semicolon
id|u16
id|wr_ptr
suffix:semicolon
id|u16
id|channel
op_assign
id|vcc-&gt;channel
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|dev-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// Update the transmit channel record.
id|dev-&gt;tx_channel_record
(braket
id|tx_channel
)braket
op_assign
id|channel
suffix:semicolon
singleline_comment|// xBR channel
id|update_tx_channel_config
(paren
id|dev
comma
id|tx_channel
comma
id|RATE_TYPE_ACCESS
comma
id|vcc-&gt;tx_xbr_bits
)paren
suffix:semicolon
singleline_comment|// Update the PCR counter preload value etc.
id|update_tx_channel_config
(paren
id|dev
comma
id|tx_channel
comma
id|PCR_TIMER_ACCESS
comma
id|vcc-&gt;tx_pcr_bits
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|vcc-&gt;tx_xbr_bits
op_eq
id|VBR_RATE_TYPE
)paren
(brace
singleline_comment|// SCR timer
id|update_tx_channel_config
(paren
id|dev
comma
id|tx_channel
comma
id|SCR_TIMER_ACCESS
comma
id|vcc-&gt;tx_scr_bits
)paren
suffix:semicolon
singleline_comment|// Bucket size...
id|update_tx_channel_config
(paren
id|dev
comma
id|tx_channel
comma
id|BUCKET_CAPACITY_ACCESS
comma
id|vcc-&gt;tx_bucket_bits
)paren
suffix:semicolon
singleline_comment|// ... and fullness
id|update_tx_channel_config
(paren
id|dev
comma
id|tx_channel
comma
id|BUCKET_FULLNESS_ACCESS
comma
id|vcc-&gt;tx_bucket_bits
)paren
suffix:semicolon
)brace
macro_line|#endif
singleline_comment|// Initialise the read and write buffer pointers
id|rd_ptr
op_assign
id|rd_mem
(paren
id|dev
comma
op_amp
id|tx_desc-&gt;rd_buf_type
)paren
op_amp
id|BUFFER_PTR_MASK
suffix:semicolon
id|wr_ptr
op_assign
id|rd_mem
(paren
id|dev
comma
op_amp
id|tx_desc-&gt;wr_buf_type
)paren
op_amp
id|BUFFER_PTR_MASK
suffix:semicolon
singleline_comment|// idle TX channels should have identical pointers
r_if
c_cond
(paren
id|rd_ptr
op_ne
id|wr_ptr
)paren
(brace
id|PRINTD
(paren
id|DBG_TX
op_or
id|DBG_ERR
comma
l_string|&quot;TX buffer pointers are broken!&quot;
)paren
suffix:semicolon
singleline_comment|// spin_unlock... return -E...
singleline_comment|// I wonder if gcc would get rid of one of the pointer aliases
)brace
id|PRINTD
(paren
id|DBG_TX
comma
l_string|&quot;TX buffer pointers are: rd %x, wr %x.&quot;
comma
id|rd_ptr
comma
id|wr_ptr
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|vcc-&gt;aal
)paren
(brace
r_case
id|aal0
suffix:colon
id|PRINTD
(paren
id|DBG_QOS
op_or
id|DBG_TX
comma
l_string|&quot;tx_channel: aal0&quot;
)paren
suffix:semicolon
id|rd_ptr
op_or_assign
id|CHANNEL_TYPE_RAW_CELLS
suffix:semicolon
id|wr_ptr
op_or_assign
id|CHANNEL_TYPE_RAW_CELLS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|aal34
suffix:colon
id|PRINTD
(paren
id|DBG_QOS
op_or
id|DBG_TX
comma
l_string|&quot;tx_channel: aal34&quot;
)paren
suffix:semicolon
id|rd_ptr
op_or_assign
id|CHANNEL_TYPE_AAL3_4
suffix:semicolon
id|wr_ptr
op_or_assign
id|CHANNEL_TYPE_AAL3_4
suffix:semicolon
r_break
suffix:semicolon
r_case
id|aal5
suffix:colon
id|rd_ptr
op_or_assign
id|CHANNEL_TYPE_AAL5
suffix:semicolon
id|wr_ptr
op_or_assign
id|CHANNEL_TYPE_AAL5
suffix:semicolon
singleline_comment|// Initialise the CRC
id|wr_mem
(paren
id|dev
comma
op_amp
id|tx_desc-&gt;partial_crc
comma
id|INITIAL_CRC
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|wr_mem
(paren
id|dev
comma
op_amp
id|tx_desc-&gt;rd_buf_type
comma
id|rd_ptr
)paren
suffix:semicolon
id|wr_mem
(paren
id|dev
comma
op_amp
id|tx_desc-&gt;wr_buf_type
comma
id|wr_ptr
)paren
suffix:semicolon
singleline_comment|// Write the Cell Header
singleline_comment|// Payload Type, CLP and GFC would go here if non-zero
id|wr_mem
(paren
id|dev
comma
op_amp
id|tx_desc-&gt;cell_header
comma
id|channel
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|dev-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|tx_channel
suffix:semicolon
)brace
multiline_comment|/********** send a frame **********/
DECL|function|hrz_send
r_static
r_int
id|hrz_send
(paren
r_struct
id|atm_vcc
op_star
id|atm_vcc
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
r_int
id|spin_count
suffix:semicolon
r_int
id|free_buffers
suffix:semicolon
id|hrz_dev
op_star
id|dev
op_assign
id|HRZ_DEV
c_func
(paren
id|atm_vcc-&gt;dev
)paren
suffix:semicolon
id|hrz_vcc
op_star
id|vcc
op_assign
id|HRZ_VCC
c_func
(paren
id|atm_vcc
)paren
suffix:semicolon
id|u16
id|channel
op_assign
id|vcc-&gt;channel
suffix:semicolon
id|u32
id|buffers_required
suffix:semicolon
multiline_comment|/* signed for error return */
r_int
id|tx_channel
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_TX
comma
l_string|&quot;hrz_send vc %x data %p len %u&quot;
comma
id|channel
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|dump_skb
(paren
l_string|&quot;&gt;&gt;&gt;&quot;
comma
id|channel
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atm_vcc-&gt;qos.txtp.traffic_class
op_eq
id|ATM_NONE
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;attempt to send on RX-only VC %x&quot;
comma
id|channel
)paren
suffix:semicolon
id|hrz_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
singleline_comment|// don&squot;t understand this
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc
op_assign
id|atm_vcc
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|atm_vcc-&gt;qos.txtp.max_sdu
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;sk_buff length greater than agreed max_sdu, dropping...&quot;
)paren
suffix:semicolon
id|hrz_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|channel
)paren
(brace
id|PRINTD
(paren
id|DBG_ERR
op_or
id|DBG_TX
comma
l_string|&quot;attempt to transmit on zero (rx_)channel&quot;
)paren
suffix:semicolon
id|hrz_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#if 0
(brace
singleline_comment|// where would be a better place for this? housekeeping?
id|u16
id|status
suffix:semicolon
id|pci_read_config_word
(paren
id|dev-&gt;pci_dev
comma
id|PCI_STATUS
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|PCI_STATUS_REC_MASTER_ABORT
)paren
(brace
id|PRINTD
(paren
id|DBG_BUS
op_or
id|DBG_ERR
comma
l_string|&quot;Clearing PCI Master Abort (and cleaning up)&quot;
)paren
suffix:semicolon
id|status
op_and_assign
op_complement
id|PCI_STATUS_REC_MASTER_ABORT
suffix:semicolon
id|pci_write_config_word
(paren
id|dev-&gt;pci_dev
comma
id|PCI_STATUS
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
(paren
id|tx_busy
comma
op_amp
id|dev-&gt;flags
)paren
)paren
(brace
id|hrz_kfree_skb
(paren
id|dev-&gt;tx_skb
)paren
suffix:semicolon
id|tx_release
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
macro_line|#ifdef DEBUG_HORIZON
multiline_comment|/* wey-hey! */
r_if
c_cond
(paren
id|channel
op_eq
l_int|1023
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|d
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|s
op_assign
id|skb-&gt;data
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
op_increment
op_eq
l_char|&squot;D&squot;
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
id|d
op_assign
(paren
id|d
op_lshift
l_int|4
)paren
op_or
(paren
(paren
op_star
id|s
op_le
l_char|&squot;9&squot;
)paren
ques
c_cond
(paren
op_star
id|s
op_minus
l_char|&squot;0&squot;
)paren
suffix:colon
(paren
op_star
id|s
op_minus
l_char|&squot;a&squot;
op_plus
l_int|10
)paren
)paren
suffix:semicolon
op_increment
id|s
suffix:semicolon
)brace
id|PRINTK
(paren
id|KERN_INFO
comma
l_string|&quot;debug bitmap is now %hx&quot;
comma
id|debug
op_assign
id|d
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
singleline_comment|// wait until TX is free and grab lock
r_if
c_cond
(paren
id|tx_hold
(paren
id|dev
)paren
)paren
(brace
id|hrz_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
singleline_comment|// Wait for enough space to be available in transmit buffer memory.
singleline_comment|// should be number of cells needed + 2 (according to hardware docs)
singleline_comment|// = ((framelen+8)+47) / 48 + 2
singleline_comment|// = (framelen+7) / 48 + 3, hmm... faster to put addition inside XXX
id|buffers_required
op_assign
(paren
id|skb-&gt;len
op_plus
(paren
id|ATM_AAL5_TRAILER
op_minus
l_int|1
)paren
)paren
op_div
id|ATM_CELL_PAYLOAD
op_plus
l_int|3
suffix:semicolon
singleline_comment|// replace with timer and sleep, add dev-&gt;tx_buffers_queue (max 1 entry)
id|spin_count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|free_buffers
op_assign
id|rd_regw
(paren
id|dev
comma
id|TX_FREE_BUFFER_COUNT_OFF
)paren
)paren
OL
id|buffers_required
)paren
(brace
id|PRINTD
(paren
id|DBG_TX
comma
l_string|&quot;waiting for free TX buffers, got %d of %d&quot;
comma
id|free_buffers
comma
id|buffers_required
)paren
suffix:semicolon
singleline_comment|// what is the appropriate delay? implement a timeout? (depending on line speed?)
singleline_comment|// mdelay (1);
singleline_comment|// what happens if we kill (current_pid, SIGKILL) ?
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|spin_count
OG
l_int|1000
)paren
(brace
id|PRINTD
(paren
id|DBG_TX
op_or
id|DBG_ERR
comma
l_string|&quot;spun out waiting for tx buffers, got %d of %d&quot;
comma
id|free_buffers
comma
id|buffers_required
)paren
suffix:semicolon
id|tx_release
(paren
id|dev
)paren
suffix:semicolon
id|hrz_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
singleline_comment|// Select a channel to transmit the frame on.
r_if
c_cond
(paren
id|channel
op_eq
id|dev-&gt;last_vc
)paren
(brace
id|PRINTD
(paren
id|DBG_TX
comma
l_string|&quot;last vc hack: hit&quot;
)paren
suffix:semicolon
id|tx_channel
op_assign
id|dev-&gt;tx_last
suffix:semicolon
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_TX
comma
l_string|&quot;last vc hack: miss&quot;
)paren
suffix:semicolon
singleline_comment|// Are we currently transmitting this VC on one of the channels?
r_for
c_loop
(paren
id|tx_channel
op_assign
l_int|0
suffix:semicolon
id|tx_channel
OL
id|TX_CHANS
suffix:semicolon
op_increment
id|tx_channel
)paren
r_if
c_cond
(paren
id|dev-&gt;tx_channel_record
(braket
id|tx_channel
)braket
op_eq
id|channel
)paren
(brace
id|PRINTD
(paren
id|DBG_TX
comma
l_string|&quot;vc already on channel: hit&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tx_channel
op_eq
id|TX_CHANS
)paren
(brace
id|PRINTD
(paren
id|DBG_TX
comma
l_string|&quot;vc already on channel: miss&quot;
)paren
suffix:semicolon
singleline_comment|// Find and set up an idle channel.
id|tx_channel
op_assign
id|setup_idle_tx_channel
(paren
id|dev
comma
id|vcc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tx_channel
OL
l_int|0
)paren
(brace
id|PRINTD
(paren
id|DBG_TX
op_or
id|DBG_ERR
comma
l_string|&quot;failed to get channel&quot;
)paren
suffix:semicolon
id|tx_release
(paren
id|dev
)paren
suffix:semicolon
r_return
id|tx_channel
suffix:semicolon
)brace
)brace
id|PRINTD
(paren
id|DBG_TX
comma
l_string|&quot;got channel&quot;
)paren
suffix:semicolon
id|SELECT_TX_CHANNEL
c_func
(paren
id|dev
comma
id|tx_channel
)paren
suffix:semicolon
id|dev-&gt;last_vc
op_assign
id|channel
suffix:semicolon
id|dev-&gt;tx_last
op_assign
id|tx_channel
suffix:semicolon
)brace
id|PRINTD
(paren
id|DBG_TX
comma
l_string|&quot;using channel %u&quot;
comma
id|tx_channel
)paren
suffix:semicolon
id|YELLOW_LED_OFF
c_func
(paren
id|dev
)paren
suffix:semicolon
singleline_comment|// TX start transfer
(brace
r_int
r_int
id|tx_len
op_assign
id|skb-&gt;len
suffix:semicolon
r_int
r_int
id|tx_iovcnt
op_assign
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|iovcnt
suffix:semicolon
singleline_comment|// remember this so we can free it later
id|dev-&gt;tx_skb
op_assign
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|tx_iovcnt
)paren
(brace
singleline_comment|// scatter gather transfer
id|dev-&gt;tx_regions
op_assign
id|tx_iovcnt
suffix:semicolon
id|dev-&gt;tx_iovec
op_assign
(paren
r_struct
id|iovec
op_star
)paren
id|skb-&gt;data
suffix:semicolon
id|dev-&gt;tx_bytes
op_assign
l_int|0
suffix:semicolon
id|PRINTD
(paren
id|DBG_TX
op_or
id|DBG_BUS
comma
l_string|&quot;TX start scatter-gather transfer (iovec %p, len %d)&quot;
comma
id|skb-&gt;data
comma
id|tx_len
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// simple transfer
id|dev-&gt;tx_regions
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tx_iovec
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tx_bytes
op_assign
id|tx_len
suffix:semicolon
id|dev-&gt;tx_addr
op_assign
id|skb-&gt;data
suffix:semicolon
id|PRINTD
(paren
id|DBG_TX
op_or
id|DBG_BUS
comma
l_string|&quot;TX start simple transfer (addr %p, len %d)&quot;
comma
id|skb-&gt;data
comma
id|tx_len
)paren
suffix:semicolon
)brace
singleline_comment|// and do the business
id|tx_schedule
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/********** reset a card **********/
DECL|function|hrz_reset
r_static
r_void
id|__init
id|hrz_reset
(paren
r_const
id|hrz_dev
op_star
id|dev
)paren
(brace
id|u32
id|control_0_reg
op_assign
id|rd_regl
(paren
id|dev
comma
id|CONTROL_0_REG
)paren
suffix:semicolon
singleline_comment|// why not set RESET_HORIZON to one and wait for the card to
singleline_comment|// reassert that bit as zero? Like so:
id|control_0_reg
op_assign
id|control_0_reg
op_amp
id|RESET_HORIZON
suffix:semicolon
id|wr_regl
(paren
id|dev
comma
id|CONTROL_0_REG
comma
id|control_0_reg
)paren
suffix:semicolon
r_while
c_loop
(paren
id|control_0_reg
op_amp
id|RESET_HORIZON
)paren
id|control_0_reg
op_assign
id|rd_regl
(paren
id|dev
comma
id|CONTROL_0_REG
)paren
suffix:semicolon
singleline_comment|// old reset code retained:
id|wr_regl
(paren
id|dev
comma
id|CONTROL_0_REG
comma
id|control_0_reg
op_or
id|RESET_ATM
op_or
id|RESET_RX
op_or
id|RESET_TX
op_or
id|RESET_HOST
)paren
suffix:semicolon
singleline_comment|// just guessing here
id|udelay
(paren
l_int|1000
)paren
suffix:semicolon
id|wr_regl
(paren
id|dev
comma
id|CONTROL_0_REG
comma
id|control_0_reg
)paren
suffix:semicolon
)brace
multiline_comment|/********** read the burnt in address **********/
DECL|function|read_bia
r_static
id|u16
id|__init
id|read_bia
(paren
r_const
id|hrz_dev
op_star
id|dev
comma
id|u16
id|addr
)paren
(brace
id|u32
id|ctrl
op_assign
id|rd_regl
(paren
id|dev
comma
id|CONTROL_0_REG
)paren
suffix:semicolon
r_void
id|WRITE_IT_WAIT
(paren
r_void
)paren
(brace
id|wr_regl
(paren
id|dev
comma
id|CONTROL_0_REG
comma
id|ctrl
)paren
suffix:semicolon
id|udelay
(paren
l_int|5
)paren
suffix:semicolon
)brace
r_void
id|CLOCK_IT
(paren
r_void
)paren
(brace
singleline_comment|// DI must be valid around rising SK edge
id|ctrl
op_and_assign
op_complement
id|SEEPROM_SK
suffix:semicolon
id|WRITE_IT_WAIT
c_func
(paren
)paren
suffix:semicolon
id|ctrl
op_or_assign
id|SEEPROM_SK
suffix:semicolon
id|WRITE_IT_WAIT
c_func
(paren
)paren
suffix:semicolon
)brace
r_const
r_int
r_int
id|addr_bits
op_assign
l_int|6
suffix:semicolon
r_const
r_int
r_int
id|data_bits
op_assign
l_int|16
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|u16
id|res
suffix:semicolon
id|ctrl
op_and_assign
op_complement
(paren
id|SEEPROM_CS
op_or
id|SEEPROM_SK
op_or
id|SEEPROM_DI
)paren
suffix:semicolon
id|WRITE_IT_WAIT
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// wake Serial EEPROM and send 110 (READ) command
id|ctrl
op_or_assign
(paren
id|SEEPROM_CS
op_or
id|SEEPROM_DI
)paren
suffix:semicolon
id|CLOCK_IT
c_func
(paren
)paren
suffix:semicolon
id|ctrl
op_or_assign
id|SEEPROM_DI
suffix:semicolon
id|CLOCK_IT
c_func
(paren
)paren
suffix:semicolon
id|ctrl
op_and_assign
op_complement
id|SEEPROM_DI
suffix:semicolon
id|CLOCK_IT
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|addr_bits
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|addr
op_amp
(paren
l_int|1
op_lshift
(paren
id|addr_bits
op_minus
l_int|1
)paren
)paren
)paren
id|ctrl
op_or_assign
id|SEEPROM_DI
suffix:semicolon
r_else
id|ctrl
op_and_assign
op_complement
id|SEEPROM_DI
suffix:semicolon
id|CLOCK_IT
c_func
(paren
)paren
suffix:semicolon
id|addr
op_assign
id|addr
op_lshift
l_int|1
suffix:semicolon
)brace
singleline_comment|// we could check that we have DO = 0 here
id|ctrl
op_and_assign
op_complement
id|SEEPROM_DI
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|data_bits
suffix:semicolon
id|i
op_increment
)paren
(brace
id|res
op_assign
id|res
op_rshift
l_int|1
suffix:semicolon
id|CLOCK_IT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rd_regl
(paren
id|dev
comma
id|CONTROL_0_REG
)paren
op_amp
id|SEEPROM_DO
)paren
id|res
op_or_assign
(paren
l_int|1
op_lshift
(paren
id|data_bits
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
id|ctrl
op_and_assign
op_complement
(paren
id|SEEPROM_SK
op_or
id|SEEPROM_CS
)paren
suffix:semicolon
id|WRITE_IT_WAIT
c_func
(paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/********** initialise a card **********/
DECL|function|hrz_init
r_static
r_int
id|__init
id|hrz_init
(paren
id|hrz_dev
op_star
id|dev
)paren
(brace
r_int
id|onefivefive
suffix:semicolon
id|u16
id|chan
suffix:semicolon
r_int
id|buff_count
suffix:semicolon
id|HDW
op_star
id|mem
suffix:semicolon
id|cell_buf
op_star
id|tx_desc
suffix:semicolon
id|cell_buf
op_star
id|rx_desc
suffix:semicolon
id|u32
id|ctrl
suffix:semicolon
id|ctrl
op_assign
id|rd_regl
(paren
id|dev
comma
id|CONTROL_0_REG
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_INFO
comma
l_string|&quot;ctrl0reg is %#x&quot;
comma
id|ctrl
)paren
suffix:semicolon
id|onefivefive
op_assign
id|ctrl
op_amp
id|ATM_LAYER_STATUS
suffix:semicolon
r_if
c_cond
(paren
id|onefivefive
)paren
id|printk
(paren
id|DEV_LABEL
l_string|&quot;: Horizon Ultra (at 155.52 MBps)&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
id|DEV_LABEL
l_string|&quot;: Horizon (at 25 MBps)&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;:&quot;
)paren
suffix:semicolon
singleline_comment|// Reset the card to get everything in a known state
id|printk
(paren
l_string|&quot; reset&quot;
)paren
suffix:semicolon
id|hrz_reset
(paren
id|dev
)paren
suffix:semicolon
singleline_comment|// Clear all the buffer memory
id|printk
(paren
l_string|&quot; clearing memory&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mem
op_assign
(paren
id|HDW
op_star
)paren
id|memmap
suffix:semicolon
id|mem
OL
(paren
id|HDW
op_star
)paren
(paren
id|memmap
op_plus
l_int|1
)paren
suffix:semicolon
op_increment
id|mem
)paren
id|wr_mem
(paren
id|dev
comma
id|mem
comma
l_int|0
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot; tx channels&quot;
)paren
suffix:semicolon
singleline_comment|// All transmit eight channels are set up as AAL5 ABR channels with
singleline_comment|// a 16us cell spacing. Why?
singleline_comment|// Channel 0 gets the free buffer at 100h, channel 1 gets the free
singleline_comment|// buffer at 110h etc.
r_for
c_loop
(paren
id|chan
op_assign
l_int|0
suffix:semicolon
id|chan
OL
id|TX_CHANS
suffix:semicolon
op_increment
id|chan
)paren
(brace
id|tx_ch_desc
op_star
id|tx_desc
op_assign
op_amp
id|memmap-&gt;tx_descs
(braket
id|chan
)braket
suffix:semicolon
id|cell_buf
op_star
id|buf
op_assign
op_amp
id|memmap-&gt;inittxbufs
(braket
id|chan
)braket
suffix:semicolon
singleline_comment|// initialise the read and write buffer pointers
id|wr_mem
(paren
id|dev
comma
op_amp
id|tx_desc-&gt;rd_buf_type
comma
id|BUF_PTR
c_func
(paren
id|buf
)paren
)paren
suffix:semicolon
id|wr_mem
(paren
id|dev
comma
op_amp
id|tx_desc-&gt;wr_buf_type
comma
id|BUF_PTR
c_func
(paren
id|buf
)paren
)paren
suffix:semicolon
singleline_comment|// set the status of the initial buffers to empty
id|wr_mem
(paren
id|dev
comma
op_amp
id|buf-&gt;next
comma
id|BUFF_STATUS_EMPTY
)paren
suffix:semicolon
)brace
singleline_comment|// Use space bufn3 at the moment for tx buffers
id|printk
(paren
l_string|&quot; tx buffers&quot;
)paren
suffix:semicolon
id|tx_desc
op_assign
id|memmap-&gt;bufn3
suffix:semicolon
id|wr_mem
(paren
id|dev
comma
op_amp
id|memmap-&gt;txfreebufstart.next
comma
id|BUF_PTR
c_func
(paren
id|tx_desc
)paren
op_or
id|BUFF_STATUS_EMPTY
)paren
suffix:semicolon
r_for
c_loop
(paren
id|buff_count
op_assign
l_int|0
suffix:semicolon
id|buff_count
OL
id|BUFN3_SIZE
op_minus
l_int|1
suffix:semicolon
id|buff_count
op_increment
)paren
(brace
id|wr_mem
(paren
id|dev
comma
op_amp
id|tx_desc-&gt;next
comma
id|BUF_PTR
c_func
(paren
id|tx_desc
op_plus
l_int|1
)paren
op_or
id|BUFF_STATUS_EMPTY
)paren
suffix:semicolon
id|tx_desc
op_increment
suffix:semicolon
)brace
id|wr_mem
(paren
id|dev
comma
op_amp
id|tx_desc-&gt;next
comma
id|BUF_PTR
c_func
(paren
op_amp
id|memmap-&gt;txfreebufend
)paren
op_or
id|BUFF_STATUS_EMPTY
)paren
suffix:semicolon
singleline_comment|// Initialise the transmit free buffer count
id|wr_regw
(paren
id|dev
comma
id|TX_FREE_BUFFER_COUNT_OFF
comma
id|BUFN3_SIZE
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot; rx channels&quot;
)paren
suffix:semicolon
singleline_comment|// Initialise all of the receive channels to be AAL5 disabled with
singleline_comment|// an interrupt threshold of 0
r_for
c_loop
(paren
id|chan
op_assign
l_int|0
suffix:semicolon
id|chan
OL
id|RX_CHANS
suffix:semicolon
op_increment
id|chan
)paren
(brace
id|rx_ch_desc
op_star
id|rx_desc
op_assign
op_amp
id|memmap-&gt;rx_descs
(braket
id|chan
)braket
suffix:semicolon
id|wr_mem
(paren
id|dev
comma
op_amp
id|rx_desc-&gt;wr_buf_type
comma
id|CHANNEL_TYPE_AAL5
op_or
id|RX_CHANNEL_DISABLED
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot; rx buffers&quot;
)paren
suffix:semicolon
singleline_comment|// Use space bufn4 at the moment for rx buffers
id|rx_desc
op_assign
id|memmap-&gt;bufn4
suffix:semicolon
id|wr_mem
(paren
id|dev
comma
op_amp
id|memmap-&gt;rxfreebufstart.next
comma
id|BUF_PTR
c_func
(paren
id|rx_desc
)paren
op_or
id|BUFF_STATUS_EMPTY
)paren
suffix:semicolon
r_for
c_loop
(paren
id|buff_count
op_assign
l_int|0
suffix:semicolon
id|buff_count
OL
id|BUFN4_SIZE
op_minus
l_int|1
suffix:semicolon
id|buff_count
op_increment
)paren
(brace
id|wr_mem
(paren
id|dev
comma
op_amp
id|rx_desc-&gt;next
comma
id|BUF_PTR
c_func
(paren
id|rx_desc
op_plus
l_int|1
)paren
op_or
id|BUFF_STATUS_EMPTY
)paren
suffix:semicolon
id|rx_desc
op_increment
suffix:semicolon
)brace
id|wr_mem
(paren
id|dev
comma
op_amp
id|rx_desc-&gt;next
comma
id|BUF_PTR
c_func
(paren
op_amp
id|memmap-&gt;rxfreebufend
)paren
op_or
id|BUFF_STATUS_EMPTY
)paren
suffix:semicolon
singleline_comment|// Initialise the receive free buffer count
id|wr_regw
(paren
id|dev
comma
id|RX_FREE_BUFFER_COUNT_OFF
comma
id|BUFN4_SIZE
)paren
suffix:semicolon
singleline_comment|// Initialize Horizons registers
singleline_comment|// TX config
id|wr_regw
(paren
id|dev
comma
id|TX_CONFIG_OFF
comma
id|ABR_ROUND_ROBIN
op_or
id|TX_NORMAL_OPERATION
op_or
id|DRVR_DRVRBAR_ENABLE
)paren
suffix:semicolon
singleline_comment|// RX config. Use 10-x VC bits, x VP bits, non user cells in channel 0.
id|wr_regw
(paren
id|dev
comma
id|RX_CONFIG_OFF
comma
id|DISCARD_UNUSED_VPI_VCI_BITS_SET
op_or
id|NON_USER_CELLS_IN_ONE_CHANNEL
op_or
id|vpi_bits
)paren
suffix:semicolon
singleline_comment|// RX line config
id|wr_regw
(paren
id|dev
comma
id|RX_LINE_CONFIG_OFF
comma
id|LOCK_DETECT_ENABLE
op_or
id|FREQUENCY_DETECT_ENABLE
op_or
id|GXTALOUT_SELECT_DIV4
)paren
suffix:semicolon
singleline_comment|// Set the max AAL5 cell count to be just enough to contain the
singleline_comment|// largest AAL5 frame that the user wants to receive
id|wr_regw
(paren
id|dev
comma
id|MAX_AAL5_CELL_COUNT_OFF
comma
(paren
id|max_rx_size
op_plus
id|ATM_AAL5_TRAILER
op_plus
id|ATM_CELL_PAYLOAD
op_minus
l_int|1
)paren
op_div
id|ATM_CELL_PAYLOAD
)paren
suffix:semicolon
singleline_comment|// Enable receive
id|wr_regw
(paren
id|dev
comma
id|RX_CONFIG_OFF
comma
id|rd_regw
(paren
id|dev
comma
id|RX_CONFIG_OFF
)paren
op_or
id|RX_ENABLE
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot; control&quot;
)paren
suffix:semicolon
singleline_comment|// Drive the OE of the LEDs then turn the green LED on
id|ctrl
op_or_assign
id|GREEN_LED_OE
op_or
id|YELLOW_LED_OE
op_or
id|GREEN_LED
op_or
id|YELLOW_LED
suffix:semicolon
id|wr_regl
(paren
id|dev
comma
id|CONTROL_0_REG
comma
id|ctrl
)paren
suffix:semicolon
singleline_comment|// Test for a 155-capable card
r_if
c_cond
(paren
id|onefivefive
)paren
(brace
singleline_comment|// Select 155 mode... make this a choice (or: how do we detect
singleline_comment|// external line speed and switch?)
id|ctrl
op_or_assign
id|ATM_LAYER_SELECT
suffix:semicolon
id|wr_regl
(paren
id|dev
comma
id|CONTROL_0_REG
comma
id|ctrl
)paren
suffix:semicolon
singleline_comment|// test SUNI-lite vs SAMBA
singleline_comment|// Register 0x00 in the SUNI will have some of bits 3-7 set, and
singleline_comment|// they will always be zero for the SAMBA.  Ha!  Bloody hardware
singleline_comment|// engineers.  It&squot;ll never work.
r_if
c_cond
(paren
id|rd_framer
(paren
id|dev
comma
l_int|0
)paren
op_amp
l_int|0x00f0
)paren
(brace
singleline_comment|// SUNI
id|printk
(paren
l_string|&quot; SUNI&quot;
)paren
suffix:semicolon
singleline_comment|// Reset, just in case
id|wr_framer
(paren
id|dev
comma
l_int|0x00
comma
l_int|0x0080
)paren
suffix:semicolon
id|wr_framer
(paren
id|dev
comma
l_int|0x00
comma
l_int|0x0000
)paren
suffix:semicolon
singleline_comment|// Configure transmit FIFO
id|wr_framer
(paren
id|dev
comma
l_int|0x63
comma
id|rd_framer
(paren
id|dev
comma
l_int|0x63
)paren
op_or
l_int|0x0002
)paren
suffix:semicolon
singleline_comment|// Set line timed mode
id|wr_framer
(paren
id|dev
comma
l_int|0x05
comma
id|rd_framer
(paren
id|dev
comma
l_int|0x05
)paren
op_or
l_int|0x0001
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// SAMBA
id|printk
(paren
l_string|&quot; SAMBA&quot;
)paren
suffix:semicolon
singleline_comment|// Reset, just in case
id|wr_framer
(paren
id|dev
comma
l_int|0
comma
id|rd_framer
(paren
id|dev
comma
l_int|0
)paren
op_or
l_int|0x0001
)paren
suffix:semicolon
id|wr_framer
(paren
id|dev
comma
l_int|0
comma
id|rd_framer
(paren
id|dev
comma
l_int|0
)paren
op_amp
op_complement
l_int|0x0001
)paren
suffix:semicolon
singleline_comment|// Turn off diagnostic loopback and enable line-timed mode
id|wr_framer
(paren
id|dev
comma
l_int|0
comma
l_int|0x0002
)paren
suffix:semicolon
singleline_comment|// Turn on transmit outputs
id|wr_framer
(paren
id|dev
comma
l_int|2
comma
l_int|0x0B80
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
singleline_comment|// Select 25 mode
id|ctrl
op_and_assign
op_complement
id|ATM_LAYER_SELECT
suffix:semicolon
singleline_comment|// Madge B154 setup
singleline_comment|// none required?
)brace
id|printk
(paren
l_string|&quot; LEDs&quot;
)paren
suffix:semicolon
id|GREEN_LED_ON
c_func
(paren
id|dev
)paren
suffix:semicolon
id|YELLOW_LED_ON
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot; ESI=&quot;
)paren
suffix:semicolon
(brace
id|u16
id|b
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u8
op_star
id|esi
op_assign
id|dev-&gt;atm_dev-&gt;esi
suffix:semicolon
singleline_comment|// in the card I have, EEPROM
singleline_comment|// addresses 0, 1, 2 contain 0
singleline_comment|// addresess 5, 6 etc. contain ffff
singleline_comment|// NB: Madge prefix is 00 00 f6 (which is 00 00 6f in Ethernet bit order)
singleline_comment|// the read_bia routine gets the BIA in Ethernet bit order
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ESI_LEN
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
op_mod
l_int|2
op_eq
l_int|0
)paren
id|b
op_assign
id|read_bia
(paren
id|dev
comma
id|i
op_div
l_int|2
op_plus
l_int|2
)paren
suffix:semicolon
r_else
id|b
op_assign
id|b
op_rshift
l_int|8
suffix:semicolon
id|esi
(braket
id|i
)braket
op_assign
id|b
op_amp
l_int|0xFF
suffix:semicolon
id|printk
(paren
l_string|&quot;%02x&quot;
comma
id|esi
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// Enable RX_Q and ?X_COMPLETE interrupts only
id|wr_regl
(paren
id|dev
comma
id|INT_ENABLE_REG_OFF
comma
id|INTERESTING_INTERRUPTS
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot; IRQ on&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|onefivefive
suffix:semicolon
)brace
multiline_comment|/********** check max_sdu **********/
DECL|function|check_max_sdu
r_static
r_int
id|check_max_sdu
(paren
id|hrz_aal
id|aal
comma
r_struct
id|atm_trafprm
op_star
id|tp
comma
r_int
r_int
id|max_frame_size
)paren
(brace
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_QOS
comma
l_string|&quot;check_max_sdu&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|aal
)paren
(brace
r_case
id|aal0
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tp-&gt;max_sdu
)paren
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;defaulting max_sdu&quot;
)paren
suffix:semicolon
id|tp-&gt;max_sdu
op_assign
id|ATM_AAL0_SDU
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tp-&gt;max_sdu
op_ne
id|ATM_AAL0_SDU
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
op_or
id|DBG_ERR
comma
l_string|&quot;rejecting max_sdu&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|aal34
suffix:colon
r_if
c_cond
(paren
id|tp-&gt;max_sdu
op_eq
l_int|0
op_logical_or
id|tp-&gt;max_sdu
OG
id|ATM_MAX_AAL34_PDU
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;%sing max_sdu&quot;
comma
id|tp-&gt;max_sdu
ques
c_cond
l_string|&quot;capp&quot;
suffix:colon
l_string|&quot;default&quot;
)paren
suffix:semicolon
id|tp-&gt;max_sdu
op_assign
id|ATM_MAX_AAL34_PDU
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|aal5
suffix:colon
r_if
c_cond
(paren
id|tp-&gt;max_sdu
op_eq
l_int|0
op_logical_or
id|tp-&gt;max_sdu
OG
id|max_frame_size
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;%sing max_sdu&quot;
comma
id|tp-&gt;max_sdu
ques
c_cond
l_string|&quot;capp&quot;
suffix:colon
l_string|&quot;default&quot;
)paren
suffix:semicolon
id|tp-&gt;max_sdu
op_assign
id|max_frame_size
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/********** check pcr **********/
singleline_comment|// something like this should be part of ATM Linux
DECL|function|atm_pcr_check
r_static
r_int
id|atm_pcr_check
(paren
r_struct
id|atm_trafprm
op_star
id|tp
comma
r_int
r_int
id|pcr
)paren
(brace
singleline_comment|// we are assuming non-UBR, and non-special values of pcr
r_if
c_cond
(paren
id|tp-&gt;min_pcr
op_eq
id|ATM_MAX_PCR
)paren
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;luser gave min_pcr = ATM_MAX_PCR&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;min_pcr
OL
l_int|0
)paren
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;luser gave negative min_pcr&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;min_pcr
op_logical_and
id|tp-&gt;min_pcr
OG
id|pcr
)paren
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;pcr less than min_pcr&quot;
)paren
suffix:semicolon
r_else
singleline_comment|// !! max_pcr = UNSPEC (0) is equivalent to max_pcr = MAX (-1)
singleline_comment|// easier to #define ATM_MAX_PCR 0 and have all rates unsigned?
singleline_comment|// [this would get rid of next two conditionals]
r_if
c_cond
(paren
(paren
l_int|0
)paren
op_logical_and
id|tp-&gt;max_pcr
op_eq
id|ATM_MAX_PCR
)paren
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;luser gave max_pcr = ATM_MAX_PCR&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|tp-&gt;max_pcr
op_ne
id|ATM_MAX_PCR
)paren
op_logical_and
id|tp-&gt;max_pcr
OL
l_int|0
)paren
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;luser gave negative max_pcr&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;max_pcr
op_logical_and
id|tp-&gt;max_pcr
op_ne
id|ATM_MAX_PCR
op_logical_and
id|tp-&gt;max_pcr
OL
id|pcr
)paren
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;pcr greater than max_pcr&quot;
)paren
suffix:semicolon
r_else
(brace
singleline_comment|// each limit unspecified or not violated
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;xBR(pcr) OK&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;pcr=%u, tp: min_pcr=%d, pcr=%d, max_pcr=%d&quot;
comma
id|pcr
comma
id|tp-&gt;min_pcr
comma
id|tp-&gt;pcr
comma
id|tp-&gt;max_pcr
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/********** open VC **********/
DECL|function|hrz_open
r_static
r_int
id|hrz_open
(paren
r_struct
id|atm_vcc
op_star
id|atm_vcc
comma
r_int
id|vpi
comma
r_int
id|vci
)paren
(brace
r_int
id|error
suffix:semicolon
id|u16
id|channel
suffix:semicolon
r_struct
id|atm_qos
op_star
id|qos
suffix:semicolon
r_struct
id|atm_trafprm
op_star
id|txtp
suffix:semicolon
r_struct
id|atm_trafprm
op_star
id|rxtp
suffix:semicolon
id|hrz_dev
op_star
id|dev
op_assign
id|HRZ_DEV
c_func
(paren
id|atm_vcc-&gt;dev
)paren
suffix:semicolon
id|hrz_vcc
id|vcc
suffix:semicolon
id|hrz_vcc
op_star
id|vccp
suffix:semicolon
singleline_comment|// allocated late
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_VCC
comma
l_string|&quot;hrz_open %x %x&quot;
comma
id|vpi
comma
id|vci
)paren
suffix:semicolon
macro_line|#ifdef ATM_VPI_UNSPEC
singleline_comment|// UNSPEC is deprecated, remove this code eventually
r_if
c_cond
(paren
id|vpi
op_eq
id|ATM_VPI_UNSPEC
op_logical_or
id|vci
op_eq
id|ATM_VCI_UNSPEC
)paren
(brace
id|PRINTK
(paren
id|KERN_WARNING
comma
l_string|&quot;rejecting open with unspecified VPI/VCI (deprecated)&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#endif
singleline_comment|// deal with possibly wildcarded VCs
id|error
op_assign
id|atm_find_ci
(paren
id|atm_vcc
comma
op_amp
id|vpi
comma
op_amp
id|vci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|PRINTD
(paren
id|DBG_WARN
op_or
id|DBG_VCC
comma
l_string|&quot;atm_find_ci failed!&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|PRINTD
(paren
id|DBG_VCC
comma
l_string|&quot;atm_find_ci gives %x %x&quot;
comma
id|vpi
comma
id|vci
)paren
suffix:semicolon
id|error
op_assign
id|vpivci_to_channel
(paren
op_amp
id|channel
comma
id|vpi
comma
id|vci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|PRINTD
(paren
id|DBG_WARN
op_or
id|DBG_VCC
comma
l_string|&quot;VPI/VCI out of range: %hd/%d&quot;
comma
id|vpi
comma
id|vci
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|vcc.channel
op_assign
id|channel
suffix:semicolon
singleline_comment|// max speed for the moment
id|vcc.tx_rate
op_assign
l_int|0x0
suffix:semicolon
id|qos
op_assign
op_amp
id|atm_vcc-&gt;qos
suffix:semicolon
singleline_comment|// check AAL and remember it
r_switch
c_cond
(paren
id|qos-&gt;aal
)paren
(brace
r_case
id|ATM_AAL0
suffix:colon
singleline_comment|// we would if it were 48 bytes and not 52!
id|PRINTD
(paren
id|DBG_QOS
op_or
id|DBG_VCC
comma
l_string|&quot;AAL0&quot;
)paren
suffix:semicolon
id|vcc.aal
op_assign
id|aal0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATM_AAL34
suffix:colon
singleline_comment|// we would if I knew how do the SAR!
id|PRINTD
(paren
id|DBG_QOS
op_or
id|DBG_VCC
comma
l_string|&quot;AAL3/4&quot;
)paren
suffix:semicolon
id|vcc.aal
op_assign
id|aal34
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATM_AAL5
suffix:colon
id|PRINTD
(paren
id|DBG_QOS
op_or
id|DBG_VCC
comma
l_string|&quot;AAL5&quot;
)paren
suffix:semicolon
id|vcc.aal
op_assign
id|aal5
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|PRINTD
(paren
id|DBG_QOS
op_or
id|DBG_VCC
comma
l_string|&quot;Bad AAL!&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// TX traffic parameters
singleline_comment|// there are two, interrelated problems here: 1. the reservation of
singleline_comment|// PCR is not a binary choice, we are given bounds and/or a
singleline_comment|// desirable value; 2. the device is only capable of certain values,
singleline_comment|// most of which are not integers. It is almost certainly acceptable
singleline_comment|// to be off by a maximum of 1 to 10 cps.
singleline_comment|// Pragmatic choice: always store an integral PCR as that which has
singleline_comment|// been allocated, even if we allocate a little (or a lot) less,
singleline_comment|// after rounding. The actual allocation depends on what we can
singleline_comment|// manage with our rate selection algorithm. The rate selection
singleline_comment|// algorithm is given an integral PCR and a tolerance and told
singleline_comment|// whether it should round the value up or down if the tolerance is
singleline_comment|// exceeded; it returns: a) the actual rate selected (rounded up to
singleline_comment|// the nearest integer), b) a bit pattern to feed to the timer
singleline_comment|// register, and c) a failure value if no applicable rate exists.
singleline_comment|// Part of the job is done by atm_pcr_goal which gives us a PCR
singleline_comment|// specification which says: EITHER grab the maximum available PCR
singleline_comment|// (and perhaps a lower bound which we musn&squot;t pass), OR grab this
singleline_comment|// amount, rounding down if you have to (and perhaps a lower bound
singleline_comment|// which we musn&squot;t pass) OR grab this amount, rounding up if you
singleline_comment|// have to (and perhaps an upper bound which we musn&squot;t pass). If any
singleline_comment|// bounds ARE passed we fail. Note that rounding is only rounding to
singleline_comment|// match device limitations, we do not round down to satisfy
singleline_comment|// bandwidth availability even if this would not violate any given
singleline_comment|// lower bound.
singleline_comment|// Note: telephony = 64kb/s = 48 byte cell payload @ 500/3 cells/s
singleline_comment|// (say) so this is not even a binary fixpoint cell rate (but this
singleline_comment|// device can do it). To avoid this sort of hassle we use a
singleline_comment|// tolerance parameter (currently fixed at 10 cps).
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;TX:&quot;
)paren
suffix:semicolon
id|txtp
op_assign
op_amp
id|qos-&gt;txtp
suffix:semicolon
singleline_comment|// set up defaults for no traffic
id|vcc.tx_rate
op_assign
l_int|0
suffix:semicolon
singleline_comment|// who knows what would actually happen if you try and send on this?
id|vcc.tx_xbr_bits
op_assign
id|IDLE_RATE_TYPE
suffix:semicolon
id|vcc.tx_pcr_bits
op_assign
id|CLOCK_DISABLE
suffix:semicolon
macro_line|#if 0
id|vcc.tx_scr_bits
op_assign
id|CLOCK_DISABLE
suffix:semicolon
id|vcc.tx_bucket_bits
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|txtp-&gt;traffic_class
op_ne
id|ATM_NONE
)paren
(brace
id|error
op_assign
id|check_max_sdu
(paren
id|vcc.aal
comma
id|txtp
comma
id|max_tx_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;TX max_sdu check failed&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|txtp-&gt;traffic_class
)paren
(brace
r_case
id|ATM_UBR
suffix:colon
(brace
singleline_comment|// we take &quot;the PCR&quot; as a rate-cap
singleline_comment|// not reserved
id|vcc.tx_rate
op_assign
l_int|0
suffix:semicolon
id|make_rate
(paren
id|dev
comma
l_int|1
op_lshift
l_int|30
comma
id|round_nearest
comma
op_amp
id|vcc.tx_pcr_bits
comma
l_int|0
)paren
suffix:semicolon
id|vcc.tx_xbr_bits
op_assign
id|ABR_RATE_TYPE
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#if 0
r_case
id|ATM_ABR
suffix:colon
(brace
singleline_comment|// reserve min, allow up to max
id|vcc.tx_rate
op_assign
l_int|0
suffix:semicolon
singleline_comment|// ?
id|make_rate
(paren
id|dev
comma
l_int|1
op_lshift
l_int|30
comma
id|round_nearest
comma
op_amp
id|vcc.tx_pcr_bits
comma
l_int|0
)paren
suffix:semicolon
id|vcc.tx_xbr_bits
op_assign
id|ABR_RATE_TYPE
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
r_case
id|ATM_CBR
suffix:colon
(brace
r_int
id|pcr
op_assign
id|atm_pcr_goal
(paren
id|txtp
)paren
suffix:semicolon
id|rounding
id|r
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcr
)paren
(brace
singleline_comment|// down vs. up, remaining bandwidth vs. unlimited bandwidth!!
singleline_comment|// should really have: once someone gets unlimited bandwidth
singleline_comment|// that no more non-UBR channels can be opened until the
singleline_comment|// unlimited one closes?? For the moment, round_down means
singleline_comment|// greedy people actually get something and not nothing
id|r
op_assign
id|round_down
suffix:semicolon
singleline_comment|// slight race (no locking) here so we may get -EAGAIN
singleline_comment|// later; the greedy bastards would deserve it :)
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;snatching all remaining TX bandwidth&quot;
)paren
suffix:semicolon
id|pcr
op_assign
id|dev-&gt;tx_avail
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pcr
OL
l_int|0
)paren
(brace
id|r
op_assign
id|round_down
suffix:semicolon
id|pcr
op_assign
op_minus
id|pcr
suffix:semicolon
)brace
r_else
(brace
id|r
op_assign
id|round_up
suffix:semicolon
)brace
id|error
op_assign
id|make_rate_with_tolerance
(paren
id|dev
comma
id|pcr
comma
id|r
comma
l_int|10
comma
op_amp
id|vcc.tx_pcr_bits
comma
op_amp
id|vcc.tx_rate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;could not make rate from TX PCR&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
singleline_comment|// not really clear what further checking is needed
id|error
op_assign
id|atm_pcr_check
(paren
id|txtp
comma
id|vcc.tx_rate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;TX PCR failed consistency check&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|vcc.tx_xbr_bits
op_assign
id|CBR_RATE_TYPE
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#if 0
r_case
id|ATM_VBR
suffix:colon
(brace
r_int
id|pcr
op_assign
id|atm_pcr_goal
(paren
id|txtp
)paren
suffix:semicolon
singleline_comment|// int scr = atm_scr_goal (txtp);
r_int
id|scr
op_assign
id|pcr
op_div
l_int|2
suffix:semicolon
singleline_comment|// just for fun
r_int
r_int
id|mbs
op_assign
l_int|60
suffix:semicolon
singleline_comment|// just for fun
id|rounding
id|pr
suffix:semicolon
id|rounding
id|sr
suffix:semicolon
r_int
r_int
id|bucket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcr
)paren
(brace
id|pr
op_assign
id|round_nearest
suffix:semicolon
id|pcr
op_assign
l_int|1
op_lshift
l_int|30
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pcr
OL
l_int|0
)paren
(brace
id|pr
op_assign
id|round_down
suffix:semicolon
id|pcr
op_assign
op_minus
id|pcr
suffix:semicolon
)brace
r_else
(brace
id|pr
op_assign
id|round_up
suffix:semicolon
)brace
id|error
op_assign
id|make_rate_with_tolerance
(paren
id|dev
comma
id|pcr
comma
id|pr
comma
l_int|10
comma
op_amp
id|vcc.tx_pcr_bits
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scr
)paren
(brace
singleline_comment|// see comments for PCR with CBR above
id|sr
op_assign
id|round_down
suffix:semicolon
singleline_comment|// slight race (no locking) here so we may get -EAGAIN
singleline_comment|// later; the greedy bastards would deserve it :)
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;snatching all remaining TX bandwidth&quot;
)paren
suffix:semicolon
id|scr
op_assign
id|dev-&gt;tx_avail
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scr
OL
l_int|0
)paren
(brace
id|sr
op_assign
id|round_down
suffix:semicolon
id|scr
op_assign
op_minus
id|scr
suffix:semicolon
)brace
r_else
(brace
id|sr
op_assign
id|round_up
suffix:semicolon
)brace
id|error
op_assign
id|make_rate_with_tolerance
(paren
id|dev
comma
id|scr
comma
id|sr
comma
l_int|10
comma
op_amp
id|vcc.tx_scr_bits
comma
op_amp
id|vcc.tx_rate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;could not make rate from TX SCR&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
singleline_comment|// not really clear what further checking is needed
singleline_comment|// error = atm_scr_check (txtp, vcc.tx_rate);
r_if
c_cond
(paren
id|error
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;TX SCR failed consistency check&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
singleline_comment|// bucket calculations (from a piece of paper...) cell bucket
singleline_comment|// capacity must be largest integer smaller than m(p-s)/p + 1
singleline_comment|// where m = max burst size, p = pcr, s = scr
id|bucket
op_assign
id|mbs
op_star
(paren
id|pcr
op_minus
id|scr
)paren
op_div
id|pcr
suffix:semicolon
r_if
c_cond
(paren
id|bucket
op_star
id|pcr
op_ne
id|mbs
op_star
(paren
id|pcr
op_minus
id|scr
)paren
)paren
id|bucket
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bucket
OG
id|BUCKET_MAX_SIZE
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;shrinking bucket from %u to %u&quot;
comma
id|bucket
comma
id|BUCKET_MAX_SIZE
)paren
suffix:semicolon
id|bucket
op_assign
id|BUCKET_MAX_SIZE
suffix:semicolon
)brace
id|vcc.tx_xbr_bits
op_assign
id|VBR_RATE_TYPE
suffix:semicolon
id|vcc.tx_bucket_bits
op_assign
id|bucket
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
r_default
suffix:colon
(brace
)brace
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;unsupported TX traffic class&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
singleline_comment|// RX traffic parameters
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;RX:&quot;
)paren
suffix:semicolon
id|rxtp
op_assign
op_amp
id|qos-&gt;rxtp
suffix:semicolon
singleline_comment|// set up defaults for no traffic
id|vcc.rx_rate
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rxtp-&gt;traffic_class
op_ne
id|ATM_NONE
)paren
(brace
id|error
op_assign
id|check_max_sdu
(paren
id|vcc.aal
comma
id|rxtp
comma
id|max_rx_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;RX max_sdu check failed&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|rxtp-&gt;traffic_class
)paren
(brace
r_case
id|ATM_UBR
suffix:colon
(brace
singleline_comment|// not reserved
r_break
suffix:semicolon
)brace
macro_line|#if 0
r_case
id|ATM_ABR
suffix:colon
(brace
singleline_comment|// reserve min
id|vcc.rx_rate
op_assign
l_int|0
suffix:semicolon
singleline_comment|// ?
r_break
suffix:semicolon
)brace
macro_line|#endif
r_case
id|ATM_CBR
suffix:colon
(brace
r_int
id|pcr
op_assign
id|atm_pcr_goal
(paren
id|rxtp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcr
)paren
(brace
singleline_comment|// slight race (no locking) here so we may get -EAGAIN
singleline_comment|// later; the greedy bastards would deserve it :)
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;snatching all remaining RX bandwidth&quot;
)paren
suffix:semicolon
id|pcr
op_assign
id|dev-&gt;rx_avail
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pcr
OL
l_int|0
)paren
(brace
id|pcr
op_assign
op_minus
id|pcr
suffix:semicolon
)brace
id|vcc.rx_rate
op_assign
id|pcr
suffix:semicolon
singleline_comment|// not really clear what further checking is needed
id|error
op_assign
id|atm_pcr_check
(paren
id|rxtp
comma
id|vcc.rx_rate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;RX PCR failed consistency check&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
macro_line|#if 0
r_case
id|ATM_VBR
suffix:colon
(brace
singleline_comment|// int scr = atm_scr_goal (rxtp);
r_int
id|scr
op_assign
l_int|1
op_lshift
l_int|16
suffix:semicolon
singleline_comment|// just for fun
r_if
c_cond
(paren
op_logical_neg
id|scr
)paren
(brace
singleline_comment|// slight race (no locking) here so we may get -EAGAIN
singleline_comment|// later; the greedy bastards would deserve it :)
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;snatching all remaining RX bandwidth&quot;
)paren
suffix:semicolon
id|scr
op_assign
id|dev-&gt;rx_avail
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scr
OL
l_int|0
)paren
(brace
id|scr
op_assign
op_minus
id|scr
suffix:semicolon
)brace
id|vcc.rx_rate
op_assign
id|scr
suffix:semicolon
singleline_comment|// not really clear what further checking is needed
singleline_comment|// error = atm_scr_check (rxtp, vcc.rx_rate);
r_if
c_cond
(paren
id|error
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;RX SCR failed consistency check&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
macro_line|#endif
r_default
suffix:colon
(brace
)brace
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;unsupported RX traffic class&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
singleline_comment|// late abort useful for diagnostics
r_if
c_cond
(paren
id|vcc.aal
op_ne
id|aal5
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;AAL not supported&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
singleline_comment|// get space for our vcc stuff and copy parameters into it
id|vccp
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|hrz_vcc
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vccp
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;out of memory!&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
op_star
id|vccp
op_assign
id|vcc
suffix:semicolon
singleline_comment|// clear error and grab cell rate resource lock
id|error
op_assign
l_int|0
suffix:semicolon
id|spin_lock
(paren
op_amp
id|dev-&gt;rate_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vcc.tx_rate
OG
id|dev-&gt;tx_avail
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;not enough TX PCR left&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vcc.rx_rate
OG
id|dev-&gt;rx_avail
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
comma
l_string|&quot;not enough RX PCR left&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
singleline_comment|// really consume cell rates
id|dev-&gt;tx_avail
op_sub_assign
id|vcc.tx_rate
suffix:semicolon
id|dev-&gt;rx_avail
op_sub_assign
id|vcc.rx_rate
suffix:semicolon
id|PRINTD
(paren
id|DBG_QOS
op_or
id|DBG_VCC
comma
l_string|&quot;reserving %u TX PCR and %u RX PCR&quot;
comma
id|vcc.tx_rate
comma
id|vcc.rx_rate
)paren
suffix:semicolon
)brace
singleline_comment|// release lock and exit on error
id|spin_unlock
(paren
op_amp
id|dev-&gt;rate_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|PRINTD
(paren
id|DBG_QOS
op_or
id|DBG_VCC
comma
l_string|&quot;insufficient cell rate resources&quot;
)paren
suffix:semicolon
id|kfree
(paren
id|vccp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
singleline_comment|// this is &quot;immediately before allocating the connection identifier
singleline_comment|// in hardware&quot; - so long as the next call does not fail :)
id|set_bit
c_func
(paren
id|ATM_VF_ADDR
comma
op_amp
id|atm_vcc-&gt;flags
)paren
suffix:semicolon
singleline_comment|// any errors here are very serious and should never occur
r_if
c_cond
(paren
id|rxtp-&gt;traffic_class
op_ne
id|ATM_NONE
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;rxer
(braket
id|channel
)braket
)paren
(brace
id|PRINTD
(paren
id|DBG_ERR
op_or
id|DBG_VCC
comma
l_string|&quot;VC already open for RX&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|hrz_open_rx
(paren
id|dev
comma
id|channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|kfree
(paren
id|vccp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
singleline_comment|// this link allows RX frames through
id|dev-&gt;rxer
(braket
id|channel
)braket
op_assign
id|atm_vcc
suffix:semicolon
)brace
singleline_comment|// success, set elements of atm_vcc
id|atm_vcc-&gt;vpi
op_assign
id|vpi
suffix:semicolon
id|atm_vcc-&gt;vci
op_assign
id|vci
suffix:semicolon
id|atm_vcc-&gt;dev_data
op_assign
(paren
r_void
op_star
)paren
id|vccp
suffix:semicolon
singleline_comment|// indicate readiness
id|set_bit
c_func
(paren
id|ATM_VF_READY
comma
op_amp
id|atm_vcc-&gt;flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/********** close VC **********/
DECL|function|hrz_close
r_static
r_void
id|hrz_close
(paren
r_struct
id|atm_vcc
op_star
id|atm_vcc
)paren
(brace
id|hrz_dev
op_star
id|dev
op_assign
id|HRZ_DEV
c_func
(paren
id|atm_vcc-&gt;dev
)paren
suffix:semicolon
id|hrz_vcc
op_star
id|vcc
op_assign
id|HRZ_VCC
c_func
(paren
id|atm_vcc
)paren
suffix:semicolon
id|u16
id|channel
op_assign
id|vcc-&gt;channel
suffix:semicolon
id|PRINTD
(paren
id|DBG_VCC
op_or
id|DBG_FLOW
comma
l_string|&quot;hrz_close&quot;
)paren
suffix:semicolon
singleline_comment|// indicate unreadiness
id|clear_bit
c_func
(paren
id|ATM_VF_READY
comma
op_amp
id|atm_vcc-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atm_vcc-&gt;qos.txtp.traffic_class
op_ne
id|ATM_NONE
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
singleline_comment|// let any TX on this channel that has started complete
singleline_comment|// no restart, just keep trying
r_while
c_loop
(paren
id|tx_hold
(paren
id|dev
)paren
)paren
suffix:semicolon
singleline_comment|// remove record of any tx_channel having been setup for this channel
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_CHANS
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|dev-&gt;tx_channel_record
(braket
id|i
)braket
op_eq
id|channel
)paren
(brace
id|dev-&gt;tx_channel_record
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;last_vc
op_eq
id|channel
)paren
id|dev-&gt;tx_last
op_assign
op_minus
l_int|1
suffix:semicolon
id|tx_release
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atm_vcc-&gt;qos.rxtp.traffic_class
op_ne
id|ATM_NONE
)paren
(brace
singleline_comment|// disable RXing - it tries quite hard
id|hrz_close_rx
(paren
id|dev
comma
id|channel
)paren
suffix:semicolon
singleline_comment|// forget the vcc - no more skbs will be pushed
r_if
c_cond
(paren
id|atm_vcc
op_ne
id|dev-&gt;rxer
(braket
id|channel
)braket
)paren
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;%s atm_vcc=%p rxer[channel]=%p&quot;
comma
l_string|&quot;arghhh! we&squot;re going to die!&quot;
comma
id|atm_vcc
comma
id|dev-&gt;rxer
(braket
id|channel
)braket
)paren
suffix:semicolon
id|dev-&gt;rxer
(braket
id|channel
)braket
op_assign
l_int|0
suffix:semicolon
)brace
singleline_comment|// atomically release our rate reservation
id|spin_lock
(paren
op_amp
id|dev-&gt;rate_lock
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_QOS
op_or
id|DBG_VCC
comma
l_string|&quot;releasing %u TX PCR and %u RX PCR&quot;
comma
id|vcc-&gt;tx_rate
comma
id|vcc-&gt;rx_rate
)paren
suffix:semicolon
id|dev-&gt;tx_avail
op_add_assign
id|vcc-&gt;tx_rate
suffix:semicolon
id|dev-&gt;rx_avail
op_add_assign
id|vcc-&gt;rx_rate
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|dev-&gt;rate_lock
)paren
suffix:semicolon
singleline_comment|// free our structure
id|kfree
(paren
id|vcc
)paren
suffix:semicolon
singleline_comment|// say the VPI/VCI is free again
id|clear_bit
c_func
(paren
id|ATM_VF_ADDR
comma
op_amp
id|atm_vcc-&gt;flags
)paren
suffix:semicolon
)brace
macro_line|#if 0
DECL|function|hrz_getsockopt
r_static
r_int
id|hrz_getsockopt
(paren
r_struct
id|atm_vcc
op_star
id|atm_vcc
comma
r_int
id|level
comma
r_int
id|optname
comma
r_void
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
id|hrz_dev
op_star
id|dev
op_assign
id|HRZ_DEV
c_func
(paren
id|atm_vcc-&gt;dev
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_VCC
comma
l_string|&quot;hrz_getsockopt&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|level
)paren
(brace
r_case
id|SOL_SOCKET
suffix:colon
r_switch
c_cond
(paren
id|optname
)paren
(brace
singleline_comment|//&t;case SO_BCTXOPT:
singleline_comment|//&t;  break;
singleline_comment|//&t;case SO_BCRXOPT:
singleline_comment|//&t;  break;
r_default
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|hrz_setsockopt
r_static
r_int
id|hrz_setsockopt
(paren
r_struct
id|atm_vcc
op_star
id|atm_vcc
comma
r_int
id|level
comma
r_int
id|optname
comma
r_void
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
id|hrz_dev
op_star
id|dev
op_assign
id|HRZ_DEV
c_func
(paren
id|atm_vcc-&gt;dev
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_VCC
comma
l_string|&quot;hrz_setsockopt&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|level
)paren
(brace
r_case
id|SOL_SOCKET
suffix:colon
r_switch
c_cond
(paren
id|optname
)paren
(brace
singleline_comment|//&t;case SO_BCTXOPT:
singleline_comment|//&t;  break;
singleline_comment|//&t;case SO_BCRXOPT:
singleline_comment|//&t;  break;
r_default
suffix:colon
r_return
op_minus
id|ENOPROTOOPT
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#endif
DECL|function|hrz_sg_send
r_static
r_int
id|hrz_sg_send
(paren
r_struct
id|atm_vcc
op_star
id|atm_vcc
comma
r_int
r_int
id|start
comma
r_int
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|atm_vcc-&gt;qos.aal
op_eq
id|ATM_AAL5
)paren
(brace
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_VCC
comma
l_string|&quot;hrz_sg_send: yes&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_FLOW
op_or
id|DBG_VCC
comma
l_string|&quot;hrz_sg_send: no&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#if 0
DECL|function|hrz_ioctl
r_static
r_int
id|hrz_ioctl
(paren
r_struct
id|atm_dev
op_star
id|atm_dev
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
id|hrz_dev
op_star
id|dev
op_assign
id|HRZ_DEV
c_func
(paren
id|atm_dev
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
comma
l_string|&quot;hrz_ioctl&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|hrz_phy_get
r_int
r_char
id|hrz_phy_get
(paren
r_struct
id|atm_dev
op_star
id|atm_dev
comma
r_int
r_int
id|addr
)paren
(brace
id|hrz_dev
op_star
id|dev
op_assign
id|HRZ_DEV
c_func
(paren
id|atm_dev
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
comma
l_string|&quot;hrz_phy_get&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hrz_phy_put
r_static
r_void
id|hrz_phy_put
(paren
r_struct
id|atm_dev
op_star
id|atm_dev
comma
r_int
r_char
id|value
comma
r_int
r_int
id|addr
)paren
(brace
id|hrz_dev
op_star
id|dev
op_assign
id|HRZ_DEV
c_func
(paren
id|atm_dev
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
comma
l_string|&quot;hrz_phy_put&quot;
)paren
suffix:semicolon
)brace
DECL|function|hrz_change_qos
r_static
r_int
id|hrz_change_qos
(paren
r_struct
id|atm_vcc
op_star
id|atm_vcc
comma
r_struct
id|atm_qos
op_star
id|qos
comma
r_int
id|flgs
)paren
(brace
id|hrz_dev
op_star
id|dev
op_assign
id|HRZ_DEV
c_func
(paren
id|vcc-&gt;dev
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
comma
l_string|&quot;hrz_change_qos&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/********** proc file contents **********/
DECL|function|hrz_proc_read
r_static
r_int
id|hrz_proc_read
(paren
r_struct
id|atm_dev
op_star
id|atm_dev
comma
id|loff_t
op_star
id|pos
comma
r_char
op_star
id|page
)paren
(brace
id|hrz_dev
op_star
id|dev
op_assign
id|HRZ_DEV
c_func
(paren
id|atm_dev
)paren
suffix:semicolon
r_int
id|left
op_assign
op_star
id|pos
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
comma
l_string|&quot;hrz_proc_read&quot;
)paren
suffix:semicolon
multiline_comment|/* more diagnostics here? */
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
id|left
op_decrement
)paren
(brace
r_int
r_int
id|count
op_assign
id|sprintf
(paren
id|page
comma
l_string|&quot;vbr buckets:&quot;
)paren
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_CHANS
suffix:semicolon
op_increment
id|i
)paren
id|count
op_add_assign
id|sprintf
(paren
id|page
comma
l_string|&quot; %u/%u&quot;
comma
id|query_tx_channel_config
(paren
id|dev
comma
id|i
comma
id|BUCKET_FULLNESS_ACCESS
)paren
comma
id|query_tx_channel_config
(paren
id|dev
comma
id|i
comma
id|BUCKET_CAPACITY_ACCESS
)paren
)paren
suffix:semicolon
id|count
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|count
comma
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|left
op_decrement
)paren
r_return
id|sprintf
(paren
id|page
comma
l_string|&quot;cells: TX %lu, RX %lu, HEC errors %lu, unassigned %lu.&bslash;n&quot;
comma
id|dev-&gt;tx_cell_count
comma
id|dev-&gt;rx_cell_count
comma
id|dev-&gt;hec_error_count
comma
id|dev-&gt;unassigned_cell_count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|left
op_decrement
)paren
r_return
id|sprintf
(paren
id|page
comma
l_string|&quot;free cell buffers: TX %hu, RX %hu+%hu.&bslash;n&quot;
comma
id|rd_regw
(paren
id|dev
comma
id|TX_FREE_BUFFER_COUNT_OFF
)paren
comma
id|rd_regw
(paren
id|dev
comma
id|RX_FREE_BUFFER_COUNT_OFF
)paren
comma
id|dev-&gt;noof_spare_buffers
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|left
op_decrement
)paren
r_return
id|sprintf
(paren
id|page
comma
l_string|&quot;cps remaining: TX %u, RX %u&bslash;n&quot;
comma
id|dev-&gt;tx_avail
comma
id|dev-&gt;rx_avail
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|hrz_ops
r_static
r_const
r_struct
id|atmdev_ops
id|hrz_ops
op_assign
(brace
id|open
suffix:colon
id|hrz_open
comma
id|close
suffix:colon
id|hrz_close
comma
id|send
suffix:colon
id|hrz_send
comma
id|sg_send
suffix:colon
id|hrz_sg_send
comma
id|proc_read
suffix:colon
id|hrz_proc_read
comma
id|owner
suffix:colon
id|THIS_MODULE
comma
)brace
suffix:semicolon
DECL|function|hrz_probe
r_static
r_int
id|__init
id|hrz_probe
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|pci_dev
suffix:semicolon
r_int
id|devs
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
comma
l_string|&quot;hrz_probe&quot;
)paren
suffix:semicolon
id|devs
op_assign
l_int|0
suffix:semicolon
id|pci_dev
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|pci_dev
op_assign
id|pci_find_device
(paren
id|PCI_VENDOR_ID_MADGE
comma
id|PCI_DEVICE_ID_MADGE_HORIZON
comma
id|pci_dev
)paren
)paren
)paren
(brace
id|hrz_dev
op_star
id|dev
suffix:semicolon
singleline_comment|// adapter slot free, read resources from PCI configuration space
id|u32
id|iobase
op_assign
id|pci_resource_start
(paren
id|pci_dev
comma
l_int|0
)paren
suffix:semicolon
id|u32
op_star
id|membase
op_assign
id|bus_to_virt
(paren
id|pci_resource_start
(paren
id|pci_dev
comma
l_int|1
)paren
)paren
suffix:semicolon
id|u8
id|irq
op_assign
id|pci_dev-&gt;irq
suffix:semicolon
singleline_comment|// check IO region
r_if
c_cond
(paren
id|check_region
(paren
id|iobase
comma
id|HRZ_IO_EXTENT
)paren
)paren
(brace
id|PRINTD
(paren
id|DBG_WARN
comma
l_string|&quot;IO range already in use&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pci_enable_device
(paren
id|pci_dev
)paren
)paren
r_continue
suffix:semicolon
id|dev
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|hrz_dev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
singleline_comment|// perhaps we should be nice: deregister all adapters and abort?
id|PRINTD
(paren
id|DBG_ERR
comma
l_string|&quot;out of memory&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|memset
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
id|hrz_dev
)paren
)paren
suffix:semicolon
singleline_comment|// grab IRQ and install handler - move this someplace more sensible
r_if
c_cond
(paren
id|request_irq
(paren
id|irq
comma
id|interrupt_handler
comma
id|SA_SHIRQ
comma
multiline_comment|/* irqflags guess */
id|DEV_LABEL
comma
multiline_comment|/* name guess */
id|dev
)paren
)paren
(brace
id|PRINTD
(paren
id|DBG_WARN
comma
l_string|&quot;request IRQ failed!&quot;
)paren
suffix:semicolon
singleline_comment|// free_irq is at &quot;endif&quot;
)brace
r_else
(brace
id|PRINTD
(paren
id|DBG_INFO
comma
l_string|&quot;found Madge ATM adapter (hrz) at: IO %x, IRQ %u, MEM %p&quot;
comma
id|iobase
comma
id|irq
comma
id|membase
)paren
suffix:semicolon
id|dev-&gt;atm_dev
op_assign
id|atm_dev_register
(paren
id|DEV_LABEL
comma
op_amp
id|hrz_ops
comma
op_minus
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;atm_dev
)paren
)paren
(brace
id|PRINTD
(paren
id|DBG_ERR
comma
l_string|&quot;failed to register Madge ATM adapter&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_char
id|lat
suffix:semicolon
id|PRINTD
(paren
id|DBG_INFO
comma
l_string|&quot;registered Madge ATM adapter (no. %d) (%p) at %p&quot;
comma
id|dev-&gt;atm_dev-&gt;number
comma
id|dev
comma
id|dev-&gt;atm_dev
)paren
suffix:semicolon
id|dev-&gt;atm_dev-&gt;dev_data
op_assign
(paren
r_void
op_star
)paren
id|dev
suffix:semicolon
id|dev-&gt;pci_dev
op_assign
id|pci_dev
suffix:semicolon
multiline_comment|/* XXX DEV_LABEL is a guess */
id|request_region
(paren
id|iobase
comma
id|HRZ_IO_EXTENT
comma
id|DEV_LABEL
)paren
suffix:semicolon
singleline_comment|// enable bus master accesses
id|pci_set_master
(paren
id|pci_dev
)paren
suffix:semicolon
singleline_comment|// frobnicate latency (upwards, usually)
id|pci_read_config_byte
(paren
id|pci_dev
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|lat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_lat
)paren
(brace
id|PRINTD
(paren
id|DBG_INFO
comma
l_string|&quot;%s PCI latency timer from %hu to %hu&quot;
comma
l_string|&quot;changing&quot;
comma
id|lat
comma
id|pci_lat
)paren
suffix:semicolon
id|pci_write_config_byte
(paren
id|pci_dev
comma
id|PCI_LATENCY_TIMER
comma
id|pci_lat
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lat
OL
id|MIN_PCI_LATENCY
)paren
(brace
id|PRINTK
(paren
id|KERN_INFO
comma
l_string|&quot;%s PCI latency timer from %hu to %hu&quot;
comma
l_string|&quot;increasing&quot;
comma
id|lat
comma
id|MIN_PCI_LATENCY
)paren
suffix:semicolon
id|pci_write_config_byte
(paren
id|pci_dev
comma
id|PCI_LATENCY_TIMER
comma
id|MIN_PCI_LATENCY
)paren
suffix:semicolon
)brace
id|dev-&gt;iobase
op_assign
id|iobase
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
id|dev-&gt;membase
op_assign
id|membase
suffix:semicolon
id|dev-&gt;rx_q_entry
op_assign
id|dev-&gt;rx_q_reset
op_assign
op_amp
id|memmap-&gt;rx_q_entries
(braket
l_int|0
)braket
suffix:semicolon
id|dev-&gt;rx_q_wrap
op_assign
op_amp
id|memmap-&gt;rx_q_entries
(braket
id|RX_CHANS
op_minus
l_int|1
)braket
suffix:semicolon
singleline_comment|// these next three are performance hacks
id|dev-&gt;last_vc
op_assign
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;tx_last
op_assign
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;tx_idle
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tx_regions
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tx_bytes
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tx_skb
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tx_iovec
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tx_cell_count
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;rx_cell_count
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;hec_error_count
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;unassigned_cell_count
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;noof_spare_buffers
op_assign
l_int|0
suffix:semicolon
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_CHANS
suffix:semicolon
op_increment
id|i
)paren
id|dev-&gt;tx_channel_record
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|dev-&gt;flags
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Allocate cell rates and remember ASIC version
singleline_comment|// Fibre: ATM_OC3_PCR = 1555200000/8/270*260/53 - 29/53
singleline_comment|// Copper: (WRONG) we want 6 into the above, close to 25Mb/s
singleline_comment|// Copper: (plagarise!) 25600000/8/270*260/53 - n/53
r_if
c_cond
(paren
id|hrz_init
(paren
id|dev
)paren
)paren
(brace
singleline_comment|// to be really pedantic, this should be ATM_OC3c_PCR
id|dev-&gt;tx_avail
op_assign
id|ATM_OC3_PCR
suffix:semicolon
id|dev-&gt;rx_avail
op_assign
id|ATM_OC3_PCR
suffix:semicolon
id|set_bit
(paren
id|ultra
comma
op_amp
id|dev-&gt;flags
)paren
suffix:semicolon
singleline_comment|// NOT &quot;|= ultra&quot; !
)brace
r_else
(brace
id|dev-&gt;tx_avail
op_assign
(paren
(paren
l_int|25600000
op_div
l_int|8
)paren
op_star
l_int|26
)paren
op_div
(paren
l_int|27
op_star
l_int|53
)paren
suffix:semicolon
id|dev-&gt;rx_avail
op_assign
(paren
(paren
l_int|25600000
op_div
l_int|8
)paren
op_star
l_int|26
)paren
op_div
(paren
l_int|27
op_star
l_int|53
)paren
suffix:semicolon
id|PRINTD
(paren
id|DBG_WARN
comma
l_string|&quot;Buggy ASIC: no TX bus-mastering.&quot;
)paren
suffix:semicolon
)brace
singleline_comment|// rate changes spinlock
id|spin_lock_init
(paren
op_amp
id|dev-&gt;rate_lock
)paren
suffix:semicolon
singleline_comment|// on-board memory access spinlock; we want atomic reads and
singleline_comment|// writes to adapter memory (handles IRQ and SMP)
id|spin_lock_init
(paren
op_amp
id|dev-&gt;mem_lock
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= 0x20303
id|init_waitqueue_head
(paren
op_amp
id|dev-&gt;tx_queue
)paren
suffix:semicolon
macro_line|#else
id|dev-&gt;tx_queue
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
singleline_comment|// vpi in 0..4, vci in 6..10
id|dev-&gt;atm_dev-&gt;ci_range.vpi_bits
op_assign
id|vpi_bits
suffix:semicolon
id|dev-&gt;atm_dev-&gt;ci_range.vci_bits
op_assign
l_int|10
op_minus
id|vpi_bits
suffix:semicolon
singleline_comment|// update count and linked list
op_increment
id|devs
suffix:semicolon
id|dev-&gt;prev
op_assign
id|hrz_devs
suffix:semicolon
id|hrz_devs
op_assign
id|dev
suffix:semicolon
singleline_comment|// success
r_continue
suffix:semicolon
multiline_comment|/* not currently reached */
id|atm_dev_deregister
(paren
id|dev-&gt;atm_dev
)paren
suffix:semicolon
)brace
multiline_comment|/* atm_dev_register */
id|free_irq
(paren
id|irq
comma
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* request_irq */
id|kfree
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* kmalloc and while */
r_return
id|devs
suffix:semicolon
)brace
DECL|function|hrz_check_args
r_static
r_void
id|__init
id|hrz_check_args
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUG_HORIZON
id|PRINTK
(paren
id|KERN_NOTICE
comma
l_string|&quot;debug bitmap is %hx&quot;
comma
id|debug
op_and_assign
id|DBG_MASK
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|debug
)paren
id|PRINTK
(paren
id|KERN_NOTICE
comma
l_string|&quot;no debug support in this image&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|vpi_bits
OG
id|HRZ_MAX_VPI
)paren
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;vpi_bits has been limited to %hu&quot;
comma
id|vpi_bits
op_assign
id|HRZ_MAX_VPI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_tx_size
OG
id|TX_AAL5_LIMIT
)paren
id|PRINTK
(paren
id|KERN_NOTICE
comma
l_string|&quot;max_tx_size has been limited to %hu&quot;
comma
id|max_tx_size
op_assign
id|TX_AAL5_LIMIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_rx_size
OG
id|RX_AAL5_LIMIT
)paren
id|PRINTK
(paren
id|KERN_NOTICE
comma
l_string|&quot;max_rx_size has been limited to %hu&quot;
comma
id|max_rx_size
op_assign
id|RX_AAL5_LIMIT
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|EXPORT_NO_SYMBOLS
suffix:semicolon
DECL|variable|maintainer_string
id|MODULE_AUTHOR
c_func
(paren
id|maintainer_string
)paren
suffix:semicolon
DECL|variable|description_string
id|MODULE_DESCRIPTION
c_func
(paren
id|description_string
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;h&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|vpi_bits
comma
l_string|&quot;h&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_tx_size
comma
l_string|&quot;h&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_rx_size
comma
l_string|&quot;h&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|pci_lat
comma
l_string|&quot;b&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|debug
comma
l_string|&quot;debug bitmap, see .h file&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|vpi_bits
comma
l_string|&quot;number of bits (0..4) to allocate to VPIs&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_tx_size
comma
l_string|&quot;maximum size of TX AAL5 frames&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_rx_size
comma
l_string|&quot;maximum size of RX AAL5 frames&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|pci_lat
comma
l_string|&quot;PCI latency in bus cycles&quot;
)paren
suffix:semicolon
multiline_comment|/********** module entry **********/
DECL|function|init_module
r_int
id|init_module
(paren
r_void
)paren
(brace
r_int
id|devs
suffix:semicolon
singleline_comment|// sanity check - cast is needed since printk does not support %Zu
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|MEMMAP
)paren
op_ne
l_int|128
op_star
l_int|1024
op_div
l_int|4
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;Fix struct MEMMAP (is %lu fakewords).&quot;
comma
(paren
r_int
r_int
)paren
r_sizeof
(paren
r_struct
id|MEMMAP
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|show_version
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// check arguments
id|hrz_check_args
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// get the juice
id|devs
op_assign
id|hrz_probe
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devs
)paren
(brace
id|init_timer
(paren
op_amp
id|housekeeping
)paren
suffix:semicolon
id|housekeeping.function
op_assign
id|do_housekeeping
suffix:semicolon
singleline_comment|// paranoia
id|housekeeping.data
op_assign
l_int|1
suffix:semicolon
id|set_timer
(paren
op_amp
id|housekeeping
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;no (usable) adapters found&quot;
)paren
suffix:semicolon
)brace
r_return
id|devs
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/********** module exit **********/
DECL|function|cleanup_module
r_void
id|cleanup_module
(paren
r_void
)paren
(brace
id|hrz_dev
op_star
id|dev
suffix:semicolon
id|PRINTD
(paren
id|DBG_FLOW
comma
l_string|&quot;cleanup_module&quot;
)paren
suffix:semicolon
singleline_comment|// paranoia
id|housekeeping.data
op_assign
l_int|0
suffix:semicolon
id|del_timer
(paren
op_amp
id|housekeeping
)paren
suffix:semicolon
r_while
c_loop
(paren
id|hrz_devs
)paren
(brace
id|dev
op_assign
id|hrz_devs
suffix:semicolon
id|hrz_devs
op_assign
id|dev-&gt;prev
suffix:semicolon
id|PRINTD
(paren
id|DBG_INFO
comma
l_string|&quot;closing %p (atm_dev = %p)&quot;
comma
id|dev
comma
id|dev-&gt;atm_dev
)paren
suffix:semicolon
id|hrz_reset
(paren
id|dev
)paren
suffix:semicolon
id|atm_dev_deregister
(paren
id|dev-&gt;atm_dev
)paren
suffix:semicolon
id|free_irq
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|release_region
(paren
id|dev-&gt;iobase
comma
id|HRZ_IO_EXTENT
)paren
suffix:semicolon
id|kfree
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/********** monolithic entry **********/
DECL|function|hrz_detect
r_int
id|__init
id|hrz_detect
(paren
r_void
)paren
(brace
r_int
id|devs
suffix:semicolon
singleline_comment|// sanity check - cast is needed since printk does not support %Zu
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|MEMMAP
)paren
op_ne
l_int|128
op_star
l_int|1024
op_div
l_int|4
)paren
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;Fix struct MEMMAP (is %lu fakewords).&quot;
comma
(paren
r_int
r_int
)paren
r_sizeof
(paren
r_struct
id|MEMMAP
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|show_version
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// what about command line arguments?
singleline_comment|// check arguments
id|hrz_check_args
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// get the juice
id|devs
op_assign
id|hrz_probe
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devs
)paren
(brace
id|init_timer
(paren
op_amp
id|housekeeping
)paren
suffix:semicolon
id|housekeeping.function
op_assign
id|do_housekeeping
suffix:semicolon
singleline_comment|// paranoia
id|housekeeping.data
op_assign
l_int|1
suffix:semicolon
id|set_timer
(paren
op_amp
id|housekeeping
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTK
(paren
id|KERN_ERR
comma
l_string|&quot;no (usable) adapters found&quot;
)paren
suffix:semicolon
)brace
r_return
id|devs
suffix:semicolon
)brace
macro_line|#endif
eof
