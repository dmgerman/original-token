multiline_comment|/* drivers/atm/firestream.c - FireStream 155 (MB86697) and&n; *                            FireStream  50 (MB86695) device driver &n; */
multiline_comment|/* Written &amp; (C) 2000 by R.E.Wolff@BitWizard.nl &n; * Copied snippets from zatm.c by Werner Almesberger, EPFL LRC/ICA &n; * and ambassador.c Copyright (C) 1995-1999  Madge Networks Ltd &n; */
multiline_comment|/*&n;  This program is free software; you can redistribute it and/or modify&n;  it under the terms of the GNU General Public License as published by&n;  the Free Software Foundation; either version 2 of the License, or&n;  (at your option) any later version.&n;&n;  This program is distributed in the hope that it will be useful,&n;  but WITHOUT ANY WARRANTY; without even the implied warranty of&n;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;  GNU General Public License for more details.&n;&n;  You should have received a copy of the GNU General Public License&n;  along with this program; if not, write to the Free Software&n;  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n;&n;  The GNU GPL is contained in /usr/doc/copyright/GPL on a Debian&n;  system and in the file COPYING in the Linux kernel source.&n;*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/atm.h&gt;
macro_line|#include &lt;linux/atmdev.h&gt;
macro_line|#include &lt;linux/sonet.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioport.h&gt; /* for request_region */
macro_line|#include &lt;linux/uio.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/capability.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/string.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &quot;firestream.h&quot;
DECL|variable|loopback
r_static
r_int
id|loopback
op_assign
l_int|0
suffix:semicolon
DECL|variable|num
r_static
r_int
id|num
op_assign
l_int|0x5a
suffix:semicolon
multiline_comment|/* According to measurements (but they look suspicious to me!) done in&n; * &squot;97, 37% of the packets are one cell in size. So it pays to have&n; * buffers allocated at that size. A large jump in percentage of&n; * packets occurs at packets around 536 bytes in length. So it also&n; * pays to have those pre-allocated. Unfortunately, we can&squot;t fully&n; * take advantage of this as the majority of the packets is likely to&n; * be TCP/IP (As where obviously the measurement comes from) There the&n; * link would be opened with say a 1500 byte MTU, and we can&squot;t handle&n; * smaller buffers more efficiently than the larger ones. -- REW&n; */
multiline_comment|/* Due to the way Linux memory management works, specifying &quot;576&quot; as&n; * an allocation size here isn&squot;t going to help. They are allocated&n; * from 1024-byte regions anyway. With the size of the sk_buffs (quite&n; * large), it doesn&squot;t pay to allocate the smallest size (64) -- REW */
multiline_comment|/* This is all guesswork. Hard numbers to back this up or disprove this, &n; * are appreciated. -- REW */
multiline_comment|/* The last entry should be about 64k. However, the &quot;buffer size&quot; is&n; * passed to the chip in a 16 bit field. I don&squot;t know how &quot;65536&quot;&n; * would be interpreted. -- REW */
DECL|macro|NP
mdefine_line|#define NP FS_NR_FREE_POOLS
DECL|variable|rx_buf_sizes
r_int
id|rx_buf_sizes
(braket
id|NP
)braket
op_assign
(brace
l_int|128
comma
l_int|256
comma
l_int|512
comma
l_int|1024
comma
l_int|2048
comma
l_int|4096
comma
l_int|16384
comma
l_int|65520
)brace
suffix:semicolon
multiline_comment|/* log2:                 7     8     9    10    11    12    14     16 */
macro_line|#if 0
r_int
id|rx_pool_sizes
(braket
id|NP
)braket
op_assign
(brace
l_int|1024
comma
l_int|1024
comma
l_int|512
comma
l_int|256
comma
l_int|128
comma
l_int|64
comma
l_int|32
comma
l_int|32
)brace
suffix:semicolon
macro_line|#else
multiline_comment|/* debug */
DECL|variable|rx_pool_sizes
r_int
id|rx_pool_sizes
(braket
id|NP
)braket
op_assign
(brace
l_int|128
comma
l_int|128
comma
l_int|128
comma
l_int|64
comma
l_int|64
comma
l_int|64
comma
l_int|32
comma
l_int|32
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/* log2:                 10    10    9    8     7     6     5      5  */
multiline_comment|/* sumlog2:              17    18    18   18    18    18    19     21 */
multiline_comment|/* mem allocated:        128k  256k  256k 256k  256k  256k  512k   2M */
multiline_comment|/* tot mem: almost 4M */
multiline_comment|/* NP is shorter, so that it fits on a single line. */
DECL|macro|NP
macro_line|#undef NP
multiline_comment|/* Small hardware gotcha:&n;&n;   The FS50 CAM (VP/VC match registers) always take the lowest channel&n;   number that matches. This is not a problem.&n;&n;   However, they also ignore wether the channel is enabled or&n;   not. This means that if you allocate channel 0 to 1.2 and then&n;   channel 1 to 0.0, then disabeling channel 0 and writing 0 to the&n;   match channel for channel 0 will &quot;steal&quot; the traffic from channel&n;   1, even if you correctly disable channel 0.&n;&n;   Workaround: &n;&n;   - When disabling channels, write an invalid VP/VC value to the&n;   match register. (We use 0xffffffff, which in the worst case &n;   matches VP/VC = &lt;maxVP&gt;/&lt;maxVC&gt;, but I expect it not to match&n;   anything as some &quot;when not in use, program to 0&quot; bits are now&n;   programmed to 1...)&n;&n;   - Don&squot;t initialize the match registers to 0, as 0.0 is a valid&n;   channel.&n;*/
multiline_comment|/* Optimization hints and tips.&n;&n;   The FireStream chips are very capable of reducing the amount of&n;   &quot;interrupt-traffic&quot; for the CPU. This driver requests an interrupt on EVERY&n;   action. You could try to minimize this a bit. &n;&n;   Besides that, the userspace-&gt;kernel copy and the PCI bus are the&n;   performance limiting issues for this driver.&n;&n;   You could queue up a bunch of outgoing packets without telling the&n;   FireStream. I&squot;m not sure that&squot;s going to win you much though. The&n;   Linux layer won&squot;t tell us in advance when it&squot;s not going to give us&n;   any more packets in a while. So this is tricky to implement right without&n;   introducing extra delays. &n;  &n;   -- REW&n; */
multiline_comment|/* The strings that define what the RX queue entry is all about. */
multiline_comment|/* Fujitsu: Please tell me which ones can have a pointer to a &n;   freepool descriptor! */
DECL|variable|res_strings
r_static
r_char
op_star
id|res_strings
(braket
)braket
op_assign
(brace
l_string|&quot;RX OK: streaming not EOP&quot;
comma
l_string|&quot;RX OK: streaming EOP&quot;
comma
l_string|&quot;RX OK: Single buffer packet&quot;
comma
l_string|&quot;RX OK: packet mode&quot;
comma
l_string|&quot;RX OK: F4 OAM (end to end)&quot;
comma
l_string|&quot;RX OK: F4 OAM (Segment)&quot;
comma
l_string|&quot;RX OK: F5 OAM (end to end)&quot;
comma
l_string|&quot;RX OK: F5 OAM (Segment)&quot;
comma
l_string|&quot;RX OK: RM cell&quot;
comma
l_string|&quot;RX OK: TRANSP cell&quot;
comma
l_string|&quot;RX OK: TRANSPC cell&quot;
comma
l_string|&quot;Unmatched cell&quot;
comma
l_string|&quot;reserved 12&quot;
comma
l_string|&quot;reserved 13&quot;
comma
l_string|&quot;reserved 14&quot;
comma
l_string|&quot;Unrecognized cell&quot;
comma
l_string|&quot;reserved 16&quot;
comma
l_string|&quot;reassemby abort: AAL5 abort&quot;
comma
l_string|&quot;packet purged&quot;
comma
l_string|&quot;packet ageing timeout&quot;
comma
l_string|&quot;channel ageing timeout&quot;
comma
l_string|&quot;calculated lenght error&quot;
comma
l_string|&quot;programmed lenght limit error&quot;
comma
l_string|&quot;aal5 crc32 error&quot;
comma
l_string|&quot;oam transp or transpc crc10 error&quot;
comma
l_string|&quot;reserved 25&quot;
comma
l_string|&quot;reserved 26&quot;
comma
l_string|&quot;reserved 27&quot;
comma
l_string|&quot;reserved 28&quot;
comma
l_string|&quot;reserved 29&quot;
comma
l_string|&quot;reserved 30&quot;
comma
l_string|&quot;reassembly abort: no buffers&quot;
comma
l_string|&quot;receive buffer overflow&quot;
comma
l_string|&quot;change in GFC&quot;
comma
l_string|&quot;receive buffer full&quot;
comma
l_string|&quot;low priority discard - no receive descriptor&quot;
comma
l_string|&quot;low priority discard - missing end of packet&quot;
comma
l_string|&quot;reserved 41&quot;
comma
l_string|&quot;reserved 42&quot;
comma
l_string|&quot;reserved 43&quot;
comma
l_string|&quot;reserved 44&quot;
comma
l_string|&quot;reserved 45&quot;
comma
l_string|&quot;reserved 46&quot;
comma
l_string|&quot;reserved 47&quot;
comma
l_string|&quot;reserved 48&quot;
comma
l_string|&quot;reserved 49&quot;
comma
l_string|&quot;reserved 50&quot;
comma
l_string|&quot;reserved 51&quot;
comma
l_string|&quot;reserved 52&quot;
comma
l_string|&quot;reserved 53&quot;
comma
l_string|&quot;reserved 54&quot;
comma
l_string|&quot;reserved 55&quot;
comma
l_string|&quot;reserved 56&quot;
comma
l_string|&quot;reserved 57&quot;
comma
l_string|&quot;reserved 58&quot;
comma
l_string|&quot;reserved 59&quot;
comma
l_string|&quot;reserved 60&quot;
comma
l_string|&quot;reserved 61&quot;
comma
l_string|&quot;reserved 62&quot;
comma
l_string|&quot;reserved 63&quot;
comma
)brace
suffix:semicolon
DECL|variable|irq_bitname
r_static
r_char
op_star
id|irq_bitname
(braket
)braket
op_assign
(brace
l_string|&quot;LPCO&quot;
comma
l_string|&quot;DPCO&quot;
comma
l_string|&quot;RBRQ0_W&quot;
comma
l_string|&quot;RBRQ1_W&quot;
comma
l_string|&quot;RBRQ2_W&quot;
comma
l_string|&quot;RBRQ3_W&quot;
comma
l_string|&quot;RBRQ0_NF&quot;
comma
l_string|&quot;RBRQ1_NF&quot;
comma
l_string|&quot;RBRQ2_NF&quot;
comma
l_string|&quot;RBRQ3_NF&quot;
comma
l_string|&quot;BFP_SC&quot;
comma
l_string|&quot;INIT&quot;
comma
l_string|&quot;INIT_ERR&quot;
comma
l_string|&quot;USCEO&quot;
comma
l_string|&quot;UPEC0&quot;
comma
l_string|&quot;VPFCO&quot;
comma
l_string|&quot;CRCCO&quot;
comma
l_string|&quot;HECO&quot;
comma
l_string|&quot;TBRQ_W&quot;
comma
l_string|&quot;TBRQ_NF&quot;
comma
l_string|&quot;CTPQ_E&quot;
comma
l_string|&quot;GFC_C0&quot;
comma
l_string|&quot;PCI_FTL&quot;
comma
l_string|&quot;CSQ_W&quot;
comma
l_string|&quot;CSQ_NF&quot;
comma
l_string|&quot;EXT_INT&quot;
comma
l_string|&quot;RXDMA_S&quot;
)brace
suffix:semicolon
DECL|macro|PHY_EOF
mdefine_line|#define PHY_EOF -1
DECL|macro|PHY_CLEARALL
mdefine_line|#define PHY_CLEARALL -2
DECL|struct|reginit_item
r_struct
id|reginit_item
(brace
DECL|member|reg
DECL|member|val
r_int
id|reg
comma
id|val
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|__initdata
r_struct
id|reginit_item
id|PHY_NTC_INIT
(braket
)braket
id|__initdata
op_assign
(brace
(brace
id|PHY_CLEARALL
comma
l_int|0x40
)brace
comma
(brace
l_int|0x12
comma
l_int|0x0001
)brace
comma
(brace
l_int|0x13
comma
l_int|0x7605
)brace
comma
(brace
l_int|0x1A
comma
l_int|0x0001
)brace
comma
(brace
l_int|0x1B
comma
l_int|0x0005
)brace
comma
(brace
l_int|0x38
comma
l_int|0x0003
)brace
comma
(brace
l_int|0x39
comma
l_int|0x0006
)brace
comma
multiline_comment|/* changed here to make loopback */
(brace
l_int|0x01
comma
l_int|0x5262
)brace
comma
(brace
l_int|0x15
comma
l_int|0x0213
)brace
comma
(brace
l_int|0x00
comma
l_int|0x0003
)brace
comma
(brace
id|PHY_EOF
comma
l_int|0
)brace
comma
multiline_comment|/* -1 signals end of list */
)brace
suffix:semicolon
multiline_comment|/* Safetyfeature: If the card interrupts more than this number of times&n;   in a jiffy (1/100th of a second) then we just disable the interrupt and&n;   print a message. This prevents the system from hanging. &n;&n;   150000 packets per second is close to the limit a PC is going to have&n;   anyway. We therefore have to disable this for production. -- REW */
DECL|macro|IRQ_RATE_LIMIT
macro_line|#undef IRQ_RATE_LIMIT 100
multiline_comment|/* Interrupts work now. Unlike serial cards, ATM cards don&squot;t work all&n;   that great without interrupts. -- REW */
DECL|macro|FS_POLL_FREQ
macro_line|#undef FS_POLL_FREQ 100
multiline_comment|/* &n;   This driver can spew a whole lot of debugging output at you. If you&n;   need maximum performance, you should disable the DEBUG define. To&n;   aid in debugging in the field, I&squot;m leaving the compile-time debug&n;   features enabled, and disable them &quot;runtime&quot;. That allows me to&n;   instruct people with problems to enable debugging without requiring&n;   them to recompile... -- REW&n;*/
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#ifdef DEBUG
DECL|macro|fs_dprintk
mdefine_line|#define fs_dprintk(f, str...) if (fs_debug &amp; f) printk (str)
macro_line|#else
DECL|macro|fs_dprintk
mdefine_line|#define fs_dprintk(f, str...) /* nothing */
macro_line|#endif
macro_line|#ifdef DEBUG
multiline_comment|/* I didn&squot;t forget to set this to zero before shipping. Hit me with a stick &n;   if you get this with the debug default not set to zero again. -- REW */
DECL|variable|fs_debug
r_static
r_int
id|fs_debug
op_assign
l_int|0
suffix:semicolon
macro_line|#else
DECL|macro|fs_debug
mdefine_line|#define fs_debug 0
macro_line|#endif
macro_line|#ifdef MODULE
macro_line|#ifdef DEBUG 
id|MODULE_PARM
c_func
(paren
id|fs_debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
id|MODULE_PARM
c_func
(paren
id|loopback
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|num
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/* XXX Add rx_buf_sizes, and rx_pool_sizes As per request Amar. -- REW */
macro_line|#endif
DECL|macro|FS_DEBUG_FLOW
mdefine_line|#define FS_DEBUG_FLOW    0x00000001
DECL|macro|FS_DEBUG_OPEN
mdefine_line|#define FS_DEBUG_OPEN    0x00000002
DECL|macro|FS_DEBUG_QUEUE
mdefine_line|#define FS_DEBUG_QUEUE   0x00000004
DECL|macro|FS_DEBUG_IRQ
mdefine_line|#define FS_DEBUG_IRQ     0x00000008
DECL|macro|FS_DEBUG_INIT
mdefine_line|#define FS_DEBUG_INIT    0x00000010
DECL|macro|FS_DEBUG_SEND
mdefine_line|#define FS_DEBUG_SEND    0x00000020
DECL|macro|FS_DEBUG_PHY
mdefine_line|#define FS_DEBUG_PHY     0x00000040
DECL|macro|FS_DEBUG_CLEANUP
mdefine_line|#define FS_DEBUG_CLEANUP 0x00000080
DECL|macro|FS_DEBUG_QOS
mdefine_line|#define FS_DEBUG_QOS     0x00000100
DECL|macro|FS_DEBUG_TXQ
mdefine_line|#define FS_DEBUG_TXQ     0x00000200
DECL|macro|FS_DEBUG_ALLOC
mdefine_line|#define FS_DEBUG_ALLOC   0x00000400
DECL|macro|FS_DEBUG_TXMEM
mdefine_line|#define FS_DEBUG_TXMEM   0x00000800
DECL|macro|FS_DEBUG_QSIZE
mdefine_line|#define FS_DEBUG_QSIZE   0x00001000
DECL|macro|func_enter
mdefine_line|#define func_enter() fs_dprintk (FS_DEBUG_FLOW, &quot;fs: enter &quot; __FUNCTION__ &quot;&bslash;n&quot;)
DECL|macro|func_exit
mdefine_line|#define func_exit()  fs_dprintk (FS_DEBUG_FLOW, &quot;fs: exit  &quot; __FUNCTION__ &quot;&bslash;n&quot;)
DECL|variable|fs_boards
r_struct
id|fs_dev
op_star
id|fs_boards
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef DEBUG
DECL|function|my_hd
r_static
r_void
id|my_hd
(paren
r_void
op_star
id|addr
comma
r_int
id|len
)paren
(brace
r_int
id|j
comma
id|ch
suffix:semicolon
r_int
r_char
op_star
id|ptr
op_assign
id|addr
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%p &quot;
comma
id|ptr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
(paren
(paren
id|len
OL
l_int|16
)paren
ques
c_cond
id|len
suffix:colon
l_int|16
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
id|printk
(paren
l_string|&quot;%02x %s&quot;
comma
id|ptr
(braket
id|j
)braket
comma
(paren
id|j
op_eq
l_int|7
)paren
ques
c_cond
l_string|&quot; &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|j
OL
l_int|16
suffix:semicolon
id|j
op_increment
)paren
(brace
id|printk
(paren
l_string|&quot;   %s&quot;
comma
(paren
id|j
op_eq
l_int|7
)paren
ques
c_cond
l_string|&quot; &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
(paren
(paren
id|len
OL
l_int|16
)paren
ques
c_cond
id|len
suffix:colon
l_int|16
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
id|ch
op_assign
id|ptr
(braket
id|j
)braket
suffix:semicolon
id|printk
(paren
l_string|&quot;%c&quot;
comma
(paren
id|ch
OL
l_int|0x20
)paren
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
(paren
(paren
id|ch
OG
l_int|0x7f
)paren
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
id|ch
)paren
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|16
suffix:semicolon
id|len
op_sub_assign
l_int|16
suffix:semicolon
)brace
)brace
macro_line|#else /* DEBUG */
DECL|function|my_hd
r_static
r_void
id|my_hd
(paren
r_void
op_star
id|addr
comma
r_int
id|len
)paren
(brace
)brace
macro_line|#endif /* DEBUG */
multiline_comment|/********** free an skb (as per ATM device driver documentation) **********/
multiline_comment|/* Hmm. If this is ATM specific, why isn&squot;t there an ATM routine for this?&n; * I copied it over from the ambassador driver. -- REW */
DECL|function|fs_kfree_skb
r_static
r_inline
r_void
id|fs_kfree_skb
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc-&gt;pop
)paren
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc-&gt;pop
(paren
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc
comma
id|skb
)paren
suffix:semicolon
r_else
id|dev_kfree_skb_any
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* It seems the ATM forum recomends this horribly complicated 16bit&n; * floating point format. Turns out the Ambassador uses the exact same&n; * encoding. I just copied it over. If Mitch agrees, I&squot;ll move it over&n; * to the atm_misc file or something like that. (and remove it from &n; * here and the ambassador driver) -- REW&n; */
multiline_comment|/* The good thing about this format is that it is monotonic. So, &n;   a conversion routine need not be very complicated. To be able to&n;   round &quot;nearest&quot; we need to take along a few extra bits. Lets&n;   put these after 16 bits, so that we can just return the top 16&n;   bits of the 32bit number as the result:&n;&n;   int mr (unsigned int rate, int r) &n;     {&n;     int e = 16+9;&n;     static int round[4]={0, 0, 0xffff, 0x8000};&n;     if (!rate) return 0;&n;     while (rate &amp; 0xfc000000) {&n;       rate &gt;&gt;= 1;&n;       e++;&n;     }&n;     while (! (rate &amp; 0xfe000000)) {&n;       rate &lt;&lt;= 1;&n;       e--;&n;     }&n;&n;// Now the mantissa is in positions bit 16-25. Excepf for the &quot;hidden 1&quot; that&squot;s in bit 26.&n;     rate &amp;= ~0x02000000;&n;// Next add in the exponent&n;     rate |= e &lt;&lt; (16+9);&n;// And perform the rounding:&n;     return (rate + round[r]) &gt;&gt; 16;&n;   }&n;&n;   14 lines-of-code. Compare that with the 120 that the Ambassador&n;   guys needed. (would be 8 lines shorter if I&squot;d try to really reduce&n;   the number of lines:&n;&n;   int mr (unsigned int rate, int r) &n;   {&n;     int e = 16+9;&n;     static int round[4]={0, 0, 0xffff, 0x8000};&n;     if (!rate) return 0;&n;     for (;  rate &amp; 0xfc000000 ;rate &gt;&gt;= 1, e++);&n;     for (;!(rate &amp; 0xfe000000);rate &lt;&lt;= 1, e--);&n;     return ((rate &amp; ~0x02000000) | (e &lt;&lt; (16+9)) + round[r]) &gt;&gt; 16;&n;   }&n;&n;   Exercise for the reader: Remove one more line-of-code, without&n;   cheating. (Just joining two lines is cheating). (I know it&squot;s&n;   possible, don&squot;t think you&squot;ve beat me if you found it... If you&n;   manage to lose two lines or more, keep me updated! ;-)&n;&n;   -- REW */
DECL|macro|ROUND_UP
mdefine_line|#define ROUND_UP      1
DECL|macro|ROUND_DOWN
mdefine_line|#define ROUND_DOWN    2
DECL|macro|ROUND_NEAREST
mdefine_line|#define ROUND_NEAREST 3
multiline_comment|/********** make rate (not quite as much fun as Horizon) **********/
DECL|function|make_rate
r_static
r_int
r_int
id|make_rate
(paren
r_int
r_int
id|rate
comma
r_int
id|r
comma
id|u16
op_star
id|bits
comma
r_int
r_int
op_star
id|actual
)paren
(brace
r_int
r_char
id|exp
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* hush gcc */
r_int
r_int
id|man
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* hush gcc */
id|fs_dprintk
(paren
id|FS_DEBUG_QOS
comma
l_string|&quot;make_rate %u&quot;
comma
id|rate
)paren
suffix:semicolon
multiline_comment|/* rates in cells per second, ITU format (nasty 16-bit floating-point)&n;&t;   given 5-bit e and 9-bit m:&n;&t;   rate = EITHER (1+m/2^9)*2^e    OR 0&n;&t;   bits = EITHER 1&lt;&lt;14 | e&lt;&lt;9 | m OR 0&n;&t;   (bit 15 is &quot;reserved&quot;, bit 14 &quot;non-zero&quot;)&n;&t;   smallest rate is 0 (special representation)&n;&t;   largest rate is (1+511/512)*2^31 = 4290772992 (&lt; 2^32-1)&n;&t;   smallest non-zero rate is (1+0/512)*2^0 = 1 (&gt; 0)&n;&t;   simple algorithm:&n;&t;   find position of top bit, this gives e&n;&t;   remove top bit and shift (rounding if feeling clever) by 9-e&n;&t;*/
multiline_comment|/* Ambassador ucode bug: please don&squot;t set bit 14! so 0 rate not&n;&t;   representable. // This should move into the ambassador driver&n;&t;   when properly merged. -- REW */
r_if
c_cond
(paren
id|rate
OG
l_int|0xffc00000U
)paren
(brace
multiline_comment|/* larger than largest representable rate */
r_if
c_cond
(paren
id|r
op_eq
id|ROUND_UP
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
id|exp
op_assign
l_int|31
suffix:semicolon
id|man
op_assign
l_int|511
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|rate
)paren
(brace
multiline_comment|/* representable rate */
id|exp
op_assign
l_int|31
suffix:semicolon
id|man
op_assign
id|rate
suffix:semicolon
multiline_comment|/* invariant: rate = man*2^(exp-31) */
r_while
c_loop
(paren
op_logical_neg
(paren
id|man
op_amp
(paren
l_int|1
op_lshift
l_int|31
)paren
)paren
)paren
(brace
id|exp
op_assign
id|exp
op_minus
l_int|1
suffix:semicolon
id|man
op_assign
id|man
op_lshift
l_int|1
suffix:semicolon
)brace
multiline_comment|/* man has top bit set&n;&t;&t;   rate = (2^31+(man-2^31))*2^(exp-31)&n;&t;&t;   rate = (1+(man-2^31)/2^31)*2^exp &n;&t;&t;*/
id|man
op_assign
id|man
op_lshift
l_int|1
suffix:semicolon
id|man
op_and_assign
l_int|0xffffffffU
suffix:semicolon
multiline_comment|/* a nop on 32-bit systems */
multiline_comment|/* rate = (1+man/2^32)*2^exp&n;    &n;&t;&t;   exp is in the range 0 to 31, man is in the range 0 to 2^32-1&n;&t;&t;   time to lose significance... we want m in the range 0 to 2^9-1&n;&t;&t;   rounding presents a minor problem... we first decide which way&n;&t;&t;   we are rounding (based on given rounding direction and possibly&n;&t;&t;   the bits of the mantissa that are to be discarded).&n;&t;&t;*/
r_switch
c_cond
(paren
id|r
)paren
(brace
r_case
id|ROUND_DOWN
suffix:colon
(brace
multiline_comment|/* just truncate */
id|man
op_assign
id|man
op_rshift
(paren
l_int|32
op_minus
l_int|9
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|ROUND_UP
suffix:colon
(brace
multiline_comment|/* check all bits that we are discarding */
r_if
c_cond
(paren
id|man
op_amp
(paren
op_minus
l_int|1
op_rshift
l_int|9
)paren
)paren
(brace
id|man
op_assign
(paren
id|man
op_rshift
(paren
l_int|32
op_minus
l_int|9
)paren
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|man
op_eq
(paren
l_int|1
op_lshift
l_int|9
)paren
)paren
(brace
multiline_comment|/* no need to check for round up outside of range */
id|man
op_assign
l_int|0
suffix:semicolon
id|exp
op_add_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|man
op_assign
(paren
id|man
op_rshift
(paren
l_int|32
op_minus
l_int|9
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|ROUND_NEAREST
suffix:colon
(brace
multiline_comment|/* check msb that we are discarding */
r_if
c_cond
(paren
id|man
op_amp
(paren
l_int|1
op_lshift
(paren
l_int|32
op_minus
l_int|9
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|man
op_assign
(paren
id|man
op_rshift
(paren
l_int|32
op_minus
l_int|9
)paren
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|man
op_eq
(paren
l_int|1
op_lshift
l_int|9
)paren
)paren
(brace
multiline_comment|/* no need to check for round up outside of range */
id|man
op_assign
l_int|0
suffix:semicolon
id|exp
op_add_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|man
op_assign
(paren
id|man
op_rshift
(paren
l_int|32
op_minus
l_int|9
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* zero rate - not representable */
r_if
c_cond
(paren
id|r
op_eq
id|ROUND_DOWN
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
id|exp
op_assign
l_int|0
suffix:semicolon
id|man
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|fs_dprintk
(paren
id|FS_DEBUG_QOS
comma
l_string|&quot;rate: man=%u, exp=%hu&quot;
comma
id|man
comma
id|exp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bits
)paren
op_star
id|bits
op_assign
multiline_comment|/* (1&lt;&lt;14) | */
(paren
id|exp
op_lshift
l_int|9
)paren
op_or
id|man
suffix:semicolon
r_if
c_cond
(paren
id|actual
)paren
op_star
id|actual
op_assign
(paren
id|exp
op_ge
l_int|9
)paren
ques
c_cond
(paren
l_int|1
op_lshift
id|exp
)paren
op_plus
(paren
id|man
op_lshift
(paren
id|exp
op_minus
l_int|9
)paren
)paren
suffix:colon
(paren
l_int|1
op_lshift
id|exp
)paren
op_plus
(paren
(paren
id|man
op_plus
(paren
l_int|1
op_lshift
(paren
l_int|9
op_minus
id|exp
op_minus
l_int|1
)paren
)paren
)paren
op_rshift
(paren
l_int|9
op_minus
id|exp
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* FireStream access routines */
multiline_comment|/* For DEEP-DOWN debugging these can be rigged to intercept accesses to&n;   certain registers or to just log all accesses. */
DECL|function|write_fs
r_static
r_inline
r_void
id|write_fs
(paren
r_struct
id|fs_dev
op_star
id|dev
comma
r_int
id|offset
comma
id|u32
id|val
)paren
(brace
id|writel
(paren
id|val
comma
id|dev-&gt;base
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|read_fs
r_static
r_inline
id|u32
id|read_fs
(paren
r_struct
id|fs_dev
op_star
id|dev
comma
r_int
id|offset
)paren
(brace
r_return
id|readl
(paren
id|dev-&gt;base
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|get_qentry
r_static
r_inline
r_struct
id|FS_QENTRY
op_star
id|get_qentry
(paren
r_struct
id|fs_dev
op_star
id|dev
comma
r_struct
id|queue
op_star
id|q
)paren
(brace
r_return
id|bus_to_virt
(paren
id|read_fs
(paren
id|dev
comma
id|Q_WP
c_func
(paren
id|q-&gt;offset
)paren
)paren
op_amp
id|Q_ADDR_MASK
)paren
suffix:semicolon
)brace
DECL|function|submit_qentry
r_static
r_void
id|submit_qentry
(paren
r_struct
id|fs_dev
op_star
id|dev
comma
r_struct
id|queue
op_star
id|q
comma
r_struct
id|FS_QENTRY
op_star
id|qe
)paren
(brace
id|u32
id|wp
suffix:semicolon
r_struct
id|FS_QENTRY
op_star
id|cqe
suffix:semicolon
multiline_comment|/* XXX Sanity check: the write pointer can be checked to be &n;&t;   still the same as the value passed as qe... -- REW */
multiline_comment|/*  udelay (5); */
r_while
c_loop
(paren
(paren
id|wp
op_assign
id|read_fs
(paren
id|dev
comma
id|Q_WP
(paren
id|q-&gt;offset
)paren
)paren
)paren
op_amp
id|Q_FULL
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_TXQ
comma
l_string|&quot;Found queue at %x full. Waiting.&bslash;n&quot;
comma
id|q-&gt;offset
)paren
suffix:semicolon
id|schedule
(paren
)paren
suffix:semicolon
)brace
id|wp
op_and_assign
op_complement
l_int|0xf
suffix:semicolon
id|cqe
op_assign
id|bus_to_virt
(paren
id|wp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qe
op_ne
id|cqe
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_TXQ
comma
l_string|&quot;q mismatch! %p %p&bslash;n&quot;
comma
id|qe
comma
id|cqe
)paren
suffix:semicolon
)brace
id|write_fs
(paren
id|dev
comma
id|Q_WP
c_func
(paren
id|q-&gt;offset
)paren
comma
id|Q_INCWRAP
)paren
suffix:semicolon
(brace
r_static
r_int
id|c
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|c
op_increment
op_mod
l_int|100
)paren
)paren
(brace
r_int
id|rp
comma
id|wp
suffix:semicolon
id|rp
op_assign
id|read_fs
(paren
id|dev
comma
id|Q_RP
c_func
(paren
id|q-&gt;offset
)paren
)paren
suffix:semicolon
id|wp
op_assign
id|read_fs
(paren
id|dev
comma
id|Q_WP
c_func
(paren
id|q-&gt;offset
)paren
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_TXQ
comma
l_string|&quot;q at %d: %x-%x: %x entries.&bslash;n&quot;
comma
id|q-&gt;offset
comma
id|rp
comma
id|wp
comma
id|wp
op_minus
id|rp
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef DEBUG_EXTRA
DECL|variable|pq
r_static
r_struct
id|FS_QENTRY
id|pq
(braket
l_int|60
)braket
suffix:semicolon
DECL|variable|qp
r_static
r_int
id|qp
suffix:semicolon
DECL|variable|dq
r_static
r_struct
id|FS_BPENTRY
id|dq
(braket
l_int|60
)braket
suffix:semicolon
DECL|variable|qd
r_static
r_int
id|qd
suffix:semicolon
DECL|variable|da
r_static
r_void
op_star
id|da
(braket
l_int|60
)braket
suffix:semicolon
macro_line|#endif 
DECL|function|submit_queue
r_static
r_void
id|submit_queue
(paren
r_struct
id|fs_dev
op_star
id|dev
comma
r_struct
id|queue
op_star
id|q
comma
id|u32
id|cmd
comma
id|u32
id|p1
comma
id|u32
id|p2
comma
id|u32
id|p3
)paren
(brace
r_struct
id|FS_QENTRY
op_star
id|qe
suffix:semicolon
id|qe
op_assign
id|get_qentry
(paren
id|dev
comma
id|q
)paren
suffix:semicolon
id|qe-&gt;cmd
op_assign
id|cmd
suffix:semicolon
id|qe-&gt;p0
op_assign
id|p1
suffix:semicolon
id|qe-&gt;p1
op_assign
id|p2
suffix:semicolon
id|qe-&gt;p2
op_assign
id|p3
suffix:semicolon
id|submit_qentry
(paren
id|dev
comma
id|q
comma
id|qe
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_EXTRA
id|pq
(braket
id|qp
)braket
dot
id|cmd
op_assign
id|cmd
suffix:semicolon
id|pq
(braket
id|qp
)braket
dot
id|p0
op_assign
id|p1
suffix:semicolon
id|pq
(braket
id|qp
)braket
dot
id|p1
op_assign
id|p2
suffix:semicolon
id|pq
(braket
id|qp
)braket
dot
id|p2
op_assign
id|p3
suffix:semicolon
id|qp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|qp
op_ge
l_int|60
)paren
id|qp
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Test the &quot;other&quot; way one day... -- REW */
macro_line|#if 1
DECL|macro|submit_command
mdefine_line|#define submit_command submit_queue
macro_line|#else
DECL|function|submit_command
r_static
r_void
id|submit_command
(paren
r_struct
id|fs_dev
op_star
id|dev
comma
r_struct
id|queue
op_star
id|q
comma
id|u32
id|cmd
comma
id|u32
id|p1
comma
id|u32
id|p2
comma
id|u32
id|p3
)paren
(brace
id|write_fs
(paren
id|dev
comma
id|CMDR0
comma
id|cmd
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|CMDR1
comma
id|p1
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|CMDR2
comma
id|p2
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|CMDR3
comma
id|p3
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|process_return_queue
r_static
r_void
id|process_return_queue
(paren
r_struct
id|fs_dev
op_star
id|dev
comma
r_struct
id|queue
op_star
id|q
)paren
(brace
r_int
id|rq
suffix:semicolon
r_struct
id|FS_QENTRY
op_star
id|qe
suffix:semicolon
r_void
op_star
id|tc
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|rq
op_assign
id|read_fs
(paren
id|dev
comma
id|Q_RP
c_func
(paren
id|q-&gt;offset
)paren
)paren
)paren
op_amp
id|Q_EMPTY
)paren
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_QUEUE
comma
l_string|&quot;reaping return queue entry at %lx&bslash;n&quot;
comma
id|rq
)paren
suffix:semicolon
id|qe
op_assign
id|bus_to_virt
(paren
id|rq
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_QUEUE
comma
l_string|&quot;queue entry: %08x %08x %08x %08x. (%d)&bslash;n&quot;
comma
id|qe-&gt;cmd
comma
id|qe-&gt;p0
comma
id|qe-&gt;p1
comma
id|qe-&gt;p2
comma
id|STATUS_CODE
(paren
id|qe
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|STATUS_CODE
(paren
id|qe
)paren
)paren
(brace
r_case
l_int|5
suffix:colon
id|tc
op_assign
id|bus_to_virt
(paren
id|qe-&gt;p0
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Free tc: %p&bslash;n&quot;
comma
id|tc
)paren
suffix:semicolon
id|kfree
(paren
id|tc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|write_fs
(paren
id|dev
comma
id|Q_RP
c_func
(paren
id|q-&gt;offset
)paren
comma
id|Q_INCWRAP
)paren
suffix:semicolon
)brace
)brace
DECL|function|process_txdone_queue
r_static
r_void
id|process_txdone_queue
(paren
r_struct
id|fs_dev
op_star
id|dev
comma
r_struct
id|queue
op_star
id|q
)paren
(brace
r_int
id|rq
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_struct
id|FS_QENTRY
op_star
id|qe
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|FS_BPENTRY
op_star
id|td
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|rq
op_assign
id|read_fs
(paren
id|dev
comma
id|Q_RP
c_func
(paren
id|q-&gt;offset
)paren
)paren
)paren
op_amp
id|Q_EMPTY
)paren
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_QUEUE
comma
l_string|&quot;reaping txdone entry at %lx&bslash;n&quot;
comma
id|rq
)paren
suffix:semicolon
id|qe
op_assign
id|bus_to_virt
(paren
id|rq
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_QUEUE
comma
l_string|&quot;queue entry: %08x %08x %08x %08x: %d&bslash;n&quot;
comma
id|qe-&gt;cmd
comma
id|qe-&gt;p0
comma
id|qe-&gt;p1
comma
id|qe-&gt;p2
comma
id|STATUS_CODE
(paren
id|qe
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|STATUS_CODE
(paren
id|qe
)paren
op_ne
l_int|2
)paren
id|fs_dprintk
(paren
id|FS_DEBUG_TXMEM
comma
l_string|&quot;queue entry: %08x %08x %08x %08x: %d&bslash;n&quot;
comma
id|qe-&gt;cmd
comma
id|qe-&gt;p0
comma
id|qe-&gt;p1
comma
id|qe-&gt;p2
comma
id|STATUS_CODE
(paren
id|qe
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|STATUS_CODE
(paren
id|qe
)paren
)paren
(brace
r_case
l_int|0x02
suffix:colon
multiline_comment|/* Process a real txdone entry. */
id|tmp
op_assign
id|qe-&gt;p0
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
l_int|0x0f
)paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;td not aligned: %ld&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
l_int|0x0f
suffix:semicolon
id|td
op_assign
id|bus_to_virt
(paren
id|tmp
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_QUEUE
comma
l_string|&quot;Pool entry: %08x %08x %08x %08x %p.&bslash;n&quot;
comma
id|td-&gt;flags
comma
id|td-&gt;next
comma
id|td-&gt;bsa
comma
id|td-&gt;aal_bufsize
comma
id|td-&gt;skb
)paren
suffix:semicolon
id|skb
op_assign
id|td-&gt;skb
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
id|FS_VCC
(paren
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc
)paren
op_member_access_from_pointer
id|last_skb
)paren
(brace
id|wake_up_interruptible
(paren
op_amp
id|FS_VCC
(paren
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc
)paren
op_member_access_from_pointer
id|close_wait
)paren
suffix:semicolon
id|FS_VCC
(paren
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc
)paren
op_member_access_from_pointer
id|last_skb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|td-&gt;dev-&gt;ntxpckts
op_decrement
suffix:semicolon
(brace
r_static
r_int
id|c
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|c
op_increment
op_mod
l_int|100
)paren
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_QSIZE
comma
l_string|&quot;[%d]&quot;
comma
id|td-&gt;dev-&gt;ntxpckts
)paren
suffix:semicolon
)brace
)brace
id|atomic_inc
c_func
(paren
op_amp
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc-&gt;stats-&gt;tx
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_TXMEM
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Free t-skb: %p&bslash;n&quot;
comma
id|skb
)paren
suffix:semicolon
id|fs_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Free trans-d: %p&bslash;n&quot;
comma
id|td
)paren
suffix:semicolon
id|memset
(paren
id|td
comma
l_int|0x12
comma
r_sizeof
(paren
r_struct
id|FS_BPENTRY
)paren
)paren
suffix:semicolon
id|kfree
(paren
id|td
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* Here we get the tx purge inhibit command ... */
multiline_comment|/* Action, I believe, is &quot;don&squot;t do anything&quot;. -- REW */
)brace
id|write_fs
(paren
id|dev
comma
id|Q_RP
c_func
(paren
id|q-&gt;offset
)paren
comma
id|Q_INCWRAP
)paren
suffix:semicolon
)brace
)brace
DECL|function|process_incoming
r_static
r_void
id|process_incoming
(paren
r_struct
id|fs_dev
op_star
id|dev
comma
r_struct
id|queue
op_star
id|q
)paren
(brace
r_int
id|rq
suffix:semicolon
r_struct
id|FS_QENTRY
op_star
id|qe
suffix:semicolon
r_struct
id|FS_BPENTRY
op_star
id|pe
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|channo
suffix:semicolon
r_struct
id|atm_vcc
op_star
id|atm_vcc
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|rq
op_assign
id|read_fs
(paren
id|dev
comma
id|Q_RP
c_func
(paren
id|q-&gt;offset
)paren
)paren
)paren
op_amp
id|Q_EMPTY
)paren
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_QUEUE
comma
l_string|&quot;reaping incoming queue entry at %lx&bslash;n&quot;
comma
id|rq
)paren
suffix:semicolon
id|qe
op_assign
id|bus_to_virt
(paren
id|rq
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_QUEUE
comma
l_string|&quot;queue entry: %08x %08x %08x %08x.  &quot;
comma
id|qe-&gt;cmd
comma
id|qe-&gt;p0
comma
id|qe-&gt;p1
comma
id|qe-&gt;p2
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_QUEUE
comma
l_string|&quot;-&gt; %x: %s&bslash;n&quot;
comma
id|STATUS_CODE
(paren
id|qe
)paren
comma
id|res_strings
(braket
id|STATUS_CODE
c_func
(paren
id|qe
)paren
)braket
)paren
suffix:semicolon
id|pe
op_assign
id|bus_to_virt
(paren
id|qe-&gt;p0
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_QUEUE
comma
l_string|&quot;Pool entry: %08x %08x %08x %08x %p %p.&bslash;n&quot;
comma
id|pe-&gt;flags
comma
id|pe-&gt;next
comma
id|pe-&gt;bsa
comma
id|pe-&gt;aal_bufsize
comma
id|pe-&gt;skb
comma
id|pe-&gt;fp
)paren
suffix:semicolon
id|channo
op_assign
id|qe-&gt;cmd
op_amp
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|channo
OL
id|dev-&gt;nchannels
)paren
id|atm_vcc
op_assign
id|dev-&gt;atm_vccs
(braket
id|channo
)braket
suffix:semicolon
r_else
id|atm_vcc
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Single buffer packet */
r_switch
c_cond
(paren
id|STATUS_CODE
(paren
id|qe
)paren
)paren
(brace
r_case
l_int|0x2
suffix:colon
multiline_comment|/* Packet received OK.... */
r_if
c_cond
(paren
id|atm_vcc
)paren
(brace
id|skb
op_assign
id|pe-&gt;skb
suffix:semicolon
id|pe-&gt;fp-&gt;n
op_decrement
suffix:semicolon
macro_line|#if 0
id|fs_dprintk
(paren
id|FS_DEBUG_QUEUE
comma
l_string|&quot;Got skb: %p&bslash;n&quot;
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FS_DEBUG_QUEUE
op_amp
id|fs_debug
)paren
id|my_hd
(paren
id|bus_to_virt
(paren
id|pe-&gt;bsa
)paren
comma
l_int|0x20
)paren
suffix:semicolon
macro_line|#endif
id|skb_put
(paren
id|skb
comma
id|qe-&gt;p1
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc
op_assign
id|atm_vcc
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|atm_vcc-&gt;stats-&gt;rx
)paren
suffix:semicolon
id|skb-&gt;stamp
op_assign
id|xtime
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Free rec-skb: %p (pushed)&bslash;n&quot;
comma
id|skb
)paren
suffix:semicolon
id|atm_vcc-&gt;push
(paren
id|atm_vcc
comma
id|skb
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Free rec-d: %p&bslash;n&quot;
comma
id|pe
)paren
suffix:semicolon
id|kfree
(paren
id|pe
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;Got a receive on a non-open channel %d.&bslash;n&quot;
comma
id|channo
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x17
suffix:colon
multiline_comment|/* AAL 5 CRC32 error. IFF the length field is nonzero, a buffer&n;&t;&t;&t;     has been consumed and needs to be processed. -- REW */
r_if
c_cond
(paren
id|qe-&gt;p1
op_amp
l_int|0xffff
)paren
(brace
id|pe
op_assign
id|bus_to_virt
(paren
id|qe-&gt;p0
)paren
suffix:semicolon
id|pe-&gt;fp-&gt;n
op_decrement
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Free rec-skb: %p&bslash;n&quot;
comma
id|pe-&gt;skb
)paren
suffix:semicolon
id|dev_kfree_skb_any
(paren
id|pe-&gt;skb
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Free rec-d: %p&bslash;n&quot;
comma
id|pe
)paren
suffix:semicolon
id|kfree
(paren
id|pe
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atm_vcc
)paren
id|atomic_inc
c_func
(paren
op_amp
id|atm_vcc-&gt;stats-&gt;rx_drop
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1f
suffix:colon
multiline_comment|/*  Reassembly abort: no buffers. */
multiline_comment|/* Silently increment error counter. */
r_if
c_cond
(paren
id|atm_vcc
)paren
id|atomic_inc
c_func
(paren
op_amp
id|atm_vcc-&gt;stats-&gt;rx_drop
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Hmm. Haven&squot;t written the code to handle the others yet... -- REW */
id|printk
(paren
id|KERN_WARNING
l_string|&quot;Don&squot;t know what to do with RX status %x: %s.&bslash;n&quot;
comma
id|STATUS_CODE
c_func
(paren
id|qe
)paren
comma
id|res_strings
(braket
id|STATUS_CODE
(paren
id|qe
)paren
)braket
)paren
suffix:semicolon
)brace
id|write_fs
(paren
id|dev
comma
id|Q_RP
c_func
(paren
id|q-&gt;offset
)paren
comma
id|Q_INCWRAP
)paren
suffix:semicolon
)brace
)brace
DECL|macro|DO_DIRECTION
mdefine_line|#define DO_DIRECTION(tp) ((tp)-&gt;traffic_class != ATM_NONE)
DECL|function|fs_open
r_static
r_int
id|fs_open
c_func
(paren
r_struct
id|atm_vcc
op_star
id|atm_vcc
comma
r_int
id|vpi
comma
r_int
id|vci
)paren
(brace
r_struct
id|fs_dev
op_star
id|dev
suffix:semicolon
r_struct
id|fs_vcc
op_star
id|vcc
suffix:semicolon
r_struct
id|fs_transmit_config
op_star
id|tc
suffix:semicolon
r_struct
id|atm_trafprm
op_star
id|txtp
suffix:semicolon
r_struct
id|atm_trafprm
op_star
id|rxtp
suffix:semicolon
multiline_comment|/*  struct fs_receive_config *rc;*/
multiline_comment|/*  struct FS_QENTRY *qe; */
r_int
id|error
suffix:semicolon
r_int
id|bfp
suffix:semicolon
r_int
id|to
suffix:semicolon
r_int
r_int
id|tmc0
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
id|dev
op_assign
id|FS_DEV
c_func
(paren
id|atm_vcc-&gt;dev
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_OPEN
comma
l_string|&quot;fs: open on dev: %p, vcc at %p&bslash;n&quot;
comma
id|dev
comma
id|atm_vcc
)paren
suffix:semicolon
id|error
op_assign
id|atm_find_ci
c_func
(paren
id|atm_vcc
comma
op_amp
id|vpi
comma
op_amp
id|vci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_OPEN
comma
l_string|&quot;fs: find_ci failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|atm_vcc-&gt;vpi
op_assign
id|vpi
suffix:semicolon
id|atm_vcc-&gt;vci
op_assign
id|vci
suffix:semicolon
r_if
c_cond
(paren
id|vci
op_ne
id|ATM_VPI_UNSPEC
op_logical_and
id|vpi
op_ne
id|ATM_VCI_UNSPEC
)paren
id|set_bit
c_func
(paren
id|ATM_VF_ADDR
comma
op_amp
id|atm_vcc-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atm_vcc-&gt;qos.aal
op_ne
id|ATM_AAL5
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* XXX AAL0 */
id|fs_dprintk
(paren
id|FS_DEBUG_OPEN
comma
l_string|&quot;fs: (itf %d): open %d.%d&bslash;n&quot;
comma
id|atm_vcc-&gt;dev-&gt;number
comma
id|atm_vcc-&gt;vpi
comma
id|atm_vcc-&gt;vci
)paren
suffix:semicolon
multiline_comment|/* XXX handle qos parameters (rate limiting) ? */
id|vcc
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|fs_vcc
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Alloc VCC: %p(%d)&bslash;n&quot;
comma
id|vcc
comma
r_sizeof
(paren
r_struct
id|fs_vcc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vcc
)paren
(brace
id|clear_bit
c_func
(paren
id|ATM_VF_ADDR
comma
op_amp
id|atm_vcc-&gt;flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|atm_vcc-&gt;dev_data
op_assign
id|vcc
suffix:semicolon
id|vcc-&gt;last_skb
op_assign
l_int|NULL
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|vcc-&gt;close_wait
)paren
suffix:semicolon
id|txtp
op_assign
op_amp
id|atm_vcc-&gt;qos.txtp
suffix:semicolon
id|rxtp
op_assign
op_amp
id|atm_vcc-&gt;qos.rxtp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|ATM_VF_PARTIAL
comma
op_amp
id|atm_vcc-&gt;flags
)paren
)paren
(brace
r_if
c_cond
(paren
id|IS_FS50
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/* Increment the channel numer: take a free one next time.  */
r_for
c_loop
(paren
id|to
op_assign
l_int|33
suffix:semicolon
id|to
suffix:semicolon
id|to
op_decrement
comma
id|dev-&gt;channo
op_increment
)paren
(brace
multiline_comment|/* If we need to do RX, AND the RX is inuse, try the next */
r_if
c_cond
(paren
id|DO_DIRECTION
c_func
(paren
id|rxtp
)paren
op_logical_and
id|dev-&gt;atm_vccs
(braket
id|dev-&gt;channo
)braket
)paren
r_continue
suffix:semicolon
multiline_comment|/* If we need to do TX, AND the TX is inuse, try the next */
r_if
c_cond
(paren
id|DO_DIRECTION
c_func
(paren
id|txtp
)paren
op_logical_and
id|test_bit
(paren
id|dev-&gt;channo
comma
id|dev-&gt;tx_inuse
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Ok, both are free! (or not needed) */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|to
)paren
(brace
id|printk
(paren
l_string|&quot;No more free channels for FS50..&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|vcc-&gt;channo
op_assign
id|dev-&gt;channo
suffix:semicolon
id|dev-&gt;channo
op_and_assign
id|dev-&gt;channel_mask
suffix:semicolon
)brace
r_else
(brace
id|vcc-&gt;channo
op_assign
(paren
id|vpi
op_lshift
id|FS155_VCI_BITS
)paren
op_or
(paren
id|vci
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|DO_DIRECTION
c_func
(paren
id|rxtp
)paren
op_logical_and
id|dev-&gt;atm_vccs
(braket
id|vcc-&gt;channo
)braket
)paren
)paren
op_logical_or
(paren
id|DO_DIRECTION
c_func
(paren
id|txtp
)paren
op_logical_and
id|test_bit
(paren
id|vcc-&gt;channo
comma
id|dev-&gt;tx_inuse
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;Channel is in use for FS155.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
id|fs_dprintk
(paren
id|FS_DEBUG_OPEN
comma
l_string|&quot;OK. Allocated channel %x(%d).&bslash;n&quot;
comma
id|vcc-&gt;channo
comma
id|vcc-&gt;channo
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DO_DIRECTION
(paren
id|txtp
)paren
)paren
(brace
id|tc
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|fs_transmit_config
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Alloc tc: %p(%d)&bslash;n&quot;
comma
id|tc
comma
r_sizeof
(paren
r_struct
id|fs_transmit_config
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tc
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_OPEN
comma
l_string|&quot;fs: can&squot;t alloc transmit_config.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Allocate the &quot;open&quot; entry from the high priority txq. This makes&n;&t;&t;   it most likely that the chip will notice it. It also prevents us&n;&t;&t;   from having to wait for completion. On the other hand, we may&n;&t;&t;   need to wait for completion anyway, to see if it completed&n;&t;&t;   succesfully. */
id|tc-&gt;flags
op_assign
l_int|0
op_or
id|TC_FLAGS_AAL5
op_or
id|TC_FLAGS_PACKET
multiline_comment|/* ??? */
op_or
id|TC_FLAGS_TYPE_CBR
op_or
id|TC_FLAGS_CAL0
suffix:semicolon
multiline_comment|/* Docs are vague about this atm_hdr field. By the way, the FS&n;&t;&t; * chip makes odd errors if lower bits are set.... -- REW */
id|tc-&gt;atm_hdr
op_assign
(paren
id|vpi
op_lshift
l_int|20
)paren
op_or
(paren
id|vci
op_lshift
l_int|4
)paren
suffix:semicolon
(brace
r_int
id|pcr
op_assign
id|atm_pcr_goal
(paren
id|txtp
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_OPEN
comma
l_string|&quot;pcr = %d.&bslash;n&quot;
comma
id|pcr
)paren
suffix:semicolon
multiline_comment|/* XXX Hmm. officially we&squot;re only allowed to do this if rounding &n;&t;&t;&t;   is round_down -- REW */
r_if
c_cond
(paren
id|IS_FS50
c_func
(paren
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|pcr
OG
l_int|51840000
op_div
l_int|53
op_div
l_int|8
)paren
id|pcr
op_assign
l_int|51840000
op_div
l_int|53
op_div
l_int|8
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|pcr
OG
l_int|155520000
op_div
l_int|53
op_div
l_int|8
)paren
id|pcr
op_assign
l_int|155520000
op_div
l_int|53
op_div
l_int|8
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pcr
)paren
(brace
multiline_comment|/* no rate cap */
id|tmc0
op_assign
id|IS_FS50
c_func
(paren
id|dev
)paren
ques
c_cond
l_int|0x61BE
suffix:colon
l_int|0x64c9
suffix:semicolon
multiline_comment|/* Just copied over the bits from Fujitsu -- REW */
)brace
r_else
(brace
r_int
id|r
suffix:semicolon
r_if
c_cond
(paren
id|pcr
OL
l_int|0
)paren
(brace
id|r
op_assign
id|ROUND_DOWN
suffix:semicolon
id|pcr
op_assign
op_minus
id|pcr
suffix:semicolon
)brace
r_else
(brace
id|r
op_assign
id|ROUND_UP
suffix:semicolon
)brace
id|error
op_assign
id|make_rate
(paren
id|pcr
comma
id|r
comma
op_amp
id|tmc0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|fs_dprintk
(paren
id|FS_DEBUG_OPEN
comma
l_string|&quot;pcr = %d.&bslash;n&quot;
comma
id|pcr
)paren
suffix:semicolon
)brace
id|tc-&gt;TMC
(braket
l_int|0
)braket
op_assign
id|tmc0
op_or
l_int|0x4000
suffix:semicolon
id|tc-&gt;TMC
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Unused */
id|tc-&gt;TMC
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Unused */
id|tc-&gt;TMC
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Unused */
id|tc-&gt;spec
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* UTOPIA address, UDF, HEC: Unused -&gt; 0 */
id|tc-&gt;rtag
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* What should I do with routing tags??? &n;&t;&t;&t;&t;    -- Not used -- AS -- Thanks -- REW*/
id|tc-&gt;rtag
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|tc-&gt;rtag
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fs_debug
op_amp
id|FS_DEBUG_OPEN
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_OPEN
comma
l_string|&quot;TX config record:&bslash;n&quot;
)paren
suffix:semicolon
id|my_hd
(paren
id|tc
comma
r_sizeof
(paren
op_star
id|tc
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* We now use the &quot;submit_command&quot; function to submit commands to&n;&t;&t;   the firestream. There is a define up near the definition of&n;&t;&t;   that routine that switches this routine between immediate write&n;&t;&t;   to the immediate comamnd registers and queuing the commands in&n;&t;&t;   the HPTXQ for execution. This last technique might be more&n;&t;&t;   efficient if we know we&squot;re going to submit a whole lot of&n;&t;&t;   commands in one go, but this driver is not setup to be able to&n;&t;&t;   use such a construct. So it probably doen&squot;t matter much right&n;&t;&t;   now. -- REW */
multiline_comment|/* The command is IMMediate and INQueue. The parameters are out-of-line.. */
id|submit_command
(paren
id|dev
comma
op_amp
id|dev-&gt;hp_txq
comma
id|QE_CMD_CONFIG_TX
op_or
id|QE_CMD_IMM_INQ
op_or
id|vcc-&gt;channo
comma
id|virt_to_bus
(paren
id|tc
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|submit_command
(paren
id|dev
comma
op_amp
id|dev-&gt;hp_txq
comma
id|QE_CMD_TX_EN
op_or
id|QE_CMD_IMM_INQ
op_or
id|vcc-&gt;channo
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|set_bit
(paren
id|vcc-&gt;channo
comma
id|dev-&gt;tx_inuse
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DO_DIRECTION
(paren
id|rxtp
)paren
)paren
(brace
id|dev-&gt;atm_vccs
(braket
id|vcc-&gt;channo
)braket
op_assign
id|atm_vcc
suffix:semicolon
r_for
c_loop
(paren
id|bfp
op_assign
l_int|0
suffix:semicolon
id|bfp
OL
id|FS_NR_FREE_POOLS
suffix:semicolon
id|bfp
op_increment
)paren
r_if
c_cond
(paren
id|atm_vcc-&gt;qos.rxtp.max_sdu
op_le
id|dev-&gt;rx_fp
(braket
id|bfp
)braket
dot
id|bufsize
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|bfp
op_ge
id|FS_NR_FREE_POOLS
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_OPEN
comma
l_string|&quot;No free pool fits sdu: %d.&bslash;n&quot;
comma
id|atm_vcc-&gt;qos.rxtp.max_sdu
)paren
suffix:semicolon
multiline_comment|/* XXX Cleanup? -- Would just calling fs_close work??? -- REW */
multiline_comment|/* XXX clear tx inuse. Close TX part? */
id|dev-&gt;atm_vccs
(braket
id|vcc-&gt;channo
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
(paren
id|vcc
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|submit_command
(paren
id|dev
comma
op_amp
id|dev-&gt;hp_txq
comma
id|QE_CMD_CONFIG_RX
op_or
id|QE_CMD_IMM_INQ
op_or
id|vcc-&gt;channo
comma
id|RC_FLAGS_AAL5
op_or
id|RC_FLAGS_BFPS_BFP
op_star
id|bfp
op_or
id|RC_FLAGS_RXBM_PSB
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_FS50
(paren
id|dev
)paren
)paren
(brace
id|submit_command
(paren
id|dev
comma
op_amp
id|dev-&gt;hp_txq
comma
id|QE_CMD_REG_WR
op_or
id|QE_CMD_IMM_INQ
comma
l_int|0x80
op_plus
id|vcc-&gt;channo
comma
(paren
id|vpi
op_lshift
l_int|16
)paren
op_or
id|vci
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* XXX -- Use defines. */
)brace
id|submit_command
(paren
id|dev
comma
op_amp
id|dev-&gt;hp_txq
comma
id|QE_CMD_RX_EN
op_or
id|QE_CMD_IMM_INQ
op_or
id|vcc-&gt;channo
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Indicate we&squot;re done! */
id|set_bit
c_func
(paren
id|ATM_VF_READY
comma
op_amp
id|atm_vcc-&gt;flags
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fs_close
r_static
r_void
id|fs_close
c_func
(paren
r_struct
id|atm_vcc
op_star
id|atm_vcc
)paren
(brace
r_struct
id|fs_dev
op_star
id|dev
op_assign
id|FS_DEV
(paren
id|atm_vcc-&gt;dev
)paren
suffix:semicolon
r_struct
id|fs_vcc
op_star
id|vcc
op_assign
id|FS_VCC
(paren
id|atm_vcc
)paren
suffix:semicolon
r_struct
id|atm_trafprm
op_star
id|txtp
suffix:semicolon
r_struct
id|atm_trafprm
op_star
id|rxtp
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|ATM_VF_READY
comma
op_amp
id|atm_vcc-&gt;flags
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_QSIZE
comma
l_string|&quot;--==**[%d]**==--&quot;
comma
id|dev-&gt;ntxpckts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vcc-&gt;last_skb
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_QUEUE
comma
l_string|&quot;Waiting for skb %p to be sent.&bslash;n&quot;
comma
id|vcc-&gt;last_skb
)paren
suffix:semicolon
multiline_comment|/* We&squot;re going to wait for the last packet to get sent on this VC. It would&n;&t;&t;   be impolite not to send them don&squot;t you think? &n;&t;&t;   XXX&n;&t;&t;   We don&squot;t know which packets didn&squot;t get sent. So if we get interrupted in &n;&t;&t;   this sleep_on, we&squot;ll lose any reference to these packets. Memory leak!&n;&t;&t;   On the other hand, it&squot;s awfully convenient that we can abort a &quot;close&quot; that&n;&t;&t;   is taking too long. Maybe just use non-interruptible sleep on? -- REW */
id|interruptible_sleep_on
(paren
op_amp
id|vcc-&gt;close_wait
)paren
suffix:semicolon
)brace
id|txtp
op_assign
op_amp
id|atm_vcc-&gt;qos.txtp
suffix:semicolon
id|rxtp
op_assign
op_amp
id|atm_vcc-&gt;qos.rxtp
suffix:semicolon
multiline_comment|/* See App note XXX (Unpublished as of now) for the reason for the &n;&t;   removal of the &quot;CMD_IMM_INQ&quot; part of the TX_PURGE_INH... -- REW */
r_if
c_cond
(paren
id|DO_DIRECTION
(paren
id|txtp
)paren
)paren
(brace
id|submit_command
(paren
id|dev
comma
op_amp
id|dev-&gt;hp_txq
comma
id|QE_CMD_TX_PURGE_INH
op_or
multiline_comment|/*QE_CMD_IMM_INQ|*/
id|vcc-&gt;channo
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|clear_bit
(paren
id|vcc-&gt;channo
comma
id|dev-&gt;tx_inuse
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DO_DIRECTION
(paren
id|rxtp
)paren
)paren
(brace
id|submit_command
(paren
id|dev
comma
op_amp
id|dev-&gt;hp_txq
comma
id|QE_CMD_RX_PURGE_INH
op_or
id|QE_CMD_IMM_INQ
op_or
id|vcc-&gt;channo
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|dev-&gt;atm_vccs
(braket
id|vcc-&gt;channo
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* This means that this is configured as a receive channel */
r_if
c_cond
(paren
id|IS_FS50
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/* Disable the receive filter. Is 0/0 indeed an invalid receive&n;&t;&t;&t;   channel? -- REW.  Yes it is. -- Hang. Ok. I&squot;ll use -1&n;&t;&t;&t;   (0xfff...) -- REW */
id|submit_command
(paren
id|dev
comma
op_amp
id|dev-&gt;hp_txq
comma
id|QE_CMD_REG_WR
op_or
id|QE_CMD_IMM_INQ
comma
l_int|0x80
op_plus
id|vcc-&gt;channo
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Free vcc: %p&bslash;n&quot;
comma
id|vcc
)paren
suffix:semicolon
id|kfree
(paren
id|vcc
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
DECL|function|fs_send
r_static
r_int
id|fs_send
(paren
r_struct
id|atm_vcc
op_star
id|atm_vcc
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|fs_dev
op_star
id|dev
op_assign
id|FS_DEV
(paren
id|atm_vcc-&gt;dev
)paren
suffix:semicolon
r_struct
id|fs_vcc
op_star
id|vcc
op_assign
id|FS_VCC
(paren
id|atm_vcc
)paren
suffix:semicolon
r_struct
id|FS_BPENTRY
op_star
id|td
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_TXMEM
comma
l_string|&quot;I&quot;
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_SEND
comma
l_string|&quot;Send: atm_vcc %p skb %p vcc %p dev %p&bslash;n&quot;
comma
id|atm_vcc
comma
id|skb
comma
id|vcc
comma
id|dev
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Alloc t-skb: %p (atm_send)&bslash;n&quot;
comma
id|skb
)paren
suffix:semicolon
id|ATM_SKB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|vcc
op_assign
id|atm_vcc
suffix:semicolon
id|vcc-&gt;last_skb
op_assign
id|skb
suffix:semicolon
id|td
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|FS_BPENTRY
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Alloc transd: %p(%d)&bslash;n&quot;
comma
id|td
comma
r_sizeof
(paren
r_struct
id|FS_BPENTRY
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
(brace
multiline_comment|/* Oops out of mem */
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|fs_dprintk
(paren
id|FS_DEBUG_SEND
comma
l_string|&quot;first word in buffer: %x&bslash;n&quot;
comma
op_star
(paren
r_int
op_star
)paren
id|skb-&gt;data
)paren
suffix:semicolon
id|td-&gt;flags
op_assign
id|TD_EPI
op_or
id|TD_DATA
op_or
id|skb-&gt;len
suffix:semicolon
id|td-&gt;next
op_assign
l_int|0
suffix:semicolon
id|td-&gt;bsa
op_assign
id|virt_to_bus
(paren
id|skb-&gt;data
)paren
suffix:semicolon
id|td-&gt;skb
op_assign
id|skb
suffix:semicolon
id|td-&gt;dev
op_assign
id|dev
suffix:semicolon
id|dev-&gt;ntxpckts
op_increment
suffix:semicolon
macro_line|#ifdef DEBUG_EXTRA
id|da
(braket
id|qd
)braket
op_assign
id|td
suffix:semicolon
id|dq
(braket
id|qd
)braket
dot
id|flags
op_assign
id|td-&gt;flags
suffix:semicolon
id|dq
(braket
id|qd
)braket
dot
id|next
op_assign
id|td-&gt;next
suffix:semicolon
id|dq
(braket
id|qd
)braket
dot
id|bsa
op_assign
id|td-&gt;bsa
suffix:semicolon
id|dq
(braket
id|qd
)braket
dot
id|skb
op_assign
id|td-&gt;skb
suffix:semicolon
id|dq
(braket
id|qd
)braket
dot
id|dev
op_assign
id|td-&gt;dev
suffix:semicolon
id|qd
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|qd
op_ge
l_int|60
)paren
id|qd
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|submit_queue
(paren
id|dev
comma
op_amp
id|dev-&gt;hp_txq
comma
id|QE_TRANSMIT_DE
op_or
id|vcc-&gt;channo
comma
id|virt_to_bus
(paren
id|td
)paren
comma
l_int|0
comma
id|virt_to_bus
(paren
id|td
)paren
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_QUEUE
comma
l_string|&quot;in send: txq %d txrq %d&bslash;n&quot;
comma
id|read_fs
(paren
id|dev
comma
id|Q_EA
(paren
id|dev-&gt;hp_txq.offset
)paren
)paren
op_minus
id|read_fs
(paren
id|dev
comma
id|Q_SA
(paren
id|dev-&gt;hp_txq.offset
)paren
)paren
comma
id|read_fs
(paren
id|dev
comma
id|Q_EA
(paren
id|dev-&gt;tx_relq.offset
)paren
)paren
op_minus
id|read_fs
(paren
id|dev
comma
id|Q_SA
(paren
id|dev-&gt;tx_relq.offset
)paren
)paren
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Some function placeholders for functions we don&squot;t yet support. */
macro_line|#if 0
r_static
r_int
id|fs_ioctl
c_func
(paren
r_struct
id|atm_dev
op_star
id|dev
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|fs_getsockopt
c_func
(paren
r_struct
id|atm_vcc
op_star
id|vcc
comma
r_int
id|level
comma
r_int
id|optname
comma
r_void
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|fs_setsockopt
c_func
(paren
r_struct
id|atm_vcc
op_star
id|vcc
comma
r_int
id|level
comma
r_int
id|optname
comma
r_void
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
id|fs_phy_put
c_func
(paren
r_struct
id|atm_dev
op_star
id|dev
comma
r_int
r_char
id|value
comma
r_int
r_int
id|addr
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
r_static
r_int
r_char
id|fs_phy_get
c_func
(paren
r_struct
id|atm_dev
op_star
id|dev
comma
r_int
r_int
id|addr
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
id|fs_feedback
c_func
(paren
r_struct
id|atm_vcc
op_star
id|vcc
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|start
comma
r_int
r_int
id|dest
comma
r_int
id|len
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
r_static
r_int
id|fs_change_qos
c_func
(paren
r_struct
id|atm_vcc
op_star
id|vcc
comma
r_struct
id|atm_qos
op_star
id|qos
comma
r_int
id|flags
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
DECL|variable|ops
r_static
r_const
r_struct
id|atmdev_ops
id|ops
op_assign
(brace
id|open
suffix:colon
id|fs_open
comma
id|close
suffix:colon
id|fs_close
comma
id|send
suffix:colon
id|fs_send
comma
macro_line|#if 0
id|owner
suffix:colon
id|THIS_MODULE
comma
macro_line|#endif
multiline_comment|/*                 fs_sg_send */
multiline_comment|/* ioctl:          fs_ioctl, */
multiline_comment|/* getsockopt:     fs_getsockopt, */
multiline_comment|/* setsockopt:     fs_setsockopt, */
multiline_comment|/* feedback:       fs_feedback, */
multiline_comment|/* change_qos:     fs_change_qos, */
multiline_comment|/* For now implement these internally here... */
multiline_comment|/* phy_put:        fs_phy_put, */
multiline_comment|/* phy_get:        fs_phy_get, */
)brace
suffix:semicolon
DECL|function|undocumented_pci_fix
r_static
r_void
id|__init
id|undocumented_pci_fix
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_int
id|tint
suffix:semicolon
multiline_comment|/* The Windows driver says: */
multiline_comment|/* Switch off FireStream Retry Limit Threshold &n;&t; */
multiline_comment|/* The register at 0x28 is documented as &quot;reserved&quot;, no further&n;&t;   comments. */
id|pci_read_config_dword
(paren
id|pdev
comma
l_int|0x28
comma
op_amp
id|tint
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tint
op_ne
l_int|0x80
)paren
(brace
id|tint
op_assign
l_int|0x80
suffix:semicolon
id|pci_write_config_dword
(paren
id|pdev
comma
l_int|0x28
comma
id|tint
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**************************************************************************&n; *                              PHY routines                              *&n; **************************************************************************/
DECL|function|write_phy
r_static
r_void
id|__init
id|write_phy
(paren
r_struct
id|fs_dev
op_star
id|dev
comma
r_int
id|regnum
comma
r_int
id|val
)paren
(brace
id|submit_command
(paren
id|dev
comma
op_amp
id|dev-&gt;hp_txq
comma
id|QE_CMD_PRP_WR
op_or
id|QE_CMD_IMM_INQ
comma
id|regnum
comma
id|val
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|init_phy
r_static
r_int
id|__init
id|init_phy
(paren
r_struct
id|fs_dev
op_star
id|dev
comma
r_struct
id|reginit_item
op_star
id|reginit
)paren
(brace
r_int
id|i
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|reginit-&gt;reg
op_ne
id|PHY_EOF
)paren
(brace
r_if
c_cond
(paren
id|reginit-&gt;reg
op_eq
id|PHY_CLEARALL
)paren
(brace
multiline_comment|/* &quot;PHY_CLEARALL means clear all registers. Numregisters is in &quot;val&quot;. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|reginit-&gt;val
suffix:semicolon
id|i
op_increment
)paren
(brace
id|write_phy
(paren
id|dev
comma
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|write_phy
(paren
id|dev
comma
id|reginit-&gt;reg
comma
id|reginit-&gt;val
)paren
suffix:semicolon
)brace
id|reginit
op_increment
suffix:semicolon
)brace
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|reset_chip
r_static
r_void
id|reset_chip
(paren
r_struct
id|fs_dev
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|SARMODE0
comma
id|SARMODE0_SRTS0
)paren
suffix:semicolon
multiline_comment|/* Undocumented delay */
id|udelay
(paren
l_int|128
)paren
suffix:semicolon
multiline_comment|/* The &quot;internal registers are documented to all reset to zero, but &n;&t;   comments &amp; code in the Windows driver indicates that the pools are&n;&t;   NOT reset. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FS_NR_FREE_POOLS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|write_fs
(paren
id|dev
comma
id|FP_CNF
(paren
id|RXB_FP
c_func
(paren
id|i
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|FP_SA
(paren
id|RXB_FP
c_func
(paren
id|i
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|FP_EA
(paren
id|RXB_FP
c_func
(paren
id|i
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|FP_CNT
(paren
id|RXB_FP
c_func
(paren
id|i
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|FP_CTU
(paren
id|RXB_FP
c_func
(paren
id|i
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* The same goes for the match channel registers, although those are&n;&t;   NOT documented that way in the Windows driver. -- REW */
multiline_comment|/* The Windows driver DOES write 0 to these registers somewhere in&n;&t;   the init sequence. However, a small hardware-feature, will&n;&t;   prevent reception of data on VPI/VCI = 0/0 (Unless the channel&n;&t;   allocated happens to have no disabled channels that have a lower&n;&t;   number. -- REW */
multiline_comment|/* Clear the match channel registers. */
r_if
c_cond
(paren
id|IS_FS50
(paren
id|dev
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FS50_NR_CHANNELS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|write_fs
(paren
id|dev
comma
l_int|0x200
op_plus
id|i
op_star
l_int|4
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|aligned_kmalloc
r_static
r_void
id|__init
op_star
id|aligned_kmalloc
(paren
r_int
id|size
comma
r_int
id|flags
comma
r_int
id|alignment
)paren
(brace
r_void
op_star
id|t
suffix:semicolon
r_if
c_cond
(paren
id|alignment
op_le
l_int|0x10
)paren
(brace
id|t
op_assign
id|kmalloc
(paren
id|size
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|t
op_amp
(paren
id|alignment
op_minus
l_int|1
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;Kmalloc doesn&squot;t align things correctly! %p&bslash;n&quot;
comma
id|t
)paren
suffix:semicolon
id|kfree
(paren
id|t
)paren
suffix:semicolon
r_return
id|aligned_kmalloc
(paren
id|size
comma
id|flags
comma
id|alignment
op_star
l_int|4
)paren
suffix:semicolon
)brace
r_return
id|t
suffix:semicolon
)brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;Request for &gt; 0x10 alignment not yet implemented (hard!)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|init_q
r_static
r_int
id|__init
id|init_q
(paren
r_struct
id|fs_dev
op_star
id|dev
comma
r_struct
id|queue
op_star
id|txq
comma
r_int
id|queue
comma
r_int
id|nentries
comma
r_int
id|is_rq
)paren
(brace
r_int
id|sz
op_assign
id|nentries
op_star
r_sizeof
(paren
r_struct
id|FS_QENTRY
)paren
suffix:semicolon
r_struct
id|FS_QENTRY
op_star
id|p
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_INIT
comma
l_string|&quot;Inititing queue at %x: %d entries:&bslash;n&quot;
comma
id|queue
comma
id|nentries
)paren
suffix:semicolon
id|p
op_assign
id|aligned_kmalloc
(paren
id|sz
comma
id|GFP_KERNEL
comma
l_int|0x10
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Alloc queue: %p(%d)&bslash;n&quot;
comma
id|p
comma
id|sz
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
l_int|0
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|Q_SA
c_func
(paren
id|queue
)paren
comma
id|virt_to_bus
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|Q_EA
c_func
(paren
id|queue
)paren
comma
id|virt_to_bus
c_func
(paren
id|p
op_plus
id|nentries
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|Q_WP
c_func
(paren
id|queue
)paren
comma
id|virt_to_bus
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|Q_RP
c_func
(paren
id|queue
)paren
comma
id|virt_to_bus
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_rq
)paren
(brace
multiline_comment|/* Configuration for the receive queue: 0: interrupt immediately,&n;&t;&t;   no pre-warning to empty queues: We do our best to keep the&n;&t;&t;   queue filled anyway. */
id|write_fs
(paren
id|dev
comma
id|Q_CNF
c_func
(paren
id|queue
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
id|txq-&gt;sa
op_assign
id|p
suffix:semicolon
id|txq-&gt;ea
op_assign
id|p
suffix:semicolon
id|txq-&gt;offset
op_assign
id|queue
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|init_fp
r_static
r_int
id|__init
id|init_fp
(paren
r_struct
id|fs_dev
op_star
id|dev
comma
r_struct
id|freepool
op_star
id|fp
comma
r_int
id|queue
comma
r_int
id|bufsize
comma
r_int
id|nr_buffers
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_INIT
comma
l_string|&quot;Inititing free pool at %x:&bslash;n&quot;
comma
id|queue
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|FP_CNF
c_func
(paren
id|queue
)paren
comma
(paren
id|bufsize
op_star
id|RBFP_RBS
)paren
op_or
id|RBFP_RBSVAL
op_or
id|RBFP_CME
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|FP_SA
c_func
(paren
id|queue
)paren
comma
l_int|0
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|FP_EA
c_func
(paren
id|queue
)paren
comma
l_int|0
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|FP_CTU
c_func
(paren
id|queue
)paren
comma
l_int|0
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|FP_CNT
c_func
(paren
id|queue
)paren
comma
l_int|0
)paren
suffix:semicolon
id|fp-&gt;offset
op_assign
id|queue
suffix:semicolon
id|fp-&gt;bufsize
op_assign
id|bufsize
suffix:semicolon
id|fp-&gt;nr_buffers
op_assign
id|nr_buffers
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|nr_buffers_in_freepool
r_static
r_inline
r_int
id|nr_buffers_in_freepool
(paren
r_struct
id|fs_dev
op_star
id|dev
comma
r_struct
id|freepool
op_star
id|fp
)paren
(brace
macro_line|#if 0
multiline_comment|/* This seems to be unreliable.... */
r_return
id|read_fs
(paren
id|dev
comma
id|FP_CNT
(paren
id|fp-&gt;offset
)paren
)paren
suffix:semicolon
macro_line|#else
r_return
id|fp-&gt;n
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Check if this gets going again if a pool ever runs out.  -- Yes, it&n;   does. I&squot;ve seen &quot;recieve abort: no buffers&quot; and things started&n;   working again after that...  -- REW */
DECL|function|top_off_fp
r_static
r_void
id|top_off_fp
(paren
r_struct
id|fs_dev
op_star
id|dev
comma
r_struct
id|freepool
op_star
id|fp
comma
r_int
id|gfp_flags
)paren
(brace
r_struct
id|FS_BPENTRY
op_star
id|qe
comma
op_star
id|ne
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|n
op_assign
l_int|0
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_QUEUE
comma
l_string|&quot;Topping off queue at %x (%d-%d/%d)&bslash;n&quot;
comma
id|fp-&gt;offset
comma
id|read_fs
(paren
id|dev
comma
id|FP_CNT
(paren
id|fp-&gt;offset
)paren
)paren
comma
id|fp-&gt;n
comma
id|fp-&gt;nr_buffers
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nr_buffers_in_freepool
c_func
(paren
id|dev
comma
id|fp
)paren
OL
id|fp-&gt;nr_buffers
)paren
(brace
id|skb
op_assign
id|alloc_skb
(paren
id|fp-&gt;bufsize
comma
id|gfp_flags
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Alloc rec-skb: %p(%d)&bslash;n&quot;
comma
id|skb
comma
id|fp-&gt;bufsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_break
suffix:semicolon
id|ne
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|FS_BPENTRY
)paren
comma
id|gfp_flags
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Alloc rec-d: %p(%d)&bslash;n&quot;
comma
id|ne
comma
r_sizeof
(paren
r_struct
id|FS_BPENTRY
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ne
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Free rec-skb: %p&bslash;n&quot;
comma
id|skb
)paren
suffix:semicolon
id|dev_kfree_skb_any
(paren
id|skb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|fs_dprintk
(paren
id|FS_DEBUG_QUEUE
comma
l_string|&quot;Adding skb %p desc %p -&gt; %p(%p) &quot;
comma
id|skb
comma
id|ne
comma
id|skb-&gt;data
comma
id|skb-&gt;head
)paren
suffix:semicolon
id|n
op_increment
suffix:semicolon
id|ne-&gt;flags
op_assign
id|FP_FLAGS_EPI
op_or
id|fp-&gt;bufsize
suffix:semicolon
id|ne-&gt;next
op_assign
id|virt_to_bus
(paren
l_int|NULL
)paren
suffix:semicolon
id|ne-&gt;bsa
op_assign
id|virt_to_bus
(paren
id|skb-&gt;data
)paren
suffix:semicolon
id|ne-&gt;aal_bufsize
op_assign
id|fp-&gt;bufsize
suffix:semicolon
id|ne-&gt;skb
op_assign
id|skb
suffix:semicolon
id|ne-&gt;fp
op_assign
id|fp
suffix:semicolon
id|qe
op_assign
(paren
r_struct
id|FS_BPENTRY
op_star
)paren
(paren
id|read_fs
(paren
id|dev
comma
id|FP_EA
c_func
(paren
id|fp-&gt;offset
)paren
)paren
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_QUEUE
comma
l_string|&quot;link at %p&bslash;n&quot;
comma
id|qe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qe
)paren
(brace
id|qe
op_assign
id|bus_to_virt
(paren
(paren
r_int
)paren
id|qe
)paren
suffix:semicolon
id|qe-&gt;next
op_assign
id|virt_to_bus
c_func
(paren
id|ne
)paren
suffix:semicolon
id|qe-&gt;flags
op_and_assign
op_complement
id|FP_FLAGS_EPI
suffix:semicolon
)brace
r_else
id|write_fs
(paren
id|dev
comma
id|FP_SA
c_func
(paren
id|fp-&gt;offset
)paren
comma
id|virt_to_bus
c_func
(paren
id|ne
)paren
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|FP_EA
c_func
(paren
id|fp-&gt;offset
)paren
comma
id|virt_to_bus
(paren
id|ne
)paren
)paren
suffix:semicolon
id|fp-&gt;n
op_increment
suffix:semicolon
multiline_comment|/* XXX Atomic_inc? */
id|write_fs
(paren
id|dev
comma
id|FP_CTU
c_func
(paren
id|fp-&gt;offset
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
id|fs_dprintk
(paren
id|FS_DEBUG_QUEUE
comma
l_string|&quot;Added %d entries. &bslash;n&quot;
comma
id|n
)paren
suffix:semicolon
)brace
DECL|function|free_queue
r_static
r_void
id|__exit
id|free_queue
(paren
r_struct
id|fs_dev
op_star
id|dev
comma
r_struct
id|queue
op_star
id|txq
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|Q_SA
c_func
(paren
id|txq-&gt;offset
)paren
comma
l_int|0
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|Q_EA
c_func
(paren
id|txq-&gt;offset
)paren
comma
l_int|0
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|Q_RP
c_func
(paren
id|txq-&gt;offset
)paren
comma
l_int|0
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|Q_WP
c_func
(paren
id|txq-&gt;offset
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Configuration ? */
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Free queue: %p&bslash;n&quot;
comma
id|txq-&gt;sa
)paren
suffix:semicolon
id|kfree
(paren
id|txq-&gt;sa
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
DECL|function|free_freepool
r_static
r_void
id|__exit
id|free_freepool
(paren
r_struct
id|fs_dev
op_star
id|dev
comma
r_struct
id|freepool
op_star
id|fp
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|FP_CNF
c_func
(paren
id|fp-&gt;offset
)paren
comma
l_int|0
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|FP_SA
(paren
id|fp-&gt;offset
)paren
comma
l_int|0
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|FP_EA
(paren
id|fp-&gt;offset
)paren
comma
l_int|0
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|FP_CNT
c_func
(paren
id|fp-&gt;offset
)paren
comma
l_int|0
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|FP_CTU
c_func
(paren
id|fp-&gt;offset
)paren
comma
l_int|0
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
DECL|function|fs_irq
r_static
r_void
id|fs_irq
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|pt_regs
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
id|status
suffix:semicolon
r_struct
id|fs_dev
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
id|status
op_assign
id|read_fs
(paren
id|dev
comma
id|ISR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
r_return
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
macro_line|#ifdef IRQ_RATE_LIMIT
multiline_comment|/* Aaargh! I&squot;m ashamed. This costs more lines-of-code than the actual &n;&t;   interrupt routine!. (Well, used to when I wrote that comment) -- REW */
(brace
r_static
r_int
id|lastjif
suffix:semicolon
r_static
r_int
id|nintr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lastjif
op_eq
id|jiffies
)paren
(brace
r_if
c_cond
(paren
op_increment
id|nintr
OG
id|IRQ_RATE_LIMIT
)paren
(brace
id|free_irq
(paren
id|dev-&gt;irq
comma
id|dev_id
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;fs: Too many interrupts. Turning off interrupt %d.&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|lastjif
op_assign
id|jiffies
suffix:semicolon
id|nintr
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
id|fs_dprintk
(paren
id|FS_DEBUG_QUEUE
comma
l_string|&quot;in intr: txq %d txrq %d&bslash;n&quot;
comma
id|read_fs
(paren
id|dev
comma
id|Q_EA
(paren
id|dev-&gt;hp_txq.offset
)paren
)paren
op_minus
id|read_fs
(paren
id|dev
comma
id|Q_SA
(paren
id|dev-&gt;hp_txq.offset
)paren
)paren
comma
id|read_fs
(paren
id|dev
comma
id|Q_EA
(paren
id|dev-&gt;tx_relq.offset
)paren
)paren
op_minus
id|read_fs
(paren
id|dev
comma
id|Q_SA
(paren
id|dev-&gt;tx_relq.offset
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* print the bits in the ISR register. */
r_if
c_cond
(paren
id|fs_debug
op_amp
id|FS_DEBUG_IRQ
)paren
(brace
multiline_comment|/* The FS_DEBUG things are unneccesary here. But this way it is&n;&t;&t;   clear for grep that these are debug prints. */
id|fs_dprintk
(paren
id|FS_DEBUG_IRQ
comma
l_string|&quot;IRQ status:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|27
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|fs_dprintk
(paren
id|FS_DEBUG_IRQ
comma
l_string|&quot; %s&quot;
comma
id|irq_bitname
(braket
id|i
)braket
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_IRQ
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|ISR_RBRQ0_W
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_IRQ
comma
l_string|&quot;Iiiin-coming (0)!!!!&bslash;n&quot;
)paren
suffix:semicolon
id|process_incoming
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_rq
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* items mentioned on RBRQ0 are from FP 0 or 1. */
id|top_off_fp
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_fp
(braket
l_int|0
)braket
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|top_off_fp
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_fp
(braket
l_int|1
)braket
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|ISR_RBRQ1_W
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_IRQ
comma
l_string|&quot;Iiiin-coming (1)!!!!&bslash;n&quot;
)paren
suffix:semicolon
id|process_incoming
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_rq
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|top_off_fp
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_fp
(braket
l_int|2
)braket
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|top_off_fp
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_fp
(braket
l_int|3
)braket
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|ISR_RBRQ2_W
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_IRQ
comma
l_string|&quot;Iiiin-coming (2)!!!!&bslash;n&quot;
)paren
suffix:semicolon
id|process_incoming
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_rq
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|top_off_fp
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_fp
(braket
l_int|4
)braket
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|top_off_fp
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_fp
(braket
l_int|5
)braket
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|ISR_RBRQ3_W
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_IRQ
comma
l_string|&quot;Iiiin-coming (3)!!!!&bslash;n&quot;
)paren
suffix:semicolon
id|process_incoming
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_rq
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|top_off_fp
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_fp
(braket
l_int|6
)braket
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|top_off_fp
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_fp
(braket
l_int|7
)braket
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|ISR_CSQ_W
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_IRQ
comma
l_string|&quot;Command executed ok!&bslash;n&quot;
)paren
suffix:semicolon
id|process_return_queue
(paren
id|dev
comma
op_amp
id|dev-&gt;st_q
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|ISR_TBRQ_W
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_IRQ
comma
l_string|&quot;Data tramsitted!&bslash;n&quot;
)paren
suffix:semicolon
id|process_txdone_queue
(paren
id|dev
comma
op_amp
id|dev-&gt;tx_relq
)paren
suffix:semicolon
)brace
id|func_exit
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef FS_POLL_FREQ
DECL|function|fs_poll
r_static
r_void
id|fs_poll
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|fs_dev
op_star
id|dev
op_assign
(paren
r_struct
id|fs_dev
op_star
)paren
id|data
suffix:semicolon
id|fs_irq
(paren
l_int|0
comma
id|dev
comma
l_int|NULL
)paren
suffix:semicolon
id|dev-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|FS_POLL_FREQ
suffix:semicolon
id|add_timer
(paren
op_amp
id|dev-&gt;timer
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|fs_init
r_static
r_int
id|__init
id|fs_init
(paren
r_struct
id|fs_dev
op_star
id|dev
)paren
(brace
r_struct
id|pci_dev
op_star
id|pci_dev
suffix:semicolon
r_int
id|isr
comma
id|to
suffix:semicolon
r_int
id|i
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
id|pci_dev
op_assign
id|dev-&gt;pci_dev
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;found a FireStream %d card, base %08lx, irq%d.&bslash;n&quot;
comma
id|IS_FS50
c_func
(paren
id|dev
)paren
ques
c_cond
l_int|50
suffix:colon
l_int|155
comma
id|pci_resource_start
c_func
(paren
id|pci_dev
comma
l_int|0
)paren
comma
id|dev-&gt;pci_dev-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs_debug
op_amp
id|FS_DEBUG_INIT
)paren
id|my_hd
(paren
(paren
r_int
r_char
op_star
)paren
id|dev
comma
r_sizeof
(paren
op_star
id|dev
)paren
)paren
suffix:semicolon
id|undocumented_pci_fix
(paren
id|pci_dev
)paren
suffix:semicolon
id|dev-&gt;hw_base
op_assign
id|pci_resource_start
c_func
(paren
id|pci_dev
comma
l_int|0
)paren
suffix:semicolon
id|dev-&gt;base
op_assign
(paren
id|ulong
)paren
id|ioremap
c_func
(paren
id|dev-&gt;hw_base
comma
l_int|0x1000
)paren
suffix:semicolon
id|reset_chip
(paren
id|dev
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|SARMODE0
comma
l_int|0
op_or
(paren
l_int|0
op_star
id|SARMODE0_SHADEN
)paren
multiline_comment|/* We don&squot;t use shadow registers. */
op_or
(paren
l_int|1
op_star
id|SARMODE0_INTMODE_READCLEAR
)paren
op_or
(paren
l_int|1
op_star
id|SARMODE0_CWRE
)paren
op_or
id|IS_FS50
c_func
(paren
id|dev
)paren
ques
c_cond
id|SARMODE0_PRPWT_FS50_5
suffix:colon
id|SARMODE0_PRPWT_FS155_3
op_or
(paren
l_int|1
op_star
id|SARMODE0_CALSUP_1
)paren
op_or
id|IS_FS50
(paren
id|dev
)paren
ques
c_cond
(paren
l_int|0
op_or
id|SARMODE0_RXVCS_32
op_or
id|SARMODE0_ABRVCS_32
op_or
id|SARMODE0_TXVCS_32
)paren
suffix:colon
(paren
l_int|0
op_or
id|SARMODE0_RXVCS_1k
op_or
id|SARMODE0_ABRVCS_1k
op_or
id|SARMODE0_TXVCS_1k
)paren
)paren
suffix:semicolon
multiline_comment|/* 10ms * 100 is 1 second. That should be enough, as AN3:9 says it takes&n;&t;   1ms. */
id|to
op_assign
l_int|100
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|to
)paren
(brace
id|isr
op_assign
id|read_fs
(paren
id|dev
comma
id|ISR
)paren
suffix:semicolon
multiline_comment|/* This bit is documented as &quot;RESERVED&quot; */
r_if
c_cond
(paren
id|isr
op_amp
id|ISR_INIT_ERR
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;Error initializing the FS... &bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|isr
op_amp
id|ISR_INIT
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_INIT
comma
l_string|&quot;Ha! Initialized OK!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Try again after 10ms. */
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
(paren
(paren
id|HZ
op_plus
l_int|99
)paren
op_div
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|to
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;timeout initializing the FS... &bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* XXX fix for fs155 */
id|dev-&gt;channel_mask
op_assign
l_int|0x1f
suffix:semicolon
id|dev-&gt;channo
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* AN3: 10 */
id|write_fs
(paren
id|dev
comma
id|SARMODE1
comma
l_int|0
op_or
(paren
l_int|0
op_star
id|SARMODE1_DEFHEC
)paren
multiline_comment|/* XXX PHY */
op_or
(paren
(paren
id|loopback
op_eq
l_int|1
)paren
op_star
id|SARMODE1_TSTLP
)paren
multiline_comment|/* XXX Loopback mode enable... */
op_or
(paren
l_int|1
op_star
id|SARMODE1_DCRM
)paren
op_or
(paren
l_int|1
op_star
id|SARMODE1_DCOAM
)paren
op_or
(paren
l_int|0
op_star
id|SARMODE1_OAMCRC
)paren
op_or
(paren
l_int|0
op_star
id|SARMODE1_DUMPE
)paren
op_or
(paren
l_int|0
op_star
id|SARMODE1_GPLEN
)paren
op_or
(paren
l_int|0
op_star
id|SARMODE1_GNAM
)paren
op_or
(paren
l_int|0
op_star
id|SARMODE1_GVAS
)paren
op_or
(paren
l_int|0
op_star
id|SARMODE1_GPAS
)paren
op_or
(paren
l_int|1
op_star
id|SARMODE1_GPRI
)paren
op_or
(paren
l_int|0
op_star
id|SARMODE1_PMS
)paren
op_or
(paren
l_int|0
op_star
id|SARMODE1_GFCR
)paren
op_or
(paren
l_int|1
op_star
id|SARMODE1_HECM2
)paren
op_or
(paren
l_int|1
op_star
id|SARMODE1_HECM1
)paren
op_or
(paren
l_int|1
op_star
id|SARMODE1_HECM0
)paren
op_or
(paren
l_int|1
op_lshift
l_int|12
)paren
multiline_comment|/* That&squot;s what hang&squot;s driver does. Program to 0 */
op_or
(paren
l_int|0
op_star
l_int|0xff
)paren
multiline_comment|/* XXX FS155 */
)paren
suffix:semicolon
multiline_comment|/* Cal prescale etc */
multiline_comment|/* AN3: 11 */
id|write_fs
(paren
id|dev
comma
id|TMCONF
comma
l_int|0x0000000f
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|CALPRESCALE
comma
l_int|0x01010101
op_star
id|num
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
l_int|0x80
comma
l_int|0x000F00E4
)paren
suffix:semicolon
multiline_comment|/* AN3: 12 */
id|write_fs
(paren
id|dev
comma
id|CELLOSCONF
comma
l_int|0
op_or
(paren
l_int|0
op_star
id|CELLOSCONF_CEN
)paren
op_or
(paren
id|CELLOSCONF_SC1
)paren
op_or
(paren
l_int|0x80
op_star
id|CELLOSCONF_COBS
)paren
op_or
(paren
id|num
op_star
id|CELLOSCONF_COPK
)paren
multiline_comment|/* Changed from 0xff to 0x5a */
op_or
(paren
id|num
op_star
id|CELLOSCONF_COST
)paren
)paren
suffix:semicolon
multiline_comment|/* after a hint from Hang. &n;&t;&t;&t;&t;&t;       * performance jumped 50-&gt;70... */
multiline_comment|/* Magic value by Hang */
id|write_fs
(paren
id|dev
comma
id|CELLOSCONF_COST
comma
l_int|0x0B809191
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_FS50
(paren
id|dev
)paren
)paren
(brace
id|write_fs
(paren
id|dev
comma
id|RAS0
comma
id|RAS0_DCD_XHLT
)paren
suffix:semicolon
id|dev-&gt;atm_dev-&gt;ci_range.vpi_bits
op_assign
l_int|12
suffix:semicolon
id|dev-&gt;atm_dev-&gt;ci_range.vci_bits
op_assign
l_int|16
suffix:semicolon
id|dev-&gt;nchannels
op_assign
id|FS50_NR_CHANNELS
suffix:semicolon
)brace
r_else
(brace
id|write_fs
(paren
id|dev
comma
id|RAS0
comma
id|RAS0_DCD_XHLT
op_or
(paren
(paren
(paren
l_int|1
op_lshift
id|FS155_VPI_BITS
)paren
op_minus
l_int|1
)paren
op_star
id|RAS0_VPSEL
)paren
op_or
(paren
(paren
(paren
l_int|1
op_lshift
id|FS155_VCI_BITS
)paren
op_minus
l_int|1
)paren
op_star
id|RAS0_VCSEL
)paren
)paren
suffix:semicolon
multiline_comment|/* We can chose the split arbitarily. We might be able to &n;&t;&t;   support more. Whatever. This should do for now. */
id|dev-&gt;atm_dev-&gt;ci_range.vpi_bits
op_assign
id|FS155_VPI_BITS
suffix:semicolon
id|dev-&gt;atm_dev-&gt;ci_range.vci_bits
op_assign
id|FS155_VCI_BITS
suffix:semicolon
multiline_comment|/* Address bits we can&squot;t use should be compared to 0. */
id|write_fs
(paren
id|dev
comma
id|RAC
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Manual (AN9, page 6) says ASF1=0 means compare Utopia address&n;&t;&t; * too.  I can&squot;t find ASF1 anywhere. Anyway, we AND with just hte&n;&t;&t; * other bits, then compare with 0, which is exactly what we&n;&t;&t; * want. */
id|write_fs
(paren
id|dev
comma
id|RAM
comma
(paren
l_int|1
op_lshift
(paren
l_int|28
op_minus
id|FS155_VPI_BITS
op_minus
id|FS155_VCI_BITS
)paren
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|dev-&gt;nchannels
op_assign
id|FS155_NR_CHANNELS
suffix:semicolon
)brace
id|dev-&gt;atm_vccs
op_assign
id|kmalloc
(paren
id|dev-&gt;nchannels
op_star
r_sizeof
(paren
r_struct
id|atm_vcc
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Alloc atmvccs: %p(%d)&bslash;n&quot;
comma
id|dev-&gt;atm_vccs
comma
id|dev-&gt;nchannels
op_star
r_sizeof
(paren
r_struct
id|atm_vcc
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;atm_vccs
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;Couldn&squot;t allocate memory for VCC buffers. Woops!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* XXX Clean up..... */
r_return
l_int|1
suffix:semicolon
)brace
id|memset
(paren
id|dev-&gt;atm_vccs
comma
l_int|0
comma
id|dev-&gt;nchannels
op_star
r_sizeof
(paren
r_struct
id|atm_vcc
op_star
)paren
)paren
suffix:semicolon
id|dev-&gt;tx_inuse
op_assign
id|kmalloc
(paren
id|dev-&gt;nchannels
op_div
l_int|8
multiline_comment|/* bits/byte */
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Alloc tx_inuse: %p(%d)&bslash;n&quot;
comma
id|dev-&gt;atm_vccs
comma
id|dev-&gt;nchannels
op_div
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;tx_inuse
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;Couldn&squot;t allocate memory for tx_inuse bits!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* XXX Clean up..... */
r_return
l_int|1
suffix:semicolon
)brace
id|memset
(paren
id|dev-&gt;tx_inuse
comma
l_int|0
comma
id|dev-&gt;nchannels
op_div
l_int|8
)paren
suffix:semicolon
multiline_comment|/* -- RAS1 : FS155 and 50 differ. Default (0) should be OK for both */
multiline_comment|/* -- RAS2 : FS50 only: Default is OK. */
multiline_comment|/* DMAMODE, default should be OK. -- REW */
id|write_fs
(paren
id|dev
comma
id|DMAMR
comma
id|DMAMR_TX_MODE_FULL
)paren
suffix:semicolon
id|init_q
(paren
id|dev
comma
op_amp
id|dev-&gt;hp_txq
comma
id|TX_PQ
c_func
(paren
id|TXQ_HP
)paren
comma
id|TXQ_NENTRIES
comma
l_int|0
)paren
suffix:semicolon
id|init_q
(paren
id|dev
comma
op_amp
id|dev-&gt;lp_txq
comma
id|TX_PQ
c_func
(paren
id|TXQ_LP
)paren
comma
id|TXQ_NENTRIES
comma
l_int|0
)paren
suffix:semicolon
id|init_q
(paren
id|dev
comma
op_amp
id|dev-&gt;tx_relq
comma
id|TXB_RQ
comma
id|TXQ_NENTRIES
comma
l_int|1
)paren
suffix:semicolon
id|init_q
(paren
id|dev
comma
op_amp
id|dev-&gt;st_q
comma
id|ST_Q
comma
id|TXQ_NENTRIES
comma
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FS_NR_FREE_POOLS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|init_fp
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_fp
(braket
id|i
)braket
comma
id|RXB_FP
c_func
(paren
id|i
)paren
comma
id|rx_buf_sizes
(braket
id|i
)braket
comma
id|rx_pool_sizes
(braket
id|i
)braket
)paren
suffix:semicolon
id|top_off_fp
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_fp
(braket
id|i
)braket
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FS_NR_RX_QUEUES
suffix:semicolon
id|i
op_increment
)paren
id|init_q
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_rq
(braket
id|i
)braket
comma
id|RXB_RQ
c_func
(paren
id|i
)paren
comma
id|RXRQ_NENTRIES
comma
l_int|1
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|pci_dev-&gt;irq
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
(paren
id|dev-&gt;irq
comma
id|fs_irq
comma
id|SA_SHIRQ
comma
l_string|&quot;firestream&quot;
comma
id|dev
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;couldn&squot;t get irq %d for firestream.&bslash;n&quot;
comma
id|pci_dev-&gt;irq
)paren
suffix:semicolon
multiline_comment|/* XXX undo all previous stuff... */
r_return
l_int|1
suffix:semicolon
)brace
id|fs_dprintk
(paren
id|FS_DEBUG_INIT
comma
l_string|&quot;Grabbed irq %d for dev at %p.&bslash;n&quot;
comma
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* We want to be notified of most things. Just the statistics count&n;&t;   overflows are not interesting */
id|write_fs
(paren
id|dev
comma
id|IMR
comma
l_int|0
op_or
id|ISR_RBRQ0_W
op_or
id|ISR_RBRQ1_W
op_or
id|ISR_RBRQ2_W
op_or
id|ISR_RBRQ3_W
op_or
id|ISR_TBRQ_W
op_or
id|ISR_CSQ_W
)paren
suffix:semicolon
id|write_fs
(paren
id|dev
comma
id|SARMODE0
comma
l_int|0
op_or
(paren
l_int|0
op_star
id|SARMODE0_SHADEN
)paren
multiline_comment|/* We don&squot;t use shadow registers. */
op_or
(paren
l_int|1
op_star
id|SARMODE0_GINT
)paren
op_or
(paren
l_int|1
op_star
id|SARMODE0_INTMODE_READCLEAR
)paren
op_or
(paren
l_int|0
op_star
id|SARMODE0_CWRE
)paren
op_or
(paren
id|IS_FS50
c_func
(paren
id|dev
)paren
ques
c_cond
id|SARMODE0_PRPWT_FS50_5
suffix:colon
id|SARMODE0_PRPWT_FS155_3
)paren
op_or
(paren
l_int|1
op_star
id|SARMODE0_CALSUP_1
)paren
op_or
(paren
id|IS_FS50
(paren
id|dev
)paren
ques
c_cond
(paren
l_int|0
op_or
id|SARMODE0_RXVCS_32
op_or
id|SARMODE0_ABRVCS_32
op_or
id|SARMODE0_TXVCS_32
)paren
suffix:colon
(paren
l_int|0
op_or
id|SARMODE0_RXVCS_1k
op_or
id|SARMODE0_ABRVCS_1k
op_or
id|SARMODE0_TXVCS_1k
)paren
)paren
op_or
(paren
l_int|1
op_star
id|SARMODE0_RUN
)paren
)paren
suffix:semicolon
id|init_phy
(paren
id|dev
comma
id|PHY_NTC_INIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|loopback
op_eq
l_int|2
)paren
(brace
id|write_phy
(paren
id|dev
comma
l_int|0x39
comma
l_int|0x000e
)paren
suffix:semicolon
)brace
macro_line|#ifdef FS_POLL_FREQ
id|init_timer
(paren
op_amp
id|dev-&gt;timer
)paren
suffix:semicolon
id|dev-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
id|dev-&gt;timer.function
op_assign
id|fs_poll
suffix:semicolon
id|dev-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|FS_POLL_FREQ
suffix:semicolon
id|add_timer
(paren
op_amp
id|dev-&gt;timer
)paren
suffix:semicolon
macro_line|#endif
id|dev-&gt;atm_dev-&gt;dev_data
op_assign
id|dev
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|firestream_init_one
r_static
r_int
id|__init
id|firestream_init_one
(paren
r_struct
id|pci_dev
op_star
id|pci_dev
comma
r_const
r_struct
id|pci_device_id
op_star
id|ent
)paren
(brace
r_struct
id|atm_dev
op_star
id|atm_dev
suffix:semicolon
r_struct
id|fs_dev
op_star
id|fs_dev
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pci_dev
)paren
)paren
r_goto
id|err_out
suffix:semicolon
id|fs_dev
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|fs_dev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Alloc fs-dev: %p(%d)&bslash;n&quot;
comma
id|fs_dev
comma
r_sizeof
(paren
r_struct
id|fs_dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fs_dev
)paren
r_goto
id|err_out
suffix:semicolon
id|memset
(paren
id|fs_dev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|fs_dev
)paren
)paren
suffix:semicolon
id|atm_dev
op_assign
id|atm_dev_register
c_func
(paren
l_string|&quot;fs&quot;
comma
op_amp
id|ops
comma
op_minus
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atm_dev
)paren
r_goto
id|err_out_free_fs_dev
suffix:semicolon
id|fs_dev-&gt;pci_dev
op_assign
id|pci_dev
suffix:semicolon
id|fs_dev-&gt;atm_dev
op_assign
id|atm_dev
suffix:semicolon
id|fs_dev-&gt;flags
op_assign
id|ent-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|fs_init
c_func
(paren
id|fs_dev
)paren
)paren
r_goto
id|err_out_free_atm_dev
suffix:semicolon
id|fs_dev-&gt;next
op_assign
id|fs_boards
suffix:semicolon
id|fs_boards
op_assign
id|fs_dev
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out_free_atm_dev
suffix:colon
id|atm_dev_deregister
c_func
(paren
id|atm_dev
)paren
suffix:semicolon
id|err_out_free_fs_dev
suffix:colon
id|kfree
c_func
(paren
id|fs_dev
)paren
suffix:semicolon
id|err_out
suffix:colon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|firestream_remove_one
r_void
id|__devexit
id|firestream_remove_one
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|fs_dev
op_star
id|dev
comma
op_star
id|nxtdev
suffix:semicolon
r_struct
id|fs_vcc
op_star
id|vcc
suffix:semicolon
r_struct
id|FS_BPENTRY
op_star
id|fp
comma
op_star
id|nxt
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
macro_line|#if 0
id|printk
(paren
l_string|&quot;hptxq:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|60
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
(paren
l_string|&quot;%d: %08x %08x %08x %08x &bslash;n&quot;
comma
id|i
comma
id|pq
(braket
id|qp
)braket
dot
id|cmd
comma
id|pq
(braket
id|qp
)braket
dot
id|p0
comma
id|pq
(braket
id|qp
)braket
dot
id|p1
comma
id|pq
(braket
id|qp
)braket
dot
id|p2
)paren
suffix:semicolon
id|qp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|qp
op_ge
l_int|60
)paren
id|qp
op_assign
l_int|0
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;descriptors:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|60
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
(paren
l_string|&quot;%d: %p: %08x %08x %p %p&bslash;n&quot;
comma
id|i
comma
id|da
(braket
id|qd
)braket
comma
id|dq
(braket
id|qd
)braket
dot
id|flags
comma
id|dq
(braket
id|qd
)braket
dot
id|bsa
comma
id|dq
(braket
id|qd
)braket
dot
id|skb
comma
id|dq
(braket
id|qd
)braket
dot
id|dev
)paren
suffix:semicolon
id|qd
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|qd
op_ge
l_int|60
)paren
id|qd
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_for
c_loop
(paren
id|dev
op_assign
id|fs_boards
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|nxtdev
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_CLEANUP
comma
l_string|&quot;Releasing resources for dev at %p.&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* XXX Hit all the tx channels too! */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;nchannels
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;atm_vccs
(braket
id|i
)braket
)paren
(brace
id|vcc
op_assign
id|FS_VCC
(paren
id|dev-&gt;atm_vccs
(braket
id|i
)braket
)paren
suffix:semicolon
id|submit_command
(paren
id|dev
comma
op_amp
id|dev-&gt;hp_txq
comma
id|QE_CMD_TX_PURGE_INH
op_or
id|QE_CMD_IMM_INQ
op_or
id|vcc-&gt;channo
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|submit_command
(paren
id|dev
comma
op_amp
id|dev-&gt;hp_txq
comma
id|QE_CMD_RX_PURGE_INH
op_or
id|QE_CMD_IMM_INQ
op_or
id|vcc-&gt;channo
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* XXX Wait a while for the chip to release all buffers. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FS_NR_FREE_POOLS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|fp
op_assign
id|bus_to_virt
(paren
id|read_fs
(paren
id|dev
comma
id|FP_SA
c_func
(paren
id|dev-&gt;rx_fp
(braket
id|i
)braket
dot
id|offset
)paren
)paren
)paren
suffix:semicolon
op_logical_neg
(paren
id|fp-&gt;flags
op_amp
id|FP_FLAGS_EPI
)paren
suffix:semicolon
id|fp
op_assign
id|nxt
)paren
(brace
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Free rec-skb: %p&bslash;n&quot;
comma
id|fp-&gt;skb
)paren
suffix:semicolon
id|dev_kfree_skb_any
(paren
id|fp-&gt;skb
)paren
suffix:semicolon
id|nxt
op_assign
id|bus_to_virt
(paren
id|fp-&gt;next
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Free rec-d: %p&bslash;n&quot;
comma
id|fp
)paren
suffix:semicolon
id|kfree
(paren
id|fp
)paren
suffix:semicolon
)brace
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Free rec-skb: %p&bslash;n&quot;
comma
id|fp-&gt;skb
)paren
suffix:semicolon
id|dev_kfree_skb_any
(paren
id|fp-&gt;skb
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Free rec-d: %p&bslash;n&quot;
comma
id|fp
)paren
suffix:semicolon
id|kfree
(paren
id|fp
)paren
suffix:semicolon
)brace
multiline_comment|/* Hang the chip in &quot;reset&quot;, prevent it clobbering memory that is&n;&t;&t;   no longer ours. */
id|reset_chip
(paren
id|dev
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_CLEANUP
comma
l_string|&quot;Freeing irq%d.&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|free_irq
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|del_timer
(paren
op_amp
id|dev-&gt;timer
)paren
suffix:semicolon
id|atm_dev_deregister
c_func
(paren
id|dev-&gt;atm_dev
)paren
suffix:semicolon
id|free_queue
(paren
id|dev
comma
op_amp
id|dev-&gt;hp_txq
)paren
suffix:semicolon
id|free_queue
(paren
id|dev
comma
op_amp
id|dev-&gt;lp_txq
)paren
suffix:semicolon
id|free_queue
(paren
id|dev
comma
op_amp
id|dev-&gt;tx_relq
)paren
suffix:semicolon
id|free_queue
(paren
id|dev
comma
op_amp
id|dev-&gt;st_q
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Free atmvccs: %p&bslash;n&quot;
comma
id|dev-&gt;atm_vccs
)paren
suffix:semicolon
id|kfree
(paren
id|dev-&gt;atm_vccs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FS_NR_FREE_POOLS
suffix:semicolon
id|i
op_increment
)paren
id|free_freepool
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_fp
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FS_NR_RX_QUEUES
suffix:semicolon
id|i
op_increment
)paren
id|free_queue
(paren
id|dev
comma
op_amp
id|dev-&gt;rx_rq
(braket
id|i
)braket
)paren
suffix:semicolon
id|fs_dprintk
(paren
id|FS_DEBUG_ALLOC
comma
l_string|&quot;Free fs-dev: %p&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
id|nxtdev
op_assign
id|dev-&gt;next
suffix:semicolon
id|kfree
(paren
id|dev
)paren
suffix:semicolon
)brace
id|func_exit
(paren
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_int
id|__init
id|fs_detect
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|pci_dev
suffix:semicolon
r_int
id|devs
op_assign
l_int|0
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
id|pci_dev
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|pci_dev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_FUJITSU_ME
comma
id|PCI_DEVICE_ID_FUJITSU_FS50
comma
id|pci_dev
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|fs_register_and_init
(paren
id|pci_dev
comma
op_amp
id|fs_pci_tbl
(braket
l_int|0
)braket
)paren
)paren
r_break
suffix:semicolon
id|devs
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|pci_dev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_FUJITSU_ME
comma
id|PCI_DEVICE_ID_FUJITSU_FS155
comma
id|pci_dev
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|fs_register_and_init
(paren
id|pci_dev
comma
id|FS_IS155
)paren
)paren
r_break
suffix:semicolon
id|devs
op_increment
suffix:semicolon
)brace
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|devs
suffix:semicolon
)brace
macro_line|#else
macro_line|#if 0
r_int
id|__init
id|init_PCI
(paren
r_void
)paren
(brace
multiline_comment|/* Begin init_PCI */
r_int
id|pci_count
suffix:semicolon
id|printk
(paren
l_string|&quot;init_PCI&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;  memset (&amp;firestream_driver, 0, sizeof (firestream_driver));&n;&t;  firestream_driver.name = &quot;firestream&quot;;&n;&t;  firestream_driver.id_table = firestream_pci_tbl;&n;&t;  firestream_driver.probe = fs_register_and_init;&n;&t;*/
id|pci_count
op_assign
id|pci_register_driver
(paren
op_amp
id|firestream_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_count
op_le
l_int|0
)paren
(brace
id|pci_unregister_driver
(paren
op_amp
id|firestream_driver
)paren
suffix:semicolon
id|pci_count
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|pci_count
suffix:semicolon
)brace
multiline_comment|/* End init_PCI */
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n;#ifdef MODULE&n;#define firestream_init init_module&n;#endif &n;*/
DECL|variable|__devinitdata
r_const
r_static
r_struct
id|pci_device_id
id|firestream_pci_tbl
(braket
)braket
id|__devinitdata
op_assign
(brace
(brace
id|PCI_VENDOR_ID_FUJITSU_ME
comma
id|PCI_DEVICE_ID_FUJITSU_FS50
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|FS_IS50
)brace
comma
(brace
id|PCI_VENDOR_ID_FUJITSU_ME
comma
id|PCI_DEVICE_ID_FUJITSU_FS155
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|FS_IS155
)brace
comma
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|firestream_pci_tbl
)paren
suffix:semicolon
DECL|variable|firestream_driver
r_static
r_struct
id|pci_driver
id|firestream_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;firestream&quot;
comma
id|id_table
suffix:colon
id|firestream_pci_tbl
comma
id|probe
suffix:colon
id|firestream_init_one
comma
id|remove
suffix:colon
id|firestream_remove_one
comma
)brace
suffix:semicolon
DECL|function|firestream_init_module
r_static
r_int
id|__init
id|firestream_init_module
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
id|error
op_assign
id|pci_module_init
c_func
(paren
op_amp
id|firestream_driver
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|firestream_cleanup_module
r_static
r_void
id|__exit
id|firestream_cleanup_module
c_func
(paren
r_void
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|firestream_driver
)paren
suffix:semicolon
)brace
DECL|variable|firestream_init_module
id|module_init
c_func
(paren
id|firestream_init_module
)paren
suffix:semicolon
DECL|variable|firestream_cleanup_module
id|module_exit
c_func
(paren
id|firestream_cleanup_module
)paren
suffix:semicolon
eof
