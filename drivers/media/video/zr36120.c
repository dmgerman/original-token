multiline_comment|/*&n;    zr36120.c - Zoran 36120/36125 based framegrabbers&n;&n;    Copyright (C) 1998-1999 Pauline Middelink &lt;middelin@polyware.nl&gt;&n;&n;    This program is free software; you can redistribute it and/or modify&n;    it under the terms of the GNU General Public License as published by&n;    the Free Software Foundation; either version 2 of the License, or&n;    (at your option) any later version.&n;&n;    This program is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;    GNU General Public License for more details.&n;&n;    You should have received a copy of the GNU General Public License&n;    along with this program; if not, write to the Free Software&n;    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/video_decoder.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;tuner.h&quot;
macro_line|#include &quot;zr36120.h&quot;
macro_line|#include &quot;zr36120_mem.h&quot;
multiline_comment|/* mark an required function argument unused - lintism */
DECL|macro|UNUSED
mdefine_line|#define&t;UNUSED(x)&t;(void)(x)
multiline_comment|/* sensible default */
macro_line|#ifndef CARDTYPE
DECL|macro|CARDTYPE
mdefine_line|#define CARDTYPE 0
macro_line|#endif
multiline_comment|/* Anybody who uses more than four? */
DECL|macro|ZORAN_MAX
mdefine_line|#define ZORAN_MAX 4
DECL|variable|triton1
r_static
r_int
r_int
id|triton1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* triton1 chipset? */
DECL|variable|cardtype
r_static
r_int
r_int
id|cardtype
(braket
id|ZORAN_MAX
)braket
op_assign
initialization_block
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Pauline Middelink &lt;middelin@polyware.nl&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Zoran ZR36120 based framegrabber&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|triton1
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|cardtype
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|ZORAN_MAX
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|variable|zoran_cards
r_static
r_int
id|zoran_cards
suffix:semicolon
DECL|variable|zorans
r_static
r_struct
id|zoran
id|zorans
(braket
id|ZORAN_MAX
)braket
suffix:semicolon
multiline_comment|/*&n; * the meaning of each element can be found in zr36120.h&n; * Determining the value of gpdir/gpval can be tricky. The&n; * best way is to run the card under the original software&n; * and read the values from the general purpose registers&n; * 0x28 and 0x2C. How you do that is left as an exercise&n; * to the impatient reader :)&n; */
DECL|macro|T
mdefine_line|#define T 1&t;/* to seperate the bools from the ints */
DECL|macro|F
mdefine_line|#define F 0
DECL|variable|tvcards
r_static
r_struct
id|tvcard
id|tvcards
(braket
)braket
op_assign
(brace
multiline_comment|/* reported working by &lt;middelin@polyware.nl&gt; */
multiline_comment|/*0*/
(brace
l_string|&quot;Trust Victor II&quot;
comma
l_int|2
comma
l_int|0
comma
id|T
comma
id|T
comma
id|T
comma
id|T
comma
l_int|0x7F
comma
l_int|0x80
comma
(brace
l_int|1
comma
id|SVHS
c_func
(paren
l_int|6
)paren
)brace
comma
(brace
l_int|0
)brace
)brace
comma
multiline_comment|/* reported working by &lt;Michael.Paxton@aihw.gov.au&gt;  */
multiline_comment|/*1*/
(brace
l_string|&quot;Aitech WaveWatcher TV-PCI&quot;
comma
l_int|3
comma
l_int|0
comma
id|T
comma
id|F
comma
id|T
comma
id|T
comma
l_int|0x7F
comma
l_int|0x80
comma
(brace
l_int|1
comma
id|TUNER
c_func
(paren
l_int|3
)paren
comma
id|SVHS
c_func
(paren
l_int|6
)paren
)brace
comma
(brace
l_int|0
)brace
)brace
comma
multiline_comment|/* reported working by ? */
multiline_comment|/*2*/
(brace
l_string|&quot;Genius Video Wonder PCI Video Capture Card&quot;
comma
l_int|2
comma
l_int|0
comma
id|T
comma
id|T
comma
id|T
comma
id|T
comma
l_int|0x7F
comma
l_int|0x80
comma
(brace
l_int|1
comma
id|SVHS
c_func
(paren
l_int|6
)paren
)brace
comma
(brace
l_int|0
)brace
)brace
comma
multiline_comment|/* reported working by &lt;Pascal.Gabriel@wanadoo.fr&gt; */
multiline_comment|/*3*/
(brace
l_string|&quot;Guillemot Maxi-TV PCI&quot;
comma
l_int|2
comma
l_int|0
comma
id|T
comma
id|T
comma
id|T
comma
id|T
comma
l_int|0x7F
comma
l_int|0x80
comma
(brace
l_int|1
comma
id|SVHS
c_func
(paren
l_int|6
)paren
)brace
comma
(brace
l_int|0
)brace
)brace
comma
multiline_comment|/* reported working by &quot;Craig Whitmore &lt;lennon@igrin.co.nz&gt; */
multiline_comment|/*4*/
(brace
l_string|&quot;Quadrant Buster&quot;
comma
l_int|3
comma
l_int|3
comma
id|T
comma
id|F
comma
id|T
comma
id|T
comma
l_int|0x7F
comma
l_int|0x80
comma
(brace
id|SVHS
c_func
(paren
l_int|1
)paren
comma
id|TUNER
c_func
(paren
l_int|2
)paren
comma
l_int|3
)brace
comma
(brace
l_int|1
comma
l_int|2
comma
l_int|3
)brace
)brace
comma
multiline_comment|/* a debug entry which has all inputs mapped */
multiline_comment|/*5*/
(brace
l_string|&quot;ZR36120 based framegrabber (all inputs enabled)&quot;
comma
l_int|6
comma
l_int|0
comma
id|T
comma
id|T
comma
id|T
comma
id|T
comma
l_int|0x7F
comma
l_int|0x80
comma
(brace
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|6
)brace
comma
(brace
l_int|0
)brace
)brace
)brace
suffix:semicolon
DECL|macro|T
macro_line|#undef T
DECL|macro|F
macro_line|#undef F
DECL|macro|NRTVCARDS
mdefine_line|#define NRTVCARDS (sizeof(tvcards)/sizeof(tvcards[0]))
macro_line|#ifdef __sparc__
DECL|macro|ENDIANESS
mdefine_line|#define&t;ENDIANESS&t;0
macro_line|#else
DECL|macro|ENDIANESS
mdefine_line|#define&t;ENDIANESS&t;ZORAN_VFEC_LE
macro_line|#endif
DECL|member|name
DECL|member|mode
DECL|member|bpp
DECL|variable|palette2fmt
r_static
r_struct
(brace
r_const
r_char
id|name
(braket
l_int|8
)braket
suffix:semicolon
id|uint
id|mode
suffix:semicolon
id|uint
id|bpp
suffix:semicolon
)brace
id|palette2fmt
(braket
)braket
op_assign
(brace
multiline_comment|/* n/a     */
(brace
l_string|&quot;n/a&quot;
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* GREY    */
(brace
l_string|&quot;GRAY&quot;
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* HI240   */
(brace
l_string|&quot;HI240&quot;
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* RGB565  */
(brace
l_string|&quot;RGB565&quot;
comma
id|ZORAN_VFEC_RGB_RGB565
op_or
id|ENDIANESS
comma
l_int|2
)brace
comma
multiline_comment|/* RGB24   */
(brace
l_string|&quot;RGB24&quot;
comma
id|ZORAN_VFEC_RGB_RGB888
op_or
id|ENDIANESS
op_or
id|ZORAN_VFEC_PACK24
comma
l_int|3
)brace
comma
multiline_comment|/* RGB32   */
(brace
l_string|&quot;RGB32&quot;
comma
id|ZORAN_VFEC_RGB_RGB888
op_or
id|ENDIANESS
comma
l_int|4
)brace
comma
multiline_comment|/* RGB555  */
(brace
l_string|&quot;RGB555&quot;
comma
id|ZORAN_VFEC_RGB_RGB555
op_or
id|ENDIANESS
comma
l_int|2
)brace
comma
multiline_comment|/* YUV422  */
(brace
l_string|&quot;YUV422&quot;
comma
id|ZORAN_VFEC_RGB_YUV422
op_or
id|ENDIANESS
comma
l_int|2
)brace
comma
multiline_comment|/* YUYV    */
(brace
l_string|&quot;YUYV&quot;
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* UYVY    */
(brace
l_string|&quot;UYVY&quot;
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* YUV420  */
(brace
l_string|&quot;YUV420&quot;
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* YUV411  */
(brace
l_string|&quot;YUV411&quot;
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* RAW     */
(brace
l_string|&quot;RAW&quot;
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* YUV422P */
(brace
l_string|&quot;YUV422P&quot;
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* YUV411P */
(brace
l_string|&quot;YUV411P&quot;
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|macro|NRPALETTES
mdefine_line|#define NRPALETTES (sizeof(palette2fmt)/sizeof(palette2fmt[0]))
DECL|macro|ENDIANESS
macro_line|#undef ENDIANESS
multiline_comment|/* ----------------------------------------------------------------------- */
multiline_comment|/* ZORAN chipset detector                                                 */
multiline_comment|/* shamelessly stolen from bttv.c                                         */
multiline_comment|/* Reason for beeing here: we need to detect if we are running on a        */
multiline_comment|/* Triton based chipset, and if so, enable a certain bit                   */
multiline_comment|/* ----------------------------------------------------------------------- */
r_static
DECL|function|handle_chipset
r_void
id|__init
id|handle_chipset
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Just in case some nut set this to something dangerous */
r_if
c_cond
(paren
id|triton1
)paren
id|triton1
op_assign
id|ZORAN_VDC_TRICOM
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_DEVICE_ID_INTEL_82437
comma
id|dev
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;zoran: Host bridge 82437FX Triton PIIX&bslash;n&quot;
)paren
suffix:semicolon
id|triton1
op_assign
id|ZORAN_VDC_TRICOM
suffix:semicolon
)brace
)brace
multiline_comment|/* ----------------------------------------------------------------------- */
multiline_comment|/* ZORAN functions&t;&t;&t;&t;&t;&t;&t;   */
multiline_comment|/* ----------------------------------------------------------------------- */
r_static
r_void
id|zoran_set_geo
c_func
(paren
r_struct
id|zoran
op_star
id|ztv
comma
r_struct
id|vidinfo
op_star
id|i
)paren
suffix:semicolon
macro_line|#if 0 /* unused */
r_static
r_void
id|zoran_dump
c_func
(paren
r_struct
id|zoran
op_star
id|ztv
)paren
(brace
r_char
id|str
(braket
l_int|256
)braket
suffix:semicolon
r_char
op_star
id|p
op_assign
id|str
suffix:semicolon
multiline_comment|/* shut up, gcc! */
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x60
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
id|p
op_assign
id|str
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|str
comma
id|KERN_DEBUG
l_string|&quot;       %04x: &quot;
comma
id|i
)paren
suffix:semicolon
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%08x &quot;
comma
id|zrread
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* unused */
r_static
DECL|function|reap_states
r_void
id|reap_states
c_func
(paren
r_struct
id|zoran
op_star
id|ztv
)paren
(brace
multiline_comment|/* count frames */
id|ztv-&gt;fieldnr
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Are we busy at all?&n;&t; * This depends on if there is a workqueue AND the&n;&t; * videotransfer is enabled on the chip...&n;&t; */
r_if
c_cond
(paren
id|ztv-&gt;workqueue
op_logical_and
(paren
id|zrread
c_func
(paren
id|ZORAN_VDC
)paren
op_amp
id|ZORAN_VDC_VIDEN
)paren
)paren
(brace
r_struct
id|vidinfo
op_star
id|newitem
suffix:semicolon
multiline_comment|/* did we get a complete frame? */
r_if
c_cond
(paren
id|zrread
c_func
(paren
id|ZORAN_VSTR
)paren
op_amp
id|ZORAN_VSTR_GRAB
)paren
r_return
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;completed %s at %p&bslash;n&quot;
comma
id|CARD
comma
id|ztv-&gt;workqueue-&gt;kindof
op_eq
id|FBUFFER_GRAB
ques
c_cond
l_string|&quot;grab&quot;
suffix:colon
l_string|&quot;read&quot;
comma
id|ztv-&gt;workqueue
)paren
)paren
suffix:semicolon
multiline_comment|/* we are done with this buffer, tell everyone */
id|ztv-&gt;workqueue-&gt;status
op_assign
id|FBUFFER_DONE
suffix:semicolon
id|ztv-&gt;workqueue-&gt;fieldnr
op_assign
id|ztv-&gt;fieldnr
suffix:semicolon
multiline_comment|/* not good, here for BTTV_FIELDNR reasons */
id|ztv-&gt;lastfieldnr
op_assign
id|ztv-&gt;fieldnr
suffix:semicolon
r_switch
c_cond
(paren
id|ztv-&gt;workqueue-&gt;kindof
)paren
(brace
r_case
id|FBUFFER_GRAB
suffix:colon
id|wake_up_interruptible
c_func
(paren
op_amp
id|ztv-&gt;grabq
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FBUFFER_VBI
suffix:colon
id|wake_up_interruptible
c_func
(paren
op_amp
id|ztv-&gt;vbiq
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|CARD_INFO
l_string|&quot;somebody killed the workqueue (kindof=%d)!&bslash;n&quot;
comma
id|CARD
comma
id|ztv-&gt;workqueue-&gt;kindof
)paren
suffix:semicolon
)brace
multiline_comment|/* item completed, skip to next item in queue */
id|write_lock
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
id|newitem
op_assign
id|ztv-&gt;workqueue-&gt;next
suffix:semicolon
id|ztv-&gt;workqueue-&gt;next
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* mark completed */
id|ztv-&gt;workqueue
op_assign
id|newitem
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * ok, so it seems we have nothing in progress right now.&n;&t; * Lets see if we can find some work.&n;&t; */
r_if
c_cond
(paren
id|ztv-&gt;workqueue
)paren
(brace
r_struct
id|vidinfo
op_star
id|newitem
suffix:semicolon
id|again
suffix:colon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;starting %s at %p&bslash;n&quot;
comma
id|CARD
comma
id|ztv-&gt;workqueue-&gt;kindof
op_eq
id|FBUFFER_GRAB
ques
c_cond
l_string|&quot;grab&quot;
suffix:colon
l_string|&quot;read&quot;
comma
id|ztv-&gt;workqueue
)paren
)paren
suffix:semicolon
multiline_comment|/* loadup the frame settings */
id|read_lock
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
id|zoran_set_geo
c_func
(paren
id|ztv
comma
id|ztv-&gt;workqueue
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ztv-&gt;workqueue-&gt;kindof
)paren
(brace
r_case
id|FBUFFER_GRAB
suffix:colon
r_case
id|FBUFFER_VBI
suffix:colon
id|zrand
c_func
(paren
op_complement
id|ZORAN_OCR_OVLEN
comma
id|ZORAN_OCR
)paren
suffix:semicolon
id|zror
c_func
(paren
id|ZORAN_VSTR_SNAPSHOT
comma
id|ZORAN_VSTR
)paren
suffix:semicolon
id|zror
c_func
(paren
id|ZORAN_VDC_VIDEN
comma
id|ZORAN_VDC
)paren
suffix:semicolon
multiline_comment|/* start single-shot grab */
id|zror
c_func
(paren
id|ZORAN_VSTR_GRAB
comma
id|ZORAN_VSTR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|CARD_INFO
l_string|&quot;what is this doing on the queue? (kindof=%d)&bslash;n&quot;
comma
id|CARD
comma
id|ztv-&gt;workqueue-&gt;kindof
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
id|newitem
op_assign
id|ztv-&gt;workqueue-&gt;next
suffix:semicolon
id|ztv-&gt;workqueue-&gt;next
op_assign
l_int|0
suffix:semicolon
id|ztv-&gt;workqueue
op_assign
id|newitem
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newitem
)paren
r_goto
id|again
suffix:semicolon
multiline_comment|/* yeah, sure.. */
)brace
multiline_comment|/* bye for now */
r_return
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;nothing in queue&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * What? Even the workqueue is empty? Am i really here&n;&t; * for nothing? Did i come all that way to... do nothing?&n;&t; */
multiline_comment|/* do we need to overlay? */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|STATE_OVERLAY
comma
op_amp
id|ztv-&gt;state
)paren
)paren
(brace
multiline_comment|/* are we already overlaying? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|zrread
c_func
(paren
id|ZORAN_OCR
)paren
op_amp
id|ZORAN_OCR_OVLEN
)paren
op_logical_or
op_logical_neg
(paren
id|zrread
c_func
(paren
id|ZORAN_VDC
)paren
op_amp
id|ZORAN_VDC_VIDEN
)paren
)paren
(brace
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;starting overlay&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
id|zoran_set_geo
c_func
(paren
id|ztv
comma
op_amp
id|ztv-&gt;overinfo
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
id|zror
c_func
(paren
id|ZORAN_OCR_OVLEN
comma
id|ZORAN_OCR
)paren
suffix:semicolon
id|zrand
c_func
(paren
op_complement
id|ZORAN_VSTR_SNAPSHOT
comma
id|ZORAN_VSTR
)paren
suffix:semicolon
id|zror
c_func
(paren
id|ZORAN_VDC_VIDEN
comma
id|ZORAN_VDC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * leave overlaying on, but turn interrupts off.&n;&t;&t; */
id|zrand
c_func
(paren
op_complement
id|ZORAN_ICR_EN
comma
id|ZORAN_ICR
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* do we have any VBI idle time processing? */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|STATE_VBI
comma
op_amp
id|ztv-&gt;state
)paren
)paren
(brace
r_struct
id|vidinfo
op_star
id|item
suffix:semicolon
r_struct
id|vidinfo
op_star
id|lastitem
suffix:semicolon
multiline_comment|/* protect the workqueue */
id|write_lock
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
id|lastitem
op_assign
id|ztv-&gt;workqueue
suffix:semicolon
r_if
c_cond
(paren
id|lastitem
)paren
r_while
c_loop
(paren
id|lastitem-&gt;next
)paren
id|lastitem
op_assign
id|lastitem-&gt;next
suffix:semicolon
r_for
c_loop
(paren
id|item
op_assign
id|ztv-&gt;readinfo
suffix:semicolon
id|item
op_ne
id|ztv-&gt;readinfo
op_plus
id|ZORAN_VBI_BUFFERS
suffix:semicolon
id|item
op_increment
)paren
r_if
c_cond
(paren
id|item-&gt;next
op_eq
l_int|0
op_logical_and
id|item-&gt;status
op_eq
id|FBUFFER_FREE
)paren
(brace
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;%p added to queue&bslash;n&quot;
comma
id|CARD
comma
id|item
)paren
)paren
suffix:semicolon
id|item-&gt;status
op_assign
id|FBUFFER_BUSY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lastitem
)paren
id|ztv-&gt;workqueue
op_assign
id|item
suffix:semicolon
r_else
id|lastitem-&gt;next
op_assign
id|item
suffix:semicolon
id|lastitem
op_assign
id|item
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ztv-&gt;workqueue
)paren
r_goto
id|again
suffix:semicolon
multiline_comment|/* hey, _i_ graduated :) */
)brace
multiline_comment|/*&n;&t; * Then we must be realy IDLE&n;&t; */
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;turning off&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
multiline_comment|/* nothing further to do, disable DMA and further IRQs */
id|zrand
c_func
(paren
op_complement
id|ZORAN_VDC_VIDEN
comma
id|ZORAN_VDC
)paren
suffix:semicolon
id|zrand
c_func
(paren
op_complement
id|ZORAN_ICR_EN
comma
id|ZORAN_ICR
)paren
suffix:semicolon
)brace
r_static
DECL|function|zoran_irq
r_void
id|zoran_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|u32
id|stat
comma
id|estat
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_struct
id|zoran
op_star
id|ztv
op_assign
(paren
r_struct
id|zoran
op_star
)paren
id|dev_id
suffix:semicolon
id|UNUSED
c_func
(paren
id|irq
)paren
suffix:semicolon
id|UNUSED
c_func
(paren
id|regs
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* get/clear interrupt status bits */
id|stat
op_assign
id|zrread
c_func
(paren
id|ZORAN_ISR
)paren
suffix:semicolon
id|estat
op_assign
id|stat
op_amp
id|zrread
c_func
(paren
id|ZORAN_ICR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|estat
)paren
r_return
suffix:semicolon
id|zrwrite
c_func
(paren
id|estat
comma
id|ZORAN_ISR
)paren
suffix:semicolon
id|IDEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;estat %08x&bslash;n&quot;
comma
id|CARD
comma
id|estat
)paren
)paren
suffix:semicolon
id|IDEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot; stat %08x&bslash;n&quot;
comma
id|CARD
comma
id|stat
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|estat
op_amp
id|ZORAN_ISR_CODE
)paren
(brace
id|IDEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;CodReplIRQ&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|estat
op_amp
id|ZORAN_ISR_GIRQ0
)paren
(brace
id|IDEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;GIRQ0&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ztv-&gt;card-&gt;usegirq1
)paren
id|reap_states
c_func
(paren
id|ztv
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|estat
op_amp
id|ZORAN_ISR_GIRQ1
)paren
(brace
id|IDEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;GIRQ1&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ztv-&gt;card-&gt;usegirq1
)paren
id|reap_states
c_func
(paren
id|ztv
)paren
suffix:semicolon
)brace
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|10
)paren
id|printk
c_func
(paren
id|CARD_ERR
l_string|&quot;irq loop %d (%x)&bslash;n&quot;
comma
id|CARD
comma
id|count
comma
id|estat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|20
)paren
(brace
id|zrwrite
c_func
(paren
l_int|0
comma
id|ZORAN_ICR
)paren
suffix:semicolon
id|printk
c_func
(paren
id|CARD_ERR
l_string|&quot;IRQ lockup, cleared int mask&bslash;n&quot;
comma
id|CARD
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
DECL|function|zoran_muxsel
r_int
id|zoran_muxsel
c_func
(paren
r_struct
id|zoran
op_star
id|ztv
comma
r_int
id|channel
comma
r_int
id|norm
)paren
(brace
r_int
id|rv
suffix:semicolon
multiline_comment|/* set the new video norm */
id|rv
op_assign
id|i2c_control_device
c_func
(paren
op_amp
(paren
id|ztv-&gt;i2c
)paren
comma
id|I2C_DRIVERID_VIDEODECODER
comma
id|DECODER_SET_NORM
comma
op_amp
id|norm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
r_return
id|rv
suffix:semicolon
id|ztv-&gt;norm
op_assign
id|norm
suffix:semicolon
multiline_comment|/* map the given channel to the cards decoder&squot;s channel */
id|channel
op_assign
id|ztv-&gt;card-&gt;video_mux
(braket
id|channel
)braket
op_amp
id|CHANNEL_MASK
suffix:semicolon
multiline_comment|/* set the new channel */
id|rv
op_assign
id|i2c_control_device
c_func
(paren
op_amp
(paren
id|ztv-&gt;i2c
)paren
comma
id|I2C_DRIVERID_VIDEODECODER
comma
id|DECODER_SET_INPUT
comma
op_amp
id|channel
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/* Tell the interrupt handler what to to.  */
r_static
DECL|function|zoran_cap
r_void
id|zoran_cap
c_func
(paren
r_struct
id|zoran
op_star
id|ztv
comma
r_int
id|on
)paren
(brace
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;zoran_cap(%d) state=%x&bslash;n&quot;
comma
id|CARD
comma
id|on
comma
id|ztv-&gt;state
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|on
)paren
(brace
id|ztv-&gt;running
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * turn interrupts (back) on. The DMA will be enabled&n;&t;&t; * inside the irq handler when it detects a restart.&n;&t;&t; */
id|zror
c_func
(paren
id|ZORAN_ICR_EN
comma
id|ZORAN_ICR
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * turn both interrupts and DMA off&n;&t;&t; */
id|zrand
c_func
(paren
op_complement
id|ZORAN_VDC_VIDEN
comma
id|ZORAN_VDC
)paren
suffix:semicolon
id|zrand
c_func
(paren
op_complement
id|ZORAN_ICR_EN
comma
id|ZORAN_ICR
)paren
suffix:semicolon
id|ztv-&gt;running
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|variable|dmask
r_static
id|ulong
id|dmask
(braket
)braket
op_assign
(brace
l_int|0xFFFFFFFF
comma
l_int|0xFFFFFFFE
comma
l_int|0xFFFFFFFC
comma
l_int|0xFFFFFFF8
comma
l_int|0xFFFFFFF0
comma
l_int|0xFFFFFFE0
comma
l_int|0xFFFFFFC0
comma
l_int|0xFFFFFF80
comma
l_int|0xFFFFFF00
comma
l_int|0xFFFFFE00
comma
l_int|0xFFFFFC00
comma
l_int|0xFFFFF800
comma
l_int|0xFFFFF000
comma
l_int|0xFFFFE000
comma
l_int|0xFFFFC000
comma
l_int|0xFFFF8000
comma
l_int|0xFFFF0000
comma
l_int|0xFFFE0000
comma
l_int|0xFFFC0000
comma
l_int|0xFFF80000
comma
l_int|0xFFF00000
comma
l_int|0xFFE00000
comma
l_int|0xFFC00000
comma
l_int|0xFF800000
comma
l_int|0xFF000000
comma
l_int|0xFE000000
comma
l_int|0xFC000000
comma
l_int|0xF8000000
comma
l_int|0xF0000000
comma
l_int|0xE0000000
comma
l_int|0xC0000000
comma
l_int|0x80000000
)brace
suffix:semicolon
r_static
DECL|function|zoran_built_overlay
r_void
id|zoran_built_overlay
c_func
(paren
r_struct
id|zoran
op_star
id|ztv
comma
r_int
id|count
comma
r_struct
id|video_clip
op_star
id|vcp
)paren
(brace
id|ulong
op_star
id|mtop
suffix:semicolon
r_int
id|ystep
op_assign
(paren
id|ztv-&gt;vidXshift
op_plus
id|ztv-&gt;vidWidth
op_plus
l_int|31
)paren
op_div
l_int|32
suffix:semicolon
multiline_comment|/* next DWORD */
r_int
id|i
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;       overlay at %p, ystep=%d, clips=%d&bslash;n&quot;
comma
id|ztv-&gt;overinfo.overlay
comma
id|ystep
comma
id|count
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|video_clip
op_star
id|vp
op_assign
id|vcp
op_plus
id|i
suffix:semicolon
id|UNUSED
c_func
(paren
id|vp
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;       %d: clip(%d,%d,%d,%d)&bslash;n&quot;
comma
id|i
comma
id|vp-&gt;x
comma
id|vp-&gt;y
comma
id|vp-&gt;width
comma
id|vp-&gt;height
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * activate the visible portion of the screen&n;&t; * Note we take some shortcuts here, because we&n;&t; * know the width can never be &lt; 32. (I.e. a DWORD)&n;&t; * We also assume the overlay starts somewhere in&n;&t; * the FIRST dword.&n;&t; */
(brace
r_int
id|start
op_assign
id|ztv-&gt;vidXshift
suffix:semicolon
id|ulong
id|firstd
op_assign
id|dmask
(braket
id|start
)braket
suffix:semicolon
id|ulong
id|lastd
op_assign
op_complement
id|dmask
(braket
(paren
id|start
op_plus
id|ztv-&gt;overinfo.w
)paren
op_amp
l_int|31
)braket
suffix:semicolon
id|mtop
op_assign
id|ztv-&gt;overinfo.overlay
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ztv-&gt;overinfo.h
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|w
op_assign
id|ztv-&gt;vidWidth
suffix:semicolon
id|ulong
op_star
id|line
op_assign
id|mtop
suffix:semicolon
r_if
c_cond
(paren
id|start
op_amp
l_int|31
)paren
(brace
op_star
id|line
op_increment
op_assign
id|firstd
suffix:semicolon
id|w
op_sub_assign
l_int|32
op_minus
(paren
id|start
op_amp
l_int|31
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|line
comma
op_complement
l_int|0
comma
id|w
op_div
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|w
op_amp
l_int|31
)paren
id|line
(braket
id|w
op_div
l_int|32
)braket
op_assign
id|lastd
suffix:semicolon
id|mtop
op_add_assign
id|ystep
suffix:semicolon
)brace
)brace
multiline_comment|/* process clipping regions */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|h
suffix:semicolon
r_if
c_cond
(paren
id|vcp-&gt;x
template_param
id|ztv-&gt;overinfo.w
op_logical_or
id|vcp-&gt;y
template_param
id|ztv-&gt;overinfo.h
op_logical_or
id|vcp-&gt;width
template_param
id|ztv-&gt;overinfo.w
op_logical_or
id|vcp-&gt;height
template_param
id|ztv-&gt;overinfo.h
)paren
(brace
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;illegal clipzone (%d,%d,%d,%d) not in (0,0,%d,%d), adapting&bslash;n&quot;
comma
id|CARD
comma
id|vcp-&gt;x
comma
id|vcp-&gt;y
comma
id|vcp-&gt;width
comma
id|vcp-&gt;height
comma
id|ztv-&gt;overinfo.w
comma
id|ztv-&gt;overinfo.h
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vcp-&gt;x
OL
l_int|0
)paren
id|vcp-&gt;x
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uint
)paren
id|vcp-&gt;x
OG
id|ztv-&gt;overinfo.w
)paren
id|vcp-&gt;x
op_assign
id|ztv-&gt;overinfo.w
suffix:semicolon
r_if
c_cond
(paren
id|vcp-&gt;y
OL
l_int|0
)paren
id|vcp-&gt;y
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vcp-&gt;y
OG
id|ztv-&gt;overinfo.h
)paren
id|vcp-&gt;y
op_assign
id|ztv-&gt;overinfo.h
suffix:semicolon
r_if
c_cond
(paren
id|vcp-&gt;width
OL
l_int|0
)paren
id|vcp-&gt;width
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uint
)paren
(paren
id|vcp-&gt;x
op_plus
id|vcp-&gt;width
)paren
OG
id|ztv-&gt;overinfo.w
)paren
id|vcp-&gt;width
op_assign
id|ztv-&gt;overinfo.w
op_minus
id|vcp-&gt;x
suffix:semicolon
r_if
c_cond
(paren
id|vcp-&gt;height
OL
l_int|0
)paren
id|vcp-&gt;height
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vcp-&gt;y
op_plus
id|vcp-&gt;height
OG
id|ztv-&gt;overinfo.h
)paren
id|vcp-&gt;height
op_assign
id|ztv-&gt;overinfo.h
op_minus
id|vcp-&gt;y
suffix:semicolon
singleline_comment|//&t;&t;&t;continue;
)brace
id|mtop
op_assign
op_amp
id|ztv-&gt;overinfo.overlay
(braket
id|vcp-&gt;y
op_star
id|ystep
)braket
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
op_le
id|vcp-&gt;height
suffix:semicolon
id|h
op_increment
)paren
(brace
r_int
id|w
suffix:semicolon
r_int
id|x
op_assign
id|ztv-&gt;vidXshift
op_plus
id|vcp-&gt;x
suffix:semicolon
r_for
c_loop
(paren
id|w
op_assign
l_int|0
suffix:semicolon
id|w
op_le
id|vcp-&gt;width
suffix:semicolon
id|w
op_increment
)paren
(brace
id|clear_bit
c_func
(paren
id|x
op_amp
l_int|31
comma
op_amp
id|mtop
(braket
id|x
op_div
l_int|32
)braket
)paren
suffix:semicolon
id|x
op_increment
suffix:semicolon
)brace
id|mtop
op_add_assign
id|ystep
suffix:semicolon
)brace
op_increment
id|vcp
suffix:semicolon
)brace
id|mtop
op_assign
id|ztv-&gt;overinfo.overlay
suffix:semicolon
id|zrwrite
c_func
(paren
id|virt_to_bus
c_func
(paren
id|mtop
)paren
comma
id|ZORAN_MTOP
)paren
suffix:semicolon
id|zrwrite
c_func
(paren
id|virt_to_bus
c_func
(paren
id|mtop
op_plus
id|ystep
)paren
comma
id|ZORAN_MBOT
)paren
suffix:semicolon
id|zraor
c_func
(paren
(paren
id|ztv-&gt;vidInterlace
op_star
id|ystep
)paren
op_lshift
l_int|0
comma
op_complement
id|ZORAN_OCR_MASKSTRIDE
comma
id|ZORAN_OCR
)paren
suffix:semicolon
)brace
DECL|struct|tvnorm
r_struct
id|tvnorm
(brace
DECL|member|Wt
DECL|member|Wa
DECL|member|Ht
DECL|member|Ha
DECL|member|HStart
DECL|member|VStart
id|u16
id|Wt
comma
id|Wa
comma
id|Ht
comma
id|Ha
comma
id|HStart
comma
id|VStart
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|tvnorms
r_static
r_struct
id|tvnorm
id|tvnorms
(braket
)braket
op_assign
(brace
multiline_comment|/* PAL-BDGHI */
multiline_comment|/*&t;{ 864, 720, 625, 576, 131, 21 },*/
multiline_comment|/*00*/
(brace
l_int|864
comma
l_int|768
comma
l_int|625
comma
l_int|576
comma
l_int|81
comma
l_int|17
)brace
comma
multiline_comment|/* NTSC */
multiline_comment|/*01*/
(brace
l_int|858
comma
l_int|720
comma
l_int|525
comma
l_int|480
comma
l_int|121
comma
l_int|10
)brace
comma
multiline_comment|/* SECAM */
multiline_comment|/*02*/
(brace
l_int|864
comma
l_int|720
comma
l_int|625
comma
l_int|576
comma
l_int|131
comma
l_int|21
)brace
comma
multiline_comment|/* BW50 */
multiline_comment|/*03*/
(brace
l_int|864
comma
l_int|720
comma
l_int|625
comma
l_int|576
comma
l_int|131
comma
l_int|21
)brace
comma
multiline_comment|/* BW60 */
multiline_comment|/*04*/
(brace
l_int|858
comma
l_int|720
comma
l_int|525
comma
l_int|480
comma
l_int|121
comma
l_int|10
)brace
)brace
suffix:semicolon
DECL|macro|TVNORMS
mdefine_line|#define TVNORMS (sizeof(tvnorms)/sizeof(tvnorm))
multiline_comment|/*&n; * Program the chip for a setup as described in the vidinfo struct.&n; *&n; * Side-effects: calculates vidXshift, vidInterlace,&n; * vidHeight, vidWidth which are used in a later stage&n; * to calculate the overlay mask&n; *&n; * This is an internal function, as such it does not check the&n; * validity of the struct members... Spectaculair crashes will&n; * follow /very/ quick when you&squot;re wrong and the chip right :)&n; */
r_static
DECL|function|zoran_set_geo
r_void
id|zoran_set_geo
c_func
(paren
r_struct
id|zoran
op_star
id|ztv
comma
r_struct
id|vidinfo
op_star
id|i
)paren
(brace
id|ulong
id|top
comma
id|bot
suffix:semicolon
r_int
id|stride
suffix:semicolon
r_int
id|winWidth
comma
id|winHeight
suffix:semicolon
r_int
id|maxWidth
comma
id|maxHeight
comma
id|maxXOffset
comma
id|maxYOffset
suffix:semicolon
r_int
id|vfec
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;set_geo(rect=(%d,%d,%d,%d), norm=%d, format=%d, bpp=%d, bpl=%d, busadr=%lx, overlay=%p)&bslash;n&quot;
comma
id|CARD
comma
id|i-&gt;x
comma
id|i-&gt;y
comma
id|i-&gt;w
comma
id|i-&gt;h
comma
id|ztv-&gt;norm
comma
id|i-&gt;format
comma
id|i-&gt;bpp
comma
id|i-&gt;bpl
comma
id|i-&gt;busadr
comma
id|i-&gt;overlay
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * make sure the DMA transfers are inhibited during our&n;&t; * reprogramming of the chip&n;&t; */
id|zrand
c_func
(paren
op_complement
id|ZORAN_VDC_VIDEN
comma
id|ZORAN_VDC
)paren
suffix:semicolon
id|maxWidth
op_assign
id|tvnorms
(braket
id|ztv-&gt;norm
)braket
dot
id|Wa
suffix:semicolon
id|maxHeight
op_assign
id|tvnorms
(braket
id|ztv-&gt;norm
)braket
dot
id|Ha
op_div
l_int|2
suffix:semicolon
id|maxXOffset
op_assign
id|tvnorms
(braket
id|ztv-&gt;norm
)braket
dot
id|HStart
suffix:semicolon
id|maxYOffset
op_assign
id|tvnorms
(braket
id|ztv-&gt;norm
)braket
dot
id|VStart
suffix:semicolon
multiline_comment|/* setup vfec register (keep ExtFl,TopField and VCLKPol settings) */
id|vfec
op_assign
(paren
id|zrread
c_func
(paren
id|ZORAN_VFEC
)paren
op_amp
(paren
id|ZORAN_VFEC_EXTFL
op_or
id|ZORAN_VFEC_TOPFIELD
op_or
id|ZORAN_VFEC_VCLKPOL
)paren
)paren
op_or
(paren
id|palette2fmt
(braket
id|i-&gt;format
)braket
dot
id|mode
op_amp
(paren
id|ZORAN_VFEC_RGB
op_or
id|ZORAN_VFEC_ERRDIF
op_or
id|ZORAN_VFEC_LE
op_or
id|ZORAN_VFEC_PACK24
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set top, bottom ptrs. Since these must be DWORD aligned,&n;&t; * possible adjust the x and the width of the window.&n;&t; * so the endposition stay the same. The vidXshift will make&n;&t; * sure we are not writing pixels before the requested x.&n;&t; */
id|ztv-&gt;vidXshift
op_assign
l_int|0
suffix:semicolon
id|winWidth
op_assign
id|i-&gt;w
suffix:semicolon
r_if
c_cond
(paren
id|winWidth
OL
l_int|0
)paren
id|winWidth
op_assign
op_minus
id|winWidth
suffix:semicolon
id|top
op_assign
id|i-&gt;busadr
op_plus
id|i-&gt;x
op_star
id|i-&gt;bpp
op_plus
id|i-&gt;y
op_star
id|i-&gt;bpl
suffix:semicolon
r_if
c_cond
(paren
id|top
op_amp
l_int|3
)paren
(brace
id|ztv-&gt;vidXshift
op_assign
(paren
id|top
op_amp
l_int|3
)paren
op_div
id|i-&gt;bpp
suffix:semicolon
id|winWidth
op_add_assign
id|ztv-&gt;vidXshift
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;       window-x shifted %d pixels left&bslash;n&quot;
comma
id|ztv-&gt;vidXshift
)paren
)paren
suffix:semicolon
id|top
op_and_assign
op_complement
l_int|3
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * bottom points to next frame but in interleaved mode we want&n;&t; * to &squot;mix&squot; the 2 frames to one capture, so &squot;bot&squot; points to one&n;&t; * (physical) line below the top line.&n;&t; */
id|bot
op_assign
id|top
op_plus
id|i-&gt;bpl
suffix:semicolon
id|zrwrite
c_func
(paren
id|top
comma
id|ZORAN_VTOP
)paren
suffix:semicolon
id|zrwrite
c_func
(paren
id|bot
comma
id|ZORAN_VBOT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure the winWidth is DWORD aligned too,&n;&t; * thereby automaticly making sure the stride to the&n;&t; * next line is DWORD aligned too (as required by spec).&n;&t; */
r_if
c_cond
(paren
(paren
id|winWidth
op_star
id|i-&gt;bpp
)paren
op_amp
l_int|3
)paren
(brace
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;       window-width enlarged by %d pixels&bslash;n&quot;
comma
(paren
id|winWidth
op_star
id|i-&gt;bpp
)paren
op_amp
l_int|3
)paren
)paren
suffix:semicolon
id|winWidth
op_add_assign
(paren
id|winWidth
op_star
id|i-&gt;bpp
)paren
op_amp
l_int|3
suffix:semicolon
)brace
multiline_comment|/* determine the DispMode and stride */
r_if
c_cond
(paren
id|i-&gt;h
op_ge
l_int|0
op_logical_and
id|i-&gt;h
op_le
id|maxHeight
)paren
(brace
multiline_comment|/* single frame grab suffices for this height. */
id|vfec
op_or_assign
id|ZORAN_VFEC_DISPMOD
suffix:semicolon
id|ztv-&gt;vidInterlace
op_assign
l_int|0
suffix:semicolon
id|stride
op_assign
id|i-&gt;bpl
op_minus
(paren
id|winWidth
op_star
id|i-&gt;bpp
)paren
suffix:semicolon
id|winHeight
op_assign
id|i-&gt;h
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* interleaving needed for this height */
id|ztv-&gt;vidInterlace
op_assign
l_int|1
suffix:semicolon
id|stride
op_assign
id|i-&gt;bpl
op_star
l_int|2
op_minus
(paren
id|winWidth
op_star
id|i-&gt;bpp
)paren
suffix:semicolon
id|winHeight
op_assign
id|i-&gt;h
op_div
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|winHeight
OL
l_int|0
)paren
multiline_comment|/* can happen for VBI! */
id|winHeight
op_assign
op_minus
id|winHeight
suffix:semicolon
multiline_comment|/* safety net, sometimes bpl is too short??? */
r_if
c_cond
(paren
id|stride
OL
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;WARNING stride = %d&bslash;n&quot;
comma
id|CARD
comma
id|stride
)paren
)paren
suffix:semicolon
id|stride
op_assign
l_int|0
suffix:semicolon
)brace
id|zraor
c_func
(paren
(paren
id|winHeight
op_lshift
l_int|12
)paren
op_or
(paren
id|winWidth
op_lshift
l_int|0
)paren
comma
op_complement
(paren
id|ZORAN_VDC_VIDWINHT
op_or
id|ZORAN_VDC_VIDWINWID
)paren
comma
id|ZORAN_VDC
)paren
suffix:semicolon
id|zraor
c_func
(paren
id|stride
op_lshift
l_int|16
comma
op_complement
id|ZORAN_VSTR_DISPSTRIDE
comma
id|ZORAN_VSTR
)paren
suffix:semicolon
multiline_comment|/* remember vidWidth, vidHeight for overlay calculations */
id|ztv-&gt;vidWidth
op_assign
id|winWidth
suffix:semicolon
id|ztv-&gt;vidHeight
op_assign
id|winHeight
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;       top=%08lx, bottom=%08lx&bslash;n&quot;
comma
id|top
comma
id|bot
)paren
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;       winWidth=%d, winHeight=%d&bslash;n&quot;
comma
id|winWidth
comma
id|winHeight
)paren
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;       maxWidth=%d, maxHeight=%d&bslash;n&quot;
comma
id|maxWidth
comma
id|maxHeight
)paren
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;       stride=%d&bslash;n&quot;
comma
id|stride
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * determine horizontal scales and crops&n;&t; */
r_if
c_cond
(paren
id|i-&gt;w
OL
l_int|0
)paren
(brace
r_int
id|Hstart
op_assign
l_int|1
suffix:semicolon
r_int
id|Hend
op_assign
id|Hstart
op_plus
id|winWidth
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;       Y: scale=0, start=%d, end=%d&bslash;n&quot;
comma
id|Hstart
comma
id|Hend
)paren
)paren
suffix:semicolon
id|zraor
c_func
(paren
(paren
id|Hstart
op_lshift
l_int|10
)paren
op_or
(paren
id|Hend
op_lshift
l_int|0
)paren
comma
op_complement
(paren
id|ZORAN_VFEH_HSTART
op_or
id|ZORAN_VFEH_HEND
)paren
comma
id|ZORAN_VFEH
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|Wa
op_assign
id|maxWidth
suffix:semicolon
r_int
id|X
op_assign
(paren
id|winWidth
op_star
l_int|64
op_plus
id|Wa
op_minus
l_int|1
)paren
op_div
id|Wa
suffix:semicolon
r_int
id|We
op_assign
id|winWidth
op_star
l_int|64
op_div
id|X
suffix:semicolon
r_int
id|HorDcm
op_assign
l_int|64
op_minus
id|X
suffix:semicolon
r_int
id|hcrop1
op_assign
l_int|2
op_star
(paren
id|Wa
op_minus
id|We
)paren
op_div
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t;&t; * BUGFIX: Juha Nurmela &lt;junki@qn-lpr2-165.quicknet.inet.fi&gt; &n;&t;&t; * found the solution to the color phase shift.&n;&t;&t; * See ChangeLog for the full explanation)&n;&t;&t; */
r_int
id|Hstart
op_assign
(paren
id|maxXOffset
op_plus
id|hcrop1
)paren
op_or
l_int|1
suffix:semicolon
r_int
id|Hend
op_assign
id|Hstart
op_plus
id|We
op_minus
l_int|1
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;       X: scale=%d, start=%d, end=%d&bslash;n&quot;
comma
id|HorDcm
comma
id|Hstart
comma
id|Hend
)paren
)paren
suffix:semicolon
id|zraor
c_func
(paren
(paren
id|Hstart
op_lshift
l_int|10
)paren
op_or
(paren
id|Hend
op_lshift
l_int|0
)paren
comma
op_complement
(paren
id|ZORAN_VFEH_HSTART
op_or
id|ZORAN_VFEH_HEND
)paren
comma
id|ZORAN_VFEH
)paren
suffix:semicolon
id|vfec
op_or_assign
id|HorDcm
op_lshift
l_int|14
suffix:semicolon
r_if
c_cond
(paren
id|HorDcm
OL
l_int|16
)paren
id|vfec
op_or_assign
id|ZORAN_VFEC_HFILTER_1
suffix:semicolon
multiline_comment|/* no filter */
r_else
r_if
c_cond
(paren
id|HorDcm
OL
l_int|32
)paren
id|vfec
op_or_assign
id|ZORAN_VFEC_HFILTER_3
suffix:semicolon
multiline_comment|/* 3 tap filter */
r_else
r_if
c_cond
(paren
id|HorDcm
OL
l_int|48
)paren
id|vfec
op_or_assign
id|ZORAN_VFEC_HFILTER_4
suffix:semicolon
multiline_comment|/* 4 tap filter */
r_else
id|vfec
op_or_assign
id|ZORAN_VFEC_HFILTER_5
suffix:semicolon
multiline_comment|/* 5 tap filter */
)brace
multiline_comment|/*&n;&t; * Determine vertical scales and crops&n;&t; *&n;&t; * when height is negative, we want to read starting at line 0&n;&t; * One day someone might need access to these lines...&n;&t; */
r_if
c_cond
(paren
id|i-&gt;h
OL
l_int|0
)paren
(brace
r_int
id|Vstart
op_assign
l_int|0
suffix:semicolon
r_int
id|Vend
op_assign
id|Vstart
op_plus
id|winHeight
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;       Y: scale=0, start=%d, end=%d&bslash;n&quot;
comma
id|Vstart
comma
id|Vend
)paren
)paren
suffix:semicolon
id|zraor
c_func
(paren
(paren
id|Vstart
op_lshift
l_int|10
)paren
op_or
(paren
id|Vend
op_lshift
l_int|0
)paren
comma
op_complement
(paren
id|ZORAN_VFEV_VSTART
op_or
id|ZORAN_VFEV_VEND
)paren
comma
id|ZORAN_VFEV
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|Ha
op_assign
id|maxHeight
suffix:semicolon
r_int
id|Y
op_assign
(paren
id|winHeight
op_star
l_int|64
op_plus
id|Ha
op_minus
l_int|1
)paren
op_div
id|Ha
suffix:semicolon
r_int
id|He
op_assign
id|winHeight
op_star
l_int|64
op_div
id|Y
suffix:semicolon
r_int
id|VerDcm
op_assign
l_int|64
op_minus
id|Y
suffix:semicolon
r_int
id|vcrop1
op_assign
l_int|2
op_star
(paren
id|Ha
op_minus
id|He
)paren
op_div
l_int|4
suffix:semicolon
r_int
id|Vstart
op_assign
id|maxYOffset
op_plus
id|vcrop1
suffix:semicolon
r_int
id|Vend
op_assign
id|Vstart
op_plus
id|He
op_minus
l_int|1
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;       Y: scale=%d, start=%d, end=%d&bslash;n&quot;
comma
id|VerDcm
comma
id|Vstart
comma
id|Vend
)paren
)paren
suffix:semicolon
id|zraor
c_func
(paren
(paren
id|Vstart
op_lshift
l_int|10
)paren
op_or
(paren
id|Vend
op_lshift
l_int|0
)paren
comma
op_complement
(paren
id|ZORAN_VFEV_VSTART
op_or
id|ZORAN_VFEV_VEND
)paren
comma
id|ZORAN_VFEV
)paren
suffix:semicolon
id|vfec
op_or_assign
id|VerDcm
op_lshift
l_int|8
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;       F: format=%d(=%s)&bslash;n&quot;
comma
id|i-&gt;format
comma
id|palette2fmt
(braket
id|i-&gt;format
)braket
dot
id|name
)paren
)paren
suffix:semicolon
multiline_comment|/* setup the requested format */
id|zrwrite
c_func
(paren
id|vfec
comma
id|ZORAN_VFEC
)paren
suffix:semicolon
)brace
r_static
DECL|function|zoran_common_open
r_void
id|zoran_common_open
c_func
(paren
r_struct
id|zoran
op_star
id|ztv
comma
r_int
id|flags
)paren
(brace
id|UNUSED
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* already opened? */
r_if
c_cond
(paren
id|ztv-&gt;users
op_increment
op_ne
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* unmute audio */
multiline_comment|/* /what/ audio? */
id|ztv-&gt;state
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* setup the encoder to the initial values */
id|ztv-&gt;picture.colour
op_assign
l_int|254
op_lshift
l_int|7
suffix:semicolon
id|ztv-&gt;picture.brightness
op_assign
l_int|128
op_lshift
l_int|8
suffix:semicolon
id|ztv-&gt;picture.hue
op_assign
l_int|128
op_lshift
l_int|8
suffix:semicolon
id|ztv-&gt;picture.contrast
op_assign
l_int|216
op_lshift
l_int|7
suffix:semicolon
id|i2c_control_device
c_func
(paren
op_amp
id|ztv-&gt;i2c
comma
id|I2C_DRIVERID_VIDEODECODER
comma
id|DECODER_SET_PICTURE
comma
op_amp
id|ztv-&gt;picture
)paren
suffix:semicolon
multiline_comment|/* default to the composite input since my camera is there */
id|zoran_muxsel
c_func
(paren
id|ztv
comma
l_int|0
comma
id|VIDEO_MODE_PAL
)paren
suffix:semicolon
)brace
r_static
DECL|function|zoran_common_close
r_void
id|zoran_common_close
c_func
(paren
r_struct
id|zoran
op_star
id|ztv
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|ztv-&gt;users
op_ne
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* mute audio */
multiline_comment|/* /what/ audio? */
multiline_comment|/* stop the chip */
id|zoran_cap
c_func
(paren
id|ztv
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Open a zoran card. Right now the flags are just a hack&n; */
DECL|function|zoran_open
r_static
r_int
id|zoran_open
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_int
id|flags
)paren
(brace
r_struct
id|zoran
op_star
id|ztv
op_assign
(paren
r_struct
id|zoran
op_star
)paren
id|dev
suffix:semicolon
r_struct
id|vidinfo
op_star
id|item
suffix:semicolon
r_char
op_star
id|pos
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;open(dev,%d)&bslash;n&quot;
comma
id|CARD
comma
id|flags
)paren
)paren
suffix:semicolon
multiline_comment|/*********************************************&n;&t; * We really should be doing lazy allocing...&n;&t; *********************************************/
multiline_comment|/* allocate a frame buffer */
r_if
c_cond
(paren
op_logical_neg
id|ztv-&gt;fbuffer
)paren
id|ztv-&gt;fbuffer
op_assign
id|bmalloc
c_func
(paren
id|ZORAN_MAX_FBUFSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ztv-&gt;fbuffer
)paren
(brace
multiline_comment|/* could not get a buffer, bail out */
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
multiline_comment|/* at this time we _always_ have a framebuffer */
id|memset
c_func
(paren
id|ztv-&gt;fbuffer
comma
l_int|0
comma
id|ZORAN_MAX_FBUFSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ztv-&gt;overinfo.overlay
)paren
id|ztv-&gt;overinfo.overlay
op_assign
(paren
r_void
op_star
)paren
id|kmalloc
c_func
(paren
l_int|1024
op_star
l_int|1024
op_div
l_int|8
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ztv-&gt;overinfo.overlay
)paren
(brace
multiline_comment|/* could not get an overlay buffer, bail out */
id|bfree
c_func
(paren
id|ztv-&gt;fbuffer
comma
id|ZORAN_MAX_FBUFSIZE
)paren
suffix:semicolon
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
multiline_comment|/* at this time we _always_ have a overlay */
multiline_comment|/* clear buffer status, and give them a DMAable address */
id|pos
op_assign
id|ztv-&gt;fbuffer
suffix:semicolon
r_for
c_loop
(paren
id|item
op_assign
id|ztv-&gt;grabinfo
suffix:semicolon
id|item
op_ne
id|ztv-&gt;grabinfo
op_plus
id|ZORAN_MAX_FBUFFERS
suffix:semicolon
id|item
op_increment
)paren
(brace
id|item-&gt;status
op_assign
id|FBUFFER_FREE
suffix:semicolon
id|item-&gt;memadr
op_assign
id|pos
suffix:semicolon
id|item-&gt;busadr
op_assign
id|virt_to_bus
c_func
(paren
id|pos
)paren
suffix:semicolon
id|pos
op_add_assign
id|ZORAN_MAX_FBUFFER
suffix:semicolon
)brace
multiline_comment|/* do the common part of all open&squot;s */
id|zoran_common_open
c_func
(paren
id|ztv
comma
id|flags
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
DECL|function|zoran_close
r_void
id|zoran_close
c_func
(paren
r_struct
id|video_device
op_star
id|dev
)paren
(brace
r_struct
id|zoran
op_star
id|ztv
op_assign
(paren
r_struct
id|zoran
op_star
)paren
id|dev
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;close(dev)&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
multiline_comment|/* driver specific closure */
id|clear_bit
c_func
(paren
id|STATE_OVERLAY
comma
op_amp
id|ztv-&gt;state
)paren
suffix:semicolon
id|zoran_common_close
c_func
(paren
id|ztv
)paren
suffix:semicolon
multiline_comment|/*&n;         *      This is sucky but right now I can&squot;t find a good way to&n;         *      be sure its safe to free the buffer. We wait 5-6 fields&n;         *      which is more than sufficient to be sure.&n;         */
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Wait 1/10th of a second */
multiline_comment|/* free the allocated framebuffer */
r_if
c_cond
(paren
id|ztv-&gt;fbuffer
)paren
id|bfree
c_func
(paren
id|ztv-&gt;fbuffer
comma
id|ZORAN_MAX_FBUFSIZE
)paren
suffix:semicolon
id|ztv-&gt;fbuffer
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ztv-&gt;overinfo.overlay
)paren
id|kfree
c_func
(paren
id|ztv-&gt;overinfo.overlay
)paren
suffix:semicolon
id|ztv-&gt;overinfo.overlay
op_assign
l_int|0
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/*&n; * This read function could be used reentrant in a SMP situation.&n; *&n; * This is made possible by the spinlock which is kept till we&n; * found and marked a buffer for our own use. The lock must&n; * be released as soon as possible to prevent lock contention.&n; */
r_static
DECL|function|zoran_read
r_int
id|zoran_read
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|count
comma
r_int
id|nonblock
)paren
(brace
r_struct
id|zoran
op_star
id|ztv
op_assign
(paren
r_struct
id|zoran
op_star
)paren
id|dev
suffix:semicolon
r_int
r_int
id|max
suffix:semicolon
r_struct
id|vidinfo
op_star
id|unused
op_assign
l_int|0
suffix:semicolon
r_struct
id|vidinfo
op_star
id|done
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;zoran_read(%p,%ld,%d)&bslash;n&quot;
comma
id|CARD
comma
id|buf
comma
id|count
comma
id|nonblock
)paren
)paren
suffix:semicolon
multiline_comment|/* find ourself a free or completed buffer */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|vidinfo
op_star
id|item
suffix:semicolon
id|write_lock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|item
op_assign
id|ztv-&gt;grabinfo
suffix:semicolon
id|item
op_ne
id|ztv-&gt;grabinfo
op_plus
id|ZORAN_MAX_FBUFFERS
suffix:semicolon
id|item
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|unused
op_logical_and
id|item-&gt;status
op_eq
id|FBUFFER_FREE
)paren
id|unused
op_assign
id|item
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|done
op_logical_and
id|item-&gt;status
op_eq
id|FBUFFER_DONE
)paren
id|done
op_assign
id|item
suffix:semicolon
)brace
r_if
c_cond
(paren
id|done
op_logical_or
id|unused
)paren
r_break
suffix:semicolon
multiline_comment|/* no more free buffers, wait for them. */
id|write_unlock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nonblock
)paren
r_return
op_minus
id|EWOULDBLOCK
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|ztv-&gt;grabq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
multiline_comment|/* Do we have &squot;ready&squot; data? */
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
(brace
multiline_comment|/* no? than this will take a while... */
r_if
c_cond
(paren
id|nonblock
)paren
(brace
id|write_unlock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
r_return
op_minus
id|EWOULDBLOCK
suffix:semicolon
)brace
multiline_comment|/* mark the unused buffer as wanted */
id|unused-&gt;status
op_assign
id|FBUFFER_BUSY
suffix:semicolon
id|unused-&gt;w
op_assign
l_int|320
suffix:semicolon
id|unused-&gt;h
op_assign
l_int|240
suffix:semicolon
id|unused-&gt;format
op_assign
id|VIDEO_PALETTE_RGB24
suffix:semicolon
id|unused-&gt;bpp
op_assign
id|palette2fmt
(braket
id|unused-&gt;format
)braket
dot
id|bpp
suffix:semicolon
id|unused-&gt;bpl
op_assign
id|unused-&gt;w
op_star
id|unused-&gt;bpp
suffix:semicolon
id|unused-&gt;next
op_assign
l_int|0
suffix:semicolon
(brace
multiline_comment|/* add to tail of queue */
r_struct
id|vidinfo
op_star
id|oldframe
op_assign
id|ztv-&gt;workqueue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|oldframe
)paren
id|ztv-&gt;workqueue
op_assign
id|unused
suffix:semicolon
r_else
(brace
r_while
c_loop
(paren
id|oldframe-&gt;next
)paren
id|oldframe
op_assign
id|oldframe-&gt;next
suffix:semicolon
id|oldframe-&gt;next
op_assign
id|unused
suffix:semicolon
)brace
)brace
id|write_unlock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* tell the state machine we want it filled /NOW/ */
id|zoran_cap
c_func
(paren
id|ztv
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* wait till this buffer gets grabbed */
r_while
c_loop
(paren
id|unused-&gt;status
op_eq
id|FBUFFER_BUSY
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|ztv-&gt;grabq
)paren
suffix:semicolon
multiline_comment|/* see if a signal did it */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|done
op_assign
id|unused
suffix:semicolon
)brace
r_else
id|write_unlock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Yes! we got data! */
id|max
op_assign
id|done-&gt;bpl
op_star
id|done-&gt;h
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|max
)paren
id|count
op_assign
id|max
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|buf
comma
id|done-&gt;memadr
comma
id|count
)paren
)paren
id|count
op_assign
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* keep the engine running */
id|done-&gt;status
op_assign
id|FBUFFER_FREE
suffix:semicolon
singleline_comment|//&t;zoran_cap(ztv,1);
multiline_comment|/* tell listeners this buffer became free */
id|wake_up_interruptible
c_func
(paren
op_amp
id|ztv-&gt;grabq
)paren
suffix:semicolon
multiline_comment|/* goodbye */
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;zoran_read() returns %lu&bslash;n&quot;
comma
id|CARD
comma
id|count
)paren
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_static
DECL|function|zoran_write
r_int
id|zoran_write
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|count
comma
r_int
id|nonblock
)paren
(brace
r_struct
id|zoran
op_star
id|ztv
op_assign
(paren
r_struct
id|zoran
op_star
)paren
id|dev
suffix:semicolon
id|UNUSED
c_func
(paren
id|ztv
)paren
suffix:semicolon
id|UNUSED
c_func
(paren
id|dev
)paren
suffix:semicolon
id|UNUSED
c_func
(paren
id|buf
)paren
suffix:semicolon
id|UNUSED
c_func
(paren
id|count
)paren
suffix:semicolon
id|UNUSED
c_func
(paren
id|nonblock
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;zoran_write&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &gt;= 0x020100
r_static
DECL|function|zoran_poll
r_int
r_int
id|zoran_poll
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|zoran
op_star
id|ztv
op_assign
(paren
r_struct
id|zoran
op_star
)paren
id|dev
suffix:semicolon
r_struct
id|vidinfo
op_star
id|item
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|ztv-&gt;grabq
comma
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
id|item
op_assign
id|ztv-&gt;grabinfo
suffix:semicolon
id|item
op_ne
id|ztv-&gt;grabinfo
op_plus
id|ZORAN_MAX_FBUFFERS
suffix:semicolon
id|item
op_increment
)paren
r_if
c_cond
(paren
id|item-&gt;status
op_eq
id|FBUFFER_DONE
)paren
(brace
id|mask
op_or_assign
(paren
id|POLLIN
op_or
id|POLLRDNORM
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;zoran_poll()=%x&bslash;n&quot;
comma
id|CARD
comma
id|mask
)paren
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* append a new clipregion to the vector of video_clips */
r_static
DECL|function|new_clip
r_void
id|new_clip
c_func
(paren
r_struct
id|video_window
op_star
id|vw
comma
r_struct
id|video_clip
op_star
id|vcp
comma
r_int
id|x
comma
r_int
id|y
comma
r_int
id|w
comma
r_int
id|h
)paren
(brace
id|vcp
(braket
id|vw-&gt;clipcount
)braket
dot
id|x
op_assign
id|x
suffix:semicolon
id|vcp
(braket
id|vw-&gt;clipcount
)braket
dot
id|y
op_assign
id|y
suffix:semicolon
id|vcp
(braket
id|vw-&gt;clipcount
)braket
dot
id|width
op_assign
id|w
suffix:semicolon
id|vcp
(braket
id|vw-&gt;clipcount
)braket
dot
id|height
op_assign
id|h
suffix:semicolon
id|vw-&gt;clipcount
op_increment
suffix:semicolon
)brace
r_static
DECL|function|zoran_ioctl
r_int
id|zoran_ioctl
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|zoran
op_star
id|ztv
op_assign
(paren
r_struct
id|zoran
op_star
)paren
id|dev
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|VIDIOCGCAP
suffix:colon
(brace
r_struct
id|video_capability
id|c
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCGCAP&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|c.name
comma
id|ztv-&gt;video_dev.name
)paren
suffix:semicolon
id|c.type
op_assign
id|VID_TYPE_CAPTURE
op_or
id|VID_TYPE_OVERLAY
op_or
id|VID_TYPE_CLIPPING
op_or
id|VID_TYPE_FRAMERAM
op_or
id|VID_TYPE_SCALES
suffix:semicolon
r_if
c_cond
(paren
id|ztv-&gt;have_tuner
)paren
id|c.type
op_or_assign
id|VID_TYPE_TUNER
suffix:semicolon
r_if
c_cond
(paren
id|ztv-&gt;have_decoder
)paren
(brace
id|c.channels
op_assign
id|ztv-&gt;card-&gt;video_inputs
suffix:semicolon
id|c.audios
op_assign
id|ztv-&gt;card-&gt;audio_inputs
suffix:semicolon
)brace
r_else
multiline_comment|/* no decoder -&gt; no channels */
id|c.channels
op_assign
id|c.audios
op_assign
l_int|0
suffix:semicolon
id|c.maxwidth
op_assign
l_int|768
suffix:semicolon
id|c.maxheight
op_assign
l_int|576
suffix:semicolon
id|c.minwidth
op_assign
l_int|32
suffix:semicolon
id|c.minheight
op_assign
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|c
comma
r_sizeof
(paren
id|c
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCGCHAN
suffix:colon
(brace
r_struct
id|video_channel
id|v
suffix:semicolon
r_int
id|mux
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|v
comma
id|arg
comma
r_sizeof
(paren
id|v
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCGCHAN(%d)&bslash;n&quot;
comma
id|CARD
comma
id|v.channel
)paren
)paren
suffix:semicolon
id|v.flags
op_assign
id|VIDEO_VC_AUDIO
macro_line|#ifdef VIDEO_VC_NORM
op_or
id|VIDEO_VC_NORM
macro_line|#endif
suffix:semicolon
id|v.tuners
op_assign
l_int|0
suffix:semicolon
id|v.type
op_assign
id|VIDEO_TYPE_CAMERA
suffix:semicolon
macro_line|#ifdef I_EXPECT_POSSIBLE_NORMS_IN_THE_API
id|v.norm
op_assign
id|VIDEO_MODE_PAL
op_or
id|VIDEO_MODE_NTSC
op_or
id|VIDEO_MODE_SECAM
suffix:semicolon
macro_line|#else
id|v.norm
op_assign
id|VIDEO_MODE_PAL
suffix:semicolon
macro_line|#endif
multiline_comment|/* too many inputs? no decoder -&gt; no channels */
r_if
c_cond
(paren
op_logical_neg
id|ztv-&gt;have_decoder
op_logical_or
id|v.channel
op_ge
id|ztv-&gt;card-&gt;video_inputs
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* now determine the name of the channel */
id|mux
op_assign
id|ztv-&gt;card-&gt;video_mux
(braket
id|v.channel
)braket
suffix:semicolon
r_if
c_cond
(paren
id|mux
op_amp
id|IS_TUNER
)paren
(brace
multiline_comment|/* lets assume only one tuner, yes? */
id|strcpy
c_func
(paren
id|v.name
comma
l_string|&quot;Television&quot;
)paren
suffix:semicolon
id|v.type
op_assign
id|VIDEO_TYPE_TV
suffix:semicolon
r_if
c_cond
(paren
id|ztv-&gt;have_tuner
)paren
(brace
id|v.flags
op_or_assign
id|VIDEO_VC_TUNER
suffix:semicolon
id|v.tuners
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|mux
op_amp
id|IS_SVHS
)paren
id|sprintf
c_func
(paren
id|v.name
comma
l_string|&quot;S-Video-%d&quot;
comma
id|v.channel
)paren
suffix:semicolon
r_else
id|sprintf
c_func
(paren
id|v.name
comma
l_string|&quot;CVBS-%d&quot;
comma
id|v.channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|v
comma
r_sizeof
(paren
id|v
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCSCHAN
suffix:colon
(brace
multiline_comment|/* set video channel */
r_struct
id|video_channel
id|v
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|v
comma
id|arg
comma
r_sizeof
(paren
id|v
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCSCHAN(%d,%d)&bslash;n&quot;
comma
id|CARD
comma
id|v.channel
comma
id|v.norm
)paren
)paren
suffix:semicolon
multiline_comment|/* too many inputs? no decoder -&gt; no channels */
r_if
c_cond
(paren
op_logical_neg
id|ztv-&gt;have_decoder
op_logical_or
id|v.channel
op_ge
id|ztv-&gt;card-&gt;video_inputs
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|v.norm
op_ne
id|VIDEO_MODE_PAL
op_logical_and
id|v.norm
op_ne
id|VIDEO_MODE_NTSC
op_logical_and
id|v.norm
op_ne
id|VIDEO_MODE_SECAM
op_logical_and
id|v.norm
op_ne
id|VIDEO_MODE_AUTO
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* make it happen, nr1! */
r_return
id|zoran_muxsel
c_func
(paren
id|ztv
comma
id|v.channel
comma
id|v.norm
)paren
suffix:semicolon
)brace
r_case
id|VIDIOCGTUNER
suffix:colon
(brace
r_struct
id|video_tuner
id|v
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|v
comma
id|arg
comma
r_sizeof
(paren
id|v
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCGTUNER(%d)&bslash;n&quot;
comma
id|CARD
comma
id|v.tuner
)paren
)paren
suffix:semicolon
multiline_comment|/* Only no or one tuner for now */
r_if
c_cond
(paren
op_logical_neg
id|ztv-&gt;have_tuner
op_logical_or
id|v.tuner
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|strcpy
c_func
(paren
id|v.name
comma
l_string|&quot;Television&quot;
)paren
suffix:semicolon
id|v.rangelow
op_assign
l_int|0
suffix:semicolon
id|v.rangehigh
op_assign
op_complement
l_int|0
suffix:semicolon
id|v.flags
op_assign
id|VIDEO_TUNER_PAL
op_or
id|VIDEO_TUNER_NTSC
op_or
id|VIDEO_TUNER_SECAM
suffix:semicolon
id|v.mode
op_assign
id|ztv-&gt;norm
suffix:semicolon
id|v.signal
op_assign
l_int|0xFFFF
suffix:semicolon
multiline_comment|/* unknown */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|v
comma
r_sizeof
(paren
id|v
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCSTUNER
suffix:colon
(brace
r_struct
id|video_tuner
id|v
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|v
comma
id|arg
comma
r_sizeof
(paren
id|v
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCSTUNER(%d,%d)&bslash;n&quot;
comma
id|CARD
comma
id|v.tuner
comma
id|v.mode
)paren
)paren
suffix:semicolon
multiline_comment|/* Only no or one tuner for now */
r_if
c_cond
(paren
op_logical_neg
id|ztv-&gt;have_tuner
op_logical_or
id|v.tuner
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* and it only has certain valid modes */
r_if
c_cond
(paren
id|v.mode
op_ne
id|VIDEO_MODE_PAL
op_logical_and
id|v.mode
op_ne
id|VIDEO_MODE_NTSC
op_logical_and
id|v.mode
op_ne
id|VIDEO_MODE_SECAM
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/* engage! */
r_return
id|zoran_muxsel
c_func
(paren
id|ztv
comma
id|v.tuner
comma
id|v.mode
)paren
suffix:semicolon
)brace
r_case
id|VIDIOCGPICT
suffix:colon
(brace
r_struct
id|video_picture
id|p
op_assign
id|ztv-&gt;picture
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCGPICT&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
id|p.depth
op_assign
id|ztv-&gt;depth
suffix:semicolon
r_switch
c_cond
(paren
id|p.depth
)paren
(brace
r_case
l_int|8
suffix:colon
id|p.palette
op_assign
id|VIDEO_PALETTE_YUV422
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|15
suffix:colon
id|p.palette
op_assign
id|VIDEO_PALETTE_RGB555
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|16
suffix:colon
id|p.palette
op_assign
id|VIDEO_PALETTE_RGB565
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|24
suffix:colon
id|p.palette
op_assign
id|VIDEO_PALETTE_RGB24
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32
suffix:colon
id|p.palette
op_assign
id|VIDEO_PALETTE_RGB32
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|p
comma
r_sizeof
(paren
id|p
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCSPICT
suffix:colon
(brace
r_struct
id|video_picture
id|p
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|p
comma
id|arg
comma
r_sizeof
(paren
id|p
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCSPICT(%d,%d,%d,%d,%d,%d,%d)&bslash;n&quot;
comma
id|CARD
comma
id|p.brightness
comma
id|p.hue
comma
id|p.colour
comma
id|p.contrast
comma
id|p.whiteness
comma
id|p.depth
comma
id|p.palette
)paren
)paren
suffix:semicolon
multiline_comment|/* depth must match with framebuffer */
r_if
c_cond
(paren
id|p.depth
op_ne
id|ztv-&gt;depth
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* check if palette matches this bpp */
r_if
c_cond
(paren
id|p.palette
OG
id|NRPALETTES
op_logical_or
id|palette2fmt
(braket
id|p.palette
)braket
dot
id|bpp
op_ne
id|ztv-&gt;overinfo.bpp
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|write_lock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
id|ztv-&gt;overinfo.format
op_assign
id|p.palette
suffix:semicolon
id|ztv-&gt;picture
op_assign
id|p
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* tell the decoder */
id|i2c_control_device
c_func
(paren
op_amp
id|ztv-&gt;i2c
comma
id|I2C_DRIVERID_VIDEODECODER
comma
id|DECODER_SET_PICTURE
comma
op_amp
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCGWIN
suffix:colon
(brace
r_struct
id|video_window
id|vw
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCGWIN&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
id|vw.x
op_assign
id|ztv-&gt;overinfo.x
suffix:semicolon
id|vw.y
op_assign
id|ztv-&gt;overinfo.y
suffix:semicolon
id|vw.width
op_assign
id|ztv-&gt;overinfo.w
suffix:semicolon
id|vw.height
op_assign
id|ztv-&gt;overinfo.h
suffix:semicolon
id|vw.chromakey
op_assign
l_int|0
suffix:semicolon
id|vw.flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ztv-&gt;vidInterlace
)paren
id|vw.flags
op_or_assign
id|VIDEO_WINDOW_INTERLACE
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|vw
comma
r_sizeof
(paren
id|vw
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCSWIN
suffix:colon
(brace
r_struct
id|video_window
id|vw
suffix:semicolon
r_struct
id|video_clip
op_star
id|vcp
suffix:semicolon
r_int
id|on
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|vw
comma
id|arg
comma
r_sizeof
(paren
id|vw
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCSWIN(%d,%d,%d,%d,%x,%d)&bslash;n&quot;
comma
id|CARD
comma
id|vw.x
comma
id|vw.y
comma
id|vw.width
comma
id|vw.height
comma
id|vw.flags
comma
id|vw.clipcount
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vw.flags
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vw.clipcount
OG
l_int|256
)paren
r_return
op_minus
id|EDOM
suffix:semicolon
multiline_comment|/* Too many! */
multiline_comment|/*&n;&t;&t; *      Do any clips.&n;&t;&t; */
id|vcp
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|video_clip
)paren
op_star
(paren
id|vw.clipcount
op_plus
l_int|4
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vcp
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|vw.clipcount
op_logical_and
id|copy_from_user
c_func
(paren
id|vcp
comma
id|vw.clips
comma
r_sizeof
(paren
r_struct
id|video_clip
)paren
op_star
id|vw.clipcount
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|on
op_assign
id|ztv-&gt;running
suffix:semicolon
r_if
c_cond
(paren
id|on
)paren
id|zoran_cap
c_func
(paren
id|ztv
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * strange, it seems xawtv sometimes calls us with 0&n;&t;&t; * width and/or height. Ignore these values&n;&t;&t; */
r_if
c_cond
(paren
id|vw.x
op_eq
l_int|0
)paren
id|vw.x
op_assign
id|ztv-&gt;overinfo.x
suffix:semicolon
r_if
c_cond
(paren
id|vw.y
op_eq
l_int|0
)paren
id|vw.y
op_assign
id|ztv-&gt;overinfo.y
suffix:semicolon
multiline_comment|/* by now we are committed to the new data... */
id|write_lock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
id|ztv-&gt;overinfo.x
op_assign
id|vw.x
suffix:semicolon
id|ztv-&gt;overinfo.y
op_assign
id|vw.y
suffix:semicolon
id|ztv-&gt;overinfo.w
op_assign
id|vw.width
suffix:semicolon
id|ztv-&gt;overinfo.h
op_assign
id|vw.height
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *      Impose display clips&n;&t;&t; */
r_if
c_cond
(paren
id|vw.x
op_plus
id|vw.width
OG
id|ztv-&gt;swidth
)paren
id|new_clip
c_func
(paren
op_amp
id|vw
comma
id|vcp
comma
id|ztv-&gt;swidth
op_minus
id|vw.x
comma
l_int|0
comma
id|vw.width
op_minus
l_int|1
comma
id|vw.height
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vw.y
op_plus
id|vw.height
OG
id|ztv-&gt;sheight
)paren
id|new_clip
c_func
(paren
op_amp
id|vw
comma
id|vcp
comma
l_int|0
comma
id|ztv-&gt;sheight
op_minus
id|vw.y
comma
id|vw.width
op_minus
l_int|1
comma
id|vw.height
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* built the requested clipping zones */
id|zoran_set_geo
c_func
(paren
id|ztv
comma
op_amp
id|ztv-&gt;overinfo
)paren
suffix:semicolon
id|zoran_built_overlay
c_func
(paren
id|ztv
comma
id|vw.clipcount
comma
id|vcp
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|vcp
)paren
suffix:semicolon
multiline_comment|/* if we were on, restart the video engine */
r_if
c_cond
(paren
id|on
)paren
id|zoran_cap
c_func
(paren
id|ztv
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCCAPTURE
suffix:colon
(brace
r_int
id|v
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|v
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCCAPTURE(%d)&bslash;n&quot;
comma
id|CARD
comma
id|v
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|v
op_eq
l_int|0
)paren
(brace
id|clear_bit
c_func
(paren
id|STATE_OVERLAY
comma
op_amp
id|ztv-&gt;state
)paren
suffix:semicolon
id|zoran_cap
c_func
(paren
id|ztv
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* is VIDIOCSFBUF, VIDIOCSWIN done? */
r_if
c_cond
(paren
id|ztv-&gt;overinfo.busadr
op_eq
l_int|0
op_logical_or
id|ztv-&gt;overinfo.w
op_eq
l_int|0
op_logical_or
id|ztv-&gt;overinfo.h
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|set_bit
c_func
(paren
id|STATE_OVERLAY
comma
op_amp
id|ztv-&gt;state
)paren
suffix:semicolon
id|zoran_cap
c_func
(paren
id|ztv
comma
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCGFBUF
suffix:colon
(brace
r_struct
id|video_buffer
id|v
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCGFBUF&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
id|v.base
op_assign
(paren
r_void
op_star
)paren
id|ztv-&gt;overinfo.busadr
suffix:semicolon
id|v.height
op_assign
id|ztv-&gt;sheight
suffix:semicolon
id|v.width
op_assign
id|ztv-&gt;swidth
suffix:semicolon
id|v.depth
op_assign
id|ztv-&gt;depth
suffix:semicolon
id|v.bytesperline
op_assign
id|ztv-&gt;overinfo.bpl
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|v
comma
r_sizeof
(paren
id|v
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCSFBUF
suffix:colon
(brace
r_struct
id|video_buffer
id|v
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= 0x020100
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
macro_line|#endif
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|v
comma
id|arg
comma
r_sizeof
(paren
id|v
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCSFBUF(%p,%d,%d,%d,%d)&bslash;n&quot;
comma
id|CARD
comma
id|v.base
comma
id|v.width
comma
id|v.height
comma
id|v.depth
comma
id|v.bytesperline
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|v.depth
op_ne
l_int|15
op_logical_and
id|v.depth
op_ne
l_int|16
op_logical_and
id|v.depth
op_ne
l_int|24
op_logical_and
id|v.depth
op_ne
l_int|32
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|v.bytesperline
OL
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ztv-&gt;running
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|write_lock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
id|ztv-&gt;overinfo.busadr
op_assign
(paren
id|ulong
)paren
id|v.base
suffix:semicolon
id|ztv-&gt;sheight
op_assign
id|v.height
suffix:semicolon
id|ztv-&gt;swidth
op_assign
id|v.width
suffix:semicolon
id|ztv-&gt;depth
op_assign
id|v.depth
suffix:semicolon
multiline_comment|/* bits per pixel */
id|ztv-&gt;overinfo.bpp
op_assign
(paren
(paren
id|v.depth
op_plus
l_int|1
)paren
op_amp
l_int|0x38
)paren
op_div
l_int|8
suffix:semicolon
multiline_comment|/* bytes per pixel */
id|ztv-&gt;overinfo.bpl
op_assign
id|v.bytesperline
suffix:semicolon
multiline_comment|/* bytes per line */
id|write_unlock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCKEY
suffix:colon
(brace
multiline_comment|/* Will be handled higher up .. */
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCSYNC
suffix:colon
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|i
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDEOCSYNC(%d)&bslash;n&quot;
comma
id|CARD
comma
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
id|ZORAN_MAX_FBUFFERS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|ztv-&gt;grabinfo
(braket
id|i
)braket
dot
id|status
)paren
(brace
r_case
id|FBUFFER_FREE
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|FBUFFER_BUSY
suffix:colon
multiline_comment|/* wait till this buffer gets grabbed */
r_while
c_loop
(paren
id|ztv-&gt;grabinfo
(braket
id|i
)braket
dot
id|status
op_eq
id|FBUFFER_BUSY
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|ztv-&gt;grabq
)paren
suffix:semicolon
multiline_comment|/* see if a signal did it */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
multiline_comment|/* don&squot;t fall through; a DONE buffer is not UNUSED */
r_break
suffix:semicolon
r_case
id|FBUFFER_DONE
suffix:colon
id|ztv-&gt;grabinfo
(braket
id|i
)braket
dot
id|status
op_assign
id|FBUFFER_FREE
suffix:semicolon
multiline_comment|/* tell ppl we have a spare buffer */
id|wake_up_interruptible
c_func
(paren
op_amp
id|ztv-&gt;grabq
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDEOCSYNC(%d) returns&bslash;n&quot;
comma
id|CARD
comma
id|i
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCMCAPTURE
suffix:colon
(brace
r_struct
id|video_mmap
id|vm
suffix:semicolon
r_struct
id|vidinfo
op_star
id|frame
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|vm
comma
id|arg
comma
r_sizeof
(paren
id|vm
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCMCAPTURE(%d,(%d,%d),%d)&bslash;n&quot;
comma
id|CARD
comma
id|vm.frame
comma
id|vm.width
comma
id|vm.height
comma
id|vm.format
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vm.frame
id|ZORAN_MAX_FBUFFERS
op_logical_or
id|vm.width
l_int|768
op_logical_or
id|vm.height
l_int|576
op_logical_or
id|vm.format
OG
id|NRPALETTES
op_logical_or
id|palette2fmt
(braket
id|vm.format
)braket
dot
id|mode
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* we are allowed to take over UNUSED and DONE buffers */
id|frame
op_assign
op_amp
id|ztv-&gt;grabinfo
(braket
id|vm.frame
)braket
suffix:semicolon
r_if
c_cond
(paren
id|frame-&gt;status
op_eq
id|FBUFFER_BUSY
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* setup the other parameters if they are given */
id|write_lock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
id|frame-&gt;w
op_assign
id|vm.width
suffix:semicolon
id|frame-&gt;h
op_assign
id|vm.height
suffix:semicolon
id|frame-&gt;format
op_assign
id|vm.format
suffix:semicolon
id|frame-&gt;bpp
op_assign
id|palette2fmt
(braket
id|frame-&gt;format
)braket
dot
id|bpp
suffix:semicolon
id|frame-&gt;bpl
op_assign
id|frame-&gt;w
op_star
id|frame-&gt;bpp
suffix:semicolon
id|frame-&gt;status
op_assign
id|FBUFFER_BUSY
suffix:semicolon
id|frame-&gt;next
op_assign
l_int|0
suffix:semicolon
(brace
multiline_comment|/* add to tail of queue */
r_struct
id|vidinfo
op_star
id|oldframe
op_assign
id|ztv-&gt;workqueue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|oldframe
)paren
id|ztv-&gt;workqueue
op_assign
id|frame
suffix:semicolon
r_else
(brace
r_while
c_loop
(paren
id|oldframe-&gt;next
)paren
id|oldframe
op_assign
id|oldframe-&gt;next
suffix:semicolon
id|oldframe-&gt;next
op_assign
id|frame
suffix:semicolon
)brace
)brace
id|write_unlock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
id|zoran_cap
c_func
(paren
id|ztv
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCGMBUF
suffix:colon
(brace
r_struct
id|video_mbuf
id|mb
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCGMBUF&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
id|mb.size
op_assign
id|ZORAN_MAX_FBUFSIZE
suffix:semicolon
id|mb.frames
op_assign
id|ZORAN_MAX_FBUFFERS
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ZORAN_MAX_FBUFFERS
suffix:semicolon
id|i
op_increment
)paren
id|mb.offsets
(braket
id|i
)braket
op_assign
id|i
op_star
id|ZORAN_MAX_FBUFFER
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|mb
comma
r_sizeof
(paren
id|mb
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCGUNIT
suffix:colon
(brace
r_struct
id|video_unit
id|vu
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCGUNIT&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
id|vu.video
op_assign
id|ztv-&gt;video_dev.minor
suffix:semicolon
id|vu.vbi
op_assign
id|ztv-&gt;vbi_dev.minor
suffix:semicolon
id|vu.radio
op_assign
id|VIDEO_NO_UNIT
suffix:semicolon
id|vu.audio
op_assign
id|VIDEO_NO_UNIT
suffix:semicolon
id|vu.teletext
op_assign
id|VIDEO_NO_UNIT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|vu
comma
r_sizeof
(paren
id|vu
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCGFREQ
suffix:colon
(brace
r_int
r_int
id|v
op_assign
id|ztv-&gt;tuner_freq
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|v
comma
r_sizeof
(paren
id|v
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCGFREQ&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCSFREQ
suffix:colon
(brace
r_int
r_int
id|v
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|v
comma
id|arg
comma
r_sizeof
(paren
id|v
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCSFREQ&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ztv-&gt;have_tuner
)paren
(brace
r_int
id|fixme
op_assign
id|v
suffix:semicolon
r_if
c_cond
(paren
id|i2c_control_device
c_func
(paren
op_amp
(paren
id|ztv-&gt;i2c
)paren
comma
id|I2C_DRIVERID_TUNER
comma
id|TUNER_SET_TVFREQ
comma
op_amp
id|fixme
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|ztv-&gt;tuner_freq
op_assign
id|v
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Why isn&squot;t this in the API?&n;&t;  * And why doesn&squot;t it take a buffer number?&n;&t; case BTTV_FIELDNR: &n;&t; {&n;&t;&t;unsigned long v = ztv-&gt;lastfieldnr;&n;&t;&t;if (copy_to_user(arg,&amp;v,sizeof(v)))&n;&t;&t;&t;return -EFAULT;&n;&t;&t;DEBUG(printk(CARD_DEBUG &quot;BTTV_FIELDNR&bslash;n&quot;,CARD));&n;&t;&t;break;&n;&t; }&n;&t; */
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
DECL|function|zoran_mmap
r_int
id|zoran_mmap
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_const
r_char
op_star
id|adr
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|zoran
op_star
id|ztv
op_assign
(paren
r_struct
id|zoran
op_star
)paren
id|dev
suffix:semicolon
r_int
r_int
id|start
op_assign
(paren
r_int
r_int
)paren
id|adr
suffix:semicolon
r_int
r_int
id|pos
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;zoran_mmap(0x%p,%ld)&bslash;n&quot;
comma
id|CARD
comma
id|adr
comma
id|size
)paren
)paren
suffix:semicolon
multiline_comment|/* sanity checks */
r_if
c_cond
(paren
id|size
OG
id|ZORAN_MAX_FBUFSIZE
op_logical_or
op_logical_neg
id|ztv-&gt;fbuffer
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* start mapping the whole shabang to user memory */
id|pos
op_assign
(paren
r_int
r_int
)paren
id|ztv-&gt;fbuffer
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
r_int
r_int
id|page
op_assign
id|virt_to_phys
c_func
(paren
(paren
r_void
op_star
)paren
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remap_page_range
c_func
(paren
id|start
comma
id|page
comma
id|PAGE_SIZE
comma
id|PAGE_SHARED
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|pos
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|zr36120_template
r_static
r_struct
id|video_device
id|zr36120_template
op_assign
(brace
id|name
suffix:colon
l_string|&quot;UNSET&quot;
comma
id|type
suffix:colon
id|VID_TYPE_TUNER
op_or
id|VID_TYPE_CAPTURE
op_or
id|VID_TYPE_OVERLAY
comma
id|hardware
suffix:colon
id|VID_HARDWARE_ZR36120
comma
id|open
suffix:colon
id|zoran_open
comma
id|close
suffix:colon
id|zoran_close
comma
id|read
suffix:colon
id|zoran_read
comma
id|write
suffix:colon
id|zoran_write
comma
id|poll
suffix:colon
id|zoran_poll
comma
id|ioctl
suffix:colon
id|zoran_ioctl
comma
id|mmap
suffix:colon
id|zoran_mmap
comma
id|minor
suffix:colon
op_minus
l_int|1
comma
)brace
suffix:semicolon
r_static
DECL|function|vbi_open
r_int
id|vbi_open
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_int
id|flags
)paren
(brace
r_struct
id|zoran
op_star
id|ztv
op_assign
(paren
r_struct
id|zoran
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|vidinfo
op_star
id|item
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;vbi_open(dev,%d)&bslash;n&quot;
comma
id|CARD
comma
id|flags
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * During VBI device open, we continiously grab VBI-like&n;&t; * data in the vbi buffer when we have nothing to do.&n;&t; * Only when there is an explicit request for VBI data&n;&t; * (read call) we /force/ a read.&n;&t; */
multiline_comment|/* allocate buffers */
r_for
c_loop
(paren
id|item
op_assign
id|ztv-&gt;readinfo
suffix:semicolon
id|item
op_ne
id|ztv-&gt;readinfo
op_plus
id|ZORAN_VBI_BUFFERS
suffix:semicolon
id|item
op_increment
)paren
(brace
id|item-&gt;status
op_assign
id|FBUFFER_FREE
suffix:semicolon
multiline_comment|/* alloc */
r_if
c_cond
(paren
op_logical_neg
id|item-&gt;memadr
)paren
(brace
id|item-&gt;memadr
op_assign
id|bmalloc
c_func
(paren
id|ZORAN_VBI_BUFSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|item-&gt;memadr
)paren
(brace
multiline_comment|/* could not get a buffer, bail out */
r_while
c_loop
(paren
id|item
op_ne
id|ztv-&gt;readinfo
)paren
(brace
id|item
op_decrement
suffix:semicolon
id|bfree
c_func
(paren
id|item-&gt;memadr
comma
id|ZORAN_VBI_BUFSIZE
)paren
suffix:semicolon
id|item-&gt;memadr
op_assign
l_int|0
suffix:semicolon
id|item-&gt;busadr
op_assign
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
)brace
multiline_comment|/* determine the DMAable address */
id|item-&gt;busadr
op_assign
id|virt_to_bus
c_func
(paren
id|item-&gt;memadr
)paren
suffix:semicolon
)brace
multiline_comment|/* do the common part of all open&squot;s */
id|zoran_common_open
c_func
(paren
id|ztv
comma
id|flags
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|STATE_VBI
comma
op_amp
id|ztv-&gt;state
)paren
suffix:semicolon
multiline_comment|/* start read-ahead */
id|zoran_cap
c_func
(paren
id|ztv
comma
l_int|1
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
DECL|function|vbi_close
r_void
id|vbi_close
c_func
(paren
r_struct
id|video_device
op_star
id|dev
)paren
(brace
r_struct
id|zoran
op_star
id|ztv
op_assign
(paren
r_struct
id|zoran
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|vidinfo
op_star
id|item
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;vbi_close(dev)&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
multiline_comment|/* driver specific closure */
id|clear_bit
c_func
(paren
id|STATE_VBI
comma
op_amp
id|ztv-&gt;state
)paren
suffix:semicolon
id|zoran_common_close
c_func
(paren
id|ztv
)paren
suffix:semicolon
multiline_comment|/*&n;         *      This is sucky but right now I can&squot;t find a good way to&n;         *      be sure its safe to free the buffer. We wait 5-6 fields&n;         *      which is more than sufficient to be sure.&n;         */
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Wait 1/10th of a second */
r_for
c_loop
(paren
id|item
op_assign
id|ztv-&gt;readinfo
suffix:semicolon
id|item
op_ne
id|ztv-&gt;readinfo
op_plus
id|ZORAN_VBI_BUFFERS
suffix:semicolon
id|item
op_increment
)paren
(brace
r_if
c_cond
(paren
id|item-&gt;memadr
)paren
id|bfree
c_func
(paren
id|item-&gt;memadr
comma
id|ZORAN_VBI_BUFSIZE
)paren
suffix:semicolon
id|item-&gt;memadr
op_assign
l_int|0
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/*&n; * This read function could be used reentrant in a SMP situation.&n; *&n; * This is made possible by the spinlock which is kept till we&n; * found and marked a buffer for our own use. The lock must&n; * be released as soon as possible to prevent lock contention.&n; */
r_static
DECL|function|vbi_read
r_int
id|vbi_read
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|count
comma
r_int
id|nonblock
)paren
(brace
r_struct
id|zoran
op_star
id|ztv
op_assign
(paren
r_struct
id|zoran
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|max
suffix:semicolon
r_struct
id|vidinfo
op_star
id|unused
op_assign
l_int|0
suffix:semicolon
r_struct
id|vidinfo
op_star
id|done
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;vbi_read(0x%p,%ld,%d)&bslash;n&quot;
comma
id|CARD
comma
id|buf
comma
id|count
comma
id|nonblock
)paren
)paren
suffix:semicolon
multiline_comment|/* find ourself a free or completed buffer */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|vidinfo
op_star
id|item
suffix:semicolon
id|write_lock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|item
op_assign
id|ztv-&gt;readinfo
suffix:semicolon
id|item
op_ne
id|ztv-&gt;readinfo
op_plus
id|ZORAN_VBI_BUFFERS
suffix:semicolon
id|item
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|unused
op_logical_and
id|item-&gt;status
op_eq
id|FBUFFER_FREE
)paren
id|unused
op_assign
id|item
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|done
op_logical_and
id|item-&gt;status
op_eq
id|FBUFFER_DONE
)paren
id|done
op_assign
id|item
suffix:semicolon
)brace
r_if
c_cond
(paren
id|done
op_logical_or
id|unused
)paren
r_break
suffix:semicolon
multiline_comment|/* no more free buffers, wait for them. */
id|write_unlock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nonblock
)paren
r_return
op_minus
id|EWOULDBLOCK
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|ztv-&gt;vbiq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
multiline_comment|/* Do we have &squot;ready&squot; data? */
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
(brace
multiline_comment|/* no? than this will take a while... */
r_if
c_cond
(paren
id|nonblock
)paren
(brace
id|write_unlock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
r_return
op_minus
id|EWOULDBLOCK
suffix:semicolon
)brace
multiline_comment|/* mark the unused buffer as wanted */
id|unused-&gt;status
op_assign
id|FBUFFER_BUSY
suffix:semicolon
id|unused-&gt;next
op_assign
l_int|0
suffix:semicolon
(brace
multiline_comment|/* add to tail of queue */
r_struct
id|vidinfo
op_star
id|oldframe
op_assign
id|ztv-&gt;workqueue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|oldframe
)paren
id|ztv-&gt;workqueue
op_assign
id|unused
suffix:semicolon
r_else
(brace
r_while
c_loop
(paren
id|oldframe-&gt;next
)paren
id|oldframe
op_assign
id|oldframe-&gt;next
suffix:semicolon
id|oldframe-&gt;next
op_assign
id|unused
suffix:semicolon
)brace
)brace
id|write_unlock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* tell the state machine we want it filled /NOW/ */
id|zoran_cap
c_func
(paren
id|ztv
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* wait till this buffer gets grabbed */
r_while
c_loop
(paren
id|unused-&gt;status
op_eq
id|FBUFFER_BUSY
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|ztv-&gt;vbiq
)paren
suffix:semicolon
multiline_comment|/* see if a signal did it */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|done
op_assign
id|unused
suffix:semicolon
)brace
r_else
id|write_unlock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Yes! we got data! */
id|max
op_assign
id|done-&gt;bpl
op_star
op_minus
id|done-&gt;h
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|max
)paren
id|count
op_assign
id|max
suffix:semicolon
multiline_comment|/* check if the user gave us enough room to write the data */
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|count
)paren
)paren
(brace
id|count
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now transform/strip the data from YUV to Y-only&n;&t; * NB. Assume the Y is in the LSB of the YUV data.&n;&t; */
(brace
r_int
r_char
op_star
id|optr
op_assign
id|buf
suffix:semicolon
r_int
r_char
op_star
id|eptr
op_assign
id|buf
op_plus
id|count
suffix:semicolon
multiline_comment|/* are we beeing accessed from an old driver? */
r_if
c_cond
(paren
id|count
op_eq
l_int|2
op_star
l_int|19
op_star
l_int|2048
)paren
(brace
multiline_comment|/*&n;&t;&t; * Extreme HACK, old VBI programs expect 2048 points&n;&t;&t; * of data, and we only got 864 orso. Double each &n;&t;&t; * datapoint and clear the rest of the line.&n;&t;&t; * This way we have appear to have a&n;&t;&t; * sample_frequency of 29.5 Mc.&n;&t;&t; */
r_int
id|x
comma
id|y
suffix:semicolon
r_int
r_char
op_star
id|iptr
op_assign
id|done-&gt;memadr
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|y
op_assign
id|done-&gt;h
suffix:semicolon
id|optr
OL
id|eptr
op_logical_and
id|y
OL
l_int|0
suffix:semicolon
id|y
op_increment
)paren
(brace
multiline_comment|/* copy to doubled data to userland */
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|optr
op_plus
l_int|1
OL
id|eptr
op_logical_and
id|x
OL
op_minus
id|done-&gt;w
suffix:semicolon
id|x
op_increment
)paren
(brace
r_int
r_char
id|a
op_assign
id|iptr
(braket
id|x
op_star
l_int|2
)braket
suffix:semicolon
op_star
id|optr
op_increment
op_assign
id|a
suffix:semicolon
op_star
id|optr
op_increment
op_assign
id|a
suffix:semicolon
)brace
multiline_comment|/* and clear the rest of the line */
r_for
c_loop
(paren
id|x
op_mul_assign
l_int|2
suffix:semicolon
id|optr
OL
id|eptr
op_logical_and
id|x
OL
id|done-&gt;bpl
suffix:semicolon
id|x
op_increment
)paren
op_star
id|optr
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* next line */
id|iptr
op_add_assign
id|done-&gt;bpl
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Other (probably newer) programs asked&n;&t;&t; * us what geometry we are using, and are&n;&t;&t; * reading the correct size.&n;&t;&t; */
r_int
id|x
comma
id|y
suffix:semicolon
r_int
r_char
op_star
id|iptr
op_assign
id|done-&gt;memadr
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|y
op_assign
id|done-&gt;h
suffix:semicolon
id|optr
OL
id|eptr
op_logical_and
id|y
OL
l_int|0
suffix:semicolon
id|y
op_increment
)paren
(brace
multiline_comment|/* copy to doubled data to userland */
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|optr
OL
id|eptr
op_logical_and
id|x
OL
op_minus
id|done-&gt;w
suffix:semicolon
id|x
op_increment
)paren
op_star
id|optr
op_increment
op_assign
id|iptr
(braket
id|x
op_star
l_int|2
)braket
suffix:semicolon
multiline_comment|/* and clear the rest of the line */
r_for
c_loop
(paren
suffix:semicolon
id|optr
OL
id|eptr
op_logical_and
id|x
OL
id|done-&gt;bpl
suffix:semicolon
id|x
op_increment
)paren
op_star
id|optr
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* next line */
id|iptr
op_add_assign
id|done-&gt;bpl
suffix:semicolon
)brace
)brace
multiline_comment|/* API compliance:&n;&t; * place the framenumber (half fieldnr) in the last long&n;&t; */
(paren
(paren
id|ulong
op_star
)paren
id|eptr
)paren
(braket
op_minus
l_int|1
)braket
op_assign
id|done-&gt;fieldnr
op_div
l_int|2
suffix:semicolon
)brace
multiline_comment|/* keep the engine running */
id|done-&gt;status
op_assign
id|FBUFFER_FREE
suffix:semicolon
id|zoran_cap
c_func
(paren
id|ztv
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* tell listeners this buffer just became free */
id|wake_up_interruptible
c_func
(paren
op_amp
id|ztv-&gt;vbiq
)paren
suffix:semicolon
multiline_comment|/* goodbye */
id|out
suffix:colon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;vbi_read() returns %lu&bslash;n&quot;
comma
id|CARD
comma
id|count
)paren
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &gt;= 0x020100
r_static
DECL|function|vbi_poll
r_int
r_int
id|vbi_poll
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|zoran
op_star
id|ztv
op_assign
(paren
r_struct
id|zoran
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|vidinfo
op_star
id|item
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|ztv-&gt;vbiq
comma
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
id|item
op_assign
id|ztv-&gt;readinfo
suffix:semicolon
id|item
op_ne
id|ztv-&gt;readinfo
op_plus
id|ZORAN_VBI_BUFFERS
suffix:semicolon
id|item
op_increment
)paren
r_if
c_cond
(paren
id|item-&gt;status
op_eq
id|FBUFFER_DONE
)paren
(brace
id|mask
op_or_assign
(paren
id|POLLIN
op_or
id|POLLRDNORM
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;vbi_poll()=%x&bslash;n&quot;
comma
id|CARD
comma
id|mask
)paren
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
macro_line|#endif
r_static
DECL|function|vbi_ioctl
r_int
id|vbi_ioctl
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|zoran
op_star
id|ztv
op_assign
(paren
r_struct
id|zoran
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|VIDIOCGVBIFMT
suffix:colon
(brace
r_struct
id|vbi_format
id|f
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCGVBIINFO&bslash;n&quot;
comma
id|CARD
)paren
)paren
suffix:semicolon
id|f.sampling_rate
op_assign
l_int|14750000UL
suffix:semicolon
id|f.samples_per_line
op_assign
op_minus
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
dot
id|w
suffix:semicolon
id|f.sample_format
op_assign
id|VIDEO_PALETTE_RAW
suffix:semicolon
id|f.start
(braket
l_int|0
)braket
op_assign
id|f.start
(braket
l_int|1
)braket
op_assign
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
dot
id|y
suffix:semicolon
id|f.start
(braket
l_int|1
)braket
op_add_assign
l_int|312
suffix:semicolon
id|f.count
(braket
l_int|0
)braket
op_assign
id|f.count
(braket
l_int|1
)braket
op_assign
op_minus
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
dot
id|h
suffix:semicolon
id|f.flags
op_assign
id|VBI_INTERLACED
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|f
comma
r_sizeof
(paren
id|f
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCSVBIFMT
suffix:colon
(brace
r_struct
id|vbi_format
id|f
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|f
comma
id|arg
comma
r_sizeof
(paren
id|f
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|CARD_DEBUG
l_string|&quot;VIDIOCSVBIINFO(%d,%d,%d,%d,%d,%d,%d,%x)&bslash;n&quot;
comma
id|CARD
comma
id|f.sampling_rate
comma
id|f.samples_per_line
comma
id|f.sample_format
comma
id|f.start
(braket
l_int|0
)braket
comma
id|f.start
(braket
l_int|1
)braket
comma
id|f.count
(braket
l_int|0
)braket
comma
id|f.count
(braket
l_int|1
)braket
comma
id|f.flags
)paren
)paren
suffix:semicolon
multiline_comment|/* lots of parameters are fixed... (PAL) */
r_if
c_cond
(paren
id|f.sampling_rate
op_ne
l_int|14750000UL
op_logical_or
id|f.samples_per_line
OG
l_int|864
op_logical_or
id|f.sample_format
op_ne
id|VIDEO_PALETTE_RAW
op_logical_or
id|f.start
(braket
l_int|0
)braket
OL
l_int|0
op_logical_or
id|f.start
(braket
l_int|0
)braket
op_ne
id|f.start
(braket
l_int|1
)braket
op_minus
l_int|312
op_logical_or
id|f.count
(braket
l_int|0
)braket
op_ne
id|f.count
(braket
l_int|1
)braket
op_logical_or
id|f.start
(braket
l_int|0
)braket
op_plus
id|f.count
(braket
l_int|0
)braket
op_ge
l_int|288
op_logical_or
id|f.flags
op_ne
id|VBI_INTERLACED
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|write_lock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
dot
id|y
op_assign
id|f.start
(braket
l_int|0
)braket
suffix:semicolon
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
dot
id|w
op_assign
op_minus
id|f.samples_per_line
suffix:semicolon
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
dot
id|h
op_assign
op_minus
id|f.count
(braket
l_int|0
)braket
suffix:semicolon
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
dot
id|bpl
op_assign
id|f.samples_per_line
op_star
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
dot
id|bpp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|ZORAN_VBI_BUFFERS
suffix:semicolon
id|i
op_increment
)paren
id|ztv-&gt;readinfo
(braket
id|i
)braket
op_assign
id|ztv-&gt;readinfo
(braket
id|i
)braket
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|ztv-&gt;lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|vbi_template
r_static
r_struct
id|video_device
id|vbi_template
op_assign
(brace
id|name
suffix:colon
l_string|&quot;UNSET&quot;
comma
id|type
suffix:colon
id|VID_TYPE_CAPTURE
op_or
id|VID_TYPE_TELETEXT
comma
id|hardware
suffix:colon
id|VID_HARDWARE_ZR36120
comma
id|open
suffix:colon
id|vbi_open
comma
id|close
suffix:colon
id|vbi_close
comma
id|read
suffix:colon
id|vbi_read
comma
id|write
suffix:colon
id|zoran_write
comma
id|poll
suffix:colon
id|vbi_poll
comma
id|ioctl
suffix:colon
id|vbi_ioctl
comma
id|minor
suffix:colon
op_minus
l_int|1
comma
)brace
suffix:semicolon
multiline_comment|/*&n; *      Scan for a Zoran chip, request the irq and map the io memory&n; */
r_static
DECL|function|find_zoran
r_int
id|__init
id|find_zoran
c_func
(paren
r_void
)paren
(brace
r_int
id|result
suffix:semicolon
r_struct
id|zoran
op_star
id|ztv
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
id|revision
suffix:semicolon
r_int
id|zoran_num
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_ZORAN
comma
id|PCI_DEVICE_ID_ZORAN_36120
comma
id|dev
)paren
)paren
)paren
(brace
multiline_comment|/* Ok, a ZR36120/ZR36125 found! */
id|ztv
op_assign
op_amp
id|zorans
(braket
id|zoran_num
)braket
suffix:semicolon
id|ztv-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|revision
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;zoran: Zoran %x (rev %d) &quot;
comma
id|dev-&gt;device
comma
id|revision
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bus: %d, devfn: %d, irq: %d, &quot;
comma
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;memory: 0x%08lx.&bslash;n&quot;
comma
id|ztv-&gt;zoran_adr
)paren
suffix:semicolon
id|ztv-&gt;zoran_mem
op_assign
id|ioremap
c_func
(paren
id|ztv-&gt;zoran_adr
comma
l_int|0x1000
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;zoran: mapped-memory at 0x%p&bslash;n&quot;
comma
id|ztv-&gt;zoran_mem
)paren
)paren
suffix:semicolon
id|result
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
id|zoran_irq
comma
id|SA_SHIRQ
op_or
id|SA_INTERRUPT
comma
l_string|&quot;zoran&quot;
comma
(paren
r_void
op_star
)paren
id|ztv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EINVAL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;zoran: Bad irq number or handler&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EBUSY
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;zoran: IRQ %d busy, change your PnP config in BIOS&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
multiline_comment|/* Enable bus-mastering */
id|pci_set_master
c_func
(paren
id|dev
)paren
suffix:semicolon
id|zoran_num
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zoran_num
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;zoran: %d Zoran card(s) found.&bslash;n&quot;
comma
id|zoran_num
)paren
suffix:semicolon
)brace
r_return
id|zoran_num
suffix:semicolon
)brace
r_static
DECL|function|init_zoran
r_int
id|__init
id|init_zoran
c_func
(paren
r_int
id|card
)paren
(brace
r_struct
id|zoran
op_star
id|ztv
op_assign
op_amp
id|zorans
(braket
id|card
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* if the given cardtype valid? */
r_if
c_cond
(paren
id|cardtype
(braket
id|card
)braket
op_ge
id|NRTVCARDS
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;invalid cardtype(%d) detected&bslash;n&quot;
comma
id|cardtype
(braket
id|card
)braket
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* reset the zoran */
id|zrand
c_func
(paren
op_complement
id|ZORAN_PCI_SOFTRESET
comma
id|ZORAN_PCI
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|zror
c_func
(paren
id|ZORAN_PCI_SOFTRESET
comma
id|ZORAN_PCI
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* zoran chip specific details */
id|ztv-&gt;card
op_assign
id|tvcards
op_plus
id|cardtype
(braket
id|card
)braket
suffix:semicolon
multiline_comment|/* point to the selected card */
id|ztv-&gt;norm
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* PAL */
id|ztv-&gt;tuner_freq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* videocard details */
id|ztv-&gt;swidth
op_assign
l_int|800
suffix:semicolon
id|ztv-&gt;sheight
op_assign
l_int|600
suffix:semicolon
id|ztv-&gt;depth
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* State details */
id|ztv-&gt;fbuffer
op_assign
l_int|0
suffix:semicolon
id|ztv-&gt;overinfo.kindof
op_assign
id|FBUFFER_OVERLAY
suffix:semicolon
id|ztv-&gt;overinfo.status
op_assign
id|FBUFFER_FREE
suffix:semicolon
id|ztv-&gt;overinfo.x
op_assign
l_int|0
suffix:semicolon
id|ztv-&gt;overinfo.y
op_assign
l_int|0
suffix:semicolon
id|ztv-&gt;overinfo.w
op_assign
l_int|768
suffix:semicolon
multiline_comment|/* 640 */
id|ztv-&gt;overinfo.h
op_assign
l_int|576
suffix:semicolon
multiline_comment|/* 480 */
id|ztv-&gt;overinfo.format
op_assign
id|VIDEO_PALETTE_RGB565
suffix:semicolon
id|ztv-&gt;overinfo.bpp
op_assign
id|palette2fmt
(braket
id|ztv-&gt;overinfo.format
)braket
dot
id|bpp
suffix:semicolon
id|ztv-&gt;overinfo.bpl
op_assign
id|ztv-&gt;overinfo.bpp
op_star
id|ztv-&gt;swidth
suffix:semicolon
id|ztv-&gt;overinfo.busadr
op_assign
l_int|0
suffix:semicolon
id|ztv-&gt;overinfo.memadr
op_assign
l_int|0
suffix:semicolon
id|ztv-&gt;overinfo.overlay
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ZORAN_MAX_FBUFFERS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ztv-&gt;grabinfo
(braket
id|i
)braket
op_assign
id|ztv-&gt;overinfo
suffix:semicolon
id|ztv-&gt;grabinfo
(braket
id|i
)braket
dot
id|kindof
op_assign
id|FBUFFER_GRAB
suffix:semicolon
)brace
id|init_waitqueue_head
c_func
(paren
op_amp
id|ztv-&gt;grabq
)paren
suffix:semicolon
multiline_comment|/* VBI details */
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
op_assign
id|ztv-&gt;overinfo
suffix:semicolon
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
dot
id|kindof
op_assign
id|FBUFFER_VBI
suffix:semicolon
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
dot
id|w
op_assign
op_minus
l_int|864
suffix:semicolon
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
dot
id|h
op_assign
op_minus
l_int|38
suffix:semicolon
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
dot
id|format
op_assign
id|VIDEO_PALETTE_YUV422
suffix:semicolon
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
dot
id|bpp
op_assign
id|palette2fmt
(braket
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
dot
id|format
)braket
dot
id|bpp
suffix:semicolon
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
dot
id|bpl
op_assign
l_int|1024
op_star
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
dot
id|bpp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|ZORAN_VBI_BUFFERS
suffix:semicolon
id|i
op_increment
)paren
id|ztv-&gt;readinfo
(braket
id|i
)braket
op_assign
id|ztv-&gt;readinfo
(braket
l_int|0
)braket
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ztv-&gt;vbiq
)paren
suffix:semicolon
multiline_comment|/* maintenance data */
id|ztv-&gt;have_decoder
op_assign
l_int|0
suffix:semicolon
id|ztv-&gt;have_tuner
op_assign
l_int|0
suffix:semicolon
id|ztv-&gt;tuner_type
op_assign
l_int|0
suffix:semicolon
id|ztv-&gt;running
op_assign
l_int|0
suffix:semicolon
id|ztv-&gt;users
op_assign
l_int|0
suffix:semicolon
id|ztv-&gt;lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
id|ztv-&gt;workqueue
op_assign
l_int|0
suffix:semicolon
id|ztv-&gt;fieldnr
op_assign
l_int|0
suffix:semicolon
id|ztv-&gt;lastfieldnr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|triton1
)paren
id|zrand
c_func
(paren
op_complement
id|ZORAN_VDC_TRICOM
comma
id|ZORAN_VDC
)paren
suffix:semicolon
multiline_comment|/* external FL determines TOP frame */
id|zror
c_func
(paren
id|ZORAN_VFEC_EXTFL
comma
id|ZORAN_VFEC
)paren
suffix:semicolon
multiline_comment|/* set HSpol */
r_if
c_cond
(paren
id|ztv-&gt;card-&gt;hsync_pos
)paren
id|zrwrite
c_func
(paren
id|ZORAN_VFEH_HSPOL
comma
id|ZORAN_VFEH
)paren
suffix:semicolon
multiline_comment|/* set VSpol */
r_if
c_cond
(paren
id|ztv-&gt;card-&gt;vsync_pos
)paren
id|zrwrite
c_func
(paren
id|ZORAN_VFEV_VSPOL
comma
id|ZORAN_VFEV
)paren
suffix:semicolon
multiline_comment|/* Set the proper General Purpuse register bits */
multiline_comment|/* implicit: no softreset, 0 waitstates */
id|zrwrite
c_func
(paren
id|ZORAN_PCI_SOFTRESET
op_or
(paren
id|ztv-&gt;card-&gt;gpdir
op_lshift
l_int|0
)paren
comma
id|ZORAN_PCI
)paren
suffix:semicolon
multiline_comment|/* implicit: 3 duration and recovery PCI clocks on guest 0-3 */
id|zrwrite
c_func
(paren
id|ztv-&gt;card-&gt;gpval
op_lshift
l_int|24
comma
id|ZORAN_GUEST
)paren
suffix:semicolon
multiline_comment|/* clear interrupt status */
id|zrwrite
c_func
(paren
op_complement
l_int|0
comma
id|ZORAN_ISR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * i2c template&n;&t; */
id|ztv-&gt;i2c
op_assign
id|zoran_i2c_bus_template
suffix:semicolon
id|sprintf
c_func
(paren
id|ztv-&gt;i2c.name
comma
l_string|&quot;zoran-%d&quot;
comma
id|card
)paren
suffix:semicolon
id|ztv-&gt;i2c.data
op_assign
id|ztv
suffix:semicolon
multiline_comment|/*&n;&t; * Now add the template and register the device unit&n;&t; */
id|ztv-&gt;video_dev
op_assign
id|zr36120_template
suffix:semicolon
id|strcpy
c_func
(paren
id|ztv-&gt;video_dev.name
comma
id|ztv-&gt;i2c.name
)paren
suffix:semicolon
id|ztv-&gt;video_dev.priv
op_assign
id|ztv
suffix:semicolon
r_if
c_cond
(paren
id|video_register_device
c_func
(paren
op_amp
id|ztv-&gt;video_dev
comma
id|VFL_TYPE_GRABBER
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|ztv-&gt;vbi_dev
op_assign
id|vbi_template
suffix:semicolon
id|strcpy
c_func
(paren
id|ztv-&gt;vbi_dev.name
comma
id|ztv-&gt;i2c.name
)paren
suffix:semicolon
id|ztv-&gt;vbi_dev.priv
op_assign
id|ztv
suffix:semicolon
r_if
c_cond
(paren
id|video_register_device
c_func
(paren
op_amp
id|ztv-&gt;vbi_dev
comma
id|VFL_TYPE_VBI
)paren
OL
l_int|0
)paren
(brace
id|video_unregister_device
c_func
(paren
op_amp
id|ztv-&gt;video_dev
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|i2c_register_bus
c_func
(paren
op_amp
id|ztv-&gt;i2c
)paren
suffix:semicolon
multiline_comment|/* set interrupt mask - the PIN enable will be set later */
id|zrwrite
c_func
(paren
id|ZORAN_ICR_GIRQ0
op_or
id|ZORAN_ICR_GIRQ1
op_or
id|ZORAN_ICR_CODE
comma
id|ZORAN_ICR
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: installed %s&bslash;n&quot;
comma
id|ztv-&gt;i2c.name
comma
id|ztv-&gt;card-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
DECL|function|release_zoran
r_void
id|__exit
id|release_zoran
c_func
(paren
r_int
id|max
)paren
(brace
r_struct
id|zoran
op_star
id|ztv
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ztv
op_assign
op_amp
id|zorans
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* turn off all capturing, DMA and IRQs */
multiline_comment|/* reset the zoran */
id|zrand
c_func
(paren
op_complement
id|ZORAN_PCI_SOFTRESET
comma
id|ZORAN_PCI
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|zror
c_func
(paren
id|ZORAN_PCI_SOFTRESET
comma
id|ZORAN_PCI
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* first disable interrupts before unmapping the memory! */
id|zrwrite
c_func
(paren
l_int|0
comma
id|ZORAN_ICR
)paren
suffix:semicolon
id|zrwrite
c_func
(paren
l_int|0xffffffffUL
comma
id|ZORAN_ISR
)paren
suffix:semicolon
multiline_comment|/* free it */
id|free_irq
c_func
(paren
id|ztv-&gt;dev-&gt;irq
comma
id|ztv
)paren
suffix:semicolon
multiline_comment|/* unregister i2c_bus */
id|i2c_unregister_bus
c_func
(paren
(paren
op_amp
id|ztv-&gt;i2c
)paren
)paren
suffix:semicolon
multiline_comment|/* unmap and free memory */
r_if
c_cond
(paren
id|ztv-&gt;zoran_mem
)paren
id|iounmap
c_func
(paren
id|ztv-&gt;zoran_mem
)paren
suffix:semicolon
id|video_unregister_device
c_func
(paren
op_amp
id|ztv-&gt;video_dev
)paren
suffix:semicolon
id|video_unregister_device
c_func
(paren
op_amp
id|ztv-&gt;vbi_dev
)paren
suffix:semicolon
)brace
)brace
DECL|function|zr36120_exit
r_void
id|__exit
id|zr36120_exit
c_func
(paren
r_void
)paren
(brace
id|release_zoran
c_func
(paren
id|zoran_cards
)paren
suffix:semicolon
)brace
DECL|function|zr36120_init
r_int
id|__init
id|zr36120_init
c_func
(paren
r_void
)paren
(brace
r_int
id|card
suffix:semicolon
id|handle_chipset
c_func
(paren
)paren
suffix:semicolon
id|zoran_cards
op_assign
id|find_zoran
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zoran_cards
OL
l_int|0
)paren
multiline_comment|/* no cards found, no need for a driver */
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* initialize Zorans */
r_for
c_loop
(paren
id|card
op_assign
l_int|0
suffix:semicolon
id|card
OL
id|zoran_cards
suffix:semicolon
id|card
op_increment
)paren
(brace
r_if
c_cond
(paren
id|init_zoran
c_func
(paren
id|card
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* only release the zorans we have registered */
id|release_zoran
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|zr36120_init
id|module_init
c_func
(paren
id|zr36120_init
)paren
suffix:semicolon
DECL|variable|zr36120_exit
id|module_exit
c_func
(paren
id|zr36120_exit
)paren
suffix:semicolon
eof
