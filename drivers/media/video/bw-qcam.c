multiline_comment|/*&n; *    QuickCam Driver For Video4Linux.&n; *&n; *&t;This version only works as a module.&n; *&n; *&t;Video4Linux conversion work by Alan Cox.&n; *&t;Parport compatibility by Phil Blundell.&n; *&t;Busy loop avoidance by Mark Cooke.&n; *&n; *    Module parameters:&n; *&n; *&t;maxpoll=&lt;1 - 5000&gt;&n; *&n; *&t;  When polling the QuickCam for a response, busy-wait for a&n; *&t;  maximum of this many loops. The default of 250 gives little&n; *&t;  impact on interactive response.&n; *&n; *&t;  NOTE: If this parameter is set too high, the processor&n; *&t;&t;will busy wait until this loop times out, and then&n; *&t;&t;slowly poll for a further 5 seconds before failing&n; *&t;&t;the transaction. You have been warned.&n; *&n; *&t;yieldlines=&lt;1 - 250&gt;&n; *&n; *&t;  When acquiring a frame from the camera, the data gathering&n; *&t;  loop will yield back to the scheduler after completing&n; *&t;  this many lines. The default of 4 provides a trade-off&n; *&t;  between increased frame acquisition time and impact on&n; *&t;  interactive response.&n; */
multiline_comment|/* qcam-lib.c -- Library for programming with the Connectix QuickCam.&n; * See the included documentation for usage instructions and details&n; * of the protocol involved. */
multiline_comment|/* Version 0.5, August 4, 1996 */
multiline_comment|/* Version 0.7, August 27, 1996 */
multiline_comment|/* Version 0.9, November 17, 1996 */
multiline_comment|/******************************************************************&n;&n;Copyright (C) 1996 by Scott Laird&n;&n;Permission is hereby granted, free of charge, to any person obtaining&n;a copy of this software and associated documentation files (the&n;&quot;Software&quot;), to deal in the Software without restriction, including&n;without limitation the rights to use, copy, modify, merge, publish,&n;distribute, sublicense, and/or sell copies of the Software, and to&n;permit persons to whom the Software is furnished to do so, subject to&n;the following conditions:&n;&n;The above copyright notice and this permission notice shall be&n;included in all copies or substantial portions of the Software.&n;&n;THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,&n;EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF&n;MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.&n;IN NO EVENT SHALL SCOTT LAIRD BE LIABLE FOR ANY CLAIM, DAMAGES OR&n;OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,&n;ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR&n;OTHER DEALINGS IN THE SOFTWARE.&n;&n;******************************************************************/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/videodev.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;bw-qcam.h&quot;
DECL|variable|maxpoll
r_static
r_int
r_int
id|maxpoll
op_assign
l_int|250
suffix:semicolon
multiline_comment|/* Maximum busy-loop count for qcam I/O */
DECL|variable|yieldlines
r_static
r_int
r_int
id|yieldlines
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* Yield after this many during capture */
macro_line|#if LINUX_VERSION_CODE &gt;= 0x020117
id|MODULE_PARM
c_func
(paren
id|maxpoll
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|yieldlines
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
DECL|function|read_lpstatus
r_extern
id|__inline__
r_int
id|read_lpstatus
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
)paren
(brace
r_return
id|parport_read_status
c_func
(paren
id|q-&gt;pport
)paren
suffix:semicolon
)brace
DECL|function|read_lpcontrol
r_extern
id|__inline__
r_int
id|read_lpcontrol
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
)paren
(brace
r_return
id|parport_read_control
c_func
(paren
id|q-&gt;pport
)paren
suffix:semicolon
)brace
DECL|function|read_lpdata
r_extern
id|__inline__
r_int
id|read_lpdata
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
)paren
(brace
r_return
id|parport_read_data
c_func
(paren
id|q-&gt;pport
)paren
suffix:semicolon
)brace
DECL|function|write_lpdata
r_extern
id|__inline__
r_void
id|write_lpdata
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
comma
r_int
id|d
)paren
(brace
id|parport_write_data
c_func
(paren
id|q-&gt;pport
comma
id|d
)paren
suffix:semicolon
)brace
DECL|function|write_lpcontrol
r_extern
id|__inline__
r_void
id|write_lpcontrol
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
comma
r_int
id|d
)paren
(brace
id|parport_write_control
c_func
(paren
id|q-&gt;pport
comma
id|d
)paren
suffix:semicolon
)brace
r_static
r_int
id|qc_waithand
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
comma
r_int
id|val
)paren
suffix:semicolon
r_static
r_int
id|qc_command
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
comma
r_int
id|command
)paren
suffix:semicolon
r_static
r_int
id|qc_readparam
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
)paren
suffix:semicolon
r_static
r_int
id|qc_setscanmode
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
)paren
suffix:semicolon
r_static
r_int
id|qc_readbytes
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
comma
r_char
id|buffer
(braket
)braket
)paren
suffix:semicolon
DECL|variable|qcam_template
r_static
r_struct
id|video_device
id|qcam_template
suffix:semicolon
DECL|function|qc_calibrate
r_static
r_int
id|qc_calibrate
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
)paren
(brace
multiline_comment|/*&n;&t; *&t;Bugfix by Hanno Mueller hmueller@kabel.de, Mai 21 96&n;&t; *&t;The white balance is an individiual value for each&n;&t; *&t;quickcam.&n;&t; */
r_int
id|value
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|qc_command
c_func
(paren
id|q
comma
l_int|27
)paren
suffix:semicolon
multiline_comment|/* AutoAdjustOffset */
id|qc_command
c_func
(paren
id|q
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Dummy Parameter, ignored by the camera */
multiline_comment|/* GetOffset (33) will read 255 until autocalibration */
multiline_comment|/* is finished. After that, a value of 1-254 will be */
multiline_comment|/* returned. */
r_do
(brace
id|qc_command
c_func
(paren
id|q
comma
l_int|33
)paren
suffix:semicolon
id|value
op_assign
id|qc_readparam
c_func
(paren
id|q
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|value
op_eq
l_int|0xff
op_logical_and
id|count
OL
l_int|2048
)paren
suffix:semicolon
id|q-&gt;whitebal
op_assign
id|value
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
multiline_comment|/* Initialize the QuickCam driver control structure.  This is where&n; * defaults are set for people who don&squot;t have a config file.*/
DECL|function|qcam_init
r_static
r_struct
id|qcam_device
op_star
id|qcam_init
c_func
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
r_struct
id|qcam_device
op_star
id|q
suffix:semicolon
id|q
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|qcam_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|q-&gt;pport
op_assign
id|port
suffix:semicolon
id|q-&gt;pdev
op_assign
id|parport_register_device
c_func
(paren
id|port
comma
l_string|&quot;bw-qcam&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;pdev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bw-qcam: couldn&squot;t register for %s.&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|q
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|q-&gt;vdev
comma
op_amp
id|qcam_template
comma
r_sizeof
(paren
id|qcam_template
)paren
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|q-&gt;lock
)paren
suffix:semicolon
id|q-&gt;port_mode
op_assign
(paren
id|QC_ANY
op_or
id|QC_NOTSET
)paren
suffix:semicolon
id|q-&gt;width
op_assign
l_int|320
suffix:semicolon
id|q-&gt;height
op_assign
l_int|240
suffix:semicolon
id|q-&gt;bpp
op_assign
l_int|4
suffix:semicolon
id|q-&gt;transfer_scale
op_assign
l_int|2
suffix:semicolon
id|q-&gt;contrast
op_assign
l_int|192
suffix:semicolon
id|q-&gt;brightness
op_assign
l_int|180
suffix:semicolon
id|q-&gt;whitebal
op_assign
l_int|105
suffix:semicolon
id|q-&gt;top
op_assign
l_int|1
suffix:semicolon
id|q-&gt;left
op_assign
l_int|14
suffix:semicolon
id|q-&gt;mode
op_assign
op_minus
l_int|1
suffix:semicolon
id|q-&gt;status
op_assign
id|QC_PARAM_CHANGE
suffix:semicolon
r_return
id|q
suffix:semicolon
)brace
multiline_comment|/* qc_command is probably a bit of a misnomer -- it&squot;s used to send&n; * bytes *to* the camera.  Generally, these bytes are either commands&n; * or arguments to commands, so the name fits, but it still bugs me a&n; * bit.  See the documentation for a list of commands. */
DECL|function|qc_command
r_static
r_int
id|qc_command
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
comma
r_int
id|command
)paren
(brace
r_int
id|n1
comma
id|n2
suffix:semicolon
r_int
id|cmd
suffix:semicolon
id|write_lpdata
c_func
(paren
id|q
comma
id|command
)paren
suffix:semicolon
id|write_lpcontrol
c_func
(paren
id|q
comma
l_int|6
)paren
suffix:semicolon
id|n1
op_assign
id|qc_waithand
c_func
(paren
id|q
comma
l_int|1
)paren
suffix:semicolon
id|write_lpcontrol
c_func
(paren
id|q
comma
l_int|0xe
)paren
suffix:semicolon
id|n2
op_assign
id|qc_waithand
c_func
(paren
id|q
comma
l_int|0
)paren
suffix:semicolon
id|cmd
op_assign
(paren
id|n1
op_amp
l_int|0xf0
)paren
op_or
(paren
(paren
id|n2
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)paren
suffix:semicolon
r_return
id|cmd
suffix:semicolon
)brace
DECL|function|qc_readparam
r_static
r_int
id|qc_readparam
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
)paren
(brace
r_int
id|n1
comma
id|n2
suffix:semicolon
r_int
id|cmd
suffix:semicolon
id|write_lpcontrol
c_func
(paren
id|q
comma
l_int|6
)paren
suffix:semicolon
id|n1
op_assign
id|qc_waithand
c_func
(paren
id|q
comma
l_int|1
)paren
suffix:semicolon
id|write_lpcontrol
c_func
(paren
id|q
comma
l_int|0xe
)paren
suffix:semicolon
id|n2
op_assign
id|qc_waithand
c_func
(paren
id|q
comma
l_int|0
)paren
suffix:semicolon
id|cmd
op_assign
(paren
id|n1
op_amp
l_int|0xf0
)paren
op_or
(paren
(paren
id|n2
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)paren
suffix:semicolon
r_return
id|cmd
suffix:semicolon
)brace
multiline_comment|/* qc_waithand busy-waits for a handshake signal from the QuickCam.&n; * Almost all communication with the camera requires handshaking. */
DECL|function|qc_waithand
r_static
r_int
id|qc_waithand
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
comma
r_int
id|val
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
id|runs
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|status
op_assign
id|read_lpstatus
c_func
(paren
id|q
)paren
)paren
op_amp
l_int|8
)paren
)paren
(brace
multiline_comment|/* 1000 is enough spins on the I/O for all normal&n;&t;&t;&t;   cases, at that point we start to poll slowly &n;&t;&t;&t;   until the camera wakes up. However, we are&n;&t;&t;&t;   busy blocked until the camera responds, so&n;&t;&t;&t;   setting it lower is much better for interactive&n;&t;&t;&t;   response. */
r_if
c_cond
(paren
id|runs
op_increment
OG
id|maxpoll
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|200
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|runs
OG
(paren
id|maxpoll
op_plus
l_int|1000
)paren
)paren
(brace
multiline_comment|/* 5 seconds */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_while
c_loop
(paren
(paren
(paren
id|status
op_assign
id|read_lpstatus
c_func
(paren
id|q
)paren
)paren
op_amp
l_int|8
)paren
)paren
(brace
multiline_comment|/* 1000 is enough spins on the I/O for all normal&n;&t;&t;&t;   cases, at that point we start to poll slowly &n;&t;&t;&t;   until the camera wakes up. However, we are&n;&t;&t;&t;   busy blocked until the camera responds, so&n;&t;&t;&t;   setting it lower is much better for interactive&n;&t;&t;&t;   response. */
r_if
c_cond
(paren
id|runs
op_increment
OG
id|maxpoll
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|200
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|runs
op_increment
OG
(paren
id|maxpoll
op_plus
l_int|1000
)paren
)paren
(brace
multiline_comment|/* 5 seconds */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* Waithand2 is used when the qcam is in bidirectional mode, and the&n; * handshaking signal is CamRdy2 (bit 0 of data reg) instead of CamRdy1&n; * (bit 3 of status register).  It also returns the last value read,&n; * since this data is useful. */
DECL|function|qc_waithand2
r_static
r_int
r_int
id|qc_waithand2
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
comma
r_int
id|val
)paren
(brace
r_int
r_int
id|status
suffix:semicolon
r_int
id|runs
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|status
op_assign
id|read_lpdata
c_func
(paren
id|q
)paren
suffix:semicolon
multiline_comment|/* 1000 is enough spins on the I/O for all normal&n;&t;&t;   cases, at that point we start to poll slowly &n;&t;&t;   until the camera wakes up. However, we are&n;&t;&t;   busy blocked until the camera responds, so&n;&t;&t;   setting it lower is much better for interactive&n;&t;&t;   response. */
r_if
c_cond
(paren
id|runs
op_increment
OG
id|maxpoll
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|200
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|runs
op_increment
OG
(paren
id|maxpoll
op_plus
l_int|1000
)paren
)paren
(brace
multiline_comment|/* 5 seconds */
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|status
op_amp
l_int|1
)paren
op_ne
id|val
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* Try to detect a QuickCam.  It appears to flash the upper 4 bits of&n;   the status register at 5-10 Hz.  This is only used in the autoprobe&n;   code.  Be aware that this isn&squot;t the way Connectix detects the&n;   camera (they send a reset and try to handshake), but this should be&n;   almost completely safe, while their method screws up my printer if&n;   I plug it in before the camera. */
DECL|function|qc_detect
r_static
r_int
id|qc_detect
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
)paren
(brace
r_int
id|reg
comma
id|lastreg
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|lastreg
op_assign
id|reg
op_assign
id|read_lpstatus
c_func
(paren
id|q
)paren
op_amp
l_int|0xf0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|500
suffix:semicolon
id|i
op_increment
)paren
(brace
id|reg
op_assign
id|read_lpstatus
c_func
(paren
id|q
)paren
op_amp
l_int|0xf0
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_ne
id|lastreg
)paren
id|count
op_increment
suffix:semicolon
id|lastreg
op_assign
id|reg
suffix:semicolon
id|mdelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* Force camera detection during testing. Sometimes the camera&n;&t;   won&squot;t be flashing these bits. Possibly unloading the module&n;&t;   in the middle of a grab? Or some timeout condition?&n;&t;   I&squot;ve seen this parameter as low as 19 on my 450Mhz box - mpc */
id|printk
c_func
(paren
l_string|&quot;Debugging: QCam detection counter &lt;30-200 counts as detected&gt;: %d&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/* Be (even more) liberal in what you accept...  */
multiline_comment|/*&t;if (count &gt; 30 &amp;&amp; count &lt; 200) */
r_if
c_cond
(paren
id|count
OG
l_int|20
op_logical_and
id|count
OL
l_int|300
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* found */
r_else
r_return
l_int|0
suffix:semicolon
multiline_comment|/* not found */
)brace
multiline_comment|/* Reset the QuickCam.  This uses the same sequence the Windows&n; * QuickPic program uses.  Someone with a bi-directional port should&n; * check that bi-directional mode is detected right, and then&n; * implement bi-directional mode in qc_readbyte(). */
DECL|function|qc_reset
r_static
r_void
id|qc_reset
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
)paren
(brace
r_switch
c_cond
(paren
id|q-&gt;port_mode
op_amp
id|QC_FORCE_MASK
)paren
(brace
r_case
id|QC_FORCE_UNIDIR
suffix:colon
id|q-&gt;port_mode
op_assign
(paren
id|q-&gt;port_mode
op_amp
op_complement
id|QC_MODE_MASK
)paren
op_or
id|QC_UNIDIR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QC_FORCE_BIDIR
suffix:colon
id|q-&gt;port_mode
op_assign
(paren
id|q-&gt;port_mode
op_amp
op_complement
id|QC_MODE_MASK
)paren
op_or
id|QC_BIDIR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QC_ANY
suffix:colon
id|write_lpcontrol
c_func
(paren
id|q
comma
l_int|0x20
)paren
suffix:semicolon
id|write_lpdata
c_func
(paren
id|q
comma
l_int|0x75
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_lpdata
c_func
(paren
id|q
)paren
op_ne
l_int|0x75
)paren
(brace
id|q-&gt;port_mode
op_assign
(paren
id|q-&gt;port_mode
op_amp
op_complement
id|QC_MODE_MASK
)paren
op_or
id|QC_BIDIR
suffix:semicolon
)brace
r_else
(brace
id|q-&gt;port_mode
op_assign
(paren
id|q-&gt;port_mode
op_amp
op_complement
id|QC_MODE_MASK
)paren
op_or
id|QC_UNIDIR
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|write_lpcontrol
c_func
(paren
id|q
comma
l_int|0xb
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|250
)paren
suffix:semicolon
id|write_lpcontrol
c_func
(paren
id|q
comma
l_int|0xe
)paren
suffix:semicolon
id|qc_setscanmode
c_func
(paren
id|q
)paren
suffix:semicolon
multiline_comment|/* in case port_mode changed */
)brace
multiline_comment|/* Decide which scan mode to use.  There&squot;s no real requirement that&n; * the scanmode match the resolution in q-&gt;height and q-&gt; width -- the&n; * camera takes the picture at the resolution specified in the&n; * &quot;scanmode&quot; and then returns the image at the resolution specified&n; * with the resolution commands.  If the scan is bigger than the&n; * requested resolution, the upper-left hand corner of the scan is&n; * returned.  If the scan is smaller, then the rest of the image&n; * returned contains garbage. */
DECL|function|qc_setscanmode
r_static
r_int
id|qc_setscanmode
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
)paren
(brace
r_int
id|old_mode
op_assign
id|q-&gt;mode
suffix:semicolon
r_switch
c_cond
(paren
id|q-&gt;transfer_scale
)paren
(brace
r_case
l_int|1
suffix:colon
id|q-&gt;mode
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|q-&gt;mode
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|q-&gt;mode
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|q-&gt;bpp
)paren
(brace
r_case
l_int|4
suffix:colon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|q-&gt;mode
op_add_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|q-&gt;port_mode
op_amp
id|QC_MODE_MASK
)paren
(brace
r_case
id|QC_BIDIR
suffix:colon
id|q-&gt;mode
op_add_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QC_NOTSET
suffix:colon
r_case
id|QC_UNIDIR
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|q-&gt;mode
op_ne
id|old_mode
)paren
id|q-&gt;status
op_or_assign
id|QC_PARAM_CHANGE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Reset the QuickCam and program for brightness, contrast,&n; * white-balance, and resolution. */
DECL|function|qc_set
r_void
id|qc_set
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
)paren
(brace
r_int
id|val
suffix:semicolon
r_int
id|val2
suffix:semicolon
id|qc_reset
c_func
(paren
id|q
)paren
suffix:semicolon
multiline_comment|/* Set the brightness.  Yes, this is repetitive, but it works.&n;&t; * Shorter versions seem to fail subtly.  Feel free to try :-). */
multiline_comment|/* I think the problem was in qc_command, not here -- bls */
id|qc_command
c_func
(paren
id|q
comma
l_int|0xb
)paren
suffix:semicolon
id|qc_command
c_func
(paren
id|q
comma
id|q-&gt;brightness
)paren
suffix:semicolon
id|val
op_assign
id|q-&gt;height
op_div
id|q-&gt;transfer_scale
suffix:semicolon
id|qc_command
c_func
(paren
id|q
comma
l_int|0x11
)paren
suffix:semicolon
id|qc_command
c_func
(paren
id|q
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q-&gt;port_mode
op_amp
id|QC_MODE_MASK
)paren
op_eq
id|QC_UNIDIR
op_logical_and
id|q-&gt;bpp
op_eq
l_int|6
)paren
(brace
multiline_comment|/* The normal &quot;transfers per line&quot; calculation doesn&squot;t seem to work&n;&t;&t;   as expected here (and yet it works fine in qc_scan).  No idea&n;&t;&t;   why this case is the odd man out.  Fortunately, Laird&squot;s original&n;&t;&t;   working version gives me a good way to guess at working values.&n;&t;&t;   -- bls */
id|val
op_assign
id|q-&gt;width
suffix:semicolon
id|val2
op_assign
id|q-&gt;transfer_scale
op_star
l_int|4
suffix:semicolon
)brace
r_else
(brace
id|val
op_assign
id|q-&gt;width
op_star
id|q-&gt;bpp
suffix:semicolon
id|val2
op_assign
(paren
(paren
(paren
id|q-&gt;port_mode
op_amp
id|QC_MODE_MASK
)paren
op_eq
id|QC_BIDIR
)paren
ques
c_cond
l_int|24
suffix:colon
l_int|8
)paren
op_star
id|q-&gt;transfer_scale
suffix:semicolon
)brace
id|val
op_assign
(paren
id|val
op_plus
id|val2
op_minus
l_int|1
)paren
op_div
id|val2
suffix:semicolon
id|qc_command
c_func
(paren
id|q
comma
l_int|0x13
)paren
suffix:semicolon
id|qc_command
c_func
(paren
id|q
comma
id|val
)paren
suffix:semicolon
multiline_comment|/* Setting top and left -- bls */
id|qc_command
c_func
(paren
id|q
comma
l_int|0xd
)paren
suffix:semicolon
id|qc_command
c_func
(paren
id|q
comma
id|q-&gt;top
)paren
suffix:semicolon
id|qc_command
c_func
(paren
id|q
comma
l_int|0xf
)paren
suffix:semicolon
id|qc_command
c_func
(paren
id|q
comma
id|q-&gt;left
op_div
l_int|2
)paren
suffix:semicolon
id|qc_command
c_func
(paren
id|q
comma
l_int|0x19
)paren
suffix:semicolon
id|qc_command
c_func
(paren
id|q
comma
id|q-&gt;contrast
)paren
suffix:semicolon
id|qc_command
c_func
(paren
id|q
comma
l_int|0x1f
)paren
suffix:semicolon
id|qc_command
c_func
(paren
id|q
comma
id|q-&gt;whitebal
)paren
suffix:semicolon
multiline_comment|/* Clear flag that we must update the grabbing parameters on the camera&n;&t;   before we grab the next frame */
id|q-&gt;status
op_and_assign
(paren
op_complement
id|QC_PARAM_CHANGE
)paren
suffix:semicolon
)brace
multiline_comment|/* Qc_readbytes reads some bytes from the QC and puts them in&n;   the supplied buffer.  It returns the number of bytes read,&n;   or -1 on error. */
DECL|function|qc_readbytes
r_extern
id|__inline__
r_int
id|qc_readbytes
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
comma
r_char
id|buffer
(braket
)braket
)paren
(brace
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|hi
comma
id|lo
suffix:semicolon
r_int
r_int
id|hi2
comma
id|lo2
suffix:semicolon
r_static
r_int
id|state
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
(brace
id|state
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|q-&gt;port_mode
op_amp
id|QC_MODE_MASK
)paren
(brace
r_case
id|QC_BIDIR
suffix:colon
multiline_comment|/* Bi-directional Port */
id|write_lpcontrol
c_func
(paren
id|q
comma
l_int|0x26
)paren
suffix:semicolon
id|lo
op_assign
(paren
id|qc_waithand2
c_func
(paren
id|q
comma
l_int|1
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|hi
op_assign
(paren
id|read_lpstatus
c_func
(paren
id|q
)paren
op_rshift
l_int|3
)paren
op_amp
l_int|0x1f
suffix:semicolon
id|write_lpcontrol
c_func
(paren
id|q
comma
l_int|0x2e
)paren
suffix:semicolon
id|lo2
op_assign
(paren
id|qc_waithand2
c_func
(paren
id|q
comma
l_int|0
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|hi2
op_assign
(paren
id|read_lpstatus
c_func
(paren
id|q
)paren
op_rshift
l_int|3
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_switch
c_cond
(paren
id|q-&gt;bpp
)paren
(brace
r_case
l_int|4
suffix:colon
id|buffer
(braket
l_int|0
)braket
op_assign
id|lo
op_amp
l_int|0xf
suffix:semicolon
id|buffer
(braket
l_int|1
)braket
op_assign
(paren
(paren
id|lo
op_amp
l_int|0x70
)paren
op_rshift
l_int|4
)paren
op_or
(paren
(paren
id|hi
op_amp
l_int|1
)paren
op_lshift
l_int|3
)paren
suffix:semicolon
id|buffer
(braket
l_int|2
)braket
op_assign
(paren
id|hi
op_amp
l_int|0x1e
)paren
op_rshift
l_int|1
suffix:semicolon
id|buffer
(braket
l_int|3
)braket
op_assign
id|lo2
op_amp
l_int|0xf
suffix:semicolon
id|buffer
(braket
l_int|4
)braket
op_assign
(paren
(paren
id|lo2
op_amp
l_int|0x70
)paren
op_rshift
l_int|4
)paren
op_or
(paren
(paren
id|hi2
op_amp
l_int|1
)paren
op_lshift
l_int|3
)paren
suffix:semicolon
id|buffer
(braket
l_int|5
)braket
op_assign
(paren
id|hi2
op_amp
l_int|0x1e
)paren
op_rshift
l_int|1
suffix:semicolon
id|ret
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|buffer
(braket
l_int|0
)braket
op_assign
id|lo
op_amp
l_int|0x3f
suffix:semicolon
id|buffer
(braket
l_int|1
)braket
op_assign
(paren
(paren
id|lo
op_amp
l_int|0x40
)paren
op_rshift
l_int|6
)paren
op_or
(paren
id|hi
op_lshift
l_int|1
)paren
suffix:semicolon
id|buffer
(braket
l_int|2
)braket
op_assign
id|lo2
op_amp
l_int|0x3f
suffix:semicolon
id|buffer
(braket
l_int|3
)braket
op_assign
(paren
(paren
id|lo2
op_amp
l_int|0x40
)paren
op_rshift
l_int|6
)paren
op_or
(paren
id|hi2
op_lshift
l_int|1
)paren
suffix:semicolon
id|ret
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|QC_UNIDIR
suffix:colon
multiline_comment|/* Unidirectional Port */
id|write_lpcontrol
c_func
(paren
id|q
comma
l_int|6
)paren
suffix:semicolon
id|lo
op_assign
(paren
id|qc_waithand
c_func
(paren
id|q
comma
l_int|1
)paren
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
suffix:semicolon
id|write_lpcontrol
c_func
(paren
id|q
comma
l_int|0xe
)paren
suffix:semicolon
id|hi
op_assign
(paren
id|qc_waithand
c_func
(paren
id|q
comma
l_int|0
)paren
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
suffix:semicolon
r_switch
c_cond
(paren
id|q-&gt;bpp
)paren
(brace
r_case
l_int|4
suffix:colon
id|buffer
(braket
l_int|0
)braket
op_assign
id|lo
suffix:semicolon
id|buffer
(braket
l_int|1
)braket
op_assign
id|hi
suffix:semicolon
id|ret
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
l_int|0
suffix:colon
id|buffer
(braket
l_int|0
)braket
op_assign
(paren
id|lo
op_lshift
l_int|2
)paren
op_or
(paren
(paren
id|hi
op_amp
l_int|0xc
)paren
op_rshift
l_int|2
)paren
suffix:semicolon
id|q-&gt;saved_bits
op_assign
(paren
id|hi
op_amp
l_int|3
)paren
op_lshift
l_int|4
suffix:semicolon
id|state
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|buffer
(braket
l_int|0
)braket
op_assign
id|lo
op_or
id|q-&gt;saved_bits
suffix:semicolon
id|q-&gt;saved_bits
op_assign
id|hi
op_lshift
l_int|2
suffix:semicolon
id|state
op_assign
l_int|2
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|buffer
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|lo
op_amp
l_int|0xc
)paren
op_rshift
l_int|2
)paren
op_or
id|q-&gt;saved_bits
suffix:semicolon
id|buffer
(braket
l_int|1
)braket
op_assign
(paren
(paren
id|lo
op_amp
l_int|3
)paren
op_lshift
l_int|4
)paren
op_or
id|hi
suffix:semicolon
id|state
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* requests a scan from the camera.  It sends the correct instructions&n; * to the camera and then reads back the correct number of bytes.  In&n; * previous versions of this routine the return structure contained&n; * the raw output from the camera, and there was a &squot;qc_convertscan&squot;&n; * function that converted that to a useful format.  In version 0.3 I&n; * rolled qc_convertscan into qc_scan and now I only return the&n; * converted scan.  The format is just an one-dimensional array of&n; * characters, one for each pixel, with 0=black up to n=white, where&n; * n=2^(bit depth)-1.  Ask me for more details if you don&squot;t understand&n; * this. */
DECL|function|qc_capture
r_int
id|qc_capture
c_func
(paren
r_struct
id|qcam_device
op_star
id|q
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|i
comma
id|j
comma
id|k
comma
id|yield
suffix:semicolon
r_int
id|bytes
suffix:semicolon
r_int
id|linestotrans
comma
id|transperline
suffix:semicolon
r_int
id|divisor
suffix:semicolon
r_int
id|pixels_per_line
suffix:semicolon
r_int
id|pixels_read
op_assign
l_int|0
suffix:semicolon
r_int
id|got
op_assign
l_int|0
suffix:semicolon
r_char
id|buffer
(braket
l_int|6
)braket
suffix:semicolon
r_int
id|shift
op_assign
l_int|8
op_minus
id|q-&gt;bpp
suffix:semicolon
r_char
id|invert
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;mode
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|qc_command
c_func
(paren
id|q
comma
l_int|0x7
)paren
suffix:semicolon
id|qc_command
c_func
(paren
id|q
comma
id|q-&gt;mode
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q-&gt;port_mode
op_amp
id|QC_MODE_MASK
)paren
op_eq
id|QC_BIDIR
)paren
(brace
id|write_lpcontrol
c_func
(paren
id|q
comma
l_int|0x2e
)paren
suffix:semicolon
multiline_comment|/* turn port around */
id|write_lpcontrol
c_func
(paren
id|q
comma
l_int|0x26
)paren
suffix:semicolon
(paren
r_void
)paren
id|qc_waithand
c_func
(paren
id|q
comma
l_int|1
)paren
suffix:semicolon
id|write_lpcontrol
c_func
(paren
id|q
comma
l_int|0x2e
)paren
suffix:semicolon
(paren
r_void
)paren
id|qc_waithand
c_func
(paren
id|q
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* strange -- should be 15:63 below, but 4bpp is odd */
id|invert
op_assign
(paren
id|q-&gt;bpp
op_eq
l_int|4
)paren
ques
c_cond
l_int|16
suffix:colon
l_int|63
suffix:semicolon
id|linestotrans
op_assign
id|q-&gt;height
op_div
id|q-&gt;transfer_scale
suffix:semicolon
id|pixels_per_line
op_assign
id|q-&gt;width
op_div
id|q-&gt;transfer_scale
suffix:semicolon
id|transperline
op_assign
id|q-&gt;width
op_star
id|q-&gt;bpp
suffix:semicolon
id|divisor
op_assign
(paren
(paren
(paren
id|q-&gt;port_mode
op_amp
id|QC_MODE_MASK
)paren
op_eq
id|QC_BIDIR
)paren
ques
c_cond
l_int|24
suffix:colon
l_int|8
)paren
op_star
id|q-&gt;transfer_scale
suffix:semicolon
id|transperline
op_assign
(paren
id|transperline
op_plus
id|divisor
op_minus
l_int|1
)paren
op_div
id|divisor
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|yield
op_assign
id|yieldlines
suffix:semicolon
id|i
OL
id|linestotrans
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|pixels_read
op_assign
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|transperline
suffix:semicolon
id|j
op_increment
)paren
(brace
id|bytes
op_assign
id|qc_readbytes
c_func
(paren
id|q
comma
id|buffer
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|bytes
op_logical_and
(paren
id|pixels_read
op_plus
id|k
)paren
OL
id|pixels_per_line
suffix:semicolon
id|k
op_increment
)paren
(brace
r_int
id|o
suffix:semicolon
r_if
c_cond
(paren
id|buffer
(braket
id|k
)braket
op_eq
l_int|0
op_logical_and
id|invert
op_eq
l_int|16
)paren
(brace
multiline_comment|/* 4bpp is odd (again) -- inverter is 16, not 15, but output&n;&t;&t;&t;&t;&t;   must be 0-15 -- bls */
id|buffer
(braket
id|k
)braket
op_assign
l_int|16
suffix:semicolon
)brace
id|o
op_assign
id|i
op_star
id|pixels_per_line
op_plus
id|pixels_read
op_plus
id|k
suffix:semicolon
r_if
c_cond
(paren
id|o
OL
id|len
)paren
(brace
id|got
op_increment
suffix:semicolon
id|put_user
c_func
(paren
(paren
id|invert
op_minus
id|buffer
(braket
id|k
)braket
)paren
op_lshift
id|shift
comma
id|buf
op_plus
id|o
)paren
suffix:semicolon
)brace
)brace
id|pixels_read
op_add_assign
id|bytes
suffix:semicolon
)brace
(paren
r_void
)paren
id|qc_readbytes
c_func
(paren
id|q
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset state machine */
multiline_comment|/* Grabbing an entire frame from the quickcam is a lengthy&n;&t;&t;   process. We don&squot;t (usually) want to busy-block the&n;&t;&t;   processor for the entire frame. yieldlines is a module&n;&t;&t;   parameter. If we yield every line, the minimum frame&n;&t;&t;   time will be 240 / 200 = 1.2 seconds. The compile-time&n;&t;&t;   default is to yield every 4 lines. */
r_if
c_cond
(paren
id|i
op_ge
id|yield
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|200
)paren
suffix:semicolon
id|yield
op_assign
id|i
op_plus
id|yieldlines
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|q-&gt;port_mode
op_amp
id|QC_MODE_MASK
)paren
op_eq
id|QC_BIDIR
)paren
(brace
id|write_lpcontrol
c_func
(paren
id|q
comma
l_int|2
)paren
suffix:semicolon
id|write_lpcontrol
c_func
(paren
id|q
comma
l_int|6
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|write_lpcontrol
c_func
(paren
id|q
comma
l_int|0xe
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|got
OL
id|len
)paren
(brace
r_return
id|got
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Video4linux interfacing&n; */
DECL|function|qcam_open
r_static
r_int
id|qcam_open
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_int
id|flags
)paren
(brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|qcam_close
r_static
r_void
id|qcam_close
c_func
(paren
r_struct
id|video_device
op_star
id|dev
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|function|qcam_write
r_static
r_int
id|qcam_write
c_func
(paren
r_struct
id|video_device
op_star
id|v
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|count
comma
r_int
id|noblock
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|qcam_ioctl
r_static
r_int
id|qcam_ioctl
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|qcam_device
op_star
id|qcam
op_assign
(paren
r_struct
id|qcam_device
op_star
)paren
id|dev
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|VIDIOCGCAP
suffix:colon
(brace
r_struct
id|video_capability
id|b
suffix:semicolon
id|strcpy
c_func
(paren
id|b.name
comma
l_string|&quot;Quickcam&quot;
)paren
suffix:semicolon
id|b.type
op_assign
id|VID_TYPE_CAPTURE
op_or
id|VID_TYPE_SCALES
op_or
id|VID_TYPE_MONOCHROME
suffix:semicolon
id|b.channels
op_assign
l_int|1
suffix:semicolon
id|b.audios
op_assign
l_int|0
suffix:semicolon
id|b.maxwidth
op_assign
l_int|320
suffix:semicolon
id|b.maxheight
op_assign
l_int|240
suffix:semicolon
id|b.minwidth
op_assign
l_int|80
suffix:semicolon
id|b.minheight
op_assign
l_int|60
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|b
comma
r_sizeof
(paren
id|b
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGCHAN
suffix:colon
(brace
r_struct
id|video_channel
id|v
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|v
comma
id|arg
comma
r_sizeof
(paren
id|v
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|v.channel
op_ne
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|v.flags
op_assign
l_int|0
suffix:semicolon
id|v.tuners
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Good question.. its composite or SVHS so.. */
id|v.type
op_assign
id|VIDEO_TYPE_CAMERA
suffix:semicolon
id|strcpy
c_func
(paren
id|v.name
comma
l_string|&quot;Camera&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|v
comma
r_sizeof
(paren
id|v
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCSCHAN
suffix:colon
(brace
r_int
id|v
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|v
comma
id|arg
comma
r_sizeof
(paren
id|v
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|v
op_ne
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGTUNER
suffix:colon
(brace
r_struct
id|video_tuner
id|v
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|v
comma
id|arg
comma
r_sizeof
(paren
id|v
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|v.tuner
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|v.name
comma
l_string|&quot;Format&quot;
)paren
suffix:semicolon
id|v.rangelow
op_assign
l_int|0
suffix:semicolon
id|v.rangehigh
op_assign
l_int|0
suffix:semicolon
id|v.flags
op_assign
l_int|0
suffix:semicolon
id|v.mode
op_assign
id|VIDEO_MODE_AUTO
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|v
comma
r_sizeof
(paren
id|v
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCSTUNER
suffix:colon
(brace
r_struct
id|video_tuner
id|v
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|v
comma
id|arg
comma
r_sizeof
(paren
id|v
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|v.tuner
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|v.mode
op_ne
id|VIDEO_MODE_AUTO
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGPICT
suffix:colon
(brace
r_struct
id|video_picture
id|p
suffix:semicolon
id|p.colour
op_assign
l_int|0x8000
suffix:semicolon
id|p.hue
op_assign
l_int|0x8000
suffix:semicolon
id|p.brightness
op_assign
id|qcam-&gt;brightness
op_lshift
l_int|8
suffix:semicolon
id|p.contrast
op_assign
id|qcam-&gt;contrast
op_lshift
l_int|8
suffix:semicolon
id|p.whiteness
op_assign
id|qcam-&gt;whitebal
op_lshift
l_int|8
suffix:semicolon
id|p.depth
op_assign
id|qcam-&gt;bpp
suffix:semicolon
id|p.palette
op_assign
id|VIDEO_PALETTE_GREY
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|p
comma
r_sizeof
(paren
id|p
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCSPICT
suffix:colon
(brace
r_struct
id|video_picture
id|p
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|p
comma
id|arg
comma
r_sizeof
(paren
id|p
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p.palette
op_ne
id|VIDEO_PALETTE_GREY
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p.depth
op_ne
l_int|4
op_logical_and
id|p.depth
op_ne
l_int|6
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;Now load the camera.&n;&t;&t;&t; */
id|qcam-&gt;brightness
op_assign
id|p.brightness
op_rshift
l_int|8
suffix:semicolon
id|qcam-&gt;contrast
op_assign
id|p.contrast
op_rshift
l_int|8
suffix:semicolon
id|qcam-&gt;whitebal
op_assign
id|p.whiteness
op_rshift
l_int|8
suffix:semicolon
id|qcam-&gt;bpp
op_assign
id|p.depth
suffix:semicolon
id|down
c_func
(paren
op_amp
id|qcam-&gt;lock
)paren
suffix:semicolon
id|qc_setscanmode
c_func
(paren
id|qcam
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|qcam-&gt;lock
)paren
suffix:semicolon
id|qcam-&gt;status
op_or_assign
id|QC_PARAM_CHANGE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCSWIN
suffix:colon
(brace
r_struct
id|video_window
id|vw
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|vw
comma
id|arg
comma
r_sizeof
(paren
id|vw
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vw.flags
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vw.clipcount
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vw.height
l_int|240
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vw.width
l_int|320
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|qcam-&gt;width
op_assign
l_int|320
suffix:semicolon
id|qcam-&gt;height
op_assign
l_int|240
suffix:semicolon
id|qcam-&gt;transfer_scale
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|vw.width
op_ge
l_int|160
op_logical_and
id|vw.height
op_ge
l_int|120
)paren
(brace
id|qcam-&gt;transfer_scale
op_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vw.width
op_ge
l_int|320
op_logical_and
id|vw.height
op_ge
l_int|240
)paren
(brace
id|qcam-&gt;width
op_assign
l_int|320
suffix:semicolon
id|qcam-&gt;height
op_assign
l_int|240
suffix:semicolon
id|qcam-&gt;transfer_scale
op_assign
l_int|1
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|qcam-&gt;lock
)paren
suffix:semicolon
id|qc_setscanmode
c_func
(paren
id|qcam
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|qcam-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* We must update the camera before we grab. We could&n;&t;&t;&t;   just have changed the grab size */
id|qcam-&gt;status
op_or_assign
id|QC_PARAM_CHANGE
suffix:semicolon
multiline_comment|/* Ok we figured out what to use from our wide choice */
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGWIN
suffix:colon
(brace
r_struct
id|video_window
id|vw
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|vw
comma
l_int|0
comma
r_sizeof
(paren
id|vw
)paren
)paren
suffix:semicolon
id|vw.width
op_assign
id|qcam-&gt;width
op_div
id|qcam-&gt;transfer_scale
suffix:semicolon
id|vw.height
op_assign
id|qcam-&gt;height
op_div
id|qcam-&gt;transfer_scale
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|vw
comma
r_sizeof
(paren
id|vw
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCCAPTURE
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|VIDIOCGFBUF
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|VIDIOCSFBUF
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|VIDIOCKEY
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|VIDIOCGFREQ
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|VIDIOCSFREQ
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|VIDIOCGAUDIO
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|VIDIOCSAUDIO
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|qcam_read
r_static
r_int
id|qcam_read
c_func
(paren
r_struct
id|video_device
op_star
id|v
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|count
comma
r_int
id|noblock
)paren
(brace
r_struct
id|qcam_device
op_star
id|qcam
op_assign
(paren
r_struct
id|qcam_device
op_star
)paren
id|v
suffix:semicolon
r_int
id|len
suffix:semicolon
id|parport_claim_or_block
c_func
(paren
id|qcam-&gt;pdev
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|qcam-&gt;lock
)paren
suffix:semicolon
id|qc_reset
c_func
(paren
id|qcam
)paren
suffix:semicolon
multiline_comment|/* Update the camera parameters if we need to */
r_if
c_cond
(paren
id|qcam-&gt;status
op_amp
id|QC_PARAM_CHANGE
)paren
id|qc_set
c_func
(paren
id|qcam
)paren
suffix:semicolon
id|len
op_assign
id|qc_capture
c_func
(paren
id|qcam
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|qcam-&gt;lock
)paren
suffix:semicolon
id|parport_release
c_func
(paren
id|qcam-&gt;pdev
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|variable|qcam_template
r_static
r_struct
id|video_device
id|qcam_template
op_assign
(brace
id|name
suffix:colon
l_string|&quot;Connectix Quickcam&quot;
comma
id|type
suffix:colon
id|VID_TYPE_CAPTURE
comma
id|hardware
suffix:colon
id|VID_HARDWARE_QCAM_BW
comma
id|open
suffix:colon
id|qcam_open
comma
id|close
suffix:colon
id|qcam_close
comma
id|read
suffix:colon
id|qcam_read
comma
id|write
suffix:colon
id|qcam_write
comma
id|ioctl
suffix:colon
id|qcam_ioctl
comma
)brace
suffix:semicolon
DECL|macro|MAX_CAMS
mdefine_line|#define MAX_CAMS 4
DECL|variable|qcams
r_static
r_struct
id|qcam_device
op_star
id|qcams
(braket
id|MAX_CAMS
)braket
suffix:semicolon
DECL|variable|num_cams
r_static
r_int
r_int
id|num_cams
op_assign
l_int|0
suffix:semicolon
DECL|function|init_bwqcam
r_int
id|init_bwqcam
c_func
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
r_struct
id|qcam_device
op_star
id|qcam
suffix:semicolon
r_if
c_cond
(paren
id|num_cams
op_eq
id|MAX_CAMS
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Too many Quickcams (max %d)&bslash;n&quot;
comma
id|MAX_CAMS
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
id|qcam
op_assign
id|qcam_init
c_func
(paren
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qcam
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|parport_claim_or_block
c_func
(paren
id|qcam-&gt;pdev
)paren
suffix:semicolon
id|qc_reset
c_func
(paren
id|qcam
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qc_detect
c_func
(paren
id|qcam
)paren
op_eq
l_int|0
)paren
(brace
id|parport_release
c_func
(paren
id|qcam-&gt;pdev
)paren
suffix:semicolon
id|parport_unregister_device
c_func
(paren
id|qcam-&gt;pdev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|qcam
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|qc_calibrate
c_func
(paren
id|qcam
)paren
suffix:semicolon
id|parport_release
c_func
(paren
id|qcam-&gt;pdev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Connectix Quickcam on %s&bslash;n&quot;
comma
id|qcam-&gt;pport-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|video_register_device
c_func
(paren
op_amp
id|qcam-&gt;vdev
comma
id|VFL_TYPE_GRABBER
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|parport_unregister_device
c_func
(paren
id|qcam-&gt;pdev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|qcam
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|qcams
(braket
id|num_cams
op_increment
)braket
op_assign
id|qcam
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|close_bwqcam
r_void
id|close_bwqcam
c_func
(paren
r_struct
id|qcam_device
op_star
id|qcam
)paren
(brace
id|video_unregister_device
c_func
(paren
op_amp
id|qcam-&gt;vdev
)paren
suffix:semicolon
id|parport_unregister_device
c_func
(paren
id|qcam-&gt;pdev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|qcam
)paren
suffix:semicolon
)brace
multiline_comment|/* The parport parameter controls which parports will be scanned.&n; * Scanning all parports causes some printers to print a garbage page.&n; *       -- March 14, 1999  Billy Donahue &lt;billy@escape.com&gt; */
macro_line|#ifdef MODULE
DECL|variable|parport
r_static
r_char
op_star
id|parport
(braket
id|MAX_CAMS
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|parport
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_CAMS
)paren
l_string|&quot;s&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|parport
op_star
id|port
suffix:semicolon
r_int
id|n
suffix:semicolon
r_if
c_cond
(paren
id|parport
(braket
l_int|0
)braket
op_logical_and
id|strncmp
c_func
(paren
id|parport
(braket
l_int|0
)braket
comma
l_string|&quot;auto&quot;
comma
l_int|4
)paren
)paren
(brace
multiline_comment|/* user gave parport parameters */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|parport
(braket
id|n
)braket
op_logical_and
id|n
OL
id|MAX_CAMS
suffix:semicolon
id|n
op_increment
)paren
(brace
r_char
op_star
id|ep
suffix:semicolon
r_int
r_int
id|r
suffix:semicolon
id|r
op_assign
id|simple_strtoul
c_func
(paren
id|parport
(braket
id|n
)braket
comma
op_amp
id|ep
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_eq
id|parport
(braket
id|n
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bw-qcam: bad port specifier &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|parport
(braket
id|n
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|port
op_assign
id|parport_enumerate
c_func
(paren
)paren
suffix:semicolon
id|port
suffix:semicolon
id|port
op_assign
id|port-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|r
op_ne
id|port-&gt;number
)paren
(brace
r_continue
suffix:semicolon
)brace
id|init_bwqcam
c_func
(paren
id|port
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
(paren
id|num_cams
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* no parameter or &quot;auto&quot; */
r_for
c_loop
(paren
id|port
op_assign
id|parport_enumerate
c_func
(paren
)paren
suffix:semicolon
id|port
suffix:semicolon
id|port
op_assign
id|port-&gt;next
)paren
id|init_bwqcam
c_func
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/* Do some sanity checks on the module parameters. */
r_if
c_cond
(paren
id|maxpoll
OG
l_int|5000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Connectix Quickcam max-poll was above 5000. Using 5000.&bslash;n&quot;
)paren
suffix:semicolon
id|maxpoll
op_assign
l_int|5000
suffix:semicolon
)brace
r_if
c_cond
(paren
id|yieldlines
OL
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Connectix Quickcam yieldlines was less than 1. Using 1.&bslash;n&quot;
)paren
suffix:semicolon
id|yieldlines
op_assign
l_int|1
suffix:semicolon
)brace
r_return
(paren
id|num_cams
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_cams
suffix:semicolon
id|i
op_increment
)paren
id|close_bwqcam
c_func
(paren
id|qcams
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|init_bw_qcams
r_int
id|__init
id|init_bw_qcams
c_func
(paren
r_struct
id|video_init
op_star
id|unused
)paren
(brace
r_struct
id|parport
op_star
id|port
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
id|parport_enumerate
c_func
(paren
)paren
suffix:semicolon
id|port
suffix:semicolon
id|port
op_assign
id|port-&gt;next
)paren
id|init_bwqcam
c_func
(paren
id|port
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
eof
