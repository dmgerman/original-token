multiline_comment|/*---------------------------------------------------------------------------+&n; |  reg_ld_str.c                                                             |&n; |                                                                           |&n; | All of the functions which transfer data between user memory and FPU_REGs.|&n; |                                                                           |&n; | Copyright (C) 1992,1993,1994                                              |&n; |                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,      |&n; |                       Australia.  E-mail   billm@vaxc.cc.monash.edu.au    |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
multiline_comment|/*---------------------------------------------------------------------------+&n; | Note:                                                                     |&n; |    The file contains code which accesses user memory.                     |&n; |    Emulator static data may change when user memory is accessed, due to   |&n; |    other processes using the emulator while swapping is in progress.      |&n; +---------------------------------------------------------------------------*/
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &quot;fpu_system.h&quot;
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;reg_constant.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;control_w.h&quot;
macro_line|#include &quot;status_w.h&quot;
DECL|macro|EXTENDED_Ebias
mdefine_line|#define EXTENDED_Ebias 0x3fff
DECL|macro|EXTENDED_Emin
mdefine_line|#define EXTENDED_Emin (-0x3ffe)  /* smallest valid exponent */
DECL|macro|DOUBLE_Emax
mdefine_line|#define DOUBLE_Emax 1023         /* largest valid exponent */
DECL|macro|DOUBLE_Ebias
mdefine_line|#define DOUBLE_Ebias 1023
DECL|macro|DOUBLE_Emin
mdefine_line|#define DOUBLE_Emin (-1022)      /* smallest valid exponent */
DECL|macro|SINGLE_Emax
mdefine_line|#define SINGLE_Emax 127          /* largest valid exponent */
DECL|macro|SINGLE_Ebias
mdefine_line|#define SINGLE_Ebias 127
DECL|macro|SINGLE_Emin
mdefine_line|#define SINGLE_Emin (-126)       /* smallest valid exponent */
r_static
r_void
id|write_to_extended
c_func
(paren
id|FPU_REG
op_star
id|rp
comma
r_char
op_star
id|d
)paren
suffix:semicolon
DECL|variable|FPU_loaded_data
id|FPU_REG
id|FPU_loaded_data
suffix:semicolon
multiline_comment|/* Get a long double from user memory */
DECL|function|reg_load_extended
r_int
id|reg_load_extended
c_func
(paren
r_void
)paren
(brace
r_int
r_float
op_star
id|s
op_assign
(paren
r_int
r_float
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
r_int
id|sigl
comma
id|sigh
comma
id|exp
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|s
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Use temporary variables here because FPU_loaded data is&n;     static and hence re-entrancy problems can arise */
id|sigl
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|s
)paren
suffix:semicolon
id|sigh
op_assign
id|get_fs_long
c_func
(paren
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|s
)paren
suffix:semicolon
id|exp
op_assign
id|get_fs_word
c_func
(paren
l_int|4
op_plus
(paren
r_int
r_int
op_star
)paren
id|s
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
multiline_comment|/* Default */
id|FPU_loaded_data.sigl
op_assign
id|sigl
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
id|sigh
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_amp
l_int|0x8000
)paren
id|FPU_loaded_data.sign
op_assign
id|SIGN_NEG
suffix:semicolon
r_else
id|FPU_loaded_data.sign
op_assign
id|SIGN_POS
suffix:semicolon
id|exp
op_and_assign
l_int|0x7fff
suffix:semicolon
id|FPU_loaded_data.exp
op_assign
id|exp
op_minus
id|EXTENDED_Ebias
op_plus
id|EXP_BIAS
suffix:semicolon
multiline_comment|/* Assume that optimisation can keep sigl, sigh, and exp in&n;     registers, otherwise it would be more efficient to work&n;     with FPU_loaded_data (which is static) here. */
r_if
c_cond
(paren
id|exp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|sigh
op_or
id|sigl
)paren
)paren
(brace
id|FPU_loaded_data.tag
op_assign
id|TW_Zero
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The number is a de-normal or pseudodenormal. */
r_if
c_cond
(paren
id|sigh
op_amp
l_int|0x80000000
)paren
(brace
multiline_comment|/* Is a pseudodenormal. */
multiline_comment|/* Convert it for internal use. */
multiline_comment|/* This is non-80486 behaviour because the number&n;&t;     loses its &squot;denormal&squot; identity. */
id|FPU_loaded_data.exp
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Is a denormal. */
multiline_comment|/* Convert it for internal use. */
id|FPU_loaded_data.exp
op_increment
suffix:semicolon
id|normalize_nuo
c_func
(paren
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|exp
op_eq
l_int|0x7fff
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|sigh
op_xor
l_int|0x80000000
)paren
op_or
id|sigl
)paren
)paren
(brace
multiline_comment|/* Matches the bit pattern for Infinity. */
id|FPU_loaded_data.exp
op_assign
id|EXP_Infinity
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Infinity
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|FPU_loaded_data.exp
op_assign
id|EXP_NaN
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_NaN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sigh
op_amp
l_int|0x80000000
)paren
)paren
(brace
multiline_comment|/* NaNs have the ms bit set to 1. */
multiline_comment|/* This is therefore an Unsupported NaN data type. */
multiline_comment|/* This is non 80486 behaviour */
multiline_comment|/* This should generate an Invalid Operand exception&n;&t;     later, so we convert it to a SNaN */
id|FPU_loaded_data.sigh
op_assign
l_int|0x80000000
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
l_int|0x00000001
suffix:semicolon
id|FPU_loaded_data.sign
op_assign
id|SIGN_NEG
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|sigh
op_amp
l_int|0x80000000
)paren
)paren
(brace
multiline_comment|/* Unsupported data type. */
multiline_comment|/* Valid numbers have the ms bit set to 1. */
multiline_comment|/* Unnormal. */
multiline_comment|/* Convert it for internal use. */
multiline_comment|/* This is non-80486 behaviour */
multiline_comment|/* This should generate an Invalid Operand exception&n;&t; later, so we convert it to a SNaN */
id|FPU_loaded_data.sigh
op_assign
l_int|0x80000000
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
l_int|0x00000001
suffix:semicolon
id|FPU_loaded_data.sign
op_assign
id|SIGN_NEG
suffix:semicolon
id|FPU_loaded_data.exp
op_assign
id|EXP_NaN
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_NaN
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get a double from user memory */
DECL|function|reg_load_double
r_int
id|reg_load_double
c_func
(paren
r_void
)paren
(brace
r_float
op_star
id|dfloat
op_assign
(paren
r_float
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
id|exp
suffix:semicolon
r_int
id|m64
comma
id|l64
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|dfloat
comma
l_int|8
)paren
suffix:semicolon
id|m64
op_assign
id|get_fs_long
c_func
(paren
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|l64
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_if
c_cond
(paren
id|m64
op_amp
l_int|0x80000000
)paren
id|FPU_loaded_data.sign
op_assign
id|SIGN_NEG
suffix:semicolon
r_else
id|FPU_loaded_data.sign
op_assign
id|SIGN_POS
suffix:semicolon
id|exp
op_assign
(paren
(paren
id|m64
op_amp
l_int|0x7ff00000
)paren
op_rshift
l_int|20
)paren
op_minus
id|DOUBLE_Ebias
suffix:semicolon
id|m64
op_and_assign
l_int|0xfffff
suffix:semicolon
r_if
c_cond
(paren
id|exp
OG
id|DOUBLE_Emax
)paren
(brace
multiline_comment|/* Infinity or NaN */
r_if
c_cond
(paren
(paren
id|m64
op_eq
l_int|0
)paren
op_logical_and
(paren
id|l64
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* +- infinity */
id|FPU_loaded_data.sigh
op_assign
l_int|0x80000000
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
l_int|0x00000000
suffix:semicolon
id|FPU_loaded_data.exp
op_assign
id|EXP_Infinity
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Infinity
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Must be a signaling or quiet NaN */
id|FPU_loaded_data.exp
op_assign
id|EXP_NaN
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_NaN
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
(paren
id|m64
op_lshift
l_int|11
)paren
op_or
l_int|0x80000000
suffix:semicolon
id|FPU_loaded_data.sigh
op_or_assign
id|l64
op_rshift
l_int|21
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
id|l64
op_lshift
l_int|11
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* The calling function must look for NaNs */
)brace
)brace
r_else
r_if
c_cond
(paren
id|exp
OL
id|DOUBLE_Emin
)paren
(brace
multiline_comment|/* Zero or de-normal */
r_if
c_cond
(paren
(paren
id|m64
op_eq
l_int|0
)paren
op_logical_and
(paren
id|l64
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* Zero */
r_int
id|c
op_assign
id|FPU_loaded_data.sign
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
id|FPU_loaded_data.sign
op_assign
id|c
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* De-normal */
id|FPU_loaded_data.exp
op_assign
id|DOUBLE_Emin
op_plus
id|EXP_BIAS
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
id|m64
op_lshift
l_int|11
suffix:semicolon
id|FPU_loaded_data.sigh
op_or_assign
id|l64
op_rshift
l_int|21
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
id|l64
op_lshift
l_int|11
suffix:semicolon
id|normalize_nuo
c_func
(paren
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
r_return
id|denormal_operand
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|FPU_loaded_data.exp
op_assign
id|exp
op_plus
id|EXP_BIAS
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
(paren
id|m64
op_lshift
l_int|11
)paren
op_or
l_int|0x80000000
suffix:semicolon
id|FPU_loaded_data.sigh
op_or_assign
id|l64
op_rshift
l_int|21
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
id|l64
op_lshift
l_int|11
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Get a float from user memory */
DECL|function|reg_load_single
r_int
id|reg_load_single
c_func
(paren
r_void
)paren
(brace
r_float
op_star
id|single
op_assign
(paren
r_float
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
id|m32
suffix:semicolon
r_int
id|exp
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|single
comma
l_int|4
)paren
suffix:semicolon
id|m32
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|single
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_if
c_cond
(paren
id|m32
op_amp
l_int|0x80000000
)paren
id|FPU_loaded_data.sign
op_assign
id|SIGN_NEG
suffix:semicolon
r_else
id|FPU_loaded_data.sign
op_assign
id|SIGN_POS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|m32
op_amp
l_int|0x7fffffff
)paren
)paren
(brace
multiline_comment|/* Zero */
r_int
id|c
op_assign
id|FPU_loaded_data.sign
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
id|FPU_loaded_data.sign
op_assign
id|c
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|exp
op_assign
(paren
(paren
id|m32
op_amp
l_int|0x7f800000
)paren
op_rshift
l_int|23
)paren
op_minus
id|SINGLE_Ebias
suffix:semicolon
id|m32
op_assign
(paren
id|m32
op_amp
l_int|0x7fffff
)paren
op_lshift
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|exp
OL
id|SINGLE_Emin
)paren
(brace
multiline_comment|/* De-normals */
id|FPU_loaded_data.exp
op_assign
id|SINGLE_Emin
op_plus
id|EXP_BIAS
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
id|m32
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
l_int|0
suffix:semicolon
id|normalize_nuo
c_func
(paren
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
r_return
id|denormal_operand
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|exp
OG
id|SINGLE_Emax
)paren
(brace
multiline_comment|/* Infinity or NaN */
r_if
c_cond
(paren
id|m32
op_eq
l_int|0
)paren
(brace
multiline_comment|/* +- infinity */
id|FPU_loaded_data.sigh
op_assign
l_int|0x80000000
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
l_int|0x00000000
suffix:semicolon
id|FPU_loaded_data.exp
op_assign
id|EXP_Infinity
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Infinity
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Must be a signaling or quiet NaN */
id|FPU_loaded_data.exp
op_assign
id|EXP_NaN
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_NaN
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
id|m32
op_or
l_int|0x80000000
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* The calling function must look for NaNs */
)brace
)brace
r_else
(brace
id|FPU_loaded_data.exp
op_assign
id|exp
op_plus
id|EXP_BIAS
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
id|m32
op_or
l_int|0x80000000
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
l_int|0
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Get a long long from user memory */
DECL|function|reg_load_int64
r_void
id|reg_load_int64
c_func
(paren
r_void
)paren
(brace
r_int
r_int
op_star
id|_s
op_assign
(paren
r_int
r_int
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
id|e
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|_s
comma
l_int|8
)paren
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|s
)paren
(braket
l_int|0
)braket
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|_s
)paren
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|s
)paren
(braket
l_int|1
)braket
op_assign
id|get_fs_long
c_func
(paren
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|_s
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_if
c_cond
(paren
id|s
op_eq
l_int|0
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
OG
l_int|0
)paren
id|FPU_loaded_data.sign
op_assign
id|SIGN_POS
suffix:semicolon
r_else
(brace
id|s
op_assign
op_minus
id|s
suffix:semicolon
id|FPU_loaded_data.sign
op_assign
id|SIGN_NEG
suffix:semicolon
)brace
id|e
op_assign
id|EXP_BIAS
op_plus
l_int|63
suffix:semicolon
id|significand
c_func
(paren
op_amp
id|FPU_loaded_data
)paren
op_assign
id|s
suffix:semicolon
id|FPU_loaded_data.exp
op_assign
id|e
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
id|normalize_nuo
c_func
(paren
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
)brace
multiline_comment|/* Get a long from user memory */
DECL|function|reg_load_int32
r_void
id|reg_load_int32
c_func
(paren
r_void
)paren
(brace
r_int
op_star
id|_s
op_assign
(paren
r_int
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
id|s
suffix:semicolon
r_int
id|e
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|_s
comma
l_int|4
)paren
suffix:semicolon
id|s
op_assign
(paren
r_int
)paren
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|_s
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_if
c_cond
(paren
id|s
op_eq
l_int|0
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
OG
l_int|0
)paren
id|FPU_loaded_data.sign
op_assign
id|SIGN_POS
suffix:semicolon
r_else
(brace
id|s
op_assign
op_minus
id|s
suffix:semicolon
id|FPU_loaded_data.sign
op_assign
id|SIGN_NEG
suffix:semicolon
)brace
id|e
op_assign
id|EXP_BIAS
op_plus
l_int|31
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
id|s
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
l_int|0
suffix:semicolon
id|FPU_loaded_data.exp
op_assign
id|e
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
id|normalize_nuo
c_func
(paren
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
)brace
multiline_comment|/* Get a short from user memory */
DECL|function|reg_load_int16
r_void
id|reg_load_int16
c_func
(paren
r_void
)paren
(brace
r_int
op_star
id|_s
op_assign
(paren
r_int
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
id|s
comma
id|e
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|_s
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Cast as short to get the sign extended. */
id|s
op_assign
(paren
r_int
)paren
id|get_fs_word
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|_s
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_if
c_cond
(paren
id|s
op_eq
l_int|0
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
OG
l_int|0
)paren
id|FPU_loaded_data.sign
op_assign
id|SIGN_POS
suffix:semicolon
r_else
(brace
id|s
op_assign
op_minus
id|s
suffix:semicolon
id|FPU_loaded_data.sign
op_assign
id|SIGN_NEG
suffix:semicolon
)brace
id|e
op_assign
id|EXP_BIAS
op_plus
l_int|15
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
id|s
op_lshift
l_int|16
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
l_int|0
suffix:semicolon
id|FPU_loaded_data.exp
op_assign
id|e
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
id|normalize_nuo
c_func
(paren
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
)brace
multiline_comment|/* Get a packed bcd array from user memory */
DECL|function|reg_load_bcd
r_void
id|reg_load_bcd
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|s
op_assign
(paren
r_char
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
id|pos
suffix:semicolon
r_int
r_char
id|bcd
suffix:semicolon
r_int
r_int
id|l
op_assign
l_int|0
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|s
comma
l_int|10
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
l_int|8
suffix:semicolon
id|pos
op_ge
l_int|0
suffix:semicolon
id|pos
op_decrement
)paren
(brace
id|l
op_mul_assign
l_int|10
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|bcd
op_assign
(paren
r_int
r_char
)paren
id|get_fs_byte
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|s
op_plus
id|pos
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
id|l
op_add_assign
id|bcd
op_rshift
l_int|4
suffix:semicolon
id|l
op_mul_assign
l_int|10
suffix:semicolon
id|l
op_add_assign
id|bcd
op_amp
l_int|0x0f
suffix:semicolon
)brace
multiline_comment|/* Finish all access to user memory before putting stuff into&n;     the static FPU_loaded_data */
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_loaded_data.sign
op_assign
(paren
(paren
r_int
r_char
)paren
id|get_fs_byte
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|s
op_plus
l_int|9
)paren
)paren
op_amp
l_int|0x80
ques
c_cond
id|SIGN_NEG
suffix:colon
id|SIGN_POS
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
l_int|0
)paren
(brace
r_char
id|sign
op_assign
id|FPU_loaded_data.sign
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
id|FPU_loaded_data.sign
op_assign
id|sign
suffix:semicolon
)brace
r_else
(brace
id|significand
c_func
(paren
op_amp
id|FPU_loaded_data
)paren
op_assign
id|l
suffix:semicolon
id|FPU_loaded_data.exp
op_assign
id|EXP_BIAS
op_plus
l_int|63
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
id|normalize_nuo
c_func
(paren
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*===========================================================================*/
multiline_comment|/* Put a long double into user memory */
DECL|function|reg_store_extended
r_int
id|reg_store_extended
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;    The only exception raised by an attempt to store to an&n;    extended format is the Invalid Stack exception, i.e.&n;    attempting to store from an empty register.&n;   */
r_int
r_float
op_star
id|d
op_assign
(paren
r_int
r_float
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_tag
op_ne
id|TW_Empty
)paren
(brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|10
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
id|write_to_extended
c_func
(paren
id|FPU_st0_ptr
comma
(paren
r_char
op_star
)paren
id|FPU_data_address
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
multiline_comment|/* The masked response */
multiline_comment|/* Put out the QNaN indefinite */
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|10
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
l_int|0xc0000000
comma
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
l_int|0xffff
comma
l_int|4
op_plus
(paren
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Put a double into user memory */
DECL|function|reg_store_double
r_int
id|reg_store_double
c_func
(paren
r_void
)paren
(brace
r_float
op_star
id|dfloat
op_assign
(paren
r_float
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
r_int
id|l
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* avoid gcc warnings */
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Valid
)paren
(brace
r_int
id|exp
suffix:semicolon
id|FPU_REG
id|tmp
suffix:semicolon
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|exp
op_assign
id|tmp.exp
op_minus
id|EXP_BIAS
suffix:semicolon
r_if
c_cond
(paren
id|exp
OL
id|DOUBLE_Emin
)paren
multiline_comment|/* It may be a denormal */
(brace
r_int
id|precision_loss
suffix:semicolon
multiline_comment|/* A denormal will always underflow. */
macro_line|#ifndef PECULIAR_486
multiline_comment|/* An 80486 is supposed to be able to generate&n;&t;     a denormal exception here, but... */
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
(brace
multiline_comment|/* Underflow has priority. */
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Underflow
)paren
id|denormal_operand
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif PECULIAR_486
id|tmp.exp
op_add_assign
op_minus
id|DOUBLE_Emin
op_plus
l_int|52
suffix:semicolon
multiline_comment|/* largest exp to be 51 */
r_if
c_cond
(paren
(paren
id|precision_loss
op_assign
id|round_to_int
c_func
(paren
op_amp
id|tmp
)paren
)paren
)paren
(brace
macro_line|#ifdef PECULIAR_486
multiline_comment|/* Did it round to a non-denormal ? */
multiline_comment|/* This behaviour might be regarded as peculiar, it appears&n;&t;&t; that the 80486 rounds to the dest precision, then&n;&t;&t; converts to decide underflow. */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|tmp.sigh
op_eq
l_int|0x00100000
)paren
op_logical_and
(paren
id|tmp.sigl
op_eq
l_int|0
)paren
op_logical_and
(paren
id|FPU_st0_ptr-&gt;sigl
op_amp
l_int|0x000007ff
)paren
)paren
)paren
macro_line|#endif PECULIAR_486
(brace
id|EXCEPTION
c_func
(paren
id|EX_Underflow
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of&n;&t;&t;     the 80486 book */
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Underflow
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|EXCEPTION
c_func
(paren
id|precision_loss
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Precision
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|l
(braket
l_int|0
)braket
op_assign
id|tmp.sigl
suffix:semicolon
id|l
(braket
l_int|1
)braket
op_assign
id|tmp.sigh
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|tmp.sigl
op_amp
l_int|0x000007ff
)paren
(brace
r_switch
c_cond
(paren
id|control_word
op_amp
id|CW_RC
)paren
(brace
r_case
id|RC_RND
suffix:colon
multiline_comment|/* Rounding can get a little messy.. */
id|increment
op_assign
(paren
(paren
id|tmp.sigl
op_amp
l_int|0x7ff
)paren
OG
l_int|0x400
)paren
op_or
multiline_comment|/* nearest */
(paren
(paren
id|tmp.sigl
op_amp
l_int|0xc00
)paren
op_eq
l_int|0xc00
)paren
suffix:semicolon
multiline_comment|/* odd -&gt; even */
r_break
suffix:semicolon
r_case
id|RC_DOWN
suffix:colon
multiline_comment|/* towards -infinity */
id|increment
op_assign
(paren
id|tmp.sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
l_int|0
suffix:colon
id|tmp.sigl
op_amp
l_int|0x7ff
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_UP
suffix:colon
multiline_comment|/* towards +infinity */
id|increment
op_assign
(paren
id|tmp.sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
id|tmp.sigl
op_amp
l_int|0x7ff
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_CHOP
suffix:colon
id|increment
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Truncate the mantissa */
id|tmp.sigl
op_and_assign
l_int|0xfffff800
suffix:semicolon
r_if
c_cond
(paren
id|increment
)paren
(brace
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp.sigl
op_ge
l_int|0xfffff800
)paren
(brace
multiline_comment|/* the sigl part overflows */
r_if
c_cond
(paren
id|tmp.sigh
op_eq
l_int|0xffffffff
)paren
(brace
multiline_comment|/* The sigh part overflows */
id|tmp.sigh
op_assign
l_int|0x80000000
suffix:semicolon
id|exp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_ge
id|EXP_OVER
)paren
r_goto
id|overflow
suffix:semicolon
)brace
r_else
(brace
id|tmp.sigh
op_increment
suffix:semicolon
)brace
id|tmp.sigl
op_assign
l_int|0x00000000
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We only need to increment sigl */
id|tmp.sigl
op_add_assign
l_int|0x00000800
suffix:semicolon
)brace
)brace
r_else
id|set_precision_flag_down
c_func
(paren
)paren
suffix:semicolon
)brace
id|l
(braket
l_int|0
)braket
op_assign
(paren
id|tmp.sigl
op_rshift
l_int|11
)paren
op_or
(paren
id|tmp.sigh
op_lshift
l_int|21
)paren
suffix:semicolon
id|l
(braket
l_int|1
)braket
op_assign
(paren
(paren
id|tmp.sigh
op_rshift
l_int|11
)paren
op_amp
l_int|0xfffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp
OG
id|DOUBLE_Emax
)paren
(brace
id|overflow
suffix:colon
id|EXCEPTION
c_func
(paren
id|EX_Overflow
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Overflow
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Precision
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
multiline_comment|/* Overflow to infinity */
id|l
(braket
l_int|0
)braket
op_assign
l_int|0x00000000
suffix:semicolon
multiline_comment|/* Set to */
id|l
(braket
l_int|1
)braket
op_assign
l_int|0x7ff00000
suffix:semicolon
multiline_comment|/* + INF */
)brace
r_else
(brace
multiline_comment|/* Add the exponent */
id|l
(braket
l_int|1
)braket
op_or_assign
(paren
(paren
(paren
id|exp
op_plus
id|DOUBLE_Ebias
)paren
op_amp
l_int|0x7ff
)paren
op_lshift
l_int|20
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
multiline_comment|/* Number is zero */
id|l
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|l
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
id|l
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|l
(braket
l_int|1
)braket
op_assign
l_int|0x7ff00000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
(brace
multiline_comment|/* See if we can get a valid NaN from the FPU_REG */
id|l
(braket
l_int|0
)braket
op_assign
(paren
id|FPU_st0_ptr-&gt;sigl
op_rshift
l_int|11
)paren
op_or
(paren
id|FPU_st0_ptr-&gt;sigh
op_lshift
l_int|21
)paren
suffix:semicolon
id|l
(braket
l_int|1
)braket
op_assign
(paren
(paren
id|FPU_st0_ptr-&gt;sigh
op_rshift
l_int|11
)paren
op_amp
l_int|0xfffff
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|FPU_st0_ptr-&gt;sigh
op_amp
l_int|0x40000000
)paren
)paren
(brace
multiline_comment|/* It is a signalling NaN */
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|l
(braket
l_int|1
)braket
op_or_assign
(paren
l_int|0x40000000
op_rshift
l_int|11
)paren
suffix:semicolon
)brace
id|l
(braket
l_int|1
)braket
op_or_assign
l_int|0x7ff00000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
multiline_comment|/* The masked response */
multiline_comment|/* Put out the QNaN indefinite */
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|dfloat
comma
l_int|8
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
l_int|0xfff80000
comma
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
)paren
id|l
(braket
l_int|1
)braket
op_or_assign
l_int|0x80000000
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|dfloat
comma
l_int|8
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|l
(braket
l_int|0
)braket
comma
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|l
(braket
l_int|1
)braket
comma
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put a float into user memory */
DECL|function|reg_store_single
r_int
id|reg_store_single
c_func
(paren
r_void
)paren
(brace
r_float
op_star
id|single
op_assign
(paren
r_float
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
id|templ
suffix:semicolon
r_int
r_int
id|increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* avoid gcc warnings */
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Valid
)paren
(brace
r_int
id|exp
suffix:semicolon
id|FPU_REG
id|tmp
suffix:semicolon
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|exp
op_assign
id|tmp.exp
op_minus
id|EXP_BIAS
suffix:semicolon
r_if
c_cond
(paren
id|exp
OL
id|SINGLE_Emin
)paren
(brace
r_int
id|precision_loss
suffix:semicolon
multiline_comment|/* A denormal will always underflow. */
macro_line|#ifndef PECULIAR_486
multiline_comment|/* An 80486 is supposed to be able to generate&n;&t;     a denormal exception here, but... */
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
(brace
multiline_comment|/* Underflow has priority. */
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Underflow
)paren
id|denormal_operand
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif PECULIAR_486
id|tmp.exp
op_add_assign
op_minus
id|SINGLE_Emin
op_plus
l_int|23
suffix:semicolon
multiline_comment|/* largest exp to be 22 */
r_if
c_cond
(paren
(paren
id|precision_loss
op_assign
id|round_to_int
c_func
(paren
op_amp
id|tmp
)paren
)paren
)paren
(brace
macro_line|#ifdef PECULIAR_486
multiline_comment|/* Did it round to a non-denormal ? */
multiline_comment|/* This behaviour might be regarded as peculiar, it appears&n;&t;&t; that the 80486 rounds to the dest precision, then&n;&t;&t; converts to decide underflow. */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|tmp.sigl
op_eq
l_int|0x00800000
)paren
op_logical_and
(paren
(paren
id|FPU_st0_ptr-&gt;sigh
op_amp
l_int|0x000000ff
)paren
op_logical_or
id|FPU_st0_ptr-&gt;sigl
)paren
)paren
)paren
macro_line|#endif PECULIAR_486
(brace
id|EXCEPTION
c_func
(paren
id|EX_Underflow
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of&n;&t;&t;     the 80486 book */
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|EX_Underflow
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|EXCEPTION
c_func
(paren
id|precision_loss
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|EX_Precision
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|templ
op_assign
id|tmp.sigl
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|tmp.sigl
op_or
(paren
id|tmp.sigh
op_amp
l_int|0x000000ff
)paren
)paren
(brace
r_int
r_int
id|sigh
op_assign
id|tmp.sigh
suffix:semicolon
r_int
r_int
id|sigl
op_assign
id|tmp.sigl
suffix:semicolon
r_switch
c_cond
(paren
id|control_word
op_amp
id|CW_RC
)paren
(brace
r_case
id|RC_RND
suffix:colon
id|increment
op_assign
(paren
(paren
id|sigh
op_amp
l_int|0xff
)paren
OG
l_int|0x80
)paren
multiline_comment|/* more than half */
op_logical_or
(paren
(paren
(paren
id|sigh
op_amp
l_int|0xff
)paren
op_eq
l_int|0x80
)paren
op_logical_and
id|sigl
)paren
multiline_comment|/* more than half */
op_logical_or
(paren
(paren
id|sigh
op_amp
l_int|0x180
)paren
op_eq
l_int|0x180
)paren
suffix:semicolon
multiline_comment|/* round to even */
r_break
suffix:semicolon
r_case
id|RC_DOWN
suffix:colon
multiline_comment|/* towards -infinity */
id|increment
op_assign
(paren
id|tmp.sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
l_int|0
suffix:colon
(paren
id|sigl
op_or
(paren
id|sigh
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_UP
suffix:colon
multiline_comment|/* towards +infinity */
id|increment
op_assign
(paren
id|tmp.sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
(paren
id|sigl
op_or
(paren
id|sigh
op_amp
l_int|0xff
)paren
)paren
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_CHOP
suffix:colon
id|increment
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Truncate part of the mantissa */
id|tmp.sigl
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|increment
)paren
(brace
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sigh
op_ge
l_int|0xffffff00
)paren
(brace
multiline_comment|/* The sigh part overflows */
id|tmp.sigh
op_assign
l_int|0x80000000
suffix:semicolon
id|exp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_ge
id|EXP_OVER
)paren
r_goto
id|overflow
suffix:semicolon
)brace
r_else
(brace
id|tmp.sigh
op_and_assign
l_int|0xffffff00
suffix:semicolon
id|tmp.sigh
op_add_assign
l_int|0x100
suffix:semicolon
)brace
)brace
r_else
(brace
id|set_precision_flag_down
c_func
(paren
)paren
suffix:semicolon
id|tmp.sigh
op_and_assign
l_int|0xffffff00
suffix:semicolon
multiline_comment|/* Finish the truncation */
)brace
)brace
id|templ
op_assign
(paren
id|tmp.sigh
op_rshift
l_int|8
)paren
op_amp
l_int|0x007fffff
suffix:semicolon
r_if
c_cond
(paren
id|exp
OG
id|SINGLE_Emax
)paren
(brace
id|overflow
suffix:colon
id|EXCEPTION
c_func
(paren
id|EX_Overflow
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Overflow
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Precision
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book. */
multiline_comment|/* Masked respose is overflow to infinity. */
id|templ
op_assign
l_int|0x7f800000
suffix:semicolon
)brace
r_else
id|templ
op_or_assign
(paren
(paren
id|exp
op_plus
id|SINGLE_Ebias
)paren
op_amp
l_int|0xff
)paren
op_lshift
l_int|23
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
id|templ
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
id|templ
op_assign
l_int|0x7f800000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
(brace
multiline_comment|/* See if we can get a valid NaN from the FPU_REG */
id|templ
op_assign
id|FPU_st0_ptr-&gt;sigh
op_rshift
l_int|8
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|FPU_st0_ptr-&gt;sigh
op_amp
l_int|0x40000000
)paren
)paren
(brace
multiline_comment|/* It is a signalling NaN */
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|templ
op_or_assign
(paren
l_int|0x40000000
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
id|templ
op_or_assign
l_int|0x7f800000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* The masked response */
multiline_comment|/* Put out the QNaN indefinite */
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|single
comma
l_int|4
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
l_int|0xffc00000
comma
(paren
r_int
r_int
op_star
)paren
id|single
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x106
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
)paren
id|templ
op_or_assign
l_int|0x80000000
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|single
comma
l_int|4
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|templ
comma
(paren
r_int
r_int
op_star
)paren
id|single
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put a long long into user memory */
DECL|function|reg_store_int64
r_int
id|reg_store_int64
c_func
(paren
r_void
)paren
(brace
r_int
r_int
op_star
id|d
op_assign
(paren
r_int
r_int
op_star
)paren
id|FPU_data_address
suffix:semicolon
id|FPU_REG
id|t
suffix:semicolon
r_int
r_int
id|tll
suffix:semicolon
r_int
id|precision_loss
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_goto
id|invalid_operand
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
op_logical_or
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_goto
id|invalid_operand
suffix:semicolon
)brace
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|t
)paren
suffix:semicolon
id|precision_loss
op_assign
id|round_to_int
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
(paren
(paren
r_int
op_star
)paren
op_amp
id|tll
)paren
(braket
l_int|0
)braket
op_assign
id|t.sigl
suffix:semicolon
(paren
(paren
r_int
op_star
)paren
op_amp
id|tll
)paren
(braket
l_int|1
)braket
op_assign
id|t.sigh
suffix:semicolon
r_if
c_cond
(paren
(paren
id|precision_loss
op_eq
l_int|1
)paren
op_logical_or
(paren
(paren
id|t.sigh
op_amp
l_int|0x80000000
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|t.sigh
op_eq
l_int|0x80000000
)paren
op_logical_and
(paren
id|t.sigl
op_eq
l_int|0
)paren
op_logical_and
(paren
id|t.sign
op_eq
id|SIGN_NEG
)paren
)paren
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
id|invalid_operand
suffix:colon
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* Produce something like QNaN &quot;indefinite&quot; */
id|tll
op_assign
l_int|0x8000000000000000LL
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|precision_loss
)paren
id|set_precision_flag
c_func
(paren
id|precision_loss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t.sign
)paren
id|tll
op_assign
op_minus
id|tll
suffix:semicolon
)brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|d
comma
l_int|8
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|tll
)paren
(braket
l_int|0
)braket
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|tll
)paren
(braket
l_int|1
)braket
comma
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put a long into user memory */
DECL|function|reg_store_int32
r_int
id|reg_store_int32
c_func
(paren
r_void
)paren
(brace
r_int
op_star
id|d
op_assign
(paren
r_int
op_star
)paren
id|FPU_data_address
suffix:semicolon
id|FPU_REG
id|t
suffix:semicolon
r_int
id|precision_loss
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_goto
id|invalid_operand
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
op_logical_or
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_goto
id|invalid_operand
suffix:semicolon
)brace
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|t
)paren
suffix:semicolon
id|precision_loss
op_assign
id|round_to_int
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t.sigh
op_logical_or
(paren
(paren
id|t.sigl
op_amp
l_int|0x80000000
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|t.sigl
op_eq
l_int|0x80000000
)paren
op_logical_and
(paren
id|t.sign
op_eq
id|SIGN_NEG
)paren
)paren
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
id|invalid_operand
suffix:colon
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* Produce something like QNaN &quot;indefinite&quot; */
id|t.sigl
op_assign
l_int|0x80000000
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|precision_loss
)paren
id|set_precision_flag
c_func
(paren
id|precision_loss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t.sign
)paren
id|t.sigl
op_assign
op_minus
(paren
r_int
)paren
id|t.sigl
suffix:semicolon
)brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|4
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|t.sigl
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put a short into user memory */
DECL|function|reg_store_int16
r_int
id|reg_store_int16
c_func
(paren
r_void
)paren
(brace
r_int
op_star
id|d
op_assign
(paren
r_int
op_star
)paren
id|FPU_data_address
suffix:semicolon
id|FPU_REG
id|t
suffix:semicolon
r_int
id|precision_loss
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_goto
id|invalid_operand
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
op_logical_or
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_goto
id|invalid_operand
suffix:semicolon
)brace
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|t
)paren
suffix:semicolon
id|precision_loss
op_assign
id|round_to_int
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t.sigh
op_logical_or
(paren
(paren
id|t.sigl
op_amp
l_int|0xffff8000
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|t.sigl
op_eq
l_int|0x8000
)paren
op_logical_and
(paren
id|t.sign
op_eq
id|SIGN_NEG
)paren
)paren
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
id|invalid_operand
suffix:colon
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* Produce something like QNaN &quot;indefinite&quot; */
id|t.sigl
op_assign
l_int|0x8000
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|precision_loss
)paren
id|set_precision_flag
c_func
(paren
id|precision_loss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t.sign
)paren
id|t.sigl
op_assign
op_minus
id|t.sigl
suffix:semicolon
)brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|2
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
(paren
r_int
)paren
id|t.sigl
comma
(paren
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put a packed bcd array into user memory */
DECL|function|reg_store_bcd
r_int
id|reg_store_bcd
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|d
op_assign
(paren
r_char
op_star
)paren
id|FPU_data_address
suffix:semicolon
id|FPU_REG
id|t
suffix:semicolon
r_int
r_int
r_int
id|ll
suffix:semicolon
r_int
r_char
id|b
suffix:semicolon
r_int
id|i
comma
id|precision_loss
suffix:semicolon
r_int
r_char
id|sign
op_assign
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_NEG
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_goto
id|invalid_operand
suffix:semicolon
)brace
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|t
)paren
suffix:semicolon
id|precision_loss
op_assign
id|round_to_int
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
id|ll
op_assign
id|significand
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
multiline_comment|/* Check for overflow, by comparing with 999999999999999999 decimal. */
r_if
c_cond
(paren
(paren
id|t.sigh
OG
l_int|0x0de0b6b3
)paren
op_logical_or
(paren
(paren
id|t.sigh
op_eq
l_int|0x0de0b6b3
)paren
op_logical_and
(paren
id|t.sigl
OG
l_int|0xa763ffff
)paren
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
id|invalid_operand
suffix:colon
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
multiline_comment|/* Produce the QNaN &quot;indefinite&quot; */
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|10
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
id|put_fs_byte
c_func
(paren
l_int|0
comma
(paren
r_int
r_char
op_star
)paren
id|d
op_plus
id|i
)paren
suffix:semicolon
multiline_comment|/* These bytes &quot;undefined&quot; */
id|put_fs_byte
c_func
(paren
l_int|0xc0
comma
(paren
r_int
r_char
op_star
)paren
id|d
op_plus
l_int|7
)paren
suffix:semicolon
multiline_comment|/* This byte &quot;undefined&quot; */
id|put_fs_byte
c_func
(paren
l_int|0xff
comma
(paren
r_int
r_char
op_star
)paren
id|d
op_plus
l_int|8
)paren
suffix:semicolon
id|put_fs_byte
c_func
(paren
l_int|0xff
comma
(paren
r_int
r_char
op_star
)paren
id|d
op_plus
l_int|9
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|precision_loss
)paren
(brace
multiline_comment|/* Precision loss doesn&squot;t stop the data transfer */
id|set_precision_flag
c_func
(paren
id|precision_loss
)paren
suffix:semicolon
)brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|10
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|9
suffix:semicolon
id|i
op_increment
)paren
(brace
id|b
op_assign
id|div_small
c_func
(paren
op_amp
id|ll
comma
l_int|10
)paren
suffix:semicolon
id|b
op_or_assign
(paren
id|div_small
c_func
(paren
op_amp
id|ll
comma
l_int|10
)paren
)paren
op_lshift
l_int|4
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|put_fs_byte
c_func
(paren
id|b
comma
(paren
r_int
r_char
op_star
)paren
id|d
op_plus
id|i
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
)brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|put_fs_byte
c_func
(paren
id|sign
comma
(paren
r_int
r_char
op_star
)paren
id|d
op_plus
l_int|9
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*===========================================================================*/
multiline_comment|/* r gets mangled such that sig is int, sign: &n;   it is NOT normalized */
multiline_comment|/* The return value (in eax) is zero if the result is exact,&n;   if bits are changed due to rounding, truncation, etc, then&n;   a non-zero value is returned */
multiline_comment|/* Overflow is signalled by a non-zero return value (in eax).&n;   In the case of overflow, the returned significand always has the&n;   the largest possible value */
DECL|function|round_to_int
r_int
id|round_to_int
c_func
(paren
id|FPU_REG
op_star
id|r
)paren
(brace
r_char
id|very_big
suffix:semicolon
r_int
id|eax
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;tag
op_eq
id|TW_Zero
)paren
(brace
multiline_comment|/* Make sure that zero is returned */
id|significand
c_func
(paren
id|r
)paren
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* o.k. */
)brace
r_if
c_cond
(paren
id|r-&gt;exp
OG
id|EXP_BIAS
op_plus
l_int|63
)paren
(brace
id|r-&gt;sigl
op_assign
id|r-&gt;sigh
op_assign
op_complement
l_int|0
suffix:semicolon
multiline_comment|/* The largest representable number */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* overflow */
)brace
id|eax
op_assign
id|shrxs
c_func
(paren
op_amp
id|r-&gt;sigl
comma
id|EXP_BIAS
op_plus
l_int|63
op_minus
id|r-&gt;exp
)paren
suffix:semicolon
id|very_big
op_assign
op_logical_neg
(paren
op_complement
(paren
id|r-&gt;sigh
)paren
op_or
op_complement
(paren
id|r-&gt;sigl
)paren
)paren
suffix:semicolon
multiline_comment|/* test for 0xfff...fff */
DECL|macro|half_or_more
mdefine_line|#define&t;half_or_more&t;(eax &amp; 0x80000000)
DECL|macro|frac_part
mdefine_line|#define&t;frac_part&t;(eax)
DECL|macro|more_than_half
mdefine_line|#define more_than_half  ((eax &amp; 0x80000001) == 0x80000001)
r_switch
c_cond
(paren
id|control_word
op_amp
id|CW_RC
)paren
(brace
r_case
id|RC_RND
suffix:colon
r_if
c_cond
(paren
id|more_than_half
multiline_comment|/* nearest */
op_logical_or
(paren
id|half_or_more
op_logical_and
(paren
id|r-&gt;sigl
op_amp
l_int|1
)paren
)paren
)paren
multiline_comment|/* odd -&gt; even */
(brace
r_if
c_cond
(paren
id|very_big
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* overflow */
id|significand
c_func
(paren
id|r
)paren
op_increment
suffix:semicolon
r_return
id|PRECISION_LOST_UP
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RC_DOWN
suffix:colon
r_if
c_cond
(paren
id|frac_part
op_logical_and
id|r-&gt;sign
)paren
(brace
r_if
c_cond
(paren
id|very_big
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* overflow */
id|significand
c_func
(paren
id|r
)paren
op_increment
suffix:semicolon
r_return
id|PRECISION_LOST_UP
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RC_UP
suffix:colon
r_if
c_cond
(paren
id|frac_part
op_logical_and
op_logical_neg
id|r-&gt;sign
)paren
(brace
r_if
c_cond
(paren
id|very_big
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* overflow */
id|significand
c_func
(paren
id|r
)paren
op_increment
suffix:semicolon
r_return
id|PRECISION_LOST_UP
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RC_CHOP
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|eax
ques
c_cond
id|PRECISION_LOST_DOWN
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*===========================================================================*/
DECL|function|fldenv
r_char
op_star
id|fldenv
c_func
(paren
id|fpu_addr_modes
id|addr_modes
)paren
(brace
r_char
op_star
id|s
op_assign
(paren
r_char
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
r_int
id|tag_word
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|tag
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|addr_modes.vm86
op_logical_or
(paren
id|addr_modes.override.operand_size
op_eq
id|OP_SIZE_PREFIX
)paren
)paren
(brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|s
comma
l_int|0x0e
)paren
suffix:semicolon
id|control_word
op_assign
id|get_fs_word
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|s
)paren
suffix:semicolon
id|partial_status
op_assign
id|get_fs_word
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|tag_word
op_assign
id|get_fs_word
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|ip_offset
op_assign
id|get_fs_word
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|6
)paren
)paren
suffix:semicolon
id|cs_selector
op_assign
id|get_fs_word
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|8
)paren
)paren
suffix:semicolon
id|data_operand_offset
op_assign
id|get_fs_word
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|0x0a
)paren
)paren
suffix:semicolon
id|operand_selector
op_assign
id|get_fs_word
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|0x0c
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
id|s
op_add_assign
l_int|0x0e
suffix:semicolon
r_if
c_cond
(paren
id|addr_modes.vm86
)paren
(brace
id|ip_offset
op_add_assign
(paren
id|cs_selector
op_amp
l_int|0xf000
)paren
op_lshift
l_int|4
suffix:semicolon
id|data_operand_offset
op_add_assign
(paren
id|operand_selector
op_amp
l_int|0xf000
)paren
op_lshift
l_int|4
suffix:semicolon
)brace
)brace
r_else
(brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|s
comma
l_int|0x1c
)paren
suffix:semicolon
id|control_word
op_assign
id|get_fs_word
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|s
)paren
suffix:semicolon
id|partial_status
op_assign
id|get_fs_word
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|tag_word
op_assign
id|get_fs_word
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|8
)paren
)paren
suffix:semicolon
id|ip_offset
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|0x0c
)paren
)paren
suffix:semicolon
id|cs_selector
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|0x10
)paren
)paren
suffix:semicolon
id|data_operand_offset
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|0x14
)paren
)paren
suffix:semicolon
id|operand_selector
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|0x18
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
id|s
op_add_assign
l_int|0x1c
suffix:semicolon
)brace
macro_line|#ifdef PECULIAR_486
id|control_word
op_and_assign
op_complement
l_int|0xe080
suffix:semicolon
macro_line|#endif PECULIAR_486
id|top
op_assign
(paren
id|partial_status
op_rshift
id|SW_Top_Shift
)paren
op_amp
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|partial_status
op_amp
op_complement
id|control_word
op_amp
id|CW_Exceptions
)paren
id|partial_status
op_or_assign
(paren
id|SW_Summary
op_or
id|SW_Backward
)paren
suffix:semicolon
r_else
id|partial_status
op_and_assign
op_complement
(paren
id|SW_Summary
op_or
id|SW_Backward
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tag
op_assign
id|tag_word
op_amp
l_int|3
suffix:semicolon
id|tag_word
op_rshift_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
l_int|3
)paren
multiline_comment|/* New tag is empty.  Accept it */
id|regs
(braket
id|i
)braket
dot
id|tag
op_assign
id|TW_Empty
suffix:semicolon
r_else
r_if
c_cond
(paren
id|regs
(braket
id|i
)braket
dot
id|tag
op_eq
id|TW_Empty
)paren
(brace
multiline_comment|/* Old tag is empty and new tag is not empty.  New tag is determined&n;&t;     by old reg contents */
r_if
c_cond
(paren
id|regs
(braket
id|i
)braket
dot
id|exp
op_eq
id|EXP_BIAS
op_minus
id|EXTENDED_Ebias
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|regs
(braket
id|i
)braket
dot
id|sigl
op_or
id|regs
(braket
id|i
)braket
dot
id|sigh
)paren
)paren
id|regs
(braket
id|i
)braket
dot
id|tag
op_assign
id|TW_Zero
suffix:semicolon
r_else
id|regs
(braket
id|i
)braket
dot
id|tag
op_assign
id|TW_Valid
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|regs
(braket
id|i
)braket
dot
id|exp
op_eq
l_int|0x7fff
op_plus
id|EXP_BIAS
op_minus
id|EXTENDED_Ebias
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|regs
(braket
id|i
)braket
dot
id|sigh
op_amp
op_complement
l_int|0x80000000
)paren
op_or
id|regs
(braket
id|i
)braket
dot
id|sigl
)paren
)paren
id|regs
(braket
id|i
)braket
dot
id|tag
op_assign
id|TW_Infinity
suffix:semicolon
r_else
id|regs
(braket
id|i
)braket
dot
id|tag
op_assign
id|TW_NaN
suffix:semicolon
)brace
r_else
id|regs
(braket
id|i
)braket
dot
id|tag
op_assign
id|TW_Valid
suffix:semicolon
)brace
multiline_comment|/* Else old tag is not empty and new tag is not empty.  Old tag&n;&t; remains correct */
)brace
multiline_comment|/* Ensure that the values just loaded are not changed by&n;     fix-up operations. */
id|NO_NET_DATA_EFFECT
suffix:semicolon
id|NO_NET_INSTR_EFFECT
suffix:semicolon
r_return
id|s
suffix:semicolon
)brace
DECL|function|frstor
r_void
id|frstor
c_func
(paren
id|fpu_addr_modes
id|addr_modes
)paren
(brace
r_int
id|i
comma
id|stnr
suffix:semicolon
r_int
r_char
id|tag
suffix:semicolon
r_char
op_star
id|s
op_assign
id|fldenv
c_func
(paren
id|addr_modes
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Load each register. */
id|FPU_data_address
op_assign
(paren
r_void
op_star
)paren
(paren
id|s
op_plus
id|i
op_star
l_int|10
)paren
suffix:semicolon
id|reg_load_extended
c_func
(paren
)paren
suffix:semicolon
id|stnr
op_assign
(paren
id|i
op_plus
id|top
)paren
op_amp
l_int|7
suffix:semicolon
id|tag
op_assign
id|regs
(braket
id|stnr
)braket
dot
id|tag
suffix:semicolon
multiline_comment|/* Derived from the loaded tag word. */
id|reg_move
c_func
(paren
op_amp
id|FPU_loaded_data
comma
op_amp
id|regs
(braket
id|stnr
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|TW_Empty
)paren
multiline_comment|/* The loaded data over-rides all other cases. */
id|regs
(braket
id|stnr
)braket
dot
id|tag
op_assign
id|tag
suffix:semicolon
)brace
multiline_comment|/* Reverse the effect which loading the registers had on the&n;     data pointer */
id|NO_NET_DATA_EFFECT
suffix:semicolon
)brace
DECL|function|tag_word
r_int
r_int
id|tag_word
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|word
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|tag
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|7
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_switch
c_cond
(paren
id|tag
op_assign
id|regs
(braket
id|i
)braket
dot
id|tag
)paren
(brace
r_case
id|TW_Valid
suffix:colon
r_if
c_cond
(paren
id|regs
(braket
id|i
)braket
dot
id|exp
op_le
(paren
id|EXP_BIAS
op_minus
id|EXTENDED_Ebias
)paren
)paren
id|tag
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TW_Infinity
suffix:colon
r_case
id|TW_NaN
suffix:colon
id|tag
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TW_Empty
suffix:colon
id|tag
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* TW_Zero already has the correct value */
)brace
id|word
op_lshift_assign
l_int|2
suffix:semicolon
id|word
op_or_assign
id|tag
suffix:semicolon
)brace
r_return
id|word
suffix:semicolon
)brace
DECL|function|fstenv
r_char
op_star
id|fstenv
c_func
(paren
id|fpu_addr_modes
id|addr_modes
)paren
(brace
r_char
op_star
id|d
op_assign
(paren
r_char
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_if
c_cond
(paren
id|addr_modes.vm86
op_logical_or
(paren
id|addr_modes.override.operand_size
op_eq
id|OP_SIZE_PREFIX
)paren
)paren
(brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|14
)paren
suffix:semicolon
macro_line|#ifdef PECULIAR_486
id|put_fs_long
c_func
(paren
id|control_word
op_amp
op_complement
l_int|0xe080
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
macro_line|#else
id|put_fs_word
c_func
(paren
id|control_word
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
macro_line|#endif PECULIAR_486
id|put_fs_word
c_func
(paren
id|status_word
c_func
(paren
)paren
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
id|tag_word
c_func
(paren
)paren
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
id|ip_offset
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|6
)paren
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
id|data_operand_offset
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|0x0a
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr_modes.vm86
)paren
(brace
id|put_fs_word
c_func
(paren
(paren
id|ip_offset
op_amp
l_int|0xf0000
)paren
op_rshift
l_int|4
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|8
)paren
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
(paren
id|data_operand_offset
op_amp
l_int|0xf0000
)paren
op_rshift
l_int|4
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|0x0c
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|put_fs_word
c_func
(paren
id|cs_selector
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|8
)paren
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
id|operand_selector
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|0x0c
)paren
)paren
suffix:semicolon
)brace
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
id|d
op_add_assign
l_int|0x0e
suffix:semicolon
)brace
r_else
(brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|28
)paren
suffix:semicolon
macro_line|#ifdef PECULIAR_486
multiline_comment|/* An 80486 sets all the reserved bits to 1. */
id|put_fs_long
c_func
(paren
l_int|0xffff0040
op_or
(paren
id|control_word
op_amp
op_complement
l_int|0xe080
)paren
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
l_int|0xffff0000
op_or
id|status_word
c_func
(paren
)paren
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
l_int|0xffff0000
op_or
id|tag_word
c_func
(paren
)paren
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|8
)paren
)paren
suffix:semicolon
macro_line|#else
id|put_fs_word
c_func
(paren
id|control_word
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
id|status_word
c_func
(paren
)paren
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
id|tag_word
c_func
(paren
)paren
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|8
)paren
)paren
suffix:semicolon
macro_line|#endif PECULIAR_486
id|put_fs_long
c_func
(paren
id|ip_offset
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|0x0c
)paren
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|cs_selector
op_amp
op_complement
l_int|0xf8000000
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|0x10
)paren
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|data_operand_offset
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|0x14
)paren
)paren
suffix:semicolon
macro_line|#ifdef PECULIAR_486
multiline_comment|/* An 80486 sets all the reserved bits to 1. */
id|put_fs_long
c_func
(paren
l_int|0xffff0000
op_or
id|operand_selector
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|0x18
)paren
)paren
suffix:semicolon
macro_line|#else
id|put_fs_long
c_func
(paren
id|operand_selector
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|0x18
)paren
)paren
suffix:semicolon
macro_line|#endif PECULIAR_486
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
id|d
op_add_assign
l_int|0x1c
suffix:semicolon
)brace
id|control_word
op_or_assign
id|CW_Exceptions
suffix:semicolon
id|partial_status
op_and_assign
op_complement
(paren
id|SW_Summary
op_or
id|SW_Backward
)paren
suffix:semicolon
r_return
id|d
suffix:semicolon
)brace
DECL|function|fsave
r_void
id|fsave
c_func
(paren
id|fpu_addr_modes
id|addr_modes
)paren
(brace
r_char
op_star
id|d
suffix:semicolon
r_int
id|i
suffix:semicolon
id|d
op_assign
id|fstenv
c_func
(paren
id|addr_modes
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|80
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|write_to_extended
c_func
(paren
op_amp
id|regs
(braket
(paren
id|top
op_plus
id|i
)paren
op_amp
l_int|7
)braket
comma
id|d
op_plus
l_int|10
op_star
id|i
)paren
suffix:semicolon
id|finit
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*===========================================================================*/
multiline_comment|/*&n;  A call to this function must be preceeded by a call to&n;  FPU_verify_area() to verify access to the 10 bytes at d&n;  */
DECL|function|write_to_extended
r_static
r_void
id|write_to_extended
c_func
(paren
id|FPU_REG
op_star
id|rp
comma
r_char
op_star
id|d
)paren
(brace
r_int
id|e
suffix:semicolon
id|FPU_REG
id|tmp
suffix:semicolon
id|e
op_assign
id|rp-&gt;exp
op_minus
id|EXP_BIAS
op_plus
id|EXTENDED_Ebias
suffix:semicolon
macro_line|#ifdef PARANOID
r_switch
c_cond
(paren
id|rp-&gt;tag
)paren
(brace
r_case
id|TW_Zero
suffix:colon
r_if
c_cond
(paren
id|rp-&gt;sigh
op_or
id|rp-&gt;sigl
op_or
id|e
)paren
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x114
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TW_Infinity
suffix:colon
r_case
id|TW_NaN
suffix:colon
r_if
c_cond
(paren
(paren
id|e
op_xor
l_int|0x7fff
)paren
op_or
op_logical_neg
(paren
id|rp-&gt;sigh
op_amp
l_int|0x80000000
)paren
)paren
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x114
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|e
OG
l_int|0x7fff
op_logical_or
id|e
OL
op_minus
l_int|63
)paren
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x114
)paren
suffix:semicolon
)brace
macro_line|#endif PARANOID
multiline_comment|/*&n;    All numbers except denormals are stored internally in a&n;    format which is compatible with the extended real number&n;    format.&n;   */
r_if
c_cond
(paren
id|e
OG
l_int|0
)paren
(brace
multiline_comment|/* just copy the reg */
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|put_fs_long
c_func
(paren
id|rp-&gt;sigl
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|rp-&gt;sigh
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;The number is a de-normal stored as a normal using our&n;&t;extra exponent range, or is Zero.&n;&t;Convert it back to a de-normal, or leave it as Zero.&n;       */
id|reg_move
c_func
(paren
id|rp
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|tmp.exp
op_add_assign
op_minus
id|EXTENDED_Emin
op_plus
l_int|63
suffix:semicolon
multiline_comment|/* largest exp to be 63 */
id|round_to_int
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|e
op_assign
l_int|0
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|put_fs_long
c_func
(paren
id|tmp.sigl
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|tmp.sigh
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
)brace
id|e
op_or_assign
id|rp-&gt;sign
op_eq
id|SIGN_POS
ques
c_cond
l_int|0
suffix:colon
l_int|0x8000
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|put_fs_word
c_func
(paren
id|e
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|8
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
)brace
eof
