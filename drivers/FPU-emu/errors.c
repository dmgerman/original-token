multiline_comment|/*---------------------------------------------------------------------------+&n; |  errors.c                                                                 |&n; |                                                                           |&n; |  The error handling functions for wm-FPU-emu                              |&n; |                                                                           |&n; | Copyright (C) 1992,1993,1994                                              |&n; |                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,      |&n; |                       Australia.  E-mail   billm@vaxc.cc.monash.edu.au    |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
multiline_comment|/*---------------------------------------------------------------------------+&n; | Note:                                                                     |&n; |    The file contains code which accesses user memory.                     |&n; |    Emulator static data may change when user memory is accessed, due to   |&n; |    other processes using the emulator while swapping is in progress.      |&n; +---------------------------------------------------------------------------*/
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &quot;fpu_system.h&quot;
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;status_w.h&quot;
macro_line|#include &quot;control_w.h&quot;
macro_line|#include &quot;reg_constant.h&quot;
macro_line|#include &quot;version.h&quot;
multiline_comment|/* */
DECL|macro|PRINT_MESSAGES
macro_line|#undef PRINT_MESSAGES
multiline_comment|/* */
DECL|function|Un_impl
r_void
id|Un_impl
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|byte1
comma
id|FPU_modrm
suffix:semicolon
r_int
r_int
id|address
op_assign
id|FPU_ORIG_EIP
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
multiline_comment|/* No need to verify_area(), we have previously fetched these bytes. */
id|printk
c_func
(paren
l_string|&quot;Unimplemented FPU Opcode at eip=%p : &quot;
comma
(paren
r_void
op_star
)paren
id|address
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|byte1
op_assign
id|get_fs_byte
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|byte1
op_amp
l_int|0xf8
)paren
op_eq
l_int|0xd8
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[%02x]&quot;
comma
id|byte1
)paren
suffix:semicolon
id|address
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|byte1
)paren
suffix:semicolon
id|FPU_modrm
op_assign
id|get_fs_byte
c_func
(paren
l_int|1
op_plus
(paren
r_int
r_char
op_star
)paren
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FPU_modrm
op_ge
l_int|0300
)paren
id|printk
c_func
(paren
l_string|&quot;%02x (%02x+%d)&bslash;n&quot;
comma
id|FPU_modrm
comma
id|FPU_modrm
op_amp
l_int|0xf8
comma
id|FPU_modrm
op_amp
l_int|7
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;/%d&bslash;n&quot;
comma
(paren
id|FPU_modrm
op_rshift
l_int|3
)paren
op_amp
l_int|7
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   Called for opcodes which are illegal and which are known to result in a&n;   SIGILL with a real 80486.&n;   */
DECL|function|FPU_illegal
r_void
id|FPU_illegal
c_func
(paren
r_void
)paren
(brace
id|math_abort
c_func
(paren
id|FPU_info
comma
id|SIGILL
)paren
suffix:semicolon
)brace
DECL|function|emu_printall
r_void
id|emu_printall
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_static
r_char
op_star
id|tag_desc
(braket
)braket
op_assign
(brace
l_string|&quot;Valid&quot;
comma
l_string|&quot;Zero&quot;
comma
l_string|&quot;ERROR&quot;
comma
l_string|&quot;ERROR&quot;
comma
l_string|&quot;DeNorm&quot;
comma
l_string|&quot;Inf&quot;
comma
l_string|&quot;NaN&quot;
comma
l_string|&quot;Empty&quot;
)brace
suffix:semicolon
r_int
r_char
id|byte1
comma
id|FPU_modrm
suffix:semicolon
r_int
r_int
id|address
op_assign
id|FPU_ORIG_EIP
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
multiline_comment|/* No need to verify_area(), we have previously fetched these bytes. */
id|printk
c_func
(paren
l_string|&quot;At %p:&quot;
comma
(paren
r_void
op_star
)paren
id|address
)paren
suffix:semicolon
DECL|macro|MAX_PRINTED_BYTES
mdefine_line|#define MAX_PRINTED_BYTES 20
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_PRINTED_BYTES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|byte1
op_assign
id|get_fs_byte
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|byte1
op_amp
l_int|0xf8
)paren
op_eq
l_int|0xd8
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
id|byte1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; [%02x]&quot;
comma
id|byte1
)paren
suffix:semicolon
id|address
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|MAX_PRINTED_BYTES
)paren
id|printk
c_func
(paren
l_string|&quot; [more..]&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|FPU_modrm
op_assign
id|get_fs_byte
c_func
(paren
l_int|1
op_plus
(paren
r_int
r_char
op_star
)paren
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FPU_modrm
op_ge
l_int|0300
)paren
id|printk
c_func
(paren
l_string|&quot; %02x (%02x+%d)&bslash;n&quot;
comma
id|FPU_modrm
comma
id|FPU_modrm
op_amp
l_int|0xf8
comma
id|FPU_modrm
op_amp
l_int|7
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; /%d, mod=%d rm=%d&bslash;n&quot;
comma
(paren
id|FPU_modrm
op_rshift
l_int|3
)paren
op_amp
l_int|7
comma
(paren
id|FPU_modrm
op_rshift
l_int|6
)paren
op_amp
l_int|3
comma
id|FPU_modrm
op_amp
l_int|7
)paren
suffix:semicolon
)brace
id|partial_status
op_assign
id|status_word
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUGGING
r_if
c_cond
(paren
id|partial_status
op_amp
id|SW_Backward
)paren
id|printk
c_func
(paren
l_string|&quot;SW: backward compatibility&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partial_status
op_amp
id|SW_C3
)paren
id|printk
c_func
(paren
l_string|&quot;SW: condition bit 3&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partial_status
op_amp
id|SW_C2
)paren
id|printk
c_func
(paren
l_string|&quot;SW: condition bit 2&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partial_status
op_amp
id|SW_C1
)paren
id|printk
c_func
(paren
l_string|&quot;SW: condition bit 1&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partial_status
op_amp
id|SW_C0
)paren
id|printk
c_func
(paren
l_string|&quot;SW: condition bit 0&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partial_status
op_amp
id|SW_Summary
)paren
id|printk
c_func
(paren
l_string|&quot;SW: exception summary&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partial_status
op_amp
id|SW_Stack_Fault
)paren
id|printk
c_func
(paren
l_string|&quot;SW: stack fault&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partial_status
op_amp
id|SW_Precision
)paren
id|printk
c_func
(paren
l_string|&quot;SW: loss of precision&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partial_status
op_amp
id|SW_Underflow
)paren
id|printk
c_func
(paren
l_string|&quot;SW: underflow&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partial_status
op_amp
id|SW_Overflow
)paren
id|printk
c_func
(paren
l_string|&quot;SW: overflow&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partial_status
op_amp
id|SW_Zero_Div
)paren
id|printk
c_func
(paren
l_string|&quot;SW: divide by zero&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partial_status
op_amp
id|SW_Denorm_Op
)paren
id|printk
c_func
(paren
l_string|&quot;SW: denormalized operand&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partial_status
op_amp
id|SW_Invalid
)paren
id|printk
c_func
(paren
l_string|&quot;SW: invalid operation&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif DEBUGGING
id|printk
c_func
(paren
l_string|&quot; SW: b=%d st=%ld es=%d sf=%d cc=%d%d%d%d ef=%d%d%d%d%d%d&bslash;n&quot;
comma
id|partial_status
op_amp
l_int|0x8000
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
multiline_comment|/* busy */
(paren
id|partial_status
op_amp
l_int|0x3800
)paren
op_rshift
l_int|11
comma
multiline_comment|/* stack top pointer */
id|partial_status
op_amp
l_int|0x80
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
multiline_comment|/* Error summary status */
id|partial_status
op_amp
l_int|0x40
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
multiline_comment|/* Stack flag */
id|partial_status
op_amp
id|SW_C3
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|partial_status
op_amp
id|SW_C2
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
multiline_comment|/* cc */
id|partial_status
op_amp
id|SW_C1
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|partial_status
op_amp
id|SW_C0
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
multiline_comment|/* cc */
id|partial_status
op_amp
id|SW_Precision
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|partial_status
op_amp
id|SW_Underflow
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|partial_status
op_amp
id|SW_Overflow
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|partial_status
op_amp
id|SW_Zero_Div
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|partial_status
op_amp
id|SW_Denorm_Op
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|partial_status
op_amp
id|SW_Invalid
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CW: ic=%d rc=%ld%ld pc=%ld%ld iem=%d     ef=%d%d%d%d%d%d&bslash;n&quot;
comma
id|control_word
op_amp
l_int|0x1000
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
(paren
id|control_word
op_amp
l_int|0x800
)paren
op_rshift
l_int|11
comma
(paren
id|control_word
op_amp
l_int|0x400
)paren
op_rshift
l_int|10
comma
(paren
id|control_word
op_amp
l_int|0x200
)paren
op_rshift
l_int|9
comma
(paren
id|control_word
op_amp
l_int|0x100
)paren
op_rshift
l_int|8
comma
id|control_word
op_amp
l_int|0x80
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|control_word
op_amp
id|SW_Precision
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|control_word
op_amp
id|SW_Underflow
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|control_word
op_amp
id|SW_Overflow
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|control_word
op_amp
id|SW_Zero_Div
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|control_word
op_amp
id|SW_Denorm_Op
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|control_word
op_amp
id|SW_Invalid
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|FPU_REG
op_star
id|r
op_assign
op_amp
id|st
c_func
(paren
id|i
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|r-&gt;tag
)paren
(brace
r_case
id|TW_Empty
suffix:colon
r_continue
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TW_Zero
suffix:colon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;st(%d)  %c .0000 0000 0000 0000         &quot;
comma
id|i
comma
id|r-&gt;sign
ques
c_cond
l_char|&squot;-&squot;
suffix:colon
l_char|&squot;+&squot;
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|TW_Valid
suffix:colon
r_case
id|TW_NaN
suffix:colon
multiline_comment|/*&t;case TW_Denormal: */
r_case
id|TW_Infinity
suffix:colon
id|printk
c_func
(paren
l_string|&quot;st(%d)  %c .%04lx %04lx %04lx %04lx e%+-6ld &quot;
comma
id|i
comma
id|r-&gt;sign
ques
c_cond
l_char|&squot;-&squot;
suffix:colon
l_char|&squot;+&squot;
comma
(paren
r_int
)paren
(paren
id|r-&gt;sigh
op_rshift
l_int|16
)paren
comma
(paren
r_int
)paren
(paren
id|r-&gt;sigh
op_amp
l_int|0xFFFF
)paren
comma
(paren
r_int
)paren
(paren
id|r-&gt;sigl
op_rshift
l_int|16
)paren
comma
(paren
r_int
)paren
(paren
id|r-&gt;sigl
op_amp
l_int|0xFFFF
)paren
comma
id|r-&gt;exp
op_minus
id|EXP_BIAS
op_plus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Whoops! Error in errors.c      &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|tag_desc
(braket
(paren
r_int
)paren
(paren
r_int
)paren
id|r-&gt;tag
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;[data] %c .%04lx %04lx %04lx %04lx e%+-6ld &quot;
comma
id|FPU_loaded_data.sign
ques
c_cond
l_char|&squot;-&squot;
suffix:colon
l_char|&squot;+&squot;
comma
(paren
r_int
)paren
(paren
id|FPU_loaded_data.sigh
op_rshift
l_int|16
)paren
comma
(paren
r_int
)paren
(paren
id|FPU_loaded_data.sigh
op_amp
l_int|0xFFFF
)paren
comma
(paren
r_int
)paren
(paren
id|FPU_loaded_data.sigl
op_rshift
l_int|16
)paren
comma
(paren
r_int
)paren
(paren
id|FPU_loaded_data.sigl
op_amp
l_int|0xFFFF
)paren
comma
id|FPU_loaded_data.exp
op_minus
id|EXP_BIAS
op_plus
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|tag_desc
(braket
(paren
r_int
)paren
(paren
r_int
)paren
id|FPU_loaded_data.tag
)braket
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
)brace
r_static
r_struct
(brace
DECL|member|type
r_int
id|type
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|variable|exception_names
)brace
id|exception_names
(braket
)braket
op_assign
(brace
(brace
id|EX_StackOver
comma
l_string|&quot;stack overflow&quot;
)brace
comma
(brace
id|EX_StackUnder
comma
l_string|&quot;stack underflow&quot;
)brace
comma
(brace
id|EX_Precision
comma
l_string|&quot;loss of precision&quot;
)brace
comma
(brace
id|EX_Underflow
comma
l_string|&quot;underflow&quot;
)brace
comma
(brace
id|EX_Overflow
comma
l_string|&quot;overflow&quot;
)brace
comma
(brace
id|EX_ZeroDiv
comma
l_string|&quot;divide by zero&quot;
)brace
comma
(brace
id|EX_Denormal
comma
l_string|&quot;denormalized operand&quot;
)brace
comma
(brace
id|EX_Invalid
comma
l_string|&quot;invalid operation&quot;
)brace
comma
(brace
id|EX_INTERNAL
comma
l_string|&quot;INTERNAL BUG in &quot;
id|FPU_VERSION
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; EX_INTERNAL is always given with a code which indicates where the&n; error was detected.&n;&n; Internal error types:&n;       0      in load_store.c&n;       0x14   in fpu_etc.c&n;       0x1nn  in a *.c file:&n;              0x101  in reg_add_sub.c&n;              0x102  in reg_mul.c&n;              0x103  in poly_sin.c&n;              0x104  in poly_atan.c&n;              0x105  in reg_mul.c&n;&t;      0x106  in reg_ld_str.c&n;              0x107  in fpu_trig.c&n;&t;      0x108  in reg_compare.c&n;&t;      0x109  in reg_compare.c&n;&t;      0x110  in reg_add_sub.c&n;&t;      0x111  in fpe_entry.c&n;&t;      0x112  in fpu_trig.c&n;&t;      0x113  in errors.c&n;&t;      0x114  in reg_ld_str.c&n;&t;      0x115  in fpu_trig.c&n;&t;      0x116  in fpu_trig.c&n;&t;      0x117  in fpu_trig.c&n;&t;      0x118  in fpu_trig.c&n;&t;      0x119  in fpu_trig.c&n;&t;      0x120  in poly_atan.c&n;&t;      0x121  in reg_compare.c&n;&t;      0x122  in reg_compare.c&n;&t;      0x123  in reg_compare.c&n;&t;      0x125  in fpu_trig.c&n;&t;      0x126  in fpu_entry.c&n;&t;      0x127  in poly_2xm1.c&n;&t;      0x128  in fpu_entry.c&n;&t;      0x130  in get_address.c&n;       0x2nn  in an *.S file:&n;              0x201  in reg_u_add.S&n;              0x202  in reg_u_div.S&n;              0x203  in reg_u_div.S&n;              0x204  in reg_u_div.S&n;              0x205  in reg_u_mul.S&n;              0x206  in reg_u_sub.S&n;              0x207  in wm_sqrt.S&n;&t;      0x208  in reg_div.S&n;              0x209  in reg_u_sub.S&n;              0x210  in reg_u_sub.S&n;              0x211  in reg_u_sub.S&n;              0x212  in reg_u_sub.S&n;&t;      0x213  in wm_sqrt.S&n;&t;      0x214  in wm_sqrt.S&n;&t;      0x215  in wm_sqrt.S&n;&t;      0x220  in reg_norm.S&n;&t;      0x221  in reg_norm.S&n;&t;      0x230  in reg_round.S&n;&t;      0x231  in reg_round.S&n;&t;      0x232  in reg_round.S&n;&t;      0x233  in reg_round.S&n;&t;      0x234  in reg_round.S&n;&t;      0x235  in reg_round.S&n;&t;      0x236  in reg_round.S&n; */
DECL|function|exception
r_void
id|exception
c_func
(paren
r_int
id|n
)paren
(brace
r_int
id|i
comma
id|int_type
suffix:semicolon
id|int_type
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Needed only to stop compiler warnings */
r_if
c_cond
(paren
id|n
op_amp
id|EX_INTERNAL
)paren
(brace
id|int_type
op_assign
id|n
op_minus
id|EX_INTERNAL
suffix:semicolon
id|n
op_assign
id|EX_INTERNAL
suffix:semicolon
multiline_comment|/* Set lots of exception bits! */
id|partial_status
op_or_assign
(paren
id|SW_Exc_Mask
op_or
id|SW_Summary
op_or
id|SW_Backward
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Extract only the bits which we use to set the status word */
id|n
op_and_assign
(paren
id|SW_Exc_Mask
)paren
suffix:semicolon
multiline_comment|/* Set the corresponding exception bit */
id|partial_status
op_or_assign
id|n
suffix:semicolon
multiline_comment|/* Set summary bits iff exception isn&squot;t masked */
r_if
c_cond
(paren
id|partial_status
op_amp
op_complement
id|control_word
op_amp
id|CW_Exceptions
)paren
id|partial_status
op_or_assign
(paren
id|SW_Summary
op_or
id|SW_Backward
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_amp
(paren
id|SW_Stack_Fault
op_or
id|EX_Precision
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|n
op_amp
id|SW_C1
)paren
)paren
multiline_comment|/* This bit distinguishes over- from underflow for a stack fault,&n;&t;       and roundup from round-down for precision loss. */
id|partial_status
op_and_assign
op_complement
id|SW_C1
suffix:semicolon
)brace
)brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
r_if
c_cond
(paren
(paren
op_complement
id|control_word
op_amp
id|n
op_amp
id|CW_Exceptions
)paren
op_logical_or
(paren
id|n
op_eq
id|EX_INTERNAL
)paren
)paren
(brace
macro_line|#ifdef PRINT_MESSAGES
multiline_comment|/* My message from the sponsor */
id|printk
c_func
(paren
id|FPU_VERSION
l_string|&quot; &quot;
id|__DATE__
l_string|&quot; (C) W. Metzenthen.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif PRINT_MESSAGES
multiline_comment|/* Get a name string for error reporting */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|exception_names
(braket
id|i
)braket
dot
id|type
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|exception_names
(braket
id|i
)braket
dot
id|type
op_amp
id|n
)paren
op_eq
id|exception_names
(braket
id|i
)braket
dot
id|type
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|exception_names
(braket
id|i
)braket
dot
id|type
)paren
(brace
macro_line|#ifdef PRINT_MESSAGES
id|printk
c_func
(paren
l_string|&quot;FP Exception: %s!&bslash;n&quot;
comma
id|exception_names
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
macro_line|#endif PRINT_MESSAGES
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;FPU emulator: Unknown Exception: 0x%04x!&bslash;n&quot;
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
id|EX_INTERNAL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FPU emulator: Internal error type 0x%04x&bslash;n&quot;
comma
id|int_type
)paren
suffix:semicolon
id|emu_printall
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef PRINT_MESSAGES
r_else
id|emu_printall
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif PRINT_MESSAGES
multiline_comment|/*&n;       * The 80486 generates an interrupt on the next non-control FPU&n;       * instruction. So we need some means of flagging it.&n;       * We use the ES (Error Summary) bit for this, assuming that&n;       * this is the way a real FPU does it (until I can check it out),&n;       * if not, then some method such as the following kludge might&n;       * be needed.&n;       */
multiline_comment|/*      regs[0].tag |= TW_FPU_Interrupt; */
)brace
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
macro_line|#ifdef __DEBUG__
id|math_abort
c_func
(paren
id|FPU_info
comma
id|SIGFPE
)paren
suffix:semicolon
macro_line|#endif __DEBUG__
)brace
multiline_comment|/* Real operation attempted on two operands, one a NaN. */
multiline_comment|/* Returns nz if the exception is unmasked */
DECL|function|real_2op_NaN
id|asmlinkage
r_int
id|real_2op_NaN
c_func
(paren
id|FPU_REG
r_const
op_star
id|a
comma
id|FPU_REG
r_const
op_star
id|b
comma
id|FPU_REG
op_star
id|dest
)paren
(brace
id|FPU_REG
r_const
op_star
id|x
suffix:semicolon
r_int
id|signalling
suffix:semicolon
multiline_comment|/* The default result for the case of two &quot;equal&quot; NaNs (signs may&n;     differ) is chosen to reproduce 80486 behaviour */
id|x
op_assign
id|a
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;tag
op_eq
id|TW_NaN
)paren
(brace
r_if
c_cond
(paren
id|b-&gt;tag
op_eq
id|TW_NaN
)paren
(brace
id|signalling
op_assign
op_logical_neg
(paren
id|a-&gt;sigh
op_amp
id|b-&gt;sigh
op_amp
l_int|0x40000000
)paren
suffix:semicolon
multiline_comment|/* find the &quot;larger&quot; */
r_if
c_cond
(paren
id|significand
c_func
(paren
id|a
)paren
OL
id|significand
c_func
(paren
id|b
)paren
)paren
id|x
op_assign
id|b
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* return the quiet version of the NaN in a */
id|signalling
op_assign
op_logical_neg
(paren
id|a-&gt;sigh
op_amp
l_int|0x40000000
)paren
suffix:semicolon
)brace
)brace
r_else
macro_line|#ifdef PARANOID
r_if
c_cond
(paren
id|b-&gt;tag
op_eq
id|TW_NaN
)paren
macro_line|#endif PARANOID
(brace
id|signalling
op_assign
op_logical_neg
(paren
id|b-&gt;sigh
op_amp
l_int|0x40000000
)paren
suffix:semicolon
id|x
op_assign
id|b
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
(brace
id|signalling
op_assign
l_int|0
suffix:semicolon
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x113
)paren
suffix:semicolon
id|x
op_assign
op_amp
id|CONST_QNaN
suffix:semicolon
)brace
macro_line|#endif PARANOID
r_if
c_cond
(paren
op_logical_neg
id|signalling
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|x-&gt;sigh
op_amp
l_int|0x80000000
)paren
)paren
multiline_comment|/* pseudo-NaN ? */
id|x
op_assign
op_amp
id|CONST_QNaN
suffix:semicolon
id|reg_move
c_func
(paren
id|x
comma
id|dest
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
multiline_comment|/* The masked response */
r_if
c_cond
(paren
op_logical_neg
(paren
id|x-&gt;sigh
op_amp
l_int|0x80000000
)paren
)paren
multiline_comment|/* pseudo-NaN ? */
id|x
op_assign
op_amp
id|CONST_QNaN
suffix:semicolon
id|reg_move
c_func
(paren
id|x
comma
id|dest
)paren
suffix:semicolon
multiline_comment|/* ensure a Quiet NaN */
id|dest-&gt;sigh
op_or_assign
l_int|0x40000000
suffix:semicolon
)brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_return
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
suffix:semicolon
)brace
multiline_comment|/* Invalid arith operation on Valid registers */
multiline_comment|/* Returns nz if the exception is unmasked */
DECL|function|arith_invalid
id|asmlinkage
r_int
id|arith_invalid
c_func
(paren
id|FPU_REG
op_star
id|dest
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
multiline_comment|/* The masked response */
id|reg_move
c_func
(paren
op_amp
id|CONST_QNaN
comma
id|dest
)paren
suffix:semicolon
)brace
r_return
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
suffix:semicolon
)brace
multiline_comment|/* Divide a finite number by zero */
DECL|function|divide_by_zero
id|asmlinkage
r_int
id|divide_by_zero
c_func
(paren
r_int
id|sign
comma
id|FPU_REG
op_star
id|dest
)paren
(brace
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_ZeroDiv
)paren
(brace
multiline_comment|/* The masked response */
id|reg_move
c_func
(paren
op_amp
id|CONST_INF
comma
id|dest
)paren
suffix:semicolon
id|dest-&gt;sign
op_assign
(paren
r_int
r_char
)paren
id|sign
suffix:semicolon
)brace
id|EXCEPTION
c_func
(paren
id|EX_ZeroDiv
)paren
suffix:semicolon
r_return
op_logical_neg
(paren
id|control_word
op_amp
id|CW_ZeroDiv
)paren
suffix:semicolon
)brace
multiline_comment|/* This may be called often, so keep it lean */
DECL|function|set_precision_flag
r_int
id|set_precision_flag
c_func
(paren
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Precision
)paren
(brace
id|partial_status
op_and_assign
op_complement
(paren
id|SW_C1
op_amp
id|flags
)paren
suffix:semicolon
id|partial_status
op_or_assign
id|flags
suffix:semicolon
multiline_comment|/* The masked response */
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|exception
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* This may be called often, so keep it lean */
DECL|function|set_precision_flag_up
id|asmlinkage
r_void
id|set_precision_flag_up
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Precision
)paren
id|partial_status
op_or_assign
(paren
id|SW_Precision
op_or
id|SW_C1
)paren
suffix:semicolon
multiline_comment|/* The masked response */
r_else
id|exception
c_func
(paren
id|EX_Precision
op_or
id|SW_C1
)paren
suffix:semicolon
)brace
multiline_comment|/* This may be called often, so keep it lean */
DECL|function|set_precision_flag_down
id|asmlinkage
r_void
id|set_precision_flag_down
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Precision
)paren
(brace
multiline_comment|/* The masked response */
id|partial_status
op_and_assign
op_complement
id|SW_C1
suffix:semicolon
id|partial_status
op_or_assign
id|SW_Precision
suffix:semicolon
)brace
r_else
id|exception
c_func
(paren
id|EX_Precision
)paren
suffix:semicolon
)brace
DECL|function|denormal_operand
id|asmlinkage
r_int
id|denormal_operand
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Denormal
)paren
(brace
multiline_comment|/* The masked response */
id|partial_status
op_or_assign
id|SW_Denorm_Op
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|exception
c_func
(paren
id|EX_Denormal
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|arith_overflow
id|asmlinkage
r_int
id|arith_overflow
c_func
(paren
id|FPU_REG
op_star
id|dest
)paren
(brace
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Overflow
)paren
(brace
r_char
id|sign
suffix:semicolon
multiline_comment|/* The masked response */
multiline_comment|/* ###### The response here depends upon the rounding mode */
id|sign
op_assign
id|dest-&gt;sign
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_INF
comma
id|dest
)paren
suffix:semicolon
id|dest-&gt;sign
op_assign
id|sign
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Subtract the magic number from the exponent */
id|dest-&gt;exp
op_sub_assign
(paren
l_int|3
op_star
(paren
l_int|1
op_lshift
l_int|13
)paren
)paren
suffix:semicolon
)brace
id|EXCEPTION
c_func
(paren
id|EX_Overflow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Overflow
)paren
(brace
multiline_comment|/* The overflow exception is masked. */
multiline_comment|/* By definition, precision is lost.&n;&t; The roundup bit (C1) is also set because we have&n;&t; &quot;rounded&quot; upwards to Infinity. */
id|EXCEPTION
c_func
(paren
id|EX_Precision
op_or
id|SW_C1
)paren
suffix:semicolon
r_return
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Precision
)paren
suffix:semicolon
)brace
r_return
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Overflow
)paren
suffix:semicolon
)brace
DECL|function|arith_underflow
id|asmlinkage
r_int
id|arith_underflow
c_func
(paren
id|FPU_REG
op_star
id|dest
)paren
(brace
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Underflow
)paren
(brace
multiline_comment|/* The masked response */
r_if
c_cond
(paren
id|dest-&gt;exp
op_le
id|EXP_UNDER
op_minus
l_int|63
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|dest
)paren
suffix:semicolon
id|partial_status
op_and_assign
op_complement
id|SW_C1
suffix:semicolon
multiline_comment|/* Round down. */
)brace
)brace
r_else
(brace
multiline_comment|/* Add the magic number to the exponent. */
id|dest-&gt;exp
op_add_assign
(paren
l_int|3
op_star
(paren
l_int|1
op_lshift
l_int|13
)paren
)paren
suffix:semicolon
)brace
id|EXCEPTION
c_func
(paren
id|EX_Underflow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Underflow
)paren
(brace
multiline_comment|/* The underflow exception is masked. */
id|EXCEPTION
c_func
(paren
id|EX_Precision
)paren
suffix:semicolon
r_return
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Precision
)paren
suffix:semicolon
)brace
r_return
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Underflow
)paren
suffix:semicolon
)brace
DECL|function|stack_overflow
r_void
id|stack_overflow
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
multiline_comment|/* The masked response */
id|top
op_decrement
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_QNaN
comma
id|FPU_st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
id|EXCEPTION
c_func
(paren
id|EX_StackOver
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|stack_underflow
r_void
id|stack_underflow
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
multiline_comment|/* The masked response */
id|reg_move
c_func
(paren
op_amp
id|CONST_QNaN
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
)brace
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|stack_underflow_i
r_void
id|stack_underflow_i
c_func
(paren
r_int
id|i
)paren
(brace
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
multiline_comment|/* The masked response */
id|reg_move
c_func
(paren
op_amp
id|CONST_QNaN
comma
op_amp
(paren
id|st
c_func
(paren
id|i
)paren
)paren
)paren
suffix:semicolon
)brace
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|stack_underflow_pop
r_void
id|stack_underflow_pop
c_func
(paren
r_int
id|i
)paren
(brace
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
multiline_comment|/* The masked response */
id|reg_move
c_func
(paren
op_amp
id|CONST_QNaN
comma
op_amp
(paren
id|st
c_func
(paren
id|i
)paren
)paren
)paren
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
)brace
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
eof
