multiline_comment|/*---------------------------------------------------------------------------+&n; |  poly_l2.c                                                                |&n; |                                                                           |&n; | Compute the base 2 log of a FPU_REG, using a polynomial approximation.    |&n; |                                                                           |&n; | Copyright (C) 1992,1993                                                   |&n; |                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,      |&n; |                       Australia.  E-mail apm233m@vaxc.cc.monash.edu.au    |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;reg_constant.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;control_w.h&quot;
DECL|macro|HIPOWER
mdefine_line|#define&t;HIPOWER&t;9
DECL|variable|lterms
r_static
r_int
r_int
id|lterms
(braket
id|HIPOWER
)braket
(braket
l_int|4
)braket
op_assign
(brace
multiline_comment|/* Ideal computation with these coeffs gives about&n;&t;   64.6 bit rel accuracy. */
(brace
l_int|0xe177
comma
l_int|0xb82f
comma
l_int|0x7652
comma
l_int|0x7154
)brace
comma
(brace
l_int|0xee0f
comma
l_int|0xe80f
comma
l_int|0x2770
comma
l_int|0x7b1c
)brace
comma
(brace
l_int|0x0fc0
comma
l_int|0xbe87
comma
l_int|0xb143
comma
l_int|0x49dd
)brace
comma
(brace
l_int|0x78b9
comma
l_int|0xdadd
comma
l_int|0xec54
comma
l_int|0x34c2
)brace
comma
(brace
l_int|0x003a
comma
l_int|0x5de9
comma
l_int|0x628b
comma
l_int|0x2909
)brace
comma
(brace
l_int|0x5588
comma
l_int|0xed16
comma
l_int|0x4abf
comma
l_int|0x2193
)brace
comma
(brace
l_int|0xb461
comma
l_int|0x85f7
comma
l_int|0x347a
comma
l_int|0x1c6a
)brace
comma
(brace
l_int|0x0975
comma
l_int|0x87b3
comma
l_int|0xd5bf
comma
l_int|0x1876
)brace
comma
(brace
l_int|0xe85c
comma
l_int|0xcec9
comma
l_int|0x84e7
comma
l_int|0x187d
)brace
)brace
suffix:semicolon
multiline_comment|/*--- poly_l2() -------------------------------------------------------------+&n; |   Base 2 logarithm by a polynomial approximation.                         |&n; +---------------------------------------------------------------------------*/
DECL|function|poly_l2
r_void
id|poly_l2
c_func
(paren
id|FPU_REG
op_star
id|arg
comma
id|FPU_REG
op_star
id|result
)paren
(brace
r_int
id|exponent
suffix:semicolon
r_char
id|zero
suffix:semicolon
multiline_comment|/* flag for an Xx == 0 */
r_int
r_int
id|bits
comma
id|shift
suffix:semicolon
r_int
r_int
r_int
id|Xsq
suffix:semicolon
id|FPU_REG
id|accum
comma
id|denom
comma
id|num
comma
id|Xx
suffix:semicolon
id|exponent
op_assign
id|arg-&gt;exp
op_minus
id|EXP_BIAS
suffix:semicolon
id|accum.tag
op_assign
id|TW_Valid
suffix:semicolon
multiline_comment|/* set the tags to Valid */
r_if
c_cond
(paren
id|arg-&gt;sigh
OG
(paren
r_int
)paren
l_int|0xb504f334
)paren
(brace
multiline_comment|/* This is good enough for the computation of the polynomial&n;&t; sum, but actually results in a loss of precision for&n;&t; the computation of Xx. This will matter only if exponent&n;&t; becomes zero. */
id|exponent
op_increment
suffix:semicolon
id|accum.sign
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* sign to negative */
id|num.exp
op_assign
id|EXP_BIAS
suffix:semicolon
multiline_comment|/* needed to prevent errors in div routine */
id|reg_u_div
c_func
(paren
op_amp
id|CONST_1
comma
id|arg
comma
op_amp
id|num
comma
id|FULL_PRECISION
)paren
suffix:semicolon
)brace
r_else
(brace
id|accum.sign
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set the sign to positive */
id|num.sigl
op_assign
id|arg-&gt;sigl
suffix:semicolon
multiline_comment|/* copy the mantissa */
id|num.sigh
op_assign
id|arg-&gt;sigh
suffix:semicolon
)brace
multiline_comment|/* shift num left, lose the ms bit */
id|num.sigh
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|num.sigl
op_amp
l_int|0x80000000
)paren
id|num.sigh
op_or_assign
l_int|1
suffix:semicolon
id|num.sigl
op_lshift_assign
l_int|1
suffix:semicolon
id|denom.sigl
op_assign
id|num.sigl
suffix:semicolon
id|denom.sigh
op_assign
id|num.sigh
suffix:semicolon
id|poly_div4
c_func
(paren
op_amp
id|significand
c_func
(paren
op_amp
id|denom
)paren
)paren
suffix:semicolon
id|denom.sigh
op_add_assign
l_int|0x80000000
suffix:semicolon
multiline_comment|/* set the msb */
id|Xx.exp
op_assign
id|EXP_BIAS
suffix:semicolon
multiline_comment|/* needed to prevent errors in div routine */
id|reg_u_div
c_func
(paren
op_amp
id|num
comma
op_amp
id|denom
comma
op_amp
id|Xx
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|zero
op_assign
op_logical_neg
(paren
id|Xx.sigh
op_or
id|Xx.sigl
)paren
suffix:semicolon
id|mul64
c_func
(paren
op_amp
id|significand
c_func
(paren
op_amp
id|Xx
)paren
comma
op_amp
id|significand
c_func
(paren
op_amp
id|Xx
)paren
comma
op_amp
id|Xsq
)paren
suffix:semicolon
id|poly_div16
c_func
(paren
op_amp
id|Xsq
)paren
suffix:semicolon
id|accum.exp
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* exponent of accum */
multiline_comment|/* Do the basic fixed point polynomial evaluation */
id|polynomial
c_func
(paren
(paren
r_int
op_star
)paren
op_amp
id|accum.sigl
comma
(paren
r_int
op_star
)paren
op_amp
id|Xsq
comma
id|lterms
comma
id|HIPOWER
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|exponent
)paren
(brace
multiline_comment|/* If the exponent is zero, then we would lose precision by&n;&t; sticking to fixed point computation here */
multiline_comment|/* We need to re-compute Xx because of loss of precision. */
id|FPU_REG
id|lXx
suffix:semicolon
r_char
id|sign
suffix:semicolon
id|sign
op_assign
id|accum.sign
suffix:semicolon
id|accum.sign
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* make accum compatible and normalize */
id|accum.exp
op_assign
id|EXP_BIAS
op_plus
id|accum.exp
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|accum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zero
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|result
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we need to re-compute lXx to better accuracy */
id|num.tag
op_assign
id|TW_Valid
suffix:semicolon
multiline_comment|/* set the tags to Vaild */
id|num.sign
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set the sign to positive */
id|num.exp
op_assign
id|EXP_BIAS
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sign
)paren
(brace
multiline_comment|/* The argument is of the form 1-x */
multiline_comment|/* Use  1-1/(1-x) = x/(1-x) */
id|significand
c_func
(paren
op_amp
id|num
)paren
op_assign
op_minus
id|significand
c_func
(paren
id|arg
)paren
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|num
)paren
suffix:semicolon
id|reg_div
c_func
(paren
op_amp
id|num
comma
id|arg
comma
op_amp
id|num
comma
id|FULL_PRECISION
)paren
suffix:semicolon
)brace
r_else
(brace
id|normalize
c_func
(paren
op_amp
id|num
)paren
suffix:semicolon
)brace
id|denom.tag
op_assign
id|TW_Valid
suffix:semicolon
multiline_comment|/* set the tags to Valid */
id|denom.sign
op_assign
id|SIGN_POS
suffix:semicolon
multiline_comment|/* set the sign to positive */
id|denom.exp
op_assign
id|EXP_BIAS
suffix:semicolon
id|reg_div
c_func
(paren
op_amp
id|num
comma
op_amp
id|denom
comma
op_amp
id|lXx
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|reg_u_mul
c_func
(paren
op_amp
id|lXx
comma
op_amp
id|accum
comma
op_amp
id|accum
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|reg_u_add
c_func
(paren
op_amp
id|lXx
comma
op_amp
id|accum
comma
id|result
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|normalize
c_func
(paren
id|result
)paren
suffix:semicolon
)brace
id|result-&gt;sign
op_assign
id|sign
suffix:semicolon
r_return
suffix:semicolon
)brace
id|mul64
c_func
(paren
op_amp
id|significand
c_func
(paren
op_amp
id|accum
)paren
comma
op_amp
id|significand
c_func
(paren
op_amp
id|Xx
)paren
comma
op_amp
id|significand
c_func
(paren
op_amp
id|accum
)paren
)paren
suffix:semicolon
id|significand
c_func
(paren
op_amp
id|accum
)paren
op_add_assign
id|significand
c_func
(paren
op_amp
id|Xx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Xx.sigh
OG
id|accum.sigh
)paren
(brace
multiline_comment|/* There was an overflow */
id|poly_div2
c_func
(paren
op_amp
id|significand
c_func
(paren
op_amp
id|accum
)paren
)paren
suffix:semicolon
id|accum.sigh
op_or_assign
l_int|0x80000000
suffix:semicolon
id|accum.exp
op_increment
suffix:semicolon
)brace
multiline_comment|/* When we add the exponent to the accum result later, we will&n;     require that their signs are the same. Here we ensure that&n;     this is so. */
r_if
c_cond
(paren
id|exponent
op_logical_and
(paren
(paren
id|exponent
OL
l_int|0
)paren
op_xor
(paren
id|accum.sign
)paren
)paren
)paren
(brace
multiline_comment|/* signs are different */
id|accum.sign
op_assign
op_logical_neg
id|accum.sign
suffix:semicolon
multiline_comment|/* An exceptional case is when accum is zero */
r_if
c_cond
(paren
id|accum.sigl
op_or
id|accum.sigh
)paren
(brace
multiline_comment|/* find 1-accum */
multiline_comment|/* Shift to get exponent == 0 */
r_if
c_cond
(paren
id|accum.exp
OL
l_int|0
)paren
(brace
id|poly_div2
c_func
(paren
op_amp
id|significand
c_func
(paren
op_amp
id|accum
)paren
)paren
suffix:semicolon
id|accum.exp
op_increment
suffix:semicolon
)brace
multiline_comment|/* Just negate, but throw away the sign */
id|significand
c_func
(paren
op_amp
id|accum
)paren
op_assign
op_minus
id|significand
c_func
(paren
op_amp
id|accum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exponent
OL
l_int|0
)paren
id|exponent
op_increment
suffix:semicolon
r_else
id|exponent
op_decrement
suffix:semicolon
)brace
)brace
id|shift
op_assign
id|exponent
op_ge
l_int|0
ques
c_cond
id|exponent
suffix:colon
op_minus
id|exponent
suffix:semicolon
id|bits
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|shift
)paren
(brace
r_if
c_cond
(paren
id|accum.exp
)paren
(brace
id|accum.exp
op_increment
suffix:semicolon
id|poly_div2
c_func
(paren
op_amp
id|significand
c_func
(paren
op_amp
id|accum
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|shift
)paren
(brace
id|poly_div2
c_func
(paren
op_amp
id|significand
c_func
(paren
op_amp
id|accum
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shift
op_amp
l_int|1
)paren
id|accum.sigh
op_or_assign
l_int|0x80000000
suffix:semicolon
id|shift
op_rshift_assign
l_int|1
suffix:semicolon
id|bits
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Convert to 64 bit signed-compatible */
id|accum.exp
op_add_assign
id|bits
op_plus
id|EXP_BIAS
op_minus
l_int|1
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|accum
comma
id|result
)paren
suffix:semicolon
id|normalize
c_func
(paren
id|result
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*--- poly_l2p1() -----------------------------------------------------------+&n; |   Base 2 logarithm by a polynomial approximation.                         |&n; |   log2(x+1)                                                               |&n; +---------------------------------------------------------------------------*/
DECL|function|poly_l2p1
r_int
id|poly_l2p1
c_func
(paren
id|FPU_REG
op_star
id|arg
comma
id|FPU_REG
op_star
id|result
)paren
(brace
r_char
id|sign
op_assign
l_int|0
suffix:semicolon
r_int
r_int
r_int
id|Xsq
suffix:semicolon
id|FPU_REG
id|arg_pl1
comma
id|denom
comma
id|accum
comma
id|local_arg
comma
id|poly_arg
suffix:semicolon
id|sign
op_assign
id|arg-&gt;sign
suffix:semicolon
id|reg_add
c_func
(paren
id|arg
comma
op_amp
id|CONST_1
comma
op_amp
id|arg_pl1
comma
id|FULL_PRECISION
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_pl1.sign
)paren
op_or
(paren
id|arg_pl1.tag
)paren
)paren
(brace
multiline_comment|/* We need a valid positive number! */
r_return
l_int|1
suffix:semicolon
)brace
id|reg_add
c_func
(paren
op_amp
id|CONST_1
comma
op_amp
id|arg_pl1
comma
op_amp
id|denom
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|reg_div
c_func
(paren
id|arg
comma
op_amp
id|denom
comma
op_amp
id|local_arg
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|local_arg.sign
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Make the sign positive */
multiline_comment|/* Now we need to check that  |local_arg| is less than&n;     3-2*sqrt(2) = 0.17157.. = .0xafb0ccc0 * 2^-2 */
r_if
c_cond
(paren
id|local_arg.exp
op_ge
id|EXP_BIAS
op_minus
l_int|3
)paren
(brace
r_if
c_cond
(paren
(paren
id|local_arg.exp
OG
id|EXP_BIAS
op_minus
l_int|3
)paren
op_logical_or
(paren
id|local_arg.sigh
OG
(paren
r_int
)paren
l_int|0xafb0ccc0
)paren
)paren
(brace
multiline_comment|/* The argument is large */
id|poly_l2
c_func
(paren
op_amp
id|arg_pl1
comma
id|result
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Make a copy of local_arg */
id|reg_move
c_func
(paren
op_amp
id|local_arg
comma
op_amp
id|poly_arg
)paren
suffix:semicolon
multiline_comment|/* Get poly_arg bits aligned as required */
id|shrx
c_func
(paren
(paren
r_int
op_star
)paren
op_amp
(paren
id|poly_arg.sigl
)paren
comma
op_minus
(paren
id|poly_arg.exp
op_minus
id|EXP_BIAS
op_plus
l_int|3
)paren
)paren
suffix:semicolon
id|mul64
c_func
(paren
op_amp
id|significand
c_func
(paren
op_amp
id|poly_arg
)paren
comma
op_amp
id|significand
c_func
(paren
op_amp
id|poly_arg
)paren
comma
op_amp
id|Xsq
)paren
suffix:semicolon
id|poly_div16
c_func
(paren
op_amp
id|Xsq
)paren
suffix:semicolon
multiline_comment|/* Do the basic fixed point polynomial evaluation */
id|polynomial
c_func
(paren
op_amp
(paren
id|accum.sigl
)paren
comma
(paren
r_int
op_star
)paren
op_amp
id|Xsq
comma
id|lterms
comma
id|HIPOWER
op_minus
l_int|1
)paren
suffix:semicolon
id|accum.tag
op_assign
id|TW_Valid
suffix:semicolon
multiline_comment|/* set the tags to Valid */
id|accum.sign
op_assign
id|SIGN_POS
suffix:semicolon
multiline_comment|/* and make accum positive */
multiline_comment|/* make accum compatible and normalize */
id|accum.exp
op_assign
id|EXP_BIAS
op_minus
l_int|1
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|accum
)paren
suffix:semicolon
id|reg_u_mul
c_func
(paren
op_amp
id|local_arg
comma
op_amp
id|accum
comma
op_amp
id|accum
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|reg_u_add
c_func
(paren
op_amp
id|local_arg
comma
op_amp
id|accum
comma
id|result
comma
id|FULL_PRECISION
)paren
suffix:semicolon
multiline_comment|/* Multiply the result by 2 */
id|result-&gt;exp
op_increment
suffix:semicolon
id|result-&gt;sign
op_assign
id|sign
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
