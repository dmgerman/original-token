multiline_comment|/*---------------------------------------------------------------------------+&n; |  fpu_trig.c                                                               |&n; |                                                                           |&n; | Implementation of the FPU &quot;transcendental&quot; functions.                     |&n; |                                                                           |&n; | Copyright (C) 1992,1993                                                   |&n; |                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,      |&n; |                       Australia.  E-mail   billm@vaxc.cc.monash.edu.au    |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
macro_line|#include &quot;fpu_system.h&quot;
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;status_w.h&quot;
macro_line|#include &quot;control_w.h&quot;
macro_line|#include &quot;reg_constant.h&quot;&t;
r_static
r_void
id|rem_kernel
c_func
(paren
r_int
r_int
r_int
id|st0
comma
r_int
r_int
r_int
op_star
id|y
comma
r_int
r_int
r_int
id|st1
comma
r_int
r_int
r_int
id|q
comma
r_int
id|n
)paren
suffix:semicolon
DECL|macro|BETTER_THAN_486
mdefine_line|#define BETTER_THAN_486
DECL|macro|FCOS
mdefine_line|#define FCOS  4
DECL|macro|FPTAN
mdefine_line|#define FPTAN 1
multiline_comment|/* Used only by fptan, fsin, fcos, and fsincos. */
multiline_comment|/* This routine produces very accurate results, similar to&n;   using a value of pi with more than 128 bits precision. */
multiline_comment|/* Limited measurements show no results worse than 64 bit precision&n;   except for the results for arguments close to 2^63, where the&n;   precision of the result sometimes degrades to about 63.9 bits */
DECL|function|trig_arg
r_static
r_int
id|trig_arg
c_func
(paren
id|FPU_REG
op_star
id|X
comma
r_int
id|even
)paren
(brace
id|FPU_REG
id|tmp
suffix:semicolon
r_int
r_int
r_int
id|q
suffix:semicolon
r_int
id|old_cw
op_assign
id|control_word
comma
id|saved_status
op_assign
id|partial_status
suffix:semicolon
r_if
c_cond
(paren
id|X-&gt;exp
op_ge
id|EXP_BIAS
op_plus
l_int|63
)paren
(brace
id|partial_status
op_or_assign
id|SW_C2
suffix:semicolon
multiline_comment|/* Reduction incomplete. */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|control_word
op_and_assign
op_complement
id|CW_RC
suffix:semicolon
id|control_word
op_or_assign
id|RC_CHOP
suffix:semicolon
id|reg_div
c_func
(paren
id|X
comma
op_amp
id|CONST_PI2
comma
op_amp
id|tmp
comma
id|PR_64_BITS
op_or
id|RC_CHOP
op_or
l_int|0x3f
)paren
suffix:semicolon
id|round_to_int
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* Fortunately, this can&squot;t overflow&n;&t;&t;&t;  to 2^64 */
id|q
op_assign
id|significand
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
)paren
(brace
id|rem_kernel
c_func
(paren
id|significand
c_func
(paren
id|X
)paren
comma
op_amp
id|significand
c_func
(paren
op_amp
id|tmp
)paren
comma
id|significand
c_func
(paren
op_amp
id|CONST_PI2
)paren
comma
id|q
comma
id|X-&gt;exp
op_minus
id|CONST_PI2.exp
)paren
suffix:semicolon
id|tmp.exp
op_assign
id|CONST_PI2.exp
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|tmp
comma
id|X
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|even
op_eq
id|FPTAN
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|X-&gt;exp
op_ge
id|EXP_BIAS
)paren
op_logical_or
(paren
(paren
id|X-&gt;exp
op_eq
id|EXP_BIAS
op_minus
l_int|1
)paren
op_logical_and
(paren
id|X-&gt;sigh
op_ge
l_int|0xc90fdaa2
)paren
)paren
)paren
op_xor
(paren
id|q
op_amp
l_int|1
)paren
)paren
id|even
op_assign
id|FCOS
suffix:semicolon
r_else
id|even
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|even
op_logical_and
op_logical_neg
(paren
id|q
op_amp
l_int|1
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|even
op_logical_and
(paren
id|q
op_amp
l_int|1
)paren
)paren
)paren
(brace
id|reg_sub
c_func
(paren
op_amp
id|CONST_PI2
comma
id|X
comma
id|X
comma
id|FULL_PRECISION
)paren
suffix:semicolon
macro_line|#ifdef BETTER_THAN_486
multiline_comment|/* So far, the results are exact but based upon a 64 bit&n;&t; precision approximation to pi/2. The technique used&n;&t; now is equivalent to using an approximation to pi/2 which&n;&t; is accurate to about 128 bits. */
r_if
c_cond
(paren
(paren
id|X-&gt;exp
op_le
id|CONST_PI2extra.exp
op_plus
l_int|64
)paren
op_logical_or
(paren
id|q
OG
l_int|1
)paren
)paren
(brace
multiline_comment|/* This code gives the effect of having p/2 to better than&n;&t;     128 bits precision. */
id|significand
c_func
(paren
op_amp
id|tmp
)paren
op_assign
id|q
op_plus
l_int|1
suffix:semicolon
id|tmp.exp
op_assign
id|EXP_BIAS
op_plus
l_int|63
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|reg_mul
c_func
(paren
op_amp
id|CONST_PI2extra
comma
op_amp
id|tmp
comma
op_amp
id|tmp
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|reg_add
c_func
(paren
id|X
comma
op_amp
id|tmp
comma
id|X
comma
id|FULL_PRECISION
)paren
suffix:semicolon
)brace
macro_line|#endif BETTER_THAN_486
)brace
macro_line|#ifdef BETTER_THAN_486
r_else
(brace
multiline_comment|/* So far, the results are exact but based upon a 64 bit&n;&t; precision approximation to pi/2. The technique used&n;&t; now is equivalent to using an approximation to pi/2 which&n;&t; is accurate to about 128 bits. */
r_if
c_cond
(paren
(paren
(paren
id|q
OG
l_int|0
)paren
op_logical_and
(paren
id|X-&gt;exp
op_le
id|CONST_PI2extra.exp
op_plus
l_int|64
)paren
)paren
op_logical_or
(paren
id|q
OG
l_int|1
)paren
)paren
(brace
multiline_comment|/* This code gives the effect of having p/2 to better than&n;&t;     128 bits precision. */
id|significand
c_func
(paren
op_amp
id|tmp
)paren
op_assign
id|q
suffix:semicolon
id|tmp.exp
op_assign
id|EXP_BIAS
op_plus
l_int|63
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|reg_mul
c_func
(paren
op_amp
id|CONST_PI2extra
comma
op_amp
id|tmp
comma
op_amp
id|tmp
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|reg_sub
c_func
(paren
id|X
comma
op_amp
id|tmp
comma
id|X
comma
id|FULL_PRECISION
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif BETTER_THAN_486
id|control_word
op_assign
id|old_cw
suffix:semicolon
id|partial_status
op_assign
id|saved_status
op_amp
op_complement
id|SW_C2
suffix:semicolon
multiline_comment|/* Reduction complete. */
r_return
(paren
id|q
op_amp
l_int|3
)paren
op_or
id|even
suffix:semicolon
)brace
multiline_comment|/* Convert a long to register */
DECL|function|convert_l2reg
r_void
id|convert_l2reg
c_func
(paren
r_int
r_const
op_star
id|arg
comma
id|FPU_REG
op_star
id|dest
)paren
(brace
r_int
id|num
op_assign
op_star
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|num
op_eq
l_int|0
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|dest
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|num
OG
l_int|0
)paren
id|dest-&gt;sign
op_assign
id|SIGN_POS
suffix:semicolon
r_else
(brace
id|num
op_assign
op_minus
id|num
suffix:semicolon
id|dest-&gt;sign
op_assign
id|SIGN_NEG
suffix:semicolon
)brace
id|dest-&gt;sigh
op_assign
id|num
suffix:semicolon
id|dest-&gt;sigl
op_assign
l_int|0
suffix:semicolon
id|dest-&gt;exp
op_assign
id|EXP_BIAS
op_plus
l_int|31
suffix:semicolon
id|dest-&gt;tag
op_assign
id|TW_Valid
suffix:semicolon
id|normalize
c_func
(paren
id|dest
)paren
suffix:semicolon
)brace
DECL|function|single_arg_error
r_static
r_void
id|single_arg_error
c_func
(paren
r_void
)paren
(brace
r_switch
c_cond
(paren
id|FPU_st0_tag
)paren
(brace
r_case
id|TW_NaN
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|FPU_st0_ptr-&gt;sigh
op_amp
l_int|0x40000000
)paren
)paren
multiline_comment|/* Signaling ? */
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
id|FPU_st0_ptr-&gt;sigh
op_or_assign
l_int|0x40000000
suffix:semicolon
multiline_comment|/* Convert to a QNaN */
)brace
r_break
suffix:semicolon
multiline_comment|/* return with a NaN in st(0) */
r_case
id|TW_Empty
suffix:colon
id|stack_underflow
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Puts a QNaN in st(0) */
r_break
suffix:semicolon
macro_line|#ifdef PARANOID
r_default
suffix:colon
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x0112
)paren
suffix:semicolon
macro_line|#endif PARANOID
)brace
)brace
DECL|function|single_arg_2_error
r_static
r_void
id|single_arg_2_error
c_func
(paren
r_void
)paren
(brace
id|FPU_REG
op_star
id|st_new_ptr
suffix:semicolon
r_switch
c_cond
(paren
id|FPU_st0_tag
)paren
(brace
r_case
id|TW_NaN
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|FPU_st0_ptr-&gt;sigh
op_amp
l_int|0x40000000
)paren
)paren
multiline_comment|/* Signaling ? */
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
multiline_comment|/* The masked response */
multiline_comment|/* Convert to a QNaN */
id|FPU_st0_ptr-&gt;sigh
op_or_assign
l_int|0x40000000
suffix:semicolon
id|st_new_ptr
op_assign
op_amp
id|st
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|st
c_func
(paren
l_int|1
)paren
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* A QNaN */
id|st_new_ptr
op_assign
op_amp
id|st
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|st
c_func
(paren
l_int|1
)paren
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* return with a NaN in st(0) */
macro_line|#ifdef PARANOID
r_default
suffix:colon
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x0112
)paren
suffix:semicolon
macro_line|#endif PARANOID
)brace
)brace
multiline_comment|/*---------------------------------------------------------------------------*/
DECL|function|f2xm1
r_static
r_void
id|f2xm1
c_func
(paren
r_void
)paren
(brace
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|FPU_st0_tag
)paren
(brace
r_case
id|TW_Valid
suffix:colon
(brace
id|FPU_REG
id|rv
comma
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
op_ge
l_int|0
)paren
(brace
multiline_comment|/* For an 80486 FPU, the result is undefined. */
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
op_ge
op_minus
l_int|64
)paren
(brace
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_POS
)paren
(brace
multiline_comment|/* poly_2xm1(x) requires 0 &lt; x &lt; 1. */
id|poly_2xm1
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|rv
)paren
suffix:semicolon
id|reg_mul
c_func
(paren
op_amp
id|rv
comma
id|FPU_st0_ptr
comma
id|FPU_st0_ptr
comma
id|FULL_PRECISION
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* poly_2xm1(x) doesn&squot;t handle negative numbers yet. */
multiline_comment|/* So we compute z=poly_2xm1(-x), and the answer is&n;&t;&t;   then -z/(1+z) */
id|FPU_st0_ptr-&gt;sign
op_assign
id|SIGN_POS
suffix:semicolon
id|poly_2xm1
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|rv
)paren
suffix:semicolon
id|reg_mul
c_func
(paren
op_amp
id|rv
comma
id|FPU_st0_ptr
comma
op_amp
id|rv
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|reg_add
c_func
(paren
op_amp
id|rv
comma
op_amp
id|CONST_1
comma
op_amp
id|tmp
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|reg_div
c_func
(paren
op_amp
id|rv
comma
op_amp
id|tmp
comma
id|FPU_st0_ptr
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|SIGN_NEG
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
multiline_comment|/* For very small arguments, this is accurate enough. */
id|reg_mul
c_func
(paren
op_amp
id|CONST_LN2
comma
id|FPU_st0_ptr
comma
id|FPU_st0_ptr
comma
id|FULL_PRECISION
)paren
suffix:semicolon
)brace
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_case
id|TW_Zero
suffix:colon
r_return
suffix:semicolon
r_case
id|TW_Infinity
suffix:colon
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_NEG
)paren
(brace
multiline_comment|/* -infinity gives -1 (p16-10) */
id|reg_move
c_func
(paren
op_amp
id|CONST_1
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|SIGN_NEG
suffix:semicolon
)brace
r_return
suffix:semicolon
r_default
suffix:colon
id|single_arg_error
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|fptan
r_static
r_void
id|fptan
c_func
(paren
r_void
)paren
(brace
id|FPU_REG
op_star
id|st_new_ptr
suffix:semicolon
r_int
id|q
suffix:semicolon
r_char
id|arg_sign
op_assign
id|FPU_st0_ptr-&gt;sign
suffix:semicolon
multiline_comment|/* Stack underflow has higher priority */
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
(brace
id|stack_underflow
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Puts a QNaN in st(0) */
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
id|st_new_ptr
op_assign
op_amp
id|st
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|stack_underflow
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Puts a QNaN in the new st(0) */
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|STACK_OVERFLOW
)paren
(brace
id|stack_overflow
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|FPU_st0_tag
)paren
(brace
r_case
id|TW_Valid
suffix:colon
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
OG
id|EXP_BIAS
op_minus
l_int|40
)paren
(brace
id|FPU_st0_ptr-&gt;sign
op_assign
id|SIGN_POS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q
op_assign
id|trig_arg
c_func
(paren
id|FPU_st0_ptr
comma
id|FPTAN
)paren
)paren
op_ne
op_minus
l_int|1
)paren
(brace
id|reg_div
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|CONST_PI2
comma
id|FPU_st0_ptr
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|poly_tan
c_func
(paren
id|FPU_st0_ptr
comma
id|FPU_st0_ptr
comma
id|q
op_amp
id|FCOS
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
(paren
id|q
op_amp
l_int|1
)paren
op_xor
id|arg_sign
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Operand is out of range */
id|FPU_st0_ptr-&gt;sign
op_assign
id|arg_sign
suffix:semicolon
multiline_comment|/* restore st(0) */
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* For a small arg, the result == the argument */
multiline_comment|/* Underflow may happen */
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
(brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
multiline_comment|/* A denormal result has been produced.&n;&t;&t; Precision must have been lost, this is always&n;&t;&t; an underflow. */
r_if
c_cond
(paren
id|arith_underflow
c_func
(paren
id|FPU_st0_ptr
)paren
)paren
r_return
suffix:semicolon
)brace
r_else
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Must be up. */
)brace
id|push
c_func
(paren
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_1
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TW_Infinity
suffix:colon
multiline_comment|/* The 80486 treats infinity as an invalid operand */
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
id|st_new_ptr
op_assign
op_amp
id|st
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
r_case
id|TW_Zero
suffix:colon
id|push
c_func
(paren
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_1
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|single_arg_2_error
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|fxtract
r_static
r_void
id|fxtract
c_func
(paren
r_void
)paren
(brace
id|FPU_REG
op_star
id|st_new_ptr
suffix:semicolon
r_register
id|FPU_REG
op_star
id|st1_ptr
op_assign
id|FPU_st0_ptr
suffix:semicolon
multiline_comment|/* anticipate */
r_if
c_cond
(paren
id|STACK_OVERFLOW
)paren
(brace
id|stack_overflow
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|FPU_st0_tag
op_xor
id|TW_Valid
)paren
)paren
(brace
r_int
id|e
suffix:semicolon
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
id|push
c_func
(paren
)paren
suffix:semicolon
id|reg_move
c_func
(paren
id|st1_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;exp
op_assign
id|EXP_BIAS
suffix:semicolon
id|e
op_assign
id|st1_ptr-&gt;exp
op_minus
id|EXP_BIAS
suffix:semicolon
id|convert_l2reg
c_func
(paren
op_amp
id|e
comma
id|st1_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
r_char
id|sign
op_assign
id|FPU_st0_ptr-&gt;sign
suffix:semicolon
r_if
c_cond
(paren
id|divide_by_zero
c_func
(paren
id|SIGN_NEG
comma
id|FPU_st0_ptr
)paren
)paren
r_return
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_char
id|sign
op_assign
id|FPU_st0_ptr-&gt;sign
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|SIGN_POS
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_INF
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
(brace
r_if
c_cond
(paren
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|FPU_st0_ptr
comma
id|FPU_st0_ptr
)paren
)paren
r_return
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|reg_move
c_func
(paren
id|st1_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
(brace
multiline_comment|/* Is this the correct behaviour? */
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
id|stack_underflow
c_func
(paren
)paren
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|stack_underflow
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x119
)paren
suffix:semicolon
macro_line|#endif PARANOID
)brace
DECL|function|fdecstp
r_static
r_void
id|fdecstp
c_func
(paren
r_void
)paren
(brace
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
id|top
op_decrement
suffix:semicolon
multiline_comment|/* FPU_st0_ptr will be fixed in math_emulate() before the next instr */
)brace
DECL|function|fincstp
r_static
r_void
id|fincstp
c_func
(paren
r_void
)paren
(brace
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
id|top
op_increment
suffix:semicolon
multiline_comment|/* FPU_st0_ptr will be fixed in math_emulate() before the next instr */
)brace
DECL|function|fsqrt_
r_static
r_void
id|fsqrt_
c_func
(paren
r_void
)paren
(brace
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|FPU_st0_tag
op_xor
id|TW_Valid
)paren
)paren
(brace
r_int
id|expon
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_NEG
)paren
(brace
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
multiline_comment|/* sqrt(negative) is invalid */
r_return
suffix:semicolon
)brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
id|expon
op_assign
id|FPU_st0_ptr-&gt;exp
op_minus
id|EXP_BIAS
suffix:semicolon
id|FPU_st0_ptr-&gt;exp
op_assign
id|EXP_BIAS
op_plus
(paren
id|expon
op_amp
l_int|1
)paren
suffix:semicolon
multiline_comment|/* make st(0) in  [1.0 .. 4.0) */
id|wm_sqrt
c_func
(paren
id|FPU_st0_ptr
comma
id|control_word
)paren
suffix:semicolon
multiline_comment|/* Do the computation */
id|FPU_st0_ptr-&gt;exp
op_add_assign
id|expon
op_rshift
l_int|1
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|SIGN_POS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
r_return
suffix:semicolon
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_NEG
)paren
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
multiline_comment|/* sqrt(-Infinity) is invalid */
r_return
suffix:semicolon
)brace
r_else
(brace
id|single_arg_error
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
DECL|function|frndint_
r_static
r_void
id|frndint_
c_func
(paren
r_void
)paren
(brace
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|FPU_st0_tag
op_xor
id|TW_Valid
)paren
)paren
(brace
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
OG
id|EXP_BIAS
op_plus
l_int|63
)paren
r_return
suffix:semicolon
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
multiline_comment|/* Fortunately, this can&squot;t overflow to 2^64 */
r_if
c_cond
(paren
(paren
id|flags
op_assign
id|round_to_int
c_func
(paren
id|FPU_st0_ptr
)paren
)paren
)paren
id|set_precision_flag
c_func
(paren
id|flags
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;exp
op_assign
id|EXP_BIAS
op_plus
l_int|63
suffix:semicolon
id|normalize
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
op_logical_or
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
)paren
r_return
suffix:semicolon
r_else
id|single_arg_error
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fsin
r_static
r_void
id|fsin
c_func
(paren
r_void
)paren
(brace
r_char
id|arg_sign
op_assign
id|FPU_st0_ptr-&gt;sign
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Valid
)paren
(brace
id|FPU_REG
id|rv
suffix:semicolon
r_int
id|q
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
OG
id|EXP_BIAS
op_minus
l_int|40
)paren
(brace
id|FPU_st0_ptr-&gt;sign
op_assign
id|SIGN_POS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q
op_assign
id|trig_arg
c_func
(paren
id|FPU_st0_ptr
comma
l_int|0
)paren
)paren
op_ne
op_minus
l_int|1
)paren
(brace
id|reg_div
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|CONST_PI2
comma
id|FPU_st0_ptr
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|poly_sine
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|rv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
op_amp
l_int|2
)paren
id|rv.sign
op_xor_assign
id|SIGN_POS
op_xor
id|SIGN_NEG
suffix:semicolon
id|rv.sign
op_xor_assign
id|arg_sign
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|rv
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
multiline_comment|/* We do not really know if up or down */
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Operand is out of range */
id|FPU_st0_ptr-&gt;sign
op_assign
id|arg_sign
suffix:semicolon
multiline_comment|/* restore st(0) */
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* For a small arg, the result == the argument */
multiline_comment|/* Underflow may happen */
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
(brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
multiline_comment|/* A denormal result has been produced.&n;&t;&t; Precision must have been lost, this is always&n;&t;&t; an underflow. */
id|arith_underflow
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Must be up. */
)brace
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
multiline_comment|/* The 80486 treats infinity as an invalid operand */
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
id|single_arg_error
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|f_cos
r_static
r_int
id|f_cos
c_func
(paren
id|FPU_REG
op_star
id|arg
)paren
(brace
r_char
id|arg_sign
op_assign
id|arg-&gt;sign
suffix:semicolon
r_if
c_cond
(paren
id|arg-&gt;tag
op_eq
id|TW_Valid
)paren
(brace
id|FPU_REG
id|rv
suffix:semicolon
r_int
id|q
suffix:semicolon
r_if
c_cond
(paren
id|arg-&gt;exp
OG
id|EXP_BIAS
op_minus
l_int|40
)paren
(brace
id|arg-&gt;sign
op_assign
id|SIGN_POS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q
op_assign
id|trig_arg
c_func
(paren
id|arg
comma
id|FCOS
)paren
)paren
op_ne
op_minus
l_int|1
)paren
(brace
id|reg_div
c_func
(paren
id|arg
comma
op_amp
id|CONST_PI2
comma
id|arg
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|poly_sine
c_func
(paren
id|arg
comma
op_amp
id|rv
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q
op_plus
l_int|1
)paren
op_amp
l_int|2
)paren
id|rv.sign
op_xor_assign
id|SIGN_POS
op_xor
id|SIGN_NEG
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|rv
comma
id|arg
)paren
suffix:semicolon
multiline_comment|/* We do not really know if up or down */
id|set_precision_flag_down
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Operand is out of range */
id|arg-&gt;sign
op_assign
id|arg_sign
suffix:semicolon
multiline_comment|/* restore st(0) */
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|arg-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
macro_line|#endif DENORM_OPERAND
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_1
comma
id|arg
)paren
suffix:semicolon
macro_line|#ifdef PECULIAR_486
id|set_precision_flag_down
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* 80486 appears to do this. */
macro_line|#else
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Must be up. */
macro_line|#endif PECULIAR_486
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|arg-&gt;tag
op_eq
id|TW_Zero
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_1
comma
id|arg
)paren
suffix:semicolon
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
multiline_comment|/* The 80486 treats infinity as an invalid operand */
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|single_arg_error
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* requires arg == &amp;st(0) */
r_return
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|fcos
r_static
r_void
id|fcos
c_func
(paren
r_void
)paren
(brace
id|f_cos
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
)brace
DECL|function|fsincos
r_static
r_void
id|fsincos
c_func
(paren
r_void
)paren
(brace
id|FPU_REG
op_star
id|st_new_ptr
suffix:semicolon
id|FPU_REG
id|arg
suffix:semicolon
multiline_comment|/* Stack underflow has higher priority */
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
(brace
id|stack_underflow
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Puts a QNaN in st(0) */
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
id|st_new_ptr
op_assign
op_amp
id|st
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|stack_underflow
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Puts a QNaN in the new st(0) */
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|STACK_OVERFLOW
)paren
(brace
id|stack_overflow
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
(brace
id|single_arg_2_error
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
multiline_comment|/* The 80486 treats infinity as an invalid operand */
r_if
c_cond
(paren
op_logical_neg
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
)paren
(brace
multiline_comment|/* unmasked response */
id|push
c_func
(paren
)paren
suffix:semicolon
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f_cos
c_func
(paren
op_amp
id|arg
)paren
)paren
(brace
id|fsin
c_func
(paren
)paren
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|arg
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*---------------------------------------------------------------------------*/
multiline_comment|/* The following all require two arguments: st(0) and st(1) */
multiline_comment|/* A lean, mean kernel for the fprem instructions. This relies upon&n;   the division and rounding to an integer in do_fprem giving an&n;   exact result. Because of this, rem_kernel() needs to deal only with&n;   the least significant 64 bits, the more significant bits of the&n;   result must be zero.&n; */
DECL|function|rem_kernel
r_static
r_void
id|rem_kernel
c_func
(paren
r_int
r_int
r_int
id|st0
comma
r_int
r_int
r_int
op_star
id|y
comma
r_int
r_int
r_int
id|st1
comma
r_int
r_int
r_int
id|q
comma
r_int
id|n
)paren
(brace
r_int
r_int
r_int
id|x
suffix:semicolon
id|x
op_assign
id|st0
op_lshift
id|n
suffix:semicolon
multiline_comment|/* Do the required multiplication and subtraction in the one operation */
id|asm
r_volatile
(paren
"&quot;"
id|movl
op_mod
l_int|2
comma
op_mod
op_mod
id|eax
suffix:semicolon
id|mull
op_mod
l_int|4
suffix:semicolon
id|subl
op_mod
op_mod
id|eax
comma
op_mod
l_int|0
suffix:semicolon
id|sbbl
op_mod
op_mod
id|edx
comma
op_mod
l_int|1
suffix:semicolon
id|movl
op_mod
l_int|3
comma
op_mod
op_mod
id|eax
suffix:semicolon
id|mull
op_mod
l_int|4
suffix:semicolon
id|subl
op_mod
op_mod
id|eax
comma
op_mod
l_int|1
suffix:semicolon
id|movl
op_mod
l_int|2
comma
op_mod
op_mod
id|eax
suffix:semicolon
id|mull
op_mod
l_int|5
suffix:semicolon
id|subl
op_mod
op_mod
id|eax
comma
op_mod
l_int|1
suffix:semicolon
"&quot;"
suffix:colon
l_string|&quot;=m&quot;
(paren
id|x
)paren
comma
l_string|&quot;=m&quot;
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|x
)paren
(braket
l_int|1
)braket
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
id|st1
)paren
comma
l_string|&quot;m&quot;
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|st1
)paren
(braket
l_int|1
)braket
)paren
comma
l_string|&quot;m&quot;
(paren
id|q
)paren
comma
l_string|&quot;m&quot;
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|q
)paren
(braket
l_int|1
)braket
)paren
suffix:colon
l_string|&quot;%ax&quot;
comma
l_string|&quot;%dx&quot;
)paren
suffix:semicolon
op_star
id|y
op_assign
id|x
suffix:semicolon
)brace
multiline_comment|/* Remainder of st(0) / st(1) */
multiline_comment|/* This routine produces exact results, i.e. there is never any&n;   rounding or truncation, etc of the result. */
DECL|function|do_fprem
r_static
r_void
id|do_fprem
c_func
(paren
r_int
id|round
)paren
(brace
id|FPU_REG
op_star
id|st1_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_char
id|st1_tag
op_assign
id|st1_ptr-&gt;tag
suffix:semicolon
r_char
id|sign
op_assign
id|FPU_st0_ptr-&gt;sign
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|FPU_st0_tag
op_xor
id|TW_Valid
)paren
op_or
(paren
id|st1_tag
op_xor
id|TW_Valid
)paren
)paren
)paren
(brace
id|FPU_REG
id|tmp
suffix:semicolon
r_int
id|old_cw
op_assign
id|control_word
suffix:semicolon
r_int
id|expdif
op_assign
id|FPU_st0_ptr-&gt;exp
op_minus
id|st1_ptr-&gt;exp
suffix:semicolon
r_int
r_int
id|q
suffix:semicolon
r_int
r_int
id|saved_status
suffix:semicolon
r_int
id|cc
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_or
(paren
id|st1_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
multiline_comment|/* We want the status following the denorm tests, but don&squot;t want&n;&t; the status changed by the arithmetic operations. */
id|saved_status
op_assign
id|partial_status
suffix:semicolon
id|control_word
op_and_assign
op_complement
id|CW_RC
suffix:semicolon
id|control_word
op_or_assign
id|RC_CHOP
suffix:semicolon
r_if
c_cond
(paren
id|expdif
OL
l_int|64
)paren
(brace
multiline_comment|/* This should be the most common case */
r_if
c_cond
(paren
id|expdif
OG
op_minus
l_int|2
)paren
(brace
id|reg_div
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
op_amp
id|tmp
comma
id|PR_64_BITS
op_or
id|RC_CHOP
op_or
l_int|0x3f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp.exp
op_ge
id|EXP_BIAS
)paren
(brace
id|round_to_int
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* Fortunately, this can&squot;t overflow&n;&t;&t;&t;&t;&t;  to 2^64 */
id|q
op_assign
id|significand
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|rem_kernel
c_func
(paren
id|significand
c_func
(paren
id|FPU_st0_ptr
)paren
comma
op_amp
id|significand
c_func
(paren
op_amp
id|tmp
)paren
comma
id|significand
c_func
(paren
id|st1_ptr
)paren
comma
id|q
comma
id|expdif
)paren
suffix:semicolon
id|tmp.exp
op_assign
id|st1_ptr-&gt;exp
suffix:semicolon
)brace
r_else
(brace
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|q
op_assign
l_int|0
suffix:semicolon
)brace
id|tmp.sign
op_assign
id|sign
suffix:semicolon
r_if
c_cond
(paren
(paren
id|round
op_eq
id|RC_RND
)paren
op_logical_and
(paren
id|tmp.sigh
op_amp
l_int|0xc0000000
)paren
)paren
(brace
multiline_comment|/* We may need to subtract st(1) once more,&n;&t;&t;     to get a result &lt;= 1/2 of st(1). */
r_int
r_int
r_int
id|x
suffix:semicolon
id|expdif
op_assign
id|st1_ptr-&gt;exp
op_minus
id|tmp.exp
suffix:semicolon
r_if
c_cond
(paren
id|expdif
op_le
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|expdif
op_eq
l_int|0
)paren
id|x
op_assign
id|significand
c_func
(paren
id|st1_ptr
)paren
op_minus
id|significand
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
r_else
multiline_comment|/* expdif is 1 */
id|x
op_assign
(paren
id|significand
c_func
(paren
id|st1_ptr
)paren
op_lshift
l_int|1
)paren
op_minus
id|significand
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
OL
id|significand
c_func
(paren
op_amp
id|tmp
)paren
)paren
op_logical_or
multiline_comment|/* or equi-distant (from 0 &amp; st(1)) and q is odd */
(paren
(paren
id|x
op_eq
id|significand
c_func
(paren
op_amp
id|tmp
)paren
)paren
op_logical_and
(paren
id|q
op_amp
l_int|1
)paren
)paren
)paren
(brace
id|tmp.sign
op_xor_assign
(paren
id|SIGN_POS
op_xor
id|SIGN_NEG
)paren
suffix:semicolon
id|significand
c_func
(paren
op_amp
id|tmp
)paren
op_assign
id|x
suffix:semicolon
id|q
op_increment
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|q
op_amp
l_int|4
)paren
id|cc
op_or_assign
id|SW_C0
suffix:semicolon
r_if
c_cond
(paren
id|q
op_amp
l_int|2
)paren
id|cc
op_or_assign
id|SW_C3
suffix:semicolon
r_if
c_cond
(paren
id|q
op_amp
l_int|1
)paren
id|cc
op_or_assign
id|SW_C1
suffix:semicolon
)brace
r_else
(brace
id|control_word
op_assign
id|old_cw
suffix:semicolon
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* There is a large exponent difference ( &gt;= 64 ) */
multiline_comment|/* To make much sense, the code in this section should&n;&t;     be done at high precision. */
r_int
id|exp_1
suffix:semicolon
multiline_comment|/* prevent overflow here */
multiline_comment|/* N is &squot;a number between 32 and 63&squot; (p26-113) */
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|tmp.exp
op_assign
id|EXP_BIAS
op_plus
l_int|56
suffix:semicolon
id|exp_1
op_assign
id|st1_ptr-&gt;exp
suffix:semicolon
id|st1_ptr-&gt;exp
op_assign
id|EXP_BIAS
suffix:semicolon
id|expdif
op_sub_assign
l_int|56
suffix:semicolon
id|reg_div
c_func
(paren
op_amp
id|tmp
comma
id|st1_ptr
comma
op_amp
id|tmp
comma
id|PR_64_BITS
op_or
id|RC_CHOP
op_or
l_int|0x3f
)paren
suffix:semicolon
id|st1_ptr-&gt;exp
op_assign
id|exp_1
suffix:semicolon
id|round_to_int
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* Fortunately, this can&squot;t overflow to 2^64 */
id|rem_kernel
c_func
(paren
id|significand
c_func
(paren
id|FPU_st0_ptr
)paren
comma
op_amp
id|significand
c_func
(paren
op_amp
id|tmp
)paren
comma
id|significand
c_func
(paren
id|st1_ptr
)paren
comma
id|significand
c_func
(paren
op_amp
id|tmp
)paren
comma
id|tmp.exp
op_minus
id|EXP_BIAS
)paren
suffix:semicolon
id|tmp.exp
op_assign
id|exp_1
op_plus
id|expdif
suffix:semicolon
id|tmp.sign
op_assign
id|sign
suffix:semicolon
multiline_comment|/* It is possible for the operation to be complete here.&n;&t;     What does the IEEE standard say? The Intel 80486 manual&n;&t;     implies that the operation will never be completed at this&n;&t;     point, and the behaviour of a real 80486 confirms this.&n;&t;   */
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp.sigh
op_or
id|tmp.sigl
)paren
)paren
(brace
multiline_comment|/* The result is zero */
id|control_word
op_assign
id|old_cw
suffix:semicolon
id|partial_status
op_assign
id|saved_status
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
macro_line|#ifdef PECULIAR_486
id|setcc
c_func
(paren
id|SW_C2
)paren
suffix:semicolon
macro_line|#else
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif PECULIAR_486
r_return
suffix:semicolon
)brace
id|cc
op_assign
id|SW_C2
suffix:semicolon
)brace
id|control_word
op_assign
id|old_cw
suffix:semicolon
id|partial_status
op_assign
id|saved_status
suffix:semicolon
id|normalize_nuo
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|tmp
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|setcc
c_func
(paren
id|cc
)paren
suffix:semicolon
multiline_comment|/* The only condition to be looked for is underflow,&n;&t; and it can occur here only if underflow is unmasked. */
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|FPU_st0_ptr-&gt;tag
op_ne
id|TW_Zero
)paren
op_logical_and
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Underflow
)paren
)paren
id|arith_underflow
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
op_or
(paren
id|st1_tag
op_eq
id|TW_Empty
)paren
)paren
(brace
id|stack_underflow
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Valid
)paren
(brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|st1_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Zero
)paren
(brace
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* fprem(?,0) always invalid */
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
(brace
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Valid
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Zero
)paren
(brace
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
multiline_comment|/* fprem(Valid,Zero) is invalid */
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_ne
id|TW_NaN
)paren
(brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
(brace
multiline_comment|/* fprem(Valid,Infinity) is o.k. */
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_ne
id|TW_NaN
)paren
(brace
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
multiline_comment|/* fprem(Infinity,?) is invalid */
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* One of the registers must contain a NaN is we got here. */
macro_line|#ifdef PARANOID
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_ne
id|TW_NaN
)paren
op_logical_and
(paren
id|st1_tag
op_ne
id|TW_NaN
)paren
)paren
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x118
)paren
suffix:semicolon
macro_line|#endif PARANOID
id|real_2op_NaN
c_func
(paren
id|st1_ptr
comma
id|FPU_st0_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
)brace
multiline_comment|/* ST(1) &lt;- ST(1) * log ST;  pop ST */
DECL|function|fyl2x
r_static
r_void
id|fyl2x
c_func
(paren
r_void
)paren
(brace
id|FPU_REG
op_star
id|st1_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_char
id|st1_tag
op_assign
id|st1_ptr-&gt;tag
suffix:semicolon
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|FPU_st0_tag
op_xor
id|TW_Valid
)paren
op_or
(paren
id|st1_tag
op_xor
id|TW_Valid
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_POS
)paren
(brace
r_int
id|saved_control
comma
id|saved_status
suffix:semicolon
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_or
(paren
id|st1_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
multiline_comment|/* We use the general purpose arithmetic,&n;&t;     so we need to save these. */
id|saved_status
op_assign
id|partial_status
suffix:semicolon
id|saved_control
op_assign
id|control_word
suffix:semicolon
id|control_word
op_assign
id|FULL_PRECISION
suffix:semicolon
id|poly_l2
c_func
(paren
id|FPU_st0_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
multiline_comment|/* Enough of the basic arithmetic is done now */
id|control_word
op_assign
id|saved_control
suffix:semicolon
id|partial_status
op_assign
id|saved_status
suffix:semicolon
multiline_comment|/* Let the multiply set the flags */
id|reg_mul
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|st1_ptr
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
id|FPU_st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* negative */
r_if
c_cond
(paren
op_logical_neg
id|arith_invalid
c_func
(paren
id|st1_ptr
)paren
)paren
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_Empty
)paren
)paren
(brace
id|stack_underflow_pop
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|st1_ptr
)paren
)paren
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_le
id|TW_Zero
)paren
op_logical_and
(paren
id|st1_tag
op_le
id|TW_Zero
)paren
)paren
(brace
multiline_comment|/* one of the args is zero, the other valid, or both zero */
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Zero
)paren
(brace
multiline_comment|/* Both args zero is invalid */
r_if
c_cond
(paren
op_logical_neg
id|arith_invalid
c_func
(paren
id|st1_ptr
)paren
)paren
id|pop
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef PECULIAR_486
multiline_comment|/* This case is not specifically covered in the manual,&n;&t;     but divide-by-zero would seem to be the best response.&n;&t;     However, a real 80486 does it this way... */
r_else
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;tag
op_eq
id|TW_Infinity
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_INF
comma
id|st1_ptr
)paren
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif PECULIAR_486
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|divide_by_zero
c_func
(paren
id|st1_ptr-&gt;sign
op_xor
id|SIGN_NEG
op_xor
id|SIGN_POS
comma
id|st1_ptr
)paren
)paren
id|pop
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* st(1) contains zero, st(0) valid &lt;&gt; 0 */
multiline_comment|/* Zero is the valid answer */
r_char
id|sign
op_assign
id|st1_ptr-&gt;sign
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_NEG
)paren
(brace
multiline_comment|/* log(negative) */
r_if
c_cond
(paren
op_logical_neg
id|arith_invalid
c_func
(paren
id|st1_ptr
)paren
)paren
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
OL
id|EXP_BIAS
)paren
id|sign
op_xor_assign
id|SIGN_NEG
op_xor
id|SIGN_POS
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
id|FPU_st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* One or both arg must be an infinity */
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_NEG
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_Zero
)paren
)paren
(brace
multiline_comment|/* log(-infinity) or 0*log(infinity) */
r_if
c_cond
(paren
op_logical_neg
id|arith_invalid
c_func
(paren
id|st1_ptr
)paren
)paren
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
r_char
id|sign
op_assign
id|st1_ptr-&gt;sign
suffix:semicolon
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|st1_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
id|pop
c_func
(paren
)paren
suffix:semicolon
id|FPU_st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_INF
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* st(1) must be infinity here */
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Valid
)paren
op_logical_and
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_POS
)paren
)paren
(brace
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
op_ge
id|EXP_BIAS
)paren
(brace
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_eq
id|EXP_BIAS
)paren
op_logical_and
(paren
id|FPU_st0_ptr-&gt;sigh
op_eq
l_int|0x80000000
)paren
op_logical_and
(paren
id|FPU_st0_ptr-&gt;sigl
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* st(0) holds 1.0 */
multiline_comment|/* infinity*log(1) */
r_if
c_cond
(paren
op_logical_neg
id|arith_invalid
c_func
(paren
id|st1_ptr
)paren
)paren
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* st(0) is positive and &gt; 1.0 */
id|pop
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* st(0) is positive and &lt; 1.0 */
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
id|st1_ptr-&gt;sign
op_xor_assign
id|SIGN_NEG
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* st(0) must be zero or negative */
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;tag
op_eq
id|TW_Zero
)paren
(brace
multiline_comment|/* This should be invalid, but a real 80486 is happy with it. */
macro_line|#ifndef PECULIAR_486
r_if
c_cond
(paren
op_logical_neg
id|divide_by_zero
c_func
(paren
id|st1_ptr-&gt;sign
comma
id|st1_ptr
)paren
)paren
macro_line|#endif PECULIAR_486
(brace
id|st1_ptr-&gt;sign
op_xor_assign
id|SIGN_NEG
op_xor
id|SIGN_POS
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* log(negative) */
r_if
c_cond
(paren
op_logical_neg
id|arith_invalid
c_func
(paren
id|st1_ptr
)paren
)paren
id|pop
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
)brace
DECL|function|fpatan
r_static
r_void
id|fpatan
c_func
(paren
r_void
)paren
(brace
id|FPU_REG
op_star
id|st1_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_char
id|st1_tag
op_assign
id|st1_ptr-&gt;tag
suffix:semicolon
r_char
id|st1_sign
op_assign
id|st1_ptr-&gt;sign
comma
id|st0_sign
op_assign
id|FPU_st0_ptr-&gt;sign
suffix:semicolon
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|FPU_st0_tag
op_xor
id|TW_Valid
)paren
op_or
(paren
id|st1_tag
op_xor
id|TW_Valid
)paren
)paren
)paren
(brace
r_int
id|saved_control
comma
id|saved_status
suffix:semicolon
id|FPU_REG
id|sum
suffix:semicolon
r_char
id|inverted
suffix:semicolon
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_or
(paren
id|st1_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
multiline_comment|/* We use the general purpose arithmetic so we need to save these. */
id|saved_status
op_assign
id|partial_status
suffix:semicolon
id|saved_control
op_assign
id|control_word
suffix:semicolon
id|control_word
op_assign
id|FULL_PRECISION
suffix:semicolon
id|st1_ptr-&gt;sign
op_assign
id|FPU_st0_ptr-&gt;sign
op_assign
id|SIGN_POS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|compare
c_func
(paren
id|st1_ptr
)paren
op_amp
op_complement
id|COMP_Denormal
)paren
op_eq
id|COMP_A_lt_B
)paren
(brace
id|inverted
op_assign
l_int|1
suffix:semicolon
id|reg_div
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
op_amp
id|sum
comma
id|FULL_PRECISION
)paren
suffix:semicolon
)brace
r_else
(brace
id|inverted
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st0_sign
op_eq
l_int|0
)paren
op_logical_and
(paren
id|st1_ptr-&gt;exp
op_minus
id|FPU_st0_ptr-&gt;exp
OL
op_minus
l_int|64
)paren
)paren
(brace
id|control_word
op_assign
id|saved_control
suffix:semicolon
id|partial_status
op_assign
id|saved_status
suffix:semicolon
id|reg_div
c_func
(paren
id|st1_ptr
comma
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|control_word
op_or
id|PR_64_BITS
)paren
suffix:semicolon
id|st1_ptr-&gt;sign
op_assign
id|st1_sign
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
id|set_precision_flag_down
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|reg_div
c_func
(paren
id|st1_ptr
comma
id|FPU_st0_ptr
comma
op_amp
id|sum
comma
id|FULL_PRECISION
)paren
suffix:semicolon
)brace
id|poly_atan
c_func
(paren
op_amp
id|sum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inverted
)paren
(brace
id|reg_sub
c_func
(paren
op_amp
id|CONST_PI2
comma
op_amp
id|sum
comma
op_amp
id|sum
comma
id|FULL_PRECISION
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st0_sign
)paren
(brace
id|reg_sub
c_func
(paren
op_amp
id|CONST_PI
comma
op_amp
id|sum
comma
op_amp
id|sum
comma
id|FULL_PRECISION
)paren
suffix:semicolon
)brace
id|sum.sign
op_assign
id|st1_sign
suffix:semicolon
multiline_comment|/* All of the basic arithmetic is done now */
id|control_word
op_assign
id|saved_control
suffix:semicolon
id|partial_status
op_assign
id|saved_status
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|sum
comma
id|st1_ptr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_Empty
)paren
)paren
(brace
id|stack_underflow_pop
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|st1_ptr
)paren
)paren
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
)paren
(brace
r_char
id|sign
op_assign
id|st1_ptr-&gt;sign
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_POS
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_PI4
comma
id|st1_ptr
)paren
suffix:semicolon
)brace
r_else
id|reg_add
c_func
(paren
op_amp
id|CONST_PI4
comma
op_amp
id|CONST_PI2
comma
id|st1_ptr
comma
id|FULL_PRECISION
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
id|st1_tag
op_ne
id|TW_Zero
)paren
(brace
r_if
c_cond
(paren
(paren
id|st1_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
)brace
macro_line|#endif DENORM_OPERAND
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_POS
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|st1_ptr
)paren
suffix:semicolon
id|st1_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
multiline_comment|/* An 80486 preserves the sign */
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
id|reg_move
c_func
(paren
op_amp
id|CONST_PI
comma
id|st1_ptr
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* st(1) is infinity, st(0) not infinity */
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
id|FPU_st0_tag
op_ne
id|TW_Zero
)paren
(brace
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
)brace
macro_line|#endif DENORM_OPERAND
id|reg_move
c_func
(paren
op_amp
id|CONST_PI2
comma
id|st1_ptr
)paren
suffix:semicolon
)brace
id|st1_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Zero
)paren
(brace
multiline_comment|/* st(0) must be valid or zero */
r_char
id|sign
op_assign
id|st1_ptr-&gt;sign
suffix:semicolon
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
id|FPU_st0_tag
op_ne
id|TW_Zero
)paren
(brace
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
)brace
macro_line|#endif DENORM_OPERAND
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_POS
)paren
(brace
multiline_comment|/* An 80486 preserves the sign */
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
id|reg_move
c_func
(paren
op_amp
id|CONST_PI
comma
id|st1_ptr
)paren
suffix:semicolon
id|st1_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
multiline_comment|/* st(1) must be TW_Valid here */
r_char
id|sign
op_assign
id|st1_ptr-&gt;sign
suffix:semicolon
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|st1_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
id|reg_move
c_func
(paren
op_amp
id|CONST_PI2
comma
id|st1_ptr
)paren
suffix:semicolon
id|st1_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x125
)paren
suffix:semicolon
macro_line|#endif PARANOID
id|pop
c_func
(paren
)paren
suffix:semicolon
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We do not really know if up or down */
)brace
DECL|function|fprem
r_static
r_void
id|fprem
c_func
(paren
r_void
)paren
(brace
id|do_fprem
c_func
(paren
id|RC_CHOP
)paren
suffix:semicolon
)brace
DECL|function|fprem1
r_static
r_void
id|fprem1
c_func
(paren
r_void
)paren
(brace
id|do_fprem
c_func
(paren
id|RC_RND
)paren
suffix:semicolon
)brace
DECL|function|fyl2xp1
r_static
r_void
id|fyl2xp1
c_func
(paren
r_void
)paren
(brace
id|FPU_REG
op_star
id|st1_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_char
id|st1_tag
op_assign
id|st1_ptr-&gt;tag
suffix:semicolon
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|FPU_st0_tag
op_xor
id|TW_Valid
)paren
op_or
(paren
id|st1_tag
op_xor
id|TW_Valid
)paren
)paren
)paren
(brace
r_int
id|saved_control
comma
id|saved_status
suffix:semicolon
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_or
(paren
id|st1_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
)paren
op_logical_and
id|denormal_operand
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
multiline_comment|/* We use the general purpose arithmetic so we need to save these. */
id|saved_status
op_assign
id|partial_status
suffix:semicolon
id|saved_control
op_assign
id|control_word
suffix:semicolon
id|control_word
op_assign
id|FULL_PRECISION
suffix:semicolon
r_if
c_cond
(paren
id|poly_l2p1
c_func
(paren
id|FPU_st0_ptr
comma
id|FPU_st0_ptr
)paren
)paren
(brace
macro_line|#ifdef PECULIAR_486   /* Stupid 80486 doesn&squot;t worry about log(negative). */
id|st1_ptr-&gt;sign
op_xor_assign
id|SIGN_POS
op_xor
id|SIGN_NEG
suffix:semicolon
id|control_word
op_assign
id|saved_control
suffix:semicolon
id|partial_status
op_assign
id|saved_status
suffix:semicolon
id|set_precision_flag_down
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
id|st1_ptr
)paren
)paren
multiline_comment|/* poly_l2p1() returned invalid */
r_return
suffix:semicolon
macro_line|#endif PECULIAR_486
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Enough of the basic arithmetic is done now */
id|control_word
op_assign
id|saved_control
suffix:semicolon
id|partial_status
op_assign
id|saved_status
suffix:semicolon
multiline_comment|/* Let the multiply set the flags */
id|reg_mul
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|st1_ptr
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
op_or
(paren
id|st1_tag
op_eq
id|TW_Empty
)paren
)paren
(brace
id|stack_underflow_pop
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_le
id|TW_Zero
)paren
(brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|st1_tag
op_eq
id|TW_Valid
)paren
op_logical_and
(paren
id|st1_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
id|FPU_st0_ptr-&gt;sign
op_xor_assign
id|st1_ptr-&gt;sign
suffix:semicolon
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
(brace
multiline_comment|/* Infinity*log(1) */
r_if
c_cond
(paren
op_logical_neg
id|arith_invalid
c_func
(paren
id|st1_ptr
)paren
)paren
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|st1_ptr
)paren
)paren
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x116
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif PARANOID
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Valid
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Zero
)paren
(brace
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_NEG
)paren
(brace
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
op_ge
id|EXP_BIAS
)paren
(brace
multiline_comment|/* st(0) holds &lt;= -1.0 */
macro_line|#ifdef PECULIAR_486   /* Stupid 80486 doesn&squot;t worry about log(negative). */
id|st1_ptr-&gt;sign
op_xor_assign
id|SIGN_POS
op_xor
id|SIGN_NEG
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
id|st1_ptr
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif PECULIAR_486
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
id|st1_ptr-&gt;sign
op_xor_assign
id|SIGN_POS
op_xor
id|SIGN_NEG
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_NEG
)paren
(brace
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_ge
id|EXP_BIAS
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|FPU_st0_ptr-&gt;sigh
op_eq
l_int|0x80000000
)paren
op_logical_and
(paren
id|FPU_st0_ptr-&gt;sigl
op_eq
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* st(0) holds &lt; -1.0 */
macro_line|#ifdef PECULIAR_486   /* Stupid 80486 doesn&squot;t worry about log(negative). */
id|st1_ptr-&gt;sign
op_xor_assign
id|SIGN_POS
op_xor
id|SIGN_NEG
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
id|st1_ptr
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif PECULIAR_486
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
id|st1_ptr-&gt;sign
op_xor_assign
id|SIGN_POS
op_xor
id|SIGN_NEG
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|st1_ptr
)paren
)paren
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|st1_ptr
)paren
)paren
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|st1_ptr
)paren
)paren
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_NEG
)paren
(brace
r_int
id|exponent
op_assign
id|st1_ptr-&gt;exp
suffix:semicolon
macro_line|#ifndef PECULIAR_486
multiline_comment|/* This should have higher priority than denormals, but... */
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
id|st1_ptr
)paren
)paren
multiline_comment|/* log(-infinity) */
r_return
suffix:semicolon
macro_line|#endif PECULIAR_486
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
id|st1_tag
op_ne
id|TW_Zero
)paren
(brace
r_if
c_cond
(paren
(paren
id|exponent
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
)brace
macro_line|#endif DENORM_OPERAND
macro_line|#ifdef PECULIAR_486
multiline_comment|/* Denormal operands actually get higher priority */
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
id|st1_ptr
)paren
)paren
multiline_comment|/* log(-infinity) */
r_return
suffix:semicolon
macro_line|#endif PECULIAR_486
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Zero
)paren
(brace
multiline_comment|/* log(infinity) */
r_if
c_cond
(paren
op_logical_neg
id|arith_invalid
c_func
(paren
id|st1_ptr
)paren
)paren
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* st(1) must be valid here. */
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|st1_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
multiline_comment|/* The Manual says that log(Infinity) is invalid, but a real&n;&t; 80486 sensibly says that it is o.k. */
(brace
r_char
id|sign
op_assign
id|st1_ptr-&gt;sign
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_INF
comma
id|st1_ptr
)paren
suffix:semicolon
id|st1_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
)brace
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x117
)paren
suffix:semicolon
)brace
macro_line|#endif PARANOID
)brace
DECL|function|fscale
r_static
r_void
id|fscale
c_func
(paren
r_void
)paren
(brace
id|FPU_REG
op_star
id|st1_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_char
id|st1_tag
op_assign
id|st1_ptr-&gt;tag
suffix:semicolon
r_int
id|old_cw
op_assign
id|control_word
suffix:semicolon
r_char
id|sign
op_assign
id|FPU_st0_ptr-&gt;sign
suffix:semicolon
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|FPU_st0_tag
op_xor
id|TW_Valid
)paren
op_or
(paren
id|st1_tag
op_xor
id|TW_Valid
)paren
)paren
)paren
(brace
r_int
id|scale
suffix:semicolon
id|FPU_REG
id|tmp
suffix:semicolon
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_or
(paren
id|st1_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
r_if
c_cond
(paren
id|st1_ptr-&gt;exp
OG
id|EXP_BIAS
op_plus
l_int|30
)paren
(brace
multiline_comment|/* 2^31 is far too large, would require 2^(2^30) or 2^(-2^30) */
r_char
id|sign
suffix:semicolon
r_if
c_cond
(paren
id|st1_ptr-&gt;sign
op_eq
id|SIGN_POS
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Overflow
)paren
suffix:semicolon
id|sign
op_assign
id|FPU_st0_ptr-&gt;sign
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_INF
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
)brace
r_else
(brace
id|EXCEPTION
c_func
(paren
id|EX_Underflow
)paren
suffix:semicolon
id|sign
op_assign
id|FPU_st0_ptr-&gt;sign
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|control_word
op_and_assign
op_complement
id|CW_RC
suffix:semicolon
id|control_word
op_or_assign
id|RC_CHOP
suffix:semicolon
id|reg_move
c_func
(paren
id|st1_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|round_to_int
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* This can never overflow here */
id|control_word
op_assign
id|old_cw
suffix:semicolon
id|scale
op_assign
id|st1_ptr-&gt;sign
ques
c_cond
op_minus
id|tmp.sigl
suffix:colon
id|tmp.sigl
suffix:semicolon
id|scale
op_add_assign
id|FPU_st0_ptr-&gt;exp
suffix:semicolon
id|FPU_st0_ptr-&gt;exp
op_assign
id|scale
suffix:semicolon
multiline_comment|/* Use round_reg() to properly detect under/overflow etc */
id|round_reg
c_func
(paren
id|FPU_st0_ptr
comma
l_int|0
comma
id|control_word
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Valid
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Zero
)paren
(brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
(brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
r_if
c_cond
(paren
id|st1_ptr-&gt;sign
op_eq
id|SIGN_POS
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_INF
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
)brace
r_else
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
(brace
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Valid
)paren
(brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|st1_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Zero
)paren
(brace
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|st1_ptr-&gt;sign
op_eq
id|SIGN_NEG
)paren
r_return
suffix:semicolon
r_else
(brace
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
multiline_comment|/* Zero scaled by +Infinity */
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
(brace
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Valid
)paren
(brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|st1_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif DENORM_OPERAND
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
op_logical_and
(paren
id|st1_ptr-&gt;sign
op_eq
id|SIGN_POS
)paren
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_Zero
)paren
)paren
r_return
suffix:semicolon
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
(brace
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
multiline_comment|/* Infinity scaled by -Infinity */
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
(brace
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_ne
id|TW_Empty
)paren
(brace
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#ifdef PARANOID
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_Empty
)paren
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x115
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* At least one of st(0), st(1) must be empty */
id|stack_underflow
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------------------------------------*/
DECL|variable|trig_table_a
r_static
id|FUNC
r_const
id|trig_table_a
(braket
)braket
op_assign
(brace
id|f2xm1
comma
id|fyl2x
comma
id|fptan
comma
id|fpatan
comma
id|fxtract
comma
id|fprem1
comma
id|fdecstp
comma
id|fincstp
)brace
suffix:semicolon
DECL|function|trig_a
r_void
id|trig_a
c_func
(paren
r_void
)paren
(brace
(paren
id|trig_table_a
(braket
id|FPU_rm
)braket
)paren
(paren
)paren
suffix:semicolon
)brace
DECL|variable|trig_table_b
r_static
id|FUNC
r_const
id|trig_table_b
(braket
)braket
op_assign
(brace
id|fprem
comma
id|fyl2xp1
comma
id|fsqrt_
comma
id|fsincos
comma
id|frndint_
comma
id|fscale
comma
id|fsin
comma
id|fcos
)brace
suffix:semicolon
DECL|function|trig_b
r_void
id|trig_b
c_func
(paren
r_void
)paren
(brace
(paren
id|trig_table_b
(braket
id|FPU_rm
)braket
)paren
(paren
)paren
suffix:semicolon
)brace
eof
