multiline_comment|/*&n; *&t;Macintosh Nubus Interface Code&n; *&n; *      Originally by Alan Cox&n; *&n; *      Mostly rewritten by David Huggins-Daines, C. Scott Ananian,&n; *      and others.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/nubus.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/hwtest.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;asm/mac_via.h&gt;
macro_line|#include &lt;asm/mac_oss.h&gt;
r_extern
r_void
id|via_nubus_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|oss_nubus_init
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Constants */
multiline_comment|/* This is, of course, the size in bytelanes, rather than the size in&n;   actual bytes */
DECL|macro|FORMAT_BLOCK_SIZE
mdefine_line|#define FORMAT_BLOCK_SIZE 20
DECL|macro|ROM_DIR_OFFSET
mdefine_line|#define ROM_DIR_OFFSET 0x24
DECL|macro|NUBUS_TEST_PATTERN
mdefine_line|#define NUBUS_TEST_PATTERN 0x5A932BC7
multiline_comment|/* Define this if you like to live dangerously - it is known not to&n;   work on pretty much every machine except the Quadra 630 and the LC&n;   III. */
DECL|macro|I_WANT_TO_PROBE_SLOT_ZERO
macro_line|#undef I_WANT_TO_PROBE_SLOT_ZERO
multiline_comment|/* This sometimes helps combat failure to boot */
DECL|macro|TRY_TO_DODGE_WSOD
macro_line|#undef TRY_TO_DODGE_WSOD
multiline_comment|/* Globals */
DECL|variable|nubus_devices
r_struct
id|nubus_dev
op_star
id|nubus_devices
suffix:semicolon
DECL|variable|nubus_boards
r_struct
id|nubus_board
op_star
id|nubus_boards
suffix:semicolon
multiline_comment|/* Meaning of &quot;bytelanes&quot;:&n;&n;   The card ROM may appear on any or all bytes of each long word in&n;   NuBus memory.  The low 4 bits of the &quot;map&quot; value found in the&n;   format block (at the top of the slot address space, as well as at&n;   the top of the MacOS ROM) tells us which bytelanes, i.e. which byte&n;   offsets within each longword, are valid.  Thus:&n;&n;   A map of 0x0f, as found in the MacOS ROM, means that all bytelanes&n;   are valid.&n;&n;   A map of 0xf0 means that no bytelanes are valid (We pray that we&n;   will never encounter this, but stranger things have happened)&n;&n;   A map of 0xe1 means that only the MSB of each long word is actually&n;   part of the card ROM.  (We hope to never encounter NuBus on a&n;   little-endian machine.  Again, stranger things have happened)&n;&n;   A map of 0x78 means that only the LSB of each long word is valid.&n;&n;   Etcetera, etcetera.  Hopefully this clears up some confusion over&n;   what the following code actually does.  */
DECL|function|not_useful
r_extern
r_inline
r_int
id|not_useful
c_func
(paren
r_void
op_star
id|p
comma
r_int
id|map
)paren
(brace
r_int
r_int
id|pv
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
id|pv
op_and_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|map
op_amp
(paren
l_int|1
op_lshift
id|pv
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|nubus_get_rom
r_static
r_int
r_int
id|nubus_get_rom
c_func
(paren
r_int
r_char
op_star
op_star
id|ptr
comma
r_int
id|len
comma
r_int
id|map
)paren
(brace
multiline_comment|/* This will hold the result */
r_int
r_int
id|v
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|p
op_assign
op_star
id|ptr
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
id|v
op_lshift_assign
l_int|8
suffix:semicolon
r_while
c_loop
(paren
id|not_useful
c_func
(paren
id|p
comma
id|map
)paren
)paren
(brace
id|p
op_increment
suffix:semicolon
)brace
id|v
op_or_assign
op_star
id|p
op_increment
suffix:semicolon
id|len
op_decrement
suffix:semicolon
)brace
op_star
id|ptr
op_assign
id|p
suffix:semicolon
r_return
id|v
suffix:semicolon
)brace
DECL|function|nubus_rewind
r_static
r_void
id|nubus_rewind
c_func
(paren
r_int
r_char
op_star
op_star
id|ptr
comma
r_int
id|len
comma
r_int
id|map
)paren
(brace
r_int
r_char
op_star
id|p
op_assign
op_star
id|ptr
suffix:semicolon
multiline_comment|/* Sanity check */
r_if
c_cond
(paren
id|len
OG
l_int|65536
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rewind of 0x%08x!&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|len
)paren
(brace
r_do
(brace
id|p
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|not_useful
c_func
(paren
id|p
comma
id|map
)paren
)paren
(brace
suffix:semicolon
)brace
id|len
op_decrement
suffix:semicolon
)brace
op_star
id|ptr
op_assign
id|p
suffix:semicolon
)brace
DECL|function|nubus_advance
r_static
r_void
id|nubus_advance
c_func
(paren
r_int
r_char
op_star
op_star
id|ptr
comma
r_int
id|len
comma
r_int
id|map
)paren
(brace
r_int
r_char
op_star
id|p
op_assign
op_star
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|65536
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;advance of 0x%08x!&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|len
)paren
(brace
r_while
c_loop
(paren
id|not_useful
c_func
(paren
id|p
comma
id|map
)paren
)paren
(brace
id|p
op_increment
suffix:semicolon
)brace
id|p
op_increment
suffix:semicolon
id|len
op_decrement
suffix:semicolon
)brace
op_star
id|ptr
op_assign
id|p
suffix:semicolon
)brace
DECL|function|nubus_move
r_static
r_void
id|nubus_move
c_func
(paren
r_int
r_char
op_star
op_star
id|ptr
comma
r_int
id|len
comma
r_int
id|map
)paren
(brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|nubus_advance
c_func
(paren
id|ptr
comma
id|len
comma
id|map
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
id|nubus_rewind
c_func
(paren
id|ptr
comma
op_minus
id|len
comma
id|map
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Now, functions to read the sResource tree */
multiline_comment|/* Each sResource entry consists of a 1-byte ID and a 3-byte data&n;   field.  If that data field contains an offset, then obviously we&n;   have to expand it from a 24-bit signed number to a 32-bit signed&n;   number. */
DECL|function|nubus_expand32
r_extern
r_inline
r_int
id|nubus_expand32
c_func
(paren
r_int
id|foo
)paren
(brace
r_if
c_cond
(paren
id|foo
op_amp
l_int|0x00800000
)paren
(brace
multiline_comment|/* 24bit negative */
id|foo
op_or_assign
l_int|0xFF000000
suffix:semicolon
)brace
r_return
id|foo
suffix:semicolon
)brace
DECL|function|nubus_rom_addr
r_extern
r_inline
r_void
op_star
id|nubus_rom_addr
c_func
(paren
r_int
id|slot
)paren
(brace
multiline_comment|/*&n;&t; *&t;Returns the first byte after the card. We then walk&n;&t; *&t;backwards to get the lane register and the config&n;&t; */
r_return
(paren
r_void
op_star
)paren
(paren
l_int|0xF1000000
op_plus
(paren
id|slot
op_lshift
l_int|24
)paren
)paren
suffix:semicolon
)brace
DECL|function|nubus_dirptr
r_static
r_int
r_char
op_star
id|nubus_dirptr
c_func
(paren
r_const
r_struct
id|nubus_dirent
op_star
id|nd
)paren
(brace
r_int
r_char
op_star
id|p
op_assign
id|nd-&gt;base
suffix:semicolon
multiline_comment|/* Essentially, just step over the bytelanes using whatever&n;&t;   offset we might have found */
id|nubus_move
c_func
(paren
op_amp
id|p
comma
id|nubus_expand32
c_func
(paren
id|nd-&gt;data
)paren
comma
id|nd-&gt;mask
)paren
suffix:semicolon
multiline_comment|/* And return the value */
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/* These two are for pulling resource data blocks (i.e. stuff that&squot;s&n;   pointed to with offsets) out of the card ROM. */
DECL|function|nubus_get_rsrc_mem
r_void
id|nubus_get_rsrc_mem
c_func
(paren
r_void
op_star
id|dest
comma
r_const
r_struct
id|nubus_dirent
op_star
id|dirent
comma
r_int
id|len
)paren
(brace
r_int
r_char
op_star
id|t
op_assign
(paren
r_int
r_char
op_star
)paren
id|dest
suffix:semicolon
r_int
r_char
op_star
id|p
op_assign
id|nubus_dirptr
c_func
(paren
id|dirent
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
op_star
id|t
op_increment
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|p
comma
l_int|1
comma
id|dirent-&gt;mask
)paren
suffix:semicolon
id|len
op_decrement
suffix:semicolon
)brace
)brace
DECL|function|nubus_get_rsrc_str
r_void
id|nubus_get_rsrc_str
c_func
(paren
r_void
op_star
id|dest
comma
r_const
r_struct
id|nubus_dirent
op_star
id|dirent
comma
r_int
id|len
)paren
(brace
r_int
r_char
op_star
id|t
op_assign
(paren
r_int
r_char
op_star
)paren
id|dest
suffix:semicolon
r_int
r_char
op_star
id|p
op_assign
id|nubus_dirptr
c_func
(paren
id|dirent
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
op_star
id|t
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|p
comma
l_int|1
comma
id|dirent-&gt;mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|t
op_increment
)paren
(brace
r_break
suffix:semicolon
)brace
id|len
op_decrement
suffix:semicolon
)brace
)brace
DECL|function|nubus_get_root_dir
r_int
id|nubus_get_root_dir
c_func
(paren
r_const
r_struct
id|nubus_board
op_star
id|board
comma
r_struct
id|nubus_dir
op_star
id|dir
)paren
(brace
id|dir-&gt;ptr
op_assign
id|dir-&gt;base
op_assign
id|board-&gt;directory
suffix:semicolon
id|dir-&gt;done
op_assign
l_int|0
suffix:semicolon
id|dir-&gt;mask
op_assign
id|board-&gt;lanes
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is a slyly renamed version of the above */
DECL|function|nubus_get_func_dir
r_int
id|nubus_get_func_dir
c_func
(paren
r_const
r_struct
id|nubus_dev
op_star
id|dev
comma
r_struct
id|nubus_dir
op_star
id|dir
)paren
(brace
id|dir-&gt;ptr
op_assign
id|dir-&gt;base
op_assign
id|dev-&gt;directory
suffix:semicolon
id|dir-&gt;done
op_assign
l_int|0
suffix:semicolon
id|dir-&gt;mask
op_assign
id|dev-&gt;board-&gt;lanes
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nubus_get_board_dir
r_int
id|nubus_get_board_dir
c_func
(paren
r_const
r_struct
id|nubus_board
op_star
id|board
comma
r_struct
id|nubus_dir
op_star
id|dir
)paren
(brace
r_struct
id|nubus_dirent
id|ent
suffix:semicolon
id|dir-&gt;ptr
op_assign
id|dir-&gt;base
op_assign
id|board-&gt;directory
suffix:semicolon
id|dir-&gt;done
op_assign
l_int|0
suffix:semicolon
id|dir-&gt;mask
op_assign
id|board-&gt;lanes
suffix:semicolon
multiline_comment|/* Now dereference it (the first directory is always the board&n;&t;   directory) */
r_if
c_cond
(paren
id|nubus_readdir
c_func
(paren
id|dir
comma
op_amp
id|ent
)paren
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|nubus_get_subdir
c_func
(paren
op_amp
id|ent
comma
id|dir
)paren
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nubus_get_subdir
r_int
id|nubus_get_subdir
c_func
(paren
r_const
r_struct
id|nubus_dirent
op_star
id|ent
comma
r_struct
id|nubus_dir
op_star
id|dir
)paren
(brace
id|dir-&gt;ptr
op_assign
id|dir-&gt;base
op_assign
id|nubus_dirptr
c_func
(paren
id|ent
)paren
suffix:semicolon
id|dir-&gt;done
op_assign
l_int|0
suffix:semicolon
id|dir-&gt;mask
op_assign
id|ent-&gt;mask
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nubus_readdir
r_int
id|nubus_readdir
c_func
(paren
r_struct
id|nubus_dir
op_star
id|nd
comma
r_struct
id|nubus_dirent
op_star
id|ent
)paren
(brace
id|u32
id|resid
suffix:semicolon
r_if
c_cond
(paren
id|nd-&gt;done
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Do this first, otherwise nubus_rewind &amp; co are off by 4 */
id|ent-&gt;base
op_assign
id|nd-&gt;ptr
suffix:semicolon
multiline_comment|/* This moves nd-&gt;ptr forward */
id|resid
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|nd-&gt;ptr
comma
l_int|4
comma
id|nd-&gt;mask
)paren
suffix:semicolon
multiline_comment|/* EOL marker, as per the Apple docs */
r_if
c_cond
(paren
(paren
id|resid
op_amp
l_int|0xff000000
)paren
op_eq
l_int|0xff000000
)paren
(brace
multiline_comment|/* Mark it as done */
id|nd-&gt;done
op_assign
l_int|1
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* First byte is the resource ID */
id|ent-&gt;type
op_assign
id|resid
op_rshift
l_int|24
suffix:semicolon
multiline_comment|/* Low 3 bytes might contain data (or might not) */
id|ent-&gt;data
op_assign
id|resid
op_amp
l_int|0xffffff
suffix:semicolon
id|ent-&gt;mask
op_assign
id|nd-&gt;mask
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nubus_rewinddir
r_int
id|nubus_rewinddir
c_func
(paren
r_struct
id|nubus_dir
op_star
id|dir
)paren
(brace
id|dir-&gt;ptr
op_assign
id|dir-&gt;base
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Driver interface functions, more or less like in pci.c */
r_struct
id|nubus_dev
op_star
DECL|function|nubus_find_device
id|nubus_find_device
c_func
(paren
r_int
r_int
id|category
comma
r_int
r_int
id|type
comma
r_int
r_int
id|dr_hw
comma
r_int
r_int
id|dr_sw
comma
r_const
r_struct
id|nubus_dev
op_star
id|from
)paren
(brace
r_struct
id|nubus_dev
op_star
id|itor
op_assign
id|from
ques
c_cond
id|from-&gt;next
suffix:colon
id|nubus_devices
suffix:semicolon
r_while
c_loop
(paren
id|itor
)paren
(brace
r_if
c_cond
(paren
id|itor-&gt;category
op_eq
id|category
op_logical_and
id|itor-&gt;type
op_eq
id|type
op_logical_and
id|itor-&gt;dr_hw
op_eq
id|dr_hw
op_logical_and
id|itor-&gt;dr_sw
op_eq
id|dr_sw
)paren
r_return
id|itor
suffix:semicolon
id|itor
op_assign
id|itor-&gt;next
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_struct
id|nubus_dev
op_star
DECL|function|nubus_find_type
id|nubus_find_type
c_func
(paren
r_int
r_int
id|category
comma
r_int
r_int
id|type
comma
r_const
r_struct
id|nubus_dev
op_star
id|from
)paren
(brace
r_struct
id|nubus_dev
op_star
id|itor
op_assign
id|from
ques
c_cond
id|from-&gt;next
suffix:colon
id|nubus_devices
suffix:semicolon
r_while
c_loop
(paren
id|itor
)paren
(brace
r_if
c_cond
(paren
id|itor-&gt;category
op_eq
id|category
op_logical_and
id|itor-&gt;type
op_eq
id|type
)paren
r_return
id|itor
suffix:semicolon
id|itor
op_assign
id|itor-&gt;next
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_struct
id|nubus_dev
op_star
DECL|function|nubus_find_slot
id|nubus_find_slot
c_func
(paren
r_int
r_int
id|slot
comma
r_const
r_struct
id|nubus_dev
op_star
id|from
)paren
(brace
r_struct
id|nubus_dev
op_star
id|itor
op_assign
id|from
ques
c_cond
id|from-&gt;next
suffix:colon
id|nubus_devices
suffix:semicolon
r_while
c_loop
(paren
id|itor
)paren
(brace
r_if
c_cond
(paren
id|itor-&gt;board-&gt;slot
op_eq
id|slot
)paren
r_return
id|itor
suffix:semicolon
id|itor
op_assign
id|itor-&gt;next
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_int
DECL|function|nubus_find_rsrc
id|nubus_find_rsrc
c_func
(paren
r_struct
id|nubus_dir
op_star
id|dir
comma
r_int
r_char
id|rsrc_type
comma
r_struct
id|nubus_dirent
op_star
id|ent
)paren
(brace
r_while
c_loop
(paren
id|nubus_readdir
c_func
(paren
id|dir
comma
id|ent
)paren
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|ent-&gt;type
op_eq
id|rsrc_type
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Initialization functions - decide which slots contain stuff worth&n;   looking at, and print out lots and lots of information from the&n;   resource blocks. */
multiline_comment|/* FIXME: A lot of this stuff will eventually be useful after&n;   initializaton, for intelligently probing Ethernet and video chips,&n;   among other things.  The rest of it should go in the /proc code.&n;   For now, we just use it to give verbose boot logs. */
DECL|function|nubus_show_display_resource
r_static
r_int
id|__init
id|nubus_show_display_resource
c_func
(paren
r_struct
id|nubus_dev
op_star
id|dev
comma
r_const
r_struct
id|nubus_dirent
op_star
id|ent
)paren
(brace
r_switch
c_cond
(paren
id|ent-&gt;type
)paren
(brace
r_case
id|NUBUS_RESID_GAMMADIR
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    gamma directory offset: 0x%06x&bslash;n&quot;
comma
id|ent-&gt;data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0080
dot
dot
dot
l_int|0x0085
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    mode %02X info offset: 0x%06x&bslash;n&quot;
comma
id|ent-&gt;type
comma
id|ent-&gt;data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    unknown resource %02X, data 0x%06x&bslash;n&quot;
comma
id|ent-&gt;type
comma
id|ent-&gt;data
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nubus_show_network_resource
r_static
r_int
id|__init
id|nubus_show_network_resource
c_func
(paren
r_struct
id|nubus_dev
op_star
id|dev
comma
r_const
r_struct
id|nubus_dirent
op_star
id|ent
)paren
(brace
r_switch
c_cond
(paren
id|ent-&gt;type
)paren
(brace
r_case
id|NUBUS_RESID_MAC_ADDRESS
suffix:colon
(brace
r_char
id|addr
(braket
l_int|6
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|nubus_get_rsrc_mem
c_func
(paren
id|addr
comma
id|ent
comma
l_int|6
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    MAC address: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x%s&quot;
comma
id|addr
(braket
id|i
)braket
op_amp
l_int|0xff
comma
id|i
op_eq
l_int|5
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;:&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    unknown resource %02X, data 0x%06x&bslash;n&quot;
comma
id|ent-&gt;type
comma
id|ent-&gt;data
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nubus_show_cpu_resource
r_static
r_int
id|__init
id|nubus_show_cpu_resource
c_func
(paren
r_struct
id|nubus_dev
op_star
id|dev
comma
r_const
r_struct
id|nubus_dirent
op_star
id|ent
)paren
(brace
r_switch
c_cond
(paren
id|ent-&gt;type
)paren
(brace
r_case
id|NUBUS_RESID_MEMINFO
suffix:colon
(brace
r_int
r_int
id|meminfo
(braket
l_int|2
)braket
suffix:semicolon
id|nubus_get_rsrc_mem
c_func
(paren
op_amp
id|meminfo
comma
id|ent
comma
l_int|8
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    memory: [ 0x%08lx 0x%08lx ]&bslash;n&quot;
comma
id|meminfo
(braket
l_int|0
)braket
comma
id|meminfo
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|NUBUS_RESID_ROMINFO
suffix:colon
(brace
r_int
r_int
id|rominfo
(braket
l_int|2
)braket
suffix:semicolon
id|nubus_get_rsrc_mem
c_func
(paren
op_amp
id|rominfo
comma
id|ent
comma
l_int|8
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    ROM:    [ 0x%08lx 0x%08lx ]&bslash;n&quot;
comma
id|rominfo
(braket
l_int|0
)braket
comma
id|rominfo
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    unknown resource %02X, data 0x%06x&bslash;n&quot;
comma
id|ent-&gt;type
comma
id|ent-&gt;data
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nubus_show_private_resource
r_static
r_int
id|__init
id|nubus_show_private_resource
c_func
(paren
r_struct
id|nubus_dev
op_star
id|dev
comma
r_const
r_struct
id|nubus_dirent
op_star
id|ent
)paren
(brace
r_switch
c_cond
(paren
id|dev-&gt;category
)paren
(brace
r_case
id|NUBUS_CAT_DISPLAY
suffix:colon
id|nubus_show_display_resource
c_func
(paren
id|dev
comma
id|ent
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NUBUS_CAT_NETWORK
suffix:colon
id|nubus_show_network_resource
c_func
(paren
id|dev
comma
id|ent
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NUBUS_CAT_CPU
suffix:colon
id|nubus_show_cpu_resource
c_func
(paren
id|dev
comma
id|ent
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    unknown resource %02X, data 0x%06x&bslash;n&quot;
comma
id|ent-&gt;type
comma
id|ent-&gt;data
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|nubus_dev
op_star
id|__init
DECL|function|nubus_get_functional_resource
id|nubus_get_functional_resource
c_func
(paren
r_struct
id|nubus_board
op_star
id|board
comma
r_int
id|slot
comma
r_const
r_struct
id|nubus_dirent
op_star
id|parent
)paren
(brace
r_struct
id|nubus_dir
id|dir
suffix:semicolon
r_struct
id|nubus_dirent
id|ent
suffix:semicolon
r_struct
id|nubus_dev
op_star
id|dev
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Function 0x%02x:&bslash;n&quot;
comma
id|parent-&gt;type
)paren
suffix:semicolon
id|nubus_get_subdir
c_func
(paren
id|parent
comma
op_amp
id|dir
)paren
suffix:semicolon
multiline_comment|/* Apple seems to have botched the ROM on the IIx */
r_if
c_cond
(paren
id|slot
op_eq
l_int|0
op_logical_and
(paren
r_int
r_int
)paren
id|dir.base
op_mod
l_int|2
)paren
id|dir.base
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_ge
l_int|10
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;nubus_get_functional_resource: parent is 0x%p, dir is 0x%p&bslash;n&quot;
comma
id|parent-&gt;base
comma
id|dir.base
)paren
suffix:semicolon
multiline_comment|/* Actually we should probably panic if this fails */
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|dev
)paren
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|dev
)paren
)paren
suffix:semicolon
id|dev-&gt;resid
op_assign
id|parent-&gt;type
suffix:semicolon
id|dev-&gt;directory
op_assign
id|dir.base
suffix:semicolon
id|dev-&gt;board
op_assign
id|board
suffix:semicolon
r_while
c_loop
(paren
id|nubus_readdir
c_func
(paren
op_amp
id|dir
comma
op_amp
id|ent
)paren
op_ne
op_minus
l_int|1
)paren
(brace
r_switch
c_cond
(paren
id|ent.type
)paren
(brace
r_case
id|NUBUS_RESID_TYPE
suffix:colon
(brace
r_int
r_int
id|nbtdata
(braket
l_int|4
)braket
suffix:semicolon
id|nubus_get_rsrc_mem
c_func
(paren
id|nbtdata
comma
op_amp
id|ent
comma
l_int|8
)paren
suffix:semicolon
id|dev-&gt;category
op_assign
id|nbtdata
(braket
l_int|0
)braket
suffix:semicolon
id|dev-&gt;type
op_assign
id|nbtdata
(braket
l_int|1
)braket
suffix:semicolon
id|dev-&gt;dr_sw
op_assign
id|nbtdata
(braket
l_int|2
)braket
suffix:semicolon
id|dev-&gt;dr_hw
op_assign
id|nbtdata
(braket
l_int|3
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    type: [cat 0x%x type 0x%x hw 0x%x sw 0x%x]&bslash;n&quot;
comma
id|nbtdata
(braket
l_int|0
)braket
comma
id|nbtdata
(braket
l_int|1
)braket
comma
id|nbtdata
(braket
l_int|2
)braket
comma
id|nbtdata
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|NUBUS_RESID_NAME
suffix:colon
(brace
id|nubus_get_rsrc_str
c_func
(paren
id|dev-&gt;name
comma
op_amp
id|ent
comma
l_int|64
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    name: %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|NUBUS_RESID_DRVRDIR
suffix:colon
(brace
multiline_comment|/* MacOS driver.  If we were NetBSD we might&n;&t;&t;&t;   use this :-) */
r_struct
id|nubus_dir
id|drvr_dir
suffix:semicolon
r_struct
id|nubus_dirent
id|drvr_ent
suffix:semicolon
id|nubus_get_subdir
c_func
(paren
op_amp
id|ent
comma
op_amp
id|drvr_dir
)paren
suffix:semicolon
id|nubus_readdir
c_func
(paren
op_amp
id|drvr_dir
comma
op_amp
id|drvr_ent
)paren
suffix:semicolon
id|dev-&gt;driver
op_assign
id|nubus_dirptr
c_func
(paren
op_amp
id|drvr_ent
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    driver at: 0x%p&bslash;n&quot;
comma
id|dev-&gt;driver
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|NUBUS_RESID_MINOR_BASEOS
suffix:colon
multiline_comment|/* We will need this in order to support&n;&t;&t;&t;   multiple framebuffers.  It might be handy&n;&t;&t;&t;   for Ethernet as well */
id|nubus_get_rsrc_mem
c_func
(paren
op_amp
id|dev-&gt;iobase
comma
op_amp
id|ent
comma
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    memory offset: 0x%08lx&bslash;n&quot;
comma
id|dev-&gt;iobase
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NUBUS_RESID_MINOR_LENGTH
suffix:colon
multiline_comment|/* Ditto */
id|nubus_get_rsrc_mem
c_func
(paren
op_amp
id|dev-&gt;iosize
comma
op_amp
id|ent
comma
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    memory length: 0x%08lx&bslash;n&quot;
comma
id|dev-&gt;iosize
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NUBUS_RESID_FLAGS
suffix:colon
id|dev-&gt;flags
op_assign
id|ent.data
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    flags: 0x%06x&bslash;n&quot;
comma
id|dev-&gt;flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NUBUS_RESID_HWDEVID
suffix:colon
id|dev-&gt;hwdevid
op_assign
id|ent.data
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    hwdevid: 0x%06x&bslash;n&quot;
comma
id|dev-&gt;hwdevid
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Local/Private resources have their own&n;&t;&t;&t;   function */
id|nubus_show_private_resource
c_func
(paren
id|dev
comma
op_amp
id|ent
)paren
suffix:semicolon
)brace
)brace
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/* This is cool. */
DECL|function|nubus_get_vidnames
r_static
r_int
id|__init
id|nubus_get_vidnames
c_func
(paren
r_struct
id|nubus_board
op_star
id|board
comma
r_const
r_struct
id|nubus_dirent
op_star
id|parent
)paren
(brace
r_struct
id|nubus_dir
id|dir
suffix:semicolon
r_struct
id|nubus_dirent
id|ent
suffix:semicolon
multiline_comment|/* FIXME: obviously we want to put this in a header file soon */
r_struct
id|vidmode
(brace
id|u32
id|size
suffix:semicolon
multiline_comment|/* Don&squot;t know what this is yet */
id|u16
id|id
suffix:semicolon
multiline_comment|/* Longest one I&squot;ve seen so far is 26 characters */
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
)brace
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    video modes supported:&bslash;n&quot;
)paren
suffix:semicolon
id|nubus_get_subdir
c_func
(paren
id|parent
comma
op_amp
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_ge
l_int|10
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;nubus_get_vidnames: parent is 0x%p, dir is 0x%p&bslash;n&quot;
comma
id|parent-&gt;base
comma
id|dir.base
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nubus_readdir
c_func
(paren
op_amp
id|dir
comma
op_amp
id|ent
)paren
op_ne
op_minus
l_int|1
)paren
(brace
r_struct
id|vidmode
id|mode
suffix:semicolon
id|u32
id|size
suffix:semicolon
multiline_comment|/* First get the length */
id|nubus_get_rsrc_mem
c_func
(paren
op_amp
id|size
comma
op_amp
id|ent
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Now clobber the whole thing */
r_if
c_cond
(paren
id|size
OG
r_sizeof
(paren
id|mode
)paren
op_minus
l_int|1
)paren
id|size
op_assign
r_sizeof
(paren
id|mode
)paren
op_minus
l_int|1
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|mode
comma
r_sizeof
(paren
id|mode
)paren
comma
l_int|0
)paren
suffix:semicolon
id|nubus_get_rsrc_mem
c_func
(paren
op_amp
id|mode
comma
op_amp
id|ent
comma
id|size
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;      %02X: (%02X) %s&bslash;n&quot;
comma
id|ent.type
comma
id|mode.id
comma
id|mode.name
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is *really* cool. */
DECL|function|nubus_get_icon
r_static
r_int
id|__init
id|nubus_get_icon
c_func
(paren
r_struct
id|nubus_board
op_star
id|board
comma
r_const
r_struct
id|nubus_dirent
op_star
id|ent
)paren
(brace
multiline_comment|/* Should be 32x32 if my memory serves me correctly */
r_int
r_char
id|icon
(braket
l_int|128
)braket
suffix:semicolon
r_int
id|x
comma
id|y
suffix:semicolon
id|nubus_get_rsrc_mem
c_func
(paren
op_amp
id|icon
comma
id|ent
comma
l_int|128
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    icon:&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* We should actually plot these somewhere in the framebuffer&n;&t;   init.  This is just to demonstrate that they do, in fact,&n;&t;   exist */
r_for
c_loop
(paren
id|y
op_assign
l_int|0
suffix:semicolon
id|y
OL
l_int|32
suffix:semicolon
id|y
op_increment
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;      &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|32
suffix:semicolon
id|x
op_increment
)paren
(brace
r_if
c_cond
(paren
id|icon
(braket
id|y
op_star
l_int|4
op_plus
id|x
op_div
l_int|8
)braket
op_amp
(paren
l_int|0x80
op_rshift
(paren
id|x
op_mod
l_int|8
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;*&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nubus_get_vendorinfo
r_static
r_int
id|__init
id|nubus_get_vendorinfo
c_func
(paren
r_struct
id|nubus_board
op_star
id|board
comma
r_const
r_struct
id|nubus_dirent
op_star
id|parent
)paren
(brace
r_struct
id|nubus_dir
id|dir
suffix:semicolon
r_struct
id|nubus_dirent
id|ent
suffix:semicolon
r_static
r_char
op_star
id|vendor_fields
(braket
l_int|6
)braket
op_assign
(brace
l_string|&quot;ID&quot;
comma
l_string|&quot;serial&quot;
comma
l_string|&quot;revision&quot;
comma
l_string|&quot;part&quot;
comma
l_string|&quot;date&quot;
comma
l_string|&quot;unknown field&quot;
)brace
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    vendor info:&bslash;n&quot;
)paren
suffix:semicolon
id|nubus_get_subdir
c_func
(paren
id|parent
comma
op_amp
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_ge
l_int|10
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;nubus_get_vendorinfo: parent is 0x%p, dir is 0x%p&bslash;n&quot;
comma
id|parent-&gt;base
comma
id|dir.base
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nubus_readdir
c_func
(paren
op_amp
id|dir
comma
op_amp
id|ent
)paren
op_ne
op_minus
l_int|1
)paren
(brace
r_char
id|name
(braket
l_int|64
)braket
suffix:semicolon
multiline_comment|/* These are all strings, we think */
id|nubus_get_rsrc_str
c_func
(paren
id|name
comma
op_amp
id|ent
comma
l_int|64
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ent.type
OG
l_int|5
)paren
id|ent.type
op_assign
l_int|5
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    %s: %s&bslash;n&quot;
comma
id|vendor_fields
(braket
id|ent.type
op_minus
l_int|1
)braket
comma
id|name
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nubus_get_board_resource
r_static
r_int
id|__init
id|nubus_get_board_resource
c_func
(paren
r_struct
id|nubus_board
op_star
id|board
comma
r_int
id|slot
comma
r_const
r_struct
id|nubus_dirent
op_star
id|parent
)paren
(brace
r_struct
id|nubus_dir
id|dir
suffix:semicolon
r_struct
id|nubus_dirent
id|ent
suffix:semicolon
id|nubus_get_subdir
c_func
(paren
id|parent
comma
op_amp
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_ge
l_int|10
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;nubus_get_board_resource: parent is 0x%p, dir is 0x%p&bslash;n&quot;
comma
id|parent-&gt;base
comma
id|dir.base
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nubus_readdir
c_func
(paren
op_amp
id|dir
comma
op_amp
id|ent
)paren
op_ne
op_minus
l_int|1
)paren
(brace
r_switch
c_cond
(paren
id|ent.type
)paren
(brace
r_case
id|NUBUS_RESID_TYPE
suffix:colon
(brace
r_int
r_int
id|nbtdata
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* This type is always the same, and is not&n;&t;&t;&t;   useful except insofar as it tells us that&n;&t;&t;&t;   we really are looking at a board resource. */
id|nubus_get_rsrc_mem
c_func
(paren
id|nbtdata
comma
op_amp
id|ent
comma
l_int|8
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    type: [cat 0x%x type 0x%x hw 0x%x sw 0x%x]&bslash;n&quot;
comma
id|nbtdata
(braket
l_int|0
)braket
comma
id|nbtdata
(braket
l_int|1
)braket
comma
id|nbtdata
(braket
l_int|2
)braket
comma
id|nbtdata
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nbtdata
(braket
l_int|0
)braket
op_ne
l_int|1
op_logical_or
id|nbtdata
(braket
l_int|1
)braket
op_ne
l_int|0
op_logical_or
id|nbtdata
(braket
l_int|2
)braket
op_ne
l_int|0
op_logical_or
id|nbtdata
(braket
l_int|3
)braket
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;this sResource is not a board resource!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|NUBUS_RESID_NAME
suffix:colon
id|nubus_get_rsrc_str
c_func
(paren
id|board-&gt;name
comma
op_amp
id|ent
comma
l_int|64
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    name: %s&bslash;n&quot;
comma
id|board-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NUBUS_RESID_ICON
suffix:colon
id|nubus_get_icon
c_func
(paren
id|board
comma
op_amp
id|ent
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NUBUS_RESID_BOARDID
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    board id: 0x%x&bslash;n&quot;
comma
id|ent.data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NUBUS_RESID_PRIMARYINIT
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    primary init offset: 0x%06x&bslash;n&quot;
comma
id|ent.data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NUBUS_RESID_VENDORINFO
suffix:colon
id|nubus_get_vendorinfo
c_func
(paren
id|board
comma
op_amp
id|ent
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NUBUS_RESID_FLAGS
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    flags: 0x%06x&bslash;n&quot;
comma
id|ent.data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NUBUS_RESID_HWDEVID
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    hwdevid: 0x%06x&bslash;n&quot;
comma
id|ent.data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NUBUS_RESID_SECONDINIT
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    secondary init offset: 0x%06x&bslash;n&quot;
comma
id|ent.data
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* WTF isn&squot;t this in the functional resources? */
r_case
id|NUBUS_RESID_VIDNAMES
suffix:colon
id|nubus_get_vidnames
c_func
(paren
id|board
comma
op_amp
id|ent
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Same goes for this */
r_case
id|NUBUS_RESID_VIDMODES
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    video mode parameter directory offset: 0x%06x&bslash;n&quot;
comma
id|ent.data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    unknown resource %02X, data 0x%06x&bslash;n&quot;
comma
id|ent.type
comma
id|ent.data
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Attempt to bypass the somewhat non-obvious arrangement of&n;   sResources in the motherboard ROM */
DECL|function|nubus_find_rom_dir
r_static
r_void
id|__init
id|nubus_find_rom_dir
c_func
(paren
r_struct
id|nubus_board
op_star
id|board
)paren
(brace
r_int
r_char
op_star
id|rp
suffix:semicolon
r_int
r_char
op_star
id|romdir
suffix:semicolon
r_struct
id|nubus_dir
id|dir
suffix:semicolon
r_struct
id|nubus_dirent
id|ent
suffix:semicolon
multiline_comment|/* Check for the extra directory just under the format block */
id|rp
op_assign
id|board-&gt;fblock
suffix:semicolon
id|nubus_rewind
c_func
(paren
op_amp
id|rp
comma
l_int|4
comma
id|board-&gt;lanes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nubus_get_rom
c_func
(paren
op_amp
id|rp
comma
l_int|4
comma
id|board-&gt;lanes
)paren
op_ne
id|NUBUS_TEST_PATTERN
)paren
(brace
multiline_comment|/* OK, the ROM was telling the truth */
id|board-&gt;directory
op_assign
id|board-&gt;fblock
suffix:semicolon
id|nubus_move
c_func
(paren
op_amp
id|board-&gt;directory
comma
id|nubus_expand32
c_func
(paren
id|board-&gt;doffset
)paren
comma
id|board-&gt;lanes
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* On &quot;slot zero&quot;, you have to walk down a few more&n;&t;   directories to get to the equivalent of a real card&squot;s root&n;&t;   directory.  We don&squot;t know what they were smoking when they&n;&t;   came up with this. */
id|romdir
op_assign
id|nubus_rom_addr
c_func
(paren
id|board-&gt;slot
)paren
suffix:semicolon
id|nubus_rewind
c_func
(paren
op_amp
id|romdir
comma
id|ROM_DIR_OFFSET
comma
id|board-&gt;lanes
)paren
suffix:semicolon
id|dir.base
op_assign
id|dir.ptr
op_assign
id|romdir
suffix:semicolon
id|dir.done
op_assign
l_int|0
suffix:semicolon
id|dir.mask
op_assign
id|board-&gt;lanes
suffix:semicolon
multiline_comment|/* This one points to an &quot;Unknown Macintosh&quot; directory */
r_if
c_cond
(paren
id|nubus_readdir
c_func
(paren
op_amp
id|dir
comma
op_amp
id|ent
)paren
op_eq
op_minus
l_int|1
)paren
r_goto
id|badrom
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_ge
l_int|10
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;nubus_get_rom_dir: entry %02x %06x&bslash;n&quot;
comma
id|ent.type
comma
id|ent.data
)paren
suffix:semicolon
multiline_comment|/* This one takes us to where we want to go. */
r_if
c_cond
(paren
id|nubus_readdir
c_func
(paren
op_amp
id|dir
comma
op_amp
id|ent
)paren
op_eq
op_minus
l_int|1
)paren
r_goto
id|badrom
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_ge
l_int|10
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;nubus_get_rom_dir: entry %02x %06x&bslash;n&quot;
comma
id|ent.type
comma
id|ent.data
)paren
suffix:semicolon
id|nubus_get_subdir
c_func
(paren
op_amp
id|ent
comma
op_amp
id|dir
)paren
suffix:semicolon
multiline_comment|/* Resource ID 01, also an &quot;Unknown Macintosh&quot; */
r_if
c_cond
(paren
id|nubus_readdir
c_func
(paren
op_amp
id|dir
comma
op_amp
id|ent
)paren
op_eq
op_minus
l_int|1
)paren
r_goto
id|badrom
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_ge
l_int|10
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;nubus_get_rom_dir: entry %02x %06x&bslash;n&quot;
comma
id|ent.type
comma
id|ent.data
)paren
suffix:semicolon
multiline_comment|/* FIXME: the first one is *not* always the right one.  We&n;&t;   suspect this has something to do with the ROM revision.&n;&t;   &quot;The HORROR ROM&quot; (LC-series) uses 0x7e, while &quot;The HORROR&n;&t;   Continues&quot; (Q630) uses 0x7b.  The DAFB Macs evidently use&n;&t;   something else.  Please run &quot;Slots&quot; on your Mac (see&n;&t;   include/linux/nubus.h for where to get this program) and&n;&t;   tell us where the &squot;SiDirPtr&squot; for Slot 0 is.  If you feel&n;&t;   brave, you should also use MacsBug to walk down the ROM&n;&t;   directories like this function does and try to find the&n;&t;   path to that address... */
r_if
c_cond
(paren
id|nubus_readdir
c_func
(paren
op_amp
id|dir
comma
op_amp
id|ent
)paren
op_eq
op_minus
l_int|1
)paren
r_goto
id|badrom
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_ge
l_int|10
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;nubus_get_rom_dir: entry %02x %06x&bslash;n&quot;
comma
id|ent.type
comma
id|ent.data
)paren
suffix:semicolon
multiline_comment|/* Bwahahahaha... */
id|nubus_get_subdir
c_func
(paren
op_amp
id|ent
comma
op_amp
id|dir
)paren
suffix:semicolon
id|board-&gt;directory
op_assign
id|dir.base
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* Even more evil laughter... */
id|badrom
suffix:colon
id|board-&gt;directory
op_assign
id|board-&gt;fblock
suffix:semicolon
id|nubus_move
c_func
(paren
op_amp
id|board-&gt;directory
comma
id|nubus_expand32
c_func
(paren
id|board-&gt;doffset
)paren
comma
id|board-&gt;lanes
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;nubus_get_rom_dir: ROM weirdness!  Notify the developers...&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Add a board (might be many devices) to the list */
DECL|function|nubus_add_board
r_static
r_struct
id|nubus_board
op_star
id|__init
id|nubus_add_board
c_func
(paren
r_int
id|slot
comma
r_int
id|bytelanes
)paren
(brace
r_struct
id|nubus_board
op_star
id|board
suffix:semicolon
r_struct
id|nubus_board
op_star
op_star
id|boardp
suffix:semicolon
r_int
r_char
op_star
id|rp
suffix:semicolon
r_int
r_int
id|dpat
suffix:semicolon
r_struct
id|nubus_dir
id|dir
suffix:semicolon
r_struct
id|nubus_dirent
id|ent
suffix:semicolon
multiline_comment|/* Move to the start of the format block */
id|rp
op_assign
id|nubus_rom_addr
c_func
(paren
id|slot
)paren
suffix:semicolon
id|nubus_rewind
c_func
(paren
op_amp
id|rp
comma
id|FORMAT_BLOCK_SIZE
comma
id|bytelanes
)paren
suffix:semicolon
multiline_comment|/* Actually we should probably panic if this fails */
r_if
c_cond
(paren
(paren
id|board
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|board
)paren
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|board
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|board
)paren
)paren
suffix:semicolon
id|board-&gt;fblock
op_assign
id|rp
suffix:semicolon
multiline_comment|/* Dump the format block for debugging purposes */
r_if
c_cond
(paren
id|console_loglevel
op_ge
l_int|10
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Slot %X, format block at 0x%p&bslash;n&quot;
comma
id|slot
comma
id|rp
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Format block: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FORMAT_BLOCK_SIZE
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
(brace
r_int
r_int
id|foo
comma
id|bar
suffix:semicolon
id|foo
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|rp
comma
l_int|2
comma
id|bytelanes
)paren
suffix:semicolon
id|bar
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|rp
comma
l_int|2
comma
id|bytelanes
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%04x %04x  &quot;
comma
id|foo
comma
id|bar
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|rp
op_assign
id|board-&gt;fblock
suffix:semicolon
)brace
id|board-&gt;slot
op_assign
id|slot
suffix:semicolon
id|board-&gt;slot_addr
op_assign
(paren
r_int
r_int
)paren
id|nubus_slot_addr
c_func
(paren
id|slot
)paren
suffix:semicolon
id|board-&gt;doffset
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|rp
comma
l_int|4
comma
id|bytelanes
)paren
suffix:semicolon
multiline_comment|/* rom_length is *supposed* to be the total length of the&n;&t; * ROM.  In practice it is the &quot;amount of ROM used to compute&n;&t; * the CRC.&quot;  So some jokers decide to set it to zero and&n;&t; * set the crc to zero so they don&squot;t have to do any math.&n;&t; * See the Performa 460 ROM, for example.  Those Apple &quot;engineers&quot;.&n;&t; */
id|board-&gt;rom_length
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|rp
comma
l_int|4
comma
id|bytelanes
)paren
suffix:semicolon
id|board-&gt;crc
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|rp
comma
l_int|4
comma
id|bytelanes
)paren
suffix:semicolon
id|board-&gt;rev
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|rp
comma
l_int|1
comma
id|bytelanes
)paren
suffix:semicolon
id|board-&gt;format
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|rp
comma
l_int|1
comma
id|bytelanes
)paren
suffix:semicolon
id|board-&gt;lanes
op_assign
id|bytelanes
suffix:semicolon
multiline_comment|/* Directory offset should be small and negative... */
r_if
c_cond
(paren
op_logical_neg
(paren
id|board-&gt;doffset
op_amp
l_int|0x00FF0000
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Dodgy doffset!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|dpat
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|rp
comma
l_int|4
comma
id|bytelanes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dpat
op_ne
id|NUBUS_TEST_PATTERN
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Wrong test pattern %08lx!&bslash;n&quot;
comma
id|dpat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;I wonder how the CRC is meant to work -&n;&t; *&t;&t;any takers ?&n;&t; * CSA: According to MAC docs, not all cards pass the CRC anyway,&n;&t; * since the initial Macintosh ROM releases skipped the check.&n;&t; */
multiline_comment|/* Attempt to work around slot zero weirdness */
id|nubus_find_rom_dir
c_func
(paren
id|board
)paren
suffix:semicolon
id|nubus_get_root_dir
c_func
(paren
id|board
comma
op_amp
id|dir
)paren
suffix:semicolon
multiline_comment|/* We&squot;re ready to rock */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Slot %X:&bslash;n&quot;
comma
id|slot
)paren
suffix:semicolon
multiline_comment|/* Each slot should have one board resource and any number of&n;&t;   functional resources.  So we&squot;ll fill in some fields in the&n;&t;   struct nubus_board from the board resource, then walk down&n;&t;   the list of functional resources, spinning out a nubus_dev&n;&t;   for each of them. */
r_if
c_cond
(paren
id|nubus_readdir
c_func
(paren
op_amp
id|dir
comma
op_amp
id|ent
)paren
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* We can&squot;t have this! */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Board resource not found!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Board resource:&bslash;n&quot;
)paren
suffix:semicolon
id|nubus_get_board_resource
c_func
(paren
id|board
comma
id|slot
comma
op_amp
id|ent
)paren
suffix:semicolon
)brace
multiline_comment|/* Aaaarrrrgghh!  The LC III motherboard has *two* board&n;&t;   resources.  I have no idea WTF to do about this. */
r_while
c_loop
(paren
id|nubus_readdir
c_func
(paren
op_amp
id|dir
comma
op_amp
id|ent
)paren
op_ne
op_minus
l_int|1
)paren
(brace
r_struct
id|nubus_dev
op_star
id|dev
suffix:semicolon
r_struct
id|nubus_dev
op_star
op_star
id|devp
suffix:semicolon
id|dev
op_assign
id|nubus_get_functional_resource
c_func
(paren
id|board
comma
id|slot
comma
op_amp
id|ent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
multiline_comment|/* We zeroed this out above */
r_if
c_cond
(paren
id|board-&gt;first_dev
op_eq
l_int|NULL
)paren
id|board-&gt;first_dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Put it on the global NuBus device chain. Keep entries in order. */
r_for
c_loop
(paren
id|devp
op_assign
op_amp
id|nubus_devices
suffix:semicolon
op_star
id|devp
op_ne
l_int|NULL
suffix:semicolon
id|devp
op_assign
op_amp
(paren
(paren
op_star
id|devp
)paren
op_member_access_from_pointer
id|next
)paren
)paren
multiline_comment|/* spin */
suffix:semicolon
op_star
id|devp
op_assign
id|dev
suffix:semicolon
id|dev-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Put it on the global NuBus board chain. Keep entries in order. */
r_for
c_loop
(paren
id|boardp
op_assign
op_amp
id|nubus_boards
suffix:semicolon
op_star
id|boardp
op_ne
l_int|NULL
suffix:semicolon
id|boardp
op_assign
op_amp
(paren
(paren
op_star
id|boardp
)paren
op_member_access_from_pointer
id|next
)paren
)paren
multiline_comment|/* spin */
suffix:semicolon
op_star
id|boardp
op_assign
id|board
suffix:semicolon
id|board-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|board
suffix:semicolon
)brace
DECL|function|nubus_probe_slot
r_void
id|__init
id|nubus_probe_slot
c_func
(paren
r_int
id|slot
)paren
(brace
r_int
r_char
id|dp
suffix:semicolon
r_int
r_char
op_star
id|rp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|rp
op_assign
id|nubus_rom_addr
c_func
(paren
id|slot
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|4
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|card_present
suffix:semicolon
id|rp
op_decrement
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|card_present
op_assign
id|hwreg_present
c_func
(paren
id|rp
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card_present
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Now probing slot %X at %p&bslash;n&quot;
comma
id|slot
comma
id|rp
)paren
suffix:semicolon
id|dp
op_assign
op_star
id|rp
suffix:semicolon
r_if
c_cond
(paren
id|dp
op_eq
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* The last byte of the format block consists of two&n;&t;&t;   nybbles which are &quot;mirror images&quot; of each other.&n;&t;&t;   These show us the valid bytelanes */
r_if
c_cond
(paren
(paren
(paren
(paren
id|dp
op_rshift
l_int|4
)paren
op_xor
id|dp
)paren
op_amp
l_int|0x0F
)paren
op_ne
l_int|0x0F
)paren
r_continue
suffix:semicolon
multiline_comment|/* Check that this value is actually *on* one of the&n;&t;&t;   bytelanes it claims are valid! */
r_if
c_cond
(paren
(paren
id|dp
op_amp
l_int|0x0F
)paren
op_ge
(paren
l_int|1
op_lshift
id|i
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Looks promising.  Let&squot;s put it on the list. */
id|nubus_add_board
c_func
(paren
id|slot
comma
id|dp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#if defined(CONFIG_PROC_FS)
multiline_comment|/* /proc/nubus stuff */
DECL|function|sprint_nubus_board
r_static
r_int
id|sprint_nubus_board
c_func
(paren
r_struct
id|nubus_board
op_star
id|board
comma
r_char
op_star
id|ptr
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
OL
l_int|100
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|ptr
comma
l_string|&quot;Slot %X: %s&bslash;n&quot;
comma
id|board-&gt;slot
comma
id|board-&gt;name
)paren
suffix:semicolon
r_return
id|strlen
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
DECL|function|nubus_read_proc
r_static
r_int
id|nubus_read_proc
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|nprinted
comma
id|len
comma
id|begin
op_assign
l_int|0
suffix:semicolon
r_int
id|slot
comma
id|size
suffix:semicolon
r_struct
id|nubus_board
op_star
id|board
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;Nubus devices found:&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Walk the list of NuBus boards */
r_for
c_loop
(paren
id|board
op_assign
id|nubus_boards
suffix:semicolon
id|board
op_ne
l_int|NULL
suffix:semicolon
id|board
op_assign
id|board-&gt;next
)paren
(brace
id|nprinted
op_assign
id|sprint_nubus_board
c_func
(paren
id|board
comma
id|buf
op_plus
id|len
comma
id|size
op_minus
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nprinted
OL
l_int|0
)paren
r_break
suffix:semicolon
id|len
op_add_assign
id|nprinted
suffix:semicolon
r_if
c_cond
(paren
id|len
op_plus
id|begin
OL
id|off
)paren
(brace
id|begin
op_add_assign
id|len
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
op_plus
id|begin
op_ge
id|off
op_plus
id|count
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|slot
op_eq
l_int|16
op_logical_or
id|len
op_plus
id|begin
OL
id|off
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
id|off
op_sub_assign
id|begin
suffix:semicolon
op_star
id|start
op_assign
id|buf
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif
DECL|function|nubus_scan_bus
r_void
id|__init
id|nubus_scan_bus
c_func
(paren
r_void
)paren
(brace
r_int
id|slot
suffix:semicolon
multiline_comment|/* This might not work on your machine */
macro_line|#ifdef I_WANT_TO_PROBE_SLOT_ZERO
id|nubus_probe_slot
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|slot
op_assign
l_int|9
suffix:semicolon
id|slot
OL
l_int|15
suffix:semicolon
id|slot
op_increment
)paren
(brace
id|nubus_probe_slot
c_func
(paren
id|slot
)paren
suffix:semicolon
)brace
)brace
DECL|function|nubus_init
r_void
id|__init
id|nubus_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|MACH_IS_MAC
)paren
r_return
suffix:semicolon
multiline_comment|/* Initialize the NuBus interrupts */
r_if
c_cond
(paren
id|oss_present
)paren
(brace
id|oss_nubus_init
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|via_nubus_init
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef TRY_TO_DODGE_WSOD
multiline_comment|/* Rogue Ethernet interrupts can kill the machine if we don&squot;t&n;&t;   do this.  Obviously this is bogus.  Hopefully the local VIA&n;&t;   gurus can fix the real cause of the problem. */
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* And probe */
id|printk
c_func
(paren
l_string|&quot;NuBus: Scanning NuBus slots.&bslash;n&quot;
)paren
suffix:semicolon
id|nubus_devices
op_assign
l_int|NULL
suffix:semicolon
id|nubus_boards
op_assign
l_int|NULL
suffix:semicolon
id|nubus_scan_bus
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|create_proc_read_entry
c_func
(paren
l_string|&quot;nubus&quot;
comma
l_int|0
comma
l_int|NULL
comma
id|nubus_read_proc
comma
l_int|NULL
)paren
suffix:semicolon
id|nubus_proc_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
