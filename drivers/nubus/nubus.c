multiline_comment|/*&n; *&t;Macintosh Nubus Interface Code&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/nubus.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/hwtest.h&gt;
multiline_comment|/* for LCIII stuff; better find a general way like MACH_HAS_NUBUS */
macro_line|#include &lt;asm/macintosh.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
DECL|macro|LCIII_WEIRDNESS
macro_line|#undef LCIII_WEIRDNESS
DECL|variable|nubus_slots
r_static
r_struct
id|nubus_slot
id|nubus_slots
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/*&n; *&t;Please skip to the bottom of this file if you ate lunch recently&n; *&t;&t;&t;&t;-- Alan&n; */
multiline_comment|/*&n; *&t;Yes this sucks. The ROM can appear on arbitary bytes of the long&n; *&t;word. We are not amused.&n; */
DECL|function|not_useful
r_extern
id|__inline__
r_int
id|not_useful
c_func
(paren
r_void
op_star
id|p
comma
r_int
id|map
)paren
(brace
r_int
r_int
id|pv
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
id|pv
op_and_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|map
op_amp
(paren
l_int|1
op_lshift
id|pv
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|nubus_get_rom
r_static
r_int
r_int
id|nubus_get_rom
c_func
(paren
r_int
r_char
op_star
op_star
id|ptr
comma
r_int
id|len
comma
r_int
id|map
)paren
(brace
r_int
r_int
id|v
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|p
op_assign
op_star
id|ptr
suffix:semicolon
multiline_comment|/* as v|=*((*ptr)++) upset someone */
r_while
c_loop
(paren
id|len
)paren
(brace
id|v
op_lshift_assign
l_int|8
suffix:semicolon
r_while
c_loop
(paren
id|not_useful
c_func
(paren
id|p
comma
id|map
)paren
)paren
(brace
id|p
op_increment
suffix:semicolon
)brace
id|v
op_or_assign
op_star
id|p
op_increment
suffix:semicolon
id|len
op_decrement
suffix:semicolon
)brace
op_star
id|ptr
op_assign
id|p
suffix:semicolon
r_return
id|v
suffix:semicolon
)brace
DECL|function|nubus_rewind
r_static
r_void
id|nubus_rewind
c_func
(paren
r_int
r_char
op_star
op_star
id|ptr
comma
r_int
id|len
comma
r_int
id|map
)paren
(brace
r_int
r_char
op_star
id|p
op_assign
op_star
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|65536
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rewind of %d!&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|len
)paren
(brace
r_do
(brace
id|p
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|not_useful
c_func
(paren
id|p
comma
id|map
)paren
)paren
(brace
suffix:semicolon
)brace
id|len
op_decrement
suffix:semicolon
)brace
op_star
id|ptr
op_assign
id|p
suffix:semicolon
)brace
DECL|function|nubus_advance
r_static
r_void
id|nubus_advance
c_func
(paren
r_int
r_char
op_star
op_star
id|ptr
comma
r_int
id|len
comma
r_int
id|map
)paren
(brace
r_int
r_char
op_star
id|p
op_assign
op_star
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|65536
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;advance of %d!&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|len
)paren
(brace
r_while
c_loop
(paren
id|not_useful
c_func
(paren
id|p
comma
id|map
)paren
)paren
(brace
id|p
op_increment
suffix:semicolon
)brace
id|p
op_increment
suffix:semicolon
id|len
op_decrement
suffix:semicolon
)brace
op_star
id|ptr
op_assign
id|p
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;24bit signed offset to 32bit&n; */
DECL|function|nubus_expand32
r_static
r_int
r_int
id|nubus_expand32
c_func
(paren
r_int
r_int
id|foo
)paren
(brace
r_if
c_cond
(paren
id|foo
op_amp
l_int|0x00800000
)paren
(brace
multiline_comment|/* 24bit negative */
id|foo
op_or_assign
l_int|0xFF000000
suffix:semicolon
)brace
r_return
id|foo
suffix:semicolon
)brace
DECL|function|nubus_move
r_static
r_void
id|nubus_move
c_func
(paren
r_int
r_char
op_star
op_star
id|ptr
comma
r_int
id|len
comma
r_int
id|map
)paren
(brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|nubus_advance
c_func
(paren
id|ptr
comma
id|len
comma
id|map
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
id|nubus_rewind
c_func
(paren
id|ptr
comma
op_minus
id|len
comma
id|map
)paren
suffix:semicolon
)brace
)brace
DECL|function|nubus_rom_addr
r_static
r_void
op_star
id|nubus_rom_addr
c_func
(paren
r_int
id|slot
)paren
(brace
multiline_comment|/*&n;&t; *&t;Returns the first byte after the card. We then walk&n;&t; *&t;backwards to get the lane register and the config&n;&t; */
r_return
(paren
r_void
op_star
)paren
(paren
l_int|0xF1000000
op_plus
(paren
id|slot
op_lshift
l_int|24
)paren
)paren
suffix:semicolon
)brace
DECL|function|nubus_memcpy
r_void
id|nubus_memcpy
c_func
(paren
r_int
id|slot
comma
r_void
op_star
id|to
comma
r_int
r_char
op_star
id|p
comma
r_int
id|len
)paren
(brace
r_int
r_char
op_star
id|t
op_assign
(paren
r_int
r_char
op_star
)paren
id|to
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
op_star
id|t
op_increment
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|p
comma
l_int|1
comma
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_lanes
)paren
suffix:semicolon
id|len
op_decrement
suffix:semicolon
)brace
)brace
DECL|function|nubus_strncpy
r_void
id|nubus_strncpy
c_func
(paren
r_int
id|slot
comma
r_void
op_star
id|to
comma
r_int
r_char
op_star
id|p
comma
r_int
id|len
)paren
(brace
r_int
r_char
op_star
id|t
op_assign
(paren
r_int
r_char
op_star
)paren
id|to
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
op_star
id|t
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|p
comma
l_int|1
comma
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_lanes
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|t
op_increment
)paren
(brace
r_break
suffix:semicolon
)brace
id|len
op_decrement
suffix:semicolon
)brace
)brace
DECL|function|nubus_dirptr
r_int
r_char
op_star
id|nubus_dirptr
c_func
(paren
r_struct
id|nubus_dirent
op_star
id|nd
)paren
(brace
r_int
r_char
op_star
id|p
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|nd-&gt;base
)paren
suffix:semicolon
id|nubus_move
c_func
(paren
op_amp
id|p
comma
id|nubus_expand32
c_func
(paren
id|nd-&gt;value
)paren
comma
id|nd-&gt;mask
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|nubus_openrootdir
r_struct
id|nubus_dir
op_star
id|nubus_openrootdir
c_func
(paren
r_int
id|slot
)paren
(brace
r_static
r_struct
id|nubus_dir
id|nbdir
suffix:semicolon
r_int
r_char
op_star
id|rp
op_assign
id|nubus_rom_addr
c_func
(paren
id|slot
)paren
suffix:semicolon
id|nubus_rewind
c_func
(paren
op_amp
id|rp
comma
l_int|20
comma
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_lanes
)paren
suffix:semicolon
id|nubus_move
c_func
(paren
op_amp
id|rp
comma
id|nubus_expand32
c_func
(paren
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_directory
)paren
comma
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_lanes
)paren
suffix:semicolon
id|nbdir.base
op_assign
id|rp
suffix:semicolon
id|nbdir.length
op_assign
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_dlength
suffix:semicolon
id|nbdir.count
op_assign
l_int|0
suffix:semicolon
id|nbdir.mask
op_assign
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_lanes
suffix:semicolon
r_return
op_amp
id|nbdir
suffix:semicolon
)brace
DECL|function|nubus_opensubdir
r_struct
id|nubus_dir
op_star
id|nubus_opensubdir
c_func
(paren
r_struct
id|nubus_dirent
op_star
id|d
)paren
(brace
r_static
r_struct
id|nubus_dir
id|nbdir
suffix:semicolon
r_int
r_char
op_star
id|rp
op_assign
id|nubus_dirptr
c_func
(paren
id|d
)paren
suffix:semicolon
id|nbdir.base
op_assign
id|rp
suffix:semicolon
id|nbdir.length
op_assign
l_int|99999
suffix:semicolon
multiline_comment|/*slots[i].slot_dlength;*/
id|nbdir.count
op_assign
l_int|0
suffix:semicolon
id|nbdir.mask
op_assign
id|d-&gt;mask
suffix:semicolon
r_return
op_amp
id|nbdir
suffix:semicolon
)brace
DECL|function|nubus_closedir
r_void
id|nubus_closedir
c_func
(paren
r_struct
id|nubus_dir
op_star
id|nd
)paren
(brace
suffix:semicolon
)brace
DECL|function|nubus_readdir
r_struct
id|nubus_dirent
op_star
id|nubus_readdir
c_func
(paren
r_struct
id|nubus_dir
op_star
id|nd
)paren
(brace
id|u32
id|resid
suffix:semicolon
id|u8
id|rescode
suffix:semicolon
r_static
r_struct
id|nubus_dirent
id|d
suffix:semicolon
r_if
c_cond
(paren
id|nd-&gt;count
op_eq
id|nd-&gt;length
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|d.base
op_assign
(paren
r_int
r_int
)paren
id|nd-&gt;base
suffix:semicolon
id|resid
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|nd-&gt;base
comma
l_int|4
comma
id|nd-&gt;mask
)paren
suffix:semicolon
id|nd-&gt;count
op_increment
suffix:semicolon
id|rescode
op_assign
id|resid
op_rshift
l_int|24
suffix:semicolon
r_if
c_cond
(paren
id|rescode
op_eq
l_int|0xFF
)paren
(brace
id|nd-&gt;count
op_assign
id|nd-&gt;length
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|d.type
op_assign
id|rescode
suffix:semicolon
id|d.value
op_assign
id|resid
op_amp
l_int|0xFFFFFF
suffix:semicolon
id|d.mask
op_assign
id|nd-&gt;mask
suffix:semicolon
r_return
op_amp
id|d
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;MAC video handling irritations&n; */
DECL|variable|nubus_vid_byte
r_static
r_int
r_char
id|nubus_vid_byte
(braket
l_int|16
)braket
suffix:semicolon
DECL|variable|nubus_vid_offset
r_static
r_int
r_int
id|nubus_vid_offset
(braket
l_int|16
)braket
suffix:semicolon
DECL|function|nubus_irqsplat
r_static
r_void
id|nubus_irqsplat
c_func
(paren
r_int
id|slot
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_char
op_star
id|p
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|nubus_slot_addr
c_func
(paren
id|slot
)paren
)paren
op_plus
id|nubus_vid_offset
(braket
id|slot
)braket
suffix:semicolon
op_star
id|p
op_assign
id|nubus_vid_byte
(braket
id|slot
)braket
suffix:semicolon
)brace
DECL|function|nubus_add_irqsplatter
r_static
r_int
id|nubus_add_irqsplatter
c_func
(paren
r_int
id|slot
comma
r_int
r_int
id|ptr
comma
r_int
r_char
id|v
)paren
(brace
id|nubus_vid_byte
(braket
id|slot
)braket
op_assign
id|v
suffix:semicolon
id|nubus_vid_offset
(braket
id|slot
)braket
op_assign
id|ptr
suffix:semicolon
id|nubus_request_irq
c_func
(paren
id|slot
comma
l_int|NULL
comma
id|nubus_irqsplat
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nubus_video_shutup
r_void
id|nubus_video_shutup
c_func
(paren
r_int
id|slot
comma
r_struct
id|nubus_type
op_star
id|nt
)paren
(brace
r_if
c_cond
(paren
id|nt-&gt;category
op_ne
l_int|3
multiline_comment|/* Display */
op_logical_or
id|nt-&gt;type
op_ne
l_int|1
multiline_comment|/* Video */
op_logical_or
id|nt-&gt;DrSW
op_ne
l_int|1
multiline_comment|/* Quickdraw device */
)paren
(brace
r_return
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|nt-&gt;DrHW
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Toby and MacII Hires cards. These behave in a MacII&n;&t;&t; *&t;anyway but not on an RBV box&n;&t;&t; */
r_case
l_int|0x0001
suffix:colon
r_case
l_int|0x0013
suffix:colon
id|nubus_add_irqsplatter
c_func
(paren
id|slot
comma
l_int|0xA0000
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Apple workstation video card.&n;&t;&t; */
r_case
l_int|0x0006
suffix:colon
id|nubus_add_irqsplatter
c_func
(paren
id|slot
comma
l_int|0xA00000
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Futura cards&n;&t;&t; */
r_case
l_int|0x0417
suffix:colon
r_case
l_int|0x042F
suffix:colon
id|nubus_add_irqsplatter
c_func
(paren
id|slot
comma
l_int|0xF05000
comma
l_int|0x80
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Fingers crossed 8)&n;&t;&t; *&t;&n;&t;&t; *&t;If you have another card and an RBV based mac you&squot;ll&n;&t;&t; *&t;almost certainly have to add it here to make it work.&n;&t;&t; */
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Device list&n; */
DECL|variable|nubus_device_list
r_static
r_struct
id|nubus_device_specifier
op_star
id|nubus_device_list
op_assign
l_int|NULL
suffix:semicolon
DECL|function|register_nubus_device
r_void
id|register_nubus_device
c_func
(paren
r_struct
id|nubus_device_specifier
op_star
id|d
)paren
(brace
id|d-&gt;next
op_assign
id|nubus_device_list
suffix:semicolon
id|nubus_device_list
op_assign
id|d
suffix:semicolon
)brace
DECL|function|unregister_nubus_device
r_void
id|unregister_nubus_device
c_func
(paren
r_struct
id|nubus_device_specifier
op_star
id|nb
)paren
(brace
r_struct
id|nubus_device_specifier
op_star
op_star
id|t
op_assign
op_amp
id|nubus_device_list
suffix:semicolon
r_while
c_loop
(paren
op_star
id|t
op_ne
id|nb
op_logical_and
op_star
id|t
)paren
(brace
id|t
op_assign
op_amp
(paren
(paren
op_star
id|t
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
)brace
op_star
id|t
op_assign
id|nb-&gt;next
suffix:semicolon
)brace
DECL|function|find_nubus_device
r_static
r_struct
id|nubus_device_specifier
op_star
id|find_nubus_device
c_func
(paren
r_int
id|slot
comma
r_struct
id|nubus_type
op_star
id|nt
)paren
(brace
r_struct
id|nubus_device_specifier
op_star
id|t
op_assign
id|nubus_device_list
suffix:semicolon
r_while
c_loop
(paren
id|t
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|t
op_member_access_from_pointer
id|setup
c_func
(paren
id|t
comma
id|slot
comma
id|nt
)paren
op_eq
l_int|0
)paren
(brace
r_return
id|t
suffix:semicolon
)brace
id|t
op_assign
id|t-&gt;next
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;No driver for device [%d %d %d %d]&bslash;n&quot;
comma
id|nt-&gt;category
comma
id|nt-&gt;type
comma
id|nt-&gt;DrHW
comma
id|nt-&gt;DrSW
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Probe a nubus slot&n; */
DECL|function|nubus_probe_slot
r_void
id|nubus_probe_slot
c_func
(paren
r_int
id|slot
comma
r_int
id|mode
)paren
(brace
r_int
r_char
op_star
id|rp
suffix:semicolon
r_int
r_char
id|dp
suffix:semicolon
r_int
id|lanes
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|dpat
suffix:semicolon
r_struct
id|nubus_dir
op_star
id|dir
suffix:semicolon
r_struct
id|nubus_dirent
op_star
id|nd
suffix:semicolon
r_struct
id|nubus_type
id|type_info
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Ok see whats cooking in the bytelanes&n;&t; */
id|rp
op_assign
id|nubus_rom_addr
c_func
(paren
id|slot
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|4
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|rp
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwreg_present
c_func
(paren
id|rp
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|dp
op_assign
op_star
id|rp
suffix:semicolon
r_if
c_cond
(paren
id|dp
op_eq
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Valid ?&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
(paren
id|dp
op_rshift
l_int|4
)paren
op_xor
id|dp
)paren
op_amp
l_int|0x0F
)paren
op_ne
l_int|0x0F
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dp
op_amp
l_int|0x0F
)paren
op_ge
l_int|1
op_lshift
id|i
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Looks promising&n;&t;&t; */
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_flags
op_or_assign
id|NUBUS_DEVICE_PRESENT
suffix:semicolon
id|lanes
op_assign
id|dp
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;nubus%c: &quot;
comma
l_string|&quot;0123456789abcdef&quot;
(braket
id|slot
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Time to dig deeper. Find the ROM base&n;&t;&t; *&t;and read it&n;&t;&t; */
id|rp
op_assign
id|nubus_rom_addr
c_func
(paren
id|slot
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Now to make this more fun the ROM is only visible&n;&t;&t; *&t;on its bytelanes - that is smeared across the address&n;&t;&t; *&t;space.&n;&t;&t; */
id|nubus_rewind
c_func
(paren
op_amp
id|rp
comma
l_int|20
comma
id|lanes
)paren
suffix:semicolon
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_directory
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|rp
comma
l_int|4
comma
id|lanes
)paren
suffix:semicolon
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_dlength
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|rp
comma
l_int|4
comma
id|lanes
)paren
suffix:semicolon
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_crc
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|rp
comma
l_int|4
comma
id|lanes
)paren
suffix:semicolon
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_rev
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|rp
comma
l_int|1
comma
id|lanes
)paren
suffix:semicolon
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_format
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|rp
comma
l_int|1
comma
id|lanes
)paren
suffix:semicolon
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_lanes
op_assign
id|lanes
suffix:semicolon
id|dpat
op_assign
id|nubus_get_rom
c_func
(paren
op_amp
id|rp
comma
l_int|4
comma
id|lanes
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Ok now check what we got&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_directory
op_amp
l_int|0x00FF0000
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Dodgy doffset ??&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dpat
op_ne
l_int|0x5A932BC7
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Wrong test pattern %lx&bslash;n&quot;
comma
id|dpat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;I wonder how the CRC is meant to work -&n;&t;&t; *&t;&t;any takers ?&n;&t;&t; */
multiline_comment|/*&n;&t;&t; *&t;Now parse the directories on the card&n;&t;&t; */
id|dir
op_assign
id|nubus_openrootdir
c_func
(paren
id|slot
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Find the board resource&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|nd
op_assign
id|nubus_readdir
c_func
(paren
id|dir
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;This ought to be 1. 1 doesn&squot;t work, 0x80&n;&t;&t;&t; *&t;does. Seems the Apple docs are wrong.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|nd-&gt;type
op_eq
l_int|0x80
multiline_comment|/*RES_ID_BOARD_DIR*/
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|nubus_closedir
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nd
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;board resource not found!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dir
op_assign
id|nubus_opensubdir
c_func
(paren
id|nd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Walk the board resource&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|nd
op_assign
id|nubus_readdir
c_func
(paren
id|dir
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_switch
c_cond
(paren
id|nd-&gt;type
)paren
(brace
r_case
id|RES_ID_TYPE
suffix:colon
(brace
r_int
r_int
id|nbtdata
(braket
l_int|4
)braket
suffix:semicolon
id|nubus_memcpy
c_func
(paren
id|slot
comma
id|nbtdata
comma
id|nubus_dirptr
c_func
(paren
id|nd
)paren
comma
l_int|8
)paren
suffix:semicolon
id|type_info.category
op_assign
id|nbtdata
(braket
l_int|0
)braket
suffix:semicolon
id|type_info.type
op_assign
id|nbtdata
(braket
l_int|1
)braket
suffix:semicolon
id|type_info.DrHW
op_assign
id|nbtdata
(braket
l_int|2
)braket
suffix:semicolon
id|type_info.DrSW
op_assign
id|nbtdata
(braket
l_int|3
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|RES_ID_NAME
suffix:colon
id|nubus_strncpy
c_func
(paren
id|slot
comma
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_cardname
comma
id|nubus_dirptr
c_func
(paren
id|nd
)paren
comma
l_int|64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
)brace
id|nubus_closedir
c_func
(paren
id|dir
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Attempt to bind a driver to this slot&n;&t;&t; */
r_if
c_cond
(paren
id|mode
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_cardname
)paren
suffix:semicolon
id|find_nubus_device
c_func
(paren
id|slot
comma
op_amp
id|type_info
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_eq
l_int|1
)paren
id|nubus_video_shutup
c_func
(paren
id|slot
comma
op_amp
id|type_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
DECL|function|nubus_probe_bus
r_void
id|nubus_probe_bus
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|9
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* printk(&quot;nubus: probing slot %d !&bslash;n&quot;, i); */
id|nubus_probe_slot
c_func
(paren
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;RBV machines have level triggered video interrupts, and a VIA&n; *&t;emulation that doesn&squot;t always seem to include being able to disable &n; *&t;an interrupt. Totally lusing hardware. Before we can init irq&squot;s we&n; *&t;have to install a handler to shut the bloody things up.&n; */
DECL|function|nubus_sweep_video
r_void
id|nubus_sweep_video
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* XXX why ?? */
r_for
c_loop
(paren
id|i
op_assign
l_int|9
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nubus_probe_slot
c_func
(paren
id|i
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Support functions&n; */
DECL|function|nubus_ethernet_addr
r_int
id|nubus_ethernet_addr
c_func
(paren
r_int
id|slot
comma
r_int
r_char
op_star
id|addr
)paren
(brace
r_struct
id|nubus_dir
op_star
id|nb
suffix:semicolon
r_struct
id|nubus_dirent
op_star
id|d
suffix:semicolon
r_int
id|ng
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|nb
op_assign
id|nubus_openrootdir
c_func
(paren
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nb
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|d
op_assign
id|nubus_readdir
c_func
(paren
id|nb
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;type
op_eq
l_int|0x80
)paren
(brace
multiline_comment|/* First private resource */
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|d
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
id|nb
op_assign
id|nubus_opensubdir
c_func
(paren
id|d
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|d
op_assign
id|nubus_readdir
c_func
(paren
id|nb
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;type
op_eq
l_int|0x80
)paren
multiline_comment|/* First private field is the mac */
(brace
r_int
id|i
suffix:semicolon
id|nubus_memcpy
c_func
(paren
id|slot
comma
id|addr
comma
id|nubus_dirptr
c_func
(paren
id|d
)paren
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/*&t;&t;&t;printk(&quot;d.base=%lX, d.value=%lX&bslash;n&quot;,&n;&t;&t;&t;&t;d-&gt;base,d-&gt;value);&n;&t;&t;&t;memcpy(addr,&quot;&bslash;xC0&bslash;xC1&bslash;xC2&bslash;xC3&bslash;xC4&bslash;xC5&quot;,6);*/
id|printk
c_func
(paren
l_string|&quot;MAC address: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s%02X&quot;
comma
id|i
ques
c_cond
l_string|&quot;:&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|ng
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;ID=%d val=%x&bslash;n&quot;
comma
id|d-&gt;type
comma
id|d-&gt;value
)paren
suffix:semicolon
)brace
r_return
id|ng
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/*&n; *&t;/proc for Nubus devices&n; */
DECL|function|sprint_nubus_config
r_static
r_int
id|sprint_nubus_config
c_func
(paren
r_int
id|slot
comma
r_char
op_star
id|ptr
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
OL
l_int|150
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|ptr
comma
l_string|&quot;Device: %s %s&bslash;n&quot;
comma
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_cardname
comma
(paren
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_flags
op_amp
id|NUBUS_DEVICE_ACTIVE
)paren
ques
c_cond
l_string|&quot;[active]&quot;
suffix:colon
l_string|&quot;[unused]&quot;
)paren
suffix:semicolon
r_return
id|strlen
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
DECL|function|get_nubus_list
r_int
id|get_nubus_list
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_int
id|nprinted
comma
id|len
comma
id|size
suffix:semicolon
r_int
id|slot
suffix:semicolon
DECL|macro|MSG
mdefine_line|#define MSG &quot;&bslash;nwarning: page-size limit reached!&bslash;n&quot;
multiline_comment|/* reserve same for truncation warning message: */
id|size
op_assign
id|PAGE_SIZE
op_minus
(paren
id|strlen
c_func
(paren
id|MSG
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;Nubus devices found:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|16
suffix:semicolon
id|slot
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|nubus_slots
(braket
id|slot
)braket
dot
id|slot_flags
op_amp
id|NUBUS_DEVICE_PRESENT
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|nprinted
op_assign
id|sprint_nubus_config
c_func
(paren
id|slot
comma
id|buf
op_plus
id|len
comma
id|size
op_minus
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nprinted
OL
l_int|0
)paren
(brace
r_return
id|len
op_plus
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
id|MSG
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|nprinted
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
DECL|variable|proc_nubus
r_static
r_struct
id|proc_dir_entry
id|proc_nubus
op_assign
(brace
id|PROC_NUBUS
comma
l_int|5
comma
l_string|&quot;nubus&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_amp
id|proc_array_inode_operations
)brace
suffix:semicolon
macro_line|#endif
DECL|function|nubus_init
r_void
id|nubus_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* &n;&t; *&t;Register cards&n;&t; */
macro_line|#ifdef CONFIG_DAYNAPORT
r_extern
r_struct
id|nubus_device_specifier
id|nubus_8390
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|MACH_IS_MAC
)paren
r_return
suffix:semicolon
macro_line|#ifdef LCIII_WEIRDNESS
r_if
c_cond
(paren
id|macintosh_config-&gt;ident
op_eq
id|MAC_MODEL_LCIII
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;nubus init: LCIII has no nubus!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_DAYNAPORT
id|register_nubus_device
c_func
(paren
op_amp
id|nubus_8390
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;And probe&n;&t; */
id|nubus_init_via
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Scanning nubus slots.&bslash;n&quot;
)paren
suffix:semicolon
id|nubus_probe_bus
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|proc_register
c_func
(paren
op_amp
id|proc_root
comma
op_amp
id|proc_nubus
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
