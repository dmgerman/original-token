multiline_comment|/* $Id: parport_init.c,v 1.3.2.4 1997/04/16 21:20:44 phil Exp $&n; * Parallel-port initialisation code.&n; * &n; * Authors: David Campbell &lt;campbell@tirian.che.curtin.edu.au&gt;&n; *          Tim Waugh &lt;tmw20@cam.ac.uk&gt;&n; *&t;    Jose Renau &lt;renau@acm.org&gt;&n; *&n; * based on work by Grant Guenther &lt;grant@torque.net&gt;&n; *              and Philip Blundell &lt;Philip.Blundell@pobox.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/tasks.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &quot;parport_ll_io.h&quot;
DECL|variable|io
r_static
r_int
id|io
(braket
id|PARPORT_MAX
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
(braket
id|PARPORT_MAX
)braket
op_assign
(brace
id|PARPORT_IRQ_NONE
comma
)brace
suffix:semicolon
DECL|variable|dma
r_static
r_int
id|dma
(braket
id|PARPORT_MAX
)braket
op_assign
(brace
id|PARPORT_DMA_NONE
comma
)brace
suffix:semicolon
multiline_comment|/******************************************************&n; *  DMA detection section:&n; */
multiline_comment|/*&n; * Prepare DMA channels from 0-8 to transmit towards buffer&n; */
DECL|function|parport_prepare_dma
r_static
r_int
id|parport_prepare_dma
c_func
(paren
r_char
op_star
id|buff
comma
r_int
id|size
)paren
(brace
r_int
id|tmp
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|retv
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|retv
op_assign
id|request_dma
c_func
(paren
id|i
comma
l_string|&quot;probe&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retv
)paren
r_continue
suffix:semicolon
id|tmp
op_or_assign
l_int|1
op_lshift
id|i
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|i
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|i
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|i
comma
id|virt_to_bus
c_func
(paren
id|buff
)paren
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|i
comma
id|size
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|i
comma
id|DMA_MODE_READ
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|tmp
suffix:semicolon
)brace
multiline_comment|/*&n; * Activate all DMA channels passed in dma&n; */
DECL|function|parport_enable_dma
r_static
r_int
id|parport_enable_dma
c_func
(paren
r_int
id|dma
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dma
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|i
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|dma
suffix:semicolon
)brace
DECL|function|parport_detect_dma_transfer
r_static
r_int
id|parport_detect_dma_transfer
c_func
(paren
r_int
id|dma
comma
r_int
id|size
comma
r_int
op_star
id|resid
)paren
(brace
r_int
id|i
comma
id|n
comma
id|retv
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|retv
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dma
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|disable_dma
c_func
(paren
id|i
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|i
)paren
suffix:semicolon
id|n
op_assign
id|get_dma_residue
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_ne
id|size
)paren
(brace
op_star
id|resid
op_assign
id|n
suffix:semicolon
id|retv
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
id|retv
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Multiple DMA&squot;s */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;parport: multiple DMA detected.  Huh?&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|count
op_increment
suffix:semicolon
)brace
id|free_dma
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/* Only if supports ECP mode */
DECL|function|programmable_dma_support
r_static
r_int
id|programmable_dma_support
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|dma
suffix:semicolon
id|w_ecr
c_func
(paren
id|pb
comma
l_int|0xE0
)paren
suffix:semicolon
multiline_comment|/* Configuration MODE */
id|dma
op_assign
id|r_cnfgB
c_func
(paren
id|pb
)paren
op_amp
l_int|0x07
suffix:semicolon
id|w_ecr
c_func
(paren
id|pb
comma
id|pb-&gt;ecr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma
op_eq
l_int|0
op_logical_or
id|dma
op_eq
l_int|4
)paren
(brace
multiline_comment|/* Jumper selection */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_return
id|dma
suffix:semicolon
)brace
multiline_comment|/* Only called if port supports ECP mode.&n; *&n; * The only restriction on DMA channels is that it has to be&n; * between 0 to 7 (inclusive). Used only in an ECP mode, DMAs are&n; * considered a shared resource and hence they should be registered&n; * when needed and then immediately unregistered.&n; *&n; * DMA autoprobes for ECP mode are known not to work for some&n; * main board BIOS configs. I had to remove everything from the&n; * port, set the mode to SPP, reboot to DOS, set the mode to ECP,&n; * and reboot again, then I got IRQ probes and DMA probes to work.&n; * [Is the BIOS doing a device detection?]&n; *&n; * A value of -1 is allowed indicating no DMA support.&n; *&n; * if( 0 &lt; DMA &lt; 4 )&n; *    1Byte DMA transfer&n; * else // 4 &lt; DMA &lt; 8&n; *    2Byte DMA transfer&n; *&n; */
DECL|function|parport_dma_probe
r_static
r_int
id|parport_dma_probe
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|dma
comma
id|retv
suffix:semicolon
r_int
id|dsr
comma
id|dsr_read
suffix:semicolon
r_char
op_star
id|buff
suffix:semicolon
id|retv
op_assign
id|programmable_dma_support
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retv
op_ne
op_minus
l_int|1
)paren
r_return
id|retv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|buff
op_assign
id|kmalloc
c_func
(paren
l_int|2048
comma
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;parport: memory squeeze&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|dsr
op_assign
id|r_ctr
c_func
(paren
id|pb
)paren
suffix:semicolon
id|dsr_read
op_assign
(paren
id|dsr
op_amp
op_complement
(paren
l_int|0x20
)paren
)paren
op_or
l_int|0x04
suffix:semicolon
multiline_comment|/* Direction == read */
id|w_ecr
c_func
(paren
id|pb
comma
l_int|0xc0
)paren
suffix:semicolon
multiline_comment|/* ECP MODE */
id|w_ctr
c_func
(paren
id|pb
comma
id|dsr_read
)paren
suffix:semicolon
id|dma
op_assign
id|parport_prepare_dma
c_func
(paren
id|buff
comma
l_int|1000
)paren
suffix:semicolon
id|w_ecr
c_func
(paren
id|pb
comma
l_int|0xd8
)paren
suffix:semicolon
multiline_comment|/* ECP FIFO + enable DMA */
id|parport_enable_dma
c_func
(paren
id|dma
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
multiline_comment|/* Give some for DMA tranfer */
id|retv
op_assign
id|parport_detect_dma_transfer
c_func
(paren
id|dma
comma
l_int|1000
comma
op_amp
id|pb-&gt;speed
)paren
suffix:semicolon
id|pb-&gt;speed
op_assign
id|pb-&gt;speed
op_star
l_int|2000
suffix:semicolon
multiline_comment|/* 500uSec * 2000 = 1sec */
multiline_comment|/*&n;&t; * National Semiconductors only supports DMA tranfers&n;&t; * in ECP MODE&n;&t; */
r_if
c_cond
(paren
id|retv
op_eq
op_minus
l_int|1
)paren
(brace
id|w_ecr
c_func
(paren
id|pb
comma
l_int|0x60
)paren
suffix:semicolon
multiline_comment|/* ECP MODE */
id|w_ctr
c_func
(paren
id|pb
comma
id|dsr_read
)paren
suffix:semicolon
id|dma
op_assign
id|parport_prepare_dma
c_func
(paren
id|buff
comma
l_int|1000
)paren
suffix:semicolon
id|w_ecr
c_func
(paren
id|pb
comma
l_int|0x68
)paren
suffix:semicolon
multiline_comment|/* ECP FIFO + enable DMA */
id|parport_enable_dma
c_func
(paren
id|dma
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
multiline_comment|/* Give some for DMA tranfer */
id|retv
op_assign
id|parport_detect_dma_transfer
c_func
(paren
id|dma
comma
l_int|1000
comma
op_amp
id|pb-&gt;speed
)paren
suffix:semicolon
id|pb-&gt;speed
op_assign
id|pb-&gt;speed
op_star
l_int|2000
suffix:semicolon
multiline_comment|/* 500uSec * 2000 = 1sec */
)brace
id|kfree
c_func
(paren
id|buff
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|pb
comma
id|pb-&gt;ctr
)paren
suffix:semicolon
id|w_ecr
c_func
(paren
id|pb
comma
id|pb-&gt;ecr
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/******************************************************&n; *  MODE detection section:&n; */
multiline_comment|/*&n; * Clear TIMEOUT BIT in EPP MODE&n; */
DECL|function|epp_clear_timeout
r_static
r_int
id|epp_clear_timeout
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|r
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r_str
c_func
(paren
id|pb
)paren
op_amp
l_int|0x01
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* To clear timeout some chips require double read */
id|r_str
c_func
(paren
id|pb
)paren
suffix:semicolon
id|r
op_assign
id|r_str
c_func
(paren
id|pb
)paren
suffix:semicolon
id|w_str
c_func
(paren
id|pb
comma
id|r
op_or
l_int|0x01
)paren
suffix:semicolon
multiline_comment|/* Some reset by writing 1 */
id|w_str
c_func
(paren
id|pb
comma
id|r
op_amp
l_int|0xfe
)paren
suffix:semicolon
multiline_comment|/* Others by writing 0 */
id|r
op_assign
id|r_str
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
op_logical_neg
(paren
id|r
op_amp
l_int|0x01
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Checks for port existence, all ports support SPP MODE&n; */
DECL|function|parport_SPP_supported
r_static
r_int
id|parport_SPP_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
multiline_comment|/* Do a simple read-write test to make sure the port exists. */
id|w_dtr
c_func
(paren
id|pb
comma
l_int|0xaa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r_dtr
c_func
(paren
id|pb
)paren
op_ne
l_int|0xaa
)paren
r_return
l_int|0
suffix:semicolon
id|w_dtr
c_func
(paren
id|pb
comma
l_int|0x55
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r_dtr
c_func
(paren
id|pb
)paren
op_ne
l_int|0x55
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|PARPORT_MODE_SPP
suffix:semicolon
)brace
multiline_comment|/* Check for ECP&n; *&n; * Old style XT ports alias io ports every 0x400, hence accessing ECR&n; * on these cards actually accesses the CTR.&n; *&n; * Modern cards don&squot;t do this but reading from ECR will return 0xff&n; * regardless of what is written here if the card does NOT support&n; * ECP.&n; *&n; * We will write 0x2c to ECR and 0xcc to CTR since both of these&n; * values are &quot;safe&quot; on the CTR since bits 6-7 of CTR are unused.&n; */
DECL|function|parport_ECR_present
r_static
r_int
id|parport_ECR_present
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|r
suffix:semicolon
id|r
op_assign
id|r_ctr
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r_ecr
c_func
(paren
id|pb
)paren
op_amp
l_int|0x03
)paren
op_eq
(paren
id|r
op_amp
l_int|0x03
)paren
)paren
(brace
id|w_ctr
c_func
(paren
id|pb
comma
id|r
op_xor
l_int|0x03
)paren
suffix:semicolon
multiline_comment|/* Toggle bits 0-1 */
id|r
op_assign
id|r_ctr
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r_ecr
c_func
(paren
id|pb
)paren
op_amp
l_int|0x03
)paren
op_eq
(paren
id|r
op_amp
l_int|0x03
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Sure that no ECR register exists */
)brace
r_if
c_cond
(paren
(paren
id|r_ecr
c_func
(paren
id|pb
)paren
op_amp
l_int|0x03
)paren
op_ne
l_int|0x01
)paren
r_return
l_int|0
suffix:semicolon
id|w_ecr
c_func
(paren
id|pb
comma
l_int|0x34
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r_ecr
c_func
(paren
id|pb
)paren
op_ne
l_int|0x35
)paren
r_return
l_int|0
suffix:semicolon
id|w_ecr
c_func
(paren
id|pb
comma
id|pb-&gt;ecr
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|pb
comma
id|pb-&gt;ctr
)paren
suffix:semicolon
r_return
id|PARPORT_MODE_ECR
suffix:semicolon
)brace
DECL|function|parport_ECP_supported
r_static
r_int
id|parport_ECP_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* If there is no ECR, we have no hope of supporting ECP. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_ECR
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Using LGS chipset it uses ECR register, but&n;&t; * it doesn&squot;t support ECP or FIFO MODE&n;&t; */
id|w_ecr
c_func
(paren
id|pb
comma
l_int|0xc0
)paren
suffix:semicolon
multiline_comment|/* TEST FIFO */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1024
op_logical_and
(paren
id|r_ecr
c_func
(paren
id|pb
)paren
op_amp
l_int|0x01
)paren
suffix:semicolon
id|i
op_increment
)paren
id|w_fifo
c_func
(paren
id|pb
comma
l_int|0xaa
)paren
suffix:semicolon
id|w_ecr
c_func
(paren
id|pb
comma
id|pb-&gt;ecr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|1024
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|PARPORT_MODE_ECP
suffix:semicolon
)brace
multiline_comment|/* EPP mode detection&n; * Theory:&n; *&t;Bit 0 of STR is the EPP timeout bit, this bit is 0&n; *&t;when EPP is possible and is set high when an EPP timeout&n; *&t;occurs (EPP uses the HALT line to stop the CPU while it does&n; *&t;the byte transfer, an EPP timeout occurs if the attached&n; *&t;device fails to respond after 10 micro seconds).&n; *&n; *&t;This bit is cleared by either reading it (National Semi)&n; *&t;or writing a 1 to the bit (SMC, UMC, WinBond), others ???&n; *&t;This bit is always high in non EPP modes.&n; */
DECL|function|parport_EPP_supported
r_static
r_int
id|parport_EPP_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
multiline_comment|/* If EPP timeout bit clear then EPP available */
r_if
c_cond
(paren
op_logical_neg
id|epp_clear_timeout
c_func
(paren
id|pb
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* No way to clear timeout */
id|w_ctr
c_func
(paren
id|pb
comma
id|r_ctr
c_func
(paren
id|pb
)paren
op_or
l_int|0x20
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|pb
comma
id|r_ctr
c_func
(paren
id|pb
)paren
op_or
l_int|0x10
)paren
suffix:semicolon
id|epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
id|r_epp
c_func
(paren
id|pb
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|30
)paren
suffix:semicolon
multiline_comment|/* Wait for possible EPP timeout */
r_if
c_cond
(paren
id|r_str
c_func
(paren
id|pb
)paren
op_amp
l_int|0x01
)paren
(brace
id|epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
id|PARPORT_MODE_EPP
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parport_ECPEPP_supported
r_static
r_int
id|parport_ECPEPP_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|mode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_ECR
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Search for SMC style EPP+ECP mode */
id|w_ecr
c_func
(paren
id|pb
comma
l_int|0x80
)paren
suffix:semicolon
id|mode
op_assign
id|parport_EPP_supported
c_func
(paren
id|pb
)paren
suffix:semicolon
id|w_ecr
c_func
(paren
id|pb
comma
id|pb-&gt;ecr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
)paren
r_return
id|PARPORT_MODE_ECPEPP
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Detect PS/2 support.&n; *&n; * Bit 5 (0x20) sets the PS/2 data direction; setting this high&n; * allows us to read data from the data lines.  In theory we would get back&n; * 0xff but any peripheral attached to the port may drag some or all of the&n; * lines down to zero.  So if we get back anything that isn&squot;t the contents&n; * of the data register we deem PS/2 support to be present. &n; *&n; * Some SPP ports have &quot;half PS/2&quot; ability - you can&squot;t turn off the line&n; * drivers, but an external peripheral with sufficiently beefy drivers of&n; * its own can overpower them and assert its own levels onto the bus, from&n; * where they can then be read back as normal.  Ports with this property&n; * and the right type of device attached are likely to fail the SPP test,&n; * (as they will appear to have stuck bits) and so the fact that they might&n; * be misdetected here is rather academic. &n; */
DECL|function|parport_PS2_supported
r_static
r_int
id|parport_PS2_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|ok
op_assign
l_int|0
suffix:semicolon
id|epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|pb
comma
id|pb-&gt;ctr
op_or
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/* try to tri-state the buffer */
id|w_dtr
c_func
(paren
id|pb
comma
l_int|0x55
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r_dtr
c_func
(paren
id|pb
)paren
op_ne
l_int|0x55
)paren
id|ok
op_increment
suffix:semicolon
id|w_dtr
c_func
(paren
id|pb
comma
l_int|0xaa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r_dtr
c_func
(paren
id|pb
)paren
op_ne
l_int|0xaa
)paren
id|ok
op_increment
suffix:semicolon
id|w_ctr
c_func
(paren
id|pb
comma
id|pb-&gt;ctr
)paren
suffix:semicolon
multiline_comment|/* cancel input mode */
r_return
id|ok
ques
c_cond
id|PARPORT_MODE_PS2
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|parport_ECPPS2_supported
r_static
r_int
id|parport_ECPPS2_supported
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|mode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_ECR
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|w_ecr
c_func
(paren
id|pb
comma
l_int|0x20
)paren
suffix:semicolon
id|mode
op_assign
id|parport_PS2_supported
c_func
(paren
id|pb
)paren
suffix:semicolon
id|w_ecr
c_func
(paren
id|pb
comma
id|pb-&gt;ecr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
)paren
r_return
id|PARPORT_MODE_ECPPS2
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************&n; *  IRQ detection section:&n; *&n; * This code is for detecting ECP interrupts (due to problems with the&n; * monolithic interrupt probing routines).&n; *&n; * In short this is a voting system where the interrupt with the most&n; * &quot;votes&quot; is the elected interrupt (it SHOULD work...)&n; *&n; * This is horribly x86-specific at the moment.  I&squot;m not convinced it&n; * belongs at all.&n; */
DECL|variable|intr_vote
r_static
r_int
id|intr_vote
(braket
l_int|16
)braket
suffix:semicolon
DECL|function|parport_vote_intr_func
r_static
r_void
id|parport_vote_intr_func
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|intr_vote
(braket
id|irq
)braket
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|open_intr_election
r_static
r_int
id|open_intr_election
c_func
(paren
r_void
)paren
(brace
r_int
id|tmp
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* We ignore the timer - irq 0 */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|intr_vote
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|i
comma
id|parport_vote_intr_func
comma
id|SA_INTERRUPT
comma
l_string|&quot;probe&quot;
comma
id|intr_vote
)paren
op_eq
l_int|0
)paren
id|tmp
op_or_assign
l_int|1
op_lshift
id|i
suffix:semicolon
)brace
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|close_intr_election
r_static
r_int
id|close_intr_election
c_func
(paren
r_int
id|tmp
)paren
(brace
r_int
id|irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* We ignore the timer - irq 0 */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|tmp
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
r_if
c_cond
(paren
id|intr_vote
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
id|irq
op_ne
id|PARPORT_IRQ_NONE
)paren
multiline_comment|/* More than one interrupt */
r_return
id|PARPORT_IRQ_NONE
suffix:semicolon
id|irq
op_assign
id|i
suffix:semicolon
)brace
id|free_irq
c_func
(paren
id|i
comma
id|intr_vote
)paren
suffix:semicolon
)brace
r_return
id|irq
suffix:semicolon
)brace
multiline_comment|/* Only if supports ECP mode */
DECL|function|programmable_irq_support
r_static
r_int
id|programmable_irq_support
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|irq
suffix:semicolon
id|w_ecr
c_func
(paren
id|pb
comma
l_int|0xE0
)paren
suffix:semicolon
multiline_comment|/* Configuration MODE */
id|irq
op_assign
(paren
id|r_cnfgB
c_func
(paren
id|pb
)paren
op_rshift
l_int|3
)paren
op_amp
l_int|0x07
suffix:semicolon
r_switch
c_cond
(paren
id|irq
)paren
(brace
r_case
l_int|2
suffix:colon
id|irq
op_assign
l_int|9
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|irq
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
id|irq
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|irq
op_add_assign
l_int|7
suffix:semicolon
)brace
id|w_ecr
c_func
(paren
id|pb
comma
id|pb-&gt;ecr
)paren
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
DECL|function|irq_probe_ECP
r_static
r_int
id|irq_probe_ECP
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|irqs
comma
id|i
suffix:semicolon
id|probe_irq_off
c_func
(paren
id|probe_irq_on
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear any interrupts */
id|irqs
op_assign
id|open_intr_election
c_func
(paren
)paren
suffix:semicolon
id|w_ecr
c_func
(paren
id|pb
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* Reset FIFO */
id|w_ctr
c_func
(paren
id|pb
comma
id|pb-&gt;ctr
)paren
suffix:semicolon
multiline_comment|/* Force direction = 0 */
id|w_ecr
c_func
(paren
id|pb
comma
l_int|0xd0
)paren
suffix:semicolon
multiline_comment|/* TEST FIFO + nErrIntrEn */
multiline_comment|/* If Full FIFO sure that WriteIntrThresold is generated */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1024
op_logical_and
op_logical_neg
(paren
id|r_ecr
c_func
(paren
id|pb
)paren
op_amp
l_int|0x02
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|w_fifo
c_func
(paren
id|pb
comma
l_int|0xaa
)paren
suffix:semicolon
)brace
id|pb-&gt;irq
op_assign
id|close_intr_election
c_func
(paren
id|irqs
)paren
suffix:semicolon
id|w_ecr
c_func
(paren
id|pb
comma
id|pb-&gt;ecr
)paren
suffix:semicolon
r_return
id|pb-&gt;irq
suffix:semicolon
)brace
multiline_comment|/*&n; * This detection seems that only works in National Semiconductors&n; * This doesn&squot;t work in SMC, LGS, and Winbond &n; */
DECL|function|irq_probe_EPP
r_static
r_int
id|irq_probe_EPP
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|irqs
suffix:semicolon
macro_line|#ifndef ADVANCED_DETECT
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
id|probe_irq_off
c_func
(paren
id|probe_irq_on
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear any interrupts */
id|irqs
op_assign
id|open_intr_election
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_ECR
)paren
(brace
id|w_ecr
c_func
(paren
id|pb
comma
id|r_ecr
c_func
(paren
id|pb
)paren
op_or
l_int|0x10
)paren
suffix:semicolon
)brace
id|epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|pb
comma
id|r_ctr
c_func
(paren
id|pb
)paren
op_or
l_int|0x20
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|pb
comma
id|r_ctr
c_func
(paren
id|pb
)paren
op_or
l_int|0x10
)paren
suffix:semicolon
id|epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
multiline_comment|/*  Device isn&squot;t expecting an EPP read&n;&t; * and generates an IRQ.&n;&t; */
id|r_epp
c_func
(paren
id|pb
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|pb-&gt;irq
op_assign
id|close_intr_election
c_func
(paren
id|irqs
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|pb
comma
id|pb-&gt;ctr
)paren
suffix:semicolon
r_return
id|pb-&gt;irq
suffix:semicolon
)brace
DECL|function|irq_probe_SPP
r_static
r_int
id|irq_probe_SPP
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_int
id|irqs
suffix:semicolon
macro_line|#ifndef ADVANCED_DETECT
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
id|probe_irq_off
c_func
(paren
id|probe_irq_on
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear any interrupts */
id|irqs
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_ECR
)paren
(brace
id|w_ecr
c_func
(paren
id|pb
comma
l_int|0x10
)paren
suffix:semicolon
)brace
id|w_dtr
c_func
(paren
id|pb
comma
l_int|0x00
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|pb
comma
l_int|0x00
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|pb
comma
l_int|0x0c
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|pb
comma
l_int|0x0d
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|pb
comma
l_int|0x0c
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|pb
comma
l_int|0x08
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|pb
comma
l_int|0x0c
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|pb-&gt;irq
op_assign
id|probe_irq_off
c_func
(paren
id|irqs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_le
l_int|0
)paren
id|pb-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
multiline_comment|/* No interrupt detected */
id|w_ctr
c_func
(paren
id|pb
comma
id|pb-&gt;ctr
)paren
suffix:semicolon
r_return
id|pb-&gt;irq
suffix:semicolon
)brace
multiline_comment|/* We will attempt to share interrupt requests since other devices&n; * such as sound cards and network cards seem to like using the&n; * printer IRQs.&n; *&n; * When ECP is available we can autoprobe for IRQs.&n; * NOTE: If we can autoprobe it, we can register the IRQ.&n; */
DECL|function|parport_irq_probe
r_static
r_int
id|parport_irq_probe
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_ECR
)paren
id|pb-&gt;irq
op_assign
id|programmable_irq_support
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_ECP
)paren
id|pb-&gt;irq
op_assign
id|irq_probe_ECP
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
op_logical_and
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_ECPEPP
)paren
)paren
(brace
id|w_ecr
c_func
(paren
id|pb
comma
l_int|0x80
)paren
suffix:semicolon
id|pb-&gt;irq
op_assign
id|irq_probe_EPP
c_func
(paren
id|pb
)paren
suffix:semicolon
id|w_ecr
c_func
(paren
id|pb
comma
id|pb-&gt;ecr
)paren
suffix:semicolon
)brace
id|epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
op_logical_and
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_EPP
)paren
)paren
id|pb-&gt;irq
op_assign
id|irq_probe_EPP
c_func
(paren
id|pb
)paren
suffix:semicolon
id|epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
)paren
id|pb-&gt;irq
op_assign
id|irq_probe_SPP
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
id|pb-&gt;irq
suffix:semicolon
)brace
DECL|function|initialize_parport
r_int
id|initialize_parport
c_func
(paren
r_struct
id|parport
op_star
id|pb
comma
r_int
r_int
id|base
comma
r_int
id|irq
comma
r_int
id|dma
comma
r_int
id|count
)paren
(brace
multiline_comment|/* Check some parameters */
r_if
c_cond
(paren
id|dma
OL
op_minus
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;parport: Invalid DMA[%d] at base 0x%lx&bslash;n&quot;
comma
id|dma
comma
id|base
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq
OL
op_minus
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;parport: Invalid IRQ[%d] at base 0x%lx&bslash;n&quot;
comma
id|irq
comma
id|base
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Init our structure */
id|memset
c_func
(paren
id|pb
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|parport
)paren
)paren
suffix:semicolon
id|pb-&gt;base
op_assign
id|base
suffix:semicolon
id|pb-&gt;irq
op_assign
id|irq
suffix:semicolon
id|pb-&gt;dma
op_assign
id|dma
suffix:semicolon
id|pb-&gt;modes
op_assign
l_int|0
suffix:semicolon
id|pb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|pb-&gt;devices
op_assign
id|pb-&gt;cad
op_assign
id|pb-&gt;lurker
op_assign
l_int|NULL
suffix:semicolon
id|pb-&gt;flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Before we start, set the control registers to something sensible. */
id|pb-&gt;ecr
op_assign
l_int|0xc
suffix:semicolon
id|pb-&gt;ctr
op_assign
l_int|0xc
suffix:semicolon
id|pb-&gt;name
op_assign
id|kmalloc
c_func
(paren
l_int|15
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pb-&gt;name
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;parport: memory squeeze&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|pb-&gt;name
comma
l_string|&quot;parport%d&quot;
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parport_SPP_supported
c_func
(paren
id|pb
)paren
)paren
(brace
id|epp_clear_timeout
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parport_SPP_supported
c_func
(paren
id|pb
)paren
)paren
(brace
id|kfree
c_func
(paren
id|pb-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|pb-&gt;modes
op_or_assign
id|PARPORT_MODE_SPP
suffix:semicolon
multiline_comment|/* All ports support SPP mode. */
id|pb-&gt;modes
op_or_assign
id|parport_PS2_supported
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;base
op_ne
l_int|0x3bc
)paren
(brace
id|pb-&gt;modes
op_or_assign
id|parport_ECR_present
c_func
(paren
id|pb
)paren
suffix:semicolon
id|pb-&gt;modes
op_or_assign
id|parport_ECP_supported
c_func
(paren
id|pb
)paren
suffix:semicolon
id|pb-&gt;modes
op_or_assign
id|parport_ECPPS2_supported
c_func
(paren
id|pb
)paren
suffix:semicolon
id|pb-&gt;modes
op_or_assign
id|parport_EPP_supported
c_func
(paren
id|pb
)paren
suffix:semicolon
id|pb-&gt;modes
op_or_assign
id|parport_ECPEPP_supported
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
multiline_comment|/* Now register regions */
r_if
c_cond
(paren
(paren
id|pb-&gt;modes
op_amp
(paren
id|PARPORT_MODE_EPP
op_or
id|PARPORT_MODE_ECPEPP
)paren
)paren
op_logical_and
(paren
id|check_region
c_func
(paren
id|pb-&gt;base
comma
l_int|8
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: EPP disabled due to port conflict at %x.&bslash;n&quot;
comma
id|pb-&gt;name
comma
id|pb-&gt;base
op_plus
l_int|3
)paren
suffix:semicolon
id|pb-&gt;modes
op_and_assign
op_complement
(paren
id|PARPORT_MODE_EPP
op_or
id|PARPORT_MODE_ECPEPP
)paren
suffix:semicolon
)brace
id|pb-&gt;size
op_assign
(paren
id|pb-&gt;modes
op_amp
(paren
id|PARPORT_MODE_EPP
op_or
id|PARPORT_MODE_ECPEPP
)paren
)paren
ques
c_cond
l_int|8
suffix:colon
l_int|3
suffix:semicolon
id|request_region
c_func
(paren
id|pb-&gt;base
comma
id|pb-&gt;size
comma
id|pb-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_ECR
)paren
id|request_region
c_func
(paren
id|pb-&gt;base
op_plus
l_int|0x400
comma
l_int|3
comma
id|pb-&gt;name
)paren
suffix:semicolon
multiline_comment|/* DMA check */
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_ECP
)paren
(brace
r_if
c_cond
(paren
id|pb-&gt;dma
op_eq
id|PARPORT_DMA_NONE
)paren
id|pb-&gt;dma
op_assign
id|parport_dma_probe
c_func
(paren
id|pb
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pb-&gt;dma
op_eq
op_minus
l_int|2
)paren
id|pb-&gt;dma
op_assign
id|PARPORT_DMA_NONE
suffix:semicolon
)brace
multiline_comment|/* IRQ check */
r_if
c_cond
(paren
id|pb-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
)paren
id|pb-&gt;irq
op_assign
id|parport_irq_probe
c_func
(paren
id|pb
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pb-&gt;irq
op_eq
op_minus
l_int|2
)paren
id|pb-&gt;irq
op_assign
id|PARPORT_IRQ_NONE
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifndef MODULE
DECL|variable|parport_setup_ptr
r_static
r_int
id|parport_setup_ptr
op_assign
l_int|0
suffix:semicolon
DECL|function|parport_setup
r_void
id|parport_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_or
id|ints
(braket
l_int|1
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Disable parport if &quot;parport=&quot; or &quot;parport=0&quot; in cmdline */
id|io
(braket
l_int|0
)braket
op_assign
id|PARPORT_DISABLE
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|parport_setup_ptr
OL
id|PARPORT_MAX
)paren
(brace
id|io
(braket
id|parport_setup_ptr
)braket
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|1
)paren
(brace
id|irq
(braket
id|parport_setup_ptr
)braket
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|2
)paren
id|dma
(braket
id|parport_setup_ptr
)braket
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
)brace
id|parport_setup_ptr
op_increment
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;parport=0x%x&quot;
comma
id|ints
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;,%d&quot;
comma
id|ints
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;,%d&quot;
comma
id|ints
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; ignored, too many ports.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_PNP_PARPORT_AUTOPROBE
r_extern
r_void
id|parport_probe_one
c_func
(paren
r_struct
id|parport
op_star
id|port
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|PARPORT_MAX
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|PARPORT_MAX
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dma
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|PARPORT_MAX
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
macro_line|#else
r_int
id|pnp_parport_init
c_func
(paren
r_void
)paren
macro_line|#endif&t;&t;&t;&t;/* MODULE */
(brace
r_struct
id|parport
op_star
id|pb
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Parallel port sharing: %s&bslash;n&quot;
comma
l_string|&quot;$Revision: 1.3.2.4 $&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|io
(braket
l_int|0
)braket
op_eq
id|PARPORT_DISABLE
)paren
r_return
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|parport_proc_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Run probes to ensure parport does exist */
DECL|macro|PORT
mdefine_line|#define PORT(a,b,c) &bslash;&n;&t;&t;if ((pb = parport_register_port((a), (b), (c))))  &bslash;&n;&t;&t;        parport_destroy(pb); 
r_if
c_cond
(paren
id|io
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* If the user specified any ports, use them */
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|io
(braket
id|i
)braket
op_logical_and
id|i
OL
id|PARPORT_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
id|PORT
c_func
(paren
id|io
(braket
id|i
)braket
comma
id|irq
(braket
id|i
)braket
comma
id|dma
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Go for the standard ports. */
id|PORT
c_func
(paren
l_int|0x378
comma
id|PARPORT_IRQ_NONE
comma
id|PARPORT_DMA_NONE
)paren
suffix:semicolon
id|PORT
c_func
(paren
l_int|0x278
comma
id|PARPORT_IRQ_NONE
comma
id|PARPORT_DMA_NONE
)paren
suffix:semicolon
id|PORT
c_func
(paren
l_int|0x3bc
comma
id|PARPORT_IRQ_NONE
comma
id|PARPORT_DMA_NONE
)paren
suffix:semicolon
DECL|macro|PORT
macro_line|#undef PORT
)brace
macro_line|#if defined(CONFIG_PNP_PARPORT_AUTOPROBE) || defined(CONFIG_PROC_FS)
r_for
c_loop
(paren
id|pb
op_assign
id|parport_enumerate
c_func
(paren
)paren
suffix:semicolon
id|pb
suffix:semicolon
id|pb
op_assign
id|pb-&gt;next
)paren
(brace
macro_line|#ifdef CONFIG_PNP_PARPORT_AUTOPROBE
id|parport_probe_one
c_func
(paren
id|pb
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_PROC_FS
id|parport_proc_register
c_func
(paren
id|pb
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|parport
op_star
id|port
comma
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
id|parport_enumerate
c_func
(paren
)paren
suffix:semicolon
id|port
suffix:semicolon
id|port
op_assign
id|next
)paren
(brace
id|next
op_assign
id|port-&gt;next
suffix:semicolon
id|parport_destroy
c_func
(paren
id|port
)paren
suffix:semicolon
id|parport_proc_unregister
c_func
(paren
id|port
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|port-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|port
)paren
suffix:semicolon
)brace
id|parport_proc_cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Exported symbols for modules. */
DECL|variable|parport_claim
id|EXPORT_SYMBOL
c_func
(paren
id|parport_claim
)paren
suffix:semicolon
DECL|variable|parport_release
id|EXPORT_SYMBOL
c_func
(paren
id|parport_release
)paren
suffix:semicolon
DECL|variable|parport_register_port
id|EXPORT_SYMBOL
c_func
(paren
id|parport_register_port
)paren
suffix:semicolon
DECL|variable|parport_destroy
id|EXPORT_SYMBOL
c_func
(paren
id|parport_destroy
)paren
suffix:semicolon
DECL|variable|parport_register_device
id|EXPORT_SYMBOL
c_func
(paren
id|parport_register_device
)paren
suffix:semicolon
DECL|variable|parport_unregister_device
id|EXPORT_SYMBOL
c_func
(paren
id|parport_unregister_device
)paren
suffix:semicolon
DECL|variable|parport_enumerate
id|EXPORT_SYMBOL
c_func
(paren
id|parport_enumerate
)paren
suffix:semicolon
DECL|variable|parport_ieee1284_nibble_mode_ok
id|EXPORT_SYMBOL
c_func
(paren
id|parport_ieee1284_nibble_mode_ok
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PNP_PARPORT_AUTOPROBE
DECL|variable|parport_probe
id|EXPORT_SYMBOL
c_func
(paren
id|parport_probe
)paren
suffix:semicolon
DECL|variable|parport_probe_one
id|EXPORT_SYMBOL
c_func
(paren
id|parport_probe_one
)paren
suffix:semicolon
macro_line|#endif
DECL|function|inc_parport_count
r_void
id|inc_parport_count
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
DECL|function|dec_parport_count
r_void
id|dec_parport_count
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
eof
