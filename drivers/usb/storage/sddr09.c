multiline_comment|/* Driver for SanDisk SDDR-09 SmartMedia reader&n; *&n; * $Id: sddr09.c,v 1.14 2000/11/21 02:58:26 mdharm Exp $&n; *&n; * SDDR09 driver v0.1:&n; *&n; * First release&n; *&n; * Current development and maintenance by:&n; *   (c) 2000 Robert Baruch (autophile@dol.net)&n; *&n; * The SanDisk SDDR-09 SmartMedia reader uses the Shuttle EUSB-01 chip.&n; * This chip is a programmable USB controller. In the SDDR-09, it has&n; * been programmed to obey a certain limited set of SCSI commands. This&n; * driver translates the &quot;real&quot; SCSI commands to the SDDR-09 SCSI&n; * commands.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;sddr09.h&quot;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
DECL|macro|short_pack
mdefine_line|#define short_pack(lsb,msb) ( ((u16)(lsb)) | ( ((u16)(msb))&lt;&lt;8 ) )
DECL|macro|LSB_of
mdefine_line|#define LSB_of(s) ((s)&amp;0xFF)
DECL|macro|MSB_of
mdefine_line|#define MSB_of(s) ((s)&gt;&gt;8)
multiline_comment|/*&n; * Send a control message and wait for the response.&n; *&n; * us - the pointer to the us_data structure for the device to use&n; *&n; * request - the URB Setup Packet&squot;s first 6 bytes. The first byte always&n; *  corresponds to the request type, and the second byte always corresponds&n; *  to the request.  The other 4 bytes do not correspond to value and index,&n; *  since they are used in a custom way by the SCM protocol.&n; *&n; * xfer_data - a buffer from which to get, or to which to store, any data&n; *  that gets send or received, respectively, with the URB. Even though&n; *  it looks like we allocate a buffer in this code for the data, xfer_data&n; *  must contain enough allocated space.&n; *&n; * xfer_len - the number of bytes to send or receive with the URB.&n; *&n; */
DECL|function|sddr09_send_control
r_static
r_int
id|sddr09_send_control
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|pipe
comma
r_int
r_char
id|request
comma
r_int
r_char
id|requesttype
comma
r_int
r_int
id|value
comma
r_int
r_int
id|index
comma
r_int
r_char
op_star
id|xfer_data
comma
r_int
r_int
id|xfer_len
)paren
(brace
r_int
id|result
suffix:semicolon
singleline_comment|// If data is going to be sent or received with the URB,
singleline_comment|// then allocate a buffer for it. If data is to be sent,
singleline_comment|// copy the data into the buffer.
multiline_comment|/*&n;&t;if (xfer_len &gt; 0) {&n;&t;&t;buffer = kmalloc(xfer_len, GFP_KERNEL);&n;&t;&t;if (!(command[0] &amp; USB_DIR_IN))&n;&t;&t;&t;memcpy(buffer, xfer_data, xfer_len);&n;&t;}&n;*/
singleline_comment|// Send the URB to the device and wait for a response.
multiline_comment|/* Why are request and request type reversed in this call? */
id|result
op_assign
id|usb_stor_control_msg
c_func
(paren
id|us
comma
id|pipe
comma
id|request
comma
id|requesttype
comma
id|value
comma
id|index
comma
id|xfer_data
comma
id|xfer_len
)paren
suffix:semicolon
singleline_comment|// If data was sent or received with the URB, free the buffer we
singleline_comment|// allocated earlier, but not before reading the data out of the
singleline_comment|// buffer if we wanted to receive data.
multiline_comment|/*&n;&t;if (xfer_len &gt; 0) {&n;&t;&t;if (command[0] &amp; USB_DIR_IN)&n;&t;&t;&t;memcpy(xfer_data, buffer, xfer_len);&n;&t;&t;kfree(buffer);&n;&t;}&n;*/
singleline_comment|// Check the return code for the command.
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* if the command was aborted, indicate that */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
r_return
id|USB_STOR_TRANSPORT_ABORTED
suffix:semicolon
multiline_comment|/* a stall is a fatal condition from the device */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Stall on control pipe. Clearing&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- usb_clear_halt() returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/* Uh oh... serious problem here */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
DECL|function|sddr09_raw_bulk
r_static
r_int
id|sddr09_raw_bulk
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|direction
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|act_len
suffix:semicolon
r_int
id|pipe
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|SCSI_DATA_READ
)paren
id|pipe
op_assign
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_in
)paren
suffix:semicolon
r_else
id|pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_msg
c_func
(paren
id|us
comma
id|data
comma
id|pipe
comma
id|len
comma
op_amp
id|act_len
)paren
suffix:semicolon
multiline_comment|/* if we stall, we need to clear it before we go on */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;EPIPE: clearing endpoint halt for&quot;
l_string|&quot; pipe 0x%x, stalled at %d bytes&bslash;n&quot;
comma
id|pipe
comma
id|act_len
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
)paren
(brace
multiline_comment|/* NAK - that means we&squot;ve retried a few times already */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_raw_bulk():&quot;
l_string|&quot; device NAKed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_FAILED
suffix:semicolon
)brace
multiline_comment|/* -ENOENT -- we canceled this transfer */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_raw_bulk():&quot;
l_string|&quot; transfer aborted&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_ABORTED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_raw_bulk():&quot;
l_string|&quot; output pipe stalled&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/* the catch-all case */
id|US_DEBUGP
c_func
(paren
l_string|&quot;us_transfer_partial(): unknown error&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|act_len
op_ne
id|len
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Warning: Transferred only %d bytes&bslash;n&quot;
comma
id|act_len
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_SHORT
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Transfered %d of %d bytes&bslash;n&quot;
comma
id|act_len
comma
id|len
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: direction must be set if command_len == 0.&n; */
DECL|function|sddr09_bulk_transport
r_static
r_int
id|sddr09_bulk_transport
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|direction
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
comma
r_int
id|use_sg
)paren
(brace
r_int
id|result
op_assign
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_int
id|transferred
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_char
id|string
(braket
l_int|64
)braket
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
multiline_comment|/* transfer the data */
r_if
c_cond
(paren
id|direction
op_eq
id|SCSI_DATA_WRITE
)paren
(brace
multiline_comment|/* Debug-print the first 48 bytes of the write transfer */
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
(brace
id|strcpy
c_func
(paren
id|string
comma
l_string|&quot;wr: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_logical_and
id|i
OL
l_int|48
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|string
op_plus
id|strlen
c_func
(paren
id|string
)paren
comma
l_string|&quot;%02X &quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|15
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|string
comma
l_string|&quot;wr: &quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_ne
l_int|0
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
)brace
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;SCM data %s transfer %d sg buffers %d&bslash;n&quot;
comma
(paren
id|direction
op_eq
id|SCSI_DATA_READ
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
)paren
comma
id|len
comma
id|use_sg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
id|result
op_assign
id|sddr09_raw_bulk
c_func
(paren
id|us
comma
id|direction
comma
id|data
comma
id|len
)paren
suffix:semicolon
r_else
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|data
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|use_sg
op_logical_and
id|transferred
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|result
op_assign
id|sddr09_raw_bulk
c_func
(paren
id|us
comma
id|direction
comma
id|sg
(braket
id|i
)braket
dot
id|address
comma
id|len
op_minus
id|transferred
OG
id|sg
(braket
id|i
)braket
dot
id|length
ques
c_cond
id|sg
(braket
id|i
)braket
dot
id|length
suffix:colon
id|len
op_minus
id|transferred
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
r_break
suffix:semicolon
id|transferred
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|direction
op_eq
id|SCSI_DATA_READ
)paren
(brace
multiline_comment|/* Debug-print the first 48 bytes of the read transfer */
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
(brace
id|strcpy
c_func
(paren
id|string
comma
l_string|&quot;rd: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_logical_and
id|i
OL
l_int|48
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|string
op_plus
id|strlen
c_func
(paren
id|string
)paren
comma
l_string|&quot;%02X &quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|15
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|string
comma
l_string|&quot;rd: &quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_ne
l_int|0
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
)brace
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|sddr09_read_data
r_int
id|sddr09_read_data
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|address
comma
r_int
r_int
id|sectors
comma
r_int
r_char
op_star
id|content
comma
r_int
id|use_sg
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|12
)braket
op_assign
(brace
l_int|0xe8
comma
l_int|0x20
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_struct
id|sddr09_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
r_int
id|lba
suffix:semicolon
r_int
r_int
id|pba
suffix:semicolon
r_int
r_int
id|page
suffix:semicolon
r_int
r_int
id|pages
suffix:semicolon
r_int
r_char
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|transferred
suffix:semicolon
singleline_comment|// If we&squot;re using scatter-gather, we have to create a new
singleline_comment|// buffer to read all of the data in first, since a
singleline_comment|// scatter-gather buffer could in theory start in the middle
singleline_comment|// of a page, which would be bad. A developer who wants a
singleline_comment|// challenge might want to write a limited-buffer
singleline_comment|// version of this code.
id|len
op_assign
id|sectors
op_star
id|info-&gt;pagesize
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
)paren
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|content
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|ptr
op_assign
id|buffer
suffix:semicolon
)brace
r_else
id|ptr
op_assign
id|content
suffix:semicolon
singleline_comment|// Figure out the initial LBA and page
id|pba
op_assign
id|address
op_rshift
(paren
id|info-&gt;pageshift
op_plus
id|info-&gt;blockshift
)paren
suffix:semicolon
id|lba
op_assign
id|info-&gt;pba_to_lba
(braket
id|pba
)braket
suffix:semicolon
id|page
op_assign
(paren
id|address
op_rshift
id|info-&gt;pageshift
)paren
op_amp
id|info-&gt;blockmask
suffix:semicolon
singleline_comment|// This could be made much more efficient by checking for
singleline_comment|// contiguous LBA&squot;s. Another exercise left to the student.
r_while
c_loop
(paren
id|sectors
OG
l_int|0
)paren
(brace
id|pba
op_assign
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
suffix:semicolon
singleline_comment|// Read as many sectors as possible in this block
id|pages
op_assign
id|info-&gt;blocksize
op_minus
id|page
suffix:semicolon
r_if
c_cond
(paren
id|pages
OG
id|sectors
)paren
id|pages
op_assign
id|sectors
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Read %02X pages, from PBA %04X&quot;
l_string|&quot; (LBA %04X) page %02X&bslash;n&quot;
comma
id|pages
comma
id|pba
comma
id|lba
comma
id|page
)paren
suffix:semicolon
id|address
op_assign
(paren
(paren
id|pba
op_lshift
id|info-&gt;blockshift
)paren
op_plus
id|page
)paren
op_lshift
id|info-&gt;pageshift
suffix:semicolon
singleline_comment|// Unlike in the documentation, the address is in
singleline_comment|// words of 2 bytes.
id|command
(braket
l_int|2
)braket
op_assign
id|MSB_of
c_func
(paren
id|address
op_rshift
l_int|17
)paren
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
id|LSB_of
c_func
(paren
id|address
op_rshift
l_int|17
)paren
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
id|MSB_of
c_func
(paren
(paren
id|address
op_rshift
l_int|1
)paren
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|command
(braket
l_int|5
)braket
op_assign
id|LSB_of
c_func
(paren
(paren
id|address
op_rshift
l_int|1
)paren
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|command
(braket
l_int|10
)braket
op_assign
id|MSB_of
c_func
(paren
id|pages
)paren
suffix:semicolon
id|command
(braket
l_int|11
)braket
op_assign
id|LSB_of
c_func
(paren
id|pages
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_send_control
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0
comma
l_int|0x41
comma
l_int|0
comma
l_int|0
comma
id|command
comma
l_int|12
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for send_control in read_data %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|result
op_assign
id|sddr09_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|ptr
comma
id|pages
op_lshift
id|info-&gt;pageshift
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|page
op_assign
l_int|0
suffix:semicolon
id|lba
op_increment
suffix:semicolon
id|sectors
op_sub_assign
id|pages
suffix:semicolon
id|ptr
op_add_assign
(paren
id|pages
op_lshift
id|info-&gt;pageshift
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|use_sg
)paren
(brace
id|transferred
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|use_sg
op_logical_and
id|transferred
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memcpy
c_func
(paren
id|sg
(braket
id|i
)braket
dot
id|address
comma
id|buffer
op_plus
id|transferred
comma
id|len
op_minus
id|transferred
OG
id|sg
(braket
id|i
)braket
dot
id|length
ques
c_cond
id|sg
(braket
id|i
)braket
dot
id|length
suffix:colon
id|len
op_minus
id|transferred
)paren
suffix:semicolon
id|transferred
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
DECL|function|sddr09_read_control
r_int
id|sddr09_read_control
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|address
comma
r_int
r_int
id|blocks
comma
r_int
r_char
op_star
id|content
comma
r_int
id|use_sg
)paren
(brace
singleline_comment|// Unlike in the documentation, the last two bytes are the
singleline_comment|// number of blocks, not sectors.
r_int
id|result
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|12
)braket
op_assign
(brace
l_int|0xe8
comma
l_int|0x21
comma
id|MSB_of
c_func
(paren
id|address
op_rshift
l_int|16
)paren
comma
id|LSB_of
c_func
(paren
id|address
op_rshift
l_int|16
)paren
comma
id|MSB_of
c_func
(paren
id|address
op_amp
l_int|0xFFFF
)paren
comma
id|LSB_of
c_func
(paren
id|address
op_amp
l_int|0xFFFF
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|MSB_of
c_func
(paren
id|blocks
)paren
comma
id|LSB_of
c_func
(paren
id|blocks
)paren
)brace
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Read control address %08lX blocks %04X&bslash;n&quot;
comma
id|address
comma
id|blocks
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_send_control
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0
comma
l_int|0x41
comma
l_int|0
comma
l_int|0
comma
id|command
comma
l_int|12
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for send_control in read_control %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|result
op_assign
id|sddr09_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|content
comma
id|blocks
op_lshift
l_int|6
comma
id|use_sg
)paren
suffix:semicolon
singleline_comment|// 0x40 bytes per block
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for bulk read in read_control %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|sddr09_read_deviceID
r_int
id|sddr09_read_deviceID
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|manufacturerID
comma
r_int
r_char
op_star
id|deviceID
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|12
)braket
op_assign
(brace
l_int|0xed
comma
l_int|0x20
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|content
(braket
l_int|64
)braket
suffix:semicolon
id|result
op_assign
id|sddr09_send_control
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0
comma
l_int|0x41
comma
l_int|0
comma
l_int|0
comma
id|command
comma
l_int|12
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result of send_control for device ID is %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|result
op_assign
id|sddr09_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|content
comma
l_int|64
comma
l_int|0
)paren
suffix:semicolon
op_star
id|manufacturerID
op_assign
id|content
(braket
l_int|0
)braket
suffix:semicolon
op_star
id|deviceID
op_assign
id|content
(braket
l_int|1
)braket
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|sddr09_read_status
r_int
id|sddr09_read_status
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|status
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|12
)braket
op_assign
(brace
l_int|0xec
comma
l_int|0x20
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|result
op_assign
id|sddr09_send_control
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0
comma
l_int|0x41
comma
l_int|0
comma
l_int|0
comma
id|command
comma
l_int|12
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|result
op_assign
id|sddr09_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|status
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|sddr09_reset
r_int
id|sddr09_reset
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|12
)braket
op_assign
(brace
l_int|0xeb
comma
l_int|0x20
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|result
op_assign
id|sddr09_send_control
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0
comma
l_int|0x41
comma
l_int|0
comma
l_int|0
comma
id|command
comma
l_int|12
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|sddr09_get_capacity
r_int
r_int
id|sddr09_get_capacity
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
op_star
id|pagesize
comma
r_int
r_int
op_star
id|blocksize
)paren
(brace
r_int
r_char
id|manufacturerID
suffix:semicolon
r_int
r_char
id|deviceID
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Reading capacity...&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_read_deviceID
c_func
(paren
id|us
comma
op_amp
id|manufacturerID
comma
op_amp
id|deviceID
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result of read_deviceID is %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
l_int|0
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Device ID = %02X&bslash;n&quot;
comma
id|deviceID
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Manuf  ID = %02X&bslash;n&quot;
comma
id|manufacturerID
)paren
suffix:semicolon
op_star
id|pagesize
op_assign
l_int|512
suffix:semicolon
op_star
id|blocksize
op_assign
l_int|16
suffix:semicolon
r_switch
c_cond
(paren
id|deviceID
)paren
(brace
r_case
l_int|0x6e
suffix:colon
singleline_comment|// 1MB
r_case
l_int|0xe8
suffix:colon
r_case
l_int|0xec
suffix:colon
op_star
id|pagesize
op_assign
l_int|256
suffix:semicolon
r_return
l_int|0x00100000
suffix:semicolon
r_case
l_int|0xea
suffix:colon
singleline_comment|// 2MB
r_case
l_int|0x5d
suffix:colon
singleline_comment|// 5d is a ROM card with pagesize 512.
r_case
l_int|0x64
suffix:colon
r_if
c_cond
(paren
id|deviceID
op_ne
l_int|0x5D
)paren
op_star
id|pagesize
op_assign
l_int|256
suffix:semicolon
r_return
l_int|0x00200000
suffix:semicolon
r_case
l_int|0xe3
suffix:colon
singleline_comment|// 4MB
r_case
l_int|0xe5
suffix:colon
r_case
l_int|0x6b
suffix:colon
r_case
l_int|0xd5
suffix:colon
r_return
l_int|0x00400000
suffix:semicolon
r_case
l_int|0xe6
suffix:colon
singleline_comment|// 8MB
r_case
l_int|0xd6
suffix:colon
r_return
l_int|0x00800000
suffix:semicolon
r_case
l_int|0x73
suffix:colon
singleline_comment|// 16MB
op_star
id|blocksize
op_assign
l_int|32
suffix:semicolon
r_return
l_int|0x01000000
suffix:semicolon
r_case
l_int|0x75
suffix:colon
singleline_comment|// 32MB
op_star
id|blocksize
op_assign
l_int|32
suffix:semicolon
r_return
l_int|0x02000000
suffix:semicolon
r_case
l_int|0x76
suffix:colon
singleline_comment|// 64MB
op_star
id|blocksize
op_assign
l_int|32
suffix:semicolon
r_return
l_int|0x04000000
suffix:semicolon
r_default
suffix:colon
singleline_comment|// unknown
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|sddr09_read_map
r_int
id|sddr09_read_map
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_struct
id|sddr09_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
(paren
id|us-&gt;extra
)paren
suffix:semicolon
r_int
id|numblocks
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
r_int
id|lba
suffix:semicolon
r_int
r_char
id|parity
suffix:semicolon
r_int
r_char
id|fast_parity
(braket
l_int|16
)braket
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
)brace
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|alloc_len
suffix:semicolon
r_int
id|alloc_blocks
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;capacity
)paren
r_return
op_minus
l_int|1
suffix:semicolon
singleline_comment|// read 64 (1&lt;&lt;6) bytes for every block 
singleline_comment|// ( 1 &lt;&lt; ( blockshift + pageshift ) bytes)
singleline_comment|//&t; of capacity:
singleline_comment|// (1&lt;&lt;6)*capacity/(1&lt;&lt;(b+p)) =
singleline_comment|// ((1&lt;&lt;6)*capacity)&gt;&gt;(b+p) =
singleline_comment|// capacity&gt;&gt;(b+p-6)
id|alloc_len
op_assign
id|info-&gt;capacity
op_rshift
(paren
id|info-&gt;blockshift
op_plus
id|info-&gt;pageshift
op_minus
l_int|6
)paren
suffix:semicolon
singleline_comment|// Allocate a number of scatterlist structures according to
singleline_comment|// the number of 128k blocks in the alloc_len. Adding 128k-1
singleline_comment|// and then dividing by 128k gives the correct number of blocks.
singleline_comment|// 128k = 1&lt;&lt;17
id|alloc_blocks
op_assign
(paren
id|alloc_len
op_plus
(paren
l_int|1
op_lshift
l_int|17
)paren
op_minus
l_int|1
)paren
op_rshift
l_int|17
suffix:semicolon
id|sg
op_assign
id|kmalloc
c_func
(paren
id|alloc_blocks
op_star
r_sizeof
(paren
r_struct
id|scatterlist
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sg
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|alloc_blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
id|alloc_blocks
op_minus
l_int|1
)paren
(brace
id|sg
(braket
id|i
)braket
dot
id|address
op_assign
id|kmalloc
c_func
(paren
(paren
l_int|1
op_lshift
l_int|17
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|sg
(braket
id|i
)braket
dot
id|length
op_assign
(paren
l_int|1
op_lshift
l_int|17
)paren
suffix:semicolon
)brace
r_else
(brace
id|sg
(braket
id|i
)braket
dot
id|address
op_assign
id|kmalloc
c_func
(paren
id|alloc_len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|sg
(braket
id|i
)braket
dot
id|length
op_assign
id|alloc_len
suffix:semicolon
)brace
id|alloc_len
op_sub_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|alloc_blocks
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|sg
(braket
id|i
)braket
dot
id|address
op_eq
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|alloc_blocks
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|sg
(braket
id|i
)braket
dot
id|address
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|sg
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|numblocks
op_assign
id|info-&gt;capacity
op_rshift
(paren
id|info-&gt;blockshift
op_plus
id|info-&gt;pageshift
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|sddr09_read_control
c_func
(paren
id|us
comma
l_int|0
comma
id|numblocks
comma
(paren
r_int
r_char
op_star
)paren
id|sg
comma
id|alloc_blocks
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|alloc_blocks
suffix:semicolon
id|i
op_increment
)paren
id|kfree
c_func
(paren
id|sg
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sg
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;lba_to_pba
)paren
id|kfree
c_func
(paren
id|info-&gt;lba_to_pba
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pba_to_lba
)paren
id|kfree
c_func
(paren
id|info-&gt;pba_to_lba
)paren
suffix:semicolon
id|info-&gt;lba_to_pba
op_assign
id|kmalloc
c_func
(paren
id|numblocks
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|info-&gt;pba_to_lba
op_assign
id|kmalloc
c_func
(paren
id|numblocks
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;lba_to_pba
op_eq
l_int|NULL
op_logical_or
id|info-&gt;pba_to_lba
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;lba_to_pba
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|info-&gt;lba_to_pba
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pba_to_lba
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|info-&gt;pba_to_lba
)paren
suffix:semicolon
id|info-&gt;lba_to_pba
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;pba_to_lba
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|alloc_blocks
suffix:semicolon
id|i
op_increment
)paren
id|kfree
c_func
(paren
id|sg
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|info-&gt;lba_to_pba
comma
l_int|0
comma
id|numblocks
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|info-&gt;pba_to_lba
comma
l_int|0
comma
id|numblocks
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
singleline_comment|// Each block is 64 bytes of control data, so block i is located in
singleline_comment|// scatterlist block i*64/128k = i*(2^6)*(2^-17) = i*(2^-11)
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ptr
op_assign
id|sg
(braket
id|i
op_rshift
l_int|11
)braket
dot
id|address
op_plus
(paren
id|i
op_lshift
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
(braket
l_int|0
)braket
op_ne
l_int|0xFF
op_logical_or
id|ptr
(braket
l_int|1
)braket
op_ne
l_int|0xFF
op_logical_or
id|ptr
(braket
l_int|2
)braket
op_ne
l_int|0xFF
op_logical_or
id|ptr
(braket
l_int|3
)braket
op_ne
l_int|0xFF
op_logical_or
id|ptr
(braket
l_int|4
)braket
op_ne
l_int|0xFF
op_logical_or
id|ptr
(braket
l_int|5
)braket
op_ne
l_int|0xFF
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ptr
(braket
l_int|6
)braket
op_rshift
l_int|4
)paren
op_ne
l_int|0x01
)paren
r_continue
suffix:semicolon
multiline_comment|/* ensure even parity */
id|lba
op_assign
id|short_pack
c_func
(paren
id|ptr
(braket
l_int|7
)braket
comma
id|ptr
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|parity
op_assign
l_int|1
suffix:semicolon
singleline_comment|// the parity of 0x1000
id|parity
op_xor_assign
id|fast_parity
(braket
id|lba
op_amp
l_int|0x000F
)braket
suffix:semicolon
id|parity
op_xor_assign
id|fast_parity
(braket
(paren
id|lba
op_rshift
l_int|4
)paren
op_amp
l_int|0x000F
)braket
suffix:semicolon
id|parity
op_xor_assign
id|fast_parity
(braket
(paren
id|lba
op_rshift
l_int|8
)paren
op_amp
l_int|0x000F
)braket
suffix:semicolon
r_if
c_cond
(paren
id|parity
)paren
(brace
multiline_comment|/* bad parity bit */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bad parity in LBA for block %04X&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|lba
op_assign
(paren
id|lba
op_amp
l_int|0x07FF
)paren
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/* Every 1024 physical blocks, the LBA numbers&n;&t;&t;&t; * go back to zero, but are within a higher&n;&t;&t;&t; * block of LBA&squot;s. In other words, in blocks&n;&t;&t;&t; * 1024-2047 you will find LBA 0-1023 which are&n;&t;&t;&t; * really LBA 1024-2047.&n;&t;&t;&t; */
id|lba
op_add_assign
(paren
id|i
op_amp
op_complement
l_int|0x3FF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lba
op_ge
id|numblocks
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bad LBA %04X for block %04X&bslash;n&quot;
comma
id|lba
comma
id|i
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lba
OL
l_int|0x10
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;LBA %04X &lt;-&gt; PBA %04X&bslash;n&quot;
comma
id|lba
comma
id|i
)paren
suffix:semicolon
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|lba
suffix:semicolon
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
op_assign
id|i
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|alloc_blocks
suffix:semicolon
id|i
op_increment
)paren
id|kfree
c_func
(paren
id|sg
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;static int init_sddr09(struct us_data *us) {&n;&n;&t;int result;&n;&t;unsigned char data[14];&n;&t;unsigned char command[8] = {&n;&t;&t;0xc1, 0x01, 0, 0, 0, 0, 0, 0&n;&t;};&n;&t;unsigned char command2[8] = {&n;&t;&t;0x41, 0, 0, 0, 0, 0, 0, 0&n;&t;};&n;&t;unsigned char tur[12] = {&n;&t;&t;0x03, 0x20, 0, 0, 0x0e, 0, 0, 0, 0, 0, 0, 0&n;&t;};&n;&n;&t;// What the hey is all this for? Doesn&squot;t seem to&n;&t;// affect the device, so we won&squot;t do device inits.&n;&n;&t;if ( (result = sddr09_send_control(us, command, data, 2)) !=&n;&t;&t;&t;USB_STOR_TRANSPORT_GOOD)&n;&t;&t;return result;&n;&n;&t;US_DEBUGP(&quot;SDDR09: %02X %02X&bslash;n&quot;, data[0], data[1]);&n;&n;&t;command[1] = 0x08;&n;&n;&t;if ( (result = sddr09_send_control(us, command, data, 2)) !=&n;&t;&t;&t;USB_STOR_TRANSPORT_GOOD)&n;&t;&t;return result;&n;&n;&t;US_DEBUGP(&quot;SDDR09: %02X %02X&bslash;n&quot;, data[0], data[1]);&n;&n;&t;if ( (result = sddr09_send_control(us, command2, tur, 12)) !=&n;&t;&t;&t;USB_STOR_TRANSPORT_GOOD) {&n;&t;&t;US_DEBUGP(&quot;SDDR09: request sense failed&bslash;n&quot;);&n;&t;&t;return result;&n;&t;}&n;&n;&t;if ( (result = sddr09_raw_bulk(&n;&t;&t;us, SCSI_DATA_READ, data, 14)) !=&n;&t;&t;&t;USB_STOR_TRANSPORT_GOOD) {&n;&t;&t;US_DEBUGP(&quot;SDDR09: request sense bulk in failed&bslash;n&quot;);&n;&t;&t;return result;&n;&t;}&n;&n;&t;US_DEBUGP(&quot;SDDR09: request sense worked&bslash;n&quot;);&n;&n;&t;return result;&n;}&n;*/
DECL|function|sddr09_card_info_destructor
r_void
id|sddr09_card_info_destructor
c_func
(paren
r_void
op_star
id|extra
)paren
(brace
r_struct
id|sddr09_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
id|extra
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|extra
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;lba_to_pba
)paren
id|kfree
c_func
(paren
id|info-&gt;lba_to_pba
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pba_to_lba
)paren
id|kfree
c_func
(paren
id|info-&gt;pba_to_lba
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Transport for the Sandisk SDDR-09&n; */
DECL|function|sddr09_transport
r_int
id|sddr09_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
id|string
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_char
id|inquiry_response
(braket
l_int|36
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x80
comma
l_int|0x00
comma
l_int|0x02
comma
l_int|0x1F
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_int
r_char
id|mode_page_01
(braket
l_int|4
)braket
op_assign
(brace
singleline_comment|// write-protected for now
l_int|0x03
comma
l_int|0x00
comma
l_int|0x80
comma
l_int|0x00
)brace
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
r_int
id|capacity
suffix:semicolon
r_int
r_int
id|lba
suffix:semicolon
r_int
r_int
id|pba
suffix:semicolon
r_int
r_int
id|page
suffix:semicolon
r_int
r_int
id|pages
suffix:semicolon
r_struct
id|sddr09_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
(paren
id|us-&gt;extra
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;extra
)paren
(brace
id|us-&gt;extra
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sddr09_card_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;extra
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|memset
c_func
(paren
id|us-&gt;extra
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sddr09_card_info
)paren
)paren
suffix:semicolon
id|us-&gt;extra_destructor
op_assign
id|sddr09_card_info_destructor
suffix:semicolon
)brace
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
id|srb-&gt;request_buffer
suffix:semicolon
multiline_comment|/* Dummy up a response for INQUIRY since SDDR09 doesn&squot;t&n;&t;   respond to INQUIRY commands */
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
(brace
id|memset
c_func
(paren
id|inquiry_response
op_plus
l_int|8
comma
l_int|0
comma
l_int|28
)paren
suffix:semicolon
id|fill_inquiry_response
c_func
(paren
id|us
comma
id|inquiry_response
comma
l_int|36
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_CAPACITY
)paren
(brace
id|capacity
op_assign
id|sddr09_get_capacity
c_func
(paren
id|us
comma
op_amp
id|info-&gt;pagesize
comma
op_amp
id|info-&gt;blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capacity
)paren
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
id|info-&gt;capacity
op_assign
id|capacity
suffix:semicolon
r_for
c_loop
(paren
id|info-&gt;pageshift
op_assign
l_int|1
suffix:semicolon
(paren
id|info-&gt;pagesize
op_rshift
id|info-&gt;pageshift
)paren
suffix:semicolon
id|info-&gt;pageshift
op_increment
)paren
suffix:semicolon
id|info-&gt;pageshift
op_decrement
suffix:semicolon
r_for
c_loop
(paren
id|info-&gt;blockshift
op_assign
l_int|1
suffix:semicolon
(paren
id|info-&gt;blocksize
op_rshift
id|info-&gt;blockshift
)paren
suffix:semicolon
id|info-&gt;blockshift
op_increment
)paren
suffix:semicolon
id|info-&gt;blockshift
op_decrement
suffix:semicolon
id|info-&gt;blockmask
op_assign
(paren
l_int|1
op_lshift
id|info-&gt;blockshift
)paren
op_minus
l_int|1
suffix:semicolon
singleline_comment|// Last page in the card
id|capacity
op_div_assign
id|info-&gt;pagesize
suffix:semicolon
id|capacity
op_decrement
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
id|MSB_of
c_func
(paren
id|capacity
op_rshift
l_int|16
)paren
suffix:semicolon
id|ptr
(braket
l_int|1
)braket
op_assign
id|LSB_of
c_func
(paren
id|capacity
op_rshift
l_int|16
)paren
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
id|MSB_of
c_func
(paren
id|capacity
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
id|LSB_of
c_func
(paren
id|capacity
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
singleline_comment|// The page size
id|ptr
(braket
l_int|4
)braket
op_assign
id|MSB_of
c_func
(paren
id|info-&gt;pagesize
op_rshift
l_int|16
)paren
suffix:semicolon
id|ptr
(braket
l_int|5
)braket
op_assign
id|LSB_of
c_func
(paren
id|info-&gt;pagesize
op_rshift
l_int|16
)paren
suffix:semicolon
id|ptr
(braket
l_int|6
)braket
op_assign
id|MSB_of
c_func
(paren
id|info-&gt;pagesize
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|ptr
(braket
l_int|7
)braket
op_assign
id|LSB_of
c_func
(paren
id|info-&gt;pagesize
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|sddr09_read_map
c_func
(paren
id|us
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE
)paren
(brace
singleline_comment|// Read-write error recovery page: there needs to
singleline_comment|// be a check for write-protect here
r_if
c_cond
(paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_amp
l_int|0x3F
)paren
op_eq
l_int|0x01
)paren
(brace
r_if
c_cond
(paren
id|ptr
op_eq
l_int|NULL
op_logical_or
id|srb-&gt;request_bufflen
OL
l_int|4
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_page_01
comma
r_sizeof
(paren
id|mode_page_01
)paren
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
singleline_comment|// FIXME: sense buffer?
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_10
)paren
(brace
id|page
op_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|page
op_lshift_assign
l_int|16
suffix:semicolon
id|page
op_or_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|pages
op_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
suffix:semicolon
singleline_comment|// convert page to block and page-within-block
id|lba
op_assign
id|page
op_rshift
id|info-&gt;blockshift
suffix:semicolon
id|page
op_assign
id|page
op_amp
id|info-&gt;blockmask
suffix:semicolon
singleline_comment|// locate physical block corresponding to logical block
r_if
c_cond
(paren
id|lba
op_ge
(paren
id|info-&gt;capacity
op_rshift
(paren
id|info-&gt;pageshift
op_plus
id|info-&gt;blockshift
)paren
)paren
)paren
(brace
singleline_comment|// FIXME: sense buffer?
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
id|pba
op_assign
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
suffix:semicolon
singleline_comment|// if pba is 0, either it&squot;s really 0, in which case
singleline_comment|// the pba-to-lba map for pba 0 will be the lba,
singleline_comment|// or that lba doesn&squot;t exist.
r_if
c_cond
(paren
id|pba
op_eq
l_int|0
op_logical_and
id|info-&gt;pba_to_lba
(braket
l_int|0
)braket
op_ne
id|lba
)paren
(brace
singleline_comment|// FIXME: sense buffer?
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;READ_10: read block %04X (LBA %04X) page %01X&quot;
l_string|&quot; pages %d&bslash;n&quot;
comma
id|pba
comma
id|lba
comma
id|page
comma
id|pages
)paren
suffix:semicolon
r_return
id|sddr09_read_data
c_func
(paren
id|us
comma
(paren
(paren
id|pba
op_lshift
id|info-&gt;blockshift
)paren
op_plus
id|page
)paren
op_lshift
id|info-&gt;pageshift
comma
id|pages
comma
id|ptr
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
)brace
singleline_comment|// Pass TEST_UNIT_READY and REQUEST_SENSE through
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|TEST_UNIT_READY
op_logical_and
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|REQUEST_SENSE
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
singleline_comment|// FIXME: sense buffer?
r_for
c_loop
(paren
suffix:semicolon
id|srb-&gt;cmd_len
OL
l_int|12
suffix:semicolon
id|srb-&gt;cmd_len
op_increment
)paren
id|srb-&gt;cmnd
(braket
id|srb-&gt;cmd_len
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_assign
l_int|0x20
suffix:semicolon
id|string
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|12
suffix:semicolon
id|i
op_increment
)paren
id|sprintf
c_func
(paren
id|string
op_plus
id|strlen
c_func
(paren
id|string
)paren
comma
l_string|&quot;%02X &quot;
comma
id|srb-&gt;cmnd
(braket
id|i
)braket
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR09: Send control for command %s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|sddr09_send_control
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0
comma
l_int|0x41
comma
l_int|0
comma
l_int|0
comma
id|srb-&gt;cmnd
comma
l_int|12
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR09: Control for command OK&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;request_bufflen
op_eq
l_int|0
)paren
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_WRITE
op_logical_or
id|srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_READ
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR09: %s %d bytes&bslash;n&quot;
comma
id|srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_WRITE
ques
c_cond
l_string|&quot;sending&quot;
suffix:colon
l_string|&quot;receiving&quot;
comma
id|srb-&gt;request_bufflen
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_bulk_transport
c_func
(paren
id|us
comma
id|srb-&gt;sc_data_direction
comma
id|srb-&gt;request_buffer
comma
id|srb-&gt;request_bufflen
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
eof
