multiline_comment|/* Driver for USB Mass Storage compliant devices&n; * SCSI layer glue code&n; *&n; * $Id: scsiglue.c,v 1.19 2000/11/13 22:28:55 mdharm Exp $&n; *&n; * Current development and maintenance by:&n; *   (c) 1999, 2000 Matthew Dharm (mdharm-usb@one-eyed-alien.net)&n; *&n; * Developed with the assistance of:&n; *   (c) 2000 David L. Brown, Jr. (usb-storage@davidb.org)&n; *   (c) 2000 Stephen J. Gowdy (SGowdy@lbl.gov)&n; *&n; * Initial work by:&n; *   (c) 1999 Michael Gee (michael@linuxspecific.com)&n; *&n; * This driver is based on the &squot;USB Mass Storage Class&squot; document. This&n; * describes in detail the protocol used to communicate with such&n; * devices.  Clearly, the designers had SCSI and ATAPI commands in&n; * mind when they created this document.  The commands are all very&n; * similar to commands in the SCSI-II and ATAPI specifications.&n; *&n; * It is important to note that in a number of cases this class&n; * exhibits class-specific exemptions from the USB specification.&n; * Notably the usage of NAK, STALL and ACK differs from the norm, in&n; * that they are used to communicate wait, failed and OK on commands.&n; *&n; * Also, for certain devices, the interrupt endpoint is used to convey&n; * status of a command.&n; *&n; * Please see http://www.one-eyed-alien.net/~mdharm/linux-usb for more&n; * information about this driver.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &quot;scsiglue.h&quot;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;transport.h&quot;
macro_line|#include &lt;linux/malloc.h&gt;
multiline_comment|/*&n; * kernel thread actions&n; */
DECL|macro|US_ACT_COMMAND
mdefine_line|#define US_ACT_COMMAND&t;&t;1
DECL|macro|US_ACT_DEVICE_RESET
mdefine_line|#define US_ACT_DEVICE_RESET&t;2
DECL|macro|US_ACT_BUS_RESET
mdefine_line|#define US_ACT_BUS_RESET&t;3
DECL|macro|US_ACT_HOST_RESET
mdefine_line|#define US_ACT_HOST_RESET&t;4
DECL|macro|US_ACT_EXIT
mdefine_line|#define US_ACT_EXIT&t;&t;5
multiline_comment|/***********************************************************************&n; * Host functions &n; ***********************************************************************/
DECL|function|host_info
r_static
r_const
r_char
op_star
id|host_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_return
l_string|&quot;SCSI emulation for USB Mass Storage devices&quot;
suffix:semicolon
)brace
multiline_comment|/* detect a virtual adapter (always works) */
DECL|function|detect
r_static
r_int
id|detect
c_func
(paren
r_struct
id|SHT
op_star
id|sht
)paren
(brace
r_struct
id|us_data
op_star
id|us
suffix:semicolon
r_char
id|local_name
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/* This is not nice at all, but how else are we to get the&n;&t; * data here? */
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|sht-&gt;proc_dir
suffix:semicolon
multiline_comment|/* set up the name of our subdirectory under /proc/scsi/ */
id|sprintf
c_func
(paren
id|local_name
comma
l_string|&quot;usb-storage-%d&quot;
comma
id|us-&gt;host_number
)paren
suffix:semicolon
id|sht-&gt;proc_name
op_assign
id|kmalloc
(paren
id|strlen
c_func
(paren
id|local_name
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sht-&gt;proc_name
)paren
r_return
l_int|0
suffix:semicolon
id|strcpy
c_func
(paren
id|sht-&gt;proc_name
comma
id|local_name
)paren
suffix:semicolon
multiline_comment|/* we start with no /proc directory entry */
id|sht-&gt;proc_dir
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* register the host */
id|us-&gt;host
op_assign
id|scsi_register
c_func
(paren
id|sht
comma
r_sizeof
(paren
id|us
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;host
)paren
(brace
id|us-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_int
)paren
id|us
suffix:semicolon
id|us-&gt;host_no
op_assign
id|us-&gt;host-&gt;host_no
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* odd... didn&squot;t register properly.  Abort and free pointers */
id|kfree
c_func
(paren
id|sht-&gt;proc_name
)paren
suffix:semicolon
id|sht-&gt;proc_name
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Release all resources used by the virtual host&n; *&n; * NOTE: There is no contention here, because we&squot;re already deregistered&n; * the driver and we&squot;re doing each virtual host in turn, not in parallel&n; */
DECL|function|release
r_static
r_int
id|release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|psh
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|psh-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;release() called for host %s&bslash;n&quot;
comma
id|us-&gt;htmplt.name
)paren
suffix:semicolon
multiline_comment|/* Kill the control threads&n;&t; *&n;&t; * Enqueue the command, wake up the thread, and wait for &n;&t; * notification that it&squot;s exited.&n;&t; */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- sending US_ACT_EXIT command to thread&bslash;n&quot;
)paren
suffix:semicolon
id|us-&gt;action
op_assign
id|US_ACT_EXIT
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
(paren
id|us-&gt;wqh
)paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
multiline_comment|/* remove the pointer to the data structure we were using */
(paren
r_struct
id|us_data
op_star
)paren
id|psh-&gt;hostdata
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* we always have a successful release */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* run command */
DECL|function|command
r_static
r_int
id|command
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bad use of us_command&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
)brace
multiline_comment|/* run command */
DECL|function|queuecommand
r_static
r_int
id|queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|srb-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;queuecommand() called&bslash;n&quot;
)paren
suffix:semicolon
id|srb-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|us
suffix:semicolon
multiline_comment|/* get exclusive access to the structures we want */
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;queue_exclusion
)paren
)paren
suffix:semicolon
multiline_comment|/* enqueue the command */
id|us-&gt;queue_srb
op_assign
id|srb
suffix:semicolon
id|srb-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|us-&gt;action
op_assign
id|US_ACT_COMMAND
suffix:semicolon
multiline_comment|/* release the lock on the structure */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;queue_exclusion
)paren
)paren
suffix:semicolon
multiline_comment|/* wake up the process task */
id|wake_up
c_func
(paren
op_amp
(paren
id|us-&gt;wqh
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Error handling functions&n; ***********************************************************************/
multiline_comment|/* Command abort */
DECL|function|command_abort
r_static
r_int
id|command_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|srb-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;command_abort() called&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* if we&squot;re stuck waiting for an IRQ, simulate it */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
id|us-&gt;ip_wanted
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- simulating missing IRQ&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;ip_waitq
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if the device has been removed, this worked */
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;pusb_dev
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- device removed already&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
multiline_comment|/* if we have an urb pending, let&squot;s wake the control thread up */
r_if
c_cond
(paren
id|us-&gt;current_urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
multiline_comment|/* cancel the URB -- this will automatically wake the thread */
id|usb_unlink_urb
c_func
(paren
id|us-&gt;current_urb
)paren
suffix:semicolon
multiline_comment|/* wait for us to be done */
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
id|US_DEBUGP
(paren
l_string|&quot;-- nothing to abort&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/* This invokes the transport reset mechanism to reset the state of the&n; * device */
DECL|function|device_reset
r_static
r_int
id|device_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|srb-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;device_reset() called&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|us
op_member_access_from_pointer
id|transport_reset
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
multiline_comment|/* This resets the device port, and simulates the device&n; * disconnect/reconnect for all drivers which have claimed other&n; * interfaces. */
DECL|function|bus_reset
r_static
r_int
id|bus_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|srb-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* we use the usb_reset_device() function to handle this for us */
id|US_DEBUGP
c_func
(paren
l_string|&quot;bus_reset() called&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* if the device has been removed, this worked */
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;pusb_dev
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- device removed already&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
multiline_comment|/* release the IRQ, if we have one */
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;irq_urb
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- releasing irq URB&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_unlink_urb
c_func
(paren
id|us-&gt;irq_urb
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- usb_unlink_urb() returned %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
multiline_comment|/* attempt to reset the port */
r_if
c_cond
(paren
id|usb_reset_device
c_func
(paren
id|us-&gt;pusb_dev
)paren
OL
l_int|0
)paren
r_return
id|FAILED
suffix:semicolon
multiline_comment|/* FIXME: This needs to lock out driver probing while it&squot;s working&n;&t; * or we can have race conditions */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|us-&gt;pusb_dev-&gt;actconfig-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_interface
op_star
id|intf
op_assign
op_amp
id|us-&gt;pusb_dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
suffix:semicolon
r_const
r_struct
id|usb_device_id
op_star
id|id
suffix:semicolon
multiline_comment|/* if this is an unclaimed interface, skip it */
r_if
c_cond
(paren
op_logical_neg
id|intf-&gt;driver
)paren
(brace
r_continue
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Examinging driver %s...&quot;
comma
id|intf-&gt;driver-&gt;name
)paren
suffix:semicolon
multiline_comment|/* skip interfaces which we&squot;ve claimed */
r_if
c_cond
(paren
id|intf-&gt;driver
op_eq
op_amp
id|usb_storage_driver
)paren
(brace
id|US_DEBUGPX
c_func
(paren
l_string|&quot;skipping ourselves.&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* simulate a disconnect and reconnect for all interfaces */
id|US_DEBUGPX
c_func
(paren
l_string|&quot;simulating disconnect/reconnect.&bslash;n&quot;
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|intf-&gt;driver-&gt;serialize
)paren
suffix:semicolon
id|intf-&gt;driver
op_member_access_from_pointer
id|disconnect
c_func
(paren
id|us-&gt;pusb_dev
comma
id|intf-&gt;private_data
)paren
suffix:semicolon
id|id
op_assign
id|usb_match_id
c_func
(paren
id|us-&gt;pusb_dev
comma
id|intf
comma
id|intf-&gt;driver-&gt;id_table
)paren
suffix:semicolon
id|intf-&gt;driver
op_member_access_from_pointer
id|probe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|i
comma
id|id
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|intf-&gt;driver-&gt;serialize
)paren
suffix:semicolon
)brace
multiline_comment|/* re-allocate the IRQ URB and submit it to restore connectivity&n;&t; * for CBI devices&n;&t; */
r_if
c_cond
(paren
id|us-&gt;protocol
op_eq
id|US_PR_CBI
)paren
(brace
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
id|us-&gt;irq_urb-&gt;dev
op_assign
id|us-&gt;pusb_dev
suffix:semicolon
id|result
op_assign
id|usb_submit_urb
c_func
(paren
id|us-&gt;irq_urb
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_submit_urb() returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;bus_reset() complete&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
multiline_comment|/* FIXME: This doesn&squot;t do anything right now */
DECL|function|host_reset
r_static
r_int
id|host_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;usb-storage: host_reset() requested but not implemented&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * /proc/scsi/ functions&n; ***********************************************************************/
multiline_comment|/* we use this macro to help us write into the buffer */
DECL|macro|SPRINTF
macro_line|#undef SPRINTF
DECL|macro|SPRINTF
mdefine_line|#define SPRINTF(args...) &bslash;&n;&t;do { if (pos &lt; buffer+length) pos += sprintf(pos, ## args); } while (0)
DECL|function|proc_info
r_static
r_int
id|proc_info
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
r_struct
id|us_data
op_star
id|us
suffix:semicolon
r_char
op_star
id|pos
op_assign
id|buffer
suffix:semicolon
multiline_comment|/* if someone is sending us data, just throw it away */
r_if
c_cond
(paren
id|inout
)paren
r_return
id|length
suffix:semicolon
multiline_comment|/* lock the data structures */
id|down
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
multiline_comment|/* find our data from hostno */
id|us
op_assign
id|us_list
suffix:semicolon
r_while
c_loop
(paren
id|us
)paren
(brace
r_if
c_cond
(paren
id|us-&gt;host_no
op_eq
id|hostno
)paren
r_break
suffix:semicolon
id|us
op_assign
id|us-&gt;next
suffix:semicolon
)brace
multiline_comment|/* release our lock on the data structures */
id|up
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
multiline_comment|/* if we couldn&squot;t find it, we return an error */
r_if
c_cond
(paren
op_logical_neg
id|us
)paren
(brace
r_return
op_minus
id|ESRCH
suffix:semicolon
)brace
multiline_comment|/* print the controler name */
id|SPRINTF
c_func
(paren
l_string|&quot;   Host scsi%d: usb-storage&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
multiline_comment|/* print product, vendor, and serial number strings */
id|SPRINTF
c_func
(paren
l_string|&quot;       Vendor: %s&bslash;n&quot;
comma
id|us-&gt;vendor
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;      Product: %s&bslash;n&quot;
comma
id|us-&gt;product
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;Serial Number: %s&bslash;n&quot;
comma
id|us-&gt;serial
)paren
suffix:semicolon
multiline_comment|/* show the protocol and transport */
id|SPRINTF
c_func
(paren
l_string|&quot;     Protocol: %s&bslash;n&quot;
comma
id|us-&gt;protocol_name
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;    Transport: %s&bslash;n&quot;
comma
id|us-&gt;transport_name
)paren
suffix:semicolon
multiline_comment|/* show the GUID of the device */
id|SPRINTF
c_func
(paren
l_string|&quot;         GUID: &quot;
id|GUID_FORMAT
l_string|&quot;&bslash;n&quot;
comma
id|GUID_ARGS
c_func
(paren
id|us-&gt;guid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate start of next buffer, and return value.&n;&t; */
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pos
op_minus
id|buffer
)paren
OL
id|offset
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|pos
op_minus
id|buffer
op_minus
id|offset
)paren
OL
id|length
)paren
r_return
(paren
id|pos
op_minus
id|buffer
op_minus
id|offset
)paren
suffix:semicolon
r_else
r_return
(paren
id|length
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * this defines our &squot;host&squot;&n; */
DECL|variable|usb_stor_host_template
id|Scsi_Host_Template
id|usb_stor_host_template
op_assign
(brace
id|name
suffix:colon
l_string|&quot;usb-storage&quot;
comma
id|proc_info
suffix:colon
id|proc_info
comma
id|info
suffix:colon
id|host_info
comma
id|detect
suffix:colon
id|detect
comma
id|release
suffix:colon
id|release
comma
id|command
suffix:colon
id|command
comma
id|queuecommand
suffix:colon
id|queuecommand
comma
id|eh_abort_handler
suffix:colon
id|command_abort
comma
id|eh_device_reset_handler
suffix:colon
id|device_reset
comma
id|eh_bus_reset_handler
suffix:colon
id|bus_reset
comma
id|eh_host_reset_handler
suffix:colon
id|host_reset
comma
id|can_queue
suffix:colon
l_int|1
comma
id|this_id
suffix:colon
op_minus
l_int|1
comma
id|sg_tablesize
suffix:colon
id|SG_ALL
comma
id|cmd_per_lun
suffix:colon
l_int|1
comma
id|present
suffix:colon
l_int|0
comma
id|unchecked_isa_dma
suffix:colon
id|FALSE
comma
id|use_clustering
suffix:colon
id|TRUE
comma
id|use_new_eh_code
suffix:colon
id|TRUE
comma
id|emulated
suffix:colon
id|TRUE
)brace
suffix:semicolon
DECL|variable|usb_stor_sense_notready
r_int
r_char
id|usb_stor_sense_notready
(braket
l_int|18
)braket
op_assign
(brace
(braket
l_int|0
)braket
op_assign
l_int|0x70
comma
multiline_comment|/* current error */
(braket
l_int|2
)braket
op_assign
l_int|0x02
comma
multiline_comment|/* not ready */
(braket
l_int|5
)braket
op_assign
l_int|0x0a
comma
multiline_comment|/* additional length */
(braket
l_int|10
)braket
op_assign
l_int|0x04
comma
multiline_comment|/* not ready */
(braket
l_int|11
)braket
op_assign
l_int|0x03
multiline_comment|/* manual intervention */
)brace
suffix:semicolon
DECL|macro|USB_STOR_SCSI_SENSE_HDRSZ
mdefine_line|#define USB_STOR_SCSI_SENSE_HDRSZ 4
DECL|macro|USB_STOR_SCSI_SENSE_10_HDRSZ
mdefine_line|#define USB_STOR_SCSI_SENSE_10_HDRSZ 8
DECL|struct|usb_stor_scsi_sense_hdr
r_struct
id|usb_stor_scsi_sense_hdr
(brace
DECL|member|dataLength
id|__u8
op_star
id|dataLength
suffix:semicolon
DECL|member|mediumType
id|__u8
op_star
id|mediumType
suffix:semicolon
DECL|member|devSpecParms
id|__u8
op_star
id|devSpecParms
suffix:semicolon
DECL|member|blkDescLength
id|__u8
op_star
id|blkDescLength
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|Usb_Stor_Scsi_Sense_Hdr
r_typedef
r_struct
id|usb_stor_scsi_sense_hdr
id|Usb_Stor_Scsi_Sense_Hdr
suffix:semicolon
DECL|union|usb_stor_scsi_sense_hdr_u
r_union
id|usb_stor_scsi_sense_hdr_u
(brace
DECL|member|hdr
id|Usb_Stor_Scsi_Sense_Hdr
id|hdr
suffix:semicolon
DECL|member|array
id|__u8
op_star
id|array
(braket
id|USB_STOR_SCSI_SENSE_HDRSZ
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|Usb_Stor_Scsi_Sense_Hdr_u
r_typedef
r_union
id|usb_stor_scsi_sense_hdr_u
id|Usb_Stor_Scsi_Sense_Hdr_u
suffix:semicolon
DECL|struct|usb_stor_scsi_sense_hdr_10
r_struct
id|usb_stor_scsi_sense_hdr_10
(brace
DECL|member|dataLengthMSB
id|__u8
op_star
id|dataLengthMSB
suffix:semicolon
DECL|member|dataLengthLSB
id|__u8
op_star
id|dataLengthLSB
suffix:semicolon
DECL|member|mediumType
id|__u8
op_star
id|mediumType
suffix:semicolon
DECL|member|devSpecParms
id|__u8
op_star
id|devSpecParms
suffix:semicolon
DECL|member|reserved1
id|__u8
op_star
id|reserved1
suffix:semicolon
DECL|member|reserved2
id|__u8
op_star
id|reserved2
suffix:semicolon
DECL|member|blkDescLengthMSB
id|__u8
op_star
id|blkDescLengthMSB
suffix:semicolon
DECL|member|blkDescLengthLSB
id|__u8
op_star
id|blkDescLengthLSB
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|Usb_Stor_Scsi_Sense_Hdr_10
r_typedef
r_struct
id|usb_stor_scsi_sense_hdr_10
id|Usb_Stor_Scsi_Sense_Hdr_10
suffix:semicolon
DECL|union|usb_stor_scsi_sense_hdr_10_u
r_union
id|usb_stor_scsi_sense_hdr_10_u
(brace
DECL|member|hdr
id|Usb_Stor_Scsi_Sense_Hdr_10
id|hdr
suffix:semicolon
DECL|member|array
id|__u8
op_star
id|array
(braket
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|Usb_Stor_Scsi_Sense_Hdr_10_u
r_typedef
r_union
id|usb_stor_scsi_sense_hdr_10_u
id|Usb_Stor_Scsi_Sense_Hdr_10_u
suffix:semicolon
r_void
id|usb_stor_scsiSenseParseBuffer
c_func
(paren
id|Scsi_Cmnd
op_star
comma
id|Usb_Stor_Scsi_Sense_Hdr_u
op_star
comma
id|Usb_Stor_Scsi_Sense_Hdr_10_u
op_star
comma
r_int
op_star
)paren
suffix:semicolon
DECL|function|usb_stor_scsiSense10to6
r_int
id|usb_stor_scsiSense10to6
c_func
(paren
id|Scsi_Cmnd
op_star
id|the10
)paren
(brace
id|__u8
op_star
id|buffer
op_assign
l_int|0
suffix:semicolon
r_int
id|outputBufferSize
op_assign
l_int|0
suffix:semicolon
r_int
id|length
op_assign
l_int|0
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
comma
id|element
op_assign
l_int|0
suffix:semicolon
id|Usb_Stor_Scsi_Sense_Hdr_u
id|the6Locations
suffix:semicolon
id|Usb_Stor_Scsi_Sense_Hdr_10_u
id|the10Locations
suffix:semicolon
r_int
id|sb
op_assign
l_int|0
comma
id|si
op_assign
l_int|0
comma
id|db
op_assign
l_int|0
comma
id|di
op_assign
l_int|0
suffix:semicolon
r_int
id|sgLength
op_assign
l_int|0
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- converting 10 byte sense data to 6 byte&bslash;n&quot;
)paren
suffix:semicolon
id|the10-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|the10-&gt;cmnd
(braket
l_int|0
)braket
op_amp
l_int|0xBF
suffix:semicolon
multiline_comment|/* Determine buffer locations */
id|usb_stor_scsiSenseParseBuffer
c_func
(paren
id|the10
comma
op_amp
id|the6Locations
comma
op_amp
id|the10Locations
comma
op_amp
id|length
)paren
suffix:semicolon
multiline_comment|/* Work out minimum buffer to output */
id|outputBufferSize
op_assign
op_star
id|the10Locations.hdr.dataLengthLSB
suffix:semicolon
id|outputBufferSize
op_add_assign
id|USB_STOR_SCSI_SENSE_HDRSZ
suffix:semicolon
multiline_comment|/* Check to see if we need to trucate the output */
r_if
c_cond
(paren
id|outputBufferSize
OG
id|length
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Had to truncate MODE_SENSE_10 buffer into MODE_SENSE.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;outputBufferSize is %d and length is %d.&bslash;n&quot;
comma
id|outputBufferSize
comma
id|length
)paren
suffix:semicolon
)brace
id|outputBufferSize
op_assign
id|length
suffix:semicolon
multiline_comment|/* Data length */
r_if
c_cond
(paren
op_star
id|the10Locations.hdr.dataLengthMSB
op_ne
l_int|0
)paren
multiline_comment|/* MSB must be zero */
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Command will be truncated to fit in SENSE6 buffer.&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|the6Locations.hdr.dataLength
op_assign
l_int|0xff
suffix:semicolon
)brace
r_else
(brace
op_star
id|the6Locations.hdr.dataLength
op_assign
op_star
id|the10Locations.hdr.dataLengthLSB
suffix:semicolon
)brace
multiline_comment|/* Medium type and DevSpecific parms */
op_star
id|the6Locations.hdr.mediumType
op_assign
op_star
id|the10Locations.hdr.mediumType
suffix:semicolon
op_star
id|the6Locations.hdr.devSpecParms
op_assign
op_star
id|the10Locations.hdr.devSpecParms
suffix:semicolon
multiline_comment|/* Block descriptor length */
r_if
c_cond
(paren
op_star
id|the10Locations.hdr.blkDescLengthMSB
op_ne
l_int|0
)paren
multiline_comment|/* MSB must be zero */
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Command will be truncated to fit in SENSE6 buffer.&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|the6Locations.hdr.blkDescLength
op_assign
l_int|0xff
suffix:semicolon
)brace
r_else
(brace
op_star
id|the6Locations.hdr.blkDescLength
op_assign
op_star
id|the10Locations.hdr.blkDescLengthLSB
suffix:semicolon
)brace
r_if
c_cond
(paren
id|the10-&gt;use_sg
op_eq
l_int|0
)paren
(brace
id|buffer
op_assign
id|the10-&gt;request_buffer
suffix:semicolon
multiline_comment|/* Copy the rest of the data */
id|memmove
c_func
(paren
op_amp
(paren
id|buffer
(braket
id|USB_STOR_SCSI_SENSE_HDRSZ
)braket
)paren
comma
op_amp
(paren
id|buffer
(braket
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)braket
)paren
comma
id|outputBufferSize
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
suffix:semicolon
multiline_comment|/* initialise last bytes left in buffer due to smaller header */
id|memset
c_func
(paren
op_amp
(paren
id|buffer
(braket
id|outputBufferSize
op_minus
(paren
id|USB_STOR_SCSI_SENSE_10_HDRSZ
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
)braket
)paren
comma
l_int|0
comma
id|USB_STOR_SCSI_SENSE_10_HDRSZ
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
suffix:semicolon
)brace
r_else
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|the10-&gt;request_buffer
suffix:semicolon
multiline_comment|/* scan through this scatterlist and figure out starting positions */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|the10-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sgLength
op_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sgLength
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* get to end of header */
r_if
c_cond
(paren
id|element
op_eq
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
(brace
id|db
op_assign
id|i
suffix:semicolon
id|di
op_assign
id|j
suffix:semicolon
)brace
r_if
c_cond
(paren
id|element
op_eq
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)paren
(brace
id|sb
op_assign
id|i
suffix:semicolon
id|si
op_assign
id|j
suffix:semicolon
multiline_comment|/* we&squot;ve found both sets now, exit loops */
id|j
op_assign
id|sgLength
suffix:semicolon
id|i
op_assign
id|the10-&gt;use_sg
suffix:semicolon
)brace
id|element
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Now we know where to start the copy from */
id|element
op_assign
id|USB_STOR_SCSI_SENSE_HDRSZ
suffix:semicolon
r_while
c_loop
(paren
id|element
OL
id|outputBufferSize
op_minus
(paren
id|USB_STOR_SCSI_SENSE_10_HDRSZ
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
)paren
(brace
multiline_comment|/* check limits */
r_if
c_cond
(paren
id|sb
op_ge
id|the10-&gt;use_sg
op_logical_or
id|si
op_ge
id|sg
(braket
id|sb
)braket
dot
id|length
op_logical_or
id|db
op_ge
id|the10-&gt;use_sg
op_logical_or
id|di
op_ge
id|sg
(braket
id|db
)braket
dot
id|length
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|USB_STORAGE
l_string|&quot;Buffer overrun averted, this shouldn&squot;t happen!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* copy one byte */
id|sg
(braket
id|db
)braket
dot
id|address
(braket
id|di
)braket
op_assign
id|sg
(braket
id|sb
)braket
dot
id|address
(braket
id|si
)braket
suffix:semicolon
multiline_comment|/* get next destination */
r_if
c_cond
(paren
id|sg
(braket
id|db
)braket
dot
id|length
op_minus
l_int|1
op_eq
id|di
)paren
(brace
id|db
op_increment
suffix:semicolon
id|di
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|di
op_increment
suffix:semicolon
)brace
multiline_comment|/* get next source */
r_if
c_cond
(paren
id|sg
(braket
id|sb
)braket
dot
id|length
op_minus
l_int|1
op_eq
id|si
)paren
(brace
id|sb
op_increment
suffix:semicolon
id|si
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|si
op_increment
suffix:semicolon
)brace
id|element
op_increment
suffix:semicolon
)brace
multiline_comment|/* zero the remaining bytes */
r_while
c_loop
(paren
id|element
OL
id|outputBufferSize
)paren
(brace
multiline_comment|/* check limits */
r_if
c_cond
(paren
id|db
op_ge
id|the10-&gt;use_sg
op_logical_or
id|di
op_ge
id|sg
(braket
id|db
)braket
dot
id|length
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|USB_STORAGE
l_string|&quot;Buffer overrun averted, this shouldn&squot;t happen!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sg
(braket
id|db
)braket
dot
id|address
(braket
id|di
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* get next destination */
r_if
c_cond
(paren
id|sg
(braket
id|db
)braket
dot
id|length
op_minus
l_int|1
op_eq
id|di
)paren
(brace
id|db
op_increment
suffix:semicolon
id|di
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|di
op_increment
suffix:semicolon
)brace
id|element
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* All done any everything was fine */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_stor_scsiSense6to10
r_int
id|usb_stor_scsiSense6to10
c_func
(paren
id|Scsi_Cmnd
op_star
id|the6
)paren
(brace
multiline_comment|/* will be used to store part of buffer */
id|__u8
id|tempBuffer
(braket
id|USB_STOR_SCSI_SENSE_10_HDRSZ
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)braket
comma
op_star
id|buffer
op_assign
l_int|0
suffix:semicolon
r_int
id|outputBufferSize
op_assign
l_int|0
suffix:semicolon
r_int
id|length
op_assign
l_int|0
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
comma
id|element
op_assign
l_int|0
suffix:semicolon
id|Usb_Stor_Scsi_Sense_Hdr_u
id|the6Locations
suffix:semicolon
id|Usb_Stor_Scsi_Sense_Hdr_10_u
id|the10Locations
suffix:semicolon
r_int
id|sb
op_assign
l_int|0
comma
id|si
op_assign
l_int|0
comma
id|db
op_assign
l_int|0
comma
id|di
op_assign
l_int|0
suffix:semicolon
r_int
id|lsb
op_assign
l_int|0
comma
id|lsi
op_assign
l_int|0
comma
id|ldb
op_assign
l_int|0
comma
id|ldi
op_assign
l_int|0
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- converting 6 byte sense data to 10 byte&bslash;n&quot;
)paren
suffix:semicolon
id|the6-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|the6-&gt;cmnd
(braket
l_int|0
)braket
op_or
l_int|0x40
suffix:semicolon
multiline_comment|/* Determine buffer locations */
id|usb_stor_scsiSenseParseBuffer
c_func
(paren
id|the6
comma
op_amp
id|the6Locations
comma
op_amp
id|the10Locations
comma
op_amp
id|length
)paren
suffix:semicolon
multiline_comment|/* Work out minimum buffer to output */
id|outputBufferSize
op_assign
op_star
id|the6Locations.hdr.dataLength
suffix:semicolon
id|outputBufferSize
op_add_assign
id|USB_STOR_SCSI_SENSE_10_HDRSZ
suffix:semicolon
multiline_comment|/* Check to see if we need to trucate the output */
r_if
c_cond
(paren
id|outputBufferSize
OG
id|length
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Had to truncate MODE_SENSE into MODE_SENSE_10 buffer.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;outputBufferSize is %d and length is %d.&bslash;n&quot;
comma
id|outputBufferSize
comma
id|length
)paren
suffix:semicolon
)brace
id|outputBufferSize
op_assign
id|length
suffix:semicolon
multiline_comment|/* Block descriptor length - save these before overwriting */
id|tempBuffer
(braket
l_int|2
)braket
op_assign
op_star
id|the10Locations.hdr.blkDescLengthMSB
suffix:semicolon
id|tempBuffer
(braket
l_int|3
)braket
op_assign
op_star
id|the10Locations.hdr.blkDescLengthLSB
suffix:semicolon
op_star
id|the10Locations.hdr.blkDescLengthLSB
op_assign
op_star
id|the6Locations.hdr.blkDescLength
suffix:semicolon
op_star
id|the10Locations.hdr.blkDescLengthMSB
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reserved - save these before overwriting */
id|tempBuffer
(braket
l_int|0
)braket
op_assign
op_star
id|the10Locations.hdr.reserved1
suffix:semicolon
id|tempBuffer
(braket
l_int|1
)braket
op_assign
op_star
id|the10Locations.hdr.reserved2
suffix:semicolon
op_star
id|the10Locations.hdr.reserved1
op_assign
op_star
id|the10Locations.hdr.reserved2
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Medium type and DevSpecific parms */
op_star
id|the10Locations.hdr.devSpecParms
op_assign
op_star
id|the6Locations.hdr.devSpecParms
suffix:semicolon
op_star
id|the10Locations.hdr.mediumType
op_assign
op_star
id|the6Locations.hdr.mediumType
suffix:semicolon
multiline_comment|/* Data length */
op_star
id|the10Locations.hdr.dataLengthLSB
op_assign
op_star
id|the6Locations.hdr.dataLength
suffix:semicolon
op_star
id|the10Locations.hdr.dataLengthMSB
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|the6-&gt;use_sg
)paren
(brace
id|buffer
op_assign
id|the6-&gt;request_buffer
suffix:semicolon
multiline_comment|/* Copy the rest of the data */
id|memmove
c_func
(paren
op_amp
(paren
id|buffer
(braket
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)braket
)paren
comma
op_amp
(paren
id|buffer
(braket
id|USB_STOR_SCSI_SENSE_HDRSZ
)braket
)paren
comma
id|outputBufferSize
op_minus
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)paren
suffix:semicolon
multiline_comment|/* Put the first four bytes (after header) in place */
id|memcpy
c_func
(paren
op_amp
(paren
id|buffer
(braket
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)braket
)paren
comma
id|tempBuffer
comma
id|USB_STOR_SCSI_SENSE_10_HDRSZ
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
suffix:semicolon
)brace
r_else
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|the6-&gt;request_buffer
suffix:semicolon
multiline_comment|/* scan through this scatterlist and figure out ending positions */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|the6-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* get to end of header */
r_if
c_cond
(paren
id|element
op_eq
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
(brace
id|ldb
op_assign
id|i
suffix:semicolon
id|ldi
op_assign
id|j
suffix:semicolon
)brace
r_if
c_cond
(paren
id|element
op_eq
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)paren
(brace
id|lsb
op_assign
id|i
suffix:semicolon
id|lsi
op_assign
id|j
suffix:semicolon
multiline_comment|/* we&squot;ve found both sets now, exit loops */
id|j
op_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|i
op_assign
id|the6-&gt;use_sg
suffix:semicolon
r_break
suffix:semicolon
)brace
id|element
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* scan through this scatterlist and figure out starting positions */
id|element
op_assign
id|length
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* destination is the last element */
id|db
op_assign
id|the6-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
id|di
op_assign
id|sg
(braket
id|db
)braket
dot
id|length
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|the6-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|sg
(braket
id|i
)braket
dot
id|length
op_minus
l_int|1
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
multiline_comment|/* get to end of header and find source for copy */
r_if
c_cond
(paren
id|element
op_eq
id|length
op_minus
l_int|1
op_minus
(paren
id|USB_STOR_SCSI_SENSE_10_HDRSZ
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
)paren
(brace
id|sb
op_assign
id|i
suffix:semicolon
id|si
op_assign
id|j
suffix:semicolon
multiline_comment|/* we&squot;ve found both sets now, exit loops */
id|j
op_assign
op_minus
l_int|1
suffix:semicolon
id|i
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|element
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/* Now we know where to start the copy from */
id|element
op_assign
id|length
op_minus
l_int|1
op_minus
(paren
id|USB_STOR_SCSI_SENSE_10_HDRSZ
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
suffix:semicolon
r_while
c_loop
(paren
id|element
op_ge
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)paren
(brace
multiline_comment|/* check limits */
r_if
c_cond
(paren
(paren
id|sb
op_le
id|lsb
op_logical_and
id|si
OL
id|lsi
)paren
op_logical_or
(paren
id|db
op_le
id|ldb
op_logical_and
id|di
OL
id|ldi
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|USB_STORAGE
l_string|&quot;Buffer overrun averted, this shouldn&squot;t happen!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* copy one byte */
id|sg
(braket
id|db
)braket
dot
id|address
(braket
id|di
)braket
op_assign
id|sg
(braket
id|sb
)braket
dot
id|address
(braket
id|si
)braket
suffix:semicolon
multiline_comment|/* get next destination */
r_if
c_cond
(paren
id|di
op_eq
l_int|0
)paren
(brace
id|db
op_decrement
suffix:semicolon
id|di
op_assign
id|sg
(braket
id|db
)braket
dot
id|length
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|di
op_decrement
suffix:semicolon
)brace
multiline_comment|/* get next source */
r_if
c_cond
(paren
id|si
op_eq
l_int|0
)paren
(brace
id|sb
op_decrement
suffix:semicolon
id|si
op_assign
id|sg
(braket
id|sb
)braket
dot
id|length
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|si
op_decrement
suffix:semicolon
)brace
id|element
op_decrement
suffix:semicolon
)brace
multiline_comment|/* copy the remaining four bytes */
r_while
c_loop
(paren
id|element
op_ge
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
(brace
multiline_comment|/* check limits */
r_if
c_cond
(paren
id|db
op_le
id|ldb
op_logical_and
id|di
OL
id|ldi
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|USB_STORAGE
l_string|&quot;Buffer overrun averted, this shouldn&squot;t happen!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sg
(braket
id|db
)braket
dot
id|address
(braket
id|di
)braket
op_assign
id|tempBuffer
(braket
id|element
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)braket
suffix:semicolon
multiline_comment|/* get next destination */
r_if
c_cond
(paren
id|di
op_eq
l_int|0
)paren
(brace
id|db
op_decrement
suffix:semicolon
id|di
op_assign
id|sg
(braket
id|db
)braket
dot
id|length
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|di
op_decrement
suffix:semicolon
)brace
id|element
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/* All done and everything was fine */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_stor_scsiSenseParseBuffer
r_void
id|usb_stor_scsiSenseParseBuffer
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
id|Usb_Stor_Scsi_Sense_Hdr_u
op_star
id|the6
comma
id|Usb_Stor_Scsi_Sense_Hdr_10_u
op_star
id|the10
comma
r_int
op_star
id|length_p
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
comma
id|element
op_assign
l_int|0
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
l_int|0
suffix:semicolon
r_int
id|length
op_assign
l_int|0
suffix:semicolon
id|__u8
op_star
id|buffer
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* are we scatter-gathering? */
r_if
c_cond
(paren
id|srb-&gt;use_sg
op_ne
l_int|0
)paren
(brace
multiline_comment|/* loop over all the scatter gather structures and &n;       * get pointer to the data members in the headers&n;       * (also work out the length while we&squot;re here)&n;       */
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|srb-&gt;request_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|srb-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
id|length
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
multiline_comment|/* We only do the inner loop for the headers */
r_if
c_cond
(paren
id|element
OL
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)paren
(brace
multiline_comment|/* scan through this scatterlist */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|element
OL
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
(brace
multiline_comment|/* fill in the pointers for both header types */
id|the6-&gt;array
(braket
id|element
)braket
op_assign
op_amp
(paren
id|sg
(braket
id|i
)braket
dot
id|address
(braket
id|j
)braket
)paren
suffix:semicolon
id|the10-&gt;array
(braket
id|element
)braket
op_assign
op_amp
(paren
id|sg
(braket
id|i
)braket
dot
id|address
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|element
OL
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)paren
(brace
multiline_comment|/* only the longer headers still cares now */
id|the10-&gt;array
(braket
id|element
)braket
op_assign
op_amp
(paren
id|sg
(braket
id|i
)braket
dot
id|address
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* increase element counter */
id|element
op_increment
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
id|length
op_assign
id|srb-&gt;request_bufflen
suffix:semicolon
id|buffer
op_assign
id|srb-&gt;request_buffer
suffix:semicolon
r_if
c_cond
(paren
id|length
OL
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)paren
id|printk
c_func
(paren
id|KERN_ERR
id|USB_STORAGE
l_string|&quot;Buffer length smaller than header!!&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USB_STOR_SCSI_SENSE_10_HDRSZ
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
(brace
id|the6-&gt;array
(braket
id|i
)braket
op_assign
op_amp
(paren
id|buffer
(braket
id|i
)braket
)paren
suffix:semicolon
id|the10-&gt;array
(braket
id|i
)braket
op_assign
op_amp
(paren
id|buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|the10-&gt;array
(braket
id|i
)braket
op_assign
op_amp
(paren
id|buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Set value of length passed in */
op_star
id|length_p
op_assign
id|length
suffix:semicolon
)brace
eof
