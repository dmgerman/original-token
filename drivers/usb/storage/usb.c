multiline_comment|/* Driver for USB Mass Storage compliant devices&n; *&n; * $Id: usb.c,v 1.3 2000/06/27 10:20:39 mdharm Exp $&n; *&n; * Current development and maintainance by:&n; *   (c) 1999, 2000 Matthew Dharm (mdharm-usb@one-eyed-alien.net)&n; *&n; * Developed with the assistance of:&n; *   (c) 2000 David L. Brown, Jr. (usb-storage@davidb.org)&n; *&n; * Initial work by:&n; *   (c) 1999 Michael Gee (michael@linuxspecific.com)&n; *&n; * This driver is based on the &squot;USB Mass Storage Class&squot; document. This&n; * describes in detail the protocol used to communicate with such&n; * devices.  Clearly, the designers had SCSI and ATAPI commands in&n; * mind when they created this document.  The commands are all very&n; * similar to commands in the SCSI-II and ATAPI specifications.&n; *&n; * It is important to note that in a number of cases this class&n; * exhibits class-specific exemptions from the USB specification.&n; * Notably the usage of NAK, STALL and ACK differs from the norm, in&n; * that they are used to communicate wait, failed and OK on commands.&n; *&n; * Also, for certain devices, the interrupt endpoint is used to convey&n; * status of a command.&n; *&n; * Please see http://www.one-eyed-alien.net/~mdharm/linux-usb for more&n; * information about this driver.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;scsiglue.h&quot;
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &lt;linux/module.h&gt;
multiline_comment|/*FIXME: note that this next include is needed for the new sleeping system&n;  * which is not implemented yet&n;  */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
multiline_comment|/*&n; * Per device data&n; */
DECL|variable|my_host_number
r_static
r_int
id|my_host_number
suffix:semicolon
multiline_comment|/*&n; * kernel thread actions&n; */
DECL|macro|US_ACT_COMMAND
mdefine_line|#define US_ACT_COMMAND&t;&t;1
DECL|macro|US_ACT_DEVICE_RESET
mdefine_line|#define US_ACT_DEVICE_RESET&t;2
DECL|macro|US_ACT_BUS_RESET
mdefine_line|#define US_ACT_BUS_RESET&t;3
DECL|macro|US_ACT_HOST_RESET
mdefine_line|#define US_ACT_HOST_RESET&t;4
DECL|macro|US_ACT_EXIT
mdefine_line|#define US_ACT_EXIT&t;&t;5
multiline_comment|/* The list of structures and the protective lock for them */
DECL|variable|us_list
r_struct
id|us_data
op_star
id|us_list
suffix:semicolon
DECL|variable|us_list_semaphore
r_struct
id|semaphore
id|us_list_semaphore
suffix:semicolon
r_static
r_void
op_star
id|storage_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
)paren
suffix:semicolon
r_static
r_void
id|storage_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
suffix:semicolon
DECL|variable|storage_driver
r_static
r_struct
id|usb_driver
id|storage_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;usb-storage&quot;
comma
id|probe
suffix:colon
id|storage_probe
comma
id|disconnect
suffix:colon
id|storage_disconnect
comma
)brace
suffix:semicolon
DECL|function|usb_stor_control_thread
r_static
r_int
id|usb_stor_control_thread
c_func
(paren
r_void
op_star
id|__us
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|__us
suffix:semicolon
r_int
id|action
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This thread doesn&squot;t need any user-level access,&n;&t; * so get rid of all our resources..&n;&t; */
id|daemonize
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set our name for identification purposes */
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;usb-storage-%d&quot;
comma
id|us-&gt;host_number
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* signal that we&squot;ve started the thread */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;*** thread sleeping.&bslash;n&quot;
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;sleeper
)paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;queue_exclusion
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;*** thread awakened.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* take the command off the queue */
id|action
op_assign
id|us-&gt;action
suffix:semicolon
id|us-&gt;action
op_assign
l_int|0
suffix:semicolon
id|us-&gt;srb
op_assign
id|us-&gt;queue_srb
suffix:semicolon
multiline_comment|/* release the queue lock as fast as possible */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;queue_exclusion
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|US_ACT_COMMAND
suffix:colon
multiline_comment|/* reject if target != 0 or if LUN is higher than&n;&t;&t;&t; * the maximum known LUN&n;&t;&t;&t; */
r_if
c_cond
(paren
id|us-&gt;srb-&gt;target
op_logical_or
(paren
id|us-&gt;srb-&gt;lun
OG
id|us-&gt;max_lun
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bad device number (%d/%d)&bslash;n&quot;
comma
id|us-&gt;srb-&gt;target
comma
id|us-&gt;srb-&gt;lun
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
id|us-&gt;srb
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|us-&gt;srb
)paren
suffix:semicolon
id|us-&gt;srb
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* handle those devices which can&squot;t do a START_STOP */
r_if
c_cond
(paren
(paren
id|us-&gt;srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|START_STOP
)paren
op_logical_and
(paren
id|us-&gt;flags
op_amp
id|US_FL_START_STOP
)paren
)paren
(brace
id|us-&gt;srb-&gt;result
op_assign
id|GOOD
suffix:semicolon
id|us-&gt;srb
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|us-&gt;srb
)paren
suffix:semicolon
id|us-&gt;srb
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* lock the device pointers */
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* our device has gone - pretend not ready */
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;pusb_dev
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Request is for removed device&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* For REQUEST_SENSE, it&squot;s the data.  But&n;&t;&t;&t;&t; * for anything else, it should look like&n;&t;&t;&t;&t; * we auto-sensed for it.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|us-&gt;srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
(brace
id|memcpy
c_func
(paren
id|us-&gt;srb-&gt;request_buffer
comma
id|usb_stor_sense_notready
comma
r_sizeof
(paren
id|usb_stor_sense_notready
)paren
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|GOOD
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|us-&gt;srb-&gt;sense_buffer
comma
id|usb_stor_sense_notready
comma
r_sizeof
(paren
id|usb_stor_sense_notready
)paren
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|CHECK_CONDITION
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* !us-&gt;pusb_dev */
multiline_comment|/* we&squot;ve got a command, let&squot;s do it! */
id|US_DEBUG
c_func
(paren
id|usb_stor_show_command
c_func
(paren
id|us-&gt;srb
)paren
)paren
suffix:semicolon
id|us
op_member_access_from_pointer
id|proto_handler
c_func
(paren
id|us-&gt;srb
comma
id|us
)paren
suffix:semicolon
)brace
multiline_comment|/* unlock the device pointers */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* indicate that the command is done */
r_if
c_cond
(paren
id|us-&gt;srb-&gt;result
op_ne
id|DID_ABORT
op_lshift
l_int|16
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;scsi cmd done, result=0x%x&bslash;n&quot;
comma
id|us-&gt;srb-&gt;result
)paren
suffix:semicolon
id|us-&gt;srb
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|us-&gt;srb
)paren
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;scsi command aborted&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
)brace
id|us-&gt;srb
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_ACT_DEVICE_RESET
suffix:colon
r_break
suffix:semicolon
r_case
id|US_ACT_BUS_RESET
suffix:colon
r_break
suffix:semicolon
r_case
id|US_ACT_HOST_RESET
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* end switch on action */
multiline_comment|/* exit if we get a signal to exit */
r_if
c_cond
(paren
id|action
op_eq
id|US_ACT_EXIT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- US_ACT_EXIT command recieved&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* for (;;) */
multiline_comment|/* notify the exit routine that we&squot;re actually exiting now */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is the list of devices we recognize, along with their flag data */
DECL|variable|us_unusual_dev_list
r_static
r_struct
id|us_unusual_dev
id|us_unusual_dev_list
(braket
)braket
op_assign
(brace
(brace
l_int|0x03f0
comma
l_int|0x0107
comma
l_int|0x0200
comma
l_int|0x0200
comma
l_string|&quot;HP USB CD-Writer Plus&quot;
comma
id|US_SC_8070
comma
id|US_PR_CB
comma
l_int|0
)brace
comma
(brace
l_int|0x04e6
comma
l_int|0x0001
comma
l_int|0x0200
comma
l_int|0x0200
comma
l_string|&quot;Matshita LS-120&quot;
comma
id|US_SC_8020
comma
id|US_PR_CB
comma
id|US_FL_SINGLE_LUN
)brace
comma
(brace
l_int|0x04e6
comma
l_int|0x0002
comma
l_int|0x0100
comma
l_int|0x0100
comma
l_string|&quot;Shuttle eUSCSI Bridge&quot;
comma
id|US_SC_SCSI
comma
id|US_PR_BULK
comma
id|US_FL_ALT_LENGTH
)brace
comma
(brace
l_int|0x04e6
comma
l_int|0x0006
comma
l_int|0x0100
comma
l_int|0x0100
comma
l_string|&quot;Shuttle eUSB MMC Adapter&quot;
comma
id|US_SC_SCSI
comma
id|US_PR_CB
comma
id|US_FL_SINGLE_LUN
)brace
comma
(brace
l_int|0x054c
comma
l_int|0x0010
comma
l_int|0x0210
comma
l_int|0x0210
comma
l_string|&quot;Sony DSC-S30/S70&quot;
comma
id|US_SC_SCSI
comma
id|US_PR_CB
comma
id|US_FL_SINGLE_LUN
op_or
id|US_FL_START_STOP
op_or
id|US_FL_MODE_XLATE
op_or
id|US_FL_ALT_LENGTH
op_or
id|US_FL_ALT_LENGTH
)brace
comma
(brace
l_int|0x054c
comma
l_int|0x002d
comma
l_int|0x0100
comma
l_int|0x0100
comma
l_string|&quot;Sony Memorystick MSAC-US1&quot;
comma
id|US_SC_SCSI
comma
id|US_PR_CB
comma
id|US_FL_SINGLE_LUN
op_or
id|US_FL_START_STOP
op_or
id|US_FL_MODE_XLATE
op_or
id|US_FL_ALT_LENGTH
)brace
comma
(brace
l_int|0x057b
comma
l_int|0x0000
comma
l_int|0x0000
comma
l_int|0x0299
comma
l_string|&quot;Y-E Data Flashbuster-U&quot;
comma
id|US_SC_UFI
comma
id|US_PR_CB
comma
id|US_FL_SINGLE_LUN
)brace
comma
(brace
l_int|0x057b
comma
l_int|0x0000
comma
l_int|0x0300
comma
l_int|0x9999
comma
l_string|&quot;Y-E Data Flashbuster-U&quot;
comma
id|US_SC_UFI
comma
id|US_PR_CBI
comma
id|US_FL_SINGLE_LUN
)brace
comma
(brace
l_int|0x0693
comma
l_int|0x0002
comma
l_int|0x0100
comma
l_int|0x0100
comma
l_string|&quot;Hagiwara FlashGate SmartMedia&quot;
comma
id|US_SC_SCSI
comma
id|US_PR_BULK
comma
id|US_FL_ALT_LENGTH
)brace
comma
(brace
l_int|0x0781
comma
l_int|0x0001
comma
l_int|0x0200
comma
l_int|0x0200
comma
l_string|&quot;Sandisk ImageMate (SDDR-01)&quot;
comma
id|US_SC_SCSI
comma
id|US_PR_CB
comma
id|US_FL_SINGLE_LUN
op_or
id|US_FL_START_STOP
)brace
comma
(brace
l_int|0x0781
comma
l_int|0x0002
comma
l_int|0x0009
comma
l_int|0x0009
comma
l_string|&quot;Sandisk Imagemate (SDDR-31)&quot;
comma
id|US_SC_SCSI
comma
id|US_PR_BULK
comma
id|US_FL_IGNORE_SER
)brace
comma
(brace
l_int|0x07af
comma
l_int|0x0004
comma
l_int|0x0100
comma
l_int|0x0100
comma
l_string|&quot;Microtech USB-SCSI-DB25&quot;
comma
id|US_SC_SCSI
comma
id|US_PR_BULK
comma
id|US_FL_ALT_LENGTH
)brace
comma
(brace
l_int|0x07af
comma
l_int|0x0005
comma
l_int|0x0100
comma
l_int|0x0100
comma
l_string|&quot;Microtech USB-SCSI-HD50&quot;
comma
id|US_SC_SCSI
comma
id|US_PR_BULK
comma
id|US_FL_ALT_LENGTH
)brace
comma
(brace
l_int|0x05ab
comma
l_int|0x0031
comma
l_int|0x0100
comma
l_int|0x0100
comma
l_string|&quot;In-System USB/IDE Bridge&quot;
comma
id|US_SC_8070
comma
id|US_PR_BULK
comma
id|US_FL_ALT_LENGTH
)brace
comma
(brace
l_int|0x0693
comma
l_int|0x0005
comma
l_int|0x0100
comma
l_int|0x0100
comma
l_string|&quot;Hagiwara Flashgate&quot;
comma
id|US_SC_SCSI
comma
id|US_PR_BULK
comma
id|US_FL_ALT_LENGTH
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* Search our ususual device list, based on vendor/product combinations&n; * to see if we can support this device.  Returns a pointer to a structure&n; * defining how we should support this device, or NULL if it&squot;s not in the&n; * list&n; */
DECL|function|us_find_dev
r_static
r_struct
id|us_unusual_dev
op_star
id|us_find_dev
c_func
(paren
id|u16
id|idVendor
comma
id|u16
id|idProduct
comma
id|u16
id|bcdDevice
)paren
(brace
r_struct
id|us_unusual_dev
op_star
id|ptr
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Searching unusual device list for (0x%x, 0x%x, 0x%x)...&bslash;n&quot;
comma
id|idVendor
comma
id|idProduct
comma
id|bcdDevice
)paren
suffix:semicolon
id|ptr
op_assign
id|us_unusual_dev_list
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ptr-&gt;idVendor
op_ne
l_int|0x0000
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|ptr-&gt;idVendor
op_eq
id|idVendor
)paren
op_logical_and
(paren
id|ptr-&gt;idProduct
op_eq
id|idProduct
)paren
op_logical_and
(paren
id|ptr-&gt;bcdDeviceMin
op_le
id|bcdDevice
)paren
op_logical_and
(paren
id|ptr-&gt;bcdDeviceMax
op_ge
id|bcdDevice
)paren
)paren
)paren
id|ptr
op_increment
suffix:semicolon
multiline_comment|/* if the search ended because we hit the end record, we failed */
r_if
c_cond
(paren
id|ptr-&gt;idVendor
op_eq
l_int|0x0000
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- did not find a matching device&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* otherwise, we found one! */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- found matching device: %s&bslash;n&quot;
comma
id|ptr-&gt;name
)paren
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/* Set up the IRQ pipe and handler&n; * Note that this function assumes that all the data in the us_data&n; * strucuture is current.  This includes the ep_int field, which gives us&n; * the endpoint for the interrupt.&n; * Returns non-zero on failure, zero on success&n; */
DECL|function|usb_stor_allocate_irq
r_static
r_int
id|usb_stor_allocate_irq
c_func
(paren
r_struct
id|us_data
op_star
id|ss
)paren
(brace
r_int
r_int
id|pipe
suffix:semicolon
r_int
id|maxp
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Allocating IRQ for CBI transport&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* lock access to the data structure */
id|down
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
multiline_comment|/* allocate the URB */
id|ss-&gt;irq_urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss-&gt;irq_urb
)paren
(brace
id|up
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;couldn&squot;t allocate interrupt URB&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* calculate the pipe and max packet size */
id|pipe
op_assign
id|usb_rcvintpipe
c_func
(paren
id|ss-&gt;pusb_dev
comma
id|ss-&gt;ep_int-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
suffix:semicolon
id|maxp
op_assign
id|usb_maxpacket
c_func
(paren
id|ss-&gt;pusb_dev
comma
id|pipe
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxp
OG
r_sizeof
(paren
id|ss-&gt;irqbuf
)paren
)paren
id|maxp
op_assign
r_sizeof
(paren
id|ss-&gt;irqbuf
)paren
suffix:semicolon
multiline_comment|/* fill in the URB with our data */
id|FILL_INT_URB
c_func
(paren
id|ss-&gt;irq_urb
comma
id|ss-&gt;pusb_dev
comma
id|pipe
comma
id|ss-&gt;irqbuf
comma
id|maxp
comma
id|usb_stor_CBI_irq
comma
id|ss
comma
id|ss-&gt;ep_int-&gt;bInterval
)paren
suffix:semicolon
multiline_comment|/* submit the URB for processing */
id|result
op_assign
id|usb_submit_urb
c_func
(paren
id|ss-&gt;irq_urb
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_submit_urb() returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|usb_free_urb
c_func
(paren
id|ss-&gt;irq_urb
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
multiline_comment|/* unlock the data structure and return success */
id|up
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Probe to see if a new device is actually a SCSI device */
DECL|function|storage_probe
r_static
r_void
op_star
id|storage_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
id|mf
(braket
id|USB_STOR_STRING_LEN
)braket
suffix:semicolon
multiline_comment|/* manufacturer */
r_char
id|prod
(braket
id|USB_STOR_STRING_LEN
)braket
suffix:semicolon
multiline_comment|/* product */
r_char
id|serial
(braket
id|USB_STOR_STRING_LEN
)braket
suffix:semicolon
multiline_comment|/* serial number */
id|GUID
c_func
(paren
id|guid
)paren
suffix:semicolon
multiline_comment|/* Global Unique Identifier */
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|us_unusual_dev
op_star
id|unusual_dev
suffix:semicolon
r_struct
id|us_data
op_star
id|ss
op_assign
l_int|NULL
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* these are temporary copies -- we test on these, then put them&n;&t; * in the us-data structure &n;&t; */
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_in
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_out
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_int
op_assign
l_int|NULL
suffix:semicolon
id|u8
id|subclass
op_assign
l_int|0
suffix:semicolon
id|u8
id|protocol
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* the altsettting 0 on the interface we&squot;re probing */
r_struct
id|usb_interface_descriptor
op_star
id|altsetting
op_assign
op_amp
(paren
id|dev-&gt;actconfig-&gt;interface
(braket
id|ifnum
)braket
dot
id|altsetting
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* clear the temporary strings */
id|memset
c_func
(paren
id|mf
comma
l_int|0
comma
r_sizeof
(paren
id|mf
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|prod
comma
l_int|0
comma
r_sizeof
(paren
id|prod
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|serial
comma
l_int|0
comma
r_sizeof
(paren
id|serial
)paren
)paren
suffix:semicolon
multiline_comment|/* search for this device in our unusual device list */
id|unusual_dev
op_assign
id|us_find_dev
c_func
(paren
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
comma
id|dev-&gt;descriptor.bcdDevice
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Can we support this device, either because we know about it&n;&t; * from our unusual device list, or because it advertises that it&squot;s&n;&t; * compliant to the specification?&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|unusual_dev
op_logical_and
op_logical_neg
(paren
id|dev-&gt;descriptor.bDeviceClass
op_eq
l_int|0
op_logical_and
id|altsetting-&gt;bInterfaceClass
op_eq
id|USB_CLASS_MASS_STORAGE
op_logical_and
id|altsetting-&gt;bInterfaceSubClass
op_ge
id|US_SC_MIN
op_logical_and
id|altsetting-&gt;bInterfaceSubClass
op_le
id|US_SC_MAX
)paren
)paren
(brace
multiline_comment|/* if it&squot;s not a mass storage, we go no further */
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* At this point, we know we&squot;ve got a live one */
id|US_DEBUGP
c_func
(paren
l_string|&quot;USB Mass Storage device detected&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Determine subclass and protocol, or copy from the interface */
r_if
c_cond
(paren
id|unusual_dev
)paren
(brace
id|subclass
op_assign
id|unusual_dev-&gt;useProtocol
suffix:semicolon
id|protocol
op_assign
id|unusual_dev-&gt;useTransport
suffix:semicolon
id|flags
op_assign
id|unusual_dev-&gt;flags
suffix:semicolon
)brace
r_else
(brace
id|subclass
op_assign
id|altsetting-&gt;bInterfaceSubClass
suffix:semicolon
id|protocol
op_assign
id|altsetting-&gt;bInterfaceProtocol
suffix:semicolon
id|flags
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find the endpoints we need&n;&t; * We are expecting a minimum of 2 endpoints - in and out (bulk).&n;&t; * An optional interrupt is OK (necessary for CBI protocol).&n;&t; * We will ignore any others.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|altsetting-&gt;bNumEndpoints
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* is it an BULK endpoint? */
r_if
c_cond
(paren
(paren
id|altsetting-&gt;endpoint
(braket
id|i
)braket
dot
id|bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_eq
id|USB_ENDPOINT_XFER_BULK
)paren
(brace
multiline_comment|/* BULK in or out? */
r_if
c_cond
(paren
id|altsetting-&gt;endpoint
(braket
id|i
)braket
dot
id|bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
id|ep_in
op_assign
op_amp
id|altsetting-&gt;endpoint
(braket
id|i
)braket
suffix:semicolon
r_else
id|ep_out
op_assign
op_amp
id|altsetting-&gt;endpoint
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* is it an interrupt endpoint? */
r_if
c_cond
(paren
(paren
id|altsetting-&gt;endpoint
(braket
id|i
)braket
dot
id|bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_eq
id|USB_ENDPOINT_XFER_INT
)paren
(brace
id|ep_int
op_assign
op_amp
id|altsetting-&gt;endpoint
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Endpoints: In: 0x%p Out: 0x%p Int: 0x%p (Period %d)&bslash;n&quot;
comma
id|ep_in
comma
id|ep_out
comma
id|ep_int
comma
id|ep_int
ques
c_cond
id|ep_int-&gt;bInterval
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/* set the interface -- STALL is an acceptable response here */
id|result
op_assign
id|usb_set_interface
c_func
(paren
id|dev
comma
id|altsetting-&gt;bInterfaceNumber
comma
l_int|0
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result from usb_set_interface is %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- clearing stall on control interface&bslash;n&quot;
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
multiline_comment|/* it&squot;s not a stall, but another error -- time to bail */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Unknown error.  Rejecting device&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Do some basic sanity checks, and bail if we find a problem */
r_if
c_cond
(paren
op_logical_neg
id|ep_in
op_logical_or
op_logical_neg
id|ep_out
op_logical_or
(paren
id|protocol
op_eq
id|US_PR_CBI
op_logical_and
op_logical_neg
id|ep_int
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Sanity check failed.&t; Rejecting device.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* At this point, we&squot;re committed to using the device */
multiline_comment|/* clear the GUID and fetch the strings */
id|GUID_CLEAR
c_func
(paren
id|guid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iManufacturer
)paren
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iManufacturer
comma
id|mf
comma
r_sizeof
(paren
id|mf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iProduct
)paren
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iProduct
comma
id|prod
comma
r_sizeof
(paren
id|prod
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iSerialNumber
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|US_FL_IGNORE_SER
)paren
)paren
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iSerialNumber
comma
id|serial
comma
r_sizeof
(paren
id|serial
)paren
)paren
suffix:semicolon
multiline_comment|/* Create a GUID for this device */
r_if
c_cond
(paren
id|dev-&gt;descriptor.iSerialNumber
op_logical_and
id|serial
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* If we have a serial number, and it&squot;s a non-NULL string */
id|make_guid
c_func
(paren
id|guid
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
comma
id|serial
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We don&squot;t have a serial number, so we use 0 */
id|make_guid
c_func
(paren
id|guid
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
comma
l_string|&quot;0&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* lock access to the data structures */
id|down
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now check if we have seen this GUID before&n;&t; * We&squot;re looking for a device with a matching GUID that isn&squot;t&n;&t; * allready on the system&n;&t; */
id|ss
op_assign
id|us_list
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ss
op_ne
l_int|NULL
)paren
op_logical_and
(paren
(paren
id|ss-&gt;pusb_dev
)paren
op_logical_or
op_logical_neg
id|GUID_EQUAL
c_func
(paren
id|guid
comma
id|ss-&gt;guid
)paren
)paren
)paren
id|ss
op_assign
id|ss-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|ss
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Existing device -- re-connect */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Found existing GUID &quot;
id|GUID_FORMAT
l_string|&quot;&bslash;n&quot;
comma
id|GUID_ARGS
c_func
(paren
id|guid
)paren
)paren
suffix:semicolon
multiline_comment|/* establish the connection to the new device upon reconnect */
id|ss-&gt;ifnum
op_assign
id|ifnum
suffix:semicolon
id|ss-&gt;pusb_dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* copy over the endpoint data */
r_if
c_cond
(paren
id|ep_in
)paren
id|ss-&gt;ep_in
op_assign
id|ep_in-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
r_if
c_cond
(paren
id|ep_out
)paren
id|ss-&gt;ep_out
op_assign
id|ep_out-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
id|ss-&gt;ep_int
op_assign
id|ep_int
suffix:semicolon
multiline_comment|/* allocate an IRQ callback if one is needed */
r_if
c_cond
(paren
(paren
id|ss-&gt;protocol
op_eq
id|US_PR_CBI
)paren
op_logical_and
id|usb_stor_allocate_irq
c_func
(paren
id|ss
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* New device -- allocate memory and initialize */
id|US_DEBUGP
c_func
(paren
l_string|&quot;New GUID &quot;
id|GUID_FORMAT
l_string|&quot;&bslash;n&quot;
comma
id|GUID_ARGS
c_func
(paren
id|guid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ss
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|us_data
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ss
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|us_data
)paren
)paren
suffix:semicolon
multiline_comment|/* allocate the URB we&squot;re going to use */
id|ss-&gt;current_urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss-&gt;current_urb
)paren
(brace
id|kfree
c_func
(paren
id|ss
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Initialize the mutexes only when the struct is new */
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
(paren
id|ss-&gt;sleeper
)paren
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
(paren
id|ss-&gt;notify
)paren
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
(paren
id|ss-&gt;ip_waitq
)paren
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|ss-&gt;queue_exclusion
)paren
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|ss-&gt;current_urb_sem
)paren
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|ss-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* copy over the subclass and protocol data */
id|ss-&gt;subclass
op_assign
id|subclass
suffix:semicolon
id|ss-&gt;protocol
op_assign
id|protocol
suffix:semicolon
id|ss-&gt;flags
op_assign
id|flags
suffix:semicolon
multiline_comment|/* copy over the endpoint data */
r_if
c_cond
(paren
id|ep_in
)paren
id|ss-&gt;ep_in
op_assign
id|ep_in-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
r_if
c_cond
(paren
id|ep_out
)paren
id|ss-&gt;ep_out
op_assign
id|ep_out-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
id|ss-&gt;ep_int
op_assign
id|ep_int
suffix:semicolon
multiline_comment|/* establish the connection to the new device */
id|ss-&gt;ifnum
op_assign
id|ifnum
suffix:semicolon
id|ss-&gt;pusb_dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* copy over the identifiying strings */
id|strncpy
c_func
(paren
id|ss-&gt;vendor
comma
id|mf
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|ss-&gt;product
comma
id|prod
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|ss-&gt;serial
comma
id|serial
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|ss-&gt;vendor
)paren
op_eq
l_int|0
)paren
id|strncpy
c_func
(paren
id|ss-&gt;vendor
comma
l_string|&quot;Unknown&quot;
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|ss-&gt;product
)paren
op_eq
l_int|0
)paren
id|strncpy
c_func
(paren
id|ss-&gt;product
comma
l_string|&quot;Unknown&quot;
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|ss-&gt;serial
)paren
op_eq
l_int|0
)paren
id|strncpy
c_func
(paren
id|ss-&gt;serial
comma
l_string|&quot;None&quot;
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
multiline_comment|/* copy the GUID we created before */
id|memcpy
c_func
(paren
id|ss-&gt;guid
comma
id|guid
comma
r_sizeof
(paren
id|guid
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Set the handler pointers based on the protocol&n;&t;&t; * Again, this data is persistant across reattachments&n;&t;&t; */
r_switch
c_cond
(paren
id|ss-&gt;protocol
)paren
(brace
r_case
id|US_PR_CB
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;Control/Bulk&quot;
suffix:semicolon
id|ss-&gt;transport
op_assign
id|usb_stor_CB_transport
suffix:semicolon
id|ss-&gt;transport_reset
op_assign
id|usb_stor_CB_reset
suffix:semicolon
id|ss-&gt;max_lun
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_PR_CBI
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;Control/Bulk/Interrupt&quot;
suffix:semicolon
id|ss-&gt;transport
op_assign
id|usb_stor_CBI_transport
suffix:semicolon
id|ss-&gt;transport_reset
op_assign
id|usb_stor_CB_reset
suffix:semicolon
id|ss-&gt;max_lun
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_PR_BULK
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;Bulk&quot;
suffix:semicolon
id|ss-&gt;transport
op_assign
id|usb_stor_Bulk_transport
suffix:semicolon
id|ss-&gt;transport_reset
op_assign
id|usb_stor_Bulk_reset
suffix:semicolon
id|ss-&gt;max_lun
op_assign
id|usb_stor_Bulk_max_lun
c_func
(paren
id|ss
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
id|up
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ss-&gt;current_urb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ss
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Transport: %s&bslash;n&quot;
comma
id|ss-&gt;transport_name
)paren
suffix:semicolon
multiline_comment|/* fix for single-lun devices */
r_if
c_cond
(paren
id|ss-&gt;flags
op_amp
id|US_FL_SINGLE_LUN
)paren
id|ss-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|ss-&gt;subclass
)paren
(brace
r_case
id|US_SC_RBC
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;Reduced Block Commands (RBC)&quot;
suffix:semicolon
id|ss-&gt;proto_handler
op_assign
id|usb_stor_transparent_scsi_command
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_8020
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;8020i&quot;
suffix:semicolon
id|ss-&gt;proto_handler
op_assign
id|usb_stor_ATAPI_command
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_QIC
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;QIC-157&quot;
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Sorry, device not supported.&t; Please&bslash;n&quot;
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;contact mdharm-usb@one-eyed-alien.net&bslash;n&quot;
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;if you see this message.&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ss-&gt;current_urb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ss
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_8070
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;8070i&quot;
suffix:semicolon
id|ss-&gt;proto_handler
op_assign
id|usb_stor_ATAPI_command
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_SCSI
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;Transparent SCSI&quot;
suffix:semicolon
id|ss-&gt;proto_handler
op_assign
id|usb_stor_transparent_scsi_command
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_UFI
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;Uniform Floppy Interface (UFI)&quot;
suffix:semicolon
id|ss-&gt;proto_handler
op_assign
id|usb_stor_ufi_command
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
id|up
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ss-&gt;current_urb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ss
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Protocol: %s&bslash;n&quot;
comma
id|ss-&gt;protocol_name
)paren
suffix:semicolon
multiline_comment|/* allocate an IRQ callback if one is needed */
r_if
c_cond
(paren
(paren
id|ss-&gt;protocol
op_eq
id|US_PR_CBI
)paren
op_logical_and
id|usb_stor_allocate_irq
c_func
(paren
id|ss
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Since this is a new device, we need to generate a scsi &n;&t;&t; * host definition, and register with the higher SCSI layers&n;&t;&t; */
multiline_comment|/* Initialize the host template based on the default one */
id|memcpy
c_func
(paren
op_amp
(paren
id|ss-&gt;htmplt
)paren
comma
op_amp
id|usb_stor_host_template
comma
r_sizeof
(paren
id|usb_stor_host_template
)paren
)paren
suffix:semicolon
multiline_comment|/* Grab the next host number */
id|ss-&gt;host_number
op_assign
id|my_host_number
op_increment
suffix:semicolon
multiline_comment|/* We abuse this pointer so we can pass the ss pointer to &n;&t;&t; * the host controler thread in us_detect.  But how else are&n;&t;&t; * we to do it?&n;&t;&t; */
(paren
r_struct
id|us_data
op_star
)paren
id|ss-&gt;htmplt.proc_dir
op_assign
id|ss
suffix:semicolon
multiline_comment|/* start up our control thread */
id|ss-&gt;pid
op_assign
id|kernel_thread
c_func
(paren
id|usb_stor_control_thread
comma
id|ss
comma
id|CLONE_FS
op_or
id|CLONE_FILES
op_or
id|CLONE_SIGHAND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss-&gt;pid
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Unable to start control thread&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ss-&gt;current_urb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ss
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* wait for the thread to start */
id|down
c_func
(paren
op_amp
(paren
id|ss-&gt;notify
)paren
)paren
suffix:semicolon
multiline_comment|/* now register&t; - our detect function will be called */
id|ss-&gt;htmplt.module
op_assign
id|THIS_MODULE
suffix:semicolon
id|scsi_register_module
c_func
(paren
id|MODULE_SCSI_HA
comma
op_amp
(paren
id|ss-&gt;htmplt
)paren
)paren
suffix:semicolon
multiline_comment|/* put us in the list */
id|ss-&gt;next
op_assign
id|us_list
suffix:semicolon
id|us_list
op_assign
id|ss
suffix:semicolon
)brace
multiline_comment|/* release the data structure lock */
id|up
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WARNING: USB Mass Storage data integrity not assured&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;USB Mass Storage device found at %d&bslash;n&quot;
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
multiline_comment|/* return a pointer for the disconnect function */
r_return
id|ss
suffix:semicolon
)brace
multiline_comment|/* Handle a disconnect event from the USB core */
DECL|function|storage_disconnect
r_static
r_void
id|storage_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|us_data
op_star
id|ss
op_assign
id|ptr
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;storage_disconnect() called&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* this is the odd case -- we disconnected but weren&squot;t using it */
r_if
c_cond
(paren
op_logical_neg
id|ss
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- device was not in use&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* lock access to the device data structure */
id|down
c_func
(paren
op_amp
(paren
id|ss-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* release the IRQ, if we have one */
id|down
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss-&gt;irq_urb
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- releasing irq handle&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_unlink_urb
c_func
(paren
id|ss-&gt;irq_urb
)paren
suffix:semicolon
id|ss-&gt;irq_urb
op_assign
l_int|NULL
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- usb_unlink_urb() returned %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|ss-&gt;irq_urb
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
multiline_comment|/* mark the device as gone */
id|ss-&gt;pusb_dev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* lock access to the device data structure */
id|up
c_func
(paren
op_amp
(paren
id|ss-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Initialization and registration&n; ***********************************************************************/
DECL|function|usb_stor_init
r_int
id|__init
id|usb_stor_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* initialize internal global data elements */
id|us_list
op_assign
l_int|NULL
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
id|my_host_number
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* register the driver, return -1 if error */
r_if
c_cond
(paren
id|usb_register
c_func
(paren
op_amp
id|storage_driver
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* we&squot;re all set */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;USB Mass Storage support registered.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_stor_exit
r_void
id|__exit
id|usb_stor_exit
c_func
(paren
r_void
)paren
(brace
r_struct
id|us_data
op_star
id|next
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_stor_exit() called&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Deregister the driver&n;&t; * This eliminates races with probes and disconnects &n;&t; */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- calling usb_deregister()&bslash;n&quot;
)paren
suffix:semicolon
id|usb_deregister
c_func
(paren
op_amp
id|storage_driver
)paren
suffix:semicolon
multiline_comment|/* lock access to the data structures */
id|down
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
multiline_comment|/* While there are still virtual hosts, unregister them&n;&t; *&n;&t; * Note that the us_release() routine will destroy the local data&n;&t; * structure.  So we have to peel these off the top of the list&n;&t; * and keep updating the head pointer as we go.&n;&t; */
r_while
c_loop
(paren
id|us_list
)paren
(brace
multiline_comment|/* keep track of where the next one is */
id|next
op_assign
id|us_list-&gt;next
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- calling scsi_unregister_module()&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_unregister_module
c_func
(paren
id|MODULE_SCSI_HA
comma
op_amp
(paren
id|us_list-&gt;htmplt
)paren
)paren
suffix:semicolon
multiline_comment|/* Now that scsi_unregister_module is done with the host&n;                 * template, we can free the us_data structure (the host&n;                 * template is inline in this structure). */
id|kfree
(paren
id|us_list
)paren
suffix:semicolon
multiline_comment|/* advance the list pointer */
id|us_list
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/* unlock the data structures */
id|up
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
)brace
DECL|variable|usb_stor_init
id|module_init
c_func
(paren
id|usb_stor_init
)paren
suffix:semicolon
DECL|variable|usb_stor_exit
id|module_exit
c_func
(paren
id|usb_stor_exit
)paren
suffix:semicolon
eof
