multiline_comment|/* Driver for USB Mass Storage compliant devices&n; *&n; * $Id: transport.c,v 1.2 2000/06/27 10:20:39 mdharm Exp $&n; *&n; * Current development and maintainance by:&n; *   (c) 1999, 2000 Matthew Dharm (mdharm-usb@one-eyed-alien.net)&n; *&n; * Developed with the assistance of:&n; *   (c) 2000 David L. Brown, Jr. (usb-storage@davidb.org)&n; *&n; * Initial work by:&n; *   (c) 1999 Michael Gee (michael@linuxspecific.com)&n; *&n; * This driver is based on the &squot;USB Mass Storage Class&squot; document. This&n; * describes in detail the protocol used to communicate with such&n; * devices.  Clearly, the designers had SCSI and ATAPI commands in&n; * mind when they created this document.  The commands are all very&n; * similar to commands in the SCSI-II and ATAPI specifications.&n; *&n; * It is important to note that in a number of cases this class&n; * exhibits class-specific exemptions from the USB specification.&n; * Notably the usage of NAK, STALL and ACK differs from the norm, in&n; * that they are used to communicate wait, failed and OK on commands.&n; *&n; * Also, for certain devices, the interrupt endpoint is used to convey&n; * status of a command.&n; *&n; * Please see http://www.one-eyed-alien.net/~mdharm/linux-usb for more&n; * information about this driver.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
multiline_comment|/***********************************************************************&n; * Data transfer routines&n; ***********************************************************************/
multiline_comment|/* This is the completion handler which will wake us up when an URB&n; * completes.&n; */
DECL|function|usb_stor_blocking_completion
r_static
r_void
id|usb_stor_blocking_completion
c_func
(paren
id|urb_t
op_star
id|urb
)paren
(brace
id|api_wrapper_data
op_star
id|awd
op_assign
(paren
id|api_wrapper_data
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
id|awd-&gt;wakeup
)paren
)paren
id|wake_up
c_func
(paren
id|awd-&gt;wakeup
)paren
suffix:semicolon
)brace
multiline_comment|/* This is our function to emulate usb_control_msg() but give us enough&n; * access to make aborts/resets work&n; */
DECL|function|usb_stor_control_msg
r_int
id|usb_stor_control_msg
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
comma
id|u8
id|request
comma
id|u8
id|requesttype
comma
id|u16
id|value
comma
id|u16
id|index
comma
r_void
op_star
id|data
comma
id|u16
id|size
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|wqh
)paren
suffix:semicolon
id|api_wrapper_data
id|awd
suffix:semicolon
r_int
id|status
suffix:semicolon
id|devrequest
op_star
id|dr
suffix:semicolon
multiline_comment|/* allocate the device request structure */
id|dr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|devrequest
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* fill in the structure */
id|dr-&gt;requesttype
op_assign
id|requesttype
suffix:semicolon
id|dr-&gt;request
op_assign
id|request
suffix:semicolon
id|dr-&gt;value
op_assign
id|cpu_to_le16
c_func
(paren
id|value
)paren
suffix:semicolon
id|dr-&gt;index
op_assign
id|cpu_to_le16
c_func
(paren
id|index
)paren
suffix:semicolon
id|dr-&gt;length
op_assign
id|cpu_to_le16
c_func
(paren
id|size
)paren
suffix:semicolon
multiline_comment|/* set up data structures for the wakeup system */
id|awd.wakeup
op_assign
op_amp
id|wqh
suffix:semicolon
id|awd.handler
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|wqh
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|wqh
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* lock the URB */
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;current_urb_sem
)paren
)paren
suffix:semicolon
multiline_comment|/* fill the URB */
id|FILL_CONTROL_URB
c_func
(paren
id|us-&gt;current_urb
comma
id|us-&gt;pusb_dev
comma
id|pipe
comma
(paren
r_int
r_char
op_star
)paren
id|dr
comma
id|data
comma
id|size
comma
id|usb_stor_blocking_completion
comma
op_amp
id|awd
)paren
suffix:semicolon
multiline_comment|/* submit the URB */
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|status
op_assign
id|usb_submit_urb
c_func
(paren
id|us-&gt;current_urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
multiline_comment|/* something went wrong */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;current_urb_sem
)paren
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|wqh
comma
op_amp
id|wait
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dr
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* wait for the completion of the URB */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;current_urb_sem
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;current_urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;current_urb_sem
)paren
)paren
suffix:semicolon
multiline_comment|/* we either timed out or got woken up -- clean up either way */
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|wqh
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* return the actual length of the data transferred if no error*/
id|status
op_assign
id|us-&gt;current_urb-&gt;status
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ge
l_int|0
)paren
id|status
op_assign
id|us-&gt;current_urb-&gt;actual_length
suffix:semicolon
multiline_comment|/* release the lock and return status */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;current_urb_sem
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dr
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* This is our function to emulate usb_bulk_msg() but give us enough&n; * access to make aborts/resets work&n; */
DECL|function|usb_stor_bulk_msg
r_int
id|usb_stor_bulk_msg
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_void
op_star
id|data
comma
r_int
id|pipe
comma
r_int
r_int
id|len
comma
r_int
r_int
op_star
id|act_len
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|wqh
)paren
suffix:semicolon
id|api_wrapper_data
id|awd
suffix:semicolon
r_int
id|status
suffix:semicolon
multiline_comment|/* set up data structures for the wakeup system */
id|awd.wakeup
op_assign
op_amp
id|wqh
suffix:semicolon
id|awd.handler
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|wqh
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|wqh
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* lock the URB */
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;current_urb_sem
)paren
)paren
suffix:semicolon
multiline_comment|/* fill the URB */
id|FILL_BULK_URB
c_func
(paren
id|us-&gt;current_urb
comma
id|us-&gt;pusb_dev
comma
id|pipe
comma
id|data
comma
id|len
comma
id|usb_stor_blocking_completion
comma
op_amp
id|awd
)paren
suffix:semicolon
multiline_comment|/* submit the URB */
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|status
op_assign
id|usb_submit_urb
c_func
(paren
id|us-&gt;current_urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
multiline_comment|/* something went wrong */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;current_urb_sem
)paren
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|wqh
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* wait for the completion of the URB */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;current_urb_sem
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;current_urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;current_urb_sem
)paren
)paren
suffix:semicolon
multiline_comment|/* we either timed out or got woken up -- clean up either way */
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|wqh
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* return the actual length of the data transferred */
op_star
id|act_len
op_assign
id|us-&gt;current_urb-&gt;actual_length
suffix:semicolon
multiline_comment|/* release the lock and return status */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;current_urb_sem
)paren
)paren
suffix:semicolon
r_return
id|us-&gt;current_urb-&gt;status
suffix:semicolon
)brace
multiline_comment|/*&n; * Transfer one SCSI scatter-gather buffer via bulk transfer&n; *&n; * Note that this function is necessary because we want the ability to&n; * use scatter-gather memory.  Good performance is achieved by a combination&n; * of scatter-gather and clustering (which makes each chunk bigger).&n; *&n; * Note that the lower layer will always retry when a NAK occurs, up to the&n; * timeout limit.  Thus we don&squot;t have to worry about it for individual&n; * packets.&n; */
DECL|function|us_transfer_partial
r_static
r_int
id|us_transfer_partial
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_char
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|partial
suffix:semicolon
r_int
id|pipe
suffix:semicolon
multiline_comment|/* calculate the appropriate pipe information */
r_if
c_cond
(paren
id|US_DIRECTION
c_func
(paren
id|us-&gt;srb-&gt;cmnd
(braket
l_int|0
)braket
)paren
)paren
id|pipe
op_assign
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_in
)paren
suffix:semicolon
r_else
id|pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
suffix:semicolon
multiline_comment|/* transfer the data */
id|US_DEBUGP
c_func
(paren
l_string|&quot;us_transfer_partial(): xfer %d bytes&bslash;n&quot;
comma
id|length
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_msg
c_func
(paren
id|us
comma
id|buf
comma
id|pipe
comma
id|length
comma
op_amp
id|partial
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_stor_bulk_msg() returned %d xferred %d/%d&bslash;n&quot;
comma
id|result
comma
id|partial
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* if we stall, we need to clear it before we go on */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;clearing endpoint halt for pipe 0x%x&bslash;n&quot;
comma
id|pipe
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
)brace
multiline_comment|/* did we send all the data? */
r_if
c_cond
(paren
id|partial
op_eq
id|length
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;us_transfer_partial(): transfer complete&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_GOOD
suffix:semicolon
)brace
multiline_comment|/* uh oh... we have an error code, so something went wrong. */
r_if
c_cond
(paren
id|result
)paren
(brace
multiline_comment|/* NAK - that means we&squot;ve retried a few times allready */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;us_transfer_partial(): device NAKed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_FAILED
suffix:semicolon
)brace
multiline_comment|/* -ENOENT -- we canceled this transfer */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;us_transfer_partial(): transfer aborted&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_ABORTED
suffix:semicolon
)brace
multiline_comment|/* the catch-all case */
id|US_DEBUGP
c_func
(paren
l_string|&quot;us_transfer_partial(): unknown error&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_FAILED
suffix:semicolon
)brace
multiline_comment|/* no error code, so we must have transferred some data, &n;&t; * just not all of it */
r_return
id|US_BULK_TRANSFER_SHORT
suffix:semicolon
)brace
multiline_comment|/*&n; * Transfer an entire SCSI command&squot;s worth of data payload over the bulk&n; * pipe.&n; *&n; * Note that this uses us_transfer_partial to achieve it&squot;s goals -- this&n; * function simply determines if we&squot;re going to use scatter-gather or not,&n; * and acts appropriately.  For now, it also re-interprets the error codes.&n; */
DECL|function|us_transfer
r_static
r_void
id|us_transfer
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
comma
r_int
id|dir_in
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
multiline_comment|/* are we scatter-gathering? */
r_if
c_cond
(paren
id|srb-&gt;use_sg
)paren
(brace
multiline_comment|/* loop over all the scatter gather structures and &n;&t;&t; * make the appropriate requests for each, until done&n;&t;&t; */
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|srb-&gt;request_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|srb-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
id|result
op_assign
id|us_transfer_partial
c_func
(paren
id|us
comma
id|sg
(braket
id|i
)braket
dot
id|address
comma
id|sg
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_break
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* no scatter-gather, just make the request */
id|result
op_assign
id|us_transfer_partial
c_func
(paren
id|us
comma
id|srb-&gt;request_buffer
comma
id|srb-&gt;request_bufflen
)paren
suffix:semicolon
multiline_comment|/* return the result in the data structure itself */
id|srb-&gt;result
op_assign
id|result
suffix:semicolon
)brace
multiline_comment|/* Calculate the length of the data transfer (not the command) for any&n; * given SCSI command&n; */
DECL|function|us_transfer_length
r_static
r_int
r_int
id|us_transfer_length
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|total
op_assign
l_int|0
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
multiline_comment|/* support those devices which need the length calculated&n;&t; * differently &n;&t; */
r_if
c_cond
(paren
id|us-&gt;flags
op_amp
id|US_FL_ALT_LENGTH
)paren
(brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
(brace
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_assign
l_int|36
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE
)paren
)paren
r_return
id|srb-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|TEST_UNIT_READY
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Are we going to scatter gather? */
r_if
c_cond
(paren
id|srb-&gt;use_sg
)paren
(brace
multiline_comment|/* Add up the sizes of all the scatter-gather segments */
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|srb-&gt;request_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|srb-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
id|total
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
r_return
id|total
suffix:semicolon
)brace
r_else
multiline_comment|/* Just return the length of the buffer */
r_return
id|srb-&gt;request_bufflen
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Transport routines&n; ***********************************************************************/
multiline_comment|/* Invoke the transport and basic error-handling/recovery methods&n; *&n; * This is used by the protocol layers to actually send the message to&n; * the device and recieve the response.&n; */
DECL|function|usb_stor_invoke_transport
r_void
id|usb_stor_invoke_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|need_auto_sense
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* send the command to the transport layer */
id|result
op_assign
id|us
op_member_access_from_pointer
id|transport
c_func
(paren
id|srb
comma
id|us
)paren
suffix:semicolon
multiline_comment|/* if the command gets aborted by the higher layers, we need to&n;&t; * short-circuit all other processing&n;&t; */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_ABORTED
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transport indicates command was aborted&bslash;n&quot;
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Determine if we need to auto-sense&n;&t; *&n;&t; * I normally don&squot;t use a flag like this, but it&squot;s almost impossible&n;&t; * to understand what&squot;s going on here if I don&squot;t.&n;&t; */
id|need_auto_sense
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re running the CB transport, which is incapable&n;&t; * of determining status on it&squot;s own, we need to auto-sense almost&n;&t; * every time.&n;&t; */
r_if
c_cond
(paren
id|us-&gt;protocol
op_eq
id|US_PR_CB
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- CB transport device requiring auto-sense&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* There are some exceptions to this.  Notably, if this is&n;&t;&t; * a UFI device and the command is REQUEST_SENSE or INQUIRY,&n;&t;&t; * then it is impossible to truly determine status.&n;&t;&t; */
r_if
c_cond
(paren
id|us-&gt;subclass
op_eq
id|US_SC_UFI
op_logical_and
(paren
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;** no auto-sense for a special command&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If we have an error, we&squot;re going to do a REQUEST_SENSE &n;&t; * automatically.  Note that we differentiate between a command&n;&t; * &quot;failure&quot; and an &quot;error&quot; in the transport mechanism.&n;&t; */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_FAILED
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transport indicates command failure&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_ERROR
)paren
(brace
multiline_comment|/* FIXME: we need to invoke a transport reset here */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transport indicates transport failure&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Also, if we have a short transfer on a command that can&squot;t have&n;&t; * a short transfer, we&squot;re going to do this.&n;&t; */
r_if
c_cond
(paren
(paren
id|srb-&gt;result
op_eq
id|US_BULK_TRANSFER_SHORT
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|LOG_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE_10
)paren
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- unexpectedly short transfer&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now, if we need to do the auto-sense, let&squot;s do it */
r_if
c_cond
(paren
id|need_auto_sense
)paren
(brace
r_int
id|temp_result
suffix:semicolon
r_void
op_star
id|old_request_buffer
suffix:semicolon
r_int
id|old_sg
suffix:semicolon
r_int
id|old_request_bufflen
suffix:semicolon
r_int
r_char
id|old_cmnd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Issuing auto-REQUEST_SENSE&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* save the old command */
id|memcpy
c_func
(paren
id|old_cmnd
comma
id|srb-&gt;cmnd
comma
id|MAX_COMMAND_SIZE
)paren
suffix:semicolon
multiline_comment|/* set the command and the LUN */
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|old_cmnd
(braket
l_int|1
)braket
op_amp
l_int|0xE0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_assign
l_int|18
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set the buffer length for transfer */
id|old_request_buffer
op_assign
id|srb-&gt;request_buffer
suffix:semicolon
id|old_request_bufflen
op_assign
id|srb-&gt;request_bufflen
suffix:semicolon
id|old_sg
op_assign
id|srb-&gt;use_sg
suffix:semicolon
id|srb-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;request_bufflen
op_assign
l_int|18
suffix:semicolon
id|srb-&gt;request_buffer
op_assign
id|srb-&gt;sense_buffer
suffix:semicolon
multiline_comment|/* issue the auto-sense command */
id|temp_result
op_assign
id|us
op_member_access_from_pointer
id|transport
c_func
(paren
id|us-&gt;srb
comma
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp_result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
multiline_comment|/* FIXME: we need to invoke a transport reset here */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- auto-sense failure&bslash;n&quot;
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_return
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Result from auto-sense is %d&bslash;n&quot;
comma
id|temp_result
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- code: 0x%x, key: 0x%x, ASC: 0x%x, ASCQ: 0x%x&bslash;n&quot;
comma
id|srb-&gt;sense_buffer
(braket
l_int|0
)braket
comma
id|srb-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
comma
id|srb-&gt;sense_buffer
(braket
l_int|12
)braket
comma
id|srb-&gt;sense_buffer
(braket
l_int|13
)braket
)paren
suffix:semicolon
multiline_comment|/* set the result so the higher layers expect this data */
id|srb-&gt;result
op_assign
id|CHECK_CONDITION
suffix:semicolon
multiline_comment|/* we&squot;re done here, let&squot;s clean up */
id|srb-&gt;request_buffer
op_assign
id|old_request_buffer
suffix:semicolon
id|srb-&gt;request_bufflen
op_assign
id|old_request_bufflen
suffix:semicolon
id|srb-&gt;use_sg
op_assign
id|old_sg
suffix:semicolon
id|memcpy
c_func
(paren
id|srb-&gt;cmnd
comma
id|old_cmnd
comma
id|MAX_COMMAND_SIZE
)paren
suffix:semicolon
multiline_comment|/* If things are really okay, then let&squot;s show that */
r_if
c_cond
(paren
(paren
id|srb-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
l_int|0x0
)paren
id|srb-&gt;result
op_assign
id|GOOD
suffix:semicolon
)brace
r_else
multiline_comment|/* if (need_auto_sense) */
id|srb-&gt;result
op_assign
id|GOOD
suffix:semicolon
multiline_comment|/* Regardless of auto-sense, if we _know_ we have an error&n;&t; * condition, show that in the result code&n;&t; */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_FAILED
)paren
id|srb-&gt;result
op_assign
id|CHECK_CONDITION
suffix:semicolon
multiline_comment|/* If we think we&squot;re good, then make sure the sense data shows it.&n;&t; * This is necessary because the auto-sense for some devices always&n;&t; * sets byte 0 == 0x70, even if there is no error&n;&t; */
r_if
c_cond
(paren
(paren
id|us-&gt;protocol
op_eq
id|US_PR_CB
)paren
op_logical_and
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_GOOD
)paren
op_logical_and
(paren
(paren
id|srb-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
l_int|0x0
)paren
)paren
id|srb-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x0
suffix:semicolon
)brace
multiline_comment|/*&n; * Control/Bulk/Interrupt transport&n; */
multiline_comment|/* The interrupt handler for CBI devices */
DECL|function|usb_stor_CBI_irq
r_void
id|usb_stor_CBI_irq
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|urb-&gt;context
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;USB IRQ recieved for device on host %d&bslash;n&quot;
comma
id|us-&gt;host_no
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- IRQ data length is %d&bslash;n&quot;
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- IRQ state is %d&bslash;n&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
multiline_comment|/* is the device removed? */
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
op_minus
id|ENOENT
)paren
(brace
multiline_comment|/* save the data for interpretation later */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Interrupt Status (0x%x, 0x%x)&bslash;n&quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|urb-&gt;transfer_buffer
)paren
(braket
l_int|0
)braket
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|urb-&gt;transfer_buffer
)paren
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* was this a wanted interrupt? */
r_if
c_cond
(paren
id|us-&gt;ip_wanted
)paren
(brace
id|us-&gt;ip_wanted
op_assign
l_int|0
suffix:semicolon
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;ip_waitq
)paren
)paren
suffix:semicolon
)brace
r_else
id|US_DEBUGP
c_func
(paren
l_string|&quot;ERROR: Unwanted interrupt received!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- device has been removed&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|usb_stor_CBI_transport
r_int
id|usb_stor_CBI_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
multiline_comment|/* COMMAND STAGE */
multiline_comment|/* let&squot;s send the command via the control pipe */
id|result
op_assign
id|usb_stor_control_msg
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
id|US_CBI_ADSC
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
id|srb-&gt;cmnd
comma
id|srb-&gt;cmd_len
)paren
suffix:semicolon
multiline_comment|/* check the return code for the command */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Call to usb_stor_control_msg() returned %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* if the command was aborted, indicate that */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
r_return
id|USB_STOR_TRANSPORT_ABORTED
suffix:semicolon
multiline_comment|/* STALL must be cleared when they are detected */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Stall on control pipe. Clearing&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- usb_clear_halt() returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/* Uh oh... serious problem here */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* Set up for status notification */
id|us-&gt;ip_wanted
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* DATA STAGE */
multiline_comment|/* transfer the data payload for this command, if one exists*/
r_if
c_cond
(paren
id|us_transfer_length
c_func
(paren
id|srb
comma
id|us
)paren
)paren
(brace
id|us_transfer
c_func
(paren
id|srb
comma
id|us
comma
id|US_DIRECTION
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;CBI data stage result is 0x%x&bslash;n&quot;
comma
id|srb-&gt;result
)paren
suffix:semicolon
multiline_comment|/* if it was aborted, we need to indicate that */
r_if
c_cond
(paren
id|srb-&gt;result
op_eq
id|USB_STOR_TRANSPORT_ABORTED
)paren
r_return
id|USB_STOR_TRANSPORT_ABORTED
suffix:semicolon
)brace
multiline_comment|/* STATUS STAGE */
multiline_comment|/* go to sleep until we get this interrupt */
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;ip_waitq
)paren
)paren
suffix:semicolon
multiline_comment|/* if we were woken up by an abort instead of the actual interrupt */
r_if
c_cond
(paren
id|us-&gt;ip_wanted
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Did not get interrupt on CBI&bslash;n&quot;
)paren
suffix:semicolon
id|us-&gt;ip_wanted
op_assign
l_int|0
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ABORTED
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Got interrupt data (0x%x, 0x%x)&bslash;n&quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|us-&gt;irq_urb-&gt;transfer_buffer
)paren
(braket
l_int|0
)braket
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|us-&gt;irq_urb-&gt;transfer_buffer
)paren
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* UFI gives us ASC and ASCQ, like a request sense&n;&t; *&n;&t; * REQUEST_SENSE and INQUIRY don&squot;t affect the sense data on UFI&n;&t; * devices, so we ignore the information for those commands.  Note&n;&t; * that this means we could be ignoring a real error on these&n;&t; * commands, but that can&squot;t be helped.&n;&t; */
r_if
c_cond
(paren
id|us-&gt;subclass
op_eq
id|US_SC_UFI
)paren
(brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_or
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|us-&gt;irq_urb-&gt;transfer_buffer
)paren
(braket
l_int|0
)braket
)paren
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_else
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/* If not UFI, we interpret the data as a result code &n;&t; * The first byte should always be a 0x0&n;&t; * The second byte &amp; 0x0F should be 0x0 for good, otherwise error &n;&t; */
r_if
c_cond
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|us-&gt;irq_urb-&gt;transfer_buffer
)paren
(braket
l_int|0
)braket
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;CBI IRQ data showed reserved bType&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_switch
c_cond
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|us-&gt;irq_urb-&gt;transfer_buffer
)paren
(braket
l_int|1
)braket
op_amp
l_int|0x0F
)paren
(brace
r_case
l_int|0x00
suffix:colon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_case
l_int|0x01
suffix:colon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_default
suffix:colon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* we should never get here, but if we do, we&squot;re in trouble */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/*&n; * Control/Bulk transport&n; */
DECL|function|usb_stor_CB_transport
r_int
id|usb_stor_CB_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
multiline_comment|/* COMMAND STAGE */
multiline_comment|/* let&squot;s send the command via the control pipe */
id|result
op_assign
id|usb_stor_control_msg
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
id|US_CBI_ADSC
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
id|srb-&gt;cmnd
comma
id|srb-&gt;cmd_len
)paren
suffix:semicolon
multiline_comment|/* check the return code for the command */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Call to usb_stor_control_msg() returned %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* if the command was aborted, indicate that */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
r_return
id|USB_STOR_TRANSPORT_ABORTED
suffix:semicolon
multiline_comment|/* a stall is a fatal condition from the device */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Stall on control pipe. Clearing&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- usb_clear_halt() returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/* Uh oh... serious problem here */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* DATA STAGE */
multiline_comment|/* transfer the data payload for this command, if one exists*/
r_if
c_cond
(paren
id|us_transfer_length
c_func
(paren
id|srb
comma
id|us
)paren
)paren
(brace
id|us_transfer
c_func
(paren
id|srb
comma
id|us
comma
id|US_DIRECTION
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;CB data stage result is 0x%x&bslash;n&quot;
comma
id|srb-&gt;result
)paren
suffix:semicolon
multiline_comment|/* if it was aborted, we need to indicate that */
r_if
c_cond
(paren
id|srb-&gt;result
op_eq
id|USB_STOR_TRANSPORT_ABORTED
)paren
r_return
id|USB_STOR_TRANSPORT_ABORTED
suffix:semicolon
)brace
multiline_comment|/* STATUS STAGE */
multiline_comment|/* NOTE: CB does not have a status stage.  Silly, I know.  So&n;&t; * we have to catch this at a higher level.&n;&t; */
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Bulk only transport&n; */
multiline_comment|/* Determine what the maximum LUN supported is */
DECL|function|usb_stor_Bulk_max_lun
r_int
id|usb_stor_Bulk_max_lun
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_char
id|data
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|pipe
suffix:semicolon
multiline_comment|/* issue the command */
id|pipe
op_assign
id|usb_rcvctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
suffix:semicolon
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
comma
id|US_BULK_GET_MAX_LUN
comma
id|USB_DIR_IN
op_or
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
op_amp
id|data
comma
r_sizeof
(paren
id|data
)paren
comma
id|HZ
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;GetMaxLUN command result is %d, data is %d&bslash;n&quot;
comma
id|result
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* if we have a successful request, return the result */
r_if
c_cond
(paren
id|result
op_eq
l_int|1
)paren
r_return
id|data
suffix:semicolon
multiline_comment|/* if we get a STALL, clear the stall */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;clearing endpoint halt for pipe 0x%x&bslash;n&quot;
comma
id|pipe
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
)brace
multiline_comment|/* return the default -- no LUNs */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_stor_Bulk_transport
r_int
id|usb_stor_Bulk_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|bulk_cb_wrap
id|bcb
suffix:semicolon
r_struct
id|bulk_cs_wrap
id|bcs
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|pipe
suffix:semicolon
r_int
id|partial
suffix:semicolon
multiline_comment|/* set up the command wrapper */
id|bcb.Signature
op_assign
id|cpu_to_le32
c_func
(paren
id|US_BULK_CB_SIGN
)paren
suffix:semicolon
id|bcb.DataTransferLength
op_assign
id|cpu_to_le32
c_func
(paren
id|us_transfer_length
c_func
(paren
id|srb
comma
id|us
)paren
)paren
suffix:semicolon
id|bcb.Flags
op_assign
id|US_DIRECTION
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)paren
op_lshift
l_int|7
suffix:semicolon
id|bcb.Tag
op_assign
id|srb-&gt;serial_number
suffix:semicolon
id|bcb.Lun
op_assign
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_rshift
l_int|5
suffix:semicolon
id|bcb.Length
op_assign
id|srb-&gt;cmd_len
suffix:semicolon
multiline_comment|/* construct the pipe handle */
id|pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
suffix:semicolon
multiline_comment|/* copy the command payload */
id|memset
c_func
(paren
id|bcb.CDB
comma
l_int|0
comma
r_sizeof
(paren
id|bcb.CDB
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bcb.CDB
comma
id|srb-&gt;cmnd
comma
id|bcb.Length
)paren
suffix:semicolon
multiline_comment|/* send it to out endpoint */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk command S 0x%x T 0x%x LUN %d L %d F %d CL %d&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|bcb.Signature
)paren
comma
id|bcb.Tag
comma
id|bcb.Lun
comma
id|bcb.DataTransferLength
comma
id|bcb.Flags
comma
id|bcb.Length
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_msg
c_func
(paren
id|us
comma
op_amp
id|bcb
comma
id|pipe
comma
id|US_BULK_CB_WRAP_LEN
comma
op_amp
id|partial
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk command transfer result=%d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
multiline_comment|/* if the command was aborted, indicate that */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
r_return
id|USB_STOR_TRANSPORT_ABORTED
suffix:semicolon
multiline_comment|/* if we stall, we need to clear it before we go on */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;clearing endpoint halt for pipe 0x%x&bslash;n&quot;
comma
id|pipe
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
)paren
(brace
multiline_comment|/* unknown error -- we&squot;ve got a problem */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* if the command transfered well, then we go to the data stage */
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
multiline_comment|/* send/receive data payload, if there is any */
r_if
c_cond
(paren
id|bcb.DataTransferLength
)paren
(brace
id|us_transfer
c_func
(paren
id|srb
comma
id|us
comma
id|bcb.Flags
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk data transfer result 0x%x&bslash;n&quot;
comma
id|srb-&gt;result
)paren
suffix:semicolon
multiline_comment|/* if it was aborted, we need to indicate that */
r_if
c_cond
(paren
id|srb-&gt;result
op_eq
id|USB_STOR_TRANSPORT_ABORTED
)paren
r_return
id|USB_STOR_TRANSPORT_ABORTED
suffix:semicolon
)brace
)brace
multiline_comment|/* See flow chart on pg 15 of the Bulk Only Transport spec for&n;&t; * an explanation of how this code works.&n;&t; */
multiline_comment|/* construct the pipe handle */
id|pipe
op_assign
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_in
)paren
suffix:semicolon
multiline_comment|/* get CSW for device status */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Attempting to get CSW...&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_msg
c_func
(paren
id|us
comma
op_amp
id|bcs
comma
id|pipe
comma
id|US_BULK_CS_WRAP_LEN
comma
op_amp
id|partial
)paren
suffix:semicolon
multiline_comment|/* if the command was aborted, indicate that */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
r_return
id|USB_STOR_TRANSPORT_ABORTED
suffix:semicolon
multiline_comment|/* did the attempt to read the CSW fail? */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;clearing endpoint halt for pipe 0x%x&bslash;n&quot;
comma
id|pipe
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
multiline_comment|/* get the status again */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Attempting to get CSW (2nd try)...&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_msg
c_func
(paren
id|us
comma
op_amp
id|bcs
comma
id|pipe
comma
id|US_BULK_CS_WRAP_LEN
comma
op_amp
id|partial
)paren
suffix:semicolon
multiline_comment|/* if the command was aborted, indicate that */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
r_return
id|USB_STOR_TRANSPORT_ABORTED
suffix:semicolon
multiline_comment|/* if it fails again, we need a reset and return an error*/
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;clearing halt for pipe 0x%x&bslash;n&quot;
comma
id|pipe
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
)brace
multiline_comment|/* if we still have a failure at this point, we&squot;re in trouble */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk status result = %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* check bulk status */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk status S 0x%x T 0x%x R %d V 0x%x&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|bcs.Signature
)paren
comma
id|bcs.Tag
comma
id|bcs.Residue
comma
id|bcs.Status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bcs.Signature
op_ne
id|cpu_to_le32
c_func
(paren
id|US_BULK_CS_SIGN
)paren
op_logical_or
id|bcs.Tag
op_ne
id|bcb.Tag
op_logical_or
id|bcs.Status
OG
id|US_BULK_STAT_PHASE
op_logical_or
id|partial
op_ne
l_int|13
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk logical error&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* based on the status code, we report good or bad */
r_switch
c_cond
(paren
id|bcs.Status
)paren
(brace
r_case
id|US_BULK_STAT_OK
suffix:colon
multiline_comment|/* command good -- note that we could be short on data */
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_case
id|US_BULK_STAT_FAIL
suffix:colon
multiline_comment|/* command failed */
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_case
id|US_BULK_STAT_PHASE
suffix:colon
multiline_comment|/* phase error */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* we should never get here, but if we do, we&squot;re in trouble */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Reset routines&n; ***********************************************************************/
multiline_comment|/* This issues a CB[I] Reset to the device in question&n; */
DECL|function|usb_stor_CB_reset
r_int
id|usb_stor_CB_reset
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_char
id|cmd
(braket
l_int|12
)braket
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;CB_reset() called&bslash;n&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cmd
comma
l_int|0xFF
comma
r_sizeof
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|SEND_DIAGNOSTIC
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
l_int|4
suffix:semicolon
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
id|US_CBI_ADSC
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
id|cmd
comma
r_sizeof
(paren
id|cmd
)paren
comma
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
multiline_comment|/* long wait for reset */
id|schedule_timeout
c_func
(paren
id|HZ
op_star
l_int|6
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;CB_reset: clearing endpoint halt&bslash;n&quot;
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_in
)paren
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;CB_reset done&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* FIXME: Does this work? */
DECL|function|usb_stor_Bulk_reset
r_int
id|usb_stor_Bulk_reset
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
id|US_BULK_RESET_REQUEST
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk hard reset failed %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_in
)paren
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
)paren
suffix:semicolon
multiline_comment|/* long wait for reset */
id|schedule_timeout
c_func
(paren
id|HZ
op_star
l_int|6
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
eof
