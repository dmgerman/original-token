multiline_comment|/* Driver for SCM Microsystems USB-ATAPI cable&n; *&n; * SCM driver v0.1&n; *&n; * Current development and maintainance by:&n; *   (c) 2000 Robert Baruch (autophile@dol.net)&n; *&n; * Many originally ATAPI devices were slightly modified to meet the USB&n; * market by using some kind of translation from ATAPI to USB on the host,&n; * and the peripheral would translate from USB back to ATAPI.&n; *&n; * SCM Microsystems (www.scmmicro.com) makes a device, sold to OEM&squot;s only, &n; * which does the USB-to-ATAPI conversion.  By obtaining the data sheet on&n; * their device under nondisclosure agreement, I have been able to write&n; * this driver for Linux.&n; *&n; * The chip used in the device can also be used for EPP and ISA translation&n; * as well. This driver is only guaranteed to work with the ATAPI&n; * translation.&n; *&n; * The only peripherals that I know of (as of 14 Jul 2000) that uses this&n; * device is the Hewlett-Packard 8200e CD-Writer Plus.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;scm.h&quot;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
r_extern
r_int
id|usb_stor_control_msg
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
comma
id|u8
id|request
comma
id|u8
id|requesttype
comma
id|u16
id|value
comma
id|u16
id|index
comma
r_void
op_star
id|data
comma
id|u16
id|size
)paren
suffix:semicolon
r_extern
r_int
id|usb_stor_bulk_msg
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_void
op_star
id|data
comma
r_int
id|pipe
comma
r_int
r_int
id|len
comma
r_int
r_int
op_star
id|act_len
)paren
suffix:semicolon
multiline_comment|/*&n; * Send a control message and wait for the response.&n; *&n; * us - the pointer to the us_data structure for the device to use&n; *&n; * request - the URB Setup Packet&squot;s first 6 bytes. The first byte always&n; *  corresponds to the request type, and the second byte always corresponds&n; *  to the request.  The other 4 bytes do not correspond to value and index,&n; *  since they are used in a custom way by the SCM protocol.&n; *&n; * xfer_data - a buffer from which to get, or to which to store, any data&n; *  that gets send or received, respectively, with the URB. Even though&n; *  it looks like we allocate a buffer in this code for the data, xfer_data&n; *  must contain enough allocated space.&n; *&n; * xfer_len - the number of bytes to send or receive with the URB.&n; *&n; */
DECL|function|scm_send_control
r_static
r_int
id|scm_send_control
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|command
(braket
l_int|8
)braket
comma
r_int
r_char
op_star
id|xfer_data
comma
r_int
r_int
id|xfer_len
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|pipe
suffix:semicolon
r_void
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
id|command
(braket
l_int|6
)braket
op_assign
id|xfer_len
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|7
)braket
op_assign
(paren
id|xfer_len
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
singleline_comment|// Get the receive or send control pipe number, based on
singleline_comment|// the direction indicated by the request type.
r_if
c_cond
(paren
id|command
(braket
l_int|0
)braket
op_amp
id|USB_DIR_IN
)paren
id|pipe
op_assign
id|usb_rcvctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
suffix:semicolon
r_else
id|pipe
op_assign
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
suffix:semicolon
singleline_comment|// If data is going to be sent or received with the URB,
singleline_comment|// then allocate a buffer for it. If data is to be sent,
singleline_comment|// copy the data into the buffer.
r_if
c_cond
(paren
id|xfer_len
OG
l_int|0
)paren
(brace
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|xfer_len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|command
(braket
l_int|0
)braket
op_amp
id|USB_DIR_IN
)paren
)paren
id|memcpy
c_func
(paren
id|buffer
comma
id|xfer_data
comma
id|xfer_len
)paren
suffix:semicolon
)brace
singleline_comment|// Send the URB to the device and wait for a response.
multiline_comment|/* Why are request and request type reversed in this call? */
id|result
op_assign
id|usb_stor_control_msg
c_func
(paren
id|us
comma
id|pipe
comma
id|command
(braket
l_int|1
)braket
comma
id|command
(braket
l_int|0
)braket
comma
(paren
(paren
(paren
r_int
r_int
)paren
id|command
(braket
l_int|3
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|command
(braket
l_int|2
)braket
comma
(paren
(paren
(paren
r_int
r_int
)paren
id|command
(braket
l_int|5
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|command
(braket
l_int|3
)braket
comma
id|buffer
comma
id|xfer_len
)paren
suffix:semicolon
singleline_comment|// If data was sent or received with the URB, free the buffer we
singleline_comment|// allocated earlier, but not before reading the data out of the
singleline_comment|// buffer if we wanted to receive data.
r_if
c_cond
(paren
id|xfer_len
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|command
(braket
l_int|0
)braket
op_amp
id|USB_DIR_IN
)paren
id|memcpy
c_func
(paren
id|xfer_data
comma
id|buffer
comma
id|xfer_len
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
singleline_comment|// Check the return code for the command.
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* a stall is a fatal condition from the device */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Stall on control pipe. Clearing&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- usb_clear_halt() returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/* Uh oh... serious problem here */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
DECL|function|scm_raw_bulk
r_static
r_int
id|scm_raw_bulk
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|pipe
comma
r_int
id|maxlen
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|transferred
op_assign
l_int|0
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|act_len
suffix:semicolon
r_int
id|partial_len
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
id|maxlen
op_assign
id|len
suffix:semicolon
singleline_comment|// while (transferred &lt; len) {
singleline_comment|// We want to transfer up to maxlen bytes
id|partial_len
op_assign
id|len
op_minus
id|transferred
OG
id|maxlen
ques
c_cond
id|maxlen
suffix:colon
id|len
op_minus
id|transferred
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_msg
c_func
(paren
id|us
comma
id|data
op_plus
id|transferred
comma
id|pipe
comma
id|partial_len
comma
op_amp
id|act_len
)paren
suffix:semicolon
multiline_comment|/* if we stall, we need to clear it before we go on */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;EPIPE: clearing endpoint halt for&quot;
l_string|&quot; pipe 0x%x, stalled at %d bytes&bslash;n&quot;
comma
id|pipe
comma
id|act_len
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
singleline_comment|// What the hey is goin&squot; on?
multiline_comment|/* US_DEBUGP(&quot;EPIPE: Trying to retransmit bulk data...&bslash;n&quot;);&n;&n;&t;&t;&t;wait_ms(10);&n;&t;&n;&t;&t;&t;result = usb_stor_bulk_msg(us, data+act_len,&n;&t;&t;&t;&t;pipe, len-act_len, &amp;act_len);&n;&n;&t;&t;&t;if (result==0)&n;&t;&t;&t;&t;US_DEBUGP(&quot;EPIPE: Retransmit successful&bslash;n&quot;); */
id|wait_ms
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Trying to get status&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|scm_read
c_func
(paren
id|us
comma
id|SCM_ATA
comma
l_int|0x17
comma
op_amp
id|status
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;SCM: Write ATA data status is %02X&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EPIPE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
)paren
(brace
multiline_comment|/* NAK - that means we&squot;ve retried a few times already */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;scm_raw_bulk():&quot;
l_string|&quot; device NAKed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_FAILED
suffix:semicolon
)brace
multiline_comment|/* -ENOENT -- we canceled this transfer */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;scm_raw_bulk():&quot;
l_string|&quot; transfer aborted&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_ABORTED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;scm_raw_bulk():&quot;
l_string|&quot; output pipe stalled&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/* the catch-all case */
id|US_DEBUGP
c_func
(paren
l_string|&quot;us_transfer_partial(): unknown error&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|act_len
op_ne
id|partial_len
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Warning: Transferred only %d bytes&bslash;n&quot;
comma
id|act_len
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_SHORT
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Transfered %d of %d bytes&bslash;n&quot;
comma
id|act_len
comma
id|partial_len
)paren
suffix:semicolon
id|transferred
op_add_assign
id|act_len
suffix:semicolon
singleline_comment|// } // while transferred &lt; len
r_return
id|US_BULK_TRANSFER_GOOD
suffix:semicolon
)brace
DECL|function|scm_bulk_transport
r_static
r_int
id|scm_bulk_transport
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|command
comma
r_int
r_int
id|command_len
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
comma
r_int
id|use_sg
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|transferred
op_assign
l_int|0
suffix:semicolon
r_int
id|maxlen
suffix:semicolon
r_int
r_char
id|execute
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x40
comma
l_int|0x80
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|pipe
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_char
id|string
(braket
l_int|64
)braket
suffix:semicolon
id|maxlen
op_assign
id|us-&gt;pusb_dev-&gt;actconfig
op_member_access_from_pointer
id|interface
(braket
l_int|0
)braket
dot
id|altsetting
(braket
l_int|0
)braket
dot
id|endpoint
(braket
(paren
(paren
id|command
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
ques
c_cond
id|us-&gt;ep_in
suffix:colon
id|us-&gt;ep_out
)paren
op_minus
l_int|1
)braket
dot
id|wMaxPacketSize
suffix:semicolon
multiline_comment|/* Fix up the command&squot;s data length */
id|command
(braket
l_int|6
)braket
op_assign
id|len
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|7
)braket
op_assign
(paren
id|len
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|result
op_assign
id|scm_send_control
c_func
(paren
id|us
comma
id|execute
comma
id|command
comma
id|command_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
id|result
suffix:semicolon
multiline_comment|/* transfer the data payload for the command, if there is any */
r_if
c_cond
(paren
id|command
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
id|pipe
op_assign
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_in
)paren
suffix:semicolon
r_else
(brace
id|pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
suffix:semicolon
multiline_comment|/* Debug-print the first 48 bytes of the transfer */
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
(brace
id|string
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_logical_and
id|i
OL
l_int|48
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|string
op_plus
id|strlen
c_func
(paren
id|string
)paren
comma
l_string|&quot;%02X &quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|15
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
id|string
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|string
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
)brace
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;HP 8200e data %s maxlen %d transfer %d sg buffers %d&bslash;n&quot;
comma
(paren
(paren
id|command
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
)paren
comma
id|maxlen
comma
id|len
comma
id|use_sg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
id|result
op_assign
id|scm_raw_bulk
c_func
(paren
id|us
comma
id|pipe
comma
id|maxlen
comma
id|data
comma
id|len
)paren
suffix:semicolon
r_else
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|data
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|use_sg
op_logical_and
id|transferred
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|result
op_assign
id|scm_raw_bulk
c_func
(paren
id|us
comma
id|pipe
comma
id|maxlen
comma
id|sg
(braket
id|i
)braket
dot
id|address
comma
id|len
op_minus
id|transferred
OG
id|sg
(braket
id|i
)braket
dot
id|length
ques
c_cond
id|sg
(braket
id|i
)braket
dot
id|length
suffix:colon
id|len
op_minus
id|transferred
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
r_break
suffix:semicolon
id|transferred
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|scm_read
r_int
id|scm_read
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|access
comma
r_int
r_char
id|reg
comma
r_int
r_char
op_star
id|content
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0xC0
comma
id|access
comma
id|reg
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
id|result
op_assign
id|scm_send_control
c_func
(paren
id|us
comma
id|command
comma
id|content
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
singleline_comment|// US_DEBUGP(&quot;SCM: Reg %d -&gt; %02X&bslash;n&quot;, reg, *content);
r_return
id|result
suffix:semicolon
)brace
DECL|function|scm_write
r_int
id|scm_write
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|access
comma
r_int
r_char
id|reg
comma
r_int
r_char
id|content
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x40
comma
id|access
op_or
l_int|0x01
comma
id|reg
comma
id|content
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
id|result
op_assign
id|scm_send_control
c_func
(paren
id|us
comma
id|command
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
singleline_comment|// US_DEBUGP(&quot;SCM: Reg %d &lt;- %02X&bslash;n&quot;, reg, content);
r_return
id|result
suffix:semicolon
)brace
DECL|function|scm_set_shuttle_features
r_int
id|scm_set_shuttle_features
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|external_trigger
comma
r_int
r_char
id|epp_control
comma
r_int
r_char
id|mask_byte
comma
r_int
r_char
id|test_pattern
comma
r_int
r_char
id|subcountH
comma
r_int
r_char
id|subcountL
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x40
comma
l_int|0x81
comma
id|epp_control
comma
id|external_trigger
comma
id|test_pattern
comma
id|mask_byte
comma
id|subcountL
comma
id|subcountH
)brace
suffix:semicolon
id|result
op_assign
id|scm_bulk_transport
c_func
(paren
id|us
comma
id|command
comma
l_int|8
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|scm_read_block
r_int
id|scm_read_block
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|access
comma
r_int
r_char
id|reg
comma
r_int
r_char
op_star
id|content
comma
r_int
r_int
id|len
comma
r_int
id|use_sg
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0xC0
comma
id|access
op_or
l_int|0x02
comma
id|reg
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
id|result
op_assign
id|scm_bulk_transport
c_func
(paren
id|us
comma
id|command
comma
l_int|8
comma
id|content
comma
id|len
comma
id|use_sg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
singleline_comment|// US_DEBUGP(&quot;SCM: Read data, result %d&bslash;n&quot;, result);
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Block, waiting for an ATA device to become not busy or to report&n; * an error condition.&n; */
DECL|function|scm_wait_not_busy
r_int
id|scm_wait_not_busy
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
multiline_comment|/* Synchronizing cache on a CDR could take a heck of a long time,&n;&t;   but probably not more than 15 minutes or so */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|500
suffix:semicolon
id|i
op_increment
)paren
(brace
id|result
op_assign
id|scm_read
c_func
(paren
id|us
comma
id|SCM_ATA
comma
l_int|0x17
comma
op_amp
id|status
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;SCM: Write ATA data status is %02X&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x01
)paren
singleline_comment|// check condition
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x80
)paren
op_ne
l_int|0x80
)paren
singleline_comment|// not busy
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|5
)paren
id|wait_ms
c_func
(paren
l_int|100
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
OL
l_int|20
)paren
id|wait_ms
c_func
(paren
l_int|500
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
OL
l_int|49
)paren
id|wait_ms
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
OL
l_int|499
)paren
id|wait_ms
c_func
(paren
l_int|2000
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|500
)paren
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
DECL|function|scm_write_block
r_int
id|scm_write_block
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|access
comma
r_int
r_char
id|reg
comma
r_int
r_char
op_star
id|content
comma
r_int
r_int
id|len
comma
r_int
id|use_sg
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x40
comma
id|access
op_or
l_int|0x03
comma
id|reg
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
id|result
op_assign
id|scm_bulk_transport
c_func
(paren
id|us
comma
id|command
comma
l_int|8
comma
id|content
comma
id|len
comma
id|use_sg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_return
id|scm_wait_not_busy
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
DECL|function|scm_write_block_test
r_int
id|scm_write_block_test
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|access
comma
r_int
r_char
op_star
id|registers
comma
r_int
r_char
op_star
id|data_out
comma
r_int
r_int
id|num_registers
comma
r_int
r_char
id|data_reg
comma
r_int
r_char
id|status_reg
comma
r_int
r_char
id|qualifier
comma
r_int
r_char
id|timeout
comma
r_int
r_char
op_star
id|content
comma
r_int
r_int
id|len
comma
r_int
id|use_sg
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|16
)braket
op_assign
(brace
l_int|0x40
comma
id|access
op_or
l_int|0x07
comma
l_int|0x07
comma
l_int|0x17
comma
l_int|0xfc
comma
l_int|0xe7
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x40
comma
id|access
op_or
l_int|0x05
comma
id|data_reg
comma
id|status_reg
comma
id|qualifier
comma
id|timeout
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_int
r_char
id|data
(braket
id|num_registers
op_star
l_int|2
)braket
suffix:semicolon
r_int
id|maxlen
suffix:semicolon
r_int
id|transferred
suffix:semicolon
r_int
id|pipe
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_char
id|string
(braket
l_int|64
)braket
suffix:semicolon
id|command
(braket
l_int|14
)braket
op_assign
id|len
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|15
)braket
op_assign
(paren
id|len
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_registers
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
(braket
id|i
op_lshift
l_int|1
)braket
op_assign
id|registers
(braket
id|i
)braket
suffix:semicolon
id|data
(braket
l_int|1
op_plus
(paren
id|i
op_lshift
l_int|1
)paren
)braket
op_assign
id|data_out
(braket
id|i
)braket
suffix:semicolon
)brace
id|result
op_assign
id|scm_bulk_transport
c_func
(paren
id|us
comma
id|command
comma
l_int|16
comma
id|data
comma
id|num_registers
op_star
l_int|2
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|maxlen
op_assign
id|us-&gt;pusb_dev-&gt;actconfig
op_member_access_from_pointer
id|interface
(braket
l_int|0
)braket
dot
id|altsetting
(braket
l_int|0
)braket
dot
id|endpoint
(braket
id|us-&gt;ep_out
op_minus
l_int|1
)braket
dot
id|wMaxPacketSize
suffix:semicolon
id|pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
suffix:semicolon
id|transferred
op_assign
l_int|0
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Transfer out %d bytes, sg buffers %d&bslash;n&quot;
comma
id|len
comma
id|use_sg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
(brace
multiline_comment|/* Debug-print the first 48 bytes of the transfer */
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
(brace
id|string
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_logical_and
id|i
OL
l_int|48
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|string
op_plus
id|strlen
c_func
(paren
id|string
)paren
comma
l_string|&quot;%02X &quot;
comma
id|content
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|15
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
id|string
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|string
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
)brace
id|result
op_assign
id|scm_raw_bulk
c_func
(paren
id|us
comma
id|pipe
comma
id|maxlen
comma
id|content
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|content
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|use_sg
op_logical_and
id|transferred
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|result
op_assign
id|scm_raw_bulk
c_func
(paren
id|us
comma
id|pipe
comma
id|maxlen
comma
id|sg
(braket
id|i
)braket
dot
id|address
comma
id|len
op_minus
id|transferred
OG
id|sg
(braket
id|i
)braket
dot
id|length
ques
c_cond
id|sg
(braket
id|i
)braket
dot
id|length
suffix:colon
id|len
op_minus
id|transferred
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
r_break
suffix:semicolon
id|transferred
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_return
id|scm_wait_not_busy
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
DECL|function|scm_multiple_write
r_int
id|scm_multiple_write
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|access
comma
r_int
r_char
op_star
id|registers
comma
r_int
r_char
op_star
id|data_out
comma
r_int
r_int
id|num_registers
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|data
(braket
id|num_registers
op_star
l_int|2
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
id|cmd
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x40
comma
id|access
op_or
l_int|0x07
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_registers
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
(braket
id|i
op_lshift
l_int|1
)braket
op_assign
id|registers
(braket
id|i
)braket
suffix:semicolon
id|data
(braket
l_int|1
op_plus
(paren
id|i
op_lshift
l_int|1
)paren
)braket
op_assign
id|data_out
(braket
id|i
)braket
suffix:semicolon
)brace
id|result
op_assign
id|scm_bulk_transport
c_func
(paren
id|us
comma
id|cmd
comma
l_int|8
comma
id|data
comma
id|num_registers
op_star
l_int|2
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_return
id|scm_wait_not_busy
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
DECL|function|hp_8200e_select_and_test_registers
r_static
r_int
id|hp_8200e_select_and_test_registers
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|selector
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
singleline_comment|// try device = master, then device = slave.
r_for
c_loop
(paren
id|selector
op_assign
l_int|0xA0
suffix:semicolon
id|selector
op_le
l_int|0xB0
suffix:semicolon
id|selector
op_add_assign
l_int|0x10
)paren
(brace
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_write
c_func
(paren
id|us
comma
id|SCM_ATA
comma
l_int|0x16
comma
id|selector
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_read
c_func
(paren
id|us
comma
id|SCM_ATA
comma
l_int|0x17
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_read
c_func
(paren
id|us
comma
id|SCM_ATA
comma
l_int|0x16
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_read
c_func
(paren
id|us
comma
id|SCM_ATA
comma
l_int|0x14
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_read
c_func
(paren
id|us
comma
id|SCM_ATA
comma
l_int|0x15
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_write
c_func
(paren
id|us
comma
id|SCM_ATA
comma
l_int|0x14
comma
l_int|0x55
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_write
c_func
(paren
id|us
comma
id|SCM_ATA
comma
l_int|0x15
comma
l_int|0xAA
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_read
c_func
(paren
id|us
comma
id|SCM_ATA
comma
l_int|0x14
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_read
c_func
(paren
id|us
comma
id|SCM_ATA
comma
l_int|0x15
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|scm_read_user_io
r_int
id|scm_read_user_io
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|data_flags
)paren
(brace
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0xC0
comma
l_int|0x82
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_int
id|result
suffix:semicolon
id|result
op_assign
id|scm_send_control
c_func
(paren
id|us
comma
id|command
comma
id|data_flags
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
singleline_comment|// US_DEBUGP(&quot;SCM: User I/O flags -&gt; %02X&bslash;n&quot;, *data_flags);
r_return
id|result
suffix:semicolon
)brace
DECL|function|scm_write_user_io
r_int
id|scm_write_user_io
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|enable_flags
comma
r_int
r_char
id|data_flags
)paren
(brace
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x40
comma
l_int|0x82
comma
id|enable_flags
comma
id|data_flags
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_int
id|result
suffix:semicolon
id|result
op_assign
id|scm_send_control
c_func
(paren
id|us
comma
id|command
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
singleline_comment|// US_DEBUGP(&quot;SCM: User I/O flags &lt;- %02X&bslash;n&quot;, data_flags);
r_return
id|result
suffix:semicolon
)brace
DECL|function|init_8200e
r_static
r_int
id|init_8200e
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
singleline_comment|// Enable peripheral control signals
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_write_user_io
c_func
(paren
id|us
comma
id|SCM_UIO_OE1
op_or
id|SCM_UIO_OE0
comma
id|SCM_UIO_EPAD
op_or
id|SCM_UIO_1
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|wait_ms
c_func
(paren
l_int|2000
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_read_user_io
c_func
(paren
id|us
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_read_user_io
c_func
(paren
id|us
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
singleline_comment|// Reset peripheral, enable periph control signals
singleline_comment|// (bring reset signal up)
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_write_user_io
c_func
(paren
id|us
comma
id|SCM_UIO_DRVRST
op_or
id|SCM_UIO_OE1
op_or
id|SCM_UIO_OE0
comma
id|SCM_UIO_EPAD
op_or
id|SCM_UIO_1
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
singleline_comment|// Enable periph control signals
singleline_comment|// (bring reset signal down)
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_write_user_io
c_func
(paren
id|us
comma
id|SCM_UIO_OE1
op_or
id|SCM_UIO_OE0
comma
id|SCM_UIO_EPAD
op_or
id|SCM_UIO_1
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|wait_ms
c_func
(paren
l_int|250
)paren
suffix:semicolon
singleline_comment|// Write 0x80 to ISA port 0x3F
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_write
c_func
(paren
id|us
comma
id|SCM_ISA
comma
l_int|0x3F
comma
l_int|0x80
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
singleline_comment|// Read ISA port 0x27
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_read
c_func
(paren
id|us
comma
id|SCM_ISA
comma
l_int|0x27
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_read_user_io
c_func
(paren
id|us
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|hp_8200e_select_and_test_registers
c_func
(paren
id|us
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_read_user_io
c_func
(paren
id|us
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
singleline_comment|// Enable periph control signals and card detect
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_write_user_io
c_func
(paren
id|us
comma
id|SCM_UIO_ACKD
op_or
id|SCM_UIO_OE1
op_or
id|SCM_UIO_OE0
comma
id|SCM_UIO_EPAD
op_or
id|SCM_UIO_1
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_read_user_io
c_func
(paren
id|us
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|wait_ms
c_func
(paren
l_int|1400
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_read_user_io
c_func
(paren
id|us
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|hp_8200e_select_and_test_registers
c_func
(paren
id|us
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_set_shuttle_features
c_func
(paren
id|us
comma
l_int|0x83
comma
l_int|0x00
comma
l_int|0x88
comma
l_int|0x08
comma
l_int|0x15
comma
l_int|0x14
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Transport for the HP 8200e&n; */
DECL|function|hp8200e_transport
r_int
id|hp8200e_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_int
r_char
id|registers
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_char
id|data
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
id|string
(braket
l_int|64
)braket
suffix:semicolon
multiline_comment|/* This table tells us:&n;&t;   X = command not supported&n;&t;   L = return length in cmnd[4] (8 bits).&n;&t;   H = return length in cmnd[7] and cmnd[8] (16 bits).&n;&t;   D = return length in cmnd[6] to cmnd[9] (32 bits).&n;&t;   B = return length/blocksize in cmnd[6] to cmnd[8].&n;&t;   T = return length in cmnd[6] to cmnd[8] (24 bits).&n;&t;   0-9 = fixed return length&n;&t;   W = 24 bytes&n;&t;   h = return length/2048 in cmnd[7-8].&n;&t;*/
r_static
r_char
op_star
id|lengths
op_assign
multiline_comment|/* 0123456789ABCDEF   0123456789ABCDEF */
l_string|&quot;0XXL0XXXXXXXXXXX&quot;
l_string|&quot;XXLXXXXXXXX0XX0X&quot;
multiline_comment|/* 00-1F */
l_string|&quot;XXXXX8XXhXH0XXX0&quot;
l_string|&quot;XXXXX0XXXXXXXXXX&quot;
multiline_comment|/* 20-3F */
l_string|&quot;XXHHL0X0XXH0XX0X&quot;
l_string|&quot;XHH00HXX0TH0H0XX&quot;
multiline_comment|/* 40-5F */
l_string|&quot;XXXXXXXXXXXXXXXX&quot;
l_string|&quot;XXXXXXXXXXXXXXXX&quot;
multiline_comment|/* 60-7F */
l_string|&quot;XXXXXXXXXXXXXXXX&quot;
l_string|&quot;XXXXXXXXXXXXXXXX&quot;
multiline_comment|/* 80-9F */
l_string|&quot;X0XXX0XXDXDXXXXX&quot;
l_string|&quot;XXXXXXXXX000XHBX&quot;
multiline_comment|/* A0-BF */
l_string|&quot;XXXXXXXXXXXXXXXX&quot;
l_string|&quot;XXXXXXXXXXXXXXXX&quot;
multiline_comment|/* C0-DF */
l_string|&quot;XDXXXXXXXXXXXXXX&quot;
l_string|&quot;XXW00HXXXXXXXXXX&quot;
suffix:semicolon
multiline_comment|/* E0-FF */
multiline_comment|/* FIXME: B9 (READ CD MSF) has unknown length! */
multiline_comment|/* US_DEBUGP(&quot;XXXXXXXX 8200e transport called, tid %08X&bslash;n&quot;,&n;&t;&t;current-&gt;pid); */
r_if
c_cond
(paren
id|us-&gt;flags
op_amp
id|US_FL_NEED_INIT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;8200e: initializing&bslash;n&quot;
)paren
suffix:semicolon
id|init_8200e
c_func
(paren
id|us
)paren
suffix:semicolon
id|us-&gt;flags
op_and_assign
op_complement
id|US_FL_NEED_INIT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_WRITE
)paren
id|len
op_assign
id|srb-&gt;request_bufflen
suffix:semicolon
r_else
(brace
r_switch
c_cond
(paren
id|lengths
(braket
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)braket
)paren
(brace
r_case
l_char|&squot;L&squot;
suffix:colon
id|len
op_assign
id|srb-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;0&squot;
suffix:colon
r_case
l_char|&squot;1&squot;
suffix:colon
r_case
l_char|&squot;2&squot;
suffix:colon
r_case
l_char|&squot;3&squot;
suffix:colon
r_case
l_char|&squot;4&squot;
suffix:colon
r_case
l_char|&squot;5&squot;
suffix:colon
r_case
l_char|&squot;6&squot;
suffix:colon
r_case
l_char|&squot;7&squot;
suffix:colon
r_case
l_char|&squot;8&squot;
suffix:colon
r_case
l_char|&squot;9&squot;
suffix:colon
id|len
op_assign
id|lengths
(braket
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)braket
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;H&squot;
suffix:colon
id|len
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|srb-&gt;cmnd
(braket
l_int|8
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;h&squot;
suffix:colon
id|len
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|srb-&gt;cmnd
(braket
l_int|8
)braket
suffix:semicolon
id|len
op_lshift_assign
l_int|11
suffix:semicolon
singleline_comment|// *2048
r_break
suffix:semicolon
r_case
l_char|&squot;T&squot;
suffix:colon
id|len
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|6
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|srb-&gt;cmnd
(braket
l_int|8
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
id|len
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|6
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|srb-&gt;cmnd
(braket
l_int|9
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;W&squot;
suffix:colon
id|len
op_assign
l_int|24
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Error: UNSUPPORTED COMMAND %02X&bslash;n&quot;
comma
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0xFFFF
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Error: len = %08X... what do I do now?&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
singleline_comment|// US_DEBUGP(&quot;XXXXXXXXXXXXXXXX req_bufflen %d, len %d, bufflen %d&bslash;n&quot;, 
singleline_comment|//&t;srb-&gt;request_bufflen, len, srb-&gt;bufflen);
multiline_comment|/* Send A0 (ATA PACKET COMMAND).&n;&t;   Note: I guess we&squot;re never going to get any of the ATA&n;&t;   commands... just ATA Packet Commands.&n; &t; */
id|registers
(braket
l_int|0
)braket
op_assign
l_int|0x11
suffix:semicolon
id|registers
(braket
l_int|1
)braket
op_assign
l_int|0x12
suffix:semicolon
id|registers
(braket
l_int|2
)braket
op_assign
l_int|0x13
suffix:semicolon
id|registers
(braket
l_int|3
)braket
op_assign
l_int|0x14
suffix:semicolon
id|registers
(braket
l_int|4
)braket
op_assign
l_int|0x15
suffix:semicolon
id|registers
(braket
l_int|5
)braket
op_assign
l_int|0x16
suffix:semicolon
id|registers
(braket
l_int|6
)braket
op_assign
l_int|0x17
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
l_int|0x00
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
l_int|0x00
suffix:semicolon
id|data
(braket
l_int|2
)braket
op_assign
l_int|0x00
suffix:semicolon
id|data
(braket
l_int|3
)braket
op_assign
id|len
op_amp
l_int|0xFF
suffix:semicolon
singleline_comment|// (cylL) = expected length (L)
id|data
(braket
l_int|4
)braket
op_assign
(paren
id|len
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
singleline_comment|// (cylH) = expected length (H)
id|data
(braket
l_int|5
)braket
op_assign
l_int|0xB0
suffix:semicolon
singleline_comment|// (device sel) = slave
id|data
(braket
l_int|6
)braket
op_assign
l_int|0xA0
suffix:semicolon
singleline_comment|// (command) = ATA PACKET COMMAND
r_if
c_cond
(paren
id|srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_WRITE
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|7
suffix:semicolon
id|i
OL
l_int|19
suffix:semicolon
id|i
op_increment
)paren
(brace
id|registers
(braket
id|i
)braket
op_assign
l_int|0x10
suffix:semicolon
id|data
(braket
id|i
)braket
op_assign
(paren
id|i
op_minus
l_int|7
op_ge
id|srb-&gt;cmd_len
)paren
ques
c_cond
l_int|0
suffix:colon
id|srb-&gt;cmnd
(braket
id|i
op_minus
l_int|7
)braket
suffix:semicolon
)brace
id|result
op_assign
id|scm_write_block_test
c_func
(paren
id|us
comma
id|SCM_ATA
comma
id|registers
comma
id|data
comma
l_int|19
comma
l_int|0x10
comma
l_int|0x17
comma
l_int|0xFD
comma
l_int|0x30
comma
id|srb-&gt;request_buffer
comma
id|len
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_multiple_write
c_func
(paren
id|us
comma
id|SCM_ATA
comma
id|registers
comma
id|data
comma
l_int|7
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_return
id|result
suffix:semicolon
)brace
singleline_comment|// Write the 12-byte command header.
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_write_block
c_func
(paren
id|us
comma
id|SCM_ATA
comma
l_int|0x10
comma
id|srb-&gt;cmnd
comma
l_int|12
comma
l_int|0
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_return
id|result
suffix:semicolon
)brace
singleline_comment|// If there is response data to be read in 
singleline_comment|// then do it here.
r_if
c_cond
(paren
id|len
op_ne
l_int|0
op_logical_and
(paren
id|srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_READ
)paren
)paren
(brace
singleline_comment|// How many bytes to read in? Check cylL register
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_read
c_func
(paren
id|us
comma
id|SCM_ATA
comma
l_int|0x14
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0xFF
)paren
(brace
singleline_comment|// need to read cylH also
id|len
op_assign
id|status
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|scm_read
c_func
(paren
id|us
comma
id|SCM_ATA
comma
l_int|0x15
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_return
id|result
suffix:semicolon
)brace
id|len
op_add_assign
(paren
(paren
r_int
r_int
)paren
id|status
)paren
op_lshift
l_int|8
suffix:semicolon
)brace
r_else
id|len
op_assign
id|status
suffix:semicolon
id|result
op_assign
id|scm_read_block
c_func
(paren
id|us
comma
id|SCM_ATA
comma
l_int|0x10
comma
id|srb-&gt;request_buffer
comma
id|len
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
multiline_comment|/* Debug-print the first 32 bytes of the transfer */
r_if
c_cond
(paren
op_logical_neg
id|srb-&gt;use_sg
)paren
(brace
id|string
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_logical_and
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|string
op_plus
id|strlen
c_func
(paren
id|string
)paren
comma
l_string|&quot;%02X &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|srb-&gt;request_buffer
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|15
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
id|string
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|string
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// US_DEBUGP(&quot;Command result %d&bslash;n&quot;, result);
r_return
id|result
suffix:semicolon
)brace
eof
