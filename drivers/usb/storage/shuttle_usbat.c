multiline_comment|/* Driver for SCM Microsystems USB-ATAPI cable&n; *&n; * $Id: shuttle_usbat.c,v 1.11 2000/11/13 22:29:36 mdharm Exp $&n; *&n; * Current development and maintenance by:&n; *   (c) 2000 Robert Baruch (autophile@dol.net)&n; *&n; * Many originally ATAPI devices were slightly modified to meet the USB&n; * market by using some kind of translation from ATAPI to USB on the host,&n; * and the peripheral would translate from USB back to ATAPI.&n; *&n; * SCM Microsystems (www.scmmicro.com) makes a device, sold to OEM&squot;s only, &n; * which does the USB-to-ATAPI conversion.  By obtaining the data sheet on&n; * their device under nondisclosure agreement, I have been able to write&n; * this driver for Linux.&n; *&n; * The chip used in the device can also be used for EPP and ISA translation&n; * as well. This driver is only guaranteed to work with the ATAPI&n; * translation.&n; *&n; * The only peripheral that I know of (as of 8 Sep 2000) that uses this&n; * device is the Hewlett-Packard 8200e/8210e CD-Writer Plus.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;shuttle_usbat.h&quot;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
r_extern
r_int
id|usb_stor_control_msg
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
comma
id|u8
id|request
comma
id|u8
id|requesttype
comma
id|u16
id|value
comma
id|u16
id|index
comma
r_void
op_star
id|data
comma
id|u16
id|size
)paren
suffix:semicolon
r_extern
r_int
id|usb_stor_bulk_msg
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_void
op_star
id|data
comma
r_int
id|pipe
comma
r_int
r_int
id|len
comma
r_int
r_int
op_star
id|act_len
)paren
suffix:semicolon
DECL|macro|short_pack
mdefine_line|#define short_pack(LSB,MSB) ( ((u16)(LSB)) | ( ((u16)(MSB))&lt;&lt;8 ) )
DECL|macro|LSB_of
mdefine_line|#define LSB_of(s) ((s)&amp;0xFF)
DECL|macro|MSB_of
mdefine_line|#define MSB_of(s) ((s)&gt;&gt;8)
DECL|variable|transferred
r_int
id|transferred
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Send a control message and wait for the response.&n; *&n; * us - the pointer to the us_data structure for the device to use&n; *&n; * request - the URB Setup Packet&squot;s first 6 bytes. The first byte always&n; *  corresponds to the request type, and the second byte always corresponds&n; *  to the request.  The other 4 bytes do not correspond to value and index,&n; *  since they are used in a custom way by the SCM protocol.&n; *&n; * xfer_data - a buffer from which to get, or to which to store, any data&n; *  that gets send or received, respectively, with the URB. Even though&n; *  it looks like we allocate a buffer in this code for the data, xfer_data&n; *  must contain enough allocated space.&n; *&n; * xfer_len - the number of bytes to send or receive with the URB.&n; *&n; */
DECL|function|usbat_send_control
r_static
r_int
id|usbat_send_control
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|pipe
comma
r_int
r_char
id|request
comma
r_int
r_char
id|requesttype
comma
r_int
r_int
id|value
comma
r_int
r_int
id|index
comma
r_int
r_char
op_star
id|xfer_data
comma
r_int
r_int
id|xfer_len
)paren
(brace
r_int
id|result
suffix:semicolon
singleline_comment|// Send the URB to the device and wait for a response.
multiline_comment|/* Why are request and request type reversed in this call? */
id|result
op_assign
id|usb_stor_control_msg
c_func
(paren
id|us
comma
id|pipe
comma
id|request
comma
id|requesttype
comma
id|value
comma
id|index
comma
id|xfer_data
comma
id|xfer_len
)paren
suffix:semicolon
singleline_comment|// Check the return code for the command.
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* if the command was aborted, indicate that */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
r_return
id|USB_STOR_TRANSPORT_ABORTED
suffix:semicolon
multiline_comment|/* a stall is a fatal condition from the device */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Stall on control pipe. Clearing&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- usb_clear_halt() returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/* Uh oh... serious problem here */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
DECL|function|usbat_raw_bulk
r_static
r_int
id|usbat_raw_bulk
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|direction
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|act_len
suffix:semicolon
r_int
id|pipe
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|SCSI_DATA_READ
)paren
id|pipe
op_assign
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_in
)paren
suffix:semicolon
r_else
id|pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_msg
c_func
(paren
id|us
comma
id|data
comma
id|pipe
comma
id|len
comma
op_amp
id|act_len
)paren
suffix:semicolon
multiline_comment|/* if we stall, we need to clear it before we go on */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;EPIPE: clearing endpoint halt for&quot;
l_string|&quot; pipe 0x%x, stalled at %d bytes&bslash;n&quot;
comma
id|pipe
comma
id|act_len
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
)paren
(brace
multiline_comment|/* NAK - that means we&squot;ve retried a few times already */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_raw_bulk():&quot;
l_string|&quot; device NAKed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_FAILED
suffix:semicolon
)brace
multiline_comment|/* -ENOENT -- we canceled this transfer */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_raw_bulk():&quot;
l_string|&quot; transfer aborted&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_ABORTED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_raw_bulk():&quot;
l_string|&quot; output pipe stalled&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_SHORT
suffix:semicolon
)brace
multiline_comment|/* the catch-all case */
id|US_DEBUGP
c_func
(paren
l_string|&quot;us_transfer_partial(): unknown error&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|act_len
op_ne
id|len
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Warning: Transferred only %d bytes&bslash;n&quot;
comma
id|act_len
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_SHORT
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Transferred %s %d of %d bytes&bslash;n&quot;
comma
id|direction
op_eq
id|SCSI_DATA_READ
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
comma
id|act_len
comma
id|len
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: direction must be set if command_len == 0.&n; */
DECL|function|usbat_bulk_transport
r_static
r_int
id|usbat_bulk_transport
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|command
comma
r_int
r_int
id|command_len
comma
r_int
id|direction
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
comma
r_int
id|use_sg
)paren
(brace
r_int
id|result
op_assign
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_int
id|transferred
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
multiline_comment|/* transfer the data payload for the command, if there is any */
r_if
c_cond
(paren
id|command_len
op_ne
l_int|0
)paren
id|direction
op_assign
(paren
id|command
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
ques
c_cond
id|SCSI_DATA_READ
suffix:colon
id|SCSI_DATA_WRITE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
id|result
op_assign
id|usbat_raw_bulk
c_func
(paren
id|us
comma
id|direction
comma
id|data
comma
id|len
)paren
suffix:semicolon
r_else
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|data
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|use_sg
op_logical_and
id|transferred
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|result
op_assign
id|usbat_raw_bulk
c_func
(paren
id|us
comma
id|direction
comma
id|sg
(braket
id|i
)braket
dot
id|address
comma
id|len
op_minus
id|transferred
OG
id|sg
(braket
id|i
)braket
dot
id|length
ques
c_cond
id|sg
(braket
id|i
)braket
dot
id|length
suffix:colon
id|len
op_minus
id|transferred
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
r_break
suffix:semicolon
id|transferred
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|usbat_read
r_int
id|usbat_read
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|access
comma
r_int
r_char
id|reg
comma
r_int
r_char
op_star
id|content
)paren
(brace
r_int
id|result
suffix:semicolon
id|result
op_assign
id|usbat_send_control
c_func
(paren
id|us
comma
id|usb_rcvctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
id|access
comma
l_int|0xC0
comma
(paren
id|u16
)paren
id|reg
comma
l_int|0
comma
id|content
comma
l_int|1
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|usbat_write
r_int
id|usbat_write
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|access
comma
r_int
r_char
id|reg
comma
r_int
r_char
id|content
)paren
(brace
r_int
id|result
suffix:semicolon
id|result
op_assign
id|usbat_send_control
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
id|access
op_or
l_int|0x01
comma
l_int|0x40
comma
id|short_pack
c_func
(paren
id|reg
comma
id|content
)paren
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|usbat_set_shuttle_features
r_int
id|usbat_set_shuttle_features
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|external_trigger
comma
r_int
r_char
id|epp_control
comma
r_int
r_char
id|mask_byte
comma
r_int
r_char
id|test_pattern
comma
r_int
r_char
id|subcountH
comma
r_int
r_char
id|subcountL
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x40
comma
l_int|0x81
comma
id|epp_control
comma
id|external_trigger
comma
id|test_pattern
comma
id|mask_byte
comma
id|subcountL
comma
id|subcountH
)brace
suffix:semicolon
id|result
op_assign
id|usbat_send_control
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0x80
comma
l_int|0x40
comma
l_int|0
comma
l_int|0
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|usbat_read_block
r_int
id|usbat_read_block
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|access
comma
r_int
r_char
id|reg
comma
r_int
r_char
op_star
id|content
comma
r_int
r_int
id|len
comma
r_int
id|use_sg
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0xC0
comma
id|access
op_or
l_int|0x02
comma
id|reg
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
id|LSB_of
c_func
(paren
id|len
)paren
comma
id|MSB_of
c_func
(paren
id|len
)paren
)brace
suffix:semicolon
id|result
op_assign
id|usbat_send_control
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0x80
comma
l_int|0x40
comma
l_int|0
comma
l_int|0
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|result
op_assign
id|usbat_bulk_transport
c_func
(paren
id|us
comma
l_int|NULL
comma
l_int|0
comma
id|SCSI_DATA_READ
comma
id|content
comma
id|len
comma
id|use_sg
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Block, waiting for an ATA device to become not busy or to report&n; * an error condition.&n; */
DECL|function|usbat_wait_not_busy
r_int
id|usbat_wait_not_busy
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|minutes
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
multiline_comment|/* Synchronizing cache on a CDR could take a heck of a long time,&n;&t; * but probably not more than 10 minutes or so. On the other hand,&n;&t; * doing a full blank on a CDRW at speed 1 will take about 75&n;&t; * minutes!&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1200
op_plus
id|minutes
op_star
l_int|60
suffix:semicolon
id|i
op_increment
)paren
(brace
id|result
op_assign
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
l_int|0x17
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x01
)paren
singleline_comment|// check condition
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x20
)paren
singleline_comment|// device fault
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x80
)paren
op_ne
l_int|0x80
)paren
(brace
singleline_comment|// not busy
id|US_DEBUGP
c_func
(paren
l_string|&quot;Waited not busy for %d steps&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|500
)paren
id|wait_ms
c_func
(paren
l_int|10
)paren
suffix:semicolon
singleline_comment|// 5 seconds
r_else
r_if
c_cond
(paren
id|i
OL
l_int|700
)paren
id|wait_ms
c_func
(paren
l_int|50
)paren
suffix:semicolon
singleline_comment|// 10 seconds
r_else
r_if
c_cond
(paren
id|i
OL
l_int|1200
)paren
id|wait_ms
c_func
(paren
l_int|100
)paren
suffix:semicolon
singleline_comment|// 50 seconds
r_else
id|wait_ms
c_func
(paren
l_int|1000
)paren
suffix:semicolon
singleline_comment|// X minutes
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Waited not busy for %d minutes, timing out.&bslash;n&quot;
comma
id|minutes
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
DECL|function|usbat_write_block
r_int
id|usbat_write_block
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|access
comma
r_int
r_char
id|reg
comma
r_int
r_char
op_star
id|content
comma
r_int
r_int
id|len
comma
r_int
id|use_sg
comma
r_int
id|minutes
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x40
comma
id|access
op_or
l_int|0x03
comma
id|reg
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
id|LSB_of
c_func
(paren
id|len
)paren
comma
id|MSB_of
c_func
(paren
id|len
)paren
)brace
suffix:semicolon
id|result
op_assign
id|usbat_send_control
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0x80
comma
l_int|0x40
comma
l_int|0
comma
l_int|0
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|result
op_assign
id|usbat_bulk_transport
c_func
(paren
id|us
comma
l_int|NULL
comma
l_int|0
comma
id|SCSI_DATA_WRITE
comma
id|content
comma
id|len
comma
id|use_sg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_return
id|usbat_wait_not_busy
c_func
(paren
id|us
comma
id|minutes
)paren
suffix:semicolon
)brace
DECL|function|usbat_rw_block_test
r_int
id|usbat_rw_block_test
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|access
comma
r_int
r_char
op_star
id|registers
comma
r_int
r_char
op_star
id|data_out
comma
r_int
r_int
id|num_registers
comma
r_int
r_char
id|data_reg
comma
r_int
r_char
id|status_reg
comma
r_int
r_char
id|timeout
comma
r_int
r_char
id|qualifier
comma
r_int
id|direction
comma
r_int
r_char
op_star
id|content
comma
r_int
r_int
id|len
comma
r_int
id|use_sg
comma
r_int
id|minutes
)paren
(brace
r_int
id|result
suffix:semicolon
singleline_comment|// Not really sure the 0x07, 0x17, 0xfc, 0xe7 is necessary here,
singleline_comment|// but that&squot;s what came out of the trace every single time.
r_int
r_char
id|command
(braket
l_int|16
)braket
op_assign
(brace
l_int|0x40
comma
id|access
op_or
l_int|0x07
comma
l_int|0x07
comma
l_int|0x17
comma
l_int|0xfc
comma
l_int|0xe7
comma
id|LSB_of
c_func
(paren
id|num_registers
op_star
l_int|2
)paren
comma
id|MSB_of
c_func
(paren
id|num_registers
op_star
l_int|2
)paren
comma
(paren
id|direction
op_eq
id|SCSI_DATA_WRITE
ques
c_cond
l_int|0x40
suffix:colon
l_int|0xC0
)paren
comma
id|access
op_or
(paren
id|direction
op_eq
id|SCSI_DATA_WRITE
ques
c_cond
l_int|0x05
suffix:colon
l_int|0x04
)paren
comma
id|data_reg
comma
id|status_reg
comma
id|timeout
comma
id|qualifier
comma
id|LSB_of
c_func
(paren
id|len
)paren
comma
id|MSB_of
c_func
(paren
id|len
)paren
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
id|data
(braket
id|num_registers
op_star
l_int|2
)braket
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_registers
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
(braket
id|i
op_lshift
l_int|1
)braket
op_assign
id|registers
(braket
id|i
)braket
suffix:semicolon
id|data
(braket
l_int|1
op_plus
(paren
id|i
op_lshift
l_int|1
)paren
)braket
op_assign
id|data_out
(braket
id|i
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * The first time we send the full command, which consists&n;&t;&t; * of downloading the SCSI command followed by downloading&n;&t;&t; * the data via a write-and-test.  Any other time we only&n;&t;&t; * send the command to download the data -- the SCSI command&n;&t;&t; * is still &squot;active&squot; in some sense in the device.&n;&t;&t; * &n;&t;&t; * We&squot;re only going to try sending the data 10 times. After&n;&t;&t; * that, we just return a failure.&n;&t;&t; */
id|result
op_assign
id|usbat_send_control
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0x80
comma
l_int|0x40
comma
l_int|0
comma
l_int|0
comma
(paren
id|i
op_eq
l_int|0
ques
c_cond
id|command
suffix:colon
id|command
op_plus
l_int|8
)paren
comma
(paren
id|i
op_eq
l_int|0
ques
c_cond
l_int|16
suffix:colon
l_int|8
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|result
op_assign
id|usbat_bulk_transport
c_func
(paren
id|us
comma
l_int|NULL
comma
l_int|0
comma
id|SCSI_DATA_WRITE
comma
id|data
comma
id|num_registers
op_star
l_int|2
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
)brace
singleline_comment|//US_DEBUGP(&quot;Transfer %s %d bytes, sg buffers %d&bslash;n&quot;,
singleline_comment|//&t;direction == SCSI_DATA_WRITE ? &quot;out&quot; : &quot;in&quot;,
singleline_comment|//&t;len, use_sg);
id|result
op_assign
id|usbat_bulk_transport
c_func
(paren
id|us
comma
l_int|NULL
comma
l_int|0
comma
id|direction
comma
id|content
comma
id|len
comma
id|use_sg
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we get a stall on the bulk download, we&squot;ll retry&n;&t;&t; * the bulk download -- but not the SCSI command because&n;&t;&t; * in some sense the SCSI command is still &squot;active&squot; and&n;&t;&t; * waiting for the data. Don&squot;t ask me why this should be;&n;&t;&t; * I&squot;m only following what the Windoze driver did.&n;&t;&t; *&n;&t;&t; * Note that a stall for the test-and-read/write command means&n;&t;&t; * that the test failed. In this case we&squot;re testing to make&n;&t;&t; * sure that the device is error-free&n;&t;&t; * (i.e. bit 0 -- CHK -- of status is 0). The most likely&n;&t;&t; * hypothesis is that the USBAT chip somehow knows what&n;&t;&t; * the device will accept, but doesn&squot;t give the device any&n;&t;&t; * data until all data is received. Thus, the device would&n;&t;&t; * still be waiting for the first byte of data if a stall&n;&t;&t; * occurs, even if the stall implies that some data was&n;&t;&t; * transferred.&n;&t;&t; */
r_if
c_cond
(paren
id|result
op_eq
id|US_BULK_TRANSFER_SHORT
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If we&squot;re reading and we stalled, then clear&n;&t;&t;&t; * the bulk output pipe only the first time.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|direction
op_eq
id|SCSI_DATA_READ
op_logical_and
id|i
op_eq
l_int|0
)paren
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Read status: is the device angry, or just busy?&n;&t;&t;&t; */
id|result
op_assign
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|direction
op_eq
id|SCSI_DATA_WRITE
ques
c_cond
l_int|0x17
suffix:colon
l_int|0x0E
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x01
)paren
singleline_comment|// check condition
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x20
)paren
singleline_comment|// device fault
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Redoing %s&bslash;n&quot;
comma
id|direction
op_eq
id|SCSI_DATA_WRITE
ques
c_cond
l_string|&quot;write&quot;
suffix:colon
l_string|&quot;read&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
r_return
id|result
suffix:semicolon
r_else
r_return
id|usbat_wait_not_busy
c_func
(paren
id|us
comma
id|minutes
)paren
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bummer! %s bulk data 20 times failed.&bslash;n&quot;
comma
id|direction
op_eq
id|SCSI_DATA_WRITE
ques
c_cond
l_string|&quot;Writing&quot;
suffix:colon
l_string|&quot;Reading&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/*&n; * Write data to multiple registers at once. Not meant for large&n; * transfers of data!&n; */
DECL|function|usbat_multiple_write
r_int
id|usbat_multiple_write
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|access
comma
r_int
r_char
op_star
id|registers
comma
r_int
r_char
op_star
id|data_out
comma
r_int
r_int
id|num_registers
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|data
(braket
id|num_registers
op_star
l_int|2
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x40
comma
id|access
op_or
l_int|0x07
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
id|LSB_of
c_func
(paren
id|num_registers
op_star
l_int|2
)paren
comma
id|MSB_of
c_func
(paren
id|num_registers
op_star
l_int|2
)paren
)brace
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_registers
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
(braket
id|i
op_lshift
l_int|1
)braket
op_assign
id|registers
(braket
id|i
)braket
suffix:semicolon
id|data
(braket
l_int|1
op_plus
(paren
id|i
op_lshift
l_int|1
)paren
)braket
op_assign
id|data_out
(braket
id|i
)braket
suffix:semicolon
)brace
id|result
op_assign
id|usbat_send_control
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0x80
comma
l_int|0x40
comma
l_int|0
comma
l_int|0
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|result
op_assign
id|usbat_bulk_transport
c_func
(paren
id|us
comma
l_int|NULL
comma
l_int|0
comma
id|SCSI_DATA_WRITE
comma
id|data
comma
id|num_registers
op_star
l_int|2
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_return
id|usbat_wait_not_busy
c_func
(paren
id|us
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|usbat_read_user_io
r_int
id|usbat_read_user_io
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|data_flags
)paren
(brace
r_int
id|result
suffix:semicolon
id|result
op_assign
id|usbat_send_control
c_func
(paren
id|us
comma
id|usb_rcvctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0x82
comma
l_int|0xC0
comma
l_int|0
comma
l_int|0
comma
id|data_flags
comma
l_int|1
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|usbat_write_user_io
r_int
id|usbat_write_user_io
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|enable_flags
comma
r_int
r_char
id|data_flags
)paren
(brace
r_int
id|result
suffix:semicolon
id|result
op_assign
id|usbat_send_control
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0x82
comma
l_int|0x40
comma
id|short_pack
c_func
(paren
id|enable_flags
comma
id|data_flags
)paren
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Squeeze a potentially huge (&gt; 65535 byte) read10 command into&n; * a little ( &lt;= 65535 byte) ATAPI pipe&n; */
DECL|function|usbat_handle_read10
r_int
id|usbat_handle_read10
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|registers
comma
r_int
r_char
op_star
id|data
comma
id|Scsi_Cmnd
op_star
id|srb
)paren
(brace
r_int
id|result
op_assign
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_int
r_int
id|sector
suffix:semicolon
r_int
r_int
id|amount
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
l_int|NULL
suffix:semicolon
r_int
id|sg_segment
op_assign
l_int|0
suffix:semicolon
r_int
id|sg_offset
op_assign
l_int|0
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;handle_read10: transfersize %d&bslash;n&quot;
comma
id|srb-&gt;transfersize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;request_bufflen
OL
l_int|0x10000
)paren
(brace
id|result
op_assign
id|usbat_rw_block_test
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|registers
comma
id|data
comma
l_int|19
comma
l_int|0x10
comma
l_int|0x17
comma
l_int|0xFD
comma
l_int|0x30
comma
id|SCSI_DATA_READ
comma
id|srb-&gt;request_buffer
comma
id|srb-&gt;request_bufflen
comma
id|srb-&gt;use_sg
comma
l_int|1
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Since we&squot;re requesting more data than we can handle in&n;&t; * a single read command (max is 64k-1), we will perform&n;&t; * multiple reads, but each read must be in multiples of&n;&t; * a sector.  Luckily the sector size is in srb-&gt;transfersize&n;&t; * (see linux/drivers/scsi/sr.c).&n;&t; */
r_if
c_cond
(paren
id|data
(braket
l_int|7
op_plus
l_int|0
)braket
op_eq
id|GPCMD_READ_CD
)paren
(brace
id|len
op_assign
id|short_pack
c_func
(paren
id|data
(braket
l_int|7
op_plus
l_int|9
)braket
comma
id|data
(braket
l_int|7
op_plus
l_int|8
)braket
)paren
suffix:semicolon
id|len
op_lshift_assign
l_int|16
suffix:semicolon
id|len
op_or_assign
id|data
(braket
l_int|7
op_plus
l_int|7
)braket
suffix:semicolon
id|srb-&gt;transfersize
op_assign
id|srb-&gt;request_bufflen
op_div
id|len
suffix:semicolon
)brace
id|len
op_assign
(paren
l_int|65535
op_div
id|srb-&gt;transfersize
)paren
op_star
id|srb-&gt;transfersize
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Max read is %d bytes&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
singleline_comment|// bloody hell!
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
id|sector
op_assign
id|short_pack
c_func
(paren
id|data
(braket
l_int|7
op_plus
l_int|3
)braket
comma
id|data
(braket
l_int|7
op_plus
l_int|2
)braket
)paren
suffix:semicolon
id|sector
op_lshift_assign
l_int|16
suffix:semicolon
id|sector
op_or_assign
id|short_pack
c_func
(paren
id|data
(braket
l_int|7
op_plus
l_int|5
)braket
comma
id|data
(braket
l_int|7
op_plus
l_int|4
)braket
)paren
suffix:semicolon
id|transferred
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;use_sg
)paren
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|srb-&gt;request_buffer
suffix:semicolon
id|sg_segment
op_assign
l_int|0
suffix:semicolon
singleline_comment|// for keeping track of where we are in
id|sg_offset
op_assign
l_int|0
suffix:semicolon
singleline_comment|// the scatter/gather list
)brace
r_while
c_loop
(paren
id|transferred
op_ne
id|srb-&gt;request_bufflen
)paren
(brace
r_if
c_cond
(paren
id|len
OG
id|srb-&gt;request_bufflen
op_minus
id|transferred
)paren
id|len
op_assign
id|srb-&gt;request_bufflen
op_minus
id|transferred
suffix:semicolon
id|data
(braket
l_int|3
)braket
op_assign
id|len
op_amp
l_int|0xFF
suffix:semicolon
singleline_comment|// (cylL) = expected length (L)
id|data
(braket
l_int|4
)braket
op_assign
(paren
id|len
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
singleline_comment|// (cylH) = expected length (H)
singleline_comment|// Fix up the SCSI command sector and num sectors
id|data
(braket
l_int|7
op_plus
l_int|2
)braket
op_assign
id|MSB_of
c_func
(paren
id|sector
op_rshift
l_int|16
)paren
suffix:semicolon
singleline_comment|// SCSI command sector
id|data
(braket
l_int|7
op_plus
l_int|3
)braket
op_assign
id|LSB_of
c_func
(paren
id|sector
op_rshift
l_int|16
)paren
suffix:semicolon
id|data
(braket
l_int|7
op_plus
l_int|4
)braket
op_assign
id|MSB_of
c_func
(paren
id|sector
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|data
(braket
l_int|7
op_plus
l_int|5
)braket
op_assign
id|LSB_of
c_func
(paren
id|sector
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
(braket
l_int|7
op_plus
l_int|0
)braket
op_eq
id|GPCMD_READ_CD
)paren
id|data
(braket
l_int|7
op_plus
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
id|data
(braket
l_int|7
op_plus
l_int|7
)braket
op_assign
id|MSB_of
c_func
(paren
id|len
op_div
id|srb-&gt;transfersize
)paren
suffix:semicolon
singleline_comment|// SCSI command
id|data
(braket
l_int|7
op_plus
l_int|8
)braket
op_assign
id|LSB_of
c_func
(paren
id|len
op_div
id|srb-&gt;transfersize
)paren
suffix:semicolon
singleline_comment|// num sectors
id|result
op_assign
id|usbat_rw_block_test
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|registers
comma
id|data
comma
l_int|19
comma
l_int|0x10
comma
l_int|0x17
comma
l_int|0xFD
comma
l_int|0x30
comma
id|SCSI_DATA_READ
comma
id|buffer
comma
id|len
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_break
suffix:semicolon
singleline_comment|// Transfer the received data into the srb buffer
r_if
c_cond
(paren
op_logical_neg
id|srb-&gt;use_sg
)paren
(brace
id|memcpy
c_func
(paren
id|srb-&gt;request_buffer
op_plus
id|transferred
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
id|amount
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|amount
OL
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_minus
id|amount
op_ge
id|sg
(braket
id|sg_segment
)braket
dot
id|length
op_minus
id|sg_offset
)paren
(brace
id|memcpy
c_func
(paren
id|sg
(braket
id|sg_segment
)braket
dot
id|address
op_plus
id|sg_offset
comma
id|buffer
op_plus
id|amount
comma
id|sg
(braket
id|sg_segment
)braket
dot
id|length
op_minus
id|sg_offset
)paren
suffix:semicolon
id|amount
op_add_assign
id|sg
(braket
id|sg_segment
)braket
dot
id|length
op_minus
id|sg_offset
suffix:semicolon
id|sg_segment
op_increment
suffix:semicolon
id|sg_offset
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|sg
(braket
id|sg_segment
)braket
dot
id|address
op_plus
id|sg_offset
comma
id|buffer
op_plus
id|amount
comma
id|len
op_minus
id|amount
)paren
suffix:semicolon
id|sg_offset
op_add_assign
(paren
id|len
op_minus
id|amount
)paren
suffix:semicolon
id|amount
op_assign
id|len
suffix:semicolon
)brace
)brace
)brace
singleline_comment|// Update the amount transferred and the sector number
id|transferred
op_add_assign
id|len
suffix:semicolon
id|sector
op_add_assign
id|len
op_div
id|srb-&gt;transfersize
suffix:semicolon
)brace
singleline_comment|// while transferred != srb-&gt;request_bufflen
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|hp_8200e_select_and_test_registers
r_static
r_int
id|hp_8200e_select_and_test_registers
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|selector
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
singleline_comment|// try device = master, then device = slave.
r_for
c_loop
(paren
id|selector
op_assign
l_int|0xA0
suffix:semicolon
id|selector
op_le
l_int|0xB0
suffix:semicolon
id|selector
op_add_assign
l_int|0x10
)paren
(brace
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_write
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
l_int|0x16
comma
id|selector
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
l_int|0x17
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
l_int|0x16
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
l_int|0x14
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
l_int|0x15
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_write
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
l_int|0x14
comma
l_int|0x55
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_write
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
l_int|0x15
comma
l_int|0xAA
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
l_int|0x14
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
l_int|0x15
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|init_8200e
r_int
id|init_8200e
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
singleline_comment|// Enable peripheral control signals
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_write_user_io
c_func
(paren
id|us
comma
id|USBAT_UIO_OE1
op_or
id|USBAT_UIO_OE0
comma
id|USBAT_UIO_EPAD
op_or
id|USBAT_UIO_1
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 1&bslash;n&quot;
)paren
suffix:semicolon
id|wait_ms
c_func
(paren
l_int|2000
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_read_user_io
c_func
(paren
id|us
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 2&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_read_user_io
c_func
(paren
id|us
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 3&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Reset peripheral, enable periph control signals
singleline_comment|// (bring reset signal up)
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_write_user_io
c_func
(paren
id|us
comma
id|USBAT_UIO_DRVRST
op_or
id|USBAT_UIO_OE1
op_or
id|USBAT_UIO_OE0
comma
id|USBAT_UIO_EPAD
op_or
id|USBAT_UIO_1
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 4&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Enable periph control signals
singleline_comment|// (bring reset signal down)
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_write_user_io
c_func
(paren
id|us
comma
id|USBAT_UIO_OE1
op_or
id|USBAT_UIO_OE0
comma
id|USBAT_UIO_EPAD
op_or
id|USBAT_UIO_1
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 5&bslash;n&quot;
)paren
suffix:semicolon
id|wait_ms
c_func
(paren
l_int|250
)paren
suffix:semicolon
singleline_comment|// Write 0x80 to ISA port 0x3F
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_write
c_func
(paren
id|us
comma
id|USBAT_ISA
comma
l_int|0x3F
comma
l_int|0x80
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 6&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Read ISA port 0x27
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ISA
comma
l_int|0x27
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 7&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_read_user_io
c_func
(paren
id|us
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 8&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|hp_8200e_select_and_test_registers
c_func
(paren
id|us
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 9&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_read_user_io
c_func
(paren
id|us
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 10&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Enable periph control signals and card detect
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_write_user_io
c_func
(paren
id|us
comma
id|USBAT_UIO_ACKD
op_or
id|USBAT_UIO_OE1
op_or
id|USBAT_UIO_OE0
comma
id|USBAT_UIO_EPAD
op_or
id|USBAT_UIO_1
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 11&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_read_user_io
c_func
(paren
id|us
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 12&bslash;n&quot;
)paren
suffix:semicolon
id|wait_ms
c_func
(paren
l_int|1400
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_read_user_io
c_func
(paren
id|us
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 13&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|hp_8200e_select_and_test_registers
c_func
(paren
id|us
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 14&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_set_shuttle_features
c_func
(paren
id|us
comma
l_int|0x83
comma
l_int|0x00
comma
l_int|0x88
comma
l_int|0x08
comma
l_int|0x15
comma
l_int|0x14
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 15&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Transport for the HP 8200e&n; */
DECL|function|hp8200e_transport
r_int
id|hp8200e_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_int
r_char
id|registers
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_char
id|data
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
id|string
(braket
l_int|64
)braket
suffix:semicolon
id|len
op_assign
id|srb-&gt;request_bufflen
suffix:semicolon
multiline_comment|/* Send A0 (ATA PACKET COMMAND).&n;&t;   Note: I guess we&squot;re never going to get any of the ATA&n;&t;   commands... just ATA Packet Commands.&n; &t; */
id|registers
(braket
l_int|0
)braket
op_assign
l_int|0x11
suffix:semicolon
id|registers
(braket
l_int|1
)braket
op_assign
l_int|0x12
suffix:semicolon
id|registers
(braket
l_int|2
)braket
op_assign
l_int|0x13
suffix:semicolon
id|registers
(braket
l_int|3
)braket
op_assign
l_int|0x14
suffix:semicolon
id|registers
(braket
l_int|4
)braket
op_assign
l_int|0x15
suffix:semicolon
id|registers
(braket
l_int|5
)braket
op_assign
l_int|0x16
suffix:semicolon
id|registers
(braket
l_int|6
)braket
op_assign
l_int|0x17
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
l_int|0x00
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
l_int|0x00
suffix:semicolon
id|data
(braket
l_int|2
)braket
op_assign
l_int|0x00
suffix:semicolon
id|data
(braket
l_int|3
)braket
op_assign
id|len
op_amp
l_int|0xFF
suffix:semicolon
singleline_comment|// (cylL) = expected length (L)
id|data
(braket
l_int|4
)braket
op_assign
(paren
id|len
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
singleline_comment|// (cylH) = expected length (H)
id|data
(braket
l_int|5
)braket
op_assign
l_int|0xB0
suffix:semicolon
singleline_comment|// (device sel) = slave
id|data
(braket
l_int|6
)braket
op_assign
l_int|0xA0
suffix:semicolon
singleline_comment|// (command) = ATA PACKET COMMAND
r_for
c_loop
(paren
id|i
op_assign
l_int|7
suffix:semicolon
id|i
OL
l_int|19
suffix:semicolon
id|i
op_increment
)paren
(brace
id|registers
(braket
id|i
)braket
op_assign
l_int|0x10
suffix:semicolon
id|data
(braket
id|i
)braket
op_assign
(paren
id|i
op_minus
l_int|7
op_ge
id|srb-&gt;cmd_len
)paren
ques
c_cond
l_int|0
suffix:colon
id|srb-&gt;cmnd
(braket
id|i
op_minus
l_int|7
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|TEST_UNIT_READY
)paren
id|transferred
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_WRITE
)paren
(brace
id|result
op_assign
id|usbat_rw_block_test
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|registers
comma
id|data
comma
l_int|19
comma
l_int|0x10
comma
l_int|0x17
comma
l_int|0xFD
comma
l_int|0x30
comma
id|SCSI_DATA_WRITE
comma
id|srb-&gt;request_buffer
comma
id|len
comma
id|srb-&gt;use_sg
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|transferred
op_add_assign
id|len
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Wrote %08X bytes&bslash;n&quot;
comma
id|transferred
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_10
op_logical_or
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|GPCMD_READ_CD
)paren
(brace
r_return
id|usbat_handle_read10
c_func
(paren
id|us
comma
id|registers
comma
id|data
comma
id|srb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0xFFFF
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Error: len = %08X... what do I do now?&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_multiple_write
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|registers
comma
id|data
comma
l_int|7
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_return
id|result
suffix:semicolon
)brace
singleline_comment|// Write the 12-byte command header.
singleline_comment|// If the command is BLANK then set the timer for 75 minutes.
singleline_comment|// Otherwise set it for 10 minutes.
singleline_comment|// NOTE: THE 8200 DOCUMENTATION STATES THAT BLANKING A CDRW
singleline_comment|// AT SPEED 4 IS UNRELIABLE!!!
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_write_block
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
l_int|0x10
comma
id|srb-&gt;cmnd
comma
l_int|12
comma
l_int|0
comma
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|GPCMD_BLANK
ques
c_cond
l_int|75
suffix:colon
l_int|10
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_return
id|result
suffix:semicolon
)brace
singleline_comment|// If there is response data to be read in 
singleline_comment|// then do it here.
r_if
c_cond
(paren
id|len
op_ne
l_int|0
op_logical_and
(paren
id|srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_READ
)paren
)paren
(brace
singleline_comment|// How many bytes to read in? Check cylL register
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
l_int|0x14
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0xFF
)paren
(brace
singleline_comment|// need to read cylH also
id|len
op_assign
id|status
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
l_int|0x15
comma
op_amp
id|status
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_return
id|result
suffix:semicolon
)brace
id|len
op_add_assign
(paren
(paren
r_int
r_int
)paren
id|status
)paren
op_lshift
l_int|8
suffix:semicolon
)brace
r_else
id|len
op_assign
id|status
suffix:semicolon
id|result
op_assign
id|usbat_read_block
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
l_int|0x10
comma
id|srb-&gt;request_buffer
comma
id|len
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
multiline_comment|/* Debug-print the first 32 bytes of the transfer */
r_if
c_cond
(paren
op_logical_neg
id|srb-&gt;use_sg
)paren
(brace
id|string
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_logical_and
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|string
op_plus
id|strlen
c_func
(paren
id|string
)paren
comma
l_string|&quot;%02X &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|srb-&gt;request_buffer
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|15
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
id|string
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|string
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
)brace
)brace
r_return
id|result
suffix:semicolon
)brace
eof
