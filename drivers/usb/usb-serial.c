multiline_comment|/*&n; * USB Serial Converter driver&n; *&n; *&t;(C) Copyright (C) 1999, 2000&n; *&t;    Greg Kroah-Hartman (greg@kroah.com)&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; * This driver was originally based on the ACM driver by Armin Fuerst (which was &n; * based on a driver by Brad Keryan)&n; *&n; * See Documentation/usb/usb-serial.txt for more information on using this driver&n; * &n; * (01/23/2000) gkh&n; *&t;Fixed problem of crash when trying to open a port that didn&squot;t have a&n; *&t;device assigned to it. Made the minor node finding a little smarter,&n; *&t;now it looks to find a continous space for the new device.&n; *&n; * (01/21/2000) gkh&n; *&t;Fixed bug in visor_startup with patch from Miles Lott (milos@insync.net)&n; *&t;Fixed get_serial_by_minor which was all messed up for multi port &n; *&t;devices. Fixed multi port problem for generic devices. Now the number&n; *&t;of ports is determined by the number of bulk out endpoints for the&n; *&t;generic device.&n; *&n; * (01/19/2000) gkh&n; *&t;Removed lots of cruft that was around from the old (pre urb) driver &n; *&t;interface.&n; *&t;Made the serial_table dynamic. This should save lots of memory when&n; *&t;the number of minor nodes goes up to 256.&n; *&t;Added initial support for devices that have more than one port. &n; *&t;Added more debugging comments for the Visor, and added a needed &n; *&t;set_configuration call.&n; *&n; * (01/17/2000) gkh&n; *&t;Fixed the WhiteHEAT firmware (my processing tool had a bug)&n; *&t;and added new debug loader firmware for it.&n; *&t;Removed the put_char function as it isn&squot;t really needed.&n; *&t;Added visor startup commands as found by the Win98 dump.&n; * &n; * (01/13/2000) gkh&n; *&t;Fixed the vendor id for the generic driver to the one I meant it to be.&n; *&n; * (01/12/2000) gkh&n; *&t;Forget the version numbering...that&squot;s pretty useless...&n; *&t;Made the driver able to be compiled so that the user can select which&n; *&t;converter they want to use. This allows people who only want the Visor&n; *&t;support to not pay the memory size price of the WhiteHEAT.&n; *&t;Fixed bug where the generic driver (idVendor=0000 and idProduct=0000)&n; *&t;grabbed the root hub. Not good.&n; * &n; * version 0.4.0 (01/10/2000) gkh&n; *&t;Added whiteheat.h containing the firmware for the ConnectTech WhiteHEAT&n; *&t;device. Added startup function to allow firmware to be downloaded to&n; *&t;a device if it needs to be.&n; *&t;Added firmware download logic to the WhiteHEAT device.&n; *&t;Started to add #defines to split up the different drivers for potential&n; *&t;configuration option.&n; *&t;&n; * version 0.3.1 (12/30/99) gkh&n; *      Fixed problems with urb for bulk out.&n; *      Added initial support for multiple sets of endpoints. This enables&n; *      the Handspring Visor to be attached successfully. Only the first&n; *      bulk in / bulk out endpoint pair is being used right now.&n; *&n; * version 0.3.0 (12/27/99) gkh&n; *&t;Added initial support for the Handspring Visor based on a patch from&n; *&t;Miles Lott (milos@sneety.insync.net)&n; *&t;Cleaned up the code a bunch and converted over to using urbs only.&n; *&n; * version 0.2.3 (12/21/99) gkh&n; *&t;Added initial support for the Connect Tech WhiteHEAT converter.&n; *&t;Incremented the number of ports in expectation of getting the&n; *&t;WhiteHEAT to work properly (4 ports per connection).&n; *&t;Added notification on insertion and removal of what port the&n; *&t;device is/was connected to (and what kind of device it was).&n; *&n; * version 0.2.2 (12/16/99) gkh&n; *&t;Changed major number to the new allocated number. We&squot;re legal now!&n; *&n; * version 0.2.1 (12/14/99) gkh&n; *&t;Fixed bug that happens when device node is opened when there isn&squot;t a&n; *&t;device attached to it. Thanks to marek@webdesign.no for noticing this.&n; *&n; * version 0.2.0 (11/10/99) gkh&n; *&t;Split up internals to make it easier to add different types of serial &n; *&t;converters to the code.&n; *&t;Added a &quot;generic&quot; driver that gets it&squot;s vendor and product id&n; *&t;from when the module is loaded. Thanks to David E. Nelson (dnelson@jump.net)&n; *&t;for the idea and sample code (from the usb scanner driver.)&n; *&t;Cleared up any licensing questions by releasing it under the GNU GPL.&n; *&n; * version 0.1.2 (10/25/99) gkh&n; * &t;Fixed bug in detecting device.&n; *&n; * version 0.1.1 (10/05/99) gkh&n; * &t;Changed the major number to not conflict with anything else.&n; *&n; * version 0.1 (09/28/99) gkh&n; * &t;Can recognize the two different devices and start up a read from&n; *&t;device when asked to. Writes also work. No control signals yet, this&n; *&t;all is vendor specific data (i.e. no spec), also no control for&n; *&t;different baud rates or other bit settings.&n; *&t;Currently we are using the same devid as the acm driver. This needs&n; *&t;to change.&n; * &n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/tty_driver.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#include &quot;usb.h&quot;
macro_line|#ifdef CONFIG_USB_SERIAL_WHITEHEAT
macro_line|#include &quot;whiteheat.h&quot;&t;&t;/* firmware for the ConnectTech WhiteHEAT device */
macro_line|#endif
multiline_comment|/* Module information */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Greg Kroah-Hartman, greg@kroah.com, http://www.kroah.com/linux-usb/&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;USB Serial Driver&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_USB_SERIAL_GENERIC
DECL|variable|vendor
r_static
id|__u16
id|vendor
op_assign
l_int|0x05f9
suffix:semicolon
DECL|variable|product
r_static
id|__u16
id|product
op_assign
l_int|0xffff
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|vendor
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|vendor
comma
l_string|&quot;User specified USB idVendor&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|product
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|product
comma
l_string|&quot;User specified USB idProduct&quot;
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
op_star
id|usb_serial_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
)paren
suffix:semicolon
r_static
r_void
id|usb_serial_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
suffix:semicolon
multiline_comment|/* USB Serial devices vendor ids and device ids that this driver supports */
DECL|macro|BELKIN_VENDOR_ID
mdefine_line|#define BELKIN_VENDOR_ID&t;&t;0x056c
DECL|macro|BELKIN_SERIAL_CONVERTER
mdefine_line|#define BELKIN_SERIAL_CONVERTER&t;&t;0x8007
DECL|macro|PERACOM_VENDOR_ID
mdefine_line|#define PERACOM_VENDOR_ID&t;&t;0x0565
DECL|macro|PERACOM_SERIAL_CONVERTER
mdefine_line|#define PERACOM_SERIAL_CONVERTER&t;0x0001
DECL|macro|CONNECT_TECH_VENDOR_ID
mdefine_line|#define CONNECT_TECH_VENDOR_ID&t;&t;0x0710
DECL|macro|CONNECT_TECH_FAKE_WHITE_HEAT_ID
mdefine_line|#define CONNECT_TECH_FAKE_WHITE_HEAT_ID&t;0x0001
DECL|macro|CONNECT_TECH_WHITE_HEAT_ID
mdefine_line|#define CONNECT_TECH_WHITE_HEAT_ID&t;0x8001
DECL|macro|HANDSPRING_VENDOR_ID
mdefine_line|#define HANDSPRING_VENDOR_ID&t;&t;0x082d
DECL|macro|HANDSPRING_VISOR_ID
mdefine_line|#define HANDSPRING_VISOR_ID&t;&t;0x0100
DECL|macro|SERIAL_TTY_MAJOR
mdefine_line|#define SERIAL_TTY_MAJOR&t;188&t;/* Nice legal number now */
DECL|macro|SERIAL_TTY_MINORS
mdefine_line|#define SERIAL_TTY_MINORS&t;16&t;/* Actually we are allowed 255, but this is good for now */
DECL|macro|MAX_NUM_PORTS
mdefine_line|#define MAX_NUM_PORTS&t;8&t;/* The maximum number of ports one device can grab at once */
DECL|struct|usb_serial
r_struct
id|usb_serial
(brace
DECL|member|dev
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
DECL|member|type
r_struct
id|usb_serial_device_type
op_star
id|type
suffix:semicolon
DECL|member|irq_handle
r_void
op_star
id|irq_handle
suffix:semicolon
DECL|member|irqpipe
r_int
r_int
id|irqpipe
suffix:semicolon
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
multiline_comment|/* the coresponding tty for this device */
DECL|member|minor
r_int
r_char
id|minor
suffix:semicolon
DECL|member|num_ports
r_int
r_char
id|num_ports
suffix:semicolon
multiline_comment|/* the number of ports this device has */
DECL|member|active
r_char
id|active
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
multiline_comment|/* someone has this device open */
DECL|member|num_interrupt_in
r_char
id|num_interrupt_in
suffix:semicolon
multiline_comment|/* number of interrupt in endpoints we have */
DECL|member|interrupt_in_interval
id|__u8
id|interrupt_in_interval
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
DECL|member|interrupt_in_buffer
r_int
r_char
op_star
id|interrupt_in_buffer
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
DECL|member|control_urb
r_struct
id|urb
id|control_urb
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
DECL|member|num_bulk_in
r_char
id|num_bulk_in
suffix:semicolon
multiline_comment|/* number of bulk in endpoints we have */
DECL|member|bulk_in_buffer
r_int
r_char
op_star
id|bulk_in_buffer
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
DECL|member|read_urb
r_struct
id|urb
id|read_urb
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
DECL|member|num_bulk_out
r_char
id|num_bulk_out
suffix:semicolon
multiline_comment|/* number of bulk out endpoints we have */
DECL|member|bulk_out_buffer
r_int
r_char
op_star
id|bulk_out_buffer
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
DECL|member|bulk_out_size
r_int
id|bulk_out_size
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
DECL|member|write_urb
r_struct
id|urb
id|write_urb
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|MUST_HAVE_NOT
mdefine_line|#define MUST_HAVE_NOT&t;0x01
DECL|macro|MUST_HAVE
mdefine_line|#define MUST_HAVE&t;0x02
DECL|macro|DONT_CARE
mdefine_line|#define DONT_CARE&t;0x03
DECL|macro|HAS
mdefine_line|#define&t;HAS&t;&t;0x02
DECL|macro|HAS_NOT
mdefine_line|#define HAS_NOT&t;&t;0x01
DECL|macro|NUM_DONT_CARE
mdefine_line|#define NUM_DONT_CARE&t;(-1)
multiline_comment|/* local function prototypes */
r_static
r_int
id|serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|serial_close
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_int
id|serial_write
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_int
id|serial_write_room
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|serial_chars_in_buffer
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|serial_throttle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|serial_unthrottle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
multiline_comment|/* This structure defines the individual serial converter. */
DECL|struct|usb_serial_device_type
r_struct
id|usb_serial_device_type
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|idVendor
id|__u16
op_star
id|idVendor
suffix:semicolon
DECL|member|idProduct
id|__u16
op_star
id|idProduct
suffix:semicolon
DECL|member|needs_interrupt_in
r_char
id|needs_interrupt_in
suffix:semicolon
DECL|member|needs_bulk_in
r_char
id|needs_bulk_in
suffix:semicolon
DECL|member|needs_bulk_out
r_char
id|needs_bulk_out
suffix:semicolon
DECL|member|num_interrupt_in
r_char
id|num_interrupt_in
suffix:semicolon
DECL|member|num_bulk_in
r_char
id|num_bulk_in
suffix:semicolon
DECL|member|num_bulk_out
r_char
id|num_bulk_out
suffix:semicolon
DECL|member|num_ports
r_char
id|num_ports
suffix:semicolon
multiline_comment|/* number of serial ports this device has */
multiline_comment|/* function call to make before accepting driver */
DECL|member|startup
r_int
(paren
op_star
id|startup
)paren
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
suffix:semicolon
multiline_comment|/* return 0 to continue initialization, anything else to abort */
multiline_comment|/* serial function calls */
DECL|member|open
r_int
(paren
op_star
id|open
)paren
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
DECL|member|close
r_void
(paren
op_star
id|close
)paren
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
DECL|member|write
r_int
(paren
op_star
id|write
)paren
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
DECL|member|write_room
r_int
(paren
op_star
id|write_room
)paren
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
DECL|member|chars_in_buffer
r_int
(paren
op_star
id|chars_in_buffer
)paren
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
DECL|member|throttle
r_void
(paren
op_star
id|throttle
)paren
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
DECL|member|unthrottle
r_void
(paren
op_star
id|unthrottle
)paren
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* function prototypes for a &quot;generic&quot; type serial converter (no flow control, not all endpoints needed) */
multiline_comment|/* need to always compile these in, as some of the other devices use these functions as their own. */
r_static
r_int
id|generic_serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|generic_serial_close
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_int
id|generic_serial_write
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_int
id|generic_write_room
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|generic_chars_in_buffer
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_USB_SERIAL_GENERIC
multiline_comment|/* All of the device info needed for the Generic Serial Converter */
DECL|variable|generic_device
r_static
r_struct
id|usb_serial_device_type
id|generic_device
op_assign
(brace
id|name
suffix:colon
l_string|&quot;Generic&quot;
comma
id|idVendor
suffix:colon
op_amp
id|vendor
comma
multiline_comment|/* use the user specified vendor id */
id|idProduct
suffix:colon
op_amp
id|product
comma
multiline_comment|/* use the user specified product id */
id|needs_interrupt_in
suffix:colon
id|DONT_CARE
comma
multiline_comment|/* don&squot;t have to have an interrupt in endpoint */
id|needs_bulk_in
suffix:colon
id|DONT_CARE
comma
multiline_comment|/* don&squot;t have to have a bulk in endpoint */
id|needs_bulk_out
suffix:colon
id|DONT_CARE
comma
multiline_comment|/* don&squot;t have to have a bulk out endpoint */
id|num_interrupt_in
suffix:colon
id|NUM_DONT_CARE
comma
id|num_bulk_in
suffix:colon
id|NUM_DONT_CARE
comma
id|num_bulk_out
suffix:colon
id|NUM_DONT_CARE
comma
id|num_ports
suffix:colon
l_int|1
comma
id|open
suffix:colon
id|generic_serial_open
comma
id|close
suffix:colon
id|generic_serial_close
comma
id|write
suffix:colon
id|generic_serial_write
comma
id|write_room
suffix:colon
id|generic_write_room
comma
id|chars_in_buffer
suffix:colon
id|generic_chars_in_buffer
comma
)brace
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_USB_SERIAL_BELKIN) || defined(CONFIG_USB_SERIAL_PERACOM)
multiline_comment|/* function prototypes for the eTek type converters (this includes Belkin and Peracom) */
r_static
r_int
id|etek_serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|etek_serial_close
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_SERIAL_BELKIN
multiline_comment|/* All of the device info needed for the Belkin Serial Converter */
DECL|variable|belkin_vendor_id
r_static
id|__u16
id|belkin_vendor_id
op_assign
id|BELKIN_VENDOR_ID
suffix:semicolon
DECL|variable|belkin_product_id
r_static
id|__u16
id|belkin_product_id
op_assign
id|BELKIN_SERIAL_CONVERTER
suffix:semicolon
DECL|variable|belkin_device
r_static
r_struct
id|usb_serial_device_type
id|belkin_device
op_assign
(brace
id|name
suffix:colon
l_string|&quot;Belkin&quot;
comma
id|idVendor
suffix:colon
op_amp
id|belkin_vendor_id
comma
multiline_comment|/* the Belkin vendor id */
id|idProduct
suffix:colon
op_amp
id|belkin_product_id
comma
multiline_comment|/* the Belkin serial converter product id */
id|needs_interrupt_in
suffix:colon
id|MUST_HAVE
comma
multiline_comment|/* this device must have an interrupt in endpoint */
id|needs_bulk_in
suffix:colon
id|MUST_HAVE
comma
multiline_comment|/* this device must have a bulk in endpoint */
id|needs_bulk_out
suffix:colon
id|MUST_HAVE
comma
multiline_comment|/* this device must have a bulk out endpoint */
id|num_interrupt_in
suffix:colon
l_int|1
comma
id|num_bulk_in
suffix:colon
l_int|1
comma
id|num_bulk_out
suffix:colon
l_int|1
comma
id|num_ports
suffix:colon
l_int|1
comma
id|open
suffix:colon
id|etek_serial_open
comma
id|close
suffix:colon
id|etek_serial_close
comma
id|write
suffix:colon
id|generic_serial_write
comma
id|write_room
suffix:colon
id|generic_write_room
comma
id|chars_in_buffer
suffix:colon
id|generic_chars_in_buffer
comma
)brace
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_SERIAL_PERACOM
multiline_comment|/* All of the device info needed for the Peracom Serial Converter */
DECL|variable|peracom_vendor_id
r_static
id|__u16
id|peracom_vendor_id
op_assign
id|PERACOM_VENDOR_ID
suffix:semicolon
DECL|variable|peracom_product_id
r_static
id|__u16
id|peracom_product_id
op_assign
id|PERACOM_SERIAL_CONVERTER
suffix:semicolon
DECL|variable|peracom_device
r_static
r_struct
id|usb_serial_device_type
id|peracom_device
op_assign
(brace
id|name
suffix:colon
l_string|&quot;Peracom&quot;
comma
id|idVendor
suffix:colon
op_amp
id|peracom_vendor_id
comma
multiline_comment|/* the Peracom vendor id */
id|idProduct
suffix:colon
op_amp
id|peracom_product_id
comma
multiline_comment|/* the Peracom serial converter product id */
id|needs_interrupt_in
suffix:colon
id|MUST_HAVE
comma
multiline_comment|/* this device must have an interrupt in endpoint */
id|needs_bulk_in
suffix:colon
id|MUST_HAVE
comma
multiline_comment|/* this device must have a bulk in endpoint */
id|needs_bulk_out
suffix:colon
id|MUST_HAVE
comma
multiline_comment|/* this device must have a bulk out endpoint */
id|num_ports
suffix:colon
l_int|1
comma
id|num_interrupt_in
suffix:colon
l_int|1
comma
id|num_bulk_in
suffix:colon
l_int|1
comma
id|num_bulk_out
suffix:colon
l_int|1
comma
id|open
suffix:colon
id|etek_serial_open
comma
id|close
suffix:colon
id|etek_serial_close
comma
id|write
suffix:colon
id|generic_serial_write
comma
id|write_room
suffix:colon
id|generic_write_room
comma
id|chars_in_buffer
suffix:colon
id|generic_chars_in_buffer
comma
)brace
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_SERIAL_WHITEHEAT
multiline_comment|/* function prototypes for the Connect Tech WhiteHEAT serial converter */
r_static
r_int
id|whiteheat_serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|whiteheat_serial_close
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|whiteheat_throttle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|whiteheat_unthrottle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|whiteheat_startup
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
suffix:semicolon
multiline_comment|/* All of the device info needed for the Connect Tech WhiteHEAT */
DECL|variable|connecttech_vendor_id
r_static
id|__u16
id|connecttech_vendor_id
op_assign
id|CONNECT_TECH_VENDOR_ID
suffix:semicolon
DECL|variable|connecttech_whiteheat_fake_product_id
r_static
id|__u16
id|connecttech_whiteheat_fake_product_id
op_assign
id|CONNECT_TECH_FAKE_WHITE_HEAT_ID
suffix:semicolon
DECL|variable|connecttech_whiteheat_product_id
r_static
id|__u16
id|connecttech_whiteheat_product_id
op_assign
id|CONNECT_TECH_WHITE_HEAT_ID
suffix:semicolon
DECL|variable|whiteheat_fake_device
r_static
r_struct
id|usb_serial_device_type
id|whiteheat_fake_device
op_assign
(brace
id|name
suffix:colon
l_string|&quot;Connect Tech - WhiteHEAT - (prerenumeration)&quot;
comma
id|idVendor
suffix:colon
op_amp
id|connecttech_vendor_id
comma
multiline_comment|/* the Connect Tech vendor id */
id|idProduct
suffix:colon
op_amp
id|connecttech_whiteheat_fake_product_id
comma
multiline_comment|/* the White Heat initial product id */
id|needs_interrupt_in
suffix:colon
id|DONT_CARE
comma
multiline_comment|/* don&squot;t have to have an interrupt in endpoint */
id|needs_bulk_in
suffix:colon
id|DONT_CARE
comma
multiline_comment|/* don&squot;t have to have a bulk in endpoint */
id|needs_bulk_out
suffix:colon
id|DONT_CARE
comma
multiline_comment|/* don&squot;t have to have a bulk out endpoint */
id|num_interrupt_in
suffix:colon
id|NUM_DONT_CARE
comma
id|num_bulk_in
suffix:colon
id|NUM_DONT_CARE
comma
id|num_bulk_out
suffix:colon
id|NUM_DONT_CARE
comma
id|startup
suffix:colon
id|whiteheat_startup
)brace
suffix:semicolon
DECL|variable|whiteheat_device
r_static
r_struct
id|usb_serial_device_type
id|whiteheat_device
op_assign
(brace
id|name
suffix:colon
l_string|&quot;Connect Tech - WhiteHEAT&quot;
comma
id|idVendor
suffix:colon
op_amp
id|connecttech_vendor_id
comma
multiline_comment|/* the Connect Tech vendor id */
id|idProduct
suffix:colon
op_amp
id|connecttech_whiteheat_product_id
comma
multiline_comment|/* the White Heat real product id */
id|needs_interrupt_in
suffix:colon
id|DONT_CARE
comma
multiline_comment|/* don&squot;t have to have an interrupt in endpoint */
id|needs_bulk_in
suffix:colon
id|DONT_CARE
comma
multiline_comment|/* don&squot;t have to have a bulk in endpoint */
id|needs_bulk_out
suffix:colon
id|DONT_CARE
comma
multiline_comment|/* don&squot;t have to have a bulk out endpoint */
id|num_interrupt_in
suffix:colon
id|NUM_DONT_CARE
comma
id|num_bulk_in
suffix:colon
id|NUM_DONT_CARE
comma
id|num_bulk_out
suffix:colon
id|NUM_DONT_CARE
comma
id|num_ports
suffix:colon
l_int|4
comma
id|open
suffix:colon
id|whiteheat_serial_open
comma
id|close
suffix:colon
id|whiteheat_serial_close
comma
id|write
suffix:colon
id|generic_serial_write
comma
id|write_room
suffix:colon
id|generic_write_room
comma
id|chars_in_buffer
suffix:colon
id|generic_chars_in_buffer
comma
id|throttle
suffix:colon
id|whiteheat_throttle
comma
id|unthrottle
suffix:colon
id|whiteheat_unthrottle
)brace
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_SERIAL_VISOR
multiline_comment|/* function prototypes for a handspring visor */
r_static
r_int
id|visor_serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|visor_serial_close
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|visor_throttle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|visor_unthrottle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|visor_startup
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
suffix:semicolon
multiline_comment|/* All of the device info needed for the Handspring Visor */
DECL|variable|handspring_vendor_id
r_static
id|__u16
id|handspring_vendor_id
op_assign
id|HANDSPRING_VENDOR_ID
suffix:semicolon
DECL|variable|handspring_product_id
r_static
id|__u16
id|handspring_product_id
op_assign
id|HANDSPRING_VISOR_ID
suffix:semicolon
DECL|variable|handspring_device
r_static
r_struct
id|usb_serial_device_type
id|handspring_device
op_assign
(brace
id|name
suffix:colon
l_string|&quot;Handspring Visor&quot;
comma
id|idVendor
suffix:colon
op_amp
id|handspring_vendor_id
comma
multiline_comment|/* the Handspring vendor ID */
id|idProduct
suffix:colon
op_amp
id|handspring_product_id
comma
multiline_comment|/* the Handspring Visor product id */
id|needs_interrupt_in
suffix:colon
id|MUST_HAVE_NOT
comma
multiline_comment|/* this device must not have an interrupt in endpoint */
id|needs_bulk_in
suffix:colon
id|MUST_HAVE
comma
multiline_comment|/* this device must have a bulk in endpoint */
id|needs_bulk_out
suffix:colon
id|MUST_HAVE
comma
multiline_comment|/* this device must have a bulk out endpoint */
id|num_interrupt_in
suffix:colon
l_int|0
comma
id|num_bulk_in
suffix:colon
l_int|2
comma
id|num_bulk_out
suffix:colon
l_int|2
comma
id|num_ports
suffix:colon
l_int|2
comma
id|open
suffix:colon
id|visor_serial_open
comma
id|close
suffix:colon
id|visor_serial_close
comma
id|write
suffix:colon
id|generic_serial_write
comma
id|write_room
suffix:colon
id|generic_write_room
comma
id|chars_in_buffer
suffix:colon
id|generic_chars_in_buffer
comma
id|throttle
suffix:colon
id|visor_throttle
comma
id|unthrottle
suffix:colon
id|visor_unthrottle
comma
id|startup
suffix:colon
id|visor_startup
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/* To add support for another serial converter, create a usb_serial_device_type&n;   structure for that device, and add it to this list, making sure that the last&n;   entry is NULL. */
DECL|variable|usb_serial_devices
r_static
r_struct
id|usb_serial_device_type
op_star
id|usb_serial_devices
(braket
)braket
op_assign
(brace
macro_line|#ifdef CONFIG_USB_SERIAL_GENERIC
op_amp
id|generic_device
comma
macro_line|#endif
macro_line|#ifdef CONFIG_USB_SERIAL_WHITEHEAT
op_amp
id|whiteheat_fake_device
comma
op_amp
id|whiteheat_device
comma
macro_line|#endif
macro_line|#ifdef CONFIG_USB_SERIAL_BELKIN
op_amp
id|belkin_device
comma
macro_line|#endif
macro_line|#ifdef CONFIG_USB_SERIAL_PERACOM
op_amp
id|peracom_device
comma
macro_line|#endif
macro_line|#ifdef CONFIG_USB_SERIAL_VISOR
op_amp
id|handspring_device
comma
macro_line|#endif
l_int|NULL
)brace
suffix:semicolon
DECL|variable|usb_serial_driver
r_static
r_struct
id|usb_driver
id|usb_serial_driver
op_assign
(brace
l_string|&quot;serial&quot;
comma
id|usb_serial_probe
comma
id|usb_serial_disconnect
comma
(brace
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|variable|serial_refcount
r_static
r_int
id|serial_refcount
suffix:semicolon
DECL|variable|serial_tty
r_static
r_struct
id|tty_struct
op_star
id|serial_tty
(braket
id|SERIAL_TTY_MINORS
)braket
suffix:semicolon
DECL|variable|serial_termios
r_static
r_struct
id|termios
op_star
id|serial_termios
(braket
id|SERIAL_TTY_MINORS
)braket
suffix:semicolon
DECL|variable|serial_termios_locked
r_static
r_struct
id|termios
op_star
id|serial_termios_locked
(braket
id|SERIAL_TTY_MINORS
)braket
suffix:semicolon
DECL|variable|serial_table
r_static
r_struct
id|usb_serial
op_star
id|serial_table
(braket
id|SERIAL_TTY_MINORS
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|macro|SERIAL_PTR_EMPTY
mdefine_line|#define SERIAL_PTR_EMPTY ((void *)(-1))
DECL|function|get_serial_by_minor
r_static
r_struct
id|usb_serial
op_star
id|get_serial_by_minor
(paren
r_int
id|minor
)paren
(brace
r_int
id|i
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;get_serial_by_minor %d&quot;
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial_table
(braket
id|minor
)braket
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial_table
(braket
id|minor
)braket
op_ne
id|SERIAL_PTR_EMPTY
)paren
r_return
(paren
id|serial_table
(braket
id|minor
)braket
)paren
suffix:semicolon
id|i
op_assign
id|minor
suffix:semicolon
r_while
c_loop
(paren
id|serial_table
(braket
id|i
)braket
op_eq
id|SERIAL_PTR_EMPTY
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
op_decrement
id|i
suffix:semicolon
)brace
r_return
(paren
id|serial_table
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|get_free_serial
r_static
r_struct
id|usb_serial
op_star
id|get_free_serial
(paren
r_int
id|num_ports
comma
r_int
op_star
id|minor
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|good_spot
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;get_free_serial %d&quot;
comma
id|num_ports
)paren
suffix:semicolon
op_star
id|minor
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SERIAL_TTY_MINORS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|serial_table
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|good_spot
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|num_ports
op_minus
l_int|1
suffix:semicolon
op_increment
id|j
)paren
r_if
c_cond
(paren
id|serial_table
(braket
id|i
op_plus
id|j
)braket
)paren
id|good_spot
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|good_spot
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|serial
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|usb_serial
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Out of memory&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|serial
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|usb_serial
)paren
)paren
suffix:semicolon
id|serial_table
(braket
id|i
)braket
op_assign
id|serial
suffix:semicolon
op_star
id|minor
op_assign
id|i
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;minor base = %d&quot;
comma
op_star
id|minor
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
op_star
id|minor
op_plus
l_int|1
suffix:semicolon
(paren
id|i
OL
(paren
op_star
id|minor
op_plus
id|num_ports
)paren
)paren
op_logical_and
(paren
id|i
OL
id|SERIAL_TTY_MINORS
)paren
suffix:semicolon
op_increment
id|i
)paren
id|serial_table
(braket
id|i
)braket
op_assign
id|SERIAL_PTR_EMPTY
suffix:semicolon
r_return
(paren
id|serial
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|serial_read_bulk
r_static
r_void
id|serial_read_bulk
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|serial-&gt;tty
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_read_irq&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;nonzero read bulk status received: %d&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;actual_length
)paren
id|dbg
c_func
(paren
l_string|&quot;%d %s&quot;
comma
id|urb-&gt;actual_length
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;actual_length
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;actual_length
suffix:semicolon
op_increment
id|i
)paren
(brace
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|data
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* Continue trying to always read  */
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
id|urb
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot;failed resubmitting read urb&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|serial_write_bulk
r_static
r_void
id|serial_write_bulk
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|serial-&gt;tty
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_write_irq&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;nonzero write bulk status received: %d&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; * Driver tty interface functions&n; *****************************************************************************/
DECL|function|serial_open
r_static
r_int
id|serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_open&quot;
)paren
suffix:semicolon
multiline_comment|/* initialize the pointer incase something fails */
id|tty-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* get the serial object associated with this tty pointer */
id|serial
op_assign
id|get_serial_by_minor
(paren
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
)paren
suffix:semicolon
multiline_comment|/* do some sanity checking that we really have a device present */
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial == NULL!&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;type
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial-&gt;type == NULL!&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
multiline_comment|/* make the tty driver remember our serial object, and us it */
id|tty-&gt;driver_data
op_assign
id|serial
suffix:semicolon
id|serial-&gt;tty
op_assign
id|tty
suffix:semicolon
multiline_comment|/* pass on to the driver specific version of this function */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;open
)paren
(brace
r_return
(paren
id|serial-&gt;type
op_member_access_from_pointer
id|open
c_func
(paren
id|tty
comma
id|filp
)paren
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|serial_close
r_static
r_void
id|serial_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_close&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial == NULL!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_close port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* do some sanity checking that we really have a device present */
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;type
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial-&gt;type == NULL!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;active
(braket
id|port
)braket
)paren
(brace
id|dbg
(paren
l_string|&quot;device already open&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;close
)paren
(brace
id|serial-&gt;type
op_member_access_from_pointer
id|close
c_func
(paren
id|tty
comma
id|filp
)paren
suffix:semicolon
)brace
)brace
DECL|function|serial_write
r_static
r_int
id|serial_write
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_write port %d, %d byte(s)&quot;
comma
id|port
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* do some sanity checking that we really have a device present */
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial == NULL!&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;type
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial-&gt;type == NULL!&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;active
(braket
id|port
)braket
)paren
(brace
id|dbg
(paren
l_string|&quot;device not opened&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;write
)paren
(brace
r_return
(paren
id|serial-&gt;type
op_member_access_from_pointer
id|write
c_func
(paren
id|tty
comma
id|from_user
comma
id|buf
comma
id|count
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* no specific driver, so return that we didn&squot;t write anything */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|serial_write_room
r_static
r_int
id|serial_write_room
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_write_room port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* do some sanity checking that we really have a device present */
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial == NULL!&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;type
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial-&gt;type == NULL!&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;active
(braket
id|port
)braket
)paren
(brace
id|dbg
(paren
l_string|&quot;device not open&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;write_room
)paren
(brace
r_return
(paren
id|serial-&gt;type
op_member_access_from_pointer
id|write_room
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|serial_chars_in_buffer
r_static
r_int
id|serial_chars_in_buffer
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_chars_in_buffer port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* do some sanity checking that we really have a device present */
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial == NULL!&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;type
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial-&gt;type == NULL!&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;active
(braket
id|port
)braket
)paren
(brace
id|dbg
(paren
l_string|&quot;device not open&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;chars_in_buffer
)paren
(brace
r_return
(paren
id|serial-&gt;type
op_member_access_from_pointer
id|chars_in_buffer
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|serial_throttle
r_static
r_void
id|serial_throttle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_throttle port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* do some sanity checking that we really have a device present */
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial == NULL!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;type
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial-&gt;type == NULL!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;active
(braket
id|port
)braket
)paren
(brace
id|dbg
(paren
l_string|&quot;device not open&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;throttle
)paren
(brace
id|serial-&gt;type
op_member_access_from_pointer
id|throttle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|serial_unthrottle
r_static
r_void
id|serial_unthrottle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_unthrottle port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* do some sanity checking that we really have a device present */
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial == NULL!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;type
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial-&gt;type == NULL!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;active
(braket
id|port
)braket
)paren
(brace
id|dbg
(paren
l_string|&quot;device not open&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;unthrottle
)paren
(brace
id|serial-&gt;type
op_member_access_from_pointer
id|unthrottle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_USB_SERIAL_BELKIN) || defined(CONFIG_USB_SERIAL_PERACOM)
multiline_comment|/*****************************************************************************&n; * eTek specific driver functions&n; *****************************************************************************/
DECL|function|etek_serial_open
r_static
r_int
id|etek_serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;etek_serial_open port %d&quot;
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial-&gt;active
(braket
id|port
)braket
)paren
(brace
id|dbg
(paren
l_string|&quot;device already open&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|serial-&gt;active
(braket
id|port
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*Start reading from the device*/
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
op_amp
id|serial-&gt;read_urb
(braket
id|port
)braket
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot;usb_submit_urb(read bulk) failed&quot;
)paren
suffix:semicolon
multiline_comment|/* Need to do device specific setup here (control lines, baud rate, etc.) */
multiline_comment|/* FIXME!!! */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|etek_serial_close
r_static
r_void
id|etek_serial_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;etek_serial_close port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* Need to change the control lines here */
multiline_comment|/* FIXME */
multiline_comment|/* shutdown our bulk reads and writes */
id|usb_unlink_urb
(paren
op_amp
id|serial-&gt;write_urb
(braket
id|port
)braket
)paren
suffix:semicolon
id|usb_unlink_urb
(paren
op_amp
id|serial-&gt;read_urb
(braket
id|port
)braket
)paren
suffix:semicolon
id|serial-&gt;active
(braket
id|port
)braket
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* defined(CONFIG_USB_SERIAL_BELKIN) || defined(CONFIG_USB_SERIAL_PERACOM) */
macro_line|#ifdef CONFIG_USB_SERIAL_WHITEHEAT
multiline_comment|/*****************************************************************************&n; * Connect Tech&squot;s White Heat specific driver functions&n; *****************************************************************************/
DECL|function|whiteheat_serial_open
r_static
r_int
id|whiteheat_serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;whiteheat_serial_open port %d&quot;
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial-&gt;active
(braket
id|port
)braket
)paren
(brace
id|dbg
(paren
l_string|&quot;device already open&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|serial-&gt;active
(braket
id|port
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*Start reading from the device*/
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
op_amp
id|serial-&gt;read_urb
(braket
id|port
)braket
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot;usb_submit_urb(read bulk) failed&quot;
)paren
suffix:semicolon
multiline_comment|/* Need to do device specific setup here (control lines, baud rate, etc.) */
multiline_comment|/* FIXME!!! */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|whiteheat_serial_close
r_static
r_void
id|whiteheat_serial_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;whiteheat_serial_close port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* Need to change the control lines here */
multiline_comment|/* FIXME */
multiline_comment|/* shutdown our bulk reads and writes */
id|usb_unlink_urb
(paren
op_amp
id|serial-&gt;write_urb
(braket
id|port
)braket
)paren
suffix:semicolon
id|usb_unlink_urb
(paren
op_amp
id|serial-&gt;read_urb
(braket
id|port
)braket
)paren
suffix:semicolon
id|serial-&gt;active
(braket
id|port
)braket
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|whiteheat_throttle
r_static
r_void
id|whiteheat_throttle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;whiteheat_throttle port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* Change the control signals */
multiline_comment|/* FIXME!!! */
r_return
suffix:semicolon
)brace
DECL|function|whiteheat_unthrottle
r_static
r_void
id|whiteheat_unthrottle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;whiteheat_unthrottle port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* Change the control signals */
multiline_comment|/* FIXME!!! */
r_return
suffix:semicolon
)brace
DECL|function|whiteheat_writememory
r_static
r_int
id|whiteheat_writememory
(paren
r_struct
id|usb_serial
op_star
id|serial
comma
r_int
id|address
comma
r_int
r_char
op_star
id|data
comma
r_int
id|length
comma
id|__u8
id|bRequest
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
op_star
id|transfer_buffer
op_assign
id|kmalloc
(paren
id|length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
singleline_comment|//&t;dbg(&quot;whiteheat_writememory %x, %d&quot;, address, length);
r_if
c_cond
(paren
op_logical_neg
id|transfer_buffer
)paren
(brace
id|err
c_func
(paren
l_string|&quot;whiteheat_writememory: kmalloc(%d) failed.&bslash;n&quot;
comma
id|length
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memcpy
(paren
id|transfer_buffer
comma
id|data
comma
id|length
)paren
suffix:semicolon
id|result
op_assign
id|usb_control_msg
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|bRequest
comma
l_int|0x40
comma
id|address
comma
l_int|0
comma
id|transfer_buffer
comma
id|length
comma
l_int|300
)paren
suffix:semicolon
id|kfree
(paren
id|transfer_buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* EZ-USB Control and Status Register.  Bit 0 controls 8051 reset */
DECL|macro|CPUCS_REG
mdefine_line|#define CPUCS_REG    0x7F92
DECL|function|whiteheat_set_reset
r_static
r_int
id|whiteheat_set_reset
(paren
r_struct
id|usb_serial
op_star
id|serial
comma
r_int
r_char
id|reset_bit
)paren
(brace
r_int
id|response
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;whiteheat_set_reset: %d&quot;
comma
id|reset_bit
)paren
suffix:semicolon
id|response
op_assign
id|whiteheat_writememory
(paren
id|serial
comma
id|CPUCS_REG
comma
op_amp
id|reset_bit
comma
l_int|1
comma
l_int|0xa0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|response
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;whiteheat_set_reset %d failed&quot;
comma
id|reset_bit
)paren
suffix:semicolon
)brace
r_return
(paren
id|response
)paren
suffix:semicolon
)brace
multiline_comment|/* steps to download the firmware to the WhiteHEAT device:&n; - hold the reset (by writing to the reset bit of the CPUCS register)&n; - download the VEND_AX.HEX file to the chip using VENDOR_REQUEST-ANCHOR_LOAD&n; - release the reset (by writing to the CPUCS register)&n; - download the WH.HEX file for all addresses greater than 0x1b3f using&n;   VENDOR_REQUEST-ANCHOR_EXTERNAL_RAM_LOAD&n; - hold the reset&n; - download the WH.HEX file for all addresses less than 0x1b40 using&n;   VENDOR_REQUEST_ANCHOR_LOAD&n; - release the reset&n; - device renumerated itself and comes up as new device id with all&n;   firmware download completed.&n;*/
DECL|function|whiteheat_startup
r_static
r_int
id|whiteheat_startup
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
r_int
id|response
suffix:semicolon
r_const
r_struct
id|whiteheat_hex_record
op_star
id|record
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;whiteheat_startup&quot;
)paren
suffix:semicolon
id|response
op_assign
id|whiteheat_set_reset
(paren
id|serial
comma
l_int|1
)paren
suffix:semicolon
id|record
op_assign
op_amp
id|whiteheat_loader
(braket
l_int|0
)braket
suffix:semicolon
r_while
c_loop
(paren
id|record-&gt;address
op_ne
l_int|0xffff
)paren
(brace
id|response
op_assign
id|whiteheat_writememory
(paren
id|serial
comma
id|record-&gt;address
comma
(paren
r_int
r_char
op_star
)paren
id|record-&gt;data
comma
id|record-&gt;data_size
comma
l_int|0xa0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|response
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;whiteheat_writememory failed for loader (%d %04X %p %d)&quot;
comma
id|response
comma
id|record-&gt;address
comma
id|record-&gt;data
comma
id|record-&gt;data_size
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
op_increment
id|record
suffix:semicolon
)brace
id|response
op_assign
id|whiteheat_set_reset
(paren
id|serial
comma
l_int|0
)paren
suffix:semicolon
id|record
op_assign
op_amp
id|whiteheat_firmware
(braket
l_int|0
)braket
suffix:semicolon
r_while
c_loop
(paren
id|record-&gt;address
OL
l_int|0x1b40
)paren
(brace
op_increment
id|record
suffix:semicolon
)brace
r_while
c_loop
(paren
id|record-&gt;address
op_ne
l_int|0xffff
)paren
(brace
id|response
op_assign
id|whiteheat_writememory
(paren
id|serial
comma
id|record-&gt;address
comma
(paren
r_int
r_char
op_star
)paren
id|record-&gt;data
comma
id|record-&gt;data_size
comma
l_int|0xa0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|response
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;whiteheat_writememory failed for first firmware step (%d %04X %p %d)&quot;
comma
id|response
comma
id|record-&gt;address
comma
id|record-&gt;data
comma
id|record-&gt;data_size
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
op_increment
id|record
suffix:semicolon
)brace
id|response
op_assign
id|whiteheat_set_reset
(paren
id|serial
comma
l_int|1
)paren
suffix:semicolon
id|record
op_assign
op_amp
id|whiteheat_firmware
(braket
l_int|0
)braket
suffix:semicolon
r_while
c_loop
(paren
id|record-&gt;address
OL
l_int|0x1b40
)paren
(brace
id|response
op_assign
id|whiteheat_writememory
(paren
id|serial
comma
id|record-&gt;address
comma
(paren
r_int
r_char
op_star
)paren
id|record-&gt;data
comma
id|record-&gt;data_size
comma
l_int|0xa0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|response
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;whiteheat_writememory failed for second firmware step (%d %04X %p %d)&bslash;n&quot;
comma
id|response
comma
id|record-&gt;address
comma
id|record-&gt;data
comma
id|record-&gt;data_size
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
op_increment
id|record
suffix:semicolon
)brace
id|response
op_assign
id|whiteheat_set_reset
(paren
id|serial
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* we want this device to fail to have a driver assigned to it. */
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_USB_SERIAL_WHITEHEAT */
macro_line|#ifdef CONFIG_USB_SERIAL_VISOR
multiline_comment|/******************************************************************************&n; * Handspring Visor specific driver functions&n; ******************************************************************************/
DECL|function|visor_serial_open
r_static
r_int
id|visor_serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;visor_serial_open port %d&quot;
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial-&gt;active
(braket
id|port
)braket
)paren
(brace
id|dbg
(paren
l_string|&quot;device already open&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|serial-&gt;active
(braket
id|port
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*Start reading from the device*/
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
op_amp
id|serial-&gt;read_urb
(braket
id|port
)braket
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot;usb_submit_urb(read bulk) failed&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|visor_serial_close
r_static
r_void
id|visor_serial_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;visor_serial_close port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* shutdown our bulk reads and writes */
id|usb_unlink_urb
(paren
op_amp
id|serial-&gt;write_urb
(braket
id|port
)braket
)paren
suffix:semicolon
id|usb_unlink_urb
(paren
op_amp
id|serial-&gt;read_urb
(braket
id|port
)braket
)paren
suffix:semicolon
id|serial-&gt;active
(braket
id|port
)braket
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|visor_throttle
r_static
r_void
id|visor_throttle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;visor_throttle port %d&quot;
comma
id|port
)paren
suffix:semicolon
id|usb_unlink_urb
(paren
op_amp
id|serial-&gt;read_urb
(braket
id|port
)braket
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|visor_unthrottle
r_static
r_void
id|visor_unthrottle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;visor_unthrottle port %d&quot;
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_unlink_urb
(paren
op_amp
id|serial-&gt;read_urb
(braket
id|port
)braket
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot;usb_submit_urb(read bulk) failed&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; Here&squot;s the raw dump of the vendor specific command data that the Visor sends on Win98&n;______________________________________________________________________&n;SETUP(0xB4) ADDR(0x02) ENDP(0x0) CRC5(0x15)&n;______________________________________________________________________&n;DATA0(0xC3) DATA(C2 03 00 00 00 00 12 00 ) CRC16(0xB0BB)&n;______________________________________________________________________&n;ACK(0x4B)&n;______________________________________________________________________&n;IN(0x96) ADDR(0x02) ENDP(0x0) CRC5(0x15)&n;______________________________________________________________________&n;DATA1(0xD2) DATA(02 00 00 01 02 02 ) CRC16(0xF4E6)&n;______________________________________________________________________&n;ACK(0x4B)&n;______________________________________________________________________&n;OUT(0x87) ADDR(0x02) ENDP(0x0) CRC5(0x15)&n;______________________________________________________________________&n;DATA1(0xD2) DATA() CRC16(0x0000)&n;______________________________________________________________________&n;ACK(0x4B)&n;______________________________________________________________________&n;SETUP(0xB4) ADDR(0x02) ENDP(0x0) CRC5(0x15)&n;______________________________________________________________________&n;DATA0(0xC3) DATA(C2 01 00 00 05 00 02 00 ) CRC16(0xC488)&n;______________________________________________________________________&n;ACK(0x4B)&n;______________________________________________________________________&n;IN(0x96) ADDR(0x02) ENDP(0x0) CRC5(0x15)&n;______________________________________________________________________&n;DATA1(0xD2) DATA(01 00 ) CRC16(0xFFFB)&n;______________________________________________________________________&n;ACK(0x4B)&n;______________________________________________________________________&n;OUT(0x87) ADDR(0x02) ENDP(0x0) CRC5(0x15)&n;______________________________________________________________________&n;DATA1(0xD2) DATA() CRC16(0x0000)&n;______________________________________________________________________&n;ACK(0x4B)&n;______________________________________________________________________&n;*/
DECL|function|visor_startup
r_static
r_int
id|visor_startup
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
multiline_comment|/* send out two unknown commands that I found by looking at a Win98 trace */
r_int
id|response
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
op_star
id|transfer_buffer
op_assign
id|kmalloc
(paren
l_int|256
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transfer_buffer
)paren
(brace
id|err
c_func
(paren
l_string|&quot;visor_startup: kmalloc(%d) failed.&bslash;n&quot;
comma
l_int|256
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;visor_startup&quot;
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;visor_setup: Set config to 1&quot;
)paren
suffix:semicolon
id|usb_set_configuration
(paren
id|serial-&gt;dev
comma
l_int|1
)paren
suffix:semicolon
id|response
op_assign
id|usb_control_msg
(paren
id|serial-&gt;dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
l_int|0x03
comma
l_int|0xc2
comma
l_int|0x0000
comma
l_int|0x0000
comma
id|transfer_buffer
comma
l_int|0x12
comma
l_int|300
)paren
suffix:semicolon
r_if
c_cond
(paren
id|response
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;visor_startup: error getting first vendor specific message&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|dbg
c_func
(paren
l_string|&quot;visor_startup: First vendor specific message successful, data received:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|response
suffix:semicolon
op_increment
id|i
)paren
id|dbg
c_func
(paren
l_string|&quot;    0x%.2x&quot;
comma
id|transfer_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|response
op_assign
id|usb_control_msg
(paren
id|serial-&gt;dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
l_int|0x01
comma
l_int|0xc2
comma
l_int|0x0000
comma
l_int|0x0005
comma
id|transfer_buffer
comma
l_int|0x02
comma
l_int|300
)paren
suffix:semicolon
r_if
c_cond
(paren
id|response
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;visor_startup: error getting second vendor specific message&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|dbg
c_func
(paren
l_string|&quot;visor_startup: Second vendor specific message successful, data received:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|response
suffix:semicolon
op_increment
id|i
)paren
id|dbg
c_func
(paren
l_string|&quot;    0x%.2x&quot;
comma
id|transfer_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|transfer_buffer
)paren
suffix:semicolon
multiline_comment|/* continue on with initialization */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_USB_SERIAL_VISOR*/
multiline_comment|/*****************************************************************************&n; * generic devices specific driver functions&n; *****************************************************************************/
DECL|function|generic_serial_open
r_static
r_int
id|generic_serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;generic_serial_open port %d&quot;
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial-&gt;active
(braket
id|port
)braket
)paren
(brace
id|dbg
(paren
l_string|&quot;device already open&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|serial-&gt;active
(braket
id|port
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* if we have a bulk interrupt, start reading from it */
r_if
c_cond
(paren
id|serial-&gt;num_bulk_in
)paren
(brace
multiline_comment|/*Start reading from the device*/
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
op_amp
id|serial-&gt;read_urb
(braket
id|port
)braket
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot;usb_submit_urb(read bulk) failed&quot;
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|generic_serial_close
r_static
r_void
id|generic_serial_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;generic_serial_close port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* shutdown any bulk reads that might be going on */
r_if
c_cond
(paren
id|serial-&gt;num_bulk_out
)paren
(brace
id|usb_unlink_urb
(paren
op_amp
id|serial-&gt;write_urb
(braket
id|port
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|serial-&gt;num_bulk_in
)paren
(brace
id|usb_unlink_urb
(paren
op_amp
id|serial-&gt;read_urb
(braket
id|port
)braket
)paren
suffix:semicolon
)brace
id|serial-&gt;active
(braket
id|port
)braket
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|generic_serial_write
r_static
r_int
id|generic_serial_write
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;generic_serial_write port %d&quot;
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;write request of 0 bytes&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* only do something if we have a bulk out endpoint */
r_if
c_cond
(paren
id|serial-&gt;num_bulk_out
)paren
(brace
r_if
c_cond
(paren
id|serial-&gt;write_urb
(braket
id|port
)braket
dot
id|status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
id|dbg
(paren
l_string|&quot;already writing&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|count
op_assign
(paren
id|count
OG
id|serial-&gt;bulk_out_size
(braket
id|port
)braket
)paren
ques
c_cond
id|serial-&gt;bulk_out_size
(braket
id|port
)braket
suffix:colon
id|count
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
(brace
id|copy_from_user
c_func
(paren
id|serial-&gt;write_urb
(braket
id|port
)braket
dot
id|transfer_buffer
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
(paren
id|serial-&gt;write_urb
(braket
id|port
)braket
dot
id|transfer_buffer
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* send the data out the bulk port */
id|serial-&gt;write_urb
(braket
id|port
)braket
dot
id|transfer_buffer_length
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
op_amp
id|serial-&gt;write_urb
(braket
id|port
)braket
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot;usb_submit_urb(write bulk) failed&quot;
)paren
suffix:semicolon
r_return
(paren
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* no bulk out, so return 0 bytes written */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|generic_write_room
r_static
r_int
id|generic_write_room
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_int
id|room
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;generic_write_room port %d&quot;
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial-&gt;num_bulk_out
)paren
(brace
r_if
c_cond
(paren
id|serial-&gt;write_urb
(braket
id|port
)braket
dot
id|status
op_eq
op_minus
id|EINPROGRESS
)paren
id|room
op_assign
l_int|0
suffix:semicolon
r_else
id|room
op_assign
id|serial-&gt;bulk_out_size
(braket
id|port
)braket
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;generic_write_room returns %d&quot;
comma
id|room
)paren
suffix:semicolon
r_return
(paren
id|room
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|generic_chars_in_buffer
r_static
r_int
id|generic_chars_in_buffer
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;generic_chars_in_buffer port %d&quot;
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial-&gt;num_bulk_out
)paren
(brace
r_if
c_cond
(paren
id|serial-&gt;write_urb
(braket
id|port
)braket
dot
id|status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
r_return
(paren
id|serial-&gt;bulk_out_size
(braket
id|port
)braket
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|usb_serial_probe
r_static
r_void
op_star
id|usb_serial_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|interface
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|endpoint
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|interrupt_in_endpoint
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|bulk_in_endpoint
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|bulk_out_endpoint
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
r_struct
id|usb_serial_device_type
op_star
id|type
suffix:semicolon
r_int
id|device_num
suffix:semicolon
r_int
id|minor
suffix:semicolon
r_int
id|buffer_size
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
id|interrupt_pipe
suffix:semicolon
r_char
id|bulk_in_pipe
suffix:semicolon
r_char
id|bulk_out_pipe
suffix:semicolon
r_int
id|num_interrupt_in
op_assign
l_int|0
suffix:semicolon
r_int
id|num_bulk_in
op_assign
l_int|0
suffix:semicolon
r_int
id|num_bulk_out
op_assign
l_int|0
suffix:semicolon
r_int
id|num_ports
suffix:semicolon
multiline_comment|/* loop through our list of known serial converters, and see if this device matches */
id|device_num
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|usb_serial_devices
(braket
id|device_num
)braket
op_ne
l_int|NULL
)paren
(brace
id|type
op_assign
id|usb_serial_devices
(braket
id|device_num
)braket
suffix:semicolon
id|dbg
(paren
l_string|&quot;Looking at %s Vendor id=%.4x Product id=%.4x&quot;
comma
id|type-&gt;name
comma
op_star
(paren
id|type-&gt;idVendor
)paren
comma
op_star
(paren
id|type-&gt;idProduct
)paren
)paren
suffix:semicolon
multiline_comment|/* look at the device descriptor */
r_if
c_cond
(paren
(paren
id|dev-&gt;descriptor.idVendor
op_eq
op_star
(paren
id|type-&gt;idVendor
)paren
)paren
op_logical_and
(paren
id|dev-&gt;descriptor.idProduct
op_eq
op_star
(paren
id|type-&gt;idProduct
)paren
)paren
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;descriptor matches...looking at the endpoints&quot;
)paren
suffix:semicolon
multiline_comment|/* descriptor matches, let&squot;s try to find the endpoints needed */
id|interrupt_pipe
op_assign
id|bulk_in_pipe
op_assign
id|bulk_out_pipe
op_assign
id|HAS_NOT
suffix:semicolon
multiline_comment|/* check out the endpoints */
id|interface
op_assign
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|ifnum
)braket
dot
id|altsetting
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|interface-&gt;bNumEndpoints
suffix:semicolon
op_increment
id|i
)paren
(brace
id|endpoint
op_assign
op_amp
id|interface-&gt;endpoint
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|endpoint-&gt;bEndpointAddress
op_amp
l_int|0x80
)paren
op_logical_and
(paren
(paren
id|endpoint-&gt;bmAttributes
op_amp
l_int|3
)paren
op_eq
l_int|0x02
)paren
)paren
(brace
multiline_comment|/* we found a bulk in endpoint */
id|dbg
c_func
(paren
l_string|&quot;found bulk in&quot;
)paren
suffix:semicolon
id|bulk_in_pipe
op_assign
id|HAS
suffix:semicolon
id|bulk_in_endpoint
(braket
id|num_bulk_in
)braket
op_assign
id|endpoint
suffix:semicolon
op_increment
id|num_bulk_in
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|endpoint-&gt;bEndpointAddress
op_amp
l_int|0x80
)paren
op_eq
l_int|0x00
)paren
op_logical_and
(paren
(paren
id|endpoint-&gt;bmAttributes
op_amp
l_int|3
)paren
op_eq
l_int|0x02
)paren
)paren
(brace
multiline_comment|/* we found a bulk out endpoint */
id|dbg
c_func
(paren
l_string|&quot;found bulk out&quot;
)paren
suffix:semicolon
id|bulk_out_pipe
op_assign
id|HAS
suffix:semicolon
id|bulk_out_endpoint
(braket
id|num_bulk_out
)braket
op_assign
id|endpoint
suffix:semicolon
op_increment
id|num_bulk_out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|endpoint-&gt;bEndpointAddress
op_amp
l_int|0x80
)paren
op_logical_and
(paren
(paren
id|endpoint-&gt;bmAttributes
op_amp
l_int|3
)paren
op_eq
l_int|0x03
)paren
)paren
(brace
multiline_comment|/* we found a interrupt in endpoint */
id|dbg
c_func
(paren
l_string|&quot;found interrupt in&quot;
)paren
suffix:semicolon
id|interrupt_pipe
op_assign
id|HAS
suffix:semicolon
id|interrupt_in_endpoint
(braket
id|num_interrupt_in
)braket
op_assign
id|endpoint
suffix:semicolon
op_increment
id|num_interrupt_in
suffix:semicolon
)brace
)brace
multiline_comment|/* verify that we found all of the endpoints that we need */
r_if
c_cond
(paren
(paren
id|interrupt_pipe
op_amp
id|type-&gt;needs_interrupt_in
)paren
op_logical_and
(paren
id|bulk_in_pipe
op_amp
id|type-&gt;needs_bulk_in
)paren
op_logical_and
(paren
id|bulk_out_pipe
op_amp
id|type-&gt;needs_bulk_out
)paren
)paren
(brace
multiline_comment|/* found all that we need */
id|info
c_func
(paren
l_string|&quot;%s converter detected&quot;
comma
id|type-&gt;name
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_USB_SERIAL_GENERIC
r_if
c_cond
(paren
id|type
op_eq
op_amp
id|generic_device
)paren
id|num_ports
op_assign
id|num_bulk_out
suffix:semicolon
r_else
macro_line|#endif
id|num_ports
op_assign
id|type-&gt;num_ports
suffix:semicolon
id|serial
op_assign
id|get_free_serial
(paren
id|num_ports
comma
op_amp
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;No more free serial devices&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|serial-&gt;dev
op_assign
id|dev
suffix:semicolon
id|serial-&gt;type
op_assign
id|type
suffix:semicolon
id|serial-&gt;minor
op_assign
id|minor
suffix:semicolon
id|serial-&gt;num_ports
op_assign
id|num_ports
suffix:semicolon
id|serial-&gt;num_bulk_in
op_assign
id|num_bulk_in
suffix:semicolon
id|serial-&gt;num_bulk_out
op_assign
id|num_bulk_out
suffix:semicolon
id|serial-&gt;num_interrupt_in
op_assign
id|num_interrupt_in
suffix:semicolon
multiline_comment|/* if this device type has a startup function, call it */
r_if
c_cond
(paren
id|type-&gt;startup
)paren
(brace
r_if
c_cond
(paren
id|type-&gt;startup
(paren
id|serial
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* set up the endpoint information */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_bulk_in
suffix:semicolon
op_increment
id|i
)paren
(brace
id|buffer_size
op_assign
id|bulk_in_endpoint
(braket
id|i
)braket
op_member_access_from_pointer
id|wMaxPacketSize
suffix:semicolon
id|serial-&gt;bulk_in_buffer
(braket
id|i
)braket
op_assign
id|kmalloc
(paren
id|buffer_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;bulk_in_buffer
(braket
id|i
)braket
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Couldn&squot;t allocate bulk_in_buffer&quot;
)paren
suffix:semicolon
r_goto
id|probe_error
suffix:semicolon
)brace
id|FILL_BULK_URB
c_func
(paren
op_amp
id|serial-&gt;read_urb
(braket
id|i
)braket
comma
id|dev
comma
id|usb_rcvbulkpipe
(paren
id|dev
comma
id|bulk_in_endpoint
(braket
id|i
)braket
op_member_access_from_pointer
id|bEndpointAddress
)paren
comma
id|serial-&gt;bulk_in_buffer
(braket
id|i
)braket
comma
id|buffer_size
comma
id|serial_read_bulk
comma
id|serial
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_bulk_out
suffix:semicolon
op_increment
id|i
)paren
(brace
id|serial-&gt;bulk_out_size
(braket
id|i
)braket
op_assign
id|bulk_out_endpoint
(braket
id|i
)braket
op_member_access_from_pointer
id|wMaxPacketSize
suffix:semicolon
id|serial-&gt;bulk_out_buffer
(braket
id|i
)braket
op_assign
id|kmalloc
(paren
id|serial-&gt;bulk_out_size
(braket
id|i
)braket
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;bulk_out_buffer
(braket
id|i
)braket
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Couldn&squot;t allocate bulk_out_buffer&quot;
)paren
suffix:semicolon
r_goto
id|probe_error
suffix:semicolon
)brace
id|FILL_BULK_URB
c_func
(paren
op_amp
id|serial-&gt;write_urb
(braket
id|i
)braket
comma
id|dev
comma
id|usb_sndbulkpipe
(paren
id|dev
comma
id|bulk_out_endpoint
(braket
id|i
)braket
op_member_access_from_pointer
id|bEndpointAddress
)paren
comma
id|serial-&gt;bulk_out_buffer
(braket
id|i
)braket
comma
id|serial-&gt;bulk_out_size
(braket
id|i
)braket
comma
id|serial_write_bulk
comma
id|serial
)paren
suffix:semicolon
)brace
macro_line|#if 0 /* use this code when WhiteHEAT is up and running */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_interrupt_in
suffix:semicolon
op_increment
id|i
)paren
(brace
id|buffer_size
op_assign
id|interrupt_in_endpoint
(braket
id|i
)braket
op_member_access_from_pointer
id|wMaxPacketSize
suffix:semicolon
id|serial-&gt;interrupt_in_buffer
(braket
id|i
)braket
op_assign
id|kmalloc
(paren
id|buffer_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;interrupt_in_buffer
(braket
id|i
)braket
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Couldn&squot;t allocate interrupt_in_buffer&quot;
)paren
suffix:semicolon
r_goto
id|probe_error
suffix:semicolon
)brace
id|FILL_INT_URB
c_func
(paren
op_amp
id|serial-&gt;control_urb
(braket
id|i
)braket
comma
id|dev
comma
id|usb_rcvintpipe
(paren
id|dev
comma
id|interrupt_in_endpoint
(braket
id|i
)braket
op_member_access_from_pointer
id|bEndpointAddress
)paren
comma
id|serial-&gt;interrupt_in_buffer
(braket
id|i
)braket
comma
id|buffer_size
comma
id|serial_control_irq
comma
id|serial
comma
id|interrupt_in_endpoint
(braket
id|i
)braket
op_member_access_from_pointer
id|bInterval
)paren
suffix:semicolon
)brace
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_ports
suffix:semicolon
op_increment
id|i
)paren
(brace
id|info
c_func
(paren
l_string|&quot;%s converter now attached to ttyUSB%d&quot;
comma
id|type-&gt;name
comma
id|serial-&gt;minor
op_plus
id|i
)paren
suffix:semicolon
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
id|serial
suffix:semicolon
)brace
r_else
(brace
id|info
c_func
(paren
l_string|&quot;descriptors matched, but endpoints did not&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* look at the next type in our list */
op_increment
id|device_num
suffix:semicolon
)brace
id|probe_error
suffix:colon
r_if
c_cond
(paren
id|serial
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_bulk_in
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|serial-&gt;bulk_in_buffer
(braket
id|i
)braket
)paren
id|kfree
(paren
id|serial-&gt;bulk_in_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_bulk_out
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|serial-&gt;bulk_out_buffer
(braket
id|i
)braket
)paren
id|kfree
(paren
id|serial-&gt;bulk_out_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_interrupt_in
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|serial-&gt;interrupt_in_buffer
(braket
id|i
)braket
)paren
id|kfree
(paren
id|serial-&gt;interrupt_in_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|usb_serial_disconnect
r_static
r_void
id|usb_serial_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|ptr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|serial
)paren
(brace
multiline_comment|/* need to stop any transfers...*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_ports
suffix:semicolon
op_increment
id|i
)paren
(brace
id|usb_unlink_urb
(paren
op_amp
id|serial-&gt;write_urb
(braket
id|i
)braket
)paren
suffix:semicolon
id|usb_unlink_urb
(paren
op_amp
id|serial-&gt;read_urb
(braket
id|i
)braket
)paren
suffix:semicolon
id|serial-&gt;active
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|serial_table
(braket
id|serial-&gt;minor
op_plus
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* free up any memory that we allocated */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_bulk_in
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|serial-&gt;bulk_in_buffer
(braket
id|i
)braket
)paren
id|kfree
(paren
id|serial-&gt;bulk_in_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_bulk_out
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|serial-&gt;bulk_out_buffer
(braket
id|i
)braket
)paren
id|kfree
(paren
id|serial-&gt;bulk_out_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_interrupt_in
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|serial-&gt;interrupt_in_buffer
(braket
id|i
)braket
)paren
id|kfree
(paren
id|serial-&gt;interrupt_in_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_ports
suffix:semicolon
op_increment
id|i
)paren
(brace
id|info
c_func
(paren
l_string|&quot;%s converter now disconnected from ttyUSB%d&quot;
comma
id|serial-&gt;type-&gt;name
comma
id|serial-&gt;minor
op_plus
id|i
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|serial
)paren
suffix:semicolon
)brace
r_else
(brace
id|info
c_func
(paren
l_string|&quot;device disconnected&quot;
)paren
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|variable|serial_tty_driver
r_static
r_struct
id|tty_driver
id|serial_tty_driver
op_assign
(brace
id|magic
suffix:colon
id|TTY_DRIVER_MAGIC
comma
id|driver_name
suffix:colon
l_string|&quot;usb&quot;
comma
id|name
suffix:colon
l_string|&quot;ttyUSB&quot;
comma
id|major
suffix:colon
id|SERIAL_TTY_MAJOR
comma
id|minor_start
suffix:colon
l_int|0
comma
id|num
suffix:colon
id|SERIAL_TTY_MINORS
comma
id|type
suffix:colon
id|TTY_DRIVER_TYPE_SERIAL
comma
id|subtype
suffix:colon
id|SERIAL_TYPE_NORMAL
comma
id|flags
suffix:colon
id|TTY_DRIVER_REAL_RAW
comma
id|refcount
suffix:colon
op_amp
id|serial_refcount
comma
id|table
suffix:colon
id|serial_tty
comma
id|proc_entry
suffix:colon
l_int|NULL
comma
id|other
suffix:colon
l_int|NULL
comma
id|termios
suffix:colon
id|serial_termios
comma
id|termios_locked
suffix:colon
id|serial_termios_locked
comma
id|open
suffix:colon
id|serial_open
comma
id|close
suffix:colon
id|serial_close
comma
id|write
suffix:colon
id|serial_write
comma
id|put_char
suffix:colon
l_int|NULL
comma
id|flush_chars
suffix:colon
l_int|NULL
comma
id|write_room
suffix:colon
id|serial_write_room
comma
id|ioctl
suffix:colon
l_int|NULL
comma
id|set_termios
suffix:colon
l_int|NULL
comma
id|set_ldisc
suffix:colon
l_int|NULL
comma
id|throttle
suffix:colon
id|serial_throttle
comma
id|unthrottle
suffix:colon
id|serial_unthrottle
comma
id|stop
suffix:colon
l_int|NULL
comma
id|start
suffix:colon
l_int|NULL
comma
id|hangup
suffix:colon
l_int|NULL
comma
id|break_ctl
suffix:colon
l_int|NULL
comma
id|wait_until_sent
suffix:colon
l_int|NULL
comma
id|send_xchar
suffix:colon
l_int|NULL
comma
id|read_proc
suffix:colon
l_int|NULL
comma
id|chars_in_buffer
suffix:colon
id|serial_chars_in_buffer
comma
id|flush_buffer
suffix:colon
l_int|NULL
)brace
suffix:semicolon
DECL|function|usb_serial_init
r_int
id|usb_serial_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Initalize our global data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SERIAL_TTY_MINORS
suffix:semicolon
op_increment
id|i
)paren
(brace
id|serial_table
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* register the tty driver */
id|serial_tty_driver.init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|serial_tty_driver.init_termios.c_cflag
op_assign
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
op_or
id|CLOCAL
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
(paren
op_amp
id|serial_tty_driver
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;failed to register tty driver&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/* register the USB driver */
r_if
c_cond
(paren
id|usb_register
c_func
(paren
op_amp
id|usb_serial_driver
)paren
OL
l_int|0
)paren
(brace
id|tty_unregister_driver
c_func
(paren
op_amp
id|serial_tty_driver
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|info
c_func
(paren
l_string|&quot;support registered&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|usb_serial_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|tty_unregister_driver
c_func
(paren
op_amp
id|serial_tty_driver
)paren
suffix:semicolon
id|usb_deregister
c_func
(paren
op_amp
id|usb_serial_driver
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
