multiline_comment|/*&n; * USB IBM C-It Video Camera driver&n; *&n; * Supports IBM C-It Video Camera.&n; *&n; * This driver is based on earlier work of:&n; *&n; * (C) Copyright 1999 Johannes Erdfelt&n; * (C) Copyright 1999 Randy Dunlap&n; *&n; * 5/24/00 Removed optional (and unnecessary) locking of the driver while&n; * the device remains plugged in. Corrected race conditions in ibmcam_open&n; * and ibmcam_probe() routines using this as a guideline:&n; *&n; * (2) The big kernel lock is automatically released when a process sleeps&n; *   in the kernel and is automatically reacquired on reschedule if the&n; *   process had the lock originally.  Any code that can be compiled as&n; *   a module and is entered with the big kernel lock held *MUST*&n; *   increment the use count to activate the indirect module protection&n; *   before doing anything that might sleep.&n; *&n; *   In practice, this means that all routines that live in modules and&n; *   are invoked under the big kernel lock should do MOD_INC_USE_COUNT&n; *   as their very first action.  And all failure paths from that&n; *   routine must do MOD_DEC_USE_COUNT before returning.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/videodev.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/wrapper.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;ibmcam.h&quot;
DECL|macro|ENABLE_HEXDUMP
mdefine_line|#define&t;ENABLE_HEXDUMP&t;0&t;/* Enable if you need it */
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Completion states of the data parser */
r_typedef
r_enum
(brace
DECL|enumerator|scan_Continue
id|scan_Continue
comma
multiline_comment|/* Just parse next item */
DECL|enumerator|scan_NextFrame
id|scan_NextFrame
comma
multiline_comment|/* Frame done, send it to V4L */
DECL|enumerator|scan_Out
id|scan_Out
comma
multiline_comment|/* Not enough data for frame */
DECL|enumerator|scan_EndParse
id|scan_EndParse
multiline_comment|/* End parsing */
DECL|typedef|scan_state_t
)brace
id|scan_state_t
suffix:semicolon
multiline_comment|/* Bit flags (options) */
DECL|macro|FLAGS_RETRY_VIDIOCSYNC
mdefine_line|#define FLAGS_RETRY_VIDIOCSYNC&t;&t;(1 &lt;&lt; 0)
DECL|macro|FLAGS_MONOCHROME
mdefine_line|#define&t;FLAGS_MONOCHROME&t;&t;(1 &lt;&lt; 1)
DECL|macro|FLAGS_DISPLAY_HINTS
mdefine_line|#define FLAGS_DISPLAY_HINTS&t;&t;(1 &lt;&lt; 2)
DECL|macro|FLAGS_OVERLAY_STATS
mdefine_line|#define FLAGS_OVERLAY_STATS&t;&t;(1 &lt;&lt; 3)
DECL|macro|FLAGS_FORCE_TESTPATTERN
mdefine_line|#define FLAGS_FORCE_TESTPATTERN&t;&t;(1 &lt;&lt; 4)
DECL|macro|FLAGS_SEPARATE_FRAMES
mdefine_line|#define FLAGS_SEPARATE_FRAMES&t;&t;(1 &lt;&lt; 5)
DECL|macro|FLAGS_CLEAN_FRAMES
mdefine_line|#define FLAGS_CLEAN_FRAMES&t;&t;(1 &lt;&lt; 6)
DECL|variable|flags
r_static
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FLAGS_DISPLAY_HINTS | FLAGS_OVERLAY_STATS; */
multiline_comment|/* This is the size of V4L frame that we provide */
DECL|variable|imgwidth
r_static
r_const
r_int
id|imgwidth
op_assign
id|V4L_FRAME_WIDTH_USED
suffix:semicolon
DECL|variable|imgheight
r_static
r_const
r_int
id|imgheight
op_assign
id|V4L_FRAME_HEIGHT
suffix:semicolon
DECL|variable|min_imgwidth
r_static
r_const
r_int
id|min_imgwidth
op_assign
l_int|8
suffix:semicolon
DECL|variable|min_imgheight
r_static
r_const
r_int
id|min_imgheight
op_assign
l_int|4
suffix:semicolon
DECL|variable|lighting
r_static
r_int
id|lighting
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Medium */
DECL|macro|SHARPNESS_MIN
mdefine_line|#define SHARPNESS_MIN&t;0
DECL|macro|SHARPNESS_MAX
mdefine_line|#define SHARPNESS_MAX&t;6
DECL|variable|sharpness
r_static
r_int
id|sharpness
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* Low noise, good details */
DECL|macro|FRAMERATE_MIN
mdefine_line|#define FRAMERATE_MIN&t;0
DECL|macro|FRAMERATE_MAX
mdefine_line|#define FRAMERATE_MAX&t;6
DECL|variable|framerate
r_static
r_int
id|framerate
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Lower, reliable frame rate (8-12 fps) */
r_enum
(brace
DECL|enumerator|VIDEOSIZE_128x96
id|VIDEOSIZE_128x96
op_assign
l_int|0
comma
DECL|enumerator|VIDEOSIZE_176x144
id|VIDEOSIZE_176x144
comma
DECL|enumerator|VIDEOSIZE_352x288
id|VIDEOSIZE_352x288
comma
DECL|enumerator|VIDEOSIZE_320x240
id|VIDEOSIZE_320x240
comma
DECL|enumerator|VIDEOSIZE_352x240
id|VIDEOSIZE_352x240
comma
)brace
suffix:semicolon
DECL|variable|videosize
r_static
r_int
id|videosize
op_assign
id|VIDEOSIZE_352x288
suffix:semicolon
multiline_comment|/*&n; * The value of &squot;scratchbufsize&squot; affects quality of the picture&n; * in many ways. Shorter buffers may cause loss of data when client&n; * is too slow. Larger buffers are memory-consuming and take longer&n; * to work with. This setting can be adjusted, but the default value&n; * should be OK for most desktop users.&n; */
DECL|macro|DEFAULT_SCRATCH_BUF_SIZE
mdefine_line|#define DEFAULT_SCRATCH_BUF_SIZE&t;(0x10000)&t;/* 64 KB */
DECL|variable|scratchbufsize
r_static
r_const
r_int
id|scratchbufsize
op_assign
id|DEFAULT_SCRATCH_BUF_SIZE
suffix:semicolon
multiline_comment|/*&n; * Here we define several initialization variables. They may&n; * be used to automatically set color, hue, brightness and&n; * contrast to desired values. This is particularly useful in&n; * case of webcams (which have no controls and no on-screen&n; * output) and also when a client V4L software is used that&n; * does not have some of those controls. In any case it&squot;s&n; * good to have startup values as options.&n; *&n; * These values are all in [0..255] range. This simplifies&n; * operation. Note that actual values of V4L variables may&n; * be scaled up (as much as &lt;&lt; 8). User can see that only&n; * on overlay output, however, or through a V4L client.&n; */
DECL|variable|init_brightness
r_static
r_int
id|init_brightness
op_assign
l_int|128
suffix:semicolon
DECL|variable|init_contrast
r_static
r_int
id|init_contrast
op_assign
l_int|192
suffix:semicolon
DECL|variable|init_color
r_static
r_int
id|init_color
op_assign
l_int|128
suffix:semicolon
DECL|variable|init_hue
r_static
r_int
id|init_hue
op_assign
l_int|128
suffix:semicolon
DECL|variable|hue_correction
r_static
r_int
id|hue_correction
op_assign
l_int|128
suffix:semicolon
multiline_comment|/* Settings for camera model 2 */
DECL|variable|init_model2_rg
r_static
r_int
id|init_model2_rg
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|init_model2_rg2
r_static
r_int
id|init_model2_rg2
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|init_model2_sat
r_static
r_int
id|init_model2_sat
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|init_model2_yb
r_static
r_int
id|init_model2_yb
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|debug
comma
l_string|&quot;Debug level: 0-9 (default=0)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|flags
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|flags
comma
l_string|&quot;Bitfield: 0=VIDIOCSYNC, 1=B/W, 2=show hints, 3=show stats, 4=test pattern, 5=seperate frames, 6=clean frames&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|framerate
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|framerate
comma
l_string|&quot;Framerate setting: 0=slowest, 6=fastest (default=2)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|lighting
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|lighting
comma
l_string|&quot;Photosensitivity: 0=bright, 1=medium (default), 2=low light&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|sharpness
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|sharpness
comma
l_string|&quot;Model1 noise reduction: 0=smooth, 6=sharp (default=4)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|videosize
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|videosize
comma
l_string|&quot;Image size: 0=128x96, 1=176x144, 2=352x288, 3=320x240, 4=352x240 (default=1)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|init_brightness
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|init_brightness
comma
l_string|&quot;Brightness preconfiguration: 0-255 (default=128)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|init_contrast
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|init_contrast
comma
l_string|&quot;Contrast preconfiguration: 0-255 (default=192)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|init_color
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|init_color
comma
l_string|&quot;Dolor preconfiguration: 0-255 (default=128)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|init_hue
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|init_hue
comma
l_string|&quot;Hue preconfiguration: 0-255 (default=128)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|hue_correction
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|hue_correction
comma
l_string|&quot;YUV colorspace regulation: 0-255 (default=128)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|init_model2_rg
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|init_model2_rg
comma
l_string|&quot;Model2 preconfiguration: 0-255 (default=112)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|init_model2_rg2
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|init_model2_rg2
comma
l_string|&quot;Model2 preconfiguration: 0-255 (default=47)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|init_model2_sat
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|init_model2_sat
comma
l_string|&quot;Model2 preconfiguration: 0-255 (default=52)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|init_model2_yb
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|init_model2_yb
comma
l_string|&quot;Model2 preconfiguration: 0-255 (default=160)&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
(paren
l_string|&quot;module author&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
(paren
l_string|&quot;IBM/Xirlink C-it USB Camera Driver for Linux (c) 2000&quot;
)paren
suffix:semicolon
multiline_comment|/* Still mysterious i2c commands */
DECL|variable|unknown_88
r_static
r_const
r_int
r_int
id|unknown_88
op_assign
l_int|0x0088
suffix:semicolon
DECL|variable|unknown_89
r_static
r_const
r_int
r_int
id|unknown_89
op_assign
l_int|0x0089
suffix:semicolon
DECL|variable|bright_3x
r_static
r_const
r_int
r_int
id|bright_3x
(braket
l_int|3
)braket
op_assign
(brace
l_int|0x0031
comma
l_int|0x0032
comma
l_int|0x0033
)brace
suffix:semicolon
DECL|variable|contrast_14
r_static
r_const
r_int
r_int
id|contrast_14
op_assign
l_int|0x0014
suffix:semicolon
DECL|variable|light_27
r_static
r_const
r_int
r_int
id|light_27
op_assign
l_int|0x0027
suffix:semicolon
DECL|variable|sharp_13
r_static
r_const
r_int
r_int
id|sharp_13
op_assign
l_int|0x0013
suffix:semicolon
multiline_comment|/* i2c commands for Model 2 cameras */
DECL|variable|mod2_brightness
r_static
r_const
r_int
r_int
id|mod2_brightness
op_assign
l_int|0x001a
suffix:semicolon
multiline_comment|/* $5b .. $ee; default=$5a */
DECL|variable|mod2_set_framerate
r_static
r_const
r_int
r_int
id|mod2_set_framerate
op_assign
l_int|0x001c
suffix:semicolon
multiline_comment|/* 0 (fast).. $1F (slow) */
DECL|variable|mod2_color_balance_rg2
r_static
r_const
r_int
r_int
id|mod2_color_balance_rg2
op_assign
l_int|0x001e
suffix:semicolon
multiline_comment|/* 0 (red) .. $7F (green) */
DECL|variable|mod2_saturation
r_static
r_const
r_int
r_int
id|mod2_saturation
op_assign
l_int|0x0020
suffix:semicolon
multiline_comment|/* 0 (b/w) - $7F (full color) */
DECL|variable|mod2_color_balance_yb
r_static
r_const
r_int
r_int
id|mod2_color_balance_yb
op_assign
l_int|0x0022
suffix:semicolon
multiline_comment|/* 0..$7F, $50 is about right */
DECL|variable|mod2_color_balance_rg
r_static
r_const
r_int
r_int
id|mod2_color_balance_rg
op_assign
l_int|0x0024
suffix:semicolon
multiline_comment|/* 0..$7F, $70 is about right */
DECL|variable|mod2_sensitivity
r_static
r_const
r_int
r_int
id|mod2_sensitivity
op_assign
l_int|0x0028
suffix:semicolon
multiline_comment|/* 0 (min) .. $1F (max) */
DECL|macro|MAX_IBMCAM
mdefine_line|#define MAX_IBMCAM&t;4
DECL|variable|cams
r_struct
id|usb_ibmcam
id|cams
(braket
id|MAX_IBMCAM
)braket
suffix:semicolon
multiline_comment|/*******************************/
multiline_comment|/* Memory management functions */
multiline_comment|/*******************************/
DECL|macro|MDEBUG
mdefine_line|#define MDEBUG(x)&t;do { } while(0)&t;&t;/* Debug memory management */
DECL|variable|ibmcam_driver
r_static
r_struct
id|usb_driver
id|ibmcam_driver
suffix:semicolon
r_static
r_void
id|usb_ibmcam_release
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
suffix:semicolon
multiline_comment|/* Given PGD from the address space&squot;s page table, return the kernel&n; * virtual mapping of the physical memory mapped at ADR.&n; */
DECL|function|uvirt_to_kva
r_static
r_inline
r_int
r_int
id|uvirt_to_kva
c_func
(paren
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|adr
)paren
(brace
r_int
r_int
id|ret
op_assign
l_int|0UL
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|ptep
comma
id|pte
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgd_none
c_func
(paren
op_star
id|pgd
)paren
)paren
(brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|adr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|adr
)paren
suffix:semicolon
id|pte
op_assign
op_star
id|ptep
suffix:semicolon
r_if
c_cond
(paren
id|pte_present
c_func
(paren
id|pte
)paren
)paren
(brace
id|ret
op_assign
(paren
r_int
r_int
)paren
id|page_address
c_func
(paren
id|pte_page
c_func
(paren
id|pte
)paren
)paren
suffix:semicolon
id|ret
op_or_assign
(paren
id|adr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
id|MDEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;uv2kva(%lx--&gt;%lx)&quot;
comma
id|adr
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|uvirt_to_bus
r_static
r_inline
r_int
r_int
id|uvirt_to_bus
c_func
(paren
r_int
r_int
id|adr
)paren
(brace
r_int
r_int
id|kva
comma
id|ret
suffix:semicolon
id|kva
op_assign
id|uvirt_to_kva
c_func
(paren
id|pgd_offset
c_func
(paren
id|current-&gt;mm
comma
id|adr
)paren
comma
id|adr
)paren
suffix:semicolon
id|ret
op_assign
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
id|kva
)paren
suffix:semicolon
id|MDEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;uv2b(%lx--&gt;%lx)&quot;
comma
id|adr
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|kvirt_to_bus
r_static
r_inline
r_int
r_int
id|kvirt_to_bus
c_func
(paren
r_int
r_int
id|adr
)paren
(brace
r_int
r_int
id|va
comma
id|kva
comma
id|ret
suffix:semicolon
id|va
op_assign
id|VMALLOC_VMADDR
c_func
(paren
id|adr
)paren
suffix:semicolon
id|kva
op_assign
id|uvirt_to_kva
c_func
(paren
id|pgd_offset_k
c_func
(paren
id|va
)paren
comma
id|va
)paren
suffix:semicolon
id|ret
op_assign
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
id|kva
)paren
suffix:semicolon
id|MDEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;kv2b(%lx--&gt;%lx)&quot;
comma
id|adr
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Here we want the physical address of the memory.&n; * This is used when initializing the contents of the&n; * area and marking the pages as reserved.&n; */
DECL|function|kvirt_to_pa
r_static
r_inline
r_int
r_int
id|kvirt_to_pa
c_func
(paren
r_int
r_int
id|adr
)paren
(brace
r_int
r_int
id|va
comma
id|kva
comma
id|ret
suffix:semicolon
id|va
op_assign
id|VMALLOC_VMADDR
c_func
(paren
id|adr
)paren
suffix:semicolon
id|kva
op_assign
id|uvirt_to_kva
c_func
(paren
id|pgd_offset_k
c_func
(paren
id|va
)paren
comma
id|va
)paren
suffix:semicolon
id|ret
op_assign
id|__pa
c_func
(paren
id|kva
)paren
suffix:semicolon
id|MDEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;kv2pa(%lx--&gt;%lx)&quot;
comma
id|adr
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|rvmalloc
r_static
r_void
op_star
id|rvmalloc
c_func
(paren
r_int
r_int
id|size
)paren
(brace
r_void
op_star
id|mem
suffix:semicolon
r_int
r_int
id|adr
comma
id|page
suffix:semicolon
multiline_comment|/* Round it off to PAGE_SIZE */
id|size
op_add_assign
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|size
op_and_assign
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|mem
op_assign
id|vmalloc_32
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mem
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|mem
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* Clear the ram out, no junk to the user */
id|adr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|kvirt_to_pa
c_func
(paren
id|adr
)paren
suffix:semicolon
id|mem_map_reserve
c_func
(paren
id|virt_to_page
c_func
(paren
id|__va
c_func
(paren
id|page
)paren
)paren
)paren
suffix:semicolon
id|adr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|PAGE_SIZE
)paren
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
r_else
id|size
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|mem
suffix:semicolon
)brace
DECL|function|rvfree
r_static
r_void
id|rvfree
c_func
(paren
r_void
op_star
id|mem
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|adr
comma
id|page
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mem
)paren
r_return
suffix:semicolon
id|size
op_add_assign
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|size
op_and_assign
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|adr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|kvirt_to_pa
c_func
(paren
id|adr
)paren
suffix:semicolon
id|mem_map_unreserve
c_func
(paren
id|virt_to_page
c_func
(paren
id|__va
c_func
(paren
id|page
)paren
)paren
)paren
suffix:semicolon
id|adr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|PAGE_SIZE
)paren
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
r_else
id|size
op_assign
l_int|0
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|mem
)paren
suffix:semicolon
)brace
macro_line|#if ENABLE_HEXDUMP
DECL|function|ibmcam_hexdump
r_static
r_void
id|ibmcam_hexdump
c_func
(paren
r_const
r_int
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_char
id|tmp
(braket
l_int|80
)braket
suffix:semicolon
r_int
id|i
comma
id|k
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|k
op_assign
l_int|0
suffix:semicolon
id|len
OG
l_int|0
suffix:semicolon
id|i
op_increment
comma
id|len
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|i
OG
l_int|0
op_logical_and
(paren
id|i
op_mod
l_int|16
op_eq
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
)brace
id|k
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|tmp
(braket
id|k
)braket
comma
l_string|&quot;%02x &quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * usb_ibmcam_overlaychar()&n; *&n; * History:&n; * 1/2/00   Created.&n; */
DECL|function|usb_ibmcam_overlaychar
r_void
id|usb_ibmcam_overlaychar
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_struct
id|ibmcam_frame
op_star
id|frame
comma
r_int
id|x
comma
r_int
id|y
comma
r_int
id|ch
)paren
(brace
r_static
r_const
r_int
r_int
id|digits
(braket
l_int|16
)braket
op_assign
(brace
l_int|0xF6DE
comma
multiline_comment|/* 0 */
l_int|0x2492
comma
multiline_comment|/* 1 */
l_int|0xE7CE
comma
multiline_comment|/* 2 */
l_int|0xE79E
comma
multiline_comment|/* 3 */
l_int|0xB792
comma
multiline_comment|/* 4 */
l_int|0xF39E
comma
multiline_comment|/* 5 */
l_int|0xF3DE
comma
multiline_comment|/* 6 */
l_int|0xF492
comma
multiline_comment|/* 7 */
l_int|0xF7DE
comma
multiline_comment|/* 8 */
l_int|0xF79E
comma
multiline_comment|/* 9 */
l_int|0x77DA
comma
multiline_comment|/* a */
l_int|0xD75C
comma
multiline_comment|/* b */
l_int|0xF24E
comma
multiline_comment|/* c */
l_int|0xD6DC
comma
multiline_comment|/* d */
l_int|0xF34E
comma
multiline_comment|/* e */
l_int|0xF348
multiline_comment|/* f */
)brace
suffix:semicolon
r_int
r_int
id|digit
suffix:semicolon
r_int
id|ix
comma
id|iy
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ibmcam
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|frame
op_eq
l_int|NULL
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;0&squot;
op_logical_and
id|ch
op_le
l_char|&squot;9&squot;
)paren
id|ch
op_sub_assign
l_char|&squot;0&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;A&squot;
op_logical_and
id|ch
op_le
l_char|&squot;F&squot;
)paren
id|ch
op_assign
l_int|10
op_plus
(paren
id|ch
op_minus
l_char|&squot;A&squot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;a&squot;
op_logical_and
id|ch
op_le
l_char|&squot;f&squot;
)paren
id|ch
op_assign
l_int|10
op_plus
(paren
id|ch
op_minus
l_char|&squot;a&squot;
)paren
suffix:semicolon
r_else
r_return
suffix:semicolon
id|digit
op_assign
id|digits
(braket
id|ch
)braket
suffix:semicolon
r_for
c_loop
(paren
id|iy
op_assign
l_int|0
suffix:semicolon
id|iy
OL
l_int|5
suffix:semicolon
id|iy
op_increment
)paren
(brace
r_for
c_loop
(paren
id|ix
op_assign
l_int|0
suffix:semicolon
id|ix
OL
l_int|3
suffix:semicolon
id|ix
op_increment
)paren
(brace
r_if
c_cond
(paren
id|digit
op_amp
l_int|0x8000
)paren
(brace
id|IBMCAM_PUTPIXEL
c_func
(paren
id|frame
comma
id|x
op_plus
id|ix
comma
id|y
op_plus
id|iy
comma
l_int|0xFF
comma
l_int|0xFF
comma
l_int|0xFF
)paren
suffix:semicolon
)brace
id|digit
op_assign
id|digit
op_lshift
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * usb_ibmcam_overlaystring()&n; *&n; * History:&n; * 1/2/00   Created.&n; */
DECL|function|usb_ibmcam_overlaystring
r_void
id|usb_ibmcam_overlaystring
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_struct
id|ibmcam_frame
op_star
id|frame
comma
r_int
id|x
comma
r_int
id|y
comma
r_const
r_char
op_star
id|str
)paren
(brace
r_while
c_loop
(paren
op_star
id|str
)paren
(brace
id|usb_ibmcam_overlaychar
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
op_star
id|str
)paren
suffix:semicolon
id|str
op_increment
suffix:semicolon
id|x
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* 3 pixels character + 1 space */
)brace
)brace
multiline_comment|/*&n; * usb_ibmcam_overlaystats()&n; *&n; * Overlays important debugging information.&n; *&n; * History:&n; * 1/2/00   Created.&n; */
DECL|function|usb_ibmcam_overlaystats
r_void
id|usb_ibmcam_overlaystats
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_struct
id|ibmcam_frame
op_star
id|frame
)paren
(brace
r_const
r_int
id|y_diff
op_assign
l_int|8
suffix:semicolon
r_char
id|tmp
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|x
op_assign
l_int|10
suffix:semicolon
r_int
id|y
op_assign
l_int|10
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8x&quot;
comma
id|ibmcam-&gt;frame_num
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|ibmcam-&gt;urb_count
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|ibmcam-&gt;urb_length
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|ibmcam-&gt;data_count
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|ibmcam-&gt;header_count
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|ibmcam-&gt;scratch_ovf_count
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|ibmcam-&gt;iso_skip_count
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|ibmcam-&gt;iso_err_count
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8x&quot;
comma
id|ibmcam-&gt;vpic.colour
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8x&quot;
comma
id|ibmcam-&gt;vpic.hue
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8x&quot;
comma
id|ibmcam-&gt;vpic.brightness
op_rshift
l_int|8
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8x&quot;
comma
id|ibmcam-&gt;vpic.contrast
op_rshift
l_int|12
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8d&quot;
comma
id|ibmcam-&gt;vpic.whiteness
op_rshift
l_int|8
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_testpattern()&n; *&n; * Procedure forms a test pattern (yellow grid on blue background).&n; *&n; * Parameters:&n; * fullframe:   if TRUE then entire frame is filled, otherwise the procedure&n; *&t;      continues from the current scanline.&n; * pmode&t;0: fill the frame with solid blue color (like on VCR or TV)&n; *&t;      1: Draw a colored grid&n; *&n; * History:&n; * 1/2/00   Created.&n; */
DECL|function|usb_ibmcam_testpattern
r_void
id|usb_ibmcam_testpattern
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
id|fullframe
comma
r_int
id|pmode
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usb_ibmcam_testpattern&quot;
suffix:semicolon
r_struct
id|ibmcam_frame
op_star
id|frame
suffix:semicolon
r_int
r_char
op_star
id|f
suffix:semicolon
r_int
id|num_cell
op_assign
l_int|0
suffix:semicolon
r_int
id|scan_length
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|num_pass
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: ibmcam == NULL&bslash;n&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ibmcam-&gt;curframe
OL
l_int|0
)paren
op_logical_or
(paren
id|ibmcam-&gt;curframe
op_ge
id|IBMCAM_NUMFRAMES
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: ibmcam-&gt;curframe=%d.&bslash;n&quot;
comma
id|proc
comma
id|ibmcam-&gt;curframe
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Grab the current frame */
id|frame
op_assign
op_amp
id|ibmcam-&gt;frame
(braket
id|ibmcam-&gt;curframe
)braket
suffix:semicolon
multiline_comment|/* Optionally start at the beginning */
r_if
c_cond
(paren
id|fullframe
)paren
(brace
id|frame-&gt;curline
op_assign
l_int|0
suffix:semicolon
id|frame-&gt;scanlength
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Form every scan line */
r_for
c_loop
(paren
suffix:semicolon
id|frame-&gt;curline
OL
id|imgheight
suffix:semicolon
id|frame-&gt;curline
op_increment
)paren
(brace
r_int
id|i
suffix:semicolon
id|f
op_assign
id|frame-&gt;data
op_plus
(paren
id|imgwidth
op_star
l_int|3
op_star
id|frame-&gt;curline
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|imgwidth
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|cb
op_assign
l_int|0x80
suffix:semicolon
r_int
r_char
id|cg
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|cr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pmode
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|frame-&gt;curline
op_mod
l_int|32
op_eq
l_int|0
)paren
id|cb
op_assign
l_int|0
comma
id|cg
op_assign
id|cr
op_assign
l_int|0xFF
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
op_mod
l_int|32
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|frame-&gt;curline
op_mod
l_int|32
op_eq
l_int|1
)paren
id|num_cell
op_increment
suffix:semicolon
id|cb
op_assign
l_int|0
comma
id|cg
op_assign
id|cr
op_assign
l_int|0xFF
suffix:semicolon
)brace
r_else
(brace
id|cb
op_assign
(paren
(paren
id|num_cell
op_star
l_int|7
)paren
op_plus
id|num_pass
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|cg
op_assign
(paren
(paren
id|num_cell
op_star
l_int|5
)paren
op_plus
id|num_pass
op_star
l_int|2
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|cr
op_assign
(paren
(paren
id|num_cell
op_star
l_int|3
)paren
op_plus
id|num_pass
op_star
l_int|3
)paren
op_amp
l_int|0xFF
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Just the blue screen */
)brace
op_star
id|f
op_increment
op_assign
id|cb
suffix:semicolon
op_star
id|f
op_increment
op_assign
id|cg
suffix:semicolon
op_star
id|f
op_increment
op_assign
id|cr
suffix:semicolon
id|scan_length
op_add_assign
l_int|3
suffix:semicolon
)brace
)brace
id|frame-&gt;grabstate
op_assign
id|FRAME_DONE
suffix:semicolon
id|frame-&gt;scanlength
op_add_assign
id|scan_length
suffix:semicolon
op_increment
id|num_pass
suffix:semicolon
multiline_comment|/* We do this unconditionally, regardless of FLAGS_OVERLAY_STATS */
id|usb_ibmcam_overlaystats
c_func
(paren
id|ibmcam
comma
id|frame
)paren
suffix:semicolon
)brace
DECL|function|ibmcam_model1_find_header
r_static
r_int
r_char
op_star
id|ibmcam_model1_find_header
c_func
(paren
r_int
r_char
id|hdr_sig
comma
r_int
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_while
c_loop
(paren
id|len
op_ge
l_int|4
)paren
(brace
r_if
c_cond
(paren
(paren
id|data
(braket
l_int|0
)braket
op_eq
l_int|0x00
)paren
op_logical_and
(paren
id|data
(braket
l_int|1
)braket
op_eq
l_int|0xFF
)paren
op_logical_and
(paren
id|data
(braket
l_int|2
)braket
op_eq
l_int|0x00
)paren
)paren
(brace
macro_line|#if 0
multiline_comment|/* This code helps to detect new frame markers */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Header sig: 00 FF 00 %02X&bslash;n&quot;
comma
id|data
(braket
l_int|3
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data
(braket
l_int|3
)braket
op_eq
id|hdr_sig
)paren
(brace
r_if
c_cond
(paren
id|debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Header found.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|data
op_plus
l_int|4
suffix:semicolon
)brace
)brace
op_increment
id|data
suffix:semicolon
op_decrement
id|len
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|ibmcam_model2_find_header
r_static
r_int
r_char
op_star
id|ibmcam_model2_find_header
c_func
(paren
r_int
r_char
id|hdr_sig
comma
r_int
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_int
id|marker_len
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|videosize
)paren
(brace
r_case
id|VIDEOSIZE_176x144
suffix:colon
id|marker_len
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|marker_len
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|len
op_ge
id|marker_len
)paren
(brace
r_if
c_cond
(paren
(paren
id|data
(braket
l_int|0
)braket
op_eq
l_int|0x00
)paren
op_logical_and
(paren
id|data
(braket
l_int|1
)braket
op_eq
l_int|0xFF
)paren
)paren
(brace
macro_line|#if 0
multiline_comment|/* This code helps to detect new frame markers */
r_static
r_int
id|pass
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pass
op_increment
op_eq
l_int|0
)paren
id|ibmcam_hexdump
c_func
(paren
id|data
comma
(paren
id|len
OG
l_int|16
)paren
ques
c_cond
l_int|16
suffix:colon
id|len
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Header found.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|data
op_plus
id|marker_len
suffix:semicolon
)brace
op_increment
id|data
suffix:semicolon
op_decrement
id|len
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* How much data is left in the scratch buf? */
DECL|macro|scratch_left
mdefine_line|#define scratch_left(x)&t;(ibmcam-&gt;scratchlen - (int)((char *)x - (char *)ibmcam-&gt;scratch))
multiline_comment|/* Grab the remaining */
DECL|function|usb_ibmcam_align_scratch
r_static
r_void
id|usb_ibmcam_align_scratch
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
r_char
op_star
id|data
)paren
(brace
r_int
r_int
id|left
suffix:semicolon
id|left
op_assign
id|scratch_left
c_func
(paren
id|data
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|ibmcam-&gt;scratch
comma
id|data
comma
id|left
)paren
suffix:semicolon
id|ibmcam-&gt;scratchlen
op_assign
id|left
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_find_header()&n; *&n; * Locate one of supported header markers in the scratch buffer.&n; * Once found, remove all preceding bytes AND the marker (4 bytes)&n; * from the scratch buffer. Whatever follows must be video lines.&n; *&n; * History:&n; * 1/21/00  Created.&n; */
DECL|function|usb_ibmcam_find_header
r_static
id|scan_state_t
id|usb_ibmcam_find_header
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_struct
id|ibmcam_frame
op_star
id|frame
suffix:semicolon
r_int
r_char
op_star
id|data
comma
op_star
id|tmp
suffix:semicolon
id|data
op_assign
id|ibmcam-&gt;scratch
suffix:semicolon
id|frame
op_assign
op_amp
id|ibmcam-&gt;frame
(braket
id|ibmcam-&gt;curframe
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;camera_model
op_eq
id|IBMCAM_MODEL_1
)paren
id|tmp
op_assign
id|ibmcam_model1_find_header
c_func
(paren
id|frame-&gt;hdr_sig
comma
id|data
comma
id|scratch_left
c_func
(paren
id|data
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ibmcam-&gt;camera_model
op_eq
id|IBMCAM_MODEL_2
)paren
id|tmp
op_assign
id|ibmcam_model2_find_header
c_func
(paren
id|frame-&gt;hdr_sig
comma
id|data
comma
id|scratch_left
c_func
(paren
id|data
)paren
)paren
suffix:semicolon
r_else
id|tmp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* No header - entire scratch buffer is useless! */
r_if
c_cond
(paren
id|debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Skipping frame, no header&bslash;n&quot;
)paren
suffix:semicolon
id|ibmcam-&gt;scratchlen
op_assign
l_int|0
suffix:semicolon
r_return
id|scan_EndParse
suffix:semicolon
)brace
multiline_comment|/* Header found */
id|data
op_assign
id|tmp
suffix:semicolon
id|ibmcam-&gt;has_hdr
op_assign
l_int|1
suffix:semicolon
id|ibmcam-&gt;header_count
op_increment
suffix:semicolon
id|frame-&gt;scanstate
op_assign
id|STATE_LINES
suffix:semicolon
id|frame-&gt;curline
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|FLAGS_FORCE_TESTPATTERN
)paren
(brace
id|usb_ibmcam_testpattern
c_func
(paren
id|ibmcam
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
r_return
id|scan_NextFrame
suffix:semicolon
)brace
id|usb_ibmcam_align_scratch
c_func
(paren
id|ibmcam
comma
id|data
)paren
suffix:semicolon
r_return
id|scan_Continue
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_parse_lines()&n; *&n; * Parse one line (TODO: more than one!) from the scratch buffer, put&n; * decoded RGB value into the current frame buffer and add the written&n; * number of bytes (RGB) to the *pcopylen.&n; *&n; * History:&n; * 1/21/00  Created.&n; */
DECL|function|usb_ibmcam_parse_lines
r_static
id|scan_state_t
id|usb_ibmcam_parse_lines
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
op_star
id|pcopylen
)paren
(brace
r_struct
id|ibmcam_frame
op_star
id|frame
suffix:semicolon
r_int
r_char
op_star
id|data
comma
op_star
id|f
comma
op_star
id|chromaLine
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_const
r_int
id|v4l_linesize
op_assign
id|imgwidth
op_star
id|V4L_BYTES_PER_PIXEL
suffix:semicolon
multiline_comment|/* V4L line offset */
r_const
r_int
id|hue_corr
op_assign
(paren
id|ibmcam-&gt;vpic.hue
op_minus
l_int|0x8000
)paren
op_rshift
l_int|10
suffix:semicolon
multiline_comment|/* -32..+31 */
r_const
r_int
id|hue2_corr
op_assign
(paren
id|hue_correction
op_minus
l_int|128
)paren
op_div
l_int|4
suffix:semicolon
multiline_comment|/* -32..+31 */
r_const
r_int
id|ccm
op_assign
l_int|128
suffix:semicolon
multiline_comment|/* Color correction median - see below */
r_int
id|y
comma
id|u
comma
id|v
comma
id|i
comma
id|frame_done
op_assign
l_int|0
comma
id|mono_plane
comma
id|color_corr
suffix:semicolon
id|color_corr
op_assign
(paren
id|ibmcam-&gt;vpic.colour
op_minus
l_int|0x8000
)paren
op_rshift
l_int|8
suffix:semicolon
multiline_comment|/* -128..+127 = -ccm..+(ccm-1)*/
id|RESTRICT_TO_RANGE
c_func
(paren
id|color_corr
comma
op_minus
id|ccm
comma
id|ccm
op_plus
l_int|1
)paren
suffix:semicolon
id|data
op_assign
id|ibmcam-&gt;scratch
suffix:semicolon
id|frame
op_assign
op_amp
id|ibmcam-&gt;frame
(braket
id|ibmcam-&gt;curframe
)braket
suffix:semicolon
id|len
op_assign
id|frame-&gt;frmwidth
op_star
l_int|3
suffix:semicolon
multiline_comment|/* 1 line of mono + 1 line of color */
multiline_comment|/*printk(KERN_DEBUG &quot;len=%d. left=%d.&bslash;n&quot;,len,scratch_left(data));*/
id|mono_plane
op_assign
(paren
(paren
id|frame-&gt;curline
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Lines are organized this way (or are they?)&n;&t; *&n;&t; * I420:&n;&t; * ~~~~&n;&t; * ___________________________________&n;&t; * |-----Y-----|---UVUVUV...UVUV-----| &bslash;&n;&t; * |-----------+---------------------|  &bslash;&n;&t; * |&lt;-- 176 --&gt;|&lt;------ 176*2 ------&gt;|  Total 72. pairs of lines&n;&t; * |...&t;   ...&t;     ...|  /&n;&t; * |___________|_____________________| /&n;&t; *  - odd line- ------- even line ---&n;&t; *&n;&t; * another format:&n;&t; * ~~~~~~~~~~~~~~&n;&t; * ___________________________________&n;&t; * |-----Y-----|---UVUVUV...UVUV-----| &bslash;&n;&t; * |-----------+---------------------|  &bslash;&n;&t; * |&lt;-- 352 --&gt;|&lt;------ 352*2 ------&gt;|  Total 144. pairs of lines&n;&t; * |...&t;   ...&t;     ...|  /&n;&t; * |___________|_____________________| /&n;&t; *  - odd line- ------- even line ---&n;&t; */
multiline_comment|/* Make sure there&squot;s enough data for the entire line */
r_if
c_cond
(paren
id|scratch_left
c_func
(paren
id|data
)paren
OL
(paren
id|len
op_plus
l_int|1024
)paren
)paren
(brace
multiline_comment|/*printk(KERN_DEBUG &quot;out of data, need %u.&bslash;n&quot;, len);*/
r_return
id|scan_Out
suffix:semicolon
)brace
macro_line|#if 0
(brace
multiline_comment|/* This code prints beginning of the source frame */
r_static
r_int
id|pass
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pass
op_increment
op_mod
l_int|3000
)paren
op_eq
l_int|0
)paren
id|ibmcam_hexdump
c_func
(paren
id|data
comma
l_int|16
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if 0
r_if
c_cond
(paren
id|frame-&gt;curline
op_eq
l_int|10
op_logical_or
id|frame-&gt;curline
op_eq
l_int|11
)paren
(brace
multiline_comment|/* This code prints beginning of 10th (mono), 11th (chroma) line */
r_static
r_int
id|pass
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pass
op_mod
l_int|100
)paren
op_eq
l_int|0
)paren
id|ibmcam_hexdump
c_func
(paren
id|data
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frame-&gt;curline
op_eq
l_int|11
)paren
id|pass
op_increment
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Make sure that our writing into output buffer&n;&t; * will not exceed the buffer. Mind that we may write&n;&t; * not into current output scanline but in several after&n;&t; * it as well (if we enlarge image vertically.)&n;&t; */
r_if
c_cond
(paren
(paren
id|frame-&gt;curline
op_plus
l_int|1
)paren
op_ge
id|V4L_FRAME_HEIGHT
)paren
r_return
id|scan_NextFrame
suffix:semicolon
multiline_comment|/*&n;&t; * Now we are sure that entire line (representing all &squot;frame-&gt;frmwidth&squot;&n;&t; * pixels from the camera) is available in the scratch buffer. We&n;&t; * start copying the line left-aligned to the V4L buffer (which&n;&t; * might be larger - not smaller, hopefully). If the camera&n;&t; * line is shorter then we should pad the V4L buffer with something&n;&t; * (black in this case) to complete the line.&n;&t; */
id|f
op_assign
id|frame-&gt;data
op_plus
(paren
id|v4l_linesize
op_star
id|frame-&gt;curline
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * chromaLine points to 1st pixel of the line with chrominance.&n;&t; * If current line is monochrome then chromaLine points to next&n;&t; * line after monochrome one. If current line has chrominance&n;&t; * then chromaLine points to this very line. Such method allows&n;&t; * to access chrominance data uniformly.&n;&t; *&n;&t; * To obtain chrominance data from the &squot;chromaLine&squot; use this:&n;&t; *   v = chromaLine[0]; // 0-1:[0], 2-3:[4], 4-5:[8]...&n;&t; *   u = chromaLine[2]; // 0-1:[2], 2-3:[6], 4-5:[10]...&n;&t; *&n;&t; * Indices must be calculated this way:&n;&t; * v_index = (i &gt;&gt; 1) &lt;&lt; 2;&n;&t; * u_index = (i &gt;&gt; 1) &lt;&lt; 2 + 2;&n;&t; *&n;&t; * where &squot;i&squot; is the column number [0..frame-&gt;frmwidth-1]&n;&t; */
id|chromaLine
op_assign
id|data
suffix:semicolon
r_if
c_cond
(paren
id|mono_plane
)paren
id|chromaLine
op_add_assign
id|frame-&gt;frmwidth
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|frame-&gt;frmwidth
suffix:semicolon
id|i
op_increment
comma
id|data
op_add_assign
(paren
id|mono_plane
ques
c_cond
l_int|1
suffix:colon
l_int|2
)paren
)paren
(brace
r_int
r_char
id|rv
comma
id|gv
comma
id|bv
suffix:semicolon
multiline_comment|/* RGB components */
multiline_comment|/*&n;&t;&t; * Search for potential Start-Of-Frame marker. It should&n;&t;&t; * not be here, of course, but if your formats don&squot;t match&n;&t;&t; * you might exceed the frame. We must match the marker to&n;&t;&t; * each byte of multi-byte data element if it is multi-byte.&n;&t;&t; */
macro_line|#if 1
r_if
c_cond
(paren
(paren
id|ibmcam-&gt;camera_model
op_eq
id|IBMCAM_MODEL_1
)paren
op_logical_and
(paren
id|scratch_left
c_func
(paren
id|data
)paren
op_ge
(paren
l_int|4
op_plus
l_int|2
)paren
)paren
)paren
(brace
r_int
r_char
op_star
id|dp
suffix:semicolon
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
comma
id|dp
op_assign
id|data
suffix:semicolon
id|j
OL
l_int|2
suffix:semicolon
id|j
op_increment
comma
id|dp
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|dp
(braket
l_int|0
)braket
op_eq
l_int|0x00
)paren
op_logical_and
(paren
id|dp
(braket
l_int|1
)braket
op_eq
l_int|0xFF
)paren
op_logical_and
(paren
id|dp
(braket
l_int|2
)braket
op_eq
l_int|0x00
)paren
op_logical_and
(paren
id|dp
(braket
l_int|3
)braket
op_eq
id|frame-&gt;hdr_sig
)paren
)paren
(brace
id|ibmcam-&gt;has_hdr
op_assign
l_int|2
suffix:semicolon
id|frame_done
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/* Check for various visual debugging hints (colorized pixels) */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|FLAGS_DISPLAY_HINTS
)paren
op_logical_and
(paren
id|ibmcam-&gt;has_hdr
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This is bad and should not happen. This means that&n;&t;&t;&t; * we somehow overshoot the line and encountered new&n;&t;&t;&t; * frame! Obviously our camera/V4L frame size is out&n;&t;&t;&t; * of whack. This cyan dot will help you to figure&n;&t;&t;&t; * out where exactly the new frame arrived.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ibmcam-&gt;has_hdr
op_eq
l_int|1
)paren
(brace
id|bv
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Yellow marker */
id|gv
op_assign
l_int|0xFF
suffix:semicolon
id|rv
op_assign
l_int|0xFF
suffix:semicolon
)brace
r_else
(brace
id|bv
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* Cyan marker */
id|gv
op_assign
l_int|0xFF
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
)brace
id|ibmcam-&gt;has_hdr
op_assign
l_int|0
suffix:semicolon
r_goto
id|make_pixel
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mono_plane
op_logical_or
id|frame-&gt;order_yc
)paren
id|y
op_assign
id|data
(braket
l_int|0
)braket
suffix:semicolon
r_else
id|y
op_assign
id|data
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|FLAGS_MONOCHROME
)paren
multiline_comment|/* Use monochrome for debugging */
id|rv
op_assign
id|gv
op_assign
id|bv
op_assign
id|y
suffix:semicolon
r_else
(brace
r_int
id|off_0
comma
id|off_2
suffix:semicolon
id|off_0
op_assign
(paren
id|i
op_rshift
l_int|1
)paren
op_lshift
l_int|2
suffix:semicolon
id|off_2
op_assign
id|off_0
op_plus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|frame-&gt;order_yc
)paren
(brace
id|off_0
op_increment
suffix:semicolon
id|off_2
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|frame-&gt;order_uv
)paren
(brace
id|off_0
op_add_assign
l_int|2
suffix:semicolon
id|off_2
op_sub_assign
l_int|2
suffix:semicolon
)brace
id|u
op_assign
id|chromaLine
(braket
id|off_0
)braket
op_plus
id|hue_corr
suffix:semicolon
id|v
op_assign
id|chromaLine
(braket
id|off_2
)braket
op_plus
id|hue2_corr
suffix:semicolon
multiline_comment|/* Apply color correction */
r_if
c_cond
(paren
id|color_corr
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Magnify up to 2 times, reduce down to zero saturation */
id|u
op_assign
l_int|128
op_plus
(paren
(paren
id|ccm
op_plus
id|color_corr
)paren
op_star
(paren
id|u
op_minus
l_int|128
)paren
)paren
op_div
id|ccm
suffix:semicolon
id|v
op_assign
l_int|128
op_plus
(paren
(paren
id|ccm
op_plus
id|color_corr
)paren
op_star
(paren
id|v
op_minus
l_int|128
)paren
)paren
op_div
id|ccm
suffix:semicolon
)brace
id|YUV_TO_RGB_BY_THE_BOOK
c_func
(paren
id|y
comma
id|u
comma
id|v
comma
id|rv
comma
id|gv
comma
id|bv
)paren
suffix:semicolon
)brace
id|make_pixel
suffix:colon
multiline_comment|/*&n;&t;&t; * The purpose of creating the pixel here, in one,&n;&t;&t; * dedicated place is that we may need to make the&n;&t;&t; * pixel wider and taller than it actually is. This&n;&t;&t; * may be used if camera generates small frames for&n;&t;&t; * sake of frame rate (or any other reason.)&n;&t;&t; *&n;&t;&t; * The output data consists of B, G, R bytes&n;&t;&t; * (in this order).&n;&t;&t; */
macro_line|#if USES_IBMCAM_PUTPIXEL
id|IBMCAM_PUTPIXEL
c_func
(paren
id|frame
comma
id|i
comma
id|frame-&gt;curline
comma
id|rv
comma
id|gv
comma
id|bv
)paren
suffix:semicolon
macro_line|#else
op_star
id|f
op_increment
op_assign
id|bv
suffix:semicolon
op_star
id|f
op_increment
op_assign
id|gv
suffix:semicolon
op_star
id|f
op_increment
op_assign
id|rv
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Typically we do not decide within a legitimate frame&n;&t;&t; * that we want to end the frame. However debugging code&n;&t;&t; * may detect marker of new frame within the data. Then&n;&t;&t; * this condition activates. The &squot;data&squot; pointer is already&n;&t;&t; * pointing at the new marker, so we&squot;d better leave it as is.&n;&t;&t; */
r_if
c_cond
(paren
id|frame_done
)paren
r_break
suffix:semicolon
multiline_comment|/* End scanning of lines */
)brace
multiline_comment|/*&n;&t; * Account for number of bytes that we wrote into output V4L frame.&n;&t; * We do it here, after we are done with the scanline, because we&n;&t; * may fill more than one output scanline if we do vertical&n;&t; * enlargement.&n;&t; */
id|frame-&gt;curline
op_increment
suffix:semicolon
op_star
id|pcopylen
op_add_assign
id|v4l_linesize
suffix:semicolon
id|usb_ibmcam_align_scratch
c_func
(paren
id|ibmcam
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frame_done
op_logical_or
(paren
id|frame-&gt;curline
op_ge
id|frame-&gt;frmheight
)paren
)paren
r_return
id|scan_NextFrame
suffix:semicolon
r_else
r_return
id|scan_Continue
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_model2_parse_lines()&n; *&n; * This procedure deals with a weird RGB format that is produced by IBM&n; * camera model 2 in modes 320x240 and above; &squot;x&squot; below is 159 or 175,&n; * depending on horizontal size of the picture:&n; *&n; * &lt;--- 160 or 176 pairs of RA,RB bytes -----&gt;&n; * *-----------------------------------------* &bslash;&n; * | RA0 | RB0 | RA1 | RB1 | ... | RAx | RBx |  &bslash;&n; * |-----+-----+-----+-----+ ... +-----+-----|   *- This is pair of horizontal lines,&n; * | B0  | G0  | B1  | G1  | ... | Bx  | Gx  |  /   total 240 or 288 lines (120 or 144&n; * |=====+=====+=====+=====+ ... +=====+=====| /    such pairs).&n; *&n; * Each group of FOUR bytes (RAi, RBi, Bi, Gi) where i=0..frame_width/2-1&n; * defines ONE pixel. Therefore this format yields 176x144 &quot;decoded&quot;&n; * resolution at best. I do not know why camera sends such format - the&n; * previous model just used I420 and everyone was happy.&n; *&n; * I do not know what is the difference between RAi and RBi bytes. Both&n; * seemingly represent R component, but slightly vary in value (so that&n; * the picture looks a bit colored if one or another is used). I use&n; * them both as R component in attempt to at least partially recover the&n; * lost resolution.&n; */
DECL|function|usb_ibmcam_model2_parse_lines
r_static
id|scan_state_t
id|usb_ibmcam_model2_parse_lines
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
op_star
id|pcopylen
)paren
(brace
r_struct
id|ibmcam_frame
op_star
id|frame
suffix:semicolon
r_int
r_char
op_star
id|data
comma
op_star
id|f
comma
op_star
id|la
comma
op_star
id|lb
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_const
r_int
id|v4l_linesize
op_assign
id|imgwidth
op_star
id|V4L_BYTES_PER_PIXEL
suffix:semicolon
multiline_comment|/* V4L line offset */
r_int
id|i
comma
id|j
comma
id|frame_done
op_assign
l_int|0
comma
id|color_corr
suffix:semicolon
id|color_corr
op_assign
(paren
id|ibmcam-&gt;vpic.colour
)paren
op_rshift
l_int|8
suffix:semicolon
multiline_comment|/* 0..+255 */
id|data
op_assign
id|ibmcam-&gt;scratch
suffix:semicolon
id|frame
op_assign
op_amp
id|ibmcam-&gt;frame
(braket
id|ibmcam-&gt;curframe
)braket
suffix:semicolon
multiline_comment|/* Here we deal with pairs of horizontal lines */
id|len
op_assign
id|frame-&gt;frmwidth
op_star
l_int|2
suffix:semicolon
multiline_comment|/* 2 lines */
multiline_comment|/*printk(KERN_DEBUG &quot;len=%d. left=%d.&bslash;n&quot;,len,scratch_left(data));*/
multiline_comment|/* Make sure there&squot;s enough data for the entire line */
r_if
c_cond
(paren
id|scratch_left
c_func
(paren
id|data
)paren
OL
(paren
id|len
op_plus
l_int|32
)paren
)paren
(brace
multiline_comment|/*printk(KERN_DEBUG &quot;out of data, need %u.&bslash;n&quot;, len);*/
r_return
id|scan_Out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Make sure that our writing into output buffer&n;&t; * will not exceed the buffer. Mind that we may write&n;&t; * not into current output scanline but in several after&n;&t; * it as well (if we enlarge image vertically.)&n;&t; */
r_if
c_cond
(paren
(paren
id|frame-&gt;curline
op_plus
l_int|1
)paren
op_ge
id|V4L_FRAME_HEIGHT
)paren
r_return
id|scan_NextFrame
suffix:semicolon
r_if
c_cond
(paren
(paren
id|frame-&gt;curline
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|la
op_assign
id|data
suffix:semicolon
id|lb
op_assign
id|data
op_plus
id|frame-&gt;frmwidth
suffix:semicolon
)brace
r_else
(brace
id|la
op_assign
id|data
op_plus
id|frame-&gt;frmwidth
suffix:semicolon
id|lb
op_assign
id|data
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now we are sure that entire line (representing all &squot;frame-&gt;frmwidth&squot;&n;&t; * pixels from the camera) is available in the scratch buffer. We&n;&t; * start copying the line left-aligned to the V4L buffer (which&n;&t; * might be larger - not smaller, hopefully). If the camera&n;&t; * line is shorter then we should pad the V4L buffer with something&n;&t; * (black in this case) to complete the line.&n;&t; */
id|f
op_assign
id|frame-&gt;data
op_plus
(paren
id|v4l_linesize
op_star
id|frame-&gt;curline
)paren
suffix:semicolon
multiline_comment|/* Fill the 2-line strip */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|frame-&gt;frmwidth
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|y
comma
id|rv
comma
id|gv
comma
id|bv
suffix:semicolon
multiline_comment|/* RGB components */
id|j
op_assign
id|i
op_amp
(paren
op_complement
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Check for various visual debugging hints (colorized pixels) */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|FLAGS_DISPLAY_HINTS
)paren
op_logical_and
(paren
id|ibmcam-&gt;has_hdr
)paren
)paren
(brace
r_if
c_cond
(paren
id|ibmcam-&gt;has_hdr
op_eq
l_int|1
)paren
(brace
id|bv
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Yellow marker */
id|gv
op_assign
l_int|0xFF
suffix:semicolon
id|rv
op_assign
l_int|0xFF
suffix:semicolon
)brace
r_else
(brace
id|bv
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* Cyan marker */
id|gv
op_assign
l_int|0xFF
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
)brace
id|ibmcam-&gt;has_hdr
op_assign
l_int|0
suffix:semicolon
r_goto
id|make_pixel
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Here I use RA and RB components, one per physical pixel.&n;&t;&t; * This causes fine vertical grid on the picture but may improve&n;&t;&t; * horizontal resolution. If you prefer replicating, use this:&n;&t;&t; *   rv = la[j + 0];   ... or ... rv = la[j + 1];&n;&t;&t; * then the pixel will be replicated.&n;&t;&t; */
id|rv
op_assign
id|la
(braket
id|i
)braket
suffix:semicolon
id|gv
op_assign
id|lb
(braket
id|j
op_plus
l_int|1
)braket
suffix:semicolon
id|bv
op_assign
id|lb
(braket
id|j
op_plus
l_int|0
)braket
suffix:semicolon
id|y
op_assign
(paren
id|rv
op_plus
id|gv
op_plus
id|bv
)paren
op_div
l_int|3
suffix:semicolon
multiline_comment|/* Brightness (badly calculated) */
r_if
c_cond
(paren
id|flags
op_amp
id|FLAGS_MONOCHROME
)paren
multiline_comment|/* Use monochrome for debugging */
id|rv
op_assign
id|gv
op_assign
id|bv
op_assign
id|y
suffix:semicolon
r_else
r_if
c_cond
(paren
id|color_corr
op_ne
l_int|128
)paren
(brace
multiline_comment|/* Calculate difference between color and brightness */
id|rv
op_sub_assign
id|y
suffix:semicolon
id|gv
op_sub_assign
id|y
suffix:semicolon
id|bv
op_sub_assign
id|y
suffix:semicolon
multiline_comment|/* Scale differences */
id|rv
op_assign
(paren
id|rv
op_star
id|color_corr
)paren
op_div
l_int|128
suffix:semicolon
id|gv
op_assign
(paren
id|gv
op_star
id|color_corr
)paren
op_div
l_int|128
suffix:semicolon
id|bv
op_assign
(paren
id|bv
op_star
id|color_corr
)paren
op_div
l_int|128
suffix:semicolon
multiline_comment|/* Reapply brightness */
id|rv
op_add_assign
id|y
suffix:semicolon
id|gv
op_add_assign
id|y
suffix:semicolon
id|bv
op_add_assign
id|y
suffix:semicolon
multiline_comment|/* Watch for overflows */
id|RESTRICT_TO_RANGE
c_func
(paren
id|rv
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|gv
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|bv
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
)brace
id|make_pixel
suffix:colon
id|IBMCAM_PUTPIXEL
c_func
(paren
id|frame
comma
id|i
comma
id|frame-&gt;curline
comma
id|rv
comma
id|gv
comma
id|bv
)paren
suffix:semicolon
id|IBMCAM_PUTPIXEL
c_func
(paren
id|frame
comma
id|i
comma
id|frame-&gt;curline
op_plus
l_int|1
comma
id|rv
comma
id|gv
comma
id|bv
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Account for number of bytes that we wrote into output V4L frame.&n;&t; * We do it here, after we are done with the scanline, because we&n;&t; * may fill more than one output scanline if we do vertical&n;&t; * enlargement.&n;&t; */
id|frame-&gt;curline
op_add_assign
l_int|2
suffix:semicolon
op_star
id|pcopylen
op_add_assign
id|v4l_linesize
op_star
l_int|2
suffix:semicolon
id|data
op_add_assign
id|frame-&gt;frmwidth
op_star
l_int|2
suffix:semicolon
id|usb_ibmcam_align_scratch
c_func
(paren
id|ibmcam
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frame_done
op_logical_or
(paren
id|frame-&gt;curline
op_ge
id|frame-&gt;frmheight
)paren
)paren
r_return
id|scan_NextFrame
suffix:semicolon
r_else
r_return
id|scan_Continue
suffix:semicolon
)brace
multiline_comment|/*&n; * ibmcam_parse_data()&n; *&n; * Generic routine to parse the scratch buffer. It employs either&n; * usb_ibmcam_find_header() or usb_ibmcam_parse_lines() to do most&n; * of work.&n; *&n; * History:&n; * 1/21/00  Created.&n; */
DECL|function|ibmcam_parse_data
r_static
r_void
id|ibmcam_parse_data
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_struct
id|ibmcam_frame
op_star
id|frame
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|ibmcam-&gt;scratch
suffix:semicolon
id|scan_state_t
id|newstate
suffix:semicolon
r_int
id|copylen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Grab the current frame and the previous frame */
id|frame
op_assign
op_amp
id|ibmcam-&gt;frame
(braket
id|ibmcam-&gt;curframe
)braket
suffix:semicolon
multiline_comment|/* printk(KERN_DEBUG &quot;parsing %u.&bslash;n&quot;, ibmcam-&gt;scratchlen); */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|newstate
op_assign
id|scan_Out
suffix:semicolon
r_if
c_cond
(paren
id|scratch_left
c_func
(paren
id|data
)paren
)paren
(brace
r_if
c_cond
(paren
id|frame-&gt;scanstate
op_eq
id|STATE_SCANNING
)paren
id|newstate
op_assign
id|usb_ibmcam_find_header
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|frame-&gt;scanstate
op_eq
id|STATE_LINES
)paren
(brace
r_if
c_cond
(paren
(paren
id|ibmcam-&gt;camera_model
op_eq
id|IBMCAM_MODEL_2
)paren
op_logical_and
(paren
id|videosize
op_ge
id|VIDEOSIZE_352x288
)paren
)paren
(brace
id|newstate
op_assign
id|usb_ibmcam_model2_parse_lines
c_func
(paren
id|ibmcam
comma
op_amp
id|copylen
)paren
suffix:semicolon
)brace
r_else
(brace
id|newstate
op_assign
id|usb_ibmcam_parse_lines
c_func
(paren
id|ibmcam
comma
op_amp
id|copylen
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|newstate
op_eq
id|scan_Continue
)paren
r_continue
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|newstate
op_eq
id|scan_NextFrame
)paren
op_logical_or
(paren
id|newstate
op_eq
id|scan_Out
)paren
)paren
r_break
suffix:semicolon
r_else
r_return
suffix:semicolon
multiline_comment|/* scan_EndParse */
)brace
r_if
c_cond
(paren
id|newstate
op_eq
id|scan_NextFrame
)paren
(brace
id|frame-&gt;grabstate
op_assign
id|FRAME_DONE
suffix:semicolon
id|ibmcam-&gt;curframe
op_assign
op_minus
l_int|1
suffix:semicolon
id|ibmcam-&gt;frame_num
op_increment
suffix:semicolon
multiline_comment|/* Optionally display statistics on the screen */
r_if
c_cond
(paren
id|flags
op_amp
id|FLAGS_OVERLAY_STATS
)paren
id|usb_ibmcam_overlaystats
c_func
(paren
id|ibmcam
comma
id|frame
)paren
suffix:semicolon
multiline_comment|/* This will cause the process to request another frame. */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|frame-&gt;wq
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|frame-&gt;wq
)paren
suffix:semicolon
)brace
multiline_comment|/* Update the frame&squot;s uncompressed length. */
id|frame-&gt;scanlength
op_add_assign
id|copylen
suffix:semicolon
)brace
multiline_comment|/*&n; * Make all of the blocks of data contiguous&n; */
DECL|function|ibmcam_compress_isochronous
r_static
r_int
id|ibmcam_compress_isochronous
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
id|urb_t
op_star
id|urb
)paren
(brace
r_int
r_char
op_star
id|cdata
comma
op_star
id|data
comma
op_star
id|data0
suffix:semicolon
r_int
id|i
comma
id|totlen
op_assign
l_int|0
suffix:semicolon
id|data
op_assign
id|data0
op_assign
id|ibmcam-&gt;scratch
op_plus
id|ibmcam-&gt;scratchlen
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|n
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
suffix:semicolon
r_int
id|st
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
suffix:semicolon
id|cdata
op_assign
id|urb-&gt;transfer_buffer
op_plus
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
suffix:semicolon
multiline_comment|/* Detect and ignore errored packets */
r_if
c_cond
(paren
id|st
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam data error: [%d] len=%d, status=%X&bslash;n&quot;
comma
id|i
comma
id|n
comma
id|st
)paren
suffix:semicolon
)brace
id|ibmcam-&gt;iso_err_count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Detect and ignore empty packets */
r_if
c_cond
(paren
id|n
op_le
l_int|0
)paren
(brace
id|ibmcam-&gt;iso_skip_count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If camera continues to feed us with data but there is no&n;&t;&t; * consumption (if, for example, V4L client fell asleep) we&n;&t;&t; * may overflow the buffer. We have to move old data over to&n;&t;&t; * free room for new data. This is bad for old data. If we&n;&t;&t; * just drop new data then it&squot;s bad for new data... choose&n;&t;&t; * your favorite evil here.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ibmcam-&gt;scratchlen
op_plus
id|n
)paren
OG
id|scratchbufsize
)paren
(brace
macro_line|#if 0
id|ibmcam-&gt;scratch_ovf_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_ge
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam: scratch buf overflow! &quot;
l_string|&quot;scr_len: %d, n: %d&bslash;n&quot;
comma
id|ibmcam-&gt;scratchlen
comma
id|n
)paren
suffix:semicolon
r_return
id|totlen
suffix:semicolon
macro_line|#else
r_int
id|mv
suffix:semicolon
id|ibmcam-&gt;scratch_ovf_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_ge
l_int|3
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam: scratch buf overflow! &quot;
l_string|&quot;scr_len: %d, n: %d&bslash;n&quot;
comma
id|ibmcam-&gt;scratchlen
comma
id|n
)paren
suffix:semicolon
)brace
id|mv
op_assign
(paren
id|ibmcam-&gt;scratchlen
op_plus
id|n
)paren
op_minus
id|scratchbufsize
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;scratchlen
op_ge
id|mv
)paren
(brace
r_int
id|newslen
op_assign
id|ibmcam-&gt;scratchlen
op_minus
id|mv
suffix:semicolon
id|memmove
c_func
(paren
id|ibmcam-&gt;scratch
comma
id|ibmcam-&gt;scratch
op_plus
id|mv
comma
id|newslen
)paren
suffix:semicolon
id|ibmcam-&gt;scratchlen
op_assign
id|newslen
suffix:semicolon
id|data
op_assign
id|data0
op_assign
id|ibmcam-&gt;scratch
op_plus
id|ibmcam-&gt;scratchlen
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam: scratch buf too small&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|totlen
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/* Now we know that there is enough room in scratch buffer */
id|memmove
c_func
(paren
id|data
comma
id|cdata
comma
id|n
)paren
suffix:semicolon
id|data
op_add_assign
id|n
suffix:semicolon
id|totlen
op_add_assign
id|n
suffix:semicolon
id|ibmcam-&gt;scratchlen
op_add_assign
id|n
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|totlen
OG
l_int|0
)paren
(brace
r_static
r_int
id|foo
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|foo
OL
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;+%d.&bslash;n&quot;
comma
id|totlen
)paren
suffix:semicolon
id|ibmcam_hexdump
c_func
(paren
id|data0
comma
(paren
id|totlen
OG
l_int|64
)paren
ques
c_cond
l_int|64
suffix:colon
id|totlen
)paren
suffix:semicolon
op_increment
id|foo
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
id|totlen
suffix:semicolon
)brace
DECL|function|ibmcam_isoc_irq
r_static
r_void
id|ibmcam_isoc_irq
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
id|urb-&gt;context
suffix:semicolon
r_struct
id|ibmcam_sbuf
op_star
id|sbuf
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* We don&squot;t want to do anything if we are about to be removed! */
r_if
c_cond
(paren
op_logical_neg
id|IBMCAM_IS_OPERATIONAL
c_func
(paren
id|ibmcam
)paren
)paren
r_return
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|urb-&gt;actual_length
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam_isoc_irq: %p status %d, &quot;
l_string|&quot; errcount = %d, length = %d&bslash;n&quot;
comma
id|urb
comma
id|urb-&gt;status
comma
id|urb-&gt;error_count
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
)brace
r_else
(brace
r_static
r_int
id|c
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|c
op_increment
op_mod
l_int|100
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam_isoc_irq: no data&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|ibmcam-&gt;streaming
)paren
(brace
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam: oops, not streaming, but interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sbuf
op_assign
op_amp
id|ibmcam-&gt;sbuf
(braket
id|ibmcam-&gt;cursbuf
)braket
suffix:semicolon
multiline_comment|/* Copy the data received into our scratch buffer */
id|len
op_assign
id|ibmcam_compress_isochronous
c_func
(paren
id|ibmcam
comma
id|urb
)paren
suffix:semicolon
id|ibmcam-&gt;urb_count
op_increment
suffix:semicolon
id|ibmcam-&gt;urb_length
op_assign
id|len
suffix:semicolon
id|ibmcam-&gt;data_count
op_add_assign
id|len
suffix:semicolon
macro_line|#if 0   /* This code prints few initial bytes of ISO data: used to decode markers */
r_if
c_cond
(paren
id|ibmcam-&gt;urb_count
op_mod
l_int|64
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|ibmcam-&gt;urb_count
op_eq
l_int|1
)paren
(brace
id|ibmcam_hexdump
c_func
(paren
id|ibmcam-&gt;scratch
comma
(paren
id|ibmcam-&gt;scratchlen
OG
l_int|32
)paren
ques
c_cond
l_int|32
suffix:colon
id|ibmcam-&gt;scratchlen
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* If we collected enough data let&squot;s parse! */
r_if
c_cond
(paren
id|ibmcam-&gt;scratchlen
)paren
(brace
multiline_comment|/* If we don&squot;t have a frame we&squot;re current working on, complain */
r_if
c_cond
(paren
id|ibmcam-&gt;curframe
op_ge
l_int|0
)paren
id|ibmcam_parse_data
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam: received data, but no frame available&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FRAMES_PER_DESC
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sbuf-&gt;urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
id|sbuf-&gt;urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Move to the next sbuf */
id|ibmcam-&gt;cursbuf
op_assign
(paren
id|ibmcam-&gt;cursbuf
op_plus
l_int|1
)paren
op_mod
id|IBMCAM_NUMSBUF
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_veio()&n; *&n; * History:&n; * 1/27/00  Added check for dev == NULL; this happens if camera is unplugged.&n; */
DECL|function|usb_ibmcam_veio
r_static
r_int
id|usb_ibmcam_veio
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
r_char
id|req
comma
r_int
r_int
id|value
comma
r_int
r_int
id|index
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usb_ibmcam_veio&quot;
suffix:semicolon
r_int
r_char
id|cp
(braket
l_int|8
)braket
multiline_comment|/* = { 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef } */
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IBMCAM_IS_OPERATIONAL
c_func
(paren
id|ibmcam
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|req
op_eq
l_int|1
)paren
(brace
id|i
op_assign
id|usb_control_msg
c_func
(paren
id|ibmcam-&gt;dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|ibmcam-&gt;dev
comma
l_int|0
)paren
comma
id|req
comma
id|USB_DIR_IN
op_or
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_ENDPOINT
comma
id|value
comma
id|index
comma
id|cp
comma
r_sizeof
(paren
id|cp
)paren
comma
id|HZ
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;USB =&gt; %02x%02x%02x%02x%02x%02x%02x%02x &quot;
l_string|&quot;(req=$%02x val=$%04x ind=$%04x)&bslash;n&quot;
comma
id|cp
(braket
l_int|0
)braket
comma
id|cp
(braket
l_int|1
)braket
comma
id|cp
(braket
l_int|2
)braket
comma
id|cp
(braket
l_int|3
)braket
comma
id|cp
(braket
l_int|4
)braket
comma
id|cp
(braket
l_int|5
)braket
comma
id|cp
(braket
l_int|6
)braket
comma
id|cp
(braket
l_int|7
)braket
comma
id|req
comma
id|value
comma
id|index
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|i
op_assign
id|usb_control_msg
c_func
(paren
id|ibmcam-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|ibmcam-&gt;dev
comma
l_int|0
)paren
comma
id|req
comma
id|USB_DIR_OUT
op_or
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_ENDPOINT
comma
id|value
comma
id|index
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: ERROR=%d. Camera stopped - &quot;
l_string|&quot;reconnect or reload driver.&bslash;n&quot;
comma
id|proc
comma
id|i
)paren
suffix:semicolon
id|ibmcam-&gt;last_error
op_assign
id|i
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_calculate_fps()&n; *&n; * This procedure roughly calculates the real frame rate based&n; * on FPS code (framerate=NNN option). Actual FPS differs&n; * slightly depending on lighting conditions, so that actual frame&n; * rate is determined by the camera. Since I don&squot;t know how to ask&n; * the camera what FPS is now I have to use the FPS code instead.&n; *&n; * The FPS code is in range [0..6], 0 is slowest, 6 is fastest.&n; * Corresponding real FPS should be in range [3..30] frames per second.&n; * The conversion formula is obvious:&n; *&n; * real_fps = 3 + (fps_code * 4.5)&n; *&n; * History:&n; * 1/18/00  Created.&n; */
DECL|function|usb_ibmcam_calculate_fps
r_static
r_int
id|usb_ibmcam_calculate_fps
c_func
(paren
r_void
)paren
(brace
r_return
l_int|3
op_plus
id|framerate
op_star
l_int|4
op_plus
id|framerate
op_div
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_send_FF_04_02()&n; *&n; * This procedure sends magic 3-command prefix to the camera.&n; * The purpose of this prefix is not known.&n; *&n; * History:&n; * 1/2/00   Created.&n; */
DECL|function|usb_ibmcam_send_FF_04_02
r_static
r_void
id|usb_ibmcam_send_FF_04_02
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00FF
comma
l_int|0x0127
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0004
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0002
comma
l_int|0x0124
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_send_00_04_06
r_static
r_void
id|usb_ibmcam_send_00_04_06
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0127
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0004
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0006
comma
l_int|0x0124
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_send_x_00
r_static
r_void
id|usb_ibmcam_send_x_00
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
r_int
id|x
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
id|x
comma
l_int|0x0127
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0124
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_send_x_00_05
r_static
r_void
id|usb_ibmcam_send_x_00_05
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
r_int
id|x
)paren
(brace
id|usb_ibmcam_send_x_00
c_func
(paren
id|ibmcam
comma
id|x
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0005
comma
l_int|0x0124
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_send_x_00_05_02
r_static
r_void
id|usb_ibmcam_send_x_00_05_02
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
r_int
id|x
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
id|x
comma
l_int|0x0127
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0005
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0002
comma
l_int|0x0124
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_send_x_01_00_05
r_static
r_void
id|usb_ibmcam_send_x_01_00_05
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
r_int
id|x
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
id|x
comma
l_int|0x0127
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0001
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0005
comma
l_int|0x0124
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_send_x_00_05_02_01
r_static
r_void
id|usb_ibmcam_send_x_00_05_02_01
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
r_int
id|x
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
id|x
comma
l_int|0x0127
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0005
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0002
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0001
comma
l_int|0x0124
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_send_x_00_05_02_08_01
r_static
r_void
id|usb_ibmcam_send_x_00_05_02_08_01
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
r_int
id|x
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
id|x
comma
l_int|0x0127
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0005
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0002
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0008
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0001
comma
l_int|0x0124
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_Packet_Format1
r_static
r_void
id|usb_ibmcam_Packet_Format1
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
r_char
id|fkey
comma
r_int
r_char
id|val
)paren
(brace
id|usb_ibmcam_send_x_01_00_05
(paren
id|ibmcam
comma
id|unknown_88
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05
(paren
id|ibmcam
comma
id|fkey
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05_02_08_01
c_func
(paren
id|ibmcam
comma
id|val
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05
(paren
id|ibmcam
comma
id|unknown_88
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05_02_01
(paren
id|ibmcam
comma
id|fkey
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05
(paren
id|ibmcam
comma
id|unknown_89
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00
(paren
id|ibmcam
comma
id|fkey
)paren
suffix:semicolon
id|usb_ibmcam_send_00_04_06
(paren
id|ibmcam
)paren
suffix:semicolon
id|usb_ibmcam_veio
(paren
id|ibmcam
comma
l_int|1
comma
l_int|0x0000
comma
l_int|0x0126
)paren
suffix:semicolon
id|usb_ibmcam_send_FF_04_02
(paren
id|ibmcam
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_PacketFormat2
r_static
r_void
id|usb_ibmcam_PacketFormat2
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
r_char
id|fkey
comma
r_int
r_char
id|val
)paren
(brace
id|usb_ibmcam_send_x_01_00_05
(paren
id|ibmcam
comma
id|unknown_88
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05
(paren
id|ibmcam
comma
id|fkey
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05_02
(paren
id|ibmcam
comma
id|val
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_model2_Packet2
r_static
r_void
id|usb_ibmcam_model2_Packet2
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00ff
comma
l_int|0x012d
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0xfea3
comma
l_int|0x0124
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_model2_Packet1
r_static
r_void
id|usb_ibmcam_model2_Packet1
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
r_int
id|v1
comma
r_int
r_int
id|v2
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00aa
comma
l_int|0x012d
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00ff
comma
l_int|0x012e
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
id|v1
comma
l_int|0x012f
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00ff
comma
l_int|0x0130
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0xc719
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
id|v2
comma
l_int|0x0127
)paren
suffix:semicolon
id|usb_ibmcam_model2_Packet2
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_adjust_contrast()&n; *&n; * The contrast value changes from 0 (high contrast) to 15 (low contrast).&n; * This is in reverse to usual order of things (such as TV controls), so&n; * we reverse it again here.&n; *&n; * TODO: we probably don&squot;t need to send the setup 5 times...&n; *&n; * History:&n; * 1/2/00   Created.&n; */
DECL|function|usb_ibmcam_adjust_contrast
r_static
r_void
id|usb_ibmcam_adjust_contrast
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_int
r_char
id|new_contrast
op_assign
id|ibmcam-&gt;vpic.contrast
op_rshift
l_int|12
suffix:semicolon
r_const
r_int
id|ntries
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|new_contrast
op_ge
l_int|16
)paren
id|new_contrast
op_assign
l_int|15
suffix:semicolon
id|new_contrast
op_assign
l_int|15
op_minus
id|new_contrast
suffix:semicolon
r_if
c_cond
(paren
id|new_contrast
op_ne
id|ibmcam-&gt;vpic_old.contrast
)paren
(brace
id|ibmcam-&gt;vpic_old.contrast
op_assign
id|new_contrast
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;camera_model
op_eq
id|IBMCAM_MODEL_1
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
(brace
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
id|contrast_14
comma
id|new_contrast
)paren
suffix:semicolon
id|usb_ibmcam_send_FF_04_02
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Camera model 2 does not have this control; implemented in software. */
)brace
)brace
)brace
multiline_comment|/*&n; * usb_ibmcam_change_lighting_conditions()&n; *&n; * Camera model 1:&n; * We have 3 levels of lighting conditions: 0=Bright, 1=Medium, 2=Low.&n; *&n; * Camera model 2:&n; * We have 16 levels of lighting, 0 for bright light and up to 15 for&n; * low light. But values above 5 or so are useless because camera is&n; * not really capable to produce anything worth viewing at such light.&n; * This setting may be altered only in certain camera state.&n; *&n; * Low lighting forces slower FPS. Lighting is set as a module parameter.&n; *&n; * History:&n; * 1/5/00   Created.&n; * 2/20/00  Added support for Model 2 cameras.&n; */
DECL|function|usb_ibmcam_change_lighting_conditions
r_static
r_void
id|usb_ibmcam_change_lighting_conditions
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usb_ibmcam_change_lighting_conditions&quot;
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Set lighting to %hu.&bslash;n&quot;
comma
id|proc
comma
id|lighting
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;camera_model
op_eq
id|IBMCAM_MODEL_1
)paren
(brace
r_const
r_int
id|ntries
op_assign
l_int|5
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
id|light_27
comma
(paren
r_int
r_int
)paren
id|lighting
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * This command apparently requires camera to be stopped. My&n;&t;&t; * experiments showed that it -is- possible to alter the lighting&n;&t;&t; * conditions setting &quot;on the fly&quot;, but why bother? This setting does&n;&t;&t; * not work reliably in all cases, so I decided simply to leave the&n;&t;&t; * setting where Xirlink put it - in the camera setup phase. This code&n;&t;&t; * is commented out because it does not work at -any- moment, so its&n;&t;&t; * presence makes no sense. You may use it for experiments.&n;&t;&t; */
macro_line|#if 0
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x010c
)paren
suffix:semicolon
multiline_comment|/* Stop camera */
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
id|mod2_sensitivity
comma
id|lighting
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00c0
comma
l_int|0x010c
)paren
suffix:semicolon
multiline_comment|/* Start camera */
macro_line|#endif
)brace
)brace
multiline_comment|/*&n; * usb_ibmcam_set_sharpness()&n; *&n; * Cameras model 1 have internal smoothing feature. It is controlled by value in&n; * range [0..6], where 0 is most smooth and 6 is most sharp (raw image, I guess).&n; * Recommended value is 4. Cameras model 2 do not have this feature at all.&n; */
DECL|function|usb_ibmcam_set_sharpness
r_static
r_void
id|usb_ibmcam_set_sharpness
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usb_ibmcam_set_sharpness&quot;
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;camera_model
op_eq
id|IBMCAM_MODEL_1
)paren
(brace
r_static
r_const
r_int
r_int
id|sa
(braket
)braket
op_assign
(brace
l_int|0x11
comma
l_int|0x13
comma
l_int|0x16
comma
l_int|0x18
comma
l_int|0x1a
comma
l_int|0x8
comma
l_int|0x0a
)brace
suffix:semicolon
r_int
r_int
id|i
comma
id|sv
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|sharpness
comma
id|SHARPNESS_MIN
comma
id|SHARPNESS_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Set sharpness to %hu.&bslash;n&quot;
comma
id|proc
comma
id|sharpness
)paren
suffix:semicolon
id|sv
op_assign
id|sa
(braket
id|sharpness
op_minus
id|SHARPNESS_MIN
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|usb_ibmcam_send_x_01_00_05
(paren
id|ibmcam
comma
id|unknown_88
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05
(paren
id|ibmcam
comma
id|sharp_13
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05_02
(paren
id|ibmcam
comma
id|sv
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Camera model 2 does not have this control */
)brace
)brace
multiline_comment|/*&n; * usb_ibmcam_set_brightness()&n; *&n; * This procedure changes brightness of the picture.&n; */
DECL|function|usb_ibmcam_set_brightness
r_static
r_void
id|usb_ibmcam_set_brightness
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usb_ibmcam_set_brightness&quot;
suffix:semicolon
r_static
r_const
r_int
r_int
id|n
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|i
comma
id|j
comma
id|bv
(braket
l_int|3
)braket
suffix:semicolon
id|bv
(braket
l_int|0
)braket
op_assign
id|bv
(braket
l_int|1
)braket
op_assign
id|bv
(braket
l_int|2
)braket
op_assign
id|ibmcam-&gt;vpic.brightness
op_rshift
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|bv
(braket
l_int|0
)braket
op_eq
(paren
id|ibmcam-&gt;vpic_old.brightness
op_rshift
l_int|10
)paren
)paren
r_return
suffix:semicolon
id|ibmcam-&gt;vpic_old.brightness
op_assign
id|ibmcam-&gt;vpic.brightness
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Set brightness to (%hu,%hu,%hu)&bslash;n&quot;
comma
id|proc
comma
id|bv
(braket
l_int|0
)braket
comma
id|bv
(braket
l_int|1
)braket
comma
id|bv
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;camera_model
op_eq
id|IBMCAM_MODEL_1
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|3
suffix:semicolon
id|j
op_increment
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
id|bright_3x
(braket
id|j
)braket
comma
id|bv
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|i
op_assign
id|ibmcam-&gt;vpic.brightness
op_rshift
l_int|12
suffix:semicolon
multiline_comment|/* 0 .. 15 */
id|j
op_assign
l_int|0x60
op_plus
id|i
op_star
(paren
(paren
l_int|0xee
op_minus
l_int|0x60
)paren
op_div
l_int|16
)paren
suffix:semicolon
multiline_comment|/* 0x60 .. 0xee or so */
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
id|mod2_brightness
comma
id|j
)paren
suffix:semicolon
)brace
)brace
DECL|function|usb_ibmcam_model2_set_hue
r_static
r_void
id|usb_ibmcam_model2_set_hue
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_int
r_int
id|hue
op_assign
id|ibmcam-&gt;vpic.hue
op_rshift
l_int|9
suffix:semicolon
multiline_comment|/* 0 .. 7F */
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
id|mod2_color_balance_rg
comma
id|hue
)paren
suffix:semicolon
multiline_comment|/* usb_ibmcam_model2_Packet1(ibmcam, mod2_saturation, sat); */
)brace
multiline_comment|/*&n; * usb_ibmcam_adjust_picture()&n; *&n; * This procedure gets called from V4L interface to update picture settings.&n; * Here we change brightness and contrast.&n; */
DECL|function|usb_ibmcam_adjust_picture
r_static
r_void
id|usb_ibmcam_adjust_picture
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
id|usb_ibmcam_adjust_contrast
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
id|usb_ibmcam_set_brightness
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;camera_model
op_eq
id|IBMCAM_MODEL_2
)paren
(brace
id|usb_ibmcam_model2_set_hue
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
)brace
)brace
DECL|function|usb_ibmcam_model1_setup
r_static
r_int
id|usb_ibmcam_model1_setup
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_const
r_int
id|ntries
op_assign
l_int|5
suffix:semicolon
r_int
id|i
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|1
comma
l_int|0x00
comma
l_int|0x0128
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|1
comma
l_int|0x00
comma
l_int|0x0100
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x01
comma
l_int|0x0100
)paren
suffix:semicolon
multiline_comment|/* LED On  */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|1
comma
l_int|0x00
comma
l_int|0x0100
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x81
comma
l_int|0x0100
)paren
suffix:semicolon
multiline_comment|/* LED Off */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|1
comma
l_int|0x00
comma
l_int|0x0100
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x01
comma
l_int|0x0100
)paren
suffix:semicolon
multiline_comment|/* LED On  */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x01
comma
l_int|0x0108
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x03
comma
l_int|0x0112
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|1
comma
l_int|0x00
comma
l_int|0x0115
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x06
comma
l_int|0x0115
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|1
comma
l_int|0x00
comma
l_int|0x0116
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x44
comma
l_int|0x0116
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|1
comma
l_int|0x00
comma
l_int|0x0116
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x40
comma
l_int|0x0116
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|1
comma
l_int|0x00
comma
l_int|0x0115
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0e
comma
l_int|0x0115
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x19
comma
l_int|0x012c
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x00
comma
l_int|0x1e
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x39
comma
l_int|0x0d
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x39
comma
l_int|0x09
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x3b
comma
l_int|0x00
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x28
comma
l_int|0x22
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
id|light_27
comma
l_int|0
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x2b
comma
l_int|0x1f
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x39
comma
l_int|0x08
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x2c
comma
l_int|0x00
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x30
comma
l_int|0x14
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x39
comma
l_int|0x02
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x01
comma
l_int|0xe1
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x02
comma
l_int|0xcd
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x03
comma
l_int|0xcd
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x04
comma
l_int|0xfa
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x3f
comma
l_int|0xff
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x39
comma
l_int|0x00
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x39
comma
l_int|0x02
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x0a
comma
l_int|0x37
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x0b
comma
l_int|0xb8
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x0c
comma
l_int|0xf3
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x0d
comma
l_int|0xe3
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x0e
comma
l_int|0x0d
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x0f
comma
l_int|0xf2
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x10
comma
l_int|0xd5
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x11
comma
l_int|0xba
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x12
comma
l_int|0x53
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x3f
comma
l_int|0xff
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x39
comma
l_int|0x00
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x39
comma
l_int|0x02
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x16
comma
l_int|0x00
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x17
comma
l_int|0x28
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x18
comma
l_int|0x7d
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x19
comma
l_int|0xbe
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x3f
comma
l_int|0xff
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
l_int|0x39
comma
l_int|0x00
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x00
comma
l_int|0x18
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x13
comma
l_int|0x18
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x14
comma
l_int|0x06
)paren
suffix:semicolon
multiline_comment|/* This is default brightness */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x31
comma
l_int|0x37
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x32
comma
l_int|0x46
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x33
comma
l_int|0x55
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x2e
comma
l_int|0x04
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x2d
comma
l_int|0x04
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x29
comma
l_int|0x80
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x2c
comma
l_int|0x01
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x30
comma
l_int|0x17
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x39
comma
l_int|0x08
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x34
comma
l_int|0x00
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x0101
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x010a
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|videosize
)paren
(brace
r_case
id|VIDEOSIZE_128x96
suffix:colon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x80
comma
l_int|0x0103
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x60
comma
l_int|0x0105
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0c
comma
l_int|0x010b
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x04
comma
l_int|0x011b
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0b
comma
l_int|0x011d
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x011e
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x0129
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_176x144
suffix:colon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0xb0
comma
l_int|0x0103
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x8f
comma
l_int|0x0105
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x06
comma
l_int|0x010b
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x04
comma
l_int|0x011b
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0d
comma
l_int|0x011d
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x011e
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x03
comma
l_int|0x0129
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_352x288
suffix:colon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0xb0
comma
l_int|0x0103
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x90
comma
l_int|0x0105
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x02
comma
l_int|0x010b
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x04
comma
l_int|0x011b
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x05
comma
l_int|0x011d
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x011e
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x0129
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0xff
comma
l_int|0x012b
)paren
suffix:semicolon
multiline_comment|/* This is another brightness - don&squot;t know why */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x31
comma
l_int|0xc3
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x32
comma
l_int|0xd2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x33
comma
l_int|0xe1
)paren
suffix:semicolon
multiline_comment|/* Default contrast */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
id|contrast_14
comma
l_int|0x0a
)paren
suffix:semicolon
multiline_comment|/* Default sharpness */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|ibmcam
comma
id|sharp_13
comma
l_int|0x1a
)paren
suffix:semicolon
multiline_comment|/* Level 4 FIXME */
multiline_comment|/* Default lighting conditions */
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
id|light_27
comma
id|lighting
)paren
suffix:semicolon
multiline_comment|/* 0=Bright 2=Low */
multiline_comment|/* Assorted init */
r_switch
c_cond
(paren
id|videosize
)paren
(brace
r_case
id|VIDEOSIZE_128x96
suffix:colon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x2b
comma
l_int|0x1e
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0xc9
comma
l_int|0x0119
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x80
comma
l_int|0x0109
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x36
comma
l_int|0x0102
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x1a
comma
l_int|0x0104
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x04
comma
l_int|0x011a
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x2b
comma
l_int|0x011c
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x23
comma
l_int|0x012a
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
macro_line|#if 0
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x0106
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x38
comma
l_int|0x0107
)paren
suffix:semicolon
macro_line|#else
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x02
comma
l_int|0x0106
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x2a
comma
l_int|0x0107
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_176x144
suffix:colon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x2b
comma
l_int|0x1e
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0xc9
comma
l_int|0x0119
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x80
comma
l_int|0x0109
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x04
comma
l_int|0x0102
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x02
comma
l_int|0x0104
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x04
comma
l_int|0x011a
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x2b
comma
l_int|0x011c
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x23
comma
l_int|0x012a
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x01
comma
l_int|0x0106
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0xca
comma
l_int|0x0107
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_352x288
suffix:colon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|ibmcam
comma
l_int|0x2b
comma
l_int|0x1f
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0xc9
comma
l_int|0x0119
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x80
comma
l_int|0x0109
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x08
comma
l_int|0x0102
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x01
comma
l_int|0x0104
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x04
comma
l_int|0x011a
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x2f
comma
l_int|0x011c
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x23
comma
l_int|0x012a
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x03
comma
l_int|0x0106
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0xf6
comma
l_int|0x0107
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|IBMCAM_IS_OPERATIONAL
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_model2_setup
r_static
r_int
id|usb_ibmcam_model2_setup
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0100
)paren
suffix:semicolon
multiline_comment|/* LED on */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|1
comma
l_int|0x0000
comma
l_int|0x0116
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0060
comma
l_int|0x0116
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0002
comma
l_int|0x0112
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00bc
comma
l_int|0x012c
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0008
comma
l_int|0x012b
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0108
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0001
comma
l_int|0x0133
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0001
comma
l_int|0x0102
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|videosize
)paren
(brace
r_case
id|VIDEOSIZE_176x144
suffix:colon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x002c
comma
l_int|0x0103
)paren
suffix:semicolon
multiline_comment|/* All except 320x240 */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0104
)paren
suffix:semicolon
multiline_comment|/* Same */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0024
comma
l_int|0x0105
)paren
suffix:semicolon
multiline_comment|/* 176x144, 352x288 */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00b9
comma
l_int|0x010a
)paren
suffix:semicolon
multiline_comment|/* Unique to this mode */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0038
comma
l_int|0x0119
)paren
suffix:semicolon
multiline_comment|/* Unique to this mode */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0003
comma
l_int|0x0106
)paren
suffix:semicolon
multiline_comment|/* Same */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0090
comma
l_int|0x0107
)paren
suffix:semicolon
multiline_comment|/* Unique to every mode*/
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_320x240
suffix:colon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0028
comma
l_int|0x0103
)paren
suffix:semicolon
multiline_comment|/* Unique to this mode */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0104
)paren
suffix:semicolon
multiline_comment|/* Same */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x001e
comma
l_int|0x0105
)paren
suffix:semicolon
multiline_comment|/* 320x240, 352x240 */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0039
comma
l_int|0x010a
)paren
suffix:semicolon
multiline_comment|/* All except 176x144 */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0070
comma
l_int|0x0119
)paren
suffix:semicolon
multiline_comment|/* All except 176x144 */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0003
comma
l_int|0x0106
)paren
suffix:semicolon
multiline_comment|/* Same */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0098
comma
l_int|0x0107
)paren
suffix:semicolon
multiline_comment|/* Unique to every mode*/
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_352x240
suffix:colon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x002c
comma
l_int|0x0103
)paren
suffix:semicolon
multiline_comment|/* All except 320x240 */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0104
)paren
suffix:semicolon
multiline_comment|/* Same */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x001e
comma
l_int|0x0105
)paren
suffix:semicolon
multiline_comment|/* 320x240, 352x240 */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0039
comma
l_int|0x010a
)paren
suffix:semicolon
multiline_comment|/* All except 176x144 */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0070
comma
l_int|0x0119
)paren
suffix:semicolon
multiline_comment|/* All except 176x144 */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0003
comma
l_int|0x0106
)paren
suffix:semicolon
multiline_comment|/* Same */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00da
comma
l_int|0x0107
)paren
suffix:semicolon
multiline_comment|/* Unique to every mode*/
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_352x288
suffix:colon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x002c
comma
l_int|0x0103
)paren
suffix:semicolon
multiline_comment|/* All except 320x240 */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0104
)paren
suffix:semicolon
multiline_comment|/* Same */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0024
comma
l_int|0x0105
)paren
suffix:semicolon
multiline_comment|/* 176x144, 352x288 */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0039
comma
l_int|0x010a
)paren
suffix:semicolon
multiline_comment|/* All except 176x144 */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0070
comma
l_int|0x0119
)paren
suffix:semicolon
multiline_comment|/* All except 176x144 */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0003
comma
l_int|0x0106
)paren
suffix:semicolon
multiline_comment|/* Same */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00fe
comma
l_int|0x0107
)paren
suffix:semicolon
multiline_comment|/* Unique to every mode*/
r_break
suffix:semicolon
)brace
r_return
id|IBMCAM_IS_OPERATIONAL
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_model1_setup_after_video_if()&n; *&n; * This code adds finishing touches to the video data interface.&n; * Here we configure the frame rate and turn on the LED.&n; */
DECL|function|usb_ibmcam_model1_setup_after_video_if
r_static
r_void
id|usb_ibmcam_model1_setup_after_video_if
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_int
r_int
id|internal_frame_rate
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|framerate
comma
id|FRAMERATE_MIN
comma
id|FRAMERATE_MAX
)paren
suffix:semicolon
id|internal_frame_rate
op_assign
id|FRAMERATE_MAX
op_minus
id|framerate
suffix:semicolon
multiline_comment|/* 0=Fast 6=Slow */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x01
comma
l_int|0x0100
)paren
suffix:semicolon
multiline_comment|/* LED On  */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
id|internal_frame_rate
comma
l_int|0x0111
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x01
comma
l_int|0x0114
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0xc0
comma
l_int|0x010c
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_model2_setup_after_video_if
r_static
r_void
id|usb_ibmcam_model2_setup_after_video_if
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_int
r_int
id|setup_model2_rg
comma
id|setup_model2_rg2
comma
id|setup_model2_sat
comma
id|setup_model2_yb
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0100
)paren
suffix:semicolon
multiline_comment|/* LED on */
r_switch
c_cond
(paren
id|videosize
)paren
(brace
r_case
id|VIDEOSIZE_176x144
suffix:colon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0050
comma
l_int|0x0111
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00d0
comma
l_int|0x0111
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_320x240
suffix:colon
r_case
id|VIDEOSIZE_352x240
suffix:colon
r_case
id|VIDEOSIZE_352x288
suffix:colon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0040
comma
l_int|0x0111
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00c0
comma
l_int|0x0111
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x009b
comma
l_int|0x010f
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00bb
comma
l_int|0x010f
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Hardware settings, may affect CMOS sensor; not user controls!&n;&t; * -------------------------------------------------------------&n;&t; * 0x0004: no effect&n;&t; * 0x0006: hardware effect&n;&t; * 0x0008: no effect&n;&t; * 0x000a: stops video stream, probably important h/w setting&n;&t; * 0x000c: changes color in hardware manner (not user setting)&n;&t; * 0x0012: changes number of colors (does not affect speed)&n;&t; * 0x002a: no effect&n;&t; * 0x002c: hardware setting (related to scan lines)&n;&t; * 0x002e: stops video stream, probably important h/w setting&n;&t; */
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x000a
comma
l_int|0x005c
)paren
suffix:semicolon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0004
comma
l_int|0x0000
)paren
suffix:semicolon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0006
comma
l_int|0x00fb
)paren
suffix:semicolon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0008
comma
l_int|0x0000
)paren
suffix:semicolon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x000c
comma
l_int|0x0009
)paren
suffix:semicolon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0012
comma
l_int|0x000a
)paren
suffix:semicolon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x002a
comma
l_int|0x0000
)paren
suffix:semicolon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x002c
comma
l_int|0x0000
)paren
suffix:semicolon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x002e
comma
l_int|0x0008
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Function 0x0030 pops up all over the place. Apparently&n;&t; * it is a hardware control register, with every bit assigned to&n;&t; * do something.&n;&t; */
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0030
comma
l_int|0x0000
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Magic control of CMOS sensor. Only lower values like&n;&t; * 0-3 work, and picture shifts left or right. Don&squot;t change.&n;&t; */
r_switch
c_cond
(paren
id|videosize
)paren
(brace
r_case
id|VIDEOSIZE_176x144
suffix:colon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0014
comma
l_int|0x0002
)paren
suffix:semicolon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0016
comma
l_int|0x0002
)paren
suffix:semicolon
multiline_comment|/* Horizontal shift */
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0018
comma
l_int|0x004a
)paren
suffix:semicolon
multiline_comment|/* Another hardware setting */
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_320x240
suffix:colon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0014
comma
l_int|0x0009
)paren
suffix:semicolon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0016
comma
l_int|0x0005
)paren
suffix:semicolon
multiline_comment|/* Horizontal shift */
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0018
comma
l_int|0x0044
)paren
suffix:semicolon
multiline_comment|/* Another hardware setting */
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_352x240
suffix:colon
multiline_comment|/* This mode doesn&squot;t work as Windows programs it; changed to work */
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0014
comma
l_int|0x0009
)paren
suffix:semicolon
multiline_comment|/* Windows sets this to 8 */
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0016
comma
l_int|0x0003
)paren
suffix:semicolon
multiline_comment|/* Horizontal shift */
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0018
comma
l_int|0x0044
)paren
suffix:semicolon
multiline_comment|/* Windows sets this to 0x0045 */
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_352x288
suffix:colon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0014
comma
l_int|0x0003
)paren
suffix:semicolon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0016
comma
l_int|0x0002
)paren
suffix:semicolon
multiline_comment|/* Horizontal shift */
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0018
comma
l_int|0x004a
)paren
suffix:semicolon
multiline_comment|/* Another hardware setting */
r_break
suffix:semicolon
)brace
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
id|mod2_brightness
comma
l_int|0x005a
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have our own frame rate setting varying from 0 (slowest) to 6 (fastest).&n;&t; * The camera model 2 allows frame rate in range [0..0x1F] where 0 is also the&n;&t; * slowest setting. However for all practical reasons high settings make no&n;&t; * sense because USB is not fast enough to support high FPS. Be aware that&n;&t; * the picture datastream will be severely disrupted if you ask for&n;&t; * frame rate faster than allowed for the video size - see below:&n;&t; *&n;&t; * Allowable ranges (obtained experimentally on OHCI, K6-3, 450 MHz):&n;&t; * -----------------------------------------------------------------&n;&t; * 176x144: [6..31]&n;&t; * 320x240: [8..31]&n;&t; * 352x240: [10..31]&n;&t; * 352x288: [16..31] I have to raise lower threshold for stability...&n;&t; *&n;&t; * As usual, slower FPS provides better sensitivity.&n;&t; */
(brace
r_int
id|hw_fps
op_assign
l_int|31
comma
id|i_framerate
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|framerate
comma
id|FRAMERATE_MIN
comma
id|FRAMERATE_MAX
)paren
suffix:semicolon
id|i_framerate
op_assign
id|FRAMERATE_MAX
op_minus
id|framerate
op_plus
id|FRAMERATE_MIN
suffix:semicolon
r_switch
c_cond
(paren
id|videosize
)paren
(brace
r_case
id|VIDEOSIZE_176x144
suffix:colon
id|hw_fps
op_assign
l_int|6
op_plus
id|i_framerate
op_star
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_320x240
suffix:colon
id|hw_fps
op_assign
l_int|8
op_plus
id|i_framerate
op_star
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_352x240
suffix:colon
id|hw_fps
op_assign
l_int|10
op_plus
id|i_framerate
op_star
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_352x288
suffix:colon
id|hw_fps
op_assign
l_int|28
op_plus
id|i_framerate
op_div
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Framerate (hardware): %hd.&bslash;n&quot;
comma
id|hw_fps
)paren
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|hw_fps
comma
l_int|0
comma
l_int|31
)paren
suffix:semicolon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
id|mod2_set_framerate
comma
id|hw_fps
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This setting does not visibly affect pictures; left it here&n;&t; * because it was present in Windows USB data stream. This function&n;&t; * does not allow arbitrary values and apparently is a bit mask, to&n;&t; * be activated only at appropriate time. Don&squot;t change it randomly!&n;&t; */
r_switch
c_cond
(paren
id|videosize
)paren
(brace
r_case
id|VIDEOSIZE_176x144
suffix:colon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0026
comma
l_int|0x00c2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_320x240
suffix:colon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0026
comma
l_int|0x0044
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_352x240
suffix:colon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0026
comma
l_int|0x0046
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_352x288
suffix:colon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0026
comma
l_int|0x0048
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
id|mod2_sensitivity
comma
id|lighting
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_model2_rg
op_ge
l_int|0
)paren
(brace
id|RESTRICT_TO_RANGE
c_func
(paren
id|init_model2_rg
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
id|setup_model2_rg
op_assign
id|init_model2_rg
suffix:semicolon
)brace
r_else
id|setup_model2_rg
op_assign
l_int|0x0070
suffix:semicolon
r_if
c_cond
(paren
id|init_model2_rg2
op_ge
l_int|0
)paren
(brace
id|RESTRICT_TO_RANGE
c_func
(paren
id|init_model2_rg2
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
id|setup_model2_rg2
op_assign
id|init_model2_rg2
suffix:semicolon
)brace
r_else
id|setup_model2_rg2
op_assign
l_int|0x002f
suffix:semicolon
r_if
c_cond
(paren
id|init_model2_sat
op_ge
l_int|0
)paren
(brace
id|RESTRICT_TO_RANGE
c_func
(paren
id|init_model2_sat
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
id|setup_model2_sat
op_assign
id|init_model2_sat
suffix:semicolon
)brace
r_else
id|setup_model2_sat
op_assign
l_int|0x0034
suffix:semicolon
r_if
c_cond
(paren
id|init_model2_yb
op_ge
l_int|0
)paren
(brace
id|RESTRICT_TO_RANGE
c_func
(paren
id|init_model2_yb
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
id|setup_model2_yb
op_assign
id|init_model2_yb
suffix:semicolon
)brace
r_else
id|setup_model2_yb
op_assign
l_int|0x00a0
suffix:semicolon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
id|mod2_color_balance_rg2
comma
id|setup_model2_rg2
)paren
suffix:semicolon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
id|mod2_saturation
comma
id|setup_model2_sat
)paren
suffix:semicolon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
id|mod2_color_balance_yb
comma
id|setup_model2_yb
)paren
suffix:semicolon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
id|mod2_color_balance_rg
comma
id|setup_model2_rg
)paren
suffix:semicolon
multiline_comment|/* Hardware control command */
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0030
comma
l_int|0x0004
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00c0
comma
l_int|0x010c
)paren
suffix:semicolon
multiline_comment|/* Go camera, go! */
id|usb_clear_halt
c_func
(paren
id|ibmcam-&gt;dev
comma
id|ibmcam-&gt;video_endp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_setup_video_stop()&n; *&n; * This code tells camera to stop streaming. The interface remains&n; * configured and bandwidth - claimed.&n; */
DECL|function|usb_ibmcam_setup_video_stop
r_static
r_void
id|usb_ibmcam_setup_video_stop
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_if
c_cond
(paren
id|ibmcam-&gt;camera_model
op_eq
id|IBMCAM_MODEL_1
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x010c
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x010c
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x01
comma
l_int|0x0114
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0xc0
comma
l_int|0x010c
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x010c
)paren
suffix:semicolon
id|usb_ibmcam_send_FF_04_02
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|1
comma
l_int|0x00
comma
l_int|0x0100
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x81
comma
l_int|0x0100
)paren
suffix:semicolon
multiline_comment|/* LED Off */
)brace
r_else
r_if
c_cond
(paren
id|ibmcam-&gt;camera_model
op_eq
id|IBMCAM_MODEL_2
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x010c
)paren
suffix:semicolon
multiline_comment|/* Stop the camera */
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0030
comma
l_int|0x0004
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0080
comma
l_int|0x0100
)paren
suffix:semicolon
multiline_comment|/* LED Off */
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0020
comma
l_int|0x0111
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00a0
comma
l_int|0x0111
)paren
suffix:semicolon
id|usb_ibmcam_model2_Packet1
c_func
(paren
id|ibmcam
comma
l_int|0x0030
comma
l_int|0x0002
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0020
comma
l_int|0x0111
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0112
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * usb_ibmcam_reinit_iso()&n; *&n; * This procedure sends couple of commands to the camera and then&n; * resets the video pipe. This sequence was observed to reinit the&n; * camera or, at least, to initiate ISO data stream.&n; *&n; * History:&n; * 1/2/00   Created.&n; */
DECL|function|usb_ibmcam_reinit_iso
r_static
r_void
id|usb_ibmcam_reinit_iso
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
id|do_stop
)paren
(brace
r_if
c_cond
(paren
id|ibmcam-&gt;camera_model
op_eq
id|IBMCAM_MODEL_1
)paren
(brace
r_if
c_cond
(paren
id|do_stop
)paren
id|usb_ibmcam_setup_video_stop
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x0001
comma
l_int|0x0114
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam
comma
l_int|0
comma
l_int|0x00c0
comma
l_int|0x010c
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|ibmcam-&gt;dev
comma
id|ibmcam-&gt;video_endp
)paren
suffix:semicolon
id|usb_ibmcam_model1_setup_after_video_if
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ibmcam-&gt;camera_model
op_eq
id|IBMCAM_MODEL_2
)paren
(brace
id|usb_ibmcam_model2_setup_after_video_if
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * ibmcam_init_isoc()&n; *&n; * History:&n; * 1/27/00  Used ibmcam-&gt;iface, ibmcam-&gt;ifaceAltActive instead of hardcoded values.&n; *          Simplified by using for loop, allowed any number of URBs.&n; */
DECL|function|ibmcam_init_isoc
r_static
r_int
id|ibmcam_init_isoc
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
id|ibmcam-&gt;dev
suffix:semicolon
r_int
id|i
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IBMCAM_IS_OPERATIONAL
c_func
(paren
id|ibmcam
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ibmcam-&gt;compress
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;curframe
op_assign
op_minus
l_int|1
suffix:semicolon
id|ibmcam-&gt;cursbuf
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;scratchlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Alternate interface 1 is is the biggest frame size */
id|i
op_assign
id|usb_set_interface
c_func
(paren
id|dev
comma
id|ibmcam-&gt;iface
comma
id|ibmcam-&gt;ifaceAltActive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usb_set_interface error&bslash;n&quot;
)paren
suffix:semicolon
id|ibmcam-&gt;last_error
op_assign
id|i
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|usb_ibmcam_change_lighting_conditions
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
id|usb_ibmcam_set_sharpness
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
id|usb_ibmcam_reinit_iso
c_func
(paren
id|ibmcam
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* We double buffer the Iso lists */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IBMCAM_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|j
comma
id|k
suffix:semicolon
id|urb_t
op_star
id|urb
suffix:semicolon
id|urb
op_assign
id|usb_alloc_urb
c_func
(paren
id|FRAMES_PER_DESC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam_init_isoc: usb_init_isoc() failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
op_assign
id|urb
suffix:semicolon
id|urb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|urb-&gt;context
op_assign
id|ibmcam
suffix:semicolon
id|urb-&gt;pipe
op_assign
id|usb_rcvisocpipe
c_func
(paren
id|dev
comma
id|ibmcam-&gt;video_endp
)paren
suffix:semicolon
id|urb-&gt;transfer_flags
op_assign
id|USB_ISO_ASAP
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|data
suffix:semicolon
id|urb-&gt;complete
op_assign
id|ibmcam_isoc_irq
suffix:semicolon
id|urb-&gt;number_of_packets
op_assign
id|FRAMES_PER_DESC
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|ibmcam-&gt;iso_packet_len
op_star
id|FRAMES_PER_DESC
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|k
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|FRAMES_PER_DESC
suffix:semicolon
id|j
op_increment
comma
id|k
op_add_assign
id|ibmcam-&gt;iso_packet_len
)paren
(brace
id|urb-&gt;iso_frame_desc
(braket
id|j
)braket
dot
id|offset
op_assign
id|k
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|j
)braket
dot
id|length
op_assign
id|ibmcam-&gt;iso_packet_len
suffix:semicolon
)brace
)brace
multiline_comment|/* Link URBs into a ring so that they invoke each other infinitely */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IBMCAM_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_plus
l_int|1
)paren
OL
id|IBMCAM_NUMSBUF
)paren
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|urb-&gt;next
op_assign
id|ibmcam-&gt;sbuf
(braket
id|i
op_plus
l_int|1
)braket
dot
id|urb
suffix:semicolon
r_else
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|urb-&gt;next
op_assign
id|ibmcam-&gt;sbuf
(braket
l_int|0
)braket
dot
id|urb
suffix:semicolon
)brace
multiline_comment|/* Submit all URBs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IBMCAM_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
(brace
id|err
op_assign
id|usb_submit_urb
c_func
(paren
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam_init_isoc: usb_run_isoc(%d) ret %d&bslash;n&quot;
comma
id|i
comma
id|err
)paren
suffix:semicolon
)brace
id|ibmcam-&gt;streaming
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* printk(KERN_DEBUG &quot;streaming=1 ibmcam-&gt;video_endp=$%02x&bslash;n&quot;, ibmcam-&gt;video_endp); */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * ibmcam_stop_isoc()&n; *&n; * This procedure stops streaming and deallocates URBs. Then it&n; * activates zero-bandwidth alt. setting of the video interface.&n; *&n; * History:&n; * 1/22/00  Corrected order of actions to work after surprise removal.&n; * 1/27/00  Used ibmcam-&gt;iface, ibmcam-&gt;ifaceAltInactive instead of hardcoded values.&n; */
DECL|function|ibmcam_stop_isoc
r_static
r_void
id|ibmcam_stop_isoc
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;ibmcam_stop_isoc&quot;
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ibmcam-&gt;streaming
op_logical_or
(paren
id|ibmcam-&gt;dev
op_eq
l_int|NULL
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Unschedule all of the iso td&squot;s */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IBMCAM_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
(brace
id|j
op_assign
id|usb_unlink_urb
c_func
(paren
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: usb_unlink_urb() error %d.&bslash;n&quot;
comma
id|proc
comma
id|j
)paren
suffix:semicolon
)brace
multiline_comment|/* printk(KERN_DEBUG &quot;streaming=0&bslash;n&quot;); */
id|ibmcam-&gt;streaming
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Delete them all */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IBMCAM_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
id|usb_free_urb
c_func
(paren
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ibmcam-&gt;remove_pending
)paren
(brace
id|usb_ibmcam_setup_video_stop
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
multiline_comment|/* Set packet size to 0 */
id|j
op_assign
id|usb_set_interface
c_func
(paren
id|ibmcam-&gt;dev
comma
id|ibmcam-&gt;iface
comma
id|ibmcam-&gt;ifaceAltInactive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: usb_set_interface() error %d.&bslash;n&quot;
comma
id|proc
comma
id|j
)paren
suffix:semicolon
id|ibmcam-&gt;last_error
op_assign
id|j
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * ibmcam_new_frame()&n; *&n; * History:&n; * 29-Mar-00 Added copying of previous frame into the current one.&n; */
DECL|function|ibmcam_new_frame
r_static
r_int
id|ibmcam_new_frame
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
id|framenum
)paren
(brace
r_struct
id|ibmcam_frame
op_star
id|frame
suffix:semicolon
r_int
id|n
comma
id|width
comma
id|height
suffix:semicolon
multiline_comment|/* If we&squot;re not grabbing a frame right now and the other frame is */
multiline_comment|/*  ready to be grabbed into, then use it instead */
r_if
c_cond
(paren
id|ibmcam-&gt;curframe
op_ne
op_minus
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
id|n
op_assign
(paren
id|framenum
op_minus
l_int|1
op_plus
id|IBMCAM_NUMFRAMES
)paren
op_mod
id|IBMCAM_NUMFRAMES
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;frame
(braket
id|n
)braket
dot
id|grabstate
op_eq
id|FRAME_READY
)paren
id|framenum
op_assign
id|n
suffix:semicolon
id|frame
op_assign
op_amp
id|ibmcam-&gt;frame
(braket
id|framenum
)braket
suffix:semicolon
id|frame-&gt;grabstate
op_assign
id|FRAME_GRABBING
suffix:semicolon
id|frame-&gt;scanstate
op_assign
id|STATE_SCANNING
suffix:semicolon
id|frame-&gt;scanlength
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Accumulated in ibmcam_parse_data() */
id|ibmcam-&gt;curframe
op_assign
id|framenum
suffix:semicolon
multiline_comment|/*&n;&t; * Normally we would want to copy previous frame into the current one&n;&t; * before we even start filling it with data; this allows us to stop&n;&t; * filling at any moment; top portion of the frame will be new and&n;&t; * bottom portion will stay as it was in previous frame. If we don&squot;t&n;&t; * do that then missing chunks of video stream will result in flickering&n;&t; * portions of old data whatever it was before.&n;&t; *&n;&t; * If we choose not to copy previous frame (to, for example, save few&n;&t; * bus cycles - the frame can be pretty large!) then we have an option&n;&t; * to clear the frame before using. If we experience losses in this&n;&t; * mode then missing picture will be black (no flickering).&n;&t; *&n;&t; * Finally, if user chooses not to clean the current frame before&n;&t; * filling it with data then the old data will be visible if we fail&n;&t; * to refill entire frame with new data.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|FLAGS_SEPARATE_FRAMES
)paren
)paren
(brace
multiline_comment|/* This copies previous frame into this one to mask losses */
id|memmove
c_func
(paren
id|frame-&gt;data
comma
id|ibmcam-&gt;frame
(braket
l_int|1
op_minus
id|framenum
)braket
dot
id|data
comma
id|MAX_FRAME_SIZE
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|FLAGS_CLEAN_FRAMES
)paren
(brace
multiline_comment|/* This provides a &quot;clean&quot; frame but slows things down */
id|memset
c_func
(paren
id|frame-&gt;data
comma
l_int|0
comma
id|MAX_FRAME_SIZE
)paren
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|videosize
)paren
(brace
r_case
id|VIDEOSIZE_128x96
suffix:colon
id|frame-&gt;frmwidth
op_assign
l_int|128
suffix:semicolon
id|frame-&gt;frmheight
op_assign
l_int|96
suffix:semicolon
id|frame-&gt;order_uv
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* U Y V Y ... */
id|frame-&gt;hdr_sig
op_assign
l_int|0x06
suffix:semicolon
multiline_comment|/* 00 FF 00 06 */
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_176x144
suffix:colon
id|frame-&gt;frmwidth
op_assign
l_int|176
suffix:semicolon
id|frame-&gt;frmheight
op_assign
l_int|144
suffix:semicolon
id|frame-&gt;order_uv
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* U Y V Y ... */
id|frame-&gt;hdr_sig
op_assign
l_int|0x0E
suffix:semicolon
multiline_comment|/* 00 FF 00 0E */
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_320x240
suffix:colon
multiline_comment|/* For model 2 only */
id|frame-&gt;frmwidth
op_assign
l_int|320
suffix:semicolon
id|frame-&gt;frmheight
op_assign
l_int|240
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_352x240
suffix:colon
multiline_comment|/* For model 2 only */
id|frame-&gt;frmwidth
op_assign
l_int|352
suffix:semicolon
id|frame-&gt;frmheight
op_assign
l_int|240
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_352x288
suffix:colon
id|frame-&gt;frmwidth
op_assign
l_int|352
suffix:semicolon
id|frame-&gt;frmheight
op_assign
l_int|288
suffix:semicolon
id|frame-&gt;order_uv
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* V Y U Y ... */
id|frame-&gt;hdr_sig
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* 00 FF 00 00 */
r_break
suffix:semicolon
)brace
id|frame-&gt;order_yc
op_assign
(paren
id|ibmcam-&gt;camera_model
op_eq
id|IBMCAM_MODEL_2
)paren
suffix:semicolon
id|width
op_assign
id|frame-&gt;width
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|width
comma
id|min_imgwidth
comma
id|imgwidth
)paren
suffix:semicolon
id|width
op_and_assign
op_complement
l_int|7
suffix:semicolon
multiline_comment|/* Multiple of 8 */
id|height
op_assign
id|frame-&gt;height
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|height
comma
id|min_imgheight
comma
id|imgheight
)paren
suffix:semicolon
id|height
op_and_assign
op_complement
l_int|3
suffix:semicolon
multiline_comment|/* Multiple of 4 */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * ibmcam_open()&n; *&n; * This is part of Video 4 Linux API. The driver can be opened by one&n; * client only (checks internal counter &squot;ibmcam-&gt;user&squot;). The procedure&n; * then allocates buffers needed for video processing.&n; *&n; * History:&n; * 1/22/00  Rewrote, moved scratch buffer allocation here. Now the&n; *          camera is also initialized here (once per connect), at&n; *          expense of V4L client (it waits on open() call).&n; * 1/27/00  Used IBMCAM_NUMSBUF as number of URB buffers.&n; * 5/24/00  Corrected to prevent race condition (MOD_xxx_USE_COUNT).&n; */
DECL|function|ibmcam_open
r_static
r_int
id|ibmcam_open
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_int
id|flags
)paren
(brace
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
(paren
r_struct
id|usb_ibmcam
op_star
)paren
id|dev
suffix:semicolon
r_const
r_int
id|sb_size
op_assign
id|FRAMES_PER_DESC
op_star
id|ibmcam-&gt;iso_packet_len
suffix:semicolon
r_int
id|i
comma
id|err
op_assign
l_int|0
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ibmcam-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;user
)paren
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_else
(brace
multiline_comment|/* Clean pointers so we know if we allocated something */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IBMCAM_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Allocate memory for the frame buffers */
id|ibmcam-&gt;fbuf_size
op_assign
id|IBMCAM_NUMFRAMES
op_star
id|MAX_FRAME_SIZE
suffix:semicolon
id|ibmcam-&gt;fbuf
op_assign
id|rvmalloc
c_func
(paren
id|ibmcam-&gt;fbuf_size
)paren
suffix:semicolon
id|ibmcam-&gt;scratch
op_assign
id|kmalloc
c_func
(paren
id|scratchbufsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|ibmcam-&gt;scratchlen
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ibmcam-&gt;fbuf
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|ibmcam-&gt;scratch
op_eq
l_int|NULL
)paren
)paren
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_else
(brace
multiline_comment|/* Allocate all buffers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IBMCAM_NUMFRAMES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ibmcam-&gt;frame
(braket
id|i
)braket
dot
id|grabstate
op_assign
id|FRAME_UNUSED
suffix:semicolon
id|ibmcam-&gt;frame
(braket
id|i
)braket
dot
id|data
op_assign
id|ibmcam-&gt;fbuf
op_plus
id|i
op_star
id|MAX_FRAME_SIZE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Set default sizes in case IOCTL (VIDIOCMCAPTURE)&n;&t;&t;&t;&t; * is not used (using read() instead).&n;&t;&t;&t;&t; */
id|ibmcam-&gt;frame
(braket
id|i
)braket
dot
id|width
op_assign
id|imgwidth
suffix:semicolon
id|ibmcam-&gt;frame
(braket
id|i
)braket
dot
id|height
op_assign
id|imgheight
suffix:semicolon
id|ibmcam-&gt;frame
(braket
id|i
)braket
dot
id|bytes_read
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IBMCAM_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_assign
id|kmalloc
c_func
(paren
id|sb_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|err
)paren
(brace
multiline_comment|/* Have to free all that memory */
r_if
c_cond
(paren
id|ibmcam-&gt;fbuf
op_ne
l_int|NULL
)paren
(brace
id|rvfree
c_func
(paren
id|ibmcam-&gt;fbuf
comma
id|ibmcam-&gt;fbuf_size
)paren
suffix:semicolon
id|ibmcam-&gt;fbuf
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ibmcam-&gt;scratch
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|ibmcam-&gt;scratch
)paren
suffix:semicolon
id|ibmcam-&gt;scratch
op_assign
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IBMCAM_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_ne
l_int|NULL
)paren
(brace
id|kfree
(paren
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|data
)paren
suffix:semicolon
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* If so far no errors then we shall start the camera */
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|err
op_assign
id|ibmcam_init_isoc
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
multiline_comment|/* Send init sequence only once, it&squot;s large! */
r_if
c_cond
(paren
op_logical_neg
id|ibmcam-&gt;initialized
)paren
(brace
r_int
id|setup_ok
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;camera_model
op_eq
id|IBMCAM_MODEL_1
)paren
id|setup_ok
op_assign
id|usb_ibmcam_model1_setup
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ibmcam-&gt;camera_model
op_eq
id|IBMCAM_MODEL_2
)paren
id|setup_ok
op_assign
id|usb_ibmcam_model2_setup
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
r_if
c_cond
(paren
id|setup_ok
)paren
id|ibmcam-&gt;initialized
op_assign
l_int|1
suffix:semicolon
r_else
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|ibmcam-&gt;user
op_increment
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|ibmcam-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * ibmcam_close()&n; *&n; * This is part of Video 4 Linux API. The procedure&n; * stops streaming and deallocates all buffers that were earlier&n; * allocated in ibmcam_open().&n; *&n; * History:&n; * 1/22/00  Moved scratch buffer deallocation here.&n; * 1/27/00  Used IBMCAM_NUMSBUF as number of URB buffers.&n; * 5/24/00  Moved MOD_DEC_USE_COUNT outside of code that can sleep.&n; */
DECL|function|ibmcam_close
r_static
r_void
id|ibmcam_close
c_func
(paren
r_struct
id|video_device
op_star
id|dev
)paren
(brace
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
(paren
r_struct
id|usb_ibmcam
op_star
)paren
id|dev
suffix:semicolon
r_int
id|i
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ibmcam-&gt;lock
)paren
suffix:semicolon
id|ibmcam_stop_isoc
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
id|rvfree
c_func
(paren
id|ibmcam-&gt;fbuf
comma
id|ibmcam-&gt;fbuf_size
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ibmcam-&gt;scratch
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IBMCAM_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
id|kfree
c_func
(paren
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|data
)paren
suffix:semicolon
id|ibmcam-&gt;user
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;remove_pending
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ibmcam_close: Final disconnect.&bslash;n&quot;
)paren
suffix:semicolon
id|usb_ibmcam_release
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ibmcam-&gt;lock
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|function|ibmcam_write
r_static
r_int
id|ibmcam_write
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|count
comma
r_int
id|noblock
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; * ibmcam_ioctl()&n; *&n; * This is part of Video 4 Linux API. The procedure handles ioctl() calls.&n; *&n; * History:&n; * 1/22/00  Corrected VIDIOCSPICT to reject unsupported settings.&n; */
DECL|function|ibmcam_ioctl
r_static
r_int
id|ibmcam_ioctl
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
(paren
r_struct
id|usb_ibmcam
op_star
)paren
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IBMCAM_IS_OPERATIONAL
c_func
(paren
id|ibmcam
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|VIDIOCGCAP
suffix:colon
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ibmcam-&gt;vcap
comma
r_sizeof
(paren
id|ibmcam-&gt;vcap
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGCHAN
suffix:colon
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ibmcam-&gt;vchan
comma
r_sizeof
(paren
id|ibmcam-&gt;vchan
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCSCHAN
suffix:colon
(brace
r_int
id|v
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|v
comma
id|arg
comma
r_sizeof
(paren
id|v
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|v
OL
l_int|0
)paren
op_logical_or
(paren
id|v
op_ge
l_int|3
)paren
)paren
multiline_comment|/* 3 grades of lighting conditions */
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|v
op_ne
id|ibmcam-&gt;vchan.channel
)paren
(brace
id|ibmcam-&gt;vchan.channel
op_assign
id|v
suffix:semicolon
id|usb_ibmcam_change_lighting_conditions
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGPICT
suffix:colon
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ibmcam-&gt;vpic
comma
r_sizeof
(paren
id|ibmcam-&gt;vpic
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCSPICT
suffix:colon
(brace
r_struct
id|video_picture
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Use temporary &squot;video_picture&squot; structure to preserve our&n;&t;&t;&t; * own settings (such as color depth, palette) that we&n;&t;&t;&t; * aren&squot;t allowing everyone (V4L client) to change.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|arg
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ibmcam-&gt;vpic.brightness
op_assign
id|tmp.brightness
suffix:semicolon
id|ibmcam-&gt;vpic.hue
op_assign
id|tmp.hue
suffix:semicolon
id|ibmcam-&gt;vpic.colour
op_assign
id|tmp.colour
suffix:semicolon
id|ibmcam-&gt;vpic.contrast
op_assign
id|tmp.contrast
suffix:semicolon
id|usb_ibmcam_adjust_picture
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCSWIN
suffix:colon
(brace
r_struct
id|video_window
id|vw
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|vw
comma
id|arg
comma
r_sizeof
(paren
id|vw
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|vw.flags
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vw.clipcount
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vw.height
op_ne
id|imgheight
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vw.width
op_ne
id|imgwidth
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ibmcam-&gt;compress
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGWIN
suffix:colon
(brace
r_struct
id|video_window
id|vw
suffix:semicolon
id|vw.x
op_assign
l_int|0
suffix:semicolon
id|vw.y
op_assign
l_int|0
suffix:semicolon
id|vw.width
op_assign
id|imgwidth
suffix:semicolon
id|vw.height
op_assign
id|imgheight
suffix:semicolon
id|vw.chromakey
op_assign
l_int|0
suffix:semicolon
id|vw.flags
op_assign
id|usb_ibmcam_calculate_fps
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|vw
comma
r_sizeof
(paren
id|vw
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGMBUF
suffix:colon
(brace
r_struct
id|video_mbuf
id|vm
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|vm
comma
l_int|0
comma
r_sizeof
(paren
id|vm
)paren
)paren
suffix:semicolon
id|vm.size
op_assign
id|MAX_FRAME_SIZE
op_star
l_int|2
suffix:semicolon
id|vm.frames
op_assign
l_int|2
suffix:semicolon
id|vm.offsets
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|vm.offsets
(braket
l_int|1
)braket
op_assign
id|MAX_FRAME_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
(paren
r_void
op_star
)paren
op_amp
id|vm
comma
r_sizeof
(paren
id|vm
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCMCAPTURE
suffix:colon
(brace
r_struct
id|video_mmap
id|vm
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|vm
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|vm
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;frame: %d, size: %dx%d, format: %d&bslash;n&quot;
comma
id|vm.frame
comma
id|vm.width
comma
id|vm.height
comma
id|vm.format
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vm.format
op_ne
id|VIDEO_PALETTE_RGB24
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vm.frame
op_ne
l_int|0
)paren
op_logical_and
(paren
id|vm.frame
op_ne
l_int|1
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;frame
(braket
id|vm.frame
)braket
dot
id|grabstate
op_eq
id|FRAME_GRABBING
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* Don&squot;t compress if the size changed */
r_if
c_cond
(paren
(paren
id|ibmcam-&gt;frame
(braket
id|vm.frame
)braket
dot
id|width
op_ne
id|vm.width
)paren
op_logical_or
(paren
id|ibmcam-&gt;frame
(braket
id|vm.frame
)braket
dot
id|height
op_ne
id|vm.height
)paren
)paren
id|ibmcam-&gt;compress
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;frame
(braket
id|vm.frame
)braket
dot
id|width
op_assign
id|vm.width
suffix:semicolon
id|ibmcam-&gt;frame
(braket
id|vm.frame
)braket
dot
id|height
op_assign
id|vm.height
suffix:semicolon
multiline_comment|/* Mark it as ready */
id|ibmcam-&gt;frame
(braket
id|vm.frame
)braket
dot
id|grabstate
op_assign
id|FRAME_READY
suffix:semicolon
r_return
id|ibmcam_new_frame
c_func
(paren
id|ibmcam
comma
id|vm.frame
)paren
suffix:semicolon
)brace
r_case
id|VIDIOCSYNC
suffix:colon
(brace
r_int
id|frame
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|frame
comma
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam: syncing to frame %d&bslash;n&quot;
comma
id|frame
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ibmcam-&gt;frame
(braket
id|frame
)braket
dot
id|grabstate
)paren
(brace
r_case
id|FRAME_UNUSED
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|FRAME_READY
suffix:colon
r_case
id|FRAME_GRABBING
suffix:colon
r_case
id|FRAME_ERROR
suffix:colon
(brace
r_int
id|ntries
suffix:semicolon
id|redo
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|IBMCAM_IS_OPERATIONAL
c_func
(paren
id|ibmcam
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|ntries
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|ibmcam-&gt;frame
(braket
id|frame
)braket
dot
id|wq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|FLAGS_RETRY_VIDIOCSYNC
)paren
(brace
multiline_comment|/* Polling apps will destroy frames with that! */
id|ibmcam_new_frame
c_func
(paren
id|ibmcam
comma
id|frame
)paren
suffix:semicolon
id|usb_ibmcam_testpattern
c_func
(paren
id|ibmcam
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|ibmcam-&gt;curframe
op_assign
op_minus
l_int|1
suffix:semicolon
id|ibmcam-&gt;frame_num
op_increment
suffix:semicolon
multiline_comment|/* This will request another frame. */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ibmcam-&gt;frame
(braket
id|frame
)braket
dot
id|wq
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|ibmcam-&gt;frame
(braket
id|frame
)braket
dot
id|wq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Standard answer: not ready yet! */
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|ibmcam-&gt;frame
(braket
id|frame
)braket
dot
id|grabstate
op_eq
id|FRAME_GRABBING
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;frame
(braket
id|frame
)braket
dot
id|grabstate
op_eq
id|FRAME_ERROR
)paren
(brace
r_int
id|ret
op_assign
id|ibmcam_new_frame
c_func
(paren
id|ibmcam
comma
id|frame
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_goto
id|redo
suffix:semicolon
)brace
)brace
r_case
id|FRAME_DONE
suffix:colon
id|ibmcam-&gt;frame
(braket
id|frame
)braket
dot
id|grabstate
op_assign
id|FRAME_UNUSED
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ibmcam-&gt;frame
(braket
id|frame
)braket
dot
id|grabstate
op_assign
id|FRAME_UNUSED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGFBUF
suffix:colon
(brace
r_struct
id|video_buffer
id|vb
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|vb
comma
l_int|0
comma
r_sizeof
(paren
id|vb
)paren
)paren
suffix:semicolon
id|vb.base
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* frame buffer not supported, not used */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
(paren
r_void
op_star
)paren
op_amp
id|vb
comma
r_sizeof
(paren
id|vb
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCKEY
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|VIDIOCCAPTURE
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|VIDIOCSFBUF
suffix:colon
r_case
id|VIDIOCGTUNER
suffix:colon
r_case
id|VIDIOCSTUNER
suffix:colon
r_case
id|VIDIOCGFREQ
suffix:colon
r_case
id|VIDIOCSFREQ
suffix:colon
r_case
id|VIDIOCGAUDIO
suffix:colon
r_case
id|VIDIOCSAUDIO
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ibmcam_read
r_static
r_int
id|ibmcam_read
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|count
comma
r_int
id|noblock
)paren
(brace
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
(paren
r_struct
id|usb_ibmcam
op_star
)paren
id|dev
suffix:semicolon
r_int
id|frmx
op_assign
op_minus
l_int|1
suffix:semicolon
r_volatile
r_struct
id|ibmcam_frame
op_star
id|frame
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam_read: %ld bytes, noblock=%d&bslash;n&quot;
comma
id|count
comma
id|noblock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IBMCAM_IS_OPERATIONAL
c_func
(paren
id|ibmcam
)paren
op_logical_or
(paren
id|buf
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* See if a frame is completed, then use it. */
r_if
c_cond
(paren
id|ibmcam-&gt;frame
(braket
l_int|0
)braket
dot
id|grabstate
op_ge
id|FRAME_DONE
)paren
multiline_comment|/* _DONE or _ERROR */
id|frmx
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ibmcam-&gt;frame
(braket
l_int|1
)braket
dot
id|grabstate
op_ge
id|FRAME_DONE
)paren
multiline_comment|/* _DONE or _ERROR */
id|frmx
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|noblock
op_logical_and
(paren
id|frmx
op_eq
op_minus
l_int|1
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/* If no FRAME_DONE, look for a FRAME_GRABBING state. */
multiline_comment|/* See if a frame is in process (grabbing), then use it. */
r_if
c_cond
(paren
id|frmx
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|ibmcam-&gt;frame
(braket
l_int|0
)braket
dot
id|grabstate
op_eq
id|FRAME_GRABBING
)paren
id|frmx
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ibmcam-&gt;frame
(braket
l_int|1
)braket
dot
id|grabstate
op_eq
id|FRAME_GRABBING
)paren
id|frmx
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If no frame is active, start one. */
r_if
c_cond
(paren
id|frmx
op_eq
op_minus
l_int|1
)paren
id|ibmcam_new_frame
c_func
(paren
id|ibmcam
comma
id|frmx
op_assign
l_int|0
)paren
suffix:semicolon
id|frame
op_assign
op_amp
id|ibmcam-&gt;frame
(braket
id|frmx
)braket
suffix:semicolon
id|restart
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|IBMCAM_IS_OPERATIONAL
c_func
(paren
id|ibmcam
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_while
c_loop
(paren
id|frame-&gt;grabstate
op_eq
id|FRAME_GRABBING
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|frame-&gt;wq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|frame-&gt;grabstate
op_eq
id|FRAME_ERROR
)paren
(brace
id|frame-&gt;bytes_read
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam_new_frame
c_func
(paren
id|ibmcam
comma
id|frmx
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam_read: ibmcam_new_frame error&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam_read: frmx=%d, bytes_read=%ld, scanlength=%ld&bslash;n&quot;
comma
id|frmx
comma
id|frame-&gt;bytes_read
comma
id|frame-&gt;scanlength
)paren
suffix:semicolon
multiline_comment|/* copy bytes to user space; we allow for partials reads */
r_if
c_cond
(paren
(paren
id|count
op_plus
id|frame-&gt;bytes_read
)paren
OG
id|frame-&gt;scanlength
)paren
id|count
op_assign
id|frame-&gt;scanlength
op_minus
id|frame-&gt;bytes_read
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|frame-&gt;data
op_plus
id|frame-&gt;bytes_read
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|frame-&gt;bytes_read
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam_read: {copy} count used=%ld, new bytes_read=%ld&bslash;n&quot;
comma
id|count
comma
id|frame-&gt;bytes_read
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frame-&gt;bytes_read
op_ge
id|frame-&gt;scanlength
)paren
(brace
multiline_comment|/* All data has been read */
id|frame-&gt;bytes_read
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Mark it as available to be used again. */
id|ibmcam-&gt;frame
(braket
id|frmx
)braket
dot
id|grabstate
op_assign
id|FRAME_UNUSED
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam_new_frame
c_func
(paren
id|ibmcam
comma
id|frmx
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam_read: ibmcam_new_frame returned error&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|ibmcam_mmap
r_static
r_int
id|ibmcam_mmap
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_const
r_char
op_star
id|adr
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
(paren
r_struct
id|usb_ibmcam
op_star
)paren
id|dev
suffix:semicolon
r_int
r_int
id|start
op_assign
(paren
r_int
r_int
)paren
id|adr
suffix:semicolon
r_int
r_int
id|page
comma
id|pos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IBMCAM_IS_OPERATIONAL
c_func
(paren
id|ibmcam
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
(paren
(paren
(paren
l_int|2
op_star
id|MAX_FRAME_SIZE
)paren
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pos
op_assign
(paren
r_int
r_int
)paren
id|ibmcam-&gt;fbuf
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|kvirt_to_pa
c_func
(paren
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remap_page_range
c_func
(paren
id|start
comma
id|page
comma
id|PAGE_SIZE
comma
id|PAGE_SHARED
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|pos
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|PAGE_SIZE
)paren
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
r_else
id|size
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ibmcam_template
r_static
r_struct
id|video_device
id|ibmcam_template
op_assign
(brace
id|name
suffix:colon
l_string|&quot;CPiA USB Camera&quot;
comma
id|type
suffix:colon
id|VID_TYPE_CAPTURE
comma
id|hardware
suffix:colon
id|VID_HARDWARE_CPIA
comma
id|open
suffix:colon
id|ibmcam_open
comma
id|close
suffix:colon
id|ibmcam_close
comma
id|read
suffix:colon
id|ibmcam_read
comma
id|write
suffix:colon
id|ibmcam_write
comma
id|ioctl
suffix:colon
id|ibmcam_ioctl
comma
id|mmap
suffix:colon
id|ibmcam_mmap
comma
)brace
suffix:semicolon
DECL|function|usb_ibmcam_configure_video
r_static
r_void
id|usb_ibmcam_configure_video
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_if
c_cond
(paren
id|ibmcam
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|init_brightness
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|init_contrast
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|init_color
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|init_hue
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|hue_correction
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ibmcam-&gt;vpic
comma
l_int|0
comma
r_sizeof
(paren
id|ibmcam-&gt;vpic
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ibmcam-&gt;vpic_old
comma
l_int|0x55
comma
r_sizeof
(paren
id|ibmcam-&gt;vpic_old
)paren
)paren
suffix:semicolon
id|ibmcam-&gt;vpic.colour
op_assign
id|init_color
op_lshift
l_int|8
suffix:semicolon
id|ibmcam-&gt;vpic.hue
op_assign
id|init_hue
op_lshift
l_int|8
suffix:semicolon
id|ibmcam-&gt;vpic.brightness
op_assign
id|init_brightness
op_lshift
l_int|8
suffix:semicolon
id|ibmcam-&gt;vpic.contrast
op_assign
id|init_contrast
op_lshift
l_int|8
suffix:semicolon
id|ibmcam-&gt;vpic.whiteness
op_assign
l_int|105
op_lshift
l_int|8
suffix:semicolon
multiline_comment|/* This one isn&squot;t used */
id|ibmcam-&gt;vpic.depth
op_assign
l_int|24
suffix:semicolon
id|ibmcam-&gt;vpic.palette
op_assign
id|VIDEO_PALETTE_RGB24
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ibmcam-&gt;vcap
comma
l_int|0
comma
r_sizeof
(paren
id|ibmcam-&gt;vcap
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|ibmcam-&gt;vcap.name
comma
l_string|&quot;IBM USB Camera&quot;
)paren
suffix:semicolon
id|ibmcam-&gt;vcap.type
op_assign
id|VID_TYPE_CAPTURE
suffix:semicolon
id|ibmcam-&gt;vcap.channels
op_assign
l_int|1
suffix:semicolon
id|ibmcam-&gt;vcap.audios
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;vcap.maxwidth
op_assign
id|imgwidth
suffix:semicolon
id|ibmcam-&gt;vcap.maxheight
op_assign
id|imgheight
suffix:semicolon
id|ibmcam-&gt;vcap.minwidth
op_assign
id|min_imgwidth
suffix:semicolon
id|ibmcam-&gt;vcap.minheight
op_assign
id|min_imgheight
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ibmcam-&gt;vchan
comma
l_int|0
comma
r_sizeof
(paren
id|ibmcam-&gt;vchan
)paren
)paren
suffix:semicolon
id|ibmcam-&gt;vchan.flags
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;vchan.tuners
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;vchan.channel
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;vchan.type
op_assign
id|VIDEO_TYPE_CAMERA
suffix:semicolon
id|strcpy
c_func
(paren
id|ibmcam-&gt;vchan.name
comma
l_string|&quot;Camera&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ibmcam_find_struct()&n; *&n; * This code searches the array of preallocated (static) structures&n; * and returns index of the first one that isn&squot;t in use. Returns -1&n; * if there are no free structures.&n; *&n; * History:&n; * 1/27/00  Created.&n; */
DECL|function|ibmcam_find_struct
r_static
r_int
id|ibmcam_find_struct
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|u
suffix:semicolon
r_for
c_loop
(paren
id|u
op_assign
l_int|0
suffix:semicolon
id|u
OL
id|MAX_IBMCAM
suffix:semicolon
id|u
op_increment
)paren
(brace
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
op_amp
id|cams
(braket
id|u
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ibmcam-&gt;ibmcam_used
)paren
multiline_comment|/* This one is free */
(brace
id|ibmcam-&gt;ibmcam_used
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* In use now */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IBMCAM_NUMFRAMES
suffix:semicolon
id|i
op_increment
)paren
id|init_waitqueue_head
c_func
(paren
op_amp
id|ibmcam-&gt;frame
(braket
id|i
)braket
dot
id|wq
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|ibmcam-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* to 1 == available */
id|ibmcam-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|ibmcam-&gt;vdev
comma
op_amp
id|ibmcam_template
comma
r_sizeof
(paren
id|ibmcam_template
)paren
)paren
suffix:semicolon
r_return
id|u
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_probe()&n; *&n; * This procedure queries device descriptor and accepts the interface&n; * if it looks like IBM C-it camera.&n; *&n; * History:&n; * 1/22/00  Moved camera init code to ibmcam_open()&n; * 1/27/00  Changed to use static structures, added locking.&n; * 5/24/00  Corrected to prevent race condition (MOD_xxx_USE_COUNT).&n; * 7/3/00   Fixed endianness bug.&n; */
DECL|function|usb_ibmcam_probe
r_static
r_void
op_star
id|usb_ibmcam_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
l_int|NULL
suffix:semicolon
r_const
r_struct
id|usb_interface_descriptor
op_star
id|interface
suffix:semicolon
r_const
r_struct
id|usb_endpoint_descriptor
op_star
id|endpoint
suffix:semicolon
r_int
id|devnum
comma
id|model
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam_probe(%p,%u.)&bslash;n&quot;
comma
id|dev
comma
id|ifnum
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t handle multi-config cameras */
r_if
c_cond
(paren
id|dev-&gt;descriptor.bNumConfigurations
op_ne
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Check the version/revision */
r_switch
c_cond
(paren
id|dev-&gt;descriptor.bcdDevice
)paren
(brace
r_case
l_int|0x0002
suffix:colon
r_if
c_cond
(paren
id|ifnum
op_ne
l_int|2
)paren
r_return
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IBM USB camera found (model 1, rev. 0x%04x).&bslash;n&quot;
comma
id|dev-&gt;descriptor.bcdDevice
)paren
suffix:semicolon
id|model
op_assign
id|IBMCAM_MODEL_1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x030A
suffix:colon
r_if
c_cond
(paren
id|ifnum
op_ne
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IBM USB camera found (model 2, rev. 0x%04x).&bslash;n&quot;
comma
id|dev-&gt;descriptor.bcdDevice
)paren
suffix:semicolon
id|model
op_assign
id|IBMCAM_MODEL_2
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* ibmcam_table contents prevents any other values from ever&n;&t;   being passed to us, so no need for &quot;default&quot; case. */
)brace
multiline_comment|/* Validate found interface: must have one ISO endpoint */
id|interface
op_assign
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|ifnum
)braket
dot
id|altsetting
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|interface-&gt;bNumEndpoints
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;IBM camera: interface %d. has %u. endpoints!&bslash;n&quot;
comma
id|ifnum
comma
(paren
r_int
)paren
(paren
id|interface-&gt;bNumEndpoints
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|endpoint
op_assign
op_amp
id|interface-&gt;endpoint
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|endpoint-&gt;bmAttributes
op_amp
l_int|0x03
)paren
op_ne
l_int|0x01
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;IBM camera: interface %d. has non-ISO endpoint!&bslash;n&quot;
comma
id|ifnum
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|endpoint-&gt;bEndpointAddress
op_amp
l_int|0x80
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;IBM camera: interface %d. has ISO OUT endpoint!&bslash;n&quot;
comma
id|ifnum
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Validate options */
r_if
c_cond
(paren
id|model
op_eq
id|IBMCAM_MODEL_1
)paren
(brace
id|RESTRICT_TO_RANGE
c_func
(paren
id|lighting
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|videosize
comma
id|VIDEOSIZE_128x96
comma
id|VIDEOSIZE_352x288
)paren
suffix:semicolon
)brace
r_else
(brace
id|RESTRICT_TO_RANGE
c_func
(paren
id|lighting
comma
l_int|0
comma
l_int|15
)paren
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|videosize
comma
id|VIDEOSIZE_176x144
comma
id|VIDEOSIZE_352x240
)paren
suffix:semicolon
)brace
multiline_comment|/* Code below may sleep, need to lock module while we are here */
id|MOD_INC_USE_COUNT
suffix:semicolon
id|devnum
op_assign
id|ibmcam_find_struct
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devnum
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IBM USB camera driver: Too many devices!&bslash;n&quot;
)paren
suffix:semicolon
id|ibmcam
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Do not free, it&squot;s preallocated */
r_goto
id|probe_done
suffix:semicolon
)brace
id|ibmcam
op_assign
op_amp
id|cams
(braket
id|devnum
)braket
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ibmcam-&gt;lock
)paren
suffix:semicolon
id|ibmcam-&gt;camera_model
op_assign
id|model
suffix:semicolon
id|ibmcam-&gt;remove_pending
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;last_error
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;dev
op_assign
id|dev
suffix:semicolon
id|ibmcam-&gt;iface
op_assign
id|ifnum
suffix:semicolon
id|ibmcam-&gt;ifaceAltInactive
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;ifaceAltActive
op_assign
l_int|1
suffix:semicolon
id|ibmcam-&gt;video_endp
op_assign
id|endpoint-&gt;bEndpointAddress
suffix:semicolon
id|ibmcam-&gt;iso_packet_len
op_assign
l_int|1014
suffix:semicolon
id|ibmcam-&gt;compress
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;user
op_assign
l_int|0
suffix:semicolon
id|usb_ibmcam_configure_video
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
id|up
(paren
op_amp
id|ibmcam-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|video_register_device
c_func
(paren
op_amp
id|ibmcam-&gt;vdev
comma
id|VFL_TYPE_GRABBER
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;video_register_device failed&bslash;n&quot;
)paren
suffix:semicolon
id|ibmcam
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Do not free, it&squot;s preallocated */
)brace
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;video_register_device() successful&bslash;n&quot;
)paren
suffix:semicolon
id|probe_done
suffix:colon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|ibmcam
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_release()&n; *&n; * This code does final release of struct usb_ibmcam. This happens&n; * after the device is disconnected -and- all clients closed their files.&n; *&n; * History:&n; * 1/27/00  Created.&n; */
DECL|function|usb_ibmcam_release
r_static
r_void
id|usb_ibmcam_release
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
id|video_unregister_device
c_func
(paren
op_amp
id|ibmcam-&gt;vdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;usb_ibmcam_release: Video unregistered.&bslash;n&quot;
)paren
suffix:semicolon
id|ibmcam-&gt;ibmcam_used
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;initialized
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_disconnect()&n; *&n; * This procedure stops all driver activity, deallocates interface-private&n; * structure (pointed by &squot;ptr&squot;) and after that driver should be removable&n; * with no ill consequences.&n; *&n; * This code handles surprise removal. The ibmcam-&gt;user is a counter which&n; * increments on open() and decrements on close(). If we see here that&n; * this counter is not 0 then we have a client who still has us opened.&n; * We set ibmcam-&gt;remove_pending flag as early as possible, and after that&n; * all access to the camera will gracefully fail. These failures should&n; * prompt client to (eventually) close the video device, and then - in&n; * ibmcam_close() - we decrement ibmcam-&gt;ibmcam_used and usage counter.&n; *&n; * History:&n; * 1/22/00  Added polling of MOD_IN_USE to delay removal until all users gone.&n; * 1/27/00  Reworked to allow pending disconnects; see ibmcam_close()&n; * 5/24/00  Corrected to prevent race condition (MOD_xxx_USE_COUNT).&n; */
DECL|function|usb_ibmcam_disconnect
r_static
r_void
id|usb_ibmcam_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usb_ibmcam_disconnect&quot;
suffix:semicolon
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
(paren
r_struct
id|usb_ibmcam
op_star
)paren
id|ptr
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s(%p,%p.)&bslash;n&quot;
comma
id|proc
comma
id|dev
comma
id|ptr
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ibmcam-&gt;lock
)paren
suffix:semicolon
id|ibmcam-&gt;remove_pending
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Now all ISO data will be ignored */
multiline_comment|/* At this time we ask to cancel outstanding URBs */
id|ibmcam_stop_isoc
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
id|ibmcam-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* USB device is no more */
r_if
c_cond
(paren
id|ibmcam-&gt;user
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: In use, disconnect pending.&bslash;n&quot;
comma
id|proc
)paren
suffix:semicolon
r_else
id|usb_ibmcam_release
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ibmcam-&gt;lock
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IBM USB camera disconnected.&bslash;n&quot;
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|variable|ibmcam_table
r_static
r_struct
id|usb_device_id
id|ibmcam_table
(braket
)braket
op_assign
(brace
(brace
id|USB_DEVICE_VER
c_func
(paren
l_int|0x0545
comma
l_int|0x8080
comma
l_int|0x0002
comma
l_int|0x0002
)paren
)brace
comma
(brace
id|USB_DEVICE_VER
c_func
(paren
l_int|0x0545
comma
l_int|0x8080
comma
l_int|0x030a
comma
l_int|0x030a
)paren
)brace
comma
(brace
)brace
multiline_comment|/* Terminating entry */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|usb
comma
id|ibmcam_table
)paren
suffix:semicolon
DECL|variable|ibmcam_driver
r_static
r_struct
id|usb_driver
id|ibmcam_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;ibmcam&quot;
comma
id|probe
suffix:colon
id|usb_ibmcam_probe
comma
id|disconnect
suffix:colon
id|usb_ibmcam_disconnect
comma
id|id_table
suffix:colon
id|ibmcam_table
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * usb_ibmcam_init()&n; *&n; * This code is run to initialize the driver.&n; *&n; * History:&n; * 1/27/00  Reworked to use statically allocated usb_ibmcam structures.&n; */
DECL|function|usb_ibmcam_init
r_static
r_int
id|__init
id|usb_ibmcam_init
c_func
(paren
r_void
)paren
(brace
r_int
id|u
suffix:semicolon
multiline_comment|/* Initialize struct */
r_for
c_loop
(paren
id|u
op_assign
l_int|0
suffix:semicolon
id|u
OL
id|MAX_IBMCAM
suffix:semicolon
id|u
op_increment
)paren
(brace
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
op_amp
id|cams
(braket
id|u
)braket
suffix:semicolon
id|memset
(paren
id|ibmcam
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|usb_ibmcam
)paren
)paren
suffix:semicolon
)brace
r_return
id|usb_register
c_func
(paren
op_amp
id|ibmcam_driver
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_cleanup
r_static
r_void
id|__exit
id|usb_ibmcam_cleanup
c_func
(paren
r_void
)paren
(brace
id|usb_deregister
c_func
(paren
op_amp
id|ibmcam_driver
)paren
suffix:semicolon
)brace
DECL|variable|usb_ibmcam_init
id|module_init
c_func
(paren
id|usb_ibmcam_init
)paren
suffix:semicolon
DECL|variable|usb_ibmcam_cleanup
id|module_exit
c_func
(paren
id|usb_ibmcam_cleanup
)paren
suffix:semicolon
eof
