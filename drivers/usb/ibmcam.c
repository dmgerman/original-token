multiline_comment|/*&n; * USB IBM C-It Video Camera driver&n; *&n; * Supports IBM C-It Video Camera.&n; *&n; * This driver is based on earlier work of:&n; *&n; * (C) Copyright 1999 Johannes Erdfelt&n; * (C) Copyright 1999 Randy Dunlap&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/videodev.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/wrapper.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;ibmcam.h&quot;
DECL|macro|ENABLE_HEXDUMP
mdefine_line|#define&t;ENABLE_HEXDUMP&t;0&t;/* Enable if you need it */
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Completion states of the data parser */
r_typedef
r_enum
(brace
DECL|enumerator|scan_Continue
id|scan_Continue
comma
multiline_comment|/* Just parse next item */
DECL|enumerator|scan_NextFrame
id|scan_NextFrame
comma
multiline_comment|/* Frame done, send it to V4L */
DECL|enumerator|scan_Out
id|scan_Out
comma
multiline_comment|/* Not enough data for frame */
DECL|enumerator|scan_EndParse
id|scan_EndParse
multiline_comment|/* End parsing */
DECL|typedef|scan_state_t
)brace
id|scan_state_t
suffix:semicolon
multiline_comment|/* Bit flags (options) */
DECL|macro|FLAGS_RETRY_VIDIOCSYNC
mdefine_line|#define FLAGS_RETRY_VIDIOCSYNC&t;&t;(1 &lt;&lt; 0)
DECL|macro|FLAGS_MONOCHROME
mdefine_line|#define&t;FLAGS_MONOCHROME&t;&t;(1 &lt;&lt; 1)
DECL|macro|FLAGS_DISPLAY_HINTS
mdefine_line|#define FLAGS_DISPLAY_HINTS&t;&t;(1 &lt;&lt; 2)
DECL|macro|FLAGS_OVERLAY_STATS
mdefine_line|#define FLAGS_OVERLAY_STATS&t;&t;(1 &lt;&lt; 3)
DECL|macro|FLAGS_FORCE_TESTPATTERN
mdefine_line|#define FLAGS_FORCE_TESTPATTERN&t;&t;(1 &lt;&lt; 4)
DECL|variable|flags
r_static
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FLAGS_DISPLAY_HINTS | FLAGS_OVERLAY_STATS; */
multiline_comment|/* This is the size of V4L frame that we provide */
DECL|variable|imgwidth
r_static
r_const
r_int
id|imgwidth
op_assign
id|V4L_FRAME_WIDTH_USED
suffix:semicolon
DECL|variable|imgheight
r_static
r_const
r_int
id|imgheight
op_assign
id|V4L_FRAME_HEIGHT
suffix:semicolon
DECL|variable|min_imgwidth
r_static
r_const
r_int
id|min_imgwidth
op_assign
l_int|8
suffix:semicolon
DECL|variable|min_imgheight
r_static
r_const
r_int
id|min_imgheight
op_assign
l_int|4
suffix:semicolon
DECL|macro|LIGHTING_MIN
mdefine_line|#define&t;LIGHTING_MIN&t;0 /* 0=Bright 1=Med 2=Low */
DECL|macro|LIGHTING_MAX
mdefine_line|#define&t;LIGHTING_MAX&t;2
DECL|variable|lighting
r_static
r_int
id|lighting
op_assign
(paren
id|LIGHTING_MIN
op_plus
id|LIGHTING_MAX
)paren
op_div
l_int|2
suffix:semicolon
multiline_comment|/* Medium */
DECL|macro|SHARPNESS_MIN
mdefine_line|#define SHARPNESS_MIN&t;0
DECL|macro|SHARPNESS_MAX
mdefine_line|#define SHARPNESS_MAX&t;6
DECL|variable|sharpness
r_static
r_int
id|sharpness
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* Low noise, good details */
DECL|macro|FRAMERATE_MIN
mdefine_line|#define FRAMERATE_MIN&t;0
DECL|macro|FRAMERATE_MAX
mdefine_line|#define FRAMERATE_MAX&t;6
DECL|variable|framerate
r_static
r_int
id|framerate
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Lower, reliable frame rate (8-12 fps) */
r_enum
(brace
DECL|enumerator|VIDEOSIZE_128x96
id|VIDEOSIZE_128x96
op_assign
l_int|0
comma
DECL|enumerator|VIDEOSIZE_176x144
id|VIDEOSIZE_176x144
comma
DECL|enumerator|VIDEOSIZE_352x288
id|VIDEOSIZE_352x288
)brace
suffix:semicolon
DECL|variable|videosize
r_static
r_int
id|videosize
op_assign
id|VIDEOSIZE_352x288
suffix:semicolon
multiline_comment|/*&n; * The value of &squot;scratchbufsize&squot; affects quality of the picture&n; * in many ways. Shorter buffers may cause loss of data when client&n; * is too slow. Larger buffers are memory-consuming and take longer&n; * to work with. This setting can be adjusted, but the default value&n; * should be OK for most desktop users.&n; */
DECL|macro|DEFAULT_SCRATCH_BUF_SIZE
mdefine_line|#define DEFAULT_SCRATCH_BUF_SIZE&t;(0x10000)&t;/* 64 KB */
DECL|variable|scratchbufsize
r_static
r_const
r_int
id|scratchbufsize
op_assign
id|DEFAULT_SCRATCH_BUF_SIZE
suffix:semicolon
multiline_comment|/*&n; * Here we define several initialization variables. They may&n; * be used to automatically set color, hue, brightness and&n; * contrast to desired values. This is particularly useful in&n; * case of webcams (which have no controls and no on-screen&n; * output) and also when a client V4L software is used that&n; * does not have some of those controls. In any case it&squot;s&n; * good to have startup values as options.&n; *&n; * These values are all in [0..255] range. This simplifies&n; * operation. Note that actual values of V4L variables may&n; * be scaled up (as much as &lt;&lt; 8). User can see that only&n; * on overlay output, however, or through a V4L client.&n; */
DECL|variable|init_brightness
r_static
r_int
id|init_brightness
op_assign
l_int|128
suffix:semicolon
DECL|variable|init_contrast
r_static
r_int
id|init_contrast
op_assign
l_int|192
suffix:semicolon
DECL|variable|init_color
r_static
r_int
id|init_color
op_assign
l_int|128
suffix:semicolon
DECL|variable|init_hue
r_static
r_int
id|init_hue
op_assign
l_int|128
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|flags
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|framerate
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|lighting
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|sharpness
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|videosize
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|init_brightness
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|init_contrast
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|init_color
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|init_hue
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
(paren
l_string|&quot;module author&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
(paren
l_string|&quot;IBM/Xirlink C-it USB Camera Driver for Linux (c) 2000&quot;
)paren
suffix:semicolon
multiline_comment|/* Still mysterious i2c commands */
DECL|variable|unknown_88
r_static
r_const
r_int
r_int
id|unknown_88
op_assign
l_int|0x0088
suffix:semicolon
DECL|variable|unknown_89
r_static
r_const
r_int
r_int
id|unknown_89
op_assign
l_int|0x0089
suffix:semicolon
DECL|variable|bright_3x
r_static
r_const
r_int
r_int
id|bright_3x
(braket
l_int|3
)braket
op_assign
(brace
l_int|0x0031
comma
l_int|0x0032
comma
l_int|0x0033
)brace
suffix:semicolon
DECL|variable|contrast_14
r_static
r_const
r_int
r_int
id|contrast_14
op_assign
l_int|0x0014
suffix:semicolon
DECL|variable|light_27
r_static
r_const
r_int
r_int
id|light_27
op_assign
l_int|0x0027
suffix:semicolon
DECL|variable|sharp_13
r_static
r_const
r_int
r_int
id|sharp_13
op_assign
l_int|0x0013
suffix:semicolon
multiline_comment|/*******************************/
multiline_comment|/* Memory management functions */
multiline_comment|/*******************************/
DECL|macro|MDEBUG
mdefine_line|#define MDEBUG(x)&t;do { } while(0)&t;&t;/* Debug memory management */
DECL|variable|ibmcam_driver
r_static
r_struct
id|usb_driver
id|ibmcam_driver
suffix:semicolon
multiline_comment|/* Given PGD from the address space&squot;s page table, return the kernel&n; * virtual mapping of the physical memory mapped at ADR.&n; */
DECL|function|uvirt_to_kva
r_static
r_inline
r_int
r_int
id|uvirt_to_kva
c_func
(paren
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|adr
)paren
(brace
r_int
r_int
id|ret
op_assign
l_int|0UL
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|ptep
comma
id|pte
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgd_none
c_func
(paren
op_star
id|pgd
)paren
)paren
(brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|adr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|adr
)paren
suffix:semicolon
id|pte
op_assign
op_star
id|ptep
suffix:semicolon
r_if
c_cond
(paren
id|pte_present
c_func
(paren
id|pte
)paren
)paren
id|ret
op_assign
id|page_address
c_func
(paren
id|pte_page
c_func
(paren
id|pte
)paren
)paren
op_or
(paren
id|adr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
)brace
id|MDEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;uv2kva(%lx--&gt;%lx)&quot;
comma
id|adr
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|uvirt_to_bus
r_static
r_inline
r_int
r_int
id|uvirt_to_bus
c_func
(paren
r_int
r_int
id|adr
)paren
(brace
r_int
r_int
id|kva
comma
id|ret
suffix:semicolon
id|kva
op_assign
id|uvirt_to_kva
c_func
(paren
id|pgd_offset
c_func
(paren
id|current-&gt;mm
comma
id|adr
)paren
comma
id|adr
)paren
suffix:semicolon
id|ret
op_assign
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
id|kva
)paren
suffix:semicolon
id|MDEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;uv2b(%lx--&gt;%lx)&quot;
comma
id|adr
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|kvirt_to_bus
r_static
r_inline
r_int
r_int
id|kvirt_to_bus
c_func
(paren
r_int
r_int
id|adr
)paren
(brace
r_int
r_int
id|va
comma
id|kva
comma
id|ret
suffix:semicolon
id|va
op_assign
id|VMALLOC_VMADDR
c_func
(paren
id|adr
)paren
suffix:semicolon
id|kva
op_assign
id|uvirt_to_kva
c_func
(paren
id|pgd_offset_k
c_func
(paren
id|va
)paren
comma
id|va
)paren
suffix:semicolon
id|ret
op_assign
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
id|kva
)paren
suffix:semicolon
id|MDEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;kv2b(%lx--&gt;%lx)&quot;
comma
id|adr
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Here we want the physical address of the memory.&n; * This is used when initializing the contents of the&n; * area and marking the pages as reserved.&n; */
DECL|function|kvirt_to_pa
r_static
r_inline
r_int
r_int
id|kvirt_to_pa
c_func
(paren
r_int
r_int
id|adr
)paren
(brace
r_int
r_int
id|va
comma
id|kva
comma
id|ret
suffix:semicolon
id|va
op_assign
id|VMALLOC_VMADDR
c_func
(paren
id|adr
)paren
suffix:semicolon
id|kva
op_assign
id|uvirt_to_kva
c_func
(paren
id|pgd_offset_k
c_func
(paren
id|va
)paren
comma
id|va
)paren
suffix:semicolon
id|ret
op_assign
id|__pa
c_func
(paren
id|kva
)paren
suffix:semicolon
id|MDEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;kv2pa(%lx--&gt;%lx)&quot;
comma
id|adr
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|rvmalloc
r_static
r_void
op_star
id|rvmalloc
c_func
(paren
r_int
r_int
id|size
)paren
(brace
r_void
op_star
id|mem
suffix:semicolon
r_int
r_int
id|adr
comma
id|page
suffix:semicolon
multiline_comment|/* Round it off to PAGE_SIZE */
id|size
op_add_assign
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|size
op_and_assign
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|mem
op_assign
id|vmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mem
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|mem
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* Clear the ram out, no junk to the user */
id|adr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|kvirt_to_pa
c_func
(paren
id|adr
)paren
suffix:semicolon
id|mem_map_reserve
c_func
(paren
id|MAP_NR
c_func
(paren
id|__va
c_func
(paren
id|page
)paren
)paren
)paren
suffix:semicolon
id|adr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|PAGE_SIZE
)paren
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
r_else
id|size
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|mem
suffix:semicolon
)brace
DECL|function|rvfree
r_static
r_void
id|rvfree
c_func
(paren
r_void
op_star
id|mem
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|adr
comma
id|page
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mem
)paren
r_return
suffix:semicolon
id|size
op_add_assign
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|size
op_and_assign
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|adr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|kvirt_to_pa
c_func
(paren
id|adr
)paren
suffix:semicolon
id|mem_map_unreserve
c_func
(paren
id|MAP_NR
c_func
(paren
id|__va
c_func
(paren
id|page
)paren
)paren
)paren
suffix:semicolon
id|adr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|PAGE_SIZE
)paren
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
r_else
id|size
op_assign
l_int|0
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|mem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_overlaychar()&n; *&n; * History:&n; * 1/2/00   Created.&n; */
DECL|function|usb_ibmcam_overlaychar
r_void
id|usb_ibmcam_overlaychar
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_struct
id|ibmcam_frame
op_star
id|frame
comma
r_int
id|x
comma
r_int
id|y
comma
r_int
id|ch
)paren
(brace
r_static
r_const
r_int
r_int
id|digits
(braket
l_int|16
)braket
op_assign
(brace
l_int|0xF6DE
comma
multiline_comment|/* 0 */
l_int|0x2492
comma
multiline_comment|/* 1 */
l_int|0xE7CE
comma
multiline_comment|/* 2 */
l_int|0xE79E
comma
multiline_comment|/* 3 */
l_int|0xB792
comma
multiline_comment|/* 4 */
l_int|0xF39E
comma
multiline_comment|/* 5 */
l_int|0xF3DE
comma
multiline_comment|/* 6 */
l_int|0xF492
comma
multiline_comment|/* 7 */
l_int|0xF7DE
comma
multiline_comment|/* 8 */
l_int|0xF79E
comma
multiline_comment|/* 9 */
l_int|0x77DA
comma
multiline_comment|/* a */
l_int|0xD75C
comma
multiline_comment|/* b */
l_int|0xF24E
comma
multiline_comment|/* c */
l_int|0xD6DC
comma
multiline_comment|/* d */
l_int|0xF34E
comma
multiline_comment|/* e */
l_int|0xF348
multiline_comment|/* f */
)brace
suffix:semicolon
r_int
r_int
id|digit
suffix:semicolon
r_int
id|ix
comma
id|iy
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ibmcam
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|frame
op_eq
l_int|NULL
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;0&squot;
op_logical_and
id|ch
op_le
l_char|&squot;9&squot;
)paren
id|ch
op_sub_assign
l_char|&squot;0&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;A&squot;
op_logical_and
id|ch
op_le
l_char|&squot;F&squot;
)paren
id|ch
op_assign
l_int|10
op_plus
(paren
id|ch
op_minus
l_char|&squot;A&squot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;a&squot;
op_logical_and
id|ch
op_le
l_char|&squot;f&squot;
)paren
id|ch
op_assign
l_int|10
op_plus
(paren
id|ch
op_minus
l_char|&squot;a&squot;
)paren
suffix:semicolon
r_else
r_return
suffix:semicolon
id|digit
op_assign
id|digits
(braket
id|ch
)braket
suffix:semicolon
r_for
c_loop
(paren
id|iy
op_assign
l_int|0
suffix:semicolon
id|iy
OL
l_int|5
suffix:semicolon
id|iy
op_increment
)paren
(brace
r_for
c_loop
(paren
id|ix
op_assign
l_int|0
suffix:semicolon
id|ix
OL
l_int|3
suffix:semicolon
id|ix
op_increment
)paren
(brace
r_if
c_cond
(paren
id|digit
op_amp
l_int|0x8000
)paren
(brace
id|IBMCAM_PUTPIXEL
c_func
(paren
id|frame
comma
id|x
op_plus
id|ix
comma
id|y
op_plus
id|iy
comma
l_int|0xFF
comma
l_int|0xFF
comma
l_int|0xFF
)paren
suffix:semicolon
)brace
id|digit
op_assign
id|digit
op_lshift
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * usb_ibmcam_overlaystring()&n; *&n; * History:&n; * 1/2/00   Created.&n; */
DECL|function|usb_ibmcam_overlaystring
r_void
id|usb_ibmcam_overlaystring
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_struct
id|ibmcam_frame
op_star
id|frame
comma
r_int
id|x
comma
r_int
id|y
comma
r_const
r_char
op_star
id|str
)paren
(brace
r_while
c_loop
(paren
op_star
id|str
)paren
(brace
id|usb_ibmcam_overlaychar
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
op_star
id|str
)paren
suffix:semicolon
id|str
op_increment
suffix:semicolon
id|x
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* 3 pixels character + 1 space */
)brace
)brace
multiline_comment|/*&n; * usb_ibmcam_overlaystats()&n; *&n; * Overlays important debugging information.&n; *&n; * History:&n; * 1/2/00   Created.&n; */
DECL|function|usb_ibmcam_overlaystats
r_void
id|usb_ibmcam_overlaystats
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_struct
id|ibmcam_frame
op_star
id|frame
)paren
(brace
r_const
r_int
id|y_diff
op_assign
l_int|8
suffix:semicolon
r_char
id|tmp
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|x
op_assign
l_int|10
suffix:semicolon
r_int
id|y
op_assign
l_int|10
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8x&quot;
comma
id|ibmcam-&gt;frame_num
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|ibmcam-&gt;urb_count
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|ibmcam-&gt;urb_length
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|ibmcam-&gt;data_count
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|ibmcam-&gt;header_count
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|ibmcam-&gt;scratch_ovf_count
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|ibmcam-&gt;iso_skip_count
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|ibmcam-&gt;iso_err_count
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8x&quot;
comma
id|ibmcam-&gt;vpic.colour
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8x&quot;
comma
id|ibmcam-&gt;vpic.hue
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8x&quot;
comma
id|ibmcam-&gt;vpic.brightness
op_rshift
l_int|8
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8x&quot;
comma
id|ibmcam-&gt;vpic.contrast
op_rshift
l_int|12
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8d&quot;
comma
id|ibmcam-&gt;vpic.whiteness
op_rshift
l_int|8
)paren
suffix:semicolon
id|usb_ibmcam_overlaystring
c_func
(paren
id|ibmcam
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_testpattern()&n; *&n; * Procedure forms a test pattern (yellow grid on blue background).&n; *&n; * Parameters:&n; * fullframe:   if TRUE then entire frame is filled, otherwise the procedure&n; *&t;      continues from the current scanline.&n; * pmode&t;0: fill the frame with solid blue color (like on VCR or TV)&n; *&t;      1: Draw a colored grid&n; *&n; * History:&n; * 1/2/00   Created.&n; */
DECL|function|usb_ibmcam_testpattern
r_void
id|usb_ibmcam_testpattern
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
id|fullframe
comma
r_int
id|pmode
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usb_ibmcam_testpattern&quot;
suffix:semicolon
r_struct
id|ibmcam_frame
op_star
id|frame
suffix:semicolon
r_int
r_char
op_star
id|f
suffix:semicolon
r_int
id|num_cell
op_assign
l_int|0
suffix:semicolon
r_int
id|scan_length
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|num_pass
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: ibmcam == NULL&bslash;n&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ibmcam-&gt;curframe
OL
l_int|0
)paren
op_logical_or
(paren
id|ibmcam-&gt;curframe
op_ge
id|IBMCAM_NUMFRAMES
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: ibmcam-&gt;curframe=%d.&bslash;n&quot;
comma
id|proc
comma
id|ibmcam-&gt;curframe
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Grab the current frame */
id|frame
op_assign
op_amp
id|ibmcam-&gt;frame
(braket
id|ibmcam-&gt;curframe
)braket
suffix:semicolon
multiline_comment|/* Optionally start at the beginning */
r_if
c_cond
(paren
id|fullframe
)paren
(brace
id|frame-&gt;curline
op_assign
l_int|0
suffix:semicolon
id|frame-&gt;scanlength
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Form every scan line */
r_for
c_loop
(paren
suffix:semicolon
id|frame-&gt;curline
OL
id|imgheight
suffix:semicolon
id|frame-&gt;curline
op_increment
)paren
(brace
r_int
id|i
suffix:semicolon
id|f
op_assign
id|frame-&gt;data
op_plus
(paren
id|imgwidth
op_star
l_int|3
op_star
id|frame-&gt;curline
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|imgwidth
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|cb
op_assign
l_int|0x80
suffix:semicolon
r_int
r_char
id|cg
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|cr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pmode
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|frame-&gt;curline
op_mod
l_int|32
op_eq
l_int|0
)paren
id|cb
op_assign
l_int|0
comma
id|cg
op_assign
id|cr
op_assign
l_int|0xFF
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
op_mod
l_int|32
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|frame-&gt;curline
op_mod
l_int|32
op_eq
l_int|1
)paren
id|num_cell
op_increment
suffix:semicolon
id|cb
op_assign
l_int|0
comma
id|cg
op_assign
id|cr
op_assign
l_int|0xFF
suffix:semicolon
)brace
r_else
(brace
id|cb
op_assign
(paren
(paren
id|num_cell
op_star
l_int|7
)paren
op_plus
id|num_pass
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|cg
op_assign
(paren
(paren
id|num_cell
op_star
l_int|5
)paren
op_plus
id|num_pass
op_star
l_int|2
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|cr
op_assign
(paren
(paren
id|num_cell
op_star
l_int|3
)paren
op_plus
id|num_pass
op_star
l_int|3
)paren
op_amp
l_int|0xFF
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Just the blue screen */
)brace
op_star
id|f
op_increment
op_assign
id|cb
suffix:semicolon
op_star
id|f
op_increment
op_assign
id|cg
suffix:semicolon
op_star
id|f
op_increment
op_assign
id|cr
suffix:semicolon
id|scan_length
op_add_assign
l_int|3
suffix:semicolon
)brace
)brace
id|frame-&gt;grabstate
op_assign
id|FRAME_DONE
suffix:semicolon
id|frame-&gt;scanlength
op_add_assign
id|scan_length
suffix:semicolon
op_increment
id|num_pass
suffix:semicolon
multiline_comment|/* We do this unconditionally, regardless of FLAGS_OVERLAY_STATS */
id|usb_ibmcam_overlaystats
c_func
(paren
id|ibmcam
comma
id|frame
)paren
suffix:semicolon
)brace
DECL|function|ibmcam_find_header
r_static
r_int
r_char
op_star
id|ibmcam_find_header
c_func
(paren
r_const
r_int
r_char
id|hdr_sig
comma
r_int
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_while
c_loop
(paren
id|len
op_ge
l_int|4
)paren
(brace
r_if
c_cond
(paren
(paren
id|data
(braket
l_int|0
)braket
op_eq
l_int|0x00
)paren
op_logical_and
(paren
id|data
(braket
l_int|1
)braket
op_eq
l_int|0xFF
)paren
op_logical_and
(paren
id|data
(braket
l_int|2
)braket
op_eq
l_int|0x00
)paren
)paren
(brace
macro_line|#if 0
multiline_comment|/* This code helps to detect new frame markers */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Header sig: 00 FF 00 %02X&bslash;n&quot;
comma
id|data
(braket
l_int|3
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data
(braket
l_int|3
)braket
op_eq
id|hdr_sig
)paren
(brace
r_if
c_cond
(paren
id|debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Header found.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
)brace
op_increment
id|data
suffix:semicolon
op_decrement
id|len
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* How much data is left in the scratch buf? */
DECL|macro|scratch_left
mdefine_line|#define scratch_left(x)&t;(ibmcam-&gt;scratchlen - (int)((char *)x - (char *)ibmcam-&gt;scratch))
multiline_comment|/* Grab the remaining */
DECL|function|usb_ibmcam_align_scratch
r_static
r_void
id|usb_ibmcam_align_scratch
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
r_char
op_star
id|data
)paren
(brace
r_int
r_int
id|left
suffix:semicolon
id|left
op_assign
id|scratch_left
c_func
(paren
id|data
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|ibmcam-&gt;scratch
comma
id|data
comma
id|left
)paren
suffix:semicolon
id|ibmcam-&gt;scratchlen
op_assign
id|left
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_find_header()&n; *&n; * Locate one of supported header markers in the scratch buffer.&n; * Once found, remove all preceding bytes AND the marker (4 bytes)&n; * from the scratch buffer. Whatever follows must be video lines.&n; *&n; * History:&n; * 1/21/00  Created.&n; */
DECL|function|usb_ibmcam_find_header
r_static
id|scan_state_t
id|usb_ibmcam_find_header
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_struct
id|ibmcam_frame
op_star
id|frame
suffix:semicolon
r_int
r_char
op_star
id|data
comma
op_star
id|tmp
suffix:semicolon
id|data
op_assign
id|ibmcam-&gt;scratch
suffix:semicolon
id|frame
op_assign
op_amp
id|ibmcam-&gt;frame
(braket
id|ibmcam-&gt;curframe
)braket
suffix:semicolon
id|tmp
op_assign
id|ibmcam_find_header
c_func
(paren
id|frame-&gt;hdr_sig
comma
id|data
comma
id|scratch_left
c_func
(paren
id|data
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* No header - entire scratch buffer is useless! */
r_if
c_cond
(paren
id|debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Skipping frame, no header&bslash;n&quot;
)paren
suffix:semicolon
id|ibmcam-&gt;scratchlen
op_assign
l_int|0
suffix:semicolon
r_return
id|scan_EndParse
suffix:semicolon
)brace
multiline_comment|/* Header found */
id|data
op_assign
id|tmp
op_plus
l_int|4
suffix:semicolon
id|ibmcam-&gt;has_hdr
op_assign
l_int|1
suffix:semicolon
id|ibmcam-&gt;header_count
op_increment
suffix:semicolon
id|frame-&gt;scanstate
op_assign
id|STATE_LINES
suffix:semicolon
id|frame-&gt;curline
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|FLAGS_FORCE_TESTPATTERN
)paren
(brace
id|usb_ibmcam_testpattern
c_func
(paren
id|ibmcam
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
r_return
id|scan_NextFrame
suffix:semicolon
)brace
id|usb_ibmcam_align_scratch
c_func
(paren
id|ibmcam
comma
id|data
)paren
suffix:semicolon
r_return
id|scan_Continue
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_parse_lines()&n; *&n; * Parse one line (TODO: more than one!) from the scratch buffer, put&n; * decoded RGB value into the current frame buffer and add the written&n; * number of bytes (RGB) to the *pcopylen.&n; *&n; * History:&n; * 1/21/00  Created.&n; */
DECL|function|usb_ibmcam_parse_lines
r_static
id|scan_state_t
id|usb_ibmcam_parse_lines
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
op_star
id|pcopylen
)paren
(brace
r_struct
id|ibmcam_frame
op_star
id|frame
suffix:semicolon
r_int
r_char
op_star
id|data
comma
op_star
id|f
comma
op_star
id|chromaLine
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_const
r_int
id|v4l_linesize
op_assign
id|imgwidth
op_star
id|V4L_BYTES_PER_PIXEL
suffix:semicolon
multiline_comment|/* V4L line offset */
r_int
id|y
comma
id|u
comma
id|v
comma
id|i
comma
id|frame_done
op_assign
l_int|0
comma
id|mono_plane
comma
id|hue_corr
comma
id|color_corr
suffix:semicolon
id|hue_corr
op_assign
(paren
id|ibmcam-&gt;vpic.hue
op_minus
l_int|0x8000
)paren
op_rshift
l_int|10
suffix:semicolon
multiline_comment|/* -32..+31 */
id|color_corr
op_assign
(paren
id|ibmcam-&gt;vpic.colour
op_minus
l_int|0x8000
)paren
op_rshift
l_int|10
suffix:semicolon
multiline_comment|/* -32..+31 */
id|data
op_assign
id|ibmcam-&gt;scratch
suffix:semicolon
id|frame
op_assign
op_amp
id|ibmcam-&gt;frame
(braket
id|ibmcam-&gt;curframe
)braket
suffix:semicolon
id|len
op_assign
id|frame-&gt;frmwidth
op_star
l_int|3
suffix:semicolon
multiline_comment|/* 1 line of mono + 1 line of color */
multiline_comment|/*printk(KERN_DEBUG &quot;len=%d. left=%d.&bslash;n&quot;,len,scratch_left(data));*/
id|mono_plane
op_assign
(paren
(paren
id|frame-&gt;curline
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Lines are organized this way (or are they?)&n;&t; *&n;&t; * I420:&n;&t; * ~~~~&n;&t; * ___________________________________&n;&t; * |-----Y-----|---UVUVUV...UVUV-----| &bslash;&n;&t; * |-----------+---------------------|  &bslash;&n;&t; * |&lt;-- 176 --&gt;|&lt;------ 176*2 ------&gt;|  Total 72. pairs of lines&n;&t; * |...&t;   ...&t;     ...|  /&n;&t; * |___________|_____________________| /&n;&t; *  - odd line- ------- even line ---&n;&t; *&n;&t; * another format:&n;&t; * ~~~~~~~~~~~~~~&n;&t; * ___________________________________&n;&t; * |-----Y-----|---UVUVUV...UVUV-----| &bslash;&n;&t; * |-----------+---------------------|  &bslash;&n;&t; * |&lt;-- 352 --&gt;|&lt;------ 352*2 ------&gt;|  Total 144. pairs of lines&n;&t; * |...&t;   ...&t;     ...|  /&n;&t; * |___________|_____________________| /&n;&t; *  - odd line- ------- even line ---&n;&t; */
multiline_comment|/* Make sure there&squot;s enough data for the entire line */
r_if
c_cond
(paren
id|scratch_left
c_func
(paren
id|data
)paren
OL
(paren
id|len
op_plus
l_int|1024
)paren
)paren
(brace
multiline_comment|/*printk(KERN_DEBUG &quot;out of data, need %u.&bslash;n&quot;, len);*/
r_return
id|scan_Out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Make sure that our writing into output buffer&n;&t; * will not exceed the buffer. Mind that we may write&n;&t; * not into current output scanline but in several after&n;&t; * it as well (if we enlarge image vertically.)&n;&t; */
r_if
c_cond
(paren
(paren
id|frame-&gt;curline
op_plus
l_int|1
)paren
op_ge
id|V4L_FRAME_HEIGHT
)paren
r_return
id|scan_NextFrame
suffix:semicolon
multiline_comment|/*&n;&t; * Now we are sure that entire line (representing all &squot;frame-&gt;frmwidth&squot;&n;&t; * pixels from the camera) is available in the scratch buffer. We&n;&t; * start copying the line left-aligned to the V4L buffer (which&n;&t; * might be larger - not smaller, hopefully). If the camera&n;&t; * line is shorter then we should pad the V4L buffer with something&n;&t; * (black in this case) to complete the line.&n;&t; */
id|f
op_assign
id|frame-&gt;data
op_plus
(paren
id|v4l_linesize
op_star
id|frame-&gt;curline
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * chromaLine points to 1st pixel of the line with chrominance.&n;&t; * If current line is monochrome then chromaLine points to next&n;&t; * line after monochrome one. If current line has chrominance&n;&t; * then chromaLine points to this very line. Such method allows&n;&t; * to access chrominance data uniformly.&n;&t; *&n;&t; * To obtain chrominance data from the &squot;chromaLine&squot; use this:&n;&t; *   v = chromaLine[0]; // 0-1:[0], 2-3:[4], 4-5:[8]...&n;&t; *   u = chromaLine[2]; // 0-1:[2], 2-3:[6], 4-5:[10]...&n;&t; *&n;&t; * Indices must be calculated this way:&n;&t; * v_index = (i &gt;&gt; 1) &lt;&lt; 2;&n;&t; * u_index = (i &gt;&gt; 1) &lt;&lt; 2 + 2;&n;&t; *&n;&t; * where &squot;i&squot; is the column number [0..frame-&gt;frmwidth-1]&n;&t; */
id|chromaLine
op_assign
id|data
suffix:semicolon
r_if
c_cond
(paren
id|mono_plane
)paren
id|chromaLine
op_add_assign
id|frame-&gt;frmwidth
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|frame-&gt;frmwidth
suffix:semicolon
id|i
op_increment
comma
id|data
op_add_assign
(paren
id|mono_plane
ques
c_cond
l_int|1
suffix:colon
l_int|2
)paren
)paren
(brace
r_int
r_char
id|rv
comma
id|gv
comma
id|bv
suffix:semicolon
multiline_comment|/* RGB components */
multiline_comment|/*&n;&t;&t; * Search for potential Start-Of-Frame marker. It should&n;&t;&t; * not be here, of course, but if your formats don&squot;t match&n;&t;&t; * you might exceed the frame. We must match the marker to&n;&t;&t; * each byte of multi-byte data element if it is multi-byte.&n;&t;&t; */
macro_line|#if 1
r_if
c_cond
(paren
id|scratch_left
c_func
(paren
id|data
)paren
op_ge
(paren
l_int|4
op_plus
l_int|2
)paren
)paren
(brace
r_int
r_char
op_star
id|dp
suffix:semicolon
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
comma
id|dp
op_assign
id|data
suffix:semicolon
id|j
OL
l_int|2
suffix:semicolon
id|j
op_increment
comma
id|dp
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|dp
(braket
l_int|0
)braket
op_eq
l_int|0x00
)paren
op_logical_and
(paren
id|dp
(braket
l_int|1
)braket
op_eq
l_int|0xFF
)paren
op_logical_and
(paren
id|dp
(braket
l_int|2
)braket
op_eq
l_int|0x00
)paren
op_logical_and
(paren
id|dp
(braket
l_int|3
)braket
op_eq
id|frame-&gt;hdr_sig
)paren
)paren
(brace
id|ibmcam-&gt;has_hdr
op_assign
l_int|2
suffix:semicolon
id|frame_done
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/* Check for various visual debugging hints (colorized pixels) */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|FLAGS_DISPLAY_HINTS
)paren
op_logical_and
(paren
id|ibmcam-&gt;has_hdr
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This is bad and should not happen. This means that&n;&t;&t;&t; * we somehow overshoot the line and encountered new&n;&t;&t;&t; * frame! Obviously our camera/V4L frame size is out&n;&t;&t;&t; * of whack. This cyan dot will help you to figure&n;&t;&t;&t; * out where exactly the new frame arrived.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ibmcam-&gt;has_hdr
op_eq
l_int|1
)paren
(brace
id|bv
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Yellow marker */
id|gv
op_assign
l_int|0xFF
suffix:semicolon
id|rv
op_assign
l_int|0xFF
suffix:semicolon
)brace
r_else
(brace
id|bv
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* Cyan marker */
id|gv
op_assign
l_int|0xFF
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
)brace
id|ibmcam-&gt;has_hdr
op_assign
l_int|0
suffix:semicolon
r_goto
id|make_pixel
suffix:semicolon
)brace
id|y
op_assign
id|mono_plane
ques
c_cond
id|data
(braket
l_int|0
)braket
suffix:colon
id|data
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|FLAGS_MONOCHROME
)paren
multiline_comment|/* Use monochrome for debugging */
id|rv
op_assign
id|gv
op_assign
id|bv
op_assign
id|y
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|frame-&gt;order_uv
)paren
(brace
id|u
op_assign
id|chromaLine
(braket
(paren
id|i
op_rshift
l_int|1
)paren
op_lshift
l_int|2
)braket
op_plus
id|hue_corr
suffix:semicolon
id|v
op_assign
id|chromaLine
(braket
(paren
(paren
id|i
op_rshift
l_int|1
)paren
op_lshift
l_int|2
)paren
op_plus
l_int|2
)braket
op_plus
id|color_corr
suffix:semicolon
)brace
r_else
(brace
id|v
op_assign
id|chromaLine
(braket
(paren
id|i
op_rshift
l_int|1
)paren
op_lshift
l_int|2
)braket
op_plus
id|color_corr
suffix:semicolon
id|u
op_assign
id|chromaLine
(braket
(paren
(paren
id|i
op_rshift
l_int|1
)paren
op_lshift
l_int|2
)paren
op_plus
l_int|2
)braket
op_plus
id|hue_corr
suffix:semicolon
)brace
id|YUV_TO_RGB_BY_THE_BOOK
c_func
(paren
id|y
comma
id|u
comma
id|v
comma
id|rv
comma
id|gv
comma
id|bv
)paren
suffix:semicolon
)brace
id|make_pixel
suffix:colon
multiline_comment|/*&n;&t;&t; * The purpose of creating the pixel here, in one,&n;&t;&t; * dedicated place is that we may need to make the&n;&t;&t; * pixel wider and taller than it actually is. This&n;&t;&t; * may be used if camera generates small frames for&n;&t;&t; * sake of frame rate (or any other reason.)&n;&t;&t; *&n;&t;&t; * The output data consists of B, G, R bytes&n;&t;&t; * (in this order).&n;&t;&t; */
macro_line|#if USES_IBMCAM_PUTPIXEL
id|IBMCAM_PUTPIXEL
c_func
(paren
id|frame
comma
id|i
comma
id|frame-&gt;curline
comma
id|rv
comma
id|gv
comma
id|bv
)paren
suffix:semicolon
macro_line|#else
op_star
id|f
op_increment
op_assign
id|bv
suffix:semicolon
op_star
id|f
op_increment
op_assign
id|gv
suffix:semicolon
op_star
id|f
op_increment
op_assign
id|rv
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Typically we do not decide within a legitimate frame&n;&t;&t; * that we want to end the frame. However debugging code&n;&t;&t; * may detect marker of new frame within the data. Then&n;&t;&t; * this condition activates. The &squot;data&squot; pointer is already&n;&t;&t; * pointing at the new marker, so we&squot;d better leave it as is.&n;&t;&t; */
r_if
c_cond
(paren
id|frame_done
)paren
r_break
suffix:semicolon
multiline_comment|/* End scanning of lines */
)brace
multiline_comment|/*&n;&t; * Account for number of bytes that we wrote into output V4L frame.&n;&t; * We do it here, after we are done with the scanline, because we&n;&t; * may fill more than one output scanline if we do vertical&n;&t; * enlargement.&n;&t; */
id|frame-&gt;curline
op_increment
suffix:semicolon
op_star
id|pcopylen
op_add_assign
id|v4l_linesize
suffix:semicolon
id|usb_ibmcam_align_scratch
c_func
(paren
id|ibmcam
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frame_done
op_logical_or
(paren
id|frame-&gt;curline
op_ge
id|frame-&gt;frmheight
)paren
)paren
r_return
id|scan_NextFrame
suffix:semicolon
r_else
r_return
id|scan_Continue
suffix:semicolon
)brace
multiline_comment|/*&n; * ibmcam_parse_data()&n; *&n; * Generic routine to parse the scratch buffer. It employs either&n; * usb_ibmcam_find_header() or usb_ibmcam_parse_lines() to do most&n; * of work.&n; *&n; * History:&n; * 1/21/00  Created.&n; */
DECL|function|ibmcam_parse_data
r_static
r_void
id|ibmcam_parse_data
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_struct
id|ibmcam_frame
op_star
id|frame
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|ibmcam-&gt;scratch
suffix:semicolon
id|scan_state_t
id|newstate
suffix:semicolon
r_int
id|copylen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Grab the current frame and the previous frame */
id|frame
op_assign
op_amp
id|ibmcam-&gt;frame
(braket
id|ibmcam-&gt;curframe
)braket
suffix:semicolon
multiline_comment|/* printk(KERN_DEBUG &quot;parsing %u.&bslash;n&quot;, ibmcam-&gt;scratchlen); */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|newstate
op_assign
id|scan_Out
suffix:semicolon
r_if
c_cond
(paren
id|scratch_left
c_func
(paren
id|data
)paren
)paren
(brace
r_if
c_cond
(paren
id|frame-&gt;scanstate
op_eq
id|STATE_SCANNING
)paren
id|newstate
op_assign
id|usb_ibmcam_find_header
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|frame-&gt;scanstate
op_eq
id|STATE_LINES
)paren
id|newstate
op_assign
id|usb_ibmcam_parse_lines
c_func
(paren
id|ibmcam
comma
op_amp
id|copylen
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newstate
op_eq
id|scan_Continue
)paren
r_continue
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|newstate
op_eq
id|scan_NextFrame
)paren
op_logical_or
(paren
id|newstate
op_eq
id|scan_Out
)paren
)paren
r_break
suffix:semicolon
r_else
r_return
suffix:semicolon
multiline_comment|/* scan_EndParse */
)brace
r_if
c_cond
(paren
id|newstate
op_eq
id|scan_NextFrame
)paren
(brace
id|frame-&gt;grabstate
op_assign
id|FRAME_DONE
suffix:semicolon
id|ibmcam-&gt;curframe
op_assign
op_minus
l_int|1
suffix:semicolon
id|ibmcam-&gt;frame_num
op_increment
suffix:semicolon
multiline_comment|/* Optionally display statistics on the screen */
r_if
c_cond
(paren
id|flags
op_amp
id|FLAGS_OVERLAY_STATS
)paren
id|usb_ibmcam_overlaystats
c_func
(paren
id|ibmcam
comma
id|frame
)paren
suffix:semicolon
multiline_comment|/* This will cause the process to request another frame. */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|frame-&gt;wq
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|frame-&gt;wq
)paren
suffix:semicolon
)brace
multiline_comment|/* Update the frame&squot;s uncompressed length. */
id|frame-&gt;scanlength
op_add_assign
id|copylen
suffix:semicolon
)brace
macro_line|#if ENABLE_HEXDUMP
DECL|function|ibmcam_hexdump
r_static
r_void
id|ibmcam_hexdump
c_func
(paren
r_const
r_int
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_char
id|tmp
(braket
l_int|80
)braket
suffix:semicolon
r_int
id|i
comma
id|k
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|k
op_assign
l_int|0
suffix:semicolon
id|len
OG
l_int|0
suffix:semicolon
id|i
op_increment
comma
id|len
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|i
OG
l_int|0
op_logical_and
(paren
id|i
op_mod
l_int|16
op_eq
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
)brace
id|k
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|tmp
(braket
id|k
)braket
comma
l_string|&quot;%02x &quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Make all of the blocks of data contiguous&n; */
DECL|function|ibmcam_compress_isochronous
r_static
r_int
id|ibmcam_compress_isochronous
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
id|urb_t
op_star
id|urb
)paren
(brace
r_int
r_char
op_star
id|cdata
comma
op_star
id|data
comma
op_star
id|data0
suffix:semicolon
r_int
id|i
comma
id|totlen
op_assign
l_int|0
suffix:semicolon
id|data
op_assign
id|data0
op_assign
id|ibmcam-&gt;scratch
op_plus
id|ibmcam-&gt;scratchlen
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|n
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
suffix:semicolon
r_int
id|st
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
suffix:semicolon
id|cdata
op_assign
id|urb-&gt;transfer_buffer
op_plus
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
suffix:semicolon
multiline_comment|/* Detect and ignore errored packets */
r_if
c_cond
(paren
id|st
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam data error: [%d] len=%d, status=%X&bslash;n&quot;
comma
id|i
comma
id|n
comma
id|st
)paren
suffix:semicolon
)brace
id|ibmcam-&gt;iso_err_count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Detect and ignore empty packets */
r_if
c_cond
(paren
id|n
op_le
l_int|0
)paren
(brace
id|ibmcam-&gt;iso_skip_count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If camera continues to feed us with data but there is no&n;&t;&t; * consumption (if, for example, V4L client fell asleep) we&n;&t;&t; * may overflow the buffer. We have to move old data over to&n;&t;&t; * free room for new data. This is bad for old data. If we&n;&t;&t; * just drop new data then it&squot;s bad for new data... choose&n;&t;&t; * your favorite evil here.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ibmcam-&gt;scratchlen
op_plus
id|n
)paren
OG
id|scratchbufsize
)paren
(brace
macro_line|#if 0
id|ibmcam-&gt;scratch_ovf_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_ge
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam: scratch buf overflow! &quot;
l_string|&quot;scr_len: %d, n: %d&bslash;n&quot;
comma
id|ibmcam-&gt;scratchlen
comma
id|n
)paren
suffix:semicolon
r_return
id|totlen
suffix:semicolon
macro_line|#else
r_int
id|mv
suffix:semicolon
id|ibmcam-&gt;scratch_ovf_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_ge
l_int|3
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam: scratch buf overflow! &quot;
l_string|&quot;scr_len: %d, n: %d&bslash;n&quot;
comma
id|ibmcam-&gt;scratchlen
comma
id|n
)paren
suffix:semicolon
)brace
id|mv
op_assign
(paren
id|ibmcam-&gt;scratchlen
op_plus
id|n
)paren
op_minus
id|scratchbufsize
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;scratchlen
op_ge
id|mv
)paren
(brace
r_int
id|newslen
op_assign
id|ibmcam-&gt;scratchlen
op_minus
id|mv
suffix:semicolon
id|memmove
c_func
(paren
id|ibmcam-&gt;scratch
comma
id|ibmcam-&gt;scratch
op_plus
id|mv
comma
id|newslen
)paren
suffix:semicolon
id|ibmcam-&gt;scratchlen
op_assign
id|newslen
suffix:semicolon
id|data
op_assign
id|data0
op_assign
id|ibmcam-&gt;scratch
op_plus
id|ibmcam-&gt;scratchlen
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam: scratch buf too small&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|totlen
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/* Now we know that there is enough room in scratch buffer */
id|memmove
c_func
(paren
id|data
comma
id|cdata
comma
id|n
)paren
suffix:semicolon
id|data
op_add_assign
id|n
suffix:semicolon
id|totlen
op_add_assign
id|n
suffix:semicolon
id|ibmcam-&gt;scratchlen
op_add_assign
id|n
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|totlen
OG
l_int|0
)paren
(brace
r_static
r_int
id|foo
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|foo
OL
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;+%d.&bslash;n&quot;
comma
id|totlen
)paren
suffix:semicolon
id|ibmcam_hexdump
c_func
(paren
id|data0
comma
(paren
id|totlen
OG
l_int|64
)paren
ques
c_cond
l_int|64
suffix:colon
id|totlen
)paren
suffix:semicolon
op_increment
id|foo
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
id|totlen
suffix:semicolon
)brace
DECL|function|ibmcam_isoc_irq
r_static
r_void
id|ibmcam_isoc_irq
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
id|urb-&gt;context
suffix:semicolon
r_struct
id|ibmcam_sbuf
op_star
id|sbuf
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* We don&squot;t want to do anything if we are about to be removed! */
r_if
c_cond
(paren
id|ibmcam-&gt;remove_pending
)paren
r_return
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|urb-&gt;actual_length
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam_isoc_irq: %p status %d, &quot;
l_string|&quot; errcount = %d, length = %d&bslash;n&quot;
comma
id|urb
comma
id|urb-&gt;status
comma
id|urb-&gt;error_count
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
)brace
r_else
(brace
r_static
r_int
id|c
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|c
op_increment
op_mod
l_int|100
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam_isoc_irq: no data&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|ibmcam-&gt;streaming
)paren
(brace
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam: oops, not streaming, but interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sbuf
op_assign
op_amp
id|ibmcam-&gt;sbuf
(braket
id|ibmcam-&gt;cursbuf
)braket
suffix:semicolon
multiline_comment|/* Copy the data received into our scratch buffer */
id|len
op_assign
id|ibmcam_compress_isochronous
c_func
(paren
id|ibmcam
comma
id|urb
)paren
suffix:semicolon
id|ibmcam-&gt;urb_count
op_increment
suffix:semicolon
id|ibmcam-&gt;urb_length
op_assign
id|len
suffix:semicolon
id|ibmcam-&gt;data_count
op_add_assign
id|len
suffix:semicolon
macro_line|#if 0   /* This code prints few initial bytes of ISO data: used to decode markers */
r_if
c_cond
(paren
id|ibmcam-&gt;urb_count
op_mod
l_int|64
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|ibmcam-&gt;urb_count
op_eq
l_int|1
)paren
(brace
id|ibmcam_hexdump
c_func
(paren
id|ibmcam-&gt;scratch
comma
(paren
id|ibmcam-&gt;scratchlen
OG
l_int|32
)paren
ques
c_cond
l_int|32
suffix:colon
id|ibmcam-&gt;scratchlen
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* If we collected enough data let&squot;s parse! */
r_if
c_cond
(paren
id|ibmcam-&gt;scratchlen
)paren
(brace
multiline_comment|/* If we don&squot;t have a frame we&squot;re current working on, complain */
r_if
c_cond
(paren
id|ibmcam-&gt;curframe
op_ge
l_int|0
)paren
id|ibmcam_parse_data
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam: received data, but no frame available&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FRAMES_PER_DESC
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sbuf-&gt;urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
id|sbuf-&gt;urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Move to the next sbuf */
id|ibmcam-&gt;cursbuf
op_assign
(paren
id|ibmcam-&gt;cursbuf
op_plus
l_int|1
)paren
op_mod
id|IBMCAM_NUMSBUF
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|usb_ibmcam_veio
r_static
r_int
id|usb_ibmcam_veio
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_char
id|req
comma
r_int
r_int
id|value
comma
r_int
r_int
id|index
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usb_ibmcam_veio&quot;
suffix:semicolon
r_int
r_char
id|cp
(braket
l_int|8
)braket
op_assign
(brace
l_int|0xde
comma
l_int|0xad
comma
l_int|0xbe
comma
l_int|0xef
comma
l_int|0xde
comma
l_int|0xad
comma
l_int|0xbe
comma
l_int|0xef
)brace
suffix:semicolon
r_const
r_int
r_int
id|len
op_assign
r_sizeof
(paren
id|cp
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|req
op_eq
l_int|1
)paren
(brace
id|i
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|req
comma
id|USB_DIR_IN
op_or
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_ENDPOINT
comma
id|value
comma
id|index
comma
id|cp
comma
id|len
comma
id|HZ
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;USB =&gt; %02x%02x%02x%02x%02x%02x%02x%02x &quot;
l_string|&quot;(req=$%02x val=$%04x ind=$%04x len=%d.)&bslash;n&quot;
comma
id|cp
(braket
l_int|0
)braket
comma
id|cp
(braket
l_int|1
)braket
comma
id|cp
(braket
l_int|2
)braket
comma
id|cp
(braket
l_int|3
)braket
comma
id|cp
(braket
l_int|4
)braket
comma
id|cp
(braket
l_int|5
)braket
comma
id|cp
(braket
l_int|6
)braket
comma
id|cp
(braket
l_int|7
)braket
comma
id|req
comma
id|value
comma
id|index
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|i
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|req
comma
id|USB_DIR_OUT
op_or
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_ENDPOINT
comma
id|value
comma
id|index
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: ERROR=%d.&bslash;n&quot;
comma
id|proc
comma
id|i
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_calculate_fps()&n; *&n; * This procedure roughly calculates the real frame rate based&n; * on FPS code (framerate=NNN option). Actual FPS differs&n; * slightly depending on lighting conditions, so that actual frame&n; * rate is determined by the camera. Since I don&squot;t know how to ask&n; * the camera what FPS is now I have to use the FPS code instead.&n; *&n; * The FPS code is in range [0..6], 0 is slowest, 6 is fastest.&n; * Corresponding real FPS should be in range [3..30] frames per second.&n; * The conversion formula is obvious:&n; *&n; * real_fps = 3 + (fps_code * 4.5)&n; *&n; * History:&n; * 1/18/00  Created.&n; */
DECL|function|usb_ibmcam_calculate_fps
r_static
r_int
id|usb_ibmcam_calculate_fps
c_func
(paren
r_void
)paren
(brace
r_return
l_int|3
op_plus
id|framerate
op_star
l_int|4
op_plus
id|framerate
op_div
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_send_FF_04_02()&n; *&n; * This procedure sends magic 3-command prefix to the camera.&n; * The purpose of this prefix is not known.&n; *&n; * History:&n; * 1/2/00   Created.&n; */
DECL|function|usb_ibmcam_send_FF_04_02
r_static
r_void
id|usb_ibmcam_send_FF_04_02
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x00FF
comma
l_int|0x0127
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0004
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0002
comma
l_int|0x0124
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_send_00_04_06
r_static
r_void
id|usb_ibmcam_send_00_04_06
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0127
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0004
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0006
comma
l_int|0x0124
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_send_x_00
r_static
r_void
id|usb_ibmcam_send_x_00
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|x
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
id|x
comma
l_int|0x0127
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0124
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_send_x_00_05
r_static
r_void
id|usb_ibmcam_send_x_00_05
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|x
)paren
(brace
id|usb_ibmcam_send_x_00
c_func
(paren
id|dev
comma
id|x
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0005
comma
l_int|0x0124
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_send_x_00_05_02
r_static
r_void
id|usb_ibmcam_send_x_00_05_02
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|x
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
id|x
comma
l_int|0x0127
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0005
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0002
comma
l_int|0x0124
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_send_x_01_00_05
r_static
r_void
id|usb_ibmcam_send_x_01_00_05
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|x
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
id|x
comma
l_int|0x0127
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0001
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0005
comma
l_int|0x0124
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_send_x_00_05_02_01
r_static
r_void
id|usb_ibmcam_send_x_00_05_02_01
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|x
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
id|x
comma
l_int|0x0127
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0005
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0002
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0001
comma
l_int|0x0124
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_send_x_00_05_02_08_01
r_static
r_void
id|usb_ibmcam_send_x_00_05_02_08_01
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|x
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
id|x
comma
l_int|0x0127
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0000
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0005
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0002
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0008
comma
l_int|0x0124
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0001
comma
l_int|0x0124
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_Packet_Format1
r_static
r_void
id|usb_ibmcam_Packet_Format1
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_char
id|fkey
comma
r_int
r_char
id|val
)paren
(brace
id|usb_ibmcam_send_x_01_00_05
(paren
id|dev
comma
id|unknown_88
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05
(paren
id|dev
comma
id|fkey
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05_02_08_01
c_func
(paren
id|dev
comma
id|val
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05
(paren
id|dev
comma
id|unknown_88
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05_02_01
(paren
id|dev
comma
id|fkey
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05
(paren
id|dev
comma
id|unknown_89
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00
(paren
id|dev
comma
id|fkey
)paren
suffix:semicolon
id|usb_ibmcam_send_00_04_06
(paren
id|dev
)paren
suffix:semicolon
id|usb_ibmcam_veio
(paren
id|dev
comma
l_int|1
comma
l_int|0x0000
comma
l_int|0x0126
)paren
suffix:semicolon
id|usb_ibmcam_send_FF_04_02
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_PacketFormat2
r_static
r_void
id|usb_ibmcam_PacketFormat2
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_char
id|fkey
comma
r_int
r_char
id|val
)paren
(brace
id|usb_ibmcam_send_x_01_00_05
(paren
id|dev
comma
id|unknown_88
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05
(paren
id|dev
comma
id|fkey
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05_02
(paren
id|dev
comma
id|val
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_adjust_contrast()&n; *&n; * The contrast value changes from 0 (high contrast) to 15 (low contrast).&n; * This is in reverse to usual order of things (such as TV controls), so&n; * we reverse it again here.&n; *&n; * TODO: we probably don&squot;t need to send the setup 5 times...&n; *&n; * History:&n; * 1/2/00   Created.&n; */
DECL|function|usb_ibmcam_adjust_contrast
r_static
r_void
id|usb_ibmcam_adjust_contrast
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
id|ibmcam-&gt;dev
suffix:semicolon
r_int
r_char
id|new_contrast
op_assign
id|ibmcam-&gt;vpic.contrast
op_rshift
l_int|12
suffix:semicolon
r_const
r_int
id|ntries
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|new_contrast
op_ge
l_int|16
)paren
id|new_contrast
op_assign
l_int|15
suffix:semicolon
id|new_contrast
op_assign
l_int|15
op_minus
id|new_contrast
suffix:semicolon
r_if
c_cond
(paren
id|new_contrast
op_ne
id|ibmcam-&gt;vpic_old.contrast
)paren
(brace
r_int
id|i
suffix:semicolon
id|ibmcam-&gt;vpic_old.contrast
op_assign
id|new_contrast
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
(brace
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
id|contrast_14
comma
id|new_contrast
)paren
suffix:semicolon
id|usb_ibmcam_send_FF_04_02
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*usb_ibmcam_veio(dev, 0, 0x00FF, 0x0127);*/
)brace
)brace
multiline_comment|/*&n; * usb_ibmcam_change_lighting_conditions()&n; *&n; * We have 3 levels of lighting conditions: 0=Bright, 1=Medium, 2=Low.&n; * Low lighting forces slower FPS. Lighting is set as a module parameter.&n; *&n; * History:&n; * 1/5/00   Created.&n; */
DECL|function|usb_ibmcam_change_lighting_conditions
r_static
r_void
id|usb_ibmcam_change_lighting_conditions
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usb_ibmcam_change_lighting_conditions&quot;
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
op_assign
id|ibmcam-&gt;dev
suffix:semicolon
r_const
r_int
id|ntries
op_assign
l_int|5
suffix:semicolon
r_int
id|i
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|lighting
comma
id|LIGHTING_MIN
comma
id|LIGHTING_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Set lighting to %hu.&bslash;n&quot;
comma
id|proc
comma
id|lighting
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
id|light_27
comma
(paren
r_int
r_int
)paren
id|lighting
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_set_sharpness
r_static
r_void
id|usb_ibmcam_set_sharpness
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usb_ibmcam_set_sharpness&quot;
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
op_assign
id|ibmcam-&gt;dev
suffix:semicolon
r_static
r_const
r_int
r_int
id|sa
(braket
)braket
op_assign
(brace
l_int|0x11
comma
l_int|0x13
comma
l_int|0x16
comma
l_int|0x18
comma
l_int|0x1a
comma
l_int|0x8
comma
l_int|0x0a
)brace
suffix:semicolon
r_int
r_int
id|i
comma
id|sv
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|sharpness
comma
id|SHARPNESS_MIN
comma
id|SHARPNESS_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Set sharpness to %hu.&bslash;n&quot;
comma
id|proc
comma
id|sharpness
)paren
suffix:semicolon
id|sv
op_assign
id|sa
(braket
id|sharpness
op_minus
id|SHARPNESS_MIN
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|usb_ibmcam_send_x_01_00_05
(paren
id|dev
comma
id|unknown_88
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05
(paren
id|dev
comma
id|sharp_13
)paren
suffix:semicolon
id|usb_ibmcam_send_x_00_05_02
(paren
id|dev
comma
id|sv
)paren
suffix:semicolon
)brace
)brace
DECL|function|usb_ibmcam_set_brightness
r_static
r_void
id|usb_ibmcam_set_brightness
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usb_ibmcam_set_brightness&quot;
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
op_assign
id|ibmcam-&gt;dev
suffix:semicolon
r_static
r_const
r_int
r_int
id|n
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|i
comma
id|j
comma
id|bv
(braket
l_int|3
)braket
suffix:semicolon
id|bv
(braket
l_int|0
)braket
op_assign
id|bv
(braket
l_int|1
)braket
op_assign
id|bv
(braket
l_int|2
)braket
op_assign
id|ibmcam-&gt;vpic.brightness
op_rshift
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|bv
(braket
l_int|0
)braket
op_eq
(paren
id|ibmcam-&gt;vpic_old.brightness
op_rshift
l_int|10
)paren
)paren
r_return
suffix:semicolon
id|ibmcam-&gt;vpic_old.brightness
op_assign
id|ibmcam-&gt;vpic.brightness
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Set brightness to (%hu,%hu,%hu)&bslash;n&quot;
comma
id|proc
comma
id|bv
(braket
l_int|0
)braket
comma
id|bv
(braket
l_int|1
)braket
comma
id|bv
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|3
suffix:semicolon
id|j
op_increment
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
id|bright_3x
(braket
id|j
)braket
comma
id|bv
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_adjust_picture
r_static
r_void
id|usb_ibmcam_adjust_picture
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
id|usb_ibmcam_adjust_contrast
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
id|usb_ibmcam_set_brightness
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_setup
r_static
r_int
id|usb_ibmcam_setup
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
id|ibmcam-&gt;dev
suffix:semicolon
r_const
r_int
id|ntries
op_assign
l_int|5
suffix:semicolon
r_int
id|i
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|1
comma
l_int|0
comma
l_int|0x128
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|1
comma
l_int|0x00
comma
l_int|0x0100
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x01
comma
l_int|0x0100
)paren
suffix:semicolon
multiline_comment|/* LED On  */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|1
comma
l_int|0x00
comma
l_int|0x0100
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x81
comma
l_int|0x0100
)paren
suffix:semicolon
multiline_comment|/* LED Off */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|1
comma
l_int|0x00
comma
l_int|0x0100
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x01
comma
l_int|0x0100
)paren
suffix:semicolon
multiline_comment|/* LED On  */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x01
comma
l_int|0x0108
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x03
comma
l_int|0x0112
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|1
comma
l_int|0x00
comma
l_int|0x0115
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x06
comma
l_int|0x0115
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|1
comma
l_int|0x00
comma
l_int|0x0116
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x44
comma
l_int|0x0116
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|1
comma
l_int|0x00
comma
l_int|0x0116
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x40
comma
l_int|0x0116
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|1
comma
l_int|0x00
comma
l_int|0x0115
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0e
comma
l_int|0x0115
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x19
comma
l_int|0x012c
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x00
comma
l_int|0x1e
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x39
comma
l_int|0x0d
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x39
comma
l_int|0x09
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x3b
comma
l_int|0x00
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x28
comma
l_int|0x22
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
id|light_27
comma
l_int|0
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x2b
comma
l_int|0x1f
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x39
comma
l_int|0x08
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x2c
comma
l_int|0x00
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x30
comma
l_int|0x14
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x39
comma
l_int|0x02
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x01
comma
l_int|0xe1
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x02
comma
l_int|0xcd
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x03
comma
l_int|0xcd
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x04
comma
l_int|0xfa
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x3f
comma
l_int|0xff
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x39
comma
l_int|0x00
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x39
comma
l_int|0x02
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x0a
comma
l_int|0x37
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x0b
comma
l_int|0xb8
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x0c
comma
l_int|0xf3
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x0d
comma
l_int|0xe3
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x0e
comma
l_int|0x0d
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x0f
comma
l_int|0xf2
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x10
comma
l_int|0xd5
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x11
comma
l_int|0xba
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x12
comma
l_int|0x53
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x3f
comma
l_int|0xff
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x39
comma
l_int|0x00
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x39
comma
l_int|0x02
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x16
comma
l_int|0x00
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x17
comma
l_int|0x28
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x18
comma
l_int|0x7d
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x19
comma
l_int|0xbe
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x3f
comma
l_int|0xff
)paren
suffix:semicolon
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
l_int|0x39
comma
l_int|0x00
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x00
comma
l_int|0x18
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x13
comma
l_int|0x18
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x14
comma
l_int|0x06
)paren
suffix:semicolon
multiline_comment|/* This is default brightness */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x31
comma
l_int|0x37
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x32
comma
l_int|0x46
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x33
comma
l_int|0x55
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x2e
comma
l_int|0x04
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x2d
comma
l_int|0x04
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x29
comma
l_int|0x80
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x2c
comma
l_int|0x01
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x30
comma
l_int|0x17
)paren
suffix:semicolon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x39
comma
l_int|0x08
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x34
comma
l_int|0x00
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x0101
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x010a
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|videosize
)paren
(brace
r_case
id|VIDEOSIZE_128x96
suffix:colon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x80
comma
l_int|0x0103
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x60
comma
l_int|0x0105
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0c
comma
l_int|0x010b
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x04
comma
l_int|0x011b
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0b
comma
l_int|0x011d
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x011e
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x0129
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_176x144
suffix:colon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0xb0
comma
l_int|0x0103
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x8f
comma
l_int|0x0105
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x06
comma
l_int|0x010b
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x04
comma
l_int|0x011b
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x0d
comma
l_int|0x011d
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x011e
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x03
comma
l_int|0x0129
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_352x288
suffix:colon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0xb0
comma
l_int|0x0103
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x90
comma
l_int|0x0105
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x02
comma
l_int|0x010b
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x04
comma
l_int|0x011b
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x05
comma
l_int|0x011d
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x011e
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x0129
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0xff
comma
l_int|0x012b
)paren
suffix:semicolon
multiline_comment|/* This is another brightness - don&squot;t know why */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x31
comma
l_int|0xc3
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x32
comma
l_int|0xd2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x33
comma
l_int|0xe1
)paren
suffix:semicolon
multiline_comment|/* Default contrast */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ntries
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
id|contrast_14
comma
l_int|0x0a
)paren
suffix:semicolon
multiline_comment|/* Default sharpness */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|usb_ibmcam_PacketFormat2
c_func
(paren
id|dev
comma
id|sharp_13
comma
l_int|0x1a
)paren
suffix:semicolon
multiline_comment|/* Level 4 FIXME */
multiline_comment|/* Default lighting conditions */
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
id|light_27
comma
id|lighting
)paren
suffix:semicolon
multiline_comment|/* 0=Bright 2=Low */
multiline_comment|/* Assorted init */
r_switch
c_cond
(paren
id|videosize
)paren
(brace
r_case
id|VIDEOSIZE_128x96
suffix:colon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x2b
comma
l_int|0x1e
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0xc9
comma
l_int|0x0119
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x80
comma
l_int|0x0109
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x36
comma
l_int|0x0102
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x1a
comma
l_int|0x0104
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x04
comma
l_int|0x011a
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x2b
comma
l_int|0x011c
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x23
comma
l_int|0x012a
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
macro_line|#if 0
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x0106
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x38
comma
l_int|0x0107
)paren
suffix:semicolon
macro_line|#else
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x02
comma
l_int|0x0106
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x2a
comma
l_int|0x0107
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_176x144
suffix:colon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x2b
comma
l_int|0x1e
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0xc9
comma
l_int|0x0119
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x80
comma
l_int|0x0109
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x04
comma
l_int|0x0102
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x02
comma
l_int|0x0104
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x04
comma
l_int|0x011a
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x2b
comma
l_int|0x011c
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x23
comma
l_int|0x012a
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x01
comma
l_int|0x0106
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0xca
comma
l_int|0x0107
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_352x288
suffix:colon
id|usb_ibmcam_Packet_Format1
c_func
(paren
id|dev
comma
l_int|0x2b
comma
l_int|0x1f
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0xc9
comma
l_int|0x0119
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x80
comma
l_int|0x0109
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x08
comma
l_int|0x0102
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x01
comma
l_int|0x0104
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x04
comma
l_int|0x011a
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x2f
comma
l_int|0x011c
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x23
comma
l_int|0x012a
)paren
suffix:semicolon
multiline_comment|/* Same everywhere */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x03
comma
l_int|0x0106
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0xf6
comma
l_int|0x0107
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* TODO: return actual completion status! */
)brace
multiline_comment|/*&n; * usb_ibmcam_setup_after_video_if()&n; *&n; * This code adds finishing touches to the video data interface.&n; * Here we configure the frame rate and turn on the LED.&n; */
DECL|function|usb_ibmcam_setup_after_video_if
r_static
r_void
id|usb_ibmcam_setup_after_video_if
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|internal_frame_rate
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|framerate
comma
id|FRAMERATE_MIN
comma
id|FRAMERATE_MAX
)paren
suffix:semicolon
id|internal_frame_rate
op_assign
id|FRAMERATE_MAX
op_minus
id|framerate
suffix:semicolon
multiline_comment|/* 0=Fast 6=Slow */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x01
comma
l_int|0x0100
)paren
suffix:semicolon
multiline_comment|/* LED On  */
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
id|internal_frame_rate
comma
l_int|0x0111
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x01
comma
l_int|0x0114
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0xc0
comma
l_int|0x010c
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_setup_video_stop()&n; *&n; * This code tells camera to stop streaming. The interface remains&n; * configured and bandwidth - claimed.&n; */
DECL|function|usb_ibmcam_setup_video_stop
r_static
r_void
id|usb_ibmcam_setup_video_stop
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x010c
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x010c
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x01
comma
l_int|0x0114
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0xc0
comma
l_int|0x010c
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x010c
)paren
suffix:semicolon
id|usb_ibmcam_send_FF_04_02
c_func
(paren
id|dev
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|1
comma
l_int|0x00
comma
l_int|0x0100
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0x81
comma
l_int|0x0100
)paren
suffix:semicolon
multiline_comment|/* LED Off */
)brace
multiline_comment|/*&n; * usb_ibmcam_reinit_iso()&n; *&n; * This procedure sends couple of commands to the camera and then&n; * resets the video pipe. This sequence was observed to reinit the&n; * camera or, at least, to initiate ISO data stream.&n; *&n; * History:&n; * 1/2/00   Created.&n; */
DECL|function|usb_ibmcam_reinit_iso
r_static
r_void
id|usb_ibmcam_reinit_iso
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
id|do_stop
)paren
(brace
r_if
c_cond
(paren
id|do_stop
)paren
id|usb_ibmcam_setup_video_stop
c_func
(paren
id|ibmcam-&gt;dev
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam-&gt;dev
comma
l_int|0
comma
l_int|0x0001
comma
l_int|0x0114
)paren
suffix:semicolon
id|usb_ibmcam_veio
c_func
(paren
id|ibmcam-&gt;dev
comma
l_int|0
comma
l_int|0x00c0
comma
l_int|0x010c
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|ibmcam-&gt;dev
comma
id|ibmcam-&gt;video_endp
)paren
suffix:semicolon
id|usb_ibmcam_setup_after_video_if
c_func
(paren
id|ibmcam-&gt;dev
)paren
suffix:semicolon
)brace
DECL|function|ibmcam_init_isoc
r_static
r_int
id|ibmcam_init_isoc
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
id|ibmcam-&gt;dev
suffix:semicolon
id|urb_t
op_star
id|urb
suffix:semicolon
r_int
id|fx
comma
id|err
suffix:semicolon
id|ibmcam-&gt;compress
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;curframe
op_assign
op_minus
l_int|1
suffix:semicolon
id|ibmcam-&gt;cursbuf
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;scratchlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Alternate interface 1 is is the biggest frame size */
r_if
c_cond
(paren
id|usb_set_interface
c_func
(paren
id|ibmcam-&gt;dev
comma
l_int|2
comma
l_int|1
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usb_set_interface error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|usb_ibmcam_change_lighting_conditions
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
id|usb_ibmcam_set_sharpness
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
id|usb_ibmcam_reinit_iso
c_func
(paren
id|ibmcam
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* We double buffer the Iso lists */
id|urb
op_assign
id|usb_alloc_urb
c_func
(paren
id|FRAMES_PER_DESC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam_init_isoc: usb_init_isoc ret %d&bslash;n&quot;
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ibmcam-&gt;sbuf
(braket
l_int|0
)braket
dot
id|urb
op_assign
id|urb
suffix:semicolon
id|urb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|urb-&gt;context
op_assign
id|ibmcam
suffix:semicolon
id|urb-&gt;pipe
op_assign
id|usb_rcvisocpipe
c_func
(paren
id|dev
comma
id|ibmcam-&gt;video_endp
)paren
suffix:semicolon
id|urb-&gt;transfer_flags
op_assign
id|USB_ISO_ASAP
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|ibmcam-&gt;sbuf
(braket
l_int|0
)braket
dot
id|data
suffix:semicolon
id|urb-&gt;complete
op_assign
id|ibmcam_isoc_irq
suffix:semicolon
id|urb-&gt;number_of_packets
op_assign
id|FRAMES_PER_DESC
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|ibmcam-&gt;iso_packet_len
op_star
id|FRAMES_PER_DESC
suffix:semicolon
r_for
c_loop
(paren
id|fx
op_assign
l_int|0
suffix:semicolon
id|fx
OL
id|FRAMES_PER_DESC
suffix:semicolon
id|fx
op_increment
)paren
(brace
id|urb-&gt;iso_frame_desc
(braket
id|fx
)braket
dot
id|offset
op_assign
id|ibmcam-&gt;iso_packet_len
op_star
id|fx
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|fx
)braket
dot
id|length
op_assign
id|ibmcam-&gt;iso_packet_len
suffix:semicolon
)brace
id|urb
op_assign
id|usb_alloc_urb
c_func
(paren
id|FRAMES_PER_DESC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam_init_isoc: usb_init_isoc ret %d&bslash;n&quot;
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ibmcam-&gt;sbuf
(braket
l_int|1
)braket
dot
id|urb
op_assign
id|urb
suffix:semicolon
id|urb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|urb-&gt;context
op_assign
id|ibmcam
suffix:semicolon
id|urb-&gt;pipe
op_assign
id|usb_rcvisocpipe
c_func
(paren
id|dev
comma
id|ibmcam-&gt;video_endp
)paren
suffix:semicolon
id|urb-&gt;transfer_flags
op_assign
id|USB_ISO_ASAP
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|ibmcam-&gt;sbuf
(braket
l_int|1
)braket
dot
id|data
suffix:semicolon
id|urb-&gt;complete
op_assign
id|ibmcam_isoc_irq
suffix:semicolon
id|urb-&gt;number_of_packets
op_assign
id|FRAMES_PER_DESC
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|ibmcam-&gt;iso_packet_len
op_star
id|FRAMES_PER_DESC
suffix:semicolon
r_for
c_loop
(paren
id|fx
op_assign
l_int|0
suffix:semicolon
id|fx
OL
id|FRAMES_PER_DESC
suffix:semicolon
id|fx
op_increment
)paren
(brace
id|urb-&gt;iso_frame_desc
(braket
id|fx
)braket
dot
id|offset
op_assign
id|ibmcam-&gt;iso_packet_len
op_star
id|fx
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|fx
)braket
dot
id|length
op_assign
id|ibmcam-&gt;iso_packet_len
suffix:semicolon
)brace
id|ibmcam-&gt;sbuf
(braket
l_int|1
)braket
dot
id|urb-&gt;next
op_assign
id|ibmcam-&gt;sbuf
(braket
l_int|0
)braket
dot
id|urb
suffix:semicolon
id|ibmcam-&gt;sbuf
(braket
l_int|0
)braket
dot
id|urb-&gt;next
op_assign
id|ibmcam-&gt;sbuf
(braket
l_int|1
)braket
dot
id|urb
suffix:semicolon
id|err
op_assign
id|usb_submit_urb
c_func
(paren
id|ibmcam-&gt;sbuf
(braket
l_int|0
)braket
dot
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam_init_isoc: usb_run_isoc(0) ret %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
id|err
op_assign
id|usb_submit_urb
c_func
(paren
id|ibmcam-&gt;sbuf
(braket
l_int|1
)braket
dot
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam_init_isoc: usb_run_isoc(1) ret %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
id|ibmcam-&gt;streaming
op_assign
l_int|1
suffix:semicolon
singleline_comment|// printk(KERN_DEBUG &quot;streaming=1 ibmcam-&gt;video_endp=$%02x&bslash;n&quot;, ibmcam-&gt;video_endp);
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * ibmcam_stop_isoc()&n; *&n; * This procedure stops streaming and deallocates URBs. Then it&n; * activates zero-bandwidth alt. setting of the video interface.&n; *&n; * History:&n; * 1/22/00  Corrected order of actions to work after surprise removal.&n; */
DECL|function|ibmcam_stop_isoc
r_static
r_void
id|ibmcam_stop_isoc
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ibmcam-&gt;streaming
)paren
r_return
suffix:semicolon
multiline_comment|/* Unschedule all of the iso td&squot;s */
id|usb_unlink_urb
c_func
(paren
id|ibmcam-&gt;sbuf
(braket
l_int|1
)braket
dot
id|urb
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|ibmcam-&gt;sbuf
(braket
l_int|0
)braket
dot
id|urb
)paren
suffix:semicolon
multiline_comment|/* printk(KERN_DEBUG &quot;streaming=0&bslash;n&quot;); */
id|ibmcam-&gt;streaming
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Delete them all */
id|usb_free_urb
c_func
(paren
id|ibmcam-&gt;sbuf
(braket
l_int|1
)braket
dot
id|urb
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|ibmcam-&gt;sbuf
(braket
l_int|0
)braket
dot
id|urb
)paren
suffix:semicolon
id|usb_ibmcam_setup_video_stop
c_func
(paren
id|ibmcam-&gt;dev
)paren
suffix:semicolon
multiline_comment|/* Set packet size to 0 */
r_if
c_cond
(paren
id|usb_set_interface
c_func
(paren
id|ibmcam-&gt;dev
comma
l_int|2
comma
l_int|0
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usb_set_interface error&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|ibmcam_new_frame
r_static
r_int
id|ibmcam_new_frame
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
comma
r_int
id|framenum
)paren
(brace
r_struct
id|ibmcam_frame
op_star
id|frame
suffix:semicolon
r_int
id|n
comma
id|width
comma
id|height
suffix:semicolon
multiline_comment|/* If we&squot;re not grabbing a frame right now and the other frame is */
multiline_comment|/*  ready to be grabbed into, then use it instead */
r_if
c_cond
(paren
id|ibmcam-&gt;curframe
op_ne
op_minus
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
id|n
op_assign
(paren
id|framenum
op_minus
l_int|1
op_plus
id|IBMCAM_NUMFRAMES
)paren
op_mod
id|IBMCAM_NUMFRAMES
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;frame
(braket
id|n
)braket
dot
id|grabstate
op_eq
id|FRAME_READY
)paren
id|framenum
op_assign
id|n
suffix:semicolon
id|frame
op_assign
op_amp
id|ibmcam-&gt;frame
(braket
id|framenum
)braket
suffix:semicolon
id|frame-&gt;grabstate
op_assign
id|FRAME_GRABBING
suffix:semicolon
id|frame-&gt;scanstate
op_assign
id|STATE_SCANNING
suffix:semicolon
id|frame-&gt;scanlength
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Accumulated in ibmcam_parse_data() */
id|ibmcam-&gt;curframe
op_assign
id|framenum
suffix:semicolon
macro_line|#if 0
multiline_comment|/* This provides a &quot;clean&quot; frame but slows things down */
id|memset
c_func
(paren
id|frame-&gt;data
comma
l_int|0
comma
id|MAX_FRAME_SIZE
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|videosize
)paren
(brace
r_case
id|VIDEOSIZE_128x96
suffix:colon
id|frame-&gt;frmwidth
op_assign
l_int|128
suffix:semicolon
id|frame-&gt;frmheight
op_assign
l_int|96
suffix:semicolon
id|frame-&gt;order_uv
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* U Y V Y ... */
id|frame-&gt;hdr_sig
op_assign
l_int|0x06
suffix:semicolon
multiline_comment|/* 00 FF 00 06 */
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_176x144
suffix:colon
id|frame-&gt;frmwidth
op_assign
l_int|176
suffix:semicolon
id|frame-&gt;frmheight
op_assign
l_int|144
suffix:semicolon
id|frame-&gt;order_uv
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* U Y V Y ... */
id|frame-&gt;hdr_sig
op_assign
l_int|0x0E
suffix:semicolon
multiline_comment|/* 00 FF 00 0E */
r_break
suffix:semicolon
r_case
id|VIDEOSIZE_352x288
suffix:colon
id|frame-&gt;frmwidth
op_assign
l_int|352
suffix:semicolon
id|frame-&gt;frmheight
op_assign
l_int|288
suffix:semicolon
id|frame-&gt;order_uv
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* V Y U Y ... */
id|frame-&gt;hdr_sig
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* 00 FF 00 00 */
r_break
suffix:semicolon
)brace
id|width
op_assign
id|frame-&gt;width
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|width
comma
id|min_imgwidth
comma
id|imgwidth
)paren
suffix:semicolon
id|width
op_and_assign
op_complement
l_int|7
suffix:semicolon
multiline_comment|/* Multiple of 8 */
id|height
op_assign
id|frame-&gt;height
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|height
comma
id|min_imgheight
comma
id|imgheight
)paren
suffix:semicolon
id|height
op_and_assign
op_complement
l_int|3
suffix:semicolon
multiline_comment|/* Multiple of 4 */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * ibmcam_open()&n; *&n; * This is part of Video 4 Linux API. The driver can be opened by one&n; * client only (checks internal counter &squot;ibmcam-&gt;user&squot;). The procedure&n; * then allocates buffers needed for video processing.&n; *&n; * History:&n; * 1/22/00  Rewrote, moved scratch buffer allocation here. Now the&n; *          camera is also initialized here (once per connect), at&n; *          expense of V4L client (it waits on open() call).&n; */
DECL|function|ibmcam_open
r_static
r_int
id|ibmcam_open
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_int
id|flags
)paren
(brace
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
(paren
r_struct
id|usb_ibmcam
op_star
)paren
id|dev
suffix:semicolon
r_const
r_int
id|nbuffers
op_assign
l_int|2
suffix:semicolon
r_const
r_int
id|sb_size
op_assign
id|FRAMES_PER_DESC
op_star
id|ibmcam-&gt;iso_packet_len
suffix:semicolon
r_int
id|i
comma
id|err
op_assign
l_int|0
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ibmcam-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;user
)paren
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_else
(brace
multiline_comment|/* Clean pointers so we know if we allocated something */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nbuffers
suffix:semicolon
id|i
op_increment
)paren
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Allocate memory for the frame buffers */
id|ibmcam-&gt;fbuf_size
op_assign
id|nbuffers
op_star
id|MAX_FRAME_SIZE
suffix:semicolon
id|ibmcam-&gt;fbuf
op_assign
id|rvmalloc
c_func
(paren
id|ibmcam-&gt;fbuf_size
)paren
suffix:semicolon
id|ibmcam-&gt;scratch
op_assign
id|kmalloc
c_func
(paren
id|scratchbufsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|ibmcam-&gt;scratchlen
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ibmcam-&gt;fbuf
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|ibmcam-&gt;scratch
op_eq
l_int|NULL
)paren
)paren
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_else
(brace
multiline_comment|/* Allocate all buffers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nbuffers
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ibmcam-&gt;frame
(braket
id|i
)braket
dot
id|grabstate
op_assign
id|FRAME_UNUSED
suffix:semicolon
id|ibmcam-&gt;frame
(braket
id|i
)braket
dot
id|data
op_assign
id|ibmcam-&gt;fbuf
op_plus
id|i
op_star
id|MAX_FRAME_SIZE
suffix:semicolon
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_assign
id|kmalloc
c_func
(paren
id|sb_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Set default sizes in case IOCTL (VIDIOCMCAPTURE)&n;&t;&t;&t;&t; * is not used (using read() instead).&n;&t;&t;&t;&t; */
id|ibmcam-&gt;frame
(braket
id|i
)braket
dot
id|width
op_assign
id|imgwidth
suffix:semicolon
id|ibmcam-&gt;frame
(braket
id|i
)braket
dot
id|height
op_assign
id|imgheight
suffix:semicolon
id|ibmcam-&gt;frame
(braket
id|i
)braket
dot
id|bytes_read
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|err
)paren
(brace
multiline_comment|/* Have to free all that memory */
r_if
c_cond
(paren
id|ibmcam-&gt;fbuf
op_ne
l_int|NULL
)paren
(brace
id|rvfree
c_func
(paren
id|ibmcam-&gt;fbuf
comma
id|ibmcam-&gt;fbuf_size
)paren
suffix:semicolon
id|ibmcam-&gt;fbuf
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ibmcam-&gt;scratch
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|ibmcam-&gt;scratch
)paren
suffix:semicolon
id|ibmcam-&gt;scratch
op_assign
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nbuffers
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_ne
l_int|NULL
)paren
(brace
id|kfree
(paren
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|data
)paren
suffix:semicolon
id|ibmcam-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* If so far no errors then we shall start the camera */
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|err
op_assign
id|ibmcam_init_isoc
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
multiline_comment|/* Send init sequence only once, it&squot;s large! */
r_if
c_cond
(paren
op_logical_neg
id|ibmcam-&gt;initialized
)paren
(brace
id|err
op_assign
id|usb_ibmcam_setup
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|ibmcam-&gt;initialized
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|ibmcam-&gt;user
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
)brace
)brace
)brace
id|up
c_func
(paren
op_amp
id|ibmcam-&gt;lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * ibmcam_close()&n; *&n; * This is part of Video 4 Linux API. The procedure&n; * stops streaming and deallocates all buffers that were earlier&n; * allocated in ibmcam_open().&n; *&n; * History:&n; * 1/22/00  Moved scratch buffer deallocation here.&n; */
DECL|function|ibmcam_close
r_static
r_void
id|ibmcam_close
c_func
(paren
r_struct
id|video_device
op_star
id|dev
)paren
(brace
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
(paren
r_struct
id|usb_ibmcam
op_star
)paren
id|dev
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ibmcam-&gt;lock
)paren
suffix:semicolon
id|ibmcam_stop_isoc
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
id|rvfree
c_func
(paren
id|ibmcam-&gt;fbuf
comma
id|ibmcam-&gt;fbuf_size
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ibmcam-&gt;scratch
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ibmcam-&gt;sbuf
(braket
l_int|1
)braket
dot
id|data
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ibmcam-&gt;sbuf
(braket
l_int|0
)braket
dot
id|data
)paren
suffix:semicolon
id|ibmcam-&gt;user
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ibmcam-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|ibmcam_init_done
r_static
r_int
id|ibmcam_init_done
c_func
(paren
r_struct
id|video_device
op_star
id|dev
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ibmcam_write
r_static
r_int
id|ibmcam_write
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|count
comma
r_int
id|noblock
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; * ibmcam_ioctl()&n; *&n; * This is part of Video 4 Linux API. The procedure handles ioctl() calls.&n; *&n; * History:&n; * 1/22/00  Corrected VIDIOCSPICT to reject unsupported settings.&n; */
DECL|function|ibmcam_ioctl
r_static
r_int
id|ibmcam_ioctl
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
(paren
r_struct
id|usb_ibmcam
op_star
)paren
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;remove_pending
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|VIDIOCGCAP
suffix:colon
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ibmcam-&gt;vcap
comma
r_sizeof
(paren
id|ibmcam-&gt;vcap
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGCHAN
suffix:colon
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ibmcam-&gt;vchan
comma
r_sizeof
(paren
id|ibmcam-&gt;vchan
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCSCHAN
suffix:colon
(brace
r_int
id|v
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|v
comma
id|arg
comma
r_sizeof
(paren
id|v
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|v
OL
l_int|0
)paren
op_logical_or
(paren
id|v
op_ge
l_int|3
)paren
)paren
multiline_comment|/* 3 grades of lighting conditions */
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|v
op_ne
id|ibmcam-&gt;vchan.channel
)paren
(brace
id|ibmcam-&gt;vchan.channel
op_assign
id|v
suffix:semicolon
id|usb_ibmcam_change_lighting_conditions
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGPICT
suffix:colon
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ibmcam-&gt;vpic
comma
r_sizeof
(paren
id|ibmcam-&gt;vpic
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCSPICT
suffix:colon
(brace
r_struct
id|video_picture
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Use temporary &squot;video_picture&squot; structure to preserve our&n;&t;&t;&t; * own settings (such as color depth, palette) that we&n;&t;&t;&t; * aren&squot;t allowing everyone (V4L client) to change.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|arg
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ibmcam-&gt;vpic.brightness
op_assign
id|tmp.brightness
suffix:semicolon
id|ibmcam-&gt;vpic.hue
op_assign
id|tmp.hue
suffix:semicolon
id|ibmcam-&gt;vpic.colour
op_assign
id|tmp.colour
suffix:semicolon
id|ibmcam-&gt;vpic.contrast
op_assign
id|tmp.contrast
suffix:semicolon
id|usb_ibmcam_adjust_picture
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCSWIN
suffix:colon
(brace
r_struct
id|video_window
id|vw
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|vw
comma
id|arg
comma
r_sizeof
(paren
id|vw
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|vw.flags
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vw.clipcount
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vw.height
op_ne
id|imgheight
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vw.width
op_ne
id|imgwidth
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ibmcam-&gt;compress
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGWIN
suffix:colon
(brace
r_struct
id|video_window
id|vw
suffix:semicolon
id|vw.x
op_assign
l_int|0
suffix:semicolon
id|vw.y
op_assign
l_int|0
suffix:semicolon
id|vw.width
op_assign
id|imgwidth
suffix:semicolon
id|vw.height
op_assign
id|imgheight
suffix:semicolon
id|vw.chromakey
op_assign
l_int|0
suffix:semicolon
id|vw.flags
op_assign
id|usb_ibmcam_calculate_fps
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|vw
comma
r_sizeof
(paren
id|vw
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGMBUF
suffix:colon
(brace
r_struct
id|video_mbuf
id|vm
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|vm
comma
l_int|0
comma
r_sizeof
(paren
id|vm
)paren
)paren
suffix:semicolon
id|vm.size
op_assign
id|MAX_FRAME_SIZE
op_star
l_int|2
suffix:semicolon
id|vm.frames
op_assign
l_int|2
suffix:semicolon
id|vm.offsets
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|vm.offsets
(braket
l_int|1
)braket
op_assign
id|MAX_FRAME_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
(paren
r_void
op_star
)paren
op_amp
id|vm
comma
r_sizeof
(paren
id|vm
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCMCAPTURE
suffix:colon
(brace
r_struct
id|video_mmap
id|vm
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|vm
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|vm
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;frame: %d, size: %dx%d, format: %d&bslash;n&quot;
comma
id|vm.frame
comma
id|vm.width
comma
id|vm.height
comma
id|vm.format
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vm.format
op_ne
id|VIDEO_PALETTE_RGB24
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vm.frame
op_ne
l_int|0
)paren
op_logical_and
(paren
id|vm.frame
op_ne
l_int|1
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;frame
(braket
id|vm.frame
)braket
dot
id|grabstate
op_eq
id|FRAME_GRABBING
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* Don&squot;t compress if the size changed */
r_if
c_cond
(paren
(paren
id|ibmcam-&gt;frame
(braket
id|vm.frame
)braket
dot
id|width
op_ne
id|vm.width
)paren
op_logical_or
(paren
id|ibmcam-&gt;frame
(braket
id|vm.frame
)braket
dot
id|height
op_ne
id|vm.height
)paren
)paren
id|ibmcam-&gt;compress
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;frame
(braket
id|vm.frame
)braket
dot
id|width
op_assign
id|vm.width
suffix:semicolon
id|ibmcam-&gt;frame
(braket
id|vm.frame
)braket
dot
id|height
op_assign
id|vm.height
suffix:semicolon
multiline_comment|/* Mark it as ready */
id|ibmcam-&gt;frame
(braket
id|vm.frame
)braket
dot
id|grabstate
op_assign
id|FRAME_READY
suffix:semicolon
r_return
id|ibmcam_new_frame
c_func
(paren
id|ibmcam
comma
id|vm.frame
)paren
suffix:semicolon
)brace
r_case
id|VIDIOCSYNC
suffix:colon
(brace
r_int
id|frame
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|frame
comma
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam: syncing to frame %d&bslash;n&quot;
comma
id|frame
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ibmcam-&gt;frame
(braket
id|frame
)braket
dot
id|grabstate
)paren
(brace
r_case
id|FRAME_UNUSED
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|FRAME_READY
suffix:colon
r_case
id|FRAME_GRABBING
suffix:colon
r_case
id|FRAME_ERROR
suffix:colon
(brace
r_int
id|ntries
suffix:semicolon
id|redo
suffix:colon
id|ntries
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|ibmcam-&gt;frame
(braket
id|frame
)braket
dot
id|wq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|FLAGS_RETRY_VIDIOCSYNC
)paren
(brace
multiline_comment|/* Polling apps will destroy frames with that! */
id|ibmcam_new_frame
c_func
(paren
id|ibmcam
comma
id|frame
)paren
suffix:semicolon
id|usb_ibmcam_testpattern
c_func
(paren
id|ibmcam
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|ibmcam-&gt;curframe
op_assign
op_minus
l_int|1
suffix:semicolon
id|ibmcam-&gt;frame_num
op_increment
suffix:semicolon
multiline_comment|/* This will request another frame. */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ibmcam-&gt;frame
(braket
id|frame
)braket
dot
id|wq
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|ibmcam-&gt;frame
(braket
id|frame
)braket
dot
id|wq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Standard answer: not ready yet! */
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|ibmcam-&gt;frame
(braket
id|frame
)braket
dot
id|grabstate
op_eq
id|FRAME_GRABBING
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;frame
(braket
id|frame
)braket
dot
id|grabstate
op_eq
id|FRAME_ERROR
)paren
(brace
r_int
id|ret
op_assign
id|ibmcam_new_frame
c_func
(paren
id|ibmcam
comma
id|frame
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_goto
id|redo
suffix:semicolon
)brace
)brace
r_case
id|FRAME_DONE
suffix:colon
id|ibmcam-&gt;frame
(braket
id|frame
)braket
dot
id|grabstate
op_assign
id|FRAME_UNUSED
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ibmcam-&gt;frame
(braket
id|frame
)braket
dot
id|grabstate
op_assign
id|FRAME_UNUSED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGFBUF
suffix:colon
(brace
r_struct
id|video_buffer
id|vb
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|vb
comma
l_int|0
comma
r_sizeof
(paren
id|vb
)paren
)paren
suffix:semicolon
id|vb.base
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* frame buffer not supported, not used */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
(paren
r_void
op_star
)paren
op_amp
id|vb
comma
r_sizeof
(paren
id|vb
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCKEY
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|VIDIOCCAPTURE
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|VIDIOCSFBUF
suffix:colon
r_case
id|VIDIOCGTUNER
suffix:colon
r_case
id|VIDIOCSTUNER
suffix:colon
r_case
id|VIDIOCGFREQ
suffix:colon
r_case
id|VIDIOCSFREQ
suffix:colon
r_case
id|VIDIOCGAUDIO
suffix:colon
r_case
id|VIDIOCSAUDIO
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ibmcam_read
r_static
r_int
id|ibmcam_read
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|count
comma
r_int
id|noblock
)paren
(brace
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
(paren
r_struct
id|usb_ibmcam
op_star
)paren
id|dev
suffix:semicolon
r_int
id|frmx
op_assign
op_minus
l_int|1
suffix:semicolon
r_volatile
r_struct
id|ibmcam_frame
op_star
id|frame
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam_read: %ld bytes, noblock=%d&bslash;n&quot;
comma
id|count
comma
id|noblock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;remove_pending
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
op_logical_neg
id|buf
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* See if a frame is completed, then use it. */
r_if
c_cond
(paren
id|ibmcam-&gt;frame
(braket
l_int|0
)braket
dot
id|grabstate
op_ge
id|FRAME_DONE
)paren
multiline_comment|/* _DONE or _ERROR */
id|frmx
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ibmcam-&gt;frame
(braket
l_int|1
)braket
dot
id|grabstate
op_ge
id|FRAME_DONE
)paren
multiline_comment|/* _DONE or _ERROR */
id|frmx
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|noblock
op_logical_and
(paren
id|frmx
op_eq
op_minus
l_int|1
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/* If no FRAME_DONE, look for a FRAME_GRABBING state. */
multiline_comment|/* See if a frame is in process (grabbing), then use it. */
r_if
c_cond
(paren
id|frmx
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|ibmcam-&gt;frame
(braket
l_int|0
)braket
dot
id|grabstate
op_eq
id|FRAME_GRABBING
)paren
id|frmx
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ibmcam-&gt;frame
(braket
l_int|1
)braket
dot
id|grabstate
op_eq
id|FRAME_GRABBING
)paren
id|frmx
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If no frame is active, start one. */
r_if
c_cond
(paren
id|frmx
op_eq
op_minus
l_int|1
)paren
id|ibmcam_new_frame
c_func
(paren
id|ibmcam
comma
id|frmx
op_assign
l_int|0
)paren
suffix:semicolon
id|frame
op_assign
op_amp
id|ibmcam-&gt;frame
(braket
id|frmx
)braket
suffix:semicolon
id|restart
suffix:colon
r_while
c_loop
(paren
id|frame-&gt;grabstate
op_eq
id|FRAME_GRABBING
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|frame-&gt;wq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|frame-&gt;grabstate
op_eq
id|FRAME_ERROR
)paren
(brace
id|frame-&gt;bytes_read
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam_new_frame
c_func
(paren
id|ibmcam
comma
id|frmx
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam_read: ibmcam_new_frame error&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam_read: frmx=%d, bytes_read=%ld, scanlength=%ld&bslash;n&quot;
comma
id|frmx
comma
id|frame-&gt;bytes_read
comma
id|frame-&gt;scanlength
)paren
suffix:semicolon
multiline_comment|/* copy bytes to user space; we allow for partials reads */
r_if
c_cond
(paren
(paren
id|count
op_plus
id|frame-&gt;bytes_read
)paren
OG
id|frame-&gt;scanlength
)paren
id|count
op_assign
id|frame-&gt;scanlength
op_minus
id|frame-&gt;bytes_read
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|frame-&gt;data
op_plus
id|frame-&gt;bytes_read
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|frame-&gt;bytes_read
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam_read: {copy} count used=%ld, new bytes_read=%ld&bslash;n&quot;
comma
id|count
comma
id|frame-&gt;bytes_read
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frame-&gt;bytes_read
op_ge
id|frame-&gt;scanlength
)paren
(brace
multiline_comment|/* All data has been read */
id|frame-&gt;bytes_read
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Mark it as available to be used again. */
id|ibmcam-&gt;frame
(braket
id|frmx
)braket
dot
id|grabstate
op_assign
id|FRAME_UNUSED
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam_new_frame
c_func
(paren
id|ibmcam
comma
id|frmx
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ibmcam_read: ibmcam_new_frame returned error&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|ibmcam_mmap
r_static
r_int
id|ibmcam_mmap
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_const
r_char
op_star
id|adr
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
(paren
r_struct
id|usb_ibmcam
op_star
)paren
id|dev
suffix:semicolon
r_int
r_int
id|start
op_assign
(paren
r_int
r_int
)paren
id|adr
suffix:semicolon
r_int
r_int
id|page
comma
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam-&gt;remove_pending
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
(paren
(paren
(paren
l_int|2
op_star
id|MAX_FRAME_SIZE
)paren
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pos
op_assign
(paren
r_int
r_int
)paren
id|ibmcam-&gt;fbuf
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|kvirt_to_pa
c_func
(paren
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remap_page_range
c_func
(paren
id|start
comma
id|page
comma
id|PAGE_SIZE
comma
id|PAGE_SHARED
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|pos
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|PAGE_SIZE
)paren
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
r_else
id|size
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ibmcam_template
r_static
r_struct
id|video_device
id|ibmcam_template
op_assign
(brace
l_string|&quot;CPiA USB Camera&quot;
comma
id|VID_TYPE_CAPTURE
comma
id|VID_HARDWARE_CPIA
comma
id|ibmcam_open
comma
id|ibmcam_close
comma
id|ibmcam_read
comma
id|ibmcam_write
comma
l_int|NULL
comma
id|ibmcam_ioctl
comma
id|ibmcam_mmap
comma
id|ibmcam_init_done
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|function|usb_ibmcam_configure_video
r_static
r_void
id|usb_ibmcam_configure_video
c_func
(paren
r_struct
id|usb_ibmcam
op_star
id|ibmcam
)paren
(brace
r_if
c_cond
(paren
id|ibmcam
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|init_brightness
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|init_contrast
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|init_color
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|init_hue
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ibmcam-&gt;vpic
comma
l_int|0
comma
r_sizeof
(paren
id|ibmcam-&gt;vpic
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ibmcam-&gt;vpic_old
comma
l_int|0x55
comma
r_sizeof
(paren
id|ibmcam-&gt;vpic_old
)paren
)paren
suffix:semicolon
id|ibmcam-&gt;vpic.colour
op_assign
id|init_color
op_lshift
l_int|8
suffix:semicolon
id|ibmcam-&gt;vpic.hue
op_assign
id|init_hue
op_lshift
l_int|8
suffix:semicolon
id|ibmcam-&gt;vpic.brightness
op_assign
id|init_brightness
op_lshift
l_int|8
suffix:semicolon
id|ibmcam-&gt;vpic.contrast
op_assign
id|init_contrast
op_lshift
l_int|8
suffix:semicolon
id|ibmcam-&gt;vpic.whiteness
op_assign
l_int|105
op_lshift
l_int|8
suffix:semicolon
multiline_comment|/* This one isn&squot;t used */
id|ibmcam-&gt;vpic.depth
op_assign
l_int|24
suffix:semicolon
id|ibmcam-&gt;vpic.palette
op_assign
id|VIDEO_PALETTE_RGB24
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ibmcam-&gt;vcap
comma
l_int|0
comma
r_sizeof
(paren
id|ibmcam-&gt;vcap
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|ibmcam-&gt;vcap.name
comma
l_string|&quot;IBM USB Camera&quot;
)paren
suffix:semicolon
id|ibmcam-&gt;vcap.type
op_assign
id|VID_TYPE_CAPTURE
multiline_comment|/*| VID_TYPE_SUBCAPTURE*/
suffix:semicolon
id|ibmcam-&gt;vcap.channels
op_assign
l_int|1
suffix:semicolon
id|ibmcam-&gt;vcap.audios
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;vcap.maxwidth
op_assign
id|imgwidth
suffix:semicolon
id|ibmcam-&gt;vcap.maxheight
op_assign
id|imgheight
suffix:semicolon
id|ibmcam-&gt;vcap.minwidth
op_assign
id|min_imgwidth
suffix:semicolon
id|ibmcam-&gt;vcap.minheight
op_assign
id|min_imgheight
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ibmcam-&gt;vchan
comma
l_int|0
comma
r_sizeof
(paren
id|ibmcam-&gt;vchan
)paren
)paren
suffix:semicolon
id|ibmcam-&gt;vchan.flags
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;vchan.tuners
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;vchan.channel
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;vchan.type
op_assign
id|VIDEO_TYPE_CAMERA
suffix:semicolon
id|strcpy
c_func
(paren
id|ibmcam-&gt;vchan.name
comma
l_string|&quot;Camera&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_probe()&n; *&n; * This procedure queries device descriptor and accepts the interface&n; * if it looks like IBM C-it camera.&n; *&n; * History:&n; * 1/22/00  Moved camera init code to ibmcam_open()&n; */
DECL|function|usb_ibmcam_probe
r_static
r_void
op_star
id|usb_ibmcam_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
)paren
(brace
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|interface
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam_probe(%p,%u.)&bslash;n&quot;
comma
id|dev
comma
id|ifnum
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t handle multi-config cameras */
r_if
c_cond
(paren
id|dev-&gt;descriptor.bNumConfigurations
op_ne
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Is it an IBM camera? */
r_if
c_cond
(paren
(paren
id|dev-&gt;descriptor.idVendor
op_ne
l_int|0x0545
)paren
op_logical_or
(paren
id|dev-&gt;descriptor.idProduct
op_ne
l_int|0x8080
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Camera confirmed. We claim only interface 2 (video data) */
r_if
c_cond
(paren
id|ifnum
op_ne
l_int|2
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* We found an IBM camera */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IBM USB camera found (interface %u.)&bslash;n&quot;
comma
id|ifnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ibmcam_probe: new ibmcam alloc&bslash;n&quot;
)paren
suffix:semicolon
id|ibmcam
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ibmcam
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ibmcam
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;couldn&squot;t kmalloc ibmcam struct&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ibmcam
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|usb_ibmcam
)paren
)paren
suffix:semicolon
id|ibmcam-&gt;dev
op_assign
id|dev
suffix:semicolon
id|interface
op_assign
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|ifnum
)braket
dot
id|altsetting
(braket
l_int|0
)braket
suffix:semicolon
id|ibmcam-&gt;iface
op_assign
id|interface-&gt;bInterfaceNumber
suffix:semicolon
id|ibmcam-&gt;video_endp
op_assign
l_int|0x82
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|ibmcam-&gt;remove_ok
)paren
suffix:semicolon
id|ibmcam-&gt;iso_packet_len
op_assign
l_int|1014
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|ibmcam-&gt;vdev
comma
op_amp
id|ibmcam_template
comma
r_sizeof
(paren
id|ibmcam_template
)paren
)paren
suffix:semicolon
id|usb_ibmcam_configure_video
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ibmcam-&gt;frame
(braket
l_int|0
)braket
dot
id|wq
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ibmcam-&gt;frame
(braket
l_int|1
)braket
dot
id|wq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|video_register_device
c_func
(paren
op_amp
id|ibmcam-&gt;vdev
comma
id|VFL_TYPE_GRABBER
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;video_register_device failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;video_register_device() successful&bslash;n&quot;
)paren
suffix:semicolon
id|ibmcam-&gt;compress
op_assign
l_int|0
suffix:semicolon
id|ibmcam-&gt;user
op_assign
l_int|0
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|ibmcam-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* to 1 == available */
r_return
id|ibmcam
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_ibmcam_disconnect()&n; *&n; * This procedure stops all driver activity, deallocates interface-private&n; * structure (pointed by &squot;ptr&squot;) and after that driver should be removable&n; * with no ill consequences.&n; *&n; * TODO: This code behaves badly on surprise removal!&n; *&n; * History:&n; * 1/22/00  Added polling of MOD_IN_USE to delay removal until all users gone.&n; */
DECL|function|usb_ibmcam_disconnect
r_static
r_void
id|usb_ibmcam_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usb_ibmcam_disconnect&quot;
suffix:semicolon
r_struct
id|usb_ibmcam
op_star
id|ibmcam
op_assign
(paren
r_struct
id|usb_ibmcam
op_star
)paren
id|ptr
suffix:semicolon
id|wait_queue_head_t
id|wq
suffix:semicolon
multiline_comment|/* Wait here until removal is safe */
r_if
c_cond
(paren
id|debug
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s(%p,%p.)&bslash;n&quot;
comma
id|proc
comma
id|dev
comma
id|ptr
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|wq
)paren
suffix:semicolon
id|ibmcam-&gt;remove_pending
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Now all ISO data will be ignored */
multiline_comment|/* At this time we ask to cancel outstanding URBs */
id|ibmcam_stop_isoc
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MOD_IN_USE
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: In use, disconnect pending.&bslash;n&quot;
comma
id|proc
)paren
suffix:semicolon
r_while
c_loop
(paren
id|MOD_IN_USE
)paren
id|interruptible_sleep_on_timeout
(paren
op_amp
id|wq
comma
id|HZ
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Released, wait.&bslash;n&quot;
comma
id|proc
)paren
suffix:semicolon
singleline_comment|//&t;&t;interruptible_sleep_on_timeout (&amp;wq, HZ*10);
)brace
id|video_unregister_device
c_func
(paren
op_amp
id|ibmcam-&gt;vdev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Video dereg&squot;d, wait.&bslash;n&quot;
comma
id|proc
)paren
suffix:semicolon
singleline_comment|//&t;interruptible_sleep_on_timeout (&amp;wq, HZ*10);
multiline_comment|/* Free the memory */
r_if
c_cond
(paren
id|debug
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: freeing ibmcam=%p&bslash;n&quot;
comma
id|proc
comma
id|ibmcam
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ibmcam
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Memory freed, wait.&bslash;n&quot;
comma
id|proc
)paren
suffix:semicolon
singleline_comment|//&t;interruptible_sleep_on_timeout (&amp;wq, HZ*10);
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IBM USB camera disconnected.&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|ibmcam_driver
r_static
r_struct
id|usb_driver
id|ibmcam_driver
op_assign
(brace
l_string|&quot;ibmcam&quot;
comma
id|usb_ibmcam_probe
comma
id|usb_ibmcam_disconnect
comma
(brace
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|function|usb_ibmcam_init
r_int
id|usb_ibmcam_init
c_func
(paren
r_void
)paren
(brace
r_return
id|usb_register
c_func
(paren
op_amp
id|ibmcam_driver
)paren
suffix:semicolon
)brace
DECL|function|usb_ibmcam_cleanup
r_void
id|usb_ibmcam_cleanup
c_func
(paren
r_void
)paren
(brace
id|usb_deregister
c_func
(paren
op_amp
id|ibmcam_driver
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|usb_ibmcam_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|usb_ibmcam_cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
