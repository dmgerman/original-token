multiline_comment|/*&n;*  Digi AccelePort USB-4 Serial Converter&n;*&n;*  Copyright 2000 by Digi International&n;*&n;*  This program is free software; you can redistribute it and/or modify&n;*  it under the terms of the GNU General Public License as published by&n;*  the Free Software Foundation; either version 2 of the License, or&n;*  (at your option) any later version.&n;*&n;*  Shamelessly based on Brian Warner&squot;s keyspan_pda.c and Greg Kroah-Hartman&squot;s&n;*  usb-serial driver.&n;*&n;*  Peter Berger (pberger@brimson.com)&n;*  Al Borchers (borchers@steinerpoint.com)&n;*&n;*  (7/15/2000) borchers&n;*    -- Fixed race in open when a close is in progress.&n;*    -- Keep count of opens and dec the module use count for each&n;*       outstanding open when shutdown is called (on disconnect).&n;*    -- Fixed sanity checks in read_bulk_callback and write_bulk_callback&n;*       so pointers are checked before use.&n;*    -- Split read bulk callback into in band and out of band&n;*       callbacks, and no longer restart read chains if there is&n;*       a status error or a sanity error.  This fixed the seg&n;*       faults and other errors we used to get on disconnect.&n;*    -- Port-&gt;active is once again a flag, not a count, as it was&n;*       intended by usb-serial.  Since it was only a char it would&n;*       have been limited to 256 simultaneous opens.  Now the open&n;*       count is kept in the port private structure in dp_open_count.&n;*    -- Added code for modularization of the digi_acceleport driver.&n;*&n;*  (6/27/2000) pberger and borchers&n;*    -- Zeroed out sync field in the wakeup_task before first use;&n;*       otherwise the uninitialized value might prevent the task from&n;*       being scheduled.&n;*    -- Initialized ret value to 0 in write_bulk_callback, otherwise&n;*       the uninitialized value could cause a spurious debugging message.&n;*&n;*  (6/22/2000) pberger and borchers&n;*    -- Made cond_wait_... inline--apparently on SPARC the flags arg&n;*       to spin_lock_irqsave cannot be passed to another function&n;*       to call spin_unlock_irqrestore.  Thanks to Pauline Middelink.&n;*    -- In digi_set_modem_signals the inner nested spin locks use just&n;*       spin_lock() rather than spin_lock_irqsave().  The old code&n;*       mistakenly left interrupts off.  Thanks to Pauline Middelink.&n;*    -- copy_from_user (which can sleep) is no longer called while a&n;*       spinlock is held.  We copy to a local buffer before getting&n;*       the spinlock--don&squot;t like the extra copy but the code is simpler.&n;*    -- Printk and dbg are no longer called while a spin lock is held.&n;*&n;*  (6/4/2000) pberger and borchers&n;*    -- Replaced separate calls to spin_unlock_irqrestore and&n;*       interruptible_sleep_on_interruptible with a new function&n;*       cond_wait_interruptible_timeout_irqrestore.  This eliminates&n;*       the race condition where the wake up could happen after&n;*       the unlock and before the sleep.&n;*    -- Close now waits for output to drain.&n;*    -- Open waits until any close in progress is finished.&n;*    -- All out of band responses are now processed, not just the&n;*       first in a USB packet.&n;*    -- Fixed a bug that prevented the driver from working when the&n;*       first Digi port was not the first USB serial port--the driver&n;*       was mistakenly using the external USB serial port number to&n;*       try to index into its internal ports.&n;*    -- Fixed an SMP bug -- write_bulk_callback is called directly from&n;*       an interrupt, so spin_lock_irqsave/spin_unlock_irqrestore are&n;*       needed for locks outside write_bulk_callback that are also&n;*       acquired by write_bulk_callback to prevent deadlocks.&n;*    -- Fixed support for select() by making digi_chars_in_buffer()&n;*       return 256 when -EINPROGRESS is set, as the line discipline&n;*       code in n_tty.c expects.&n;*    -- Fixed an include file ordering problem that prevented debugging&n;*       messages from working.&n;*    -- Fixed an intermittent timeout problem that caused writes to&n;*       sometimes get stuck on some machines on some kernels.  It turns&n;*       out in these circumstances write_chan() (in n_tty.c) was&n;*       asleep waiting for our wakeup call.  Even though we call&n;*       wake_up_interruptible() in digi_write_bulk_callback(), there is&n;*       a race condition that could cause the wakeup to fail: if our&n;*       wake_up_interruptible() call occurs between the time that our&n;*       driver write routine finishes and write_chan() sets current-&gt;state&n;*       to TASK_INTERRUPTIBLE, the effect of our wakeup setting the state&n;*       to TASK_RUNNING will be lost and write_chan&squot;s subsequent call to&n;*       schedule() will never return (unless it catches a signal).&n;*       This race condition occurs because write_bulk_callback() (and thus&n;*       the wakeup) are called asynchonously from an interrupt, rather than&n;*       from the scheduler.  We can avoid the race by calling the wakeup&n;*       from the scheduler queue and that&squot;s our fix:  Now, at the end of&n;*       write_bulk_callback() we queue up a wakeup call on the scheduler&n;*       task queue.  We still also invoke the wakeup directly since that&n;*       squeezes a bit more performance out of the driver, and any lost&n;*       race conditions will get cleaned up at the next scheduler run.&n;*&n;*       NOTE:  The problem also goes away if you comment out&n;*       the two code lines in write_chan() where current-&gt;state&n;*       is set to TASK_RUNNING just before calling driver.write() and to&n;*       TASK_INTERRUPTIBLE immediately afterwards.  This is why the&n;*       problem did not show up with the 2.2 kernels -- they do not&n;*       include that code.&n;*&n;*  (5/16/2000) pberger and borchers&n;*    -- Added timeouts to sleeps, to defend against lost wake ups.&n;*    -- Handle transition to/from B0 baud rate in digi_set_termios.&n;*&n;*  (5/13/2000) pberger and borchers&n;*    -- All commands now sent on out of band port, using&n;*       digi_write_oob_command.&n;*    -- Get modem control signals whenever they change, support TIOCMGET/&n;*       SET/BIS/BIC ioctls.&n;*    -- digi_set_termios now supports parity, word size, stop bits, and&n;*       receive enable.&n;*    -- Cleaned up open and close, use digi_set_termios and&n;*       digi_write_oob_command to set port parameters.&n;*    -- Added digi_startup_device to start read chains on all ports.&n;*    -- Write buffer is only used when count==1, to be sure put_char can&n;*       write a char (unless the buffer is full).&n;*&n;*  (5/10/2000) pberger and borchers&n;*    -- Added MOD_INC_USE_COUNT/MOD_DEC_USE_COUNT calls on open/close.&n;*    -- Fixed problem where the first incoming character is lost on&n;*       port opens after the first close on that port.  Now we keep&n;*       the read_urb chain open until shutdown.&n;*    -- Added more port conditioning calls in digi_open and digi_close.&n;*    -- Convert port-&gt;active to a use count so that we can deal with multiple&n;*       opens and closes properly.&n;*    -- Fixed some problems with the locking code.&n;*&n;*  (5/3/2000) pberger and borchers&n;*    -- First alpha version of the driver--many known limitations and bugs.&n;*&n;*&n;*  Locking and SMP&n;*&n;*  - Each port, including the out-of-band port, has a lock used to&n;*    serialize all access to the port&squot;s private structure.&n;*  - The port lock is also used to serialize all writes and access to&n;*    the port&squot;s URB.&n;*  - The port lock is also used for the port write_wait condition&n;*    variable.  Holding the port lock will prevent a wake up on the&n;*    port&squot;s write_wait; this can be used with cond_wait_... to be sure&n;*    the wake up is not lost in a race when dropping the lock and&n;*    sleeping waiting for the wakeup.&n;*  - digi_write() does not sleep, since it is sometimes called on&n;*    interrupt time.&n;*  - digi_write_bulk_callback() and digi_read_bulk_callback() are&n;*    called directly from interrupts.  Hence spin_lock_irqsave()&n;*    and spin_lock_irqrestore() are used in the rest of the code&n;*    for any locks they acquire.&n;*  - digi_write_bulk_callback() gets the port lock before waking up&n;*    processes sleeping on the port write_wait.  It also schedules&n;*    wake ups so they happen from the scheduler, because the tty&n;*    system can miss wake ups from interrupts.&n;*  - All sleeps use a timeout of DIGI_RETRY_TIMEOUT before looping to&n;*    recheck the condition they are sleeping on.  This is defensive,&n;*    in case a wake up is lost.&n;*  - Following Documentation/DocBook/kernel-locking.pdf no spin locks&n;*    are held when calling copy_to/from_user or printk.&n;*    &n;*  $Id: digi_acceleport.c,v 1.5 2000/07/18 04:52:43 root Exp $&n;*/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/tty_driver.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#ifdef CONFIG_USB_SERIAL_DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#else
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &quot;usb-serial.h&quot;
multiline_comment|/* Defines */
multiline_comment|/* port buffer length -- must be &lt;= transfer buffer length - 2 */
multiline_comment|/* so we can be sure to send the full buffer in one urb */
DECL|macro|DIGI_PORT_BUF_LEN
mdefine_line|#define DIGI_PORT_BUF_LEN&t;&t;8
multiline_comment|/* retry timeout while sleeping */
DECL|macro|DIGI_RETRY_TIMEOUT
mdefine_line|#define DIGI_RETRY_TIMEOUT&t;&t;(HZ/10)
multiline_comment|/* timeout while waiting for tty output to drain in close */
multiline_comment|/* this delay is used twice in close, so the total delay could */
multiline_comment|/* be twice this value */
DECL|macro|DIGI_CLOSE_TIMEOUT
mdefine_line|#define DIGI_CLOSE_TIMEOUT&t;&t;(5*HZ)
multiline_comment|/* AccelePort USB Defines */
multiline_comment|/* ids */
DECL|macro|DIGI_VENDOR_ID
mdefine_line|#define DIGI_VENDOR_ID&t;&t;&t;0x05c5
DECL|macro|DIGI_ID
mdefine_line|#define DIGI_ID&t;&t;&t;&t;0x0004
multiline_comment|/* commands&n; * &quot;INB&quot;: can be used on the in-band endpoint&n; * &quot;OOB&quot;: can be used on the out-of-band endpoint&n; */
DECL|macro|DIGI_CMD_SET_BAUD_RATE
mdefine_line|#define DIGI_CMD_SET_BAUD_RATE&t;&t;&t;0&t;/* INB, OOB */
DECL|macro|DIGI_CMD_SET_WORD_SIZE
mdefine_line|#define DIGI_CMD_SET_WORD_SIZE&t;&t;&t;1&t;/* INB, OOB */
DECL|macro|DIGI_CMD_SET_PARITY
mdefine_line|#define DIGI_CMD_SET_PARITY&t;&t;&t;2&t;/* INB, OOB */
DECL|macro|DIGI_CMD_SET_STOP_BITS
mdefine_line|#define DIGI_CMD_SET_STOP_BITS&t;&t;&t;3&t;/* INB, OOB */
DECL|macro|DIGI_CMD_SET_INPUT_FLOW_CONTROL
mdefine_line|#define DIGI_CMD_SET_INPUT_FLOW_CONTROL&t;&t;4&t;/* INB, OOB */
DECL|macro|DIGI_CMD_SET_OUTPUT_FLOW_CONTROL
mdefine_line|#define DIGI_CMD_SET_OUTPUT_FLOW_CONTROL&t;5&t;/* INB, OOB */
DECL|macro|DIGI_CMD_SET_DTR_SIGNAL
mdefine_line|#define DIGI_CMD_SET_DTR_SIGNAL&t;&t;&t;6&t;/* INB, OOB */
DECL|macro|DIGI_CMD_SET_RTS_SIGNAL
mdefine_line|#define DIGI_CMD_SET_RTS_SIGNAL&t;&t;&t;7&t;/* INB, OOB */
DECL|macro|DIGI_CMD_READ_INPUT_SIGNALS
mdefine_line|#define DIGI_CMD_READ_INPUT_SIGNALS&t;&t;8&t;/*      OOB */
DECL|macro|DIGI_CMD_IFLUSH_FIFO
mdefine_line|#define DIGI_CMD_IFLUSH_FIFO&t;&t;&t;9&t;/*      OOB */
DECL|macro|DIGI_CMD_RECEIVE_ENABLE
mdefine_line|#define DIGI_CMD_RECEIVE_ENABLE&t;&t;&t;10&t;/* INB, OOB */
DECL|macro|DIGI_CMD_BREAK_CONTROL
mdefine_line|#define DIGI_CMD_BREAK_CONTROL&t;&t;&t;11&t;/* INB, OOB */
DECL|macro|DIGI_CMD_LOCAL_LOOPBACK
mdefine_line|#define DIGI_CMD_LOCAL_LOOPBACK&t;&t;&t;12&t;/* INB, OOB */
DECL|macro|DIGI_CMD_TRANSMIT_IDLE
mdefine_line|#define DIGI_CMD_TRANSMIT_IDLE&t;&t;&t;13&t;/* INB, OOB */
DECL|macro|DIGI_CMD_READ_UART_REGISTER
mdefine_line|#define DIGI_CMD_READ_UART_REGISTER&t;&t;14&t;/*      OOB */
DECL|macro|DIGI_CMD_WRITE_UART_REGISTER
mdefine_line|#define DIGI_CMD_WRITE_UART_REGISTER&t;&t;15&t;/* INB, OOB */
DECL|macro|DIGI_CMD_AND_UART_REGISTER
mdefine_line|#define DIGI_CMD_AND_UART_REGISTER&t;&t;16&t;/* INB, OOB */
DECL|macro|DIGI_CMD_OR_UART_REGISTER
mdefine_line|#define DIGI_CMD_OR_UART_REGISTER&t;&t;17&t;/* INB, OOB */
DECL|macro|DIGI_CMD_SEND_DATA
mdefine_line|#define DIGI_CMD_SEND_DATA&t;&t;&t;18&t;/* INB      */
DECL|macro|DIGI_CMD_RECEIVE_DATA
mdefine_line|#define DIGI_CMD_RECEIVE_DATA&t;&t;&t;19&t;/* INB      */
DECL|macro|DIGI_CMD_RECEIVE_DISABLE
mdefine_line|#define DIGI_CMD_RECEIVE_DISABLE&t;&t;20&t;/* INB      */
DECL|macro|DIGI_CMD_GET_PORT_TYPE
mdefine_line|#define DIGI_CMD_GET_PORT_TYPE&t;&t;&t;21&t;/*      OOB */
multiline_comment|/* baud rates */
DECL|macro|DIGI_BAUD_50
mdefine_line|#define DIGI_BAUD_50&t;&t;&t;&t;0
DECL|macro|DIGI_BAUD_75
mdefine_line|#define DIGI_BAUD_75&t;&t;&t;&t;1
DECL|macro|DIGI_BAUD_110
mdefine_line|#define DIGI_BAUD_110&t;&t;&t;&t;2
DECL|macro|DIGI_BAUD_150
mdefine_line|#define DIGI_BAUD_150&t;&t;&t;&t;3
DECL|macro|DIGI_BAUD_200
mdefine_line|#define DIGI_BAUD_200&t;&t;&t;&t;4
DECL|macro|DIGI_BAUD_300
mdefine_line|#define DIGI_BAUD_300&t;&t;&t;&t;5
DECL|macro|DIGI_BAUD_600
mdefine_line|#define DIGI_BAUD_600&t;&t;&t;&t;6
DECL|macro|DIGI_BAUD_1200
mdefine_line|#define DIGI_BAUD_1200&t;&t;&t;&t;7
DECL|macro|DIGI_BAUD_1800
mdefine_line|#define DIGI_BAUD_1800&t;&t;&t;&t;8
DECL|macro|DIGI_BAUD_2400
mdefine_line|#define DIGI_BAUD_2400&t;&t;&t;&t;9
DECL|macro|DIGI_BAUD_4800
mdefine_line|#define DIGI_BAUD_4800&t;&t;&t;&t;10
DECL|macro|DIGI_BAUD_7200
mdefine_line|#define DIGI_BAUD_7200&t;&t;&t;&t;11
DECL|macro|DIGI_BAUD_9600
mdefine_line|#define DIGI_BAUD_9600&t;&t;&t;&t;12
DECL|macro|DIGI_BAUD_14400
mdefine_line|#define DIGI_BAUD_14400&t;&t;&t;&t;13
DECL|macro|DIGI_BAUD_19200
mdefine_line|#define DIGI_BAUD_19200&t;&t;&t;&t;14
DECL|macro|DIGI_BAUD_28800
mdefine_line|#define DIGI_BAUD_28800&t;&t;&t;&t;15
DECL|macro|DIGI_BAUD_38400
mdefine_line|#define DIGI_BAUD_38400&t;&t;&t;&t;16
DECL|macro|DIGI_BAUD_57600
mdefine_line|#define DIGI_BAUD_57600&t;&t;&t;&t;17
DECL|macro|DIGI_BAUD_76800
mdefine_line|#define DIGI_BAUD_76800&t;&t;&t;&t;18
DECL|macro|DIGI_BAUD_115200
mdefine_line|#define DIGI_BAUD_115200&t;&t;&t;19
DECL|macro|DIGI_BAUD_153600
mdefine_line|#define DIGI_BAUD_153600&t;&t;&t;20
DECL|macro|DIGI_BAUD_230400
mdefine_line|#define DIGI_BAUD_230400&t;&t;&t;21
DECL|macro|DIGI_BAUD_460800
mdefine_line|#define DIGI_BAUD_460800&t;&t;&t;22
multiline_comment|/* arguments */
DECL|macro|DIGI_WORD_SIZE_5
mdefine_line|#define DIGI_WORD_SIZE_5&t;&t;&t;0
DECL|macro|DIGI_WORD_SIZE_6
mdefine_line|#define DIGI_WORD_SIZE_6&t;&t;&t;1
DECL|macro|DIGI_WORD_SIZE_7
mdefine_line|#define DIGI_WORD_SIZE_7&t;&t;&t;2
DECL|macro|DIGI_WORD_SIZE_8
mdefine_line|#define DIGI_WORD_SIZE_8&t;&t;&t;3
DECL|macro|DIGI_PARITY_NONE
mdefine_line|#define DIGI_PARITY_NONE&t;&t;&t;0
DECL|macro|DIGI_PARITY_ODD
mdefine_line|#define DIGI_PARITY_ODD&t;&t;&t;&t;1
DECL|macro|DIGI_PARITY_EVEN
mdefine_line|#define DIGI_PARITY_EVEN&t;&t;&t;2
DECL|macro|DIGI_PARITY_MARK
mdefine_line|#define DIGI_PARITY_MARK&t;&t;&t;3
DECL|macro|DIGI_PARITY_SPACE
mdefine_line|#define DIGI_PARITY_SPACE&t;&t;&t;4
DECL|macro|DIGI_STOP_BITS_1
mdefine_line|#define DIGI_STOP_BITS_1&t;&t;&t;0
DECL|macro|DIGI_STOP_BITS_2
mdefine_line|#define DIGI_STOP_BITS_2&t;&t;&t;1
DECL|macro|DIGI_INPUT_FLOW_CONTROL_XON_XOFF
mdefine_line|#define DIGI_INPUT_FLOW_CONTROL_XON_XOFF&t;1
DECL|macro|DIGI_INPUT_FLOW_CONTROL_RTS
mdefine_line|#define DIGI_INPUT_FLOW_CONTROL_RTS&t;&t;2
DECL|macro|DIGI_INPUT_FLOW_CONTROL_DTR
mdefine_line|#define DIGI_INPUT_FLOW_CONTROL_DTR&t;&t;4
DECL|macro|DIGI_OUTPUT_FLOW_CONTROL_XON_XOFF
mdefine_line|#define DIGI_OUTPUT_FLOW_CONTROL_XON_XOFF&t;1
DECL|macro|DIGI_OUTPUT_FLOW_CONTROL_CTS
mdefine_line|#define DIGI_OUTPUT_FLOW_CONTROL_CTS&t;&t;2
DECL|macro|DIGI_OUTPUT_FLOW_CONTROL_DSR
mdefine_line|#define DIGI_OUTPUT_FLOW_CONTROL_DSR&t;&t;4
DECL|macro|DIGI_DTR_INACTIVE
mdefine_line|#define DIGI_DTR_INACTIVE&t;&t;&t;0
DECL|macro|DIGI_DTR_ACTIVE
mdefine_line|#define DIGI_DTR_ACTIVE&t;&t;&t;&t;1
DECL|macro|DIGI_DTR_INPUT_FLOW_CONTROL
mdefine_line|#define DIGI_DTR_INPUT_FLOW_CONTROL&t;&t;2
DECL|macro|DIGI_RTS_INACTIVE
mdefine_line|#define DIGI_RTS_INACTIVE&t;&t;&t;0
DECL|macro|DIGI_RTS_ACTIVE
mdefine_line|#define DIGI_RTS_ACTIVE&t;&t;&t;&t;1
DECL|macro|DIGI_RTS_INPUT_FLOW_CONTROL
mdefine_line|#define DIGI_RTS_INPUT_FLOW_CONTROL&t;&t;2
DECL|macro|DIGI_RTS_TOGGLE
mdefine_line|#define DIGI_RTS_TOGGLE&t;&t;&t;&t;3
DECL|macro|DIGI_FLUSH_TX
mdefine_line|#define DIGI_FLUSH_TX&t;&t;&t;&t;1
DECL|macro|DIGI_FLUSH_RX
mdefine_line|#define DIGI_FLUSH_RX&t;&t;&t;&t;2
DECL|macro|DIGI_RESUME_TX
mdefine_line|#define DIGI_RESUME_TX&t;&t;&t;&t;4 /* clears xoff condition */
DECL|macro|DIGI_TRANSMIT_NOT_IDLE
mdefine_line|#define DIGI_TRANSMIT_NOT_IDLE&t;&t;&t;0
DECL|macro|DIGI_TRANSMIT_IDLE
mdefine_line|#define DIGI_TRANSMIT_IDLE&t;&t;&t;1
DECL|macro|DIGI_DISABLE
mdefine_line|#define DIGI_DISABLE&t;&t;&t;&t;0
DECL|macro|DIGI_ENABLE
mdefine_line|#define DIGI_ENABLE&t;&t;&t;&t;1
DECL|macro|DIGI_DEASSERT
mdefine_line|#define DIGI_DEASSERT&t;&t;&t;&t;0
DECL|macro|DIGI_ASSERT
mdefine_line|#define DIGI_ASSERT&t;&t;&t;&t;1
multiline_comment|/* in band status codes */
DECL|macro|DIGI_OVERRUN_ERROR
mdefine_line|#define DIGI_OVERRUN_ERROR&t;&t;&t;4
DECL|macro|DIGI_PARITY_ERROR
mdefine_line|#define DIGI_PARITY_ERROR&t;&t;&t;8
DECL|macro|DIGI_FRAMING_ERROR
mdefine_line|#define DIGI_FRAMING_ERROR&t;&t;&t;16
DECL|macro|DIGI_BREAK_ERROR
mdefine_line|#define DIGI_BREAK_ERROR&t;&t;&t;32
multiline_comment|/* out of band status */
DECL|macro|DIGI_NO_ERROR
mdefine_line|#define DIGI_NO_ERROR&t;&t;&t;&t;0
DECL|macro|DIGI_BAD_FIRST_PARAMETER
mdefine_line|#define DIGI_BAD_FIRST_PARAMETER&t;&t;1
DECL|macro|DIGI_BAD_SECOND_PARAMETER
mdefine_line|#define DIGI_BAD_SECOND_PARAMETER&t;&t;2
DECL|macro|DIGI_INVALID_LINE
mdefine_line|#define DIGI_INVALID_LINE&t;&t;&t;3
DECL|macro|DIGI_INVALID_OPCODE
mdefine_line|#define DIGI_INVALID_OPCODE&t;&t;&t;4
multiline_comment|/* input signals */
DECL|macro|DIGI_READ_INPUT_SIGNALS_SLOT
mdefine_line|#define DIGI_READ_INPUT_SIGNALS_SLOT&t;&t;1
DECL|macro|DIGI_READ_INPUT_SIGNALS_ERR
mdefine_line|#define DIGI_READ_INPUT_SIGNALS_ERR&t;&t;2
DECL|macro|DIGI_READ_INPUT_SIGNALS_BUSY
mdefine_line|#define DIGI_READ_INPUT_SIGNALS_BUSY&t;&t;4
DECL|macro|DIGI_READ_INPUT_SIGNALS_PE
mdefine_line|#define DIGI_READ_INPUT_SIGNALS_PE&t;&t;8
DECL|macro|DIGI_READ_INPUT_SIGNALS_CTS
mdefine_line|#define DIGI_READ_INPUT_SIGNALS_CTS&t;&t;16
DECL|macro|DIGI_READ_INPUT_SIGNALS_DSR
mdefine_line|#define DIGI_READ_INPUT_SIGNALS_DSR&t;&t;32
DECL|macro|DIGI_READ_INPUT_SIGNALS_RI
mdefine_line|#define DIGI_READ_INPUT_SIGNALS_RI&t;&t;64
DECL|macro|DIGI_READ_INPUT_SIGNALS_DCD
mdefine_line|#define DIGI_READ_INPUT_SIGNALS_DCD&t;&t;128
multiline_comment|/* macros */
DECL|macro|MAX
mdefine_line|#define MAX(a,b)&t;(((a)&gt;(b))?(a):(b))
DECL|macro|MIN
mdefine_line|#define MIN(a,b)&t;(((a)&lt;(b))?(a):(b))
multiline_comment|/* Structures */
DECL|struct|digi_private
r_typedef
r_struct
id|digi_private
(brace
DECL|member|dp_port_num
r_int
id|dp_port_num
suffix:semicolon
DECL|member|dp_port_lock
id|spinlock_t
id|dp_port_lock
suffix:semicolon
DECL|member|dp_buf_len
r_int
id|dp_buf_len
suffix:semicolon
DECL|member|dp_buf
r_int
r_char
id|dp_buf
(braket
id|DIGI_PORT_BUF_LEN
)braket
suffix:semicolon
DECL|member|dp_modem_signals
r_int
r_int
id|dp_modem_signals
suffix:semicolon
DECL|member|dp_open_count
r_int
id|dp_open_count
suffix:semicolon
multiline_comment|/* inc on open, dec on close */
DECL|member|dp_transmit_idle
r_int
id|dp_transmit_idle
suffix:semicolon
DECL|member|dp_in_close
r_int
id|dp_in_close
suffix:semicolon
multiline_comment|/* close in progress */
DECL|member|dp_close_wait
id|wait_queue_head_t
id|dp_close_wait
suffix:semicolon
multiline_comment|/* wait queue for close */
DECL|member|dp_wakeup_task
r_struct
id|tq_struct
id|dp_wakeup_task
suffix:semicolon
DECL|typedef|digi_private_t
)brace
id|digi_private_t
suffix:semicolon
multiline_comment|/* Local Function Declarations */
r_static
r_void
id|digi_wakeup_write
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
suffix:semicolon
r_static
r_void
id|digi_wakeup_write_lock
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
suffix:semicolon
r_static
r_int
id|digi_write_oob_command
c_func
(paren
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_int
id|digi_write_inb_command
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
suffix:semicolon
r_static
r_int
id|digi_set_modem_signals
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_int
r_int
id|modem_signals
)paren
suffix:semicolon
r_static
r_int
id|digi_transmit_idle
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_int
r_int
id|timeout
)paren
suffix:semicolon
r_static
r_void
id|digi_rx_throttle
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
suffix:semicolon
r_static
r_void
id|digi_rx_unthrottle
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
suffix:semicolon
r_static
r_void
id|digi_set_termios
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|termios
op_star
id|old_termios
)paren
suffix:semicolon
r_static
r_void
id|digi_break_ctl
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_int
id|break_state
)paren
suffix:semicolon
r_static
r_int
id|digi_ioctl
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|digi_write
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_void
id|digi_write_bulk_callback
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_int
id|digi_write_room
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
suffix:semicolon
r_static
r_int
id|digi_chars_in_buffer
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
suffix:semicolon
r_static
r_int
id|digi_open
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|digi_close
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_int
id|digi_startup_device
c_func
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
suffix:semicolon
r_static
r_int
id|digi_startup
c_func
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
suffix:semicolon
r_static
r_void
id|digi_shutdown
c_func
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
suffix:semicolon
r_static
r_void
id|digi_read_bulk_callback
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_int
id|digi_read_inb_callback
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_int
id|digi_read_oob_callback
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
multiline_comment|/* Statics */
multiline_comment|/* device info needed for the Digi serial converter */
DECL|variable|digi_vendor_id
r_static
id|u16
id|digi_vendor_id
op_assign
id|DIGI_VENDOR_ID
suffix:semicolon
DECL|variable|digi_product_id
r_static
id|u16
id|digi_product_id
op_assign
id|DIGI_ID
suffix:semicolon
multiline_comment|/* out of band port */
DECL|variable|oob_port_num
r_static
r_int
id|oob_port_num
suffix:semicolon
multiline_comment|/* index of out-of-band port */
DECL|variable|oob_port
r_static
r_struct
id|usb_serial_port
op_star
id|oob_port
suffix:semicolon
multiline_comment|/* out-of-band port */
DECL|variable|device_startup
r_static
r_int
id|device_startup
op_assign
l_int|0
suffix:semicolon
DECL|variable|startup_lock
id|spinlock_t
id|startup_lock
suffix:semicolon
multiline_comment|/* used by startup_device */
DECL|variable|modem_change_wait
r_static
id|wait_queue_head_t
id|modem_change_wait
suffix:semicolon
DECL|variable|transmit_idle_wait
r_static
id|wait_queue_head_t
id|transmit_idle_wait
suffix:semicolon
multiline_comment|/* Globals */
DECL|variable|digi_acceleport_device
r_struct
id|usb_serial_device_type
id|digi_acceleport_device
op_assign
(brace
id|name
suffix:colon
l_string|&quot;Digi USB&quot;
comma
id|idVendor
suffix:colon
op_amp
id|digi_vendor_id
comma
id|idProduct
suffix:colon
op_amp
id|digi_product_id
comma
id|needs_interrupt_in
suffix:colon
id|DONT_CARE
comma
id|needs_bulk_in
suffix:colon
id|MUST_HAVE
comma
id|needs_bulk_out
suffix:colon
id|MUST_HAVE
comma
id|num_interrupt_in
suffix:colon
l_int|0
comma
id|num_bulk_in
suffix:colon
l_int|5
comma
id|num_bulk_out
suffix:colon
l_int|5
comma
id|num_ports
suffix:colon
l_int|4
comma
id|open
suffix:colon
id|digi_open
comma
id|close
suffix:colon
id|digi_close
comma
id|write
suffix:colon
id|digi_write
comma
id|write_room
suffix:colon
id|digi_write_room
comma
id|write_bulk_callback
suffix:colon
id|digi_write_bulk_callback
comma
id|read_bulk_callback
suffix:colon
id|digi_read_bulk_callback
comma
id|chars_in_buffer
suffix:colon
id|digi_chars_in_buffer
comma
id|throttle
suffix:colon
id|digi_rx_throttle
comma
id|unthrottle
suffix:colon
id|digi_rx_unthrottle
comma
id|ioctl
suffix:colon
id|digi_ioctl
comma
id|set_termios
suffix:colon
id|digi_set_termios
comma
id|break_ctl
suffix:colon
id|digi_break_ctl
comma
id|startup
suffix:colon
id|digi_startup
comma
id|shutdown
suffix:colon
id|digi_shutdown
comma
)brace
suffix:semicolon
multiline_comment|/* Functions */
multiline_comment|/*&n;*  Cond Wait Interruptible Timeout Irqrestore&n;*&n;*  Do spin_unlock_irqrestore and interruptible_sleep_on_timeout&n;*  so that wake ups are not lost if they occur between the unlock&n;*  and the sleep.  In other words, spin_lock_irqrestore and&n;*  interruptible_sleep_on_timeout are &quot;atomic&quot; with respect to&n;*  wake ups.  This is used to implement condition variables.&n;*/
DECL|function|cond_wait_interruptible_timeout_irqrestore
r_static
r_inline
r_int
id|cond_wait_interruptible_timeout_irqrestore
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
id|timeout
comma
id|spinlock_t
op_star
id|lock
comma
r_int
r_int
id|flags
)paren
(brace
id|wait_queue_t
id|wait
suffix:semicolon
id|init_waitqueue_entry
c_func
(paren
op_amp
id|wait
comma
id|current
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|q
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|lock
comma
id|flags
)paren
suffix:semicolon
id|timeout
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|q
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|timeout
suffix:semicolon
)brace
multiline_comment|/*&n;*  Digi Wakeup Write&n;*&n;*  Wake up port, line discipline, and tty processes sleeping&n;*  on writes.&n;*/
DECL|function|digi_wakeup_write_lock
r_static
r_void
id|digi_wakeup_write_lock
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|digi_private_t
op_star
id|priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
id|digi_wakeup_write
c_func
(paren
id|port
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|digi_wakeup_write
r_static
r_void
id|digi_wakeup_write
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|port-&gt;tty
suffix:semicolon
multiline_comment|/* wake up port processes */
id|wake_up_interruptible
c_func
(paren
op_amp
id|port-&gt;write_wait
)paren
suffix:semicolon
multiline_comment|/* wake up line discipline */
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(brace
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* wake up other tty processes */
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
multiline_comment|/* For 2.2.16 backport -- wake_up_interruptible( &amp;tty-&gt;poll_wait ); */
)brace
multiline_comment|/*&n;*  Digi Write OOB Command&n;*&n;*  Write commands on the out of band port.  Commands are 4&n;*  bytes each, multiple commands can be sent at once, and&n;*  no command will be split across USB packets.  Returns 0&n;*  if successful, -EINTR if interrupted while sleeping, or&n;*  a negative error returned by usb_submit_urb.&n;*/
DECL|function|digi_write_oob_command
r_static
r_int
id|digi_write_oob_command
c_func
(paren
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|len
suffix:semicolon
id|digi_private_t
op_star
id|oob_priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|oob_port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;digi_write_oob_command: TOP: port=%d, count=%d&quot;
comma
id|oob_port_num
comma
id|count
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|oob_priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|oob_port-&gt;write_urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
id|cond_wait_interruptible_timeout_irqrestore
c_func
(paren
op_amp
id|oob_port-&gt;write_wait
comma
id|DIGI_RETRY_TIMEOUT
comma
op_amp
id|oob_priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|oob_priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* len must be a multiple of 4, so commands are not split */
id|len
op_assign
id|MIN
c_func
(paren
id|count
comma
id|oob_port-&gt;bulk_out_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|4
)paren
(brace
id|len
op_and_assign
op_complement
l_int|3
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|oob_port-&gt;write_urb-&gt;transfer_buffer
comma
id|buf
comma
id|len
)paren
suffix:semicolon
id|oob_port-&gt;write_urb-&gt;transfer_buffer_length
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_submit_urb
c_func
(paren
id|oob_port-&gt;write_urb
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|count
op_sub_assign
id|len
suffix:semicolon
id|buf
op_add_assign
id|len
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|oob_priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;digi_write_oob_command: usb_submit_urb failed, ret=%d&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;*  Digi Write In Band Command&n;*&n;*  Write commands on the given port.  Commands are 4&n;*  bytes each, multiple commands can be sent at once, and&n;*  no command will be split across USB packets.  Returns 0&n;*  if successful, or a negative error returned by digi_write.&n;*/
DECL|function|digi_write_inb_command
r_static
r_int
id|digi_write_inb_command
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|len
suffix:semicolon
id|digi_private_t
op_star
id|priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|port-&gt;write_urb-&gt;transfer_buffer
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;digi_write_inb_command: TOP: port=%d, count=%d&quot;
comma
id|priv-&gt;dp_port_num
comma
id|count
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|port-&gt;write_urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
id|cond_wait_interruptible_timeout_irqrestore
c_func
(paren
op_amp
id|port-&gt;write_wait
comma
id|DIGI_RETRY_TIMEOUT
comma
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* len must be a multiple of 4 and small enough to */
multiline_comment|/* guarantee the write will send buffered data first, */
multiline_comment|/* so commands are in order with data and not split */
id|len
op_assign
id|MIN
c_func
(paren
id|count
comma
id|port-&gt;bulk_out_size
op_minus
l_int|2
op_minus
id|priv-&gt;dp_buf_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|4
)paren
(brace
id|len
op_and_assign
op_complement
l_int|3
suffix:semicolon
)brace
multiline_comment|/* write any buffered data first */
r_if
c_cond
(paren
id|priv-&gt;dp_buf_len
OG
l_int|0
)paren
(brace
id|data
(braket
l_int|0
)braket
op_assign
id|DIGI_CMD_SEND_DATA
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
id|priv-&gt;dp_buf_len
suffix:semicolon
id|memcpy
c_func
(paren
id|data
op_plus
l_int|2
comma
id|priv-&gt;dp_buf
comma
id|priv-&gt;dp_buf_len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|data
op_plus
l_int|2
op_plus
id|priv-&gt;dp_buf_len
comma
id|buf
comma
id|len
)paren
suffix:semicolon
id|port-&gt;write_urb-&gt;transfer_buffer_length
op_assign
id|priv-&gt;dp_buf_len
op_plus
l_int|2
op_plus
id|len
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|data
comma
id|buf
comma
id|len
)paren
suffix:semicolon
id|port-&gt;write_urb-&gt;transfer_buffer_length
op_assign
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_submit_urb
c_func
(paren
id|port-&gt;write_urb
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|priv-&gt;dp_buf_len
op_assign
l_int|0
suffix:semicolon
id|count
op_sub_assign
id|len
suffix:semicolon
id|buf
op_add_assign
id|len
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;digi_write_inb_command: usb_submit_urb failed, ret=%d&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;*  Digi Set Modem Signals&n;*&n;*  Sets or clears DTR and RTS on the port, according to the&n;*  modem_signals argument.  Use TIOCM_DTR and TIOCM_RTS flags&n;*  for the modem_signals argument.  Returns 0 if successful,&n;*  -EINTR if interrupted while sleeping, or a non-zero error&n;*  returned by usb_submit_urb.&n;*/
DECL|function|digi_set_modem_signals
r_static
r_int
id|digi_set_modem_signals
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_int
r_int
id|modem_signals
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|oob_port-&gt;write_urb-&gt;transfer_buffer
suffix:semicolon
id|digi_private_t
op_star
id|port_priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
id|digi_private_t
op_star
id|oob_priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|oob_port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;digi_set_modem_signals: TOP: port=%d, modem_signals=0x%x&quot;
comma
id|port_priv-&gt;dp_port_num
comma
id|modem_signals
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|oob_priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|port_priv-&gt;dp_port_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|oob_port-&gt;write_urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|port_priv-&gt;dp_port_lock
)paren
suffix:semicolon
id|cond_wait_interruptible_timeout_irqrestore
c_func
(paren
op_amp
id|oob_port-&gt;write_wait
comma
id|DIGI_RETRY_TIMEOUT
comma
op_amp
id|oob_priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|oob_priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|port_priv-&gt;dp_port_lock
)paren
suffix:semicolon
)brace
id|data
(braket
l_int|0
)braket
op_assign
id|DIGI_CMD_SET_DTR_SIGNAL
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
id|port_priv-&gt;dp_port_num
suffix:semicolon
id|data
(braket
l_int|2
)braket
op_assign
(paren
id|modem_signals
op_amp
id|TIOCM_DTR
)paren
ques
c_cond
id|DIGI_DTR_ACTIVE
suffix:colon
id|DIGI_DTR_INACTIVE
suffix:semicolon
id|data
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|data
(braket
l_int|4
)braket
op_assign
id|DIGI_CMD_SET_RTS_SIGNAL
suffix:semicolon
id|data
(braket
l_int|5
)braket
op_assign
id|port_priv-&gt;dp_port_num
suffix:semicolon
id|data
(braket
l_int|6
)braket
op_assign
(paren
id|modem_signals
op_amp
id|TIOCM_RTS
)paren
ques
c_cond
id|DIGI_RTS_ACTIVE
suffix:colon
id|DIGI_RTS_INACTIVE
suffix:semicolon
id|data
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
id|oob_port-&gt;write_urb-&gt;transfer_buffer_length
op_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_submit_urb
c_func
(paren
id|oob_port-&gt;write_urb
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|port_priv-&gt;dp_modem_signals
op_assign
(paren
id|port_priv-&gt;dp_modem_signals
op_amp
op_complement
(paren
id|TIOCM_DTR
op_or
id|TIOCM_RTS
)paren
)paren
op_or
(paren
id|modem_signals
op_amp
(paren
id|TIOCM_DTR
op_or
id|TIOCM_RTS
)paren
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|port_priv-&gt;dp_port_lock
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|oob_priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;digi_set_modem_signals: usb_submit_urb failed, ret=%d&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;*  Digi Transmit Idle&n;*&n;*  Digi transmit idle waits, up to timeout ticks, for the transmitter&n;*  to go idle.  It returns 0 if successful or a negative error.&n;*&n;*  There are race conditions here if more than one process is calling&n;*  digi_transmit_idle on the same port at the same time.  However, this&n;*  is only called from close, and only one process can be in close on a&n;*  port at a time, so its ok.&n;*/
DECL|function|digi_transmit_idle
r_static
r_int
id|digi_transmit_idle
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_int
r_int
id|timeout
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|2
)braket
suffix:semicolon
id|digi_private_t
op_star
id|priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
id|priv-&gt;dp_transmit_idle
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
id|DIGI_CMD_TRANSMIT_IDLE
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|digi_write_inb_command
c_func
(paren
id|port
comma
id|buf
comma
l_int|2
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
id|timeout
op_add_assign
id|jiffies
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|timeout
op_logical_and
op_logical_neg
id|priv-&gt;dp_transmit_idle
)paren
(brace
id|cond_wait_interruptible_timeout_irqrestore
c_func
(paren
op_amp
id|transmit_idle_wait
comma
id|DIGI_RETRY_TIMEOUT
comma
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|priv-&gt;dp_transmit_idle
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|digi_rx_throttle
r_static
r_void
id|digi_rx_throttle
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
macro_line|#ifdef DEBUG
id|digi_private_t
op_star
id|priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
macro_line|#endif
id|dbg
c_func
(paren
l_string|&quot;digi_rx_throttle: TOP: port=%d&quot;
comma
id|priv-&gt;dp_port_num
)paren
suffix:semicolon
multiline_comment|/* stop receiving characters. We just turn off the URB request, and&n;&t;   let chars pile up in the device. If we&squot;re doing hardware&n;&t;   flowcontrol, the device will signal the other end when its buffer&n;&t;   fills up. If we&squot;re doing XON/XOFF, this would be a good time to&n;&t;   send an XOFF, although it might make sense to foist that off&n;&t;   upon the device too. */
singleline_comment|// usb_unlink_urb(port-&gt;interrupt_in_urb);
)brace
DECL|function|digi_rx_unthrottle
r_static
r_void
id|digi_rx_unthrottle
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
macro_line|#ifdef DEBUG
id|digi_private_t
op_star
id|priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
macro_line|#endif
id|dbg
c_func
(paren
l_string|&quot;digi_rx_unthrottle: TOP: port=%d&quot;
comma
id|priv-&gt;dp_port_num
)paren
suffix:semicolon
multiline_comment|/* just restart the receive interrupt URB */
singleline_comment|//if (usb_submit_urb(port-&gt;interrupt_in_urb))
singleline_comment|//&t;dbg( &quot;digi_rx_unthrottle: usb_submit_urb failed&quot; );
)brace
DECL|function|digi_set_termios
r_static
r_void
id|digi_set_termios
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
id|digi_private_t
op_star
id|priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_int
r_int
id|iflag
op_assign
id|port-&gt;tty-&gt;termios-&gt;c_iflag
suffix:semicolon
r_int
r_int
id|cflag
op_assign
id|port-&gt;tty-&gt;termios-&gt;c_cflag
suffix:semicolon
r_int
r_int
id|old_iflag
op_assign
id|old_termios-&gt;c_iflag
suffix:semicolon
r_int
r_int
id|old_cflag
op_assign
id|old_termios-&gt;c_cflag
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|32
)braket
suffix:semicolon
r_int
id|arg
comma
id|ret
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;digi_set_termios: TOP: port=%d, iflag=0x%x, old_iflag=0x%x, cflag=0x%x, old_cflag=0x%x&quot;
comma
id|priv-&gt;dp_port_num
comma
id|iflag
comma
id|old_iflag
comma
id|cflag
comma
id|old_cflag
)paren
suffix:semicolon
multiline_comment|/* set baud rate */
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|CBAUD
)paren
op_ne
(paren
id|old_cflag
op_amp
id|CBAUD
)paren
)paren
(brace
id|arg
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* reassert DTR and (maybe) RTS on transition from B0 */
r_if
c_cond
(paren
(paren
id|old_cflag
op_amp
id|CBAUD
)paren
op_eq
id|B0
)paren
(brace
multiline_comment|/* don&squot;t set RTS if using hardware flow control */
multiline_comment|/* and throttling input -- not implemented yet */
id|digi_set_modem_signals
c_func
(paren
id|port
comma
id|TIOCM_DTR
op_or
id|TIOCM_RTS
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
(paren
id|cflag
op_amp
id|CBAUD
)paren
)paren
(brace
multiline_comment|/* drop DTR and RTS on transition to B0 */
r_case
id|B0
suffix:colon
id|digi_set_modem_signals
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B50
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_50
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B75
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_75
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B110
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_110
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B150
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_150
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B200
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_200
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B300
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_300
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B600
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_600
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B1200
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_1200
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B1800
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_1800
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B2400
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_2400
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B4800
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_4800
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B9600
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_9600
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B19200
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_19200
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B38400
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_38400
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B57600
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_57600
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B115200
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_115200
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B230400
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_230400
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B460800
suffix:colon
id|arg
op_assign
id|DIGI_BAUD_460800
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;digi_set_termios: can&squot;t handle baud rate 0x%x&quot;
comma
(paren
id|cflag
op_amp
id|CBAUD
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_ne
op_minus
l_int|1
)paren
(brace
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|DIGI_CMD_SET_BAUD_RATE
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|priv-&gt;dp_port_num
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|arg
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* set parity */
r_if
c_cond
(paren
(paren
id|cflag
op_amp
(paren
id|PARENB
op_or
id|PARODD
)paren
)paren
op_ne
(paren
id|old_cflag
op_amp
(paren
id|PARENB
op_or
id|PARODD
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|PARENB
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|PARODD
)paren
)paren
(brace
id|arg
op_assign
id|DIGI_PARITY_ODD
suffix:semicolon
)brace
r_else
id|arg
op_assign
id|DIGI_PARITY_EVEN
suffix:semicolon
)brace
r_else
(brace
id|arg
op_assign
id|DIGI_PARITY_NONE
suffix:semicolon
)brace
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|DIGI_CMD_SET_PARITY
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|priv-&gt;dp_port_num
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|arg
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* set word size */
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|CSIZE
)paren
op_ne
(paren
id|old_cflag
op_amp
id|CSIZE
)paren
)paren
(brace
id|arg
op_assign
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|cflag
op_amp
id|CSIZE
)paren
)paren
(brace
r_case
id|CS5
suffix:colon
id|arg
op_assign
id|DIGI_WORD_SIZE_5
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS6
suffix:colon
id|arg
op_assign
id|DIGI_WORD_SIZE_6
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS7
suffix:colon
id|arg
op_assign
id|DIGI_WORD_SIZE_7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS8
suffix:colon
id|arg
op_assign
id|DIGI_WORD_SIZE_8
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;digi_set_termios: can&squot;t handle word size %d&quot;
comma
(paren
id|cflag
op_amp
id|CSIZE
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_ne
op_minus
l_int|1
)paren
(brace
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|DIGI_CMD_SET_WORD_SIZE
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|priv-&gt;dp_port_num
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|arg
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* set stop bits */
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|CSTOPB
)paren
op_ne
(paren
id|old_cflag
op_amp
id|CSTOPB
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|CSTOPB
)paren
)paren
(brace
id|arg
op_assign
id|DIGI_STOP_BITS_2
suffix:semicolon
)brace
r_else
id|arg
op_assign
id|DIGI_STOP_BITS_1
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|DIGI_CMD_SET_STOP_BITS
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|priv-&gt;dp_port_num
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|arg
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* set input flow control */
r_if
c_cond
(paren
(paren
id|iflag
op_amp
id|IXOFF
)paren
op_ne
(paren
id|old_iflag
op_amp
id|IXOFF
)paren
op_logical_or
(paren
id|cflag
op_amp
id|CRTSCTS
)paren
op_ne
(paren
id|old_cflag
op_amp
id|CRTSCTS
)paren
)paren
(brace
id|arg
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iflag
op_amp
id|IXOFF
)paren
)paren
(brace
id|arg
op_or_assign
id|DIGI_INPUT_FLOW_CONTROL_XON_XOFF
suffix:semicolon
)brace
r_else
id|arg
op_and_assign
op_complement
id|DIGI_INPUT_FLOW_CONTROL_XON_XOFF
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|CRTSCTS
)paren
)paren
(brace
id|arg
op_or_assign
id|DIGI_INPUT_FLOW_CONTROL_RTS
suffix:semicolon
)brace
r_else
id|arg
op_and_assign
op_complement
id|DIGI_INPUT_FLOW_CONTROL_RTS
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|DIGI_CMD_SET_INPUT_FLOW_CONTROL
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|priv-&gt;dp_port_num
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|arg
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* set output flow control */
multiline_comment|/*if( (iflag&amp;IXON) != (old_iflag&amp;IXON)&n;&t;|| (cflag&amp;CRTSCTS) != (old_cflag&amp;CRTSCTS) )*/
(brace
id|arg
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iflag
op_amp
id|IXON
)paren
)paren
(brace
id|arg
op_or_assign
id|DIGI_OUTPUT_FLOW_CONTROL_XON_XOFF
suffix:semicolon
)brace
r_else
id|arg
op_and_assign
op_complement
id|DIGI_OUTPUT_FLOW_CONTROL_XON_XOFF
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|CRTSCTS
)paren
)paren
(brace
id|arg
op_or_assign
id|DIGI_OUTPUT_FLOW_CONTROL_CTS
suffix:semicolon
)brace
r_else
id|arg
op_and_assign
op_complement
id|DIGI_OUTPUT_FLOW_CONTROL_CTS
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|DIGI_CMD_SET_OUTPUT_FLOW_CONTROL
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|priv-&gt;dp_port_num
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|arg
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* set receive enable/disable */
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|CREAD
)paren
op_ne
(paren
id|old_cflag
op_amp
id|CREAD
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|CREAD
)paren
)paren
(brace
id|arg
op_assign
id|DIGI_ENABLE
suffix:semicolon
)brace
r_else
id|arg
op_assign
id|DIGI_DISABLE
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|DIGI_CMD_RECEIVE_ENABLE
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|priv-&gt;dp_port_num
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|arg
suffix:semicolon
id|buf
(braket
id|i
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|digi_write_oob_command
c_func
(paren
id|buf
comma
id|i
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;digi_set_termios: write oob failed, ret=%d&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
)brace
DECL|function|digi_break_ctl
r_static
r_void
id|digi_break_ctl
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_int
id|break_state
)paren
(brace
macro_line|#ifdef DEBUG
id|digi_private_t
op_star
id|priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
macro_line|#endif
id|dbg
c_func
(paren
l_string|&quot;digi_break_ctl: TOP: port=%d&quot;
comma
id|priv-&gt;dp_port_num
)paren
suffix:semicolon
)brace
DECL|function|digi_ioctl
r_static
r_int
id|digi_ioctl
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|digi_private_t
op_star
id|priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;digi_ioctl: TOP: port=%d, cmd=0x%x&quot;
comma
id|priv-&gt;dp_port_num
comma
id|cmd
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMGET
suffix:colon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
id|val
op_assign
id|priv-&gt;dp_modem_signals
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|arg
comma
op_amp
id|val
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCMSET
suffix:colon
r_case
id|TIOCMBIS
suffix:colon
r_case
id|TIOCMBIC
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|TIOCMBIS
)paren
(brace
id|val
op_assign
id|priv-&gt;dp_modem_signals
op_or
id|val
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd
op_eq
id|TIOCMBIC
)paren
(brace
id|val
op_assign
id|priv-&gt;dp_modem_signals
op_amp
op_complement
id|val
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|digi_set_modem_signals
c_func
(paren
id|port
comma
id|val
)paren
suffix:semicolon
r_case
id|TIOCMIWAIT
suffix:colon
multiline_comment|/* wait for any of the 4 modem inputs (DCD,RI,DSR,CTS)*/
multiline_comment|/* TODO */
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCGICOUNT
suffix:colon
multiline_comment|/* return count of modemline transitions */
multiline_comment|/* TODO */
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
DECL|function|digi_write
r_static
r_int
id|digi_write
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|ret
comma
id|data_len
comma
id|new_len
suffix:semicolon
id|digi_private_t
op_star
id|priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|port-&gt;write_urb-&gt;transfer_buffer
suffix:semicolon
r_int
r_char
id|user_buf
(braket
l_int|64
)braket
suffix:semicolon
multiline_comment|/* 64 bytes is max USB bulk packet */
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;digi_write: TOP: port=%d, count=%d, from_user=%d, in_interrupt=%d&quot;
comma
id|priv-&gt;dp_port_num
comma
id|count
comma
id|from_user
comma
id|in_interrupt
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* copy user data (which can sleep) before getting spin lock */
id|count
op_assign
id|MIN
c_func
(paren
l_int|64
comma
id|MIN
c_func
(paren
id|count
comma
id|port-&gt;bulk_out_size
op_minus
l_int|2
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from_user
op_logical_and
id|copy_from_user
c_func
(paren
id|user_buf
comma
id|buf
comma
id|count
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* be sure only one write proceeds at a time */
multiline_comment|/* there are races on the port private buffer */
multiline_comment|/* and races to check write_urb-&gt;status */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* wait for urb status clear to submit another urb */
r_if
c_cond
(paren
id|port-&gt;write_urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
multiline_comment|/* buffer data if count is 1 (probably put_char) if possible */
r_if
c_cond
(paren
id|count
op_eq
l_int|1
)paren
(brace
id|new_len
op_assign
id|MIN
c_func
(paren
id|count
comma
id|DIGI_PORT_BUF_LEN
op_minus
id|priv-&gt;dp_buf_len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|priv-&gt;dp_buf
op_plus
id|priv-&gt;dp_buf_len
comma
id|buf
comma
id|new_len
)paren
suffix:semicolon
id|priv-&gt;dp_buf_len
op_add_assign
id|new_len
suffix:semicolon
)brace
r_else
(brace
id|new_len
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|new_len
suffix:semicolon
)brace
multiline_comment|/* allow space for any buffered data and for new data, up to */
multiline_comment|/* transfer buffer size - 2 (for command and length bytes) */
id|new_len
op_assign
id|MIN
c_func
(paren
id|count
comma
id|port-&gt;bulk_out_size
op_minus
l_int|2
op_minus
id|priv-&gt;dp_buf_len
)paren
suffix:semicolon
id|data_len
op_assign
id|new_len
op_plus
id|priv-&gt;dp_buf_len
suffix:semicolon
r_if
c_cond
(paren
id|data_len
op_eq
l_int|0
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|port-&gt;write_urb-&gt;transfer_buffer_length
op_assign
id|data_len
op_plus
l_int|2
suffix:semicolon
op_star
id|data
op_increment
op_assign
id|DIGI_CMD_SEND_DATA
suffix:semicolon
op_star
id|data
op_increment
op_assign
id|data_len
suffix:semicolon
multiline_comment|/* copy in buffered data first */
id|memcpy
c_func
(paren
id|data
comma
id|priv-&gt;dp_buf
comma
id|priv-&gt;dp_buf_len
)paren
suffix:semicolon
id|data
op_add_assign
id|priv-&gt;dp_buf_len
suffix:semicolon
multiline_comment|/* copy in new data */
id|memcpy
c_func
(paren
id|data
comma
id|from_user
ques
c_cond
id|user_buf
suffix:colon
id|buf
comma
id|new_len
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_submit_urb
c_func
(paren
id|port-&gt;write_urb
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|new_len
suffix:semicolon
id|priv-&gt;dp_buf_len
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* return length of new data written, or error */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;digi_write: usb_submit_urb failed, ret=%d&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;digi_write: returning %d&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|digi_write_bulk_callback
r_static
r_void
id|digi_write_bulk_callback
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
suffix:semicolon
id|digi_private_t
op_star
id|priv
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;digi_write_bulk_callback: TOP&quot;
)paren
suffix:semicolon
multiline_comment|/* port sanity check */
r_if
c_cond
(paren
id|port
op_eq
l_int|NULL
op_logical_or
(paren
id|priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
id|__FUNCTION__
l_string|&quot;: port or port-&gt;private is NULL, status=%d&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* handle oob callback */
r_if
c_cond
(paren
id|priv-&gt;dp_port_num
op_eq
id|oob_port_num
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;digi_write_bulk_callback: oob callback&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|port-&gt;write_wait
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* sanity checks */
r_if
c_cond
(paren
id|port_paranoia_check
c_func
(paren
id|port
comma
l_string|&quot;digi_write_bulk_callback&quot;
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|serial
comma
l_string|&quot;digi_write_bulk_callback&quot;
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* try to send any buffered data on this port */
id|spin_lock
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;write_urb-&gt;status
op_ne
op_minus
id|EINPROGRESS
op_logical_and
id|priv-&gt;dp_buf_len
OG
l_int|0
)paren
(brace
op_star
(paren
(paren
r_int
r_char
op_star
)paren
(paren
id|port-&gt;write_urb-&gt;transfer_buffer
)paren
)paren
op_assign
(paren
r_int
r_char
)paren
id|DIGI_CMD_SEND_DATA
suffix:semicolon
op_star
(paren
(paren
r_int
r_char
op_star
)paren
(paren
id|port-&gt;write_urb-&gt;transfer_buffer
)paren
op_plus
l_int|1
)paren
op_assign
(paren
r_int
r_char
)paren
id|priv-&gt;dp_buf_len
suffix:semicolon
id|port-&gt;write_urb-&gt;transfer_buffer_length
op_assign
id|priv-&gt;dp_buf_len
op_plus
l_int|2
suffix:semicolon
id|memcpy
c_func
(paren
id|port-&gt;write_urb-&gt;transfer_buffer
op_plus
l_int|2
comma
id|priv-&gt;dp_buf
comma
id|priv-&gt;dp_buf_len
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_submit_urb
c_func
(paren
id|port-&gt;write_urb
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|priv-&gt;dp_buf_len
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* wake up processes sleeping on writes immediately */
id|digi_wakeup_write
c_func
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/* also queue up a wakeup at scheduler time, in case we */
multiline_comment|/* lost the race in write_chan(). */
id|queue_task
c_func
(paren
op_amp
id|priv-&gt;dp_wakeup_task
comma
op_amp
id|tq_scheduler
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|err
c_func
(paren
id|__FUNCTION__
l_string|&quot;: usb_submit_urb failed, ret=%d, port=%d&quot;
comma
id|ret
comma
id|priv-&gt;dp_port_num
)paren
suffix:semicolon
)brace
)brace
DECL|function|digi_write_room
r_static
r_int
id|digi_write_room
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
r_int
id|room
suffix:semicolon
id|digi_private_t
op_star
id|priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;write_urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
id|room
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|room
op_assign
id|port-&gt;bulk_out_size
op_minus
l_int|2
op_minus
id|priv-&gt;dp_buf_len
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;digi_write_room: port=%d, room=%d&quot;
comma
id|priv-&gt;dp_port_num
comma
id|room
)paren
suffix:semicolon
r_return
id|room
suffix:semicolon
)brace
DECL|function|digi_chars_in_buffer
r_static
r_int
id|digi_chars_in_buffer
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
id|digi_private_t
op_star
id|priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;write_urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;digi_chars_in_buffer: port=%d, chars=%d&quot;
comma
id|priv-&gt;dp_port_num
comma
id|port-&gt;bulk_out_size
op_minus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* return( port-&gt;bulk_out_size - 2 ); */
r_return
l_int|256
suffix:semicolon
)brace
r_else
(brace
id|dbg
c_func
(paren
l_string|&quot;digi_chars_in_buffer: port=%d, chars=%d&quot;
comma
id|priv-&gt;dp_port_num
comma
id|priv-&gt;dp_buf_len
)paren
suffix:semicolon
r_return
id|priv-&gt;dp_buf_len
suffix:semicolon
)brace
)brace
DECL|function|digi_open
r_static
r_int
id|digi_open
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|32
)braket
suffix:semicolon
id|digi_private_t
op_star
id|priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_struct
id|termios
id|not_termios
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;digi_open: TOP: port=%d, active=%d, open_count=%d&quot;
comma
id|priv-&gt;dp_port_num
comma
id|port-&gt;active
comma
id|priv-&gt;dp_open_count
)paren
suffix:semicolon
multiline_comment|/* be sure the device is started up */
r_if
c_cond
(paren
id|digi_startup_device
c_func
(paren
id|port-&gt;serial
)paren
op_ne
l_int|0
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* don&squot;t wait on a close in progress for non-blocking opens */
r_if
c_cond
(paren
id|priv-&gt;dp_in_close
op_logical_and
(paren
id|filp-&gt;f_flags
op_amp
(paren
id|O_NDELAY
op_or
id|O_NONBLOCK
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* wait for a close in progress to finish */
r_while
c_loop
(paren
id|priv-&gt;dp_in_close
)paren
(brace
id|cond_wait_interruptible_timeout_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_close_wait
comma
id|DIGI_RETRY_TIMEOUT
comma
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* if port is already open, just return */
multiline_comment|/* be sure exactly one open proceeds */
r_if
c_cond
(paren
id|port-&gt;active
)paren
(brace
op_increment
id|priv-&gt;dp_open_count
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* open is certain */
id|port-&gt;active
op_assign
l_int|1
suffix:semicolon
op_increment
id|priv-&gt;dp_open_count
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* read modem signals automatically whenever they change */
id|buf
(braket
l_int|0
)braket
op_assign
id|DIGI_CMD_READ_INPUT_SIGNALS
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
id|priv-&gt;dp_port_num
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
id|DIGI_ENABLE
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* flush fifos */
id|buf
(braket
l_int|4
)braket
op_assign
id|DIGI_CMD_IFLUSH_FIFO
suffix:semicolon
id|buf
(braket
l_int|5
)braket
op_assign
id|priv-&gt;dp_port_num
suffix:semicolon
id|buf
(braket
l_int|6
)braket
op_assign
id|DIGI_FLUSH_TX
op_or
id|DIGI_FLUSH_RX
suffix:semicolon
id|buf
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|digi_write_oob_command
c_func
(paren
id|buf
comma
l_int|8
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;digi_open: write oob failed, ret=%d&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/* set termios settings */
id|not_termios.c_cflag
op_assign
op_complement
id|port-&gt;tty-&gt;termios-&gt;c_cflag
suffix:semicolon
id|not_termios.c_iflag
op_assign
op_complement
id|port-&gt;tty-&gt;termios-&gt;c_iflag
suffix:semicolon
id|digi_set_termios
c_func
(paren
id|port
comma
op_amp
id|not_termios
)paren
suffix:semicolon
multiline_comment|/* set DTR and RTS */
id|digi_set_modem_signals
c_func
(paren
id|port
comma
id|TIOCM_DTR
op_or
id|TIOCM_RTS
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|digi_close
r_static
r_void
id|digi_close
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|32
)braket
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|port-&gt;tty
suffix:semicolon
id|digi_private_t
op_star
id|priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;digi_close: TOP: port=%d, active=%d, open_count=%d&quot;
comma
id|priv-&gt;dp_port_num
comma
id|port-&gt;active
comma
id|priv-&gt;dp_open_count
)paren
suffix:semicolon
multiline_comment|/* do cleanup only after final close on this port */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;dp_open_count
OG
l_int|1
)paren
(brace
op_decrement
id|priv-&gt;dp_open_count
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|priv-&gt;dp_open_count
op_le
l_int|0
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|priv-&gt;dp_in_close
op_assign
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* tell line discipline to process only XON/XOFF */
id|tty-&gt;closing
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* wait for output to drain */
r_if
c_cond
(paren
(paren
id|filp-&gt;f_flags
op_amp
(paren
id|O_NDELAY
op_or
id|O_NONBLOCK
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
id|DIGI_CLOSE_TIMEOUT
)paren
suffix:semicolon
)brace
multiline_comment|/* flush driver and line discipline buffers */
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
(brace
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
(brace
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* wait for transmit idle */
r_if
c_cond
(paren
(paren
id|filp-&gt;f_flags
op_amp
(paren
id|O_NDELAY
op_or
id|O_NONBLOCK
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|digi_transmit_idle
c_func
(paren
id|port
comma
id|DIGI_CLOSE_TIMEOUT
)paren
suffix:semicolon
)brace
multiline_comment|/* drop DTR and RTS */
id|digi_set_modem_signals
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable input flow control */
id|buf
(braket
l_int|0
)braket
op_assign
id|DIGI_CMD_SET_INPUT_FLOW_CONTROL
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
id|priv-&gt;dp_port_num
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
id|DIGI_DISABLE
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* disable output flow control */
id|buf
(braket
l_int|4
)braket
op_assign
id|DIGI_CMD_SET_OUTPUT_FLOW_CONTROL
suffix:semicolon
id|buf
(braket
l_int|5
)braket
op_assign
id|priv-&gt;dp_port_num
suffix:semicolon
id|buf
(braket
l_int|6
)braket
op_assign
id|DIGI_DISABLE
suffix:semicolon
id|buf
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* disable reading modem signals automatically */
id|buf
(braket
l_int|8
)braket
op_assign
id|DIGI_CMD_READ_INPUT_SIGNALS
suffix:semicolon
id|buf
(braket
l_int|9
)braket
op_assign
id|priv-&gt;dp_port_num
suffix:semicolon
id|buf
(braket
l_int|10
)braket
op_assign
id|DIGI_DISABLE
suffix:semicolon
id|buf
(braket
l_int|11
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* flush fifos */
id|buf
(braket
l_int|12
)braket
op_assign
id|DIGI_CMD_IFLUSH_FIFO
suffix:semicolon
id|buf
(braket
l_int|13
)braket
op_assign
id|priv-&gt;dp_port_num
suffix:semicolon
id|buf
(braket
l_int|14
)braket
op_assign
id|DIGI_FLUSH_TX
op_or
id|DIGI_FLUSH_RX
suffix:semicolon
id|buf
(braket
l_int|15
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* disable receive */
id|buf
(braket
l_int|16
)braket
op_assign
id|DIGI_CMD_RECEIVE_ENABLE
suffix:semicolon
id|buf
(braket
l_int|17
)braket
op_assign
id|priv-&gt;dp_port_num
suffix:semicolon
id|buf
(braket
l_int|18
)braket
op_assign
id|DIGI_DISABLE
suffix:semicolon
id|buf
(braket
l_int|19
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|digi_write_oob_command
c_func
(paren
id|buf
comma
l_int|20
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;digi_close: write oob failed, ret=%d&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/* wait for final commands on oob port to complete */
r_while
c_loop
(paren
id|oob_port-&gt;write_urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|oob_port-&gt;write_wait
comma
id|DIGI_RETRY_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* shutdown any outstanding bulk writes */
id|usb_unlink_urb
(paren
id|port-&gt;write_urb
)paren
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
id|port-&gt;active
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;dp_in_close
op_assign
l_int|0
suffix:semicolon
op_decrement
id|priv-&gt;dp_open_count
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|priv-&gt;dp_close_wait
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;digi_close: done&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;*  Digi Startup Device&n;*&n;*  Starts reads on all ports.  Must be called AFTER startup, with&n;*  urbs initialized.  Returns 0 if successful, non-zero error otherwise.&n;*/
DECL|function|digi_startup_device
r_static
r_int
id|digi_startup_device
c_func
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* be sure this happens exactly once */
id|spin_lock
c_func
(paren
op_amp
id|startup_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device_startup
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|startup_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|device_startup
op_assign
l_int|1
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|startup_lock
)paren
suffix:semicolon
multiline_comment|/* start reading from each bulk in endpoint for the device */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|digi_acceleport_device.num_ports
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_submit_urb
c_func
(paren
id|serial-&gt;port
(braket
id|i
)braket
dot
id|read_urb
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;digi_startup_device: usb_submit_urb failed, port=%d, ret=%d&quot;
comma
id|i
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|digi_startup
r_static
r_int
id|digi_startup
c_func
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
r_int
id|i
suffix:semicolon
id|digi_private_t
op_star
id|priv
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;digi_startup: TOP&quot;
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|startup_lock
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|modem_change_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|transmit_idle_wait
)paren
suffix:semicolon
multiline_comment|/* allocate the private data structures for all ports */
multiline_comment|/* number of regular ports + 1 for the out-of-band port */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|digi_acceleport_device.num_ports
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|serial-&gt;port
(braket
id|i
)braket
dot
id|active
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* allocate private structure */
id|priv
op_assign
id|serial-&gt;port
(braket
id|i
)braket
dot
r_private
op_assign
(paren
id|digi_private_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|digi_private_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv
op_eq
(paren
id|digi_private_t
op_star
)paren
l_int|0
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* error */
multiline_comment|/* initialize private structure */
id|priv-&gt;dp_port_num
op_assign
id|i
suffix:semicolon
id|priv-&gt;dp_buf_len
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;dp_modem_signals
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;dp_open_count
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;dp_transmit_idle
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;dp_in_close
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|priv-&gt;dp_close_wait
)paren
suffix:semicolon
id|priv-&gt;dp_wakeup_task.next
op_assign
l_int|NULL
suffix:semicolon
id|priv-&gt;dp_wakeup_task.sync
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;dp_wakeup_task.routine
op_assign
(paren
r_void
op_star
)paren
id|digi_wakeup_write_lock
suffix:semicolon
id|priv-&gt;dp_wakeup_task.data
op_assign
(paren
r_void
op_star
)paren
(paren
op_amp
id|serial-&gt;port
(braket
id|i
)braket
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
)paren
suffix:semicolon
multiline_comment|/* initialize write wait queue for this port */
id|init_waitqueue_head
c_func
(paren
op_amp
id|serial-&gt;port
(braket
id|i
)braket
dot
id|write_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* initialize out of band port info */
id|oob_port_num
op_assign
id|digi_acceleport_device.num_ports
suffix:semicolon
id|oob_port
op_assign
op_amp
id|serial-&gt;port
(braket
id|oob_port_num
)braket
suffix:semicolon
id|device_startup
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|digi_shutdown
r_static
r_void
id|digi_shutdown
c_func
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
r_int
id|i
suffix:semicolon
id|digi_private_t
op_star
id|priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;digi_shutdown: TOP, in_interrupt()=%d&quot;
comma
id|in_interrupt
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* stop reads and writes on all ports */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|digi_acceleport_device.num_ports
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|usb_unlink_urb
c_func
(paren
id|serial-&gt;port
(braket
id|i
)braket
dot
id|read_urb
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|serial-&gt;port
(braket
id|i
)braket
dot
id|write_urb
)paren
suffix:semicolon
)brace
id|device_startup
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* dec module use count */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|digi_acceleport_device.num_ports
suffix:semicolon
id|i
op_increment
)paren
(brace
id|priv
op_assign
id|serial-&gt;port
(braket
id|i
)braket
dot
r_private
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|priv-&gt;dp_open_count
OG
l_int|0
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
op_decrement
id|priv-&gt;dp_open_count
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* free the private data structures for all ports */
multiline_comment|/* number of regular ports + 1 for the out-of-band port */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|digi_acceleport_device.num_ports
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kfree
c_func
(paren
id|serial-&gt;port
(braket
id|i
)braket
dot
r_private
)paren
suffix:semicolon
)brace
)brace
DECL|function|digi_read_bulk_callback
r_static
r_void
id|digi_read_bulk_callback
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|urb-&gt;context
suffix:semicolon
id|digi_private_t
op_star
id|priv
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;digi_read_bulk_callback: TOP&quot;
)paren
suffix:semicolon
multiline_comment|/* port sanity check, do not resubmit if port is not valid */
r_if
c_cond
(paren
id|port
op_eq
l_int|NULL
op_logical_or
(paren
id|priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
id|__FUNCTION__
l_string|&quot;: port or port-&gt;private is NULL, status=%d&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* do not resubmit urb if it has any status error */
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
id|err
c_func
(paren
id|__FUNCTION__
l_string|&quot;: nonzero read bulk status: status=%d, port=%d&quot;
comma
id|urb-&gt;status
comma
id|priv-&gt;dp_port_num
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* handle oob or inb callback, do not resubmit if error */
r_if
c_cond
(paren
id|priv-&gt;dp_port_num
op_eq
id|oob_port_num
)paren
(brace
r_if
c_cond
(paren
id|digi_read_oob_callback
c_func
(paren
id|urb
)paren
op_ne
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|digi_read_inb_callback
c_func
(paren
id|urb
)paren
op_ne
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* continue read */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_submit_urb
c_func
(paren
id|urb
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|err
c_func
(paren
id|__FUNCTION__
l_string|&quot;: failed resubmitting urb, ret=%d, port=%d&quot;
comma
id|ret
comma
id|priv-&gt;dp_port_num
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;*  Digi Read INB Callback&n;*&n;*  Digi Read INB Callback handles reads on the in band ports, sending&n;*  the data on to the tty subsystem.  When called we know port and&n;*  port-&gt;private are not NULL.  It returns 0 if successful, and -1 if&n;*  the sanity checks failed.&n;*/
DECL|function|digi_read_inb_callback
r_static
r_int
id|digi_read_inb_callback
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|port-&gt;tty
suffix:semicolon
id|digi_private_t
op_star
id|priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_int
id|opcode
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|urb-&gt;transfer_buffer
)paren
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|len
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|urb-&gt;transfer_buffer
)paren
(braket
l_int|1
)braket
suffix:semicolon
r_int
id|status
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|urb-&gt;transfer_buffer
)paren
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|urb-&gt;transfer_buffer
)paren
op_plus
l_int|3
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* sanity checks */
r_if
c_cond
(paren
id|port_paranoia_check
c_func
(paren
id|port
comma
id|__FUNCTION__
)paren
op_logical_or
id|serial_paranoia_check
c_func
(paren
id|serial
comma
id|__FUNCTION__
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* short packet check */
r_if
c_cond
(paren
id|urb-&gt;actual_length
op_ne
id|len
op_plus
l_int|2
)paren
(brace
id|err
c_func
(paren
id|__FUNCTION__
l_string|&quot;: INCOMPLETE PACKET, urb-&gt;status=%d, port=%d, opcode=%d, len=%d, actual_length=%d, status=%d&quot;
comma
id|urb-&gt;status
comma
id|priv-&gt;dp_port_num
comma
id|opcode
comma
id|len
comma
id|urb-&gt;actual_length
comma
id|status
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* receive data */
r_if
c_cond
(paren
id|opcode
op_eq
id|DIGI_CMD_RECEIVE_DATA
op_logical_and
id|urb-&gt;actual_length
OG
l_int|3
)paren
(brace
id|len
op_assign
id|MIN
c_func
(paren
id|len
comma
id|urb-&gt;actual_length
op_minus
l_int|3
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
op_increment
id|i
)paren
(brace
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|data
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n;*  Digi Read OOB Callback&n;*&n;*  Digi Read OOB Callback handles reads on the out of band port.&n;*  When called we know port and port-&gt;private are not NULL.  It&n;*  returns 0 if successful, and -1 if the sanity checks failed.&n;*/
DECL|function|digi_read_oob_callback
r_static
r_int
id|digi_read_oob_callback
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
id|digi_private_t
op_star
id|priv
op_assign
(paren
id|digi_private_t
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_int
id|opcode
comma
id|line
comma
id|status
comma
id|val
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;digi_read_oob_callback: len=%d&quot;
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|serial
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
id|__FUNCTION__
l_string|&quot;: port-&gt;serial is NULL, status=%d, port=%d&quot;
comma
id|urb-&gt;status
comma
id|priv-&gt;dp_port_num
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* handle each oob command */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;actual_length
op_minus
l_int|3
suffix:semicolon
)paren
(brace
id|opcode
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|urb-&gt;transfer_buffer
)paren
(braket
id|i
op_increment
)braket
suffix:semicolon
id|line
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|urb-&gt;transfer_buffer
)paren
(braket
id|i
op_increment
)braket
suffix:semicolon
id|status
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|urb-&gt;transfer_buffer
)paren
(braket
id|i
op_increment
)braket
suffix:semicolon
id|val
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|urb-&gt;transfer_buffer
)paren
(braket
id|i
op_increment
)braket
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;digi_read_oob_callback: opcode=%d, line=%d, status=%d, val=%d&quot;
comma
id|opcode
comma
id|line
comma
id|status
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|priv
op_assign
id|serial-&gt;port
(braket
id|line
)braket
dot
r_private
)paren
op_eq
l_int|NULL
)paren
(brace
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot;: port[%d].private is NULL!&quot;
comma
id|line
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opcode
op_eq
id|DIGI_CMD_READ_INPUT_SIGNALS
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
)paren
suffix:semicolon
multiline_comment|/* convert from digi flags to termiox flags */
r_if
c_cond
(paren
id|val
op_amp
id|DIGI_READ_INPUT_SIGNALS_CTS
)paren
(brace
id|priv-&gt;dp_modem_signals
op_or_assign
id|TIOCM_CTS
suffix:semicolon
)brace
r_else
id|priv-&gt;dp_modem_signals
op_and_assign
op_complement
id|TIOCM_CTS
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
id|DIGI_READ_INPUT_SIGNALS_DSR
)paren
(brace
id|priv-&gt;dp_modem_signals
op_or_assign
id|TIOCM_DSR
suffix:semicolon
)brace
r_else
id|priv-&gt;dp_modem_signals
op_and_assign
op_complement
id|TIOCM_DSR
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
id|DIGI_READ_INPUT_SIGNALS_RI
)paren
(brace
id|priv-&gt;dp_modem_signals
op_or_assign
id|TIOCM_RI
suffix:semicolon
)brace
r_else
id|priv-&gt;dp_modem_signals
op_and_assign
op_complement
id|TIOCM_RI
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
id|DIGI_READ_INPUT_SIGNALS_DCD
)paren
(brace
id|priv-&gt;dp_modem_signals
op_or_assign
id|TIOCM_CD
suffix:semicolon
)brace
r_else
id|priv-&gt;dp_modem_signals
op_and_assign
op_complement
id|TIOCM_CD
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|modem_change_wait
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|opcode
op_eq
id|DIGI_CMD_TRANSMIT_IDLE
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
)paren
suffix:semicolon
id|priv-&gt;dp_transmit_idle
op_assign
l_int|1
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|transmit_idle_wait
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|priv-&gt;dp_port_lock
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|digi_init
r_int
id|digi_init
(paren
r_void
)paren
(brace
id|usb_serial_register
(paren
op_amp
id|digi_acceleport_device
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|digi_exit
r_void
id|digi_exit
(paren
r_void
)paren
(brace
id|usb_serial_deregister
(paren
op_amp
id|digi_acceleport_device
)paren
suffix:semicolon
)brace
DECL|variable|digi_init
id|module_init
c_func
(paren
id|digi_init
)paren
suffix:semicolon
DECL|variable|digi_exit
id|module_exit
c_func
(paren
id|digi_exit
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Peter Berger &lt;pberger@brimson.com&gt;, Al Borchers &lt;borchers@steinerpoint.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Digi AccelePort USB-4 Serial Converter driver&quot;
)paren
suffix:semicolon
eof
