multiline_comment|/*&n; * USB Serial Converter driver&n; *&n; *&t;(C) Copyright (C) 1999, 2000&n; *&t;    Greg Kroah-Hartman (greg@kroah.com)&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; * This driver was originally based on the ACM driver by Armin Fuerst (which was &n; * based on a driver by Brad Keryan)&n; *&n; * See Documentation/usb/usb-serial.txt for more information on using this driver&n; * &n; * (03/17/2000) gkh&n; *&t;Added config option for debugging messages.&n; *&t;Added patch for keyspan pda from Brian Warner.&n; *&n; * (03/06/2000) gkh&n; *&t;Added the keyspan pda code from Brian Warner &lt;warner@lothar.com&gt;&n; *&t;Moved a bunch of the port specific stuff into its own structure. This&n; *&t;is in anticipation of the true multiport devices (there&squot;s a bug if you&n; *&t;try to access more than one port of any multiport device right now)&n; *&n; * (02/21/2000) gkh&n; *&t;Made it so that any serial devices only have to specify which functions&n; *&t;they want to overload from the generic function calls (great, &n; *&t;inheritance in C, in a driver, just what I wanted...)&n; *&t;Added support for set_termios and ioctl function calls. No drivers take&n; *&t;advantage of this yet.&n; *&t;Removed the #ifdef MODULE, now there is no module specific code.&n; *&t;Cleaned up a few comments in usb-serial.h that were wrong (thanks again&n; *&t;to Miles Lott).&n; *&t;Small fix to get_free_serial.&n; *&n; * (02/14/2000) gkh&n; *&t;Removed the Belkin and Peracom functionality from the driver due to&n; *&t;the lack of support from the vendor, and me not wanting people to &n; *&t;accidenatly buy the device, expecting it to work with Linux.&n; *&t;Added read_bulk_callback and write_bulk_callback to the type structure&n; *&t;for the needs of the FTDI and WhiteHEAT driver.&n; *&t;Changed all reverences to FTDI to FTDI_SIO at the request of Bill&n; *&t;Ryder.&n; *&t;Changed the output urb size back to the max endpoint size to make&n; *&t;the ftdi_sio driver have it easier, and due to the fact that it didn&squot;t&n; *&t;really increase the speed any.&n; *&n; * (02/11/2000) gkh&n; *&t;Added VISOR_FUNCTION_CONSOLE to the visor startup function. This was a&n; *&t;patch from Miles Lott (milos@insync.net).&n; *&t;Fixed bug with not restoring the minor range that a device grabs, if&n; *&t;the startup function fails (thanks Miles for finding this).&n; *&n; * (02/05/2000) gkh&n; *&t;Added initial framework for the Keyspan PDA serial converter so that&n; *&t;Brian Warner has a place to put his code.&n; *&t;Made the ezusb specific functions generic enough that different&n; *&t;devices can use them (whiteheat and keyspan_pda both need them).&n; *&t;Split out a whole bunch of structure and other stuff to a seperate&n; *&t;usb-serial.h file.&n; *&t;Made the Visor connection messages a little more understandable, now&n; *&t;that Miles Lott (milos@insync.net) has gotten the Generic channel to&n; *&t;work. Also made them always show up in the log file.&n; * &n; * (01/25/2000) gkh&n; *&t;Added initial framework for FTDI serial converter so that Bill Ryder&n; *&t;has a place to put his code.&n; *&t;Added the vendor specific info from Handspring. Now we can print out&n; *&t;informational debug messages as well as understand what is happening.&n; *&n; * (01/23/2000) gkh&n; *&t;Fixed problem of crash when trying to open a port that didn&squot;t have a&n; *&t;device assigned to it. Made the minor node finding a little smarter,&n; *&t;now it looks to find a continous space for the new device.&n; *&n; * (01/21/2000) gkh&n; *&t;Fixed bug in visor_startup with patch from Miles Lott (milos@insync.net)&n; *&t;Fixed get_serial_by_minor which was all messed up for multi port &n; *&t;devices. Fixed multi port problem for generic devices. Now the number&n; *&t;of ports is determined by the number of bulk out endpoints for the&n; *&t;generic device.&n; *&n; * (01/19/2000) gkh&n; *&t;Removed lots of cruft that was around from the old (pre urb) driver &n; *&t;interface.&n; *&t;Made the serial_table dynamic. This should save lots of memory when&n; *&t;the number of minor nodes goes up to 256.&n; *&t;Added initial support for devices that have more than one port. &n; *&t;Added more debugging comments for the Visor, and added a needed &n; *&t;set_configuration call.&n; *&n; * (01/17/2000) gkh&n; *&t;Fixed the WhiteHEAT firmware (my processing tool had a bug)&n; *&t;and added new debug loader firmware for it.&n; *&t;Removed the put_char function as it isn&squot;t really needed.&n; *&t;Added visor startup commands as found by the Win98 dump.&n; * &n; * (01/13/2000) gkh&n; *&t;Fixed the vendor id for the generic driver to the one I meant it to be.&n; *&n; * (01/12/2000) gkh&n; *&t;Forget the version numbering...that&squot;s pretty useless...&n; *&t;Made the driver able to be compiled so that the user can select which&n; *&t;converter they want to use. This allows people who only want the Visor&n; *&t;support to not pay the memory size price of the WhiteHEAT.&n; *&t;Fixed bug where the generic driver (idVendor=0000 and idProduct=0000)&n; *&t;grabbed the root hub. Not good.&n; * &n; * version 0.4.0 (01/10/2000) gkh&n; *&t;Added whiteheat.h containing the firmware for the ConnectTech WhiteHEAT&n; *&t;device. Added startup function to allow firmware to be downloaded to&n; *&t;a device if it needs to be.&n; *&t;Added firmware download logic to the WhiteHEAT device.&n; *&t;Started to add #defines to split up the different drivers for potential&n; *&t;configuration option.&n; *&t;&n; * version 0.3.1 (12/30/99) gkh&n; *      Fixed problems with urb for bulk out.&n; *      Added initial support for multiple sets of endpoints. This enables&n; *      the Handspring Visor to be attached successfully. Only the first&n; *      bulk in / bulk out endpoint pair is being used right now.&n; *&n; * version 0.3.0 (12/27/99) gkh&n; *&t;Added initial support for the Handspring Visor based on a patch from&n; *&t;Miles Lott (milos@sneety.insync.net)&n; *&t;Cleaned up the code a bunch and converted over to using urbs only.&n; *&n; * version 0.2.3 (12/21/99) gkh&n; *&t;Added initial support for the Connect Tech WhiteHEAT converter.&n; *&t;Incremented the number of ports in expectation of getting the&n; *&t;WhiteHEAT to work properly (4 ports per connection).&n; *&t;Added notification on insertion and removal of what port the&n; *&t;device is/was connected to (and what kind of device it was).&n; *&n; * version 0.2.2 (12/16/99) gkh&n; *&t;Changed major number to the new allocated number. We&squot;re legal now!&n; *&n; * version 0.2.1 (12/14/99) gkh&n; *&t;Fixed bug that happens when device node is opened when there isn&squot;t a&n; *&t;device attached to it. Thanks to marek@webdesign.no for noticing this.&n; *&n; * version 0.2.0 (11/10/99) gkh&n; *&t;Split up internals to make it easier to add different types of serial &n; *&t;converters to the code.&n; *&t;Added a &quot;generic&quot; driver that gets it&squot;s vendor and product id&n; *&t;from when the module is loaded. Thanks to David E. Nelson (dnelson@jump.net)&n; *&t;for the idea and sample code (from the usb scanner driver.)&n; *&t;Cleared up any licensing questions by releasing it under the GNU GPL.&n; *&n; * version 0.1.2 (10/25/99) gkh&n; * &t;Fixed bug in detecting device.&n; *&n; * version 0.1.1 (10/05/99) gkh&n; * &t;Changed the major number to not conflict with anything else.&n; *&n; * version 0.1 (09/28/99) gkh&n; * &t;Can recognize the two different devices and start up a read from&n; *&t;device when asked to. Writes also work. No control signals yet, this&n; *&t;all is vendor specific data (i.e. no spec), also no control for&n; *&t;different baud rates or other bit settings.&n; *&t;Currently we are using the same devid as the acm driver. This needs&n; *&t;to change.&n; * &n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/tty_driver.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#ifdef CONFIG_USB_SERIAL_DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#else
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#ifdef CONFIG_USB_SERIAL_WHITEHEAT
macro_line|#include &quot;whiteheat.h&quot;&t;&t;/* firmware for the ConnectTech WhiteHEAT device */
macro_line|#endif
macro_line|#ifdef CONFIG_USB_SERIAL_KEYSPAN_PDA
DECL|struct|ezusb_hex_record
r_struct
id|ezusb_hex_record
(brace
DECL|member|address
id|__u16
id|address
suffix:semicolon
DECL|member|data_size
id|__u8
id|data_size
suffix:semicolon
DECL|member|data
id|__u8
id|data
(braket
l_int|16
)braket
suffix:semicolon
)brace
suffix:semicolon
macro_line|#include &quot;keyspan_pda_fw.h&quot;
macro_line|#endif
macro_line|#include &quot;usb-serial.h&quot;
multiline_comment|/* parity check flag */
DECL|macro|RELEVANT_IFLAG
mdefine_line|#define RELEVANT_IFLAG(iflag)&t;(iflag &amp; (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
multiline_comment|/* local function prototypes */
r_static
r_int
id|serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|serial_close
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_int
id|serial_write
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_int
id|serial_write_room
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|serial_chars_in_buffer
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|serial_throttle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|serial_unthrottle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|serial_ioctl
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_void
id|serial_set_termios
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old
)paren
suffix:semicolon
r_static
r_void
op_star
id|usb_serial_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
)paren
suffix:semicolon
r_static
r_void
id|usb_serial_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
suffix:semicolon
DECL|variable|usb_serial_driver
r_static
r_struct
id|usb_driver
id|usb_serial_driver
op_assign
(brace
l_string|&quot;serial&quot;
comma
id|usb_serial_probe
comma
id|usb_serial_disconnect
comma
(brace
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|variable|serial_refcount
r_static
r_int
id|serial_refcount
suffix:semicolon
DECL|variable|serial_tty
r_static
r_struct
id|tty_struct
op_star
id|serial_tty
(braket
id|SERIAL_TTY_MINORS
)braket
suffix:semicolon
DECL|variable|serial_termios
r_static
r_struct
id|termios
op_star
id|serial_termios
(braket
id|SERIAL_TTY_MINORS
)braket
suffix:semicolon
DECL|variable|serial_termios_locked
r_static
r_struct
id|termios
op_star
id|serial_termios_locked
(braket
id|SERIAL_TTY_MINORS
)braket
suffix:semicolon
DECL|variable|serial_table
r_static
r_struct
id|usb_serial
op_star
id|serial_table
(braket
id|SERIAL_TTY_MINORS
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|function|get_serial_by_minor
r_static
r_struct
id|usb_serial
op_star
id|get_serial_by_minor
(paren
r_int
id|minor
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;get_serial_by_minor %d&quot;
comma
id|minor
)paren
suffix:semicolon
r_return
id|serial_table
(braket
id|minor
)braket
suffix:semicolon
)brace
DECL|function|get_free_serial
r_static
r_struct
id|usb_serial
op_star
id|get_free_serial
(paren
r_int
id|num_ports
comma
r_int
op_star
id|minor
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|good_spot
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;get_free_serial %d&quot;
comma
id|num_ports
)paren
suffix:semicolon
op_star
id|minor
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SERIAL_TTY_MINORS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|serial_table
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|good_spot
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
op_le
id|num_ports
op_minus
l_int|1
suffix:semicolon
op_increment
id|j
)paren
r_if
c_cond
(paren
id|serial_table
(braket
id|i
op_plus
id|j
)braket
)paren
id|good_spot
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|good_spot
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|serial
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|usb_serial
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Out of memory&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|serial
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|usb_serial
)paren
)paren
suffix:semicolon
id|serial_table
(braket
id|i
)braket
op_assign
id|serial
suffix:semicolon
op_star
id|minor
op_assign
id|i
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;minor base = %d&quot;
comma
op_star
id|minor
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
op_star
id|minor
op_plus
l_int|1
suffix:semicolon
(paren
id|i
OL
(paren
op_star
id|minor
op_plus
id|num_ports
)paren
)paren
op_logical_and
(paren
id|i
OL
id|SERIAL_TTY_MINORS
)paren
suffix:semicolon
op_increment
id|i
)paren
id|serial_table
(braket
id|i
)braket
op_assign
id|serial
suffix:semicolon
r_return
id|serial
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|return_serial
r_static
r_void
id|return_serial
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
r_int
id|i
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;return_serial&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_ports
suffix:semicolon
op_increment
id|i
)paren
(brace
id|serial_table
(braket
id|serial-&gt;minor
op_plus
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef USES_EZUSB_FUNCTIONS
multiline_comment|/* EZ-USB Control and Status Register.  Bit 0 controls 8051 reset */
DECL|macro|CPUCS_REG
mdefine_line|#define CPUCS_REG    0x7F92
DECL|function|ezusb_writememory
r_static
r_int
id|ezusb_writememory
(paren
r_struct
id|usb_serial
op_star
id|serial
comma
r_int
id|address
comma
r_int
r_char
op_star
id|data
comma
r_int
id|length
comma
id|__u8
id|bRequest
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
op_star
id|transfer_buffer
op_assign
id|kmalloc
(paren
id|length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
singleline_comment|//&t;dbg(&quot;ezusb_writememory %x, %d&quot;, address, length);
r_if
c_cond
(paren
op_logical_neg
id|transfer_buffer
)paren
(brace
id|err
c_func
(paren
l_string|&quot;ezusb_writememory: kmalloc(%d) failed.&quot;
comma
id|length
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memcpy
(paren
id|transfer_buffer
comma
id|data
comma
id|length
)paren
suffix:semicolon
id|result
op_assign
id|usb_control_msg
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|bRequest
comma
l_int|0x40
comma
id|address
comma
l_int|0
comma
id|transfer_buffer
comma
id|length
comma
l_int|300
)paren
suffix:semicolon
id|kfree
(paren
id|transfer_buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|ezusb_set_reset
r_static
r_int
id|ezusb_set_reset
(paren
r_struct
id|usb_serial
op_star
id|serial
comma
r_int
r_char
id|reset_bit
)paren
(brace
r_int
id|response
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;ezusb_set_reset: %d&quot;
comma
id|reset_bit
)paren
suffix:semicolon
id|response
op_assign
id|ezusb_writememory
(paren
id|serial
comma
id|CPUCS_REG
comma
op_amp
id|reset_bit
comma
l_int|1
comma
l_int|0xa0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|response
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;ezusb_set_reset %d failed&quot;
comma
id|reset_bit
)paren
suffix:semicolon
)brace
r_return
id|response
suffix:semicolon
)brace
macro_line|#endif&t;/* USES_EZUSB_FUNCTIONS */
multiline_comment|/*****************************************************************************&n; * Driver tty interface functions&n; *****************************************************************************/
DECL|function|serial_open
r_static
r_int
id|serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_open&quot;
)paren
suffix:semicolon
multiline_comment|/* initialize the pointer incase something fails */
id|tty-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* get the serial object associated with this tty pointer */
id|serial
op_assign
id|get_serial_by_minor
(paren
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
)paren
suffix:semicolon
multiline_comment|/* do some sanity checking that we really have a device present */
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial == NULL!&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;type
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial-&gt;type == NULL!&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
multiline_comment|/* make the tty driver remember our serial object, and us it */
id|tty-&gt;driver_data
op_assign
id|serial
suffix:semicolon
id|serial-&gt;tty
op_assign
id|tty
suffix:semicolon
multiline_comment|/* pass on to the driver specific version of this function if it is available */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;open
)paren
(brace
r_return
(paren
id|serial-&gt;type
op_member_access_from_pointer
id|open
c_func
(paren
id|tty
comma
id|filp
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
(paren
id|generic_serial_open
c_func
(paren
id|tty
comma
id|filp
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|serial_close
r_static
r_void
id|serial_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_close&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial == NULL!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_close port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* do some sanity checking that we really have a device present */
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;type
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial-&gt;type == NULL!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;port
(braket
id|port
)braket
dot
id|active
)paren
(brace
id|dbg
(paren
l_string|&quot;device not opened&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function if it is available */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;close
)paren
(brace
id|serial-&gt;type
op_member_access_from_pointer
id|close
c_func
(paren
id|tty
comma
id|filp
)paren
suffix:semicolon
)brace
r_else
(brace
id|generic_serial_close
c_func
(paren
id|tty
comma
id|filp
)paren
suffix:semicolon
)brace
)brace
DECL|function|serial_write
r_static
r_int
id|serial_write
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_write port %d, %d byte(s)&quot;
comma
id|port
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* do some sanity checking that we really have a device present */
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial == NULL!&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;type
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial-&gt;type == NULL!&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;port
(braket
id|port
)braket
dot
id|active
)paren
(brace
id|dbg
(paren
l_string|&quot;device not opened&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function if it is available */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;write
)paren
(brace
r_return
(paren
id|serial-&gt;type
op_member_access_from_pointer
id|write
c_func
(paren
id|tty
comma
id|from_user
comma
id|buf
comma
id|count
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
(paren
id|generic_serial_write
c_func
(paren
id|tty
comma
id|from_user
comma
id|buf
comma
id|count
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|serial_write_room
r_static
r_int
id|serial_write_room
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_write_room port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* do some sanity checking that we really have a device present */
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial == NULL!&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;type
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial-&gt;type == NULL!&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;port
(braket
id|port
)braket
dot
id|active
)paren
(brace
id|dbg
(paren
l_string|&quot;device not open&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function if it is available */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;write_room
)paren
(brace
r_return
(paren
id|serial-&gt;type
op_member_access_from_pointer
id|write_room
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
(paren
id|generic_write_room
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|serial_chars_in_buffer
r_static
r_int
id|serial_chars_in_buffer
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_chars_in_buffer port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* do some sanity checking that we really have a device present */
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial == NULL!&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;type
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial-&gt;type == NULL!&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;port
(braket
id|port
)braket
dot
id|active
)paren
(brace
id|dbg
(paren
l_string|&quot;device not open&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function if it is available */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;chars_in_buffer
)paren
(brace
r_return
(paren
id|serial-&gt;type
op_member_access_from_pointer
id|chars_in_buffer
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
(paren
id|generic_chars_in_buffer
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|serial_throttle
r_static
r_void
id|serial_throttle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_throttle port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* do some sanity checking that we really have a device present */
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial == NULL!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;type
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial-&gt;type == NULL!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;port
(braket
id|port
)braket
dot
id|active
)paren
(brace
id|dbg
(paren
l_string|&quot;device not open&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;throttle
)paren
(brace
id|serial-&gt;type
op_member_access_from_pointer
id|throttle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_else
(brace
id|generic_throttle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|serial_unthrottle
r_static
r_void
id|serial_unthrottle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_unthrottle port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* do some sanity checking that we really have a device present */
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial == NULL!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;type
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial-&gt;type == NULL!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;port
(braket
id|port
)braket
dot
id|active
)paren
(brace
id|dbg
(paren
l_string|&quot;device not open&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;unthrottle
)paren
(brace
id|serial-&gt;type
op_member_access_from_pointer
id|unthrottle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_else
(brace
id|generic_unthrottle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|serial_ioctl
r_static
r_int
id|serial_ioctl
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_ioctl&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial == NULL!&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_ioctl port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* do some sanity checking that we really have a device present */
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;type
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial-&gt;type == NULL!&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;port
(braket
id|port
)braket
dot
id|active
)paren
(brace
id|dbg
(paren
l_string|&quot;device not open&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function if it is available */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;ioctl
)paren
(brace
r_return
(paren
id|serial-&gt;type
op_member_access_from_pointer
id|ioctl
c_func
(paren
id|tty
comma
id|file
comma
id|cmd
comma
id|arg
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
(paren
id|generic_ioctl
(paren
id|tty
comma
id|file
comma
id|cmd
comma
id|arg
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|serial_set_termios
r_static
r_void
id|serial_set_termios
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_set_termios&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial == NULL!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_set_termios port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* do some sanity checking that we really have a device present */
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;type
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial-&gt;type == NULL!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;port
(braket
id|port
)braket
dot
id|active
)paren
(brace
id|dbg
(paren
l_string|&quot;device not open&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function if it is available */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;set_termios
)paren
(brace
id|serial-&gt;type
op_member_access_from_pointer
id|set_termios
c_func
(paren
id|tty
comma
id|old
)paren
suffix:semicolon
)brace
r_else
(brace
id|generic_set_termios
(paren
id|tty
comma
id|old
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|serial_break
r_static
r_void
id|serial_break
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|break_state
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial == NULL!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;serial_break port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* do some sanity checking that we really have a device present */
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;type
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;serial-&gt;type == NULL!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;port
(braket
id|port
)braket
dot
id|active
)paren
(brace
id|dbg
(paren
l_string|&quot;device not open&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function if it is&n;           available */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;break_ctl
)paren
(brace
id|serial-&gt;type
op_member_access_from_pointer
id|break_ctl
c_func
(paren
id|tty
comma
id|break_state
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_USB_SERIAL_WHITEHEAT
multiline_comment|/*****************************************************************************&n; * Connect Tech&squot;s White Heat specific driver functions&n; *****************************************************************************/
DECL|function|whiteheat_serial_open
r_static
r_int
id|whiteheat_serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|portNumber
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|portNumber
)braket
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;whiteheat_serial_open port %d&quot;
comma
id|portNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;active
)paren
(brace
id|dbg
(paren
l_string|&quot;device already open&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|port-&gt;active
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*Start reading from the device*/
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
op_amp
id|port-&gt;read_urb
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot;usb_submit_urb(read bulk) failed&quot;
)paren
suffix:semicolon
multiline_comment|/* Need to do device specific setup here (control lines, baud rate, etc.) */
multiline_comment|/* FIXME!!! */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|whiteheat_serial_close
r_static
r_void
id|whiteheat_serial_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|portNumber
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|portNumber
)braket
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;whiteheat_serial_close port %d&quot;
comma
id|portNumber
)paren
suffix:semicolon
multiline_comment|/* Need to change the control lines here */
multiline_comment|/* FIXME */
multiline_comment|/* shutdown our bulk reads and writes */
id|usb_unlink_urb
(paren
op_amp
id|port-&gt;write_urb
)paren
suffix:semicolon
id|usb_unlink_urb
(paren
op_amp
id|port-&gt;read_urb
)paren
suffix:semicolon
id|port-&gt;active
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|whiteheat_set_termios
r_static
r_void
id|whiteheat_set_termios
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_int
r_int
id|cflag
op_assign
id|tty-&gt;termios-&gt;c_cflag
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;whiteheat_set_termios port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* check that they really want us to change something */
r_if
c_cond
(paren
id|old_termios
)paren
(brace
r_if
c_cond
(paren
(paren
id|cflag
op_eq
id|old_termios-&gt;c_cflag
)paren
op_logical_and
(paren
id|RELEVANT_IFLAG
c_func
(paren
id|tty-&gt;termios-&gt;c_iflag
)paren
op_eq
id|RELEVANT_IFLAG
c_func
(paren
id|old_termios-&gt;c_iflag
)paren
)paren
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;nothing to change...&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* do the parsing of the cflag to see what to set the line to */
multiline_comment|/* FIXME!! */
r_return
suffix:semicolon
)brace
DECL|function|whiteheat_throttle
r_static
r_void
id|whiteheat_throttle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;whiteheat_throttle port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* Change the control signals */
multiline_comment|/* FIXME!!! */
r_return
suffix:semicolon
)brace
DECL|function|whiteheat_unthrottle
r_static
r_void
id|whiteheat_unthrottle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;whiteheat_unthrottle port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* Change the control signals */
multiline_comment|/* FIXME!!! */
r_return
suffix:semicolon
)brace
multiline_comment|/* steps to download the firmware to the WhiteHEAT device:&n; - hold the reset (by writing to the reset bit of the CPUCS register)&n; - download the VEND_AX.HEX file to the chip using VENDOR_REQUEST-ANCHOR_LOAD&n; - release the reset (by writing to the CPUCS register)&n; - download the WH.HEX file for all addresses greater than 0x1b3f using&n;   VENDOR_REQUEST-ANCHOR_EXTERNAL_RAM_LOAD&n; - hold the reset&n; - download the WH.HEX file for all addresses less than 0x1b40 using&n;   VENDOR_REQUEST_ANCHOR_LOAD&n; - release the reset&n; - device renumerated itself and comes up as new device id with all&n;   firmware download completed.&n;*/
DECL|function|whiteheat_startup
r_static
r_int
id|whiteheat_startup
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
r_int
id|response
suffix:semicolon
r_const
r_struct
id|whiteheat_hex_record
op_star
id|record
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;whiteheat_startup&quot;
)paren
suffix:semicolon
id|response
op_assign
id|ezusb_set_reset
(paren
id|serial
comma
l_int|1
)paren
suffix:semicolon
id|record
op_assign
op_amp
id|whiteheat_loader
(braket
l_int|0
)braket
suffix:semicolon
r_while
c_loop
(paren
id|record-&gt;address
op_ne
l_int|0xffff
)paren
(brace
id|response
op_assign
id|ezusb_writememory
(paren
id|serial
comma
id|record-&gt;address
comma
(paren
r_int
r_char
op_star
)paren
id|record-&gt;data
comma
id|record-&gt;data_size
comma
l_int|0xa0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|response
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;ezusb_writememory failed for loader (%d %04X %p %d)&quot;
comma
id|response
comma
id|record-&gt;address
comma
id|record-&gt;data
comma
id|record-&gt;data_size
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
op_increment
id|record
suffix:semicolon
)brace
id|response
op_assign
id|ezusb_set_reset
(paren
id|serial
comma
l_int|0
)paren
suffix:semicolon
id|record
op_assign
op_amp
id|whiteheat_firmware
(braket
l_int|0
)braket
suffix:semicolon
r_while
c_loop
(paren
id|record-&gt;address
OL
l_int|0x1b40
)paren
(brace
op_increment
id|record
suffix:semicolon
)brace
r_while
c_loop
(paren
id|record-&gt;address
op_ne
l_int|0xffff
)paren
(brace
id|response
op_assign
id|ezusb_writememory
(paren
id|serial
comma
id|record-&gt;address
comma
(paren
r_int
r_char
op_star
)paren
id|record-&gt;data
comma
id|record-&gt;data_size
comma
l_int|0xa0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|response
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;ezusb_writememory failed for first firmware step (%d %04X %p %d)&quot;
comma
id|response
comma
id|record-&gt;address
comma
id|record-&gt;data
comma
id|record-&gt;data_size
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
op_increment
id|record
suffix:semicolon
)brace
id|response
op_assign
id|ezusb_set_reset
(paren
id|serial
comma
l_int|1
)paren
suffix:semicolon
id|record
op_assign
op_amp
id|whiteheat_firmware
(braket
l_int|0
)braket
suffix:semicolon
r_while
c_loop
(paren
id|record-&gt;address
OL
l_int|0x1b40
)paren
(brace
id|response
op_assign
id|ezusb_writememory
(paren
id|serial
comma
id|record-&gt;address
comma
(paren
r_int
r_char
op_star
)paren
id|record-&gt;data
comma
id|record-&gt;data_size
comma
l_int|0xa0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|response
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;ezusb_writememory failed for second firmware step (%d %04X %p %d)&quot;
comma
id|response
comma
id|record-&gt;address
comma
id|record-&gt;data
comma
id|record-&gt;data_size
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
op_increment
id|record
suffix:semicolon
)brace
id|response
op_assign
id|ezusb_set_reset
(paren
id|serial
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* we want this device to fail to have a driver assigned to it. */
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_USB_SERIAL_WHITEHEAT */
macro_line|#ifdef CONFIG_USB_SERIAL_VISOR
multiline_comment|/******************************************************************************&n; * Handspring Visor specific driver functions&n; ******************************************************************************/
DECL|function|visor_serial_open
r_static
r_int
id|visor_serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|portNumber
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|portNumber
)braket
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;visor_serial_open port %d&quot;
comma
id|portNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;active
)paren
(brace
id|dbg
(paren
l_string|&quot;device already open&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|port-&gt;active
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*Start reading from the device*/
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
op_amp
id|port-&gt;read_urb
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot;usb_submit_urb(read bulk) failed&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|visor_serial_close
r_static
r_void
id|visor_serial_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|portNumber
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|portNumber
)braket
suffix:semicolon
r_int
r_char
op_star
id|transfer_buffer
op_assign
id|kmalloc
(paren
l_int|0x12
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;visor_serial_close port %d&quot;
comma
id|portNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transfer_buffer
)paren
(brace
id|err
c_func
(paren
l_string|&quot;visor_serial_close: kmalloc(%d) failed.&quot;
comma
l_int|0x12
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* send a shutdown message to the device */
id|usb_control_msg
(paren
id|serial-&gt;dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|VISOR_CLOSE_NOTIFICATION
comma
l_int|0xc2
comma
l_int|0x0000
comma
l_int|0x0000
comma
id|transfer_buffer
comma
l_int|0x12
comma
l_int|300
)paren
suffix:semicolon
)brace
multiline_comment|/* shutdown our bulk reads and writes */
id|usb_unlink_urb
(paren
op_amp
id|port-&gt;write_urb
)paren
suffix:semicolon
id|usb_unlink_urb
(paren
op_amp
id|port-&gt;read_urb
)paren
suffix:semicolon
id|port-&gt;active
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|visor_throttle
r_static
r_void
id|visor_throttle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;visor_throttle port %d&quot;
comma
id|port
)paren
suffix:semicolon
id|usb_unlink_urb
(paren
op_amp
id|serial-&gt;port
(braket
id|port
)braket
dot
id|read_urb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|visor_unthrottle
r_static
r_void
id|visor_unthrottle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;visor_unthrottle port %d&quot;
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_unlink_urb
(paren
op_amp
id|serial-&gt;port
(braket
id|port
)braket
dot
id|read_urb
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot;usb_submit_urb(read bulk) failed&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|visor_startup
r_static
r_int
id|visor_startup
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
r_int
id|response
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
op_star
id|transfer_buffer
op_assign
id|kmalloc
(paren
l_int|256
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transfer_buffer
)paren
(brace
id|err
c_func
(paren
l_string|&quot;visor_startup: kmalloc(%d) failed.&quot;
comma
l_int|256
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;visor_startup&quot;
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;visor_setup: Set config to 1&quot;
)paren
suffix:semicolon
id|usb_set_configuration
(paren
id|serial-&gt;dev
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* send a get connection info request */
id|response
op_assign
id|usb_control_msg
(paren
id|serial-&gt;dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|VISOR_GET_CONNECTION_INFORMATION
comma
l_int|0xc2
comma
l_int|0x0000
comma
l_int|0x0000
comma
id|transfer_buffer
comma
l_int|0x12
comma
l_int|300
)paren
suffix:semicolon
r_if
c_cond
(paren
id|response
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;visor_startup: error getting connection information&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|visor_connection_info
op_star
id|connection_info
op_assign
(paren
r_struct
id|visor_connection_info
op_star
)paren
id|transfer_buffer
suffix:semicolon
r_char
op_star
id|string
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;%s: Number of ports: %d&quot;
comma
id|serial-&gt;type-&gt;name
comma
id|connection_info-&gt;num_ports
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|connection_info-&gt;num_ports
suffix:semicolon
op_increment
id|i
)paren
(brace
r_switch
c_cond
(paren
id|connection_info-&gt;connections
(braket
id|i
)braket
dot
id|port_function_id
)paren
(brace
r_case
id|VISOR_FUNCTION_GENERIC
suffix:colon
id|string
op_assign
l_string|&quot;Generic&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VISOR_FUNCTION_DEBUGGER
suffix:colon
id|string
op_assign
l_string|&quot;Debugger&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VISOR_FUNCTION_HOTSYNC
suffix:colon
id|string
op_assign
l_string|&quot;HotSync&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VISOR_FUNCTION_CONSOLE
suffix:colon
id|string
op_assign
l_string|&quot;Console&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VISOR_FUNCTION_REMOTE_FILE_SYS
suffix:colon
id|string
op_assign
l_string|&quot;Remote File System&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|string
op_assign
l_string|&quot;unknown&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|info
c_func
(paren
l_string|&quot;%s: port %d, is for %s use and is bound to ttyUSB%d&quot;
comma
id|serial-&gt;type-&gt;name
comma
id|connection_info-&gt;connections
(braket
id|i
)braket
dot
id|port
comma
id|string
comma
id|serial-&gt;minor
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* ask for the number of bytes available, but ignore the response as it is broken */
id|response
op_assign
id|usb_control_msg
(paren
id|serial-&gt;dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|VISOR_REQUEST_BYTES_AVAILABLE
comma
l_int|0xc2
comma
l_int|0x0000
comma
l_int|0x0005
comma
id|transfer_buffer
comma
l_int|0x02
comma
l_int|300
)paren
suffix:semicolon
r_if
c_cond
(paren
id|response
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;visor_startup: error getting bytes available request&quot;
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|transfer_buffer
)paren
suffix:semicolon
multiline_comment|/* continue on with initialization */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_USB_SERIAL_VISOR*/
macro_line|#ifdef CONFIG_USB_SERIAL_FTDI_SIO
multiline_comment|/******************************************************************************&n; * FTDI SIO Serial Converter specific driver functions&n; ******************************************************************************/
multiline_comment|/* Bill Ryder - bryder@sgi.com - wrote the FTDI_SIO implementation */
multiline_comment|/* Thanx to FTDI for so kindly providing details of the protocol required */
multiline_comment|/*   to talk to the device */
macro_line|#include &quot;ftdi_sio.h&quot;
DECL|function|ftdi_sio_serial_open
r_static
r_int
id|ftdi_sio_serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|portNumber
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|portNumber
)braket
suffix:semicolon
r_char
id|buf
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Needed for the usb_control_msg I think */
id|dbg
c_func
(paren
l_string|&quot;ftdi_sio_serial_open port %d&quot;
comma
id|portNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;active
)paren
(brace
id|dbg
(paren
l_string|&quot;device already open&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|port-&gt;active
op_assign
l_int|1
suffix:semicolon
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|FTDI_SIO_RESET_REQUEST
comma
id|FTDI_SIO_RESET_REQUEST_TYPE
comma
id|FTDI_SIO_RESET_SIO
comma
l_int|0
comma
id|buf
comma
l_int|0
comma
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
multiline_comment|/* FIXME - Should I really purge the buffers? */
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|FTDI_SIO_RESET_REQUEST
comma
id|FTDI_SIO_RESET_REQUEST_TYPE
comma
id|FTDI_SIO_RESET_PURGE_RX
comma
l_int|0
comma
id|buf
comma
l_int|0
comma
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|FTDI_SIO_RESET_REQUEST
comma
id|FTDI_SIO_RESET_REQUEST_TYPE
comma
id|FTDI_SIO_RESET_PURGE_TX
comma
l_int|0
comma
id|buf
comma
l_int|0
comma
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
multiline_comment|/* As per usb_serial_init s/be CS8, B9600, 1 STOP BIT */
r_if
c_cond
(paren
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|FTDI_SIO_SET_BAUDRATE_REQUEST
comma
id|FTDI_SIO_SET_BAUDRATE_REQUEST_TYPE
comma
id|ftdi_sio_b9600
comma
l_int|0
comma
id|buf
comma
l_int|0
comma
id|HZ
op_star
l_int|5
)paren
OL
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;Error from baudrate urb&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|FTDI_SIO_SET_DATA_REQUEST
comma
id|FTDI_SIO_SET_DATA_REQUEST_TYPE
comma
l_int|8
op_or
id|FTDI_SIO_SET_DATA_PARITY_NONE
op_or
id|FTDI_SIO_SET_DATA_STOP_BITS_1
comma
l_int|0
comma
id|buf
comma
l_int|0
comma
id|HZ
op_star
l_int|5
)paren
OL
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;Error from cs8/noparity/1 stopbit urb&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Disable flow control */
r_if
c_cond
(paren
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|FTDI_SIO_SET_FLOW_CTRL_REQUEST
comma
id|FTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE
comma
l_int|0
comma
l_int|0
comma
id|buf
comma
l_int|0
comma
id|HZ
op_star
l_int|5
)paren
OL
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;error from flowcontrol urb&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Turn on RTS and DTR since we are not flow controlling*/
multiline_comment|/* FIXME - check for correct behaviour clocal vs non clocal */
multiline_comment|/* FIXME - might be able to do both simultaneously */
r_if
c_cond
(paren
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|FTDI_SIO_SET_MODEM_CTRL_REQUEST
comma
id|FTDI_SIO_SET_MODEM_CTRL_REQUEST_TYPE
comma
(paren
r_int
)paren
id|FTDI_SIO_SET_DTR_HIGH
comma
l_int|0
comma
id|buf
comma
l_int|0
comma
id|HZ
op_star
l_int|5
)paren
OL
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;Error from DTR HIGH urb&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|FTDI_SIO_SET_MODEM_CTRL_REQUEST
comma
id|FTDI_SIO_SET_MODEM_CTRL_REQUEST_TYPE
comma
(paren
r_int
)paren
id|FTDI_SIO_SET_RTS_HIGH
comma
l_int|0
comma
id|buf
comma
l_int|0
comma
id|HZ
op_star
l_int|5
)paren
OL
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;Error from RTS HIGH urb&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*Start reading from the device*/
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
op_amp
id|port-&gt;read_urb
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot;usb_submit_urb(read bulk) failed&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|ftdi_sio_serial_close
r_static
r_void
id|ftdi_sio_serial_close
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|portNumber
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|portNumber
)braket
suffix:semicolon
r_char
id|buf
(braket
l_int|1
)braket
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;ftdi_sio_serial_close port %d&quot;
comma
id|portNumber
)paren
suffix:semicolon
multiline_comment|/* FIXME - might be able to do both simultaneously */
r_if
c_cond
(paren
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|FTDI_SIO_SET_MODEM_CTRL_REQUEST
comma
id|FTDI_SIO_SET_MODEM_CTRL_REQUEST_TYPE
comma
(paren
r_int
)paren
id|FTDI_SIO_SET_DTR_LOW
comma
l_int|0
comma
id|buf
comma
l_int|0
comma
id|HZ
op_star
l_int|5
)paren
OL
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;Error from DTR LOW urb&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|FTDI_SIO_SET_MODEM_CTRL_REQUEST
comma
id|FTDI_SIO_SET_MODEM_CTRL_REQUEST_TYPE
comma
(paren
r_int
)paren
id|FTDI_SIO_SET_RTS_LOW
comma
l_int|0
comma
id|buf
comma
l_int|0
comma
id|HZ
op_star
l_int|5
)paren
OL
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;Error from RTS LOW urb&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME Should I flush the device here? - not doing it for now */
multiline_comment|/* shutdown our bulk reads and writes */
id|usb_unlink_urb
(paren
op_amp
id|port-&gt;write_urb
)paren
suffix:semicolon
id|usb_unlink_urb
(paren
op_amp
id|port-&gt;read_urb
)paren
suffix:semicolon
id|port-&gt;active
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The ftdi_sio requires the first byte to have:&n;   B0 1&n;   B1 0&n;   B2..7 length of message excluding byte 0&n;*/
DECL|function|ftdi_sio_serial_write
r_static
r_int
id|ftdi_sio_serial_write
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|portNumber
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|portNumber
)braket
suffix:semicolon
r_const
r_int
id|data_offset
op_assign
l_int|1
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;ftdi_sio_serial_write port %d, %d bytes&quot;
comma
id|portNumber
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;write request of 0 bytes&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* only do something if we have a bulk out endpoint */
r_if
c_cond
(paren
id|serial-&gt;num_bulk_out
)paren
(brace
r_int
r_char
op_star
id|first_byte
op_assign
id|port-&gt;write_urb.transfer_buffer
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;write_urb.status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
id|dbg
(paren
l_string|&quot;already writing&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|count
op_add_assign
id|data_offset
suffix:semicolon
id|count
op_assign
(paren
id|count
OG
id|port-&gt;bulk_out_size
)paren
ques
c_cond
id|port-&gt;bulk_out_size
suffix:colon
id|count
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Copy in the data to send */
r_if
c_cond
(paren
id|from_user
)paren
(brace
id|copy_from_user
c_func
(paren
id|port-&gt;write_urb.transfer_buffer
op_plus
id|data_offset
comma
id|buf
comma
id|count
op_minus
id|data_offset
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|port-&gt;write_urb.transfer_buffer
op_plus
id|data_offset
comma
id|buf
comma
id|count
op_minus
id|data_offset
)paren
suffix:semicolon
)brace
multiline_comment|/* Write the control byte at the front of the packet*/
id|first_byte
op_assign
id|port-&gt;write_urb.transfer_buffer
suffix:semicolon
op_star
id|first_byte
op_assign
l_int|1
op_or
(paren
(paren
id|count
op_minus
id|data_offset
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|dbg
c_func
(paren
l_string|&quot;Bytes: %d, Control Byte: 0o%03o&quot;
comma
id|count
comma
id|first_byte
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
id|__FILE__
l_string|&quot;: data written - length = %d, data = &quot;
comma
id|count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
op_increment
id|i
)paren
(brace
id|printk
(paren
l_string|&quot;0x%02x &quot;
comma
id|first_byte
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_byte
(braket
id|i
)braket
OG
l_char|&squot; &squot;
op_logical_and
id|first_byte
(braket
id|i
)braket
OL
l_char|&squot;~&squot;
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%c &quot;
comma
id|first_byte
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;  &quot;
)paren
suffix:semicolon
)brace
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* send the data out the bulk port */
id|port-&gt;write_urb.transfer_buffer_length
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
op_amp
id|port-&gt;write_urb
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot;usb_submit_urb(write bulk) failed&quot;
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;write returning: %d&quot;
comma
id|count
op_minus
id|data_offset
)paren
suffix:semicolon
r_return
(paren
id|count
op_minus
id|data_offset
)paren
suffix:semicolon
)brace
multiline_comment|/* no bulk out, so return 0 bytes written */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ftdi_sio_read_bulk_callback
r_static
r_void
id|ftdi_sio_read_bulk_callback
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
multiline_comment|/* ftdi_sio_serial_buld_callback */
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|serial-&gt;tty
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
r_const
r_int
id|data_offset
op_assign
l_int|2
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;ftdi_sio_read_bulk_callback&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;nonzero read bulk status received: %d&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|urb-&gt;actual_length
OG
l_int|2
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
id|__FILE__
l_string|&quot;: data read - length = %d, data = &quot;
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;actual_length
suffix:semicolon
op_increment
id|i
)paren
(brace
id|printk
(paren
l_string|&quot;0x%.2x &quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
OG
l_char|&squot; &squot;
op_logical_and
id|data
(braket
id|i
)braket
OL
l_char|&squot;~&squot;
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%c &quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;  &quot;
)paren
suffix:semicolon
)brace
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|urb-&gt;actual_length
OG
id|data_offset
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|data_offset
suffix:semicolon
id|i
OL
id|urb-&gt;actual_length
suffix:semicolon
op_increment
id|i
)paren
(brace
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|data
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* Continue trying to always read  */
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
id|urb
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot;failed resubmitting read urb&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* ftdi_sio_serial_read_bulk_callback */
DECL|function|ftdi_sio_set_termios
r_static
r_void
id|ftdi_sio_set_termios
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_int
r_int
id|cflag
op_assign
id|tty-&gt;termios-&gt;c_cflag
suffix:semicolon
id|__u16
id|urb_value
suffix:semicolon
multiline_comment|/* Will hold the new flags */
r_char
id|buf
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Perhaps I should dynamically alloc this? */
id|dbg
c_func
(paren
l_string|&quot;ftdi_sio_set_termios port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* FIXME - we should keep the old termios really */
multiline_comment|/* FIXME -For this cut I don&squot;t care if the line is really changing or &n;&t;   not  - so just do the change regardless */
multiline_comment|/* Set number of data bits, parity, stop bits */
id|urb_value
op_assign
l_int|0
suffix:semicolon
id|urb_value
op_or_assign
(paren
id|cflag
op_amp
id|CSTOPB
ques
c_cond
id|FTDI_SIO_SET_DATA_STOP_BITS_2
suffix:colon
id|FTDI_SIO_SET_DATA_STOP_BITS_1
)paren
suffix:semicolon
id|urb_value
op_or_assign
(paren
id|cflag
op_amp
id|PARENB
ques
c_cond
(paren
id|cflag
op_amp
id|PARODD
ques
c_cond
id|FTDI_SIO_SET_DATA_PARITY_ODD
suffix:colon
id|FTDI_SIO_SET_DATA_PARITY_EVEN
)paren
suffix:colon
id|FTDI_SIO_SET_DATA_PARITY_NONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cflag
op_amp
id|CSIZE
)paren
(brace
r_switch
c_cond
(paren
id|cflag
op_amp
id|CSIZE
)paren
(brace
r_case
id|CS5
suffix:colon
id|urb_value
op_or_assign
l_int|5
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Setting CS5&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS6
suffix:colon
id|urb_value
op_or_assign
l_int|6
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Setting CS6&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS7
suffix:colon
id|urb_value
op_or_assign
l_int|7
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Setting CS7&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS8
suffix:colon
id|urb_value
op_or_assign
l_int|8
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Setting CS8&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;CSIZE was set but not CS5-CS8&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|FTDI_SIO_SET_DATA_REQUEST
comma
id|FTDI_SIO_SET_DATA_REQUEST_TYPE
comma
id|urb_value
comma
l_int|0
comma
id|buf
comma
l_int|0
comma
l_int|100
)paren
OL
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;FAILED to set databits/stopbits/parity&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Now do the baudrate */
multiline_comment|/* FIXME - should drop lines on B0 */
multiline_comment|/* FIXME Should also handle CLOCAL here  */
r_switch
c_cond
(paren
id|cflag
op_amp
id|CBAUD
)paren
(brace
r_case
id|B300
suffix:colon
id|urb_value
op_assign
id|ftdi_sio_b300
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Set to 300&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B600
suffix:colon
id|urb_value
op_assign
id|ftdi_sio_b600
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Set to 600&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B1200
suffix:colon
id|urb_value
op_assign
id|ftdi_sio_b1200
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Set to 1200&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B2400
suffix:colon
id|urb_value
op_assign
id|ftdi_sio_b2400
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Set to 2400&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B4800
suffix:colon
id|urb_value
op_assign
id|ftdi_sio_b4800
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Set to 4800&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B9600
suffix:colon
id|urb_value
op_assign
id|ftdi_sio_b9600
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Set to 9600&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B19200
suffix:colon
id|urb_value
op_assign
id|ftdi_sio_b19200
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Set to 19200&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B38400
suffix:colon
id|urb_value
op_assign
id|ftdi_sio_b38400
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Set to 38400&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B57600
suffix:colon
id|urb_value
op_assign
id|ftdi_sio_b57600
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Set to 57600&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B115200
suffix:colon
id|urb_value
op_assign
id|ftdi_sio_b115200
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Set to 115200&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;FTDI_SIO does not support the baudrate requested&quot;
)paren
suffix:semicolon
multiline_comment|/* FIXME - how to return an error for this? */
r_break
suffix:semicolon
)brace
multiline_comment|/* Send the URB */
r_if
c_cond
(paren
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|FTDI_SIO_SET_BAUDRATE_REQUEST
comma
id|FTDI_SIO_SET_BAUDRATE_REQUEST_TYPE
comma
id|urb_value
comma
l_int|0
comma
id|buf
comma
l_int|0
comma
l_int|100
)paren
OL
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;urb failed to set baurdrate&quot;
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*FIXME - the beginnings of this implementation - not even hooked into the driver yet */
DECL|function|ftdi_sio_ioctl
r_static
r_int
id|ftdi_sio_ioctl
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|__u16
id|urb_value
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Will hold the new flags */
r_char
id|buf
(braket
l_int|1
)braket
suffix:semicolon
r_int
id|ret
comma
id|mask
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;ftdi_sio_ioctl port %d&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* Based on code from acm.c */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMGET
suffix:colon
multiline_comment|/* Request the status from the device */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|FTDI_SIO_GET_MODEM_STATUS_REQUEST
comma
id|FTDI_SIO_GET_MODEM_STATUS_REQUEST_TYPE
comma
l_int|0
comma
l_int|0
comma
id|buf
comma
l_int|1
comma
id|HZ
op_star
l_int|5
)paren
)paren
OL
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;Get not get modem status of device&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
(paren
id|buf
(braket
l_int|0
)braket
op_amp
id|FTDI_SIO_DSR_MASK
ques
c_cond
id|TIOCM_DSR
suffix:colon
l_int|0
)paren
op_or
(paren
id|buf
(braket
l_int|0
)braket
op_amp
id|FTDI_SIO_CTS_MASK
ques
c_cond
id|TIOCM_CTS
suffix:colon
l_int|0
)paren
op_or
(paren
id|buf
(braket
l_int|0
)braket
op_amp
id|FTDI_SIO_RI_MASK
ques
c_cond
id|TIOCM_RI
suffix:colon
l_int|0
)paren
op_or
(paren
id|buf
(braket
l_int|0
)braket
op_amp
id|FTDI_SIO_RLSD_MASK
ques
c_cond
id|TIOCM_CD
suffix:colon
l_int|0
)paren
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMSET
suffix:colon
r_case
id|TIOCMBIS
suffix:colon
r_case
id|TIOCMBIC
suffix:colon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|get_user
c_func
(paren
id|mask
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* FIXME Need to remember if we have set DTR or RTS since we&n;&t;&t;&t;   can&squot;t ask the device  */
multiline_comment|/* FIXME - also need to find the meaning of TIOCMBIS/BIC/SET */
r_if
c_cond
(paren
id|mask
op_amp
id|TIOCM_DTR
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMSET
suffix:colon
id|urb_value
op_assign
id|FTDI_SIO_SET_DTR_HIGH
op_or
id|FTDI_SIO_SET_RTS_LOW
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMBIS
suffix:colon
multiline_comment|/* Will leave RTS alone and set DTR */
id|urb_value
op_assign
id|FTDI_SIO_SET_DTR_HIGH
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMBIC
suffix:colon
id|urb_value
op_assign
id|FTDI_SIO_SET_DTR_LOW
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|mask
op_amp
id|TIOCM_RTS
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMSET
suffix:colon
id|urb_value
op_assign
id|FTDI_SIO_SET_DTR_LOW
op_or
id|FTDI_SIO_SET_RTS_HIGH
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMBIS
suffix:colon
multiline_comment|/* Will leave DTR and set RTS */
id|urb_value
op_assign
id|FTDI_SIO_SET_RTS_HIGH
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMBIC
suffix:colon
multiline_comment|/* Will unset RTS */
id|urb_value
op_assign
id|FTDI_SIO_SET_RTS_LOW
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|FTDI_SIO_SET_MODEM_CTRL_REQUEST
comma
id|FTDI_SIO_SET_MODEM_CTRL_REQUEST_TYPE
comma
id|urb_value
comma
l_int|0
comma
id|buf
comma
l_int|0
comma
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_USB_SERIAL_FTDI_SIO */
macro_line|#ifdef CONFIG_USB_SERIAL_KEYSPAN_PDA
multiline_comment|/*****************************************************************************&n; * Keyspan PDA specific driver functions&n; *****************************************************************************/
DECL|function|keyspan_pda_rx_interrupt
r_static
r_void
id|keyspan_pda_rx_interrupt
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|serial-&gt;tty
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* the urb might have been killed. */
r_if
c_cond
(paren
id|urb-&gt;status
)paren
r_return
suffix:semicolon
multiline_comment|/* see if the message is data or a status interrupt */
r_switch
c_cond
(paren
id|data
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* rest of message is rx data */
r_if
c_cond
(paren
id|urb-&gt;actual_length
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|urb-&gt;actual_length
suffix:semicolon
op_increment
id|i
)paren
(brace
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|data
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* status interrupt */
id|dbg
c_func
(paren
l_string|&quot; rx int, d1=%d, d2=%d&quot;
comma
id|data
(braket
l_int|1
)braket
comma
id|data
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|data
(braket
l_int|1
)braket
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* modemline change */
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* tx unthrottle interrupt */
id|serial-&gt;tx_throttled
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|serial-&gt;write_wait
)paren
suffix:semicolon
multiline_comment|/* wake up writer */
id|wake_up
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
multiline_comment|/* them too */
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* INT urbs are automatically re-submitted */
)brace
DECL|function|keyspan_pda_rx_throttle
r_static
r_void
id|keyspan_pda_rx_throttle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
multiline_comment|/* stop receiving characters. We just turn off the URB request, and&n;&t;   let chars pile up in the device. If we&squot;re doing hardware&n;&t;   flowcontrol, the device will signal the other end when its buffer&n;&t;   fills up. If we&squot;re doing XON/XOFF, this would be a good time to&n;&t;   send an XOFF, although it might make sense to foist that off&n;&t;   upon the device too. */
id|dbg
c_func
(paren
l_string|&quot;keyspan_pda_rx_throttle port %d&quot;
comma
id|port
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
op_amp
id|serial-&gt;port
(braket
id|port
)braket
dot
id|read_urb
)paren
suffix:semicolon
)brace
DECL|function|keyspan_pda_rx_unthrottle
r_static
r_void
id|keyspan_pda_rx_unthrottle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
multiline_comment|/* just restart the receive interrupt URB */
id|dbg
c_func
(paren
l_string|&quot;keyspan_pda_rx_unthrottle port %d&quot;
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
op_amp
id|serial-&gt;port
(braket
id|port
)braket
dot
id|read_urb
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot; usb_submit_urb(read urb) failed&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|keyspan_pda_setbaud
r_static
r_int
id|keyspan_pda_setbaud
(paren
r_struct
id|usb_serial
op_star
id|serial
comma
r_int
id|baud
)paren
(brace
r_int
id|rc
suffix:semicolon
r_int
id|bindex
suffix:semicolon
r_switch
c_cond
(paren
id|baud
)paren
(brace
r_case
l_int|110
suffix:colon
id|bindex
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|300
suffix:colon
id|bindex
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1200
suffix:colon
id|bindex
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2400
suffix:colon
id|bindex
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4800
suffix:colon
id|bindex
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9600
suffix:colon
id|bindex
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|19200
suffix:colon
id|bindex
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|38400
suffix:colon
id|bindex
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|57600
suffix:colon
id|bindex
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|115200
suffix:colon
id|bindex
op_assign
l_int|9
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* rather than figure out how to sleep while waiting for this&n;&t;   to complete, I just use the &quot;legacy&quot; API. */
id|rc
op_assign
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
l_int|0
comma
multiline_comment|/* set baud */
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_INTERFACE
op_or
id|USB_DIR_OUT
comma
multiline_comment|/* type */
id|bindex
comma
multiline_comment|/* value */
l_int|0
comma
multiline_comment|/* index */
l_int|NULL
comma
multiline_comment|/* &amp;data */
l_int|0
comma
multiline_comment|/* size */
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
multiline_comment|/* timeout */
r_return
id|rc
suffix:semicolon
)brace
DECL|function|keyspan_pda_break_ctl
r_static
r_void
id|keyspan_pda_break_ctl
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|break_state
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|value
suffix:semicolon
r_if
c_cond
(paren
id|break_state
op_eq
op_minus
l_int|1
)paren
id|value
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* start break */
r_else
id|value
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear break */
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
l_int|4
comma
multiline_comment|/* set break */
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_INTERFACE
op_or
id|USB_DIR_OUT
comma
id|value
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
multiline_comment|/* there is something funky about this.. the TCSBRK that &squot;cu&squot; performs&n;&t;   ought to translate into a break_ctl(-1),break_ctl(0) pair HZ/4&n;&t;   seconds apart, but it feels like the break sent isn&squot;t as long as it&n;&t;   is on /dev/ttyS0 */
)brace
DECL|function|keyspan_pda_set_termios
r_static
r_void
id|keyspan_pda_set_termios
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|cflag
op_assign
id|tty-&gt;termios-&gt;c_cflag
suffix:semicolon
multiline_comment|/* cflag specifies lots of stuff: number of stop bits, parity, number&n;&t;   of data bits, baud. What can the device actually handle?:&n;&t;   CSTOPB (1 stop bit or 2)&n;&t;   PARENB (parity)&n;&t;   CSIZE (5bit .. 8bit)&n;&t;   There is minimal hw support for parity (a PSW bit seems to hold the&n;&t;   parity of whatever is in the accumulator). The UART either deals&n;&t;   with 10 bits (start, 8 data, stop) or 11 bits (start, 8 data,&n;&t;   1 special, stop). So, with firmware changes, we could do:&n;&t;   8N1: 10 bit&n;&t;   8N2: 11 bit, extra bit always (mark?)&n;&t;   8[EOMS]1: 11 bit, extra bit is parity&n;&t;   7[EOMS]1: 10 bit, b0/b7 is parity&n;&t;   7[EOMS]2: 11 bit, b0/b7 is parity, extra bit always (mark?)&n;&n;&t;   HW flow control is dictated by the tty-&gt;termios-&gt;c_cflags &amp; CRTSCTS&n;&t;   bit.&n;&n;&t;   For now, just do baud. */
r_switch
c_cond
(paren
id|cflag
op_amp
id|CBAUD
)paren
(brace
multiline_comment|/* we could support more values here, just need to calculate&n;&t;&t;   the necessary divisors in the firmware. &lt;asm/termbits.h&gt;&n;&t;&t;   has the Bnnn constants. */
r_case
id|B110
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|110
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B300
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|300
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B1200
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|1200
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B2400
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|2400
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B4800
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|4800
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B9600
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|9600
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B19200
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|19200
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B38400
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|38400
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B57600
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|57600
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B115200
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|115200
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;can&squot;t handle requested baud rate&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* modem control pins: DTR and RTS are outputs and can be controlled.&n;   DCD, RI, DSR, CTS are inputs and can be read. All outputs can also be&n;   read. The byte passed is: DTR(b7) DCD RI DSR CTS RTS(b2) unused unused */
DECL|function|keyspan_pda_get_modem_info
r_static
r_int
id|keyspan_pda_get_modem_info
c_func
(paren
r_struct
id|usb_serial
op_star
id|serial
comma
r_int
r_char
op_star
id|value
)paren
(brace
r_int
id|rc
suffix:semicolon
r_int
r_char
id|data
suffix:semicolon
id|rc
op_assign
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
l_int|3
comma
multiline_comment|/* get pins */
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_INTERFACE
op_or
id|USB_DIR_IN
comma
l_int|0
comma
l_int|0
comma
op_amp
id|data
comma
l_int|1
comma
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OG
l_int|0
)paren
op_star
id|value
op_assign
id|data
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|keyspan_pda_set_modem_info
r_static
r_int
id|keyspan_pda_set_modem_info
c_func
(paren
r_struct
id|usb_serial
op_star
id|serial
comma
r_int
r_char
id|value
)paren
(brace
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
l_int|3
comma
multiline_comment|/* set pins */
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_INTERFACE
op_or
id|USB_DIR_OUT
comma
id|value
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|keyspan_pda_ioctl
r_static
r_int
id|keyspan_pda_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
r_int
id|value
suffix:semicolon
r_int
r_char
id|status
comma
id|mask
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMGET
suffix:colon
multiline_comment|/* get modem pins state */
id|rc
op_assign
id|keyspan_pda_get_modem_info
c_func
(paren
id|serial
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
id|value
op_assign
(paren
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
ques
c_cond
id|TIOCM_DTR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|6
)paren
)paren
ques
c_cond
id|TIOCM_CAR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
ques
c_cond
id|TIOCM_RNG
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|4
)paren
)paren
ques
c_cond
id|TIOCM_DSR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|3
)paren
)paren
ques
c_cond
id|TIOCM_CTS
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|2
)paren
)paren
ques
c_cond
id|TIOCM_RTS
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|arg
comma
op_amp
id|value
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCMSET
suffix:colon
multiline_comment|/* set a state as returned by MGET */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|value
comma
(paren
r_int
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|status
op_assign
(paren
(paren
id|value
op_amp
id|TIOCM_DTR
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|7
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|value
op_amp
id|TIOCM_CAR
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|6
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|value
op_amp
id|TIOCM_RNG
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|5
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|value
op_amp
id|TIOCM_DSR
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|4
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|value
op_amp
id|TIOCM_CTS
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|3
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|value
op_amp
id|TIOCM_RTS
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|2
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
id|rc
op_assign
id|keyspan_pda_set_modem_info
c_func
(paren
id|serial
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCMBIS
suffix:colon
multiline_comment|/* set bits in bitmask &lt;arg&gt; */
r_case
id|TIOCMBIC
suffix:colon
multiline_comment|/* clear bits from bitmask &lt;arg&gt; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|value
comma
(paren
r_int
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|rc
op_assign
id|keyspan_pda_get_modem_info
c_func
(paren
id|serial
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
id|mask
op_assign
(paren
(paren
id|value
op_amp
id|TIOCM_RTS
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|2
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|value
op_amp
id|TIOCM_DTR
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|7
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|TIOCMBIS
)paren
id|status
op_or_assign
id|mask
suffix:semicolon
r_else
id|status
op_and_assign
op_complement
id|mask
suffix:semicolon
id|rc
op_assign
id|keyspan_pda_set_modem_info
c_func
(paren
id|serial
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCMIWAIT
suffix:colon
multiline_comment|/* wait for any of the 4 modem inputs (DCD,RI,DSR,CTS)*/
multiline_comment|/* TODO */
r_case
id|TIOCGICOUNT
suffix:colon
multiline_comment|/* return count of modemline transitions */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* TODO */
)brace
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
DECL|function|keyspan_pda_write
r_static
r_int
id|keyspan_pda_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|port
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_int
id|request_unthrottle
op_assign
l_int|0
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
multiline_comment|/* guess how much room is left in the device&squot;s ring buffer, and if we&n;&t;   want to send more than that, check first, updating our notion of&n;&t;   what is left. If our write will result in no room left, ask the&n;&t;   device to give us an interrupt when the room available rises above&n;&t;   a threshold, and hold off all writers (eventually, those using&n;&t;   select() or poll() too) until we receive that unthrottle interrupt.&n;&t;   Block if we can&squot;t write anything at all, otherwise write as much as&n;&t;   we can. */
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot; write request of 0 bytes&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* we might block because of:&n;&t;   the TX urb is in-flight (wait until it completes)&n;&t;   the device is full (wait until it says there is room)&n;&t;*/
r_while
c_loop
(paren
id|serial-&gt;port
(braket
id|port
)braket
dot
id|write_urb.status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
r_if
c_cond
(paren
l_int|0
multiline_comment|/* file-&gt;f_flags &amp; O_NONBLOCK */
)paren
(brace
id|rc
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|serial-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
)brace
multiline_comment|/* at this point the URB is in our control, nobody else can submit it&n;&t;   again (the only sudden transition was the one from EINPROGRESS to&n;&t;   finished) */
multiline_comment|/* the next potential block is that our TX process might be throttled.&n;&t;   The transition from throttled-&gt;not happens because of an Rx&n;&t;   interrupt, and the wake_up occurs during the same interrupt, so we&n;&t;   have to be careful to avoid a race that would cause us to sleep&n;&t;   forever. */
id|add_wait_queue
c_func
(paren
op_amp
id|serial-&gt;write_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_while
c_loop
(paren
id|serial-&gt;tx_throttled
)paren
(brace
multiline_comment|/* device can&squot;t accomodate any more characters. Sleep until it&n;&t;&t;   can. Woken up by an Rx interrupt message, which clears&n;&t;&t;   tx_throttled first. */
id|dbg
c_func
(paren
l_string|&quot; tx_throttled, going to sleep&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|serial-&gt;write_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot; woke up because of signal&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot; woke up&quot;
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|serial-&gt;write_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|count
op_assign
(paren
id|count
OG
id|serial-&gt;port
(braket
id|port
)braket
dot
id|bulk_out_size
)paren
ques
c_cond
id|serial-&gt;port
(braket
id|port
)braket
dot
id|bulk_out_size
suffix:colon
id|count
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|serial-&gt;tx_room
)paren
(brace
r_int
r_char
id|room
suffix:semicolon
multiline_comment|/* Looks like we might overrun the Tx buffer. Ask the device&n;&t;&t;   how much room it really has */
id|rc
op_assign
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
l_int|6
comma
multiline_comment|/* write_room */
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_INTERFACE
op_or
id|USB_DIR_IN
comma
l_int|0
comma
multiline_comment|/* value: 0 means &quot;remaining room&quot; */
l_int|0
comma
multiline_comment|/* index */
op_amp
id|room
comma
l_int|1
comma
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot; roomquery failed&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
multiline_comment|/* failed */
)brace
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot; roomquery returned 0 bytes&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* device didn&squot;t return any data */
)brace
id|dbg
c_func
(paren
l_string|&quot; roomquery says %d&quot;
comma
id|room
)paren
suffix:semicolon
id|serial-&gt;tx_room
op_assign
id|room
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|serial-&gt;tx_room
)paren
(brace
multiline_comment|/* we&squot;re about to completely fill the Tx buffer, so&n;&t;&t;&t;   we&squot;ll be throttled afterwards. */
id|count
op_assign
id|serial-&gt;tx_room
suffix:semicolon
id|request_unthrottle
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|serial-&gt;tx_room
op_sub_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
multiline_comment|/* now transfer data */
r_if
c_cond
(paren
id|from_user
)paren
(brace
id|copy_from_user
c_func
(paren
id|serial-&gt;port
(braket
id|port
)braket
dot
id|write_urb.transfer_buffer
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
(paren
id|serial-&gt;port
(braket
id|port
)braket
dot
id|write_urb.transfer_buffer
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* send the data out the bulk port */
id|serial-&gt;port
(braket
id|port
)braket
dot
id|write_urb.transfer_buffer_length
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
op_amp
id|serial-&gt;port
(braket
id|port
)braket
dot
id|write_urb
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot; usb_submit_urb(write bulk) failed&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There wasn&squot;t any room left, so we are throttled until&n;&t;&t;   the buffer empties a bit */
id|request_unthrottle
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_unthrottle
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot; request_unthrottle&quot;
)paren
suffix:semicolon
multiline_comment|/* ask the device to tell us when the tx buffer becomes&n;&t;&t;   sufficiently empty */
id|serial-&gt;tx_throttled
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* block writers */
id|rc
op_assign
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
l_int|7
comma
multiline_comment|/* request_unthrottle */
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_INTERFACE
op_or
id|USB_DIR_OUT
comma
l_int|16
comma
multiline_comment|/* value: threshold */
l_int|0
comma
multiline_comment|/* index */
l_int|NULL
comma
l_int|0
comma
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
)brace
r_return
(paren
id|count
)paren
suffix:semicolon
id|err
suffix:colon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
DECL|function|keyspan_pda_write_bulk_callback
r_static
r_void
id|keyspan_pda_write_bulk_callback
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|serial-&gt;tty
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|serial-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
)brace
DECL|function|keyspan_pda_write_room
r_static
r_int
id|keyspan_pda_write_room
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
multiline_comment|/* used by n_tty.c for processing of tabs and such. Giving it our&n;&t;   conservative guess is probably good enough, but needs testing by&n;&t;   running a console through the device. */
r_return
(paren
id|serial-&gt;tx_room
)paren
suffix:semicolon
)brace
DECL|function|keyspan_pda_chars_in_buffer
r_static
r_int
id|keyspan_pda_chars_in_buffer
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
multiline_comment|/* when throttled, return at least WAKEUP_CHARS to tell select() (via&n;&t;   n_tty.c:normal_poll() ) that we&squot;re not writeable. */
r_if
c_cond
(paren
id|serial-&gt;tx_throttled
)paren
r_return
l_int|256
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|keyspan_pda_serial_open
r_static
r_int
id|keyspan_pda_serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|portNumber
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|portNumber
)braket
suffix:semicolon
r_int
r_char
id|room
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;active
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|port-&gt;active
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* find out how much room is in the Tx ring */
id|rc
op_assign
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
l_int|6
comma
multiline_comment|/* write_room */
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_INTERFACE
op_or
id|USB_DIR_IN
comma
l_int|0
comma
multiline_comment|/* value */
l_int|0
comma
multiline_comment|/* index */
op_amp
id|room
comma
l_int|1
comma
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot; roomquery failed&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
multiline_comment|/* failed */
)brace
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot; roomquery returned 0 bytes&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* device didn&squot;t return any data */
)brace
id|serial-&gt;tx_room
op_assign
id|room
suffix:semicolon
id|serial-&gt;tx_throttled
op_assign
id|room
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* the normal serial device seems to always turn on DTR and RTS here,&n;&t;   so do the same */
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CBAUD
)paren
id|keyspan_pda_set_modem_info
c_func
(paren
id|serial
comma
(paren
l_int|1
op_lshift
l_int|7
)paren
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
r_else
id|keyspan_pda_set_modem_info
c_func
(paren
id|serial
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*Start reading from the device*/
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
op_amp
id|port-&gt;read_urb
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot; usb_submit_urb(read int) failed&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|keyspan_pda_serial_close
r_static
r_void
id|keyspan_pda_serial_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|portNumber
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|portNumber
)braket
suffix:semicolon
multiline_comment|/* the normal serial device seems to always shut off DTR and RTS now */
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|HUPCL
)paren
id|keyspan_pda_set_modem_info
c_func
(paren
id|serial
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* shutdown our bulk reads and writes */
id|usb_unlink_urb
(paren
op_amp
id|port-&gt;write_urb
)paren
suffix:semicolon
id|usb_unlink_urb
(paren
op_amp
id|port-&gt;read_urb
)paren
suffix:semicolon
id|port-&gt;active
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* download the firmware to a &quot;fake&quot; device (pre-renumeration) */
DECL|function|keyspan_pda_fake_startup
r_static
r_int
id|keyspan_pda_fake_startup
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
r_int
id|response
suffix:semicolon
r_const
r_struct
id|ezusb_hex_record
op_star
id|record
suffix:semicolon
multiline_comment|/* download the firmware here ... */
id|response
op_assign
id|ezusb_set_reset
c_func
(paren
id|serial
comma
l_int|1
)paren
suffix:semicolon
id|record
op_assign
op_amp
id|keyspan_pda_firmware
(braket
l_int|0
)braket
suffix:semicolon
r_while
c_loop
(paren
id|record-&gt;address
op_ne
l_int|0xffff
)paren
(brace
id|response
op_assign
id|ezusb_writememory
c_func
(paren
id|serial
comma
id|record-&gt;address
comma
(paren
r_int
r_char
op_star
)paren
id|record-&gt;data
comma
id|record-&gt;data_size
comma
l_int|0xa0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|response
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;ezusb_writememory failed for Keyspan PDA &quot;
l_string|&quot;firmware (%d %04X %p %d)&quot;
comma
id|response
comma
id|record-&gt;address
comma
id|record-&gt;data
comma
id|record-&gt;data_size
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|record
op_increment
suffix:semicolon
)brace
multiline_comment|/* bring device out of reset. Renumeration will occur in a moment&n;&t;   and the new device will bind to the real driver */
id|response
op_assign
id|ezusb_set_reset
c_func
(paren
id|serial
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* we want this device to fail to have a driver assigned to it. */
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* do some startup allocations not currently performed by usb_serial_probe() */
DECL|function|keyspan_pda_startup
r_static
r_int
id|keyspan_pda_startup
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
r_struct
id|usb_endpoint_descriptor
op_star
id|intin
suffix:semicolon
id|intin
op_assign
id|serial-&gt;port
(braket
l_int|0
)braket
dot
id|interrupt_in_endpoint
suffix:semicolon
multiline_comment|/* set up the receive interrupt urb */
id|FILL_INT_URB
c_func
(paren
op_amp
id|serial-&gt;port
(braket
l_int|0
)braket
dot
id|read_urb
comma
id|serial-&gt;dev
comma
id|usb_rcvintpipe
c_func
(paren
id|serial-&gt;dev
comma
id|intin-&gt;bEndpointAddress
)paren
comma
id|serial-&gt;port
(braket
l_int|0
)braket
dot
id|interrupt_in_buffer
comma
id|intin-&gt;wMaxPacketSize
comma
id|keyspan_pda_rx_interrupt
comma
id|serial
comma
id|intin-&gt;bInterval
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|serial-&gt;write_wait
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_USB_SERIAL_KEYSPAN_PDA */
multiline_comment|/*****************************************************************************&n; * generic devices specific driver functions&n; *****************************************************************************/
DECL|function|generic_serial_open
r_static
r_int
id|generic_serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|portNumber
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|portNumber
)braket
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;generic_serial_open port %d&quot;
comma
id|portNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;active
)paren
(brace
id|dbg
(paren
l_string|&quot;device already open&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|port-&gt;active
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* if we have a bulk interrupt, start reading from it */
r_if
c_cond
(paren
id|serial-&gt;num_bulk_in
)paren
(brace
multiline_comment|/*Start reading from the device*/
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
op_amp
id|port-&gt;read_urb
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot;usb_submit_urb(read bulk) failed&quot;
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|generic_serial_close
r_static
r_void
id|generic_serial_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|portNumber
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|portNumber
)braket
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;generic_serial_close port %d&quot;
comma
id|portNumber
)paren
suffix:semicolon
multiline_comment|/* shutdown any bulk reads that might be going on */
r_if
c_cond
(paren
id|serial-&gt;num_bulk_out
)paren
(brace
id|usb_unlink_urb
(paren
op_amp
id|port-&gt;write_urb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|serial-&gt;num_bulk_in
)paren
(brace
id|usb_unlink_urb
(paren
op_amp
id|port-&gt;read_urb
)paren
suffix:semicolon
)brace
id|port-&gt;active
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|generic_serial_write
r_static
r_int
id|generic_serial_write
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|portNumber
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|portNumber
)braket
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;generic_serial_write port %d&quot;
comma
id|portNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;write request of 0 bytes&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* only do something if we have a bulk out endpoint */
r_if
c_cond
(paren
id|serial-&gt;num_bulk_out
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;write_urb.status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
id|dbg
(paren
l_string|&quot;already writing&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|count
op_assign
(paren
id|count
OG
id|port-&gt;bulk_out_size
)paren
ques
c_cond
id|port-&gt;bulk_out_size
suffix:colon
id|count
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
(brace
id|copy_from_user
c_func
(paren
id|port-&gt;write_urb.transfer_buffer
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
(paren
id|port-&gt;write_urb.transfer_buffer
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* send the data out the bulk port */
id|port-&gt;write_urb.transfer_buffer_length
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
op_amp
id|port-&gt;write_urb
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot;usb_submit_urb(write bulk) failed&quot;
)paren
suffix:semicolon
r_return
(paren
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* no bulk out, so return 0 bytes written */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|generic_write_room
r_static
r_int
id|generic_write_room
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|portNumber
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|portNumber
)braket
suffix:semicolon
r_int
id|room
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;generic_write_room port %d&quot;
comma
id|portNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial-&gt;num_bulk_out
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;write_urb.status
op_eq
op_minus
id|EINPROGRESS
)paren
id|room
op_assign
l_int|0
suffix:semicolon
r_else
id|room
op_assign
id|port-&gt;bulk_out_size
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;generic_write_room returns %d&quot;
comma
id|room
)paren
suffix:semicolon
r_return
(paren
id|room
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|generic_chars_in_buffer
r_static
r_int
id|generic_chars_in_buffer
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|portNumber
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|portNumber
)braket
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;generic_chars_in_buffer port %d&quot;
comma
id|portNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial-&gt;num_bulk_out
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;write_urb.status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
r_return
(paren
id|port-&gt;bulk_out_size
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|generic_throttle
r_static
r_void
id|generic_throttle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
multiline_comment|/* do nothing for the generic device */
r_return
suffix:semicolon
)brace
DECL|function|generic_unthrottle
r_static
r_void
id|generic_unthrottle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
multiline_comment|/* do nothing for the generic device */
r_return
suffix:semicolon
)brace
DECL|function|generic_ioctl
r_static
r_int
id|generic_ioctl
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
multiline_comment|/* generic driver doesn&squot;t support any ioctls yet */
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
DECL|function|generic_set_termios
r_static
r_void
id|generic_set_termios
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old
)paren
(brace
multiline_comment|/* generic driver doesn&squot;t really care about setting any line settings */
r_return
suffix:semicolon
)brace
DECL|function|generic_read_bulk_callback
r_static
r_void
id|generic_read_bulk_callback
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|serial-&gt;tty
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;generic_read_bulk_callback&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;nonzero read bulk status received: %d&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|urb-&gt;actual_length
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
id|__FILE__
l_string|&quot;: data read - length = %d, data = &quot;
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;actual_length
suffix:semicolon
op_increment
id|i
)paren
(brace
id|printk
(paren
l_string|&quot;%.2x &quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|urb-&gt;actual_length
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;actual_length
suffix:semicolon
op_increment
id|i
)paren
(brace
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|data
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* Continue trying to always read  */
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
id|urb
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot;failed resubmitting read urb&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|generic_write_bulk_callback
r_static
r_void
id|generic_write_bulk_callback
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|serial-&gt;tty
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;generic_write_bulk_callback&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;nonzero write bulk status received: %d&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|usb_serial_probe
r_static
r_void
op_star
id|usb_serial_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|interface
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|endpoint
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|interrupt_in_endpoint
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|bulk_in_endpoint
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|bulk_out_endpoint
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
r_struct
id|usb_serial_device_type
op_star
id|type
suffix:semicolon
r_int
id|device_num
suffix:semicolon
r_int
id|minor
suffix:semicolon
r_int
id|buffer_size
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
id|interrupt_pipe
suffix:semicolon
r_char
id|bulk_in_pipe
suffix:semicolon
r_char
id|bulk_out_pipe
suffix:semicolon
r_int
id|num_interrupt_in
op_assign
l_int|0
suffix:semicolon
r_int
id|num_bulk_in
op_assign
l_int|0
suffix:semicolon
r_int
id|num_bulk_out
op_assign
l_int|0
suffix:semicolon
r_int
id|num_ports
suffix:semicolon
multiline_comment|/* loop through our list of known serial converters, and see if this device matches */
id|device_num
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|usb_serial_devices
(braket
id|device_num
)braket
op_ne
l_int|NULL
)paren
(brace
id|type
op_assign
id|usb_serial_devices
(braket
id|device_num
)braket
suffix:semicolon
id|dbg
(paren
l_string|&quot;Looking at %s Vendor id=%.4x Product id=%.4x&quot;
comma
id|type-&gt;name
comma
op_star
(paren
id|type-&gt;idVendor
)paren
comma
op_star
(paren
id|type-&gt;idProduct
)paren
)paren
suffix:semicolon
multiline_comment|/* look at the device descriptor */
r_if
c_cond
(paren
(paren
id|dev-&gt;descriptor.idVendor
op_eq
op_star
(paren
id|type-&gt;idVendor
)paren
)paren
op_logical_and
(paren
id|dev-&gt;descriptor.idProduct
op_eq
op_star
(paren
id|type-&gt;idProduct
)paren
)paren
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;descriptor matches...looking at the endpoints&quot;
)paren
suffix:semicolon
multiline_comment|/* descriptor matches, let&squot;s try to find the endpoints needed */
id|interrupt_pipe
op_assign
id|bulk_in_pipe
op_assign
id|bulk_out_pipe
op_assign
id|HAS_NOT
suffix:semicolon
multiline_comment|/* check out the endpoints */
id|interface
op_assign
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|ifnum
)braket
dot
id|altsetting
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|interface-&gt;bNumEndpoints
suffix:semicolon
op_increment
id|i
)paren
(brace
id|endpoint
op_assign
op_amp
id|interface-&gt;endpoint
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|endpoint-&gt;bEndpointAddress
op_amp
l_int|0x80
)paren
op_logical_and
(paren
(paren
id|endpoint-&gt;bmAttributes
op_amp
l_int|3
)paren
op_eq
l_int|0x02
)paren
)paren
(brace
multiline_comment|/* we found a bulk in endpoint */
id|dbg
c_func
(paren
l_string|&quot;found bulk in&quot;
)paren
suffix:semicolon
id|bulk_in_pipe
op_assign
id|HAS
suffix:semicolon
id|bulk_in_endpoint
(braket
id|num_bulk_in
)braket
op_assign
id|endpoint
suffix:semicolon
op_increment
id|num_bulk_in
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|endpoint-&gt;bEndpointAddress
op_amp
l_int|0x80
)paren
op_eq
l_int|0x00
)paren
op_logical_and
(paren
(paren
id|endpoint-&gt;bmAttributes
op_amp
l_int|3
)paren
op_eq
l_int|0x02
)paren
)paren
(brace
multiline_comment|/* we found a bulk out endpoint */
id|dbg
c_func
(paren
l_string|&quot;found bulk out&quot;
)paren
suffix:semicolon
id|bulk_out_pipe
op_assign
id|HAS
suffix:semicolon
id|bulk_out_endpoint
(braket
id|num_bulk_out
)braket
op_assign
id|endpoint
suffix:semicolon
op_increment
id|num_bulk_out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|endpoint-&gt;bEndpointAddress
op_amp
l_int|0x80
)paren
op_logical_and
(paren
(paren
id|endpoint-&gt;bmAttributes
op_amp
l_int|3
)paren
op_eq
l_int|0x03
)paren
)paren
(brace
multiline_comment|/* we found a interrupt in endpoint */
id|dbg
c_func
(paren
l_string|&quot;found interrupt in&quot;
)paren
suffix:semicolon
id|interrupt_pipe
op_assign
id|HAS
suffix:semicolon
id|interrupt_in_endpoint
(braket
id|num_interrupt_in
)braket
op_assign
id|endpoint
suffix:semicolon
op_increment
id|num_interrupt_in
suffix:semicolon
)brace
)brace
multiline_comment|/* verify that we found all of the endpoints that we need */
r_if
c_cond
(paren
(paren
id|interrupt_pipe
op_amp
id|type-&gt;needs_interrupt_in
)paren
op_logical_and
(paren
id|bulk_in_pipe
op_amp
id|type-&gt;needs_bulk_in
)paren
op_logical_and
(paren
id|bulk_out_pipe
op_amp
id|type-&gt;needs_bulk_out
)paren
)paren
(brace
multiline_comment|/* found all that we need */
id|info
c_func
(paren
l_string|&quot;%s converter detected&quot;
comma
id|type-&gt;name
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_USB_SERIAL_GENERIC
r_if
c_cond
(paren
id|type
op_eq
op_amp
id|generic_device
)paren
id|num_ports
op_assign
id|num_bulk_out
suffix:semicolon
r_else
macro_line|#endif
id|num_ports
op_assign
id|type-&gt;num_ports
suffix:semicolon
id|serial
op_assign
id|get_free_serial
(paren
id|num_ports
comma
op_amp
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;No more free serial devices&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|serial-&gt;dev
op_assign
id|dev
suffix:semicolon
id|serial-&gt;type
op_assign
id|type
suffix:semicolon
id|serial-&gt;minor
op_assign
id|minor
suffix:semicolon
id|serial-&gt;num_ports
op_assign
id|num_ports
suffix:semicolon
id|serial-&gt;num_bulk_in
op_assign
id|num_bulk_in
suffix:semicolon
id|serial-&gt;num_bulk_out
op_assign
id|num_bulk_out
suffix:semicolon
id|serial-&gt;num_interrupt_in
op_assign
id|num_interrupt_in
suffix:semicolon
multiline_comment|/* collect interrupt_in endpoints now, because&n;&t;&t;&t;&t;   the keyspan_pda startup function needs&n;&t;&t;&t;&t;   to know about them */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_interrupt_in
suffix:semicolon
op_increment
id|i
)paren
(brace
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
id|buffer_size
op_assign
id|interrupt_in_endpoint
(braket
id|i
)braket
op_member_access_from_pointer
id|wMaxPacketSize
suffix:semicolon
id|port-&gt;interrupt_in_buffer
op_assign
id|kmalloc
(paren
id|buffer_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;interrupt_in_buffer
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Couldn&squot;t allocate interrupt_in_buffer&quot;
)paren
suffix:semicolon
r_goto
id|probe_error
suffix:semicolon
)brace
id|port-&gt;interrupt_in_endpoint
op_assign
id|interrupt_in_endpoint
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* if this device type has a startup function, call it */
r_if
c_cond
(paren
id|type-&gt;startup
)paren
(brace
r_if
c_cond
(paren
id|type-&gt;startup
(paren
id|serial
)paren
)paren
(brace
id|return_serial
(paren
id|serial
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* set up the endpoint information */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_bulk_in
suffix:semicolon
op_increment
id|i
)paren
(brace
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
id|buffer_size
op_assign
id|bulk_in_endpoint
(braket
id|i
)braket
op_member_access_from_pointer
id|wMaxPacketSize
suffix:semicolon
id|port-&gt;bulk_in_buffer
op_assign
id|kmalloc
(paren
id|buffer_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;bulk_in_buffer
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Couldn&squot;t allocate bulk_in_buffer&quot;
)paren
suffix:semicolon
r_goto
id|probe_error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|serial-&gt;type-&gt;read_bulk_callback
)paren
(brace
id|FILL_BULK_URB
c_func
(paren
op_amp
id|port-&gt;read_urb
comma
id|dev
comma
id|usb_rcvbulkpipe
(paren
id|dev
comma
id|bulk_in_endpoint
(braket
id|i
)braket
op_member_access_from_pointer
id|bEndpointAddress
)paren
comma
id|port-&gt;bulk_in_buffer
comma
id|buffer_size
comma
id|serial-&gt;type-&gt;read_bulk_callback
comma
id|serial
)paren
suffix:semicolon
)brace
r_else
(brace
id|FILL_BULK_URB
c_func
(paren
op_amp
id|port-&gt;read_urb
comma
id|dev
comma
id|usb_rcvbulkpipe
(paren
id|dev
comma
id|bulk_in_endpoint
(braket
id|i
)braket
op_member_access_from_pointer
id|bEndpointAddress
)paren
comma
id|port-&gt;bulk_in_buffer
comma
id|buffer_size
comma
id|generic_read_bulk_callback
comma
id|serial
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_bulk_out
suffix:semicolon
op_increment
id|i
)paren
(brace
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
id|port-&gt;bulk_out_size
op_assign
id|bulk_out_endpoint
(braket
id|i
)braket
op_member_access_from_pointer
id|wMaxPacketSize
suffix:semicolon
id|port-&gt;bulk_out_buffer
op_assign
id|kmalloc
(paren
id|port-&gt;bulk_out_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;bulk_out_buffer
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Couldn&squot;t allocate bulk_out_buffer&quot;
)paren
suffix:semicolon
r_goto
id|probe_error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|serial-&gt;type-&gt;write_bulk_callback
)paren
(brace
id|FILL_BULK_URB
c_func
(paren
op_amp
id|port-&gt;write_urb
comma
id|dev
comma
id|usb_sndbulkpipe
(paren
id|dev
comma
id|bulk_out_endpoint
(braket
id|i
)braket
op_member_access_from_pointer
id|bEndpointAddress
)paren
comma
id|port-&gt;bulk_out_buffer
comma
id|port-&gt;bulk_out_size
comma
id|serial-&gt;type-&gt;write_bulk_callback
comma
id|serial
)paren
suffix:semicolon
)brace
r_else
(brace
id|FILL_BULK_URB
c_func
(paren
op_amp
id|port-&gt;write_urb
comma
id|dev
comma
id|usb_sndbulkpipe
(paren
id|dev
comma
id|bulk_out_endpoint
(braket
id|i
)braket
op_member_access_from_pointer
id|bEndpointAddress
)paren
comma
id|port-&gt;bulk_out_buffer
comma
id|port-&gt;bulk_out_size
comma
id|generic_write_bulk_callback
comma
id|serial
)paren
suffix:semicolon
)brace
)brace
macro_line|#if 0 /* use this code when WhiteHEAT is up and running */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_interrupt_in
suffix:semicolon
op_increment
id|i
)paren
(brace
id|buffer_size
op_assign
id|interrupt_in_endpoint
(braket
id|i
)braket
op_member_access_from_pointer
id|wMaxPacketSize
suffix:semicolon
id|serial-&gt;interrupt_in_buffer
(braket
id|i
)braket
op_assign
id|kmalloc
(paren
id|buffer_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;interrupt_in_buffer
(braket
id|i
)braket
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Couldn&squot;t allocate interrupt_in_buffer&quot;
)paren
suffix:semicolon
r_goto
id|probe_error
suffix:semicolon
)brace
id|FILL_INT_URB
c_func
(paren
op_amp
id|serial-&gt;control_urb
(braket
id|i
)braket
comma
id|dev
comma
id|usb_rcvintpipe
(paren
id|dev
comma
id|interrupt_in_endpoint
(braket
id|i
)braket
op_member_access_from_pointer
id|bEndpointAddress
)paren
comma
id|serial-&gt;interrupt_in_buffer
(braket
id|i
)braket
comma
id|buffer_size
comma
id|serial_control_irq
comma
id|serial
comma
id|interrupt_in_endpoint
(braket
id|i
)braket
op_member_access_from_pointer
id|bInterval
)paren
suffix:semicolon
)brace
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_ports
suffix:semicolon
op_increment
id|i
)paren
(brace
id|info
c_func
(paren
l_string|&quot;%s converter now attached to ttyUSB%d&quot;
comma
id|type-&gt;name
comma
id|serial-&gt;minor
op_plus
id|i
)paren
suffix:semicolon
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
id|serial
suffix:semicolon
)brace
r_else
(brace
id|info
c_func
(paren
l_string|&quot;descriptors matched, but endpoints did not&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* look at the next type in our list */
op_increment
id|device_num
suffix:semicolon
)brace
id|probe_error
suffix:colon
r_if
c_cond
(paren
id|serial
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_bulk_in
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|serial-&gt;port
(braket
id|i
)braket
dot
id|bulk_in_buffer
(braket
id|i
)braket
)paren
id|kfree
(paren
id|serial-&gt;port
(braket
id|i
)braket
dot
id|bulk_in_buffer
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_bulk_out
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|serial-&gt;port
(braket
id|i
)braket
dot
id|bulk_out_buffer
)paren
id|kfree
(paren
id|serial-&gt;port
(braket
id|i
)braket
dot
id|bulk_out_buffer
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_interrupt_in
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|serial-&gt;port
(braket
id|i
)braket
dot
id|interrupt_in_buffer
)paren
id|kfree
(paren
id|serial-&gt;port
(braket
id|i
)braket
dot
id|interrupt_in_buffer
)paren
suffix:semicolon
multiline_comment|/* return the minor range that this device had */
id|return_serial
(paren
id|serial
)paren
suffix:semicolon
multiline_comment|/* free up any memory that we allocated */
id|kfree
(paren
id|serial
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|usb_serial_disconnect
r_static
r_void
id|usb_serial_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
(paren
r_struct
id|usb_serial
op_star
)paren
id|ptr
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|serial
)paren
(brace
multiline_comment|/* need to stop any transfers...*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_ports
suffix:semicolon
op_increment
id|i
)paren
(brace
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
id|usb_unlink_urb
(paren
op_amp
id|port-&gt;write_urb
)paren
suffix:semicolon
id|usb_unlink_urb
(paren
op_amp
id|port-&gt;read_urb
)paren
suffix:semicolon
id|port-&gt;active
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* free up any memory that we allocated */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_bulk_in
suffix:semicolon
op_increment
id|i
)paren
(brace
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;bulk_in_buffer
)paren
id|kfree
(paren
id|port-&gt;bulk_in_buffer
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_bulk_out
suffix:semicolon
op_increment
id|i
)paren
(brace
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;bulk_out_buffer
)paren
id|kfree
(paren
id|port-&gt;bulk_out_buffer
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_interrupt_in
suffix:semicolon
op_increment
id|i
)paren
(brace
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;interrupt_in_buffer
)paren
id|kfree
(paren
id|port-&gt;interrupt_in_buffer
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_ports
suffix:semicolon
op_increment
id|i
)paren
(brace
id|info
c_func
(paren
l_string|&quot;%s converter now disconnected from ttyUSB%d&quot;
comma
id|serial-&gt;type-&gt;name
comma
id|serial-&gt;minor
op_plus
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* return the minor range that this device had */
id|return_serial
(paren
id|serial
)paren
suffix:semicolon
multiline_comment|/* free up any memory that we allocated */
id|kfree
(paren
id|serial
)paren
suffix:semicolon
)brace
r_else
(brace
id|info
c_func
(paren
l_string|&quot;device disconnected&quot;
)paren
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|variable|serial_tty_driver
r_static
r_struct
id|tty_driver
id|serial_tty_driver
op_assign
(brace
id|magic
suffix:colon
id|TTY_DRIVER_MAGIC
comma
id|driver_name
suffix:colon
l_string|&quot;usb&quot;
comma
id|name
suffix:colon
l_string|&quot;ttyUSB&quot;
comma
id|major
suffix:colon
id|SERIAL_TTY_MAJOR
comma
id|minor_start
suffix:colon
l_int|0
comma
id|num
suffix:colon
id|SERIAL_TTY_MINORS
comma
id|type
suffix:colon
id|TTY_DRIVER_TYPE_SERIAL
comma
id|subtype
suffix:colon
id|SERIAL_TYPE_NORMAL
comma
id|flags
suffix:colon
id|TTY_DRIVER_REAL_RAW
comma
id|refcount
suffix:colon
op_amp
id|serial_refcount
comma
id|table
suffix:colon
id|serial_tty
comma
id|proc_entry
suffix:colon
l_int|NULL
comma
id|other
suffix:colon
l_int|NULL
comma
id|termios
suffix:colon
id|serial_termios
comma
id|termios_locked
suffix:colon
id|serial_termios_locked
comma
id|open
suffix:colon
id|serial_open
comma
id|close
suffix:colon
id|serial_close
comma
id|write
suffix:colon
id|serial_write
comma
id|put_char
suffix:colon
l_int|NULL
comma
id|flush_chars
suffix:colon
l_int|NULL
comma
id|write_room
suffix:colon
id|serial_write_room
comma
id|ioctl
suffix:colon
id|serial_ioctl
comma
id|set_termios
suffix:colon
id|serial_set_termios
comma
id|set_ldisc
suffix:colon
l_int|NULL
comma
id|throttle
suffix:colon
id|serial_throttle
comma
id|unthrottle
suffix:colon
id|serial_unthrottle
comma
id|stop
suffix:colon
l_int|NULL
comma
id|start
suffix:colon
l_int|NULL
comma
id|hangup
suffix:colon
l_int|NULL
comma
id|break_ctl
suffix:colon
id|serial_break
comma
id|wait_until_sent
suffix:colon
l_int|NULL
comma
id|send_xchar
suffix:colon
l_int|NULL
comma
id|read_proc
suffix:colon
l_int|NULL
comma
id|chars_in_buffer
suffix:colon
id|serial_chars_in_buffer
comma
id|flush_buffer
suffix:colon
l_int|NULL
)brace
suffix:semicolon
DECL|function|usb_serial_init
r_int
id|usb_serial_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Initalize our global data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SERIAL_TTY_MINORS
suffix:semicolon
op_increment
id|i
)paren
(brace
id|serial_table
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* register the tty driver */
id|serial_tty_driver.init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|serial_tty_driver.init_termios.c_cflag
op_assign
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
op_or
id|CLOCAL
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
(paren
op_amp
id|serial_tty_driver
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;failed to register tty driver&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/* register the USB driver */
r_if
c_cond
(paren
id|usb_register
c_func
(paren
op_amp
id|usb_serial_driver
)paren
OL
l_int|0
)paren
(brace
id|tty_unregister_driver
c_func
(paren
op_amp
id|serial_tty_driver
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|info
c_func
(paren
l_string|&quot;support registered&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_serial_exit
r_void
id|usb_serial_exit
c_func
(paren
r_void
)paren
(brace
id|tty_unregister_driver
c_func
(paren
op_amp
id|serial_tty_driver
)paren
suffix:semicolon
id|usb_deregister
c_func
(paren
op_amp
id|usb_serial_driver
)paren
suffix:semicolon
)brace
DECL|variable|usb_serial_init
id|module_init
c_func
(paren
id|usb_serial_init
)paren
suffix:semicolon
DECL|variable|usb_serial_exit
id|module_exit
c_func
(paren
id|usb_serial_exit
)paren
suffix:semicolon
eof
