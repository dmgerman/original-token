multiline_comment|/*&n; * USB Keyspan PDA Converter driver&n; *&n; * Copyright (c) 1999, 2000 Greg Kroah-Hartman&t;&lt;greg@kroah.com&gt;&n; * Copyright (c) 1999, 2000 Brian Warner&t;&lt;warner@lothar.com&gt;&n; * Copyright (c) 2000 Al Borchers&t;&t;&lt;borchers@steinerpoint.com&gt;&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; * See Documentation/usb/usb-serial.txt for more information on using this driver&n; * &n; * (11/01/2000) Adam J. Richter&n; *&t;usb_device_id table support&n; * &n; * (10/05/2000) gkh&n; *&t;Fixed bug with urb-&gt;dev not being set properly, now that the usb&n; *&t;core needs it.&n; * &n; * (08/28/2000) gkh&n; *&t;Added locks for SMP safeness.&n; *&t;Fixed MOD_INC and MOD_DEC logic and the ability to open a port more &n; *&t;than once.&n; * &n; * (07/20/2000) borchers&n; *&t;- keyspan_pda_write no longer sleeps if it is called on interrupt time;&n; *&t;  PPP and the line discipline with stty echo on can call write on&n; *&t;  interrupt time and this would cause an oops if write slept&n; *&t;- if keyspan_pda_write is in an interrupt, it will not call&n; *&t;  usb_control_msg (which sleeps) to query the room in the device&n; *&t;  buffer, it simply uses the current room value it has&n; *&t;- if the urb is busy or if it is throttled keyspan_pda_write just&n; *&t;  returns 0, rather than sleeping to wait for this to change; the&n; *&t;  write_chan code in n_tty.c will sleep if needed before calling&n; *&t;  keyspan_pda_write again&n; *&t;- if the device needs to be unthrottled, write now queues up the&n; *&t;  call to usb_control_msg (which sleeps) to unthrottle the device&n; *&t;- the wakeups from keyspan_pda_write_bulk_callback are queued rather&n; *&t;  than done directly from the callback to avoid the race in write_chan&n; *&t;- keyspan_pda_chars_in_buffer also indicates its buffer is full if the&n; *&t;  urb status is -EINPROGRESS, meaning it cannot write at the moment&n; *      &n; * (07/19/2000) gkh&n; *&t;Added module_init and module_exit functions to handle the fact that this&n; *&t;driver is a loadable module now.&n; *&n; * (03/26/2000) gkh&n; *&t;Split driver up into device specific pieces.&n; * &n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/tty_driver.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#ifdef CONFIG_USB_SERIAL_DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#else
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
macro_line|#include &lt;linux/usb.h&gt;
DECL|struct|ezusb_hex_record
r_struct
id|ezusb_hex_record
(brace
DECL|member|address
id|__u16
id|address
suffix:semicolon
DECL|member|data_size
id|__u8
id|data_size
suffix:semicolon
DECL|member|data
id|__u8
id|data
(braket
l_int|16
)braket
suffix:semicolon
)brace
suffix:semicolon
macro_line|#include &quot;keyspan_pda_fw.h&quot;
macro_line|#include &quot;usb-serial.h&quot;
DECL|struct|keyspan_pda_private
r_struct
id|keyspan_pda_private
(brace
DECL|member|tx_room
r_int
id|tx_room
suffix:semicolon
DECL|member|tx_throttled
r_int
id|tx_throttled
suffix:semicolon
DECL|member|wakeup_task
r_struct
id|tq_struct
id|wakeup_task
suffix:semicolon
DECL|member|unthrottle_task
r_struct
id|tq_struct
id|unthrottle_task
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|KEYSPAN_VENDOR_ID
mdefine_line|#define KEYSPAN_VENDOR_ID&t;&t;0x06cd
DECL|macro|KEYSPAN_PDA_FAKE_ID
mdefine_line|#define KEYSPAN_PDA_FAKE_ID&t;&t;0x0103
DECL|macro|KEYSPAN_PDA_ID
mdefine_line|#define KEYSPAN_PDA_ID&t;&t;&t;0x0104 /* no clue */
DECL|variable|id_table_combined
r_static
id|__devinitdata
r_struct
id|usb_device_id
id|id_table_combined
(braket
)braket
op_assign
(brace
(brace
id|USB_DEVICE
c_func
(paren
id|KEYSPAN_VENDOR_ID
comma
id|KEYSPAN_PDA_FAKE_ID
)paren
)brace
comma
(brace
id|USB_DEVICE
c_func
(paren
id|KEYSPAN_VENDOR_ID
comma
id|KEYSPAN_PDA_ID
)paren
)brace
comma
(brace
)brace
multiline_comment|/* Terminating entry */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|usb
comma
id|id_table_combined
)paren
suffix:semicolon
DECL|variable|id_table_std
r_static
id|__devinitdata
r_struct
id|usb_device_id
id|id_table_std
(braket
)braket
op_assign
(brace
(brace
id|USB_DEVICE
c_func
(paren
id|KEYSPAN_VENDOR_ID
comma
id|KEYSPAN_PDA_ID
)paren
)brace
comma
(brace
)brace
multiline_comment|/* Terminating entry */
)brace
suffix:semicolon
DECL|variable|id_table_fake
r_static
id|__devinitdata
r_struct
id|usb_device_id
id|id_table_fake
(braket
)braket
op_assign
(brace
(brace
id|USB_DEVICE
c_func
(paren
id|KEYSPAN_VENDOR_ID
comma
id|KEYSPAN_PDA_FAKE_ID
)paren
)brace
comma
(brace
)brace
multiline_comment|/* Terminating entry */
)brace
suffix:semicolon
DECL|function|keyspan_pda_wakeup_write
r_static
r_void
id|keyspan_pda_wakeup_write
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|port-&gt;tty
suffix:semicolon
multiline_comment|/* wake up port processes */
id|wake_up_interruptible
c_func
(paren
op_amp
id|port-&gt;write_wait
)paren
suffix:semicolon
multiline_comment|/* wake up line discipline */
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(brace
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* wake up other tty processes */
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
multiline_comment|/* For 2.2.16 backport -- wake_up_interruptible( &amp;tty-&gt;poll_wait ); */
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|function|keyspan_pda_request_unthrottle
r_static
r_void
id|keyspan_pda_request_unthrottle
c_func
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot; request_unthrottle&quot;
)paren
suffix:semicolon
multiline_comment|/* ask the device to tell us when the tx buffer becomes&n;&t;   sufficiently empty */
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
l_int|7
comma
multiline_comment|/* request_unthrottle */
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_INTERFACE
op_or
id|USB_DIR_OUT
comma
l_int|16
comma
multiline_comment|/* value: threshold */
l_int|0
comma
multiline_comment|/* index */
l_int|NULL
comma
l_int|0
comma
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|function|keyspan_pda_rx_interrupt
r_static
r_void
id|keyspan_pda_rx_interrupt
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|keyspan_pda_private
op_star
id|priv
suffix:semicolon
id|priv
op_assign
(paren
r_struct
id|keyspan_pda_private
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
multiline_comment|/* the urb might have been killed. */
r_if
c_cond
(paren
id|urb-&gt;status
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|port_paranoia_check
(paren
id|port
comma
l_string|&quot;keyspan_pda_rx_interrupt&quot;
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_if
c_cond
(paren
id|serial_paranoia_check
(paren
id|serial
comma
l_string|&quot;keyspan_pda_rx_interrupt&quot;
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* see if the message is data or a status interrupt */
r_switch
c_cond
(paren
id|data
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* rest of message is rx data */
r_if
c_cond
(paren
id|urb-&gt;actual_length
)paren
(brace
id|tty
op_assign
id|serial-&gt;port
(braket
l_int|0
)braket
dot
id|tty
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|urb-&gt;actual_length
suffix:semicolon
op_increment
id|i
)paren
(brace
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|data
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* status interrupt */
id|dbg
c_func
(paren
l_string|&quot; rx int, d1=%d, d2=%d&quot;
comma
id|data
(braket
l_int|1
)braket
comma
id|data
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|data
(braket
l_int|1
)braket
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* modemline change */
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* tx unthrottle interrupt */
id|tty
op_assign
id|serial-&gt;port
(braket
l_int|0
)braket
dot
id|tty
suffix:semicolon
id|priv-&gt;tx_throttled
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* queue up a wakeup at scheduler time */
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|schedule_task
c_func
(paren
op_amp
id|priv-&gt;wakeup_task
)paren
op_eq
l_int|0
)paren
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* INT urbs are automatically re-submitted */
)brace
DECL|function|keyspan_pda_rx_throttle
r_static
r_void
id|keyspan_pda_rx_throttle
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
multiline_comment|/* stop receiving characters. We just turn off the URB request, and&n;&t;   let chars pile up in the device. If we&squot;re doing hardware&n;&t;   flowcontrol, the device will signal the other end when its buffer&n;&t;   fills up. If we&squot;re doing XON/XOFF, this would be a good time to&n;&t;   send an XOFF, although it might make sense to foist that off&n;&t;   upon the device too. */
id|dbg
c_func
(paren
l_string|&quot;keyspan_pda_rx_throttle port %d&quot;
comma
id|port-&gt;number
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|port-&gt;interrupt_in_urb
)paren
suffix:semicolon
)brace
DECL|function|keyspan_pda_rx_unthrottle
r_static
r_void
id|keyspan_pda_rx_unthrottle
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
multiline_comment|/* just restart the receive interrupt URB */
id|dbg
c_func
(paren
l_string|&quot;keyspan_pda_rx_unthrottle port %d&quot;
comma
id|port-&gt;number
)paren
suffix:semicolon
id|port-&gt;interrupt_in_urb-&gt;dev
op_assign
id|port-&gt;serial-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
id|port-&gt;interrupt_in_urb
)paren
)paren
id|dbg
c_func
(paren
l_string|&quot; usb_submit_urb(read urb) failed&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|keyspan_pda_setbaud
r_static
r_int
id|keyspan_pda_setbaud
(paren
r_struct
id|usb_serial
op_star
id|serial
comma
r_int
id|baud
)paren
(brace
r_int
id|rc
suffix:semicolon
r_int
id|bindex
suffix:semicolon
r_switch
c_cond
(paren
id|baud
)paren
(brace
r_case
l_int|110
suffix:colon
id|bindex
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|300
suffix:colon
id|bindex
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1200
suffix:colon
id|bindex
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2400
suffix:colon
id|bindex
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4800
suffix:colon
id|bindex
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9600
suffix:colon
id|bindex
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|19200
suffix:colon
id|bindex
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|38400
suffix:colon
id|bindex
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|57600
suffix:colon
id|bindex
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|115200
suffix:colon
id|bindex
op_assign
l_int|9
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* rather than figure out how to sleep while waiting for this&n;&t;   to complete, I just use the &quot;legacy&quot; API. */
id|rc
op_assign
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
l_int|0
comma
multiline_comment|/* set baud */
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_INTERFACE
op_or
id|USB_DIR_OUT
comma
multiline_comment|/* type */
id|bindex
comma
multiline_comment|/* value */
l_int|0
comma
multiline_comment|/* index */
l_int|NULL
comma
multiline_comment|/* &amp;data */
l_int|0
comma
multiline_comment|/* size */
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
multiline_comment|/* timeout */
r_return
id|rc
suffix:semicolon
)brace
DECL|function|keyspan_pda_break_ctl
r_static
r_void
id|keyspan_pda_break_ctl
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_int
id|break_state
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_int
id|value
suffix:semicolon
r_if
c_cond
(paren
id|break_state
op_eq
op_minus
l_int|1
)paren
id|value
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* start break */
r_else
id|value
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear break */
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
l_int|4
comma
multiline_comment|/* set break */
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_INTERFACE
op_or
id|USB_DIR_OUT
comma
id|value
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
multiline_comment|/* there is something funky about this.. the TCSBRK that &squot;cu&squot; performs&n;&t;   ought to translate into a break_ctl(-1),break_ctl(0) pair HZ/4&n;&t;   seconds apart, but it feels like the break sent isn&squot;t as long as it&n;&t;   is on /dev/ttyS0 */
)brace
DECL|function|keyspan_pda_set_termios
r_static
r_void
id|keyspan_pda_set_termios
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_int
r_int
id|cflag
op_assign
id|port-&gt;tty-&gt;termios-&gt;c_cflag
suffix:semicolon
multiline_comment|/* cflag specifies lots of stuff: number of stop bits, parity, number&n;&t;   of data bits, baud. What can the device actually handle?:&n;&t;   CSTOPB (1 stop bit or 2)&n;&t;   PARENB (parity)&n;&t;   CSIZE (5bit .. 8bit)&n;&t;   There is minimal hw support for parity (a PSW bit seems to hold the&n;&t;   parity of whatever is in the accumulator). The UART either deals&n;&t;   with 10 bits (start, 8 data, stop) or 11 bits (start, 8 data,&n;&t;   1 special, stop). So, with firmware changes, we could do:&n;&t;   8N1: 10 bit&n;&t;   8N2: 11 bit, extra bit always (mark?)&n;&t;   8[EOMS]1: 11 bit, extra bit is parity&n;&t;   7[EOMS]1: 10 bit, b0/b7 is parity&n;&t;   7[EOMS]2: 11 bit, b0/b7 is parity, extra bit always (mark?)&n;&n;&t;   HW flow control is dictated by the tty-&gt;termios-&gt;c_cflags &amp; CRTSCTS&n;&t;   bit.&n;&n;&t;   For now, just do baud. */
r_switch
c_cond
(paren
id|cflag
op_amp
id|CBAUD
)paren
(brace
multiline_comment|/* we could support more values here, just need to calculate&n;&t;&t;   the necessary divisors in the firmware. &lt;asm/termbits.h&gt;&n;&t;&t;   has the Bnnn constants. */
r_case
id|B110
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|110
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B300
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|300
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B1200
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|1200
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B2400
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|2400
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B4800
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|4800
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B9600
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|9600
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B19200
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|19200
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B38400
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|38400
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B57600
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|57600
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B115200
suffix:colon
id|keyspan_pda_setbaud
c_func
(paren
id|serial
comma
l_int|115200
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;can&squot;t handle requested baud rate&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* modem control pins: DTR and RTS are outputs and can be controlled.&n;   DCD, RI, DSR, CTS are inputs and can be read. All outputs can also be&n;   read. The byte passed is: DTR(b7) DCD RI DSR CTS RTS(b2) unused unused */
DECL|function|keyspan_pda_get_modem_info
r_static
r_int
id|keyspan_pda_get_modem_info
c_func
(paren
r_struct
id|usb_serial
op_star
id|serial
comma
r_int
r_char
op_star
id|value
)paren
(brace
r_int
id|rc
suffix:semicolon
r_int
r_char
id|data
suffix:semicolon
id|rc
op_assign
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
l_int|3
comma
multiline_comment|/* get pins */
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_INTERFACE
op_or
id|USB_DIR_IN
comma
l_int|0
comma
l_int|0
comma
op_amp
id|data
comma
l_int|1
comma
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OG
l_int|0
)paren
op_star
id|value
op_assign
id|data
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|keyspan_pda_set_modem_info
r_static
r_int
id|keyspan_pda_set_modem_info
c_func
(paren
r_struct
id|usb_serial
op_star
id|serial
comma
r_int
r_char
id|value
)paren
(brace
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
l_int|3
comma
multiline_comment|/* set pins */
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_INTERFACE
op_or
id|USB_DIR_OUT
comma
id|value
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|keyspan_pda_ioctl
r_static
r_int
id|keyspan_pda_ioctl
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
r_int
id|value
suffix:semicolon
r_int
r_char
id|status
comma
id|mask
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMGET
suffix:colon
multiline_comment|/* get modem pins state */
id|rc
op_assign
id|keyspan_pda_get_modem_info
c_func
(paren
id|serial
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
id|value
op_assign
(paren
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
ques
c_cond
id|TIOCM_DTR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|6
)paren
)paren
ques
c_cond
id|TIOCM_CAR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
ques
c_cond
id|TIOCM_RNG
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|4
)paren
)paren
ques
c_cond
id|TIOCM_DSR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|3
)paren
)paren
ques
c_cond
id|TIOCM_CTS
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|2
)paren
)paren
ques
c_cond
id|TIOCM_RTS
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|arg
comma
op_amp
id|value
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCMSET
suffix:colon
multiline_comment|/* set a state as returned by MGET */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|value
comma
(paren
r_int
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|status
op_assign
(paren
(paren
id|value
op_amp
id|TIOCM_DTR
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|7
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|value
op_amp
id|TIOCM_CAR
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|6
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|value
op_amp
id|TIOCM_RNG
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|5
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|value
op_amp
id|TIOCM_DSR
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|4
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|value
op_amp
id|TIOCM_CTS
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|3
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|value
op_amp
id|TIOCM_RTS
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|2
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
id|rc
op_assign
id|keyspan_pda_set_modem_info
c_func
(paren
id|serial
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCMBIS
suffix:colon
multiline_comment|/* set bits in bitmask &lt;arg&gt; */
r_case
id|TIOCMBIC
suffix:colon
multiline_comment|/* clear bits from bitmask &lt;arg&gt; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|value
comma
(paren
r_int
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|rc
op_assign
id|keyspan_pda_get_modem_info
c_func
(paren
id|serial
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
id|mask
op_assign
(paren
(paren
id|value
op_amp
id|TIOCM_RTS
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|2
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|value
op_amp
id|TIOCM_DTR
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|7
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|TIOCMBIS
)paren
id|status
op_or_assign
id|mask
suffix:semicolon
r_else
id|status
op_and_assign
op_complement
id|mask
suffix:semicolon
id|rc
op_assign
id|keyspan_pda_set_modem_info
c_func
(paren
id|serial
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCMIWAIT
suffix:colon
multiline_comment|/* wait for any of the 4 modem inputs (DCD,RI,DSR,CTS)*/
multiline_comment|/* TODO */
r_case
id|TIOCGICOUNT
suffix:colon
multiline_comment|/* return count of modemline transitions */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* TODO */
)brace
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
DECL|function|keyspan_pda_write
r_static
r_int
id|keyspan_pda_write
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_int
id|request_unthrottle
op_assign
l_int|0
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|keyspan_pda_private
op_star
id|priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|priv
op_assign
(paren
r_struct
id|keyspan_pda_private
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
multiline_comment|/* guess how much room is left in the device&squot;s ring buffer, and if we&n;&t;   want to send more than that, check first, updating our notion of&n;&t;   what is left. If our write will result in no room left, ask the&n;&t;   device to give us an interrupt when the room available rises above&n;&t;   a threshold, and hold off all writers (eventually, those using&n;&t;   select() or poll() too) until we receive that unthrottle interrupt.&n;&t;   Block if we can&squot;t write anything at all, otherwise write as much as&n;&t;   we can. */
id|dbg
c_func
(paren
l_string|&quot;keyspan_pda_write(%d)&quot;
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot; write request of 0 bytes&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* we might block because of:&n;&t;   the TX urb is in-flight (wait until it completes)&n;&t;   the device is full (wait until it says there is room)&n;&t;*/
r_if
c_cond
(paren
id|port-&gt;write_urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
op_logical_or
id|priv-&gt;tx_throttled
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* At this point the URB is in our control, nobody else can submit it&n;&t;   again (the only sudden transition was the one from EINPROGRESS to&n;&t;   finished).  Also, the tx process is not throttled. So we are&n;&t;   ready to write. */
id|spin_lock_irqsave
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_assign
(paren
id|count
OG
id|port-&gt;bulk_out_size
)paren
ques
c_cond
id|port-&gt;bulk_out_size
suffix:colon
id|count
suffix:semicolon
multiline_comment|/* Check if we might overrun the Tx buffer.   If so, ask the&n;&t;   device how much room it really has.  This is done only on&n;&t;   scheduler time, since usb_control_msg() sleeps. */
r_if
c_cond
(paren
id|count
OG
id|priv-&gt;tx_room
op_logical_and
op_logical_neg
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
r_int
r_char
id|room
suffix:semicolon
id|rc
op_assign
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
l_int|6
comma
multiline_comment|/* write_room */
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_INTERFACE
op_or
id|USB_DIR_IN
comma
l_int|0
comma
multiline_comment|/* value: 0 means &quot;remaining room&quot; */
l_int|0
comma
multiline_comment|/* index */
op_amp
id|room
comma
l_int|1
comma
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot; roomquery failed&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
multiline_comment|/* failed */
)brace
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot; roomquery returned 0 bytes&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* device didn&squot;t return any data */
)brace
id|dbg
c_func
(paren
l_string|&quot; roomquery says %d&quot;
comma
id|room
)paren
suffix:semicolon
id|priv-&gt;tx_room
op_assign
id|room
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OG
id|priv-&gt;tx_room
)paren
(brace
multiline_comment|/* we&squot;re about to completely fill the Tx buffer, so&n;&t;&t;   we&squot;ll be throttled afterwards. */
id|count
op_assign
id|priv-&gt;tx_room
suffix:semicolon
id|request_unthrottle
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
multiline_comment|/* now transfer data */
r_if
c_cond
(paren
id|from_user
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|port-&gt;write_urb-&gt;transfer_buffer
comma
id|buf
comma
id|count
)paren
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_else
(brace
id|memcpy
(paren
id|port-&gt;write_urb-&gt;transfer_buffer
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* send the data out the bulk port */
id|port-&gt;write_urb-&gt;transfer_buffer_length
op_assign
id|count
suffix:semicolon
id|priv-&gt;tx_room
op_sub_assign
id|count
suffix:semicolon
id|port-&gt;write_urb-&gt;dev
op_assign
id|port-&gt;serial-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
id|port-&gt;write_urb
)paren
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot; usb_submit_urb(write bulk) failed&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* There wasn&squot;t any room left, so we are throttled until&n;&t;&t;   the buffer empties a bit */
id|request_unthrottle
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_unthrottle
)paren
(brace
id|priv-&gt;tx_throttled
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* block writers */
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|schedule_task
c_func
(paren
op_amp
id|priv-&gt;unthrottle_task
)paren
op_eq
l_int|0
)paren
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
id|count
)paren
suffix:semicolon
)brace
DECL|function|keyspan_pda_write_bulk_callback
r_static
r_void
id|keyspan_pda_write_bulk_callback
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
suffix:semicolon
r_struct
id|keyspan_pda_private
op_star
id|priv
suffix:semicolon
id|priv
op_assign
(paren
r_struct
id|keyspan_pda_private
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port_paranoia_check
(paren
id|port
comma
l_string|&quot;keyspan_pda_rx_interrupt&quot;
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_if
c_cond
(paren
id|serial_paranoia_check
(paren
id|serial
comma
l_string|&quot;keyspan_pda_rx_interrupt&quot;
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* queue up a wakeup at scheduler time */
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|schedule_task
c_func
(paren
op_amp
id|priv-&gt;wakeup_task
)paren
op_eq
l_int|0
)paren
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|function|keyspan_pda_write_room
r_static
r_int
id|keyspan_pda_write_room
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
r_struct
id|keyspan_pda_private
op_star
id|priv
suffix:semicolon
id|priv
op_assign
(paren
r_struct
id|keyspan_pda_private
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
multiline_comment|/* used by n_tty.c for processing of tabs and such. Giving it our&n;&t;   conservative guess is probably good enough, but needs testing by&n;&t;   running a console through the device. */
r_return
(paren
id|priv-&gt;tx_room
)paren
suffix:semicolon
)brace
DECL|function|keyspan_pda_chars_in_buffer
r_static
r_int
id|keyspan_pda_chars_in_buffer
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
r_struct
id|keyspan_pda_private
op_star
id|priv
suffix:semicolon
id|priv
op_assign
(paren
r_struct
id|keyspan_pda_private
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
multiline_comment|/* when throttled, return at least WAKEUP_CHARS to tell select() (via&n;&t;   n_tty.c:normal_poll() ) that we&squot;re not writeable. */
r_if
c_cond
(paren
id|port-&gt;write_urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
op_logical_or
id|priv-&gt;tx_throttled
)paren
(brace
r_return
l_int|256
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|keyspan_pda_open
r_static
r_int
id|keyspan_pda_open
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_int
r_char
id|room
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_struct
id|keyspan_pda_private
op_star
id|priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
op_increment
id|port-&gt;open_count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;active
)paren
(brace
id|port-&gt;active
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* find out how much room is in the Tx ring */
id|spin_unlock_irqrestore
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|rc
op_assign
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
l_int|6
comma
multiline_comment|/* write_room */
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_INTERFACE
op_or
id|USB_DIR_IN
comma
l_int|0
comma
multiline_comment|/* value */
l_int|0
comma
multiline_comment|/* index */
op_amp
id|room
comma
l_int|1
comma
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - roomquery failed&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - roomquery returned 0 bytes&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|priv
op_assign
(paren
r_struct
id|keyspan_pda_private
op_star
)paren
(paren
id|port
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
id|priv-&gt;tx_room
op_assign
id|room
suffix:semicolon
id|priv-&gt;tx_throttled
op_assign
id|room
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* the normal serial device seems to always turn on DTR and RTS here,&n;&t;&t;   so do the same */
id|spin_unlock_irqrestore
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;tty-&gt;termios-&gt;c_cflag
op_amp
id|CBAUD
)paren
id|keyspan_pda_set_modem_info
c_func
(paren
id|serial
comma
(paren
l_int|1
op_lshift
l_int|7
)paren
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
r_else
id|keyspan_pda_set_modem_info
c_func
(paren
id|serial
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*Start reading from the device*/
id|port-&gt;interrupt_in_urb-&gt;dev
op_assign
id|serial-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
id|port-&gt;interrupt_in_urb
)paren
)paren
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - usb_submit_urb(read int) failed&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|error
suffix:colon
op_decrement
id|port-&gt;open_count
suffix:semicolon
id|port-&gt;active
op_assign
l_int|0
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|keyspan_pda_close
r_static
r_void
id|keyspan_pda_close
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
op_decrement
id|port-&gt;open_count
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;open_count
op_le
l_int|0
)paren
(brace
multiline_comment|/* the normal serial device seems to always shut off DTR and RTS now */
id|spin_unlock_irqrestore
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;tty-&gt;termios-&gt;c_cflag
op_amp
id|HUPCL
)paren
id|keyspan_pda_set_modem_info
c_func
(paren
id|serial
comma
l_int|0
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* shutdown our bulk reads and writes */
id|usb_unlink_urb
(paren
id|port-&gt;write_urb
)paren
suffix:semicolon
id|usb_unlink_urb
(paren
id|port-&gt;interrupt_in_urb
)paren
suffix:semicolon
id|port-&gt;active
op_assign
l_int|0
suffix:semicolon
id|port-&gt;open_count
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* download the firmware to a &quot;fake&quot; device (pre-renumeration) */
DECL|function|keyspan_pda_fake_startup
r_static
r_int
id|keyspan_pda_fake_startup
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
r_int
id|response
suffix:semicolon
r_const
r_struct
id|ezusb_hex_record
op_star
id|record
suffix:semicolon
multiline_comment|/* download the firmware here ... */
id|response
op_assign
id|ezusb_set_reset
c_func
(paren
id|serial
comma
l_int|1
)paren
suffix:semicolon
id|record
op_assign
op_amp
id|keyspan_pda_firmware
(braket
l_int|0
)braket
suffix:semicolon
r_while
c_loop
(paren
id|record-&gt;address
op_ne
l_int|0xffff
)paren
(brace
id|response
op_assign
id|ezusb_writememory
c_func
(paren
id|serial
comma
id|record-&gt;address
comma
(paren
r_int
r_char
op_star
)paren
id|record-&gt;data
comma
id|record-&gt;data_size
comma
l_int|0xa0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|response
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;ezusb_writememory failed for Keyspan PDA &quot;
l_string|&quot;firmware (%d %04X %p %d)&quot;
comma
id|response
comma
id|record-&gt;address
comma
id|record-&gt;data
comma
id|record-&gt;data_size
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|record
op_increment
suffix:semicolon
)brace
multiline_comment|/* bring device out of reset. Renumeration will occur in a moment&n;&t;   and the new device will bind to the real driver */
id|response
op_assign
id|ezusb_set_reset
c_func
(paren
id|serial
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* we want this device to fail to have a driver assigned to it. */
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|keyspan_pda_startup
r_static
r_int
id|keyspan_pda_startup
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
r_struct
id|keyspan_pda_private
op_star
id|priv
suffix:semicolon
multiline_comment|/* allocate the private data structures for all ports. Well, for all&n;&t;   one ports. */
id|priv
op_assign
id|serial-&gt;port
(braket
l_int|0
)braket
dot
r_private
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|keyspan_pda_private
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* error */
id|init_waitqueue_head
c_func
(paren
op_amp
id|serial-&gt;port
(braket
l_int|0
)braket
dot
id|write_wait
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|priv-&gt;wakeup_task.list
)paren
suffix:semicolon
id|priv-&gt;wakeup_task.sync
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;wakeup_task.routine
op_assign
(paren
r_void
op_star
)paren
id|keyspan_pda_wakeup_write
suffix:semicolon
id|priv-&gt;wakeup_task.data
op_assign
(paren
r_void
op_star
)paren
(paren
op_amp
id|serial-&gt;port
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|priv-&gt;unthrottle_task.list
)paren
suffix:semicolon
id|priv-&gt;unthrottle_task.sync
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;unthrottle_task.routine
op_assign
(paren
r_void
op_star
)paren
id|keyspan_pda_request_unthrottle
suffix:semicolon
id|priv-&gt;unthrottle_task.data
op_assign
(paren
r_void
op_star
)paren
(paren
id|serial
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|keyspan_pda_shutdown
r_static
r_void
id|keyspan_pda_shutdown
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
id|dbg
(paren
id|__FUNCTION__
)paren
suffix:semicolon
r_while
c_loop
(paren
id|serial-&gt;port
(braket
l_int|0
)braket
dot
id|open_count
OG
l_int|0
)paren
(brace
id|keyspan_pda_close
(paren
op_amp
id|serial-&gt;port
(braket
l_int|0
)braket
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|serial-&gt;port
(braket
l_int|0
)braket
dot
r_private
)paren
suffix:semicolon
)brace
DECL|variable|keyspan_pda_fake_device
r_struct
id|usb_serial_device_type
id|keyspan_pda_fake_device
op_assign
(brace
id|name
suffix:colon
l_string|&quot;Keyspan PDA - (prerenumeration)&quot;
comma
id|id_table
suffix:colon
id|id_table_fake
comma
id|needs_interrupt_in
suffix:colon
id|DONT_CARE
comma
id|needs_bulk_in
suffix:colon
id|DONT_CARE
comma
id|needs_bulk_out
suffix:colon
id|DONT_CARE
comma
id|num_interrupt_in
suffix:colon
id|NUM_DONT_CARE
comma
id|num_bulk_in
suffix:colon
id|NUM_DONT_CARE
comma
id|num_bulk_out
suffix:colon
id|NUM_DONT_CARE
comma
id|num_ports
suffix:colon
l_int|1
comma
id|startup
suffix:colon
id|keyspan_pda_fake_startup
comma
)brace
suffix:semicolon
DECL|variable|keyspan_pda_device
r_struct
id|usb_serial_device_type
id|keyspan_pda_device
op_assign
(brace
id|name
suffix:colon
l_string|&quot;Keyspan PDA&quot;
comma
id|id_table
suffix:colon
id|id_table_std
comma
id|needs_interrupt_in
suffix:colon
id|MUST_HAVE
comma
id|needs_bulk_in
suffix:colon
id|DONT_CARE
comma
id|needs_bulk_out
suffix:colon
id|MUST_HAVE
comma
id|num_interrupt_in
suffix:colon
l_int|1
comma
id|num_bulk_in
suffix:colon
l_int|0
comma
id|num_bulk_out
suffix:colon
l_int|1
comma
id|num_ports
suffix:colon
l_int|1
comma
id|open
suffix:colon
id|keyspan_pda_open
comma
id|close
suffix:colon
id|keyspan_pda_close
comma
id|write
suffix:colon
id|keyspan_pda_write
comma
id|write_room
suffix:colon
id|keyspan_pda_write_room
comma
id|write_bulk_callback
suffix:colon
id|keyspan_pda_write_bulk_callback
comma
id|read_int_callback
suffix:colon
id|keyspan_pda_rx_interrupt
comma
id|chars_in_buffer
suffix:colon
id|keyspan_pda_chars_in_buffer
comma
id|throttle
suffix:colon
id|keyspan_pda_rx_throttle
comma
id|unthrottle
suffix:colon
id|keyspan_pda_rx_unthrottle
comma
id|ioctl
suffix:colon
id|keyspan_pda_ioctl
comma
id|set_termios
suffix:colon
id|keyspan_pda_set_termios
comma
id|break_ctl
suffix:colon
id|keyspan_pda_break_ctl
comma
id|startup
suffix:colon
id|keyspan_pda_startup
comma
id|shutdown
suffix:colon
id|keyspan_pda_shutdown
comma
)brace
suffix:semicolon
DECL|function|keyspan_pda_init
r_static
r_int
id|__init
id|keyspan_pda_init
(paren
r_void
)paren
(brace
id|usb_serial_register
(paren
op_amp
id|keyspan_pda_fake_device
)paren
suffix:semicolon
id|usb_serial_register
(paren
op_amp
id|keyspan_pda_device
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|keyspan_pda_exit
r_static
r_void
id|__exit
id|keyspan_pda_exit
(paren
r_void
)paren
(brace
id|usb_serial_deregister
(paren
op_amp
id|keyspan_pda_fake_device
)paren
suffix:semicolon
id|usb_serial_deregister
(paren
op_amp
id|keyspan_pda_device
)paren
suffix:semicolon
)brace
DECL|variable|keyspan_pda_init
id|module_init
c_func
(paren
id|keyspan_pda_init
)paren
suffix:semicolon
DECL|variable|keyspan_pda_exit
id|module_exit
c_func
(paren
id|keyspan_pda_exit
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Brian Warner &lt;warner@lothar.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;USB Keyspan PDA Converter driver&quot;
)paren
suffix:semicolon
eof
