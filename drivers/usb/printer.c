multiline_comment|/* Driver for USB Printers&n; * &n; * Copyright 1999 Michael Gee (michael@linuxspecific.com)&n; * Copyright 1999 Pavel Machek (pavel@suse.cz)&n; *&n; * Distribute under GPL version 2 or later.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/lp.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &quot;usb.h&quot;
DECL|macro|NAK_TIMEOUT
mdefine_line|#define NAK_TIMEOUT (HZ)&t;&t;&t;&t;/* stall wait for printer */
DECL|macro|MAX_RETRY_COUNT
mdefine_line|#define MAX_RETRY_COUNT ((60*60*HZ)/NAK_TIMEOUT)&t;/* should not take 1 minute a page! */
DECL|macro|BIG_BUF_SIZE
mdefine_line|#define BIG_BUF_SIZE&t;&t;&t;8192
DECL|macro|SUBCLASS_PRINTERS
mdefine_line|#define SUBCLASS_PRINTERS&t;&t;1
DECL|macro|PROTOCOL_UNIDIRECTIONAL
mdefine_line|#define PROTOCOL_UNIDIRECTIONAL&t;&t;1
DECL|macro|PROTOCOL_BIDIRECTIONAL
mdefine_line|#define PROTOCOL_BIDIRECTIONAL&t;&t;2
multiline_comment|/*&n; * USB Printer Requests&n; */
DECL|macro|USB_PRINTER_REQ_GET_DEVICE_ID
mdefine_line|#define USB_PRINTER_REQ_GET_DEVICE_ID&t;0
DECL|macro|USB_PRINTER_REQ_GET_PORT_STATUS
mdefine_line|#define USB_PRINTER_REQ_GET_PORT_STATUS&t;1
DECL|macro|USB_PRINTER_REQ_SOFT_RESET
mdefine_line|#define USB_PRINTER_REQ_SOFT_RESET&t;2
DECL|macro|MAX_PRINTERS
mdefine_line|#define MAX_PRINTERS&t;8
DECL|struct|pp_usb_data
r_struct
id|pp_usb_data
(brace
DECL|member|pusb_dev
r_struct
id|usb_device
op_star
id|pusb_dev
suffix:semicolon
DECL|member|isopen
id|__u8
id|isopen
suffix:semicolon
multiline_comment|/* True if open */
DECL|member|noinput
id|__u8
id|noinput
suffix:semicolon
multiline_comment|/* True if no input stream */
DECL|member|minor
id|__u8
id|minor
suffix:semicolon
multiline_comment|/* minor number of device */
DECL|member|status
id|__u8
id|status
suffix:semicolon
multiline_comment|/* last status from device */
DECL|member|maxin
DECL|member|maxout
r_int
id|maxin
comma
id|maxout
suffix:semicolon
multiline_comment|/* max transfer size in and out */
DECL|member|obuf
r_char
op_star
id|obuf
suffix:semicolon
multiline_comment|/* transfer buffer (out only) */
DECL|member|wait_q
id|wait_queue_head_t
id|wait_q
suffix:semicolon
multiline_comment|/* for timeouts */
DECL|member|last_error
r_int
r_int
id|last_error
suffix:semicolon
multiline_comment|/* save for checking */
DECL|member|bulk_in_ep
r_int
id|bulk_in_ep
suffix:semicolon
multiline_comment|/* Bulk IN endpoint */
DECL|member|bulk_out_ep
r_int
id|bulk_out_ep
suffix:semicolon
multiline_comment|/* Bulk OUT endpoint */
DECL|member|bulk_in_index
r_int
id|bulk_in_index
suffix:semicolon
multiline_comment|/* endpoint[bulk_in_index] */
DECL|member|bulk_out_index
r_int
id|bulk_out_index
suffix:semicolon
multiline_comment|/* endpoint[bulk_out_index] */
)brace
suffix:semicolon
DECL|variable|minor_data
r_static
r_struct
id|pp_usb_data
op_star
id|minor_data
(braket
id|MAX_PRINTERS
)braket
suffix:semicolon
DECL|macro|PPDATA
mdefine_line|#define PPDATA(x) ((struct pp_usb_data *)(x))
DECL|function|printer_read_status
r_static
r_int
r_char
id|printer_read_status
c_func
(paren
r_struct
id|pp_usb_data
op_star
id|p
)paren
(brace
id|__u8
id|status
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
op_assign
id|p-&gt;pusb_dev
suffix:semicolon
r_if
c_cond
(paren
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_PRINTER_REQ_GET_PORT_STATUS
comma
id|USB_TYPE_CLASS
op_or
id|USB_RT_INTERFACE
op_or
id|USB_DIR_IN
comma
l_int|0
comma
l_int|0
comma
op_amp
id|status
comma
r_sizeof
(paren
id|status
)paren
comma
id|HZ
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
DECL|function|printer_check_status
r_static
r_int
id|printer_check_status
c_func
(paren
r_struct
id|pp_usb_data
op_star
id|p
)paren
(brace
r_int
r_int
id|last
op_assign
id|p-&gt;last_error
suffix:semicolon
r_int
r_char
id|status
op_assign
id|printer_read_status
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|LP_PERRORP
)paren
multiline_comment|/* No error. */
id|last
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|LP_POUTPA
)paren
)paren
(brace
r_if
c_cond
(paren
id|last
op_ne
id|LP_POUTPA
)paren
(brace
id|last
op_assign
id|LP_POUTPA
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usblp%d out of paper (%x)&bslash;n&quot;
comma
id|p-&gt;minor
comma
id|status
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|LP_PSELECD
)paren
)paren
(brace
r_if
c_cond
(paren
id|last
op_ne
id|LP_PSELECD
)paren
(brace
id|last
op_assign
id|LP_PSELECD
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usblp%d off-line (%x)&bslash;n&quot;
comma
id|p-&gt;minor
comma
id|status
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|last
op_ne
id|LP_PERRORP
)paren
(brace
id|last
op_assign
id|LP_PERRORP
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usblp%d on fire (%x)&bslash;n&quot;
comma
id|p-&gt;minor
comma
id|status
)paren
suffix:semicolon
)brace
)brace
id|p-&gt;last_error
op_assign
id|last
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|printer_reset
r_static
r_void
id|printer_reset
c_func
(paren
r_struct
id|pp_usb_data
op_star
id|p
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
id|p-&gt;pusb_dev
suffix:semicolon
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_PRINTER_REQ_SOFT_RESET
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_OTHER
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
)paren
suffix:semicolon
)brace
DECL|function|open_printer
r_static
r_int
id|open_printer
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|pp_usb_data
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_ge
id|MAX_PRINTERS
op_logical_or
op_logical_neg
id|minor_data
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|p
op_assign
id|minor_data
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
suffix:semicolon
id|p-&gt;minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;isopen
op_increment
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;obuf
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|p-&gt;isopen
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|printer_check_status
c_func
(paren
id|p
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|p
suffix:semicolon
singleline_comment|//&t;printer_reset(p);
id|init_waitqueue_head
c_func
(paren
op_amp
id|p-&gt;wait_q
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|close_printer
r_static
r_int
id|close_printer
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|pp_usb_data
op_star
id|p
op_assign
id|file-&gt;private_data
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|p-&gt;obuf
)paren
suffix:semicolon
id|p-&gt;isopen
op_assign
l_int|0
suffix:semicolon
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* free the resources if the printer is no longer around */
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;pusb_dev
)paren
(brace
id|minor_data
(braket
id|p-&gt;minor
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_printer
r_static
id|ssize_t
id|write_printer
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|pp_usb_data
op_star
id|p
op_assign
id|file-&gt;private_data
suffix:semicolon
r_int
r_int
id|copy_size
suffix:semicolon
r_int
r_int
id|bytes_written
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|partial
suffix:semicolon
r_int
id|result
op_assign
id|USB_ST_NOERROR
suffix:semicolon
r_int
id|maxretry
suffix:semicolon
r_do
(brace
r_char
op_star
id|obuf
op_assign
id|p-&gt;obuf
suffix:semicolon
r_int
r_int
id|thistime
suffix:semicolon
id|thistime
op_assign
id|copy_size
op_assign
(paren
id|count
OG
id|p-&gt;maxout
)paren
ques
c_cond
id|p-&gt;maxout
suffix:colon
id|count
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|p-&gt;obuf
comma
id|buffer
comma
id|copy_size
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|maxretry
op_assign
id|MAX_RETRY_COUNT
suffix:semicolon
r_while
c_loop
(paren
id|thistime
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;pusb_dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_return
id|bytes_written
ques
c_cond
id|bytes_written
suffix:colon
op_minus
id|EINTR
suffix:semicolon
)brace
id|result
op_assign
id|usb_bulk_msg
c_func
(paren
id|p-&gt;pusb_dev
comma
id|usb_sndbulkpipe
c_func
(paren
id|p-&gt;pusb_dev
comma
id|p-&gt;bulk_out_ep
)paren
comma
id|obuf
comma
id|thistime
comma
op_amp
id|partial
comma
id|HZ
op_star
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partial
)paren
(brace
id|obuf
op_add_assign
id|partial
suffix:semicolon
id|thistime
op_sub_assign
id|partial
suffix:semicolon
id|maxretry
op_assign
id|MAX_RETRY_COUNT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_eq
id|USB_ST_TIMEOUT
)paren
(brace
multiline_comment|/* NAK - so hold for a while */
r_if
c_cond
(paren
op_logical_neg
id|maxretry
op_decrement
)paren
r_return
op_minus
id|ETIME
suffix:semicolon
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|p-&gt;wait_q
comma
id|NAK_TIMEOUT
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|result
op_logical_and
op_logical_neg
id|partial
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
multiline_comment|/* whoops - let&squot;s reset and fail the request */
singleline_comment|//&t;&t;&t;printk(&quot;Whoops - %x&bslash;n&quot;, result);
id|printer_reset
c_func
(paren
id|p
)paren
suffix:semicolon
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|p-&gt;wait_q
comma
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
multiline_comment|/* let reset do its stuff */
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|bytes_written
op_add_assign
id|copy_size
suffix:semicolon
id|count
op_sub_assign
id|copy_size
suffix:semicolon
id|buffer
op_add_assign
id|copy_size
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
suffix:semicolon
r_return
id|bytes_written
ques
c_cond
id|bytes_written
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|read_printer
r_static
id|ssize_t
id|read_printer
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|pp_usb_data
op_star
id|p
op_assign
id|file-&gt;private_data
suffix:semicolon
r_int
id|read_count
op_assign
l_int|0
suffix:semicolon
r_int
id|this_read
suffix:semicolon
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_int
id|partial
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;noinput
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_return
id|read_count
ques
c_cond
id|read_count
suffix:colon
op_minus
id|EINTR
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;pusb_dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|this_read
op_assign
(paren
id|count
OG
r_sizeof
(paren
id|buf
)paren
)paren
ques
c_cond
r_sizeof
(paren
id|buf
)paren
suffix:colon
id|count
suffix:semicolon
id|result
op_assign
id|usb_bulk_msg
c_func
(paren
id|p-&gt;pusb_dev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|p-&gt;pusb_dev
comma
id|p-&gt;bulk_in_ep
)paren
comma
id|buf
comma
id|this_read
comma
op_amp
id|partial
comma
id|HZ
op_star
l_int|20
)paren
suffix:semicolon
multiline_comment|/* unlike writes, we don&squot;t retry a NAK, just stop now */
r_if
c_cond
(paren
op_logical_neg
id|result
op_amp
id|partial
)paren
id|count
op_assign
id|this_read
op_assign
id|partial
suffix:semicolon
r_else
r_if
c_cond
(paren
id|result
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|this_read
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|buf
comma
id|this_read
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|count
op_sub_assign
id|this_read
suffix:semicolon
id|read_count
op_add_assign
id|this_read
suffix:semicolon
id|buffer
op_add_assign
id|this_read
suffix:semicolon
)brace
)brace
r_return
id|read_count
suffix:semicolon
)brace
DECL|function|printer_probe
r_static
r_void
op_star
id|printer_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
)paren
(brace
r_struct
id|usb_interface_descriptor
op_star
id|interface
suffix:semicolon
r_struct
id|pp_usb_data
op_star
id|pp
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME - this will not cope with combined printer/scanners&n;&t; */
r_if
c_cond
(paren
(paren
id|dev-&gt;descriptor.bDeviceClass
op_ne
id|USB_CLASS_PRINTER
op_logical_and
id|dev-&gt;descriptor.bDeviceClass
op_ne
l_int|0
)paren
op_logical_or
id|dev-&gt;descriptor.bNumConfigurations
op_ne
l_int|1
op_logical_or
id|dev-&gt;actconfig-&gt;bNumInterfaces
op_ne
l_int|1
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|interface
op_assign
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|ifnum
)braket
dot
id|altsetting
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Let&squot;s be paranoid (for the moment). */
r_if
c_cond
(paren
id|interface-&gt;bInterfaceClass
op_ne
id|USB_CLASS_PRINTER
op_logical_or
id|interface-&gt;bInterfaceSubClass
op_ne
id|SUBCLASS_PRINTERS
op_logical_or
(paren
id|interface-&gt;bInterfaceProtocol
op_ne
id|PROTOCOL_BIDIRECTIONAL
op_logical_and
id|interface-&gt;bInterfaceProtocol
op_ne
id|PROTOCOL_UNIDIRECTIONAL
)paren
op_logical_or
id|interface-&gt;bNumEndpoints
OG
l_int|2
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Does this (these) interface(s) support bulk transfers? */
r_if
c_cond
(paren
(paren
id|interface-&gt;endpoint
(braket
l_int|0
)braket
dot
id|bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_ne
id|USB_ENDPOINT_XFER_BULK
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|interface-&gt;bNumEndpoints
OG
l_int|1
)paren
op_logical_and
(paren
(paren
id|interface-&gt;endpoint
(braket
l_int|1
)braket
dot
id|bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_ne
id|USB_ENDPOINT_XFER_BULK
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Does this interface have at least one OUT endpoint&n;&t; *  that we can write to: endpoint index 0 or 1?&n;&t; */
r_if
c_cond
(paren
(paren
id|interface-&gt;endpoint
(braket
l_int|0
)braket
dot
id|bEndpointAddress
op_amp
id|USB_ENDPOINT_DIR_MASK
)paren
op_ne
id|USB_DIR_OUT
op_logical_and
(paren
id|interface-&gt;bNumEndpoints
OG
l_int|1
op_logical_and
(paren
id|interface-&gt;endpoint
(braket
l_int|1
)braket
dot
id|bEndpointAddress
op_amp
id|USB_ENDPOINT_DIR_MASK
)paren
op_ne
id|USB_DIR_OUT
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_PRINTERS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|minor_data
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ge
id|MAX_PRINTERS
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;No minor table space available for USB Printer&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;USB Printer found at address %d&bslash;n&quot;
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pp_usb_data
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;usb_printer: no memory!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|pp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|pp_usb_data
)paren
)paren
suffix:semicolon
id|minor_data
(braket
id|i
)braket
op_assign
id|PPDATA
c_func
(paren
id|pp
)paren
suffix:semicolon
id|pp-&gt;minor
op_assign
id|i
suffix:semicolon
id|pp-&gt;pusb_dev
op_assign
id|dev
suffix:semicolon
id|pp-&gt;maxout
op_assign
(paren
id|BIG_BUF_SIZE
OG
id|PAGE_SIZE
)paren
ques
c_cond
id|PAGE_SIZE
suffix:colon
id|BIG_BUF_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|interface-&gt;bInterfaceProtocol
op_ne
id|PROTOCOL_BIDIRECTIONAL
)paren
id|pp-&gt;noinput
op_assign
l_int|1
suffix:semicolon
id|pp-&gt;bulk_out_index
op_assign
(paren
(paren
id|interface-&gt;endpoint
(braket
l_int|0
)braket
dot
id|bEndpointAddress
op_amp
id|USB_ENDPOINT_DIR_MASK
)paren
op_eq
id|USB_DIR_OUT
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|pp-&gt;bulk_in_index
op_assign
id|pp-&gt;noinput
ques
c_cond
op_minus
l_int|1
suffix:colon
(paren
id|pp-&gt;bulk_out_index
op_eq
l_int|0
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|pp-&gt;bulk_in_ep
op_assign
id|pp-&gt;noinput
ques
c_cond
op_minus
l_int|1
suffix:colon
id|interface-&gt;endpoint
(braket
id|pp-&gt;bulk_in_index
)braket
dot
id|bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
id|pp-&gt;bulk_out_ep
op_assign
id|interface-&gt;endpoint
(braket
id|pp-&gt;bulk_out_index
)braket
dot
id|bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
r_if
c_cond
(paren
id|interface-&gt;bInterfaceProtocol
op_eq
id|PROTOCOL_BIDIRECTIONAL
)paren
(brace
id|pp-&gt;maxin
op_assign
id|interface-&gt;endpoint
(braket
id|pp-&gt;bulk_in_index
)braket
dot
id|wMaxPacketSize
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usblp%d Summary:&bslash;n&quot;
comma
id|pp-&gt;minor
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;index=%d, maxout=%d, noinput=%d, maxin=%d&bslash;n&quot;
comma
id|i
comma
id|pp-&gt;maxout
comma
id|pp-&gt;noinput
comma
id|pp-&gt;maxin
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;bulk_in_ix=%d, bulk_in_ep=%d, bulk_out_ix=%d, bulk_out_ep=%d&bslash;n&quot;
comma
id|pp-&gt;bulk_in_index
comma
id|pp-&gt;bulk_in_ep
comma
id|pp-&gt;bulk_out_index
comma
id|pp-&gt;bulk_out_ep
)paren
suffix:semicolon
macro_line|#if 1
(brace
id|__u8
id|status
suffix:semicolon
id|__u8
id|ieee_id
(braket
l_int|64
)braket
suffix:semicolon
multiline_comment|/* first 2 bytes are (big-endian) length */
r_int
id|length
op_assign
id|be16_to_cpup
c_func
(paren
(paren
id|__u16
op_star
)paren
id|ieee_id
)paren
suffix:semicolon
multiline_comment|/* Let&squot;s get the device id if possible. */
r_if
c_cond
(paren
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_PRINTER_REQ_GET_DEVICE_ID
comma
id|USB_TYPE_CLASS
op_or
id|USB_RT_INTERFACE
op_or
id|USB_DIR_IN
comma
l_int|0
comma
l_int|0
comma
id|ieee_id
comma
r_sizeof
(paren
id|ieee_id
)paren
op_minus
l_int|1
comma
id|HZ
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ieee_id
(braket
l_int|1
)braket
OL
r_sizeof
(paren
id|ieee_id
)paren
op_minus
l_int|1
)paren
id|ieee_id
(braket
id|ieee_id
(braket
l_int|1
)braket
op_plus
l_int|2
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_else
id|ieee_id
(braket
r_sizeof
(paren
id|ieee_id
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  usblp%d Device ID length=%d, string=%s&bslash;n&quot;
comma
id|pp-&gt;minor
comma
id|length
comma
op_amp
id|ieee_id
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  usblp%d: error reading IEEE-1284 Device ID&bslash;n&quot;
comma
id|pp-&gt;minor
)paren
suffix:semicolon
id|status
op_assign
id|printer_read_status
c_func
(paren
id|PPDATA
c_func
(paren
id|pp
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  usblp%d Probe Status is %x: %s,%s,%s&bslash;n&quot;
comma
id|pp-&gt;minor
comma
id|status
comma
(paren
id|status
op_amp
id|LP_PSELECD
)paren
ques
c_cond
l_string|&quot;Selected&quot;
suffix:colon
l_string|&quot;Not Selected&quot;
comma
(paren
id|status
op_amp
id|LP_POUTPA
)paren
ques
c_cond
l_string|&quot;No Paper&quot;
suffix:colon
l_string|&quot;Paper&quot;
comma
(paren
id|status
op_amp
id|LP_PERRORP
)paren
ques
c_cond
l_string|&quot;No Error&quot;
suffix:colon
l_string|&quot;Error&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|pp
suffix:semicolon
)brace
DECL|function|printer_disconnect
r_static
r_void
id|printer_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|pp_usb_data
op_star
id|pp
op_assign
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;isopen
)paren
(brace
multiline_comment|/* better let it finish - the release will do whats needed */
id|pp-&gt;pusb_dev
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
id|minor_data
(braket
id|pp-&gt;minor
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|pp
)paren
suffix:semicolon
)brace
DECL|variable|usb_printer_fops
r_static
r_struct
id|file_operations
id|usb_printer_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* seek */
id|read_printer
comma
id|write_printer
comma
l_int|NULL
comma
multiline_comment|/* readdir */
l_int|NULL
comma
multiline_comment|/* poll - out for the moment */
l_int|NULL
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|open_printer
comma
l_int|NULL
comma
multiline_comment|/* flush ? */
id|close_printer
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|printer_driver
r_static
r_struct
id|usb_driver
id|printer_driver
op_assign
(brace
l_string|&quot;printer&quot;
comma
id|printer_probe
comma
id|printer_disconnect
comma
(brace
l_int|NULL
comma
l_int|NULL
)brace
comma
op_amp
id|usb_printer_fops
comma
l_int|0
)brace
suffix:semicolon
DECL|function|usb_printer_init
r_int
id|usb_printer_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|usb_register
c_func
(paren
op_amp
id|printer_driver
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;USB Printer support registered.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|usb_printer_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|usb_deregister
c_func
(paren
op_amp
id|printer_driver
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
