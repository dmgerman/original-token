multiline_comment|/* -*- linux-c -*- */
multiline_comment|/* &n; * Driver for USB Scanners (linux-2.3.33)&n; *&n; * David E. Nelson (dnelson@jump.net)&n; * &n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as&n; * published by the Free Software Foundation; either version 2 of the&n; * License, or (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Based upon mouse.c (Brad Keryan) and printer.c (Michael Gee).&n; *&n; * History&n; *  0.1  8/31/1999&n; *&n; *    Developed/tested using linux-2.3.15 with minor ohci.c changes to&n; *    support short packes during bulk xfer mode.  Some testing was&n; *    done with ohci-hcd but the performace was low.  Very limited&n; *    testing was performed with uhci but I was unable to get it to&n; *    work.  Initial relase to the linux-usb development effort.&n; *&n; *  0.2  10/16/1999&n; *&n; *    FIXED:&n; *    - Device can&squot;t be opened unless a scanner is plugged into the USB.&n; *    - Finally settled on a reasonable value for the I/O buffer&squot;s.&n; *    - Cleaned up write_scanner()&n; *    - Disabled read/write stats&n; *    - A little more code cleanup&n; *&n; *  0.3  10/18/1999&n; *&n; *    FIXED:&n; *    - Device registration changed to reflect new device&n; *      allocation/registration for linux-2.3.22+.&n; *    - Adopted David Brownell&squot;s &lt;david-b@pacbell.net&gt; technique for &n; *      assigning bulk endpoints.&n; *    - Removed unnessesary #include&squot;s&n; *    - Scanner model now reported via syslog INFO after being detected &n; *      *and* configured.&n; *    - Added user specified verdor:product USB ID&squot;s which can be passed &n; *      as module parameters.&n; *&n; *  0.3.1&n; *    FIXED:&n; *    - Applied patches for linux-2.3.25.&n; *    - Error number reporting changed to reflect negative return codes.&n; *&n; *  0.3.2&n; *    FIXED:&n; *    - Applied patches for linux-2.3.26 to scanner_init().&n; *    - Debug read/write stats now report values as signed decimal.&n; *&n; *&n; *  0.3.3&n; *    FIXED:&n; *    - Updated the bulk_msg() calls to usb usb_bulk_msg().&n; *    - Added a small delay in the write_scanner() method to aid in&n; *      avoiding NULL data reads on HP scanners.  We&squot;ll see how this works.&n; *    - Return values from usb_bulk_msg() now ignore positive values for&n; *      use with the ohci driver.&n; *    - Added conditional debugging instead of commenting/uncommenting&n; *      all over the place.&n; *    - kfree()&squot;d the pointer after using usb_string() as documented in&n; *      linux-usb-api.txt.&n; *    - Added usb_set_configuration().  It got lost in version 0.3 -- ack!&n; *    - Added the HP 5200C USB Vendor/Product ID&squot;s&n; *&n; *  TODO&n; *    - Simultaneous multiple device attachment&n; *    - ioctl()&squot;s ?&n; *&n; *  Thanks to:&n; *    - All the folks on the linux-usb list who put up with me. :)  This &n; *      has been a great learning experience for me.&n; *    - To Linus Torvalds for this great OS.&n; *    - The GNU folks.&n; *    - The folks that forwarded Vendor:Product ID&squot;s to me.&n; *    - And anybody else who chimed in with reports and suggestions.&n; *&n; *  Performance:&n; *    System: Pentium 120, 80 MB RAM, OHCI, Linux 2.3.23, HP 4100C USB Scanner&n; *            300 dpi scan of the entire bed&n; *      24 Bit Color ~ 70 secs - 3.6 Mbit/sec&n; *       8 Bit Gray  ~ 17 secs - 4.2 Mbit/sec&n; * */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
DECL|macro|DEBUG
macro_line|#undef DEBUG&t;&t;/* Enable to print results of read/write_scanner() calls */
DECL|macro|RD_DATA_DUMP
macro_line|#undef RD_DATA_DUMP&t;/* Enable to dump data - limited to 24 bytes */
DECL|macro|WR_DATA_DUMP
macro_line|#undef WR_DATA_DUMP
macro_line|#include &quot;usb.h&quot;
DECL|macro|IBUF_SIZE
mdefine_line|#define IBUF_SIZE 32768
DECL|macro|OBUF_SIZE
mdefine_line|#define OBUF_SIZE 4096
DECL|struct|hpscan_usb_data
r_struct
id|hpscan_usb_data
(brace
DECL|member|hpscan_dev
r_struct
id|usb_device
op_star
id|hpscan_dev
suffix:semicolon
DECL|member|isopen
r_int
id|isopen
suffix:semicolon
multiline_comment|/* Not zero if the device is open */
DECL|member|present
r_int
id|present
suffix:semicolon
multiline_comment|/* Device is present on the bus */
DECL|member|obuf
DECL|member|ibuf
r_char
op_star
id|obuf
comma
op_star
id|ibuf
suffix:semicolon
multiline_comment|/* transfer buffers */
DECL|member|iep
DECL|member|oep
r_char
id|iep
comma
id|oep
suffix:semicolon
multiline_comment|/* I/O Endpoints */
)brace
suffix:semicolon
DECL|variable|hpscan
r_static
r_struct
id|hpscan_usb_data
id|hpscan
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;David E. Nelson, dnelson@jump.net, http://www.jump.net/~dnelson&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;USB Scanner Driver&quot;
)paren
suffix:semicolon
DECL|variable|vendor
DECL|variable|product
r_static
id|__u16
id|vendor
op_assign
l_int|0
comma
id|product
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|vendor
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|vendor
comma
l_string|&quot;User specified USB idVendor&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|product
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|product
comma
l_string|&quot;User specified USB idProduct&quot;
)paren
suffix:semicolon
r_static
r_int
DECL|function|open_scanner
id|open_scanner
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|hpscan_usb_data
op_star
id|hps
op_assign
op_amp
id|hpscan
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hps-&gt;present
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|hps-&gt;hpscan_dev
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hps-&gt;isopen
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|hps-&gt;isopen
op_assign
l_int|1
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|close_scanner
id|close_scanner
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|hpscan_usb_data
op_star
id|hps
op_assign
op_amp
id|hpscan
suffix:semicolon
id|hps-&gt;isopen
op_assign
l_int|0
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|write_scanner
id|write_scanner
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|hpscan_usb_data
op_star
id|hps
op_assign
op_amp
id|hpscan
suffix:semicolon
r_int
r_int
id|copy_size
suffix:semicolon
r_int
r_int
id|bytes_written
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|partial
suffix:semicolon
id|ssize_t
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|obuf
op_assign
id|hps-&gt;obuf
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|copy_size
op_assign
(paren
id|count
OG
id|OBUF_SIZE
)paren
ques
c_cond
id|OBUF_SIZE
suffix:colon
id|count
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|hps-&gt;obuf
comma
id|buffer
comma
id|copy_size
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|result
op_assign
id|usb_bulk_msg
c_func
(paren
id|hps-&gt;hpscan_dev
comma
id|usb_sndbulkpipe
c_func
(paren
id|hps-&gt;hpscan_dev
comma
id|hps-&gt;oep
)paren
comma
id|obuf
comma
id|copy_size
comma
op_amp
id|partial
comma
l_int|30
op_star
id|HZ
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;write stats: result:%d copy_size:%lu partial:%lu&quot;
comma
(paren
r_int
)paren
id|result
comma
id|copy_size
comma
id|partial
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|USB_ST_TIMEOUT
)paren
(brace
multiline_comment|/* NAK -- shouldn&squot;t happen */
id|warn
c_func
(paren
l_string|&quot;write_scanner: NAK recieved.&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ETIME
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* We should not get any I/O errors */
id|warn
c_func
(paren
l_string|&quot;write_scanner: funky result: %d. Please notify the maintainer.&quot;
comma
id|result
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef WR_DATA_DUMP
r_if
c_cond
(paren
id|partial
)paren
(brace
r_int
r_char
id|cnt
comma
id|cnt_max
suffix:semicolon
id|cnt_max
op_assign
(paren
id|partial
OG
l_int|24
)paren
ques
c_cond
l_int|24
suffix:colon
id|partial
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
id|__FILE__
l_string|&quot;: dump: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|cnt_max
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%X &quot;
comma
id|obuf
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|partial
op_ne
id|copy_size
)paren
(brace
multiline_comment|/* Unable to write complete amount */
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|partial
)paren
(brace
multiline_comment|/* Data written */
id|obuf
op_add_assign
id|partial
suffix:semicolon
id|count
op_sub_assign
id|partial
suffix:semicolon
id|bytes_written
op_add_assign
id|partial
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No data written */
id|ret
op_assign
l_int|0
suffix:semicolon
id|bytes_written
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
singleline_comment|//&t;mdelay(5);
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
id|bytes_written
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|read_scanner
id|read_scanner
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|hpscan_usb_data
op_star
id|hps
op_assign
op_amp
id|hpscan
suffix:semicolon
id|ssize_t
id|read_count
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|partial
suffix:semicolon
r_int
id|this_read
suffix:semicolon
r_int
id|result
suffix:semicolon
r_char
op_star
id|ibuf
op_assign
id|hps-&gt;ibuf
suffix:semicolon
id|read_count
op_assign
l_int|0
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|this_read
op_assign
(paren
id|count
OG
id|IBUF_SIZE
)paren
ques
c_cond
id|IBUF_SIZE
suffix:colon
id|count
suffix:semicolon
id|result
op_assign
id|usb_bulk_msg
c_func
(paren
id|hps-&gt;hpscan_dev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|hps-&gt;hpscan_dev
comma
id|hps-&gt;iep
)paren
comma
id|ibuf
comma
id|this_read
comma
op_amp
id|partial
comma
l_int|60
op_star
id|HZ
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;read stats: result:%d this_read:%u partial:%lu&quot;
comma
(paren
r_int
)paren
id|result
comma
id|this_read
comma
id|partial
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|USB_ST_TIMEOUT
)paren
(brace
multiline_comment|/* NAK -- shouldn&squot;t happen */
id|warn
c_func
(paren
l_string|&quot;read_scanner: NAK received&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ETIME
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|result
OL
l_int|0
)paren
op_logical_and
(paren
id|result
op_ne
id|USB_ST_DATAUNDERRUN
)paren
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;read_scanner: funky result: %d. Please notify the maintainer.&quot;
comma
(paren
r_int
)paren
id|result
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef RD_DATA_DUMP
r_if
c_cond
(paren
id|partial
)paren
(brace
r_int
r_char
id|cnt
comma
id|cnt_max
suffix:semicolon
id|cnt_max
op_assign
(paren
id|partial
OG
l_int|24
)paren
ques
c_cond
l_int|24
suffix:colon
id|partial
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
id|__FILE__
l_string|&quot;: dump: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|cnt_max
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%X &quot;
comma
id|ibuf
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|partial
)paren
(brace
multiline_comment|/* Data returned */
id|count
op_assign
id|this_read
op_assign
id|partial
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|read_count
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|this_read
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|ibuf
comma
id|this_read
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|count
op_sub_assign
id|this_read
suffix:semicolon
id|read_count
op_add_assign
id|this_read
suffix:semicolon
id|buffer
op_add_assign
id|this_read
suffix:semicolon
)brace
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
id|read_count
suffix:semicolon
)brace
r_static
r_void
op_star
DECL|function|probe_scanner
id|probe_scanner
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
)paren
(brace
r_struct
id|hpscan_usb_data
op_star
id|hps
op_assign
op_amp
id|hpscan
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|endpoint
suffix:semicolon
r_char
op_star
id|ident
suffix:semicolon
id|hps-&gt;present
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vendor
op_ne
l_int|0
op_logical_or
id|product
op_ne
l_int|0
)paren
id|info
c_func
(paren
l_string|&quot;USB Scanner Vendor:Product - %x:%x&bslash;n&quot;
comma
id|vendor
comma
id|product
)paren
suffix:semicolon
multiline_comment|/* There doesn&squot;t seem to be an imaging class defined in the USB&n; * Spec. (yet).  If there is, HP isn&squot;t following it and it doesn&squot;t&n; * look like anybody else is either.  Therefore, we have to test the&n; * Vendor and Product ID&squot;s to see what we have.  This makes this&n; * driver a high maintenance driver since it has to be updated with&n; * each release of a product.  Also, other scanners may be able to use&n; * this driver but again, their Vendor and Product ID&squot;s must be added.&n; *&n; * NOTE: Just because a product is supported here does not mean that&n; * applications exist that support the product.  It&squot;s in the hopes&n; * that this will allow developers a means to produce applications&n; * that will support USB products.&n; *&n; * Until we detect a device which is pleasing, we silently punt.&n; * */
r_if
c_cond
(paren
id|dev-&gt;descriptor.idVendor
op_ne
l_int|0x03f0
op_logical_and
multiline_comment|/* Hewlett Packard */
id|dev-&gt;descriptor.idVendor
op_ne
l_int|0x06bd
op_logical_and
multiline_comment|/* AGFA */
id|dev-&gt;descriptor.idVendor
op_ne
l_int|0x1606
op_logical_and
multiline_comment|/* UMAX */
id|dev-&gt;descriptor.idVendor
op_ne
id|vendor
)paren
(brace
multiline_comment|/* User specified */
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;descriptor.idProduct
op_ne
l_int|0x0101
op_logical_and
multiline_comment|/* HP 4100C */
id|dev-&gt;descriptor.idProduct
op_ne
l_int|0x0102
op_logical_and
multiline_comment|/* HP 4200C &amp; PhotoSmart S20? */
id|dev-&gt;descriptor.idProduct
op_ne
l_int|0x0202
op_logical_and
multiline_comment|/* HP 5100C */
id|dev-&gt;descriptor.idProduct
op_ne
l_int|0x0401
op_logical_and
multiline_comment|/* HP 5200C */
id|dev-&gt;descriptor.idProduct
op_ne
l_int|0x0201
op_logical_and
multiline_comment|/* HP 6200C */
id|dev-&gt;descriptor.idProduct
op_ne
l_int|0x0601
op_logical_and
multiline_comment|/* HP 6300C */
id|dev-&gt;descriptor.idProduct
op_ne
l_int|0x0001
op_logical_and
multiline_comment|/* AGFA SnapScan 1212U */
id|dev-&gt;descriptor.idProduct
op_ne
l_int|0x0030
op_logical_and
multiline_comment|/* Umax 2000U */
id|dev-&gt;descriptor.idProduct
op_ne
id|product
)paren
(brace
multiline_comment|/* User specified */
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* After this point we can be a little noisy about what we are trying to&n; *  configure. */
r_if
c_cond
(paren
id|dev-&gt;descriptor.bNumConfigurations
op_ne
l_int|1
op_logical_or
id|dev-&gt;config
(braket
l_int|0
)braket
dot
id|bNumInterfaces
op_ne
l_int|1
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: only simple configurations supported&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|endpoint
op_assign
id|dev-&gt;config
(braket
l_int|0
)braket
dot
id|interface
(braket
l_int|0
)braket
dot
id|altsetting
(braket
l_int|0
)braket
dot
id|endpoint
suffix:semicolon
r_if
c_cond
(paren
id|endpoint
(braket
l_int|0
)braket
dot
id|bmAttributes
op_ne
id|USB_ENDPOINT_XFER_BULK
op_logical_or
id|endpoint
(braket
l_int|1
)braket
dot
id|bmAttributes
op_ne
id|USB_ENDPOINT_XFER_BULK
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: invalid bulk endpoints&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usb_set_configuration
c_func
(paren
id|dev
comma
id|dev-&gt;config
(braket
l_int|0
)braket
dot
id|bConfigurationValue
)paren
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: failed usb_set_configuration&quot;
)paren
suffix:semicolon
id|hps-&gt;hpscan_dev
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* By the time we get here, we should be dealing with a fairly simple&n; * device that supports at least two bulk endpoints on endpoints 1 and&n; * 2.&n; *&n; * We determine the bulk endpoints so that the read_*() and write_*()&n; * procedures can recv/send data to the correct endpoint.&n; * */
id|hps-&gt;iep
op_assign
id|hps-&gt;oep
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|endpoint
(braket
l_int|0
)braket
dot
id|bEndpointAddress
op_amp
l_int|0x80
)paren
op_eq
l_int|0x80
)paren
(brace
id|hps-&gt;iep
op_assign
id|endpoint
(braket
l_int|0
)braket
dot
id|bEndpointAddress
op_amp
l_int|0x7f
suffix:semicolon
)brace
r_else
(brace
id|hps-&gt;oep
op_assign
id|endpoint
(braket
l_int|0
)braket
dot
id|bEndpointAddress
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|endpoint
(braket
l_int|1
)braket
dot
id|bEndpointAddress
op_amp
l_int|0x80
)paren
op_eq
l_int|0x80
)paren
(brace
id|hps-&gt;iep
op_assign
id|endpoint
(braket
l_int|1
)braket
dot
id|bEndpointAddress
op_amp
l_int|0x7f
suffix:semicolon
)brace
r_else
(brace
id|hps-&gt;oep
op_assign
id|endpoint
(braket
l_int|1
)braket
dot
id|bEndpointAddress
suffix:semicolon
)brace
id|ident
op_assign
id|kmalloc
c_func
(paren
l_int|256
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ident
)paren
(brace
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iProduct
comma
id|ident
comma
l_int|256
)paren
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;USB Scanner (%s) found at address %d&quot;
comma
id|ident
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ident
)paren
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: using bulk endpoints - In: %x  Out: %x&quot;
comma
id|hps-&gt;iep
comma
id|hps-&gt;oep
)paren
suffix:semicolon
id|hps-&gt;present
op_assign
l_int|1
suffix:semicolon
id|hps-&gt;hpscan_dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hps-&gt;obuf
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|OBUF_SIZE
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hps-&gt;ibuf
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|IBUF_SIZE
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|hps
suffix:semicolon
)brace
r_static
r_void
DECL|function|disconnect_scanner
id|disconnect_scanner
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|hpscan_usb_data
op_star
id|hps
op_assign
(paren
r_struct
id|hpscan_usb_data
op_star
)paren
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|hps-&gt;isopen
)paren
(brace
multiline_comment|/* better let it finish - the release will do whats needed */
id|hps-&gt;hpscan_dev
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|hps-&gt;ibuf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hps-&gt;obuf
)paren
suffix:semicolon
id|hps-&gt;present
op_assign
l_int|0
suffix:semicolon
)brace
r_static
r_struct
DECL|variable|usb_scanner_fops
id|file_operations
id|usb_scanner_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* seek */
id|read_scanner
comma
id|write_scanner
comma
l_int|NULL
comma
multiline_comment|/* readdir */
l_int|NULL
comma
multiline_comment|/* poll */
l_int|NULL
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|open_scanner
comma
l_int|NULL
comma
multiline_comment|/* flush */
id|close_scanner
comma
l_int|NULL
comma
l_int|NULL
comma
multiline_comment|/* fasync */
)brace
suffix:semicolon
r_static
r_struct
DECL|variable|scanner_driver
id|usb_driver
id|scanner_driver
op_assign
(brace
l_string|&quot;usbscanner&quot;
comma
id|probe_scanner
comma
id|disconnect_scanner
comma
(brace
l_int|NULL
comma
l_int|NULL
)brace
comma
op_amp
id|usb_scanner_fops
comma
l_int|48
)brace
suffix:semicolon
r_int
DECL|function|usb_scanner_init
id|usb_scanner_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|usb_register
c_func
(paren
op_amp
id|scanner_driver
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;USB Scanner support registered.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|usb_scanner_cleanup
id|usb_scanner_cleanup
c_func
(paren
r_void
)paren
(brace
r_struct
id|hpscan_usb_data
op_star
id|hps
op_assign
op_amp
id|hpscan
suffix:semicolon
id|hps-&gt;present
op_assign
l_int|0
suffix:semicolon
id|usb_deregister
c_func
(paren
op_amp
id|scanner_driver
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|usb_scanner_init
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|usb_scanner_cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
