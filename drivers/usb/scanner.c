multiline_comment|/* -*- linux-c -*- */
multiline_comment|/* &n; * Driver for USB Scanners (linux-2.4.0test1-ac7)&n; *&n; * Copyright (C) 1999, 2000 David E. Nelson&n; *&n; * Portions may be copyright Brad Keryan and Michael Gee.&n; *&n; * David E. Nelson (dnelson@jump.net)&n; * &n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as&n; * published by the Free Software Foundation; either version 2 of the&n; * License, or (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Originally based upon mouse.c (Brad Keryan) and printer.c (Michael Gee).&n; *&n; * History&n; *&n; *  0.1  8/31/1999&n; *&n; *    Developed/tested using linux-2.3.15 with minor ohci.c changes to&n; *    support short packes during bulk xfer mode.  Some testing was&n; *    done with ohci-hcd but the performace was low.  Very limited&n; *    testing was performed with uhci but I was unable to get it to&n; *    work.  Initial relase to the linux-usb development effort.&n; *&n; *&n; *  0.2  10/16/1999&n; *&n; *    - Device can&squot;t be opened unless a scanner is plugged into the USB.&n; *    - Finally settled on a reasonable value for the I/O buffer&squot;s.&n; *    - Cleaned up write_scanner()&n; *    - Disabled read/write stats&n; *    - A little more code cleanup&n; *&n; *&n; *  0.3  10/18/1999&n; *&n; *    - Device registration changed to reflect new device&n; *      allocation/registration for linux-2.3.22+.&n; *    - Adopted David Brownell&squot;s &lt;david-b@pacbell.net&gt; technique for &n; *      assigning bulk endpoints.&n; *    - Removed unnessesary #include&squot;s&n; *    - Scanner model now reported via syslog INFO after being detected &n; *      *and* configured.&n; *    - Added user specified vendor:product USB ID&squot;s which can be passed &n; *      as module parameters.&n; *&n; *&n; *  0.3.1&n; *&n; *    - Applied patches for linux-2.3.25.&n; *    - Error number reporting changed to reflect negative return codes.&n; *&n; *&n; *  0.3.2&n; *&n; *    - Applied patches for linux-2.3.26 to scanner_init().&n; *    - Debug read/write stats now report values as signed decimal.&n; *&n; *&n; *  0.3.3&n; *&n; *    - Updated the bulk_msg() calls to usb usb_bulk_msg().&n; *    - Added a small delay in the write_scanner() method to aid in&n; *      avoiding NULL data reads on HP scanners.  We&squot;ll see how this works.&n; *    - Return values from usb_bulk_msg() now ignore positive values for&n; *      use with the ohci driver.&n; *    - Added conditional debugging instead of commenting/uncommenting&n; *      all over the place.&n; *    - kfree()&squot;d the pointer after using usb_string() as documented in&n; *      linux-usb-api.txt.&n; *    - Added usb_set_configuration().  It got lost in version 0.3 -- ack!&n; *    - Added the HP 5200C USB Vendor/Product ID&squot;s.&n; *&n; *&n; *  0.3.4  1/23/2000&n; *&n; *    - Added Greg K-H&squot;s &lt;greg@kroah.com&gt; patch for better handling of &n; *      Product/Vendor detection.&n; *    - The driver now autoconfigures its endpoints including interrupt&n; *      endpoints if one is detected.  The concept was originally based&n; *      upon David Brownell&squot;s method.&n; *    - Added some Seiko/Epson ID&squot;s. Thanks to Karl Heinz &n; *      Kremer &lt;khk@khk.net&gt;.&n; *    - Added some preliminary ioctl() calls for the PV8630 which is used&n; *      by the HP4200. The ioctl()&squot;s still have to be registered. Thanks &n; *      to Adrian Perez Jorge &lt;adrianpj@easynews.com&gt;.&n; *    - Moved/migrated stuff to scanner.h&n; *    - Removed the usb_set_configuration() since this is handled by&n; *      the usb_new_device() routine in usb.c.&n; *    - Added the HP 3300C.  Thanks to Bruce Tenison.&n; *    - Changed user specified vendor/product id so that root hub doesn&squot;t&n; *      get falsely attached to. Thanks to Greg K-H.&n; *    - Added some Mustek ID&squot;s. Thanks to Gernot Hoyler &n; *      &lt;Dr.Hoyler@t-online.de&gt;.&n; *    - Modified the usb_string() reporting.  See kfree() comment above.&n; *    - Added Umax Astra 2000U. Thanks to Doug Alcorn &lt;doug@lathi.net&gt;.&n; *    - Updated the printk()&squot;s to use the info/warn/dbg macros.&n; *    - Updated usb_bulk_msg() argument types to fix gcc warnings.&n; *&n; *&n; *  0.4  2/4/2000&n; *&n; *    - Removed usb_string() from probe_scanner since the core now does a&n; *      good job of reporting what was connnected.  &n; *    - Finally, simultaneous multiple device attachment!&n; *    - Fixed some potential memory freeing issues should memory allocation&n; *      fail in probe_scanner();&n; *    - Some fixes to disconnect_scanner().&n; *    - Added interrupt endpoint support.&n; *    - Added Agfa SnapScan Touch. Thanks to Jan Van den Bergh&n; *      &lt;jan.vandenbergh@cs.kuleuven.ac.be&gt;.&n; *    - Added Umax 1220U ID&squot;s. Thanks to Maciek Klimkowski&n; *      &lt;mac@nexus.carleton.ca&gt;.&n; *    - Fixed bug in write_scanner(). The buffer was not being properly&n; *      updated for writes larger than OBUF_SIZE. Thanks to Henrik &n; *      Johansson &lt;henrikjo@post.utfors.se&gt; for identifying it.&n; *    - Added Microtek X6 ID&squot;s. Thanks to Oliver Neukum&n; *      &lt;Oliver.Neukum@lrz.uni-muenchen.de&gt;.&n; *&n; * &n; *  0.4.1  2/15/2000&n; *  &n; *    - Fixed &squot;count&squot; bug in read_scanner(). Thanks to Henrik&n; *      Johansson &lt;henrikjo@post.utfors.se&gt; for identifying it.  Amazing&n; *      it has worked this long.&n; *    - Fixed &squot;&gt;=&squot; bug in both read/write_scanner methods.&n; *    - Cleaned up both read/write_scanner() methods so that they are &n; *      a little more readable.&n; *    - Added a lot of Microtek ID&squot;s.  Thanks to Adrian Perez Jorge.&n; *    - Adopted the __initcall().&n; *    - Added #include &lt;linux/init.h&gt; to scanner.h for __initcall().&n; *    - Added one liner in irq_scanner() to keep gcc from complaining &n; *      about an unused variable (data) if debugging was disabled&n; *      in scanner.c.&n; *    - Increased the timeout parameter in read_scanner() to 120 Secs.&n; *&n; *&n; *  0.4.2  3/23/2000&n; *&n; *    - Added Umax 1236U ID.  Thanks to Philipp Baer &lt;ph_baer@npw.net&gt;.&n; *    - Added Primax, ReadyScan, Visioneer, Colorado, and Genius ID&squot;s.&n; *      Thanks to Adrian Perez Jorge &lt;adrianpj@easynews.com&gt;.&n; *    - Fixed error number reported for non-existant devices.  Thanks to&n; *      Spyridon Papadimitriou &lt;Spyridon_Papadimitriou@gs91.sp.cs.cmu.edu&gt;.&n; *    - Added Acer Prisascan 620U ID&squot;s.  Thanks to Joao &lt;joey@knoware.nl&gt;.&n; *    - Replaced __initcall() with module_init()/module_exit(). Updates&n; *      from patch-2.3.48.&n; *    - Replaced file_operations structure with new syntax.  Updates&n; *      from patch-2.3.49.&n; *    - Changed #include &quot;usb.h&quot; to #include &lt;linux/usb.h&gt;&n; *    - Added #define SCN_IOCTL to exclude development areas &n; *      since 2.4.x is about to be released. This mainly affects the &n; *      ioctl() stuff.  See scanner.h for more details.&n; *    - Changed the return value for signal_pending() from -ERESTARTSYS to&n; *      -EINTR.&n; *&n; *&n; * 0.4.3  4/30/2000&n; *&n; *    - Added Umax Astra 2200 ID.  Thanks to Flynn Marquardt &n; *      &lt;flynn@isr.uni-stuttgart.de&gt;.&n; *    - Added iVina 1200U ID. Thanks to Dyson Lin &lt;dyson@avision.com.tw&gt;.&n; *    - Added access time update for the device file courtesy of Paul&n; *      Mackerras &lt;paulus@linuxcare.com&gt;.  This allows a user space daemon&n; *      to turn the lamp off for a Umax 1220U scanner after a prescribed&n; *      time.&n; *    - Fixed HP S20 ID&squot;s.  Thanks to Ruud Linders &lt;rlinders@xs4all.nl&gt;.&n; *    - Added Acer ScanPrisa 620U ID. Thanks to Oliver&n; *      Schwartz &lt;Oliver.Schwartz@gmx.de&gt; via sane-devel mail list.&n; *    - Fixed bug in read_scanner for copy_to_user() function.  The returned&n; *      value should be &squot;partial&squot; not &squot;this_read&squot;.&n; *    - Fixed bug in read_scanner. &squot;count&squot; should be decremented &n; *      by &squot;this_read&squot; and not by &squot;partial&squot;.  This resulted in twice as many&n; *      calls to read_scanner() for small amounts of data and possibly&n; *      unexpected returns of &squot;0&squot;.  Thanks to Karl Heinz &n; *      Kremer &lt;khk@khk.net&gt; and Alain Knaff &lt;Alain.Knaff@ltnb.lu&gt;&n; *      for discovering this.&n; *    - Integrated Randy Dunlap&squot;s &lt;randy.dunlap@intel.com&gt; patch for a&n; *      scanner lookup/ident table. Thanks Randy.&n; *    - Documentation updates.&n; *    - Added wait queues to read_scanner().&n; *&n; *&n; * 0.4.3.1&n; *&n; *    - Fixed HP S20 ID&squot;s...again..sigh.  Thanks to Ruud&n; *      Linders &lt;rlinders@xs4all.nl&gt;.&n; *&n; * 0.4.4&n; *    - Added addtional Mustek ID&squot;s (BearPaw 1200, 600 CU, 1200 USB,&n; *      and 1200 UB.  Thanks to Henning Meier-Geinitz &lt;henningmg@gmx.de&gt;.&n; *    - Added the Vuego Scan Brisa 340U ID&squot;s.  Apparently this scanner is&n; *      marketed by Acer Peripherals as a cheap 300 dpi model. Thanks to&n; *      David Gundersen &lt;gundersd@paradise.net.nz&gt;.&n; *    - Added the Epson Expression1600 ID&squot;s. Thanks to Karl Heinz&n; *      Kremer &lt;khk@khk.net&gt;.&n; *&n; *  TODO&n; *&n; *    - Performance&n; *    - Select/poll methods&n; *    - More testing&n; *    - Proper registry/assignment for LM9830 ioctl&squot;s&n; *&n; *&n; *  Thanks to:&n; *&n; *    - All the folks on the linux-usb list who put up with me. :)  This &n; *      has been a great learning experience for me.&n; *    - To Linus Torvalds for this great OS.&n; *    - The GNU folks.&n; *    - The folks that forwarded Vendor:Product ID&squot;s to me.&n; *    - Johannes Erdfelt for the loaning of a USB analyzer for tracking an&n; *      issue with HP-4100 and uhci.&n; *    - Adolfo Montero for his assistance.&n; *    - All the folks who chimed in with reports and suggestions.&n; *    - All the developers that are working on USB SANE backends or other&n; *      applications to use USB scanners.&n; *&n; *  Performance:&n; *&n; *    System: Pentium 120, 80 MB RAM, OHCI, Linux 2.3.23, HP 4100C USB Scanner&n; *            300 dpi scan of the entire bed&n; *      24 Bit Color ~ 70 secs - 3.6 Mbit/sec&n; *       8 Bit Gray  ~ 17 secs - 4.2 Mbit/sec&n; */
multiline_comment|/* &n; * Scanner definitions, macros, module info, &n; * debug/ioctl/data_dump enable, and other constants.&n; */
macro_line|#include &quot;scanner.h&quot;
multiline_comment|/* Table of scanners that may work with this driver */
DECL|variable|scanner_device_ids
r_static
r_struct
id|usb_device_id
id|scanner_device_ids
(braket
)braket
op_assign
(brace
multiline_comment|/* Acer */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x04a5
comma
l_int|0x2060
)paren
)brace
comma
multiline_comment|/* Prisa Acerscan 620U &amp; 640U (!)*/
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x04a5
comma
l_int|0x2040
)paren
)brace
comma
multiline_comment|/* Prisa AcerScan 620U (!) */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x04a5
comma
l_int|0x2022
)paren
)brace
comma
multiline_comment|/* Vuego Scan Brisa 340U */
multiline_comment|/* Agfa */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x06bd
comma
l_int|0x0001
)paren
)brace
comma
multiline_comment|/* SnapScan 1212U */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x06bd
comma
l_int|0x0002
)paren
)brace
comma
multiline_comment|/* SnapScan 1236U */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x06bd
comma
l_int|0x2061
)paren
)brace
comma
multiline_comment|/* Another SnapScan 1212U (?)*/
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x06bd
comma
l_int|0x0100
)paren
)brace
comma
multiline_comment|/* SnapScan Touch */
multiline_comment|/* Colorado -- See Primax/Colorado below */
multiline_comment|/* Epson -- See Seiko/Epson below */
multiline_comment|/* Genius */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0458
comma
l_int|0x2001
)paren
)brace
comma
multiline_comment|/* ColorPage-Vivid Pro */
multiline_comment|/* Hewlett Packard */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x03f0
comma
l_int|0x0205
)paren
)brace
comma
multiline_comment|/* 3300C */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x03f0
comma
l_int|0x0101
)paren
)brace
comma
multiline_comment|/* 4100C */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x03f0
comma
l_int|0x0105
)paren
)brace
comma
multiline_comment|/* 4200C */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x03f0
comma
l_int|0x0102
)paren
)brace
comma
multiline_comment|/* PhotoSmart S20 */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x03f0
comma
l_int|0x0401
)paren
)brace
comma
multiline_comment|/* 5200C */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x03f0
comma
l_int|0x0701
)paren
)brace
comma
multiline_comment|/* 5300C */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x03f0
comma
l_int|0x0201
)paren
)brace
comma
multiline_comment|/* 6200C */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x03f0
comma
l_int|0x0601
)paren
)brace
comma
multiline_comment|/* 6300C */
multiline_comment|/* iVina */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0638
comma
l_int|0x0268
)paren
)brace
comma
multiline_comment|/* 1200U */
multiline_comment|/* Microtek */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x05da
comma
l_int|0x0099
)paren
)brace
comma
multiline_comment|/* ScanMaker X6 - X6U */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x05da
comma
l_int|0x0094
)paren
)brace
comma
multiline_comment|/* Phantom 336CX - C3 */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x05da
comma
l_int|0x00a0
)paren
)brace
comma
multiline_comment|/* Phantom 336CX - C3 #2 */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x05da
comma
l_int|0x009a
)paren
)brace
comma
multiline_comment|/* Phantom C6 */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x05da
comma
l_int|0x00a3
)paren
)brace
comma
multiline_comment|/* ScanMaker V6USL */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x05da
comma
l_int|0x80a3
)paren
)brace
comma
multiline_comment|/* ScanMaker V6USL #2 */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x05da
comma
l_int|0x80ac
)paren
)brace
comma
multiline_comment|/* ScanMaker V6UL - SpicyU */
multiline_comment|/* Mustek */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x055f
comma
l_int|0x0001
)paren
)brace
comma
multiline_comment|/* 1200 CU */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0400
comma
l_int|0x1000
)paren
)brace
comma
multiline_comment|/* BearPaw 1200 */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x055f
comma
l_int|0x0002
)paren
)brace
comma
multiline_comment|/* 600 CU */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x055f
comma
l_int|0x0003
)paren
)brace
comma
multiline_comment|/* 1200 USB */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x055f
comma
l_int|0x0006
)paren
)brace
comma
multiline_comment|/* 1200 UB */
multiline_comment|/* Primax/Colorado */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0461
comma
l_int|0x0300
)paren
)brace
comma
multiline_comment|/* G2-300 #1 */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0461
comma
l_int|0x0380
)paren
)brace
comma
multiline_comment|/* G2-600 #1 */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0461
comma
l_int|0x0301
)paren
)brace
comma
multiline_comment|/* G2E-300 #1 */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0461
comma
l_int|0x0381
)paren
)brace
comma
multiline_comment|/* ReadyScan 636i */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0461
comma
l_int|0x0302
)paren
)brace
comma
multiline_comment|/* G2-300 #2 */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0461
comma
l_int|0x0382
)paren
)brace
comma
multiline_comment|/* G2-600 #2 */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0461
comma
l_int|0x0303
)paren
)brace
comma
multiline_comment|/* G2E-300 #2 */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0461
comma
l_int|0x0383
)paren
)brace
comma
multiline_comment|/* G2E-600 */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0461
comma
l_int|0x0340
)paren
)brace
comma
multiline_comment|/* Colorado USB 9600 */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0461
comma
l_int|0x0360
)paren
)brace
comma
multiline_comment|/* Colorado USB 19200 */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0461
comma
l_int|0x0341
)paren
)brace
comma
multiline_comment|/* Colorado 600u */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0461
comma
l_int|0x0361
)paren
)brace
comma
multiline_comment|/* Colorado 1200u */
multiline_comment|/* Seiko/Epson Corp. */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x04b8
comma
l_int|0x0101
)paren
)brace
comma
multiline_comment|/* Perfection 636U and 636Photo */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x04b8
comma
l_int|0x0103
)paren
)brace
comma
multiline_comment|/* Perfection 610 */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x04b8
comma
l_int|0x0104
)paren
)brace
comma
multiline_comment|/* Perfection 1200U and 1200Photo*/
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x04b8
comma
l_int|0x0106
)paren
)brace
comma
multiline_comment|/* Stylus Scan 2500 */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x04b8
comma
l_int|0x0107
)paren
)brace
comma
multiline_comment|/* Expression 1600 */
multiline_comment|/* Umax */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x1606
comma
l_int|0x0010
)paren
)brace
comma
multiline_comment|/* Astra 1220U */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x1606
comma
l_int|0x0030
)paren
)brace
comma
multiline_comment|/* Astra 2000U */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x1606
comma
l_int|0x0230
)paren
)brace
comma
multiline_comment|/* Astra 2200U */
multiline_comment|/* Visioneer */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x04a7
comma
l_int|0x0221
)paren
)brace
comma
multiline_comment|/* OneTouch 5300 USB */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x04a7
comma
l_int|0x0211
)paren
)brace
comma
multiline_comment|/* OneTouch 7600 USB */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x04a7
comma
l_int|0x0231
)paren
)brace
comma
multiline_comment|/* 6100 USB */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x04a7
comma
l_int|0x0311
)paren
)brace
comma
multiline_comment|/* 6200 EPP/USB */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x04a7
comma
l_int|0x0321
)paren
)brace
comma
multiline_comment|/* OneTouch 8100 EPP/USB */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x04a7
comma
l_int|0x0331
)paren
)brace
comma
multiline_comment|/* OneTouch 8600 EPP/USB */
(brace
)brace
multiline_comment|/* Terminating entry */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|usb
comma
id|scanner_device_ids
)paren
suffix:semicolon
r_static
r_void
DECL|function|irq_scanner
id|irq_scanner
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
multiline_comment|/*&n; * For the meantime, this is just a placeholder until I figure out what&n; * all I want to do with it -- or somebody else for that matter.&n; */
r_struct
id|scn_usb_data
op_star
id|scn
op_assign
id|urb-&gt;context
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
op_amp
id|scn-&gt;button
suffix:semicolon
id|data
op_add_assign
l_int|0
suffix:semicolon
multiline_comment|/* Keep gcc from complaining about unused var */
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
r_return
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;irq_scanner(%d): data:%x&quot;
comma
id|scn-&gt;scn_minor
comma
op_star
id|data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|open_scanner
id|open_scanner
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|scn_usb_data
op_star
id|scn
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
id|kdev_t
id|scn_minor
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|scn_minor
op_assign
id|USB_SCN_MINOR
c_func
(paren
id|inode
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;open_scanner: scn_minor:%d&quot;
comma
id|scn_minor
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_scn_table
(braket
id|scn_minor
)braket
)paren
(brace
id|err
c_func
(paren
l_string|&quot;open_scanner(%d): Unable to access minor data&quot;
comma
id|scn_minor
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out_error
suffix:semicolon
)brace
id|scn
op_assign
id|p_scn_table
(braket
id|scn_minor
)braket
suffix:semicolon
id|dev
op_assign
id|scn-&gt;scn_dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|err
c_func
(paren
l_string|&quot;open_scanner(%d): Scanner device not present&quot;
comma
id|scn_minor
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out_error
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|scn-&gt;present
)paren
(brace
id|err
c_func
(paren
l_string|&quot;open_scanner(%d): Scanner is not present&quot;
comma
id|scn_minor
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out_error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scn-&gt;isopen
)paren
(brace
id|err
c_func
(paren
l_string|&quot;open_scanner(%d): Scanner device is already open&quot;
comma
id|scn_minor
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out_error
suffix:semicolon
)brace
id|init_waitqueue_head
c_func
(paren
op_amp
id|scn-&gt;rd_wait_q
)paren
suffix:semicolon
id|scn-&gt;isopen
op_assign
l_int|1
suffix:semicolon
id|file-&gt;private_data
op_assign
id|scn
suffix:semicolon
multiline_comment|/* Used by the read and write metheds */
id|MOD_INC_USE_COUNT
suffix:semicolon
id|out_error
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_static
r_int
DECL|function|close_scanner
id|close_scanner
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|scn_usb_data
op_star
id|scn
suffix:semicolon
id|kdev_t
id|scn_minor
suffix:semicolon
id|scn_minor
op_assign
id|USB_SCN_MINOR
(paren
id|inode
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;close_scanner: scn_minor:%d&quot;
comma
id|scn_minor
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_scn_table
(braket
id|scn_minor
)braket
)paren
(brace
id|err
c_func
(paren
l_string|&quot;close_scanner(%d): invalid scn_minor&quot;
comma
id|scn_minor
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|scn
op_assign
id|p_scn_table
(braket
id|scn_minor
)braket
suffix:semicolon
id|scn-&gt;isopen
op_assign
l_int|0
suffix:semicolon
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|write_scanner
id|write_scanner
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|scn_usb_data
op_star
id|scn
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
id|ssize_t
id|bytes_written
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Overall count of bytes written */
id|ssize_t
id|ret
op_assign
l_int|0
suffix:semicolon
id|kdev_t
id|scn_minor
suffix:semicolon
r_int
id|this_write
suffix:semicolon
multiline_comment|/* Number of bytes to write */
r_int
id|partial
suffix:semicolon
multiline_comment|/* Number of bytes successfully written */
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|obuf
suffix:semicolon
id|scn
op_assign
id|file-&gt;private_data
suffix:semicolon
id|scn_minor
op_assign
id|scn-&gt;scn_minor
suffix:semicolon
id|obuf
op_assign
id|scn-&gt;obuf
suffix:semicolon
id|dev
op_assign
id|scn-&gt;scn_dev
suffix:semicolon
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_atime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|down
c_func
(paren
op_amp
(paren
id|scn-&gt;gen_lock
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
id|this_write
op_assign
(paren
id|count
op_ge
id|OBUF_SIZE
)paren
ques
c_cond
id|OBUF_SIZE
suffix:colon
id|count
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|scn-&gt;obuf
comma
id|buffer
comma
id|this_write
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|result
op_assign
id|usb_bulk_msg
c_func
(paren
id|dev
comma
id|usb_sndbulkpipe
c_func
(paren
id|dev
comma
id|scn-&gt;bulk_out_ep
)paren
comma
id|obuf
comma
id|this_write
comma
op_amp
id|partial
comma
l_int|60
op_star
id|HZ
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;write stats(%d): result:%d this_write:%d partial:%d&quot;
comma
id|scn_minor
comma
id|result
comma
id|this_write
comma
id|partial
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|USB_ST_TIMEOUT
)paren
(brace
multiline_comment|/* NAK -- shouldn&squot;t happen */
id|warn
c_func
(paren
l_string|&quot;write_scanner: NAK recieved.&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ETIME
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* We should not get any I/O errors */
id|warn
c_func
(paren
l_string|&quot;write_scanner(%d): funky result: %d. Please notify the maintainer.&quot;
comma
id|scn_minor
comma
id|result
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef WR_DATA_DUMP
r_if
c_cond
(paren
id|partial
)paren
(brace
r_int
r_char
id|cnt
comma
id|cnt_max
suffix:semicolon
id|cnt_max
op_assign
(paren
id|partial
OG
l_int|24
)paren
ques
c_cond
l_int|24
suffix:colon
id|partial
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;dump(%d): &quot;
comma
id|scn_minor
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|cnt_max
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%X &quot;
comma
id|obuf
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|partial
op_ne
id|this_write
)paren
(brace
multiline_comment|/* Unable to write all contents of obuf */
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|partial
)paren
(brace
multiline_comment|/* Data written */
id|buffer
op_add_assign
id|partial
suffix:semicolon
id|count
op_sub_assign
id|partial
suffix:semicolon
id|bytes_written
op_add_assign
id|partial
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No data written */
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
(paren
id|scn-&gt;gen_lock
)paren
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
multiline_comment|/* This seems to help with SANE queries */
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
id|bytes_written
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|read_scanner
id|read_scanner
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|scn_usb_data
op_star
id|scn
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
id|ssize_t
id|bytes_read
suffix:semicolon
multiline_comment|/* Overall count of bytes_read */
id|ssize_t
id|ret
suffix:semicolon
id|kdev_t
id|scn_minor
suffix:semicolon
r_int
id|partial
suffix:semicolon
multiline_comment|/* Number of bytes successfully read */
r_int
id|this_read
suffix:semicolon
multiline_comment|/* Max number of bytes to read */
r_int
id|result
suffix:semicolon
r_int
id|rd_expire
op_assign
id|RD_EXPIRE
suffix:semicolon
r_char
op_star
id|ibuf
suffix:semicolon
id|scn
op_assign
id|file-&gt;private_data
suffix:semicolon
id|scn_minor
op_assign
id|scn-&gt;scn_minor
suffix:semicolon
id|ibuf
op_assign
id|scn-&gt;ibuf
suffix:semicolon
id|dev
op_assign
id|scn-&gt;scn_dev
suffix:semicolon
id|bytes_read
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_atime
op_assign
id|CURRENT_TIME
suffix:semicolon
multiline_comment|/* Update the&n;                                                            atime of&n;                                                            the device&n;                                                            node */
id|down
c_func
(paren
op_amp
(paren
id|scn-&gt;gen_lock
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
id|this_read
op_assign
(paren
id|count
op_ge
id|IBUF_SIZE
)paren
ques
c_cond
id|IBUF_SIZE
suffix:colon
id|count
suffix:semicolon
id|result
op_assign
id|usb_bulk_msg
c_func
(paren
id|dev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|dev
comma
id|scn-&gt;bulk_in_ep
)paren
comma
id|ibuf
comma
id|this_read
comma
op_amp
id|partial
comma
id|RD_NAK_TIMEOUT
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;read stats(%d): result:%d this_read:%d partial:%d count:%d&quot;
comma
id|scn_minor
comma
id|result
comma
id|this_read
comma
id|partial
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&n; * Scanners are sometimes inheriently slow since they are mechanical&n; * in nature.  USB bulk reads tend to timeout while the scanner is&n; * positioning, resetting, warming up the lamp, etc if the timeout is&n; * set too low.  A very long timeout parameter for bulk reads was used&n; * to overcome this limitation, but this sometimes resulted in folks&n; * having to wait for the timeout to expire after pressing Ctrl-C from&n; * an application. The user was sometimes left with the impression&n; * that something had hung or crashed when in fact the USB read was&n; * just waiting on data.  So, the below code retains the same long&n; * timeout period, but splits it up into smaller parts so that&n; * Ctrl-C&squot;s are acted upon in a reasonable amount of time.&n; */
r_if
c_cond
(paren
id|result
op_eq
id|USB_ST_TIMEOUT
op_logical_and
op_logical_neg
id|partial
)paren
(brace
multiline_comment|/* Timeout&n;                                                               and no&n;                                                               data */
r_if
c_cond
(paren
op_decrement
id|rd_expire
op_le
l_int|0
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;read_scanner(%d): excessive NAK&squot;s received&quot;
comma
id|scn_minor
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ETIME
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|scn-&gt;rd_wait_q
comma
id|RD_NAK_TIMEOUT
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|result
OL
l_int|0
)paren
op_logical_and
(paren
id|result
op_ne
id|USB_ST_DATAUNDERRUN
)paren
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;read_scanner(%d): funky result:%d. Please notify the maintainer.&quot;
comma
id|scn_minor
comma
(paren
r_int
)paren
id|result
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef RD_DATA_DUMP
r_if
c_cond
(paren
id|partial
)paren
(brace
r_int
r_char
id|cnt
comma
id|cnt_max
suffix:semicolon
id|cnt_max
op_assign
(paren
id|partial
OG
l_int|24
)paren
ques
c_cond
l_int|24
suffix:colon
id|partial
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;dump(%d): &quot;
comma
id|scn_minor
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|cnt_max
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%X &quot;
comma
id|ibuf
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|partial
)paren
(brace
multiline_comment|/* Data returned */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|ibuf
comma
id|partial
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|count
op_sub_assign
id|this_read
suffix:semicolon
multiline_comment|/* Compensate for short reads */
id|bytes_read
op_add_assign
id|partial
suffix:semicolon
multiline_comment|/* Keep tally of what actually was read */
id|buffer
op_add_assign
id|partial
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
(paren
id|scn-&gt;gen_lock
)paren
)paren
suffix:semicolon
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
id|bytes_read
suffix:semicolon
)brace
r_static
r_void
op_star
DECL|function|probe_scanner
id|probe_scanner
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|scn_usb_data
op_star
id|scn
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|interface
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|endpoint
suffix:semicolon
r_int
id|ep_cnt
suffix:semicolon
r_int
id|ix
suffix:semicolon
id|kdev_t
id|scn_minor
suffix:semicolon
r_char
id|valid_device
op_assign
l_int|0
suffix:semicolon
r_char
id|have_bulk_in
comma
id|have_bulk_out
comma
id|have_intr
suffix:semicolon
r_if
c_cond
(paren
id|vendor
op_ne
op_minus
l_int|1
op_logical_and
id|product
op_ne
op_minus
l_int|1
)paren
(brace
id|info
c_func
(paren
l_string|&quot;probe_scanner: User specified USB scanner -- Vendor:Product - %x:%x&quot;
comma
id|vendor
comma
id|product
)paren
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: USB dev address:%p&quot;
comma
id|dev
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: ifnum:%u&quot;
comma
id|ifnum
)paren
suffix:semicolon
multiline_comment|/*&n; * 1. Check Vendor/Product&n; * 2. Determine/Assign Bulk Endpoints&n; * 3. Determine/Assign Intr Endpoint&n; */
multiline_comment|/*&n; * There doesn&squot;t seem to be an imaging class defined in the USB&n; * Spec. (yet).  If there is, HP isn&squot;t following it and it doesn&squot;t&n; * look like anybody else is either.  Therefore, we have to test the&n; * Vendor and Product ID&squot;s to see what we have.  Also, other scanners&n; * may be able to use this driver by specifying both vendor and&n; * product ID&squot;s as options to the scanner module in conf.modules.&n; *&n; * NOTE: Just because a product is supported here does not mean that&n; * applications exist that support the product.  It&squot;s in the hopes&n; * that this will allow developers a means to produce applications&n; * that will support USB products.&n; *&n; * Until we detect a device which is pleasing, we silently punt.&n; */
r_for
c_loop
(paren
id|ix
op_assign
l_int|0
suffix:semicolon
id|ix
OL
r_sizeof
(paren
id|scanner_device_ids
)paren
op_div
r_sizeof
(paren
r_struct
id|usb_device_id
)paren
suffix:semicolon
id|ix
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;descriptor.idVendor
op_eq
id|scanner_device_ids
(braket
id|ix
)braket
dot
id|idVendor
)paren
op_logical_and
(paren
id|dev-&gt;descriptor.idProduct
op_eq
id|scanner_device_ids
(braket
id|ix
)braket
dot
id|idProduct
)paren
)paren
(brace
id|valid_device
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dev-&gt;descriptor.idVendor
op_eq
id|vendor
op_logical_and
multiline_comment|/* User specified */
id|dev-&gt;descriptor.idProduct
op_eq
id|product
)paren
(brace
multiline_comment|/* User specified */
id|valid_device
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|valid_device
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* We didn&squot;t find anything pleasing */
multiline_comment|/*&n; * After this point we can be a little noisy about what we are trying to&n; *  configure.&n; */
r_if
c_cond
(paren
id|dev-&gt;descriptor.bNumConfigurations
op_ne
l_int|1
)paren
(brace
id|info
c_func
(paren
l_string|&quot;probe_scanner: Only one device configuration is supported.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;config
(braket
l_int|0
)braket
dot
id|bNumInterfaces
op_ne
l_int|1
)paren
(brace
id|info
c_func
(paren
l_string|&quot;probe_scanner: Only one device interface is supported.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|interface
op_assign
id|dev-&gt;config
(braket
l_int|0
)braket
dot
id|interface
(braket
id|ifnum
)braket
dot
id|altsetting
suffix:semicolon
id|endpoint
op_assign
id|interface
(braket
id|ifnum
)braket
dot
id|endpoint
suffix:semicolon
multiline_comment|/*&n; * Start checking for two bulk endpoints OR two bulk endpoints *and* one&n; * interrupt endpoint. If we have an interrupt endpoint go ahead and&n; * setup the handler. FIXME: This is a future enhancement...&n; */
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: Number of Endpoints:%d&quot;
comma
(paren
r_int
)paren
id|interface-&gt;bNumEndpoints
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|interface-&gt;bNumEndpoints
op_ne
l_int|2
)paren
op_logical_and
(paren
id|interface-&gt;bNumEndpoints
op_ne
l_int|3
)paren
)paren
(brace
id|info
c_func
(paren
l_string|&quot;probe_scanner: Only two or three endpoints supported.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|ep_cnt
op_assign
id|have_bulk_in
op_assign
id|have_bulk_out
op_assign
id|have_intr
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|ep_cnt
OL
id|interface-&gt;bNumEndpoints
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|have_bulk_in
op_logical_and
id|IS_EP_BULK_IN
c_func
(paren
id|endpoint
(braket
id|ep_cnt
)braket
)paren
)paren
(brace
id|ep_cnt
op_increment
suffix:semicolon
id|have_bulk_in
op_assign
id|ep_cnt
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: bulk_in_ep:%d&quot;
comma
id|have_bulk_in
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|have_bulk_out
op_logical_and
id|IS_EP_BULK_OUT
c_func
(paren
id|endpoint
(braket
id|ep_cnt
)braket
)paren
)paren
(brace
id|ep_cnt
op_increment
suffix:semicolon
id|have_bulk_out
op_assign
id|ep_cnt
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: bulk_out_ep:%d&quot;
comma
id|have_bulk_out
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|have_intr
op_logical_and
id|IS_EP_INTR
c_func
(paren
id|endpoint
(braket
id|ep_cnt
)braket
)paren
)paren
(brace
id|ep_cnt
op_increment
suffix:semicolon
id|have_intr
op_assign
id|ep_cnt
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: intr_ep:%d&quot;
comma
id|have_intr
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|info
c_func
(paren
l_string|&quot;probe_scanner: Undetected endpoint. Notify the maintainer.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Shouldn&squot;t ever get here unless we have something weird */
)brace
multiline_comment|/*&n; * Perform a quick check to make sure that everything worked as it&n; * should have.&n; */
r_switch
c_cond
(paren
id|interface-&gt;bNumEndpoints
)paren
(brace
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|have_bulk_in
op_logical_or
op_logical_neg
id|have_bulk_out
)paren
(brace
id|info
c_func
(paren
l_string|&quot;probe_scanner: Two bulk endpoints required.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|have_bulk_in
op_logical_or
op_logical_neg
id|have_bulk_out
op_logical_or
op_logical_neg
id|have_intr
)paren
(brace
id|info
c_func
(paren
l_string|&quot;probe_scanner: Two bulk endpoints and one interrupt endpoint required.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|info
c_func
(paren
l_string|&quot;probe_scanner: Endpoint determination failed.  Notify the maintainer.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Determine a minor number and initialize the structure associated&n; * with it.  The problem with this is that we are counting on the fact&n; * that the user will sequentially add device nodes for the scanner&n; * devices.  */
r_for
c_loop
(paren
id|scn_minor
op_assign
l_int|0
suffix:semicolon
id|scn_minor
OL
id|SCN_MAX_MNR
suffix:semicolon
id|scn_minor
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|p_scn_table
(braket
id|scn_minor
)braket
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Check to make sure that the last slot isn&squot;t already taken */
r_if
c_cond
(paren
id|p_scn_table
(braket
id|scn_minor
)braket
)paren
(brace
id|err
c_func
(paren
l_string|&quot;probe_scanner: No more minor devices remaining.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: Allocated minor:%d&quot;
comma
id|scn_minor
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|scn
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|scn_usb_data
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;probe_scanner: Out of memory.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
(paren
id|scn
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|scn_usb_data
)paren
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;probe_scanner(%d): Address of scn:%p&quot;
comma
id|scn_minor
comma
id|scn
)paren
suffix:semicolon
multiline_comment|/* Ok, if we detected an interrupt EP, setup a handler for it */
r_if
c_cond
(paren
id|have_intr
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;probe_scanner(%d): Configuring IRQ handler for intr EP:%d&quot;
comma
id|scn_minor
comma
id|have_intr
)paren
suffix:semicolon
id|FILL_INT_URB
c_func
(paren
op_amp
id|scn-&gt;scn_irq
comma
id|dev
comma
id|usb_rcvintpipe
c_func
(paren
id|dev
comma
id|have_intr
)paren
comma
op_amp
id|scn-&gt;button
comma
l_int|1
comma
id|irq_scanner
comma
id|scn
comma
singleline_comment|// endpoint[(int)have_intr].bInterval);
l_int|250
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
op_amp
id|scn-&gt;scn_irq
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;probe_scanner(%d): Unable to allocate INT URB.&quot;
comma
id|scn_minor
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|scn
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* Ok, now initialize all the relevant values */
r_if
c_cond
(paren
op_logical_neg
(paren
id|scn-&gt;obuf
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|OBUF_SIZE
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;probe_scanner(%d): Not enough memory for the output buffer.&quot;
comma
id|scn_minor
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|scn
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;probe_scanner(%d): obuf address:%p&quot;
comma
id|scn_minor
comma
id|scn-&gt;obuf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|scn-&gt;ibuf
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|IBUF_SIZE
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;probe_scanner(%d): Not enough memory for the input buffer.&quot;
comma
id|scn_minor
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|scn-&gt;obuf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|scn
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;probe_scanner(%d): ibuf address:%p&quot;
comma
id|scn_minor
comma
id|scn-&gt;ibuf
)paren
suffix:semicolon
id|scn-&gt;bulk_in_ep
op_assign
id|have_bulk_in
suffix:semicolon
id|scn-&gt;bulk_out_ep
op_assign
id|have_bulk_out
suffix:semicolon
id|scn-&gt;intr_ep
op_assign
id|have_intr
suffix:semicolon
id|scn-&gt;present
op_assign
l_int|1
suffix:semicolon
id|scn-&gt;scn_dev
op_assign
id|dev
suffix:semicolon
id|scn-&gt;scn_minor
op_assign
id|scn_minor
suffix:semicolon
id|scn-&gt;isopen
op_assign
l_int|0
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|scn-&gt;gen_lock
)paren
)paren
suffix:semicolon
r_return
id|p_scn_table
(braket
id|scn_minor
)braket
op_assign
id|scn
suffix:semicolon
)brace
r_static
r_void
DECL|function|disconnect_scanner
id|disconnect_scanner
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|scn_usb_data
op_star
id|scn
op_assign
(paren
r_struct
id|scn_usb_data
op_star
)paren
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|scn-&gt;intr_ep
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;disconnect_scanner(%d): Unlinking IRQ URB&quot;
comma
id|scn-&gt;scn_minor
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
op_amp
id|scn-&gt;scn_irq
)paren
suffix:semicolon
)brace
id|usb_driver_release_interface
c_func
(paren
op_amp
id|scanner_driver
comma
op_amp
id|scn-&gt;scn_dev-&gt;actconfig-&gt;interface
(braket
id|scn-&gt;ifnum
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|scn-&gt;ibuf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|scn-&gt;obuf
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;disconnect_scanner: De-allocating minor:%d&quot;
comma
id|scn-&gt;scn_minor
)paren
suffix:semicolon
id|p_scn_table
(braket
id|scn-&gt;scn_minor
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
(paren
id|scn
)paren
suffix:semicolon
)brace
macro_line|#ifdef SCN_IOCTL
r_static
r_int
DECL|function|ioctl_scanner
id|ioctl_scanner
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
r_int
id|result
suffix:semicolon
id|kdev_t
id|scn_minor
suffix:semicolon
id|scn_minor
op_assign
id|USB_SCN_MINOR
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_scn_table
(braket
id|scn_minor
)braket
)paren
(brace
id|err
c_func
(paren
l_string|&quot;ioctl_scanner(%d): invalid scn_minor&quot;
comma
id|scn_minor
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dev
op_assign
id|p_scn_table
(braket
id|scn_minor
)braket
op_member_access_from_pointer
id|scn_dev
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PV8630_IOCTL_INREQUEST
suffix:colon
(brace
r_struct
(brace
id|__u8
id|data
suffix:semicolon
id|__u8
id|request
suffix:semicolon
id|__u16
id|value
suffix:semicolon
id|__u16
id|index
suffix:semicolon
)brace
id|args
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|args
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|args
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|args.request
comma
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_DEVICE
op_or
id|USB_DIR_IN
comma
id|args.value
comma
id|args.index
comma
op_amp
id|args.data
comma
l_int|1
comma
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;ioctl_scanner(%d): inreq: args.data:%x args.value:%x args.index:%x args.request:%x&bslash;n&quot;
comma
id|scn_minor
comma
id|args.data
comma
id|args.value
comma
id|args.index
comma
id|args.request
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|args
comma
r_sizeof
(paren
id|args
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;ioctl_scanner(%d): inreq: result:%d&bslash;n&quot;
comma
id|scn_minor
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_case
id|PV8630_IOCTL_OUTREQUEST
suffix:colon
(brace
r_struct
(brace
id|__u8
id|request
suffix:semicolon
id|__u16
id|value
suffix:semicolon
id|__u16
id|index
suffix:semicolon
)brace
id|args
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|args
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|args
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;ioctl_scanner(%d): outreq: args.value:%x args.index:%x args.request:%x&bslash;n&quot;
comma
id|scn_minor
comma
id|args.value
comma
id|args.index
comma
id|args.request
)paren
suffix:semicolon
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|args.request
comma
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_DEVICE
op_or
id|USB_DIR_OUT
comma
id|args.value
comma
id|args.index
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;ioctl_scanner(%d): outreq: result:%d&bslash;n&quot;
comma
id|scn_minor
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* SCN_IOCTL */
r_static
r_struct
DECL|variable|usb_scanner_fops
id|file_operations
id|usb_scanner_fops
op_assign
(brace
id|read
suffix:colon
id|read_scanner
comma
id|write
suffix:colon
id|write_scanner
comma
macro_line|#ifdef SCN_IOCTL
id|ioctl
suffix:colon
id|ioctl_scanner
comma
macro_line|#endif /* SCN_IOCTL */
id|open
suffix:colon
id|open_scanner
comma
id|release
suffix:colon
id|close_scanner
comma
)brace
suffix:semicolon
r_static
r_struct
DECL|variable|scanner_driver
id|usb_driver
id|scanner_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;usbscanner&quot;
comma
id|probe
suffix:colon
id|probe_scanner
comma
id|disconnect
suffix:colon
id|disconnect_scanner
comma
id|fops
suffix:colon
op_amp
id|usb_scanner_fops
comma
id|minor
suffix:colon
id|SCN_BASE_MNR
comma
id|id_table
suffix:colon
l_int|NULL
comma
multiline_comment|/* This would be scanner_device_ids, but we&n;&t;&t;&t;&t; need to check every USB device, in case&n;&t;&t;&t;&t; we match a user defined vendor/product ID. */
)brace
suffix:semicolon
r_void
id|__exit
DECL|function|usb_scanner_exit
id|usb_scanner_exit
c_func
(paren
r_void
)paren
(brace
id|usb_deregister
c_func
(paren
op_amp
id|scanner_driver
)paren
suffix:semicolon
)brace
r_int
id|__init
DECL|function|usb_scanner_init
id|usb_scanner_init
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|usb_register
c_func
(paren
op_amp
id|scanner_driver
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;USB Scanner support registered.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|usb_scanner_init
id|module_init
c_func
(paren
id|usb_scanner_init
)paren
suffix:semicolon
DECL|variable|usb_scanner_exit
id|module_exit
c_func
(paren
id|usb_scanner_exit
)paren
suffix:semicolon
eof
