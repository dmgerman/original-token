multiline_comment|/*&n; * USB HID boot protocol mouse support based on MS BusMouse driver, psaux &n; * driver, and Linus&squot;s skeleton USB mouse driver. Fixed up a lot by Linus.&n; *&n; * Brad Keryan 4/3/1999&n; *&n; * version 0.20: Linus rewrote read_mouse() to do PS/2 and do it&n; * correctly. Events are added together, not queued, to keep the rodent sober.&n; *&n; * version 0.02: Hmm, the mouse seems drunk because I&squot;m queueing the events.&n; * This is wrong: when an application (like X or gpm) reads the mouse device,&n; * it wants to find out the mouse&squot;s current position, not its recent history.&n; * The button thing turned out to be UHCI not flipping data toggle, so half the&n; * packets were thrown out.&n; *&n; * version 0.01: Switched over to busmouse protocol, and changed the minor&n; * number to 32 (same as uusbd&squot;s hidbp driver). Buttons work more sanely now, &n; * but it still doesn&squot;t generate button events unless you move the mouse.&n; *&n; * version 0.0: Driver emulates a PS/2 mouse, stealing /dev/psaux (sorry, I &n; * know that&squot;s not very nice). Moving in the X and Y axes works. Buttons don&squot;t&n; * work right yet: X sees a lot of MotionNotify/ButtonPress/ButtonRelease &n; * combos when you hold down a button and drag the mouse around. Probably has &n; * some additional bugs on an SMP machine.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/spinlock.h&gt;
macro_line|#include &quot;usb.h&quot;
DECL|macro|USB_MOUSE_MINOR
mdefine_line|#define USB_MOUSE_MINOR 32
DECL|struct|mouse_state
r_struct
id|mouse_state
(brace
DECL|member|buttons
r_int
r_char
id|buttons
suffix:semicolon
multiline_comment|/* current button state */
DECL|member|dx
r_int
id|dx
suffix:semicolon
multiline_comment|/* dx, dy, dz are change since last read */
DECL|member|dy
r_int
id|dy
suffix:semicolon
DECL|member|dz
r_int
id|dz
suffix:semicolon
DECL|member|present
r_int
id|present
suffix:semicolon
multiline_comment|/* this mouse is plugged in */
DECL|member|active
r_int
id|active
suffix:semicolon
multiline_comment|/* someone is has this mouse&squot;s device open */
DECL|member|ready
r_int
id|ready
suffix:semicolon
multiline_comment|/* the mouse has changed state since the last read */
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
multiline_comment|/* for polling */
DECL|member|fasync
r_struct
id|fasync_struct
op_star
id|fasync
suffix:semicolon
multiline_comment|/* later, add a list here to support multiple mice */
multiline_comment|/* but we will also need a list of file pointers to identify it */
multiline_comment|/* FIXME: move these to a per-mouse structure */
DECL|member|dev
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* host controller this mouse is on */
DECL|member|irq_handle
r_void
op_star
id|irq_handle
suffix:semicolon
multiline_comment|/* host controller&squot;s IRQ transfer handle */
DECL|member|bEndpointAddress
id|__u8
id|bEndpointAddress
suffix:semicolon
multiline_comment|/* these are from the endpoint descriptor */
DECL|member|bInterval
id|__u8
id|bInterval
suffix:semicolon
multiline_comment|/* ...  used when calling usb_request_irq */
)brace
suffix:semicolon
DECL|variable|static_mouse_state
r_static
r_struct
id|mouse_state
id|static_mouse_state
suffix:semicolon
DECL|variable|usb_mouse_lock
id|spinlock_t
id|usb_mouse_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|mouse_irq
r_static
r_int
id|mouse_irq
c_func
(paren
r_int
id|state
comma
r_void
op_star
id|__buffer
comma
r_int
id|len
comma
r_void
op_star
id|dev_id
)paren
(brace
r_int
r_char
op_star
id|data
op_assign
id|__buffer
suffix:semicolon
multiline_comment|/* finding the mouse is easy when there&squot;s only one */
r_struct
id|mouse_state
op_star
id|mouse
op_assign
op_amp
id|static_mouse_state
suffix:semicolon
multiline_comment|/* if a mouse moves with no one listening, do we care? no */
r_if
c_cond
(paren
op_logical_neg
id|mouse-&gt;active
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* if the USB mouse sends an interrupt, then something noteworthy&n;&t;   must have happened */
id|mouse-&gt;buttons
op_assign
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x07
suffix:semicolon
id|mouse-&gt;dx
op_add_assign
id|data
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* data[] is signed, so this works */
id|mouse-&gt;dy
op_sub_assign
id|data
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* y-axis is reversed */
id|mouse-&gt;dz
op_sub_assign
id|data
(braket
l_int|3
)braket
suffix:semicolon
id|mouse-&gt;ready
op_assign
l_int|1
suffix:semicolon
id|add_mouse_randomness
c_func
(paren
(paren
id|mouse-&gt;buttons
op_lshift
l_int|24
)paren
op_plus
(paren
id|mouse-&gt;dz
op_lshift
l_int|16
)paren
op_plus
(paren
id|mouse-&gt;dy
op_lshift
l_int|8
)paren
op_plus
id|mouse-&gt;dx
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|mouse-&gt;wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mouse-&gt;fasync
)paren
id|kill_fasync
c_func
(paren
id|mouse-&gt;fasync
comma
id|SIGIO
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|fasync_mouse
r_static
r_int
id|fasync_mouse
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|on
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|mouse_state
op_star
id|mouse
op_assign
op_amp
id|static_mouse_state
suffix:semicolon
id|retval
op_assign
id|fasync_helper
c_func
(paren
id|fd
comma
id|filp
comma
id|on
comma
op_amp
id|mouse-&gt;fasync
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_return
id|retval
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|release_mouse
r_static
r_int
id|release_mouse
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|mouse_state
op_star
id|mouse
op_assign
op_amp
id|static_mouse_state
suffix:semicolon
id|fasync_mouse
c_func
(paren
op_minus
l_int|1
comma
id|file
comma
l_int|0
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|mouse-&gt;active
op_eq
l_int|0
)paren
(brace
multiline_comment|/* stop polling the mouse while its not in use */
id|usb_release_irq
c_func
(paren
id|mouse-&gt;dev
comma
id|mouse-&gt;irq_handle
)paren
suffix:semicolon
multiline_comment|/* never keep a reference to a released IRQ! */
id|mouse-&gt;irq_handle
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|open_mouse
r_static
r_int
id|open_mouse
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|mouse_state
op_star
id|mouse
op_assign
op_amp
id|static_mouse_state
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mouse-&gt;present
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|mouse-&gt;active
op_increment
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* flush state */
id|mouse-&gt;buttons
op_assign
id|mouse-&gt;dx
op_assign
id|mouse-&gt;dy
op_assign
id|mouse-&gt;dz
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* prevent the driver from being unloaded while its in use */
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/* start the usb controller&squot;s polling of the mouse */
id|mouse-&gt;irq_handle
op_assign
id|usb_request_irq
c_func
(paren
id|mouse-&gt;dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|mouse-&gt;dev
comma
id|mouse-&gt;bEndpointAddress
)paren
comma
id|mouse_irq
comma
id|mouse-&gt;bInterval
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_mouse
r_static
id|ssize_t
id|write_mouse
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; * Look like a PS/2 mouse, please..&n; *&n; * The PS/2 protocol is fairly strange, but&n; * oh, well, it&squot;s at least common..&n; */
DECL|function|read_mouse
r_static
id|ssize_t
id|read_mouse
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|state
op_assign
l_int|0
suffix:semicolon
r_struct
id|mouse_state
op_star
id|mouse
op_assign
op_amp
id|static_mouse_state
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
id|mouse-&gt;ready
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
l_int|0
suffix:colon
(brace
multiline_comment|/* buttons and sign */
r_int
id|buttons
op_assign
id|mouse-&gt;buttons
suffix:semicolon
id|mouse-&gt;buttons
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mouse-&gt;dx
OL
l_int|0
)paren
id|buttons
op_or_assign
l_int|0x10
suffix:semicolon
r_if
c_cond
(paren
id|mouse-&gt;dy
OL
l_int|0
)paren
id|buttons
op_or_assign
l_int|0x20
suffix:semicolon
id|put_user
c_func
(paren
id|buttons
comma
id|buffer
)paren
suffix:semicolon
id|buffer
op_increment
suffix:semicolon
id|retval
op_increment
suffix:semicolon
id|state
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|count
)paren
r_break
suffix:semicolon
)brace
r_case
l_int|1
suffix:colon
(brace
multiline_comment|/* dx */
r_int
id|dx
op_assign
id|mouse-&gt;dx
suffix:semicolon
id|mouse-&gt;dx
op_assign
l_int|0
suffix:semicolon
id|put_user
c_func
(paren
id|dx
comma
id|buffer
)paren
suffix:semicolon
id|buffer
op_increment
suffix:semicolon
id|retval
op_increment
suffix:semicolon
id|state
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|count
)paren
r_break
suffix:semicolon
)brace
r_case
l_int|2
suffix:colon
(brace
multiline_comment|/* dy */
r_int
id|dy
op_assign
id|mouse-&gt;dy
suffix:semicolon
id|mouse-&gt;dy
op_assign
l_int|0
suffix:semicolon
id|put_user
c_func
(paren
id|dy
comma
id|buffer
)paren
suffix:semicolon
id|buffer
op_increment
suffix:semicolon
id|retval
op_increment
suffix:semicolon
id|state
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|count
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * SUBTLE:&n;&t;&t; *&n;&t;&t; * The only way to get here is to do a read() of&n;&t;&t; * more than 3 bytes: if you read a byte at a time&n;&t;&t; * you will just ever see states 0-2, for backwards&n;&t;&t; * compatibility.&n;&t;&t; *&n;&t;&t; * So you can think of this as a packet interface,&n;&t;&t; * where you have arbitrary-sized packets, and you&n;&t;&t; * only ever see the first three bytes when you read&n;&t;&t; * them in small chunks.&n;&t;&t; */
(brace
multiline_comment|/* fallthrough - dz */
r_int
id|dz
op_assign
id|mouse-&gt;dz
suffix:semicolon
id|mouse-&gt;dz
op_assign
l_int|0
suffix:semicolon
id|put_user
c_func
(paren
id|dz
comma
id|buffer
)paren
suffix:semicolon
id|buffer
op_increment
suffix:semicolon
id|retval
op_increment
suffix:semicolon
id|state
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|mouse_poll
r_static
r_int
r_int
id|mouse_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|mouse_state
op_star
id|mouse
op_assign
op_amp
id|static_mouse_state
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|mouse-&gt;wait
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mouse-&gt;ready
)paren
r_return
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|usb_mouse_fops
r_struct
id|file_operations
id|usb_mouse_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* mouse_seek */
id|read_mouse
comma
id|write_mouse
comma
l_int|NULL
comma
multiline_comment|/* mouse_readdir */
id|mouse_poll
comma
multiline_comment|/* mouse_poll */
l_int|NULL
comma
multiline_comment|/* mouse_ioctl */
l_int|NULL
comma
multiline_comment|/* mouse_mmap */
id|open_mouse
comma
l_int|NULL
comma
multiline_comment|/* flush */
id|release_mouse
comma
l_int|NULL
comma
id|fasync_mouse
comma
)brace
suffix:semicolon
DECL|variable|usb_mouse
r_static
r_struct
id|miscdevice
id|usb_mouse
op_assign
(brace
id|USB_MOUSE_MINOR
comma
l_string|&quot;USB mouse&quot;
comma
op_amp
id|usb_mouse_fops
)brace
suffix:semicolon
DECL|function|mouse_probe
r_static
r_int
id|mouse_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_struct
id|usb_interface_descriptor
op_star
id|interface
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|endpoint
suffix:semicolon
r_struct
id|mouse_state
op_star
id|mouse
op_assign
op_amp
id|static_mouse_state
suffix:semicolon
multiline_comment|/* We don&squot;t handle multi-config mice */
r_if
c_cond
(paren
id|dev-&gt;descriptor.bNumConfigurations
op_ne
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* We don&squot;t handle multi-interface mice */
r_if
c_cond
(paren
id|dev-&gt;config
(braket
l_int|0
)braket
dot
id|bNumInterfaces
op_ne
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Is it a mouse interface? */
id|interface
op_assign
op_amp
id|dev-&gt;config
(braket
l_int|0
)braket
dot
id|interface
(braket
l_int|0
)braket
dot
id|altsetting
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|interface-&gt;bInterfaceClass
op_ne
l_int|3
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|interface-&gt;bInterfaceSubClass
op_ne
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|interface-&gt;bInterfaceProtocol
op_ne
l_int|2
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Multiple endpoints? What kind of mutant ninja-mouse is this? */
r_if
c_cond
(paren
id|interface-&gt;bNumEndpoints
op_ne
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|endpoint
op_assign
op_amp
id|interface-&gt;endpoint
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Output endpoint? Curiousier and curiousier.. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|endpoint-&gt;bEndpointAddress
op_amp
l_int|0x80
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* If it&squot;s not an interrupt endpoint, we&squot;d better punt! */
r_if
c_cond
(paren
(paren
id|endpoint-&gt;bmAttributes
op_amp
l_int|3
)paren
op_ne
l_int|3
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;USB mouse found&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_set_configuration
c_func
(paren
id|dev
comma
id|dev-&gt;config
(braket
l_int|0
)braket
dot
id|bConfigurationValue
)paren
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot; Failed usb_set_configuration: mouse&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* these are used to request the irq when the mouse is opened */
id|mouse-&gt;dev
op_assign
id|dev
suffix:semicolon
id|mouse-&gt;bEndpointAddress
op_assign
id|endpoint-&gt;bEndpointAddress
suffix:semicolon
id|mouse-&gt;bInterval
op_assign
id|endpoint-&gt;bInterval
suffix:semicolon
id|mouse-&gt;present
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mouse_disconnect
r_static
r_void
id|mouse_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_struct
id|mouse_state
op_star
id|mouse
op_assign
op_amp
id|static_mouse_state
suffix:semicolon
multiline_comment|/* stop the usb interrupt transfer */
r_if
c_cond
(paren
id|mouse-&gt;present
)paren
(brace
id|usb_release_irq
c_func
(paren
id|mouse-&gt;dev
comma
id|mouse-&gt;irq_handle
)paren
suffix:semicolon
multiline_comment|/* never keep a reference to a released IRQ! */
id|mouse-&gt;irq_handle
op_assign
l_int|NULL
suffix:semicolon
)brace
id|mouse-&gt;irq_handle
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* this might need work */
id|mouse-&gt;present
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Mouse disconnected&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|mouse_driver
r_static
r_struct
id|usb_driver
id|mouse_driver
op_assign
(brace
l_string|&quot;mouse&quot;
comma
id|mouse_probe
comma
id|mouse_disconnect
comma
(brace
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|function|usb_mouse_init
r_int
id|usb_mouse_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|mouse_state
op_star
id|mouse
op_assign
op_amp
id|static_mouse_state
suffix:semicolon
id|mouse-&gt;present
op_assign
id|mouse-&gt;active
op_assign
l_int|0
suffix:semicolon
id|mouse-&gt;irq_handle
op_assign
l_int|NULL
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|mouse-&gt;wait
)paren
suffix:semicolon
id|mouse-&gt;fasync
op_assign
l_int|NULL
suffix:semicolon
id|misc_register
c_func
(paren
op_amp
id|usb_mouse
)paren
suffix:semicolon
id|usb_register
c_func
(paren
op_amp
id|mouse_driver
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;USB HID boot protocol mouse driver registered.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_mouse_cleanup
r_void
id|usb_mouse_cleanup
c_func
(paren
r_void
)paren
(brace
r_struct
id|mouse_state
op_star
id|mouse
op_assign
op_amp
id|static_mouse_state
suffix:semicolon
multiline_comment|/* stop the usb interrupt transfer */
r_if
c_cond
(paren
id|mouse-&gt;present
)paren
(brace
id|usb_release_irq
c_func
(paren
id|mouse-&gt;dev
comma
id|mouse-&gt;irq_handle
)paren
suffix:semicolon
multiline_comment|/* never keep a reference to a released IRQ! */
id|mouse-&gt;irq_handle
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* this, too, probably needs work */
id|usb_deregister
c_func
(paren
op_amp
id|mouse_driver
)paren
suffix:semicolon
id|misc_deregister
c_func
(paren
op_amp
id|usb_mouse
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|usb_mouse_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|usb_mouse_cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
