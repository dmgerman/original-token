multiline_comment|/*&n; * drivers/usb/usb.c&n; *&n; * (C) Copyright Linus Torvalds 1999&n; * (C) Copyright Johannes Erdfelt 1999&n; * (C) Copyright Andreas Gal 1999&n; * (C) Copyright Gregory P. Smith 1999&n; * (C) Copyright Deti Fliegl 1999 (new USB architecture)&n; * (C) Copyright Randy Dunlap 2000&n; * (C) Copyright David Brownell 2000 (kernel hotplug, usb_device_id)&n; * (C) Copyright Yggdrasil Computing, Inc. 2000&n; *     (usb_device_id matching changes by Adam J. Richter)&n; *&n; * NOTE! This is not actually a driver at all, rather this is&n; * just a collection of helper routines that implement the&n; * generic USB things that the real drivers can use..&n; *&n; * Think of this as a &quot;USB library&quot; rather than anything else.&n; * It should be considered a slave, with no callbacks. Callbacks&n; * are evil.&n; *&n; * $Id: usb.c,v 1.53 2000/01/14 16:19:09 acher Exp $&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;  /* for in_interrupt() */
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#ifdef CONFIG_USB_DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#else
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
macro_line|#include &lt;linux/usb.h&gt;
DECL|macro|DEVNUM_ROUND_ROBIN
mdefine_line|#define DEVNUM_ROUND_ROBIN&t;/***** OPTION *****/
macro_line|#ifdef DEVNUM_ROUND_ROBIN
DECL|variable|devnum_next
r_static
r_int
id|devnum_next
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
DECL|variable|usb_bandwidth_option
r_static
r_const
r_int
id|usb_bandwidth_option
op_assign
macro_line|#ifdef CONFIG_USB_BANDWIDTH
l_int|1
suffix:semicolon
macro_line|#else
l_int|0
suffix:semicolon
macro_line|#endif
r_extern
r_int
id|usb_hub_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|usb_hub_cleanup
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Prototypes for the device driver probing/loading functions&n; */
r_static
r_void
id|usb_find_drivers
c_func
(paren
r_struct
id|usb_device
op_star
)paren
suffix:semicolon
r_static
r_int
id|usb_find_interface_driver
c_func
(paren
r_struct
id|usb_device
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|usb_check_support
c_func
(paren
r_struct
id|usb_device
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * We have a per-interface &quot;registered driver&quot; list.&n; */
DECL|variable|usb_driver_list
id|LIST_HEAD
c_func
(paren
id|usb_driver_list
)paren
suffix:semicolon
DECL|variable|usb_bus_list
id|LIST_HEAD
c_func
(paren
id|usb_bus_list
)paren
suffix:semicolon
DECL|variable|usb_devfs_handle
id|devfs_handle_t
id|usb_devfs_handle
suffix:semicolon
multiline_comment|/* /dev/usb dir. */
DECL|variable|busmap
r_static
r_struct
id|usb_busmap
id|busmap
suffix:semicolon
DECL|variable|usb_minors
r_static
r_struct
id|usb_driver
op_star
id|usb_minors
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/**&n; *&t;usb_register - register a USB driver&n; *&t;@new_driver: USB operations for the driver&n; *&n; *&t;Registers a USB driver with the USB core.  The list of unattached&n; *&t;interfaces will be rescanned whenever a new driver is added, allowing&n; *&t;the new driver to attach to any recognized devices.&n; *&t;Returns a negative error code on failure and 0 on success.&n; */
DECL|function|usb_register
r_int
id|usb_register
c_func
(paren
r_struct
id|usb_driver
op_star
id|new_driver
)paren
(brace
r_if
c_cond
(paren
id|new_driver-&gt;fops
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|usb_minors
(braket
id|new_driver-&gt;minor
op_div
l_int|16
)braket
)paren
(brace
id|err
c_func
(paren
l_string|&quot;error registering %s driver&quot;
comma
id|new_driver-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|usb_minors
(braket
id|new_driver-&gt;minor
op_div
l_int|16
)braket
op_assign
id|new_driver
suffix:semicolon
)brace
id|info
c_func
(paren
l_string|&quot;registered new driver %s&quot;
comma
id|new_driver-&gt;name
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|new_driver-&gt;serialize
)paren
suffix:semicolon
multiline_comment|/* Add it to the list of known drivers */
id|list_add_tail
c_func
(paren
op_amp
id|new_driver-&gt;driver_list
comma
op_amp
id|usb_driver_list
)paren
suffix:semicolon
id|usb_scan_devices
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;usb_scan_devices - scans all unclaimed USB interfaces&n; *&n; *&t;Goes through all unclaimed USB interfaces, and offers them to all&n; *&t;registered USB drivers through the &squot;probe&squot; function.&n; *&t;This will automatically be called after usb_register is called.&n; *&t;It is called by some of the USB subsystems after one of their subdrivers&n; *&t;are registered.&n; */
DECL|function|usb_scan_devices
r_void
id|usb_scan_devices
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|tmp
op_assign
id|usb_bus_list.next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
op_amp
id|usb_bus_list
)paren
(brace
r_struct
id|usb_bus
op_star
id|bus
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|usb_bus
comma
id|bus_list
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
id|usb_check_support
c_func
(paren
id|bus-&gt;root_hub
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function is part of a depth-first search down the device tree,&n; * removing any instances of a device driver.&n; */
DECL|function|usb_drivers_purge
r_static
r_void
id|usb_drivers_purge
c_func
(paren
r_struct
id|usb_driver
op_star
id|driver
comma
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|err
c_func
(paren
l_string|&quot;null device being purged!!!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USB_MAXCHILDREN
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dev-&gt;children
(braket
id|i
)braket
)paren
id|usb_drivers_purge
c_func
(paren
id|driver
comma
id|dev-&gt;children
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;actconfig
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;actconfig-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_interface
op_star
id|interface
op_assign
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|interface-&gt;driver
op_eq
id|driver
)paren
(brace
id|down
c_func
(paren
op_amp
id|driver-&gt;serialize
)paren
suffix:semicolon
id|driver
op_member_access_from_pointer
id|disconnect
c_func
(paren
id|dev
comma
id|interface-&gt;private_data
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|driver-&gt;serialize
)paren
suffix:semicolon
id|usb_driver_release_interface
c_func
(paren
id|driver
comma
id|interface
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * This will go through the list looking for another&n;&t;&t;&t; * driver that can handle the device&n;&t;&t;&t; */
id|usb_find_interface_driver
c_func
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**&n; *&t;usb_deregister - unregister a USB driver&n; *&t;@driver: USB operations of the driver to unregister&n; *&n; *&t;Unlinks the specified driver from the internal USB driver list.&n; */
DECL|function|usb_deregister
r_void
id|usb_deregister
c_func
(paren
r_struct
id|usb_driver
op_star
id|driver
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;deregistering driver %s&quot;
comma
id|driver-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;fops
op_ne
l_int|NULL
)paren
id|usb_minors
(braket
id|driver-&gt;minor
op_div
l_int|16
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * first we remove the driver, to be sure it doesn&squot;t get used by&n;&t; * another thread while we are stepping through removing entries&n;&t; */
id|list_del
c_func
(paren
op_amp
id|driver-&gt;driver_list
)paren
suffix:semicolon
id|tmp
op_assign
id|usb_bus_list.next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
op_amp
id|usb_bus_list
)paren
(brace
r_struct
id|usb_bus
op_star
id|bus
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|usb_bus
comma
id|bus_list
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
id|usb_drivers_purge
c_func
(paren
id|driver
comma
id|bus-&gt;root_hub
)paren
suffix:semicolon
)brace
)brace
DECL|function|usb_ifnum_to_if
r_struct
id|usb_interface
op_star
id|usb_ifnum_to_if
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;actconfig-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
dot
id|altsetting
(braket
l_int|0
)braket
dot
id|bInterfaceNumber
op_eq
id|ifnum
)paren
r_return
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|usb_epnum_to_ep_desc
r_struct
id|usb_endpoint_descriptor
op_star
id|usb_epnum_to_ep_desc
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|epnum
)paren
(brace
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;actconfig-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
dot
id|num_altsetting
suffix:semicolon
id|j
op_increment
)paren
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
dot
id|altsetting
(braket
id|j
)braket
dot
id|bNumEndpoints
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|epnum
op_eq
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
dot
id|altsetting
(braket
id|j
)braket
dot
id|endpoint
(braket
id|k
)braket
dot
id|bEndpointAddress
)paren
r_return
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
dot
id|altsetting
(braket
id|j
)braket
dot
id|endpoint
(braket
id|k
)braket
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_calc_bus_time:&n; *&n; * returns (approximate) USB bus time in nanoseconds for a USB transaction.&n; */
DECL|function|usb_calc_bus_time
r_static
r_int
id|usb_calc_bus_time
(paren
r_int
id|low_speed
comma
r_int
id|input_dir
comma
r_int
id|isoc
comma
r_int
id|bytecount
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|low_speed
)paren
multiline_comment|/* no isoc. here */
(brace
r_if
c_cond
(paren
id|input_dir
)paren
(brace
id|tmp
op_assign
(paren
l_int|67667L
op_star
(paren
l_int|31L
op_plus
l_int|10L
op_star
id|BitTime
(paren
id|bytecount
)paren
)paren
)paren
op_div
l_int|1000L
suffix:semicolon
r_return
(paren
l_int|64060L
op_plus
(paren
l_int|2
op_star
id|BW_HUB_LS_SETUP
)paren
op_plus
id|BW_HOST_DELAY
op_plus
id|tmp
)paren
suffix:semicolon
)brace
r_else
(brace
id|tmp
op_assign
(paren
l_int|66700L
op_star
(paren
l_int|31L
op_plus
l_int|10L
op_star
id|BitTime
(paren
id|bytecount
)paren
)paren
)paren
op_div
l_int|1000L
suffix:semicolon
r_return
(paren
l_int|64107L
op_plus
(paren
l_int|2
op_star
id|BW_HUB_LS_SETUP
)paren
op_plus
id|BW_HOST_DELAY
op_plus
id|tmp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* for full-speed: */
r_if
c_cond
(paren
op_logical_neg
id|isoc
)paren
multiline_comment|/* Input or Output */
(brace
id|tmp
op_assign
(paren
l_int|8354L
op_star
(paren
l_int|31L
op_plus
l_int|10L
op_star
id|BitTime
(paren
id|bytecount
)paren
)paren
)paren
op_div
l_int|1000L
suffix:semicolon
r_return
(paren
l_int|9107L
op_plus
id|BW_HOST_DELAY
op_plus
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/* end not Isoc */
multiline_comment|/* for isoc: */
id|tmp
op_assign
(paren
l_int|8354L
op_star
(paren
l_int|31L
op_plus
l_int|10L
op_star
id|BitTime
(paren
id|bytecount
)paren
)paren
)paren
op_div
l_int|1000L
suffix:semicolon
r_return
(paren
(paren
(paren
id|input_dir
)paren
ques
c_cond
l_int|7268L
suffix:colon
l_int|6265L
)paren
op_plus
id|BW_HOST_DELAY
op_plus
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_check_bandwidth():&n; *&n; * old_alloc is from host_controller-&gt;bandwidth_allocated in microseconds;&n; * bustime is from calc_bus_time(), but converted to microseconds.&n; *&n; * returns &lt;bustime in us&gt; if successful,&n; * or USB_ST_BANDWIDTH_ERROR if bandwidth request fails.&n; *&n; * FIXME:&n; * This initial implementation does not use Endpoint.bInterval&n; * in managing bandwidth allocation.&n; * It probably needs to be expanded to use Endpoint.bInterval.&n; * This can be done as a later enhancement (correction).&n; * This will also probably require some kind of&n; * frame allocation tracking...meaning, for example,&n; * that if multiple drivers request interrupts every 10 USB frames,&n; * they don&squot;t all have to be allocated at&n; * frame numbers N, N+10, N+20, etc.  Some of them could be at&n; * N+11, N+21, N+31, etc., and others at&n; * N+12, N+22, N+32, etc.&n; * However, this first cut at USB bandwidth allocation does not&n; * contain any frame allocation tracking.&n; */
DECL|function|usb_check_bandwidth
r_int
id|usb_check_bandwidth
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|new_alloc
suffix:semicolon
r_int
id|old_alloc
op_assign
id|dev-&gt;bus-&gt;bandwidth_allocated
suffix:semicolon
r_int
r_int
id|pipe
op_assign
id|urb-&gt;pipe
suffix:semicolon
r_int
id|bustime
suffix:semicolon
id|bustime
op_assign
id|usb_calc_bus_time
(paren
id|usb_pipeslow
c_func
(paren
id|pipe
)paren
comma
id|usb_pipein
c_func
(paren
id|pipe
)paren
comma
id|usb_pipeisoc
c_func
(paren
id|pipe
)paren
comma
id|usb_maxpacket
c_func
(paren
id|dev
comma
id|pipe
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipeisoc
c_func
(paren
id|pipe
)paren
)paren
id|bustime
op_assign
id|NS_TO_US
c_func
(paren
id|bustime
)paren
op_div
id|urb-&gt;number_of_packets
suffix:semicolon
r_else
id|bustime
op_assign
id|NS_TO_US
c_func
(paren
id|bustime
)paren
suffix:semicolon
id|new_alloc
op_assign
id|old_alloc
op_plus
(paren
r_int
)paren
id|bustime
suffix:semicolon
multiline_comment|/* what new total allocated bus time would be */
r_if
c_cond
(paren
id|new_alloc
OG
id|FRAME_TIME_MAX_USECS_ALLOC
)paren
id|dbg
c_func
(paren
l_string|&quot;usb-check-bandwidth %sFAILED: was %u, would be %u, bustime = %ld us&quot;
comma
id|usb_bandwidth_option
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;would have &quot;
comma
id|old_alloc
comma
id|new_alloc
comma
id|bustime
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usb_bandwidth_option
)paren
multiline_comment|/* don&squot;t enforce it */
r_return
(paren
id|bustime
)paren
suffix:semicolon
r_return
(paren
id|new_alloc
op_le
id|FRAME_TIME_MAX_USECS_ALLOC
)paren
ques
c_cond
id|bustime
suffix:colon
id|USB_ST_BANDWIDTH_ERROR
suffix:semicolon
)brace
DECL|function|usb_claim_bandwidth
r_void
id|usb_claim_bandwidth
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|bustime
comma
r_int
id|isoc
)paren
(brace
id|dev-&gt;bus-&gt;bandwidth_allocated
op_add_assign
id|bustime
suffix:semicolon
r_if
c_cond
(paren
id|isoc
)paren
id|dev-&gt;bus-&gt;bandwidth_isoc_reqs
op_increment
suffix:semicolon
r_else
id|dev-&gt;bus-&gt;bandwidth_int_reqs
op_increment
suffix:semicolon
id|urb-&gt;bandwidth
op_assign
id|bustime
suffix:semicolon
macro_line|#ifdef USB_BANDWIDTH_MESSAGES
id|dbg
c_func
(paren
l_string|&quot;bandwidth alloc increased by %d to %d for %d requesters&quot;
comma
id|bustime
comma
id|dev-&gt;bus-&gt;bandwidth_allocated
comma
id|dev-&gt;bus-&gt;bandwidth_int_reqs
op_plus
id|dev-&gt;bus-&gt;bandwidth_isoc_reqs
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * usb_release_bandwidth():&n; *&n; * called to release a pipe&squot;s bandwidth (in microseconds)&n; */
DECL|function|usb_release_bandwidth
r_void
id|usb_release_bandwidth
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|isoc
)paren
(brace
id|dev-&gt;bus-&gt;bandwidth_allocated
op_sub_assign
id|urb-&gt;bandwidth
suffix:semicolon
r_if
c_cond
(paren
id|isoc
)paren
id|dev-&gt;bus-&gt;bandwidth_isoc_reqs
op_decrement
suffix:semicolon
r_else
id|dev-&gt;bus-&gt;bandwidth_int_reqs
op_decrement
suffix:semicolon
macro_line|#ifdef USB_BANDWIDTH_MESSAGES
id|dbg
c_func
(paren
l_string|&quot;bandwidth alloc reduced by %d to %d for %d requesters&quot;
comma
id|urb-&gt;bandwidth
comma
id|dev-&gt;bus-&gt;bandwidth_allocated
comma
id|dev-&gt;bus-&gt;bandwidth_int_reqs
op_plus
id|dev-&gt;bus-&gt;bandwidth_isoc_reqs
)paren
suffix:semicolon
macro_line|#endif
id|urb-&gt;bandwidth
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;usb_alloc_bus - creates a new USB host controller structure&n; *&t;@op: pointer to a struct usb_operations that this bus structure should use&n; *&n; *&t;Creates a USB host controller bus structure with the specified &n; *&t;usb_operations and initializes all the necessary internal objects.&n; *&n; *&t;If no memory is available, NULL is returned.&n; *&n; *&t;The caller should call usb_free_bus() when it is finished with the structure.&n; */
DECL|function|usb_alloc_bus
r_struct
id|usb_bus
op_star
id|usb_alloc_bus
c_func
(paren
r_struct
id|usb_operations
op_star
id|op
)paren
(brace
r_struct
id|usb_bus
op_star
id|bus
suffix:semicolon
id|bus
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|bus
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|bus-&gt;devmap
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|usb_devmap
)paren
)paren
suffix:semicolon
id|bus-&gt;op
op_assign
id|op
suffix:semicolon
id|bus-&gt;root_hub
op_assign
l_int|NULL
suffix:semicolon
id|bus-&gt;hcpriv
op_assign
l_int|NULL
suffix:semicolon
id|bus-&gt;busnum
op_assign
op_minus
l_int|1
suffix:semicolon
id|bus-&gt;bandwidth_allocated
op_assign
l_int|0
suffix:semicolon
id|bus-&gt;bandwidth_int_reqs
op_assign
l_int|0
suffix:semicolon
id|bus-&gt;bandwidth_isoc_reqs
op_assign
l_int|0
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|bus-&gt;bus_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|bus-&gt;inodes
)paren
suffix:semicolon
r_return
id|bus
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;usb_free_bus - frees the memory used by a bus structure&n; *&t;@bus: pointer to the bus to free&n; *&n; */
DECL|function|usb_free_bus
r_void
id|usb_free_bus
c_func
(paren
r_struct
id|usb_bus
op_star
id|bus
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bus
)paren
r_return
suffix:semicolon
id|kfree
c_func
(paren
id|bus
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;usb_register_bus - registers the USB host controller with the usb core&n; *&t;@bus: pointer to the bus to register&n; *&n; */
DECL|function|usb_register_bus
r_void
id|usb_register_bus
c_func
(paren
r_struct
id|usb_bus
op_star
id|bus
)paren
(brace
r_int
id|busnum
suffix:semicolon
id|busnum
op_assign
id|find_next_zero_bit
c_func
(paren
id|busmap.busmap
comma
id|USB_MAXBUS
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|busnum
OL
id|USB_MAXBUS
)paren
(brace
id|set_bit
c_func
(paren
id|busnum
comma
id|busmap.busmap
)paren
suffix:semicolon
id|bus-&gt;busnum
op_assign
id|busnum
suffix:semicolon
)brace
r_else
id|warn
c_func
(paren
l_string|&quot;too many buses&quot;
)paren
suffix:semicolon
multiline_comment|/* Add it to the list of buses */
id|list_add
c_func
(paren
op_amp
id|bus-&gt;bus_list
comma
op_amp
id|usb_bus_list
)paren
suffix:semicolon
id|usbdevfs_add_bus
c_func
(paren
id|bus
)paren
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;new USB bus registered, assigned bus number %d&quot;
comma
id|bus-&gt;busnum
)paren
suffix:semicolon
)brace
DECL|function|usb_deregister_bus
r_void
id|usb_deregister_bus
c_func
(paren
r_struct
id|usb_bus
op_star
id|bus
)paren
(brace
id|info
c_func
(paren
l_string|&quot;USB bus %d deregistered&quot;
comma
id|bus-&gt;busnum
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE: make sure that all the devices are removed by the&n;&t; * controller code, as well as having it call this when cleaning&n;&t; * itself up&n;&t; */
id|list_del
c_func
(paren
op_amp
id|bus-&gt;bus_list
)paren
suffix:semicolon
id|usbdevfs_remove_bus
c_func
(paren
id|bus
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|bus-&gt;busnum
comma
id|busmap.busmap
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is for doing a depth-first search for devices which&n; * have support, for dynamic loading of driver modules.&n; */
DECL|function|usb_check_support
r_static
r_void
id|usb_check_support
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|err
c_func
(paren
l_string|&quot;null device being checked!!!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USB_MAXCHILDREN
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dev-&gt;children
(braket
id|i
)braket
)paren
id|usb_check_support
c_func
(paren
id|dev-&gt;children
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;actconfig
)paren
r_return
suffix:semicolon
multiline_comment|/* now we check this device */
r_if
c_cond
(paren
id|dev-&gt;devnum
OG
l_int|0
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;actconfig-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
id|usb_find_interface_driver
c_func
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is intended to be used by usb device drivers that need to&n; * claim more than one interface on a device at once when probing&n; * (audio and acm are good examples).  No device driver should have&n; * to mess with the internal usb_interface or usb_device structure&n; * members.&n; */
DECL|function|usb_driver_claim_interface
r_void
id|usb_driver_claim_interface
c_func
(paren
r_struct
id|usb_driver
op_star
id|driver
comma
r_struct
id|usb_interface
op_star
id|iface
comma
r_void
op_star
id|priv
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|iface
op_logical_or
op_logical_neg
id|driver
)paren
r_return
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s driver claimed interface %p&quot;
comma
id|driver-&gt;name
comma
id|iface
)paren
suffix:semicolon
id|iface-&gt;driver
op_assign
id|driver
suffix:semicolon
id|iface-&gt;private_data
op_assign
id|priv
suffix:semicolon
)brace
multiline_comment|/* usb_driver_claim_interface() */
multiline_comment|/*&n; * This should be used by drivers to check other interfaces to see if&n; * they are available or not.&n; */
DECL|function|usb_interface_claimed
r_int
id|usb_interface_claimed
c_func
(paren
r_struct
id|usb_interface
op_star
id|iface
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|iface
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|iface-&gt;driver
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* usb_interface_claimed() */
multiline_comment|/*&n; * This should be used by drivers to release their claimed interfaces&n; */
DECL|function|usb_driver_release_interface
r_void
id|usb_driver_release_interface
c_func
(paren
r_struct
id|usb_driver
op_star
id|driver
comma
r_struct
id|usb_interface
op_star
id|iface
)paren
(brace
multiline_comment|/* this should never happen, don&squot;t release something that&squot;s not ours */
r_if
c_cond
(paren
op_logical_neg
id|iface
op_logical_or
id|iface-&gt;driver
op_ne
id|driver
)paren
r_return
suffix:semicolon
id|iface-&gt;driver
op_assign
l_int|NULL
suffix:semicolon
id|iface-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* usb_match_id searches an array of usb_device_id&squot;s and returns&n;   the first one that matches the device and interface.&n;&n;   Parameters:&n;   &t;&quot;id&quot; is an array of usb_device_id&squot;s is terminated by an entry&n;&t; containing all zeroes.&n;&n;&t; &quot;dev&quot; and &quot;interface&quot; are the device and interface for which&n;&t; a match is sought.&n;&n;   If no match is found or if the &quot;id&quot; pointer is NULL, then&n;   usb_match_id returns NULL.&n;&n;&n;   What constitutes a match:&n;&n;   A zero in any element of a usb_device_id entry is a wildcard&n;   (i.e., that field always matches).  For there to be a match,&n;   *every* nonzero element of the usb_device_id must match the&n;   provided device and interface in.  The comparison is for equality,&n;   except for one pair of fields: usb_match_id.bcdDevice_{lo,hi} define&n;   an inclusive range that dev-&gt;descriptor.bcdDevice must be in.&n;&n;   If interface-&gt;altsettings does not exist (i.e., there are no&n;   interfaces defined), then bInterface{Class,SubClass,Protocol}&n;   only match if they are all zeroes.&n;&n;&n;   What constitutes a good &quot;usb_device_id&quot;?&n;&n;   The match algorithm is very simple, so that intelligence in&n;   driver selection must come from smart driver id records.&n;   Unless you have good reasons to use another selection policy,&n;   provide match elements only in related groups:&n;&n;    * device specifiers (vendor and product IDs; and maybe&n;      a revision range for that product);&n;    * generic device specs (class/subclass/protocol);&n;    * interface specs (class/subclass/protocol).&n;    &n;   Within those groups, work from least specific to most specific.&n;   For example, don&squot;t give a product version range without vendor&n;   and product IDs.&n;&n;   &quot;driver_info&quot; is not considered by the kernel matching algorithm,&n;   but you can create a wildcard &quot;matches anything&quot; usb_device_id&n;   as your driver&squot;s &quot;modules.usbmap&quot; entry if you provide only an&n;   id with a nonzero &quot;driver_info&quot; field.&n;*/
r_const
r_struct
id|usb_device_id
op_star
DECL|function|usb_match_id
id|usb_match_id
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|usb_interface
op_star
id|interface
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|usb_interface_descriptor
op_star
id|intf
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* proc_connectinfo in devio.c may call us with id == NULL. */
r_if
c_cond
(paren
id|id
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* It is important to check that id-&gt;driver_info is nonzero,&n;&t;   since an entry that is all zeroes except for a nonzero&n;&t;   id-&gt;driver_info is the way to create an entry that&n;&t;   indicates that the driver want to examine every&n;&t;   device and interface. */
r_for
c_loop
(paren
suffix:semicolon
id|id-&gt;idVendor
op_logical_or
id|id-&gt;bDeviceClass
op_logical_or
id|id-&gt;bInterfaceClass
op_logical_or
id|id-&gt;driver_info
suffix:semicolon
id|id
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_VENDOR
)paren
op_logical_and
id|id-&gt;idVendor
op_ne
id|dev-&gt;descriptor.idVendor
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_PRODUCT
)paren
op_logical_and
id|id-&gt;idProduct
op_ne
id|dev-&gt;descriptor.idProduct
)paren
r_continue
suffix:semicolon
multiline_comment|/* No need to test id-&gt;bcdDevice_lo != 0, since 0 is never&n;&t;&t;   greater than any unsigned number. */
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_DEV_LO
)paren
op_logical_and
(paren
id|id-&gt;bcdDevice_lo
OG
id|dev-&gt;descriptor.bcdDevice
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_DEV_HI
)paren
op_logical_and
(paren
id|id-&gt;bcdDevice_hi
OL
id|dev-&gt;descriptor.bcdDevice
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_DEV_CLASS
)paren
op_logical_and
(paren
id|id-&gt;bDeviceClass
op_ne
id|dev-&gt;descriptor.bDeviceClass
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_DEV_SUBCLASS
)paren
op_logical_and
(paren
id|id-&gt;bDeviceSubClass
op_ne
id|dev-&gt;descriptor.bDeviceSubClass
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_DEV_PROTOCOL
)paren
op_logical_and
(paren
id|id-&gt;bDeviceProtocol
op_ne
id|dev-&gt;descriptor.bDeviceProtocol
)paren
)paren
r_continue
suffix:semicolon
id|intf
op_assign
op_amp
id|interface-&gt;altsetting
(braket
id|interface-&gt;act_altsetting
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_INT_CLASS
)paren
op_logical_and
(paren
id|id-&gt;bInterfaceClass
op_ne
id|intf-&gt;bInterfaceClass
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_INT_SUBCLASS
)paren
op_logical_and
(paren
id|id-&gt;bInterfaceSubClass
op_ne
id|intf-&gt;bInterfaceSubClass
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_INT_PROTOCOL
)paren
op_logical_and
(paren
id|id-&gt;bInterfaceProtocol
op_ne
id|intf-&gt;bInterfaceProtocol
)paren
)paren
r_continue
suffix:semicolon
r_return
id|id
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * This entrypoint gets called for each new device.&n; *&n; * We now walk the list of registered USB drivers,&n; * looking for one that will accept this interface.&n; *&n; * &quot;New Style&quot; drivers use a table describing the devices and interfaces&n; * they handle.  Those tables are available to user mode tools deciding&n; * whether to load driver modules for a new device.&n; *&n; * The probe return value is changed to be a private pointer.  This way&n; * the drivers don&squot;t have to dig around in our structures to set the&n; * private pointer if they only need one interface. &n; *&n; * Returns: 0 if a driver accepted the interface, -1 otherwise&n; */
DECL|function|usb_find_interface_driver
r_static
r_int
id|usb_find_interface_driver
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|usb_interface
op_star
id|interface
suffix:semicolon
r_void
op_star
r_private
suffix:semicolon
r_const
r_struct
id|usb_device_id
op_star
id|id
suffix:semicolon
r_struct
id|usb_driver
op_star
id|driver
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|dev
)paren
op_logical_or
(paren
id|ifnum
op_ge
id|dev-&gt;actconfig-&gt;bNumInterfaces
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;bad find_interface_driver params&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|interface
op_assign
id|dev-&gt;actconfig-&gt;interface
op_plus
id|ifnum
suffix:semicolon
r_if
c_cond
(paren
id|usb_interface_claimed
c_func
(paren
id|interface
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_private
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|usb_driver_list.next
suffix:semicolon
id|tmp
op_ne
op_amp
id|usb_driver_list
suffix:semicolon
)paren
(brace
id|driver
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|usb_driver
comma
id|driver_list
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
id|down
c_func
(paren
op_amp
id|driver-&gt;serialize
)paren
suffix:semicolon
id|id
op_assign
id|driver-&gt;id_table
suffix:semicolon
multiline_comment|/* new style driver? */
r_if
c_cond
(paren
id|id
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|interface-&gt;num_altsetting
suffix:semicolon
id|i
op_increment
)paren
(brace
id|interface-&gt;act_altsetting
op_assign
id|i
suffix:semicolon
id|id
op_assign
id|usb_match_id
c_func
(paren
id|dev
comma
id|interface
comma
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
)paren
(brace
r_private
op_assign
id|driver
op_member_access_from_pointer
id|probe
c_func
(paren
id|dev
comma
id|ifnum
comma
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
r_private
op_ne
l_int|NULL
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* if driver not bound, leave defaults unchanged */
r_if
c_cond
(paren
r_private
op_eq
l_int|NULL
)paren
id|interface-&gt;act_altsetting
op_assign
l_int|0
suffix:semicolon
)brace
r_else
multiline_comment|/* &quot;old style&quot; driver */
r_private
op_assign
id|driver
op_member_access_from_pointer
id|probe
c_func
(paren
id|dev
comma
id|ifnum
comma
l_int|NULL
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|driver-&gt;serialize
)paren
suffix:semicolon
r_if
c_cond
(paren
r_private
)paren
(brace
id|usb_driver_claim_interface
c_func
(paren
id|driver
comma
id|interface
comma
r_private
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef&t;CONFIG_HOTPLUG
multiline_comment|/*&n; * USB hotplugging invokes what /proc/sys/kernel/hotplug says&n; * (normally /sbin/hotplug) when USB devices get added or removed.&n; *&n; * This invokes a user mode policy agent, typically helping to load driver&n; * or other modules, configure the device, and more.  Drivers can provide&n; * a MODULE_DEVICE_TABLE to help with module loading subtasks.&n; *&n; * Some synchronization is important: removes can&squot;t start processing&n; * before the add-device processing completes, and vice versa.  That keeps&n; * a stack of USB-related identifiers stable while they&squot;re in use.  If we&n; * know that agents won&squot;t complete after they return (such as by forking&n; * a process that completes later), it&squot;s enough to just waitpid() for the&n; * agent -- as is currently done.&n; *&n; * The reason: we know we&squot;re called either from khubd (the typical case)&n; * or from root hub initialization (init, kapmd, modprobe, etc).  In both&n; * cases, we know no other thread can recycle our address, since we must&n; * already have been serialized enough to prevent that.&n; */
DECL|function|call_policy
r_static
r_void
id|call_policy
(paren
r_char
op_star
id|verb
comma
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_char
op_star
id|argv
(braket
l_int|3
)braket
comma
op_star
op_star
id|envp
comma
op_star
id|buf
comma
op_star
id|scratch
suffix:semicolon
r_int
id|i
op_assign
l_int|0
comma
id|value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hotplug_path
(braket
l_int|0
)braket
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
(paren
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;In_interrupt&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;fs-&gt;root
)paren
(brace
multiline_comment|/* statically linked USB is initted rather early */
id|dbg
(paren
l_string|&quot;call_policy %s, num %d -- no FS yet&quot;
comma
id|verb
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;devnum
OL
l_int|0
)paren
(brace
id|dbg
(paren
l_string|&quot;device already deleted ??&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|envp
op_assign
(paren
r_char
op_star
op_star
)paren
id|kmalloc
(paren
l_int|20
op_star
r_sizeof
(paren
r_char
op_star
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;enomem&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|buf
op_assign
id|kmalloc
(paren
l_int|256
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|kfree
(paren
id|envp
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;enomem2&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* only one standardized param to hotplug command: type */
id|argv
(braket
l_int|0
)braket
op_assign
id|hotplug_path
suffix:semicolon
id|argv
(braket
l_int|1
)braket
op_assign
l_string|&quot;usb&quot;
suffix:semicolon
id|argv
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* minimal command environment */
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;HOME=/&quot;
suffix:semicolon
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;
suffix:semicolon
macro_line|#ifdef&t;DEBUG
multiline_comment|/* hint that policy agent should enter no-stdout debug mode */
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;DEBUG=kernel&quot;
suffix:semicolon
macro_line|#endif
multiline_comment|/* extensible set of named bus-specific parameters,&n;&t; * supporting multiple driver selection algorithms.&n;&t; */
id|scratch
op_assign
id|buf
suffix:semicolon
multiline_comment|/* action:  add, remove */
id|envp
(braket
id|i
op_increment
)braket
op_assign
id|scratch
suffix:semicolon
id|scratch
op_add_assign
id|sprintf
(paren
id|scratch
comma
l_string|&quot;ACTION=%s&quot;
comma
id|verb
)paren
op_plus
l_int|1
suffix:semicolon
macro_line|#ifdef&t;CONFIG_USB_DEVICEFS
multiline_comment|/* If this is available, userspace programs can directly read&n;&t; * all the device descriptors we don&squot;t tell them about.  Or&n;&t; * even act as usermode drivers.&n;&t; *&n;&t; * FIXME reduce hardwired intelligence here&n;&t; */
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;DEVFS=/proc/bus/usb&quot;
suffix:semicolon
id|envp
(braket
id|i
op_increment
)braket
op_assign
id|scratch
suffix:semicolon
id|scratch
op_add_assign
id|sprintf
(paren
id|scratch
comma
l_string|&quot;DEVICE=/proc/bus/usb/%03d/%03d&quot;
comma
id|dev-&gt;bus-&gt;busnum
comma
id|dev-&gt;devnum
)paren
op_plus
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/* per-device configuration hacks are common */
id|envp
(braket
id|i
op_increment
)braket
op_assign
id|scratch
suffix:semicolon
id|scratch
op_add_assign
id|sprintf
(paren
id|scratch
comma
l_string|&quot;PRODUCT=%x/%x/%x&quot;
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
comma
id|dev-&gt;descriptor.bcdDevice
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* class-based driver binding models */
id|envp
(braket
id|i
op_increment
)braket
op_assign
id|scratch
suffix:semicolon
id|scratch
op_add_assign
id|sprintf
(paren
id|scratch
comma
l_string|&quot;TYPE=%d/%d/%d&quot;
comma
id|dev-&gt;descriptor.bDeviceClass
comma
id|dev-&gt;descriptor.bDeviceSubClass
comma
id|dev-&gt;descriptor.bDeviceProtocol
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.bDeviceClass
op_eq
l_int|0
)paren
(brace
r_int
id|alt
op_assign
id|dev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
dot
id|act_altsetting
suffix:semicolon
multiline_comment|/* a simple/common case: one config, one interface, one driver&n;&t;&t; * with current altsetting being a reasonable setting.&n;&t;&t; * everything needs a smart agent and usbdevfs; or can rely on&n;&t;&t; * device-specific binding policies.&n;&t;&t; */
id|envp
(braket
id|i
op_increment
)braket
op_assign
id|scratch
suffix:semicolon
id|scratch
op_add_assign
id|sprintf
(paren
id|scratch
comma
l_string|&quot;INTERFACE=%d/%d/%d&quot;
comma
id|dev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
dot
id|altsetting
(braket
id|alt
)braket
dot
id|bInterfaceClass
comma
id|dev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
dot
id|altsetting
(braket
id|alt
)braket
dot
id|bInterfaceSubClass
comma
id|dev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
dot
id|altsetting
(braket
id|alt
)braket
dot
id|bInterfaceProtocol
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* INTERFACE-0, INTERFACE-1, ... ? */
)brace
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* assert: (scratch - buf) &lt; sizeof buf */
multiline_comment|/* NOTE: user mode daemons can call the agents too */
id|dbg
(paren
l_string|&quot;kusbd: %s %s %d&quot;
comma
id|argv
(braket
l_int|0
)braket
comma
id|verb
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
id|value
op_assign
id|call_usermodehelper
(paren
id|argv
(braket
l_int|0
)braket
comma
id|argv
comma
id|envp
)paren
suffix:semicolon
id|kfree
(paren
id|buf
)paren
suffix:semicolon
id|kfree
(paren
id|envp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
l_int|0
)paren
id|dbg
(paren
l_string|&quot;kusbd policy returned 0x%x&quot;
comma
id|value
)paren
suffix:semicolon
)brace
macro_line|#else
r_static
r_inline
r_void
DECL|function|call_policy
id|call_policy
(paren
r_char
op_star
id|verb
comma
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
)brace
macro_line|#endif&t;/* KMOD */
multiline_comment|/*&n; * This entrypoint gets called for each new device.&n; *&n; * All interfaces are scanned for matching drivers.&n; */
DECL|function|usb_find_drivers
r_static
r_void
id|usb_find_drivers
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|ifnum
suffix:semicolon
r_int
id|rejected
op_assign
l_int|0
suffix:semicolon
r_int
id|claimed
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|ifnum
op_assign
l_int|0
suffix:semicolon
id|ifnum
OL
id|dev-&gt;actconfig-&gt;bNumInterfaces
suffix:semicolon
id|ifnum
op_increment
)paren
(brace
multiline_comment|/* if this interface hasn&squot;t already been claimed */
r_if
c_cond
(paren
op_logical_neg
id|usb_interface_claimed
c_func
(paren
id|dev-&gt;actconfig-&gt;interface
op_plus
id|ifnum
)paren
)paren
(brace
r_if
c_cond
(paren
id|usb_find_interface_driver
c_func
(paren
id|dev
comma
id|ifnum
)paren
)paren
id|rejected
op_increment
suffix:semicolon
r_else
id|claimed
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rejected
)paren
id|dbg
c_func
(paren
l_string|&quot;unhandled interfaces on device&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|claimed
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;USB device %d (vend/prod 0x%x/0x%x) is not claimed by any active driver.&quot;
comma
id|dev-&gt;devnum
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|usb_show_device
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*&n; * Only HC&squot;s should call usb_alloc_dev and usb_free_dev directly&n; * Anybody may use usb_inc_dev_use or usb_dec_dev_use&n; */
DECL|function|usb_alloc_dev
r_struct
id|usb_device
op_star
id|usb_alloc_dev
c_func
(paren
r_struct
id|usb_device
op_star
id|parent
comma
r_struct
id|usb_bus
op_star
id|bus
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|dev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|dev
)paren
)paren
suffix:semicolon
id|dev-&gt;bus
op_assign
id|bus
suffix:semicolon
id|dev-&gt;parent
op_assign
id|parent
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|dev-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dev-&gt;inodes
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dev-&gt;filelist
)paren
suffix:semicolon
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|allocate
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
DECL|function|usb_free_dev
r_void
id|usb_free_dev
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
)paren
(brace
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|deallocate
c_func
(paren
id|dev
)paren
suffix:semicolon
id|usb_destroy_configuration
c_func
(paren
id|dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
DECL|function|usb_inc_dev_use
r_void
id|usb_inc_dev_use
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------------------- &n; * New USB Core Functions&n; * -------------------------------------------------------------------------------------*/
multiline_comment|/**&n; *&t;usb_alloc_urb - creates a new urb for a USB driver to use&n; *&t;@iso_packets: number of iso packets for this urb&n; *&n; *&t;Creates an urb for the USB driver to use and returns a pointer to it.&n; *&t;If no memory is available, NULL is returned.&n; *&n; *&t;If the driver want to use this urb for interrupt, control, or bulk&n; *&t;endpoints, pass &squot;0&squot; as the number of iso packets.&n; *&n; *&t;The driver should call usb_free_urb() when it is finished with the urb.&n; */
DECL|function|usb_alloc_urb
id|urb_t
op_star
id|usb_alloc_urb
c_func
(paren
r_int
id|iso_packets
)paren
(brace
id|urb_t
op_star
id|urb
suffix:semicolon
id|urb
op_assign
(paren
id|urb_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|urb_t
)paren
op_plus
id|iso_packets
op_star
r_sizeof
(paren
id|iso_packet_descriptor_t
)paren
comma
id|in_interrupt
c_func
(paren
)paren
ques
c_cond
id|GFP_ATOMIC
suffix:colon
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|err
c_func
(paren
l_string|&quot;alloc_urb: kmalloc failed&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|urb
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|urb
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
r_return
id|urb
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;usb_free_urb - frees the memory used by a urb&n; *&t;@urb: pointer to the urb to free&n; *&n; *&t;If an urb is created with a call to usb_create_urb() it should be&n; *&t;cleaned up with a call to usb_free_urb() when the driver is finished&n; *&t;with it.&n; */
DECL|function|usb_free_urb
r_void
id|usb_free_urb
c_func
(paren
id|urb_t
op_star
id|urb
)paren
(brace
r_if
c_cond
(paren
id|urb
)paren
id|kfree
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
DECL|function|usb_submit_urb
r_int
id|usb_submit_urb
c_func
(paren
id|urb_t
op_star
id|urb
)paren
(brace
r_if
c_cond
(paren
id|urb
op_logical_and
id|urb-&gt;dev
)paren
r_return
id|urb-&gt;dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|submit_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
r_else
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
DECL|function|usb_unlink_urb
r_int
id|usb_unlink_urb
c_func
(paren
id|urb_t
op_star
id|urb
)paren
(brace
r_if
c_cond
(paren
id|urb
op_logical_and
id|urb-&gt;dev
)paren
r_return
id|urb-&gt;dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|unlink_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
r_else
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*&n; *                     COMPLETION HANDLERS                           *&n; *-------------------------------------------------------------------*/
multiline_comment|/*-------------------------------------------------------------------*&n; * completion handler for compatibility wrappers (sync control/bulk) *&n; *-------------------------------------------------------------------*/
DECL|function|usb_api_blocking_completion
r_static
r_void
id|usb_api_blocking_completion
c_func
(paren
id|urb_t
op_star
id|urb
)paren
(brace
id|api_wrapper_data
op_star
id|awd
op_assign
(paren
id|api_wrapper_data
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
id|awd-&gt;wakeup
)paren
)paren
id|wake_up
c_func
(paren
id|awd-&gt;wakeup
)paren
suffix:semicolon
macro_line|#if 0
r_else
id|dbg
c_func
(paren
l_string|&quot;(blocking_completion): waitqueue empty!&quot;
)paren
suffix:semicolon
singleline_comment|// even occurs if urb was unlinked by timeout...
macro_line|#endif
)brace
multiline_comment|/*-------------------------------------------------------------------*&n; *                         COMPATIBILITY STUFF                       *&n; *-------------------------------------------------------------------*/
singleline_comment|// Starts urb and waits for completion or timeout
DECL|function|usb_start_wait_urb
r_static
r_int
id|usb_start_wait_urb
c_func
(paren
id|urb_t
op_star
id|urb
comma
r_int
id|timeout
comma
r_int
op_star
id|actual_length
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|wqh
)paren
suffix:semicolon
id|api_wrapper_data
id|awd
suffix:semicolon
r_int
id|status
suffix:semicolon
id|awd.wakeup
op_assign
op_amp
id|wqh
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|wqh
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|wqh
comma
op_amp
id|wait
)paren
suffix:semicolon
id|urb-&gt;context
op_assign
op_amp
id|awd
suffix:semicolon
id|status
op_assign
id|usb_submit_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
singleline_comment|// something went wrong
id|usb_free_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|wqh
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
r_while
c_loop
(paren
id|timeout
op_logical_and
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
id|status
op_assign
id|timeout
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
)brace
r_else
id|status
op_assign
l_int|1
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|wqh
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
singleline_comment|// timeout
id|printk
c_func
(paren
l_string|&quot;usb_control/bulk_msg: timeout&bslash;n&quot;
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
singleline_comment|// remove urb safely
id|status
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
r_else
id|status
op_assign
id|urb-&gt;status
suffix:semicolon
r_if
c_cond
(paren
id|actual_length
)paren
op_star
id|actual_length
op_assign
id|urb-&gt;actual_length
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
singleline_comment|// returns status (negative) or length (positive)
DECL|function|usb_internal_control_msg
r_int
id|usb_internal_control_msg
c_func
(paren
r_struct
id|usb_device
op_star
id|usb_dev
comma
r_int
r_int
id|pipe
comma
id|devrequest
op_star
id|cmd
comma
r_void
op_star
id|data
comma
r_int
id|len
comma
r_int
id|timeout
)paren
(brace
id|urb_t
op_star
id|urb
suffix:semicolon
r_int
id|retv
suffix:semicolon
r_int
id|length
suffix:semicolon
id|urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|FILL_CONTROL_URB
c_func
(paren
id|urb
comma
id|usb_dev
comma
id|pipe
comma
(paren
r_int
r_char
op_star
)paren
id|cmd
comma
id|data
comma
id|len
comma
multiline_comment|/* build urb */
(paren
id|usb_complete_t
)paren
id|usb_api_blocking_completion
comma
l_int|0
)paren
suffix:semicolon
id|retv
op_assign
id|usb_start_wait_urb
c_func
(paren
id|urb
comma
id|timeout
comma
op_amp
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retv
OL
l_int|0
)paren
r_return
id|retv
suffix:semicolon
r_else
r_return
id|length
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;usb_control_msg - Builds a control urb, sends it off and waits for completion&n; *&t;@dev: pointer to the usb device to send the message to&n; *&t;@pipe: endpoint &quot;pipe&quot; to send the message to&n; *&t;@request: USB message request value&n; *&t;@requesttype: USB message request type value&n; *&t;@value: USB message value&n; *&t;@index: USB message index value&n; *&t;@data: pointer to the data to send&n; *&t;@size: length in bytes of the data to send&n; *&t;@timeout: time to wait for the message to complete before timing out (if 0 the wait is forever)&n; *&n; *&t;This function sends a simple control message to a specified endpoint&n; *&t;and waits for the message to complete, or timeout.&n; *&t;&n; *&t;If successful, it returns 0, othwise a negative error number.&n; *&n; *&t;Don&squot;t use this function from within an interrupt context, like a&n; *&t;bottom half handler.  If you need a asyncronous message, or need to send&n; *&t;a message from within interrupt context, use usb_submit_urb()&n; */
DECL|function|usb_control_msg
r_int
id|usb_control_msg
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|pipe
comma
id|__u8
id|request
comma
id|__u8
id|requesttype
comma
id|__u16
id|value
comma
id|__u16
id|index
comma
r_void
op_star
id|data
comma
id|__u16
id|size
comma
r_int
id|timeout
)paren
(brace
id|devrequest
op_star
id|dr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|devrequest
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|dr-&gt;requesttype
op_assign
id|requesttype
suffix:semicolon
id|dr-&gt;request
op_assign
id|request
suffix:semicolon
id|dr-&gt;value
op_assign
id|cpu_to_le16p
c_func
(paren
op_amp
id|value
)paren
suffix:semicolon
id|dr-&gt;index
op_assign
id|cpu_to_le16p
c_func
(paren
op_amp
id|index
)paren
suffix:semicolon
id|dr-&gt;length
op_assign
id|cpu_to_le16p
c_func
(paren
op_amp
id|size
)paren
suffix:semicolon
singleline_comment|//dbg(&quot;usb_control_msg&quot;);&t;
id|ret
op_assign
id|usb_internal_control_msg
c_func
(paren
id|dev
comma
id|pipe
comma
id|dr
comma
id|data
comma
id|size
comma
id|timeout
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dr
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;usb_bulk_msg - Builds a bulk urb, sends it off and waits for completion&n; *&t;@usb_dev: pointer to the usb device to send the message to&n; *&t;@pipe: endpoint &quot;pipe&quot; to send the message to&n; *&t;@data: pointer to the data to send&n; *&t;@len: length in bytes of the data to send&n; *&t;@actual_length: pointer to a location to put the actual length transfered in bytes&n; *&t;@timeout: time to wait for the message to complete before timing out (if 0 the wait is forever)&n; *&n; *&t;This function sends a simple bulk message to a specified endpoint&n; *&t;and waits for the message to complete, or timeout.&n; *&t;&n; *&t;If successful, it returns 0, othwise a negative error number.&n; *&t;The number of actual bytes transferred will be plaed in the &n; *&t;actual_timeout paramater.&n; *&n; *&t;Don&squot;t use this function from within an interrupt context, like a&n; *&t;bottom half handler.  If you need a asyncronous message, or need to&n; *&t;send a message from within interrupt context, use usb_submit_urb()&n; */
DECL|function|usb_bulk_msg
r_int
id|usb_bulk_msg
c_func
(paren
r_struct
id|usb_device
op_star
id|usb_dev
comma
r_int
r_int
id|pipe
comma
r_void
op_star
id|data
comma
r_int
id|len
comma
r_int
op_star
id|actual_length
comma
r_int
id|timeout
)paren
(brace
id|urb_t
op_star
id|urb
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|FILL_BULK_URB
c_func
(paren
id|urb
comma
id|usb_dev
comma
id|pipe
comma
(paren
r_int
r_char
op_star
)paren
id|data
comma
id|len
comma
multiline_comment|/* build urb */
(paren
id|usb_complete_t
)paren
id|usb_api_blocking_completion
comma
l_int|0
)paren
suffix:semicolon
r_return
id|usb_start_wait_urb
c_func
(paren
id|urb
comma
id|timeout
comma
id|actual_length
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_get_current_frame_number()&n; *&n; * returns the current frame number for the parent USB bus/controller&n; * of the given USB device.&n; */
DECL|function|usb_get_current_frame_number
r_int
id|usb_get_current_frame_number
c_func
(paren
r_struct
id|usb_device
op_star
id|usb_dev
)paren
(brace
r_return
id|usb_dev-&gt;bus-&gt;op-&gt;get_frame_number
(paren
id|usb_dev
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
DECL|function|usb_parse_endpoint
r_static
r_int
id|usb_parse_endpoint
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|usb_endpoint_descriptor
op_star
id|endpoint
comma
r_int
r_char
op_star
id|buffer
comma
r_int
id|size
)paren
(brace
r_struct
id|usb_descriptor_header
op_star
id|header
suffix:semicolon
r_int
r_char
op_star
id|begin
suffix:semicolon
r_int
id|parsed
op_assign
l_int|0
comma
id|len
comma
id|numskipped
suffix:semicolon
id|header
op_assign
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
id|buffer
suffix:semicolon
multiline_comment|/* Everything should be fine being passed into here, but we sanity */
multiline_comment|/*  check JIC */
r_if
c_cond
(paren
id|header-&gt;bLength
OG
id|size
)paren
(brace
id|err
c_func
(paren
l_string|&quot;ran out of descriptors parsing&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|header-&gt;bDescriptorType
op_ne
id|USB_DT_ENDPOINT
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;unexpected descriptor 0x%X, expecting endpoint descriptor, type 0x%X&quot;
comma
id|endpoint-&gt;bDescriptorType
comma
id|USB_DT_ENDPOINT
)paren
suffix:semicolon
r_return
id|parsed
suffix:semicolon
)brace
r_if
c_cond
(paren
id|header-&gt;bLength
op_eq
id|USB_DT_ENDPOINT_AUDIO_SIZE
)paren
id|memcpy
c_func
(paren
id|endpoint
comma
id|buffer
comma
id|USB_DT_ENDPOINT_AUDIO_SIZE
)paren
suffix:semicolon
r_else
id|memcpy
c_func
(paren
id|endpoint
comma
id|buffer
comma
id|USB_DT_ENDPOINT_SIZE
)paren
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|endpoint-&gt;wMaxPacketSize
)paren
suffix:semicolon
id|buffer
op_add_assign
id|header-&gt;bLength
suffix:semicolon
id|size
op_sub_assign
id|header-&gt;bLength
suffix:semicolon
id|parsed
op_add_assign
id|header-&gt;bLength
suffix:semicolon
multiline_comment|/* Skip over the rest of the Class Specific or Vendor Specific */
multiline_comment|/*  descriptors */
id|begin
op_assign
id|buffer
suffix:semicolon
id|numskipped
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|size
op_ge
r_sizeof
(paren
r_struct
id|usb_descriptor_header
)paren
)paren
(brace
id|header
op_assign
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;bLength
OL
l_int|2
)paren
(brace
id|err
c_func
(paren
l_string|&quot;invalid descriptor length of %d&quot;
comma
id|header-&gt;bLength
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If we find another descriptor which is at or below us */
multiline_comment|/*  in the descriptor heirarchy then we&squot;re done  */
r_if
c_cond
(paren
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_ENDPOINT
)paren
op_logical_or
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_INTERFACE
)paren
op_logical_or
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_CONFIG
)paren
op_logical_or
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_DEVICE
)paren
)paren
r_break
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;skipping descriptor 0x%X&quot;
comma
id|header-&gt;bDescriptorType
)paren
suffix:semicolon
id|numskipped
op_increment
suffix:semicolon
id|buffer
op_add_assign
id|header-&gt;bLength
suffix:semicolon
id|size
op_sub_assign
id|header-&gt;bLength
suffix:semicolon
id|parsed
op_add_assign
id|header-&gt;bLength
suffix:semicolon
)brace
r_if
c_cond
(paren
id|numskipped
)paren
id|dbg
c_func
(paren
l_string|&quot;skipped %d class/vendor specific endpoint descriptors&quot;
comma
id|numskipped
)paren
suffix:semicolon
multiline_comment|/* Copy any unknown descriptors into a storage area for drivers */
multiline_comment|/*  to later parse */
id|len
op_assign
(paren
r_int
)paren
(paren
id|buffer
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
(brace
id|endpoint-&gt;extra
op_assign
l_int|NULL
suffix:semicolon
id|endpoint-&gt;extralen
op_assign
l_int|0
suffix:semicolon
r_return
id|parsed
suffix:semicolon
)brace
id|endpoint-&gt;extra
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|endpoint-&gt;extra
)paren
(brace
id|err
c_func
(paren
l_string|&quot;couldn&squot;t allocate memory for endpoint extra descriptors&quot;
)paren
suffix:semicolon
id|endpoint-&gt;extralen
op_assign
l_int|0
suffix:semicolon
r_return
id|parsed
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|endpoint-&gt;extra
comma
id|begin
comma
id|len
)paren
suffix:semicolon
id|endpoint-&gt;extralen
op_assign
id|len
suffix:semicolon
r_return
id|parsed
suffix:semicolon
)brace
DECL|function|usb_parse_interface
r_static
r_int
id|usb_parse_interface
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|usb_interface
op_star
id|interface
comma
r_int
r_char
op_star
id|buffer
comma
r_int
id|size
)paren
(brace
r_int
id|i
comma
id|len
comma
id|numskipped
comma
id|retval
comma
id|parsed
op_assign
l_int|0
suffix:semicolon
r_struct
id|usb_descriptor_header
op_star
id|header
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|ifp
suffix:semicolon
r_int
r_char
op_star
id|begin
suffix:semicolon
id|interface-&gt;act_altsetting
op_assign
l_int|0
suffix:semicolon
id|interface-&gt;num_altsetting
op_assign
l_int|0
suffix:semicolon
id|interface-&gt;max_altsetting
op_assign
id|USB_ALTSETTINGALLOC
suffix:semicolon
id|interface-&gt;altsetting
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|usb_interface_descriptor
)paren
op_star
id|interface-&gt;max_altsetting
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|interface-&gt;altsetting
)paren
(brace
id|err
c_func
(paren
l_string|&quot;couldn&squot;t kmalloc interface-&gt;altsetting&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|interface-&gt;num_altsetting
op_ge
id|interface-&gt;max_altsetting
)paren
(brace
r_void
op_star
id|ptr
suffix:semicolon
r_int
id|oldmas
suffix:semicolon
id|oldmas
op_assign
id|interface-&gt;max_altsetting
suffix:semicolon
id|interface-&gt;max_altsetting
op_add_assign
id|USB_ALTSETTINGALLOC
suffix:semicolon
r_if
c_cond
(paren
id|interface-&gt;max_altsetting
OG
id|USB_MAXALTSETTING
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;too many alternate settings (max %d)&quot;
comma
id|USB_MAXALTSETTING
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ptr
op_assign
id|interface-&gt;altsetting
suffix:semicolon
id|interface-&gt;altsetting
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|usb_interface_descriptor
)paren
op_star
id|interface-&gt;max_altsetting
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|interface-&gt;altsetting
)paren
(brace
id|err
c_func
(paren
l_string|&quot;couldn&squot;t kmalloc interface-&gt;altsetting&quot;
)paren
suffix:semicolon
id|interface-&gt;altsetting
op_assign
id|ptr
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|interface-&gt;altsetting
comma
id|ptr
comma
r_sizeof
(paren
r_struct
id|usb_interface_descriptor
)paren
op_star
id|oldmas
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
id|ifp
op_assign
id|interface-&gt;altsetting
op_plus
id|interface-&gt;num_altsetting
suffix:semicolon
id|interface-&gt;num_altsetting
op_increment
suffix:semicolon
id|memcpy
c_func
(paren
id|ifp
comma
id|buffer
comma
id|USB_DT_INTERFACE_SIZE
)paren
suffix:semicolon
multiline_comment|/* Skip over the interface */
id|buffer
op_add_assign
id|ifp-&gt;bLength
suffix:semicolon
id|parsed
op_add_assign
id|ifp-&gt;bLength
suffix:semicolon
id|size
op_sub_assign
id|ifp-&gt;bLength
suffix:semicolon
id|begin
op_assign
id|buffer
suffix:semicolon
id|numskipped
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Skip over any interface, class or vendor descriptors */
r_while
c_loop
(paren
id|size
op_ge
r_sizeof
(paren
r_struct
id|usb_descriptor_header
)paren
)paren
(brace
id|header
op_assign
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;bLength
OL
l_int|2
)paren
(brace
id|err
c_func
(paren
l_string|&quot;invalid descriptor length of %d&quot;
comma
id|header-&gt;bLength
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If we find another descriptor which is at or below */
multiline_comment|/*  us in the descriptor heirarchy then return */
r_if
c_cond
(paren
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_INTERFACE
)paren
op_logical_or
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_ENDPOINT
)paren
op_logical_or
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_CONFIG
)paren
op_logical_or
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_DEVICE
)paren
)paren
r_break
suffix:semicolon
id|numskipped
op_increment
suffix:semicolon
id|buffer
op_add_assign
id|header-&gt;bLength
suffix:semicolon
id|parsed
op_add_assign
id|header-&gt;bLength
suffix:semicolon
id|size
op_sub_assign
id|header-&gt;bLength
suffix:semicolon
)brace
r_if
c_cond
(paren
id|numskipped
)paren
id|dbg
c_func
(paren
l_string|&quot;skipped %d class/vendor specific interface descriptors&quot;
comma
id|numskipped
)paren
suffix:semicolon
multiline_comment|/* Copy any unknown descriptors into a storage area for */
multiline_comment|/*  drivers to later parse */
id|len
op_assign
(paren
r_int
)paren
(paren
id|buffer
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
(brace
id|ifp-&gt;extra
op_assign
l_int|NULL
suffix:semicolon
id|ifp-&gt;extralen
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ifp-&gt;extra
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ifp-&gt;extra
)paren
(brace
id|err
c_func
(paren
l_string|&quot;couldn&squot;t allocate memory for interface extra descriptors&quot;
)paren
suffix:semicolon
id|ifp-&gt;extralen
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|ifp-&gt;extra
comma
id|begin
comma
id|len
)paren
suffix:semicolon
id|ifp-&gt;extralen
op_assign
id|len
suffix:semicolon
)brace
multiline_comment|/* Did we hit an unexpected descriptor? */
id|header
op_assign
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
(paren
id|size
op_ge
r_sizeof
(paren
r_struct
id|usb_descriptor_header
)paren
)paren
op_logical_and
(paren
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_CONFIG
)paren
op_logical_or
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_DEVICE
)paren
)paren
)paren
r_return
id|parsed
suffix:semicolon
r_if
c_cond
(paren
id|ifp-&gt;bNumEndpoints
OG
id|USB_MAXENDPOINTS
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;too many endpoints&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ifp-&gt;endpoint
op_assign
(paren
r_struct
id|usb_endpoint_descriptor
op_star
)paren
id|kmalloc
c_func
(paren
id|ifp-&gt;bNumEndpoints
op_star
r_sizeof
(paren
r_struct
id|usb_endpoint_descriptor
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ifp-&gt;endpoint
)paren
(brace
id|err
c_func
(paren
l_string|&quot;out of memory&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ifp-&gt;endpoint
comma
l_int|0
comma
id|ifp-&gt;bNumEndpoints
op_star
r_sizeof
(paren
r_struct
id|usb_endpoint_descriptor
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ifp-&gt;bNumEndpoints
suffix:semicolon
id|i
op_increment
)paren
(brace
id|header
op_assign
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;bLength
OG
id|size
)paren
(brace
id|err
c_func
(paren
l_string|&quot;ran out of descriptors parsing&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|retval
op_assign
id|usb_parse_endpoint
c_func
(paren
id|dev
comma
id|ifp-&gt;endpoint
op_plus
id|i
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_return
id|retval
suffix:semicolon
id|buffer
op_add_assign
id|retval
suffix:semicolon
id|parsed
op_add_assign
id|retval
suffix:semicolon
id|size
op_sub_assign
id|retval
suffix:semicolon
)brace
multiline_comment|/* We check to see if it&squot;s an alternate to this one */
id|ifp
op_assign
(paren
r_struct
id|usb_interface_descriptor
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
id|USB_DT_INTERFACE_SIZE
op_logical_or
id|ifp-&gt;bDescriptorType
op_ne
id|USB_DT_INTERFACE
op_logical_or
op_logical_neg
id|ifp-&gt;bAlternateSetting
)paren
r_return
id|parsed
suffix:semicolon
)brace
r_return
id|parsed
suffix:semicolon
)brace
DECL|function|usb_parse_configuration
r_int
id|usb_parse_configuration
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|usb_config_descriptor
op_star
id|config
comma
r_char
op_star
id|buffer
)paren
(brace
r_int
id|i
comma
id|retval
comma
id|size
suffix:semicolon
r_struct
id|usb_descriptor_header
op_star
id|header
suffix:semicolon
id|memcpy
c_func
(paren
id|config
comma
id|buffer
comma
id|USB_DT_CONFIG_SIZE
)paren
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|config-&gt;wTotalLength
)paren
suffix:semicolon
id|size
op_assign
id|config-&gt;wTotalLength
suffix:semicolon
r_if
c_cond
(paren
id|config-&gt;bNumInterfaces
OG
id|USB_MAXINTERFACES
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;too many interfaces&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|config-&gt;interface
op_assign
(paren
r_struct
id|usb_interface
op_star
)paren
id|kmalloc
c_func
(paren
id|config-&gt;bNumInterfaces
op_star
r_sizeof
(paren
r_struct
id|usb_interface
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;kmalloc IF %p, numif %i&quot;
comma
id|config-&gt;interface
comma
id|config-&gt;bNumInterfaces
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|config-&gt;interface
)paren
(brace
id|err
c_func
(paren
l_string|&quot;out of memory&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|config-&gt;interface
comma
l_int|0
comma
id|config-&gt;bNumInterfaces
op_star
r_sizeof
(paren
r_struct
id|usb_interface
)paren
)paren
suffix:semicolon
id|buffer
op_add_assign
id|config-&gt;bLength
suffix:semicolon
id|size
op_sub_assign
id|config-&gt;bLength
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|config-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|numskipped
comma
id|len
suffix:semicolon
r_char
op_star
id|begin
suffix:semicolon
multiline_comment|/* Skip over the rest of the Class Specific or Vendor */
multiline_comment|/*  Specific descriptors */
id|begin
op_assign
id|buffer
suffix:semicolon
id|numskipped
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|size
op_ge
r_sizeof
(paren
r_struct
id|usb_descriptor_header
)paren
)paren
(brace
id|header
op_assign
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
(paren
id|header-&gt;bLength
OG
id|size
)paren
op_logical_or
(paren
id|header-&gt;bLength
OL
l_int|2
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;invalid descriptor length of %d&quot;
comma
id|header-&gt;bLength
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If we find another descriptor which is at or below */
multiline_comment|/*  us in the descriptor heirarchy then we&squot;re done  */
r_if
c_cond
(paren
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_ENDPOINT
)paren
op_logical_or
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_INTERFACE
)paren
op_logical_or
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_CONFIG
)paren
op_logical_or
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_DEVICE
)paren
)paren
r_break
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;skipping descriptor 0x%X&quot;
comma
id|header-&gt;bDescriptorType
)paren
suffix:semicolon
id|numskipped
op_increment
suffix:semicolon
id|buffer
op_add_assign
id|header-&gt;bLength
suffix:semicolon
id|size
op_sub_assign
id|header-&gt;bLength
suffix:semicolon
)brace
r_if
c_cond
(paren
id|numskipped
)paren
id|dbg
c_func
(paren
l_string|&quot;skipped %d class/vendor specific endpoint descriptors&quot;
comma
id|numskipped
)paren
suffix:semicolon
multiline_comment|/* Copy any unknown descriptors into a storage area for */
multiline_comment|/*  drivers to later parse */
id|len
op_assign
(paren
r_int
)paren
(paren
id|buffer
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
(brace
id|config-&gt;extra
op_assign
l_int|NULL
suffix:semicolon
id|config-&gt;extralen
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|config-&gt;extra
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|config-&gt;extra
)paren
(brace
id|err
c_func
(paren
l_string|&quot;couldn&squot;t allocate memory for config extra descriptors&quot;
)paren
suffix:semicolon
id|config-&gt;extralen
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|config-&gt;extra
comma
id|begin
comma
id|len
)paren
suffix:semicolon
id|config-&gt;extralen
op_assign
id|len
suffix:semicolon
)brace
id|retval
op_assign
id|usb_parse_interface
c_func
(paren
id|dev
comma
id|config-&gt;interface
op_plus
id|i
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_return
id|retval
suffix:semicolon
id|buffer
op_add_assign
id|retval
suffix:semicolon
id|size
op_sub_assign
id|retval
suffix:semicolon
)brace
r_return
id|size
suffix:semicolon
)brace
DECL|function|usb_destroy_configuration
r_void
id|usb_destroy_configuration
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|c
comma
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;config
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;rawdescriptors
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;descriptor.bNumConfigurations
suffix:semicolon
id|i
op_increment
)paren
id|kfree
c_func
(paren
id|dev-&gt;rawdescriptors
(braket
id|i
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev-&gt;rawdescriptors
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
OL
id|dev-&gt;descriptor.bNumConfigurations
suffix:semicolon
id|c
op_increment
)paren
(brace
r_struct
id|usb_config_descriptor
op_star
id|cf
op_assign
op_amp
id|dev-&gt;config
(braket
id|c
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cf-&gt;interface
)paren
r_break
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cf-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_interface
op_star
id|ifp
op_assign
op_amp
id|cf-&gt;interface
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ifp-&gt;altsetting
)paren
r_break
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ifp-&gt;num_altsetting
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|usb_interface_descriptor
op_star
id|as
op_assign
op_amp
id|ifp-&gt;altsetting
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|as-&gt;extra
)paren
(brace
id|kfree
c_func
(paren
id|as-&gt;extra
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|as-&gt;endpoint
)paren
r_break
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|as-&gt;bNumEndpoints
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
id|as-&gt;endpoint
(braket
id|k
)braket
dot
id|extra
)paren
(brace
id|kfree
c_func
(paren
id|as-&gt;endpoint
(braket
id|k
)braket
dot
id|extra
)paren
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|as-&gt;endpoint
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|ifp-&gt;altsetting
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|cf-&gt;interface
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|dev-&gt;config
)paren
suffix:semicolon
)brace
multiline_comment|/* for returning string descriptors in UTF-16LE */
DECL|function|ascii2utf
r_static
r_int
id|ascii2utf
(paren
r_char
op_star
id|ascii
comma
id|__u8
op_star
id|utf
comma
r_int
id|utfmax
)paren
(brace
r_int
id|retval
suffix:semicolon
r_for
c_loop
(paren
id|retval
op_assign
l_int|0
suffix:semicolon
op_star
id|ascii
op_logical_and
id|utfmax
OG
l_int|1
suffix:semicolon
id|utfmax
op_sub_assign
l_int|2
comma
id|retval
op_add_assign
l_int|2
)paren
(brace
op_star
id|utf
op_increment
op_assign
op_star
id|ascii
op_increment
op_amp
l_int|0x7f
suffix:semicolon
op_star
id|utf
op_increment
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * root_hub_string is used by each host controller&squot;s root hub code,&n; * so that they&squot;re identified consistently throughout the system.&n; */
DECL|function|usb_root_hub_string
r_int
id|usb_root_hub_string
(paren
r_int
id|id
comma
r_int
id|serial
comma
r_char
op_star
id|type
comma
id|__u8
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_char
id|buf
(braket
l_int|30
)braket
suffix:semicolon
singleline_comment|// assert (len &gt; (2 * (sizeof (buf) + 1)));
singleline_comment|// assert (strlen (type) &lt;= 8);
singleline_comment|// language ids
r_if
c_cond
(paren
id|id
op_eq
l_int|0
)paren
(brace
op_star
id|data
op_increment
op_assign
l_int|4
suffix:semicolon
op_star
id|data
op_increment
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* 4 bytes data */
op_star
id|data
op_increment
op_assign
l_int|0
suffix:semicolon
op_star
id|data
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* some language id */
r_return
l_int|4
suffix:semicolon
singleline_comment|// serial number
)brace
r_else
r_if
c_cond
(paren
id|id
op_eq
l_int|1
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;%x&quot;
comma
id|serial
)paren
suffix:semicolon
singleline_comment|// product description
)brace
r_else
r_if
c_cond
(paren
id|id
op_eq
l_int|2
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;USB %s Root Hub&quot;
comma
id|type
)paren
suffix:semicolon
singleline_comment|// id 3 == vendor description
singleline_comment|// unsupported IDs --&gt; &quot;stall&quot;
)brace
r_else
r_return
l_int|0
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
l_int|2
op_plus
id|ascii2utf
(paren
id|buf
comma
id|data
op_plus
l_int|2
comma
id|len
op_minus
l_int|2
)paren
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
l_int|3
suffix:semicolon
r_return
id|data
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * __usb_get_extra_descriptor() finds a descriptor of specific type in the&n; * extra field of the interface and endpoint descriptor structs.&n; */
DECL|function|__usb_get_extra_descriptor
r_int
id|__usb_get_extra_descriptor
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|size
comma
r_int
r_char
id|type
comma
r_void
op_star
op_star
id|ptr
)paren
(brace
r_struct
id|usb_descriptor_header
op_star
id|header
suffix:semicolon
r_while
c_loop
(paren
id|size
op_ge
r_sizeof
(paren
r_struct
id|usb_descriptor_header
)paren
)paren
(brace
id|header
op_assign
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;bLength
OL
l_int|2
)paren
(brace
id|err
c_func
(paren
l_string|&quot;invalid descriptor length of %d&quot;
comma
id|header-&gt;bLength
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|header-&gt;bDescriptorType
op_eq
id|type
)paren
(brace
op_star
id|ptr
op_assign
id|header
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|buffer
op_add_assign
id|header-&gt;bLength
suffix:semicolon
id|size
op_sub_assign
id|header-&gt;bLength
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Something got disconnected. Get rid of it, and all of its children.&n; */
DECL|function|usb_disconnect
r_void
id|usb_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
op_star
id|pdev
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
op_star
id|pdev
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
suffix:semicolon
op_star
id|pdev
op_assign
l_int|NULL
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;USB disconnect on device %d&quot;
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;actconfig
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;actconfig-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_interface
op_star
id|interface
op_assign
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
suffix:semicolon
r_struct
id|usb_driver
op_star
id|driver
op_assign
id|interface-&gt;driver
suffix:semicolon
r_if
c_cond
(paren
id|driver
)paren
(brace
id|down
c_func
(paren
op_amp
id|driver-&gt;serialize
)paren
suffix:semicolon
id|driver
op_member_access_from_pointer
id|disconnect
c_func
(paren
id|dev
comma
id|interface-&gt;private_data
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|driver-&gt;serialize
)paren
suffix:semicolon
id|usb_driver_release_interface
c_func
(paren
id|driver
comma
id|interface
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Free up all the children.. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USB_MAXCHILDREN
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_device
op_star
op_star
id|child
op_assign
id|dev-&gt;children
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_star
id|child
)paren
id|usb_disconnect
c_func
(paren
id|child
)paren
suffix:semicolon
)brace
multiline_comment|/* Let policy agent unload modules etc */
id|call_policy
(paren
l_string|&quot;remove&quot;
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* Free the device number and remove the /proc/bus/usb entry */
r_if
c_cond
(paren
id|dev-&gt;devnum
OG
l_int|0
)paren
(brace
id|clear_bit
c_func
(paren
id|dev-&gt;devnum
comma
op_amp
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|usbdevfs_remove_device
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Free up the device itself */
id|usb_free_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Connect a new USB device. This basically just initializes&n; * the USB device information and sets up the topology - it&squot;s&n; * up to the low-level driver to reset the port and actually&n; * do the setup (the upper levels don&squot;t know how to do that).&n; */
DECL|function|usb_connect
r_void
id|usb_connect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|devnum
suffix:semicolon
singleline_comment|// FIXME needs locking for SMP!!
multiline_comment|/* why? this is called only from the hub thread, &n;&t; * which hopefully doesn&squot;t run on multiple CPU&squot;s simultaneously 8-)&n;&t; */
id|dev-&gt;descriptor.bMaxPacketSize0
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* Start off at 8 bytes  */
macro_line|#ifndef DEVNUM_ROUND_ROBIN
id|devnum
op_assign
id|find_next_zero_bit
c_func
(paren
id|dev-&gt;bus-&gt;devmap.devicemap
comma
l_int|128
comma
l_int|1
)paren
suffix:semicolon
macro_line|#else&t;/* round_robin alloc of devnums */
multiline_comment|/* Try to allocate the next devnum beginning at devnum_next. */
id|devnum
op_assign
id|find_next_zero_bit
c_func
(paren
id|dev-&gt;bus-&gt;devmap.devicemap
comma
l_int|128
comma
id|devnum_next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devnum
op_ge
l_int|128
)paren
id|devnum
op_assign
id|find_next_zero_bit
c_func
(paren
id|dev-&gt;bus-&gt;devmap.devicemap
comma
l_int|128
comma
l_int|1
)paren
suffix:semicolon
id|devnum_next
op_assign
id|devnum
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|devnum_next
op_ge
l_int|128
)paren
id|devnum_next
op_assign
l_int|1
suffix:semicolon
macro_line|#endif&t;/* round_robin alloc of devnums */
r_if
c_cond
(paren
id|devnum
OL
l_int|128
)paren
(brace
id|set_bit
c_func
(paren
id|devnum
comma
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
id|devnum
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * These are the actual routines to send&n; * and receive control messages.&n; */
DECL|macro|GET_TIMEOUT
mdefine_line|#define GET_TIMEOUT 3
DECL|macro|SET_TIMEOUT
mdefine_line|#define SET_TIMEOUT 3
DECL|function|usb_set_address
r_int
id|usb_set_address
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_snddefctrl
c_func
(paren
id|dev
)paren
comma
id|USB_REQ_SET_ADDRESS
comma
l_int|0
comma
id|dev-&gt;devnum
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
id|GET_TIMEOUT
)paren
suffix:semicolon
)brace
DECL|function|usb_get_descriptor
r_int
id|usb_get_descriptor
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_char
id|type
comma
r_int
r_char
id|index
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_int
id|i
op_assign
l_int|5
suffix:semicolon
r_int
id|result
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
singleline_comment|// Make sure we parse really received data
r_while
c_loop
(paren
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_DESCRIPTOR
comma
id|USB_DIR_IN
comma
(paren
id|type
op_lshift
l_int|8
)paren
op_plus
id|index
comma
l_int|0
comma
id|buf
comma
id|size
comma
id|HZ
op_star
id|GET_TIMEOUT
)paren
)paren
OG
l_int|0
op_logical_or
id|result
op_eq
op_minus
id|EPIPE
)paren
r_break
suffix:semicolon
multiline_comment|/* retry if the returned length was 0; flaky device */
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|usb_get_class_descriptor
r_int
id|usb_get_class_descriptor
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
comma
r_int
r_char
id|type
comma
r_int
r_char
id|id
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_DESCRIPTOR
comma
id|USB_RECIP_INTERFACE
op_or
id|USB_DIR_IN
comma
(paren
id|type
op_lshift
l_int|8
)paren
op_plus
id|id
comma
id|ifnum
comma
id|buf
comma
id|size
comma
id|HZ
op_star
id|GET_TIMEOUT
)paren
suffix:semicolon
)brace
DECL|function|usb_get_string
r_int
id|usb_get_string
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|langid
comma
r_int
r_char
id|index
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_DESCRIPTOR
comma
id|USB_DIR_IN
comma
(paren
id|USB_DT_STRING
op_lshift
l_int|8
)paren
op_plus
id|index
comma
id|langid
comma
id|buf
comma
id|size
comma
id|HZ
op_star
id|GET_TIMEOUT
)paren
suffix:semicolon
)brace
DECL|function|usb_get_device_descriptor
r_int
id|usb_get_device_descriptor
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|ret
op_assign
id|usb_get_descriptor
c_func
(paren
id|dev
comma
id|USB_DT_DEVICE
comma
l_int|0
comma
op_amp
id|dev-&gt;descriptor
comma
r_sizeof
(paren
id|dev-&gt;descriptor
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
(brace
id|le16_to_cpus
c_func
(paren
op_amp
id|dev-&gt;descriptor.bcdUSB
)paren
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|dev-&gt;descriptor.idVendor
)paren
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|dev-&gt;descriptor.idProduct
)paren
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|dev-&gt;descriptor.bcdDevice
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|usb_get_status
r_int
id|usb_get_status
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|type
comma
r_int
id|target
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_STATUS
comma
id|USB_DIR_IN
op_or
id|type
comma
l_int|0
comma
id|target
comma
id|data
comma
l_int|2
comma
id|HZ
op_star
id|GET_TIMEOUT
)paren
suffix:semicolon
)brace
DECL|function|usb_get_protocol
r_int
id|usb_get_protocol
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
)paren
(brace
r_int
r_char
id|type
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_PROTOCOL
comma
id|USB_DIR_IN
op_or
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|ifnum
comma
op_amp
id|type
comma
l_int|1
comma
id|HZ
op_star
id|GET_TIMEOUT
)paren
)paren
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_return
id|type
suffix:semicolon
)brace
DECL|function|usb_set_protocol
r_int
id|usb_set_protocol
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
comma
r_int
id|protocol
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_SET_PROTOCOL
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
id|protocol
comma
id|ifnum
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
id|SET_TIMEOUT
)paren
suffix:semicolon
)brace
DECL|function|usb_set_idle
r_int
id|usb_set_idle
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
comma
r_int
id|duration
comma
r_int
id|report_id
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_SET_IDLE
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
(paren
id|duration
op_lshift
l_int|8
)paren
op_or
id|report_id
comma
id|ifnum
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
id|SET_TIMEOUT
)paren
suffix:semicolon
)brace
DECL|function|usb_set_maxpacket
r_void
id|usb_set_maxpacket
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|i
comma
id|b
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;actconfig-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_interface
op_star
id|ifp
op_assign
id|dev-&gt;actconfig-&gt;interface
op_plus
id|i
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|as
op_assign
id|ifp-&gt;altsetting
op_plus
id|ifp-&gt;act_altsetting
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep
op_assign
id|as-&gt;endpoint
suffix:semicolon
r_int
id|e
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
l_int|0
suffix:semicolon
id|e
OL
id|as-&gt;bNumEndpoints
suffix:semicolon
id|e
op_increment
)paren
(brace
id|b
op_assign
id|ep
(braket
id|e
)braket
dot
id|bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ep
(braket
id|e
)braket
dot
id|bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_eq
id|USB_ENDPOINT_XFER_CONTROL
)paren
(brace
multiline_comment|/* Control =&gt; bidirectional */
id|dev-&gt;epmaxpacketout
(braket
id|b
)braket
op_assign
id|ep
(braket
id|e
)braket
dot
id|wMaxPacketSize
suffix:semicolon
id|dev-&gt;epmaxpacketin
(braket
id|b
)braket
op_assign
id|ep
(braket
id|e
)braket
dot
id|wMaxPacketSize
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|usb_endpoint_out
c_func
(paren
id|ep
(braket
id|e
)braket
dot
id|bEndpointAddress
)paren
)paren
(brace
r_if
c_cond
(paren
id|ep
(braket
id|e
)braket
dot
id|wMaxPacketSize
OG
id|dev-&gt;epmaxpacketout
(braket
id|b
)braket
)paren
id|dev-&gt;epmaxpacketout
(braket
id|b
)braket
op_assign
id|ep
(braket
id|e
)braket
dot
id|wMaxPacketSize
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ep
(braket
id|e
)braket
dot
id|wMaxPacketSize
OG
id|dev-&gt;epmaxpacketin
(braket
id|b
)braket
)paren
id|dev-&gt;epmaxpacketin
(braket
id|b
)braket
op_assign
id|ep
(braket
id|e
)braket
dot
id|wMaxPacketSize
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * endp: endpoint number in bits 0-3;&n; *&t;direction flag in bit 7 (1 = IN, 0 = OUT)&n; */
DECL|function|usb_clear_halt
r_int
id|usb_clear_halt
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|pipe
)paren
(brace
r_int
id|result
suffix:semicolon
id|__u16
id|status
suffix:semicolon
r_int
id|endp
op_assign
id|usb_pipeendpoint
c_func
(paren
id|pipe
)paren
op_or
(paren
id|usb_pipein
c_func
(paren
id|pipe
)paren
op_lshift
l_int|7
)paren
suffix:semicolon
multiline_comment|/*&n;&t;if (!usb_endpoint_halted(dev, endp &amp; 0x0f, usb_endpoint_out(endp)))&n;&t;&t;return 0;&n;*/
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_CLEAR_FEATURE
comma
id|USB_RECIP_ENDPOINT
comma
l_int|0
comma
id|endp
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
id|SET_TIMEOUT
)paren
suffix:semicolon
multiline_comment|/* don&squot;t clear if failed */
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_STATUS
comma
id|USB_DIR_IN
op_or
id|USB_RECIP_ENDPOINT
comma
l_int|0
comma
id|endp
comma
op_amp
id|status
comma
r_sizeof
(paren
id|status
)paren
comma
id|HZ
op_star
id|SET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|status
)paren
op_amp
l_int|1
)paren
r_return
op_minus
id|EPIPE
suffix:semicolon
multiline_comment|/* still halted */
id|usb_endpoint_running
c_func
(paren
id|dev
comma
id|usb_pipeendpoint
c_func
(paren
id|pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
)paren
suffix:semicolon
multiline_comment|/* toggle is reset on clear */
id|usb_settoggle
c_func
(paren
id|dev
comma
id|usb_pipeendpoint
c_func
(paren
id|pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_set_interface
r_int
id|usb_set_interface
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|interface
comma
r_int
id|alternate
)paren
(brace
r_struct
id|usb_interface
op_star
id|iface
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|iface
op_assign
id|usb_ifnum_to_if
c_func
(paren
id|dev
comma
id|interface
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iface
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;selecting invalid interface %d&quot;
comma
id|interface
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_SET_INTERFACE
comma
id|USB_RECIP_INTERFACE
comma
id|alternate
comma
id|interface
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
l_int|5
)paren
)paren
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|iface-&gt;act_altsetting
op_assign
id|alternate
suffix:semicolon
id|dev-&gt;toggle
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 9.1.1.5 says to do this */
id|dev-&gt;toggle
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|usb_set_maxpacket
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_set_configuration
r_int
id|usb_set_configuration
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|configuration
)paren
(brace
r_int
id|i
comma
id|ret
suffix:semicolon
r_struct
id|usb_config_descriptor
op_star
id|cp
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;descriptor.bNumConfigurations
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;config
(braket
id|i
)braket
dot
id|bConfigurationValue
op_eq
id|configuration
)paren
(brace
id|cp
op_assign
op_amp
id|dev-&gt;config
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;selecting invalid configuration %d&quot;
comma
id|configuration
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_SET_CONFIGURATION
comma
l_int|0
comma
id|configuration
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
id|SET_TIMEOUT
)paren
)paren
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|dev-&gt;actconfig
op_assign
id|cp
suffix:semicolon
id|dev-&gt;toggle
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;toggle
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|usb_set_maxpacket
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_get_report
r_int
id|usb_get_report
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
comma
r_int
r_char
id|type
comma
r_int
r_char
id|id
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_REPORT
comma
id|USB_DIR_IN
op_or
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
(paren
id|type
op_lshift
l_int|8
)paren
op_plus
id|id
comma
id|ifnum
comma
id|buf
comma
id|size
comma
id|HZ
op_star
id|GET_TIMEOUT
)paren
suffix:semicolon
)brace
DECL|function|usb_set_report
r_int
id|usb_set_report
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
comma
r_int
r_char
id|type
comma
r_int
r_char
id|id
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_SET_REPORT
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
(paren
id|type
op_lshift
l_int|8
)paren
op_plus
id|id
comma
id|ifnum
comma
id|buf
comma
id|size
comma
id|HZ
)paren
suffix:semicolon
)brace
DECL|function|usb_get_configuration
r_int
id|usb_get_configuration
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_int
id|cfgno
comma
id|length
suffix:semicolon
r_int
r_char
id|buffer
(braket
l_int|8
)braket
suffix:semicolon
r_int
r_char
op_star
id|bigbuffer
suffix:semicolon
r_struct
id|usb_config_descriptor
op_star
id|desc
op_assign
(paren
r_struct
id|usb_config_descriptor
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.bNumConfigurations
OG
id|USB_MAXCONFIG
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;too many configurations&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;descriptor.bNumConfigurations
OL
l_int|1
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;not enough configurations&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev-&gt;config
op_assign
(paren
r_struct
id|usb_config_descriptor
op_star
)paren
id|kmalloc
c_func
(paren
id|dev-&gt;descriptor.bNumConfigurations
op_star
r_sizeof
(paren
r_struct
id|usb_config_descriptor
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;config
)paren
(brace
id|err
c_func
(paren
l_string|&quot;out of memory&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev-&gt;config
comma
l_int|0
comma
id|dev-&gt;descriptor.bNumConfigurations
op_star
r_sizeof
(paren
r_struct
id|usb_config_descriptor
)paren
)paren
suffix:semicolon
id|dev-&gt;rawdescriptors
op_assign
(paren
r_char
op_star
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_char
op_star
)paren
op_star
id|dev-&gt;descriptor.bNumConfigurations
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;rawdescriptors
)paren
(brace
id|err
c_func
(paren
l_string|&quot;out of memory&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cfgno
op_assign
l_int|0
suffix:semicolon
id|cfgno
OL
id|dev-&gt;descriptor.bNumConfigurations
suffix:semicolon
id|cfgno
op_increment
)paren
(brace
multiline_comment|/* We grab the first 8 bytes so we know how long the whole */
multiline_comment|/*  configuration is */
id|result
op_assign
id|usb_get_descriptor
c_func
(paren
id|dev
comma
id|USB_DT_CONFIG
comma
id|cfgno
comma
id|buffer
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|8
)paren
(brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
id|err
c_func
(paren
l_string|&quot;unable to get descriptor&quot;
)paren
suffix:semicolon
r_else
(brace
id|err
c_func
(paren
l_string|&quot;config descriptor too short (expected %i, got %i)&quot;
comma
l_int|8
comma
id|result
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/* Get the full buffer */
id|length
op_assign
id|le16_to_cpu
c_func
(paren
id|desc-&gt;wTotalLength
)paren
suffix:semicolon
id|bigbuffer
op_assign
id|kmalloc
c_func
(paren
id|length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bigbuffer
)paren
(brace
id|err
c_func
(paren
l_string|&quot;unable to allocate memory for configuration descriptors&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/* Now that we know the length, get the whole thing */
id|result
op_assign
id|usb_get_descriptor
c_func
(paren
id|dev
comma
id|USB_DT_CONFIG
comma
id|cfgno
comma
id|bigbuffer
comma
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;couldn&squot;t get all of config descriptors&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|bigbuffer
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
OL
id|length
)paren
(brace
id|err
c_func
(paren
l_string|&quot;config descriptor too short (expected %i, got %i)&quot;
comma
id|length
comma
id|result
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|kfree
c_func
(paren
id|bigbuffer
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
id|dev-&gt;rawdescriptors
(braket
id|cfgno
)braket
op_assign
id|bigbuffer
suffix:semicolon
id|result
op_assign
id|usb_parse_configuration
c_func
(paren
id|dev
comma
op_amp
id|dev-&gt;config
(braket
id|cfgno
)braket
comma
id|bigbuffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OG
l_int|0
)paren
id|dbg
c_func
(paren
l_string|&quot;descriptor data left&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|result
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
id|err
suffix:colon
id|dev-&gt;descriptor.bNumConfigurations
op_assign
id|cfgno
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_string:&n; *&t;returns string length (&gt; 0) or error (&lt; 0)&n; */
DECL|function|usb_string
r_int
id|usb_string
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|index
comma
r_char
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_int
r_char
op_star
id|tbuf
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
r_int
id|u
comma
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|size
op_le
l_int|0
op_logical_or
op_logical_neg
id|buf
op_logical_or
op_logical_neg
id|index
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|tbuf
op_assign
id|kmalloc
c_func
(paren
l_int|256
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* get langid for strings if it&squot;s not yet known */
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;have_langid
)paren
(brace
id|err
op_assign
id|usb_get_string
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0
comma
id|tbuf
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;error getting string descriptor 0 (error=%d)&quot;
comma
id|err
)paren
suffix:semicolon
r_goto
id|errout
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tbuf
(braket
l_int|0
)braket
OL
l_int|4
)paren
(brace
id|err
c_func
(paren
l_string|&quot;string descriptor 0 too short&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|errout
suffix:semicolon
)brace
r_else
(brace
id|dev-&gt;have_langid
op_assign
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;string_langid
op_assign
id|tbuf
(braket
l_int|2
)braket
op_or
(paren
id|tbuf
(braket
l_int|3
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* always use the first langid listed */
id|dbg
c_func
(paren
l_string|&quot;USB device number %d default language ID 0x%x&quot;
comma
id|dev-&gt;devnum
comma
id|dev-&gt;string_langid
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Just ask for a maximum length string and then take the length&n;&t; * that was returned.&n;&t; */
id|err
op_assign
id|usb_get_string
c_func
(paren
id|dev
comma
id|dev-&gt;string_langid
comma
id|index
comma
id|tbuf
comma
l_int|255
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|errout
suffix:semicolon
id|size
op_decrement
suffix:semicolon
multiline_comment|/* leave room for trailing NULL char in output buffer */
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
comma
id|u
op_assign
l_int|2
suffix:semicolon
id|u
OL
id|err
suffix:semicolon
id|u
op_add_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|idx
op_ge
id|size
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|tbuf
(braket
id|u
op_plus
l_int|1
)braket
)paren
multiline_comment|/* high byte */
id|buf
(braket
id|idx
op_increment
)braket
op_assign
l_char|&squot;?&squot;
suffix:semicolon
multiline_comment|/* non-ASCII character */
r_else
id|buf
(braket
id|idx
op_increment
)braket
op_assign
id|tbuf
(braket
id|u
)braket
suffix:semicolon
)brace
id|buf
(braket
id|idx
)braket
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|idx
suffix:semicolon
id|errout
suffix:colon
id|kfree
c_func
(paren
id|tbuf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * By the time we get here, the device has gotten a new device ID&n; * and is in the default state. We need to identify the thing and&n; * get the ball rolling..&n; *&n; * Returns 0 for success, != 0 for error.&n; */
DECL|function|usb_new_device
r_int
id|usb_new_device
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|err
suffix:semicolon
multiline_comment|/* USB v1.1 5.5.3 */
multiline_comment|/* We read the first 8 bytes from the device descriptor to get to */
multiline_comment|/*  the bMaxPacketSize0 field. Then we set the maximum packet size */
multiline_comment|/*  for the control pipe, and retrieve the rest */
id|dev-&gt;epmaxpacketin
(braket
l_int|0
)braket
op_assign
l_int|8
suffix:semicolon
id|dev-&gt;epmaxpacketout
(braket
l_int|0
)braket
op_assign
l_int|8
suffix:semicolon
id|err
op_assign
id|usb_set_address
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;USB device not accepting new address=%d (error=%d)&quot;
comma
id|dev-&gt;devnum
comma
id|err
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|dev-&gt;devnum
comma
op_amp
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|wait_ms
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Let the SET_ADDRESS settle */
id|err
op_assign
id|usb_get_descriptor
c_func
(paren
id|dev
comma
id|USB_DT_DEVICE
comma
l_int|0
comma
op_amp
id|dev-&gt;descriptor
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|8
)paren
(brace
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
id|err
c_func
(paren
l_string|&quot;USB device not responding, giving up (error=%d)&quot;
comma
id|err
)paren
suffix:semicolon
r_else
id|err
c_func
(paren
l_string|&quot;USB device descriptor short read (expected %i, got %i)&quot;
comma
l_int|8
comma
id|err
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|dev-&gt;devnum
comma
op_amp
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dev-&gt;epmaxpacketin
(braket
l_int|0
)braket
op_assign
id|dev-&gt;descriptor.bMaxPacketSize0
suffix:semicolon
id|dev-&gt;epmaxpacketout
(braket
l_int|0
)braket
op_assign
id|dev-&gt;descriptor.bMaxPacketSize0
suffix:semicolon
id|err
op_assign
id|usb_get_device_descriptor
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
r_sizeof
(paren
id|dev-&gt;descriptor
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
id|err
c_func
(paren
l_string|&quot;unable to get device descriptor (error=%d)&quot;
comma
id|err
)paren
suffix:semicolon
r_else
id|err
c_func
(paren
l_string|&quot;USB device descriptor short read (expected %i, got %i)&quot;
comma
r_sizeof
(paren
id|dev-&gt;descriptor
)paren
comma
id|err
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|dev-&gt;devnum
comma
op_amp
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|err
op_assign
id|usb_get_configuration
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;unable to get device %d configuration (error=%d)&quot;
comma
id|dev-&gt;devnum
comma
id|err
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|dev-&gt;devnum
comma
op_amp
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
id|usb_free_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* we set the default configuration here */
id|err
op_assign
id|usb_set_configuration
c_func
(paren
id|dev
comma
id|dev-&gt;config
(braket
l_int|0
)braket
dot
id|bConfigurationValue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|err
c_func
(paren
l_string|&quot;failed to set device %d default configuration (error=%d)&quot;
comma
id|dev-&gt;devnum
comma
id|err
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|dev-&gt;devnum
comma
op_amp
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;new device strings: Mfr=%d, Product=%d, SerialNumber=%d&quot;
comma
id|dev-&gt;descriptor.iManufacturer
comma
id|dev-&gt;descriptor.iProduct
comma
id|dev-&gt;descriptor.iSerialNumber
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|dev-&gt;descriptor.iManufacturer
)paren
id|usb_show_string
c_func
(paren
id|dev
comma
l_string|&quot;Manufacturer&quot;
comma
id|dev-&gt;descriptor.iManufacturer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iProduct
)paren
id|usb_show_string
c_func
(paren
id|dev
comma
l_string|&quot;Product&quot;
comma
id|dev-&gt;descriptor.iProduct
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iSerialNumber
)paren
id|usb_show_string
c_func
(paren
id|dev
comma
l_string|&quot;SerialNumber&quot;
comma
id|dev-&gt;descriptor.iSerialNumber
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* now that the basic setup is over, add a /proc/bus/usb entry */
id|usbdevfs_add_device
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* find drivers willing to handle this device */
id|usb_find_drivers
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* userspace may load modules and/or configure further */
id|call_policy
(paren
l_string|&quot;add&quot;
comma
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_open
r_static
r_int
id|usb_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|usb_driver
op_star
id|c
op_assign
id|usb_minors
(braket
id|minor
op_div
l_int|16
)braket
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_struct
id|file_operations
op_star
id|old_fops
comma
op_star
id|new_fops
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * No load-on-demand? Randy, could you ACK that it&squot;s really not&n;&t; * supposed to be done?&t;&t;&t;&t;&t;-- AV&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|c
op_logical_or
op_logical_neg
(paren
id|new_fops
op_assign
id|fops_get
c_func
(paren
id|c-&gt;fops
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
id|old_fops
op_assign
id|file-&gt;f_op
suffix:semicolon
id|file-&gt;f_op
op_assign
id|new_fops
suffix:semicolon
multiline_comment|/* Curiouser and curiouser... NULL -&gt;open() as &quot;no device&quot; ? */
r_if
c_cond
(paren
id|file-&gt;f_op-&gt;open
)paren
id|err
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|open
c_func
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|fops_put
c_func
(paren
id|file-&gt;f_op
)paren
suffix:semicolon
id|file-&gt;f_op
op_assign
id|fops_get
c_func
(paren
id|old_fops
)paren
suffix:semicolon
)brace
id|fops_put
c_func
(paren
id|old_fops
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|usb_fops
r_static
r_struct
id|file_operations
id|usb_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|open
suffix:colon
id|usb_open
comma
)brace
suffix:semicolon
DECL|function|usb_major_init
r_int
id|usb_major_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|devfs_register_chrdev
c_func
(paren
id|USB_MAJOR
comma
l_string|&quot;usb&quot;
comma
op_amp
id|usb_fops
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;unable to get major %d for usb devices&quot;
comma
id|USB_MAJOR
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|usb_devfs_handle
op_assign
id|devfs_mk_dir
c_func
(paren
l_int|NULL
comma
l_string|&quot;usb&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_major_cleanup
r_void
id|usb_major_cleanup
c_func
(paren
r_void
)paren
(brace
id|devfs_unregister
c_func
(paren
id|usb_devfs_handle
)paren
suffix:semicolon
id|devfs_unregister_chrdev
c_func
(paren
id|USB_MAJOR
comma
l_string|&quot;usb&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|usb_driver_get_list
r_struct
id|list_head
op_star
id|usb_driver_get_list
c_func
(paren
r_void
)paren
(brace
r_return
op_amp
id|usb_driver_list
suffix:semicolon
)brace
DECL|function|usb_bus_get_list
r_struct
id|list_head
op_star
id|usb_bus_get_list
c_func
(paren
r_void
)paren
(brace
r_return
op_amp
id|usb_bus_list
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Init&n; */
DECL|function|usb_init
r_static
r_int
id|__init
id|usb_init
c_func
(paren
r_void
)paren
(brace
id|usb_major_init
c_func
(paren
)paren
suffix:semicolon
id|usbdevfs_init
c_func
(paren
)paren
suffix:semicolon
id|usb_hub_init
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Cleanup&n; */
DECL|function|usb_exit
r_static
r_void
id|__exit
id|usb_exit
c_func
(paren
r_void
)paren
(brace
id|usb_major_cleanup
c_func
(paren
)paren
suffix:semicolon
id|usbdevfs_cleanup
c_func
(paren
)paren
suffix:semicolon
id|usb_hub_cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|usb_init
id|module_init
c_func
(paren
id|usb_init
)paren
suffix:semicolon
DECL|variable|usb_exit
id|module_exit
c_func
(paren
id|usb_exit
)paren
suffix:semicolon
multiline_comment|/*&n; * USB may be built into the kernel or be built as modules.&n; * If the USB core [and maybe a host controller driver] is built&n; * into the kernel, and other device drivers are built as modules,&n; * then these symbols need to be exported for the modules to use.&n; */
DECL|variable|usb_ifnum_to_if
id|EXPORT_SYMBOL
c_func
(paren
id|usb_ifnum_to_if
)paren
suffix:semicolon
DECL|variable|usb_epnum_to_ep_desc
id|EXPORT_SYMBOL
c_func
(paren
id|usb_epnum_to_ep_desc
)paren
suffix:semicolon
DECL|variable|usb_register
id|EXPORT_SYMBOL
c_func
(paren
id|usb_register
)paren
suffix:semicolon
DECL|variable|usb_deregister
id|EXPORT_SYMBOL
c_func
(paren
id|usb_deregister
)paren
suffix:semicolon
DECL|variable|usb_scan_devices
id|EXPORT_SYMBOL
c_func
(paren
id|usb_scan_devices
)paren
suffix:semicolon
DECL|variable|usb_alloc_bus
id|EXPORT_SYMBOL
c_func
(paren
id|usb_alloc_bus
)paren
suffix:semicolon
DECL|variable|usb_free_bus
id|EXPORT_SYMBOL
c_func
(paren
id|usb_free_bus
)paren
suffix:semicolon
DECL|variable|usb_register_bus
id|EXPORT_SYMBOL
c_func
(paren
id|usb_register_bus
)paren
suffix:semicolon
DECL|variable|usb_deregister_bus
id|EXPORT_SYMBOL
c_func
(paren
id|usb_deregister_bus
)paren
suffix:semicolon
DECL|variable|usb_alloc_dev
id|EXPORT_SYMBOL
c_func
(paren
id|usb_alloc_dev
)paren
suffix:semicolon
DECL|variable|usb_free_dev
id|EXPORT_SYMBOL
c_func
(paren
id|usb_free_dev
)paren
suffix:semicolon
DECL|variable|usb_inc_dev_use
id|EXPORT_SYMBOL
c_func
(paren
id|usb_inc_dev_use
)paren
suffix:semicolon
DECL|variable|usb_driver_claim_interface
id|EXPORT_SYMBOL
c_func
(paren
id|usb_driver_claim_interface
)paren
suffix:semicolon
DECL|variable|usb_interface_claimed
id|EXPORT_SYMBOL
c_func
(paren
id|usb_interface_claimed
)paren
suffix:semicolon
DECL|variable|usb_driver_release_interface
id|EXPORT_SYMBOL
c_func
(paren
id|usb_driver_release_interface
)paren
suffix:semicolon
DECL|variable|usb_match_id
id|EXPORT_SYMBOL
c_func
(paren
id|usb_match_id
)paren
suffix:semicolon
DECL|variable|usb_root_hub_string
id|EXPORT_SYMBOL
c_func
(paren
id|usb_root_hub_string
)paren
suffix:semicolon
DECL|variable|usb_new_device
id|EXPORT_SYMBOL
c_func
(paren
id|usb_new_device
)paren
suffix:semicolon
DECL|variable|usb_reset_device
id|EXPORT_SYMBOL
c_func
(paren
id|usb_reset_device
)paren
suffix:semicolon
DECL|variable|usb_connect
id|EXPORT_SYMBOL
c_func
(paren
id|usb_connect
)paren
suffix:semicolon
DECL|variable|usb_disconnect
id|EXPORT_SYMBOL
c_func
(paren
id|usb_disconnect
)paren
suffix:semicolon
DECL|variable|usb_check_bandwidth
id|EXPORT_SYMBOL
c_func
(paren
id|usb_check_bandwidth
)paren
suffix:semicolon
DECL|variable|usb_claim_bandwidth
id|EXPORT_SYMBOL
c_func
(paren
id|usb_claim_bandwidth
)paren
suffix:semicolon
DECL|variable|usb_release_bandwidth
id|EXPORT_SYMBOL
c_func
(paren
id|usb_release_bandwidth
)paren
suffix:semicolon
DECL|variable|usb_set_address
id|EXPORT_SYMBOL
c_func
(paren
id|usb_set_address
)paren
suffix:semicolon
DECL|variable|usb_get_descriptor
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_descriptor
)paren
suffix:semicolon
DECL|variable|usb_get_class_descriptor
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_class_descriptor
)paren
suffix:semicolon
DECL|variable|__usb_get_extra_descriptor
id|EXPORT_SYMBOL
c_func
(paren
id|__usb_get_extra_descriptor
)paren
suffix:semicolon
DECL|variable|usb_get_device_descriptor
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_device_descriptor
)paren
suffix:semicolon
DECL|variable|usb_get_string
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_string
)paren
suffix:semicolon
DECL|variable|usb_string
id|EXPORT_SYMBOL
c_func
(paren
id|usb_string
)paren
suffix:semicolon
DECL|variable|usb_get_protocol
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_protocol
)paren
suffix:semicolon
DECL|variable|usb_set_protocol
id|EXPORT_SYMBOL
c_func
(paren
id|usb_set_protocol
)paren
suffix:semicolon
DECL|variable|usb_get_report
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_report
)paren
suffix:semicolon
DECL|variable|usb_set_report
id|EXPORT_SYMBOL
c_func
(paren
id|usb_set_report
)paren
suffix:semicolon
DECL|variable|usb_set_idle
id|EXPORT_SYMBOL
c_func
(paren
id|usb_set_idle
)paren
suffix:semicolon
DECL|variable|usb_clear_halt
id|EXPORT_SYMBOL
c_func
(paren
id|usb_clear_halt
)paren
suffix:semicolon
DECL|variable|usb_set_interface
id|EXPORT_SYMBOL
c_func
(paren
id|usb_set_interface
)paren
suffix:semicolon
DECL|variable|usb_get_configuration
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_configuration
)paren
suffix:semicolon
DECL|variable|usb_set_configuration
id|EXPORT_SYMBOL
c_func
(paren
id|usb_set_configuration
)paren
suffix:semicolon
DECL|variable|usb_get_current_frame_number
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_current_frame_number
)paren
suffix:semicolon
DECL|variable|usb_alloc_urb
id|EXPORT_SYMBOL
c_func
(paren
id|usb_alloc_urb
)paren
suffix:semicolon
DECL|variable|usb_free_urb
id|EXPORT_SYMBOL
c_func
(paren
id|usb_free_urb
)paren
suffix:semicolon
DECL|variable|usb_submit_urb
id|EXPORT_SYMBOL
c_func
(paren
id|usb_submit_urb
)paren
suffix:semicolon
DECL|variable|usb_unlink_urb
id|EXPORT_SYMBOL
c_func
(paren
id|usb_unlink_urb
)paren
suffix:semicolon
DECL|variable|usb_control_msg
id|EXPORT_SYMBOL
c_func
(paren
id|usb_control_msg
)paren
suffix:semicolon
DECL|variable|usb_bulk_msg
id|EXPORT_SYMBOL
c_func
(paren
id|usb_bulk_msg
)paren
suffix:semicolon
DECL|variable|usb_devfs_handle
id|EXPORT_SYMBOL
c_func
(paren
id|usb_devfs_handle
)paren
suffix:semicolon
eof
