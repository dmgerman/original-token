multiline_comment|/*&n; * drivers/usb/usb.c&n; *&n; * (C) Copyright Linus Torvalds 1999&n; * (C) Copyright Johannes Erdfelt 1999&n; *&n; * NOTE! This is not actually a driver at all, rather this is&n; * just a collection of helper routines that implement the&n; * generic USB things that the real drivers can use..&n; *&n; * Think of this as a &quot;USB library&quot; rather than anything else.&n; * It should be considered a slave, with no callbacks. Callbacks&n; * are evil.&n; */
macro_line|#ifndef EXPORT_SYMTAB
DECL|macro|EXPORT_SYMTAB
mdefine_line|#define EXPORT_SYMTAB
macro_line|#endif
DECL|macro|USB_DEBUG
mdefine_line|#define USB_DEBUG&t;1
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &quot;usb.h&quot;
r_static
r_int
id|usb_find_driver
c_func
(paren
r_struct
id|usb_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|usb_check_support
c_func
(paren
r_struct
id|usb_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|usb_driver_purge
c_func
(paren
r_struct
id|usb_driver
op_star
comma
r_struct
id|usb_device
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * We have a per-interface &quot;registered driver&quot; list.&n; */
r_static
id|LIST_HEAD
c_func
(paren
id|usb_driver_list
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|usb_bus_list
)paren
suffix:semicolon
DECL|variable|usb_minors
r_static
r_struct
id|usb_driver
op_star
id|usb_minors
(braket
l_int|16
)braket
suffix:semicolon
DECL|function|usb_register
r_int
id|usb_register
c_func
(paren
r_struct
id|usb_driver
op_star
id|new_driver
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;usbcore: Registering new driver %s&bslash;n&quot;
comma
id|new_driver-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_driver-&gt;fops
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|usb_minors
(braket
id|new_driver-&gt;minor
op_div
l_int|16
)braket
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|usb_minors
(braket
id|new_driver-&gt;minor
op_div
l_int|16
)braket
op_assign
id|new_driver
suffix:semicolon
)brace
multiline_comment|/* Add it to the list of known drivers */
id|list_add
c_func
(paren
op_amp
id|new_driver-&gt;driver_list
comma
op_amp
id|usb_driver_list
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We go through all existing devices, and see if any of them would&n;&t; * be acceptable to the new driver.. This is done using a depth-first&n;&t; * search for devices without a registered driver already, then &n;&t; * running &squot;probe&squot; with each of the drivers registered on every one &n;&t; * of these.&n;&t; */
id|tmp
op_assign
id|usb_bus_list.next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
op_amp
id|usb_bus_list
)paren
(brace
r_struct
id|usb_bus
op_star
id|bus
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|usb_bus
comma
id|bus_list
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
id|usb_check_support
c_func
(paren
id|bus-&gt;root_hub
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_deregister
r_void
id|usb_deregister
c_func
(paren
r_struct
id|usb_driver
op_star
id|driver
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;usbcore: Deregistering driver %s&bslash;n&quot;
comma
id|driver-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;fops
op_ne
l_int|NULL
)paren
id|usb_minors
(braket
id|driver-&gt;minor
op_div
l_int|16
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * first we remove the driver, to be sure it doesn&squot;t get used by&n;&t; * another thread while we are stepping through removing entries&n;&t; */
id|list_del
c_func
(paren
op_amp
id|driver-&gt;driver_list
)paren
suffix:semicolon
id|tmp
op_assign
id|usb_bus_list.next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
op_amp
id|usb_bus_list
)paren
(brace
r_struct
id|usb_bus
op_star
id|bus
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|usb_bus
comma
id|bus_list
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
id|usb_driver_purge
c_func
(paren
id|driver
comma
id|bus-&gt;root_hub
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function is part of a depth-first search down the device tree,&n; * removing any instances of a device driver.&n; */
DECL|function|usb_driver_purge
r_static
r_void
id|usb_driver_purge
c_func
(paren
r_struct
id|usb_driver
op_star
id|driver
comma
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbcore: null device being purged!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USB_MAXCHILDREN
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dev-&gt;children
(braket
id|i
)braket
)paren
id|usb_driver_purge
c_func
(paren
id|driver
comma
id|dev-&gt;children
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* now we check this device */
r_if
c_cond
(paren
id|dev-&gt;driver
op_eq
id|driver
)paren
(brace
multiline_comment|/*&n;&t;&t; * Note: this is not the correct way to do this, this&n;&t;&t; * uninitializes and reinitializes EVERY driver&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;disconnect driverless device %d&bslash;n&quot;
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
id|dev-&gt;driver
op_member_access_from_pointer
id|disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;driver
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This will go back through the list looking for a driver&n;&t;&t; * that can handle the device&n;&t;&t; */
id|usb_find_driver
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * calc_bus_time:&n; *&n; * returns (approximate) USB bus time in nanoseconds for a USB transaction.&n; */
DECL|function|calc_bus_time
r_static
r_int
id|calc_bus_time
(paren
r_int
id|low_speed
comma
r_int
id|input_dir
comma
r_int
id|isoc
comma
r_int
id|bytecount
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|low_speed
)paren
multiline_comment|/* no isoc. here */
(brace
r_if
c_cond
(paren
id|input_dir
)paren
(brace
id|tmp
op_assign
(paren
l_int|67667L
op_star
(paren
l_int|31L
op_plus
l_int|10L
op_star
id|BitTime
(paren
id|bytecount
)paren
)paren
)paren
op_div
l_int|1000L
suffix:semicolon
r_return
(paren
l_int|64060L
op_plus
(paren
l_int|2
op_star
id|BW_HUB_LS_SETUP
)paren
op_plus
id|BW_HOST_DELAY
op_plus
id|tmp
)paren
suffix:semicolon
)brace
r_else
(brace
id|tmp
op_assign
(paren
l_int|66700L
op_star
(paren
l_int|31L
op_plus
l_int|10L
op_star
id|BitTime
(paren
id|bytecount
)paren
)paren
)paren
op_div
l_int|1000L
suffix:semicolon
r_return
(paren
l_int|64107L
op_plus
(paren
l_int|2
op_star
id|BW_HUB_LS_SETUP
)paren
op_plus
id|BW_HOST_DELAY
op_plus
id|tmp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* for full-speed: */
r_if
c_cond
(paren
op_logical_neg
id|isoc
)paren
multiline_comment|/* Input or Output */
(brace
id|tmp
op_assign
(paren
l_int|8354L
op_star
(paren
l_int|31L
op_plus
l_int|10L
op_star
id|BitTime
(paren
id|bytecount
)paren
)paren
)paren
op_div
l_int|1000L
suffix:semicolon
r_return
(paren
l_int|9107L
op_plus
id|BW_HOST_DELAY
op_plus
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/* end not Isoc */
multiline_comment|/* for isoc: */
id|tmp
op_assign
(paren
l_int|8354L
op_star
(paren
l_int|31L
op_plus
l_int|10L
op_star
id|BitTime
(paren
id|bytecount
)paren
)paren
)paren
op_div
l_int|1000L
suffix:semicolon
r_return
(paren
(paren
(paren
id|input_dir
)paren
ques
c_cond
l_int|7268L
suffix:colon
l_int|6265L
)paren
op_plus
id|BW_HOST_DELAY
op_plus
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/* end calc_bus_time */
multiline_comment|/*&n; * check_bandwidth_alloc():&n; *&n; * old_alloc is from host_controller-&gt;bandwidth_allocated in microseconds;&n; * bustime is from calc_bus_time(), but converted to microseconds.&n; *&n; * returns 0 if successful,&n; * -1 if bandwidth request fails.&n; *&n; * FIXME:&n; * This initial implementation does not use Endpoint.bInterval&n; * in managing bandwidth allocation.&n; * It probably needs to be expanded to use Endpoint.bInterval.&n; * This can be done as a later enhancement (correction).&n; * This will also probably require some kind of&n; * frame allocation tracking...meaning, for example,&n; * that if multiple drivers request interrupts every 10 USB frames,&n; * they don&squot;t all have to be allocated at&n; * frame numbers N, N+10, N+20, etc.  Some of them could be at&n; * N+11, N+21, N+31, etc., and others at&n; * N+12, N+22, N+32, etc.&n; * However, this first cut at USB bandwidth allocation does not&n; * contain any frame allocation tracking.&n; */
DECL|function|check_bandwidth_alloc
r_static
r_int
id|check_bandwidth_alloc
(paren
r_int
r_int
id|old_alloc
comma
r_int
id|bustime
)paren
(brace
r_int
r_int
id|new_alloc
suffix:semicolon
id|new_alloc
op_assign
id|old_alloc
op_plus
id|bustime
suffix:semicolon
multiline_comment|/* what new total allocated bus time would be */
id|PRINTD
(paren
l_string|&quot;usb-bandwidth-alloc: was: %u, new: %u, &quot;
l_string|&quot;bustime = %ld us, Pipe allowed: %s&quot;
comma
id|old_alloc
comma
id|new_alloc
comma
id|bustime
comma
(paren
id|new_alloc
op_le
id|FRAME_TIME_MAX_USECS_ALLOC
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
r_return
(paren
id|new_alloc
op_le
id|FRAME_TIME_MAX_USECS_ALLOC
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* end check_bandwidth_alloc */
multiline_comment|/*&n; * New functions for (de)registering a controller&n; */
DECL|function|usb_alloc_bus
r_struct
id|usb_bus
op_star
id|usb_alloc_bus
c_func
(paren
r_struct
id|usb_operations
op_star
id|op
)paren
(brace
r_struct
id|usb_bus
op_star
id|bus
suffix:semicolon
id|bus
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|bus
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|bus-&gt;devmap
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|usb_devmap
)paren
)paren
suffix:semicolon
id|bus-&gt;op
op_assign
id|op
suffix:semicolon
id|bus-&gt;root_hub
op_assign
l_int|NULL
suffix:semicolon
id|bus-&gt;hcpriv
op_assign
l_int|NULL
suffix:semicolon
id|bus-&gt;bandwidth_allocated
op_assign
l_int|0
suffix:semicolon
id|bus-&gt;bandwidth_int_reqs
op_assign
l_int|0
suffix:semicolon
id|bus-&gt;bandwidth_isoc_reqs
op_assign
l_int|0
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|bus-&gt;bus_list
)paren
suffix:semicolon
r_return
id|bus
suffix:semicolon
)brace
DECL|function|usb_free_bus
r_void
id|usb_free_bus
c_func
(paren
r_struct
id|usb_bus
op_star
id|bus
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bus
)paren
r_return
suffix:semicolon
id|kfree
c_func
(paren
id|bus
)paren
suffix:semicolon
)brace
DECL|function|usb_register_bus
r_void
id|usb_register_bus
c_func
(paren
r_struct
id|usb_bus
op_star
id|bus
)paren
(brace
id|proc_usb_add_bus
c_func
(paren
id|bus
)paren
suffix:semicolon
multiline_comment|/* Add it to the list of buses */
id|list_add
c_func
(paren
op_amp
id|bus-&gt;bus_list
comma
op_amp
id|usb_bus_list
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;New USB bus registered&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|usb_deregister_bus
r_void
id|usb_deregister_bus
c_func
(paren
r_struct
id|usb_bus
op_star
id|bus
)paren
(brace
multiline_comment|/*&n;&t; * NOTE: make sure that all the devices are removed by the&n;&t; * controller code, as well as having it call this when cleaning&n;&t; * itself up&n;&t; */
id|list_del
c_func
(paren
op_amp
id|bus-&gt;bus_list
)paren
suffix:semicolon
id|proc_usb_remove_bus
c_func
(paren
id|bus
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is for doing a depth-first search for devices which&n; * have support, for dynamic loading of driver modules.&n; */
DECL|function|usb_check_support
r_static
r_void
id|usb_check_support
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbcore: null device being checked!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USB_MAXCHILDREN
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dev-&gt;children
(braket
id|i
)braket
)paren
id|usb_check_support
c_func
(paren
id|dev-&gt;children
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* now we check this device */
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;driver
op_logical_and
id|dev-&gt;devnum
OG
l_int|0
)paren
id|usb_find_driver
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This entrypoint gets called for each new device.&n; *&n; * We now walk the list of registered USB drivers,&n; * looking for one that will accept this device as&n; * his..&n; */
DECL|function|usb_find_driver
r_static
r_int
id|usb_find_driver
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
op_assign
id|usb_driver_list.next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
op_amp
id|usb_driver_list
)paren
(brace
r_struct
id|usb_driver
op_star
id|driver
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|usb_driver
comma
id|driver_list
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|driver
op_member_access_from_pointer
id|probe
c_func
(paren
id|dev
)paren
)paren
r_continue
suffix:semicolon
id|dev-&gt;driver
op_assign
id|driver
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ok, no driver accepted the device, so show the info&n;&t; * for debugging..&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Only HC&squot;s should call usb_alloc_dev and usb_free_dev directly&n; * Anybody may use usb_inc_dev_use or usb_dec_dev_use&n; */
DECL|function|usb_alloc_dev
r_struct
id|usb_device
op_star
id|usb_alloc_dev
c_func
(paren
r_struct
id|usb_device
op_star
id|parent
comma
r_struct
id|usb_bus
op_star
id|bus
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|dev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|dev
)paren
)paren
suffix:semicolon
id|dev-&gt;bus
op_assign
id|bus
suffix:semicolon
id|dev-&gt;parent
op_assign
id|parent
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|dev-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|allocate
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
DECL|function|usb_free_dev
r_void
id|usb_free_dev
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
)paren
(brace
id|usb_destroy_configuration
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|deallocate
c_func
(paren
id|dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
DECL|function|usb_inc_dev_use
r_void
id|usb_inc_dev_use
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
suffix:semicolon
)brace
DECL|function|usb_parse_endpoint
r_static
r_int
id|usb_parse_endpoint
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|usb_endpoint_descriptor
op_star
id|endpoint
comma
r_int
r_char
op_star
id|buffer
comma
r_int
id|size
)paren
(brace
r_struct
id|usb_descriptor_header
op_star
id|header
suffix:semicolon
r_int
id|parsed
op_assign
l_int|0
suffix:semicolon
id|header
op_assign
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
id|buffer
suffix:semicolon
multiline_comment|/* Everything should be fine being passed into here, but we sanity */
multiline_comment|/*  check JIC */
r_if
c_cond
(paren
id|header-&gt;bLength
OG
id|size
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usb: ran out of descriptors parsing&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|header-&gt;bDescriptorType
op_ne
id|USB_DT_ENDPOINT
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb: unexpected descriptor 0x%X&bslash;n&quot;
comma
id|endpoint-&gt;bDescriptorType
)paren
suffix:semicolon
r_return
id|parsed
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|endpoint
comma
id|buffer
comma
id|USB_DT_ENDPOINT_SIZE
)paren
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|endpoint-&gt;wMaxPacketSize
)paren
suffix:semicolon
id|buffer
op_add_assign
id|header-&gt;bLength
suffix:semicolon
id|size
op_sub_assign
id|header-&gt;bLength
suffix:semicolon
id|parsed
op_add_assign
id|header-&gt;bLength
suffix:semicolon
multiline_comment|/* Skip over the rest of the Class Specific or Vendor Specific */
multiline_comment|/*  descriptors */
r_while
c_loop
(paren
id|size
op_ge
r_sizeof
(paren
r_struct
id|usb_descriptor_header
)paren
)paren
(brace
id|header
op_assign
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;bLength
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usb: invalid descriptor length of %d&bslash;n&quot;
comma
id|header-&gt;bLength
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If we find another descriptor which is at or below us */
multiline_comment|/*  in the descriptor heirarchy then return */
r_if
c_cond
(paren
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_ENDPOINT
)paren
op_logical_or
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_INTERFACE
)paren
op_logical_or
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_CONFIG
)paren
op_logical_or
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_DEVICE
)paren
)paren
r_return
id|parsed
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb: skipping descriptor 0x%X&bslash;n&quot;
comma
id|header-&gt;bDescriptorType
)paren
suffix:semicolon
id|buffer
op_add_assign
id|header-&gt;bLength
suffix:semicolon
id|size
op_sub_assign
id|header-&gt;bLength
suffix:semicolon
id|parsed
op_add_assign
id|header-&gt;bLength
suffix:semicolon
)brace
r_return
id|parsed
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_int
id|usb_parse_hid
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|usb_hid_descriptor
op_star
id|hid
comma
r_int
r_char
op_star
id|ptr
comma
r_int
id|len
)paren
(brace
r_int
id|parsed
op_assign
id|usb_expect_descriptor
c_func
(paren
id|ptr
comma
id|len
comma
id|USB_DT_HID
comma
id|ptr
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|parsed
OL
l_int|0
)paren
r_return
id|parsed
suffix:semicolon
id|memcpy
c_func
(paren
id|hid
comma
id|ptr
op_plus
id|parsed
comma
id|ptr
(braket
id|parsed
)braket
)paren
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|hid-&gt;bcdHID
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hid-&gt;bNumDescriptors
suffix:semicolon
id|i
op_increment
)paren
id|le16_to_cpus
c_func
(paren
op_amp
(paren
id|hid-&gt;desc
(braket
id|i
)braket
dot
id|wDescriptorLength
)paren
)paren
suffix:semicolon
r_return
id|parsed
op_plus
id|ptr
(braket
id|parsed
)braket
suffix:semicolon
)brace
macro_line|#endif
DECL|function|usb_parse_interface
r_static
r_int
id|usb_parse_interface
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|usb_interface
op_star
id|interface
comma
r_int
r_char
op_star
id|buffer
comma
r_int
id|size
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|retval
comma
id|parsed
op_assign
l_int|0
suffix:semicolon
r_struct
id|usb_descriptor_header
op_star
id|header
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|ifp
suffix:semicolon
id|interface-&gt;act_altsetting
op_assign
l_int|0
suffix:semicolon
id|interface-&gt;num_altsetting
op_assign
l_int|0
suffix:semicolon
id|interface-&gt;altsetting
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|usb_interface_descriptor
)paren
op_star
id|USB_MAXALTSETTING
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|interface-&gt;altsetting
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;couldn&squot;t kmalloc interface-&gt;altsetting&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|ifp
op_assign
id|interface-&gt;altsetting
op_plus
id|interface-&gt;num_altsetting
suffix:semicolon
id|interface-&gt;num_altsetting
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|interface-&gt;num_altsetting
op_ge
id|USB_MAXALTSETTING
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;usb: too many alternate settings&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|ifp
comma
id|buffer
comma
id|USB_DT_INTERFACE_SIZE
)paren
suffix:semicolon
multiline_comment|/* Skip over the interface */
id|buffer
op_add_assign
id|ifp-&gt;bLength
suffix:semicolon
id|parsed
op_add_assign
id|ifp-&gt;bLength
suffix:semicolon
id|size
op_sub_assign
id|ifp-&gt;bLength
suffix:semicolon
multiline_comment|/* Skip over at Interface class or vendor descriptors */
r_while
c_loop
(paren
id|size
op_ge
r_sizeof
(paren
r_struct
id|usb_descriptor_header
)paren
)paren
(brace
id|header
op_assign
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;bLength
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usb: invalid descriptor length of %d&bslash;n&quot;
comma
id|header-&gt;bLength
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If we find another descriptor which is at or below us */
multiline_comment|/*  in the descriptor heirarchy then return */
r_if
c_cond
(paren
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_INTERFACE
)paren
op_logical_or
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_ENDPOINT
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_CONFIG
)paren
op_logical_or
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_DEVICE
)paren
)paren
r_return
id|parsed
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;bDescriptorType
op_eq
id|USB_DT_HID
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb: skipping HID descriptor&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb: unexpected descriptor 0x%X&bslash;n&quot;
comma
id|header-&gt;bDescriptorType
)paren
suffix:semicolon
id|buffer
op_add_assign
id|header-&gt;bLength
suffix:semicolon
id|parsed
op_add_assign
id|header-&gt;bLength
suffix:semicolon
id|size
op_sub_assign
id|header-&gt;bLength
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ifp-&gt;bNumEndpoints
OG
id|USB_MAXENDPOINTS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;usb: too many endpoints&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ifp-&gt;endpoint
op_assign
(paren
r_struct
id|usb_endpoint_descriptor
op_star
)paren
id|kmalloc
c_func
(paren
id|ifp-&gt;bNumEndpoints
op_star
r_sizeof
(paren
r_struct
id|usb_endpoint_descriptor
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ifp-&gt;endpoint
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;usb: out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ifp-&gt;endpoint
comma
l_int|0
comma
id|ifp-&gt;bNumEndpoints
op_star
r_sizeof
(paren
r_struct
id|usb_endpoint_descriptor
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ifp-&gt;bNumEndpoints
suffix:semicolon
id|i
op_increment
)paren
(brace
id|header
op_assign
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;bLength
OG
id|size
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usb: ran out of descriptors parsing&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|retval
op_assign
id|usb_parse_endpoint
c_func
(paren
id|dev
comma
id|ifp-&gt;endpoint
op_plus
id|i
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_return
id|retval
suffix:semicolon
id|buffer
op_add_assign
id|retval
suffix:semicolon
id|parsed
op_add_assign
id|retval
suffix:semicolon
id|size
op_sub_assign
id|retval
suffix:semicolon
)brace
multiline_comment|/* We check to see if it&squot;s an alternate to this one */
id|ifp
op_assign
(paren
r_struct
id|usb_interface_descriptor
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
id|USB_DT_INTERFACE_SIZE
op_logical_or
id|ifp-&gt;bDescriptorType
op_ne
id|USB_DT_INTERFACE
op_logical_or
op_logical_neg
id|ifp-&gt;bAlternateSetting
)paren
r_return
id|parsed
suffix:semicolon
)brace
r_return
id|parsed
suffix:semicolon
)brace
DECL|function|usb_parse_configuration
r_static
r_int
id|usb_parse_configuration
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|usb_config_descriptor
op_star
id|config
comma
r_char
op_star
id|buffer
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|size
suffix:semicolon
r_struct
id|usb_descriptor_header
op_star
id|header
suffix:semicolon
id|memcpy
c_func
(paren
id|config
comma
id|buffer
comma
id|USB_DT_INTERFACE_SIZE
)paren
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|config-&gt;wTotalLength
)paren
suffix:semicolon
id|size
op_assign
id|config-&gt;wTotalLength
suffix:semicolon
r_if
c_cond
(paren
id|config-&gt;bNumInterfaces
OG
id|USB_MAXINTERFACES
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;usb: too many interfaces&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|config-&gt;interface
op_assign
(paren
r_struct
id|usb_interface
op_star
)paren
id|kmalloc
c_func
(paren
id|config-&gt;bNumInterfaces
op_star
r_sizeof
(paren
r_struct
id|usb_interface
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|config-&gt;interface
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;usb: out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|config-&gt;interface
comma
l_int|0
comma
id|config-&gt;bNumInterfaces
op_star
r_sizeof
(paren
r_struct
id|usb_interface_descriptor
)paren
)paren
suffix:semicolon
id|buffer
op_add_assign
id|config-&gt;bLength
suffix:semicolon
id|size
op_sub_assign
id|config-&gt;bLength
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|config-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
id|header
op_assign
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;bLength
OG
id|size
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usb: ran out of descriptors parsing&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|header-&gt;bDescriptorType
op_ne
id|USB_DT_INTERFACE
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb: unexpected descriptor 0x%X&bslash;n&quot;
comma
id|header-&gt;bDescriptorType
)paren
suffix:semicolon
id|buffer
op_add_assign
id|header-&gt;bLength
suffix:semicolon
id|size
op_sub_assign
id|header-&gt;bLength
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|retval
op_assign
id|usb_parse_interface
c_func
(paren
id|dev
comma
id|config-&gt;interface
op_plus
id|i
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_return
id|retval
suffix:semicolon
id|buffer
op_add_assign
id|retval
suffix:semicolon
id|size
op_sub_assign
id|retval
suffix:semicolon
)brace
r_return
id|size
suffix:semicolon
)brace
DECL|function|usb_destroy_configuration
r_void
id|usb_destroy_configuration
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|c
comma
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;config
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
OL
id|dev-&gt;descriptor.bNumConfigurations
suffix:semicolon
id|c
op_increment
)paren
(brace
r_struct
id|usb_config_descriptor
op_star
id|cf
op_assign
op_amp
id|dev-&gt;config
(braket
id|c
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cf-&gt;interface
)paren
r_break
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cf-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_interface
op_star
id|ifp
op_assign
op_amp
id|cf-&gt;interface
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ifp-&gt;altsetting
)paren
r_break
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ifp-&gt;num_altsetting
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|usb_interface_descriptor
op_star
id|as
op_assign
op_amp
id|ifp-&gt;altsetting
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|as-&gt;endpoint
)paren
r_break
suffix:semicolon
id|kfree
c_func
(paren
id|as-&gt;endpoint
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|ifp-&gt;altsetting
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|cf-&gt;interface
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|dev-&gt;config
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;string
)paren
(brace
id|kfree
c_func
(paren
id|dev-&gt;string
)paren
suffix:semicolon
id|dev-&gt;string
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|usb_init_root_hub
r_void
id|usb_init_root_hub
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
id|dev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;slow
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Something got disconnected. Get rid of it, and all of its children.&n; */
DECL|function|usb_disconnect
r_void
id|usb_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
op_star
id|pdev
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
op_star
id|pdev
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
suffix:semicolon
op_star
id|pdev
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;USB disconnect on device %d&bslash;n&quot;
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;driver
)paren
id|dev-&gt;driver
op_member_access_from_pointer
id|disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Free up all the children.. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USB_MAXCHILDREN
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_device
op_star
op_star
id|child
op_assign
id|dev-&gt;children
op_plus
id|i
suffix:semicolon
id|usb_disconnect
c_func
(paren
id|child
)paren
suffix:semicolon
)brace
multiline_comment|/* remove /proc/bus/usb entry */
id|proc_usb_remove_device
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Free up the device itself, including its device number */
r_if
c_cond
(paren
id|dev-&gt;devnum
OG
l_int|0
)paren
id|clear_bit
c_func
(paren
id|dev-&gt;devnum
comma
op_amp
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|usb_free_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Connect a new USB device. This basically just initializes&n; * the USB device information and sets up the topology - it&squot;s&n; * up to the low-level driver to reset the port and actually&n; * do the setup (the upper levels don&squot;t know how to do that).&n; */
DECL|function|usb_connect
r_void
id|usb_connect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|devnum
suffix:semicolon
id|dev-&gt;descriptor.bMaxPacketSize0
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* XXX fixed 8 bytes for now */
id|devnum
op_assign
id|find_next_zero_bit
c_func
(paren
id|dev-&gt;bus-&gt;devmap.devicemap
comma
l_int|128
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devnum
OL
l_int|128
)paren
(brace
id|set_bit
c_func
(paren
id|devnum
comma
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
id|devnum
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * These are the actual routines to send&n; * and receive control messages.&n; */
DECL|function|usb_set_address
r_int
id|usb_set_address
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
id|devrequest
id|dr
suffix:semicolon
id|dr.requesttype
op_assign
l_int|0
suffix:semicolon
id|dr.request
op_assign
id|USB_REQ_SET_ADDRESS
suffix:semicolon
id|dr.value
op_assign
id|dev-&gt;devnum
suffix:semicolon
id|dr.index
op_assign
l_int|0
suffix:semicolon
id|dr.length
op_assign
l_int|0
suffix:semicolon
r_return
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|control_msg
c_func
(paren
id|dev
comma
id|usb_snddefctrl
c_func
(paren
id|dev
)paren
comma
op_amp
id|dr
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
)paren
suffix:semicolon
)brace
DECL|function|usb_get_descriptor
r_int
id|usb_get_descriptor
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_char
id|type
comma
r_int
r_char
id|index
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
id|devrequest
id|dr
suffix:semicolon
r_int
id|i
op_assign
l_int|5
suffix:semicolon
r_int
id|result
suffix:semicolon
id|dr.requesttype
op_assign
id|USB_DIR_IN
suffix:semicolon
id|dr.request
op_assign
id|USB_REQ_GET_DESCRIPTOR
suffix:semicolon
id|dr.value
op_assign
(paren
id|type
op_lshift
l_int|8
)paren
op_plus
id|index
suffix:semicolon
id|dr.index
op_assign
l_int|0
suffix:semicolon
id|dr.length
op_assign
id|size
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|result
op_assign
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
op_amp
id|dr
comma
id|buf
comma
id|size
comma
id|HZ
)paren
)paren
op_logical_or
id|result
op_eq
id|USB_ST_STALL
)paren
r_break
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|usb_get_string
r_int
id|usb_get_string
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|langid
comma
r_int
r_char
id|index
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
id|devrequest
id|dr
suffix:semicolon
id|dr.requesttype
op_assign
id|USB_DIR_IN
suffix:semicolon
id|dr.request
op_assign
id|USB_REQ_GET_DESCRIPTOR
suffix:semicolon
id|dr.value
op_assign
(paren
id|USB_DT_STRING
op_lshift
l_int|8
)paren
op_plus
id|index
suffix:semicolon
id|dr.index
op_assign
id|langid
suffix:semicolon
id|dr.length
op_assign
id|size
suffix:semicolon
r_return
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
op_amp
id|dr
comma
id|buf
comma
id|size
comma
id|HZ
)paren
suffix:semicolon
)brace
DECL|function|usb_get_device_descriptor
r_int
id|usb_get_device_descriptor
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|ret
op_assign
id|usb_get_descriptor
c_func
(paren
id|dev
comma
id|USB_DT_DEVICE
comma
l_int|0
comma
op_amp
id|dev-&gt;descriptor
comma
r_sizeof
(paren
id|dev-&gt;descriptor
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|le16_to_cpus
c_func
(paren
op_amp
id|dev-&gt;descriptor.bcdUSB
)paren
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|dev-&gt;descriptor.idVendor
)paren
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|dev-&gt;descriptor.idProduct
)paren
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|dev-&gt;descriptor.bcdDevice
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|usb_get_status
r_int
id|usb_get_status
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|type
comma
r_int
id|target
comma
r_void
op_star
id|data
)paren
(brace
id|devrequest
id|dr
suffix:semicolon
id|dr.requesttype
op_assign
id|USB_DIR_IN
op_or
id|type
suffix:semicolon
multiline_comment|/* USB_RECIP_DEVICE, _INTERFACE, or _ENDPOINT */
id|dr.request
op_assign
id|USB_REQ_GET_STATUS
suffix:semicolon
id|dr.value
op_assign
l_int|0
suffix:semicolon
id|dr.index
op_assign
id|target
suffix:semicolon
id|dr.length
op_assign
l_int|2
suffix:semicolon
r_return
id|dev-&gt;bus-&gt;op-&gt;control_msg
(paren
id|dev
comma
id|usb_rcvctrlpipe
(paren
id|dev
comma
l_int|0
)paren
comma
op_amp
id|dr
comma
id|data
comma
l_int|2
comma
id|HZ
)paren
suffix:semicolon
)brace
DECL|function|usb_get_protocol
r_int
id|usb_get_protocol
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
r_char
id|buf
(braket
l_int|8
)braket
suffix:semicolon
id|devrequest
id|dr
suffix:semicolon
id|dr.requesttype
op_assign
id|USB_RT_HIDD
op_or
id|USB_DIR_IN
suffix:semicolon
id|dr.request
op_assign
id|USB_REQ_GET_PROTOCOL
suffix:semicolon
id|dr.value
op_assign
l_int|0
suffix:semicolon
id|dr.index
op_assign
l_int|1
suffix:semicolon
id|dr.length
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
op_amp
id|dr
comma
id|buf
comma
l_int|1
comma
id|HZ
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
id|buf
(braket
l_int|0
)braket
suffix:semicolon
)brace
DECL|function|usb_set_protocol
r_int
id|usb_set_protocol
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|protocol
)paren
(brace
id|devrequest
id|dr
suffix:semicolon
id|dr.requesttype
op_assign
id|USB_RT_HIDD
suffix:semicolon
id|dr.request
op_assign
id|USB_REQ_SET_PROTOCOL
suffix:semicolon
id|dr.value
op_assign
id|protocol
suffix:semicolon
id|dr.index
op_assign
l_int|1
suffix:semicolon
id|dr.length
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
op_amp
id|dr
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* keyboards want a nonzero duration according to HID spec, but&n;   mice should use infinity (0) -keryan */
DECL|function|usb_set_idle
r_int
id|usb_set_idle
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|duration
comma
r_int
id|report_id
)paren
(brace
id|devrequest
id|dr
suffix:semicolon
id|dr.requesttype
op_assign
id|USB_RT_HIDD
suffix:semicolon
id|dr.request
op_assign
id|USB_REQ_SET_IDLE
suffix:semicolon
id|dr.value
op_assign
(paren
id|duration
op_lshift
l_int|8
)paren
op_or
id|report_id
suffix:semicolon
id|dr.index
op_assign
l_int|1
suffix:semicolon
id|dr.length
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
op_amp
id|dr
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_set_maxpacket
r_static
r_void
id|usb_set_maxpacket
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_struct
id|usb_interface
op_star
id|ifp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;actconfig-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ifp
op_assign
id|dev-&gt;actconfig-&gt;interface
op_plus
id|i
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ifp-&gt;num_altsetting
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|usb_interface_descriptor
op_star
id|as
op_assign
id|ifp-&gt;altsetting
op_plus
id|j
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep
op_assign
id|as-&gt;endpoint
suffix:semicolon
r_int
id|e
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
l_int|0
suffix:semicolon
id|e
OL
id|as-&gt;bNumEndpoints
suffix:semicolon
id|e
op_increment
)paren
(brace
r_if
c_cond
(paren
id|usb_endpoint_out
c_func
(paren
id|ep
(braket
id|e
)braket
dot
id|bEndpointAddress
)paren
)paren
id|dev-&gt;epmaxpacketout
(braket
id|ep
(braket
id|e
)braket
dot
id|bEndpointAddress
op_amp
l_int|0x0f
)braket
op_assign
id|ep
(braket
id|e
)braket
dot
id|wMaxPacketSize
suffix:semicolon
r_else
id|dev-&gt;epmaxpacketin
(braket
id|ep
(braket
id|e
)braket
dot
id|bEndpointAddress
op_amp
l_int|0x0f
)braket
op_assign
id|ep
(braket
id|e
)braket
dot
id|wMaxPacketSize
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * endp: endpoint number in bits 0-3;&n; *&t;direction flag in bit 7 (1 = IN, 0 = OUT)&n; */
DECL|function|usb_clear_halt
r_int
id|usb_clear_halt
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|endp
)paren
(brace
id|devrequest
id|dr
suffix:semicolon
r_int
id|result
suffix:semicolon
id|__u16
id|status
suffix:semicolon
singleline_comment|//if (!usb_endpoint_halted(dev, endp &amp; 0x0f, usb_endpoint_out(endp)))
singleline_comment|//&t;return 0;
id|dr.requesttype
op_assign
id|USB_RT_ENDPOINT
suffix:semicolon
id|dr.request
op_assign
id|USB_REQ_CLEAR_FEATURE
suffix:semicolon
id|dr.value
op_assign
l_int|0
suffix:semicolon
id|dr.index
op_assign
id|endp
suffix:semicolon
id|dr.length
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
op_amp
id|dr
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
)paren
suffix:semicolon
multiline_comment|/* don&squot;t clear if failed */
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
macro_line|#if 1&t;/* let&squot;s be really tough */
id|dr.requesttype
op_assign
id|USB_DIR_IN
op_or
id|USB_RT_ENDPOINT
suffix:semicolon
id|dr.request
op_assign
id|USB_REQ_GET_STATUS
suffix:semicolon
id|dr.length
op_assign
l_int|2
suffix:semicolon
id|status
op_assign
l_int|0xffff
suffix:semicolon
id|result
op_assign
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
op_amp
id|dr
comma
op_amp
id|status
comma
l_int|2
comma
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* still halted */
macro_line|#endif
id|usb_endpoint_running
c_func
(paren
id|dev
comma
id|endp
op_amp
l_int|0x0f
comma
id|usb_endpoint_out
c_func
(paren
id|endp
)paren
)paren
suffix:semicolon
multiline_comment|/* toggle is reset on clear */
id|usb_settoggle
c_func
(paren
id|dev
comma
id|endp
op_amp
l_int|0x0f
comma
id|usb_endpoint_out
c_func
(paren
id|endp
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_set_interface
r_int
id|usb_set_interface
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|interface
comma
r_int
id|alternate
)paren
(brace
id|devrequest
id|dr
suffix:semicolon
id|dr.requesttype
op_assign
l_int|1
suffix:semicolon
id|dr.request
op_assign
id|USB_REQ_SET_INTERFACE
suffix:semicolon
id|dr.value
op_assign
id|alternate
suffix:semicolon
id|dr.index
op_assign
id|interface
suffix:semicolon
id|dr.length
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
op_amp
id|dr
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;ifnum
op_assign
id|interface
suffix:semicolon
id|dev-&gt;actconfig-&gt;interface
(braket
id|interface
)braket
dot
id|act_altsetting
op_assign
id|alternate
suffix:semicolon
id|usb_set_maxpacket
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_set_configuration
r_int
id|usb_set_configuration
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|configuration
)paren
(brace
id|devrequest
id|dr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|usb_config_descriptor
op_star
id|cp
op_assign
l_int|NULL
suffix:semicolon
id|dr.requesttype
op_assign
l_int|0
suffix:semicolon
id|dr.request
op_assign
id|USB_REQ_SET_CONFIGURATION
suffix:semicolon
id|dr.value
op_assign
id|configuration
suffix:semicolon
id|dr.index
op_assign
l_int|0
suffix:semicolon
id|dr.length
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;descriptor.bNumConfigurations
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;config
(braket
id|i
)braket
dot
id|bConfigurationValue
op_eq
id|configuration
)paren
(brace
id|cp
op_assign
op_amp
id|dev-&gt;config
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb: selecting invalid configuration %d&bslash;n&quot;
comma
id|configuration
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
op_amp
id|dr
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;actconfig
op_assign
id|cp
suffix:semicolon
id|dev-&gt;toggle
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;toggle
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|usb_set_maxpacket
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_get_report
r_int
id|usb_get_report
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_char
id|type
comma
r_int
r_char
id|id
comma
r_int
r_char
id|index
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
id|devrequest
id|dr
suffix:semicolon
id|dr.requesttype
op_assign
id|USB_RT_HIDD
op_or
id|USB_DIR_IN
suffix:semicolon
id|dr.request
op_assign
id|USB_REQ_GET_REPORT
suffix:semicolon
id|dr.value
op_assign
(paren
id|type
op_lshift
l_int|8
)paren
op_plus
id|id
suffix:semicolon
id|dr.index
op_assign
id|index
suffix:semicolon
id|dr.length
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
op_amp
id|dr
comma
id|buf
comma
id|size
comma
id|HZ
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_get_configuration
r_int
id|usb_get_configuration
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|cfgno
suffix:semicolon
r_int
r_char
id|buffer
(braket
l_int|8
)braket
suffix:semicolon
r_int
r_char
op_star
id|bigbuffer
suffix:semicolon
r_struct
id|usb_config_descriptor
op_star
id|desc
op_assign
(paren
r_struct
id|usb_config_descriptor
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.bNumConfigurations
OG
id|USB_MAXCONFIG
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;usb: too many configurations&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|dev-&gt;config
op_assign
(paren
r_struct
id|usb_config_descriptor
op_star
)paren
id|kmalloc
c_func
(paren
id|dev-&gt;descriptor.bNumConfigurations
op_star
r_sizeof
(paren
r_struct
id|usb_config_descriptor
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;config
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;usb: out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev-&gt;config
comma
l_int|0
comma
id|dev-&gt;descriptor.bNumConfigurations
op_star
r_sizeof
(paren
r_struct
id|usb_config_descriptor
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfgno
op_assign
l_int|0
suffix:semicolon
id|cfgno
OL
id|dev-&gt;descriptor.bNumConfigurations
suffix:semicolon
id|cfgno
op_increment
)paren
(brace
r_int
id|result
suffix:semicolon
multiline_comment|/* We grab the first 8 bytes so we know how long the whole */
multiline_comment|/*  configuration is */
id|result
op_assign
id|usb_get_descriptor
c_func
(paren
id|dev
comma
id|USB_DT_CONFIG
comma
id|cfgno
comma
id|buffer
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Get the full buffer */
id|le16_to_cpus
c_func
(paren
op_amp
id|desc-&gt;wTotalLength
)paren
suffix:semicolon
id|bigbuffer
op_assign
id|kmalloc
c_func
(paren
id|desc-&gt;wTotalLength
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bigbuffer
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Now that we know the length, get the whole thing */
id|result
op_assign
id|usb_get_descriptor
c_func
(paren
id|dev
comma
id|USB_DT_CONFIG
comma
id|cfgno
comma
id|bigbuffer
comma
id|desc-&gt;wTotalLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|kfree
c_func
(paren
id|bigbuffer
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|result
op_assign
id|usb_parse_configuration
c_func
(paren
id|dev
comma
op_amp
id|dev-&gt;config
(braket
id|cfgno
)braket
comma
id|bigbuffer
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|bigbuffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb: descriptor data left&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_string
r_char
op_star
id|usb_string
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|index
)paren
(brace
r_int
id|len
comma
id|i
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
r_union
(brace
r_int
r_char
id|buffer
(braket
l_int|256
)braket
suffix:semicolon
r_struct
id|usb_string_descriptor
id|desc
suffix:semicolon
)brace
id|u
suffix:semicolon
r_if
c_cond
(paren
id|index
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;string
)paren
id|kfree
(paren
id|dev-&gt;string
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;string_langid
op_eq
l_int|0
)paren
(brace
multiline_comment|/* read string descriptor 0 */
r_if
c_cond
(paren
id|usb_get_string
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0
comma
id|u.buffer
comma
l_int|2
)paren
op_eq
l_int|0
op_logical_and
id|u.desc.bLength
op_ge
l_int|4
op_logical_and
id|usb_get_string
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0
comma
id|u.buffer
comma
l_int|4
)paren
op_eq
l_int|0
)paren
id|dev-&gt;string_langid
op_assign
id|le16_to_cpup
c_func
(paren
op_amp
id|u.desc.wData
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|dev-&gt;string_langid
op_or_assign
l_int|0x10000
suffix:semicolon
multiline_comment|/* so it&squot;s non-zero */
)brace
r_if
c_cond
(paren
id|usb_get_string
c_func
(paren
id|dev
comma
id|dev-&gt;string_langid
comma
id|index
comma
id|u.buffer
comma
l_int|2
)paren
op_logical_or
id|usb_get_string
c_func
(paren
id|dev
comma
id|dev-&gt;string_langid
comma
id|index
comma
id|u.buffer
comma
id|u.desc.bLength
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|len
op_assign
id|u.desc.bLength
op_div
l_int|2
suffix:semicolon
multiline_comment|/* includes terminating null */
id|ptr
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_minus
l_int|1
suffix:semicolon
op_increment
id|i
)paren
id|ptr
(braket
id|i
)braket
op_assign
id|le16_to_cpup
c_func
(paren
op_amp
id|u.desc.wData
(braket
id|i
)braket
)paren
suffix:semicolon
id|ptr
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;string
op_assign
id|ptr
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/*&n; * By the time we get here, the device has gotten a new device ID&n; * and is in the default state. We need to identify the thing and&n; * get the ball rolling..&n; */
DECL|function|usb_new_device
r_int
id|usb_new_device
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|addr
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;USB new device connect, assigned device number %d&bslash;n&quot;
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
id|dev-&gt;maxpacketsize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Default to 8 byte max packet size */
id|dev-&gt;epmaxpacketin
(braket
l_int|0
)braket
op_assign
l_int|8
suffix:semicolon
id|dev-&gt;epmaxpacketout
(braket
l_int|0
)braket
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* We still haven&squot;t set the Address yet */
id|addr
op_assign
id|dev-&gt;devnum
suffix:semicolon
id|dev-&gt;devnum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Slow devices */
r_if
c_cond
(paren
id|usb_get_descriptor
c_func
(paren
id|dev
comma
id|USB_DT_DEVICE
comma
l_int|0
comma
op_amp
id|dev-&gt;descriptor
comma
l_int|8
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbcore: USB device not responding, giving up&bslash;n&quot;
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dev-&gt;epmaxpacketin
(braket
l_int|0
)braket
op_assign
id|dev-&gt;descriptor.bMaxPacketSize0
suffix:semicolon
id|dev-&gt;epmaxpacketout
(braket
l_int|0
)braket
op_assign
id|dev-&gt;descriptor.bMaxPacketSize0
suffix:semicolon
r_switch
c_cond
(paren
id|dev-&gt;descriptor.bMaxPacketSize0
)paren
(brace
r_case
l_int|8
suffix:colon
id|dev-&gt;maxpacketsize
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|16
suffix:colon
id|dev-&gt;maxpacketsize
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32
suffix:colon
id|dev-&gt;maxpacketsize
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|64
suffix:colon
id|dev-&gt;maxpacketsize
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dev-&gt;devnum
op_assign
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|usb_set_address
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbcore: USB device not accepting new address&bslash;n&quot;
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|wait_ms
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Let the SET_ADDRESS settle */
r_if
c_cond
(paren
id|usb_get_device_descriptor
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbcore: unable to get device descriptor&bslash;n&quot;
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usb_get_configuration
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbcore: unable to get configuration&bslash;n&quot;
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dev-&gt;actconfig
op_assign
id|dev-&gt;config
suffix:semicolon
id|dev-&gt;ifnum
op_assign
l_int|0
suffix:semicolon
id|usb_set_maxpacket
c_func
(paren
id|dev
)paren
suffix:semicolon
id|usb_show_string
c_func
(paren
id|dev
comma
l_string|&quot;Manufacturer&quot;
comma
id|dev-&gt;descriptor.iManufacturer
)paren
suffix:semicolon
id|usb_show_string
c_func
(paren
id|dev
comma
l_string|&quot;Product&quot;
comma
id|dev-&gt;descriptor.iProduct
)paren
suffix:semicolon
id|usb_show_string
c_func
(paren
id|dev
comma
l_string|&quot;SerialNumber&quot;
comma
id|dev-&gt;descriptor.iSerialNumber
)paren
suffix:semicolon
multiline_comment|/* now that the basic setup is over, add a /proc/bus/usb entry */
id|proc_usb_add_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usb_find_driver
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Ok, no driver accepted the device, so show the info for&n;&t;&t; * debugging&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Unknown new USB device:&bslash;n&quot;
)paren
suffix:semicolon
id|usb_show_device
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_control_msg
r_int
id|usb_control_msg
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|pipe
comma
id|__u8
id|request
comma
id|__u8
id|requesttype
comma
id|__u16
id|value
comma
id|__u16
id|index
comma
r_void
op_star
id|data
comma
id|__u16
id|size
comma
r_int
id|timeout
)paren
(brace
id|devrequest
id|dr
suffix:semicolon
id|dr.requesttype
op_assign
id|requesttype
suffix:semicolon
id|dr.request
op_assign
id|request
suffix:semicolon
id|dr.value
op_assign
id|value
suffix:semicolon
id|dr.index
op_assign
id|index
suffix:semicolon
id|dr.length
op_assign
id|size
suffix:semicolon
r_return
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|control_msg
c_func
(paren
id|dev
comma
id|pipe
comma
op_amp
id|dr
comma
id|data
comma
id|size
comma
id|timeout
)paren
suffix:semicolon
)brace
DECL|function|usb_request_irq
r_int
id|usb_request_irq
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|pipe
comma
id|usb_device_irq
id|handler
comma
r_int
id|period
comma
r_void
op_star
id|dev_id
comma
r_void
op_star
op_star
id|handle
)paren
(brace
r_int
id|bustime
suffix:semicolon
r_int
id|ret
suffix:semicolon
op_star
id|handle
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Check host controller&squot;s bandwidth for this int. request. */
id|bustime
op_assign
id|calc_bus_time
(paren
id|usb_pipeslow
c_func
(paren
id|pipe
)paren
comma
id|usb_pipein
c_func
(paren
id|pipe
)paren
comma
l_int|0
comma
id|usb_maxpacket
c_func
(paren
id|dev
comma
id|pipe
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
)paren
)paren
suffix:semicolon
id|bustime
op_assign
id|NS_TO_US
c_func
(paren
id|bustime
)paren
suffix:semicolon
multiline_comment|/* work in microseconds */
r_if
c_cond
(paren
id|check_bandwidth_alloc
(paren
id|dev-&gt;bus-&gt;bandwidth_allocated
comma
id|bustime
)paren
)paren
r_return
(paren
id|USB_ST_BANDWIDTH_ERROR
)paren
suffix:semicolon
id|ret
op_assign
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|request_irq
c_func
(paren
id|dev
comma
id|pipe
comma
id|handler
comma
id|period
comma
id|dev_id
comma
id|handle
comma
id|bustime
)paren
suffix:semicolon
multiline_comment|/* Claim the USB bandwidth if no error. */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|dev-&gt;bus-&gt;bandwidth_allocated
op_add_assign
id|bustime
suffix:semicolon
id|dev-&gt;bus-&gt;bandwidth_int_reqs
op_increment
suffix:semicolon
id|PRINTD
(paren
l_string|&quot;bw_alloc bumped to %d for %d requesters&quot;
comma
id|dev-&gt;bus-&gt;bandwidth_allocated
comma
id|dev-&gt;bus-&gt;bandwidth_int_reqs
op_plus
id|dev-&gt;bus-&gt;bandwidth_isoc_reqs
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|usb_request_bulk
r_void
op_star
id|usb_request_bulk
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|pipe
comma
id|usb_device_irq
id|handler
comma
r_void
op_star
id|data
comma
r_int
id|len
comma
r_void
op_star
id|dev_id
)paren
(brace
r_return
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|request_bulk
c_func
(paren
id|dev
comma
id|pipe
comma
id|handler
comma
id|data
comma
id|len
comma
id|dev_id
)paren
suffix:semicolon
)brace
DECL|function|usb_terminate_bulk
r_int
id|usb_terminate_bulk
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|first
)paren
(brace
r_return
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|terminate_bulk
c_func
(paren
id|dev
comma
id|first
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_release_bandwidth():&n; *&n; * called to release an interrupt pipe&squot;s bandwidth (in microseconds)&n; */
DECL|function|usb_release_bandwidth
r_void
id|usb_release_bandwidth
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|bw_alloc
)paren
(brace
id|dev-&gt;bus-&gt;bandwidth_allocated
op_sub_assign
id|bw_alloc
suffix:semicolon
id|dev-&gt;bus-&gt;bandwidth_int_reqs
op_decrement
suffix:semicolon
id|PRINTD
(paren
l_string|&quot;bw_alloc reduced to %d for %d requesters&quot;
comma
id|dev-&gt;bus-&gt;bandwidth_allocated
comma
id|dev-&gt;bus-&gt;bandwidth_int_reqs
op_plus
id|dev-&gt;bus-&gt;bandwidth_isoc_reqs
)paren
suffix:semicolon
)brace
DECL|function|usb_release_irq
r_int
id|usb_release_irq
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|handle
comma
r_int
r_int
id|pipe
)paren
(brace
r_int
id|bustime
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|release_irq
c_func
(paren
id|dev
comma
id|handle
)paren
suffix:semicolon
multiline_comment|/* Return the USB bandwidth if no error. */
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|bustime
op_assign
id|calc_bus_time
(paren
id|usb_pipeslow
c_func
(paren
id|pipe
)paren
comma
id|usb_pipein
c_func
(paren
id|pipe
)paren
comma
l_int|0
comma
id|usb_maxpacket
c_func
(paren
id|dev
comma
id|pipe
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
)paren
)paren
suffix:semicolon
id|bustime
op_assign
id|NS_TO_US
c_func
(paren
id|bustime
)paren
suffix:semicolon
multiline_comment|/* work in microseconds */
id|usb_release_bandwidth
c_func
(paren
id|dev
comma
id|bustime
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_get_current_frame_number()&n; *&n; * returns the current frame number for the parent USB bus/controller&n; * of the given USB device.&n; */
DECL|function|usb_get_current_frame_number
r_int
id|usb_get_current_frame_number
(paren
r_struct
id|usb_device
op_star
id|usb_dev
)paren
(brace
r_return
id|usb_dev-&gt;bus-&gt;op-&gt;get_frame_number
(paren
id|usb_dev
)paren
suffix:semicolon
)brace
DECL|function|usb_init_isoc
r_int
id|usb_init_isoc
(paren
r_struct
id|usb_device
op_star
id|usb_dev
comma
r_int
r_int
id|pipe
comma
r_int
id|frame_count
comma
r_void
op_star
id|context
comma
r_struct
id|usb_isoc_desc
op_star
op_star
id|isocdesc
)paren
(brace
r_int
id|bustime
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|frame_count
op_le
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Check host controller&squot;s bandwidth for this Isoc. request. */
multiline_comment|/* TBD: some way to factor in frame_spacing ??? */
id|bustime
op_assign
id|calc_bus_time
(paren
l_int|0
comma
id|usb_pipein
c_func
(paren
id|pipe
)paren
comma
l_int|1
comma
id|usb_maxpacket
c_func
(paren
id|usb_dev
comma
id|pipe
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
)paren
)paren
suffix:semicolon
id|bustime
op_assign
id|NS_TO_US
c_func
(paren
id|bustime
)paren
op_div
id|frame_count
suffix:semicolon
multiline_comment|/* work in microseconds */
r_if
c_cond
(paren
id|check_bandwidth_alloc
(paren
id|usb_dev-&gt;bus-&gt;bandwidth_allocated
comma
id|bustime
)paren
)paren
r_return
id|USB_ST_BANDWIDTH_ERROR
suffix:semicolon
id|err
op_assign
id|usb_dev-&gt;bus-&gt;op-&gt;init_isoc
(paren
id|usb_dev
comma
id|pipe
comma
id|frame_count
comma
id|context
comma
id|isocdesc
)paren
suffix:semicolon
multiline_comment|/* Claim the USB bandwidth if no error. */
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|usb_dev-&gt;bus-&gt;bandwidth_allocated
op_add_assign
id|bustime
suffix:semicolon
id|usb_dev-&gt;bus-&gt;bandwidth_isoc_reqs
op_increment
suffix:semicolon
id|PRINTD
(paren
l_string|&quot;bw_alloc bumped to %d for %d requesters&quot;
comma
id|usb_dev-&gt;bus-&gt;bandwidth_allocated
comma
id|usb_dev-&gt;bus-&gt;bandwidth_int_reqs
op_plus
id|usb_dev-&gt;bus-&gt;bandwidth_isoc_reqs
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|usb_free_isoc
r_void
id|usb_free_isoc
(paren
r_struct
id|usb_isoc_desc
op_star
id|isocdesc
)paren
(brace
r_int
id|bustime
suffix:semicolon
multiline_comment|/* Return the USB bandwidth. */
id|bustime
op_assign
id|calc_bus_time
(paren
l_int|0
comma
id|usb_pipein
c_func
(paren
id|isocdesc-&gt;pipe
)paren
comma
l_int|1
comma
id|usb_maxpacket
c_func
(paren
id|isocdesc-&gt;usb_dev
comma
id|isocdesc-&gt;pipe
comma
id|usb_pipeout
c_func
(paren
id|isocdesc-&gt;pipe
)paren
)paren
)paren
suffix:semicolon
id|bustime
op_assign
id|NS_TO_US
c_func
(paren
id|bustime
)paren
op_div
id|isocdesc-&gt;frame_count
suffix:semicolon
id|isocdesc-&gt;usb_dev-&gt;bus-&gt;bandwidth_allocated
op_sub_assign
id|bustime
suffix:semicolon
id|isocdesc-&gt;usb_dev-&gt;bus-&gt;bandwidth_isoc_reqs
op_decrement
suffix:semicolon
id|PRINTD
(paren
l_string|&quot;bw_alloc reduced to %d for %d requesters&quot;
comma
id|isocdesc-&gt;usb_dev-&gt;bus-&gt;bandwidth_allocated
comma
id|isocdesc-&gt;usb_dev-&gt;bus-&gt;bandwidth_int_reqs
op_plus
id|isocdesc-&gt;usb_dev-&gt;bus-&gt;bandwidth_isoc_reqs
)paren
suffix:semicolon
id|isocdesc-&gt;usb_dev-&gt;bus-&gt;op-&gt;free_isoc
(paren
id|isocdesc
)paren
suffix:semicolon
)brace
DECL|function|usb_run_isoc
r_int
id|usb_run_isoc
(paren
r_struct
id|usb_isoc_desc
op_star
id|isocdesc
comma
r_struct
id|usb_isoc_desc
op_star
id|pr_isocdesc
)paren
(brace
r_return
id|isocdesc-&gt;usb_dev-&gt;bus-&gt;op-&gt;run_isoc
(paren
id|isocdesc
comma
id|pr_isocdesc
)paren
suffix:semicolon
)brace
DECL|function|usb_kill_isoc
r_int
id|usb_kill_isoc
(paren
r_struct
id|usb_isoc_desc
op_star
id|isocdesc
)paren
(brace
r_return
id|isocdesc-&gt;usb_dev-&gt;bus-&gt;op-&gt;kill_isoc
(paren
id|isocdesc
)paren
suffix:semicolon
)brace
DECL|function|usb_open
r_static
r_int
id|usb_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|usb_driver
op_star
id|c
op_assign
id|usb_minors
(braket
id|minor
op_div
l_int|16
)braket
suffix:semicolon
id|file-&gt;f_op
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|file-&gt;f_op
op_assign
id|c-&gt;fops
)paren
op_logical_and
id|file-&gt;f_op-&gt;open
)paren
r_return
id|file-&gt;f_op
op_member_access_from_pointer
id|open
c_func
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
r_else
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|variable|usb_fops
r_static
r_struct
id|file_operations
id|usb_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* seek */
l_int|NULL
comma
multiline_comment|/* read */
l_int|NULL
comma
multiline_comment|/* write */
l_int|NULL
comma
multiline_comment|/* readdir */
l_int|NULL
comma
multiline_comment|/* poll */
l_int|NULL
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|usb_open
comma
l_int|NULL
comma
multiline_comment|/* flush */
l_int|NULL
multiline_comment|/* release */
)brace
suffix:semicolon
DECL|function|usb_major_init
r_void
id|usb_major_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|register_chrdev
c_func
(paren
l_int|180
comma
l_string|&quot;usb&quot;
comma
op_amp
id|usb_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;unable to get major %d for usb devices&bslash;n&quot;
comma
id|MISC_MAJOR
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|usb_driver_get_list
r_struct
id|list_head
op_star
id|usb_driver_get_list
c_func
(paren
r_void
)paren
(brace
r_return
op_amp
id|usb_driver_list
suffix:semicolon
)brace
DECL|function|usb_bus_get_list
r_struct
id|list_head
op_star
id|usb_bus_get_list
c_func
(paren
r_void
)paren
(brace
r_return
op_amp
id|usb_bus_list
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * USB may be built into the kernel or be built as modules.&n; * If the USB core [and maybe a host controller driver] is built&n; * into the kernel, and other device drivers are built as modules,&n; * then these symbols need to be exported for the modules to use.&n; */
DECL|variable|usb_register
id|EXPORT_SYMBOL
c_func
(paren
id|usb_register
)paren
suffix:semicolon
DECL|variable|usb_deregister
id|EXPORT_SYMBOL
c_func
(paren
id|usb_deregister
)paren
suffix:semicolon
DECL|variable|usb_alloc_bus
id|EXPORT_SYMBOL
c_func
(paren
id|usb_alloc_bus
)paren
suffix:semicolon
DECL|variable|usb_free_bus
id|EXPORT_SYMBOL
c_func
(paren
id|usb_free_bus
)paren
suffix:semicolon
DECL|variable|usb_register_bus
id|EXPORT_SYMBOL
c_func
(paren
id|usb_register_bus
)paren
suffix:semicolon
DECL|variable|usb_deregister_bus
id|EXPORT_SYMBOL
c_func
(paren
id|usb_deregister_bus
)paren
suffix:semicolon
DECL|variable|usb_alloc_dev
id|EXPORT_SYMBOL
c_func
(paren
id|usb_alloc_dev
)paren
suffix:semicolon
DECL|variable|usb_free_dev
id|EXPORT_SYMBOL
c_func
(paren
id|usb_free_dev
)paren
suffix:semicolon
DECL|variable|usb_inc_dev_use
id|EXPORT_SYMBOL
c_func
(paren
id|usb_inc_dev_use
)paren
suffix:semicolon
DECL|variable|usb_init_root_hub
id|EXPORT_SYMBOL
c_func
(paren
id|usb_init_root_hub
)paren
suffix:semicolon
DECL|variable|usb_new_device
id|EXPORT_SYMBOL
c_func
(paren
id|usb_new_device
)paren
suffix:semicolon
DECL|variable|usb_connect
id|EXPORT_SYMBOL
c_func
(paren
id|usb_connect
)paren
suffix:semicolon
DECL|variable|usb_disconnect
id|EXPORT_SYMBOL
c_func
(paren
id|usb_disconnect
)paren
suffix:semicolon
DECL|variable|usb_release_bandwidth
id|EXPORT_SYMBOL
c_func
(paren
id|usb_release_bandwidth
)paren
suffix:semicolon
DECL|variable|usb_set_address
id|EXPORT_SYMBOL
c_func
(paren
id|usb_set_address
)paren
suffix:semicolon
DECL|variable|usb_get_descriptor
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_descriptor
)paren
suffix:semicolon
DECL|variable|usb_get_string
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_string
)paren
suffix:semicolon
DECL|variable|usb_string
id|EXPORT_SYMBOL
c_func
(paren
id|usb_string
)paren
suffix:semicolon
DECL|variable|usb_get_protocol
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_protocol
)paren
suffix:semicolon
DECL|variable|usb_set_protocol
id|EXPORT_SYMBOL
c_func
(paren
id|usb_set_protocol
)paren
suffix:semicolon
DECL|variable|usb_get_report
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_report
)paren
suffix:semicolon
DECL|variable|usb_set_idle
id|EXPORT_SYMBOL
c_func
(paren
id|usb_set_idle
)paren
suffix:semicolon
DECL|variable|usb_clear_halt
id|EXPORT_SYMBOL
c_func
(paren
id|usb_clear_halt
)paren
suffix:semicolon
DECL|variable|usb_set_interface
id|EXPORT_SYMBOL
c_func
(paren
id|usb_set_interface
)paren
suffix:semicolon
DECL|variable|usb_get_configuration
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_configuration
)paren
suffix:semicolon
DECL|variable|usb_set_configuration
id|EXPORT_SYMBOL
c_func
(paren
id|usb_set_configuration
)paren
suffix:semicolon
DECL|variable|usb_control_msg
id|EXPORT_SYMBOL
c_func
(paren
id|usb_control_msg
)paren
suffix:semicolon
DECL|variable|usb_request_irq
id|EXPORT_SYMBOL
c_func
(paren
id|usb_request_irq
)paren
suffix:semicolon
DECL|variable|usb_release_irq
id|EXPORT_SYMBOL
c_func
(paren
id|usb_release_irq
)paren
suffix:semicolon
multiline_comment|/* EXPORT_SYMBOL(usb_bulk_msg); */
DECL|variable|usb_request_bulk
id|EXPORT_SYMBOL
c_func
(paren
id|usb_request_bulk
)paren
suffix:semicolon
DECL|variable|usb_terminate_bulk
id|EXPORT_SYMBOL
c_func
(paren
id|usb_terminate_bulk
)paren
suffix:semicolon
DECL|variable|usb_get_current_frame_number
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_current_frame_number
)paren
suffix:semicolon
DECL|variable|usb_init_isoc
id|EXPORT_SYMBOL
c_func
(paren
id|usb_init_isoc
)paren
suffix:semicolon
DECL|variable|usb_free_isoc
id|EXPORT_SYMBOL
c_func
(paren
id|usb_free_isoc
)paren
suffix:semicolon
DECL|variable|usb_run_isoc
id|EXPORT_SYMBOL
c_func
(paren
id|usb_run_isoc
)paren
suffix:semicolon
DECL|variable|usb_kill_isoc
id|EXPORT_SYMBOL
c_func
(paren
id|usb_kill_isoc
)paren
suffix:semicolon
eof
