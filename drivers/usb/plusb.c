multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *      plusb.c  --  prolific pl-2301/pl-2302 driver.&n; *&n; *      Copyright (C) 2000  Deti Fliegl (deti@fliegl.de)&n; *      Copyright (C) 2000  Pavel Machek (pavel@suse.cz)&n; *      Copyright (C) 2000  Eric Z. Ayers (eric@compgen.com)&n; *&n; *      This program is free software; you can redistribute it and/or modify&n; *      it under the terms of the GNU General Public License as published by&n; *      the Free Software Foundation; either version 2 of the License, or&n; *      (at your option) any later version.&n; *&n; *      This program is distributed in the hope that it will be useful,&n; *      but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *      GNU General Public License for more details.&n; *&n; *      You should have received a copy of the GNU General Public License&n; *      along with this program; if not, write to the Free Software&n; *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *&n; *  This driver creates a network interface (plusb0, plusb1, ...) that will&n; *  send messages over a USB host-host cable based on the Prolific ASIC.&n; *  It works a lot like plip or PP over an RS-232C null modem cable.&n; *&n; *  Expect speeds of around 330Kbytes/second over a UHCI host controller.&n; *  OHCI should be faster.  Increase the MTU for faster transfers of large&n; *  files (up-to 800Kbytes/second).  (16384 is a good size)&n; *&n; *  $Id: plusb.c,v 1.18 2000/02/14 10:38:58 fliegl Exp $&n; *&n; *  Changelog:&n; *&n; *    v0.1                deti&n; *        Original Version of driver.&n; *    v0.2     15 Sep 2000  pavel&n; *        Patches to decrease latency by rescheduling the bottom half of&n; *          interrupt code.&n; *    v0.3     10 Oct 2000  eric&n; *        Patches to work in v2.2 backport (v2.4 changes the way net_dev.name&n; *          is allocated)&n; *    v0.4     19 Oct 2000  eric&n; *        Some more performance fixes.  Lock re-submitting urbs.&n; *          Lower the number of sk_buff&squot;s to queue.&n; *    v0.5     25 Oct 2000 eric&n; *        Removed use of usb_bulk_msg() all together.  This caused&n; *          the driver to block in an interrupt context.&n; *        Consolidate read urb submission into read_urb_submit().&n; *        Performance is the same as v0.4.&n; *    v0.5.1   27 Oct 2000 eric&n; *        Extra debugging messages to help diagnose problem with uchi.o stack.&n; *    v0.5.2   27 Oct 2000 eric&n; *        Set the &squot;start&squot; flag for the network device in plusb_net_start()&n; *         and plusb_net_stop() (doesn&squot;t help)&n; *    v0.5.3   27 Oct 2000 pavel&n; *        Commented out handlers when -EPIPE is received,&n; *         (remove calls to usb_clear_halt()) Since the callback is in&n; *         an interrupt context, it doesn&squot;t help, it just panics&n; *         the kernel. (what do we do?)&n; *        Under high load, dev_alloc_skb() fails, the read URB must&n; *         be re-submitted.&n; *        Added plusb_change_mtu() and increased the size of _BULK_DATA_LEN&n; *    v0.5.4   31 Oct 2000 eric&n; *        Fix race between plusb_net_xmit() and plusb_bulk_write_complete()&n; *    v0.5.5    1 Nov 2000 eric&n; *        Remove dev-&gt;start field, otherwise, it won&squot;t compile in 2.4&n; *        Use dev_kfree_skb_any(). (important in 2.4 kernel)&n; *    v0.5.6   2 Nov 2000 pavel,eric&n; *        Add calls to netif_stop_queue() and netif_start_queue()&n; *        Drop packets that come in while the free list is empty.&n; *        (This version is being submitted after the release of 2.4-test10)&n; *    v0.5.7   6 Nov 2000&n; *        Fix to not re-submit the urb on error to help when cables&n; *          are yanked (not tested)&n; *&n; *&n; * KNOWN PROBLEMS: (Any suggestions greatfully accepted!)&n; *&n; *     2 Nov 2000&n; *      - The shutdown for this may not be entirely clean.  Sometimes, the&n; *         kernel will Oops when the cable is unplugged, or&n; *         if the plusb module is removed.&n; *      - If you ifdown a device and then ifup it again, the link will not&n; *         always work.  You have to &squot;rmmod plusb ; modprobe plusb&squot; on&n; *         both machines to get it to work again.  Something must be wrong with&n; *         plusb_net_open() and plusb_net_start() ?  Maybe&n; *         the &squot;suspend&squot; and &squot;resume&squot; entry points need to be&n; *         implemented?&n; *      - Needs to handle -EPIPE correctly in bulk complete handlers.&n; *         (replace usb_clear_halt() function with async urbs?)&n; *      - I think this code relies too much on one spinlock and does&n; *         too much in the interrupt handler.  The net1080 code is&n; *         much more elegant, and should work for this chip.  Its&n; *         only drawback is that it is going to be tough to backport&n; *         it to v2.2.&n; *      - Occasionally the device will hang under the &squot;uhci.o&squot;&n; *         driver.   The workaround is to ifdown the device and&n; *         remove the modules, then re-insert them.  You may have&n; *         better luck with the &squot;usb-uhci.o&squot; driver.&n; *      - After using ifconfig down ; ifconfig up, sometimes packets&n; *         continue to be received, but there is a framing problem.&n; *&n; * FUTURE DIRECTIONS:&n; *&n; *     - Fix the known problems.&n; *     - There isn&squot;t much functional difference between the net1080&n; *        driver and this one.  It would be neat if the same driver&n; *        could handle both types of chips.  Or if both drivers&n; *        could handle both types of chips - this one is easier to&n; *        backport to the 2.2 kernel.&n; *     - Get rid of plusb_add_buf_tail and the single spinlock.&n; *        Use a separate spinlock for the 2 lists, and use atomic&n; *        operators for writeurb_submitted and readurb_submitted members.&n; *&n; *&n; */
multiline_comment|/*****************************************************************************/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
singleline_comment|//#define DEBUG 1
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#if (LINUX_VERSION_CODE &lt; 0x020300)
DECL|macro|dev_kfree_skb_any
mdefine_line|#define dev_kfree_skb_any dev_kfree_skb
macro_line|#endif
multiline_comment|/* Definitions formerly in plusb.h relocated. No need to export them -EZA */
DECL|macro|_PLUSB_INTPIPE
mdefine_line|#define _PLUSB_INTPIPE&t;&t;0x1
DECL|macro|_PLUSB_BULKOUTPIPE
mdefine_line|#define _PLUSB_BULKOUTPIPE&t;0x2
DECL|macro|_PLUSB_BULKINPIPE
mdefine_line|#define _PLUSB_BULKINPIPE&t;0x3
DECL|macro|_SKB_NUM
mdefine_line|#define _SKB_NUM&t;&t;32
multiline_comment|/* increase size of BULK_DATA_LEN so we can use bigger MTU&squot;s*/
DECL|macro|_BULK_DATA_LEN
mdefine_line|#define _BULK_DATA_LEN&t;&t;32768
r_typedef
r_struct
(brace
DECL|member|connected
r_int
id|connected
suffix:semicolon
multiline_comment|/* indicates if this structure is active */
DECL|member|usbdev
r_struct
id|usb_device
op_star
id|usbdev
suffix:semicolon
multiline_comment|/* keep track of USB structure */
DECL|member|status
r_int
id|status
suffix:semicolon
multiline_comment|/* Prolific status byte returned from interrupt */
DECL|member|in_bh
r_int
id|in_bh
suffix:semicolon
multiline_comment|/* flag to indicate that we are in the bulk handler */
DECL|member|opened
r_int
id|opened
suffix:semicolon
multiline_comment|/* flag to indicate that network dev is open    */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* Lock for the buffer list. re-used for&n;&t;&t;&t;&t;&t;&t;locking around submitting the readurb member.&n;&t;&t;&t;&t;&t; */
DECL|member|inturb
id|urb_t
op_star
id|inturb
suffix:semicolon
multiline_comment|/* Read buffer for the interrupt callback */
DECL|member|interrupt_in_buffer
r_int
r_char
op_star
id|interrupt_in_buffer
suffix:semicolon
multiline_comment|/* holds data for the inturb*/
DECL|member|readurb
id|urb_t
op_star
id|readurb
suffix:semicolon
multiline_comment|/* Read buffer for the bulk data callback */
DECL|member|bulk_in_buffer
r_int
r_char
op_star
id|bulk_in_buffer
suffix:semicolon
multiline_comment|/* kmalloc&squot;ed data for the readurb */
DECL|member|readurb_submitted
r_int
id|readurb_submitted
suffix:semicolon
multiline_comment|/* Flag to indicate that readurb already sent */
DECL|member|writeurb
id|urb_t
op_star
id|writeurb
suffix:semicolon
multiline_comment|/* Write buffer for the bulk data callback */
DECL|member|writeurb_submitted
r_int
id|writeurb_submitted
suffix:semicolon
multiline_comment|/* Flag to indicate that writeurb already sent */
DECL|member|tx_skb_list
r_struct
id|list_head
id|tx_skb_list
suffix:semicolon
multiline_comment|/* sk_buff&squot;s read from net device */
DECL|member|free_skb_list
r_struct
id|list_head
id|free_skb_list
suffix:semicolon
multiline_comment|/* free sk_buff list */
DECL|member|net_dev
r_struct
id|net_device
id|net_dev
suffix:semicolon
multiline_comment|/* handle to linux network device */
DECL|member|net_stats
r_struct
id|net_device_stats
id|net_stats
suffix:semicolon
multiline_comment|/* stats to return for ifconfig output */
DECL|typedef|plusb_t
DECL|typedef|pplusb_t
)brace
id|plusb_t
comma
op_star
id|pplusb_t
suffix:semicolon
multiline_comment|/*&n; * skb_list - queue of packets from the network driver to be delivered to USB&n; */
r_typedef
r_struct
(brace
DECL|member|skb_list
r_struct
id|list_head
id|skb_list
suffix:semicolon
DECL|member|skb
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
DECL|member|state
r_int
id|state
suffix:semicolon
DECL|member|s
id|plusb_t
op_star
id|s
suffix:semicolon
DECL|typedef|skb_list_t
DECL|typedef|pskb_list_t
)brace
id|skb_list_t
comma
op_star
id|pskb_list_t
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------- */
DECL|macro|NRPLUSB
mdefine_line|#define NRPLUSB 4
multiline_comment|/*&n; * Interrupt endpoint status byte, from Prolific PL-2301 docs&n; * Check the &squot;download&squot; link at www.prolifictech.com&n; */
DECL|macro|_PL_INT_RES1
mdefine_line|#define _PL_INT_RES1    0x80 /* reserved              */
DECL|macro|_PL_INT_RES2
mdefine_line|#define _PL_INT_RES2    0x40 /* reserved              */
DECL|macro|_PL_INT_RXD
mdefine_line|#define _PL_INT_RXD&t;_PL_INT_RES2  /* Read data ready - Not documented by Prolific, but seems to work! */
DECL|macro|_PL_INT_TX_RDY
mdefine_line|#define _PL_INT_TX_RDY&t;0x20 /* OK to transmit data   */
DECL|macro|_PL_INT_RESET_O
mdefine_line|#define _PL_INT_RESET_O&t;0x10 /* reset output pipe     */
DECL|macro|_PL_INT_RESET_I
mdefine_line|#define _PL_INT_RESET_I 0x08 /* reset input pipe      */
DECL|macro|_PL_INT_TX_C
mdefine_line|#define _PL_INT_TX_C    0x04 /* transmission complete */
DECL|macro|_PL_INT_TX_REQ
mdefine_line|#define _PL_INT_TX_REQ  0x02 /* transmission received */
DECL|macro|_PL_INT_PEER_E
mdefine_line|#define _PL_INT_PEER_E  0x01 /* peer exists           */
multiline_comment|/*-------------------------------------------------------------------*/
DECL|variable|plusb
r_static
id|plusb_t
id|plusb
(braket
id|NRPLUSB
)braket
suffix:semicolon
r_static
r_void
id|plusb_write_bulk_complete
c_func
(paren
id|urb_t
op_star
id|purb
)paren
suffix:semicolon
r_static
r_void
id|plusb_read_bulk_complete
c_func
(paren
id|urb_t
op_star
id|purb
)paren
suffix:semicolon
r_static
r_void
id|plusb_int_complete
c_func
(paren
id|urb_t
op_star
id|purb
)paren
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/*&n; * plusb_add_buf_tail - Take the head of the src list and append it to&n; *                      the tail of the dest list&n; */
DECL|function|plusb_add_buf_tail
r_static
r_int
id|plusb_add_buf_tail
(paren
id|plusb_t
op_star
id|s
comma
r_struct
id|list_head
op_star
id|dst
comma
r_struct
id|list_head
op_star
id|src
)paren
(brace
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
(paren
id|src
)paren
)paren
(brace
singleline_comment|// no elements in source buffer
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
id|tmp
op_assign
id|src-&gt;next
suffix:semicolon
id|list_del
(paren
id|tmp
)paren
suffix:semicolon
id|list_add_tail
(paren
id|tmp
comma
id|dst
)paren
suffix:semicolon
id|err
suffix:colon
id|spin_unlock_irqrestore
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/*&n; * dequeue_next_skb - submit the first thing on the tx_skb_list to the&n; * USB stack.  This function should be called each time we get a new&n; * message to send to the other host, or each time a message is sucessfully&n; * sent.&n; */
DECL|function|dequeue_next_skb
r_static
r_void
id|dequeue_next_skb
c_func
(paren
r_char
op_star
id|func
comma
id|plusb_t
op_star
id|s
)paren
(brace
id|skb_list_t
op_star
id|skb_list
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;connected
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|s-&gt;tx_skb_list
)paren
op_logical_and
op_logical_neg
id|s-&gt;writeurb_submitted
)paren
(brace
r_int
id|submit_ret
suffix:semicolon
id|skb_list
op_assign
id|list_entry
(paren
id|s-&gt;tx_skb_list.next
comma
id|skb_list_t
comma
id|skb_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_list-&gt;skb
)paren
(brace
id|s-&gt;writeurb_submitted
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Use the buffer inside the sk_buff directly. why copy? */
id|FILL_BULK_URB_TO
c_func
(paren
id|s-&gt;writeurb
comma
id|s-&gt;usbdev
comma
id|usb_sndbulkpipe
c_func
(paren
id|s-&gt;usbdev
comma
id|_PLUSB_BULKOUTPIPE
)paren
comma
id|skb_list-&gt;skb-&gt;data
comma
id|skb_list-&gt;skb-&gt;len
comma
id|plusb_write_bulk_complete
comma
id|skb_list
comma
l_int|500
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s: %s: submitting urb. skb_list %p&quot;
comma
id|s-&gt;net_dev.name
comma
id|func
comma
id|skb_list
)paren
suffix:semicolon
id|submit_ret
op_assign
id|usb_submit_urb
c_func
(paren
id|s-&gt;writeurb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|submit_ret
)paren
(brace
id|s-&gt;writeurb_submitted
op_assign
l_int|0
suffix:semicolon
id|printk
(paren
id|KERN_CRIT
l_string|&quot;%s: %s: can&squot;t submit writeurb: %d&bslash;n&quot;
comma
id|s-&gt;net_dev.name
comma
id|func
comma
id|submit_ret
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end if the skb value has been filled in */
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * submit_read_urb - re-submit the read URB to the stack&n; */
DECL|function|submit_read_urb
r_void
id|submit_read_urb
c_func
(paren
r_char
op_star
id|func
comma
id|plusb_t
op_star
id|s
)paren
(brace
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;connected
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;readurb_submitted
)paren
(brace
r_int
id|ret
suffix:semicolon
id|s-&gt;readurb_submitted
op_assign
l_int|1
suffix:semicolon
id|s-&gt;readurb-&gt;dev
op_assign
id|s-&gt;usbdev
suffix:semicolon
id|ret
op_assign
id|usb_submit_urb
c_func
(paren
id|s-&gt;readurb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
(paren
id|KERN_CRIT
l_string|&quot;%s: %s: error %d submitting read URB&bslash;n&quot;
comma
id|s-&gt;net_dev.name
comma
id|func
comma
id|ret
)paren
suffix:semicolon
id|s-&gt;readurb_submitted
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/*&n; * plusb_net_xmit - callback from the network device driver for outgoing data&n; *&n; * Data has arrived to the network device from the local machine and needs&n; * to be sent over the USB cable.  This is in an interrupt, so we don&squot;t&n; * want to spend too much time in this function.&n; *&n; */
DECL|function|plusb_net_xmit
r_static
r_int
id|plusb_net_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|plusb_t
op_star
id|s
op_assign
id|dev-&gt;priv
suffix:semicolon
id|skb_list_t
op_star
id|skb_list
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;plusb_net_xmit: len:%d i:%d&quot;
comma
id|skb-&gt;len
comma
id|in_interrupt
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;connected
op_logical_or
op_logical_neg
id|s-&gt;opened
)paren
(brace
multiline_comment|/*&n;&t;&t;  NOTE: If we get to this point, you&squot;ll return the error&n;&t;&t;  kernel: virtual device plusb0 asks to queue packet&n;&n;&t;&t;  Other things we could do:&n;&t;&t;  1) just drop this packet&n;&t;&t;  2) drop other packets in the queue&n;&t;&t;*/
r_return
l_int|1
suffix:semicolon
)brace
id|spin_lock_irqsave
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|s-&gt;free_skb_list
)paren
op_logical_or
id|plusb_add_buf_tail
(paren
id|s
comma
op_amp
id|s-&gt;tx_skb_list
comma
op_amp
id|s-&gt;free_skb_list
)paren
)paren
(brace
multiline_comment|/* The buffers on this side are full. DROP the packet&n;&t;&t;   I think that this shouldn&squot;t happen with the correct&n;&t;&t;   use of the netif_XXX functions -EZA&n;&t;&t; */
id|dbg
(paren
l_string|&quot;plusb: Free list is empty.&quot;
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|s-&gt;net_stats.tx_dropped
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|skb_list
op_assign
id|list_entry
(paren
id|s-&gt;tx_skb_list.prev
comma
id|skb_list_t
comma
id|skb_list
)paren
suffix:semicolon
id|skb_list-&gt;skb
op_assign
id|skb
suffix:semicolon
id|skb_list-&gt;state
op_assign
l_int|1
suffix:semicolon
id|skb_list-&gt;s
op_assign
id|s
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|s-&gt;free_skb_list
)paren
)paren
(brace
multiline_comment|/* apply &quot;backpressure&quot;. Tell the net layer to stop sending&n;&t;&t;   the driver packets.&n;&t;&t;*/
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* If there is no write urb outstanding, pull the first thing&n;&t;   off of the list and submit it to the USB stack&n;&t;*/
id|dequeue_next_skb
c_func
(paren
l_string|&quot;plusb_net_xmit&quot;
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/*&n; * plusb_write_bulk_complete () - callback after the data has been&n; *   sent to the USB device, or a timeout occured.&n; */
DECL|function|plusb_write_bulk_complete
r_static
r_void
id|plusb_write_bulk_complete
c_func
(paren
id|urb_t
op_star
id|purb
)paren
(brace
id|skb_list_t
op_star
id|skb_list
op_assign
id|purb-&gt;context
suffix:semicolon
id|plusb_t
op_star
id|s
op_assign
id|skb_list-&gt;s
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s: plusb_write_bulk_complete: status:%d skb_list:%p&bslash;n&quot;
comma
id|s-&gt;net_dev.name
comma
id|purb-&gt;status
comma
id|skb_list
)paren
suffix:semicolon
id|skb_list-&gt;state
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|purb-&gt;status
op_eq
op_minus
id|EPIPE
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s: plusb_write_bulk_complete: got -EPIPE and don&squot;t know what to do!&bslash;n&quot;
comma
id|s-&gt;net_dev.name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|purb-&gt;status
)paren
(brace
id|s-&gt;net_stats.tx_packets
op_increment
suffix:semicolon
id|s-&gt;net_stats.tx_bytes
op_add_assign
id|skb_list-&gt;skb-&gt;len
suffix:semicolon
)brace
r_else
(brace
id|err
(paren
l_string|&quot;%s: plusb_write_bulk_complete: returned ERROR status:%d&bslash;n&quot;
comma
id|s-&gt;net_dev.name
comma
id|purb-&gt;status
)paren
suffix:semicolon
id|s-&gt;net_stats.tx_errors
op_increment
suffix:semicolon
id|s-&gt;net_stats.tx_aborted_errors
op_increment
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;plusb_bh: dev_kfree_skb&quot;
)paren
suffix:semicolon
multiline_comment|/* NOTE: In 2.4 it&squot;s a problem to call dev_kfree_skb() in a hard IRQ:&n;&t;   Oct 28 23:42:14 bug kernel: Warning: kfree_skb on hard IRQ c023329a&n;&t;*/
id|dev_kfree_skb_any
c_func
(paren
id|skb_list-&gt;skb
)paren
suffix:semicolon
id|skb_list-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|plusb_add_buf_tail
(paren
id|s
comma
op_amp
id|s-&gt;free_skb_list
comma
op_amp
id|s-&gt;tx_skb_list
)paren
)paren
(brace
id|err
(paren
l_string|&quot;plusb: tx list empty. This shouldn&squot;t happen.&quot;
)paren
suffix:semicolon
)brace
id|purb-&gt;status
op_assign
l_int|0
suffix:semicolon
id|s-&gt;writeurb_submitted
op_assign
l_int|0
suffix:semicolon
id|netif_wake_queue
c_func
(paren
(paren
op_amp
id|s-&gt;net_dev
)paren
)paren
suffix:semicolon
id|dequeue_next_skb
c_func
(paren
l_string|&quot;plusb_write_bulk_complete&quot;
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * plusb_read_bulk_complete - Callback for data arriving from the USB device&n; *&n; * This gets called back when a full &squot;urb&squot; is received from the remote system.&n; * This urb was allocated by this driver and is kept in the member: s-&gt;readurb&n; *&n; */
DECL|function|plusb_read_bulk_complete
r_static
r_void
id|plusb_read_bulk_complete
c_func
(paren
id|urb_t
op_star
id|purb
)paren
(brace
id|plusb_t
op_star
id|s
op_assign
id|purb-&gt;context
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;plusb_read_bulk_complete: status:%d length:%d&quot;
comma
id|purb-&gt;status
comma
id|purb-&gt;actual_length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;connected
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|purb-&gt;status
op_eq
op_minus
id|EPIPE
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s: plusb_read_bulk_complete: got -EPIPE and I don&squot;t know what to do!&bslash;n&quot;
comma
id|s-&gt;net_dev.name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|purb-&gt;status
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_char
op_star
id|dst
suffix:semicolon
r_int
id|len
op_assign
id|purb-&gt;transfer_buffer_length
suffix:semicolon
r_struct
id|net_device_stats
op_star
id|stats
op_assign
op_amp
id|s-&gt;net_stats
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|printk
(paren
id|KERN_CRIT
l_string|&quot;%s: plusb_read_bulk_complete: dev_alloc_skb(%d)=NULL, dropping frame&bslash;n&quot;
comma
id|s-&gt;net_dev.name
comma
id|len
)paren
suffix:semicolon
id|stats-&gt;rx_dropped
op_increment
suffix:semicolon
)brace
r_else
(brace
id|dst
op_assign
(paren
r_char
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dst
comma
id|purb-&gt;transfer_buffer
comma
id|len
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
op_amp
id|s-&gt;net_dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|skb-&gt;dev
)paren
suffix:semicolon
id|stats-&gt;rx_packets
op_increment
suffix:semicolon
id|stats-&gt;rx_bytes
op_add_assign
id|len
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
id|s-&gt;readurb_submitted
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|purb-&gt;status
)paren
(brace
multiline_comment|/* Give the system a chance to &quot;catch its breath&quot;. Shortcut&n;&t;&t;   re-submitting the read URB&gt;  It will be re-submitted if&n;&t;&t;   another interrupt comes back.  The problem scenario is that&n;&t;&t;   the plub is pulled and the read returns an error.&n;&t;&t;   You don&squot;t want to resumbit in this case.&n;&t;&t;*/
id|err
(paren
l_string|&quot;%s: plusb_read_bulk_complete: returned status %d&bslash;n&quot;
comma
id|s-&gt;net_dev.name
comma
id|purb-&gt;status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|purb-&gt;status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Keep it coming! resubmit the URB for reading.. Make sure&n;&t;   we aren&squot;t in contention with the interrupt callback.&n;&t;*/
id|submit_read_urb
c_func
(paren
l_string|&quot;plusb_read_bulk_complete&quot;
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/*&n; * plusb_int_complete - USB driver callback for interrupt msg from the device&n; *&n; * Interrupts are scheduled to go off on a periodic basis (see FILL_INT_URB)&n; * For the prolific device, this is basically just returning a register&n; * filled with bits.  See the macro definitions for _PL_INT_XXX above.&n; * Most of these bits are for implementing a machine-machine protocol&n; * and can be set with a special message (described as the &quot;Quicklink&quot;&n; * feature in the prolific documentation.)&n; *&n; * I don&squot;t think we need any of that to work as a network device. If a&n; * message is lost, big deal - that&squot;s what UNIX networking expects from&n; * the physical layer.&n; *&n; */
DECL|function|plusb_int_complete
r_static
r_void
id|plusb_int_complete
c_func
(paren
id|urb_t
op_star
id|purb
)paren
(brace
id|plusb_t
op_star
id|s
op_assign
id|purb-&gt;context
suffix:semicolon
id|s-&gt;status
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|purb-&gt;transfer_buffer
)paren
(braket
l_int|0
)braket
op_amp
l_int|255
suffix:semicolon
macro_line|#if 0
multiline_comment|/* This isn&squot;t right because 0x20 is TX_RDY and&n;&t;   sometimes will not be set&n;&t;*/
r_if
c_cond
(paren
(paren
id|s-&gt;status
op_amp
l_int|0x3f
)paren
op_ne
l_int|0x20
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;invalid device status %02X&quot;
comma
id|s-&gt;status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif&t;
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;connected
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t turn this on unless you want to see the log flooded. */
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;plusb_int_complete: PEER_E:%d TX_REQ:%d TX_C:%d RESET_IN:%d RESET_O: %d TX_RDY:%d RES1:%d RES2:%d&bslash;n&quot;
comma
id|s-&gt;status
op_amp
id|_PL_INT_PEER_E
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|s-&gt;status
op_amp
id|_PL_INT_TX_REQ
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|s-&gt;status
op_amp
id|_PL_INT_TX_C
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|s-&gt;status
op_amp
id|_PL_INT_RESET_I
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|s-&gt;status
op_amp
id|_PL_INT_RESET_O
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|s-&gt;status
op_amp
id|_PL_INT_TX_RDY
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|s-&gt;status
op_amp
id|_PL_INT_RES1
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|s-&gt;status
op_amp
id|_PL_INT_RES2
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 1
multiline_comment|/* At first glance, this logic appears to not really be needed, but&n;&t;   it can help recover from intermittent problems where the&n;&t;   usb_submit_urb() fails in the read callback. -EZA&n;&t;*/
multiline_comment|/* Try to submit the read URB again. Make sure&n;&t;   we aren&squot;t in contention with the bulk read callback&n;&t;*/
id|submit_read_urb
(paren
l_string|&quot;plusb_int_complete&quot;
comma
id|s
)paren
suffix:semicolon
multiline_comment|/* While we are at it, why not check to see if the&n;&t;   write urb should be re-submitted?&n;&t;*/
id|dequeue_next_skb
c_func
(paren
l_string|&quot;plusb_int_complete&quot;
comma
id|s
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/*&n; * plusb_free_all - deallocate all memory kept for an instance of the device.&n; */
DECL|function|plusb_free_all
r_static
r_void
id|plusb_free_all
c_func
(paren
id|plusb_t
op_star
id|s
)paren
(brace
r_struct
id|list_head
op_star
id|skb
suffix:semicolon
id|skb_list_t
op_star
id|skb_list
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;plusb_free_all&quot;
)paren
suffix:semicolon
multiline_comment|/* set a flag to tell all callbacks to cease and desist */
id|s-&gt;connected
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If the interrupt handler is about to fire, let it finish up */
id|run_task_queue
c_func
(paren
op_amp
id|tq_immediate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;inturb
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;unlink inturb&quot;
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|s-&gt;inturb
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;free_urb inturb&quot;
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|s-&gt;inturb
)paren
suffix:semicolon
id|s-&gt;inturb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;interrupt_in_buffer
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;kfree s-&gt;interrupt_in_buffer&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|s-&gt;interrupt_in_buffer
)paren
suffix:semicolon
id|s-&gt;interrupt_in_buffer
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;readurb
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;unlink readurb&quot;
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|s-&gt;readurb
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;free_urb readurb:&quot;
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|s-&gt;readurb
)paren
suffix:semicolon
id|s-&gt;readurb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;bulk_in_buffer
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;kfree s-&gt;bulk_in_buffer&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|s-&gt;bulk_in_buffer
)paren
suffix:semicolon
id|s-&gt;bulk_in_buffer
op_assign
l_int|NULL
suffix:semicolon
)brace
id|s-&gt;readurb_submitted
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;writeurb
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;unlink writeurb&quot;
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|s-&gt;writeurb
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;free_urb writeurb:&quot;
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|s-&gt;writeurb
)paren
suffix:semicolon
id|s-&gt;writeurb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|s-&gt;writeurb_submitted
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|s-&gt;free_skb_list
)paren
)paren
(brace
id|skb
op_assign
id|s-&gt;free_skb_list.next
suffix:semicolon
id|list_del
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb_list
op_assign
id|list_entry
(paren
id|skb
comma
id|skb_list_t
comma
id|skb_list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|skb_list
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|s-&gt;tx_skb_list
)paren
)paren
(brace
id|skb
op_assign
id|s-&gt;tx_skb_list.next
suffix:semicolon
id|list_del
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb_list
op_assign
id|list_entry
(paren
id|skb
comma
id|skb_list_t
comma
id|skb_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_list-&gt;skb
)paren
(brace
id|dbg
(paren
l_string|&quot;Freeing SKB in queue&quot;
)paren
suffix:semicolon
id|dev_kfree_skb_any
c_func
(paren
id|skb_list-&gt;skb
)paren
suffix:semicolon
id|skb_list-&gt;skb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|skb_list
)paren
suffix:semicolon
)brace
id|s-&gt;in_bh
op_assign
l_int|0
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;plusb_free_all: finished&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/*&n; * plusb_alloc - allocate memory associated with one instance of the device&n; */
DECL|function|plusb_alloc
r_static
r_int
id|plusb_alloc
c_func
(paren
id|plusb_t
op_star
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
id|skb_list_t
op_star
id|skb
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;plusb_alloc&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|_SKB_NUM
suffix:semicolon
id|i
op_increment
)paren
(brace
id|skb
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|skb_list_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|err
c_func
(paren
l_string|&quot;kmalloc for skb_list failed&quot;
)paren
suffix:semicolon
r_goto
id|reject
suffix:semicolon
)brace
id|memset
c_func
(paren
id|skb
comma
l_int|0
comma
r_sizeof
(paren
id|skb_list_t
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|skb-&gt;skb_list
comma
op_amp
id|s-&gt;free_skb_list
)paren
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;inturb allocation:&quot;
)paren
suffix:semicolon
id|s-&gt;inturb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;inturb
)paren
(brace
id|err
c_func
(paren
l_string|&quot;alloc_urb failed&quot;
)paren
suffix:semicolon
r_goto
id|reject
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;bulk read urb allocation:&quot;
)paren
suffix:semicolon
id|s-&gt;readurb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;readurb
)paren
(brace
id|err
c_func
(paren
l_string|&quot;alloc_urb failed&quot;
)paren
suffix:semicolon
r_goto
id|reject
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;bulk write urb allocation:&quot;
)paren
suffix:semicolon
id|s-&gt;writeurb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;writeurb
)paren
(brace
id|err
c_func
(paren
l_string|&quot;alloc_urb for writeurb failed&quot;
)paren
suffix:semicolon
r_goto
id|reject
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;readurb/inturb init:&quot;
)paren
suffix:semicolon
id|s-&gt;interrupt_in_buffer
op_assign
id|kmalloc
c_func
(paren
l_int|64
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;interrupt_in_buffer
)paren
(brace
id|err
c_func
(paren
l_string|&quot;kmalloc failed&quot;
)paren
suffix:semicolon
r_goto
id|reject
suffix:semicolon
)brace
multiline_comment|/* The original value of &squot;10&squot; makes this interrupt fire off a LOT.&n;&t;   It was set so low because the callback determined when to&n;&t;   sumbit the buld read URB. I&squot;ve lowered it to 100 - the driver&n;&t;   doesn&squot;t depend on that logic anymore. -EZA&n;&t;*/
id|FILL_INT_URB
c_func
(paren
id|s-&gt;inturb
comma
id|s-&gt;usbdev
comma
id|usb_rcvintpipe
(paren
id|s-&gt;usbdev
comma
id|_PLUSB_INTPIPE
)paren
comma
id|s-&gt;interrupt_in_buffer
comma
l_int|1
comma
id|plusb_int_complete
comma
id|s
comma
id|HZ
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;inturb submission:&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
id|s-&gt;inturb
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;usb_submit_urb failed&quot;
)paren
suffix:semicolon
r_goto
id|reject
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;readurb init:&quot;
)paren
suffix:semicolon
id|s-&gt;bulk_in_buffer
op_assign
id|kmalloc
c_func
(paren
id|_BULK_DATA_LEN
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;bulk_in_buffer
)paren
(brace
id|err
c_func
(paren
l_string|&quot;kmalloc %d bytes for bulk in buffer failed&quot;
comma
id|_BULK_DATA_LEN
)paren
suffix:semicolon
)brace
id|FILL_BULK_URB
c_func
(paren
id|s-&gt;readurb
comma
id|s-&gt;usbdev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|s-&gt;usbdev
comma
id|_PLUSB_BULKINPIPE
)paren
comma
id|s-&gt;bulk_in_buffer
comma
id|_BULK_DATA_LEN
comma
id|plusb_read_bulk_complete
comma
id|s
)paren
suffix:semicolon
multiline_comment|/* The write urb will be initialized inside the network&n;&t;   interrupt.&n;&t;*/
multiline_comment|/* get the bulk read going */
id|submit_read_urb
c_func
(paren
l_string|&quot;plusb_alloc&quot;
comma
id|s
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;plusb_alloc: finished. readurb=%p writeurb=%p inturb=%p&quot;
comma
id|s-&gt;readurb
comma
id|s-&gt;writeurb
comma
id|s-&gt;inturb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|reject
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;plusb_alloc: failed&quot;
)paren
suffix:semicolon
id|plusb_free_all
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
DECL|function|plusb_net_open
r_static
r_int
id|plusb_net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|plusb_t
op_star
id|s
op_assign
id|dev-&gt;priv
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;plusb_net_open&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|plusb_alloc
c_func
(paren
id|s
)paren
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|s-&gt;opened
op_assign
l_int|1
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;plusb_net_open: success&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|plusb_net_stop
r_static
r_int
id|plusb_net_stop
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|plusb_t
op_star
id|s
op_assign
id|dev-&gt;priv
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;plusb_net_stop&quot;
)paren
suffix:semicolon
id|s-&gt;opened
op_assign
l_int|0
suffix:semicolon
id|plusb_free_all
c_func
(paren
id|s
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;plusb_net_stop:finished&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|plusb_net_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|plusb_net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|plusb_t
op_star
id|s
op_assign
id|dev-&gt;priv
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;net_device_stats&quot;
)paren
suffix:semicolon
r_return
op_amp
id|s-&gt;net_stats
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|plusb_find_struct
r_static
id|plusb_t
op_star
id|plusb_find_struct
(paren
r_void
)paren
(brace
r_int
id|u
suffix:semicolon
r_for
c_loop
(paren
id|u
op_assign
l_int|0
suffix:semicolon
id|u
OL
id|NRPLUSB
suffix:semicolon
id|u
op_increment
)paren
(brace
id|plusb_t
op_star
id|s
op_assign
op_amp
id|plusb
(braket
id|u
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;connected
)paren
r_return
id|s
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|plusb_disconnect
r_static
r_void
id|plusb_disconnect
(paren
r_struct
id|usb_device
op_star
id|usbdev
comma
r_void
op_star
id|ptr
)paren
(brace
id|plusb_t
op_star
id|s
op_assign
id|ptr
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;plusb_disconnect&quot;
)paren
suffix:semicolon
id|plusb_free_all
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;opened
op_logical_and
id|s-&gt;net_dev.name
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;unregistering netdev: %s&quot;
comma
id|s-&gt;net_dev.name
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
op_amp
id|s-&gt;net_dev
)paren
suffix:semicolon
id|s-&gt;net_dev.name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &lt; 0x020300)
id|dbg
c_func
(paren
l_string|&quot;plusb_disconnect: About to free name&quot;
)paren
suffix:semicolon
id|kfree
(paren
id|s-&gt;net_dev.name
)paren
suffix:semicolon
id|s-&gt;net_dev.name
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif&t;
)brace
id|dbg
c_func
(paren
l_string|&quot;plusb_disconnect: finished&quot;
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|plusb_change_mtu
r_static
r_int
id|plusb_change_mtu
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|new_mtu
)paren
(brace
r_if
c_cond
(paren
(paren
id|new_mtu
OL
l_int|68
)paren
op_logical_or
(paren
id|new_mtu
OG
id|_BULK_DATA_LEN
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;plusb: changing mtu to %d&bslash;n&quot;
comma
id|new_mtu
)paren
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|new_mtu
suffix:semicolon
multiline_comment|/* NOTE: Could we change the size of the READ URB here dynamically&n;&t;   to save kernel memory?&n;&t;*/
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|plusb_net_init
r_int
id|plusb_net_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;plusb_net_init&quot;
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|plusb_net_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|plusb_net_stop
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|plusb_net_xmit
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|plusb_net_get_stats
suffix:semicolon
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;change_mtu
op_assign
id|plusb_change_mtu
suffix:semicolon
multiline_comment|/* Setting the default MTU to 16K gives good performance for&n;&t;   me, and keeps the ping latency low too.  Setting it up&n;&t;   to 32K made performance go down. -EZA&n;&t;   Pavel says it would be best not to do this...&n;&t;*/
multiline_comment|/*dev-&gt;mtu=16384; */
id|dev-&gt;tx_queue_len
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;flags
op_assign
id|IFF_POINTOPOINT
op_or
id|IFF_NOARP
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;plusb_net_init: finished&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|plusb_probe
r_static
r_void
op_star
id|plusb_probe
(paren
r_struct
id|usb_device
op_star
id|usbdev
comma
r_int
r_int
id|ifnum
)paren
(brace
id|plusb_t
op_star
id|s
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;plusb: probe: vendor id 0x%x, device id 0x%x ifnum:%d&quot;
comma
id|usbdev-&gt;descriptor.idVendor
comma
id|usbdev-&gt;descriptor.idProduct
comma
id|ifnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usbdev-&gt;descriptor.idVendor
op_ne
l_int|0x067b
op_logical_or
id|usbdev-&gt;descriptor.idProduct
OG
l_int|0x1
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* We don&squot;t handle multiple configurations */
r_if
c_cond
(paren
id|usbdev-&gt;descriptor.bNumConfigurations
op_ne
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
id|s
op_assign
id|plusb_find_struct
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
r_return
l_int|NULL
suffix:semicolon
id|s-&gt;usbdev
op_assign
id|usbdev
suffix:semicolon
r_if
c_cond
(paren
id|usb_set_configuration
(paren
id|s-&gt;usbdev
comma
id|usbdev-&gt;config
(braket
l_int|0
)braket
dot
id|bConfigurationValue
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;set_configuration failed&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usb_set_interface
(paren
id|s-&gt;usbdev
comma
l_int|0
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;set_interface failed&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#if (LINUX_VERSION_CODE &lt; 0x020300)
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* For Kernel version 2.2, the driver is responsible for&n; &t;&t;   allocating this memory. For version 2.4, the rules&n; &t;&t;   have apparently changed, but there is a nifty function&n; &t;&t;   &squot;init_netdev&squot; that might make this easier...  It&squot;s in &n; &t;&t;   ../net/net_init.c - but can we get there from here?  (no)&n;&t;&t;   -EZA&n; &t;&t;*/
multiline_comment|/* Find the device number... we seem to have lost it... -EZA */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NRPLUSB
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_amp
id|plusb
(braket
id|i
)braket
op_eq
id|s
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;net_dev.name
)paren
(brace
id|s-&gt;net_dev.name
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
l_string|&quot;plusbXXXX&quot;
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|sprintf
(paren
id|s-&gt;net_dev.name
comma
l_string|&quot;plusb%d&quot;
comma
id|i
)paren
suffix:semicolon
id|s-&gt;net_dev.init
op_assign
id|plusb_net_init
suffix:semicolon
id|s-&gt;net_dev.priv
op_assign
id|s
suffix:semicolon
id|printk
(paren
l_string|&quot;plusb_probe: Registering Device&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|register_netdev
c_func
(paren
op_amp
id|s-&gt;net_dev
)paren
)paren
(brace
id|info
c_func
(paren
l_string|&quot;registered: %s&quot;
comma
id|s-&gt;net_dev.name
)paren
suffix:semicolon
)brace
r_else
(brace
id|err
c_func
(paren
l_string|&quot;register_netdev failed&quot;
)paren
suffix:semicolon
id|s-&gt;net_dev.name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
id|dbg
(paren
l_string|&quot;plusb_probe: Connected!&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
multiline_comment|/* Kernel version 2.3+ works a little bit differently than 2.2 */
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;net_dev.name
(braket
l_int|0
)braket
)paren
(brace
id|strcpy
c_func
(paren
id|s-&gt;net_dev.name
comma
l_string|&quot;plusb%d&quot;
)paren
suffix:semicolon
id|s-&gt;net_dev.init
op_assign
id|plusb_net_init
suffix:semicolon
id|s-&gt;net_dev.priv
op_assign
id|s
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|register_netdev
c_func
(paren
op_amp
id|s-&gt;net_dev
)paren
)paren
(brace
id|info
c_func
(paren
l_string|&quot;registered: %s&quot;
comma
id|s-&gt;net_dev.name
)paren
suffix:semicolon
)brace
r_else
(brace
id|err
c_func
(paren
l_string|&quot;register_netdev failed&quot;
)paren
suffix:semicolon
id|s-&gt;net_dev.name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
macro_line|#endif
id|s-&gt;connected
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;opened
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;net device already allocated, restarting USB transfers&quot;
)paren
suffix:semicolon
id|plusb_alloc
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
id|info
c_func
(paren
l_string|&quot;bound to interface: %d dev: %p&quot;
comma
id|ifnum
comma
id|usbdev
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
id|s
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|variable|plusb_driver
r_static
r_struct
id|usb_driver
id|plusb_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;plusb&quot;
comma
id|probe
suffix:colon
id|plusb_probe
comma
id|disconnect
suffix:colon
id|plusb_disconnect
comma
)brace
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|plusb_init
r_static
r_int
id|__init
id|plusb_init
(paren
r_void
)paren
(brace
r_int
id|u
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;plusb_init&quot;
)paren
suffix:semicolon
multiline_comment|/* initialize struct */
r_for
c_loop
(paren
id|u
op_assign
l_int|0
suffix:semicolon
id|u
OL
id|NRPLUSB
suffix:semicolon
id|u
op_increment
)paren
(brace
id|plusb_t
op_star
id|s
op_assign
op_amp
id|plusb
(braket
id|u
)braket
suffix:semicolon
id|memset
(paren
id|s
comma
l_int|0
comma
r_sizeof
(paren
id|plusb_t
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|s-&gt;tx_skb_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|s-&gt;free_skb_list
)paren
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* register misc device */
id|usb_register
(paren
op_amp
id|plusb_driver
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;plusb_init: driver registered&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|plusb_cleanup
r_static
r_void
id|__exit
id|plusb_cleanup
(paren
r_void
)paren
(brace
r_int
id|u
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;plusb_cleanup&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|u
op_assign
l_int|0
suffix:semicolon
id|u
OL
id|NRPLUSB
suffix:semicolon
id|u
op_increment
)paren
(brace
id|plusb_t
op_star
id|s
op_assign
op_amp
id|plusb
(braket
id|u
)braket
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &lt; 0x020300)
r_if
c_cond
(paren
id|s-&gt;net_dev.name
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;unregistering netdev: %s&quot;
comma
id|s-&gt;net_dev.name
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
op_amp
id|s-&gt;net_dev
)paren
suffix:semicolon
id|s-&gt;net_dev.name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|kfree
(paren
id|s-&gt;net_dev.name
)paren
suffix:semicolon
id|s-&gt;net_dev.name
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
id|s-&gt;net_dev.name
(braket
l_int|0
)braket
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;unregistering netdev: %s&quot;
comma
id|s-&gt;net_dev.name
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
op_amp
id|s-&gt;net_dev
)paren
suffix:semicolon
id|s-&gt;net_dev.name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
macro_line|#endif
)brace
id|usb_deregister
(paren
op_amp
id|plusb_driver
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;plusb_cleanup: finished&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
id|MODULE_AUTHOR
(paren
l_string|&quot;Deti Fliegl, deti@fliegl.de&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
(paren
l_string|&quot;PL-2302 USB Interface Driver for Linux (c)2000&quot;
)paren
suffix:semicolon
DECL|variable|plusb_init
id|module_init
(paren
id|plusb_init
)paren
suffix:semicolon
DECL|variable|plusb_cleanup
id|module_exit
(paren
id|plusb_cleanup
)paren
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------- */
eof
