multiline_comment|/* Driver for USB Mass Storage compliant devices&n; *&n; * (c) 1999 Michael Gee (michael@linuxspecific.com)&n; * (c) 1999, 2000 Matthew Dharm (mdharm-usb@one-eyed-alien.net)&n; *&n; * This driver is based on the &squot;USB Mass Storage Class&squot; document. This&n; * describes in detail the protocol used to communicate with such&n; * devices.  Clearly, the designers had SCSI and ATAPI commands in&n; * mind when they created this document.  The commands are all very&n; * similar to commands in the SCSI-II and ATAPI specifications.&n; *&n; * It is important to note that in a number of cases this class&n; * exhibits class-specific exemptions from the USB specification.&n; * Notably the usage of NAK, STALL and ACK differs from the norm, in&n; * that they are used to communicate wait, failed and OK on commands.&n; *&n; * Also, for certain devices, the interrupt endpoint is used to convey&n; * status of a command.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;../scsi/scsi.h&quot;
macro_line|#include &quot;../scsi/hosts.h&quot;
macro_line|#include &quot;../scsi/sd.h&quot;
macro_line|#include &quot;usb-storage.h&quot;
macro_line|#include &quot;usb-storage-debug.h&quot;
multiline_comment|/* direction table -- this indicates the direction of the data&n; * transfer for each command code -- a 1 indicates input&n; */
multiline_comment|/* FIXME: we need to use the new direction indicators in the Scsi_Cmnd&n; * structure, not this table.  First we need to evaluate if it&squot;s being set&n; * correctly for us, though&n; */
DECL|variable|us_direction
r_int
r_char
id|us_direction
(braket
l_int|256
op_div
l_int|8
)braket
op_assign
(brace
l_int|0x28
comma
l_int|0x81
comma
l_int|0x14
comma
l_int|0x14
comma
l_int|0x20
comma
l_int|0x01
comma
l_int|0x90
comma
l_int|0x77
comma
l_int|0x0C
comma
l_int|0x20
comma
l_int|0x00
comma
l_int|0x04
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x01
comma
l_int|0x00
comma
l_int|0x01
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
multiline_comment|/*&n; * Per device data&n; */
DECL|variable|my_host_number
r_static
r_int
id|my_host_number
suffix:semicolon
r_struct
id|us_data
suffix:semicolon
DECL|typedef|trans_cmnd
r_typedef
r_int
(paren
op_star
id|trans_cmnd
)paren
(paren
id|Scsi_Cmnd
op_star
comma
r_struct
id|us_data
op_star
)paren
suffix:semicolon
DECL|typedef|trans_reset
r_typedef
r_int
(paren
op_star
id|trans_reset
)paren
(paren
r_struct
id|us_data
op_star
)paren
suffix:semicolon
DECL|typedef|proto_cmnd
r_typedef
r_void
(paren
op_star
id|proto_cmnd
)paren
(paren
id|Scsi_Cmnd
op_star
comma
r_struct
id|us_data
op_star
)paren
suffix:semicolon
multiline_comment|/* we allocate one of these for every device that we remember */
DECL|struct|us_data
r_struct
id|us_data
(brace
DECL|member|next
r_struct
id|us_data
op_star
id|next
suffix:semicolon
multiline_comment|/* next device */
multiline_comment|/* the device we&squot;re working with */
DECL|member|dev_semaphore
r_struct
id|semaphore
id|dev_semaphore
suffix:semicolon
multiline_comment|/* protect pusb_dev */
DECL|member|pusb_dev
r_struct
id|usb_device
op_star
id|pusb_dev
suffix:semicolon
multiline_comment|/* this usb_device */
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* from filter initially */
multiline_comment|/* information about the device -- always good */
DECL|member|vendor
r_char
id|vendor
(braket
id|USB_STOR_STRING_LEN
)braket
suffix:semicolon
DECL|member|product
r_char
id|product
(braket
id|USB_STOR_STRING_LEN
)braket
suffix:semicolon
DECL|member|serial
r_char
id|serial
(braket
id|USB_STOR_STRING_LEN
)braket
suffix:semicolon
DECL|member|transport_name
r_char
op_star
id|transport_name
suffix:semicolon
DECL|member|protocol_name
r_char
op_star
id|protocol_name
suffix:semicolon
DECL|member|subclass
id|u8
id|subclass
suffix:semicolon
DECL|member|protocol
id|u8
id|protocol
suffix:semicolon
multiline_comment|/* information about the device -- only good if device is attached */
DECL|member|ifnum
id|u8
id|ifnum
suffix:semicolon
multiline_comment|/* interface number   */
DECL|member|ep_in
id|u8
id|ep_in
suffix:semicolon
multiline_comment|/* bulk in endpoint   */
DECL|member|ep_out
id|u8
id|ep_out
suffix:semicolon
multiline_comment|/* bulk out endpoint  */
DECL|member|ep_int
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_int
suffix:semicolon
multiline_comment|/* interrupt endpoint */
multiline_comment|/* function pointers for this device */
DECL|member|transport
id|trans_cmnd
id|transport
suffix:semicolon
multiline_comment|/* transport function&t;   */
DECL|member|transport_reset
id|trans_reset
id|transport_reset
suffix:semicolon
multiline_comment|/* transport device reset */
DECL|member|proto_handler
id|proto_cmnd
id|proto_handler
suffix:semicolon
multiline_comment|/* protocol handler&t;   */
multiline_comment|/* SCSI interfaces */
id|GUID
c_func
(paren
id|guid
)paren
suffix:semicolon
multiline_comment|/* unique dev id&t;*/
DECL|member|host
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
multiline_comment|/* our dummy host data */
DECL|member|htmplt
id|Scsi_Host_Template
id|htmplt
suffix:semicolon
multiline_comment|/* own host template&t;*/
DECL|member|host_number
r_int
id|host_number
suffix:semicolon
multiline_comment|/* to find us&t;&t;*/
DECL|member|host_no
r_int
id|host_no
suffix:semicolon
multiline_comment|/* allocated by scsi&t;*/
DECL|member|srb
id|Scsi_Cmnd
op_star
id|srb
suffix:semicolon
multiline_comment|/* current srb&t;&t;*/
multiline_comment|/* thread information */
DECL|member|queue_srb
id|Scsi_Cmnd
op_star
id|queue_srb
suffix:semicolon
multiline_comment|/* the single queue slot */
DECL|member|action
r_int
id|action
suffix:semicolon
multiline_comment|/* what to do&t;&t;  */
DECL|member|pid
r_int
id|pid
suffix:semicolon
multiline_comment|/* control thread&t;  */
multiline_comment|/* interrupt info for CBI devices -- only good if attached */
DECL|member|ip_waitq
r_struct
id|semaphore
id|ip_waitq
suffix:semicolon
multiline_comment|/* for CBI interrupts&t; */
DECL|member|ip_wanted
r_int
id|ip_wanted
suffix:semicolon
multiline_comment|/* is an IRQ expected?&t; */
DECL|member|irq_urb_sem
r_struct
id|semaphore
id|irq_urb_sem
suffix:semicolon
multiline_comment|/* to protect irq_urb&t; */
DECL|member|irq_urb
r_struct
id|urb
op_star
id|irq_urb
suffix:semicolon
multiline_comment|/* for USB int requests */
DECL|member|irqbuf
r_int
r_char
id|irqbuf
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* buffer for USB IRQ&t; */
multiline_comment|/* mutual exclusion structures */
DECL|member|notify
r_struct
id|semaphore
id|notify
suffix:semicolon
multiline_comment|/* thread begin/end&t;    */
DECL|member|sleeper
r_struct
id|semaphore
id|sleeper
suffix:semicolon
multiline_comment|/* to sleep the thread on  */
DECL|member|queue_exclusion
r_struct
id|semaphore
id|queue_exclusion
suffix:semicolon
multiline_comment|/* to protect data structs */
)brace
suffix:semicolon
multiline_comment|/*&n; * kernel thread actions&n; */
DECL|macro|US_ACT_COMMAND
mdefine_line|#define US_ACT_COMMAND&t;&t;1
DECL|macro|US_ACT_DEVICE_RESET
mdefine_line|#define US_ACT_DEVICE_RESET&t;2
DECL|macro|US_ACT_BUS_RESET
mdefine_line|#define US_ACT_BUS_RESET&t;3
DECL|macro|US_ACT_HOST_RESET
mdefine_line|#define US_ACT_HOST_RESET&t;4
DECL|macro|US_ACT_EXIT
mdefine_line|#define US_ACT_EXIT&t;&t;5
multiline_comment|/* The list of structures and the protective lock for them */
DECL|variable|us_list
r_static
r_struct
id|us_data
op_star
id|us_list
suffix:semicolon
DECL|variable|us_list_semaphore
r_struct
id|semaphore
id|us_list_semaphore
suffix:semicolon
r_static
r_void
op_star
id|storage_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
)paren
suffix:semicolon
r_static
r_void
id|storage_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
suffix:semicolon
DECL|variable|storage_driver
r_static
r_struct
id|usb_driver
id|storage_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;usb-storage&quot;
comma
id|probe
suffix:colon
id|storage_probe
comma
id|disconnect
suffix:colon
id|storage_disconnect
comma
)brace
suffix:semicolon
multiline_comment|/***********************************************************************&n; * Data transfer routines&n; ***********************************************************************/
multiline_comment|/*&n; * Transfer one SCSI scatter-gather buffer via bulk transfer&n; *&n; * Note that this function is necessary because we want the ability to&n; * use scatter-gather memory.  Good performance is achieved by a combination&n; * of scatter-gather and clustering (which makes each chunk bigger).&n; *&n; * Note that the lower layer will always retry when a NAK occurs, up to the&n; * timeout limit.  Thus we don&squot;t have to worry about it for individual&n; * packets.&n; */
DECL|function|us_transfer_partial
r_static
r_int
id|us_transfer_partial
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|pipe
comma
r_char
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|partial
suffix:semicolon
multiline_comment|/* transfer the data */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk xfer 0x%x(%d)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|buf
comma
id|length
)paren
suffix:semicolon
id|result
op_assign
id|usb_bulk_msg
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
comma
id|buf
comma
id|length
comma
op_amp
id|partial
comma
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;bulk_msg returned %d xferred %d/%d&bslash;n&quot;
comma
id|result
comma
id|partial
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* if we stall, we need to clear it before we go on */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;clearing endpoint halt for pipe 0x%x&bslash;n&quot;
comma
id|pipe
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
)brace
multiline_comment|/* did we send all the data? */
r_if
c_cond
(paren
id|partial
op_eq
id|length
)paren
(brace
r_return
id|US_BULK_TRANSFER_GOOD
suffix:semicolon
)brace
multiline_comment|/* uh oh... we have an error code, so something went wrong. */
r_if
c_cond
(paren
id|result
)paren
(brace
multiline_comment|/* NAK - that means we&squot;ve retried a few times allready */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;us_transfer_partial(): device NAKed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|US_BULK_TRANSFER_FAILED
suffix:semicolon
)brace
multiline_comment|/* no error code, so we must have transferred some data, &n;&t; * just not all of it */
r_return
id|US_BULK_TRANSFER_SHORT
suffix:semicolon
)brace
multiline_comment|/*&n; * Transfer an entire SCSI command&squot;s worth of data payload over the bulk&n; * pipe.&n; *&n; * Note that this uses us_transfer_partial to achieve it&squot;s goals -- this&n; * function simply determines if we&squot;re going to use scatter-gather or not,&n; * and acts appropriately.  For now, it also re-interprets the error codes.&n; */
DECL|function|us_transfer
r_static
r_void
id|us_transfer
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_int
id|dir_in
)paren
(brace
r_struct
id|us_data
op_star
id|us
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|pipe
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
multiline_comment|/* calculate the appropriate pipe information */
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|srb-&gt;host_scribble
suffix:semicolon
r_if
c_cond
(paren
id|dir_in
)paren
id|pipe
op_assign
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_in
)paren
suffix:semicolon
r_else
id|pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
suffix:semicolon
multiline_comment|/* are we scatter-gathering? */
r_if
c_cond
(paren
id|srb-&gt;use_sg
)paren
(brace
multiline_comment|/* loop over all the scatter gather structures and &n;&t;&t; * make the appropriate requests for each, until done&n;&t;&t; */
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|srb-&gt;request_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|srb-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
id|result
op_assign
id|us_transfer_partial
c_func
(paren
id|us
comma
id|pipe
comma
id|sg
(braket
id|i
)braket
dot
id|address
comma
id|sg
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_break
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* no scatter-gather, just make the request */
id|result
op_assign
id|us_transfer_partial
c_func
(paren
id|us
comma
id|pipe
comma
id|srb-&gt;request_buffer
comma
id|srb-&gt;request_bufflen
)paren
suffix:semicolon
multiline_comment|/* return the result in the data structure itself */
id|srb-&gt;result
op_assign
id|result
suffix:semicolon
)brace
multiline_comment|/* Calculate the length of the data transfer (not the command) for any&n; * given SCSI command&n; */
DECL|function|us_transfer_length
r_static
r_int
r_int
id|us_transfer_length
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|total
op_assign
l_int|0
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
multiline_comment|/* support those devices which need the length calculated&n;&t; * differently &n;&t; */
r_if
c_cond
(paren
id|us-&gt;flags
op_amp
id|US_FL_ALT_LENGTH
)paren
(brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
(brace
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_assign
l_int|36
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE
)paren
)paren
r_return
id|srb-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|TEST_UNIT_READY
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Are we going to scatter gather? */
r_if
c_cond
(paren
id|srb-&gt;use_sg
)paren
(brace
multiline_comment|/* Add up the sizes of all the scatter-gather segments */
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|srb-&gt;request_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|srb-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
id|total
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
r_return
id|total
suffix:semicolon
)brace
r_else
multiline_comment|/* Just return the length of the buffer */
r_return
id|srb-&gt;request_bufflen
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Transport routines&n; ***********************************************************************/
multiline_comment|/* Invoke the transport and basic error-handling/recovery methods&n; *&n; * This is used by the protocol layers to actually send the message to&n; * the device and recieve the response.&n; */
DECL|function|invoke_transport
r_static
r_void
id|invoke_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|need_auto_sense
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* send the command to the transport layer */
id|result
op_assign
id|us
op_member_access_from_pointer
id|transport
c_func
(paren
id|srb
comma
id|us
)paren
suffix:semicolon
multiline_comment|/* Determine if we need to auto-sense&n;&t; *&n;&t; * I normally don&squot;t use a flag like this, but it&squot;s almost impossible&n;&t; * to understand what&squot;s going on here if I don&squot;t.&n;&t; */
id|need_auto_sense
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re running the CB transport, which is incapable&n;&t; * of determining status on it&squot;s own, we need to auto-sense almost&n;&t; * every time.&n;&t; */
r_if
c_cond
(paren
id|us-&gt;protocol
op_eq
id|US_PR_CB
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- CB transport device requiring auto-sense&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* There are some exceptions to this.  Notably, if this is&n;&t;&t; * a UFI device and the command is REQUEST_SENSE or INQUIRY,&n;&t;&t; * then it is impossible to truly determine status.&n;&t;&t; */
r_if
c_cond
(paren
id|us-&gt;subclass
op_eq
id|US_SC_UFI
op_logical_and
(paren
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;** no auto-sense for a special command&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If we have an error, we&squot;re going to do a REQUEST_SENSE &n;&t; * automatically.  Note that we differentiate between a command&n;&t; * &quot;failure&quot; and an &quot;error&quot; in the transport mechanism.&n;&t; */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_FAILED
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transport indicates command failure&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_ERROR
)paren
(brace
multiline_comment|/* FIXME: we need to invoke a transport reset here */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transport indicates transport failure&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Also, if we have a short transfer on a command that can&squot;t have&n;&t; * a short transfer, we&squot;re going to do this.&n;&t; */
r_if
c_cond
(paren
(paren
id|srb-&gt;result
op_eq
id|US_BULK_TRANSFER_SHORT
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|LOG_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE_10
)paren
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- unexpectedly short transfer&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now, if we need to do the auto-sense, let&squot;s do it */
r_if
c_cond
(paren
id|need_auto_sense
)paren
(brace
r_int
id|temp_result
suffix:semicolon
r_void
op_star
id|old_request_buffer
suffix:semicolon
r_int
id|old_sg
suffix:semicolon
r_int
id|old_request_bufflen
suffix:semicolon
r_int
r_char
id|old_cmnd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Issuing auto-REQUEST_SENSE&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* save the old command */
id|memcpy
c_func
(paren
id|old_cmnd
comma
id|srb-&gt;cmnd
comma
id|MAX_COMMAND_SIZE
)paren
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_assign
l_int|18
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set the buffer length for transfer */
id|old_request_buffer
op_assign
id|srb-&gt;request_buffer
suffix:semicolon
id|old_request_bufflen
op_assign
id|srb-&gt;request_bufflen
suffix:semicolon
id|old_sg
op_assign
id|srb-&gt;use_sg
suffix:semicolon
id|srb-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;request_bufflen
op_assign
l_int|18
suffix:semicolon
id|srb-&gt;request_buffer
op_assign
id|srb-&gt;sense_buffer
suffix:semicolon
multiline_comment|/* issue the auto-sense command */
id|temp_result
op_assign
id|us
op_member_access_from_pointer
id|transport
c_func
(paren
id|us-&gt;srb
comma
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp_result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
multiline_comment|/* FIXME: we need to invoke a transport reset here */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- auto-sense failure&bslash;n&quot;
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_return
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Result from auto-sense is %d&bslash;n&quot;
comma
id|temp_result
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- code: 0x%x, key: 0x%x, ASC: 0x%x, ASCQ: 0x%x&bslash;n&quot;
comma
id|srb-&gt;sense_buffer
(braket
l_int|0
)braket
comma
id|srb-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
comma
id|srb-&gt;sense_buffer
(braket
l_int|12
)braket
comma
id|srb-&gt;sense_buffer
(braket
l_int|13
)braket
)paren
suffix:semicolon
multiline_comment|/* set the result so the higher layers expect this data */
id|srb-&gt;result
op_assign
id|CHECK_CONDITION
suffix:semicolon
multiline_comment|/* we&squot;re done here, let&squot;s clean up */
id|srb-&gt;request_buffer
op_assign
id|old_request_buffer
suffix:semicolon
id|srb-&gt;request_bufflen
op_assign
id|old_request_bufflen
suffix:semicolon
id|srb-&gt;use_sg
op_assign
id|old_sg
suffix:semicolon
id|memcpy
c_func
(paren
id|srb-&gt;cmnd
comma
id|old_cmnd
comma
id|MAX_COMMAND_SIZE
)paren
suffix:semicolon
multiline_comment|/* If things are really okay, then let&squot;s show that */
r_if
c_cond
(paren
(paren
id|srb-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
l_int|0x0
)paren
id|srb-&gt;result
op_assign
id|GOOD
suffix:semicolon
)brace
r_else
multiline_comment|/* if (need_auto_sense) */
id|srb-&gt;result
op_assign
id|GOOD
suffix:semicolon
multiline_comment|/* Regardless of auto-sense, if we _know_ we have an error&n;&t; * condition, show that in the result code&n;&t; */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_FAILED
)paren
id|srb-&gt;result
op_assign
id|CHECK_CONDITION
suffix:semicolon
multiline_comment|/* If we think we&squot;re good, then make sure the sense data shows it.&n;&t; * This is necessary because the auto-sense for some devices always&n;&t; * sets byte 0 == 0x70, even if there is no error&n;&t; */
r_if
c_cond
(paren
(paren
id|us-&gt;protocol
op_eq
id|US_PR_CB
)paren
op_logical_and
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_GOOD
)paren
op_logical_and
(paren
(paren
id|srb-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
l_int|0x0
)paren
)paren
id|srb-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x0
suffix:semicolon
)brace
multiline_comment|/*&n; * Control/Bulk/Interrupt transport&n; */
DECL|function|CBI_irq
r_static
r_void
id|CBI_irq
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|urb-&gt;context
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;USB IRQ recieved for device on host %d&bslash;n&quot;
comma
id|us-&gt;host_no
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- IRQ data length is %d&bslash;n&quot;
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- IRQ state is %d&bslash;n&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
multiline_comment|/* is the device removed? */
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
op_minus
id|ENOENT
)paren
(brace
multiline_comment|/* save the data for interpretation later */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Interrupt Status (0x%x, 0x%x)&bslash;n&quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|urb-&gt;transfer_buffer
)paren
(braket
l_int|0
)braket
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|urb-&gt;transfer_buffer
)paren
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* was this a wanted interrupt? */
r_if
c_cond
(paren
id|us-&gt;ip_wanted
)paren
(brace
id|us-&gt;ip_wanted
op_assign
l_int|0
suffix:semicolon
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;ip_waitq
)paren
)paren
suffix:semicolon
)brace
r_else
id|US_DEBUGP
c_func
(paren
l_string|&quot;ERROR: Unwanted interrupt received!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- device has been removed&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|CBI_transport
r_static
r_int
id|CBI_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
multiline_comment|/* COMMAND STAGE */
multiline_comment|/* let&squot;s send the command via the control pipe */
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
id|US_CBI_ADSC
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
id|srb-&gt;cmnd
comma
id|srb-&gt;cmd_len
comma
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
multiline_comment|/* check the return code for the command */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Call to usb_control_msg() returned %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* STALL must be cleared when they are detected */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Stall on control pipe. Clearing&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- usb_clear_halt() returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/* Uh oh... serious problem here */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* Set up for status notification */
id|us-&gt;ip_wanted
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* DATA STAGE */
multiline_comment|/* transfer the data payload for this command, if one exists*/
r_if
c_cond
(paren
id|us_transfer_length
c_func
(paren
id|srb
comma
id|us
)paren
)paren
(brace
id|us_transfer
c_func
(paren
id|srb
comma
id|US_DIRECTION
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;CBI data stage result is 0x%x&bslash;n&quot;
comma
id|srb-&gt;result
)paren
suffix:semicolon
)brace
multiline_comment|/* STATUS STAGE */
multiline_comment|/* go to sleep until we get this interrupt */
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;ip_waitq
)paren
)paren
suffix:semicolon
multiline_comment|/* if we were woken up by an abort instead of the actual interrupt */
r_if
c_cond
(paren
id|us-&gt;ip_wanted
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Did not get interrupt on CBI&bslash;n&quot;
)paren
suffix:semicolon
id|us-&gt;ip_wanted
op_assign
l_int|0
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Got interrupt data (0x%x, 0x%x)&bslash;n&quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|us-&gt;irq_urb-&gt;transfer_buffer
)paren
(braket
l_int|0
)braket
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|us-&gt;irq_urb-&gt;transfer_buffer
)paren
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* UFI gives us ASC and ASCQ, like a request sense&n;&t; *&n;&t; * REQUEST_SENSE and INQUIRY don&squot;t affect the sense data on UFI&n;&t; * devices, so we ignore the information for those commands.  Note&n;&t; * that this means we could be ignoring a real error on these&n;&t; * commands, but that can&squot;t be helped.&n;&t; */
r_if
c_cond
(paren
id|us-&gt;subclass
op_eq
id|US_SC_UFI
)paren
(brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_or
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|us-&gt;irq_urb-&gt;transfer_buffer
)paren
(braket
l_int|0
)braket
)paren
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_else
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/* If not UFI, we interpret the data as a result code &n;&t; * The first byte should always be a 0x0&n;&t; * The second byte &amp; 0x0F should be 0x0 for good, otherwise error &n;&t; */
r_if
c_cond
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|us-&gt;irq_urb-&gt;transfer_buffer
)paren
(braket
l_int|0
)braket
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;CBI IRQ data showed reserved bType&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_switch
c_cond
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|us-&gt;irq_urb-&gt;transfer_buffer
)paren
(braket
l_int|1
)braket
op_amp
l_int|0x0F
)paren
(brace
r_case
l_int|0x00
suffix:colon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_case
l_int|0x01
suffix:colon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_default
suffix:colon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;CBI_transport() reached end of function&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/*&n; * Control/Bulk transport&n; */
DECL|function|CB_transport
r_static
r_int
id|CB_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
multiline_comment|/* COMMAND STAGE */
multiline_comment|/* let&squot;s send the command via the control pipe */
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
id|US_CBI_ADSC
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
id|srb-&gt;cmnd
comma
id|srb-&gt;cmd_len
comma
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
multiline_comment|/* check the return code for the command */
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Call to usb_control_msg() returned %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
multiline_comment|/* a stall is a fatal condition from the device */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Stall on control pipe. Clearing&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- usb_clear_halt() returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/* Uh oh... serious problem here */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* DATA STAGE */
multiline_comment|/* transfer the data payload for this command, if one exists*/
r_if
c_cond
(paren
id|us_transfer_length
c_func
(paren
id|srb
comma
id|us
)paren
)paren
(brace
id|us_transfer
c_func
(paren
id|srb
comma
id|US_DIRECTION
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;CB data stage result is 0x%x&bslash;n&quot;
comma
id|srb-&gt;result
)paren
suffix:semicolon
)brace
multiline_comment|/* STATUS STAGE */
multiline_comment|/* NOTE: CB does not have a status stage.  Silly, I know.  So&n;&t; * we have to catch this at a higher level.&n;&t; */
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Bulk only transport&n; */
DECL|function|Bulk_transport
r_static
r_int
id|Bulk_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|bulk_cb_wrap
id|bcb
suffix:semicolon
r_struct
id|bulk_cs_wrap
id|bcs
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|pipe
suffix:semicolon
r_int
id|partial
suffix:semicolon
multiline_comment|/* set up the command wrapper */
id|bcb.Signature
op_assign
id|cpu_to_le32
c_func
(paren
id|US_BULK_CB_SIGN
)paren
suffix:semicolon
id|bcb.DataTransferLength
op_assign
id|cpu_to_le32
c_func
(paren
id|us_transfer_length
c_func
(paren
id|srb
comma
id|us
)paren
)paren
suffix:semicolon
id|bcb.Flags
op_assign
id|US_DIRECTION
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)paren
op_lshift
l_int|7
suffix:semicolon
id|bcb.Tag
op_assign
id|srb-&gt;serial_number
suffix:semicolon
id|bcb.Lun
op_assign
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_rshift
l_int|5
suffix:semicolon
id|bcb.Length
op_assign
id|srb-&gt;cmd_len
suffix:semicolon
multiline_comment|/* construct the pipe handle */
id|pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
suffix:semicolon
multiline_comment|/* copy the command payload */
id|memset
c_func
(paren
id|bcb.CDB
comma
l_int|0
comma
r_sizeof
(paren
id|bcb.CDB
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bcb.CDB
comma
id|srb-&gt;cmnd
comma
id|bcb.Length
)paren
suffix:semicolon
multiline_comment|/* send it to out endpoint */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk command S 0x%x T 0x%x LUN %d L %d F %d CL %d&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|bcb.Signature
)paren
comma
id|bcb.Tag
comma
id|bcb.Lun
comma
id|bcb.DataTransferLength
comma
id|bcb.Flags
comma
id|bcb.Length
)paren
suffix:semicolon
id|result
op_assign
id|usb_bulk_msg
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
comma
op_amp
id|bcb
comma
id|US_BULK_CB_WRAP_LEN
comma
op_amp
id|partial
comma
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk command transfer result=%d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
multiline_comment|/* if we stall, we need to clear it before we go on */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;clearing endpoint halt for pipe 0x%x&bslash;n&quot;
comma
id|pipe
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
)brace
multiline_comment|/* if the command transfered well, then we go to the data stage */
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
multiline_comment|/* send/receive data payload, if there is any */
r_if
c_cond
(paren
id|bcb.DataTransferLength
)paren
(brace
id|us_transfer
c_func
(paren
id|srb
comma
id|bcb.Flags
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk data transfer result 0x%x&bslash;n&quot;
comma
id|srb-&gt;result
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* See flow chart on pg 15 of the Bulk Only Transport spec for&n;&t; * an explanation of how this code works.&n;&t; */
multiline_comment|/* construct the pipe handle */
id|pipe
op_assign
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_in
)paren
suffix:semicolon
multiline_comment|/* get CSW for device status */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Attempting to get CSW...&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_bulk_msg
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
comma
op_amp
id|bcs
comma
id|US_BULK_CS_WRAP_LEN
comma
op_amp
id|partial
comma
id|HZ
op_star
l_int|2
)paren
suffix:semicolon
multiline_comment|/* did the attempt to read the CSW fail? */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;clearing endpoint halt for pipe 0x%x&bslash;n&quot;
comma
id|pipe
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
multiline_comment|/* get the status again */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Attempting to get CSW (2nd try)...&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_bulk_msg
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
comma
op_amp
id|bcs
comma
id|US_BULK_CS_WRAP_LEN
comma
op_amp
id|partial
comma
id|HZ
op_star
l_int|2
)paren
suffix:semicolon
multiline_comment|/* if it fails again, we need a reset and return an error*/
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;clearing halt for pipe 0x%x&bslash;n&quot;
comma
id|pipe
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
)brace
multiline_comment|/* if we still have a failure at this point, we&squot;re in trouble */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk status result = %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* check bulk status */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk status S 0x%x T 0x%x R %d V 0x%x&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|bcs.Signature
)paren
comma
id|bcs.Tag
comma
id|bcs.Residue
comma
id|bcs.Status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bcs.Signature
op_ne
id|cpu_to_le32
c_func
(paren
id|US_BULK_CS_SIGN
)paren
op_logical_or
id|bcs.Tag
op_ne
id|bcb.Tag
op_logical_or
id|bcs.Status
OG
id|US_BULK_STAT_PHASE
op_logical_or
id|partial
op_ne
l_int|13
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk logical error&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* based on the status code, we report good or bad */
r_switch
c_cond
(paren
id|bcs.Status
)paren
(brace
r_case
id|US_BULK_STAT_OK
suffix:colon
multiline_comment|/* command good -- note that we could be short on data */
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_case
id|US_BULK_STAT_FAIL
suffix:colon
multiline_comment|/* command failed */
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_case
id|US_BULK_STAT_PHASE
suffix:colon
multiline_comment|/* phase error */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* we should never get here, but if we do, we&squot;re in trouble */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Protocol routines&n; ***********************************************************************/
DECL|function|ATAPI_command
r_static
r_void
id|ATAPI_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|old_cmnd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fix some commands -- this is a form of mode translation&n;&t; * ATAPI devices only accept 12 byte long commands &n;&t; *&n;&t; * NOTE: This only works because a Scsi_Cmnd struct field contains&n;&t; * a unsigned char cmnd[12], so we know we have storage available&n;&t; */
multiline_comment|/* set command length to 12 bytes */
id|srb-&gt;cmd_len
op_assign
l_int|12
suffix:semicolon
multiline_comment|/* determine the correct (or minimum) data length for these commands */
r_switch
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* change MODE_SENSE/MODE_SELECT from 6 to 10 byte commands */
r_case
id|MODE_SENSE
suffix:colon
r_case
id|MODE_SELECT
suffix:colon
multiline_comment|/* save the command so we can tell what it was */
id|old_cmnd
op_assign
id|srb-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|11
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|10
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|9
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|8
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|2
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|1
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_or
l_int|0x40
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* change READ_6/WRITE_6 to READ_10/WRITE_10, which &n;&t;&t; * are ATAPI commands */
r_case
id|WRITE_6
suffix:colon
r_case
id|READ_6
suffix:colon
id|srb-&gt;cmnd
(braket
l_int|11
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|10
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|9
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|8
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|5
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|3
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|2
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|3
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_amp
l_int|0x1F
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_amp
l_int|0xE0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_or
l_int|0x20
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* end switch on cmnd[0] */
multiline_comment|/* send the command to the transport layer */
id|invoke_transport
c_func
(paren
id|srb
comma
id|us
)paren
suffix:semicolon
multiline_comment|/* Fix the MODE_SENSE data if we translated the command&n;&t; */
r_if
c_cond
(paren
id|old_cmnd
op_eq
id|MODE_SENSE
)paren
(brace
r_int
r_char
op_star
id|dta
op_assign
(paren
r_int
r_char
op_star
)paren
id|us-&gt;srb-&gt;request_buffer
suffix:semicolon
multiline_comment|/* FIXME: we need to compress the entire data structure here&n;&t;&t; */
id|dta
(braket
l_int|0
)braket
op_assign
id|dta
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* data len */
id|dta
(braket
l_int|1
)braket
op_assign
id|dta
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* med type */
id|dta
(braket
l_int|2
)braket
op_assign
id|dta
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* dev-spec prm */
id|dta
(braket
l_int|3
)braket
op_assign
id|dta
(braket
l_int|7
)braket
suffix:semicolon
multiline_comment|/* block desc len */
id|printk
(paren
id|KERN_DEBUG
id|USB_STORAGE
l_string|&quot;new MODE_SENSE_6 data = %.2X %.2X %.2X %.2X&bslash;n&quot;
comma
id|dta
(braket
l_int|0
)braket
comma
id|dta
(braket
l_int|1
)braket
comma
id|dta
(braket
l_int|2
)braket
comma
id|dta
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Fix-up the return data from an INQUIRY command to show &n;&t; * ANSI SCSI rev 2 so we don&squot;t confuse the SCSI layers above us&n;&t; */
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
(brace
(paren
(paren
r_int
r_char
op_star
)paren
id|us-&gt;srb-&gt;request_buffer
)paren
(braket
l_int|2
)braket
op_or_assign
l_int|0x2
suffix:semicolon
)brace
)brace
DECL|function|ufi_command
r_static
r_void
id|ufi_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|old_cmnd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* fix some commands -- this is a form of mode translation&n;&t; * UFI devices only accept 12 byte long commands &n;&t; *&n;&t; * NOTE: This only works because a Scsi_Cmnd struct field contains&n;&t; * a unsigned char cmnd[12], so we know we have storage available&n;&t; */
multiline_comment|/* set command length to 12 bytes (this affects the transport layer) */
id|srb-&gt;cmd_len
op_assign
l_int|12
suffix:semicolon
multiline_comment|/* determine the correct (or minimum) data length for these commands */
r_switch
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* for INQUIRY, UFI devices only ever return 36 bytes */
r_case
id|INQUIRY
suffix:colon
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_assign
l_int|36
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* change MODE_SENSE/MODE_SELECT from 6 to 10 byte commands */
r_case
id|MODE_SENSE
suffix:colon
r_case
id|MODE_SELECT
suffix:colon
multiline_comment|/* save the command so we can tell what it was */
id|old_cmnd
op_assign
id|srb-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|11
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|10
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|9
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* if we&squot;re sending data, we send all.&t;If getting data, &n;&t;&t; * get the minimum */
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SELECT
)paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
r_else
id|srb-&gt;cmnd
(braket
l_int|8
)braket
op_assign
l_int|8
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|2
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|1
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_or
l_int|0x40
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* again, for MODE_SENSE_10, we get the minimum (8) */
r_case
id|MODE_SENSE_10
suffix:colon
id|srb-&gt;cmnd
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|8
)braket
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* for REQUEST_SENSE, UFI devices only ever return 18 bytes */
r_case
id|REQUEST_SENSE
suffix:colon
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_assign
l_int|18
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* change READ_6/WRITE_6 to READ_10/WRITE_10, which &n;&t;&t; * are UFI commands */
r_case
id|WRITE_6
suffix:colon
r_case
id|READ_6
suffix:colon
id|srb-&gt;cmnd
(braket
l_int|11
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|10
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|9
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|8
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|5
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|3
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|2
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|3
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_amp
l_int|0x1F
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_amp
l_int|0xE0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_or
l_int|0x20
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* end switch on cmnd[0] */
multiline_comment|/* send the command to the transport layer */
id|invoke_transport
c_func
(paren
id|srb
comma
id|us
)paren
suffix:semicolon
multiline_comment|/* Fix the MODE_SENSE data here if we had to translate the command&n;&t; */
r_if
c_cond
(paren
id|old_cmnd
op_eq
id|MODE_SENSE
)paren
(brace
r_int
r_char
op_star
id|dta
op_assign
(paren
r_int
r_char
op_star
)paren
id|us-&gt;srb-&gt;request_buffer
suffix:semicolon
multiline_comment|/* FIXME: we need to compress the entire data structure here&n;&t;&t; */
id|dta
(braket
l_int|0
)braket
op_assign
id|dta
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* data len */
id|dta
(braket
l_int|1
)braket
op_assign
id|dta
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* med type */
id|dta
(braket
l_int|2
)braket
op_assign
id|dta
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* dev-spec prm */
id|dta
(braket
l_int|3
)braket
op_assign
id|dta
(braket
l_int|7
)braket
suffix:semicolon
multiline_comment|/* block desc len */
id|printk
(paren
id|KERN_DEBUG
id|USB_STORAGE
l_string|&quot;new MODE_SENSE_6 data = %.2X %.2X %.2X %.2X&bslash;n&quot;
comma
id|dta
(braket
l_int|0
)braket
comma
id|dta
(braket
l_int|1
)braket
comma
id|dta
(braket
l_int|2
)braket
comma
id|dta
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Fix-up the return data from an INQUIRY command to show &n;&t; * ANSI SCSI rev 2 so we don&squot;t confuse the SCSI layers above us&n;&t; */
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
(brace
(paren
(paren
r_int
r_char
op_star
)paren
id|us-&gt;srb-&gt;request_buffer
)paren
(braket
l_int|2
)braket
op_or_assign
l_int|0x2
suffix:semicolon
)brace
)brace
DECL|function|transparent_scsi_command
r_static
r_void
id|transparent_scsi_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
multiline_comment|/* This code supports devices which do not support {READ|WRITE}_6&n;&t; * Apparently, neither Windows or MacOS will use these commands,&n;&t; * so some devices do not support them&n;&t; */
r_if
c_cond
(paren
id|us-&gt;flags
op_amp
id|US_FL_MODE_XLATE
)paren
(brace
multiline_comment|/* translate READ_6 to READ_10 */
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0x08
)paren
(brace
multiline_comment|/* get the control */
id|srb-&gt;cmnd
(braket
l_int|9
)braket
op_assign
id|us-&gt;srb-&gt;cmnd
(braket
l_int|5
)braket
suffix:semicolon
multiline_comment|/* get the length */
id|srb-&gt;cmnd
(braket
l_int|8
)braket
op_assign
id|us-&gt;srb-&gt;cmnd
(braket
l_int|6
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set the reserved area to 0 */
id|srb-&gt;cmnd
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* get LBA */
id|srb-&gt;cmnd
(braket
l_int|5
)braket
op_assign
id|us-&gt;srb-&gt;cmnd
(braket
l_int|3
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_assign
id|us-&gt;srb-&gt;cmnd
(braket
l_int|2
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* LUN and other info in cmnd[1] can stay */
multiline_comment|/* fix command code */
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_assign
l_int|0x28
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Changing READ_6 to READ_10&bslash;n&quot;
)paren
suffix:semicolon
id|US_DEBUG
c_func
(paren
id|us_show_command
c_func
(paren
id|srb
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* translate WRITE_6 to WRITE_10 */
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0x0A
)paren
(brace
multiline_comment|/* get the control */
id|srb-&gt;cmnd
(braket
l_int|9
)braket
op_assign
id|us-&gt;srb-&gt;cmnd
(braket
l_int|5
)braket
suffix:semicolon
multiline_comment|/* get the length */
id|srb-&gt;cmnd
(braket
l_int|8
)braket
op_assign
id|us-&gt;srb-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set the reserved area to 0 */
id|srb-&gt;cmnd
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* get LBA */
id|srb-&gt;cmnd
(braket
l_int|5
)braket
op_assign
id|us-&gt;srb-&gt;cmnd
(braket
l_int|3
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_assign
id|us-&gt;srb-&gt;cmnd
(braket
l_int|2
)braket
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* LUN and other info in cmnd[1] can stay */
multiline_comment|/* fix command code */
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_assign
l_int|0x2A
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Changing WRITE_6 to WRITE_10&bslash;n&quot;
)paren
suffix:semicolon
id|US_DEBUG
c_func
(paren
id|us_show_command
c_func
(paren
id|us-&gt;srb
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* if (us-&gt;flags &amp; US_FL_MODE_XLATE) */
multiline_comment|/* send the command to the transport layer */
id|invoke_transport
c_func
(paren
id|srb
comma
id|us
)paren
suffix:semicolon
multiline_comment|/* fix the results of an INQUIRY */
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Fixing INQUIRY data, setting SCSI rev to 2&bslash;n&quot;
)paren
suffix:semicolon
(paren
(paren
r_int
r_char
op_star
)paren
id|us-&gt;srb-&gt;request_buffer
)paren
(braket
l_int|2
)braket
op_or_assign
l_int|2
suffix:semicolon
)brace
)brace
multiline_comment|/***********************************************************************&n; * Reset routines&n; ***********************************************************************/
multiline_comment|/* This issues a CB[I] Reset to the device in question&n; */
DECL|function|CB_reset
r_static
r_int
id|CB_reset
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_char
id|cmd
(braket
l_int|12
)braket
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;CB_reset() called&bslash;n&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cmd
comma
l_int|0xFF
comma
r_sizeof
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|SEND_DIAGNOSTIC
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
l_int|4
suffix:semicolon
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
id|US_CBI_ADSC
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
id|cmd
comma
r_sizeof
(paren
id|cmd
)paren
comma
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
multiline_comment|/* long wait for reset */
id|schedule_timeout
c_func
(paren
id|HZ
op_star
l_int|6
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;CB_reset: clearing endpoint halt&bslash;n&quot;
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_in
)paren
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;CB_reset done&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* FIXME: Does this work? */
DECL|function|Bulk_reset
r_static
r_int
id|Bulk_reset
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
id|US_BULK_RESET
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
id|US_BULK_RESET_HARD
comma
id|us-&gt;ifnum
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk hard reset failed %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_in
)paren
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
)paren
suffix:semicolon
multiline_comment|/* long wait for reset */
id|schedule_timeout
c_func
(paren
id|HZ
op_star
l_int|6
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Host functions &n; ***********************************************************************/
DECL|function|us_info
r_static
r_const
r_char
op_star
id|us_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_return
l_string|&quot;SCSI emulation for USB Mass Storage devices&bslash;n&quot;
suffix:semicolon
)brace
multiline_comment|/* detect a virtual adapter (always works) */
DECL|function|us_detect
r_static
r_int
id|us_detect
c_func
(paren
r_struct
id|SHT
op_star
id|sht
)paren
(brace
r_struct
id|us_data
op_star
id|us
suffix:semicolon
r_char
id|local_name
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/* This is not nice at all, but how else are we to get the&n;&t; * data here? */
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|sht-&gt;proc_dir
suffix:semicolon
multiline_comment|/* set up the name of our subdirectory under /proc/scsi/ */
id|sprintf
c_func
(paren
id|local_name
comma
l_string|&quot;usb-storage-%d&quot;
comma
id|us-&gt;host_number
)paren
suffix:semicolon
id|sht-&gt;proc_name
op_assign
id|kmalloc
(paren
id|strlen
c_func
(paren
id|local_name
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sht-&gt;proc_name
)paren
r_return
l_int|0
suffix:semicolon
id|strcpy
c_func
(paren
id|sht-&gt;proc_name
comma
id|local_name
)paren
suffix:semicolon
multiline_comment|/* we start with no /proc directory entry */
id|sht-&gt;proc_dir
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* register the host */
id|us-&gt;host
op_assign
id|scsi_register
c_func
(paren
id|sht
comma
r_sizeof
(paren
id|us
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;host
)paren
(brace
id|us-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_int
)paren
id|us
suffix:semicolon
id|us-&gt;host_no
op_assign
id|us-&gt;host-&gt;host_no
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* odd... didn&squot;t register properly.  Abort and free pointers */
id|kfree
c_func
(paren
id|sht-&gt;proc_name
)paren
suffix:semicolon
id|sht-&gt;proc_name
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Release all resources used by the virtual host&n; *&n; * NOTE: There is no contention here, because we&squot;re allready deregistered&n; * the driver and we&squot;re doing each virtual host in turn, not in parallel&n; */
DECL|function|us_release
r_static
r_int
id|us_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|psh
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|psh-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;us_release() called for host %s&bslash;n&quot;
comma
id|us-&gt;htmplt.name
)paren
suffix:semicolon
multiline_comment|/* Kill the control threads&n;&t; *&n;&t; * Enqueue the command, wake up the thread, and wait for &n;&t; * notification that it&squot;s exited.&n;&t; */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- sending US_ACT_EXIT command to thread&bslash;n&quot;
)paren
suffix:semicolon
id|us-&gt;action
op_assign
id|US_ACT_EXIT
suffix:semicolon
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;sleeper
)paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
multiline_comment|/* free the data structure we were using */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- freeing private host data structure&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|us
)paren
suffix:semicolon
(paren
r_struct
id|us_data
op_star
)paren
id|psh-&gt;hostdata
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* we always have a successful release */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* run command */
DECL|function|us_command
r_static
r_int
id|us_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bad use of us_command&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
)brace
multiline_comment|/* run command */
DECL|function|us_queuecommand
r_static
r_int
id|us_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|srb-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;us_queuecommand() called&bslash;n&quot;
)paren
suffix:semicolon
id|srb-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|us
suffix:semicolon
multiline_comment|/* get exclusive access to the structures we want */
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;queue_exclusion
)paren
)paren
suffix:semicolon
multiline_comment|/* enqueue the command */
id|us-&gt;queue_srb
op_assign
id|srb
suffix:semicolon
id|srb-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|us-&gt;action
op_assign
id|US_ACT_COMMAND
suffix:semicolon
multiline_comment|/* wake up the process task */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;queue_exclusion
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;sleeper
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Error handling functions&n; ***********************************************************************/
multiline_comment|/* Command abort&n; *&n; * Note that this is really only meaningful right now for CBI transport&n; * devices which have failed to give us the command completion interrupt&n; */
DECL|function|us_abort
r_static
r_int
id|us_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|srb-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;us_abort() called&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* if we&squot;re stuck waiting for an IRQ, simulate it */
r_if
c_cond
(paren
id|us-&gt;ip_wanted
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- simulating missing IRQ&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;ip_waitq
)paren
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/* FIXME: this doesn&squot;t do anything right now */
DECL|function|us_bus_reset
r_static
r_int
id|us_bus_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
)paren
(brace
singleline_comment|// struct us_data *us = (struct us_data *)srb-&gt;host-&gt;hostdata[0];
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;usb-storage: bus_reset() requested but not implemented&bslash;n&quot;
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bus reset requested&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|//  us-&gt;transport_reset(us);
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/* FIXME: This doesn&squot;t actually reset anything */
DECL|function|us_host_reset
r_static
r_int
id|us_host_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;usb-storage: host_reset() requested but not implemented&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * /proc/scsi/ functions&n; ***********************************************************************/
multiline_comment|/* we use this macro to help us write into the buffer */
DECL|macro|SPRINTF
macro_line|#undef SPRINTF
DECL|macro|SPRINTF
mdefine_line|#define SPRINTF(args...) &bslash;&n;&t;do { if (pos &lt; buffer+length) pos += sprintf(pos, ## args); } while (0)
DECL|function|usb_stor_proc_info
r_int
id|usb_stor_proc_info
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|inout
)paren
(brace
r_struct
id|us_data
op_star
id|us
suffix:semicolon
r_char
op_star
id|pos
op_assign
id|buffer
suffix:semicolon
multiline_comment|/* if someone is sending us data, just throw it away */
r_if
c_cond
(paren
id|inout
)paren
r_return
id|length
suffix:semicolon
multiline_comment|/* lock the data structures */
id|down
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
multiline_comment|/* find our data from hostno */
id|us
op_assign
id|us_list
suffix:semicolon
r_while
c_loop
(paren
id|us
)paren
(brace
r_if
c_cond
(paren
id|us-&gt;host_no
op_eq
id|hostno
)paren
r_break
suffix:semicolon
id|us
op_assign
id|us-&gt;next
suffix:semicolon
)brace
multiline_comment|/* if we couldn&squot;t find it, we return an error */
r_if
c_cond
(paren
op_logical_neg
id|us
)paren
(brace
id|up
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
r_return
op_minus
id|ESRCH
suffix:semicolon
)brace
multiline_comment|/* print the controler name */
id|SPRINTF
c_func
(paren
l_string|&quot;   Host scsi%d: usb-storage&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
multiline_comment|/* print product, vendor, and serial number strings */
id|SPRINTF
c_func
(paren
l_string|&quot;&t;Vendor: %s&bslash;n&quot;
comma
id|us-&gt;vendor
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;      Product: %s&bslash;n&quot;
comma
id|us-&gt;product
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;Serial Number: %s&bslash;n&quot;
comma
id|us-&gt;serial
)paren
suffix:semicolon
multiline_comment|/* show the protocol and transport */
id|SPRINTF
c_func
(paren
l_string|&quot;     Protocol: %s&bslash;n&quot;
comma
id|us-&gt;protocol_name
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;    Transport: %s&bslash;n&quot;
comma
id|us-&gt;transport_name
)paren
suffix:semicolon
multiline_comment|/* show the GUID of the device */
id|SPRINTF
c_func
(paren
l_string|&quot;&t;  GUID: &quot;
id|GUID_FORMAT
l_string|&quot;&bslash;n&quot;
comma
id|GUID_ARGS
c_func
(paren
id|us-&gt;guid
)paren
)paren
suffix:semicolon
multiline_comment|/* release our lock on the data structures */
id|up
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate start of next buffer, and return value.&n;&t; */
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pos
op_minus
id|buffer
)paren
OL
id|offset
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|pos
op_minus
id|buffer
op_minus
id|offset
)paren
OL
id|length
)paren
r_return
(paren
id|pos
op_minus
id|buffer
op_minus
id|offset
)paren
suffix:semicolon
r_else
r_return
(paren
id|length
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * this defines our &squot;host&squot;&n; */
DECL|variable|my_host_template
r_static
id|Scsi_Host_Template
id|my_host_template
op_assign
(brace
id|name
suffix:colon
l_string|&quot;usb-storage&quot;
comma
id|proc_info
suffix:colon
id|usb_stor_proc_info
comma
id|info
suffix:colon
id|us_info
comma
id|detect
suffix:colon
id|us_detect
comma
id|release
suffix:colon
id|us_release
comma
id|command
suffix:colon
id|us_command
comma
id|queuecommand
suffix:colon
id|us_queuecommand
comma
id|eh_abort_handler
suffix:colon
id|us_abort
comma
id|eh_device_reset_handler
suffix:colon
id|us_bus_reset
comma
id|eh_bus_reset_handler
suffix:colon
id|us_bus_reset
comma
id|eh_host_reset_handler
suffix:colon
id|us_host_reset
comma
id|can_queue
suffix:colon
l_int|1
comma
id|this_id
suffix:colon
op_minus
l_int|1
comma
id|sg_tablesize
suffix:colon
id|SG_ALL
comma
id|cmd_per_lun
suffix:colon
l_int|1
comma
id|present
suffix:colon
l_int|0
comma
id|unchecked_isa_dma
suffix:colon
id|FALSE
comma
id|use_clustering
suffix:colon
id|TRUE
comma
id|use_new_eh_code
suffix:colon
id|TRUE
comma
id|emulated
suffix:colon
id|TRUE
)brace
suffix:semicolon
DECL|variable|sense_notready
r_static
r_int
r_char
id|sense_notready
(braket
)braket
op_assign
(brace
l_int|0x70
comma
multiline_comment|/* current error */
l_int|0x00
comma
l_int|0x02
comma
multiline_comment|/* not ready */
l_int|0x00
comma
l_int|0x00
comma
l_int|0x0a
comma
multiline_comment|/* additional length */
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x04
comma
multiline_comment|/* not ready */
l_int|0x03
comma
multiline_comment|/* manual intervention */
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
DECL|function|usb_stor_control_thread
r_static
r_int
id|usb_stor_control_thread
c_func
(paren
r_void
op_star
id|__us
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|__us
suffix:semicolon
r_int
id|action
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This thread doesn&squot;t need any user-level access,&n;&t; * so get rid of all our resources..&n;&t; */
id|daemonize
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set our name for identification purposes */
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;usb-storage-%d&quot;
comma
id|us-&gt;host_number
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* signal that we&squot;ve started the thread */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;*** thread sleeping.&bslash;n&quot;
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;sleeper
)paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;queue_exclusion
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;*** thread awakened.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* take the command off the queue */
id|action
op_assign
id|us-&gt;action
suffix:semicolon
id|us-&gt;action
op_assign
l_int|0
suffix:semicolon
id|us-&gt;srb
op_assign
id|us-&gt;queue_srb
suffix:semicolon
multiline_comment|/* release the queue lock as fast as possible */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;queue_exclusion
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|US_ACT_COMMAND
suffix:colon
multiline_comment|/* reject if target != 0 or if single-lun device&n;&t;&t;&t; * and LUN != 0&n;&t;&t;&t; */
r_if
c_cond
(paren
id|us-&gt;srb-&gt;target
op_logical_or
(paren
(paren
id|us-&gt;flags
op_amp
id|US_FL_SINGLE_LUN
)paren
op_logical_and
id|us-&gt;srb-&gt;lun
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bad device number (%d/%d)&bslash;n&quot;
comma
id|us-&gt;srb-&gt;target
comma
id|us-&gt;srb-&gt;lun
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
id|us-&gt;srb
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|us-&gt;srb
)paren
suffix:semicolon
id|us-&gt;srb
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* handle those devices which can&squot;t do a START_STOP */
r_if
c_cond
(paren
(paren
id|us-&gt;srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|START_STOP
)paren
op_logical_and
(paren
id|us-&gt;flags
op_amp
id|US_FL_START_STOP
)paren
)paren
(brace
id|us-&gt;srb-&gt;result
op_assign
id|GOOD
suffix:semicolon
id|us-&gt;srb
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|us-&gt;srb
)paren
suffix:semicolon
id|us-&gt;srb
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* lock the device pointers */
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* our device has gone - pretend not ready */
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;pusb_dev
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Request is for removed device&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* For REQUEST_SENSE, it&squot;s the data.  But&n;&t;&t;&t;&t; * for anything else, it should look like&n;&t;&t;&t;&t; * we auto-sensed for it.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|us-&gt;srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
(brace
id|memcpy
c_func
(paren
id|us-&gt;srb-&gt;request_buffer
comma
id|sense_notready
comma
r_sizeof
(paren
id|sense_notready
)paren
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|GOOD
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|us-&gt;srb-&gt;sense_buffer
comma
id|sense_notready
comma
r_sizeof
(paren
id|sense_notready
)paren
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|CHECK_CONDITION
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* !us-&gt;pusb_dev */
multiline_comment|/* we&squot;ve got a command, let&squot;s do it! */
id|US_DEBUG
c_func
(paren
id|us_show_command
c_func
(paren
id|us-&gt;srb
)paren
)paren
suffix:semicolon
id|us
op_member_access_from_pointer
id|proto_handler
c_func
(paren
id|us-&gt;srb
comma
id|us
)paren
suffix:semicolon
)brace
multiline_comment|/* unlock the device pointers */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* indicate that the command is done */
id|US_DEBUGP
c_func
(paren
l_string|&quot;scsi cmd done, result=0x%x&bslash;n&quot;
comma
id|us-&gt;srb-&gt;result
)paren
suffix:semicolon
id|us-&gt;srb
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|us-&gt;srb
)paren
suffix:semicolon
id|us-&gt;srb
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_ACT_DEVICE_RESET
suffix:colon
r_break
suffix:semicolon
r_case
id|US_ACT_BUS_RESET
suffix:colon
r_break
suffix:semicolon
r_case
id|US_ACT_HOST_RESET
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* end switch on action */
multiline_comment|/* exit if we get a signal to exit */
r_if
c_cond
(paren
id|action
op_eq
id|US_ACT_EXIT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- US_ACT_EXIT command recieved&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* for (;;) */
multiline_comment|/* notify the exit routine that we&squot;re actually exiting now */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|us_unusual_dev_list
r_static
r_struct
id|us_unusual_dev
id|us_unusual_dev_list
(braket
)braket
op_assign
(brace
(brace
l_int|0x057b
comma
l_int|0x0000
comma
l_int|0x0114
comma
l_string|&quot;Y-E Data Flashbuster-U&quot;
comma
id|US_SC_UFI
comma
id|US_PR_CB
comma
id|US_FL_SINGLE_LUN
)brace
comma
(brace
l_int|0x059b
comma
l_int|0x0030
comma
l_int|0x0100
comma
l_string|&quot;Iomega Zip 250&quot;
comma
id|US_SC_SCSI
comma
id|US_PR_BULK
comma
id|US_FL_SINGLE_LUN
)brace
comma
(brace
l_int|0x0781
comma
l_int|0x0001
comma
l_int|0x0200
comma
l_string|&quot;Sandisk ImageMate (w/eject button)&quot;
comma
id|US_SC_SCSI
comma
id|US_PR_CB
comma
id|US_FL_SINGLE_LUN
op_or
id|US_FL_START_STOP
)brace
comma
(brace
l_int|0x0781
comma
l_int|0x0002
comma
l_int|0x0009
comma
l_string|&quot;** SECRET DEVICE **&quot;
comma
id|US_SC_SCSI
comma
id|US_PR_BULK
comma
id|US_FL_SINGLE_LUN
op_or
id|US_FL_IGNORE_SER
)brace
comma
(brace
l_int|0x07af
comma
l_int|0x0005
comma
l_int|0x0100
comma
l_string|&quot;Microtech USB-SCSI-HD50&quot;
comma
id|US_SC_SCSI
comma
id|US_PR_BULK
comma
id|US_FL_ALT_LENGTH
)brace
comma
(brace
l_int|0x04e6
comma
l_int|0x0002
comma
l_int|0x0100
comma
l_string|&quot;Shuttle eUSCSI Bridge&quot;
comma
id|US_SC_SCSI
comma
id|US_PR_BULK
comma
id|US_FL_ALT_LENGTH
)brace
comma
(brace
l_int|0x04e6
comma
l_int|0x0006
comma
l_int|0x0100
comma
l_string|&quot;Shuttle eUSB MMC Adapter&quot;
comma
id|US_SC_SCSI
comma
id|US_PR_CB
comma
id|US_FL_SINGLE_LUN
)brace
comma
(brace
l_int|0x03f0
comma
l_int|0x0107
comma
l_int|0x0200
comma
l_string|&quot;HP USB CD-Writer Plus&quot;
comma
id|US_SC_8070
comma
id|US_PR_CB
comma
l_int|0
)brace
comma
(brace
l_int|0x0000
comma
l_int|0x0000
comma
l_int|0x0
comma
l_string|&quot;&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* Search our ususual device list, based on vendor/product combinations&n; * to see if we can support this device.  Returns a pointer to a structure&n; * defining how we should support this device, or NULL if it&squot;s not in the&n; * list&n; */
DECL|function|us_find_dev
r_static
r_struct
id|us_unusual_dev
op_star
id|us_find_dev
c_func
(paren
id|u16
id|idVendor
comma
id|u16
id|idProduct
comma
id|u16
id|bcdDevice
)paren
(brace
r_struct
id|us_unusual_dev
op_star
id|ptr
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Searching unusual device list for (0x%x, 0x%x, 0x%x)...&bslash;n&quot;
comma
id|idVendor
comma
id|idProduct
comma
id|bcdDevice
)paren
suffix:semicolon
id|ptr
op_assign
id|us_unusual_dev_list
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ptr-&gt;idVendor
op_ne
l_int|0x0000
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|ptr-&gt;idVendor
op_eq
id|idVendor
)paren
op_logical_and
(paren
id|ptr-&gt;idProduct
op_eq
id|idProduct
)paren
op_logical_and
(paren
id|ptr-&gt;bcdDevice
op_eq
id|bcdDevice
)paren
)paren
)paren
id|ptr
op_increment
suffix:semicolon
multiline_comment|/* if the search ended because we hit the end record, we failed */
r_if
c_cond
(paren
id|ptr-&gt;idVendor
op_eq
l_int|0x0000
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- did not find a matching device&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* otherwise, we found one! */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- found matching device: %s&bslash;n&quot;
comma
id|ptr-&gt;name
)paren
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/* Set up the IRQ pipe and handler&n; * Note that this function assumes that all the data in the us_data&n; * strucuture is current.  This includes the ep_int field, which gives us&n; * the endpoint for the interrupt.&n; * Returns non-zero on failure, zero on success&n; */
DECL|function|usb_stor_allocate_irq
r_static
r_int
id|usb_stor_allocate_irq
c_func
(paren
r_struct
id|us_data
op_star
id|ss
)paren
(brace
r_int
r_int
id|pipe
suffix:semicolon
r_int
id|maxp
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Allocating IRQ for CBI transport&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* lock access to the data structure */
id|down
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
multiline_comment|/* allocate the URB */
id|ss-&gt;irq_urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss-&gt;irq_urb
)paren
(brace
id|up
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;couldn&squot;t allocate interrupt URB&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* calculate the pipe and max packet size */
id|pipe
op_assign
id|usb_rcvintpipe
c_func
(paren
id|ss-&gt;pusb_dev
comma
id|ss-&gt;ep_int-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
suffix:semicolon
id|maxp
op_assign
id|usb_maxpacket
c_func
(paren
id|ss-&gt;pusb_dev
comma
id|pipe
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxp
OG
r_sizeof
(paren
id|ss-&gt;irqbuf
)paren
)paren
id|maxp
op_assign
r_sizeof
(paren
id|ss-&gt;irqbuf
)paren
suffix:semicolon
multiline_comment|/* fill in the URB with our data */
id|FILL_INT_URB
c_func
(paren
id|ss-&gt;irq_urb
comma
id|ss-&gt;pusb_dev
comma
id|pipe
comma
id|ss-&gt;irqbuf
comma
id|maxp
comma
id|CBI_irq
comma
id|ss
comma
id|ss-&gt;ep_int-&gt;bInterval
)paren
suffix:semicolon
multiline_comment|/* submit the URB for processing */
id|result
op_assign
id|usb_submit_urb
c_func
(paren
id|ss-&gt;irq_urb
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_submit_urb() returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|usb_free_urb
c_func
(paren
id|ss-&gt;irq_urb
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
multiline_comment|/* unlock the data structure and return success */
id|up
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Probe to see if a new device is actually a SCSI device */
DECL|function|storage_probe
r_static
r_void
op_star
id|storage_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
id|mf
(braket
id|USB_STOR_STRING_LEN
)braket
suffix:semicolon
multiline_comment|/* manufacturer */
r_char
id|prod
(braket
id|USB_STOR_STRING_LEN
)braket
suffix:semicolon
multiline_comment|/* product */
r_char
id|serial
(braket
id|USB_STOR_STRING_LEN
)braket
suffix:semicolon
multiline_comment|/* serial number */
id|GUID
c_func
(paren
id|guid
)paren
suffix:semicolon
multiline_comment|/* Global Unique Identifier */
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|us_unusual_dev
op_star
id|unusual_dev
suffix:semicolon
r_struct
id|us_data
op_star
id|ss
op_assign
l_int|NULL
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* these are temporary copies -- we test on these, then put them&n;&t; * in the us-data structure &n;&t; */
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_in
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_out
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_int
op_assign
l_int|NULL
suffix:semicolon
id|u8
id|subclass
op_assign
l_int|0
suffix:semicolon
id|u8
id|protocol
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* the altsettting 0 on the interface we&squot;re probing */
r_struct
id|usb_interface_descriptor
op_star
id|altsetting
op_assign
op_amp
(paren
id|dev-&gt;actconfig-&gt;interface
(braket
id|ifnum
)braket
dot
id|altsetting
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* clear the temporary strings */
id|memset
c_func
(paren
id|mf
comma
l_int|0
comma
r_sizeof
(paren
id|mf
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|prod
comma
l_int|0
comma
r_sizeof
(paren
id|prod
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|serial
comma
l_int|0
comma
r_sizeof
(paren
id|serial
)paren
)paren
suffix:semicolon
multiline_comment|/* search for this device in our unusual device list */
id|unusual_dev
op_assign
id|us_find_dev
c_func
(paren
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
comma
id|dev-&gt;descriptor.bcdDevice
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Can we support this device, either because we know about it&n;&t; * from our unusual device list, or because it advertises that it&squot;s&n;&t; * compliant to the specification?&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|unusual_dev
op_logical_and
op_logical_neg
(paren
id|dev-&gt;descriptor.bDeviceClass
op_eq
l_int|0
op_logical_and
id|altsetting-&gt;bInterfaceClass
op_eq
id|USB_CLASS_MASS_STORAGE
op_logical_and
id|altsetting-&gt;bInterfaceSubClass
op_ge
id|US_SC_MIN
op_logical_and
id|altsetting-&gt;bInterfaceSubClass
op_le
id|US_SC_MAX
)paren
)paren
(brace
multiline_comment|/* if it&squot;s not a mass storage, we go no further */
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* At this point, we know we&squot;ve got a live one */
id|US_DEBUGP
c_func
(paren
l_string|&quot;USB Mass Storage device detected&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Determine subclass and protocol, or copy from the interface */
r_if
c_cond
(paren
id|unusual_dev
)paren
(brace
id|subclass
op_assign
id|unusual_dev-&gt;useProtocol
suffix:semicolon
id|protocol
op_assign
id|unusual_dev-&gt;useTransport
suffix:semicolon
id|flags
op_assign
id|unusual_dev-&gt;flags
suffix:semicolon
)brace
r_else
(brace
id|subclass
op_assign
id|altsetting-&gt;bInterfaceSubClass
suffix:semicolon
id|protocol
op_assign
id|altsetting-&gt;bInterfaceProtocol
suffix:semicolon
id|flags
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find the endpoints we need&n;&t; * We are expecting a minimum of 2 endpoints - in and out (bulk).&n;&t; * An optional interrupt is OK (necessary for CBI protocol).&n;&t; * We will ignore any others.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|altsetting-&gt;bNumEndpoints
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* is it an BULK endpoint? */
r_if
c_cond
(paren
(paren
id|altsetting-&gt;endpoint
(braket
id|i
)braket
dot
id|bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_eq
id|USB_ENDPOINT_XFER_BULK
)paren
(brace
multiline_comment|/* BULK in or out? */
r_if
c_cond
(paren
id|altsetting-&gt;endpoint
(braket
id|i
)braket
dot
id|bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
id|ep_in
op_assign
op_amp
id|altsetting-&gt;endpoint
(braket
id|i
)braket
suffix:semicolon
r_else
id|ep_out
op_assign
op_amp
id|altsetting-&gt;endpoint
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* is it an interrupt endpoint? */
r_if
c_cond
(paren
(paren
id|altsetting-&gt;endpoint
(braket
id|i
)braket
dot
id|bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_eq
id|USB_ENDPOINT_XFER_INT
)paren
(brace
id|ep_int
op_assign
op_amp
id|altsetting-&gt;endpoint
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Endpoints: In: 0x%p Out: 0x%p Int: 0x%p (Period %d)&bslash;n&quot;
comma
id|ep_in
comma
id|ep_out
comma
id|ep_int
comma
id|ep_int
ques
c_cond
id|ep_int-&gt;bInterval
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/* set the interface -- STALL is an acceptable response here */
id|result
op_assign
id|usb_set_interface
c_func
(paren
id|dev
comma
id|altsetting-&gt;bInterfaceNumber
comma
l_int|0
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result from usb_set_interface is %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- clearing stall on control interface&bslash;n&quot;
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
multiline_comment|/* it&squot;s not a stall, but another error -- time to bail */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Unknown error.  Rejecting device&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Do some basic sanity checks, and bail if we find a problem */
r_if
c_cond
(paren
op_logical_neg
id|ep_in
op_logical_or
op_logical_neg
id|ep_out
op_logical_or
(paren
id|protocol
op_eq
id|US_PR_CBI
op_logical_and
op_logical_neg
id|ep_int
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Sanity check failed.&t; Rejecting device.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* At this point, we&squot;re committed to using the device */
multiline_comment|/* clear the GUID and fetch the strings */
id|GUID_CLEAR
c_func
(paren
id|guid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iManufacturer
)paren
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iManufacturer
comma
id|mf
comma
r_sizeof
(paren
id|mf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iProduct
)paren
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iProduct
comma
id|prod
comma
r_sizeof
(paren
id|prod
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iSerialNumber
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|US_FL_IGNORE_SER
)paren
)paren
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iSerialNumber
comma
id|serial
comma
r_sizeof
(paren
id|serial
)paren
)paren
suffix:semicolon
multiline_comment|/* Create a GUID for this device */
r_if
c_cond
(paren
id|dev-&gt;descriptor.iSerialNumber
op_logical_and
id|serial
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* If we have a serial number, and it&squot;s a non-NULL string */
id|make_guid
c_func
(paren
id|guid
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
comma
id|serial
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We don&squot;t have a serial number, so we use 0 */
id|make_guid
c_func
(paren
id|guid
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
comma
l_string|&quot;0&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* lock access to the data structures */
id|down
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now check if we have seen this GUID before&n;&t; * We&squot;re looking for a device with a matching GUID that isn&squot;t&n;&t; * allready on the system&n;&t; */
id|ss
op_assign
id|us_list
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ss
op_ne
l_int|NULL
)paren
op_logical_and
(paren
(paren
id|ss-&gt;pusb_dev
)paren
op_logical_or
op_logical_neg
id|GUID_EQUAL
c_func
(paren
id|guid
comma
id|ss-&gt;guid
)paren
)paren
)paren
id|ss
op_assign
id|ss-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|ss
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Existing device -- re-connect */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Found existing GUID &quot;
id|GUID_FORMAT
l_string|&quot;&bslash;n&quot;
comma
id|GUID_ARGS
c_func
(paren
id|guid
)paren
)paren
suffix:semicolon
multiline_comment|/* establish the connection to the new device upon reconnect */
id|ss-&gt;ifnum
op_assign
id|ifnum
suffix:semicolon
id|ss-&gt;pusb_dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* copy over the endpoint data */
r_if
c_cond
(paren
id|ep_in
)paren
id|ss-&gt;ep_in
op_assign
id|ep_in-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
r_if
c_cond
(paren
id|ep_out
)paren
id|ss-&gt;ep_out
op_assign
id|ep_out-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
id|ss-&gt;ep_int
op_assign
id|ep_int
suffix:semicolon
multiline_comment|/* allocate an IRQ callback if one is needed */
r_if
c_cond
(paren
(paren
id|ss-&gt;protocol
op_eq
id|US_PR_CBI
)paren
op_logical_and
id|usb_stor_allocate_irq
c_func
(paren
id|ss
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* New device -- allocate memory and initialize */
id|US_DEBUGP
c_func
(paren
l_string|&quot;New GUID &quot;
id|GUID_FORMAT
l_string|&quot;&bslash;n&quot;
comma
id|GUID_ARGS
c_func
(paren
id|guid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ss
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|us_data
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ss
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|us_data
)paren
)paren
suffix:semicolon
multiline_comment|/* Initialize the mutexes only when the struct is new */
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
(paren
id|ss-&gt;sleeper
)paren
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
(paren
id|ss-&gt;notify
)paren
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
(paren
id|ss-&gt;ip_waitq
)paren
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|ss-&gt;queue_exclusion
)paren
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|ss-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* copy over the subclass and protocol data */
id|ss-&gt;subclass
op_assign
id|subclass
suffix:semicolon
id|ss-&gt;protocol
op_assign
id|protocol
suffix:semicolon
id|ss-&gt;flags
op_assign
id|flags
suffix:semicolon
multiline_comment|/* copy over the endpoint data */
r_if
c_cond
(paren
id|ep_in
)paren
id|ss-&gt;ep_in
op_assign
id|ep_in-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
r_if
c_cond
(paren
id|ep_out
)paren
id|ss-&gt;ep_out
op_assign
id|ep_out-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
id|ss-&gt;ep_int
op_assign
id|ep_int
suffix:semicolon
multiline_comment|/* establish the connection to the new device */
id|ss-&gt;ifnum
op_assign
id|ifnum
suffix:semicolon
id|ss-&gt;pusb_dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* copy over the identifiying strings */
id|strncpy
c_func
(paren
id|ss-&gt;vendor
comma
id|mf
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|ss-&gt;product
comma
id|prod
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|ss-&gt;serial
comma
id|serial
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|ss-&gt;vendor
)paren
op_eq
l_int|0
)paren
id|strncpy
c_func
(paren
id|ss-&gt;vendor
comma
l_string|&quot;Unknown&quot;
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|ss-&gt;product
)paren
op_eq
l_int|0
)paren
id|strncpy
c_func
(paren
id|ss-&gt;product
comma
l_string|&quot;Unknown&quot;
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|ss-&gt;serial
)paren
op_eq
l_int|0
)paren
id|strncpy
c_func
(paren
id|ss-&gt;serial
comma
l_string|&quot;None&quot;
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
multiline_comment|/* copy the GUID we created before */
id|memcpy
c_func
(paren
id|ss-&gt;guid
comma
id|guid
comma
r_sizeof
(paren
id|guid
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Set the handler pointers based on the protocol&n;&t;&t; * Again, this data is persistant across reattachments&n;&t;&t; */
r_switch
c_cond
(paren
id|ss-&gt;protocol
)paren
(brace
r_case
id|US_PR_CB
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;Control/Bulk&quot;
suffix:semicolon
id|ss-&gt;transport
op_assign
id|CB_transport
suffix:semicolon
id|ss-&gt;transport_reset
op_assign
id|CB_reset
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_PR_CBI
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;Control/Bulk/Interrupt&quot;
suffix:semicolon
id|ss-&gt;transport
op_assign
id|CBI_transport
suffix:semicolon
id|ss-&gt;transport_reset
op_assign
id|CB_reset
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_PR_BULK
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;Bulk&quot;
suffix:semicolon
id|ss-&gt;transport
op_assign
id|Bulk_transport
suffix:semicolon
id|ss-&gt;transport_reset
op_assign
id|Bulk_reset
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
id|up
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ss
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Transport: %s&bslash;n&quot;
comma
id|ss-&gt;transport_name
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ss-&gt;subclass
)paren
(brace
r_case
id|US_SC_RBC
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;Reduced Block Commands (RBC)&quot;
suffix:semicolon
id|ss-&gt;proto_handler
op_assign
id|transparent_scsi_command
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_8020
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;8020i&quot;
suffix:semicolon
id|ss-&gt;proto_handler
op_assign
id|ATAPI_command
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_QIC
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;QIC-157&quot;
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Sorry, device not supported.&t; Please&bslash;n&quot;
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;contact mdharm-usb@one-eyed-alien.net&bslash;n&quot;
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;if you see this message.&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ss
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_8070
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;8070i&quot;
suffix:semicolon
id|ss-&gt;proto_handler
op_assign
id|ATAPI_command
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_SCSI
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;Transparent SCSI&quot;
suffix:semicolon
id|ss-&gt;proto_handler
op_assign
id|transparent_scsi_command
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_UFI
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;Uniform Floppy Interface (UFI)&quot;
suffix:semicolon
id|ss-&gt;proto_handler
op_assign
id|ufi_command
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
id|up
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ss
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Protocol: %s&bslash;n&quot;
comma
id|ss-&gt;protocol_name
)paren
suffix:semicolon
multiline_comment|/* allocate an IRQ callback if one is needed */
r_if
c_cond
(paren
(paren
id|ss-&gt;protocol
op_eq
id|US_PR_CBI
)paren
op_logical_and
id|usb_stor_allocate_irq
c_func
(paren
id|ss
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Since this is a new device, we need to generate a scsi &n;&t;&t; * host definition, and register with the higher SCSI layers&n;&t;&t; */
multiline_comment|/* Initialize the host template based on the default one */
id|memcpy
c_func
(paren
op_amp
(paren
id|ss-&gt;htmplt
)paren
comma
op_amp
id|my_host_template
comma
r_sizeof
(paren
id|my_host_template
)paren
)paren
suffix:semicolon
multiline_comment|/* Grab the next host number */
id|ss-&gt;host_number
op_assign
id|my_host_number
op_increment
suffix:semicolon
multiline_comment|/* We abuse this pointer so we can pass the ss pointer to &n;&t;&t; * the host controler thread in us_detect.  But how else are&n;&t;&t; * we to do it?&n;&t;&t; */
(paren
r_struct
id|us_data
op_star
)paren
id|ss-&gt;htmplt.proc_dir
op_assign
id|ss
suffix:semicolon
multiline_comment|/* start up our control thread */
id|ss-&gt;pid
op_assign
id|kernel_thread
c_func
(paren
id|usb_stor_control_thread
comma
id|ss
comma
id|CLONE_FS
op_or
id|CLONE_FILES
op_or
id|CLONE_SIGHAND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss-&gt;pid
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Unable to start control thread&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ss
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* wait for the thread to start */
id|down
c_func
(paren
op_amp
(paren
id|ss-&gt;notify
)paren
)paren
suffix:semicolon
multiline_comment|/* now register&t; - our detect function will be called */
id|ss-&gt;htmplt.module
op_assign
id|THIS_MODULE
suffix:semicolon
id|scsi_register_module
c_func
(paren
id|MODULE_SCSI_HA
comma
op_amp
(paren
id|ss-&gt;htmplt
)paren
)paren
suffix:semicolon
multiline_comment|/* put us in the list */
id|ss-&gt;next
op_assign
id|us_list
suffix:semicolon
id|us_list
op_assign
id|ss
suffix:semicolon
)brace
multiline_comment|/* release the data structure lock */
id|up
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WARNING: USB Mass Storage data integrity not assured&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;USB Mass Storage device found at %d&bslash;n&quot;
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
multiline_comment|/* return a pointer for the disconnect function */
r_return
id|ss
suffix:semicolon
)brace
multiline_comment|/* Handle a disconnect event from the USB core */
DECL|function|storage_disconnect
r_static
r_void
id|storage_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|us_data
op_star
id|ss
op_assign
id|ptr
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;storage_disconnect() called&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* this is the odd case -- we disconnected but weren&squot;t using it */
r_if
c_cond
(paren
op_logical_neg
id|ss
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- device was not in use&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* lock access to the device data structure */
id|down
c_func
(paren
op_amp
(paren
id|ss-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* release the IRQ, if we have one */
id|down
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss-&gt;irq_urb
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- releasing irq handle&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_unlink_urb
c_func
(paren
id|ss-&gt;irq_urb
)paren
suffix:semicolon
id|ss-&gt;irq_urb
op_assign
l_int|NULL
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- usb_unlink_urb() returned %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|ss-&gt;irq_urb
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
multiline_comment|/* mark the device as gone */
id|ss-&gt;pusb_dev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* lock access to the device data structure */
id|up
c_func
(paren
op_amp
(paren
id|ss-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Initialization and registration&n; ***********************************************************************/
DECL|function|usb_stor_init
r_int
id|__init
id|usb_stor_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* initialize internal global data elements */
id|us_list
op_assign
l_int|NULL
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
id|my_host_number
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* register the driver, return -1 if error */
r_if
c_cond
(paren
id|usb_register
c_func
(paren
op_amp
id|storage_driver
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* we&squot;re all set */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;USB Mass Storage support registered.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_stor_exit
r_void
id|__exit
id|usb_stor_exit
c_func
(paren
r_void
)paren
(brace
r_struct
id|us_data
op_star
id|next
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_stor_exit() called&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Deregister the driver&n;&t; * This eliminates races with probes and disconnects &n;&t; */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- calling usb_deregister()&bslash;n&quot;
)paren
suffix:semicolon
id|usb_deregister
c_func
(paren
op_amp
id|storage_driver
)paren
suffix:semicolon
multiline_comment|/* lock access to the data structures */
id|down
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
multiline_comment|/* While there are still virtual hosts, unregister them&n;&t; *&n;&t; * Note that the us_release() routine will destroy the local data&n;&t; * structure.  So we have to peel these off the top of the list&n;&t; * and keep updating the head pointer as we go.&n;&t; */
r_while
c_loop
(paren
id|us_list
)paren
(brace
multiline_comment|/* keep track of where the next one is */
id|next
op_assign
id|us_list-&gt;next
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- calling scsi_unregister_module()&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_unregister_module
c_func
(paren
id|MODULE_SCSI_HA
comma
op_amp
(paren
id|us_list-&gt;htmplt
)paren
)paren
suffix:semicolon
multiline_comment|/* advance the list pointer */
id|us_list
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/* unlock the data structures */
id|up
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
)brace
DECL|variable|usb_stor_init
id|module_init
c_func
(paren
id|usb_stor_init
)paren
suffix:semicolon
DECL|variable|usb_stor_exit
id|module_exit
c_func
(paren
id|usb_stor_exit
)paren
suffix:semicolon
eof
