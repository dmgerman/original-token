multiline_comment|/*&n; * drivers.c&n; * (C) Copyright 1999 Randy Dunlap.&n; * (C) Copyright 1999, 2000 Thomas Sailer &lt;sailer@ife.ee.ethz.ch&gt;. (proc file per device)&n; * (C) Copyright 1999 Deti Fliegl (new USB architecture)&n; *&n; * $id$&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; *&n; *************************************************************&n; *&n; * 1999-12-16: Thomas Sailer &lt;sailer@ife.ee.ethz.ch&gt;&n; *   Converted the whole proc stuff to real&n; *   read methods. Now not the whole device list needs to fit&n; *   into one page, only the device list for one bus.&n; *   Added a poll method to /proc/bus/usb/devices, to wake&n; *   up an eventual usbd&n; * 2000-01-04: Thomas Sailer &lt;sailer@ife.ee.ethz.ch&gt;&n; *   Turned into its own filesystem&n; *&n; * $Id: drivers.c,v 1.3 2000/01/11 13:58:24 tom Exp $&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;linux/usbdevice_fs.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/*****************************************************************/
multiline_comment|/*&n; * Dump usb_driver_list.&n; *&n; * We now walk the list of registered USB drivers.&n; */
DECL|function|usb_driver_read
r_static
id|ssize_t
id|usb_driver_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|nbytes
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
op_assign
id|usb_driver_list.next
suffix:semicolon
r_char
op_star
id|page
comma
op_star
id|start
comma
op_star
id|end
suffix:semicolon
id|ssize_t
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|pos
comma
id|len
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ppos
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|nbytes
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|nbytes
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|start
op_assign
id|page
suffix:semicolon
id|end
op_assign
id|page
op_plus
(paren
id|PAGE_SIZE
op_minus
l_int|100
)paren
suffix:semicolon
id|pos
op_assign
op_star
id|ppos
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|tmp
op_ne
op_amp
id|usb_driver_list
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
(brace
r_struct
id|usb_driver
op_star
id|driver
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|usb_driver
comma
id|driver_list
)paren
suffix:semicolon
r_int
id|minor
op_assign
id|driver-&gt;fops
ques
c_cond
id|driver-&gt;minor
suffix:colon
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_eq
op_minus
l_int|1
)paren
id|start
op_add_assign
id|sprintf
(paren
id|start
comma
l_string|&quot;         %s&bslash;n&quot;
comma
id|driver-&gt;name
)paren
suffix:semicolon
r_else
id|start
op_add_assign
id|sprintf
(paren
id|start
comma
l_string|&quot;%3d-%3d: %s&bslash;n&quot;
comma
id|minor
comma
id|minor
op_plus
l_int|15
comma
id|driver-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
OG
id|end
)paren
(brace
id|start
op_add_assign
id|sprintf
c_func
(paren
id|start
comma
l_string|&quot;(truncated)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|start
op_eq
id|page
)paren
id|start
op_add_assign
id|sprintf
c_func
(paren
id|start
comma
l_string|&quot;(none)&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_assign
id|start
op_minus
id|page
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|pos
)paren
(brace
id|len
op_sub_assign
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|nbytes
)paren
id|len
op_assign
id|nbytes
suffix:semicolon
id|ret
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|page
op_plus
id|pos
comma
id|len
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_else
op_star
id|ppos
op_add_assign
id|len
suffix:semicolon
)brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|page
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|usb_driver_lseek
r_static
id|loff_t
id|usb_driver_lseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|orig
)paren
(brace
r_switch
c_cond
(paren
id|orig
)paren
(brace
r_case
l_int|0
suffix:colon
id|file-&gt;f_pos
op_assign
id|offset
suffix:semicolon
r_return
id|file-&gt;f_pos
suffix:semicolon
r_case
l_int|1
suffix:colon
id|file-&gt;f_pos
op_add_assign
id|offset
suffix:semicolon
r_return
id|file-&gt;f_pos
suffix:semicolon
r_case
l_int|2
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|variable|usbdevfs_drivers_fops
r_struct
id|file_operations
id|usbdevfs_drivers_fops
op_assign
(brace
id|llseek
suffix:colon
id|usb_driver_lseek
comma
id|read
suffix:colon
id|usb_driver_read
comma
)brace
suffix:semicolon
eof
