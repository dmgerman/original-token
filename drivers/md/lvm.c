multiline_comment|/*&n; * kernel/lvm.c&n; *&n; * Copyright (C) 1997 - 2000  Heinz Mauelshagen, Sistina Software&n; *&n; * February-November 1997&n; * April-May,July-August,November 1998&n; * January-March,May,July,September,October 1999&n; * January,February,July,September-November 2000&n; *&n; *&n; * LVM driver is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; * &n; * LVM driver is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with GNU CC; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 59 Temple Place - Suite 330,&n; * Boston, MA 02111-1307, USA. &n; *&n; */
multiline_comment|/*&n; * Changelog&n; *&n; *    09/11/1997 - added chr ioctls VG_STATUS_GET_COUNT&n; *                 and VG_STATUS_GET_NAMELIST&n; *    18/01/1998 - change lvm_chr_open/close lock handling&n; *    30/04/1998 - changed LV_STATUS ioctl to LV_STATUS_BYNAME and&n; *               - added   LV_STATUS_BYINDEX ioctl&n; *               - used lvm_status_byname_req_t and&n; *                      lvm_status_byindex_req_t vars&n; *    04/05/1998 - added multiple device support&n; *    08/05/1998 - added support to set/clear extendable flag in volume group&n; *    09/05/1998 - changed output of lvm_proc_get_global_info() because of&n; *                 support for free (eg. longer) logical volume names&n; *    12/05/1998 - added spin_locks (thanks to Pascal van Dam&n; *                 &lt;pascal@ramoth.xs4all.nl&gt;)&n; *    25/05/1998 - fixed handling of locked PEs in lvm_map() and lvm_chr_ioctl()&n; *    26/05/1998 - reactivated verify_area by access_ok&n; *    07/06/1998 - used vmalloc/vfree instead of kmalloc/kfree to go&n; *                 beyond 128/256 KB max allocation limit per call&n; *               - #ifdef blocked spin_lock calls to avoid compile errors&n; *                 with 2.0.x&n; *    11/06/1998 - another enhancement to spinlock code in lvm_chr_open()&n; *                 and use of LVM_VERSION_CODE instead of my own macros&n; *                 (thanks to  Michael Marxmeier &lt;mike@msede.com&gt;)&n; *    07/07/1998 - added statistics in lvm_map()&n; *    08/07/1998 - saved statistics in lvm_do_lv_extend_reduce()&n; *    25/07/1998 - used __initfunc macro&n; *    02/08/1998 - changes for official char/block major numbers&n; *    07/08/1998 - avoided init_module() and cleanup_module() to be static&n; *    30/08/1998 - changed VG lv_open counter from sum of LV lv_open counters&n; *                 to sum of LVs open (no matter how often each is)&n; *    01/09/1998 - fixed lvm_gendisk.part[] index error&n; *    07/09/1998 - added copying of lv_current_pe-array&n; *                 in LV_STATUS_BYINDEX ioctl&n; *    17/11/1998 - added KERN_* levels to printk&n; *    13/01/1999 - fixed LV index bug in lvm_do_lv_create() which hit lvrename&n; *    07/02/1999 - fixed spinlock handling bug in case of LVM_RESET&n; *                 by moving spinlock code from lvm_chr_open()&n; *                 to lvm_chr_ioctl()&n; *               - added LVM_LOCK_LVM ioctl to lvm_chr_ioctl()&n; *               - allowed LVM_RESET and retrieval commands to go ahead;&n; *                 only other update ioctls are blocked now&n; *               - fixed pv-&gt;pe to NULL for pv_status&n; *               - using lv_req structure in lvm_chr_ioctl() now&n; *               - fixed NULL ptr reference bug in lvm_do_lv_extend_reduce()&n; *                 caused by uncontiguous PV array in lvm_chr_ioctl(VG_REDUCE)&n; *    09/02/1999 - changed BLKRASET and BLKRAGET in lvm_chr_ioctl() to&n; *                 handle lgoical volume private read ahead sector&n; *               - implemented LV read_ahead handling with lvm_blk_read()&n; *                 and lvm_blk_write()&n; *    10/02/1999 - implemented 2.[12].* support function lvm_hd_name()&n; *                 to be used in drivers/block/genhd.c by disk_name()&n; *    12/02/1999 - fixed index bug in lvm_blk_ioctl(), HDIO_GETGEO&n; *               - enhanced gendisk insert/remove handling&n; *    16/02/1999 - changed to dynamic block minor number allocation to&n; *                 have as much as 99 volume groups with 256 logical volumes&n; *                 as the grand total; this allows having 1 volume group with&n; *                 up to 256 logical volumes in it&n; *    21/02/1999 - added LV open count information to proc filesystem&n; *               - substituted redundant LVM_RESET code by calls&n; *                 to lvm_do_vg_remove()&n; *    22/02/1999 - used schedule_timeout() to be more responsive&n; *                 in case of lvm_do_vg_remove() with lots of logical volumes&n; *    19/03/1999 - fixed NULL pointer bug in module_init/lvm_init&n; *    17/05/1999 - used DECLARE_WAIT_QUEUE_HEAD macro (&gt;2.3.0)&n; *               - enhanced lvm_hd_name support&n; *    03/07/1999 - avoided use of KERNEL_VERSION macro based ifdefs and&n; *                 memcpy_tofs/memcpy_fromfs macro redefinitions&n; *    06/07/1999 - corrected reads/writes statistic counter copy in case&n; *                 of striped logical volume&n; *    28/07/1999 - implemented snapshot logical volumes&n; *                 - lvm_chr_ioctl&n; *                   - LV_STATUS_BYINDEX&n; *                   - LV_STATUS_BYNAME&n; *                 - lvm_do_lv_create&n; *                 - lvm_do_lv_remove&n; *                 - lvm_map&n; *                 - new lvm_snapshot_remap_block&n; *                 - new lvm_snapshot_remap_new_block&n; *    08/10/1999 - implemented support for multiple snapshots per&n; *                 original logical volume&n; *    12/10/1999 - support for 2.3.19&n; *    11/11/1999 - support for 2.3.28&n; *    21/11/1999 - changed lvm_map() interface to buffer_head based&n; *    19/12/1999 - support for 2.3.33&n; *    01/01/2000 - changed locking concept in lvm_map(),&n; *                 lvm_do_vg_create() and lvm_do_lv_remove()&n; *    15/01/2000 - fixed PV_FLUSH bug in lvm_chr_ioctl()&n; *    24/01/2000 - ported to 2.3.40 including Alan Cox&squot;s pointer changes etc.&n; *    29/01/2000 - used kmalloc/kfree again for all small structures&n; *    20/01/2000 - cleaned up lvm_chr_ioctl by moving code&n; *                 to seperated functions&n; *               - avoided &quot;/dev/&quot; in proc filesystem output&n; *               - avoided inline strings functions lvm_strlen etc.&n; *    14/02/2000 - support for 2.3.43&n; *               - integrated Andrea Arcagneli&squot;s snapshot code&n; *    25/06/2000 - james (chip) , IKKHAYD! roffl&n; *    26/06/2000 - enhanced lv_extend_reduce for snapshot logical volume support&n; *    06/09/2000 - added devfs support&n; *    07/09/2000 - changed IOP version to 9&n; *               - started to add new char ioctl LV_STATUS_BYDEV_T to support&n; *                 getting an lv_t based on the dev_t of the Logical Volume&n; *    14/09/2000 - enhanced lvm_do_lv_create to upcall VFS functions&n; *                 to sync and lock, activate snapshot and unlock the FS&n; *                 (to support journaled filesystems)&n; *    18/09/2000 - hardsector size support&n; *    27/09/2000 - implemented lvm_do_lv_rename() and lvm_do_vg_rename()&n; *    30/10/2000 - added Andi Kleen&squot;s LV_BMAP ioctl to support LILO&n; *    01/11/2000 - added memory information on hash tables to&n; *                 lvm_proc_get_global_info()&n; *    02/11/2000 - implemented /proc/lvm/ hierarchy&n; *    07/12/2000 - make sure lvm_make_request_fn returns correct value - 0 or 1 - NeilBrown&n; *&n; */
DECL|variable|lvm_version
r_static
r_char
op_star
id|lvm_version
op_assign
l_string|&quot;LVM version 0.9  by Heinz Mauelshagen  (13/11/2000)&bslash;n&quot;
suffix:semicolon
DECL|variable|lvm_short_version
r_static
r_char
op_star
id|lvm_short_version
op_assign
l_string|&quot;version 0.9 (13/11/2000)&quot;
suffix:semicolon
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR&t;LVM_BLK_MAJOR
DECL|macro|DEVICE_OFF
mdefine_line|#define&t;DEVICE_OFF(device)
multiline_comment|/* lvm_do_lv_create calls fsync_dev_lockfs()/unlockfs() */
multiline_comment|/* #define&t;LVM_VFS_ENHANCEMENT */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#ifdef MODVERSIONS
DECL|macro|MODULE
macro_line|#undef MODULE
DECL|macro|MODULE
mdefine_line|#define MODULE
macro_line|#include &lt;linux/modversions.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/ioctl.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#ifdef CONFIG_KERNELD
macro_line|#include &lt;linux/kerneld.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/lvm.h&gt;
DECL|macro|LVM_CORRECT_READ_AHEAD
mdefine_line|#define&t;LVM_CORRECT_READ_AHEAD( a) &bslash;&n;   if      ( a &lt; LVM_MIN_READ_AHEAD || &bslash;&n;             a &gt; LVM_MAX_READ_AHEAD) a = LVM_MAX_READ_AHEAD;
macro_line|#ifndef WRITEA
DECL|macro|WRITEA
macro_line|#  define WRITEA WRITE
macro_line|#endif
multiline_comment|/*&n; * External function prototypes&n; */
macro_line|#ifdef MODULE
r_int
id|init_module
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#else
r_extern
r_int
id|lvm_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|lvm_dummy_device_request
c_func
(paren
id|request_queue_t
op_star
)paren
suffix:semicolon
DECL|macro|DEVICE_REQUEST
mdefine_line|#define&t;DEVICE_REQUEST&t;lvm_dummy_device_request
r_static
r_int
id|lvm_make_request_fn
c_func
(paren
id|request_queue_t
op_star
comma
r_int
comma
r_struct
id|buffer_head
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_blk_ioctl
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
id|uint
comma
id|ulong
)paren
suffix:semicolon
r_static
r_int
id|lvm_blk_open
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_chr_open
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_chr_close
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_blk_close
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_user_bmap
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|lv_bmap
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_chr_ioctl
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
id|uint
comma
id|ulong
)paren
suffix:semicolon
macro_line|#if defined CONFIG_LVM_PROC_FS &amp;&amp; defined CONFIG_PROC_FS
r_int
id|lvm_proc_read_vg_info
c_func
(paren
r_char
op_star
comma
r_char
op_star
op_star
comma
id|off_t
comma
r_int
comma
r_int
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_int
id|lvm_proc_read_lv_info
c_func
(paren
r_char
op_star
comma
r_char
op_star
op_star
comma
id|off_t
comma
r_int
comma
r_int
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_int
id|lvm_proc_read_pv_info
c_func
(paren
r_char
op_star
comma
r_char
op_star
op_star
comma
id|off_t
comma
r_int
comma
r_int
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_proc_get_global_info
c_func
(paren
r_char
op_star
comma
r_char
op_star
op_star
comma
id|off_t
comma
r_int
comma
r_int
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_void
id|lvm_do_create_proc_entry_of_vg
(paren
id|vg_t
op_star
)paren
suffix:semicolon
r_inline
r_void
id|lvm_do_remove_proc_entry_of_vg
(paren
id|vg_t
op_star
)paren
suffix:semicolon
r_inline
r_void
id|lvm_do_create_proc_entry_of_lv
(paren
id|vg_t
op_star
comma
id|lv_t
op_star
)paren
suffix:semicolon
r_inline
r_void
id|lvm_do_remove_proc_entry_of_lv
(paren
id|vg_t
op_star
comma
id|lv_t
op_star
)paren
suffix:semicolon
r_inline
r_void
id|lvm_do_create_proc_entry_of_pv
(paren
id|vg_t
op_star
comma
id|pv_t
op_star
)paren
suffix:semicolon
r_inline
r_void
id|lvm_do_remove_proc_entry_of_pv
(paren
id|vg_t
op_star
comma
id|pv_t
op_star
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef LVM_HD_NAME
r_void
id|lvm_hd_name
c_func
(paren
r_char
op_star
comma
r_int
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* End external function prototypes */
multiline_comment|/*&n; * Internal function prototypes&n; */
r_static
r_void
id|lvm_init_vars
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* external snapshot calls */
r_extern
r_inline
r_int
id|lvm_get_blksize
c_func
(paren
id|kdev_t
)paren
suffix:semicolon
r_extern
r_int
id|lvm_snapshot_alloc
c_func
(paren
id|lv_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|lvm_snapshot_fill_COW_page
c_func
(paren
id|vg_t
op_star
comma
id|lv_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|lvm_snapshot_COW
c_func
(paren
id|kdev_t
comma
id|ulong
comma
id|ulong
comma
id|ulong
comma
id|lv_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|lvm_snapshot_remap_block
c_func
(paren
id|kdev_t
op_star
comma
id|ulong
op_star
comma
id|ulong
comma
id|lv_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|lvm_snapshot_release
c_func
(paren
id|lv_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|lvm_write_COW_table_block
c_func
(paren
id|vg_t
op_star
comma
id|lv_t
op_star
)paren
suffix:semicolon
r_extern
r_inline
r_void
id|lvm_hash_link
c_func
(paren
id|lv_block_exception_t
op_star
comma
id|kdev_t
comma
id|ulong
comma
id|lv_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|lvm_snapshot_alloc_hash_table
c_func
(paren
id|lv_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|lvm_drop_snapshot
c_func
(paren
id|lv_t
op_star
comma
r_char
op_star
)paren
suffix:semicolon
macro_line|#ifdef LVM_HD_NAME
r_extern
r_void
(paren
op_star
id|lvm_hd_name_ptr
)paren
(paren
r_char
op_star
comma
r_int
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|lvm_map
c_func
(paren
r_struct
id|buffer_head
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_lock_lvm
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_le_remap
c_func
(paren
id|vg_t
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_pv_create
c_func
(paren
id|pv_t
op_star
comma
id|vg_t
op_star
comma
id|ulong
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_pv_remove
c_func
(paren
id|vg_t
op_star
comma
id|ulong
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_lv_create
c_func
(paren
r_int
comma
r_char
op_star
comma
id|lv_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_lv_extend_reduce
c_func
(paren
r_int
comma
r_char
op_star
comma
id|lv_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_lv_remove
c_func
(paren
r_int
comma
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_lv_rename
c_func
(paren
id|vg_t
op_star
comma
id|lv_req_t
op_star
comma
id|lv_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_lv_status_byname
c_func
(paren
id|vg_t
op_star
id|r
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_lv_status_byindex
c_func
(paren
id|vg_t
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_lv_status_bydev
c_func
(paren
id|vg_t
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_pe_lock_unlock
c_func
(paren
id|vg_t
op_star
id|r
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_pv_change
c_func
(paren
id|vg_t
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_pv_status
c_func
(paren
id|vg_t
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_vg_create
c_func
(paren
r_int
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_vg_extend
c_func
(paren
id|vg_t
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_vg_reduce
c_func
(paren
id|vg_t
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_vg_rename
c_func
(paren
id|vg_t
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_vg_remove
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_void
id|lvm_geninit
c_func
(paren
r_struct
id|gendisk
op_star
)paren
suffix:semicolon
macro_line|#ifdef LVM_GET_INODE
r_static
r_struct
id|inode
op_star
id|lvm_get_inode
c_func
(paren
r_int
)paren
suffix:semicolon
r_void
id|lvm_clear_inode
c_func
(paren
r_struct
id|inode
op_star
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* END Internal function prototypes */
multiline_comment|/* volume group descriptor area pointers */
DECL|variable|vg
r_static
id|vg_t
op_star
id|vg
(braket
id|ABS_MAX_VG
)braket
suffix:semicolon
macro_line|#ifdef&t;CONFIG_DEVFS_FS
DECL|variable|lvm_devfs_handle
r_static
id|devfs_handle_t
id|lvm_devfs_handle
suffix:semicolon
DECL|variable|vg_devfs_handle
r_static
id|devfs_handle_t
id|vg_devfs_handle
(braket
id|MAX_VG
)braket
suffix:semicolon
DECL|variable|ch_devfs_handle
r_static
id|devfs_handle_t
id|ch_devfs_handle
(braket
id|MAX_VG
)braket
suffix:semicolon
DECL|variable|lv_devfs_handle
r_static
id|devfs_handle_t
id|lv_devfs_handle
(braket
id|MAX_LV
)braket
suffix:semicolon
macro_line|#endif
DECL|variable|pvp
r_static
id|pv_t
op_star
id|pvp
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|lvp
r_static
id|lv_t
op_star
id|lvp
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|pep
r_static
id|pe_t
op_star
id|pep
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|pep1
r_static
id|pe_t
op_star
id|pep1
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|basename
r_static
r_char
op_star
id|basename
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* map from block minor number to VG and LV numbers */
r_typedef
r_struct
(brace
DECL|member|vg_number
r_int
id|vg_number
suffix:semicolon
DECL|member|lv_number
r_int
id|lv_number
suffix:semicolon
DECL|typedef|vg_lv_map_t
)brace
id|vg_lv_map_t
suffix:semicolon
DECL|variable|vg_lv_map
r_static
id|vg_lv_map_t
id|vg_lv_map
(braket
id|ABS_MAX_LV
)braket
suffix:semicolon
multiline_comment|/* Request structures (lvm_chr_ioctl()) */
DECL|variable|pv_change_req
r_static
id|pv_change_req_t
id|pv_change_req
suffix:semicolon
DECL|variable|pv_flush_req
r_static
id|pv_flush_req_t
id|pv_flush_req
suffix:semicolon
DECL|variable|pv_status_req
r_static
id|pv_status_req_t
id|pv_status_req
suffix:semicolon
DECL|variable|pe_lock_req
r_static
id|pe_lock_req_t
id|pe_lock_req
suffix:semicolon
DECL|variable|le_remap_req
r_static
id|le_remap_req_t
id|le_remap_req
suffix:semicolon
DECL|variable|lv_req
r_static
id|lv_req_t
id|lv_req
suffix:semicolon
macro_line|#ifdef LVM_TOTAL_RESET
DECL|variable|lvm_reset_spindown
r_static
r_int
id|lvm_reset_spindown
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|variable|pv_name
r_static
r_char
id|pv_name
(braket
id|NAME_LEN
)braket
suffix:semicolon
multiline_comment|/* static char rootvg[NAME_LEN] = { 0, }; */
DECL|variable|lvm_name
r_const
r_char
op_star
r_const
id|lvm_name
op_assign
id|LVM_NAME
suffix:semicolon
DECL|variable|lock
r_static
r_int
id|lock
op_assign
l_int|0
suffix:semicolon
DECL|variable|loadtime
r_static
r_int
id|loadtime
op_assign
l_int|0
suffix:semicolon
DECL|variable|vg_count
r_static
id|uint
id|vg_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|lvm_chr_open_count
r_static
r_int
id|lvm_chr_open_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|lvm_iop_version
r_static
id|ushort
id|lvm_iop_version
op_assign
id|LVM_DRIVER_IOP_VERSION
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|lvm_snapshot_wait
)paren
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|lvm_wait
)paren
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|lvm_map_wait
)paren
suffix:semicolon
DECL|variable|lvm_lock
r_static
id|spinlock_t
id|lvm_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|lvm_snapshot_lock
r_static
id|spinlock_t
id|lvm_snapshot_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
macro_line|#if defined CONFIG_LVM_PROC_FS &amp;&amp; defined CONFIG_PROC_FS
DECL|variable|lvm_proc_dir
r_static
r_struct
id|proc_dir_entry
op_star
id|lvm_proc_dir
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|lvm_proc_vg_subdir
r_static
r_struct
id|proc_dir_entry
op_star
id|lvm_proc_vg_subdir
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|pde
r_struct
id|proc_dir_entry
op_star
id|pde
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
DECL|variable|lvm_chr_fops
r_static
r_struct
id|file_operations
id|lvm_chr_fops
op_assign
(brace
id|open
suffix:colon
id|lvm_chr_open
comma
id|release
suffix:colon
id|lvm_chr_close
comma
id|ioctl
suffix:colon
id|lvm_chr_ioctl
comma
)brace
suffix:semicolon
DECL|macro|BLOCK_DEVICE_OPERATIONS
mdefine_line|#define BLOCK_DEVICE_OPERATIONS
multiline_comment|/* block device operations structure needed for 2.3.38? and above */
DECL|variable|lvm_blk_dops
r_static
r_struct
id|block_device_operations
id|lvm_blk_dops
op_assign
(brace
id|open
suffix:colon
id|lvm_blk_open
comma
id|release
suffix:colon
id|lvm_blk_close
comma
id|ioctl
suffix:colon
id|lvm_blk_ioctl
comma
)brace
suffix:semicolon
multiline_comment|/* gendisk structures */
DECL|variable|lvm_hd_struct
r_static
r_struct
id|hd_struct
id|lvm_hd_struct
(braket
id|MAX_LV
)braket
suffix:semicolon
DECL|variable|lvm_blocksizes
r_static
r_int
id|lvm_blocksizes
(braket
id|MAX_LV
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|lvm_size
r_static
r_int
id|lvm_size
(braket
id|MAX_LV
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|lvm_gendisk
r_static
r_struct
id|gendisk
id|lvm_gendisk
op_assign
(brace
id|MAJOR_NR
comma
multiline_comment|/* major # */
id|LVM_NAME
comma
multiline_comment|/* name of major */
l_int|0
comma
multiline_comment|/* number of times minor is shifted&n;&t;&t;&t;&t;   to get real minor */
l_int|1
comma
multiline_comment|/* maximum partitions per device */
id|lvm_hd_struct
comma
multiline_comment|/* partition table */
id|lvm_size
comma
multiline_comment|/* device size in blocks, copied&n;&t;&t;&t;&t;   to block_size[] */
id|MAX_LV
comma
multiline_comment|/* number or real devices */
l_int|NULL
comma
multiline_comment|/* internal */
l_int|NULL
comma
multiline_comment|/* pointer to next gendisk struct (internal) */
)brace
suffix:semicolon
macro_line|#ifdef MODULE
multiline_comment|/*&n; * Module initialization...&n; */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
macro_line|#else
multiline_comment|/*&n; * Driver initialization...&n; */
macro_line|#ifdef __initfunc
id|__initfunc
c_func
(paren
r_int
id|lvm_init
c_func
(paren
r_void
)paren
)paren
macro_line|#else
r_int
id|__init
id|lvm_init
c_func
(paren
r_void
)paren
macro_line|#endif
macro_line|#endif&t;&t;&t;&t;/* #ifdef MODULE */
(brace
r_struct
id|gendisk
op_star
id|gendisk_ptr
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|register_chrdev
c_func
(paren
id|LVM_CHAR_MAJOR
comma
id|lvm_name
comma
op_amp
id|lvm_chr_fops
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s -- register_chrdev failed&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#ifdef BLOCK_DEVICE_OPERATIONS
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
id|lvm_name
comma
op_amp
id|lvm_blk_dops
)paren
OL
l_int|0
)paren
macro_line|#else
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
id|lvm_name
comma
op_amp
id|lvm_blk_fops
)paren
OL
l_int|0
)paren
macro_line|#endif
(brace
id|printk
c_func
(paren
l_string|&quot;%s -- register_blkdev failed&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unregister_chrdev
c_func
(paren
id|LVM_CHAR_MAJOR
comma
id|lvm_name
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s -- unregister_chrdev failed&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#ifdef&t;CONFIG_DEVFS_FS
id|lvm_devfs_handle
op_assign
id|devfs_register
c_func
(paren
l_int|0
comma
l_string|&quot;lvm&quot;
comma
l_int|0
comma
l_int|0
comma
id|LVM_CHAR_MAJOR
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
comma
op_amp
id|lvm_chr_fops
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined CONFIG_LVM_PROC_FS &amp;&amp; defined CONFIG_PROC_FS
id|lvm_proc_dir
op_assign
id|create_proc_entry
(paren
id|LVM_DIR
comma
id|S_IFDIR
comma
op_amp
id|proc_root
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lvm_proc_dir
op_ne
l_int|NULL
)paren
(brace
id|lvm_proc_vg_subdir
op_assign
id|create_proc_entry
(paren
id|LVM_VG_SUBDIR
comma
id|S_IFDIR
comma
id|lvm_proc_dir
)paren
suffix:semicolon
id|pde
op_assign
id|create_proc_entry
c_func
(paren
id|LVM_GLOBAL
comma
id|S_IFREG
comma
id|lvm_proc_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pde
op_ne
l_int|NULL
)paren
id|pde-&gt;read_proc
op_assign
op_amp
id|lvm_proc_get_global_info
suffix:semicolon
)brace
macro_line|#endif
id|lvm_init_vars
c_func
(paren
)paren
suffix:semicolon
id|lvm_geninit
c_func
(paren
op_amp
id|lvm_gendisk
)paren
suffix:semicolon
multiline_comment|/* insert our gendisk at the corresponding major */
r_if
c_cond
(paren
id|gendisk_head
op_ne
l_int|NULL
)paren
(brace
id|gendisk_ptr
op_assign
id|gendisk_head
suffix:semicolon
r_while
c_loop
(paren
id|gendisk_ptr-&gt;next
op_ne
l_int|NULL
op_logical_and
id|gendisk_ptr-&gt;major
OG
id|lvm_gendisk.major
)paren
(brace
id|gendisk_ptr
op_assign
id|gendisk_ptr-&gt;next
suffix:semicolon
)brace
id|lvm_gendisk.next
op_assign
id|gendisk_ptr-&gt;next
suffix:semicolon
id|gendisk_ptr-&gt;next
op_assign
op_amp
id|lvm_gendisk
suffix:semicolon
)brace
r_else
(brace
id|gendisk_head
op_assign
op_amp
id|lvm_gendisk
suffix:semicolon
id|lvm_gendisk.next
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef LVM_HD_NAME
multiline_comment|/* reference from drivers/block/genhd.c */
id|lvm_hd_name_ptr
op_assign
id|lvm_hd_name
suffix:semicolon
macro_line|#endif
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|DEVICE_REQUEST
)paren
suffix:semicolon
id|blk_queue_make_request
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|lvm_make_request_fn
)paren
suffix:semicolon
multiline_comment|/* optional read root VGDA */
multiline_comment|/*&n;   if ( *rootvg != 0) vg_read_with_pv_and_lv ( rootvg, &amp;vg);&n;*/
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s%s -- &quot;
macro_line|#ifdef MODULE
l_string|&quot;Module&quot;
macro_line|#else
l_string|&quot;Driver&quot;
macro_line|#endif
l_string|&quot; successfully initialized&bslash;n&quot;
comma
id|lvm_version
comma
id|lvm_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* init_module() / lvm_init() */
macro_line|#ifdef MODULE
multiline_comment|/*&n; * Module cleanup...&n; */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|gendisk
op_star
id|gendisk_ptr
op_assign
l_int|NULL
comma
op_star
id|gendisk_ptr_prev
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef&t;CONFIG_DEVFS_FS
id|devfs_unregister
(paren
id|lvm_devfs_handle
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|unregister_chrdev
c_func
(paren
id|LVM_CHAR_MAJOR
comma
id|lvm_name
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s -- unregister_chrdev failed&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
id|lvm_name
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s -- unregister_blkdev failed&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
)brace
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
id|gendisk_ptr
op_assign
id|gendisk_ptr_prev
op_assign
id|gendisk_head
suffix:semicolon
r_while
c_loop
(paren
id|gendisk_ptr
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|gendisk_ptr
op_eq
op_amp
id|lvm_gendisk
)paren
r_break
suffix:semicolon
id|gendisk_ptr_prev
op_assign
id|gendisk_ptr
suffix:semicolon
id|gendisk_ptr
op_assign
id|gendisk_ptr-&gt;next
suffix:semicolon
)brace
multiline_comment|/* delete our gendisk from chain */
r_if
c_cond
(paren
id|gendisk_ptr
op_eq
op_amp
id|lvm_gendisk
)paren
id|gendisk_ptr_prev-&gt;next
op_assign
id|gendisk_ptr-&gt;next
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
l_int|NULL
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
l_int|NULL
suffix:semicolon
id|hardsect_size
(braket
id|MAJOR_NR
)braket
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if defined CONFIG_LVM_PROC_FS &amp;&amp; defined CONFIG_PROC_FS
id|remove_proc_entry
c_func
(paren
id|LVM_GLOBAL
comma
id|lvm_proc_dir
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|LVM_VG_SUBDIR
comma
id|lvm_proc_dir
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|LVM_DIR
comma
op_amp
id|proc_root
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef LVM_HD_NAME
multiline_comment|/* reference from linux/drivers/block/genhd.c */
id|lvm_hd_name_ptr
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s -- Module successfully deactivated&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* void cleanup_module() */
macro_line|#endif&t;/* #ifdef MODULE */
multiline_comment|/*&n; * support function to initialize lvm variables&n; */
macro_line|#ifdef __initfunc
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|lvm_init_vars
c_func
(paren
r_void
)paren
)paren
macro_line|#else
r_void
id|__init
id|lvm_init_vars
c_func
(paren
r_void
)paren
macro_line|#endif
(brace
r_int
id|v
suffix:semicolon
id|loadtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|lvm_lock
op_assign
id|lvm_snapshot_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|pe_lock_req.lock
op_assign
id|UNLOCK_PE
suffix:semicolon
id|pe_lock_req.data.lv_dev
op_assign
"&bslash;"
id|pe_lock_req.data.pv_dev
op_assign
"&bslash;"
id|pe_lock_req.data.pv_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize VG pointers */
r_for
c_loop
(paren
id|v
op_assign
l_int|0
suffix:semicolon
id|v
OL
id|ABS_MAX_VG
suffix:semicolon
id|v
op_increment
)paren
id|vg
(braket
id|v
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Initialize LV -&gt; VG association */
r_for
c_loop
(paren
id|v
op_assign
l_int|0
suffix:semicolon
id|v
OL
id|ABS_MAX_LV
suffix:semicolon
id|v
op_increment
)paren
(brace
multiline_comment|/* index ABS_MAX_VG never used for real VG */
id|vg_lv_map
(braket
id|v
)braket
dot
id|vg_number
op_assign
id|ABS_MAX_VG
suffix:semicolon
id|vg_lv_map
(braket
id|v
)braket
dot
id|lv_number
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* lvm_init_vars() */
multiline_comment|/********************************************************************&n; *&n; * Character device functions&n; *&n; ********************************************************************/
multiline_comment|/*&n; * character device open routine&n; */
DECL|function|lvm_chr_open
r_static
r_int
id|lvm_chr_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- lvm_chr_open MINOR: %d  VG#: %d  mode: 0x%X  lock: %d&bslash;n&quot;
comma
id|lvm_name
comma
id|minor
comma
id|VG_CHR
c_func
(paren
id|minor
)paren
comma
id|file-&gt;f_mode
comma
id|lock
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* super user validation */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* Group special file open */
r_if
c_cond
(paren
id|VG_CHR
c_func
(paren
id|minor
)paren
OG
id|MAX_VG
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|lvm_chr_open_count
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_chr_open() */
multiline_comment|/*&n; * character device i/o-control routine&n; *&n; * Only one changing process can do changing ioctl at one time,&n; * others will block.&n; *&n; */
DECL|function|lvm_chr_ioctl
r_static
r_int
id|lvm_chr_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|uint
id|command
comma
id|ulong
id|a
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|uint
id|extendable
comma
id|l
comma
id|v
suffix:semicolon
r_void
op_star
id|arg
op_assign
(paren
r_void
op_star
)paren
id|a
suffix:semicolon
id|lv_t
id|lv
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
op_assign
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
multiline_comment|/* otherwise cc will complain about unused variables */
(paren
r_void
)paren
id|lvm_lock
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- lvm_chr_ioctl: command: 0x%X  MINOR: %d  &quot;
l_string|&quot;VG#: %d  mode: 0x%X&bslash;n&quot;
comma
id|lvm_name
comma
id|command
comma
id|minor
comma
id|VG_CHR
c_func
(paren
id|minor
)paren
comma
id|file-&gt;f_mode
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef LVM_TOTAL_RESET
r_if
c_cond
(paren
id|lvm_reset_spindown
OG
l_int|0
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
macro_line|#endif
multiline_comment|/* Main command switch */
r_switch
c_cond
(paren
id|command
)paren
(brace
r_case
id|LVM_LOCK_LVM
suffix:colon
multiline_comment|/* lock the LVM */
r_return
id|lvm_do_lock_lvm
c_func
(paren
)paren
suffix:semicolon
r_case
id|LVM_GET_IOP_VERSION
suffix:colon
multiline_comment|/* check lvm version to ensure driver/tools+lib&n;&t;&t;   interoperability */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|lvm_iop_version
comma
r_sizeof
(paren
id|ushort
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef LVM_TOTAL_RESET
r_case
id|LVM_RESET
suffix:colon
multiline_comment|/* lock reset function */
id|lvm_reset_spindown
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|v
op_assign
l_int|0
suffix:semicolon
id|v
OL
id|ABS_MAX_VG
suffix:semicolon
id|v
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg
(braket
id|v
)braket
op_ne
l_int|NULL
)paren
id|lvm_do_vg_remove
c_func
(paren
id|v
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
r_while
c_loop
(paren
id|GET_USE_COUNT
c_func
(paren
op_amp
id|__this_module
)paren
OL
l_int|1
)paren
id|MOD_INC_USE_COUNT
suffix:semicolon
r_while
c_loop
(paren
id|GET_USE_COUNT
c_func
(paren
op_amp
id|__this_module
)paren
OG
l_int|1
)paren
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif /* MODULE */
id|lock
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* release lock */
id|wake_up_interruptible
c_func
(paren
op_amp
id|lvm_wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif /* LVM_TOTAL_RESET */
r_case
id|LE_REMAP
suffix:colon
multiline_comment|/* remap a logical extent (after moving the physical extent) */
r_return
id|lvm_do_le_remap
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|PE_LOCK_UNLOCK
suffix:colon
multiline_comment|/* lock/unlock i/o to a physical extent to move it to another&n;&t;&t;   physical volume (move&squot;s done in user space&squot;s pvmove) */
r_return
id|lvm_do_pe_lock_unlock
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|VG_CREATE
suffix:colon
multiline_comment|/* create a VGDA */
r_return
id|lvm_do_vg_create
c_func
(paren
id|minor
comma
id|arg
)paren
suffix:semicolon
r_case
id|VG_EXTEND
suffix:colon
multiline_comment|/* extend a volume group */
r_return
id|lvm_do_vg_extend
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|VG_REDUCE
suffix:colon
multiline_comment|/* reduce a volume group */
r_return
id|lvm_do_vg_reduce
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|VG_RENAME
suffix:colon
multiline_comment|/* rename a volume group */
r_return
id|lvm_do_vg_rename
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|VG_REMOVE
suffix:colon
multiline_comment|/* remove an inactive VGDA */
r_return
id|lvm_do_vg_remove
c_func
(paren
id|minor
)paren
suffix:semicolon
r_case
id|VG_SET_EXTENDABLE
suffix:colon
multiline_comment|/* set/clear extendability flag of volume group */
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|extendable
comma
id|arg
comma
r_sizeof
(paren
id|extendable
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|extendable
op_eq
id|VG_EXTENDABLE
op_logical_or
id|extendable
op_eq
op_complement
id|VG_EXTENDABLE
)paren
(brace
r_if
c_cond
(paren
id|extendable
op_eq
id|VG_EXTENDABLE
)paren
id|vg_ptr-&gt;vg_status
op_or_assign
id|VG_EXTENDABLE
suffix:semicolon
r_else
id|vg_ptr-&gt;vg_status
op_and_assign
op_complement
id|VG_EXTENDABLE
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|VG_STATUS
suffix:colon
multiline_comment|/* get volume group data (only the vg_t struct) */
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
id|vg_ptr
comma
r_sizeof
(paren
id|vg_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|VG_STATUS_GET_COUNT
suffix:colon
multiline_comment|/* get volume group count */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|vg_count
comma
r_sizeof
(paren
id|vg_count
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|VG_STATUS_GET_NAMELIST
suffix:colon
multiline_comment|/* get volume group count */
r_for
c_loop
(paren
id|l
op_assign
id|v
op_assign
l_int|0
suffix:semicolon
id|v
OL
id|ABS_MAX_VG
suffix:semicolon
id|v
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg
(braket
id|v
)braket
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
op_plus
id|l
op_star
id|NAME_LEN
comma
id|vg
(braket
id|v
)braket
op_member_access_from_pointer
id|vg_name
comma
id|NAME_LEN
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|l
op_increment
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|LV_CREATE
suffix:colon
r_case
id|LV_EXTEND
suffix:colon
r_case
id|LV_REDUCE
suffix:colon
r_case
id|LV_REMOVE
suffix:colon
r_case
id|LV_RENAME
suffix:colon
multiline_comment|/* create, extend, reduce, remove or rename a logical volume */
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|lv_req
comma
id|arg
comma
r_sizeof
(paren
id|lv_req
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|command
op_ne
id|LV_REMOVE
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|lv
comma
id|lv_req.lv
comma
r_sizeof
(paren
id|lv_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|command
)paren
(brace
r_case
id|LV_CREATE
suffix:colon
r_return
id|lvm_do_lv_create
c_func
(paren
id|minor
comma
id|lv_req.lv_name
comma
op_amp
id|lv
)paren
suffix:semicolon
r_case
id|LV_EXTEND
suffix:colon
r_case
id|LV_REDUCE
suffix:colon
r_return
id|lvm_do_lv_extend_reduce
c_func
(paren
id|minor
comma
id|lv_req.lv_name
comma
op_amp
id|lv
)paren
suffix:semicolon
r_case
id|LV_REMOVE
suffix:colon
r_return
id|lvm_do_lv_remove
c_func
(paren
id|minor
comma
id|lv_req.lv_name
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_case
id|LV_RENAME
suffix:colon
r_return
id|lvm_do_lv_rename
c_func
(paren
id|vg_ptr
comma
op_amp
id|lv_req
comma
op_amp
id|lv
)paren
suffix:semicolon
)brace
r_case
id|LV_STATUS_BYNAME
suffix:colon
multiline_comment|/* get status of a logical volume by name */
r_return
id|lvm_do_lv_status_byname
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|LV_STATUS_BYINDEX
suffix:colon
multiline_comment|/* get status of a logical volume by index */
r_return
id|lvm_do_lv_status_byindex
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|LV_STATUS_BYDEV
suffix:colon
r_return
id|lvm_do_lv_status_bydev
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|PV_CHANGE
suffix:colon
multiline_comment|/* change a physical volume */
r_return
id|lvm_do_pv_change
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|PV_STATUS
suffix:colon
multiline_comment|/* get physical volume data (pv_t structure only) */
r_return
id|lvm_do_pv_status
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|PV_FLUSH
suffix:colon
multiline_comment|/* physical volume buffer flush/invalidate */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|pv_flush_req
comma
id|arg
comma
r_sizeof
(paren
id|pv_flush_req
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|fsync_dev
c_func
(paren
id|pv_flush_req.pv_dev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|pv_flush_req.pv_dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s -- lvm_chr_ioctl: unknown command %x&bslash;n&quot;
comma
id|lvm_name
comma
id|command
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_chr_ioctl */
multiline_comment|/*&n; * character device close routine&n; */
DECL|function|lvm_chr_close
r_static
r_int
id|lvm_chr_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
macro_line|#ifdef DEBUG
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- lvm_chr_close   VG#: %d&bslash;n&quot;
comma
id|lvm_name
comma
id|VG_CHR
c_func
(paren
id|minor
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef LVM_TOTAL_RESET
r_if
c_cond
(paren
id|lvm_reset_spindown
OG
l_int|0
)paren
(brace
id|lvm_reset_spindown
op_assign
l_int|0
suffix:semicolon
id|lvm_chr_open_count
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|lvm_chr_open_count
OG
l_int|0
)paren
id|lvm_chr_open_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|lock
op_eq
id|current-&gt;pid
)paren
(brace
id|lock
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* release lock */
id|wake_up_interruptible
c_func
(paren
op_amp
id|lvm_wait
)paren
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_chr_close() */
multiline_comment|/********************************************************************&n; *&n; * Block device functions&n; *&n; ********************************************************************/
multiline_comment|/*&n; * block device open routine&n; */
DECL|function|lvm_blk_open
r_static
r_int
id|lvm_blk_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
op_assign
id|vg
(braket
id|VG_BLK
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
macro_line|#ifdef DEBUG_LVM_BLK_OPEN
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- lvm_blk_open MINOR: %d  VG#: %d  LV#: %d  mode: 0x%X&bslash;n&quot;
comma
id|lvm_name
comma
id|minor
comma
id|VG_BLK
c_func
(paren
id|minor
)paren
comma
id|LV_BLK
c_func
(paren
id|minor
)paren
comma
id|file-&gt;f_mode
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef LVM_TOTAL_RESET
r_if
c_cond
(paren
id|lvm_reset_spindown
OG
l_int|0
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|vg_ptr
op_ne
l_int|NULL
op_logical_and
(paren
id|vg_ptr-&gt;vg_status
op_amp
id|VG_ACTIVE
)paren
op_logical_and
(paren
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|LV_BLK
c_func
(paren
id|minor
)paren
)braket
)paren
op_ne
l_int|NULL
op_logical_and
id|LV_BLK
c_func
(paren
id|minor
)paren
op_ge
l_int|0
op_logical_and
id|LV_BLK
c_func
(paren
id|minor
)paren
OL
id|vg_ptr-&gt;lv_max
)paren
(brace
multiline_comment|/* Check parallel LV spindown (LV remove) */
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_status
op_amp
id|LV_SPINDOWN
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* Check inactive LV and open for read/write */
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|O_RDWR
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|lv_ptr-&gt;lv_status
op_amp
id|LV_ACTIVE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|lv_ptr-&gt;lv_access
op_amp
id|LV_WRITE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
macro_line|#ifndef BLOCK_DEVICE_OPERATIONS
id|file-&gt;f_op
op_assign
op_amp
id|lvm_blk_fops
suffix:semicolon
macro_line|#endif
multiline_comment|/* be sure to increment VG counter */
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_open
op_eq
l_int|0
)paren
id|vg_ptr-&gt;lv_open
op_increment
suffix:semicolon
id|lv_ptr-&gt;lv_open
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#ifdef DEBUG_LVM_BLK_OPEN
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- lvm_blk_open MINOR: %d  VG#: %d  LV#: %d  size: %d&bslash;n&quot;
comma
id|lvm_name
comma
id|minor
comma
id|VG_BLK
c_func
(paren
id|minor
)paren
comma
id|LV_BLK
c_func
(paren
id|minor
)paren
comma
id|lv_ptr-&gt;lv_size
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* lvm_blk_open() */
multiline_comment|/*&n; * block device i/o-control routine&n; */
DECL|function|lvm_blk_ioctl
r_static
r_int
id|lvm_blk_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|uint
id|command
comma
id|ulong
id|a
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
op_assign
id|vg
(braket
id|VG_BLK
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|LV_BLK
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
r_void
op_star
id|arg
op_assign
(paren
r_void
op_star
)paren
id|a
suffix:semicolon
r_struct
id|hd_geometry
op_star
id|hd
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|a
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- lvm_blk_ioctl MINOR: %d  command: 0x%X  arg: %X  &quot;
l_string|&quot;VG#: %dl  LV#: %d&bslash;n&quot;
comma
id|lvm_name
comma
id|minor
comma
id|command
comma
(paren
id|ulong
)paren
id|arg
comma
id|VG_BLK
c_func
(paren
id|minor
)paren
comma
id|LV_BLK
c_func
(paren
id|minor
)paren
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|command
)paren
(brace
r_case
id|BLKGETSIZE
suffix:colon
multiline_comment|/* return device size */
macro_line|#ifdef DEBUG_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- lvm_blk_ioctl -- BLKGETSIZE: %u&bslash;n&quot;
comma
id|lvm_name
comma
id|lv_ptr-&gt;lv_size
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|lv_ptr-&gt;lv_size
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLKFLSBUF
suffix:colon
multiline_comment|/* flush buffer cache */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- lvm_blk_ioctl -- BLKFLSBUF&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
macro_line|#endif
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLKRASET
suffix:colon
multiline_comment|/* set read ahead for block device */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
macro_line|#ifdef DEBUG_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- lvm_blk_ioctl -- BLKRASET: %d sectors for %02X:%02X&bslash;n&quot;
comma
id|lvm_name
comma
(paren
r_int
)paren
id|arg
comma
id|MAJOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
comma
id|minor
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
r_int
)paren
id|arg
template_param
id|LVM_MAX_READ_AHEAD
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|lv_ptr-&gt;lv_read_ahead
op_assign
(paren
r_int
)paren
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLKRAGET
suffix:colon
multiline_comment|/* get current read ahead setting */
macro_line|#ifdef DEBUG_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- lvm_blk_ioctl -- BLKRAGET&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|lv_ptr-&gt;lv_read_ahead
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDIO_GETGEO
suffix:colon
multiline_comment|/* get disk geometry */
macro_line|#ifdef DEBUG_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- lvm_blk_ioctl -- HDIO_GETGEO&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|hd
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
(brace
r_int
r_char
id|heads
op_assign
l_int|64
suffix:semicolon
r_int
r_char
id|sectors
op_assign
l_int|32
suffix:semicolon
r_int
id|start
op_assign
l_int|0
suffix:semicolon
r_int
id|cylinders
op_assign
id|lv_ptr-&gt;lv_size
op_div
id|heads
op_div
id|sectors
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|hd-&gt;heads
comma
op_amp
id|heads
comma
r_sizeof
(paren
id|heads
)paren
)paren
op_ne
l_int|0
op_logical_or
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|hd-&gt;sectors
comma
op_amp
id|sectors
comma
r_sizeof
(paren
id|sectors
)paren
)paren
op_ne
l_int|0
op_logical_or
id|copy_to_user
c_func
(paren
(paren
r_int
op_star
)paren
op_amp
id|hd-&gt;cylinders
comma
op_amp
id|cylinders
comma
r_sizeof
(paren
id|cylinders
)paren
)paren
op_ne
l_int|0
op_logical_or
id|copy_to_user
c_func
(paren
(paren
r_int
op_star
)paren
op_amp
id|hd-&gt;start
comma
op_amp
id|start
comma
r_sizeof
(paren
id|start
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- lvm_blk_ioctl -- cylinders: %d&bslash;n&quot;
comma
id|lvm_name
comma
id|lv_ptr-&gt;lv_size
op_div
id|heads
op_div
id|sectors
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|LV_SET_ACCESS
suffix:colon
multiline_comment|/* set access flags of a logical volume */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|lv_ptr-&gt;lv_access
op_assign
(paren
id|ulong
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_access
op_amp
id|LV_WRITE
)paren
id|set_device_ro
c_func
(paren
id|lv_ptr-&gt;lv_dev
comma
l_int|0
)paren
suffix:semicolon
r_else
id|set_device_ro
c_func
(paren
id|lv_ptr-&gt;lv_dev
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LV_SET_STATUS
suffix:colon
multiline_comment|/* set status flags of a logical volume */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|ulong
)paren
id|arg
op_amp
id|LV_ACTIVE
)paren
op_logical_and
id|lv_ptr-&gt;lv_open
OG
l_int|1
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|lv_ptr-&gt;lv_status
op_assign
(paren
id|ulong
)paren
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LV_BMAP
suffix:colon
multiline_comment|/* turn logical block into (dev_t, block). non privileged. */
r_return
id|lvm_user_bmap
c_func
(paren
id|inode
comma
(paren
r_struct
id|lv_bmap
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LV_SET_ALLOCATION
suffix:colon
multiline_comment|/* set allocation flags of a logical volume */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|lv_ptr-&gt;lv_allocation
op_assign
(paren
id|ulong
)paren
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LV_SNAPSHOT_USE_RATE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|lv_ptr-&gt;lv_access
op_amp
id|LV_SNAPSHOT
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
(brace
id|lv_snapshot_use_rate_req_t
id|lv_snapshot_use_rate_req
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|lv_snapshot_use_rate_req
comma
id|arg
comma
r_sizeof
(paren
id|lv_snapshot_use_rate_req_t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|lv_snapshot_use_rate_req.rate
template_param
l_int|100
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|lv_snapshot_use_rate_req.block
)paren
(brace
r_case
l_int|0
suffix:colon
id|lv_ptr-&gt;lv_snapshot_use_rate
op_assign
id|lv_snapshot_use_rate_req.rate
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_remap_ptr
op_star
l_int|100
op_div
id|lv_ptr-&gt;lv_remap_end
OL
id|lv_ptr-&gt;lv_snapshot_use_rate
)paren
id|interruptible_sleep_on
(paren
op_amp
id|lv_ptr-&gt;lv_snapshot_wait
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|O_NONBLOCK
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|lv_snapshot_use_rate_req.rate
op_assign
id|lv_ptr-&gt;lv_remap_ptr
op_star
l_int|100
op_div
id|lv_ptr-&gt;lv_remap_end
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|lv_snapshot_use_rate_req
comma
r_sizeof
(paren
id|lv_snapshot_use_rate_req_t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s -- lvm_blk_ioctl: unknown command %d&bslash;n&quot;
comma
id|lvm_name
comma
id|command
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_blk_ioctl() */
multiline_comment|/*&n; * block device close routine&n; */
DECL|function|lvm_blk_close
r_static
r_int
id|lvm_blk_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
op_assign
id|vg
(braket
id|VG_BLK
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|LV_BLK
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- lvm_blk_close MINOR: %d  VG#: %d  LV#: %d&bslash;n&quot;
comma
id|lvm_name
comma
id|minor
comma
id|VG_BLK
c_func
(paren
id|minor
)paren
comma
id|LV_BLK
c_func
(paren
id|minor
)paren
)paren
suffix:semicolon
macro_line|#endif
id|sync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_open
op_eq
l_int|1
)paren
id|vg_ptr-&gt;lv_open
op_decrement
suffix:semicolon
id|lv_ptr-&gt;lv_open
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_blk_close() */
DECL|function|lvm_user_bmap
r_static
r_int
id|lvm_user_bmap
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|lv_bmap
op_star
id|user_result
)paren
(brace
r_struct
id|buffer_head
id|bh
suffix:semicolon
r_int
r_int
id|block
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|block
comma
op_amp
id|user_result-&gt;lv_block
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|bh
comma
l_int|0
comma
r_sizeof
id|bh
)paren
suffix:semicolon
id|bh.b_rsector
op_assign
id|block
suffix:semicolon
id|bh.b_dev
op_assign
id|bh.b_rdev
op_assign
id|inode-&gt;i_dev
suffix:semicolon
id|bh.b_size
op_assign
id|lvm_get_blksize
c_func
(paren
id|bh.b_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|lvm_map
c_func
(paren
op_amp
id|bh
comma
id|READ
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;lvm map failed: %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
id|kdev_t_to_nr
c_func
(paren
id|bh.b_rdev
)paren
comma
op_amp
id|user_result-&gt;lv_dev
)paren
op_logical_or
id|put_user
c_func
(paren
id|bh.b_rsector
comma
op_amp
id|user_result-&gt;lv_block
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * provide VG info for proc filesystem use (global)&n; */
DECL|function|lvm_vg_info
r_int
id|lvm_vg_info
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_char
op_star
id|buf
)paren
(brace
r_int
id|sz
op_assign
l_int|0
suffix:semicolon
r_char
id|inactive_flag
op_assign
l_char|&squot; &squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|vg_ptr-&gt;vg_status
op_amp
id|VG_ACTIVE
)paren
)paren
id|inactive_flag
op_assign
l_char|&squot;I&squot;
suffix:semicolon
id|sz
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;&bslash;nVG: %c%s  [%d PV, %d LV/%d open] &quot;
l_string|&quot; PE Size: %d KB&bslash;n&quot;
l_string|&quot;  Usage [KB/PE]: %d /%d total  &quot;
l_string|&quot;%d /%d used  %d /%d free&quot;
comma
id|inactive_flag
comma
id|vg_ptr-&gt;vg_name
comma
id|vg_ptr-&gt;pv_cur
comma
id|vg_ptr-&gt;lv_cur
comma
id|vg_ptr-&gt;lv_open
comma
id|vg_ptr-&gt;pe_size
op_rshift
l_int|1
comma
id|vg_ptr-&gt;pe_size
op_star
id|vg_ptr-&gt;pe_total
op_rshift
l_int|1
comma
id|vg_ptr-&gt;pe_total
comma
id|vg_ptr-&gt;pe_allocated
op_star
id|vg_ptr-&gt;pe_size
op_rshift
l_int|1
comma
id|vg_ptr-&gt;pe_allocated
comma
(paren
id|vg_ptr-&gt;pe_total
op_minus
id|vg_ptr-&gt;pe_allocated
)paren
op_star
id|vg_ptr-&gt;pe_size
op_rshift
l_int|1
comma
id|vg_ptr-&gt;pe_total
op_minus
id|vg_ptr-&gt;pe_allocated
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
multiline_comment|/*&n; * provide LV info for proc filesystem use (global)&n; */
DECL|function|lvm_lv_info
r_int
id|lvm_lv_info
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
id|lv_t
op_star
id|lv_ptr
comma
r_char
op_star
id|buf
)paren
(brace
r_int
id|sz
op_assign
l_int|0
suffix:semicolon
r_char
id|inactive_flag
op_assign
l_char|&squot;A&squot;
comma
id|allocation_flag
op_assign
l_char|&squot; &squot;
comma
id|stripes_flag
op_assign
l_char|&squot; &squot;
comma
id|rw_flag
op_assign
l_char|&squot; &squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|lv_ptr-&gt;lv_status
op_amp
id|LV_ACTIVE
)paren
)paren
id|inactive_flag
op_assign
l_char|&squot;I&squot;
suffix:semicolon
id|rw_flag
op_assign
l_char|&squot;R&squot;
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_access
op_amp
id|LV_WRITE
)paren
id|rw_flag
op_assign
l_char|&squot;W&squot;
suffix:semicolon
id|allocation_flag
op_assign
l_char|&squot;D&squot;
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_allocation
op_amp
id|LV_CONTIGUOUS
)paren
id|allocation_flag
op_assign
l_char|&squot;C&squot;
suffix:semicolon
id|stripes_flag
op_assign
l_char|&squot;L&squot;
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_stripes
OG
l_int|1
)paren
id|stripes_flag
op_assign
l_char|&squot;S&squot;
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|sz
comma
l_string|&quot;[%c%c%c%c&quot;
comma
id|inactive_flag
comma
id|rw_flag
comma
id|allocation_flag
comma
id|stripes_flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_stripes
OG
l_int|1
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|sz
comma
l_string|&quot;%-2d&quot;
comma
id|lv_ptr-&gt;lv_stripes
)paren
suffix:semicolon
r_else
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|sz
comma
l_string|&quot;  &quot;
)paren
suffix:semicolon
id|basename
op_assign
id|strrchr
c_func
(paren
id|lv_ptr-&gt;lv_name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|basename
op_eq
l_int|0
)paren
id|basename
op_assign
id|lv_ptr-&gt;lv_name
suffix:semicolon
r_else
id|basename
op_increment
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|sz
comma
l_string|&quot;] %-25s&quot;
comma
id|basename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|basename
)paren
OG
l_int|25
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|sz
comma
l_string|&quot;&bslash;n                              &quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|sz
comma
l_string|&quot;%9d /%-6d   &quot;
comma
id|lv_ptr-&gt;lv_size
op_rshift
l_int|1
comma
id|lv_ptr-&gt;lv_size
op_div
id|vg_ptr-&gt;pe_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_open
op_eq
l_int|0
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|sz
comma
l_string|&quot;close&quot;
)paren
suffix:semicolon
r_else
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|sz
comma
l_string|&quot;%dx open&quot;
comma
id|lv_ptr-&gt;lv_open
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
multiline_comment|/*&n; * provide PV info for proc filesystem use (global)&n; */
DECL|function|lvm_pv_info
r_int
id|lvm_pv_info
c_func
(paren
id|pv_t
op_star
id|pv_ptr
comma
r_char
op_star
id|buf
)paren
(brace
r_int
id|sz
op_assign
l_int|0
suffix:semicolon
r_char
id|inactive_flag
op_assign
l_char|&squot;A&squot;
comma
id|allocation_flag
op_assign
l_char|&squot; &squot;
suffix:semicolon
r_char
op_star
id|pv_name
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pv_ptr-&gt;pv_status
op_amp
id|PV_ACTIVE
)paren
)paren
id|inactive_flag
op_assign
l_char|&squot;I&squot;
suffix:semicolon
id|allocation_flag
op_assign
l_char|&squot;A&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pv_ptr-&gt;pv_allocatable
op_amp
id|PV_ALLOCATABLE
)paren
)paren
id|allocation_flag
op_assign
l_char|&squot;N&squot;
suffix:semicolon
id|pv_name
op_assign
id|strrchr
c_func
(paren
id|pv_ptr-&gt;pv_name
op_plus
l_int|1
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pv_name
op_eq
l_int|0
)paren
id|pv_name
op_assign
id|pv_ptr-&gt;pv_name
suffix:semicolon
r_else
id|pv_name
op_increment
suffix:semicolon
id|sz
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;[%c%c] %-21s %8d /%-6d  &quot;
l_string|&quot;%8d /%-6d  %8d /%-6d&quot;
comma
id|inactive_flag
comma
id|allocation_flag
comma
id|pv_name
comma
id|pv_ptr-&gt;pe_total
op_star
id|pv_ptr-&gt;pe_size
op_rshift
l_int|1
comma
id|pv_ptr-&gt;pe_total
comma
id|pv_ptr-&gt;pe_allocated
op_star
id|pv_ptr-&gt;pe_size
op_rshift
l_int|1
comma
id|pv_ptr-&gt;pe_allocated
comma
(paren
id|pv_ptr-&gt;pe_total
op_minus
id|pv_ptr-&gt;pe_allocated
)paren
op_star
id|pv_ptr-&gt;pe_size
op_rshift
l_int|1
comma
id|pv_ptr-&gt;pe_total
op_minus
id|pv_ptr-&gt;pe_allocated
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
macro_line|#if defined CONFIG_LVM_PROC_FS &amp;&amp; defined CONFIG_PROC_FS
multiline_comment|/*&n; * Support functions /proc-Filesystem&n; */
DECL|macro|LVM_PROC_BUF
mdefine_line|#define  LVM_PROC_BUF   ( i == 0 ? dummy_buf : &amp;buf[sz])
multiline_comment|/*&n; * provide global LVM information&n; */
DECL|function|lvm_proc_get_global_info
r_static
r_int
id|lvm_proc_get_global_info
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|pos
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|c
comma
id|i
comma
id|l
comma
id|p
comma
id|v
comma
id|vg_counter
comma
id|pv_counter
comma
id|lv_counter
comma
id|lv_open_counter
comma
id|lv_open_total
comma
id|pe_t_bytes
comma
id|hash_table_bytes
comma
id|lv_block_exception_t_bytes
comma
id|seconds
suffix:semicolon
r_static
id|off_t
id|sz
suffix:semicolon
id|off_t
id|sz_last
suffix:semicolon
r_static
r_char
op_star
id|buf
op_assign
l_int|NULL
suffix:semicolon
r_static
r_char
id|dummy_buf
(braket
l_int|160
)braket
suffix:semicolon
multiline_comment|/* sized for 2 lines */
id|vg_t
op_star
id|vg_ptr
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
id|pv_t
op_star
id|pv_ptr
suffix:semicolon
macro_line|#ifdef DEBUG_LVM_PROC_GET_INFO
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s - lvm_proc_get_global_info CALLED  pos: %lu  count: %d  whence: %d&bslash;n&quot;
comma
id|lvm_name
comma
id|pos
comma
id|count
comma
id|whence
)paren
suffix:semicolon
macro_line|#endif
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_eq
l_int|0
op_logical_or
id|buf
op_eq
l_int|NULL
)paren
(brace
id|sz_last
op_assign
id|vg_counter
op_assign
id|pv_counter
op_assign
id|lv_counter
op_assign
id|lv_open_counter
op_assign
"&bslash;"
id|lv_open_total
op_assign
id|pe_t_bytes
op_assign
id|hash_table_bytes
op_assign
"&bslash;"
id|lv_block_exception_t_bytes
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* search for activity */
r_for
c_loop
(paren
id|v
op_assign
l_int|0
suffix:semicolon
id|v
OL
id|ABS_MAX_VG
suffix:semicolon
id|v
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|vg_ptr
op_assign
id|vg
(braket
id|v
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|vg_counter
op_increment
suffix:semicolon
id|pv_counter
op_add_assign
id|vg_ptr-&gt;pv_cur
suffix:semicolon
id|lv_counter
op_add_assign
id|vg_ptr-&gt;lv_cur
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr-&gt;lv_cur
OG
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg
(braket
id|v
)braket
op_member_access_from_pointer
id|lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|pe_t_bytes
op_add_assign
id|lv_ptr-&gt;lv_allocated_le
suffix:semicolon
id|hash_table_bytes
op_add_assign
id|lv_ptr-&gt;lv_snapshot_hash_table_size
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_block_exception
op_ne
l_int|NULL
)paren
id|lv_block_exception_t_bytes
op_add_assign
id|lv_ptr-&gt;lv_remap_end
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_open
OG
l_int|0
)paren
(brace
id|lv_open_counter
op_increment
suffix:semicolon
id|lv_open_total
op_add_assign
id|lv_ptr-&gt;lv_open
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
)brace
id|pe_t_bytes
op_mul_assign
r_sizeof
(paren
id|pe_t
)paren
suffix:semicolon
id|lv_block_exception_t_bytes
op_mul_assign
r_sizeof
(paren
id|lv_block_exception_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_ne
l_int|NULL
)paren
(brace
macro_line|#ifdef DEBUG_KFREE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- vfree %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|buf
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|buf
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* 2 times: first to get size to allocate buffer,&n;&t;&t;   2nd to fill the malloced buffer */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sz
op_assign
l_int|0
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|LVM_PROC_BUF
comma
l_string|&quot;LVM &quot;
macro_line|#ifdef MODULE
l_string|&quot;module&quot;
macro_line|#else
l_string|&quot;driver&quot;
macro_line|#endif
l_string|&quot; %s&bslash;n&bslash;n&quot;
l_string|&quot;Total:  %d VG%s  %d PV%s  %d LV%s &quot;
comma
id|lvm_short_version
comma
id|vg_counter
comma
id|vg_counter
op_eq
l_int|1
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
comma
id|pv_counter
comma
id|pv_counter
op_eq
l_int|1
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
comma
id|lv_counter
comma
id|lv_counter
op_eq
l_int|1
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|LVM_PROC_BUF
comma
l_string|&quot;(%d LV%s open&quot;
comma
id|lv_open_counter
comma
id|lv_open_counter
op_eq
l_int|1
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lv_open_total
OG
l_int|0
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|LVM_PROC_BUF
comma
l_string|&quot; %d times)&bslash;n&quot;
comma
id|lv_open_total
)paren
suffix:semicolon
r_else
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|LVM_PROC_BUF
comma
l_string|&quot;)&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|LVM_PROC_BUF
comma
l_string|&quot;&bslash;nGlobal: %lu bytes malloced   IOP version: %d   &quot;
comma
id|vg_counter
op_star
r_sizeof
(paren
id|vg_t
)paren
op_plus
id|pv_counter
op_star
r_sizeof
(paren
id|pv_t
)paren
op_plus
id|lv_counter
op_star
r_sizeof
(paren
id|lv_t
)paren
op_plus
id|pe_t_bytes
op_plus
id|hash_table_bytes
op_plus
id|lv_block_exception_t_bytes
op_plus
id|sz_last
comma
id|lvm_iop_version
)paren
suffix:semicolon
id|seconds
op_assign
id|CURRENT_TIME
op_minus
id|loadtime
suffix:semicolon
r_if
c_cond
(paren
id|seconds
OL
l_int|0
)paren
id|loadtime
op_assign
id|CURRENT_TIME
op_plus
id|seconds
suffix:semicolon
r_if
c_cond
(paren
id|seconds
op_div
l_int|86400
OG
l_int|0
)paren
(brace
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|LVM_PROC_BUF
comma
l_string|&quot;%d day%s &quot;
comma
id|seconds
op_div
l_int|86400
comma
id|seconds
op_div
l_int|86400
op_eq
l_int|0
op_logical_or
id|seconds
op_div
l_int|86400
OG
l_int|1
ques
c_cond
l_string|&quot;s&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|LVM_PROC_BUF
comma
l_string|&quot;%d:%02d:%02d active&bslash;n&quot;
comma
(paren
id|seconds
op_mod
l_int|86400
)paren
op_div
l_int|3600
comma
(paren
id|seconds
op_mod
l_int|3600
)paren
op_div
l_int|60
comma
id|seconds
op_mod
l_int|60
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vg_counter
OG
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|v
op_assign
l_int|0
suffix:semicolon
id|v
OL
id|ABS_MAX_VG
suffix:semicolon
id|v
op_increment
)paren
(brace
multiline_comment|/* volume group */
r_if
c_cond
(paren
(paren
id|vg_ptr
op_assign
id|vg
(braket
id|v
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|sz
op_add_assign
id|lvm_vg_info
c_func
(paren
id|vg_ptr
comma
id|LVM_PROC_BUF
)paren
suffix:semicolon
multiline_comment|/* physical volumes */
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|LVM_PROC_BUF
comma
l_string|&quot;&bslash;n  PV%s &quot;
comma
id|vg_ptr-&gt;pv_cur
op_eq
l_int|1
ques
c_cond
l_string|&quot;: &quot;
suffix:colon
l_string|&quot;s:&quot;
)paren
suffix:semicolon
id|c
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|sz
op_add_assign
id|lvm_pv_info
c_func
(paren
id|pv_ptr
comma
id|LVM_PROC_BUF
)paren
suffix:semicolon
id|c
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
OL
id|vg_ptr-&gt;pv_cur
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|LVM_PROC_BUF
comma
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* logical volumes */
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|LVM_PROC_BUF
comma
l_string|&quot;&bslash;n    LV%s &quot;
comma
id|vg_ptr-&gt;lv_cur
op_eq
l_int|1
ques
c_cond
l_string|&quot;: &quot;
suffix:colon
l_string|&quot;s:&quot;
)paren
suffix:semicolon
id|c
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|sz
op_add_assign
id|lvm_lv_info
c_func
(paren
id|vg_ptr
comma
id|lv_ptr
comma
id|LVM_PROC_BUF
)paren
suffix:semicolon
id|c
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
OL
id|vg_ptr-&gt;lv_cur
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|LVM_PROC_BUF
comma
l_string|&quot;&bslash;n         &quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|vg_ptr-&gt;lv_cur
op_eq
l_int|0
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|LVM_PROC_BUF
comma
l_string|&quot;none&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|LVM_PROC_BUF
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|buf
op_assign
id|vmalloc
c_func
(paren
id|sz
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
)paren
(brace
id|sz
op_assign
l_int|0
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%s - vmalloc error at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
)brace
)brace
id|sz_last
op_assign
id|sz
suffix:semicolon
)brace
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|pos
OG
id|sz
op_minus
l_int|1
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|buf
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|buf
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|start
op_assign
op_amp
id|buf
(braket
id|pos
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sz
op_minus
id|pos
OL
id|count
)paren
r_return
id|sz
op_minus
id|pos
suffix:semicolon
r_else
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* lvm_proc_get_global_info() */
macro_line|#endif /* #if defined CONFIG_LVM_PROC_FS &amp;&amp; defined CONFIG_PROC_FS */
multiline_comment|/*&n; * provide VG information&n; */
DECL|function|lvm_proc_read_vg_info
r_int
id|lvm_proc_read_vg_info
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|sz
op_assign
l_int|0
suffix:semicolon
id|vg_t
op_star
id|vg
op_assign
id|data
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;name:         %s&bslash;n&quot;
comma
id|vg-&gt;vg_name
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;size:         %u&bslash;n&quot;
comma
id|vg-&gt;pe_total
op_star
id|vg-&gt;pe_size
op_div
l_int|2
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;access:       %u&bslash;n&quot;
comma
id|vg-&gt;vg_access
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;status:       %u&bslash;n&quot;
comma
id|vg-&gt;vg_status
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;number:       %u&bslash;n&quot;
comma
id|vg-&gt;vg_number
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;LV max:       %u&bslash;n&quot;
comma
id|vg-&gt;lv_max
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;LV current:   %u&bslash;n&quot;
comma
id|vg-&gt;lv_cur
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;LV open:      %u&bslash;n&quot;
comma
id|vg-&gt;lv_open
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;PV max:       %u&bslash;n&quot;
comma
id|vg-&gt;pv_max
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;PV current:   %u&bslash;n&quot;
comma
id|vg-&gt;pv_cur
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;PV active:    %u&bslash;n&quot;
comma
id|vg-&gt;pv_act
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;PE size:      %u&bslash;n&quot;
comma
id|vg-&gt;pe_size
op_div
l_int|2
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;PE total:     %u&bslash;n&quot;
comma
id|vg-&gt;pe_total
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;PE allocated: %u&bslash;n&quot;
comma
id|vg-&gt;pe_allocated
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;uuid:         %s&bslash;n&quot;
comma
id|vg-&gt;vg_uuid
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
multiline_comment|/*&n; * provide LV information&n; */
DECL|function|lvm_proc_read_lv_info
r_int
id|lvm_proc_read_lv_info
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|sz
op_assign
l_int|0
suffix:semicolon
id|lv_t
op_star
id|lv
op_assign
id|data
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;name:         %s&bslash;n&quot;
comma
id|lv-&gt;lv_name
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;size:         %u&bslash;n&quot;
comma
id|lv-&gt;lv_size
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;access:       %u&bslash;n&quot;
comma
id|lv-&gt;lv_access
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;status:       %u&bslash;n&quot;
comma
id|lv-&gt;lv_status
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;number:       %u&bslash;n&quot;
comma
id|lv-&gt;lv_number
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;open:         %u&bslash;n&quot;
comma
id|lv-&gt;lv_open
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;allocation:   %u&bslash;n&quot;
comma
id|lv-&gt;lv_allocation
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;device:       %02u:%02u&bslash;n&quot;
comma
id|MAJOR
c_func
(paren
id|lv-&gt;lv_dev
)paren
comma
id|MINOR
c_func
(paren
id|lv-&gt;lv_dev
)paren
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
multiline_comment|/*&n; * provide PV information&n; */
DECL|function|lvm_proc_read_pv_info
r_int
id|lvm_proc_read_pv_info
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|sz
op_assign
l_int|0
suffix:semicolon
id|pv_t
op_star
id|pv
op_assign
id|data
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;name:         %s&bslash;n&quot;
comma
id|pv-&gt;pv_name
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;size:         %u&bslash;n&quot;
comma
id|pv-&gt;pv_size
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;status:       %u&bslash;n&quot;
comma
id|pv-&gt;pv_status
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;number:       %u&bslash;n&quot;
comma
id|pv-&gt;pv_number
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;allocatable:  %u&bslash;n&quot;
comma
id|pv-&gt;pv_allocatable
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;LV current:   %u&bslash;n&quot;
comma
id|pv-&gt;lv_cur
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;PE size:      %u&bslash;n&quot;
comma
id|pv-&gt;pe_size
op_div
l_int|2
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;PE total:     %u&bslash;n&quot;
comma
id|pv-&gt;pe_total
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;PE allocated: %u&bslash;n&quot;
comma
id|pv-&gt;pe_allocated
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;device:       %02u:%02u&bslash;n&quot;
comma
id|MAJOR
c_func
(paren
id|pv-&gt;pv_dev
)paren
comma
id|MINOR
c_func
(paren
id|pv-&gt;pv_dev
)paren
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;uuid:         %s&bslash;n&quot;
comma
id|pv-&gt;pv_uuid
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
multiline_comment|/*&n; * block device support function for /usr/src/linux/drivers/block/ll_rw_blk.c&n; * (see init_module/lvm_init)&n; */
DECL|function|lvm_map
r_static
r_int
id|lvm_map
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|rw
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|bh-&gt;b_dev
)paren
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|ulong
id|index
suffix:semicolon
id|ulong
id|pe_start
suffix:semicolon
id|ulong
id|size
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|ulong
id|rsector_tmp
op_assign
id|bh-&gt;b_blocknr
op_star
id|size
suffix:semicolon
id|ulong
id|rsector_sav
suffix:semicolon
id|kdev_t
id|rdev_tmp
op_assign
id|bh-&gt;b_dev
suffix:semicolon
id|kdev_t
id|rdev_sav
suffix:semicolon
id|vg_t
op_star
id|vg_this
op_assign
id|vg
(braket
id|VG_BLK
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
id|lv_t
op_star
id|lv
op_assign
id|vg_this-&gt;lv
(braket
id|LV_BLK
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|lv-&gt;lv_status
op_amp
id|LV_ACTIVE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;%s - lvm_map: ll_rw_blk for inactive LV %s&bslash;n&quot;
comma
id|lvm_name
comma
id|lv-&gt;lv_name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rw
op_eq
id|WRITE
op_logical_or
id|rw
op_eq
id|WRITEA
)paren
op_logical_and
op_logical_neg
(paren
id|lv-&gt;lv_access
op_amp
id|LV_WRITE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s - lvm_map: ll_rw_blk write for readonly LV %s&bslash;n&quot;
comma
id|lvm_name
comma
id|lv-&gt;lv_name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_MAP
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s - lvm_map minor:%d  *rdev: %02d:%02d  *rsector: %lu  &quot;
l_string|&quot;size:%lu&bslash;n&quot;
comma
id|lvm_name
comma
id|minor
comma
id|MAJOR
c_func
(paren
id|rdev_tmp
)paren
comma
id|MINOR
c_func
(paren
id|rdev_tmp
)paren
comma
id|rsector_tmp
comma
id|size
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|rsector_tmp
op_plus
id|size
OG
id|lv-&gt;lv_size
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;%s - lvm_map access beyond end of device; *rsector: &quot;
l_string|&quot;%lu or size: %lu wrong for minor: %2d&bslash;n&quot;
comma
id|lvm_name
comma
id|rsector_tmp
comma
id|size
comma
id|minor
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|rsector_sav
op_assign
id|rsector_tmp
suffix:semicolon
id|rdev_sav
op_assign
id|rdev_tmp
suffix:semicolon
id|lvm_second_remap
suffix:colon
multiline_comment|/* linear mapping */
r_if
c_cond
(paren
id|lv-&gt;lv_stripes
OL
l_int|2
)paren
(brace
multiline_comment|/* get the index */
id|index
op_assign
id|rsector_tmp
op_div
id|vg_this-&gt;pe_size
suffix:semicolon
id|pe_start
op_assign
id|lv-&gt;lv_current_pe
(braket
id|index
)braket
dot
id|pe
suffix:semicolon
id|rsector_tmp
op_assign
id|lv-&gt;lv_current_pe
(braket
id|index
)braket
dot
id|pe
op_plus
(paren
id|rsector_tmp
op_mod
id|vg_this-&gt;pe_size
)paren
suffix:semicolon
id|rdev_tmp
op_assign
id|lv-&gt;lv_current_pe
(braket
id|index
)braket
dot
id|dev
suffix:semicolon
macro_line|#ifdef DEBUG_MAP
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;lv_current_pe[%ld].pe: %ld  rdev: %02d:%02d  rsector:%ld&bslash;n&quot;
comma
id|index
comma
id|lv-&gt;lv_current_pe
(braket
id|index
)braket
dot
id|pe
comma
id|MAJOR
c_func
(paren
id|rdev_tmp
)paren
comma
id|MINOR
c_func
(paren
id|rdev_tmp
)paren
comma
id|rsector_tmp
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* striped mapping */
)brace
r_else
(brace
id|ulong
id|stripe_index
suffix:semicolon
id|ulong
id|stripe_length
suffix:semicolon
id|stripe_length
op_assign
id|vg_this-&gt;pe_size
op_star
id|lv-&gt;lv_stripes
suffix:semicolon
id|stripe_index
op_assign
(paren
id|rsector_tmp
op_mod
id|stripe_length
)paren
op_div
id|lv-&gt;lv_stripesize
suffix:semicolon
id|index
op_assign
id|rsector_tmp
op_div
id|stripe_length
op_plus
(paren
id|stripe_index
op_mod
id|lv-&gt;lv_stripes
)paren
op_star
(paren
id|lv-&gt;lv_allocated_le
op_div
id|lv-&gt;lv_stripes
)paren
suffix:semicolon
id|pe_start
op_assign
id|lv-&gt;lv_current_pe
(braket
id|index
)braket
dot
id|pe
suffix:semicolon
id|rsector_tmp
op_assign
id|lv-&gt;lv_current_pe
(braket
id|index
)braket
dot
id|pe
op_plus
(paren
id|rsector_tmp
op_mod
id|stripe_length
)paren
op_minus
(paren
id|stripe_index
op_mod
id|lv-&gt;lv_stripes
)paren
op_star
id|lv-&gt;lv_stripesize
op_minus
id|stripe_index
op_div
id|lv-&gt;lv_stripes
op_star
(paren
id|lv-&gt;lv_stripes
op_minus
l_int|1
)paren
op_star
id|lv-&gt;lv_stripesize
suffix:semicolon
id|rdev_tmp
op_assign
id|lv-&gt;lv_current_pe
(braket
id|index
)braket
dot
id|dev
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_MAP
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;lv_current_pe[%ld].pe: %ld  rdev: %02d:%02d  rsector:%ld&bslash;n&quot;
l_string|&quot;stripe_length: %ld  stripe_index: %ld&bslash;n&quot;
comma
id|index
comma
id|lv-&gt;lv_current_pe
(braket
id|index
)braket
dot
id|pe
comma
id|MAJOR
c_func
(paren
id|rdev_tmp
)paren
comma
id|MINOR
c_func
(paren
id|rdev_tmp
)paren
comma
id|rsector_tmp
comma
id|stripe_length
comma
id|stripe_index
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* handle physical extents on the move */
r_if
c_cond
(paren
id|pe_lock_req.lock
op_eq
id|LOCK_PE
)paren
(brace
r_if
c_cond
(paren
id|rdev_tmp
op_eq
id|pe_lock_req.data.pv_dev
op_logical_and
id|rsector_tmp
op_ge
id|pe_lock_req.data.pv_offset
op_logical_and
id|rsector_tmp
OL
(paren
id|pe_lock_req.data.pv_offset
op_plus
id|vg_this-&gt;pe_size
)paren
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|lvm_map_wait
)paren
suffix:semicolon
id|rsector_tmp
op_assign
id|rsector_sav
suffix:semicolon
id|rdev_tmp
op_assign
id|rdev_sav
suffix:semicolon
r_goto
id|lvm_second_remap
suffix:semicolon
)brace
)brace
multiline_comment|/* statistic */
r_if
c_cond
(paren
id|rw
op_eq
id|WRITE
op_logical_or
id|rw
op_eq
id|WRITEA
)paren
id|lv-&gt;lv_current_pe
(braket
id|index
)braket
dot
id|writes
op_increment
suffix:semicolon
r_else
id|lv-&gt;lv_current_pe
(braket
id|index
)braket
dot
id|reads
op_increment
suffix:semicolon
multiline_comment|/* snapshot volume exception handling on physical device address base */
r_if
c_cond
(paren
id|lv-&gt;lv_access
op_amp
(paren
id|LV_SNAPSHOT
op_or
id|LV_SNAPSHOT_ORG
)paren
)paren
(brace
multiline_comment|/* original logical volume */
r_if
c_cond
(paren
id|lv-&gt;lv_access
op_amp
id|LV_SNAPSHOT_ORG
)paren
(brace
r_if
c_cond
(paren
id|rw
op_eq
id|WRITE
op_logical_or
id|rw
op_eq
id|WRITEA
)paren
(brace
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
multiline_comment|/* start with first snapshot and loop thrugh all of them */
r_for
c_loop
(paren
id|lv_ptr
op_assign
id|lv-&gt;lv_snapshot_next
suffix:semicolon
id|lv_ptr
op_ne
l_int|NULL
suffix:semicolon
id|lv_ptr
op_assign
id|lv_ptr-&gt;lv_snapshot_next
)paren
(brace
multiline_comment|/* Check for inactive snapshot */
r_if
c_cond
(paren
op_logical_neg
(paren
id|lv_ptr-&gt;lv_status
op_amp
id|LV_ACTIVE
)paren
)paren
r_continue
suffix:semicolon
id|down
c_func
(paren
op_amp
id|lv-&gt;lv_snapshot_org-&gt;lv_snapshot_sem
)paren
suffix:semicolon
multiline_comment|/* do we still have exception storage for this snapshot free? */
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_block_exception
op_ne
l_int|NULL
)paren
(brace
id|rdev_sav
op_assign
id|rdev_tmp
suffix:semicolon
id|rsector_sav
op_assign
id|rsector_tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lvm_snapshot_remap_block
c_func
(paren
op_amp
id|rdev_tmp
comma
op_amp
id|rsector_tmp
comma
id|pe_start
comma
id|lv_ptr
)paren
)paren
(brace
multiline_comment|/* create a new mapping */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ret
op_assign
id|lvm_snapshot_COW
c_func
(paren
id|rdev_tmp
comma
id|rsector_tmp
comma
id|pe_start
comma
id|rsector_sav
comma
id|lv_ptr
)paren
)paren
)paren
id|ret
op_assign
id|lvm_write_COW_table_block
c_func
(paren
id|vg_this
comma
id|lv_ptr
)paren
suffix:semicolon
)brace
id|rdev_tmp
op_assign
id|rdev_sav
suffix:semicolon
id|rsector_tmp
op_assign
id|rsector_sav
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|lv-&gt;lv_snapshot_org-&gt;lv_snapshot_sem
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* remap snapshot logical volume */
id|down
c_func
(paren
op_amp
id|lv-&gt;lv_snapshot_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lv-&gt;lv_block_exception
op_ne
l_int|NULL
)paren
id|lvm_snapshot_remap_block
c_func
(paren
op_amp
id|rdev_tmp
comma
op_amp
id|rsector_tmp
comma
id|pe_start
comma
id|lv
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|lv-&gt;lv_snapshot_sem
)paren
suffix:semicolon
)brace
)brace
id|bh-&gt;b_rdev
op_assign
id|rdev_tmp
suffix:semicolon
id|bh-&gt;b_rsector
op_assign
id|rsector_tmp
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* lvm_map() */
multiline_comment|/*&n; * internal support functions&n; */
macro_line|#ifdef LVM_HD_NAME
multiline_comment|/*&n; * generate &quot;hard disk&quot; name&n; */
DECL|function|lvm_hd_name
r_void
id|lvm_hd_name
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|minor
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|vg
(braket
id|VG_BLK
c_func
(paren
id|minor
)paren
)braket
op_eq
l_int|NULL
op_logical_or
(paren
id|lv_ptr
op_assign
id|vg
(braket
id|VG_BLK
c_func
(paren
id|minor
)paren
)braket
op_member_access_from_pointer
id|lv
(braket
id|LV_BLK
c_func
(paren
id|minor
)paren
)braket
)paren
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|lv_ptr-&gt;lv_name
)paren
op_minus
l_int|5
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
op_amp
id|lv_ptr-&gt;lv_name
(braket
l_int|5
)braket
comma
id|len
)paren
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * this one never should be called...&n; */
DECL|function|lvm_dummy_device_request
r_static
r_void
id|lvm_dummy_device_request
c_func
(paren
id|request_queue_t
op_star
id|t
)paren
(brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;%s -- oops, got lvm request for %02d:%02d [sector: %lu]&bslash;n&quot;
comma
id|lvm_name
comma
id|MAJOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
comma
id|MINOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
comma
id|CURRENT-&gt;sector
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * make request function&n; */
DECL|function|lvm_make_request_fn
r_static
r_int
id|lvm_make_request_fn
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_int
id|rw
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|lvm_map
c_func
(paren
id|bh
comma
id|rw
)paren
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* failure, buffer_IO_error has been called, don&squot;t recurse */
r_else
r_return
l_int|1
suffix:semicolon
multiline_comment|/* all ok, mapping done, call lower level driver */
)brace
multiline_comment|/********************************************************************&n; *&n; * Character device support functions&n; *&n; ********************************************************************/
multiline_comment|/*&n; * character device support function logical volume manager lock&n; */
DECL|function|lvm_do_lock_lvm
r_static
r_int
id|lvm_do_lock_lvm
c_func
(paren
r_void
)paren
(brace
id|lock_try_again
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|lvm_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock
op_ne
l_int|0
op_logical_and
id|lock
op_ne
id|current-&gt;pid
)paren
(brace
macro_line|#ifdef DEBUG_IOCTL
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lvm_do_lock_lvm: %s is locked by pid %d ...&bslash;n&quot;
comma
id|lvm_name
comma
id|lock
)paren
suffix:semicolon
macro_line|#endif
id|spin_unlock
c_func
(paren
op_amp
id|lvm_lock
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|lvm_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;sigpending
op_ne
l_int|0
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
macro_line|#ifdef LVM_TOTAL_RESET
r_if
c_cond
(paren
id|lvm_reset_spindown
OG
l_int|0
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
macro_line|#endif
r_goto
id|lock_try_again
suffix:semicolon
)brace
id|lock
op_assign
id|current-&gt;pid
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lvm_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_lock_lvm */
multiline_comment|/*&n; * character device support function lock/unlock physical extend&n; */
DECL|function|lvm_do_pe_lock_unlock
r_static
r_int
id|lvm_do_pe_lock_unlock
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
id|uint
id|p
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|pe_lock_req
comma
id|arg
comma
r_sizeof
(paren
id|pe_lock_req_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|pe_lock_req.lock
)paren
(brace
r_case
id|LOCK_PE
suffix:colon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_ne
l_int|NULL
op_logical_and
id|pe_lock_req.data.pv_dev
op_eq
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pv_dev
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
op_eq
id|vg_ptr-&gt;pv_max
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|pe_lock_req.lock
op_assign
id|UNLOCK_PE
suffix:semicolon
id|fsync_dev
c_func
(paren
id|pe_lock_req.data.lv_dev
)paren
suffix:semicolon
id|pe_lock_req.lock
op_assign
id|LOCK_PE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNLOCK_PE
suffix:colon
id|pe_lock_req.lock
op_assign
id|UNLOCK_PE
suffix:semicolon
id|pe_lock_req.data.lv_dev
op_assign
"&bslash;"
id|pe_lock_req.data.pv_dev
op_assign
"&bslash;"
id|pe_lock_req.data.pv_offset
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lvm_map_wait
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * character device support function logical extend remap&n; */
DECL|function|lvm_do_le_remap
r_static
r_int
id|lvm_do_le_remap
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
id|uint
id|l
comma
id|le
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|le_remap_req
comma
id|arg
comma
r_sizeof
(paren
id|le_remap_req_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|lv_ptr-&gt;lv_name
comma
id|le_remap_req.lv_name
)paren
op_eq
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|le
op_assign
l_int|0
suffix:semicolon
id|le
OL
id|lv_ptr-&gt;lv_allocated_le
suffix:semicolon
id|le
op_increment
)paren
(brace
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_current_pe
(braket
id|le
)braket
dot
id|dev
op_eq
id|le_remap_req.old_dev
op_logical_and
id|lv_ptr-&gt;lv_current_pe
(braket
id|le
)braket
dot
id|pe
op_eq
id|le_remap_req.old_pe
)paren
(brace
id|lv_ptr-&gt;lv_current_pe
(braket
id|le
)braket
dot
id|dev
op_assign
id|le_remap_req.new_dev
suffix:semicolon
id|lv_ptr-&gt;lv_current_pe
(braket
id|le
)braket
dot
id|pe
op_assign
id|le_remap_req.new_pe
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* lvm_do_le_remap() */
multiline_comment|/*&n; * character device support function VGDA create&n; */
DECL|function|lvm_do_vg_create
r_int
id|lvm_do_vg_create
c_func
(paren
r_int
id|minor
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|ulong
id|l
comma
id|ls
op_assign
l_int|0
comma
id|p
comma
id|size
suffix:semicolon
id|lv_t
id|lv
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
suffix:semicolon
id|lv_t
op_star
op_star
id|snap_lv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
op_ne
l_int|NULL
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vg_ptr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|vg_t
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- VG_CREATE: kmalloc error VG at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* get the volume group structure */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|vg_ptr
comma
id|arg
comma
r_sizeof
(paren
id|vg_t
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|vg_ptr
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* we are not that active so far... */
id|vg_ptr-&gt;vg_status
op_and_assign
op_complement
id|VG_ACTIVE
suffix:semicolon
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
op_assign
id|vg_ptr
suffix:semicolon
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
op_member_access_from_pointer
id|pe_allocated
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr-&gt;pv_max
OG
id|ABS_MAX_PV
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s -- Can&squot;t activate VG: ABS_MAX_PV too small&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vg_ptr
)paren
suffix:semicolon
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vg_ptr-&gt;lv_max
OG
id|ABS_MAX_LV
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s -- Can&squot;t activate VG: ABS_MAX_LV too small for %u&bslash;n&quot;
comma
id|lvm_name
comma
id|vg_ptr-&gt;lv_max
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vg_ptr
)paren
suffix:semicolon
id|vg_ptr
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/* get the physical volume structures */
id|vg_ptr-&gt;pv_act
op_assign
id|vg_ptr-&gt;pv_cur
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|p
op_increment
)paren
(brace
multiline_comment|/* user space address */
r_if
c_cond
(paren
(paren
id|pvp
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|ret
op_assign
id|lvm_do_pv_create
c_func
(paren
id|pvp
comma
id|vg_ptr
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|lvm_do_vg_remove
c_func
(paren
id|minor
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
)brace
id|size
op_assign
id|vg_ptr-&gt;lv_max
op_star
r_sizeof
(paren
id|lv_t
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|snap_lv_ptr
op_assign
id|vmalloc
(paren
id|size
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- VG_CREATE: vmalloc error snapshot LVs at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
id|lvm_do_vg_remove
c_func
(paren
id|minor
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|memset
c_func
(paren
id|snap_lv_ptr
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* get the logical volume structures */
id|vg_ptr-&gt;lv_cur
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
multiline_comment|/* user space address */
r_if
c_cond
(paren
(paren
id|lvp
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|lv
comma
id|lvp
comma
r_sizeof
(paren
id|lv_t
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|lvm_do_vg_remove
c_func
(paren
id|minor
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lv.lv_access
op_amp
id|LV_SNAPSHOT
)paren
(brace
id|snap_lv_ptr
(braket
id|ls
)braket
op_assign
id|lvp
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
id|ls
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* only create original logical volumes for now */
r_if
c_cond
(paren
id|lvm_do_lv_create
c_func
(paren
id|minor
comma
id|lv.lv_name
comma
op_amp
id|lv
)paren
op_ne
l_int|0
)paren
(brace
id|lvm_do_vg_remove
c_func
(paren
id|minor
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Second path to correct snapshot logical volumes which are not&n;&t;   in place during first path above */
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|ls
suffix:semicolon
id|l
op_increment
)paren
(brace
id|lvp
op_assign
id|snap_lv_ptr
(braket
id|l
)braket
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|lv
comma
id|lvp
comma
r_sizeof
(paren
id|lv_t
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|lvm_do_vg_remove
c_func
(paren
id|minor
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lvm_do_lv_create
c_func
(paren
id|minor
comma
id|lv.lv_name
comma
op_amp
id|lv
)paren
op_ne
l_int|0
)paren
(brace
id|lvm_do_vg_remove
c_func
(paren
id|minor
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
macro_line|#ifdef&t;CONFIG_DEVFS_FS
id|vg_devfs_handle
(braket
id|vg_ptr-&gt;vg_number
)braket
op_assign
id|devfs_mk_dir
c_func
(paren
l_int|0
comma
id|vg_ptr-&gt;vg_name
comma
l_int|NULL
)paren
suffix:semicolon
id|ch_devfs_handle
(braket
id|vg_ptr-&gt;vg_number
)braket
op_assign
id|devfs_register
c_func
(paren
id|vg_devfs_handle
(braket
id|vg_ptr-&gt;vg_number
)braket
comma
l_string|&quot;group&quot;
comma
id|DEVFS_FL_DEFAULT
comma
id|LVM_CHAR_MAJOR
comma
id|vg_ptr-&gt;vg_number
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
comma
op_amp
id|lvm_chr_fops
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined CONFIG_LVM_PROC_FS &amp;&amp; defined CONFIG_PROC_FS
id|lvm_do_create_proc_entry_of_vg
(paren
id|vg_ptr
)paren
suffix:semicolon
macro_line|#endif
id|vfree
c_func
(paren
id|snap_lv_ptr
)paren
suffix:semicolon
id|vg_count
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/* let&squot;s go active */
id|vg_ptr-&gt;vg_status
op_or_assign
id|VG_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_vg_create() */
multiline_comment|/*&n; * character device support function VGDA extend&n; */
DECL|function|lvm_do_vg_extend
r_static
r_int
id|lvm_do_vg_extend
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|uint
id|p
suffix:semicolon
id|pv_t
op_star
id|pv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr-&gt;pv_cur
OL
id|vg_ptr-&gt;pv_max
)paren
(brace
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
)paren
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
id|lvm_do_pv_create
c_func
(paren
id|arg
comma
id|vg_ptr
comma
id|p
)paren
suffix:semicolon
id|lvm_do_create_proc_entry_of_pv
(paren
id|vg_ptr
comma
id|pv_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* We don&squot;t need the PE list&n;&t;&t;&t;&t;   in kernel space like LVs pe_t list */
id|pv_ptr-&gt;pe
op_assign
l_int|NULL
suffix:semicolon
id|vg_ptr-&gt;pv_cur
op_increment
suffix:semicolon
id|vg_ptr-&gt;pv_act
op_increment
suffix:semicolon
id|vg_ptr-&gt;pe_total
op_add_assign
id|pv_ptr-&gt;pe_total
suffix:semicolon
macro_line|#ifdef LVM_GET_INODE
multiline_comment|/* insert a dummy inode for fs_may_mount */
id|pv_ptr-&gt;inode
op_assign
id|lvm_get_inode
c_func
(paren
id|pv_ptr-&gt;pv_dev
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/* lvm_do_vg_extend() */
multiline_comment|/*&n; * character device support function VGDA reduce&n; */
DECL|function|lvm_do_vg_reduce
r_static
r_int
id|lvm_do_vg_reduce
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
id|uint
id|p
suffix:semicolon
id|pv_t
op_star
id|pv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|pv_name
comma
id|arg
comma
r_sizeof
(paren
id|pv_name
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|p
op_increment
)paren
(brace
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pv_ptr
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|pv_ptr-&gt;pv_name
comma
id|pv_name
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|pv_ptr-&gt;lv_cur
OG
l_int|0
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|vg_ptr-&gt;pe_total
op_sub_assign
id|pv_ptr-&gt;pe_total
suffix:semicolon
id|vg_ptr-&gt;pv_cur
op_decrement
suffix:semicolon
id|vg_ptr-&gt;pv_act
op_decrement
suffix:semicolon
id|lvm_do_pv_remove
c_func
(paren
id|vg_ptr
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* Make PV pointer array contiguous */
r_for
c_loop
(paren
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
op_minus
l_int|1
suffix:semicolon
id|p
op_increment
)paren
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
op_plus
l_int|1
)braket
suffix:semicolon
id|vg_ptr-&gt;pv
(braket
id|p
op_plus
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* lvm_do_vg_reduce */
multiline_comment|/*&n; * character device support function VG rename&n; */
DECL|function|lvm_do_vg_rename
r_static
r_int
id|lvm_do_vg_rename
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|l
op_assign
l_int|0
comma
id|p
op_assign
l_int|0
comma
id|len
op_assign
l_int|0
suffix:semicolon
r_char
id|vg_name
(braket
id|NAME_LEN
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
r_char
id|lv_name
(braket
id|NAME_LEN
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
r_char
op_star
id|ptr
op_assign
l_int|NULL
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
op_assign
l_int|NULL
suffix:semicolon
id|pv_t
op_star
id|pv_ptr
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|vg_name
comma
id|arg
comma
r_sizeof
(paren
id|vg_name
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
macro_line|#if defined CONFIG_LVM_PROC_FS &amp;&amp; defined CONFIG_PROC_FS
id|lvm_do_remove_proc_entry_of_vg
(paren
id|vg_ptr
)paren
suffix:semicolon
macro_line|#endif
id|strncpy
(paren
id|vg_ptr-&gt;vg_name
comma
id|vg_name
comma
r_sizeof
(paren
id|vg_name
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
)paren
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|strncpy
c_func
(paren
id|lv_ptr-&gt;vg_name
comma
id|vg_name
comma
r_sizeof
(paren
id|vg_name
)paren
)paren
suffix:semicolon
id|ptr
op_assign
id|strrchr
c_func
(paren
id|lv_ptr-&gt;lv_name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_eq
l_int|NULL
)paren
id|ptr
op_assign
id|lv_ptr-&gt;lv_name
suffix:semicolon
id|strncpy
c_func
(paren
id|lv_name
comma
id|ptr
comma
r_sizeof
(paren
id|lv_name
)paren
)paren
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
id|LVM_DIR_PREFIX
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|lv_ptr-&gt;lv_name
comma
id|LVM_DIR_PREFIX
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|lv_ptr-&gt;lv_name
comma
id|vg_name
comma
id|NAME_LEN
op_minus
id|len
)paren
suffix:semicolon
id|len
op_add_assign
id|strlen
(paren
id|vg_name
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|lv_ptr-&gt;lv_name
comma
id|lv_name
comma
id|NAME_LEN
op_minus
id|len
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
)paren
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|strncpy
c_func
(paren
id|pv_ptr-&gt;vg_name
comma
id|vg_name
comma
id|NAME_LEN
)paren
suffix:semicolon
)brace
macro_line|#if defined CONFIG_LVM_PROC_FS &amp;&amp; defined CONFIG_PROC_FS
id|lvm_do_create_proc_entry_of_vg
(paren
id|vg_ptr
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_vg_rename */
multiline_comment|/*&n; * character device support function VGDA remove&n; */
DECL|function|lvm_do_vg_remove
r_static
r_int
id|lvm_do_vg_remove
c_func
(paren
r_int
id|minor
)paren
(brace
r_int
id|i
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
op_assign
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
id|pv_t
op_star
id|pv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
macro_line|#ifdef LVM_TOTAL_RESET
r_if
c_cond
(paren
id|vg_ptr-&gt;lv_open
OG
l_int|0
op_logical_and
id|lvm_reset_spindown
op_eq
l_int|0
)paren
macro_line|#else
r_if
c_cond
(paren
id|vg_ptr-&gt;lv_open
OG
l_int|0
)paren
macro_line|#endif
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* let&squot;s go inactive */
id|vg_ptr-&gt;vg_status
op_and_assign
op_complement
id|VG_ACTIVE
suffix:semicolon
multiline_comment|/* free LVs */
multiline_comment|/* first free snapshot logical volumes */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;lv
(braket
id|i
)braket
op_ne
l_int|NULL
op_logical_and
id|vg_ptr-&gt;lv
(braket
id|i
)braket
op_member_access_from_pointer
id|lv_access
op_amp
id|LV_SNAPSHOT
)paren
(brace
id|lvm_do_lv_remove
c_func
(paren
id|minor
comma
l_int|NULL
comma
id|i
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* then free the rest of the LVs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;lv
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|lvm_do_lv_remove
c_func
(paren
id|minor
comma
l_int|NULL
comma
id|i
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* free PVs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
macro_line|#ifdef DEBUG_KFREE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- kfree %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|lvm_do_pv_remove
c_func
(paren
id|vg_ptr
comma
id|i
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef&t;CONFIG_DEVFS_FS
id|devfs_unregister
(paren
id|ch_devfs_handle
(braket
id|vg_ptr-&gt;vg_number
)braket
)paren
suffix:semicolon
id|devfs_unregister
(paren
id|vg_devfs_handle
(braket
id|vg_ptr-&gt;vg_number
)braket
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined CONFIG_LVM_PROC_FS &amp;&amp; defined CONFIG_PROC_FS
id|lvm_do_remove_proc_entry_of_vg
(paren
id|vg_ptr
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_KFREE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- kfree %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|kfree
c_func
(paren
id|vg_ptr
)paren
suffix:semicolon
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
op_assign
l_int|NULL
suffix:semicolon
id|vg_count
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_vg_remove() */
multiline_comment|/*&n; * character device support function physical volume create&n; */
DECL|function|lvm_do_pv_create
r_static
r_int
id|lvm_do_pv_create
c_func
(paren
id|pv_t
op_star
id|pvp
comma
id|vg_t
op_star
id|vg_ptr
comma
id|ulong
id|p
)paren
(brace
id|pv_t
op_star
id|pv_ptr
op_assign
l_int|NULL
suffix:semicolon
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|pv_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pv_ptr
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- VG_CREATE: kmalloc error PV at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|pv_ptr
comma
id|pvp
comma
r_sizeof
(paren
id|pv_t
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* We don&squot;t need the PE list&n;&t;   in kernel space as with LVs pe_t list (see below) */
id|pv_ptr-&gt;pe
op_assign
l_int|NULL
suffix:semicolon
id|pv_ptr-&gt;pe_allocated
op_assign
l_int|0
suffix:semicolon
id|pv_ptr-&gt;pv_status
op_assign
id|PV_ACTIVE
suffix:semicolon
id|vg_ptr-&gt;pv_act
op_increment
suffix:semicolon
id|vg_ptr-&gt;pv_cur
op_increment
suffix:semicolon
macro_line|#ifdef LVM_GET_INODE
multiline_comment|/* insert a dummy inode for fs_may_mount */
id|pv_ptr-&gt;inode
op_assign
id|lvm_get_inode
c_func
(paren
id|pv_ptr-&gt;pv_dev
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_pv_create() */
multiline_comment|/*&n; * character device support function physical volume create&n; */
DECL|function|lvm_do_pv_remove
r_static
r_int
id|lvm_do_pv_remove
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
id|ulong
id|p
)paren
(brace
id|pv_t
op_star
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
suffix:semicolon
macro_line|#if defined CONFIG_LVM_PROC_FS &amp;&amp; defined CONFIG_PROC_FS
id|lvm_do_remove_proc_entry_of_pv
(paren
id|vg_ptr
comma
id|pv_ptr
)paren
suffix:semicolon
macro_line|#endif
id|vg_ptr-&gt;pe_total
op_sub_assign
id|pv_ptr-&gt;pe_total
suffix:semicolon
id|vg_ptr-&gt;pv_cur
op_decrement
suffix:semicolon
id|vg_ptr-&gt;pv_act
op_decrement
suffix:semicolon
macro_line|#ifdef LVM_GET_INODE
id|lvm_clear_inode
c_func
(paren
id|pv_ptr-&gt;inode
)paren
suffix:semicolon
macro_line|#endif
id|kfree
c_func
(paren
id|pv_ptr
)paren
suffix:semicolon
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * character device support function logical volume create&n; */
DECL|function|lvm_do_lv_create
r_static
r_int
id|lvm_do_lv_create
c_func
(paren
r_int
id|minor
comma
r_char
op_star
id|lv_name
comma
id|lv_t
op_star
id|lv
)paren
(brace
r_int
id|e
comma
id|ret
comma
id|l
comma
id|le
comma
id|l_new
comma
id|p
comma
id|size
suffix:semicolon
id|ulong
id|lv_status_save
suffix:semicolon
id|lv_block_exception_t
op_star
id|lvbe
op_assign
id|lv-&gt;lv_block_exception
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
op_assign
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pep
op_assign
id|lv-&gt;lv_current_pe
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|lv-&gt;lv_chunk_size
OG
id|LVM_SNAPSHOT_MAX_CHUNK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_member_access_from_pointer
id|lv_name
comma
id|lv_name
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
multiline_comment|/* in case of lv_remove(), lv_create() pair */
id|l_new
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr-&gt;lv
(braket
id|lv-&gt;lv_number
)braket
op_eq
l_int|NULL
)paren
id|l_new
op_assign
id|lv-&gt;lv_number
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_eq
l_int|NULL
)paren
r_if
c_cond
(paren
id|l_new
op_eq
op_minus
l_int|1
)paren
id|l_new
op_assign
id|l
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|l_new
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_else
id|l
op_assign
id|l_new
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lv_ptr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|lv_t
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- LV_CREATE: kmalloc error LV at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* copy preloaded LV */
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|lv_ptr
comma
(paren
r_char
op_star
)paren
id|lv
comma
r_sizeof
(paren
id|lv_t
)paren
)paren
suffix:semicolon
id|lv_status_save
op_assign
id|lv_ptr-&gt;lv_status
suffix:semicolon
id|lv_ptr-&gt;lv_status
op_and_assign
op_complement
id|LV_ACTIVE
suffix:semicolon
id|lv_ptr-&gt;lv_snapshot_org
op_assign
"&bslash;"
id|lv_ptr-&gt;lv_snapshot_prev
op_assign
"&bslash;"
id|lv_ptr-&gt;lv_snapshot_next
op_assign
l_int|NULL
suffix:semicolon
id|lv_ptr-&gt;lv_block_exception
op_assign
l_int|NULL
suffix:semicolon
id|lv_ptr-&gt;lv_iobuf
op_assign
l_int|NULL
suffix:semicolon
id|lv_ptr-&gt;lv_snapshot_hash_table
op_assign
l_int|NULL
suffix:semicolon
id|lv_ptr-&gt;lv_snapshot_hash_table_size
op_assign
l_int|0
suffix:semicolon
id|lv_ptr-&gt;lv_snapshot_hash_mask
op_assign
l_int|0
suffix:semicolon
id|lv_ptr-&gt;lv_COW_table_page
op_assign
l_int|NULL
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|lv_ptr-&gt;lv_snapshot_sem
)paren
suffix:semicolon
id|lv_ptr-&gt;lv_snapshot_use_rate
op_assign
l_int|0
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
id|lv_ptr
suffix:semicolon
multiline_comment|/* get the PE structures from user space if this&n;&t;   is no snapshot logical volume */
r_if
c_cond
(paren
op_logical_neg
(paren
id|lv_ptr-&gt;lv_access
op_amp
id|LV_SNAPSHOT
)paren
)paren
(brace
id|size
op_assign
id|lv_ptr-&gt;lv_allocated_le
op_star
r_sizeof
(paren
id|pe_t
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lv_ptr-&gt;lv_current_pe
op_assign
id|vmalloc
c_func
(paren
id|size
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- LV_CREATE: vmalloc error LV_CURRENT_PE of %d Byte &quot;
l_string|&quot;at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|size
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_KFREE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- kfree %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|kfree
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
op_member_access_from_pointer
id|lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|lv_ptr-&gt;lv_current_pe
comma
id|pep
comma
id|size
)paren
)paren
(brace
id|vfree
c_func
(paren
id|lv_ptr-&gt;lv_current_pe
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* correct the PE count in PVs */
r_for
c_loop
(paren
id|le
op_assign
l_int|0
suffix:semicolon
id|le
OL
id|lv_ptr-&gt;lv_allocated_le
suffix:semicolon
id|le
op_increment
)paren
(brace
id|vg_ptr-&gt;pe_allocated
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_cur
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pv_dev
op_eq
id|lv_ptr-&gt;lv_current_pe
(braket
id|le
)braket
dot
id|dev
)paren
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pe_allocated
op_increment
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Get snapshot exception data and block list */
r_if
c_cond
(paren
id|lvbe
op_ne
l_int|NULL
)paren
(brace
id|lv_ptr-&gt;lv_snapshot_org
op_assign
id|vg_ptr-&gt;lv
(braket
id|LV_BLK
c_func
(paren
id|lv_ptr-&gt;lv_snapshot_minor
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_snapshot_org
op_ne
l_int|NULL
)paren
(brace
id|size
op_assign
id|lv_ptr-&gt;lv_remap_end
op_star
r_sizeof
(paren
id|lv_block_exception_t
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lv_ptr-&gt;lv_block_exception
op_assign
id|vmalloc
c_func
(paren
id|size
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- lvm_do_lv_create: vmalloc error LV_BLOCK_EXCEPTION &quot;
l_string|&quot;of %d byte at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|size
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_KFREE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- kfree %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|kfree
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|lv_ptr-&gt;lv_block_exception
comma
id|lvbe
comma
id|size
)paren
)paren
(brace
id|vfree
c_func
(paren
id|lv_ptr-&gt;lv_block_exception
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
op_member_access_from_pointer
id|lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* point to the original logical volume */
id|lv_ptr
op_assign
id|lv_ptr-&gt;lv_snapshot_org
suffix:semicolon
id|lv_ptr-&gt;lv_snapshot_minor
op_assign
l_int|0
suffix:semicolon
id|lv_ptr-&gt;lv_snapshot_org
op_assign
id|lv_ptr
suffix:semicolon
id|lv_ptr-&gt;lv_snapshot_prev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* walk thrugh the snapshot list */
r_while
c_loop
(paren
id|lv_ptr-&gt;lv_snapshot_next
op_ne
l_int|NULL
)paren
id|lv_ptr
op_assign
id|lv_ptr-&gt;lv_snapshot_next
suffix:semicolon
multiline_comment|/* now lv_ptr points to the last existing snapshot in the chain */
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_member_access_from_pointer
id|lv_snapshot_prev
op_assign
id|lv_ptr
suffix:semicolon
multiline_comment|/* our new one now back points to the previous last in the chain&n;&t;&t;&t;&t;   which can be the original logical volume */
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
suffix:semicolon
multiline_comment|/* now lv_ptr points to our new last snapshot logical volume */
id|lv_ptr-&gt;lv_snapshot_org
op_assign
id|lv_ptr-&gt;lv_snapshot_prev-&gt;lv_snapshot_org
suffix:semicolon
id|lv_ptr-&gt;lv_snapshot_next
op_assign
l_int|NULL
suffix:semicolon
id|lv_ptr-&gt;lv_current_pe
op_assign
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_current_pe
suffix:semicolon
id|lv_ptr-&gt;lv_allocated_le
op_assign
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_allocated_le
suffix:semicolon
id|lv_ptr-&gt;lv_current_le
op_assign
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_current_le
suffix:semicolon
id|lv_ptr-&gt;lv_size
op_assign
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_size
suffix:semicolon
id|lv_ptr-&gt;lv_stripes
op_assign
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_stripes
suffix:semicolon
id|lv_ptr-&gt;lv_stripesize
op_assign
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_stripesize
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|lvm_snapshot_alloc
c_func
(paren
id|lv_ptr
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|vfree
c_func
(paren
id|lv_ptr-&gt;lv_block_exception
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
op_member_access_from_pointer
id|lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_for
c_loop
(paren
id|e
op_assign
l_int|0
suffix:semicolon
id|e
OL
id|lv_ptr-&gt;lv_remap_ptr
suffix:semicolon
id|e
op_increment
)paren
id|lvm_hash_link
(paren
id|lv_ptr-&gt;lv_block_exception
op_plus
id|e
comma
id|lv_ptr-&gt;lv_block_exception
(braket
id|e
)braket
dot
id|rdev_org
comma
id|lv_ptr-&gt;lv_block_exception
(braket
id|e
)braket
dot
id|rsector_org
comma
id|lv_ptr
)paren
suffix:semicolon
multiline_comment|/* need to fill the COW exception table data&n;&t;&t;&t;&t;   into the page for disk i/o */
id|lvm_snapshot_fill_COW_page
c_func
(paren
id|vg_ptr
comma
id|lv_ptr
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|lv_ptr-&gt;lv_snapshot_wait
)paren
suffix:semicolon
)brace
r_else
(brace
id|vfree
c_func
(paren
id|lv_ptr-&gt;lv_block_exception
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_else
(brace
id|kfree
c_func
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
)paren
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/* if ( vg[VG_CHR(minor)]-&gt;lv[l]-&gt;lv_access &amp; LV_SNAPSHOT) */
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
suffix:semicolon
id|lvm_gendisk.part
(braket
id|MINOR
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|lvm_gendisk.part
(braket
id|MINOR
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
)braket
dot
id|nr_sects
op_assign
id|lv_ptr-&gt;lv_size
suffix:semicolon
id|lvm_size
(braket
id|MINOR
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
)braket
op_assign
id|lv_ptr-&gt;lv_size
op_rshift
l_int|1
suffix:semicolon
id|vg_lv_map
(braket
id|MINOR
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
)braket
dot
id|vg_number
op_assign
id|vg_ptr-&gt;vg_number
suffix:semicolon
id|vg_lv_map
(braket
id|MINOR
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
)braket
dot
id|lv_number
op_assign
id|lv_ptr-&gt;lv_number
suffix:semicolon
id|LVM_CORRECT_READ_AHEAD
c_func
(paren
id|lv_ptr-&gt;lv_read_ahead
)paren
suffix:semicolon
id|vg_ptr-&gt;lv_cur
op_increment
suffix:semicolon
id|lv_ptr-&gt;lv_status
op_assign
id|lv_status_save
suffix:semicolon
macro_line|#ifdef&t;CONFIG_DEVFS_FS
(brace
r_char
op_star
id|lv_tmp
comma
op_star
id|lv_buf
op_assign
l_int|NULL
suffix:semicolon
id|strtok
c_func
(paren
id|lv-&gt;lv_name
comma
l_string|&quot;/&quot;
)paren
suffix:semicolon
multiline_comment|/* /dev */
r_while
c_loop
(paren
(paren
id|lv_tmp
op_assign
id|strtok
c_func
(paren
l_int|NULL
comma
l_string|&quot;/&quot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|lv_buf
op_assign
id|lv_tmp
suffix:semicolon
)brace
id|lv_devfs_handle
(braket
id|lv-&gt;lv_number
)braket
op_assign
id|devfs_register
c_func
(paren
id|vg_devfs_handle
(braket
id|vg_ptr-&gt;vg_number
)braket
comma
id|lv_buf
comma
id|DEVFS_FL_DEFAULT
comma
id|LVM_BLK_MAJOR
comma
id|lv-&gt;lv_number
comma
id|S_IFBLK
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
comma
op_amp
id|lvm_blk_dops
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if defined CONFIG_LVM_PROC_FS &amp;&amp; defined CONFIG_PROC_FS
id|lvm_do_create_proc_entry_of_lv
(paren
id|vg_ptr
comma
id|lv_ptr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* optionally add our new snapshot LV */
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_access
op_amp
id|LV_SNAPSHOT
)paren
(brace
multiline_comment|/* sync the original logical volume */
id|fsync_dev
c_func
(paren
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_dev
)paren
suffix:semicolon
macro_line|#ifdef&t;LVM_VFS_ENHANCEMENT
multiline_comment|/* VFS function call to sync and lock the filesystem */
id|fsync_dev_lockfs
c_func
(paren
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_dev
)paren
suffix:semicolon
macro_line|#endif
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_access
op_or_assign
id|LV_SNAPSHOT_ORG
suffix:semicolon
id|lv_ptr-&gt;lv_access
op_and_assign
op_complement
id|LV_SNAPSHOT_ORG
suffix:semicolon
multiline_comment|/* put ourselve into the chain */
id|lv_ptr-&gt;lv_snapshot_prev-&gt;lv_snapshot_next
op_assign
id|lv_ptr
suffix:semicolon
)brace
multiline_comment|/* activate the logical volume */
id|lv_ptr-&gt;lv_status
op_or_assign
id|LV_ACTIVE
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_access
op_amp
id|LV_WRITE
)paren
id|set_device_ro
c_func
(paren
id|lv_ptr-&gt;lv_dev
comma
l_int|0
)paren
suffix:semicolon
r_else
id|set_device_ro
c_func
(paren
id|lv_ptr-&gt;lv_dev
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef&t;LVM_VFS_ENHANCEMENT
multiline_comment|/* VFS function call to unlock the filesystem */
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_access
op_amp
id|LV_SNAPSHOT
)paren
(brace
id|unlockfs
c_func
(paren
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_dev
)paren
suffix:semicolon
)brace
macro_line|#endif
id|lv_ptr-&gt;vg
op_assign
id|vg_ptr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_lv_create() */
multiline_comment|/*&n; * character device support function logical volume remove&n; */
DECL|function|lvm_do_lv_remove
r_static
r_int
id|lvm_do_lv_remove
c_func
(paren
r_int
id|minor
comma
r_char
op_star
id|lv_name
comma
r_int
id|l
)paren
(brace
id|uint
id|le
comma
id|p
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
op_assign
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
op_minus
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_member_access_from_pointer
id|lv_name
comma
id|lv_name
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|l
op_eq
id|vg_ptr-&gt;lv_max
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
suffix:semicolon
macro_line|#ifdef LVM_TOTAL_RESET
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_open
OG
l_int|0
op_logical_and
id|lvm_reset_spindown
op_eq
l_int|0
)paren
macro_line|#else
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_open
OG
l_int|0
)paren
macro_line|#endif
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* check for deletion of snapshot source while&n;&t;   snapshot volume still exists */
r_if
c_cond
(paren
(paren
id|lv_ptr-&gt;lv_access
op_amp
id|LV_SNAPSHOT_ORG
)paren
op_logical_and
id|lv_ptr-&gt;lv_snapshot_next
op_ne
l_int|NULL
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|lv_ptr-&gt;lv_status
op_or_assign
id|LV_SPINDOWN
suffix:semicolon
multiline_comment|/* sync the buffers */
id|fsync_dev
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
suffix:semicolon
id|lv_ptr-&gt;lv_status
op_and_assign
op_complement
id|LV_ACTIVE
suffix:semicolon
multiline_comment|/* invalidate the buffers */
id|invalidate_buffers
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
suffix:semicolon
multiline_comment|/* reset generic hd */
id|lvm_gendisk.part
(braket
id|MINOR
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
)braket
dot
id|start_sect
op_assign
op_minus
l_int|1
suffix:semicolon
id|lvm_gendisk.part
(braket
id|MINOR
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
id|lvm_size
(braket
id|MINOR
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reset VG/LV mapping */
id|vg_lv_map
(braket
id|MINOR
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
)braket
dot
id|vg_number
op_assign
id|ABS_MAX_VG
suffix:semicolon
id|vg_lv_map
(braket
id|MINOR
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
)braket
dot
id|lv_number
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* correct the PE count in PVs if this is no snapshot logical volume */
r_if
c_cond
(paren
op_logical_neg
(paren
id|lv_ptr-&gt;lv_access
op_amp
id|LV_SNAPSHOT
)paren
)paren
(brace
multiline_comment|/* only if this is no snapshot logical volume because&n;&t;&t;   we share the lv_current_pe[] structs with the&n;&t;&t;   original logical volume */
r_for
c_loop
(paren
id|le
op_assign
l_int|0
suffix:semicolon
id|le
OL
id|lv_ptr-&gt;lv_allocated_le
suffix:semicolon
id|le
op_increment
)paren
(brace
id|vg_ptr-&gt;pe_allocated
op_decrement
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_cur
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pv_dev
op_eq
id|lv_ptr-&gt;lv_current_pe
(braket
id|le
)braket
dot
id|dev
)paren
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pe_allocated
op_decrement
suffix:semicolon
)brace
)brace
id|vfree
c_func
(paren
id|lv_ptr-&gt;lv_current_pe
)paren
suffix:semicolon
multiline_comment|/* LV_SNAPSHOT */
)brace
r_else
(brace
multiline_comment|/* remove this snapshot logical volume from the chain */
id|lv_ptr-&gt;lv_snapshot_prev-&gt;lv_snapshot_next
op_assign
id|lv_ptr-&gt;lv_snapshot_next
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_snapshot_next
op_ne
l_int|NULL
)paren
(brace
id|lv_ptr-&gt;lv_snapshot_next-&gt;lv_snapshot_prev
op_assign
id|lv_ptr-&gt;lv_snapshot_prev
suffix:semicolon
)brace
multiline_comment|/* no more snapshots? */
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_snapshot_next
op_eq
l_int|NULL
)paren
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_access
op_and_assign
op_complement
id|LV_SNAPSHOT_ORG
suffix:semicolon
id|lvm_snapshot_release
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
)brace
macro_line|#ifdef&t;CONFIG_DEVFS_FS
id|devfs_unregister
c_func
(paren
id|lv_devfs_handle
(braket
id|lv_ptr-&gt;lv_number
)braket
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined CONFIG_LVM_PROC_FS &amp;&amp; defined CONFIG_PROC_FS
id|lvm_do_remove_proc_entry_of_lv
(paren
id|vg_ptr
comma
id|lv_ptr
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_KFREE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- kfree %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|kfree
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
id|vg_ptr-&gt;lv_cur
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_lv_remove() */
multiline_comment|/*&n; * character device support function logical volume extend / reduce&n; */
DECL|function|lvm_do_lv_extend_reduce
r_static
r_int
id|lvm_do_lv_extend_reduce
c_func
(paren
r_int
id|minor
comma
r_char
op_star
id|lv_name
comma
id|lv_t
op_star
id|lv
)paren
(brace
id|ulong
id|end
comma
id|l
comma
id|le
comma
id|p
comma
id|size
comma
id|old_allocated_le
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
op_assign
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
id|pe_t
op_star
id|pe
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pep
op_assign
id|lv-&gt;lv_current_pe
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_member_access_from_pointer
id|lv_name
comma
id|lv_name
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|l
op_eq
id|vg_ptr-&gt;lv_max
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
suffix:semicolon
multiline_comment|/* check for active snapshot */
r_if
c_cond
(paren
id|lv-&gt;lv_access
op_amp
id|LV_SNAPSHOT
)paren
(brace
id|ulong
id|e
suffix:semicolon
id|lv_block_exception_t
op_star
id|lvbe
comma
op_star
id|lvbe_old
suffix:semicolon
r_struct
id|list_head
op_star
id|lvs_hash_table_old
suffix:semicolon
r_if
c_cond
(paren
id|lv-&gt;lv_block_exception
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|size
op_assign
id|lv-&gt;lv_remap_end
op_star
r_sizeof
(paren
id|lv_block_exception_t
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lvbe
op_assign
id|vmalloc
c_func
(paren
id|size
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- lvm_do_lv_extend_reduce: vmalloc error LV_BLOCK_EXCEPTION &quot;
l_string|&quot;of %lu Byte at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|size
comma
id|__LINE__
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lv-&gt;lv_remap_end
OG
id|lv_ptr-&gt;lv_remap_end
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|lvbe
comma
id|lv-&gt;lv_block_exception
comma
id|size
)paren
)paren
(brace
id|vfree
c_func
(paren
id|lvbe
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
id|lvbe_old
op_assign
id|lv_ptr-&gt;lv_block_exception
suffix:semicolon
id|lvs_hash_table_old
op_assign
id|lv_ptr-&gt;lv_snapshot_hash_table
suffix:semicolon
multiline_comment|/* we need to play on the safe side here... */
id|down
c_func
(paren
op_amp
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_snapshot_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_block_exception
op_eq
l_int|NULL
op_logical_or
id|lv_ptr-&gt;lv_remap_ptr
OG
id|lv_ptr-&gt;lv_remap_end
)paren
(brace
id|up
c_func
(paren
op_amp
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_snapshot_sem
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|lvbe
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|lvbe
comma
id|lv_ptr-&gt;lv_block_exception
comma
(paren
id|lv-&gt;lv_remap_end
OG
id|lv_ptr-&gt;lv_remap_end
ques
c_cond
id|lv_ptr-&gt;lv_remap_ptr
suffix:colon
id|lv-&gt;lv_remap_end
)paren
op_star
r_sizeof
(paren
id|lv_block_exception_t
)paren
)paren
suffix:semicolon
id|lv_ptr-&gt;lv_block_exception
op_assign
id|lvbe
suffix:semicolon
id|lv_ptr-&gt;lv_remap_end
op_assign
id|lv-&gt;lv_remap_end
suffix:semicolon
r_if
c_cond
(paren
id|lvm_snapshot_alloc_hash_table
c_func
(paren
id|lv_ptr
)paren
op_ne
l_int|0
)paren
(brace
id|lvm_drop_snapshot
c_func
(paren
id|lv_ptr
comma
l_string|&quot;hash_alloc&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_snapshot_sem
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|lvbe_old
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|lvs_hash_table_old
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|e
op_assign
l_int|0
suffix:semicolon
id|e
OL
id|lv_ptr-&gt;lv_remap_ptr
suffix:semicolon
id|e
op_increment
)paren
id|lvm_hash_link
(paren
id|lv_ptr-&gt;lv_block_exception
op_plus
id|e
comma
id|lv_ptr-&gt;lv_block_exception
(braket
id|e
)braket
dot
id|rdev_org
comma
id|lv_ptr-&gt;lv_block_exception
(braket
id|e
)braket
dot
id|rsector_org
comma
id|lv_ptr
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_snapshot_sem
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|lvbe_old
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|lvs_hash_table_old
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* we drop in here in case it is an original logical volume */
r_if
c_cond
(paren
(paren
id|pe
op_assign
id|vmalloc
c_func
(paren
id|size
op_assign
id|lv-&gt;lv_current_le
op_star
r_sizeof
(paren
id|pe_t
)paren
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- lvm_do_lv_extend_reduce: vmalloc error LV_CURRENT_PE &quot;
l_string|&quot;of %lu Byte at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|size
comma
id|__LINE__
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* get the PE structures from user space */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|pe
comma
id|pep
comma
id|size
)paren
)paren
(brace
id|vfree
c_func
(paren
id|pe
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- fsync_dev and &quot;
l_string|&quot;invalidate_buffers for %s [%s] in %s&bslash;n&quot;
comma
id|lvm_name
comma
id|lv_ptr-&gt;lv_name
comma
id|kdevname
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
comma
id|vg_ptr-&gt;vg_name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* reduce allocation counters on PV(s) */
r_for
c_loop
(paren
id|le
op_assign
l_int|0
suffix:semicolon
id|le
OL
id|lv_ptr-&gt;lv_allocated_le
suffix:semicolon
id|le
op_increment
)paren
(brace
id|vg_ptr-&gt;pe_allocated
op_decrement
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_cur
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pv_dev
op_eq
id|lv_ptr-&gt;lv_current_pe
(braket
id|le
)braket
dot
id|dev
)paren
(brace
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pe_allocated
op_decrement
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* save pointer to &quot;old&quot; lv/pe pointer array */
id|pep1
op_assign
id|lv_ptr-&gt;lv_current_pe
suffix:semicolon
id|end
op_assign
id|lv_ptr-&gt;lv_current_le
suffix:semicolon
multiline_comment|/* save open counter... */
id|lv-&gt;lv_open
op_assign
id|lv_ptr-&gt;lv_open
suffix:semicolon
id|lv-&gt;lv_snapshot_prev
op_assign
id|lv_ptr-&gt;lv_snapshot_prev
suffix:semicolon
id|lv-&gt;lv_snapshot_next
op_assign
id|lv_ptr-&gt;lv_snapshot_next
suffix:semicolon
id|lv-&gt;lv_snapshot_org
op_assign
id|lv_ptr-&gt;lv_snapshot_org
suffix:semicolon
id|lv-&gt;lv_current_pe
op_assign
id|pe
suffix:semicolon
multiline_comment|/* save # of old allocated logical extents */
id|old_allocated_le
op_assign
id|lv_ptr-&gt;lv_allocated_le
suffix:semicolon
multiline_comment|/* in case of shrinking -&gt; let&squot;s flush */
r_if
c_cond
(paren
id|end
OG
id|lv-&gt;lv_current_le
)paren
id|fsync_dev
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
suffix:semicolon
multiline_comment|/* copy preloaded LV */
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|lv_ptr
comma
(paren
r_char
op_star
)paren
id|lv
comma
r_sizeof
(paren
id|lv_t
)paren
)paren
suffix:semicolon
id|lvm_gendisk.part
(braket
id|MINOR
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|lvm_gendisk.part
(braket
id|MINOR
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
)braket
dot
id|nr_sects
op_assign
id|lv_ptr-&gt;lv_size
suffix:semicolon
id|lvm_size
(braket
id|MINOR
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
)braket
op_assign
id|lv_ptr-&gt;lv_size
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/* vg_lv_map array doesn&squot;t have to be changed here */
id|LVM_CORRECT_READ_AHEAD
c_func
(paren
id|lv_ptr-&gt;lv_read_ahead
)paren
suffix:semicolon
multiline_comment|/* save availiable i/o statistic data */
multiline_comment|/* linear logical volume */
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_stripes
OL
l_int|2
)paren
(brace
multiline_comment|/* Check what last LE shall be used */
r_if
c_cond
(paren
id|end
OG
id|lv_ptr-&gt;lv_current_le
)paren
id|end
op_assign
id|lv_ptr-&gt;lv_current_le
suffix:semicolon
r_for
c_loop
(paren
id|le
op_assign
l_int|0
suffix:semicolon
id|le
OL
id|end
suffix:semicolon
id|le
op_increment
)paren
(brace
id|lv_ptr-&gt;lv_current_pe
(braket
id|le
)braket
dot
id|reads
op_add_assign
id|pep1
(braket
id|le
)braket
dot
id|reads
suffix:semicolon
id|lv_ptr-&gt;lv_current_pe
(braket
id|le
)braket
dot
id|writes
op_add_assign
id|pep1
(braket
id|le
)braket
dot
id|writes
suffix:semicolon
)brace
multiline_comment|/* striped logical volume */
)brace
r_else
(brace
id|uint
id|i
comma
id|j
comma
id|source
comma
id|dest
comma
id|end
comma
id|old_stripe_size
comma
id|new_stripe_size
suffix:semicolon
id|old_stripe_size
op_assign
id|old_allocated_le
op_div
id|lv_ptr-&gt;lv_stripes
suffix:semicolon
id|new_stripe_size
op_assign
id|lv_ptr-&gt;lv_allocated_le
op_div
id|lv_ptr-&gt;lv_stripes
suffix:semicolon
id|end
op_assign
id|old_stripe_size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|new_stripe_size
)paren
id|end
op_assign
id|new_stripe_size
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|source
op_assign
id|dest
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lv_ptr-&gt;lv_stripes
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|end
suffix:semicolon
id|j
op_increment
)paren
(brace
id|lv_ptr-&gt;lv_current_pe
(braket
id|dest
op_plus
id|j
)braket
dot
id|reads
op_add_assign
id|pep1
(braket
id|source
op_plus
id|j
)braket
dot
id|reads
suffix:semicolon
id|lv_ptr-&gt;lv_current_pe
(braket
id|dest
op_plus
id|j
)braket
dot
id|writes
op_add_assign
id|pep1
(braket
id|source
op_plus
id|j
)braket
dot
id|writes
suffix:semicolon
)brace
id|source
op_add_assign
id|old_stripe_size
suffix:semicolon
id|dest
op_add_assign
id|new_stripe_size
suffix:semicolon
)brace
)brace
multiline_comment|/* extend the PE count in PVs */
r_for
c_loop
(paren
id|le
op_assign
l_int|0
suffix:semicolon
id|le
OL
id|lv_ptr-&gt;lv_allocated_le
suffix:semicolon
id|le
op_increment
)paren
(brace
id|vg_ptr-&gt;pe_allocated
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_cur
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pv_dev
op_eq
id|lv_ptr-&gt;lv_current_pe
(braket
id|le
)braket
dot
id|dev
)paren
(brace
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pe_allocated
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|vfree
(paren
id|pep1
)paren
suffix:semicolon
id|pep1
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|lv-&gt;lv_access
op_amp
id|LV_SNAPSHOT_ORG
)paren
(brace
multiline_comment|/* Correct the snapshot size information */
r_while
c_loop
(paren
(paren
id|lv_ptr
op_assign
id|lv_ptr-&gt;lv_snapshot_next
)paren
op_ne
l_int|NULL
)paren
(brace
id|lv_ptr-&gt;lv_current_pe
op_assign
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_current_pe
suffix:semicolon
id|lv_ptr-&gt;lv_allocated_le
op_assign
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_allocated_le
suffix:semicolon
id|lv_ptr-&gt;lv_current_le
op_assign
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_current_le
suffix:semicolon
id|lv_ptr-&gt;lv_size
op_assign
id|lv_ptr-&gt;lv_snapshot_org-&gt;lv_size
suffix:semicolon
id|lvm_gendisk.part
(braket
id|MINOR
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
)braket
dot
id|nr_sects
op_assign
id|lv_ptr-&gt;lv_size
suffix:semicolon
id|lvm_size
(braket
id|MINOR
c_func
(paren
id|lv_ptr-&gt;lv_dev
)paren
)braket
op_assign
id|lv_ptr-&gt;lv_size
op_rshift
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_lv_extend_reduce() */
multiline_comment|/*&n; * character device support function logical volume status by name&n; */
DECL|function|lvm_do_lv_status_byname
r_static
r_int
id|lvm_do_lv_status_byname
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
id|uint
id|l
suffix:semicolon
id|ulong
id|size
suffix:semicolon
id|lv_t
id|lv
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
id|lv_status_byname_req_t
id|lv_status_byname_req
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|lv_status_byname_req
comma
id|arg
comma
r_sizeof
(paren
id|lv_status_byname_req_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|lv_status_byname_req.lv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|lv
comma
id|lv_status_byname_req.lv
comma
r_sizeof
(paren
id|lv_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|lv_ptr-&gt;lv_name
comma
id|lv_status_byname_req.lv_name
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|lv_status_byname_req.lv
comma
id|lv_ptr
comma
r_sizeof
(paren
id|lv_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|lv.lv_current_pe
op_ne
l_int|NULL
)paren
(brace
id|size
op_assign
id|lv_ptr-&gt;lv_allocated_le
op_star
r_sizeof
(paren
id|pe_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|lv.lv_current_pe
comma
id|lv_ptr-&gt;lv_current_pe
comma
id|size
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* lvm_do_lv_status_byname() */
multiline_comment|/*&n; * character device support function logical volume status by index&n; */
DECL|function|lvm_do_lv_status_byindex
r_static
r_int
id|lvm_do_lv_status_byindex
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
id|ulong
id|size
suffix:semicolon
id|lv_t
id|lv
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
id|lv_status_byindex_req_t
id|lv_status_byindex_req
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|lv_status_byindex_req
comma
id|arg
comma
r_sizeof
(paren
id|lv_status_byindex_req
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lvp
op_assign
id|lv_status_byindex_req.lv
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|lv_status_byindex_req.lv_index
)braket
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|lv
comma
id|lvp
comma
r_sizeof
(paren
id|lv_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|lvp
comma
id|lv_ptr
comma
r_sizeof
(paren
id|lv_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|lv.lv_current_pe
op_ne
l_int|NULL
)paren
(brace
id|size
op_assign
id|lv_ptr-&gt;lv_allocated_le
op_star
r_sizeof
(paren
id|pe_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|lv.lv_current_pe
comma
id|lv_ptr-&gt;lv_current_pe
comma
id|size
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_lv_status_byindex() */
multiline_comment|/*&n; * character device support function logical volume status by device number&n; */
DECL|function|lvm_do_lv_status_bydev
r_static
r_int
id|lvm_do_lv_status_bydev
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|l
suffix:semicolon
id|lv_status_bydev_req_t
id|lv_status_bydev_req
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|lv_status_bydev_req
comma
id|arg
comma
r_sizeof
(paren
id|lv_status_bydev_req
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_member_access_from_pointer
id|lv_dev
op_eq
id|lv_status_bydev_req.dev
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|l
op_eq
id|vg_ptr-&gt;lv_max
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|lv_status_bydev_req.lv
comma
id|vg_ptr-&gt;lv
(braket
id|l
)braket
comma
r_sizeof
(paren
id|lv_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_lv_status_bydev() */
multiline_comment|/*&n; * character device support function rename a logical volume&n; */
DECL|function|lvm_do_lv_rename
r_static
r_int
id|lvm_do_lv_rename
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
id|lv_req_t
op_star
id|lv_req
comma
id|lv_t
op_star
id|lv
)paren
(brace
r_int
id|l
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
)paren
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;lv_dev
op_eq
id|lv-&gt;lv_dev
)paren
(brace
macro_line|#if defined CONFIG_LVM_PROC_FS &amp;&amp; defined CONFIG_PROC_FS
id|lvm_do_remove_proc_entry_of_lv
(paren
id|vg_ptr
comma
id|lv_ptr
)paren
suffix:semicolon
macro_line|#endif
id|strncpy
c_func
(paren
id|lv_ptr-&gt;lv_name
comma
id|lv_req-&gt;lv_name
comma
id|NAME_LEN
)paren
suffix:semicolon
macro_line|#if defined CONFIG_LVM_PROC_FS &amp;&amp; defined CONFIG_PROC_FS
id|lvm_do_create_proc_entry_of_lv
(paren
id|vg_ptr
comma
id|lv_ptr
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|l
op_eq
id|vg_ptr-&gt;lv_max
)paren
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* lvm_do_lv_rename */
multiline_comment|/*&n; * character device support function physical volume change&n; */
DECL|function|lvm_do_pv_change
r_static
r_int
id|lvm_do_pv_change
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
id|uint
id|p
suffix:semicolon
id|pv_t
op_star
id|pv_ptr
suffix:semicolon
macro_line|#ifdef LVM_GET_INODE
r_struct
id|inode
op_star
id|inode_sav
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|pv_change_req
comma
id|arg
comma
r_sizeof
(paren
id|pv_change_req
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|p
op_increment
)paren
(brace
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pv_ptr
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|pv_ptr-&gt;pv_name
comma
id|pv_change_req.pv_name
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef LVM_GET_INODE
id|inode_sav
op_assign
id|pv_ptr-&gt;inode
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|pv_ptr
comma
id|pv_change_req.pv
comma
r_sizeof
(paren
id|pv_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* We don&squot;t need the PE list&n;&t;&t;&t;   in kernel space as with LVs pe_t list */
id|pv_ptr-&gt;pe
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef LVM_GET_INODE
id|pv_ptr-&gt;inode
op_assign
id|inode_sav
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* lvm_do_pv_change() */
multiline_comment|/*&n; * character device support function get physical volume status&n; */
DECL|function|lvm_do_pv_status
r_static
r_int
id|lvm_do_pv_status
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
id|uint
id|p
suffix:semicolon
id|pv_t
op_star
id|pv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|pv_status_req
comma
id|arg
comma
r_sizeof
(paren
id|pv_status_req
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|p
op_increment
)paren
(brace
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pv_ptr
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|pv_ptr-&gt;pv_name
comma
id|pv_status_req.pv_name
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|pv_status_req.pv
comma
id|pv_ptr
comma
r_sizeof
(paren
id|pv_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* lvm_do_pv_status() */
multiline_comment|/*&n; * create a /proc entry for a logical volume&n; */
DECL|function|lvm_do_create_proc_entry_of_lv
r_inline
r_void
id|lvm_do_create_proc_entry_of_lv
(paren
id|vg_t
op_star
id|vg_ptr
comma
id|lv_t
op_star
id|lv_ptr
)paren
(brace
r_char
op_star
id|basename
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr-&gt;lv_subdir_pde
op_ne
l_int|NULL
)paren
(brace
id|basename
op_assign
id|strrchr
c_func
(paren
id|lv_ptr-&gt;lv_name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|basename
op_eq
l_int|NULL
)paren
id|basename
op_assign
id|lv_ptr-&gt;lv_name
suffix:semicolon
r_else
id|basename
op_increment
suffix:semicolon
id|pde
op_assign
id|create_proc_entry
c_func
(paren
id|basename
comma
id|S_IFREG
comma
id|vg_ptr-&gt;lv_subdir_pde
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pde
op_ne
l_int|NULL
)paren
(brace
id|pde-&gt;read_proc
op_assign
id|lvm_proc_read_lv_info
suffix:semicolon
id|pde-&gt;data
op_assign
id|lv_ptr
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * remove a /proc entry for a logical volume&n; */
DECL|function|lvm_do_remove_proc_entry_of_lv
r_inline
r_void
id|lvm_do_remove_proc_entry_of_lv
(paren
id|vg_t
op_star
id|vg_ptr
comma
id|lv_t
op_star
id|lv_ptr
)paren
(brace
r_char
op_star
id|basename
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr-&gt;lv_subdir_pde
op_ne
l_int|NULL
)paren
(brace
id|basename
op_assign
id|strrchr
c_func
(paren
id|lv_ptr-&gt;lv_name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|basename
op_eq
l_int|NULL
)paren
id|basename
op_assign
id|lv_ptr-&gt;lv_name
suffix:semicolon
r_else
id|basename
op_increment
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|basename
comma
id|vg_ptr-&gt;lv_subdir_pde
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * create a /proc entry for a physical volume&n; */
DECL|function|lvm_do_create_proc_entry_of_pv
r_inline
r_void
id|lvm_do_create_proc_entry_of_pv
(paren
id|vg_t
op_star
id|vg_ptr
comma
id|pv_t
op_star
id|pv_ptr
)paren
(brace
r_char
op_star
id|basename
suffix:semicolon
id|basename
op_assign
id|strrchr
c_func
(paren
id|pv_ptr-&gt;pv_name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|basename
op_eq
l_int|NULL
)paren
id|basename
op_assign
id|pv_ptr-&gt;pv_name
suffix:semicolon
r_else
id|basename
op_increment
suffix:semicolon
id|pde
op_assign
id|create_proc_entry
c_func
(paren
id|basename
comma
id|S_IFREG
comma
id|vg_ptr-&gt;pv_subdir_pde
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pde
op_ne
l_int|NULL
)paren
(brace
id|pde-&gt;read_proc
op_assign
id|lvm_proc_read_pv_info
suffix:semicolon
id|pde-&gt;data
op_assign
id|pv_ptr
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * remove a /proc entry for a physical volume&n; */
DECL|function|lvm_do_remove_proc_entry_of_pv
r_inline
r_void
id|lvm_do_remove_proc_entry_of_pv
(paren
id|vg_t
op_star
id|vg_ptr
comma
id|pv_t
op_star
id|pv_ptr
)paren
(brace
r_char
op_star
id|basename
suffix:semicolon
id|basename
op_assign
id|strrchr
c_func
(paren
id|pv_ptr-&gt;pv_name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr-&gt;pv_subdir_pde
op_ne
l_int|NULL
)paren
(brace
id|basename
op_assign
id|strrchr
c_func
(paren
id|pv_ptr-&gt;pv_name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|basename
op_eq
l_int|NULL
)paren
id|basename
op_assign
id|pv_ptr-&gt;pv_name
suffix:semicolon
r_else
id|basename
op_increment
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|basename
comma
id|vg_ptr-&gt;pv_subdir_pde
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * create a /proc entry for a volume group&n; */
macro_line|#if defined CONFIG_LVM_PROC_FS &amp;&amp; defined CONFIG_PROC_FS
DECL|function|lvm_do_create_proc_entry_of_vg
r_void
id|lvm_do_create_proc_entry_of_vg
(paren
id|vg_t
op_star
id|vg_ptr
)paren
(brace
r_int
id|l
comma
id|p
suffix:semicolon
id|pv_t
op_star
id|pv_ptr
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
id|pde
op_assign
id|create_proc_entry
c_func
(paren
id|vg_ptr-&gt;vg_name
comma
id|S_IFDIR
comma
id|lvm_proc_vg_subdir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pde
op_ne
l_int|NULL
)paren
(brace
id|vg_ptr-&gt;vg_dir_pde
op_assign
id|pde
suffix:semicolon
id|pde
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;group&quot;
comma
id|S_IFREG
comma
id|vg_ptr-&gt;vg_dir_pde
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pde
op_ne
l_int|NULL
)paren
(brace
id|pde-&gt;read_proc
op_assign
id|lvm_proc_read_vg_info
suffix:semicolon
id|pde-&gt;data
op_assign
id|vg_ptr
suffix:semicolon
)brace
id|vg_ptr-&gt;lv_subdir_pde
op_assign
id|create_proc_entry
c_func
(paren
id|LVM_LV_SUBDIR
comma
id|S_IFDIR
comma
id|vg_ptr-&gt;vg_dir_pde
)paren
suffix:semicolon
id|vg_ptr-&gt;pv_subdir_pde
op_assign
id|create_proc_entry
c_func
(paren
id|LVM_PV_SUBDIR
comma
id|S_IFDIR
comma
id|vg_ptr-&gt;vg_dir_pde
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vg_ptr-&gt;pv_subdir_pde
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
)paren
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|lvm_do_create_proc_entry_of_lv
(paren
id|vg_ptr
comma
id|lv_ptr
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
)paren
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|lvm_do_create_proc_entry_of_pv
(paren
id|vg_ptr
comma
id|pv_ptr
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * remove a /proc entry for a volume group&n; */
DECL|function|lvm_do_remove_proc_entry_of_vg
r_void
id|lvm_do_remove_proc_entry_of_vg
(paren
id|vg_t
op_star
id|vg_ptr
)paren
(brace
r_int
id|l
comma
id|p
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
id|pv_t
op_star
id|pv_ptr
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
)paren
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|lvm_do_remove_proc_entry_of_lv
(paren
id|vg_ptr
comma
id|vg_ptr-&gt;lv
(braket
id|l
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
)paren
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|lvm_do_remove_proc_entry_of_pv
(paren
id|vg_ptr
comma
id|vg_ptr-&gt;pv
(braket
id|p
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vg_ptr-&gt;vg_dir_pde
op_ne
l_int|NULL
)paren
(brace
id|remove_proc_entry
c_func
(paren
id|LVM_LV_SUBDIR
comma
id|vg_ptr-&gt;vg_dir_pde
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|LVM_PV_SUBDIR
comma
id|vg_ptr-&gt;vg_dir_pde
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;group&quot;
comma
id|vg_ptr-&gt;vg_dir_pde
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|vg_ptr-&gt;vg_name
comma
id|lvm_proc_vg_subdir
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; * support function initialize gendisk variables&n; */
macro_line|#ifdef __initfunc
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|lvm_geninit
c_func
(paren
r_struct
id|gendisk
op_star
id|lvm_gdisk
)paren
)paren
macro_line|#else
r_void
id|__init
id|lvm_geninit
c_func
(paren
r_struct
id|gendisk
op_star
id|lvm_gdisk
)paren
macro_line|#endif
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_GENDISK
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- lvm_gendisk&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_LV
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lvm_gendisk.part
(braket
id|i
)braket
dot
id|start_sect
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* avoid partition check */
id|lvm_size
(braket
id|i
)braket
op_assign
id|lvm_gendisk.part
(braket
id|i
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
id|lvm_blocksizes
(braket
id|i
)braket
op_assign
id|BLOCK_SIZE
suffix:semicolon
)brace
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
id|lvm_size
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|lvm_blocksizes
suffix:semicolon
id|hardsect_size
(braket
id|MAJOR_NR
)braket
op_assign
id|lvm_blocksizes
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* lvm_gen_init() */
macro_line|#ifdef LVM_GET_INODE
multiline_comment|/*&n; * support function to get an empty inode&n; *&n; * Gets an empty inode to be inserted into the inode hash,&n; * so that a physical volume can&squot;t be mounted.&n; * This is analog to drivers/block/md.c&n; *&n; * Is this the real thing?&n; *&n; */
DECL|function|lvm_get_inode
r_struct
id|inode
op_star
id|lvm_get_inode
c_func
(paren
r_int
id|dev
)paren
(brace
r_struct
id|inode
op_star
id|inode_this
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Lock the device by inserting a dummy inode. */
id|inode_this
op_assign
id|get_empty_inode
c_func
(paren
)paren
suffix:semicolon
id|inode_this-&gt;i_dev
op_assign
id|dev
suffix:semicolon
id|insert_inode_hash
c_func
(paren
id|inode_this
)paren
suffix:semicolon
r_return
id|inode_this
suffix:semicolon
)brace
multiline_comment|/*&n; * support function to clear an inode&n; *&n; */
DECL|function|lvm_clear_inode
r_void
id|lvm_clear_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
macro_line|#ifdef I_FREEING
id|inode-&gt;i_state
op_or_assign
id|I_FREEING
suffix:semicolon
macro_line|#endif
id|clear_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* #ifdef LVM_GET_INODE */
eof
