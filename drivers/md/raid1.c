multiline_comment|/*&n; * raid1.c : Multiple Devices driver for Linux&n; *&n; * Copyright (C) 1999, 2000 Ingo Molnar, Red Hat&n; *&n; * Copyright (C) 1996, 1997, 1998 Ingo Molnar, Miguel de Icaza, Gadi Oxman&n; *&n; * RAID-1 management functions.&n; *&n; * Better read-balancing code written by Mika Kuoppala &lt;miku@iki.fi&gt;, 2000&n; *&n; * Fixes to reconstruction by Jakob &#xfffd;stergaard&quot; &lt;jakob@ostenfeld.dk&gt;&n; * Various fixes by Neil Brown &lt;neilb@cse.unsw.edu.au&gt;&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * You should have received a copy of the GNU General Public License&n; * (for example /usr/src/linux/COPYING); if not, write to the Free&n; * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/raid/raid1.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR MD_MAJOR
DECL|macro|MD_DRIVER
mdefine_line|#define MD_DRIVER
DECL|macro|MD_PERSONALITY
mdefine_line|#define MD_PERSONALITY
DECL|macro|MAX_WORK_PER_DISK
mdefine_line|#define MAX_WORK_PER_DISK 128
multiline_comment|/*&n; * The following can be used to debug the driver&n; */
DECL|macro|RAID1_DEBUG
mdefine_line|#define RAID1_DEBUG&t;0
macro_line|#if RAID1_DEBUG
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x...)   printk(x)
DECL|macro|inline
mdefine_line|#define inline
DECL|macro|__inline__
mdefine_line|#define __inline__
macro_line|#else
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x...)  do { } while (0)
macro_line|#endif
DECL|variable|raid1_personality
r_static
id|mdk_personality_t
id|raid1_personality
suffix:semicolon
DECL|variable|retry_list_lock
r_static
id|md_spinlock_t
id|retry_list_lock
op_assign
id|MD_SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|raid1_retry_list
DECL|variable|raid1_retry_tail
r_struct
id|raid1_bh
op_star
id|raid1_retry_list
op_assign
l_int|NULL
comma
op_star
op_star
id|raid1_retry_tail
suffix:semicolon
DECL|function|raid1_alloc_bh
r_static
r_struct
id|buffer_head
op_star
id|raid1_alloc_bh
c_func
(paren
id|raid1_conf_t
op_star
id|conf
comma
r_int
id|cnt
)paren
(brace
multiline_comment|/* return a linked list of &quot;cnt&quot; struct buffer_heads.&n;&t; * don&squot;t take any off the free list unless we know we can&n;&t; * get all we need, otherwise we could deadlock&n;&t; */
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|cnt
)paren
(brace
r_struct
id|buffer_head
op_star
id|t
suffix:semicolon
id|md_spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;freebh_cnt
op_ge
id|cnt
)paren
r_while
c_loop
(paren
id|cnt
)paren
(brace
id|t
op_assign
id|conf-&gt;freebh
suffix:semicolon
id|conf-&gt;freebh
op_assign
id|t-&gt;b_next
suffix:semicolon
id|t-&gt;b_next
op_assign
id|bh
suffix:semicolon
id|bh
op_assign
id|t
suffix:semicolon
id|t-&gt;b_state
op_assign
l_int|0
suffix:semicolon
id|conf-&gt;freebh_cnt
op_decrement
suffix:semicolon
id|cnt
op_decrement
suffix:semicolon
)brace
id|md_spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|t
op_assign
(paren
r_struct
id|buffer_head
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|buffer_head
)paren
comma
id|GFP_BUFFER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
id|memset
c_func
(paren
id|t
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|t
)paren
)paren
suffix:semicolon
id|t-&gt;b_next
op_assign
id|bh
suffix:semicolon
id|bh
op_assign
id|t
suffix:semicolon
id|cnt
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|PRINTK
c_func
(paren
l_string|&quot;waiting for %d bh&bslash;n&quot;
comma
id|cnt
)paren
suffix:semicolon
id|wait_event
c_func
(paren
id|conf-&gt;wait_buffer
comma
id|conf-&gt;freebh_cnt
op_ge
id|cnt
)paren
suffix:semicolon
)brace
)brace
r_return
id|bh
suffix:semicolon
)brace
DECL|function|raid1_free_bh
r_static
r_inline
r_void
id|raid1_free_bh
c_func
(paren
id|raid1_conf_t
op_star
id|conf
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bh
)paren
(brace
r_struct
id|buffer_head
op_star
id|t
op_assign
id|bh
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_next
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;b_pprev
op_eq
l_int|NULL
)paren
id|kfree
c_func
(paren
id|t
)paren
suffix:semicolon
r_else
(brace
id|t-&gt;b_next
op_assign
id|conf-&gt;freebh
suffix:semicolon
id|conf-&gt;freebh
op_assign
id|t
suffix:semicolon
id|conf-&gt;freebh_cnt
op_increment
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_buffer
)paren
suffix:semicolon
)brace
DECL|function|raid1_grow_bh
r_static
r_int
id|raid1_grow_bh
c_func
(paren
id|raid1_conf_t
op_star
id|conf
comma
r_int
id|cnt
)paren
(brace
multiline_comment|/* allocate cnt buffer_heads, possibly less if kalloc fails */
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|cnt
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|bh
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|bh
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_break
suffix:semicolon
id|memset
c_func
(paren
id|bh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|bh
)paren
)paren
suffix:semicolon
id|md_spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|bh-&gt;b_pprev
op_assign
op_amp
id|conf-&gt;freebh
suffix:semicolon
id|bh-&gt;b_next
op_assign
id|conf-&gt;freebh
suffix:semicolon
id|conf-&gt;freebh
op_assign
id|bh
suffix:semicolon
id|conf-&gt;freebh_cnt
op_increment
suffix:semicolon
id|md_spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
DECL|function|raid1_shrink_bh
r_static
r_int
id|raid1_shrink_bh
c_func
(paren
id|raid1_conf_t
op_star
id|conf
comma
r_int
id|cnt
)paren
(brace
multiline_comment|/* discard cnt buffer_heads, if we can find them */
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|md_spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i
OL
id|cnt
)paren
op_logical_and
id|conf-&gt;freebh
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|conf-&gt;freebh
suffix:semicolon
id|conf-&gt;freebh
op_assign
id|bh-&gt;b_next
suffix:semicolon
id|kfree
c_func
(paren
id|bh
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|conf-&gt;freebh_cnt
op_decrement
suffix:semicolon
)brace
id|md_spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|raid1_alloc_r1bh
r_static
r_struct
id|raid1_bh
op_star
id|raid1_alloc_r1bh
c_func
(paren
id|raid1_conf_t
op_star
id|conf
)paren
(brace
r_struct
id|raid1_bh
op_star
id|r1_bh
op_assign
l_int|NULL
suffix:semicolon
r_do
(brace
id|md_spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;freer1
)paren
(brace
id|r1_bh
op_assign
id|conf-&gt;freer1
suffix:semicolon
id|conf-&gt;freer1
op_assign
id|r1_bh-&gt;next_r1
suffix:semicolon
id|r1_bh-&gt;next_r1
op_assign
l_int|NULL
suffix:semicolon
id|r1_bh-&gt;state
op_assign
l_int|0
suffix:semicolon
id|r1_bh-&gt;bh_req.b_state
op_assign
l_int|0
suffix:semicolon
)brace
id|md_spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r1_bh
)paren
r_return
id|r1_bh
suffix:semicolon
id|r1_bh
op_assign
(paren
r_struct
id|raid1_bh
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|raid1_bh
)paren
comma
id|GFP_BUFFER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r1_bh
)paren
(brace
id|memset
c_func
(paren
id|r1_bh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|r1_bh
)paren
)paren
suffix:semicolon
r_return
id|r1_bh
suffix:semicolon
)brace
id|wait_event
c_func
(paren
id|conf-&gt;wait_buffer
comma
id|conf-&gt;freer1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|raid1_free_r1bh
r_static
r_inline
r_void
id|raid1_free_r1bh
c_func
(paren
r_struct
id|raid1_bh
op_star
id|r1_bh
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|r1_bh-&gt;mirror_bh_list
suffix:semicolon
id|raid1_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r1_bh-&gt;mddev
)paren
suffix:semicolon
id|r1_bh-&gt;mirror_bh_list
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|R1BH_PreAlloc
comma
op_amp
id|r1_bh-&gt;state
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
id|r1_bh-&gt;next_r1
op_assign
id|conf-&gt;freer1
suffix:semicolon
id|conf-&gt;freer1
op_assign
id|r1_bh
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|kfree
c_func
(paren
id|r1_bh
)paren
suffix:semicolon
)brace
id|raid1_free_bh
c_func
(paren
id|conf
comma
id|bh
)paren
suffix:semicolon
)brace
DECL|function|raid1_grow_r1bh
r_static
r_int
id|raid1_grow_r1bh
(paren
id|raid1_conf_t
op_star
id|conf
comma
r_int
id|cnt
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|cnt
)paren
(brace
r_struct
id|raid1_bh
op_star
id|r1_bh
suffix:semicolon
id|r1_bh
op_assign
(paren
r_struct
id|raid1_bh
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|r1_bh
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r1_bh
)paren
r_break
suffix:semicolon
id|memset
c_func
(paren
id|r1_bh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|r1_bh
)paren
)paren
suffix:semicolon
id|md_spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|R1BH_PreAlloc
comma
op_amp
id|r1_bh-&gt;state
)paren
suffix:semicolon
id|r1_bh-&gt;next_r1
op_assign
id|conf-&gt;freer1
suffix:semicolon
id|conf-&gt;freer1
op_assign
id|r1_bh
suffix:semicolon
id|md_spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
DECL|function|raid1_shrink_r1bh
r_static
r_void
id|raid1_shrink_r1bh
c_func
(paren
id|raid1_conf_t
op_star
id|conf
)paren
(brace
id|md_spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|conf-&gt;freer1
)paren
(brace
r_struct
id|raid1_bh
op_star
id|r1_bh
op_assign
id|conf-&gt;freer1
suffix:semicolon
id|conf-&gt;freer1
op_assign
id|r1_bh-&gt;next_r1
suffix:semicolon
id|kfree
c_func
(paren
id|r1_bh
)paren
suffix:semicolon
)brace
id|md_spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
)brace
DECL|function|raid1_free_buf
r_static
r_inline
r_void
id|raid1_free_buf
c_func
(paren
r_struct
id|raid1_bh
op_star
id|r1_bh
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|r1_bh-&gt;mirror_bh_list
suffix:semicolon
id|raid1_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r1_bh-&gt;mddev
)paren
suffix:semicolon
id|r1_bh-&gt;mirror_bh_list
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
id|r1_bh-&gt;next_r1
op_assign
id|conf-&gt;freebuf
suffix:semicolon
id|conf-&gt;freebuf
op_assign
id|r1_bh
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
id|raid1_free_bh
c_func
(paren
id|conf
comma
id|bh
)paren
suffix:semicolon
)brace
DECL|function|raid1_alloc_buf
r_static
r_struct
id|raid1_bh
op_star
id|raid1_alloc_buf
c_func
(paren
id|raid1_conf_t
op_star
id|conf
)paren
(brace
r_struct
id|raid1_bh
op_star
id|r1_bh
suffix:semicolon
id|md_spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_buffer
comma
id|conf-&gt;freebuf
comma
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|r1_bh
op_assign
id|conf-&gt;freebuf
suffix:semicolon
id|conf-&gt;freebuf
op_assign
id|r1_bh-&gt;next_r1
suffix:semicolon
id|r1_bh-&gt;next_r1
op_assign
l_int|NULL
suffix:semicolon
id|md_spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_return
id|r1_bh
suffix:semicolon
)brace
DECL|function|raid1_grow_buffers
r_static
r_int
id|raid1_grow_buffers
(paren
id|raid1_conf_t
op_star
id|conf
comma
r_int
id|cnt
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|md_spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|cnt
)paren
(brace
r_struct
id|raid1_bh
op_star
id|r1_bh
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|page
op_assign
id|alloc_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_break
suffix:semicolon
id|r1_bh
op_assign
(paren
r_struct
id|raid1_bh
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|r1_bh
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r1_bh
)paren
(brace
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memset
c_func
(paren
id|r1_bh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|r1_bh
)paren
)paren
suffix:semicolon
id|r1_bh-&gt;bh_req.b_page
op_assign
id|page
suffix:semicolon
id|r1_bh-&gt;bh_req.b_data
op_assign
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
id|r1_bh-&gt;next_r1
op_assign
id|conf-&gt;freebuf
suffix:semicolon
id|conf-&gt;freebuf
op_assign
id|r1_bh
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|md_spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|raid1_shrink_buffers
r_static
r_void
id|raid1_shrink_buffers
(paren
id|raid1_conf_t
op_star
id|conf
)paren
(brace
id|md_spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|conf-&gt;freebuf
)paren
(brace
r_struct
id|raid1_bh
op_star
id|r1_bh
op_assign
id|conf-&gt;freebuf
suffix:semicolon
id|conf-&gt;freebuf
op_assign
id|r1_bh-&gt;next_r1
suffix:semicolon
id|__free_page
c_func
(paren
id|r1_bh-&gt;bh_req.b_page
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|r1_bh
)paren
suffix:semicolon
)brace
id|md_spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
)brace
DECL|function|raid1_map
r_static
r_int
id|raid1_map
(paren
id|mddev_t
op_star
id|mddev
comma
id|kdev_t
op_star
id|rdev
comma
r_int
r_int
id|size
)paren
(brace
id|raid1_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|i
comma
id|disks
op_assign
id|MD_SB_DISKS
suffix:semicolon
multiline_comment|/*&n;&t; * Later we do read balancing on the read side &n;&t; * now we use the first available disk.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|operational
)paren
(brace
op_star
id|rdev
op_assign
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|dev
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;raid1_map(): huh, no more operational devices?&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|raid1_reschedule_retry
r_static
r_void
id|raid1_reschedule_retry
(paren
r_struct
id|raid1_bh
op_star
id|r1_bh
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|mddev_t
op_star
id|mddev
op_assign
id|r1_bh-&gt;mddev
suffix:semicolon
id|raid1_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|md_spin_lock_irqsave
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raid1_retry_list
op_eq
l_int|NULL
)paren
id|raid1_retry_tail
op_assign
op_amp
id|raid1_retry_list
suffix:semicolon
op_star
id|raid1_retry_tail
op_assign
id|r1_bh
suffix:semicolon
id|raid1_retry_tail
op_assign
op_amp
id|r1_bh-&gt;next_r1
suffix:semicolon
id|r1_bh-&gt;next_r1
op_assign
l_int|NULL
suffix:semicolon
id|md_spin_unlock_irqrestore
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|conf-&gt;thread
)paren
suffix:semicolon
)brace
DECL|function|io_request_done
r_static
r_void
r_inline
id|io_request_done
c_func
(paren
r_int
r_int
id|sector
comma
id|raid1_conf_t
op_star
id|conf
comma
r_int
id|phase
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;segment_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sector
OL
id|conf-&gt;start_active
)paren
id|conf-&gt;cnt_done
op_decrement
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sector
op_ge
id|conf-&gt;start_future
op_logical_and
id|conf-&gt;phase
op_eq
id|phase
)paren
id|conf-&gt;cnt_future
op_decrement
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|conf-&gt;cnt_pending
)paren
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_ready
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;segment_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|sync_request_done
r_static
r_void
r_inline
id|sync_request_done
(paren
r_int
r_int
id|sector
comma
id|raid1_conf_t
op_star
id|conf
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;segment_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sector
op_ge
id|conf-&gt;start_ready
)paren
op_decrement
id|conf-&gt;cnt_ready
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sector
op_ge
id|conf-&gt;start_active
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|conf-&gt;cnt_active
)paren
(brace
id|conf-&gt;start_active
op_assign
id|conf-&gt;start_ready
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_done
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;segment_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * raid1_end_bh_io() is called when we have finished servicing a mirrored&n; * operation and are ready to return a success/failure code to the buffer&n; * cache layer.&n; */
DECL|function|raid1_end_bh_io
r_static
r_void
id|raid1_end_bh_io
(paren
r_struct
id|raid1_bh
op_star
id|r1_bh
comma
r_int
id|uptodate
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|r1_bh-&gt;master_bh
suffix:semicolon
id|io_request_done
c_func
(paren
id|bh-&gt;b_rsector
comma
id|mddev_to_conf
c_func
(paren
id|r1_bh-&gt;mddev
)paren
comma
id|test_bit
c_func
(paren
id|R1BH_SyncPhase
comma
op_amp
id|r1_bh-&gt;state
)paren
)paren
suffix:semicolon
id|bh
op_member_access_from_pointer
id|b_end_io
c_func
(paren
id|bh
comma
id|uptodate
)paren
suffix:semicolon
id|raid1_free_r1bh
c_func
(paren
id|r1_bh
)paren
suffix:semicolon
)brace
DECL|function|raid1_end_request
r_void
id|raid1_end_request
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_struct
id|raid1_bh
op_star
id|r1_bh
op_assign
(paren
r_struct
id|raid1_bh
op_star
)paren
(paren
id|bh-&gt;b_private
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * this branch is our &squot;one mirror IO has finished&squot; event handler:&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|md_error
(paren
id|mddev_to_kdev
c_func
(paren
id|r1_bh-&gt;mddev
)paren
comma
id|bh-&gt;b_dev
)paren
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t; * Set R1BH_Uptodate in our master buffer_head, so that&n;&t;&t; * we will return a good error code for to the higher&n;&t;&t; * levels even if IO on some other mirrored buffer fails.&n;&t;&t; *&n;&t;&t; * The &squot;master&squot; represents the complex operation to &n;&t;&t; * user-side. So if something waits for IO, then it will&n;&t;&t; * wait for the &squot;master&squot; buffer_head.&n;&t;&t; */
id|set_bit
(paren
id|R1BH_Uptodate
comma
op_amp
id|r1_bh-&gt;state
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We split up the read and write side, imho they are &n;&t; * conceptually different.&n;&t; */
r_if
c_cond
(paren
(paren
id|r1_bh-&gt;cmd
op_eq
id|READ
)paren
op_logical_or
(paren
id|r1_bh-&gt;cmd
op_eq
id|READA
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * we have only one buffer_head on the read side&n;&t;&t; */
r_if
c_cond
(paren
id|uptodate
)paren
(brace
id|raid1_end_bh_io
c_func
(paren
id|r1_bh
comma
id|uptodate
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * oops, read error:&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1: %s: rescheduling block %lu&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|bh-&gt;b_dev
)paren
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
id|raid1_reschedule_retry
c_func
(paren
id|r1_bh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * WRITE:&n;&t; *&n;&t; * Let&squot;s see if all mirrored write operations have finished &n;&t; * already.&n;&t; */
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|r1_bh-&gt;remaining
)paren
)paren
id|raid1_end_bh_io
c_func
(paren
id|r1_bh
comma
id|test_bit
c_func
(paren
id|R1BH_Uptodate
comma
op_amp
id|r1_bh-&gt;state
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine returns the disk from which the requested read should&n; * be done. It bookkeeps the last read position for every disk&n; * in array and when new read requests come, the disk which last&n; * position is nearest to the request, is chosen.&n; *&n; * TODO: now if there are 2 mirrors in the same 2 devices, performance&n; * degrades dramatically because position is mirror, not device based.&n; * This should be changed to be device based. Also atomic sequential&n; * reads should be somehow balanced.&n; */
DECL|function|raid1_read_balance
r_static
r_int
id|raid1_read_balance
(paren
id|raid1_conf_t
op_star
id|conf
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_int
id|new_disk
op_assign
id|conf-&gt;last_used
suffix:semicolon
r_const
r_int
id|sectors
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
r_const
r_int
r_int
id|this_sector
op_assign
id|bh-&gt;b_rsector
suffix:semicolon
r_int
id|disk
op_assign
id|new_disk
suffix:semicolon
r_int
r_int
id|new_distance
suffix:semicolon
r_int
r_int
id|current_distance
suffix:semicolon
multiline_comment|/*&n;&t; * Check if it is sane at all to balance&n;&t; */
r_if
c_cond
(paren
id|conf-&gt;resync_mirrors
)paren
r_goto
id|rb_out
suffix:semicolon
multiline_comment|/* make sure that disk is operational */
r_while
c_loop
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|new_disk
)braket
dot
id|operational
)paren
(brace
r_if
c_cond
(paren
id|new_disk
op_le
l_int|0
)paren
id|new_disk
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
id|new_disk
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|new_disk
op_eq
id|disk
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This means no working disk was found&n;&t;&t;&t; * Nothing much to do, lets not change anything&n;&t;&t;&t; * and hope for the best...&n;&t;&t;&t; */
id|new_disk
op_assign
id|conf-&gt;last_used
suffix:semicolon
r_goto
id|rb_out
suffix:semicolon
)brace
)brace
id|disk
op_assign
id|new_disk
suffix:semicolon
multiline_comment|/* now disk == new_disk == starting point for search */
multiline_comment|/*&n;&t; * Don&squot;t touch anything for sequential reads.&n;&t; */
r_if
c_cond
(paren
id|this_sector
op_eq
id|conf-&gt;mirrors
(braket
id|new_disk
)braket
dot
id|head_position
)paren
r_goto
id|rb_out
suffix:semicolon
multiline_comment|/*&n;&t; * If reads have been done only on a single disk&n;&t; * for a time, lets give another disk a change.&n;&t; * This is for kicking those idling disks so that&n;&t; * they would find work near some hotspot.&n;&t; */
r_if
c_cond
(paren
id|conf-&gt;sect_count
op_ge
id|conf-&gt;mirrors
(braket
id|new_disk
)braket
dot
id|sect_limit
)paren
(brace
id|conf-&gt;sect_count
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|new_disk
op_le
l_int|0
)paren
id|new_disk
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
id|new_disk
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|new_disk
op_eq
id|disk
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|conf-&gt;mirrors
(braket
id|new_disk
)braket
dot
id|write_only
)paren
op_logical_or
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|new_disk
)braket
dot
id|operational
)paren
)paren
suffix:semicolon
r_goto
id|rb_out
suffix:semicolon
)brace
id|current_distance
op_assign
id|abs
c_func
(paren
id|this_sector
op_minus
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|head_position
)paren
suffix:semicolon
multiline_comment|/* Find the disk which is closest */
r_do
(brace
r_if
c_cond
(paren
id|disk
op_le
l_int|0
)paren
id|disk
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
id|disk
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|write_only
)paren
op_logical_or
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|operational
)paren
)paren
r_continue
suffix:semicolon
id|new_distance
op_assign
id|abs
c_func
(paren
id|this_sector
op_minus
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|head_position
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_distance
OL
id|current_distance
)paren
(brace
id|conf-&gt;sect_count
op_assign
l_int|0
suffix:semicolon
id|current_distance
op_assign
id|new_distance
suffix:semicolon
id|new_disk
op_assign
id|disk
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|disk
op_ne
id|conf-&gt;last_used
)paren
suffix:semicolon
id|rb_out
suffix:colon
id|conf-&gt;mirrors
(braket
id|new_disk
)braket
dot
id|head_position
op_assign
id|this_sector
op_plus
id|sectors
suffix:semicolon
id|conf-&gt;last_used
op_assign
id|new_disk
suffix:semicolon
id|conf-&gt;sect_count
op_add_assign
id|sectors
suffix:semicolon
r_return
id|new_disk
suffix:semicolon
)brace
DECL|function|raid1_make_request
r_static
r_int
id|raid1_make_request
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|rw
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|raid1_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh_req
comma
op_star
id|bhl
suffix:semicolon
r_struct
id|raid1_bh
op_star
id|r1_bh
suffix:semicolon
r_int
id|disks
op_assign
id|MD_SB_DISKS
suffix:semicolon
r_int
id|i
comma
id|sum_bhs
op_assign
l_int|0
comma
id|sectors
suffix:semicolon
r_struct
id|mirror_info
op_star
id|mirror
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; * make_request() can abort the operation when READA is being&n; * used and no empty request is available.&n; *&n; * Currently, just replace the command with READ/WRITE.&n; */
r_if
c_cond
(paren
id|rw
op_eq
id|READA
)paren
id|rw
op_assign
id|READ
suffix:semicolon
id|r1_bh
op_assign
id|raid1_alloc_r1bh
(paren
id|conf
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;segment_lock
)paren
suffix:semicolon
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_done
comma
id|bh-&gt;b_rsector
OL
id|conf-&gt;start_active
op_logical_or
id|bh-&gt;b_rsector
op_ge
id|conf-&gt;start_future
comma
id|conf-&gt;segment_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_rsector
OL
id|conf-&gt;start_active
)paren
id|conf-&gt;cnt_done
op_increment
suffix:semicolon
r_else
(brace
id|conf-&gt;cnt_future
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;phase
)paren
id|set_bit
c_func
(paren
id|R1BH_SyncPhase
comma
op_amp
id|r1_bh-&gt;state
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;segment_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * i think the read and write branch should be separated completely,&n;&t; * since we want to do read balancing on the read side for example.&n;&t; * Alternative implementations? :) --mingo&n;&t; */
id|r1_bh-&gt;master_bh
op_assign
id|bh
suffix:semicolon
id|r1_bh-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|r1_bh-&gt;cmd
op_assign
id|rw
suffix:semicolon
id|sectors
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|READ
)paren
(brace
multiline_comment|/*&n;&t;&t; * read balancing logic:&n;&t;&t; */
id|mirror
op_assign
id|conf-&gt;mirrors
op_plus
id|raid1_read_balance
c_func
(paren
id|conf
comma
id|bh
)paren
suffix:semicolon
id|bh_req
op_assign
op_amp
id|r1_bh-&gt;bh_req
suffix:semicolon
id|memcpy
c_func
(paren
id|bh_req
comma
id|bh
comma
r_sizeof
(paren
op_star
id|bh
)paren
)paren
suffix:semicolon
id|bh_req-&gt;b_blocknr
op_assign
id|bh-&gt;b_rsector
op_div
id|sectors
suffix:semicolon
id|bh_req-&gt;b_dev
op_assign
id|mirror-&gt;dev
suffix:semicolon
id|bh_req-&gt;b_rdev
op_assign
id|mirror-&gt;dev
suffix:semicolon
multiline_comment|/*&t;bh_req-&gt;b_rsector = bh-&gt;n_rsector; */
id|bh_req-&gt;b_end_io
op_assign
id|raid1_end_request
suffix:semicolon
id|bh_req-&gt;b_private
op_assign
id|r1_bh
suffix:semicolon
id|generic_make_request
(paren
id|rw
comma
id|bh_req
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * WRITE:&n;&t; */
id|bhl
op_assign
id|raid1_alloc_bh
c_func
(paren
id|conf
comma
id|conf-&gt;raid_disks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|mbh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|operational
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t; * We should use a private pool (size depending on NR_REQUEST),&n;&t; * to avoid writes filling up the memory with bhs&n;&t; *&n; &t; * Such pools are much faster than kmalloc anyways (so we waste&n; &t; * almost nothing by not using the master bh when writing and&n; &t; * win alot of cleanness) but for now we are cool enough. --mingo&n; &t; *&n;&t; * It&squot;s safe to sleep here, buffer heads cannot be used in a shared&n; &t; * manner in the write branch. Look how we lock the buffer at the&n; &t; * beginning of this function to grok the difference ;)&n;&t; */
id|mbh
op_assign
id|bhl
suffix:semicolon
r_if
c_cond
(paren
id|mbh
op_eq
l_int|NULL
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bhl
op_assign
id|mbh-&gt;b_next
suffix:semicolon
id|mbh-&gt;b_next
op_assign
l_int|NULL
suffix:semicolon
id|mbh-&gt;b_this_page
op_assign
(paren
r_struct
id|buffer_head
op_star
)paren
l_int|1
suffix:semicolon
multiline_comment|/*&n; &t; * prepare mirrored mbh (fields ordered for max mem throughput):&n; &t; */
id|mbh-&gt;b_blocknr
op_assign
id|bh-&gt;b_rsector
op_div
id|sectors
suffix:semicolon
id|mbh-&gt;b_dev
op_assign
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|dev
suffix:semicolon
id|mbh-&gt;b_rdev
op_assign
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|dev
suffix:semicolon
id|mbh-&gt;b_rsector
op_assign
id|bh-&gt;b_rsector
suffix:semicolon
id|mbh-&gt;b_state
op_assign
(paren
l_int|1
op_lshift
id|BH_Req
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Dirty
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Mapped
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Lock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|mbh-&gt;b_count
comma
l_int|1
)paren
suffix:semicolon
id|mbh-&gt;b_size
op_assign
id|bh-&gt;b_size
suffix:semicolon
id|mbh-&gt;b_page
op_assign
id|bh-&gt;b_page
suffix:semicolon
id|mbh-&gt;b_data
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|mbh-&gt;b_list
op_assign
id|BUF_LOCKED
suffix:semicolon
id|mbh-&gt;b_end_io
op_assign
id|raid1_end_request
suffix:semicolon
id|mbh-&gt;b_private
op_assign
id|r1_bh
suffix:semicolon
id|mbh-&gt;b_next
op_assign
id|r1_bh-&gt;mirror_bh_list
suffix:semicolon
id|r1_bh-&gt;mirror_bh_list
op_assign
id|mbh
suffix:semicolon
id|sum_bhs
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bhl
)paren
id|raid1_free_bh
c_func
(paren
id|conf
comma
id|bhl
)paren
suffix:semicolon
id|md_atomic_set
c_func
(paren
op_amp
id|r1_bh-&gt;remaining
comma
id|sum_bhs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have to be a bit careful about the semaphore above, thats&n;&t; * why we start the requests separately. Since kmalloc() could&n;&t; * fail, sleep and make_request() can sleep too, this is the&n;&t; * safer solution. Imagine, end_request decreasing the semaphore&n;&t; * before we could have set it up ... We could play tricks with&n;&t; * the semaphore (presetting it and correcting at the end if&n;&t; * sum_bhs is not &squot;n&squot; but we have to do end_request by hand if&n;&t; * all requests finish until we had a chance to set up the&n;&t; * semaphore correctly ... lots of races).&n;&t; */
id|bh
op_assign
id|r1_bh-&gt;mirror_bh_list
suffix:semicolon
r_while
c_loop
(paren
id|bh
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh2
op_assign
id|bh
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_next
suffix:semicolon
id|generic_make_request
c_func
(paren
id|rw
comma
id|bh2
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|raid1_status
r_static
r_int
id|raid1_status
(paren
r_char
op_star
id|page
comma
id|mddev_t
op_star
id|mddev
)paren
(brace
id|raid1_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|sz
op_assign
l_int|0
comma
id|i
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; [%d/%d] [&quot;
comma
id|conf-&gt;raid_disks
comma
id|conf-&gt;working_disks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;%s&quot;
comma
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|operational
ques
c_cond
l_string|&quot;U&quot;
suffix:colon
l_string|&quot;_&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;]&quot;
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
DECL|macro|LAST_DISK
mdefine_line|#define LAST_DISK KERN_ALERT &bslash;&n;&quot;raid1: only one disk left and IO error.&bslash;n&quot;
DECL|macro|NO_SPARE_DISK
mdefine_line|#define NO_SPARE_DISK KERN_ALERT &bslash;&n;&quot;raid1: no spare disk left, degrading mirror level by one.&bslash;n&quot;
DECL|macro|DISK_FAILED
mdefine_line|#define DISK_FAILED KERN_ALERT &bslash;&n;&quot;raid1: Disk failure on %s, disabling device. &bslash;n&quot; &bslash;&n;&quot;&t;Operation continuing on %d devices&bslash;n&quot;
DECL|macro|START_SYNCING
mdefine_line|#define START_SYNCING KERN_ALERT &bslash;&n;&quot;raid1: start syncing spare disk.&bslash;n&quot;
DECL|macro|ALREADY_SYNCING
mdefine_line|#define ALREADY_SYNCING KERN_INFO &bslash;&n;&quot;raid1: syncing already in progress.&bslash;n&quot;
DECL|function|mark_disk_bad
r_static
r_void
id|mark_disk_bad
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|failed
)paren
(brace
id|raid1_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_struct
id|mirror_info
op_star
id|mirror
op_assign
id|conf-&gt;mirrors
op_plus
id|failed
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
id|mirror-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|mark_disk_faulty
c_func
(paren
id|sb-&gt;disks
op_plus
id|mirror-&gt;number
)paren
suffix:semicolon
id|mark_disk_nonsync
c_func
(paren
id|sb-&gt;disks
op_plus
id|mirror-&gt;number
)paren
suffix:semicolon
id|mark_disk_inactive
c_func
(paren
id|sb-&gt;disks
op_plus
id|mirror-&gt;number
)paren
suffix:semicolon
id|sb-&gt;active_disks
op_decrement
suffix:semicolon
id|sb-&gt;working_disks
op_decrement
suffix:semicolon
id|sb-&gt;failed_disks
op_increment
suffix:semicolon
id|mddev-&gt;sb_dirty
op_assign
l_int|1
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|conf-&gt;thread
)paren
suffix:semicolon
id|conf-&gt;working_disks
op_decrement
suffix:semicolon
id|printk
(paren
id|DISK_FAILED
comma
id|partition_name
(paren
id|mirror-&gt;dev
)paren
comma
id|conf-&gt;working_disks
)paren
suffix:semicolon
)brace
DECL|function|raid1_error
r_static
r_int
id|raid1_error
(paren
id|mddev_t
op_star
id|mddev
comma
id|kdev_t
id|dev
)paren
(brace
id|raid1_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_struct
id|mirror_info
op_star
id|mirrors
op_assign
id|conf-&gt;mirrors
suffix:semicolon
r_int
id|disks
op_assign
id|MD_SB_DISKS
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;working_disks
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Uh oh, we can do nothing if this is our last disk, but&n;&t;&t; * first check if this is a queued request for a device&n;&t;&t; * which has just failed.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mirrors
(braket
id|i
)braket
dot
id|dev
op_eq
id|dev
op_logical_and
op_logical_neg
id|mirrors
(braket
id|i
)braket
dot
id|operational
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|printk
(paren
id|LAST_DISK
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Mark disk as unusable&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mirrors
(braket
id|i
)braket
dot
id|dev
op_eq
id|dev
op_logical_and
id|mirrors
(braket
id|i
)braket
dot
id|operational
)paren
(brace
id|mark_disk_bad
c_func
(paren
id|mddev
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|LAST_DISK
macro_line|#undef LAST_DISK
DECL|macro|NO_SPARE_DISK
macro_line|#undef NO_SPARE_DISK
DECL|macro|DISK_FAILED
macro_line|#undef DISK_FAILED
DECL|macro|START_SYNCING
macro_line|#undef START_SYNCING
DECL|function|print_raid1_conf
r_static
r_void
id|print_raid1_conf
(paren
id|raid1_conf_t
op_star
id|conf
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|mirror_info
op_star
id|tmp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RAID1 conf printout:&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(conf==NULL)&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; --- wd:%d rd:%d nd:%d&bslash;n&quot;
comma
id|conf-&gt;working_disks
comma
id|conf-&gt;raid_disks
comma
id|conf-&gt;nr_disks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;mirrors
op_plus
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; disk %d, s:%d, o:%d, n:%d rd:%d us:%d dev:%s&bslash;n&quot;
comma
id|i
comma
id|tmp-&gt;spare
comma
id|tmp-&gt;operational
comma
id|tmp-&gt;number
comma
id|tmp-&gt;raid_disk
comma
id|tmp-&gt;used_slot
comma
id|partition_name
c_func
(paren
id|tmp-&gt;dev
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|close_sync
r_static
r_void
id|close_sync
c_func
(paren
id|raid1_conf_t
op_star
id|conf
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|conf-&gt;mddev
suffix:semicolon
multiline_comment|/* If reconstruction was interrupted, we need to close the &quot;active&quot; and &quot;pending&quot;&n;&t; * holes.&n;&t; * we know that there are no active rebuild requests, os cnt_active == cnt_ready ==0&n;&t; */
multiline_comment|/* this is really needed when recovery stops too... */
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;segment_lock
)paren
suffix:semicolon
id|conf-&gt;start_active
op_assign
id|conf-&gt;start_pending
suffix:semicolon
id|conf-&gt;start_ready
op_assign
id|conf-&gt;start_pending
suffix:semicolon
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_ready
comma
op_logical_neg
id|conf-&gt;cnt_pending
comma
id|conf-&gt;segment_lock
)paren
suffix:semicolon
id|conf-&gt;start_active
op_assign
id|conf-&gt;start_ready
op_assign
id|conf-&gt;start_pending
op_assign
id|conf-&gt;start_future
suffix:semicolon
id|conf-&gt;start_future
op_assign
id|mddev-&gt;sb-&gt;size
op_plus
l_int|1
suffix:semicolon
id|conf-&gt;cnt_pending
op_assign
id|conf-&gt;cnt_future
suffix:semicolon
id|conf-&gt;cnt_future
op_assign
l_int|0
suffix:semicolon
id|conf-&gt;phase
op_assign
id|conf-&gt;phase
op_xor
l_int|1
suffix:semicolon
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_ready
comma
op_logical_neg
id|conf-&gt;cnt_pending
comma
id|conf-&gt;segment_lock
)paren
suffix:semicolon
id|conf-&gt;start_active
op_assign
id|conf-&gt;start_ready
op_assign
id|conf-&gt;start_pending
op_assign
id|conf-&gt;start_future
op_assign
l_int|0
suffix:semicolon
id|conf-&gt;phase
op_assign
l_int|0
suffix:semicolon
id|conf-&gt;cnt_future
op_assign
id|conf-&gt;cnt_done
suffix:semicolon
suffix:semicolon
id|conf-&gt;cnt_done
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;segment_lock
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_done
)paren
suffix:semicolon
)brace
DECL|function|raid1_diskop
r_static
r_int
id|raid1_diskop
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdp_disk_t
op_star
op_star
id|d
comma
r_int
id|state
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|failed_disk
op_assign
op_minus
l_int|1
comma
id|spare_disk
op_assign
op_minus
l_int|1
comma
id|removed_disk
op_assign
op_minus
l_int|1
comma
id|added_disk
op_assign
op_minus
l_int|1
suffix:semicolon
id|raid1_conf_t
op_star
id|conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|mirror_info
op_star
id|tmp
comma
op_star
id|sdisk
comma
op_star
id|fdisk
comma
op_star
id|rdisk
comma
op_star
id|adisk
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
id|mdp_disk_t
op_star
id|failed_desc
comma
op_star
id|spare_desc
comma
op_star
id|added_desc
suffix:semicolon
id|print_raid1_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
id|md_spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * find the disk ...&n;&t; */
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|DISKOP_SPARE_ACTIVE
suffix:colon
multiline_comment|/*&n;&t;&t; * Find the failed disk within the RAID1 configuration ...&n;&t;&t; * (this can only be in the first conf-&gt;working_disks part)&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;mirrors
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|tmp-&gt;operational
op_logical_and
op_logical_neg
id|tmp-&gt;spare
)paren
op_logical_or
op_logical_neg
id|tmp-&gt;used_slot
)paren
(brace
id|failed_disk
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * When we activate a spare disk we _must_ have a disk in&n;&t;&t; * the lower (active) part of the array to replace. &n;&t;&t; */
r_if
c_cond
(paren
(paren
id|failed_disk
op_eq
op_minus
l_int|1
)paren
op_logical_or
(paren
id|failed_disk
op_ge
id|conf-&gt;raid_disks
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
multiline_comment|/* fall through */
r_case
id|DISKOP_SPARE_WRITE
suffix:colon
r_case
id|DISKOP_SPARE_INACTIVE
suffix:colon
multiline_comment|/*&n;&t;&t; * Find the spare disk ... (can only be in the &squot;high&squot;&n;&t;&t; * area of the array)&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;mirrors
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;spare
op_logical_and
id|tmp-&gt;number
op_eq
(paren
op_star
id|d
)paren
op_member_access_from_pointer
id|number
)paren
(brace
id|spare_disk
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|spare_disk
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISKOP_HOT_REMOVE_DISK
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;mirrors
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;used_slot
op_logical_and
(paren
id|tmp-&gt;number
op_eq
(paren
op_star
id|d
)paren
op_member_access_from_pointer
id|number
)paren
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;operational
)paren
(brace
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|removed_disk
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|removed_disk
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISKOP_HOT_ADD_DISK
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;mirrors
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp-&gt;used_slot
)paren
(brace
id|added_disk
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|added_disk
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|state
)paren
(brace
multiline_comment|/*&n;&t; * Switch the spare disk to write-only mode:&n;&t; */
r_case
id|DISKOP_SPARE_WRITE
suffix:colon
id|sdisk
op_assign
id|conf-&gt;mirrors
op_plus
id|spare_disk
suffix:semicolon
id|sdisk-&gt;operational
op_assign
l_int|1
suffix:semicolon
id|sdisk-&gt;write_only
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * Deactivate a spare disk:&n;&t; */
r_case
id|DISKOP_SPARE_INACTIVE
suffix:colon
id|close_sync
c_func
(paren
id|conf
)paren
suffix:semicolon
id|sdisk
op_assign
id|conf-&gt;mirrors
op_plus
id|spare_disk
suffix:semicolon
id|sdisk-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|sdisk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * Activate (mark read-write) the (now sync) spare disk,&n;&t; * which means we switch it&squot;s &squot;raid position&squot; (-&gt;raid_disk)&n;&t; * with the failed disk. (only the first &squot;conf-&gt;nr_disks&squot;&n;&t; * slots are used for &squot;real&squot; disks and we must preserve this&n;&t; * property)&n;&t; */
r_case
id|DISKOP_SPARE_ACTIVE
suffix:colon
id|close_sync
c_func
(paren
id|conf
)paren
suffix:semicolon
id|sdisk
op_assign
id|conf-&gt;mirrors
op_plus
id|spare_disk
suffix:semicolon
id|fdisk
op_assign
id|conf-&gt;mirrors
op_plus
id|failed_disk
suffix:semicolon
id|spare_desc
op_assign
op_amp
id|sb-&gt;disks
(braket
id|sdisk-&gt;number
)braket
suffix:semicolon
id|failed_desc
op_assign
op_amp
id|sb-&gt;disks
(braket
id|fdisk-&gt;number
)braket
suffix:semicolon
r_if
c_cond
(paren
id|spare_desc
op_ne
op_star
id|d
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|spare_desc-&gt;raid_disk
op_ne
id|sdisk-&gt;raid_disk
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sdisk-&gt;raid_disk
op_ne
id|spare_disk
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|failed_desc-&gt;raid_disk
op_ne
id|fdisk-&gt;raid_disk
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdisk-&gt;raid_disk
op_ne
id|failed_disk
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * do the switch finally&n;&t;&t; */
id|xchg_values
c_func
(paren
op_star
id|spare_desc
comma
op_star
id|failed_desc
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
op_star
id|fdisk
comma
op_star
id|sdisk
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * (careful, &squot;failed&squot; and &squot;spare&squot; are switched from now on)&n;&t;&t; *&n;&t;&t; * we want to preserve linear numbering and we want to&n;&t;&t; * give the proper raid_disk number to the now activated&n;&t;&t; * disk. (this means we switch back these values)&n;&t;&t; */
id|xchg_values
c_func
(paren
id|spare_desc-&gt;raid_disk
comma
id|failed_desc-&gt;raid_disk
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
id|sdisk-&gt;raid_disk
comma
id|fdisk-&gt;raid_disk
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
id|spare_desc-&gt;number
comma
id|failed_desc-&gt;number
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
id|sdisk-&gt;number
comma
id|fdisk-&gt;number
)paren
suffix:semicolon
op_star
id|d
op_assign
id|failed_desc
suffix:semicolon
r_if
c_cond
(paren
id|sdisk-&gt;dev
op_eq
id|MKDEV
c_func
(paren
l_int|0
comma
l_int|0
)paren
)paren
id|sdisk-&gt;used_slot
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * this really activates the spare.&n;&t;&t; */
id|fdisk-&gt;spare
op_assign
l_int|0
suffix:semicolon
id|fdisk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if we activate a spare, we definitely replace a&n;&t;&t; * non-operational disk slot in the &squot;low&squot; area of&n;&t;&t; * the disk array.&n;&t;&t; */
id|conf-&gt;working_disks
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DISKOP_HOT_REMOVE_DISK
suffix:colon
id|rdisk
op_assign
id|conf-&gt;mirrors
op_plus
id|removed_disk
suffix:semicolon
r_if
c_cond
(paren
id|rdisk-&gt;spare
op_logical_and
(paren
id|removed_disk
OL
id|conf-&gt;raid_disks
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|rdisk-&gt;dev
op_assign
id|MKDEV
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|rdisk-&gt;used_slot
op_assign
l_int|0
suffix:semicolon
id|conf-&gt;nr_disks
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DISKOP_HOT_ADD_DISK
suffix:colon
id|adisk
op_assign
id|conf-&gt;mirrors
op_plus
id|added_disk
suffix:semicolon
id|added_desc
op_assign
op_star
id|d
suffix:semicolon
r_if
c_cond
(paren
id|added_disk
op_ne
id|added_desc-&gt;number
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|adisk-&gt;number
op_assign
id|added_desc-&gt;number
suffix:semicolon
id|adisk-&gt;raid_disk
op_assign
id|added_desc-&gt;raid_disk
suffix:semicolon
id|adisk-&gt;dev
op_assign
id|MKDEV
c_func
(paren
id|added_desc-&gt;major
comma
id|added_desc-&gt;minor
)paren
suffix:semicolon
id|adisk-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|adisk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
id|adisk-&gt;spare
op_assign
l_int|1
suffix:semicolon
id|adisk-&gt;used_slot
op_assign
l_int|1
suffix:semicolon
id|adisk-&gt;head_position
op_assign
l_int|0
suffix:semicolon
id|conf-&gt;nr_disks
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
m_abort
suffix:colon
id|md_spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|DISKOP_SPARE_ACTIVE
op_logical_or
id|state
op_eq
id|DISKOP_SPARE_INACTIVE
)paren
multiline_comment|/* should move to &quot;END_REBUILD&quot; when such exists */
id|raid1_shrink_buffers
c_func
(paren
id|conf
)paren
suffix:semicolon
id|print_raid1_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|macro|IO_ERROR
mdefine_line|#define IO_ERROR KERN_ALERT &bslash;&n;&quot;raid1: %s: unrecoverable I/O read error for block %lu&bslash;n&quot;
DECL|macro|REDIRECT_SECTOR
mdefine_line|#define REDIRECT_SECTOR KERN_ERR &bslash;&n;&quot;raid1: %s: redirecting sector %lu to another mirror&bslash;n&quot;
multiline_comment|/*&n; * This is a kernel thread which:&n; *&n; *&t;1.&t;Retries failed read operations on working mirrors.&n; *&t;2.&t;Updates the raid superblock when problems encounter.&n; *&t;3.&t;Performs writes following reads for array syncronising.&n; */
r_static
r_void
id|end_sync_write
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
suffix:semicolon
r_static
r_void
id|end_sync_read
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
suffix:semicolon
DECL|function|raid1d
r_static
r_void
id|raid1d
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|raid1_bh
op_star
id|r1_bh
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|md_spin_lock_irqsave
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
id|r1_bh
op_assign
id|raid1_retry_list
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r1_bh
)paren
r_break
suffix:semicolon
id|raid1_retry_list
op_assign
id|r1_bh-&gt;next_r1
suffix:semicolon
id|md_spin_unlock_irqrestore
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
id|mddev
op_assign
id|r1_bh-&gt;mddev
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;sb_dirty
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;dirty sb detected, updating.&bslash;n&quot;
)paren
suffix:semicolon
id|mddev-&gt;sb_dirty
op_assign
l_int|0
suffix:semicolon
id|md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
id|bh
op_assign
op_amp
id|r1_bh-&gt;bh_req
suffix:semicolon
r_switch
c_cond
(paren
id|r1_bh-&gt;cmd
)paren
(brace
r_case
id|SPECIAL
suffix:colon
multiline_comment|/* have to allocate lots of bh structures and&n;&t;&t;&t; * schedule writes&n;&t;&t;&t; */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|R1BH_Uptodate
comma
op_amp
id|r1_bh-&gt;state
)paren
)paren
(brace
r_int
id|i
comma
id|sum_bhs
op_assign
l_int|0
suffix:semicolon
r_int
id|disks
op_assign
id|MD_SB_DISKS
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bhl
comma
op_star
id|mbh
suffix:semicolon
id|raid1_conf_t
op_star
id|conf
suffix:semicolon
r_int
id|sectors
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|bhl
op_assign
id|raid1_alloc_bh
c_func
(paren
id|conf
comma
id|conf-&gt;raid_disks
)paren
suffix:semicolon
multiline_comment|/* don&squot;t really need this many */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|operational
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|conf-&gt;last_used
)paren
multiline_comment|/* we read from here, no need to write */
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|conf-&gt;raid_disks
op_logical_and
op_logical_neg
id|conf-&gt;resync_mirrors
)paren
multiline_comment|/* don&squot;t need to write this,&n;&t;&t;&t;&t;&t;&t; * we are just rebuilding */
r_continue
suffix:semicolon
id|mbh
op_assign
id|bhl
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mbh
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bhl
op_assign
id|mbh-&gt;b_next
suffix:semicolon
id|mbh-&gt;b_this_page
op_assign
(paren
r_struct
id|buffer_head
op_star
)paren
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * prepare mirrored bh (fields ordered for max mem throughput):&n;&t;&t;&t;&t; */
id|mbh-&gt;b_blocknr
op_assign
id|bh-&gt;b_blocknr
suffix:semicolon
id|mbh-&gt;b_dev
op_assign
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|dev
suffix:semicolon
id|mbh-&gt;b_rdev
op_assign
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|dev
suffix:semicolon
id|mbh-&gt;b_rsector
op_assign
id|bh-&gt;b_blocknr
op_star
id|sectors
suffix:semicolon
id|mbh-&gt;b_state
op_assign
(paren
l_int|1
op_lshift
id|BH_Req
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Dirty
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Mapped
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Lock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|mbh-&gt;b_count
comma
l_int|1
)paren
suffix:semicolon
id|mbh-&gt;b_size
op_assign
id|bh-&gt;b_size
suffix:semicolon
id|mbh-&gt;b_page
op_assign
id|bh-&gt;b_page
suffix:semicolon
id|mbh-&gt;b_data
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|mbh-&gt;b_list
op_assign
id|BUF_LOCKED
suffix:semicolon
id|mbh-&gt;b_end_io
op_assign
id|end_sync_write
suffix:semicolon
id|mbh-&gt;b_private
op_assign
id|r1_bh
suffix:semicolon
id|mbh-&gt;b_next
op_assign
id|r1_bh-&gt;mirror_bh_list
suffix:semicolon
id|r1_bh-&gt;mirror_bh_list
op_assign
id|mbh
suffix:semicolon
id|sum_bhs
op_increment
suffix:semicolon
)brace
id|md_atomic_set
c_func
(paren
op_amp
id|r1_bh-&gt;remaining
comma
id|sum_bhs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bhl
)paren
id|raid1_free_bh
c_func
(paren
id|conf
comma
id|bhl
)paren
suffix:semicolon
id|mbh
op_assign
id|r1_bh-&gt;mirror_bh_list
suffix:semicolon
r_while
c_loop
(paren
id|mbh
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh1
op_assign
id|mbh
suffix:semicolon
id|mbh
op_assign
id|mbh-&gt;b_next
suffix:semicolon
id|generic_make_request
c_func
(paren
id|WRITE
comma
id|bh1
)paren
suffix:semicolon
id|md_sync_acct
c_func
(paren
id|bh1-&gt;b_dev
comma
id|bh1-&gt;b_size
op_div
l_int|512
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|dev
op_assign
id|bh-&gt;b_dev
suffix:semicolon
id|raid1_map
(paren
id|mddev
comma
op_amp
id|bh-&gt;b_dev
comma
id|bh-&gt;b_size
op_rshift
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_eq
id|dev
)paren
(brace
id|printk
(paren
id|IO_ERROR
comma
id|partition_name
c_func
(paren
id|bh-&gt;b_dev
)paren
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
id|md_done_sync
c_func
(paren
id|mddev
comma
id|bh-&gt;b_size
op_rshift
l_int|10
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|REDIRECT_SECTOR
comma
id|partition_name
c_func
(paren
id|bh-&gt;b_dev
)paren
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
id|bh-&gt;b_rdev
op_assign
id|bh-&gt;b_dev
suffix:semicolon
id|generic_make_request
c_func
(paren
id|READ
comma
id|bh
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|READ
suffix:colon
r_case
id|READA
suffix:colon
id|dev
op_assign
id|bh-&gt;b_dev
suffix:semicolon
id|raid1_map
(paren
id|mddev
comma
op_amp
id|bh-&gt;b_dev
comma
id|bh-&gt;b_size
op_rshift
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_eq
id|dev
)paren
(brace
id|printk
(paren
id|IO_ERROR
comma
id|partition_name
c_func
(paren
id|bh-&gt;b_dev
)paren
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
id|raid1_end_bh_io
c_func
(paren
id|r1_bh
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|REDIRECT_SECTOR
comma
id|partition_name
c_func
(paren
id|bh-&gt;b_dev
)paren
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
id|bh-&gt;b_rdev
op_assign
id|bh-&gt;b_dev
suffix:semicolon
id|generic_make_request
(paren
id|r1_bh-&gt;cmd
comma
id|bh
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|md_spin_unlock_irqrestore
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|macro|IO_ERROR
macro_line|#undef IO_ERROR
DECL|macro|REDIRECT_SECTOR
macro_line|#undef REDIRECT_SECTOR
multiline_comment|/*&n; * Private kernel thread to reconstruct mirrors after an unclean&n; * shutdown.&n; */
DECL|function|raid1syncd
r_static
r_void
id|raid1syncd
(paren
r_void
op_star
id|data
)paren
(brace
id|raid1_conf_t
op_star
id|conf
op_assign
id|data
suffix:semicolon
id|mddev_t
op_star
id|mddev
op_assign
id|conf-&gt;mddev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;resync_mirrors
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;resync_mirrors
op_eq
l_int|2
)paren
r_return
suffix:semicolon
id|down
c_func
(paren
op_amp
id|mddev-&gt;recovery_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|md_do_sync
c_func
(paren
id|mddev
comma
l_int|NULL
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Only if everything went Ok.&n;&t;&t; */
id|conf-&gt;resync_mirrors
op_assign
l_int|0
suffix:semicolon
)brace
id|close_sync
c_func
(paren
id|conf
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mddev-&gt;recovery_sem
)paren
suffix:semicolon
id|raid1_shrink_buffers
c_func
(paren
id|conf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * perform a &quot;sync&quot; on one &quot;block&quot;&n; *&n; * We need to make sure that no normal I/O request - particularly write&n; * requests - conflict with active sync requests.&n; * This is achieved by conceptually dividing the device space into a&n; * number of sections:&n; *  DONE: 0 .. a-1     These blocks are in-sync&n; *  ACTIVE: a.. b-1    These blocks may have active sync requests, but&n; *                     no normal IO requests&n; *  READY: b .. c-1    These blocks have no normal IO requests - sync&n; *                     request may be happening&n; *  PENDING: c .. d-1  These blocks may have IO requests, but no new&n; *                     ones will be added&n; *  FUTURE:  d .. end  These blocks are not to be considered yet. IO may&n; *                     be happening, but not sync&n; *&n; * We keep a&n; *   phase    which flips (0 or 1) each time d moves and&n; * a count of:&n; *   z =  active io requests in FUTURE since d moved - marked with&n; *        current phase&n; *   y =  active io requests in FUTURE before d moved, or PENDING -&n; *        marked with previous phase&n; *   x =  active sync requests in READY&n; *   w =  active sync requests in ACTIVE&n; *   v =  active io requests in DONE&n; *&n; * Normally, a=b=c=d=0 and z= active io requests&n; *   or a=b=c=d=END and v= active io requests&n; * Allowed changes to a,b,c,d:&n; * A:  c==d &amp;&amp;  y==0 -&gt; d+=window, y=z, z=0, phase=!phase&n; * B:  y==0 -&gt; c=d&n; * C:   b=c, w+=x, x=0&n; * D:  w==0 -&gt; a=b&n; * E: a==b==c==d==end -&gt; a=b=c=d=0, z=v, v=0&n; *&n; * At start of sync we apply A.&n; * When y reaches 0, we apply B then A then being sync requests&n; * When sync point reaches c-1, we wait for y==0, and W==0, and&n; * then apply apply B then A then D then C.&n; * Finally, we apply E&n; *&n; * The sync request simply issues a &quot;read&quot; against a working drive&n; * This is marked so that on completion the raid1d thread is woken to&n; * issue suitable write requests&n; */
DECL|function|raid1_sync_request
r_static
r_int
id|raid1_sync_request
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
r_int
id|block_nr
)paren
(brace
id|raid1_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_struct
id|mirror_info
op_star
id|mirror
suffix:semicolon
r_struct
id|raid1_bh
op_star
id|r1_bh
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|bsize
suffix:semicolon
r_int
id|disk
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;segment_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|block_nr
)paren
(brace
multiline_comment|/* initialize ...*/
r_int
id|buffs
suffix:semicolon
id|conf-&gt;start_active
op_assign
l_int|0
suffix:semicolon
id|conf-&gt;start_ready
op_assign
l_int|0
suffix:semicolon
id|conf-&gt;start_pending
op_assign
l_int|0
suffix:semicolon
id|conf-&gt;start_future
op_assign
l_int|0
suffix:semicolon
id|conf-&gt;phase
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we want enough buffers to hold twice the window of 128*/
id|buffs
op_assign
l_int|128
op_star
l_int|2
op_div
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
suffix:semicolon
id|buffs
op_assign
id|raid1_grow_buffers
c_func
(paren
id|conf
comma
id|buffs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffs
OL
l_int|2
)paren
r_goto
id|nomem
suffix:semicolon
id|conf-&gt;window
op_assign
id|buffs
op_star
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
op_div
l_int|2
suffix:semicolon
id|conf-&gt;cnt_future
op_add_assign
id|conf-&gt;cnt_done
op_plus
id|conf-&gt;cnt_pending
suffix:semicolon
id|conf-&gt;cnt_done
op_assign
id|conf-&gt;cnt_pending
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;cnt_ready
op_logical_or
id|conf-&gt;cnt_active
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|block_nr
op_lshift
l_int|1
)paren
op_ge
id|conf-&gt;start_pending
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;wait .. sect=%lu start_active=%d ready=%d pending=%d future=%d, cnt_done=%d active=%d ready=%d pending=%d future=%d&bslash;n&quot;
comma
id|block_nr
op_lshift
l_int|1
comma
id|conf-&gt;start_active
comma
id|conf-&gt;start_ready
comma
id|conf-&gt;start_pending
comma
id|conf-&gt;start_future
comma
id|conf-&gt;cnt_done
comma
id|conf-&gt;cnt_active
comma
id|conf-&gt;cnt_ready
comma
id|conf-&gt;cnt_pending
comma
id|conf-&gt;cnt_future
)paren
suffix:semicolon
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_done
comma
op_logical_neg
id|conf-&gt;cnt_active
comma
id|conf-&gt;segment_lock
)paren
suffix:semicolon
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_ready
comma
op_logical_neg
id|conf-&gt;cnt_pending
comma
id|conf-&gt;segment_lock
)paren
suffix:semicolon
id|conf-&gt;start_active
op_assign
id|conf-&gt;start_ready
suffix:semicolon
id|conf-&gt;start_ready
op_assign
id|conf-&gt;start_pending
suffix:semicolon
id|conf-&gt;start_pending
op_assign
id|conf-&gt;start_future
suffix:semicolon
id|conf-&gt;start_future
op_assign
id|conf-&gt;start_future
op_plus
id|conf-&gt;window
suffix:semicolon
singleline_comment|// Note: falling off the end is not a problem
id|conf-&gt;phase
op_assign
id|conf-&gt;phase
op_xor
l_int|1
suffix:semicolon
id|conf-&gt;cnt_active
op_assign
id|conf-&gt;cnt_ready
suffix:semicolon
id|conf-&gt;cnt_ready
op_assign
l_int|0
suffix:semicolon
id|conf-&gt;cnt_pending
op_assign
id|conf-&gt;cnt_future
suffix:semicolon
id|conf-&gt;cnt_future
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_done
)paren
suffix:semicolon
)brace
id|conf-&gt;cnt_ready
op_increment
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;segment_lock
)paren
suffix:semicolon
multiline_comment|/* If reconstructing, and &gt;1 working disc,&n;&t; * could dedicate one to rebuild and others to&n;&t; * service read requests ..&n;&t; */
id|disk
op_assign
id|conf-&gt;last_used
suffix:semicolon
multiline_comment|/* make sure disk is operational */
r_while
c_loop
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|operational
)paren
(brace
r_if
c_cond
(paren
id|disk
op_le
l_int|0
)paren
id|disk
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
id|disk
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|disk
op_eq
id|conf-&gt;last_used
)paren
r_break
suffix:semicolon
)brace
id|conf-&gt;last_used
op_assign
id|disk
suffix:semicolon
id|mirror
op_assign
id|conf-&gt;mirrors
op_plus
id|conf-&gt;last_used
suffix:semicolon
id|r1_bh
op_assign
id|raid1_alloc_buf
(paren
id|conf
)paren
suffix:semicolon
id|r1_bh-&gt;master_bh
op_assign
l_int|NULL
suffix:semicolon
id|r1_bh-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|r1_bh-&gt;cmd
op_assign
id|SPECIAL
suffix:semicolon
id|bh
op_assign
op_amp
id|r1_bh-&gt;bh_req
suffix:semicolon
id|bh-&gt;b_blocknr
op_assign
id|block_nr
suffix:semicolon
id|bsize
op_assign
l_int|1024
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|bh-&gt;b_blocknr
op_amp
l_int|1
)paren
op_logical_and
id|bsize
OL
id|PAGE_SIZE
op_logical_and
(paren
id|bh-&gt;b_blocknr
op_plus
l_int|2
)paren
op_star
(paren
id|bsize
op_rshift
l_int|10
)paren
OL
id|mddev-&gt;sb-&gt;size
)paren
(brace
id|bh-&gt;b_blocknr
op_rshift_assign
l_int|1
suffix:semicolon
id|bsize
op_lshift_assign
l_int|1
suffix:semicolon
)brace
id|bh-&gt;b_size
op_assign
id|bsize
suffix:semicolon
id|bh-&gt;b_list
op_assign
id|BUF_LOCKED
suffix:semicolon
id|bh-&gt;b_dev
op_assign
id|mirror-&gt;dev
suffix:semicolon
id|bh-&gt;b_rdev
op_assign
id|mirror-&gt;dev
suffix:semicolon
id|bh-&gt;b_state
op_assign
(paren
l_int|1
op_lshift
id|BH_Req
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Mapped
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh-&gt;b_page
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh-&gt;b_data
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_data
op_ne
id|page_address
c_func
(paren
id|bh-&gt;b_page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
id|end_sync_read
suffix:semicolon
id|bh-&gt;b_private
op_assign
id|r1_bh
suffix:semicolon
id|bh-&gt;b_rsector
op_assign
id|block_nr
op_lshift
l_int|1
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|bh-&gt;b_wait
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|READ
comma
id|bh
)paren
suffix:semicolon
id|md_sync_acct
c_func
(paren
id|bh-&gt;b_dev
comma
id|bh-&gt;b_size
op_div
l_int|512
)paren
suffix:semicolon
r_return
(paren
id|bsize
op_rshift
l_int|10
)paren
suffix:semicolon
id|nomem
suffix:colon
id|raid1_shrink_buffers
c_func
(paren
id|conf
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;segment_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|end_sync_read
r_static
r_void
id|end_sync_read
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_struct
id|raid1_bh
op_star
id|r1_bh
op_assign
(paren
r_struct
id|raid1_bh
op_star
)paren
(paren
id|bh-&gt;b_private
)paren
suffix:semicolon
multiline_comment|/* we have read a block, now it needs to be re-written,&n;&t; * or re-read if the read failed.&n;&t; * We don&squot;t do much here, just schedule handling by raid1d&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|md_error
(paren
id|mddev_to_kdev
c_func
(paren
id|r1_bh-&gt;mddev
)paren
comma
id|bh-&gt;b_dev
)paren
suffix:semicolon
r_else
id|set_bit
c_func
(paren
id|R1BH_Uptodate
comma
op_amp
id|r1_bh-&gt;state
)paren
suffix:semicolon
id|raid1_reschedule_retry
c_func
(paren
id|r1_bh
)paren
suffix:semicolon
)brace
DECL|function|end_sync_write
r_static
r_void
id|end_sync_write
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_struct
id|raid1_bh
op_star
id|r1_bh
op_assign
(paren
r_struct
id|raid1_bh
op_star
)paren
(paren
id|bh-&gt;b_private
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|md_error
(paren
id|mddev_to_kdev
c_func
(paren
id|r1_bh-&gt;mddev
)paren
comma
id|bh-&gt;b_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|r1_bh-&gt;remaining
)paren
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|r1_bh-&gt;mddev
suffix:semicolon
r_int
r_int
id|sect
op_assign
id|bh-&gt;b_blocknr
op_star
(paren
id|bh-&gt;b_size
op_rshift
l_int|9
)paren
suffix:semicolon
r_int
id|size
op_assign
id|bh-&gt;b_size
suffix:semicolon
id|raid1_free_buf
c_func
(paren
id|r1_bh
)paren
suffix:semicolon
id|sync_request_done
c_func
(paren
id|sect
comma
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|md_done_sync
c_func
(paren
id|mddev
comma
id|size
op_rshift
l_int|10
comma
id|uptodate
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This will catch the scenario in which one of the mirrors was&n; * mounted as a normal device rather than as a part of a raid set.&n; *&n; * check_consistency is very personality-dependent, eg. RAID5 cannot&n; * do this check, it uses another method.&n; */
DECL|function|__check_consistency
r_static
r_int
id|__check_consistency
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|row
)paren
(brace
id|raid1_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|disks
op_assign
id|MD_SB_DISKS
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|rc
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(checking disk %d)&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|operational
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;(really checking disk %d)&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|dev
op_assign
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|dev
suffix:semicolon
id|set_blocksize
c_func
(paren
id|dev
comma
l_int|4096
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
id|row
op_div
l_int|4
comma
l_int|4096
)paren
)paren
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
(brace
id|buffer
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
r_break
suffix:semicolon
id|memcpy
c_func
(paren
id|buffer
comma
id|bh-&gt;b_data
comma
l_int|4096
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|buffer
comma
id|bh-&gt;b_data
comma
l_int|4096
)paren
)paren
(brace
id|rc
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bforget
c_func
(paren
id|bh
)paren
suffix:semicolon
id|fsync_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|dev
)paren
suffix:semicolon
id|bh
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer
)paren
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
id|dev
op_assign
id|bh-&gt;b_dev
suffix:semicolon
id|bforget
c_func
(paren
id|bh
)paren
suffix:semicolon
id|fsync_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|check_consistency
r_static
r_int
id|check_consistency
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_if
c_cond
(paren
id|__check_consistency
c_func
(paren
id|mddev
comma
l_int|0
)paren
)paren
multiline_comment|/*&n; * we do not do this currently, as it&squot;s perfectly possible to&n; * have an inconsistent array when it&squot;s freshly created. Only&n; * newly written data has to be consistent.&n; */
r_return
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|INVALID_LEVEL
mdefine_line|#define INVALID_LEVEL KERN_WARNING &bslash;&n;&quot;raid1: md%d: raid level not set to mirroring (%d)&bslash;n&quot;
DECL|macro|NO_SB
mdefine_line|#define NO_SB KERN_ERR &bslash;&n;&quot;raid1: disabled mirror %s (couldn&squot;t access raid superblock)&bslash;n&quot;
DECL|macro|ERRORS
mdefine_line|#define ERRORS KERN_ERR &bslash;&n;&quot;raid1: disabled mirror %s (errors detected)&bslash;n&quot;
DECL|macro|NOT_IN_SYNC
mdefine_line|#define NOT_IN_SYNC KERN_ERR &bslash;&n;&quot;raid1: disabled mirror %s (not in sync)&bslash;n&quot;
DECL|macro|INCONSISTENT
mdefine_line|#define INCONSISTENT KERN_ERR &bslash;&n;&quot;raid1: disabled mirror %s (inconsistent descriptor)&bslash;n&quot;
DECL|macro|ALREADY_RUNNING
mdefine_line|#define ALREADY_RUNNING KERN_ERR &bslash;&n;&quot;raid1: disabled mirror %s (mirror %d already operational)&bslash;n&quot;
DECL|macro|OPERATIONAL
mdefine_line|#define OPERATIONAL KERN_INFO &bslash;&n;&quot;raid1: device %s operational as mirror %d&bslash;n&quot;
DECL|macro|MEM_ERROR
mdefine_line|#define MEM_ERROR KERN_ERR &bslash;&n;&quot;raid1: couldn&squot;t allocate memory for md%d&bslash;n&quot;
DECL|macro|SPARE
mdefine_line|#define SPARE KERN_INFO &bslash;&n;&quot;raid1: spare disk %s&bslash;n&quot;
DECL|macro|NONE_OPERATIONAL
mdefine_line|#define NONE_OPERATIONAL KERN_ERR &bslash;&n;&quot;raid1: no operational mirrors for md%d&bslash;n&quot;
DECL|macro|RUNNING_CKRAID
mdefine_line|#define RUNNING_CKRAID KERN_ERR &bslash;&n;&quot;raid1: detected mirror differences -- running resync&bslash;n&quot;
DECL|macro|ARRAY_IS_ACTIVE
mdefine_line|#define ARRAY_IS_ACTIVE KERN_INFO &bslash;&n;&quot;raid1: raid set md%d active with %d out of %d mirrors&bslash;n&quot;
DECL|macro|THREAD_ERROR
mdefine_line|#define THREAD_ERROR KERN_ERR &bslash;&n;&quot;raid1: couldn&squot;t allocate thread for md%d&bslash;n&quot;
DECL|macro|START_RESYNC
mdefine_line|#define START_RESYNC KERN_WARNING &bslash;&n;&quot;raid1: raid set md%d not clean; reconstructing mirrors&bslash;n&quot;
DECL|function|raid1_run
r_static
r_int
id|raid1_run
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|raid1_conf_t
op_star
id|conf
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|disk_idx
suffix:semicolon
r_struct
id|mirror_info
op_star
id|disk
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
id|mdp_disk_t
op_star
id|descriptor
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
r_int
id|start_recovery
op_assign
l_int|0
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;level
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|INVALID_LEVEL
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|sb-&gt;level
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * copy the already verified devices into our private RAID1&n;&t; * bookkeeping area. [whatever we allocate in raid1_run(),&n;&t; * should be freed in raid1_stop()]&n;&t; */
id|conf
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|raid1_conf_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
id|conf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf
)paren
(brace
id|printk
c_func
(paren
id|MEM_ERROR
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|memset
c_func
(paren
id|conf
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|conf
)paren
)paren
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|printk
c_func
(paren
id|ERRORS
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|descriptor
op_assign
op_amp
id|sb-&gt;disks
(braket
id|rdev-&gt;desc_nr
)braket
suffix:semicolon
id|disk_idx
op_assign
id|descriptor-&gt;raid_disk
suffix:semicolon
id|disk
op_assign
id|conf-&gt;mirrors
op_plus
id|disk_idx
suffix:semicolon
r_if
c_cond
(paren
id|disk_faulty
c_func
(paren
id|descriptor
)paren
)paren
(brace
id|disk-&gt;number
op_assign
id|descriptor-&gt;number
suffix:semicolon
id|disk-&gt;raid_disk
op_assign
id|disk_idx
suffix:semicolon
id|disk-&gt;dev
op_assign
id|rdev-&gt;dev
suffix:semicolon
id|disk-&gt;sect_limit
op_assign
id|MAX_WORK_PER_DISK
suffix:semicolon
id|disk-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;spare
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;used_slot
op_assign
l_int|1
suffix:semicolon
id|disk-&gt;head_position
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|disk_active
c_func
(paren
id|descriptor
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|disk_sync
c_func
(paren
id|descriptor
)paren
)paren
(brace
id|printk
c_func
(paren
id|NOT_IN_SYNC
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|descriptor-&gt;number
OG
id|MD_SB_DISKS
)paren
op_logical_or
(paren
id|disk_idx
OG
id|sb-&gt;raid_disks
)paren
)paren
(brace
id|printk
c_func
(paren
id|INCONSISTENT
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|disk-&gt;operational
)paren
(brace
id|printk
c_func
(paren
id|ALREADY_RUNNING
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|disk_idx
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
id|OPERATIONAL
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|disk_idx
)paren
suffix:semicolon
id|disk-&gt;number
op_assign
id|descriptor-&gt;number
suffix:semicolon
id|disk-&gt;raid_disk
op_assign
id|disk_idx
suffix:semicolon
id|disk-&gt;dev
op_assign
id|rdev-&gt;dev
suffix:semicolon
id|disk-&gt;sect_limit
op_assign
id|MAX_WORK_PER_DISK
suffix:semicolon
id|disk-&gt;operational
op_assign
l_int|1
suffix:semicolon
id|disk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;spare
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;used_slot
op_assign
l_int|1
suffix:semicolon
id|disk-&gt;head_position
op_assign
l_int|0
suffix:semicolon
id|conf-&gt;working_disks
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Must be a spare disk ..&n;&t;&t; */
id|printk
c_func
(paren
id|SPARE
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
id|disk-&gt;number
op_assign
id|descriptor-&gt;number
suffix:semicolon
id|disk-&gt;raid_disk
op_assign
id|disk_idx
suffix:semicolon
id|disk-&gt;dev
op_assign
id|rdev-&gt;dev
suffix:semicolon
id|disk-&gt;sect_limit
op_assign
id|MAX_WORK_PER_DISK
suffix:semicolon
id|disk-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;spare
op_assign
l_int|1
suffix:semicolon
id|disk-&gt;used_slot
op_assign
l_int|1
suffix:semicolon
id|disk-&gt;head_position
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|conf-&gt;raid_disks
op_assign
id|sb-&gt;raid_disks
suffix:semicolon
id|conf-&gt;nr_disks
op_assign
id|sb-&gt;nr_disks
suffix:semicolon
id|conf-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|conf-&gt;device_lock
op_assign
id|MD_SPIN_LOCK_UNLOCKED
suffix:semicolon
id|conf-&gt;segment_lock
op_assign
id|MD_SPIN_LOCK_UNLOCKED
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|conf-&gt;wait_buffer
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|conf-&gt;wait_done
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|conf-&gt;wait_ready
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;working_disks
)paren
(brace
id|printk
c_func
(paren
id|NONE_OPERATIONAL
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out_free_conf
suffix:semicolon
)brace
multiline_comment|/* pre-allocate some buffer_head structures.&n;&t; * As a minimum, 1 r1bh and raid_disks buffer_heads&n;&t; * would probably get us by in tight memory situations,&n;&t; * but a few more is probably a good idea.&n;&t; * For now, try 16 r1bh and 16*raid_disks bufferheads&n;&t; * This will allow at least 16 concurrent reads or writes&n;&t; * even if kmalloc starts failing&n;&t; */
r_if
c_cond
(paren
id|raid1_grow_r1bh
c_func
(paren
id|conf
comma
l_int|16
)paren
OL
l_int|16
op_logical_or
id|raid1_grow_bh
c_func
(paren
id|conf
comma
l_int|16
op_star
id|conf-&gt;raid_disks
)paren
OL
l_int|16
op_star
id|conf-&gt;raid_disks
)paren
(brace
id|printk
c_func
(paren
id|MEM_ERROR
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out_free_conf
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|descriptor
op_assign
id|sb-&gt;disks
op_plus
id|i
suffix:semicolon
id|disk_idx
op_assign
id|descriptor-&gt;raid_disk
suffix:semicolon
id|disk
op_assign
id|conf-&gt;mirrors
op_plus
id|disk_idx
suffix:semicolon
r_if
c_cond
(paren
id|disk_faulty
c_func
(paren
id|descriptor
)paren
op_logical_and
(paren
id|disk_idx
OL
id|conf-&gt;raid_disks
)paren
op_logical_and
op_logical_neg
id|disk-&gt;used_slot
)paren
(brace
id|disk-&gt;number
op_assign
id|descriptor-&gt;number
suffix:semicolon
id|disk-&gt;raid_disk
op_assign
id|disk_idx
suffix:semicolon
id|disk-&gt;dev
op_assign
id|MKDEV
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|disk-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;spare
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;used_slot
op_assign
l_int|1
suffix:semicolon
id|disk-&gt;head_position
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * find the first working one and use it as a starting point&n;&t; * to read balancing.&n;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|conf-&gt;mirrors
(braket
id|j
)braket
dot
id|operational
op_logical_and
id|j
OL
id|MD_SB_DISKS
suffix:semicolon
id|j
op_increment
)paren
multiline_comment|/* nothing */
suffix:semicolon
id|conf-&gt;last_used
op_assign
id|j
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;working_disks
op_ne
id|sb-&gt;raid_disks
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;raid1: md%d, not all disks are operational -- trying to recover array&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|start_recovery
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|start_recovery
op_logical_and
(paren
id|sb-&gt;state
op_amp
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * we do sanity checks even if the device says&n;&t;&t; * it&squot;s clean ...&n;&t;&t; */
r_if
c_cond
(paren
id|check_consistency
c_func
(paren
id|mddev
)paren
)paren
(brace
id|printk
c_func
(paren
id|RUNNING_CKRAID
)paren
suffix:semicolon
id|sb-&gt;state
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
suffix:semicolon
)brace
)brace
(brace
r_const
r_char
op_star
id|name
op_assign
l_string|&quot;raid1d&quot;
suffix:semicolon
id|conf-&gt;thread
op_assign
id|md_register_thread
c_func
(paren
id|raid1d
comma
id|conf
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;thread
)paren
(brace
id|printk
c_func
(paren
id|THREAD_ERROR
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out_free_conf
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|start_recovery
op_logical_and
op_logical_neg
(paren
id|sb-&gt;state
op_amp
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
)paren
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
l_string|&quot;raid1syncd&quot;
suffix:semicolon
id|conf-&gt;resync_thread
op_assign
id|md_register_thread
c_func
(paren
id|raid1syncd
comma
id|conf
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;resync_thread
)paren
(brace
id|printk
c_func
(paren
id|THREAD_ERROR
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out_free_conf
suffix:semicolon
)brace
id|printk
c_func
(paren
id|START_RESYNC
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|conf-&gt;resync_mirrors
op_assign
l_int|1
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|conf-&gt;resync_thread
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Regenerate the &quot;device is in sync with the raid set&quot; bit for&n;&t; * each device.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mark_disk_nonsync
c_func
(paren
id|sb-&gt;disks
op_plus
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sb-&gt;raid_disks
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|j
)braket
dot
id|operational
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;disks
(braket
id|i
)braket
dot
id|number
op_eq
id|conf-&gt;mirrors
(braket
id|j
)braket
dot
id|number
)paren
id|mark_disk_sync
c_func
(paren
id|sb-&gt;disks
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
id|sb-&gt;active_disks
op_assign
id|conf-&gt;working_disks
suffix:semicolon
r_if
c_cond
(paren
id|start_recovery
)paren
id|md_recover_arrays
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|ARRAY_IS_ACTIVE
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|sb-&gt;active_disks
comma
id|sb-&gt;raid_disks
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, everything is just fine now&n;&t; */
r_return
l_int|0
suffix:semicolon
id|out_free_conf
suffix:colon
id|raid1_shrink_r1bh
c_func
(paren
id|conf
)paren
suffix:semicolon
id|raid1_shrink_bh
c_func
(paren
id|conf
comma
id|conf-&gt;freebh_cnt
)paren
suffix:semicolon
id|raid1_shrink_buffers
c_func
(paren
id|conf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|conf
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
id|out
suffix:colon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
DECL|macro|INVALID_LEVEL
macro_line|#undef INVALID_LEVEL
DECL|macro|NO_SB
macro_line|#undef NO_SB
DECL|macro|ERRORS
macro_line|#undef ERRORS
DECL|macro|NOT_IN_SYNC
macro_line|#undef NOT_IN_SYNC
DECL|macro|INCONSISTENT
macro_line|#undef INCONSISTENT
DECL|macro|ALREADY_RUNNING
macro_line|#undef ALREADY_RUNNING
DECL|macro|OPERATIONAL
macro_line|#undef OPERATIONAL
DECL|macro|SPARE
macro_line|#undef SPARE
DECL|macro|NONE_OPERATIONAL
macro_line|#undef NONE_OPERATIONAL
DECL|macro|RUNNING_CKRAID
macro_line|#undef RUNNING_CKRAID
DECL|macro|ARRAY_IS_ACTIVE
macro_line|#undef ARRAY_IS_ACTIVE
DECL|function|raid1_stop_resync
r_static
r_int
id|raid1_stop_resync
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|raid1_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;resync_thread
)paren
(brace
r_if
c_cond
(paren
id|conf-&gt;resync_mirrors
)paren
(brace
id|conf-&gt;resync_mirrors
op_assign
l_int|2
suffix:semicolon
id|md_interrupt_thread
c_func
(paren
id|conf-&gt;resync_thread
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;raid1: mirror resync was not fully finished, restarting next time.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|raid1_restart_resync
r_static
r_int
id|raid1_restart_resync
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|raid1_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;resync_mirrors
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;resync_thread
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|conf-&gt;resync_mirrors
op_assign
l_int|1
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|conf-&gt;resync_thread
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|raid1_stop
r_static
r_int
id|raid1_stop
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|raid1_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|md_unregister_thread
c_func
(paren
id|conf-&gt;thread
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;resync_thread
)paren
id|md_unregister_thread
c_func
(paren
id|conf-&gt;resync_thread
)paren
suffix:semicolon
id|raid1_shrink_r1bh
c_func
(paren
id|conf
)paren
suffix:semicolon
id|raid1_shrink_bh
c_func
(paren
id|conf
comma
id|conf-&gt;freebh_cnt
)paren
suffix:semicolon
id|raid1_shrink_buffers
c_func
(paren
id|conf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|conf
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|raid1_personality
r_static
id|mdk_personality_t
id|raid1_personality
op_assign
(brace
id|name
suffix:colon
l_string|&quot;raid1&quot;
comma
id|make_request
suffix:colon
id|raid1_make_request
comma
id|run
suffix:colon
id|raid1_run
comma
id|stop
suffix:colon
id|raid1_stop
comma
id|status
suffix:colon
id|raid1_status
comma
id|error_handler
suffix:colon
id|raid1_error
comma
id|diskop
suffix:colon
id|raid1_diskop
comma
id|stop_resync
suffix:colon
id|raid1_stop_resync
comma
id|restart_resync
suffix:colon
id|raid1_restart_resync
comma
id|sync_request
suffix:colon
id|raid1_sync_request
)brace
suffix:semicolon
DECL|function|raid1_init
r_static
r_int
id|md__init
id|raid1_init
(paren
r_void
)paren
(brace
r_return
id|register_md_personality
(paren
id|RAID1
comma
op_amp
id|raid1_personality
)paren
suffix:semicolon
)brace
DECL|function|raid1_exit
r_static
r_void
id|raid1_exit
(paren
r_void
)paren
(brace
id|unregister_md_personality
(paren
id|RAID1
)paren
suffix:semicolon
)brace
DECL|variable|raid1_init
id|module_init
c_func
(paren
id|raid1_init
)paren
suffix:semicolon
DECL|variable|raid1_exit
id|module_exit
c_func
(paren
id|raid1_exit
)paren
suffix:semicolon
eof
