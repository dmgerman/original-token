multiline_comment|/*&n; * raid5.c : Multiple Devices driver for Linux&n; *&t;   Copyright (C) 1996, 1997 Ingo Molnar, Miguel de Icaza, Gadi Oxman&n; *&t;   Copyright (C) 1999, 2000 Ingo Molnar&n; *&n; * RAID-5 management functions.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * You should have received a copy of the GNU General Public License&n; * (for example /usr/src/linux/COPYING); if not, write to the Free&n; * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/raid/raid5.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
DECL|variable|raid5_personality
r_static
id|mdk_personality_t
id|raid5_personality
suffix:semicolon
multiline_comment|/*&n; * Stripe cache&n; */
DECL|macro|NR_STRIPES
mdefine_line|#define NR_STRIPES&t;&t;256
DECL|macro|HASH_PAGES
mdefine_line|#define HASH_PAGES&t;&t;1
DECL|macro|HASH_PAGES_ORDER
mdefine_line|#define HASH_PAGES_ORDER&t;0
DECL|macro|NR_HASH
mdefine_line|#define NR_HASH&t;&t;&t;(HASH_PAGES * PAGE_SIZE / sizeof(struct stripe_head *))
DECL|macro|HASH_MASK
mdefine_line|#define HASH_MASK&t;&t;(NR_HASH - 1)
DECL|macro|stripe_hash
mdefine_line|#define stripe_hash(conf, sect)&t;((conf)-&gt;stripe_hashtbl[((sect) / ((conf)-&gt;buffer_size &gt;&gt; 9)) &amp; HASH_MASK])
multiline_comment|/*&n; * The following can be used to debug the driver&n; */
DECL|macro|RAID5_DEBUG
mdefine_line|#define RAID5_DEBUG&t;0
DECL|macro|RAID5_PARANOIA
mdefine_line|#define RAID5_PARANOIA&t;1
macro_line|#if RAID5_PARANOIA &amp;&amp; CONFIG_SMP
DECL|macro|CHECK_DEVLOCK
macro_line|# define CHECK_DEVLOCK() if (!spin_is_locked(&amp;conf-&gt;device_lock)) BUG()
macro_line|#else
DECL|macro|CHECK_DEVLOCK
macro_line|# define CHECK_DEVLOCK()
macro_line|#endif
macro_line|#if RAID5_DEBUG
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x...) printk(x)
DECL|macro|inline
mdefine_line|#define inline
DECL|macro|__inline__
mdefine_line|#define __inline__
macro_line|#else
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x...) do { } while (0)
macro_line|#endif
r_static
r_void
id|print_raid5_conf
(paren
id|raid5_conf_t
op_star
id|conf
)paren
suffix:semicolon
DECL|function|__release_stripe
r_static
r_inline
r_void
id|__release_stripe
c_func
(paren
id|raid5_conf_t
op_star
id|conf
comma
r_struct
id|stripe_head
op_star
id|sh
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|sh-&gt;count
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sh-&gt;lru
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|conf-&gt;active_stripes
)paren
op_eq
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|STRIPE_HANDLE
comma
op_amp
id|sh-&gt;state
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|sh-&gt;lru
comma
op_amp
id|conf-&gt;handle_list
)paren
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|conf-&gt;thread
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_add_tail
c_func
(paren
op_amp
id|sh-&gt;lru
comma
op_amp
id|conf-&gt;inactive_list
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|conf-&gt;active_stripes
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_for_stripe
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|release_stripe
r_static
r_void
id|release_stripe
c_func
(paren
r_struct
id|stripe_head
op_star
id|sh
)paren
(brace
id|raid5_conf_t
op_star
id|conf
op_assign
id|sh-&gt;raid_conf
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|__release_stripe
c_func
(paren
id|conf
comma
id|sh
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
)brace
DECL|function|remove_hash
r_static
r_void
id|remove_hash
c_func
(paren
r_struct
id|stripe_head
op_star
id|sh
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;remove_hash(), stripe %lu&bslash;n&quot;
comma
id|sh-&gt;sector
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh-&gt;hash_pprev
)paren
(brace
r_if
c_cond
(paren
id|sh-&gt;hash_next
)paren
id|sh-&gt;hash_next-&gt;hash_pprev
op_assign
id|sh-&gt;hash_pprev
suffix:semicolon
op_star
id|sh-&gt;hash_pprev
op_assign
id|sh-&gt;hash_next
suffix:semicolon
id|sh-&gt;hash_pprev
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|insert_hash
r_static
id|__inline__
r_void
id|insert_hash
c_func
(paren
id|raid5_conf_t
op_star
id|conf
comma
r_struct
id|stripe_head
op_star
id|sh
)paren
(brace
r_struct
id|stripe_head
op_star
op_star
id|shp
op_assign
op_amp
id|stripe_hash
c_func
(paren
id|conf
comma
id|sh-&gt;sector
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;insert_hash(), stripe %lu&bslash;n&quot;
comma
id|sh-&gt;sector
)paren
suffix:semicolon
id|CHECK_DEVLOCK
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sh-&gt;hash_next
op_assign
op_star
id|shp
)paren
op_ne
l_int|NULL
)paren
(paren
op_star
id|shp
)paren
op_member_access_from_pointer
id|hash_pprev
op_assign
op_amp
id|sh-&gt;hash_next
suffix:semicolon
op_star
id|shp
op_assign
id|sh
suffix:semicolon
id|sh-&gt;hash_pprev
op_assign
id|shp
suffix:semicolon
)brace
multiline_comment|/* find an idle stripe, make sure it is unhashed, and return it. */
DECL|function|get_free_stripe
r_static
r_struct
id|stripe_head
op_star
id|get_free_stripe
c_func
(paren
id|raid5_conf_t
op_star
id|conf
)paren
(brace
r_struct
id|stripe_head
op_star
id|sh
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|first
suffix:semicolon
id|CHECK_DEVLOCK
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|conf-&gt;inactive_list
)paren
)paren
r_goto
id|out
suffix:semicolon
id|first
op_assign
id|conf-&gt;inactive_list.next
suffix:semicolon
id|sh
op_assign
id|list_entry
c_func
(paren
id|first
comma
r_struct
id|stripe_head
comma
id|lru
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
id|first
)paren
suffix:semicolon
id|remove_hash
c_func
(paren
id|sh
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;active_stripes
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|sh
suffix:semicolon
)brace
DECL|function|shrink_buffers
r_static
r_void
id|shrink_buffers
c_func
(paren
r_struct
id|stripe_head
op_star
id|sh
comma
r_int
id|num
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bh
op_assign
id|sh-&gt;bh_cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_return
suffix:semicolon
id|sh-&gt;bh_cache
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|bh-&gt;b_data
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
DECL|function|grow_buffers
r_static
r_int
id|grow_buffers
c_func
(paren
r_struct
id|stripe_head
op_star
id|sh
comma
r_int
id|num
comma
r_int
id|b_size
comma
r_int
id|priority
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|bh
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|buffer_head
)paren
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_return
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|bh
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|buffer_head
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|bh-&gt;b_wait
)paren
suffix:semicolon
id|page
op_assign
id|alloc_page
c_func
(paren
id|priority
)paren
suffix:semicolon
id|bh-&gt;b_data
op_assign
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh-&gt;b_data
)paren
(brace
id|kfree
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
id|bh-&gt;b_count
comma
l_int|0
)paren
suffix:semicolon
id|bh-&gt;b_page
op_assign
id|page
suffix:semicolon
id|sh-&gt;bh_cache
(braket
id|i
)braket
op_assign
id|bh
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|buffer_head
op_star
id|raid5_build_block
(paren
r_struct
id|stripe_head
op_star
id|sh
comma
r_int
id|i
)paren
suffix:semicolon
DECL|function|init_stripe
r_static
r_inline
r_void
id|init_stripe
c_func
(paren
r_struct
id|stripe_head
op_star
id|sh
comma
r_int
r_int
id|sector
)paren
(brace
id|raid5_conf_t
op_star
id|conf
op_assign
id|sh-&gt;raid_conf
suffix:semicolon
r_int
id|disks
op_assign
id|conf-&gt;raid_disks
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sh-&gt;count
)paren
op_ne
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|STRIPE_HANDLE
comma
op_amp
id|sh-&gt;state
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|CHECK_DEVLOCK
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;init_stripe called, stripe %lu&bslash;n&quot;
comma
id|sh-&gt;sector
)paren
suffix:semicolon
id|remove_hash
c_func
(paren
id|sh
)paren
suffix:semicolon
id|sh-&gt;sector
op_assign
id|sector
suffix:semicolon
id|sh-&gt;size
op_assign
id|conf-&gt;buffer_size
suffix:semicolon
id|sh-&gt;state
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|disks
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|sh-&gt;bh_read
(braket
id|i
)braket
op_logical_or
id|sh-&gt;bh_write
(braket
id|i
)braket
op_logical_or
id|sh-&gt;bh_written
(braket
id|i
)braket
op_logical_or
id|buffer_locked
c_func
(paren
id|sh-&gt;bh_cache
(braket
id|i
)braket
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sector=%lx i=%d %p %p %p %d&bslash;n&quot;
comma
id|sh-&gt;sector
comma
id|i
comma
id|sh-&gt;bh_read
(braket
id|i
)braket
comma
id|sh-&gt;bh_write
(braket
id|i
)braket
comma
id|sh-&gt;bh_written
(braket
id|i
)braket
comma
id|buffer_locked
c_func
(paren
id|sh-&gt;bh_cache
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|sh-&gt;bh_cache
(braket
id|i
)braket
op_member_access_from_pointer
id|b_state
)paren
suffix:semicolon
id|raid5_build_block
c_func
(paren
id|sh
comma
id|i
)paren
suffix:semicolon
)brace
id|insert_hash
c_func
(paren
id|conf
comma
id|sh
)paren
suffix:semicolon
)brace
multiline_comment|/* the buffer size has changed, so unhash all stripes&n; * as active stripes complete, they will go onto inactive list&n; */
DECL|function|shrink_stripe_cache
r_static
r_void
id|shrink_stripe_cache
c_func
(paren
id|raid5_conf_t
op_star
id|conf
)paren
(brace
r_int
id|i
suffix:semicolon
id|CHECK_DEVLOCK
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|conf-&gt;active_stripes
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HASH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|stripe_head
op_star
id|sh
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sh
op_assign
id|conf-&gt;stripe_hashtbl
(braket
id|i
)braket
)paren
)paren
id|remove_hash
c_func
(paren
id|sh
)paren
suffix:semicolon
)brace
)brace
DECL|function|__find_stripe
r_static
r_struct
id|stripe_head
op_star
id|__find_stripe
c_func
(paren
id|raid5_conf_t
op_star
id|conf
comma
r_int
r_int
id|sector
)paren
(brace
r_struct
id|stripe_head
op_star
id|sh
suffix:semicolon
id|CHECK_DEVLOCK
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;__find_stripe, sector %lu&bslash;n&quot;
comma
id|sector
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sh
op_assign
id|stripe_hash
c_func
(paren
id|conf
comma
id|sector
)paren
suffix:semicolon
id|sh
suffix:semicolon
id|sh
op_assign
id|sh-&gt;hash_next
)paren
r_if
c_cond
(paren
id|sh-&gt;sector
op_eq
id|sector
)paren
r_return
id|sh
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;__stripe %lu not in cache&bslash;n&quot;
comma
id|sector
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|get_active_stripe
r_static
r_struct
id|stripe_head
op_star
id|get_active_stripe
c_func
(paren
id|raid5_conf_t
op_star
id|conf
comma
r_int
r_int
id|sector
comma
r_int
id|size
comma
r_int
id|noblock
)paren
(brace
r_struct
id|stripe_head
op_star
id|sh
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;get_stripe, sector %lu&bslash;n&quot;
comma
id|sector
)paren
suffix:semicolon
id|md_spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|conf-&gt;buffer_size
op_eq
l_int|0
op_logical_or
(paren
id|size
op_logical_and
id|size
op_ne
id|conf-&gt;buffer_size
)paren
)paren
(brace
multiline_comment|/* either the size is being changed (buffer_size==0) or&n;&t;&t;&t; * we need to change it.&n;&t;&t;&t; * If size==0, we can proceed as soon as buffer_size gets set.&n;&t;&t;&t; * If size&gt;0, we can proceed when active_stripes reaches 0, or&n;&t;&t;&t; * when someone else sets the buffer_size to size.&n;&t;&t;&t; * If someone sets the buffer size to something else, we will need to&n;&t;&t;&t; * assert that we want to change it again&n;&t;&t;&t; */
r_int
id|oldsize
op_assign
id|conf-&gt;buffer_size
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;get_stripe %ld/%d buffer_size is %d, %d active&bslash;n&quot;
comma
id|sector
comma
id|size
comma
id|conf-&gt;buffer_size
comma
id|atomic_read
c_func
(paren
op_amp
id|conf-&gt;active_stripes
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_for_stripe
comma
id|conf-&gt;buffer_size
comma
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_else
(brace
r_while
c_loop
(paren
id|conf-&gt;buffer_size
op_ne
id|size
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|conf-&gt;active_stripes
)paren
)paren
(brace
id|conf-&gt;buffer_size
op_assign
l_int|0
suffix:semicolon
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_for_stripe
comma
id|atomic_read
c_func
(paren
op_amp
id|conf-&gt;active_stripes
)paren
op_eq
l_int|0
op_logical_or
id|conf-&gt;buffer_size
comma
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;waited and now  %ld/%d buffer_size is %d - %d active&bslash;n&quot;
comma
id|sector
comma
id|size
comma
id|conf-&gt;buffer_size
comma
id|atomic_read
c_func
(paren
op_amp
id|conf-&gt;active_stripes
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|conf-&gt;buffer_size
op_ne
id|size
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;raid5: switching cache buffer size, %d --&gt; %d&bslash;n&quot;
comma
id|oldsize
comma
id|size
)paren
suffix:semicolon
id|shrink_stripe_cache
c_func
(paren
id|conf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|conf-&gt;buffer_size
op_assign
id|size
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;size now %d&bslash;n&quot;
comma
id|conf-&gt;buffer_size
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
id|sector
op_sub_assign
id|sector
op_amp
(paren
(paren
id|conf-&gt;buffer_size
op_rshift
l_int|9
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|sh
op_assign
id|__find_stripe
c_func
(paren
id|conf
comma
id|sector
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sh
)paren
(brace
id|sh
op_assign
id|get_free_stripe
c_func
(paren
id|conf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|noblock
op_logical_and
id|sh
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sh
)paren
(brace
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_for_stripe
comma
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|conf-&gt;inactive_list
)paren
comma
id|conf-&gt;device_lock
)paren
suffix:semicolon
)brace
r_else
id|init_stripe
c_func
(paren
id|sh
comma
id|sector
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sh-&gt;count
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sh-&gt;lru
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|STRIPE_HANDLE
comma
op_amp
id|sh-&gt;state
)paren
)paren
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;active_stripes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|sh-&gt;lru
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|sh-&gt;lru
)paren
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|sh
op_eq
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh
)paren
id|atomic_inc
c_func
(paren
op_amp
id|sh-&gt;count
)paren
suffix:semicolon
id|md_spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_return
id|sh
suffix:semicolon
)brace
DECL|function|grow_stripes
r_static
r_int
id|grow_stripes
c_func
(paren
id|raid5_conf_t
op_star
id|conf
comma
r_int
id|num
comma
r_int
id|priority
)paren
(brace
r_struct
id|stripe_head
op_star
id|sh
suffix:semicolon
r_while
c_loop
(paren
id|num
op_decrement
)paren
(brace
id|sh
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|stripe_head
)paren
comma
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sh
)paren
r_return
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|sh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|sh
)paren
)paren
suffix:semicolon
id|sh-&gt;raid_conf
op_assign
id|conf
suffix:semicolon
id|sh-&gt;lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_if
c_cond
(paren
id|grow_buffers
c_func
(paren
id|sh
comma
id|conf-&gt;raid_disks
comma
id|PAGE_SIZE
comma
id|priority
)paren
)paren
(brace
id|shrink_buffers
c_func
(paren
id|sh
comma
id|conf-&gt;raid_disks
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* we just created an active stripe so... */
id|atomic_set
c_func
(paren
op_amp
id|sh-&gt;count
comma
l_int|1
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;active_stripes
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sh-&gt;lru
)paren
suffix:semicolon
id|release_stripe
c_func
(paren
id|sh
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shrink_stripes
r_static
r_void
id|shrink_stripes
c_func
(paren
id|raid5_conf_t
op_star
id|conf
comma
r_int
id|num
)paren
(brace
r_struct
id|stripe_head
op_star
id|sh
suffix:semicolon
r_while
c_loop
(paren
id|num
op_decrement
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|sh
op_assign
id|get_free_stripe
c_func
(paren
id|conf
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sh
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sh-&gt;count
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|shrink_buffers
c_func
(paren
id|sh
comma
id|conf-&gt;raid_disks
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sh
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|conf-&gt;active_stripes
)paren
suffix:semicolon
)brace
)brace
DECL|function|raid5_end_buffer_read
r_static
r_inline
r_void
id|raid5_end_buffer_read
c_func
(paren
r_struct
id|buffer_head
op_star
id|blist
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_while
c_loop
(paren
id|blist
)paren
(brace
r_struct
id|buffer_head
op_star
r_new
op_assign
id|blist
suffix:semicolon
id|blist
op_assign
r_new
op_member_access_from_pointer
id|b_reqnext
suffix:semicolon
id|memcpy
c_func
(paren
r_new
op_member_access_from_pointer
id|b_data
comma
id|bh-&gt;b_data
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|b_end_io
c_func
(paren
r_new
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
DECL|function|raid5_end_read_request
r_static
r_void
id|raid5_end_read_request
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_struct
id|stripe_head
op_star
id|sh
op_assign
id|bh-&gt;b_private
suffix:semicolon
id|raid5_conf_t
op_star
id|conf
op_assign
id|sh-&gt;raid_conf
suffix:semicolon
r_int
id|disks
op_assign
id|conf-&gt;raid_disks
comma
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|buffer_head
op_star
id|buffers
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|bh
op_eq
id|sh-&gt;bh_cache
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;end_read_request %lu/%d,  %d, count: %d, uptodate %d.&bslash;n&quot;
comma
id|sh-&gt;sector
comma
id|i
comma
id|atomic_read
c_func
(paren
op_amp
id|sh-&gt;count
)paren
comma
id|uptodate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|disks
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|md_spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uptodate
)paren
(brace
macro_line|#ifdef CONFIG_HIGHMEM
multiline_comment|/* cannot map highmem bufferheads from irq,&n;&t;&t; * so leave it for stripe_handle if there might&n;&t;&t; * be a problem&n;&t;&t; */
r_if
c_cond
(paren
id|sh-&gt;bh_read
(braket
id|i
)braket
op_logical_and
id|sh-&gt;bh_read
(braket
id|i
)braket
op_member_access_from_pointer
id|b_reqnext
op_eq
l_int|NULL
op_logical_and
op_logical_neg
id|PageHighMem
c_func
(paren
id|sh-&gt;bh_read
(braket
id|i
)braket
op_member_access_from_pointer
id|b_page
)paren
)paren
(brace
multiline_comment|/* it&squot;s safe */
id|buffers
op_assign
id|sh-&gt;bh_read
(braket
id|i
)braket
suffix:semicolon
id|sh-&gt;bh_read
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#else
id|buffers
op_assign
id|sh-&gt;bh_read
(braket
id|i
)braket
suffix:semicolon
id|sh-&gt;bh_read
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|set_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffers
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
id|raid5_end_buffer_read
c_func
(paren
id|buffers
comma
id|bh
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|md_error
c_func
(paren
id|mddev_to_kdev
c_func
(paren
id|conf-&gt;mddev
)paren
comma
id|bh-&gt;b_dev
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|BH_Lock
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|STRIPE_HANDLE
comma
op_amp
id|sh-&gt;state
)paren
suffix:semicolon
id|__release_stripe
c_func
(paren
id|conf
comma
id|sh
)paren
suffix:semicolon
id|md_spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|raid5_end_write_request
r_static
r_void
id|raid5_end_write_request
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_struct
id|stripe_head
op_star
id|sh
op_assign
id|bh-&gt;b_private
suffix:semicolon
id|raid5_conf_t
op_star
id|conf
op_assign
id|sh-&gt;raid_conf
suffix:semicolon
r_int
id|disks
op_assign
id|conf-&gt;raid_disks
comma
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|bh
op_eq
id|sh-&gt;bh_cache
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;end_write_request %lu/%d, count %d, uptodate: %d.&bslash;n&quot;
comma
id|sh-&gt;sector
comma
id|i
comma
id|atomic_read
c_func
(paren
op_amp
id|sh-&gt;count
)paren
comma
id|uptodate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|disks
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|md_spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|md_error
c_func
(paren
id|mddev_to_kdev
c_func
(paren
id|conf-&gt;mddev
)paren
comma
id|bh-&gt;b_dev
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Lock
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|STRIPE_HANDLE
comma
op_amp
id|sh-&gt;state
)paren
suffix:semicolon
id|__release_stripe
c_func
(paren
id|conf
comma
id|sh
)paren
suffix:semicolon
id|md_spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|raid5_build_block
r_static
r_struct
id|buffer_head
op_star
id|raid5_build_block
(paren
r_struct
id|stripe_head
op_star
id|sh
comma
r_int
id|i
)paren
(brace
id|raid5_conf_t
op_star
id|conf
op_assign
id|sh-&gt;raid_conf
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|sh-&gt;bh_cache
(braket
id|i
)braket
suffix:semicolon
r_int
r_int
id|block
op_assign
id|sh-&gt;sector
op_div
(paren
id|sh-&gt;size
op_rshift
l_int|9
)paren
suffix:semicolon
id|init_buffer
c_func
(paren
id|bh
comma
id|raid5_end_read_request
comma
id|sh
)paren
suffix:semicolon
id|bh-&gt;b_dev
op_assign
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|dev
suffix:semicolon
id|bh-&gt;b_blocknr
op_assign
id|block
suffix:semicolon
id|bh-&gt;b_state
op_assign
(paren
l_int|1
op_lshift
id|BH_Req
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Mapped
)paren
suffix:semicolon
id|bh-&gt;b_size
op_assign
id|sh-&gt;size
suffix:semicolon
id|bh-&gt;b_list
op_assign
id|BUF_LOCKED
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
DECL|function|raid5_error
r_static
r_int
id|raid5_error
(paren
id|mddev_t
op_star
id|mddev
comma
id|kdev_t
id|dev
)paren
(brace
id|raid5_conf_t
op_star
id|conf
op_assign
(paren
id|raid5_conf_t
op_star
)paren
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
r_struct
id|disk_info
op_star
id|disk
suffix:semicolon
r_int
id|i
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;raid5_error called&bslash;n&quot;
)paren
suffix:semicolon
id|conf-&gt;resync_parity
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|disk
op_assign
id|conf-&gt;disks
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
comma
id|disk
op_increment
)paren
(brace
r_if
c_cond
(paren
id|disk-&gt;dev
op_eq
id|dev
op_logical_and
id|disk-&gt;operational
)paren
(brace
id|disk-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|mark_disk_faulty
c_func
(paren
id|sb-&gt;disks
op_plus
id|disk-&gt;number
)paren
suffix:semicolon
id|mark_disk_nonsync
c_func
(paren
id|sb-&gt;disks
op_plus
id|disk-&gt;number
)paren
suffix:semicolon
id|mark_disk_inactive
c_func
(paren
id|sb-&gt;disks
op_plus
id|disk-&gt;number
)paren
suffix:semicolon
id|sb-&gt;active_disks
op_decrement
suffix:semicolon
id|sb-&gt;working_disks
op_decrement
suffix:semicolon
id|sb-&gt;failed_disks
op_increment
suffix:semicolon
id|mddev-&gt;sb_dirty
op_assign
l_int|1
suffix:semicolon
id|conf-&gt;working_disks
op_decrement
suffix:semicolon
id|conf-&gt;failed_disks
op_increment
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|conf-&gt;thread
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ALERT
l_string|&quot;raid5: Disk failure on %s, disabling device.&quot;
l_string|&quot; Operation continuing on %d devices&bslash;n&quot;
comma
id|partition_name
(paren
id|dev
)paren
comma
id|conf-&gt;working_disks
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * handle errors in spares (during reconstruction)&n;&t; */
r_if
c_cond
(paren
id|conf-&gt;spare
)paren
(brace
id|disk
op_assign
id|conf-&gt;spare
suffix:semicolon
r_if
c_cond
(paren
id|disk-&gt;dev
op_eq
id|dev
)paren
(brace
id|printk
(paren
id|KERN_ALERT
l_string|&quot;raid5: Disk failure on spare %s&bslash;n&quot;
comma
id|partition_name
(paren
id|dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;spare-&gt;operational
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|disk-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
id|conf-&gt;spare
op_assign
l_int|NULL
suffix:semicolon
id|mark_disk_faulty
c_func
(paren
id|sb-&gt;disks
op_plus
id|disk-&gt;number
)paren
suffix:semicolon
id|mark_disk_nonsync
c_func
(paren
id|sb-&gt;disks
op_plus
id|disk-&gt;number
)paren
suffix:semicolon
id|mark_disk_inactive
c_func
(paren
id|sb-&gt;disks
op_plus
id|disk-&gt;number
)paren
suffix:semicolon
id|sb-&gt;spare_disks
op_decrement
suffix:semicolon
id|sb-&gt;working_disks
op_decrement
suffix:semicolon
id|sb-&gt;failed_disks
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n; * Input: a &squot;big&squot; sector number,&n; * Output: index of the data and parity disk, and the sector # in them.&n; */
DECL|function|raid5_compute_sector
r_static
r_int
r_int
id|raid5_compute_sector
c_func
(paren
r_int
r_int
id|r_sector
comma
r_int
r_int
id|raid_disks
comma
r_int
r_int
id|data_disks
comma
r_int
r_int
op_star
id|dd_idx
comma
r_int
r_int
op_star
id|pd_idx
comma
id|raid5_conf_t
op_star
id|conf
)paren
(brace
r_int
r_int
id|stripe
suffix:semicolon
r_int
r_int
id|chunk_number
suffix:semicolon
r_int
r_int
id|chunk_offset
suffix:semicolon
r_int
r_int
id|new_sector
suffix:semicolon
r_int
id|sectors_per_chunk
op_assign
id|conf-&gt;chunk_size
op_rshift
l_int|9
suffix:semicolon
multiline_comment|/* First compute the information on this sector */
multiline_comment|/*&n;&t; * Compute the chunk number and the sector offset inside the chunk&n;&t; */
id|chunk_number
op_assign
id|r_sector
op_div
id|sectors_per_chunk
suffix:semicolon
id|chunk_offset
op_assign
id|r_sector
op_mod
id|sectors_per_chunk
suffix:semicolon
multiline_comment|/*&n;&t; * Compute the stripe number&n;&t; */
id|stripe
op_assign
id|chunk_number
op_div
id|data_disks
suffix:semicolon
multiline_comment|/*&n;&t; * Compute the data disk and parity disk indexes inside the stripe&n;&t; */
op_star
id|dd_idx
op_assign
id|chunk_number
op_mod
id|data_disks
suffix:semicolon
multiline_comment|/*&n;&t; * Select the parity disk based on the user selected algorithm.&n;&t; */
r_if
c_cond
(paren
id|conf-&gt;level
op_eq
l_int|4
)paren
op_star
id|pd_idx
op_assign
id|data_disks
suffix:semicolon
r_else
r_switch
c_cond
(paren
id|conf-&gt;algorithm
)paren
(brace
r_case
id|ALGORITHM_LEFT_ASYMMETRIC
suffix:colon
op_star
id|pd_idx
op_assign
id|data_disks
op_minus
id|stripe
op_mod
id|raid_disks
suffix:semicolon
r_if
c_cond
(paren
op_star
id|dd_idx
op_ge
op_star
id|pd_idx
)paren
(paren
op_star
id|dd_idx
)paren
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ALGORITHM_RIGHT_ASYMMETRIC
suffix:colon
op_star
id|pd_idx
op_assign
id|stripe
op_mod
id|raid_disks
suffix:semicolon
r_if
c_cond
(paren
op_star
id|dd_idx
op_ge
op_star
id|pd_idx
)paren
(paren
op_star
id|dd_idx
)paren
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ALGORITHM_LEFT_SYMMETRIC
suffix:colon
op_star
id|pd_idx
op_assign
id|data_disks
op_minus
id|stripe
op_mod
id|raid_disks
suffix:semicolon
op_star
id|dd_idx
op_assign
(paren
op_star
id|pd_idx
op_plus
l_int|1
op_plus
op_star
id|dd_idx
)paren
op_mod
id|raid_disks
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ALGORITHM_RIGHT_SYMMETRIC
suffix:colon
op_star
id|pd_idx
op_assign
id|stripe
op_mod
id|raid_disks
suffix:semicolon
op_star
id|dd_idx
op_assign
(paren
op_star
id|pd_idx
op_plus
l_int|1
op_plus
op_star
id|dd_idx
)paren
op_mod
id|raid_disks
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;raid5: unsupported algorithm %d&bslash;n&quot;
comma
id|conf-&gt;algorithm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Finally, compute the new sector number&n;&t; */
id|new_sector
op_assign
id|stripe
op_star
id|sectors_per_chunk
op_plus
id|chunk_offset
suffix:semicolon
r_return
id|new_sector
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_int
r_int
id|compute_blocknr
c_func
(paren
r_struct
id|stripe_head
op_star
id|sh
comma
r_int
id|i
)paren
(brace
id|raid5_conf_t
op_star
id|conf
op_assign
id|sh-&gt;raid_conf
suffix:semicolon
r_int
id|raid_disks
op_assign
id|conf-&gt;raid_disks
comma
id|data_disks
op_assign
id|raid_disks
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|new_sector
op_assign
id|sh-&gt;sector
comma
id|check
suffix:semicolon
r_int
id|sectors_per_chunk
op_assign
id|conf-&gt;chunk_size
op_rshift
l_int|9
suffix:semicolon
r_int
r_int
id|stripe
op_assign
id|new_sector
op_div
id|sectors_per_chunk
suffix:semicolon
r_int
id|chunk_offset
op_assign
id|new_sector
op_mod
id|sectors_per_chunk
suffix:semicolon
r_int
id|chunk_number
comma
id|dummy1
comma
id|dummy2
comma
id|dd_idx
op_assign
id|i
suffix:semicolon
r_int
r_int
id|r_sector
comma
id|blocknr
suffix:semicolon
r_switch
c_cond
(paren
id|conf-&gt;algorithm
)paren
(brace
r_case
id|ALGORITHM_LEFT_ASYMMETRIC
suffix:colon
r_case
id|ALGORITHM_RIGHT_ASYMMETRIC
suffix:colon
r_if
c_cond
(paren
id|i
OG
id|sh-&gt;pd_idx
)paren
id|i
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ALGORITHM_LEFT_SYMMETRIC
suffix:colon
r_case
id|ALGORITHM_RIGHT_SYMMETRIC
suffix:colon
r_if
c_cond
(paren
id|i
OL
id|sh-&gt;pd_idx
)paren
id|i
op_add_assign
id|raid_disks
suffix:semicolon
id|i
op_sub_assign
(paren
id|sh-&gt;pd_idx
op_plus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;raid5: unsupported algorithm %d&bslash;n&quot;
comma
id|conf-&gt;algorithm
)paren
suffix:semicolon
)brace
id|chunk_number
op_assign
id|stripe
op_star
id|data_disks
op_plus
id|i
suffix:semicolon
id|r_sector
op_assign
id|chunk_number
op_star
id|sectors_per_chunk
op_plus
id|chunk_offset
suffix:semicolon
id|blocknr
op_assign
id|r_sector
op_div
(paren
id|sh-&gt;size
op_rshift
l_int|9
)paren
suffix:semicolon
id|check
op_assign
id|raid5_compute_sector
(paren
id|r_sector
comma
id|raid_disks
comma
id|data_disks
comma
op_amp
id|dummy1
comma
op_amp
id|dummy2
comma
id|conf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check
op_ne
id|sh-&gt;sector
op_logical_or
id|dummy1
op_ne
id|dd_idx
op_logical_or
id|dummy2
op_ne
id|sh-&gt;pd_idx
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;compute_blocknr: map not correct&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|blocknr
suffix:semicolon
)brace
macro_line|#endif
DECL|macro|check_xor
mdefine_line|#define check_xor() &t;do { &t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;   if (count == MAX_XOR_BLOCKS) {&t;&bslash;&n;&t;&t;&t;&t;xor_block(count, bh_ptr);&t;&bslash;&n;&t;&t;&t;&t;count = 1;&t;&t;&t;&bslash;&n;&t;&t;&t;   }&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;} while(0)
DECL|function|compute_block
r_static
r_void
id|compute_block
c_func
(paren
r_struct
id|stripe_head
op_star
id|sh
comma
r_int
id|dd_idx
)paren
(brace
id|raid5_conf_t
op_star
id|conf
op_assign
id|sh-&gt;raid_conf
suffix:semicolon
r_int
id|i
comma
id|count
comma
id|disks
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh_ptr
(braket
id|MAX_XOR_BLOCKS
)braket
comma
op_star
id|bh
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;compute_block, stripe %lu, idx %d&bslash;n&quot;
comma
id|sh-&gt;sector
comma
id|dd_idx
)paren
suffix:semicolon
id|memset
c_func
(paren
id|sh-&gt;bh_cache
(braket
id|dd_idx
)braket
op_member_access_from_pointer
id|b_data
comma
l_int|0
comma
id|sh-&gt;size
)paren
suffix:semicolon
id|bh_ptr
(braket
l_int|0
)braket
op_assign
id|sh-&gt;bh_cache
(braket
id|dd_idx
)braket
suffix:semicolon
id|count
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|disks
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|dd_idx
)paren
r_continue
suffix:semicolon
id|bh
op_assign
id|sh-&gt;bh_cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|bh_ptr
(braket
id|count
op_increment
)braket
op_assign
id|bh
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;compute_block() %d, stripe %lu, %d not present&bslash;n&quot;
comma
id|dd_idx
comma
id|sh-&gt;sector
comma
id|i
)paren
suffix:semicolon
id|check_xor
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_ne
l_int|1
)paren
id|xor_block
c_func
(paren
id|count
comma
id|bh_ptr
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|sh-&gt;bh_cache
(braket
id|dd_idx
)braket
op_member_access_from_pointer
id|b_state
)paren
suffix:semicolon
)brace
DECL|function|compute_parity
r_static
r_void
id|compute_parity
c_func
(paren
r_struct
id|stripe_head
op_star
id|sh
comma
r_int
id|method
)paren
(brace
id|raid5_conf_t
op_star
id|conf
op_assign
id|sh-&gt;raid_conf
suffix:semicolon
r_int
id|i
comma
id|pd_idx
op_assign
id|sh-&gt;pd_idx
comma
id|disks
op_assign
id|conf-&gt;raid_disks
comma
id|count
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh_ptr
(braket
id|MAX_XOR_BLOCKS
)braket
suffix:semicolon
r_struct
id|buffer_head
op_star
id|chosen
(braket
id|MD_SB_DISKS
)braket
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;compute_parity, stripe %lu, method %d&bslash;n&quot;
comma
id|sh-&gt;sector
comma
id|method
)paren
suffix:semicolon
id|memset
c_func
(paren
id|chosen
comma
l_int|0
comma
r_sizeof
(paren
id|chosen
)paren
)paren
suffix:semicolon
id|count
op_assign
l_int|1
suffix:semicolon
id|bh_ptr
(braket
l_int|0
)braket
op_assign
id|sh-&gt;bh_cache
(braket
id|pd_idx
)braket
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|method
)paren
(brace
r_case
id|READ_MODIFY_WRITE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|sh-&gt;bh_cache
(braket
id|pd_idx
)braket
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|disks
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|pd_idx
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|sh-&gt;bh_write
(braket
id|i
)braket
op_logical_and
id|buffer_uptodate
c_func
(paren
id|sh-&gt;bh_cache
(braket
id|i
)braket
)paren
)paren
(brace
id|bh_ptr
(braket
id|count
op_increment
)braket
op_assign
id|sh-&gt;bh_cache
(braket
id|i
)braket
suffix:semicolon
id|chosen
(braket
id|i
)braket
op_assign
id|sh-&gt;bh_write
(braket
id|i
)braket
suffix:semicolon
id|sh-&gt;bh_write
(braket
id|i
)braket
op_assign
id|sh-&gt;bh_write
(braket
id|i
)braket
op_member_access_from_pointer
id|b_reqnext
suffix:semicolon
id|chosen
(braket
id|i
)braket
op_member_access_from_pointer
id|b_reqnext
op_assign
id|sh-&gt;bh_written
(braket
id|i
)braket
suffix:semicolon
id|sh-&gt;bh_written
(braket
id|i
)braket
op_assign
id|chosen
(braket
id|i
)braket
suffix:semicolon
id|check_xor
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|RECONSTRUCT_WRITE
suffix:colon
id|memset
c_func
(paren
id|sh-&gt;bh_cache
(braket
id|pd_idx
)braket
op_member_access_from_pointer
id|b_data
comma
l_int|0
comma
id|sh-&gt;size
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|disks
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
r_if
c_cond
(paren
id|i
op_ne
id|pd_idx
op_logical_and
id|sh-&gt;bh_write
(braket
id|i
)braket
)paren
(brace
id|chosen
(braket
id|i
)braket
op_assign
id|sh-&gt;bh_write
(braket
id|i
)braket
suffix:semicolon
id|sh-&gt;bh_write
(braket
id|i
)braket
op_assign
id|sh-&gt;bh_write
(braket
id|i
)braket
op_member_access_from_pointer
id|b_reqnext
suffix:semicolon
id|chosen
(braket
id|i
)braket
op_member_access_from_pointer
id|b_reqnext
op_assign
id|sh-&gt;bh_written
(braket
id|i
)braket
suffix:semicolon
id|sh-&gt;bh_written
(braket
id|i
)braket
op_assign
id|chosen
(braket
id|i
)braket
suffix:semicolon
id|check_xor
c_func
(paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CHECK_PARITY
suffix:colon
r_break
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|disks
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
r_if
c_cond
(paren
id|chosen
(braket
id|i
)braket
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|sh-&gt;bh_cache
(braket
id|i
)braket
suffix:semicolon
r_char
op_star
id|bdata
suffix:semicolon
id|mark_buffer_clean
c_func
(paren
id|chosen
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* NO FIXME */
id|bdata
op_assign
id|bh_kmap
c_func
(paren
id|chosen
(braket
id|i
)braket
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bh-&gt;b_data
comma
id|bdata
comma
id|sh-&gt;size
)paren
suffix:semicolon
id|bh_kunmap
c_func
(paren
id|chosen
(braket
id|i
)braket
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Lock
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|mark_buffer_uptodate
c_func
(paren
id|bh
comma
l_int|1
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|method
)paren
(brace
r_case
id|RECONSTRUCT_WRITE
suffix:colon
r_case
id|CHECK_PARITY
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
id|disks
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
r_if
c_cond
(paren
id|i
op_ne
id|pd_idx
)paren
(brace
id|bh_ptr
(braket
id|count
op_increment
)braket
op_assign
id|sh-&gt;bh_cache
(braket
id|i
)braket
suffix:semicolon
id|check_xor
c_func
(paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|READ_MODIFY_WRITE
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
id|disks
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
r_if
c_cond
(paren
id|chosen
(braket
id|i
)braket
)paren
(brace
id|bh_ptr
(braket
id|count
op_increment
)braket
op_assign
id|sh-&gt;bh_cache
(braket
id|i
)braket
suffix:semicolon
id|check_xor
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|count
op_ne
l_int|1
)paren
id|xor_block
c_func
(paren
id|count
comma
id|bh_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|method
op_ne
id|CHECK_PARITY
)paren
(brace
id|mark_buffer_uptodate
c_func
(paren
id|sh-&gt;bh_cache
(braket
id|pd_idx
)braket
comma
l_int|1
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Lock
comma
op_amp
id|sh-&gt;bh_cache
(braket
id|pd_idx
)braket
op_member_access_from_pointer
id|b_state
)paren
suffix:semicolon
)brace
r_else
id|mark_buffer_uptodate
c_func
(paren
id|sh-&gt;bh_cache
(braket
id|pd_idx
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|add_stripe_bh
r_static
r_void
id|add_stripe_bh
(paren
r_struct
id|stripe_head
op_star
id|sh
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|dd_idx
comma
r_int
id|rw
)paren
(brace
r_struct
id|buffer_head
op_star
op_star
id|bhp
suffix:semicolon
id|raid5_conf_t
op_star
id|conf
op_assign
id|sh-&gt;raid_conf
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;adding bh b#%lu to stripe s#%lu&bslash;n&quot;
comma
id|bh-&gt;b_blocknr
comma
id|sh-&gt;sector
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|READ
)paren
id|bhp
op_assign
op_amp
id|sh-&gt;bh_read
(braket
id|dd_idx
)braket
suffix:semicolon
r_else
id|bhp
op_assign
op_amp
id|sh-&gt;bh_write
(braket
id|dd_idx
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|bhp
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;raid5: multiple %d requests for sector %ld&bslash;n&quot;
comma
id|rw
comma
id|sh-&gt;sector
)paren
suffix:semicolon
id|bhp
op_assign
op_amp
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_reqnext
suffix:semicolon
)brace
op_star
id|bhp
op_assign
id|bh
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;added bh b#%lu to stripe s#%lu, disk %d.&bslash;n&quot;
comma
id|bh-&gt;b_blocknr
comma
id|sh-&gt;sector
comma
id|dd_idx
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * handle_stripe - do things to a stripe.&n; *&n; * We lock the stripe and then examine the state of various bits&n; * to see what needs to be done.&n; * Possible results:&n; *    return some read request which now have data&n; *    return some write requests which are safely on disc&n; *    schedule a read on some buffers&n; *    schedule a write of some buffers&n; *    return confirmation of parity correctness&n; *&n; * Parity calculations are done inside the stripe lock&n; * buffers are taken off read_list or write_list, and bh_cache buffers&n; * get BH_Lock set before the stripe lock is released.&n; *&n; */
DECL|function|handle_stripe
r_static
r_void
id|handle_stripe
c_func
(paren
r_struct
id|stripe_head
op_star
id|sh
)paren
(brace
id|raid5_conf_t
op_star
id|conf
op_assign
id|sh-&gt;raid_conf
suffix:semicolon
r_int
id|disks
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
r_struct
id|buffer_head
op_star
id|return_ok
op_assign
l_int|NULL
comma
op_star
id|return_fail
op_assign
l_int|NULL
suffix:semicolon
r_int
id|action
(braket
id|MD_SB_DISKS
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|syncing
suffix:semicolon
r_int
id|locked
op_assign
l_int|0
comma
id|uptodate
op_assign
l_int|0
comma
id|to_read
op_assign
l_int|0
comma
id|to_write
op_assign
l_int|0
comma
id|failed
op_assign
l_int|0
comma
id|written
op_assign
l_int|0
suffix:semicolon
r_int
id|failed_num
op_assign
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;handling stripe %ld, cnt=%d, pd_idx=%d&bslash;n&quot;
comma
id|sh-&gt;sector
comma
id|atomic_read
c_func
(paren
op_amp
id|sh-&gt;count
)paren
comma
id|sh-&gt;pd_idx
)paren
suffix:semicolon
id|memset
c_func
(paren
id|action
comma
l_int|0
comma
r_sizeof
(paren
id|action
)paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sh-&gt;lock
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|STRIPE_HANDLE
comma
op_amp
id|sh-&gt;state
)paren
suffix:semicolon
id|syncing
op_assign
id|test_bit
c_func
(paren
id|STRIPE_SYNCING
comma
op_amp
id|sh-&gt;state
)paren
suffix:semicolon
multiline_comment|/* Now to look around and see what can be done */
r_for
c_loop
(paren
id|i
op_assign
id|disks
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
(brace
id|bh
op_assign
id|sh-&gt;bh_cache
(braket
id|i
)braket
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;check %d: state %lx read %p write %p written %p&bslash;n&quot;
comma
id|i
comma
id|bh-&gt;b_state
comma
id|sh-&gt;bh_read
(braket
id|i
)braket
comma
id|sh-&gt;bh_write
(braket
id|i
)braket
comma
id|sh-&gt;bh_written
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* maybe we can reply to a read */
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
op_logical_and
id|sh-&gt;bh_read
(braket
id|i
)braket
)paren
(brace
r_struct
id|buffer_head
op_star
id|rbh
comma
op_star
id|rbh2
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;Return read for disc %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|rbh
op_assign
id|sh-&gt;bh_read
(braket
id|i
)braket
suffix:semicolon
id|sh-&gt;bh_read
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|rbh
)paren
(brace
r_char
op_star
id|bdata
suffix:semicolon
id|bdata
op_assign
id|bh_kmap
c_func
(paren
id|rbh
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bdata
comma
id|bh-&gt;b_data
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
id|bh_kunmap
c_func
(paren
id|rbh
)paren
suffix:semicolon
id|rbh2
op_assign
id|rbh-&gt;b_reqnext
suffix:semicolon
id|rbh-&gt;b_reqnext
op_assign
id|return_ok
suffix:semicolon
id|return_ok
op_assign
id|rbh
suffix:semicolon
id|rbh
op_assign
id|rbh2
suffix:semicolon
)brace
)brace
multiline_comment|/* now count some things */
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
id|locked
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|uptodate
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sh-&gt;bh_read
(braket
id|i
)braket
)paren
id|to_read
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sh-&gt;bh_write
(braket
id|i
)braket
)paren
id|to_write
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sh-&gt;bh_written
(braket
id|i
)braket
)paren
id|written
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|operational
)paren
(brace
id|failed
op_increment
suffix:semicolon
id|failed_num
op_assign
id|i
suffix:semicolon
)brace
)brace
id|PRINTK
c_func
(paren
l_string|&quot;locked=%d uptodate=%d to_read=%d to_write=%d failed=%d failed_num=%d&bslash;n&quot;
comma
id|locked
comma
id|uptodate
comma
id|to_read
comma
id|to_write
comma
id|failed
comma
id|failed_num
)paren
suffix:semicolon
multiline_comment|/* check if the array has lost two devices and, if so, some requests might&n;&t; * need to be failed&n;&t; */
r_if
c_cond
(paren
id|failed
OG
l_int|1
op_logical_and
id|to_read
op_plus
id|to_write
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|disks
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
(brace
multiline_comment|/* fail all writes first */
r_if
c_cond
(paren
id|sh-&gt;bh_write
(braket
id|i
)braket
)paren
id|to_write
op_decrement
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|sh-&gt;bh_write
(braket
id|i
)braket
)paren
)paren
(brace
id|sh-&gt;bh_write
(braket
id|i
)braket
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
id|bh-&gt;b_reqnext
op_assign
id|return_fail
suffix:semicolon
id|return_fail
op_assign
id|bh
suffix:semicolon
)brace
multiline_comment|/* fail any reads if this device is non-operational */
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|operational
)paren
(brace
r_if
c_cond
(paren
id|sh-&gt;bh_read
(braket
id|i
)braket
)paren
id|to_read
op_decrement
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|sh-&gt;bh_read
(braket
id|i
)braket
)paren
)paren
(brace
id|sh-&gt;bh_read
(braket
id|i
)braket
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
id|bh-&gt;b_reqnext
op_assign
id|return_fail
suffix:semicolon
id|return_fail
op_assign
id|bh
suffix:semicolon
)brace
)brace
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|syncing
)paren
(brace
id|md_done_sync
c_func
(paren
id|conf-&gt;mddev
comma
(paren
id|sh-&gt;size
op_rshift
l_int|10
)paren
op_minus
id|sh-&gt;sync_redone
comma
l_int|0
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|STRIPE_SYNCING
comma
op_amp
id|sh-&gt;state
)paren
suffix:semicolon
id|syncing
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* might be able to return some write requests if the parity block&n;&t; * is safe, or on a failed drive&n;&t; */
id|bh
op_assign
id|sh-&gt;bh_cache
(braket
id|sh-&gt;pd_idx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|written
op_logical_and
(paren
(paren
id|conf-&gt;disks
(braket
id|sh-&gt;pd_idx
)braket
dot
id|operational
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_and
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
op_logical_or
(paren
id|failed
op_eq
l_int|1
op_logical_and
id|failed_num
op_eq
id|sh-&gt;pd_idx
)paren
)paren
)paren
(brace
multiline_comment|/* any written block on a uptodate or failed drive can be returned */
r_for
c_loop
(paren
id|i
op_assign
id|disks
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
r_if
c_cond
(paren
id|sh-&gt;bh_written
(braket
id|i
)braket
)paren
(brace
id|bh
op_assign
id|sh-&gt;bh_cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;disks
(braket
id|sh-&gt;pd_idx
)braket
dot
id|operational
op_logical_or
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_and
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
)paren
(brace
multiline_comment|/* maybe we can return some write requests */
r_struct
id|buffer_head
op_star
id|wbh
comma
op_star
id|wbh2
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;Return write for disc %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|wbh
op_assign
id|sh-&gt;bh_written
(braket
id|i
)braket
suffix:semicolon
id|sh-&gt;bh_written
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|wbh
)paren
(brace
id|wbh2
op_assign
id|wbh-&gt;b_reqnext
suffix:semicolon
id|wbh-&gt;b_reqnext
op_assign
id|return_ok
suffix:semicolon
id|return_ok
op_assign
id|wbh
suffix:semicolon
id|wbh
op_assign
id|wbh2
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* Now we might consider reading some blocks, either to check/generate&n;&t; * parity, or to satisfy requests&n;&t; */
r_if
c_cond
(paren
id|to_read
op_logical_or
(paren
id|syncing
op_logical_and
(paren
id|uptodate
op_plus
id|failed
OL
id|disks
)paren
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|disks
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
(brace
id|bh
op_assign
id|sh-&gt;bh_cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
op_logical_and
(paren
id|sh-&gt;bh_read
(braket
id|i
)braket
op_logical_or
id|syncing
op_logical_or
(paren
id|failed
op_logical_and
id|sh-&gt;bh_read
(braket
id|failed_num
)braket
)paren
)paren
)paren
(brace
multiline_comment|/* we would like to get this block, possibly&n;&t;&t;&t;&t; * by computing it, but we might not be able to&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|uptodate
op_eq
id|disks
op_minus
l_int|1
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;Computing block %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|compute_block
c_func
(paren
id|sh
comma
id|i
)paren
suffix:semicolon
id|uptodate
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|operational
)paren
(brace
id|set_bit
c_func
(paren
id|BH_Lock
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|action
(braket
id|i
)braket
op_assign
id|READ
op_plus
l_int|1
suffix:semicolon
id|locked
op_increment
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;Reading block %d (sync=%d)&bslash;n&quot;
comma
id|i
comma
id|syncing
)paren
suffix:semicolon
r_if
c_cond
(paren
id|syncing
)paren
id|md_sync_acct
c_func
(paren
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|dev
comma
id|bh-&gt;b_size
op_rshift
l_int|9
)paren
suffix:semicolon
)brace
)brace
)brace
id|set_bit
c_func
(paren
id|STRIPE_HANDLE
comma
op_amp
id|sh-&gt;state
)paren
suffix:semicolon
)brace
multiline_comment|/* now to consider writing and what else, if anything should be read */
r_if
c_cond
(paren
id|to_write
)paren
(brace
r_int
id|rmw
op_assign
l_int|0
comma
id|rcw
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|disks
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
(brace
multiline_comment|/* would I have to read this buffer for read_modify_write */
id|bh
op_assign
id|sh-&gt;bh_cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sh-&gt;bh_write
(braket
id|i
)braket
op_logical_or
id|i
op_eq
id|sh-&gt;pd_idx
)paren
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
r_if
c_cond
(paren
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|operational
multiline_comment|/*&t;&t;&t;&t;    &amp;&amp; !(conf-&gt;resync_parity &amp;&amp; i == sh-&gt;pd_idx) */
)paren
id|rmw
op_increment
suffix:semicolon
r_else
id|rmw
op_add_assign
l_int|2
op_star
id|disks
suffix:semicolon
multiline_comment|/* cannot read it */
)brace
multiline_comment|/* Would I have to read this buffer for reconstruct_write */
r_if
c_cond
(paren
op_logical_neg
id|sh-&gt;bh_write
(braket
id|i
)braket
op_logical_and
id|i
op_ne
id|sh-&gt;pd_idx
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
r_if
c_cond
(paren
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|operational
)paren
id|rcw
op_increment
suffix:semicolon
r_else
id|rcw
op_add_assign
l_int|2
op_star
id|disks
suffix:semicolon
)brace
)brace
id|PRINTK
c_func
(paren
l_string|&quot;for sector %ld, rmw=%d rcw=%d&bslash;n&quot;
comma
id|sh-&gt;sector
comma
id|rmw
comma
id|rcw
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|STRIPE_HANDLE
comma
op_amp
id|sh-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rmw
template_param
l_int|0
)paren
multiline_comment|/* prefer read-modify-write, but need to get some data */
r_for
c_loop
(paren
id|i
op_assign
id|disks
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
(brace
id|bh
op_assign
id|sh-&gt;bh_cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sh-&gt;bh_write
(braket
id|i
)braket
op_logical_or
id|i
op_eq
id|sh-&gt;pd_idx
)paren
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
op_logical_and
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|operational
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;Read_old block %d for r-m-w&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Lock
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|action
(braket
id|i
)braket
op_assign
id|READ
op_plus
l_int|1
suffix:semicolon
id|locked
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rcw
op_le
id|rmw
op_logical_and
id|rcw
OG
l_int|0
)paren
multiline_comment|/* want reconstruct write, but need to get some data */
r_for
c_loop
(paren
id|i
op_assign
id|disks
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
(brace
id|bh
op_assign
id|sh-&gt;bh_cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sh-&gt;bh_write
(braket
id|i
)braket
op_logical_and
id|i
op_ne
id|sh-&gt;pd_idx
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
op_logical_and
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|operational
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;Read_old block %d for Reconstruct&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Lock
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|action
(braket
id|i
)braket
op_assign
id|READ
op_plus
l_int|1
suffix:semicolon
id|locked
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* now if nothing is locked, and if we have enough data, we can start a write request */
r_if
c_cond
(paren
id|locked
op_eq
l_int|0
op_logical_and
(paren
id|rcw
op_eq
l_int|0
op_logical_or
id|rmw
op_eq
l_int|0
)paren
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;Computing parity...&bslash;n&quot;
)paren
suffix:semicolon
id|compute_parity
c_func
(paren
id|sh
comma
id|rcw
op_eq
l_int|0
ques
c_cond
id|RECONSTRUCT_WRITE
suffix:colon
id|READ_MODIFY_WRITE
)paren
suffix:semicolon
multiline_comment|/* now every locked buffer is ready to be written */
r_for
c_loop
(paren
id|i
op_assign
id|disks
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|sh-&gt;bh_cache
(braket
id|i
)braket
)paren
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;Writing block %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|locked
op_increment
suffix:semicolon
id|action
(braket
id|i
)braket
op_assign
id|WRITE
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|operational
op_logical_or
(paren
id|i
op_eq
id|sh-&gt;pd_idx
op_logical_and
id|failed
op_eq
l_int|0
)paren
)paren
id|set_bit
c_func
(paren
id|STRIPE_INSYNC
comma
op_amp
id|sh-&gt;state
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* maybe we need to check and possibly fix the parity for this stripe&n;&t; * Any reads will already have been scheduled, so we just see if enough data&n;&t; * is available&n;&t; */
r_if
c_cond
(paren
id|syncing
op_logical_and
id|locked
op_eq
l_int|0
op_logical_and
op_logical_neg
id|test_bit
c_func
(paren
id|STRIPE_INSYNC
comma
op_amp
id|sh-&gt;state
)paren
op_logical_and
id|failed
op_le
l_int|1
)paren
(brace
id|set_bit
c_func
(paren
id|STRIPE_HANDLE
comma
op_amp
id|sh-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|failed
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|uptodate
op_ne
id|disks
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|compute_parity
c_func
(paren
id|sh
comma
id|CHECK_PARITY
)paren
suffix:semicolon
id|uptodate
op_decrement
suffix:semicolon
id|bh
op_assign
id|sh-&gt;bh_cache
(braket
id|sh-&gt;pd_idx
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
(paren
id|u32
op_star
)paren
id|bh-&gt;b_data
)paren
op_eq
l_int|0
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|bh-&gt;b_data
comma
id|bh-&gt;b_data
op_plus
l_int|4
comma
id|bh-&gt;b_size
op_minus
l_int|4
)paren
)paren
(brace
multiline_comment|/* parity is correct (on disc, not in buffer any more) */
id|set_bit
c_func
(paren
id|STRIPE_INSYNC
comma
op_amp
id|sh-&gt;state
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|STRIPE_INSYNC
comma
op_amp
id|sh-&gt;state
)paren
)paren
(brace
r_if
c_cond
(paren
id|failed
op_eq
l_int|0
)paren
id|failed_num
op_assign
id|sh-&gt;pd_idx
suffix:semicolon
multiline_comment|/* should be able to compute the missing block and write it to spare */
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|sh-&gt;bh_cache
(braket
id|failed_num
)braket
)paren
)paren
(brace
r_if
c_cond
(paren
id|uptodate
op_plus
l_int|1
op_ne
id|disks
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|compute_block
c_func
(paren
id|sh
comma
id|failed_num
)paren
suffix:semicolon
id|uptodate
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uptodate
op_ne
id|disks
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|bh
op_assign
id|sh-&gt;bh_cache
(braket
id|failed_num
)braket
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Lock
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|action
(braket
id|failed_num
)braket
op_assign
id|WRITE
op_plus
l_int|1
suffix:semicolon
id|locked
op_increment
suffix:semicolon
id|set_bit
c_func
(paren
id|STRIPE_INSYNC
comma
op_amp
id|sh-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|operational
)paren
id|md_sync_acct
c_func
(paren
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|dev
comma
id|bh-&gt;b_size
op_rshift
l_int|9
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|conf-&gt;spare
)paren
id|md_sync_acct
c_func
(paren
id|conf-&gt;spare-&gt;dev
comma
id|bh-&gt;b_size
op_rshift
l_int|9
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|syncing
op_logical_and
id|locked
op_eq
l_int|0
op_logical_and
id|test_bit
c_func
(paren
id|STRIPE_INSYNC
comma
op_amp
id|sh-&gt;state
)paren
)paren
(brace
id|md_done_sync
c_func
(paren
id|conf-&gt;mddev
comma
(paren
id|sh-&gt;size
op_rshift
l_int|10
)paren
op_minus
id|sh-&gt;sync_redone
comma
l_int|1
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|STRIPE_SYNCING
comma
op_amp
id|sh-&gt;state
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|sh-&gt;lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|return_ok
)paren
)paren
(brace
id|return_ok
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
id|bh
op_member_access_from_pointer
id|b_end_io
c_func
(paren
id|bh
comma
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|return_fail
)paren
)paren
(brace
id|return_ok
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
id|bh
op_member_access_from_pointer
id|b_end_io
c_func
(paren
id|bh
comma
l_int|0
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|disks
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
r_if
c_cond
(paren
id|action
(braket
id|i
)braket
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|sh-&gt;bh_cache
(braket
id|i
)braket
suffix:semicolon
r_int
id|skip
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|action
(braket
id|i
)braket
op_eq
id|READ
op_plus
l_int|1
)paren
id|bh-&gt;b_end_io
op_assign
id|raid5_end_read_request
suffix:semicolon
r_else
id|bh-&gt;b_end_io
op_assign
id|raid5_end_write_request
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|operational
)paren
id|bh-&gt;b_dev
op_assign
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|dev
suffix:semicolon
r_else
r_if
c_cond
(paren
id|conf-&gt;spare
op_logical_and
id|action
(braket
id|i
)braket
op_eq
id|WRITE
op_plus
l_int|1
)paren
id|bh-&gt;b_dev
op_assign
id|conf-&gt;spare-&gt;dev
suffix:semicolon
r_else
r_if
c_cond
(paren
id|action
(braket
id|i
)braket
op_eq
id|READ
op_plus
l_int|1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_else
id|skip
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;for %ld schedule op %d on disc %d&bslash;n&quot;
comma
id|sh-&gt;sector
comma
id|action
(braket
id|i
)braket
op_minus
l_int|1
comma
id|i
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|sh-&gt;count
)paren
suffix:semicolon
id|bh-&gt;b_rdev
op_assign
id|bh-&gt;b_dev
suffix:semicolon
id|bh-&gt;b_rsector
op_assign
id|bh-&gt;b_blocknr
op_star
(paren
id|bh-&gt;b_size
op_rshift
l_int|9
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|action
(braket
id|i
)braket
op_minus
l_int|1
comma
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTK
c_func
(paren
l_string|&quot;skip op %d on disc %d for sector %ld&bslash;n&quot;
comma
id|action
(braket
id|i
)braket
op_minus
l_int|1
comma
id|i
comma
id|sh-&gt;sector
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Lock
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|STRIPE_HANDLE
comma
op_amp
id|sh-&gt;state
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|raid5_make_request
r_static
r_int
id|raid5_make_request
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|rw
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|raid5_conf_t
op_star
id|conf
op_assign
(paren
id|raid5_conf_t
op_star
)paren
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_const
r_int
r_int
id|raid_disks
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
r_const
r_int
r_int
id|data_disks
op_assign
id|raid_disks
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|dd_idx
comma
id|pd_idx
suffix:semicolon
r_int
r_int
id|new_sector
suffix:semicolon
r_int
id|read_ahead
op_assign
l_int|0
suffix:semicolon
r_struct
id|stripe_head
op_star
id|sh
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|READA
)paren
(brace
id|rw
op_assign
id|READ
suffix:semicolon
id|read_ahead
op_assign
l_int|1
suffix:semicolon
)brace
id|new_sector
op_assign
id|raid5_compute_sector
c_func
(paren
id|bh-&gt;b_rsector
comma
id|raid_disks
comma
id|data_disks
comma
op_amp
id|dd_idx
comma
op_amp
id|pd_idx
comma
id|conf
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;raid5_make_request, sector %lu&bslash;n&quot;
comma
id|new_sector
)paren
suffix:semicolon
id|sh
op_assign
id|get_active_stripe
c_func
(paren
id|conf
comma
id|new_sector
comma
id|bh-&gt;b_size
comma
id|read_ahead
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh
)paren
(brace
id|sh-&gt;pd_idx
op_assign
id|pd_idx
suffix:semicolon
id|add_stripe_bh
c_func
(paren
id|sh
comma
id|bh
comma
id|dd_idx
comma
id|rw
)paren
suffix:semicolon
id|handle_stripe
c_func
(paren
id|sh
)paren
suffix:semicolon
id|release_stripe
c_func
(paren
id|sh
)paren
suffix:semicolon
)brace
r_else
id|bh
op_member_access_from_pointer
id|b_end_io
c_func
(paren
id|bh
comma
id|test_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Determine correct block size for this device.&n; */
DECL|function|device_bsize
r_int
r_int
id|device_bsize
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
r_int
id|i
comma
id|correct_size
suffix:semicolon
id|correct_size
op_assign
id|BLOCK_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
)paren
(brace
id|i
op_assign
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
id|correct_size
op_assign
id|i
suffix:semicolon
)brace
r_return
id|correct_size
suffix:semicolon
)brace
DECL|function|raid5_sync_request
r_static
r_int
id|raid5_sync_request
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
r_int
id|block_nr
)paren
(brace
id|raid5_conf_t
op_star
id|conf
op_assign
(paren
id|raid5_conf_t
op_star
)paren
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|stripe_head
op_star
id|sh
suffix:semicolon
r_int
id|sectors_per_chunk
op_assign
id|conf-&gt;chunk_size
op_rshift
l_int|9
suffix:semicolon
r_int
r_int
id|stripe
op_assign
(paren
id|block_nr
op_lshift
l_int|1
)paren
op_div
id|sectors_per_chunk
suffix:semicolon
r_int
id|chunk_offset
op_assign
(paren
id|block_nr
op_lshift
l_int|1
)paren
op_mod
id|sectors_per_chunk
suffix:semicolon
r_int
id|dd_idx
comma
id|pd_idx
suffix:semicolon
r_int
r_int
id|first_sector
suffix:semicolon
r_int
id|raid_disks
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
r_int
id|data_disks
op_assign
id|raid_disks
op_minus
l_int|1
suffix:semicolon
r_int
id|redone
op_assign
l_int|0
suffix:semicolon
r_int
id|bufsize
suffix:semicolon
id|sh
op_assign
id|get_active_stripe
c_func
(paren
id|conf
comma
id|block_nr
op_lshift
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|bufsize
op_assign
id|sh-&gt;size
suffix:semicolon
id|redone
op_assign
id|block_nr
op_minus
(paren
id|sh-&gt;sector
op_rshift
l_int|1
)paren
suffix:semicolon
id|first_sector
op_assign
id|raid5_compute_sector
c_func
(paren
id|stripe
op_star
id|data_disks
op_star
id|sectors_per_chunk
op_plus
id|chunk_offset
comma
id|raid_disks
comma
id|data_disks
comma
op_amp
id|dd_idx
comma
op_amp
id|pd_idx
comma
id|conf
)paren
suffix:semicolon
id|sh-&gt;pd_idx
op_assign
id|pd_idx
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sh-&gt;lock
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|STRIPE_SYNCING
comma
op_amp
id|sh-&gt;state
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|STRIPE_INSYNC
comma
op_amp
id|sh-&gt;state
)paren
suffix:semicolon
id|sh-&gt;sync_redone
op_assign
id|redone
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sh-&gt;lock
)paren
suffix:semicolon
id|handle_stripe
c_func
(paren
id|sh
)paren
suffix:semicolon
id|release_stripe
c_func
(paren
id|sh
)paren
suffix:semicolon
r_return
(paren
id|bufsize
op_rshift
l_int|10
)paren
op_minus
id|redone
suffix:semicolon
)brace
multiline_comment|/*&n; * This is our raid5 kernel thread.&n; *&n; * We scan the hash table for stripes which can be handled now.&n; * During the scan, completed stripes are saved for us by the interrupt&n; * handler, so that they will not have to wait for our next wakeup.&n; */
DECL|function|raid5d
r_static
r_void
id|raid5d
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|stripe_head
op_star
id|sh
suffix:semicolon
id|raid5_conf_t
op_star
id|conf
op_assign
id|data
suffix:semicolon
id|mddev_t
op_star
id|mddev
op_assign
id|conf-&gt;mddev
suffix:semicolon
r_int
id|handled
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;+++ raid5d active&bslash;n&quot;
)paren
suffix:semicolon
id|handled
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;sb_dirty
)paren
(brace
id|mddev-&gt;sb_dirty
op_assign
l_int|0
suffix:semicolon
id|md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
id|md_spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|conf-&gt;handle_list
)paren
)paren
(brace
r_struct
id|list_head
op_star
id|first
op_assign
id|conf-&gt;handle_list.next
suffix:semicolon
id|sh
op_assign
id|list_entry
c_func
(paren
id|first
comma
r_struct
id|stripe_head
comma
id|lru
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
id|first
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|sh-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sh-&gt;count
)paren
op_ne
l_int|1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|md_spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|handled
op_increment
suffix:semicolon
id|handle_stripe
c_func
(paren
id|sh
)paren
suffix:semicolon
id|release_stripe
c_func
(paren
id|sh
)paren
suffix:semicolon
id|md_spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
)brace
id|PRINTK
c_func
(paren
l_string|&quot;%d stripes handled&bslash;n&quot;
comma
id|handled
)paren
suffix:semicolon
id|md_spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;--- raid5d inactive&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Private kernel thread for parity reconstruction after an unclean&n; * shutdown. Reconstruction on spare drives in case of a failed drive&n; * is done by the generic mdsyncd.&n; */
DECL|function|raid5syncd
r_static
r_void
id|raid5syncd
(paren
r_void
op_star
id|data
)paren
(brace
id|raid5_conf_t
op_star
id|conf
op_assign
id|data
suffix:semicolon
id|mddev_t
op_star
id|mddev
op_assign
id|conf-&gt;mddev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;resync_parity
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;resync_parity
op_eq
l_int|2
)paren
r_return
suffix:semicolon
id|down
c_func
(paren
op_amp
id|mddev-&gt;recovery_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|md_do_sync
c_func
(paren
id|mddev
comma
l_int|NULL
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|mddev-&gt;recovery_sem
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;raid5: resync aborted!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|conf-&gt;resync_parity
op_assign
l_int|0
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mddev-&gt;recovery_sem
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;raid5: resync finished.&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|__check_consistency
r_static
r_int
id|__check_consistency
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|row
)paren
(brace
id|raid5_conf_t
op_star
id|conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
(braket
id|MD_SB_DISKS
)braket
comma
op_star
id|tmp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|ret
op_assign
l_int|0
comma
id|nr
op_assign
l_int|0
comma
id|count
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh_ptr
(braket
id|MAX_XOR_BLOCKS
)braket
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;working_disks
op_ne
id|conf-&gt;raid_disks
)paren
r_goto
id|out
suffix:semicolon
id|tmp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|tmp
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|tmp-&gt;b_size
op_assign
l_int|4096
suffix:semicolon
id|tmp-&gt;b_page
op_assign
id|alloc_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
id|tmp-&gt;b_data
op_assign
id|page_address
c_func
(paren
id|tmp-&gt;b_page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp-&gt;b_data
)paren
r_goto
id|out
suffix:semicolon
id|md_clear_page
c_func
(paren
id|tmp-&gt;b_data
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bh
comma
l_int|0
comma
id|MD_SB_DISKS
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev
op_assign
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|dev
suffix:semicolon
id|set_blocksize
c_func
(paren
id|dev
comma
l_int|4096
)paren
suffix:semicolon
id|bh
(braket
id|i
)braket
op_assign
id|bread
c_func
(paren
id|dev
comma
id|row
op_div
l_int|4
comma
l_int|4096
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
id|nr
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nr
op_eq
id|conf-&gt;raid_disks
)paren
(brace
id|bh_ptr
(braket
l_int|0
)braket
op_assign
id|tmp
suffix:semicolon
id|count
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bh_ptr
(braket
id|count
op_increment
)braket
op_assign
id|bh
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
id|MAX_XOR_BLOCKS
)paren
(brace
id|xor_block
c_func
(paren
id|count
comma
op_amp
id|bh_ptr
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|count
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|count
op_ne
l_int|1
)paren
(brace
id|xor_block
c_func
(paren
id|count
comma
op_amp
id|bh_ptr
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|tmp-&gt;b_data
comma
id|bh
(braket
l_int|0
)braket
op_member_access_from_pointer
id|b_data
comma
l_int|4096
)paren
)paren
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev
op_assign
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|bh
(braket
id|i
)braket
)paren
(brace
id|bforget
c_func
(paren
id|bh
(braket
id|i
)braket
)paren
suffix:semicolon
id|bh
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|fsync_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|tmp-&gt;b_data
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|tmp
)paren
id|kfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|check_consistency
r_static
r_int
id|check_consistency
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_if
c_cond
(paren
id|__check_consistency
c_func
(paren
id|mddev
comma
l_int|0
)paren
)paren
multiline_comment|/*&n; * We are not checking this currently, as it&squot;s legitimate to have&n; * an inconsistent array, at creation time.&n; */
r_return
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|raid5_run
r_static
r_int
id|raid5_run
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|raid5_conf_t
op_star
id|conf
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|raid_disk
comma
id|memory
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
id|mdp_disk_t
op_star
id|desc
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|disk_info
op_star
id|disk
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
r_int
id|start_recovery
op_assign
l_int|0
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;level
op_ne
l_int|5
op_logical_and
id|sb-&gt;level
op_ne
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;raid5: md%d: raid level not set to 4/5 (%d)&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|sb-&gt;level
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|mddev
op_member_access_from_pointer
r_private
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|raid5_conf_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
)paren
op_eq
l_int|NULL
)paren
r_goto
m_abort
suffix:semicolon
id|memset
(paren
id|conf
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|conf
)paren
)paren
suffix:semicolon
id|conf-&gt;mddev
op_assign
id|mddev
suffix:semicolon
r_if
c_cond
(paren
(paren
id|conf-&gt;stripe_hashtbl
op_assign
(paren
r_struct
id|stripe_head
op_star
op_star
)paren
id|md__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|HASH_PAGES_ORDER
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
m_abort
suffix:semicolon
id|memset
c_func
(paren
id|conf-&gt;stripe_hashtbl
comma
l_int|0
comma
id|HASH_PAGES
op_star
id|PAGE_SIZE
)paren
suffix:semicolon
id|conf-&gt;device_lock
op_assign
id|MD_SPIN_LOCK_UNLOCKED
suffix:semicolon
id|md_init_waitqueue_head
c_func
(paren
op_amp
id|conf-&gt;wait_for_stripe
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|conf-&gt;handle_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|conf-&gt;inactive_list
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|conf-&gt;active_stripes
comma
l_int|0
)paren
suffix:semicolon
id|conf-&gt;buffer_size
op_assign
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/* good default for rebuild */
id|PRINTK
c_func
(paren
l_string|&quot;raid5_run(md%d) called.&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
multiline_comment|/*&n;&t;&t; * This is important -- we are using the descriptor on&n;&t;&t; * the disk only to get a pointer to the descriptor on&n;&t;&t; * the main superblock, which might be more recent.&n;&t;&t; */
id|desc
op_assign
id|sb-&gt;disks
op_plus
id|rdev-&gt;desc_nr
suffix:semicolon
id|raid_disk
op_assign
id|desc-&gt;raid_disk
suffix:semicolon
id|disk
op_assign
id|conf-&gt;disks
op_plus
id|raid_disk
suffix:semicolon
r_if
c_cond
(paren
id|disk_faulty
c_func
(paren
id|desc
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid5: disabled device %s (errors detected)&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;faulty
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|disk-&gt;number
op_assign
id|desc-&gt;number
suffix:semicolon
id|disk-&gt;raid_disk
op_assign
id|raid_disk
suffix:semicolon
id|disk-&gt;dev
op_assign
id|rdev-&gt;dev
suffix:semicolon
id|disk-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;spare
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;used_slot
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|disk_active
c_func
(paren
id|desc
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|disk_sync
c_func
(paren
id|desc
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid5: disabled device %s (not in sync)&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raid_disk
OG
id|sb-&gt;raid_disks
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid5: disabled device %s (inconsistent descriptor)&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|disk-&gt;operational
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid5: disabled device %s (device %d already operational)&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|raid_disk
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;raid5: device %s operational as raid disk %d&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|raid_disk
)paren
suffix:semicolon
id|disk-&gt;number
op_assign
id|desc-&gt;number
suffix:semicolon
id|disk-&gt;raid_disk
op_assign
id|raid_disk
suffix:semicolon
id|disk-&gt;dev
op_assign
id|rdev-&gt;dev
suffix:semicolon
id|disk-&gt;operational
op_assign
l_int|1
suffix:semicolon
id|disk-&gt;used_slot
op_assign
l_int|1
suffix:semicolon
id|conf-&gt;working_disks
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Must be a spare disk ..&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;raid5: spare disk %s&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
id|disk-&gt;number
op_assign
id|desc-&gt;number
suffix:semicolon
id|disk-&gt;raid_disk
op_assign
id|raid_disk
suffix:semicolon
id|disk-&gt;dev
op_assign
id|rdev-&gt;dev
suffix:semicolon
id|disk-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;spare
op_assign
l_int|1
suffix:semicolon
id|disk-&gt;used_slot
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|desc
op_assign
id|sb-&gt;disks
op_plus
id|i
suffix:semicolon
id|raid_disk
op_assign
id|desc-&gt;raid_disk
suffix:semicolon
id|disk
op_assign
id|conf-&gt;disks
op_plus
id|raid_disk
suffix:semicolon
r_if
c_cond
(paren
id|disk_faulty
c_func
(paren
id|desc
)paren
op_logical_and
(paren
id|raid_disk
OL
id|sb-&gt;raid_disks
)paren
op_logical_and
op_logical_neg
id|conf-&gt;disks
(braket
id|raid_disk
)braket
dot
id|used_slot
)paren
(brace
id|disk-&gt;number
op_assign
id|desc-&gt;number
suffix:semicolon
id|disk-&gt;raid_disk
op_assign
id|raid_disk
suffix:semicolon
id|disk-&gt;dev
op_assign
id|MKDEV
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|disk-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;spare
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;used_slot
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|conf-&gt;raid_disks
op_assign
id|sb-&gt;raid_disks
suffix:semicolon
multiline_comment|/*&n;&t; * 0 for a fully functional array, 1 for a degraded array.&n;&t; */
id|conf-&gt;failed_disks
op_assign
id|conf-&gt;raid_disks
op_minus
id|conf-&gt;working_disks
suffix:semicolon
id|conf-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|conf-&gt;chunk_size
op_assign
id|sb-&gt;chunk_size
suffix:semicolon
id|conf-&gt;level
op_assign
id|sb-&gt;level
suffix:semicolon
id|conf-&gt;algorithm
op_assign
id|sb-&gt;layout
suffix:semicolon
id|conf-&gt;max_nr_stripes
op_assign
id|NR_STRIPES
suffix:semicolon
macro_line|#if 0
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|used_slot
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;chunk_size
op_logical_or
id|conf-&gt;chunk_size
op_mod
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid5: invalid chunk size %d for md%d&bslash;n&quot;
comma
id|conf-&gt;chunk_size
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|conf-&gt;algorithm
OG
id|ALGORITHM_RIGHT_SYMMETRIC
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid5: unsupported parity algorithm %d for md%d&bslash;n&quot;
comma
id|conf-&gt;algorithm
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|conf-&gt;failed_disks
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid5: not enough operational devices for md%d (%d/%d failed)&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|conf-&gt;failed_disks
comma
id|conf-&gt;raid_disks
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|conf-&gt;working_disks
op_ne
id|sb-&gt;raid_disks
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;raid5: md%d, not all disks are operational -- trying to recover array&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|start_recovery
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|start_recovery
op_logical_and
(paren
id|sb-&gt;state
op_amp
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
)paren
op_logical_and
id|check_consistency
c_func
(paren
id|mddev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid5: detected raid-5 superblock xor inconsistency -- running resync&bslash;n&quot;
)paren
suffix:semicolon
id|sb-&gt;state
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
suffix:semicolon
)brace
(brace
r_const
r_char
op_star
id|name
op_assign
l_string|&quot;raid5d&quot;
suffix:semicolon
id|conf-&gt;thread
op_assign
id|md_register_thread
c_func
(paren
id|raid5d
comma
id|conf
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;thread
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid5: couldn&squot;t allocate thread for md%d&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
id|memory
op_assign
id|conf-&gt;max_nr_stripes
op_star
(paren
r_sizeof
(paren
r_struct
id|stripe_head
)paren
op_plus
id|conf-&gt;raid_disks
op_star
(paren
(paren
r_sizeof
(paren
r_struct
id|buffer_head
)paren
op_plus
id|PAGE_SIZE
)paren
)paren
)paren
op_div
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
id|grow_stripes
c_func
(paren
id|conf
comma
id|conf-&gt;max_nr_stripes
comma
id|GFP_KERNEL
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid5: couldn&squot;t allocate %dkB for buffers&bslash;n&quot;
comma
id|memory
)paren
suffix:semicolon
id|shrink_stripes
c_func
(paren
id|conf
comma
id|conf-&gt;max_nr_stripes
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;raid5: allocated %dkB for md%d&bslash;n&quot;
comma
id|memory
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Regenerate the &quot;device is in sync with the raid set&quot; bit for&n;&t; * each device.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mark_disk_nonsync
c_func
(paren
id|sb-&gt;disks
op_plus
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sb-&gt;raid_disks
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;disks
(braket
id|j
)braket
dot
id|operational
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;disks
(braket
id|i
)braket
dot
id|number
op_eq
id|conf-&gt;disks
(braket
id|j
)braket
dot
id|number
)paren
id|mark_disk_sync
c_func
(paren
id|sb-&gt;disks
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
id|sb-&gt;active_disks
op_assign
id|conf-&gt;working_disks
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;active_disks
op_eq
id|sb-&gt;raid_disks
)paren
id|printk
c_func
(paren
l_string|&quot;raid5: raid level %d set md%d active with %d out of %d devices, algorithm %d&bslash;n&quot;
comma
id|conf-&gt;level
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|sb-&gt;active_disks
comma
id|sb-&gt;raid_disks
comma
id|conf-&gt;algorithm
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;raid5: raid level %d set md%d active with %d out of %d devices, algorithm %d&bslash;n&quot;
comma
id|conf-&gt;level
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|sb-&gt;active_disks
comma
id|sb-&gt;raid_disks
comma
id|conf-&gt;algorithm
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|start_recovery
op_logical_and
op_logical_neg
(paren
id|sb-&gt;state
op_amp
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
)paren
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
l_string|&quot;raid5syncd&quot;
suffix:semicolon
id|conf-&gt;resync_thread
op_assign
id|md_register_thread
c_func
(paren
id|raid5syncd
comma
id|conf
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;resync_thread
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid5: couldn&squot;t allocate thread for md%d&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;raid5: raid set md%d not clean; reconstructing parity&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|conf-&gt;resync_parity
op_assign
l_int|1
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|conf-&gt;resync_thread
)paren
suffix:semicolon
)brace
id|print_raid5_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_recovery
)paren
id|md_recover_arrays
c_func
(paren
)paren
suffix:semicolon
id|print_raid5_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
multiline_comment|/* Ok, everything is just fine now */
r_return
(paren
l_int|0
)paren
suffix:semicolon
m_abort
suffix:colon
r_if
c_cond
(paren
id|conf
)paren
(brace
id|print_raid5_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;stripe_hashtbl
)paren
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|conf-&gt;stripe_hashtbl
comma
id|HASH_PAGES_ORDER
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|conf
)paren
suffix:semicolon
)brace
id|mddev
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;raid5: failed to run raid set md%d&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|raid5_stop_resync
r_static
r_int
id|raid5_stop_resync
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|raid5_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mdk_thread_t
op_star
id|thread
op_assign
id|conf-&gt;resync_thread
suffix:semicolon
r_if
c_cond
(paren
id|thread
)paren
(brace
r_if
c_cond
(paren
id|conf-&gt;resync_parity
)paren
(brace
id|conf-&gt;resync_parity
op_assign
l_int|2
suffix:semicolon
id|md_interrupt_thread
c_func
(paren
id|thread
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;raid5: parity resync was not fully finished, restarting next time.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|raid5_restart_resync
r_static
r_int
id|raid5_restart_resync
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|raid5_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;resync_parity
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;resync_thread
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;raid5: waking up raid5resync.&bslash;n&quot;
)paren
suffix:semicolon
id|conf-&gt;resync_parity
op_assign
l_int|1
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|conf-&gt;resync_thread
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;raid5: no restart-resync needed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|raid5_stop
r_static
r_int
id|raid5_stop
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|raid5_conf_t
op_star
id|conf
op_assign
(paren
id|raid5_conf_t
op_star
)paren
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;resync_thread
)paren
id|md_unregister_thread
c_func
(paren
id|conf-&gt;resync_thread
)paren
suffix:semicolon
id|md_unregister_thread
c_func
(paren
id|conf-&gt;thread
)paren
suffix:semicolon
id|shrink_stripes
c_func
(paren
id|conf
comma
id|conf-&gt;max_nr_stripes
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|conf-&gt;stripe_hashtbl
comma
id|HASH_PAGES_ORDER
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|conf
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if RAID5_DEBUG
DECL|function|print_sh
r_static
r_void
id|print_sh
(paren
r_struct
id|stripe_head
op_star
id|sh
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sh %lu, size %d, pd_idx %d, state %ld.&bslash;n&quot;
comma
id|sh-&gt;sector
comma
id|sh-&gt;size
comma
id|sh-&gt;pd_idx
comma
id|sh-&gt;state
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sh %lu,  count %d.&bslash;n&quot;
comma
id|sh-&gt;sector
comma
id|atomic_read
c_func
(paren
op_amp
id|sh-&gt;count
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sh %lu, &quot;
comma
id|sh-&gt;sector
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sh-&gt;bh_cache
(braket
id|i
)braket
)paren
id|printk
c_func
(paren
l_string|&quot;(cache%d: %p %ld) &quot;
comma
id|i
comma
id|sh-&gt;bh_cache
(braket
id|i
)braket
comma
id|sh-&gt;bh_cache
(braket
id|i
)braket
op_member_access_from_pointer
id|b_state
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|printall
r_static
r_void
id|printall
(paren
id|raid5_conf_t
op_star
id|conf
)paren
(brace
r_struct
id|stripe_head
op_star
id|sh
suffix:semicolon
r_int
id|i
suffix:semicolon
id|md_spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HASH
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sh
op_assign
id|conf-&gt;stripe_hashtbl
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|sh
suffix:semicolon
id|sh
op_assign
id|sh-&gt;hash_next
)paren
(brace
r_if
c_cond
(paren
id|sh-&gt;raid_conf
op_ne
id|conf
)paren
r_continue
suffix:semicolon
id|print_sh
c_func
(paren
id|sh
)paren
suffix:semicolon
)brace
)brace
id|md_spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;--- raid5d inactive&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|raid5_status
r_static
r_int
id|raid5_status
(paren
r_char
op_star
id|page
comma
id|mddev_t
op_star
id|mddev
)paren
(brace
id|raid5_conf_t
op_star
id|conf
op_assign
(paren
id|raid5_conf_t
op_star
)paren
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
r_int
id|sz
op_assign
l_int|0
comma
id|i
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; level %d, %dk chunk, algorithm %d&quot;
comma
id|sb-&gt;level
comma
id|sb-&gt;chunk_size
op_rshift
l_int|10
comma
id|sb-&gt;layout
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; [%d/%d] [&quot;
comma
id|conf-&gt;raid_disks
comma
id|conf-&gt;working_disks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;%s&quot;
comma
id|conf-&gt;disks
(braket
id|i
)braket
dot
id|operational
ques
c_cond
l_string|&quot;U&quot;
suffix:colon
l_string|&quot;_&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;]&quot;
)paren
suffix:semicolon
macro_line|#if RAID5_DEBUG
DECL|macro|D
mdefine_line|#define D(x) &bslash;&n;&t;sz += sprintf (page+sz, &quot;&lt;&quot;#x&quot;:%d&gt;&quot;, atomic_read(&amp;conf-&gt;x))
id|printall
c_func
(paren
id|conf
)paren
suffix:semicolon
macro_line|#endif
r_return
id|sz
suffix:semicolon
)brace
DECL|function|print_raid5_conf
r_static
r_void
id|print_raid5_conf
(paren
id|raid5_conf_t
op_star
id|conf
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|disk_info
op_star
id|tmp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RAID5 conf printout:&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(conf==NULL)&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; --- rd:%d wd:%d fd:%d&bslash;n&quot;
comma
id|conf-&gt;raid_disks
comma
id|conf-&gt;working_disks
comma
id|conf-&gt;failed_disks
)paren
suffix:semicolon
macro_line|#if RAID5_DEBUG
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;working_disks
op_plus
id|conf-&gt;failed_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#endif
id|tmp
op_assign
id|conf-&gt;disks
op_plus
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; disk %d, s:%d, o:%d, n:%d rd:%d us:%d dev:%s&bslash;n&quot;
comma
id|i
comma
id|tmp-&gt;spare
comma
id|tmp-&gt;operational
comma
id|tmp-&gt;number
comma
id|tmp-&gt;raid_disk
comma
id|tmp-&gt;used_slot
comma
id|partition_name
c_func
(paren
id|tmp-&gt;dev
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|raid5_diskop
r_static
r_int
id|raid5_diskop
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdp_disk_t
op_star
op_star
id|d
comma
r_int
id|state
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|failed_disk
op_assign
op_minus
l_int|1
comma
id|spare_disk
op_assign
op_minus
l_int|1
comma
id|removed_disk
op_assign
op_minus
l_int|1
comma
id|added_disk
op_assign
op_minus
l_int|1
suffix:semicolon
id|raid5_conf_t
op_star
id|conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|disk_info
op_star
id|tmp
comma
op_star
id|sdisk
comma
op_star
id|fdisk
comma
op_star
id|rdisk
comma
op_star
id|adisk
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
id|mdp_disk_t
op_star
id|failed_desc
comma
op_star
id|spare_desc
comma
op_star
id|added_desc
suffix:semicolon
id|print_raid5_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
id|md_spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * find the disk ...&n;&t; */
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|DISKOP_SPARE_ACTIVE
suffix:colon
multiline_comment|/*&n;&t;&t; * Find the failed disk within the RAID5 configuration ...&n;&t;&t; * (this can only be in the first conf-&gt;raid_disks part)&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;disks
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|tmp-&gt;operational
op_logical_and
op_logical_neg
id|tmp-&gt;spare
)paren
op_logical_or
op_logical_neg
id|tmp-&gt;used_slot
)paren
(brace
id|failed_disk
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * When we activate a spare disk we _must_ have a disk in&n;&t;&t; * the lower (active) part of the array to replace.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|failed_disk
op_eq
op_minus
l_int|1
)paren
op_logical_or
(paren
id|failed_disk
op_ge
id|conf-&gt;raid_disks
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
multiline_comment|/* fall through */
r_case
id|DISKOP_SPARE_WRITE
suffix:colon
r_case
id|DISKOP_SPARE_INACTIVE
suffix:colon
multiline_comment|/*&n;&t;&t; * Find the spare disk ... (can only be in the &squot;high&squot;&n;&t;&t; * area of the array)&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;disks
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;spare
op_logical_and
id|tmp-&gt;number
op_eq
(paren
op_star
id|d
)paren
op_member_access_from_pointer
id|number
)paren
(brace
id|spare_disk
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|spare_disk
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISKOP_HOT_REMOVE_DISK
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;disks
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;used_slot
op_logical_and
(paren
id|tmp-&gt;number
op_eq
(paren
op_star
id|d
)paren
op_member_access_from_pointer
id|number
)paren
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;operational
)paren
(brace
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|removed_disk
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|removed_disk
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISKOP_HOT_ADD_DISK
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;disks
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp-&gt;used_slot
)paren
(brace
id|added_disk
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|added_disk
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|state
)paren
(brace
multiline_comment|/*&n;&t; * Switch the spare disk to write-only mode:&n;&t; */
r_case
id|DISKOP_SPARE_WRITE
suffix:colon
r_if
c_cond
(paren
id|conf-&gt;spare
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|sdisk
op_assign
id|conf-&gt;disks
op_plus
id|spare_disk
suffix:semicolon
id|sdisk-&gt;operational
op_assign
l_int|1
suffix:semicolon
id|sdisk-&gt;write_only
op_assign
l_int|1
suffix:semicolon
id|conf-&gt;spare
op_assign
id|sdisk
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * Deactivate a spare disk:&n;&t; */
r_case
id|DISKOP_SPARE_INACTIVE
suffix:colon
id|sdisk
op_assign
id|conf-&gt;disks
op_plus
id|spare_disk
suffix:semicolon
id|sdisk-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|sdisk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Was the spare being resynced?&n;&t;&t; */
r_if
c_cond
(paren
id|conf-&gt;spare
op_eq
id|sdisk
)paren
id|conf-&gt;spare
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * Activate (mark read-write) the (now sync) spare disk,&n;&t; * which means we switch it&squot;s &squot;raid position&squot; (-&gt;raid_disk)&n;&t; * with the failed disk. (only the first &squot;conf-&gt;raid_disks&squot;&n;&t; * slots are used for &squot;real&squot; disks and we must preserve this&n;&t; * property)&n;&t; */
r_case
id|DISKOP_SPARE_ACTIVE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;spare
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|sdisk
op_assign
id|conf-&gt;disks
op_plus
id|spare_disk
suffix:semicolon
id|fdisk
op_assign
id|conf-&gt;disks
op_plus
id|failed_disk
suffix:semicolon
id|spare_desc
op_assign
op_amp
id|sb-&gt;disks
(braket
id|sdisk-&gt;number
)braket
suffix:semicolon
id|failed_desc
op_assign
op_amp
id|sb-&gt;disks
(braket
id|fdisk-&gt;number
)braket
suffix:semicolon
r_if
c_cond
(paren
id|spare_desc
op_ne
op_star
id|d
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|spare_desc-&gt;raid_disk
op_ne
id|sdisk-&gt;raid_disk
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sdisk-&gt;raid_disk
op_ne
id|spare_disk
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|failed_desc-&gt;raid_disk
op_ne
id|fdisk-&gt;raid_disk
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdisk-&gt;raid_disk
op_ne
id|failed_disk
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * do the switch finally&n;&t;&t; */
id|xchg_values
c_func
(paren
op_star
id|spare_desc
comma
op_star
id|failed_desc
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
op_star
id|fdisk
comma
op_star
id|sdisk
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * (careful, &squot;failed&squot; and &squot;spare&squot; are switched from now on)&n;&t;&t; *&n;&t;&t; * we want to preserve linear numbering and we want to&n;&t;&t; * give the proper raid_disk number to the now activated&n;&t;&t; * disk. (this means we switch back these values)&n;&t;&t; */
id|xchg_values
c_func
(paren
id|spare_desc-&gt;raid_disk
comma
id|failed_desc-&gt;raid_disk
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
id|sdisk-&gt;raid_disk
comma
id|fdisk-&gt;raid_disk
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
id|spare_desc-&gt;number
comma
id|failed_desc-&gt;number
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
id|sdisk-&gt;number
comma
id|fdisk-&gt;number
)paren
suffix:semicolon
op_star
id|d
op_assign
id|failed_desc
suffix:semicolon
r_if
c_cond
(paren
id|sdisk-&gt;dev
op_eq
id|MKDEV
c_func
(paren
l_int|0
comma
l_int|0
)paren
)paren
id|sdisk-&gt;used_slot
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * this really activates the spare.&n;&t;&t; */
id|fdisk-&gt;spare
op_assign
l_int|0
suffix:semicolon
id|fdisk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if we activate a spare, we definitely replace a&n;&t;&t; * non-operational disk slot in the &squot;low&squot; area of&n;&t;&t; * the disk array.&n;&t;&t; */
id|conf-&gt;failed_disks
op_decrement
suffix:semicolon
id|conf-&gt;working_disks
op_increment
suffix:semicolon
id|conf-&gt;spare
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DISKOP_HOT_REMOVE_DISK
suffix:colon
id|rdisk
op_assign
id|conf-&gt;disks
op_plus
id|removed_disk
suffix:semicolon
r_if
c_cond
(paren
id|rdisk-&gt;spare
op_logical_and
(paren
id|removed_disk
OL
id|conf-&gt;raid_disks
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|rdisk-&gt;dev
op_assign
id|MKDEV
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|rdisk-&gt;used_slot
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DISKOP_HOT_ADD_DISK
suffix:colon
id|adisk
op_assign
id|conf-&gt;disks
op_plus
id|added_disk
suffix:semicolon
id|added_desc
op_assign
op_star
id|d
suffix:semicolon
r_if
c_cond
(paren
id|added_disk
op_ne
id|added_desc-&gt;number
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|adisk-&gt;number
op_assign
id|added_desc-&gt;number
suffix:semicolon
id|adisk-&gt;raid_disk
op_assign
id|added_desc-&gt;raid_disk
suffix:semicolon
id|adisk-&gt;dev
op_assign
id|MKDEV
c_func
(paren
id|added_desc-&gt;major
comma
id|added_desc-&gt;minor
)paren
suffix:semicolon
id|adisk-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|adisk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
id|adisk-&gt;spare
op_assign
l_int|1
suffix:semicolon
id|adisk-&gt;used_slot
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
m_abort
suffix:colon
id|md_spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|print_raid5_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|raid5_personality
r_static
id|mdk_personality_t
id|raid5_personality
op_assign
(brace
id|name
suffix:colon
l_string|&quot;raid5&quot;
comma
id|make_request
suffix:colon
id|raid5_make_request
comma
id|run
suffix:colon
id|raid5_run
comma
id|stop
suffix:colon
id|raid5_stop
comma
id|status
suffix:colon
id|raid5_status
comma
id|error_handler
suffix:colon
id|raid5_error
comma
id|diskop
suffix:colon
id|raid5_diskop
comma
id|stop_resync
suffix:colon
id|raid5_stop_resync
comma
id|restart_resync
suffix:colon
id|raid5_restart_resync
comma
id|sync_request
suffix:colon
id|raid5_sync_request
)brace
suffix:semicolon
DECL|function|raid5_init
r_static
r_int
id|md__init
id|raid5_init
(paren
r_void
)paren
(brace
r_return
id|register_md_personality
(paren
id|RAID5
comma
op_amp
id|raid5_personality
)paren
suffix:semicolon
)brace
DECL|function|raid5_exit
r_static
r_void
id|raid5_exit
(paren
r_void
)paren
(brace
id|unregister_md_personality
(paren
id|RAID5
)paren
suffix:semicolon
)brace
DECL|variable|raid5_init
id|module_init
c_func
(paren
id|raid5_init
)paren
suffix:semicolon
DECL|variable|raid5_exit
id|module_exit
c_func
(paren
id|raid5_exit
)paren
suffix:semicolon
eof
