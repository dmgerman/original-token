multiline_comment|/*&n;   md.c : Multiple Devices driver for Linux&n;&t;  Copyright (C) 1998, 1999, 2000 Ingo Molnar&n;&n;     completely rewritten, based on the MD driver code from Marc Zyngier&n;&n;   Changes:&n;&n;   - RAID-1/RAID-5 extensions by Miguel de Icaza, Gadi Oxman, Ingo Molnar&n;   - boot support for linear and striped mode by Harald Hoyer &lt;HarryH@Royal.Net&gt;&n;   - kerneld support by Boris Tobotras &lt;boris@xtalk.msk.su&gt;&n;   - kmod support by: Cyrus Durgin&n;   - RAID0 bugfixes: Mark Anthony Lisher &lt;markal@iname.com&gt;&n;   - Devfs support by Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&n;   - lots of fixes and improvements to the RAID1/RAID5 and generic&n;     RAID code (such as request based resynchronization):&n;&n;     Neil Brown &lt;neilb@cse.unsw.edu.au&gt;.&n;&n;   This program is free software; you can redistribute it and/or modify&n;   it under the terms of the GNU General Public License as published by&n;   the Free Software Foundation; either version 2, or (at your option)&n;   any later version.&n;&n;   You should have received a copy of the GNU General Public License&n;   (for example /usr/src/linux/COPYING); if not, write to the Free&n;   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/raid/md.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/raid/xor.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#ifdef CONFIG_KMOD
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#endif
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
r_extern
id|asmlinkage
r_int
id|sys_sched_yield
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|sys_setsid
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR MD_MAJOR
DECL|macro|MD_DRIVER
mdefine_line|#define MD_DRIVER
macro_line|#include &lt;linux/blk.h&gt;
DECL|macro|DEBUG
mdefine_line|#define DEBUG 0
macro_line|#if DEBUG
DECL|macro|dprintk
macro_line|# define dprintk(x...) printk(x)
macro_line|#else
DECL|macro|dprintk
macro_line|# define dprintk(x...) do { } while(0)
macro_line|#endif
DECL|variable|pers
r_static
id|mdk_personality_t
op_star
id|pers
(braket
id|MAX_PERSONALITY
)braket
suffix:semicolon
multiline_comment|/*&n; * Current RAID-1,4,5 parallel reconstruction &squot;guaranteed speed limit&squot;&n; * is 100 KB/sec, so the extra system load does not show up that much.&n; * Increase it if you want to have more _guaranteed_ speed. Note that&n; * the RAID driver will use the maximum available bandwith if the IO&n; * subsystem is idle. There is also an &squot;absolute maximum&squot; reconstruction&n; * speed limit - in case reconstruction slows down your system despite&n; * idle IO detection.&n; *&n; * you can change it via /proc/sys/dev/raid/speed_limit_min and _max.&n; */
DECL|variable|sysctl_speed_limit_min
r_static
r_int
id|sysctl_speed_limit_min
op_assign
l_int|100
suffix:semicolon
DECL|variable|sysctl_speed_limit_max
r_static
r_int
id|sysctl_speed_limit_max
op_assign
l_int|100000
suffix:semicolon
DECL|variable|raid_table_header
r_static
r_struct
id|ctl_table_header
op_star
id|raid_table_header
suffix:semicolon
DECL|variable|raid_table
r_static
id|ctl_table
id|raid_table
(braket
)braket
op_assign
(brace
(brace
id|DEV_RAID_SPEED_LIMIT_MIN
comma
l_string|&quot;speed_limit_min&quot;
comma
op_amp
id|sysctl_speed_limit_min
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
id|DEV_RAID_SPEED_LIMIT_MAX
comma
l_string|&quot;speed_limit_max&quot;
comma
op_amp
id|sysctl_speed_limit_max
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|raid_dir_table
r_static
id|ctl_table
id|raid_dir_table
(braket
)braket
op_assign
(brace
(brace
id|DEV_RAID
comma
l_string|&quot;raid&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|raid_table
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|raid_root_table
r_static
id|ctl_table
id|raid_root_table
(braket
)braket
op_assign
(brace
(brace
id|CTL_DEV
comma
l_string|&quot;dev&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|raid_dir_table
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * these have to be allocated separately because external&n; * subsystems want to have a pre-defined structure&n; */
DECL|variable|md_hd_struct
r_struct
id|hd_struct
id|md_hd_struct
(braket
id|MAX_MD_DEVS
)braket
suffix:semicolon
DECL|variable|md_blocksizes
r_static
r_int
id|md_blocksizes
(braket
id|MAX_MD_DEVS
)braket
suffix:semicolon
DECL|variable|md_hardsect_sizes
r_static
r_int
id|md_hardsect_sizes
(braket
id|MAX_MD_DEVS
)braket
suffix:semicolon
DECL|variable|md_maxreadahead
r_static
r_int
id|md_maxreadahead
(braket
id|MAX_MD_DEVS
)braket
suffix:semicolon
DECL|variable|md_recovery_thread
r_static
id|mdk_thread_t
op_star
id|md_recovery_thread
suffix:semicolon
DECL|variable|md_size
r_int
id|md_size
(braket
id|MAX_MD_DEVS
)braket
suffix:semicolon
r_extern
r_struct
id|block_device_operations
id|md_fops
suffix:semicolon
DECL|variable|devfs_handle
r_static
id|devfs_handle_t
id|devfs_handle
suffix:semicolon
DECL|variable|md_gendisk
r_static
r_struct
id|gendisk
id|md_gendisk
op_assign
(brace
id|major
suffix:colon
id|MD_MAJOR
comma
id|major_name
suffix:colon
l_string|&quot;md&quot;
comma
id|minor_shift
suffix:colon
l_int|0
comma
id|max_p
suffix:colon
l_int|1
comma
id|part
suffix:colon
id|md_hd_struct
comma
id|sizes
suffix:colon
id|md_size
comma
id|nr_real
suffix:colon
id|MAX_MD_DEVS
comma
id|real_devices
suffix:colon
l_int|NULL
comma
id|next
suffix:colon
l_int|NULL
comma
id|fops
suffix:colon
op_amp
id|md_fops
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Enables to iterate over all existing md arrays&n; */
r_static
id|MD_LIST_HEAD
c_func
(paren
id|all_mddevs
)paren
suffix:semicolon
multiline_comment|/*&n; * The mapping between kdev and mddev is not necessary a simple&n; * one! Eg. HSM uses several sub-devices to implement Logical&n; * Volumes. All these sub-devices map to the same mddev.&n; */
DECL|variable|mddev_map
id|dev_mapping_t
id|mddev_map
(braket
id|MAX_MD_DEVS
)braket
suffix:semicolon
DECL|function|add_mddev_mapping
r_void
id|add_mddev_mapping
(paren
id|mddev_t
op_star
id|mddev
comma
id|kdev_t
id|dev
comma
r_void
op_star
id|data
)paren
(brace
r_int
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|dev
)paren
op_ne
id|MD_MAJOR
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev_map
(braket
id|minor
)braket
dot
id|mddev
op_ne
l_int|NULL
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|mddev_map
(braket
id|minor
)braket
dot
id|mddev
op_assign
id|mddev
suffix:semicolon
id|mddev_map
(braket
id|minor
)braket
dot
id|data
op_assign
id|data
suffix:semicolon
)brace
DECL|function|del_mddev_mapping
r_void
id|del_mddev_mapping
(paren
id|mddev_t
op_star
id|mddev
comma
id|kdev_t
id|dev
)paren
(brace
r_int
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|dev
)paren
op_ne
id|MD_MAJOR
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev_map
(braket
id|minor
)braket
dot
id|mddev
op_ne
id|mddev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|mddev_map
(braket
id|minor
)braket
dot
id|mddev
op_assign
l_int|NULL
suffix:semicolon
id|mddev_map
(braket
id|minor
)braket
dot
id|data
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|md_make_request
r_static
r_int
id|md_make_request
(paren
id|request_queue_t
op_star
id|q
comma
r_int
id|rw
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|kdev_to_mddev
c_func
(paren
id|bh-&gt;b_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev
op_logical_and
id|mddev-&gt;pers
)paren
r_return
id|mddev-&gt;pers
op_member_access_from_pointer
id|make_request
c_func
(paren
id|mddev
comma
id|rw
comma
id|bh
)paren
suffix:semicolon
r_else
(brace
id|buffer_IO_error
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|alloc_mddev
r_static
id|mddev_t
op_star
id|alloc_mddev
(paren
id|kdev_t
id|dev
)paren
(brace
id|mddev_t
op_star
id|mddev
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|dev
)paren
op_ne
id|MD_MAJOR
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|mddev
op_assign
(paren
id|mddev_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|mddev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|mddev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|mddev
)paren
)paren
suffix:semicolon
id|mddev-&gt;__minor
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|mddev-&gt;reconfig_sem
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|mddev-&gt;recovery_sem
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|mddev-&gt;resync_sem
)paren
suffix:semicolon
id|MD_INIT_LIST_HEAD
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
suffix:semicolon
id|MD_INIT_LIST_HEAD
c_func
(paren
op_amp
id|mddev-&gt;all_mddevs
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|mddev-&gt;active
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The &squot;base&squot; mddev is the one with data NULL.&n;&t; * personalities can create additional mddevs&n;&t; * if necessary.&n;&t; */
id|add_mddev_mapping
c_func
(paren
id|mddev
comma
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|md_list_add
c_func
(paren
op_amp
id|mddev-&gt;all_mddevs
comma
op_amp
id|all_mddevs
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
id|mddev
suffix:semicolon
)brace
DECL|function|find_gendisk
r_struct
id|gendisk
op_star
id|find_gendisk
(paren
id|kdev_t
id|dev
)paren
(brace
r_struct
id|gendisk
op_star
id|tmp
op_assign
id|gendisk_head
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;major
op_eq
id|MAJOR
c_func
(paren
id|dev
)paren
)paren
r_return
(paren
id|tmp
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|find_rdev_nr
id|mdk_rdev_t
op_star
id|find_rdev_nr
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|nr
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
id|nr
)paren
r_return
id|rdev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|find_rdev
id|mdk_rdev_t
op_star
id|find_rdev
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|kdev_t
id|dev
)paren
(brace
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;dev
op_eq
id|dev
)paren
r_return
id|rdev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
id|MD_LIST_HEAD
c_func
(paren
id|device_names
)paren
suffix:semicolon
DECL|function|partition_name
r_char
op_star
id|partition_name
(paren
id|kdev_t
id|dev
)paren
(brace
r_struct
id|gendisk
op_star
id|hd
suffix:semicolon
r_static
r_char
id|nomem
(braket
)braket
op_assign
l_string|&quot;&lt;nomem&gt;&quot;
suffix:semicolon
id|dev_name_t
op_star
id|dname
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
op_assign
id|device_names.next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
op_amp
id|device_names
)paren
(brace
id|dname
op_assign
id|md_list_entry
c_func
(paren
id|tmp
comma
id|dev_name_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dname-&gt;dev
op_eq
id|dev
)paren
r_return
id|dname-&gt;name
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
id|dname
op_assign
(paren
id|dev_name_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|dname
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dname
)paren
r_return
id|nomem
suffix:semicolon
multiline_comment|/*&n;&t; * ok, add this new device name to the list&n;&t; */
id|hd
op_assign
id|find_gendisk
(paren
id|dev
)paren
suffix:semicolon
id|dname-&gt;name
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|hd
)paren
id|dname-&gt;name
op_assign
id|disk_name
(paren
id|hd
comma
id|MINOR
c_func
(paren
id|dev
)paren
comma
id|dname-&gt;namebuf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dname-&gt;name
)paren
(brace
id|sprintf
(paren
id|dname-&gt;namebuf
comma
l_string|&quot;[dev %s]&quot;
comma
id|kdevname
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|dname-&gt;name
op_assign
id|dname-&gt;namebuf
suffix:semicolon
)brace
id|dname-&gt;dev
op_assign
id|dev
suffix:semicolon
id|MD_INIT_LIST_HEAD
c_func
(paren
op_amp
id|dname-&gt;list
)paren
suffix:semicolon
id|md_list_add
c_func
(paren
op_amp
id|dname-&gt;list
comma
op_amp
id|device_names
)paren
suffix:semicolon
r_return
id|dname-&gt;name
suffix:semicolon
)brace
DECL|function|calc_dev_sboffset
r_static
r_int
r_int
id|calc_dev_sboffset
(paren
id|kdev_t
id|dev
comma
id|mddev_t
op_star
id|mddev
comma
r_int
id|persistent
)paren
(brace
r_int
r_int
id|size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|blk_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
)paren
id|size
op_assign
id|blk_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|persistent
)paren
id|size
op_assign
id|MD_NEW_SIZE_BLOCKS
c_func
(paren
id|size
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
DECL|function|calc_dev_size
r_static
r_int
r_int
id|calc_dev_size
(paren
id|kdev_t
id|dev
comma
id|mddev_t
op_star
id|mddev
comma
r_int
id|persistent
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
id|size
op_assign
id|calc_dev_sboffset
c_func
(paren
id|dev
comma
id|mddev
comma
id|persistent
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;sb-&gt;chunk_size
)paren
id|size
op_and_assign
op_complement
(paren
id|mddev-&gt;sb-&gt;chunk_size
op_div
l_int|1024
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
DECL|function|zoned_raid_size
r_static
r_int
r_int
id|zoned_raid_size
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * do size and offset calculations.&n;&t; */
id|mask
op_assign
op_complement
(paren
id|mddev-&gt;sb-&gt;chunk_size
op_div
l_int|1024
op_minus
l_int|1
)paren
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
id|rdev-&gt;size
op_and_assign
id|mask
suffix:semicolon
id|md_size
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_add_assign
id|rdev-&gt;size
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We check wether all devices are numbered from 0 to nb_dev-1. The&n; * order is guaranteed even after device name changes.&n; *&n; * Some personalities (raid0, linear) use this. Personalities that&n; * provide data have to be able to deal with loss of individual&n; * disks, so they do their checking themselves.&n; */
DECL|function|md_check_ordering
r_int
id|md_check_ordering
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|i
comma
id|c
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t; * First, all devices must be fully functional&n;&t; */
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: md%d&squot;s device %s faulty, aborting.&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
id|c
op_assign
l_int|0
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
id|c
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_ne
id|mddev-&gt;nb_dev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;nb_dev
op_ne
id|mddev-&gt;sb-&gt;raid_disks
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: md%d, array needs %d disks, has %d, aborting.&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|mddev-&gt;sb-&gt;raid_disks
comma
id|mddev-&gt;nb_dev
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now the numbering check&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mddev-&gt;nb_dev
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_assign
l_int|0
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
id|i
)paren
id|c
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: md%d, missing disk #%d, aborting.&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|i
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: md%d, too many disks #%d, aborting.&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|i
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
m_abort
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|remove_descriptor
r_static
r_void
id|remove_descriptor
(paren
id|mdp_disk_t
op_star
id|disk
comma
id|mdp_super_t
op_star
id|sb
)paren
(brace
r_if
c_cond
(paren
id|disk_active
c_func
(paren
id|disk
)paren
)paren
(brace
id|sb-&gt;working_disks
op_decrement
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|disk_spare
c_func
(paren
id|disk
)paren
)paren
(brace
id|sb-&gt;spare_disks
op_decrement
suffix:semicolon
id|sb-&gt;working_disks
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|sb-&gt;failed_disks
op_decrement
suffix:semicolon
)brace
)brace
id|sb-&gt;nr_disks
op_decrement
suffix:semicolon
id|disk-&gt;major
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;minor
op_assign
l_int|0
suffix:semicolon
id|mark_disk_removed
c_func
(paren
id|disk
)paren
suffix:semicolon
)brace
DECL|macro|BAD_MAGIC
mdefine_line|#define BAD_MAGIC KERN_ERR &bslash;&n;&quot;md: invalid raid superblock magic on %s&bslash;n&quot;
DECL|macro|BAD_MINOR
mdefine_line|#define BAD_MINOR KERN_ERR &bslash;&n;&quot;md: %s: invalid raid minor (%x)&bslash;n&quot;
DECL|macro|OUT_OF_MEM
mdefine_line|#define OUT_OF_MEM KERN_ALERT &bslash;&n;&quot;md: out of memory.&bslash;n&quot;
DECL|macro|NO_SB
mdefine_line|#define NO_SB KERN_ERR &bslash;&n;&quot;md: disabled device %s, could not read superblock.&bslash;n&quot;
DECL|macro|BAD_CSUM
mdefine_line|#define BAD_CSUM KERN_WARNING &bslash;&n;&quot;md: invalid superblock checksum on %s&bslash;n&quot;
DECL|function|alloc_array_sb
r_static
r_int
id|alloc_array_sb
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_if
c_cond
(paren
id|mddev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|mddev-&gt;sb
op_assign
(paren
id|mdp_super_t
op_star
)paren
id|__get_free_page
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|md_clear_page
c_func
(paren
id|mddev-&gt;sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|alloc_disk_sb
r_static
r_int
id|alloc_disk_sb
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;sb
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|rdev-&gt;sb
op_assign
(paren
id|mdp_super_t
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;sb
)paren
(brace
id|printk
(paren
id|OUT_OF_MEM
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|md_clear_page
c_func
(paren
id|rdev-&gt;sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|free_disk_sb
r_static
r_void
id|free_disk_sb
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;sb
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|rdev-&gt;sb
)paren
suffix:semicolon
id|rdev-&gt;sb
op_assign
l_int|NULL
suffix:semicolon
id|rdev-&gt;sb_offset
op_assign
l_int|0
suffix:semicolon
id|rdev-&gt;size
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;faulty
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|mark_rdev_faulty
r_static
r_void
id|mark_rdev_faulty
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|free_disk_sb
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|rdev-&gt;faulty
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|read_disk_sb
r_static
r_int
id|read_disk_sb
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
id|kdev_t
id|dev
op_assign
id|rdev-&gt;dev
suffix:semicolon
id|mdp_super_t
op_star
id|sb
suffix:semicolon
r_int
r_int
id|sb_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Calculate the position of the superblock,&n;&t; * it&squot;s at the end of the disk&n;&t; */
id|sb_offset
op_assign
id|calc_dev_sboffset
c_func
(paren
id|rdev-&gt;dev
comma
id|rdev-&gt;mddev
comma
l_int|1
)paren
suffix:semicolon
id|rdev-&gt;sb_offset
op_assign
id|sb_offset
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;(read) %s&squot;s sb offset: %ld&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
comma
id|sb_offset
)paren
suffix:semicolon
id|fsync_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|set_blocksize
(paren
id|dev
comma
id|MD_SB_BYTES
)paren
suffix:semicolon
id|bh
op_assign
id|bread
(paren
id|dev
comma
id|sb_offset
op_div
id|MD_SB_BLOCKS
comma
id|MD_SB_BYTES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
id|sb
op_assign
(paren
id|mdp_super_t
op_star
)paren
id|bh-&gt;b_data
suffix:semicolon
id|memcpy
(paren
id|rdev-&gt;sb
comma
id|sb
comma
id|MD_SB_BYTES
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|NO_SB
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; [events: %08lx]&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|rdev-&gt;sb-&gt;events_lo
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
m_abort
suffix:colon
r_if
c_cond
(paren
id|bh
)paren
id|brelse
(paren
id|bh
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|calc_sb_csum
r_static
r_int
r_int
id|calc_sb_csum
(paren
id|mdp_super_t
op_star
id|sb
)paren
(brace
r_int
r_int
id|disk_csum
comma
id|csum
suffix:semicolon
id|disk_csum
op_assign
id|sb-&gt;sb_csum
suffix:semicolon
id|sb-&gt;sb_csum
op_assign
l_int|0
suffix:semicolon
id|csum
op_assign
id|csum_partial
c_func
(paren
(paren
r_void
op_star
)paren
id|sb
comma
id|MD_SB_BYTES
comma
l_int|0
)paren
suffix:semicolon
id|sb-&gt;sb_csum
op_assign
id|disk_csum
suffix:semicolon
r_return
id|csum
suffix:semicolon
)brace
multiline_comment|/*&n; * Check one RAID superblock for generic plausibility&n; */
DECL|function|check_disk_sb
r_static
r_int
id|check_disk_sb
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
id|mdp_super_t
op_star
id|sb
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|sb
op_assign
id|rdev-&gt;sb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sb-&gt;md_magic
op_ne
id|MD_SB_MAGIC
)paren
(brace
id|printk
(paren
id|BAD_MAGIC
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sb-&gt;md_minor
op_ge
id|MAX_MD_DEVS
)paren
(brace
id|printk
(paren
id|BAD_MINOR
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|sb-&gt;md_minor
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|calc_sb_csum
c_func
(paren
id|sb
)paren
op_ne
id|sb-&gt;sb_csum
)paren
id|printk
c_func
(paren
id|BAD_CSUM
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
m_abort
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|dev_unit
r_static
id|kdev_t
id|dev_unit
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_struct
id|gendisk
op_star
id|hd
op_assign
id|find_gendisk
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hd
)paren
r_return
l_int|0
suffix:semicolon
id|mask
op_assign
op_complement
(paren
(paren
l_int|1
op_lshift
id|hd-&gt;minor_shift
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|MKDEV
c_func
(paren
id|MAJOR
c_func
(paren
id|dev
)paren
comma
id|MINOR
c_func
(paren
id|dev
)paren
op_amp
id|mask
)paren
suffix:semicolon
)brace
DECL|function|match_dev_unit
r_static
id|mdk_rdev_t
op_star
id|match_dev_unit
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|kdev_t
id|dev
)paren
(brace
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
r_if
c_cond
(paren
id|dev_unit
c_func
(paren
id|rdev-&gt;dev
)paren
op_eq
id|dev_unit
c_func
(paren
id|dev
)paren
)paren
r_return
id|rdev
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|match_mddev_units
r_static
r_int
id|match_mddev_units
c_func
(paren
id|mddev_t
op_star
id|mddev1
comma
id|mddev_t
op_star
id|mddev2
)paren
(brace
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev1
comma
id|rdev
comma
id|tmp
)paren
r_if
c_cond
(paren
id|match_dev_unit
c_func
(paren
id|mddev2
comma
id|rdev-&gt;dev
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|MD_LIST_HEAD
c_func
(paren
id|all_raid_disks
)paren
suffix:semicolon
r_static
id|MD_LIST_HEAD
c_func
(paren
id|pending_raid_disks
)paren
suffix:semicolon
DECL|function|bind_rdev_to_array
r_static
r_void
id|bind_rdev_to_array
(paren
id|mdk_rdev_t
op_star
id|rdev
comma
id|mddev_t
op_star
id|mddev
)paren
(brace
id|mdk_rdev_t
op_star
id|same_pdev
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;mddev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|same_pdev
op_assign
id|match_dev_unit
c_func
(paren
id|mddev
comma
id|rdev-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|same_pdev
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md%d: WARNING: %s appears to be on the same physical disk as %s. True&bslash;n&quot;
l_string|&quot;     protection against single-disk failure might be compromised.&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|partition_name
c_func
(paren
id|same_pdev-&gt;dev
)paren
)paren
suffix:semicolon
id|md_list_add
c_func
(paren
op_amp
id|rdev-&gt;same_set
comma
op_amp
id|mddev-&gt;disks
)paren
suffix:semicolon
id|rdev-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|mddev-&gt;nb_dev
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bind&lt;%s,%d&gt;&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|mddev-&gt;nb_dev
)paren
suffix:semicolon
)brace
DECL|function|unbind_rdev_from_array
r_static
r_void
id|unbind_rdev_from_array
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;mddev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|md_list_del
c_func
(paren
op_amp
id|rdev-&gt;same_set
)paren
suffix:semicolon
id|MD_INIT_LIST_HEAD
c_func
(paren
op_amp
id|rdev-&gt;same_set
)paren
suffix:semicolon
id|rdev-&gt;mddev-&gt;nb_dev
op_decrement
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;unbind&lt;%s,%d&gt;&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|rdev-&gt;mddev-&gt;nb_dev
)paren
suffix:semicolon
id|rdev-&gt;mddev
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * prevent the device from being mounted, repartitioned or&n; * otherwise reused by a RAID array (or any other kernel&n; * subsystem), by opening the device. [simply getting an&n; * inode is not enough, the SCSI module usage code needs&n; * an explicit open() on the device]&n; */
DECL|function|lock_rdev
r_static
r_int
id|lock_rdev
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
id|bdev
op_assign
id|bdget
c_func
(paren
id|rdev-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|err
op_assign
id|blkdev_get
c_func
(paren
id|bdev
comma
id|FMODE_READ
op_or
id|FMODE_WRITE
comma
l_int|0
comma
id|BDEV_FILE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|rdev-&gt;bdev
op_assign
id|bdev
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|unlock_rdev
r_static
r_void
id|unlock_rdev
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;bdev
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|blkdev_put
c_func
(paren
id|rdev-&gt;bdev
comma
id|BDEV_FILE
)paren
suffix:semicolon
id|bdput
c_func
(paren
id|rdev-&gt;bdev
)paren
suffix:semicolon
id|rdev-&gt;bdev
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|export_rdev
r_static
r_void
id|export_rdev
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;export_rdev(%s)&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;mddev
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|unlock_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|free_disk_sb
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|md_list_del
c_func
(paren
op_amp
id|rdev-&gt;all
)paren
suffix:semicolon
id|MD_INIT_LIST_HEAD
c_func
(paren
op_amp
id|rdev-&gt;all
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;pending.next
op_ne
op_amp
id|rdev-&gt;pending
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(%s was pending)&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
id|md_list_del
c_func
(paren
op_amp
id|rdev-&gt;pending
)paren
suffix:semicolon
id|MD_INIT_LIST_HEAD
c_func
(paren
op_amp
id|rdev-&gt;pending
)paren
suffix:semicolon
)brace
id|rdev-&gt;dev
op_assign
l_int|0
suffix:semicolon
id|rdev-&gt;faulty
op_assign
l_int|0
suffix:semicolon
id|kfree
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
DECL|function|kick_rdev_from_array
r_static
r_void
id|kick_rdev_from_array
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
id|unbind_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
DECL|function|export_array
r_static
r_void
id|export_array
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;sb
)paren
(brace
id|mddev-&gt;sb
op_assign
l_int|NULL
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|sb
)paren
suffix:semicolon
)brace
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;mddev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|kick_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;nb_dev
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|free_mddev
r_static
r_void
id|free_mddev
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mddev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|export_array
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|md_size
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_assign
l_int|0
suffix:semicolon
id|md_hd_struct
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure nobody else is using this mddev&n;&t; * (careful, we rely on the global kernel lock here)&n;&t; */
r_while
c_loop
(paren
id|md_atomic_read
c_func
(paren
op_amp
id|mddev-&gt;resync_sem.count
)paren
op_ne
l_int|1
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|md_atomic_read
c_func
(paren
op_amp
id|mddev-&gt;recovery_sem.count
)paren
op_ne
l_int|1
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|del_mddev_mapping
c_func
(paren
id|mddev
comma
id|MKDEV
c_func
(paren
id|MD_MAJOR
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
)paren
suffix:semicolon
id|md_list_del
c_func
(paren
op_amp
id|mddev-&gt;all_mddevs
)paren
suffix:semicolon
id|MD_INIT_LIST_HEAD
c_func
(paren
op_amp
id|mddev-&gt;all_mddevs
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|macro|BAD_CSUM
macro_line|#undef BAD_CSUM
DECL|macro|BAD_MAGIC
macro_line|#undef BAD_MAGIC
DECL|macro|OUT_OF_MEM
macro_line|#undef OUT_OF_MEM
DECL|macro|NO_SB
macro_line|#undef NO_SB
DECL|function|print_desc
r_static
r_void
id|print_desc
c_func
(paren
id|mdp_disk_t
op_star
id|desc
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; DISK&lt;N:%d,%s(%d,%d),R:%d,S:%d&gt;&bslash;n&quot;
comma
id|desc-&gt;number
comma
id|partition_name
c_func
(paren
id|MKDEV
c_func
(paren
id|desc-&gt;major
comma
id|desc-&gt;minor
)paren
)paren
comma
id|desc-&gt;major
comma
id|desc-&gt;minor
comma
id|desc-&gt;raid_disk
comma
id|desc-&gt;state
)paren
suffix:semicolon
)brace
DECL|function|print_sb
r_static
r_void
id|print_sb
c_func
(paren
id|mdp_super_t
op_star
id|sb
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  SB: (V:%d.%d.%d) ID:&lt;%08x.%08x.%08x.%08x&gt; CT:%08x&bslash;n&quot;
comma
id|sb-&gt;major_version
comma
id|sb-&gt;minor_version
comma
id|sb-&gt;patch_version
comma
id|sb-&gt;set_uuid0
comma
id|sb-&gt;set_uuid1
comma
id|sb-&gt;set_uuid2
comma
id|sb-&gt;set_uuid3
comma
id|sb-&gt;ctime
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     L%d S%08d ND:%d RD:%d md%d LO:%d CS:%d&bslash;n&quot;
comma
id|sb-&gt;level
comma
id|sb-&gt;size
comma
id|sb-&gt;nr_disks
comma
id|sb-&gt;raid_disks
comma
id|sb-&gt;md_minor
comma
id|sb-&gt;layout
comma
id|sb-&gt;chunk_size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     UT:%08x ST:%d AD:%d WD:%d FD:%d SD:%d CSUM:%08x E:%08lx&bslash;n&quot;
comma
id|sb-&gt;utime
comma
id|sb-&gt;state
comma
id|sb-&gt;active_disks
comma
id|sb-&gt;working_disks
comma
id|sb-&gt;failed_disks
comma
id|sb-&gt;spare_disks
comma
id|sb-&gt;sb_csum
comma
(paren
r_int
r_int
)paren
id|sb-&gt;events_lo
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mdp_disk_t
op_star
id|desc
suffix:semicolon
id|desc
op_assign
id|sb-&gt;disks
op_plus
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     D %2d: &quot;
comma
id|i
)paren
suffix:semicolon
id|print_desc
c_func
(paren
id|desc
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;     THIS: &quot;
)paren
suffix:semicolon
id|print_desc
c_func
(paren
op_amp
id|sb-&gt;this_disk
)paren
suffix:semicolon
)brace
DECL|function|print_rdev
r_static
r_void
id|print_rdev
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; rdev %s: O:%s, SZ:%08ld F:%d DN:%d &quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|partition_name
c_func
(paren
id|rdev-&gt;old_dev
)paren
comma
id|rdev-&gt;size
comma
id|rdev-&gt;faulty
comma
id|rdev-&gt;desc_nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;sb
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rdev superblock:&bslash;n&quot;
)paren
suffix:semicolon
id|print_sb
c_func
(paren
id|rdev-&gt;sb
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;no rdev superblock!&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|md_print_devices
r_void
id|md_print_devices
(paren
r_void
)paren
(brace
r_struct
id|md_list_head
op_star
id|tmp
comma
op_star
id|tmp2
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&t;**********************************&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&t;* &lt;COMPLETE RAID STATE PRINTOUT&gt; *&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&t;**********************************&bslash;n&quot;
)paren
suffix:semicolon
id|ITERATE_MDDEV
c_func
(paren
id|mddev
comma
id|tmp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md%d: &quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp2
)paren
id|printk
c_func
(paren
l_string|&quot;&lt;%s&gt;&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;sb
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; array superblock:&bslash;n&quot;
)paren
suffix:semicolon
id|print_sb
c_func
(paren
id|mddev-&gt;sb
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot; no array superblock.&bslash;n&quot;
)paren
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp2
)paren
id|print_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&t;**********************************&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|sb_equal
r_static
r_int
id|sb_equal
(paren
id|mdp_super_t
op_star
id|sb1
comma
id|mdp_super_t
op_star
id|sb2
)paren
(brace
r_int
id|ret
suffix:semicolon
id|mdp_super_t
op_star
id|tmp1
comma
op_star
id|tmp2
suffix:semicolon
id|tmp1
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|tmp1
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|tmp2
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|tmp2
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp1
op_logical_or
op_logical_neg
id|tmp2
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
op_star
id|tmp1
op_assign
op_star
id|sb1
suffix:semicolon
op_star
id|tmp2
op_assign
op_star
id|sb2
suffix:semicolon
multiline_comment|/*&n;&t; * nr_disks is not constant&n;&t; */
id|tmp1-&gt;nr_disks
op_assign
l_int|0
suffix:semicolon
id|tmp2-&gt;nr_disks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|tmp1
comma
id|tmp2
comma
id|MD_SB_GENERIC_CONSTANT_WORDS
op_star
l_int|4
)paren
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
r_else
id|ret
op_assign
l_int|1
suffix:semicolon
m_abort
suffix:colon
r_if
c_cond
(paren
id|tmp1
)paren
id|kfree
c_func
(paren
id|tmp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp2
)paren
id|kfree
c_func
(paren
id|tmp2
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|uuid_equal
r_static
r_int
id|uuid_equal
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev1
comma
id|mdk_rdev_t
op_star
id|rdev2
)paren
(brace
r_if
c_cond
(paren
(paren
id|rdev1-&gt;sb-&gt;set_uuid0
op_eq
id|rdev2-&gt;sb-&gt;set_uuid0
)paren
op_logical_and
(paren
id|rdev1-&gt;sb-&gt;set_uuid1
op_eq
id|rdev2-&gt;sb-&gt;set_uuid1
)paren
op_logical_and
(paren
id|rdev1-&gt;sb-&gt;set_uuid2
op_eq
id|rdev2-&gt;sb-&gt;set_uuid2
)paren
op_logical_and
(paren
id|rdev1-&gt;sb-&gt;set_uuid3
op_eq
id|rdev2-&gt;sb-&gt;set_uuid3
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|find_rdev_all
r_static
id|mdk_rdev_t
op_star
id|find_rdev_all
(paren
id|kdev_t
id|dev
)paren
(brace
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|tmp
op_assign
id|all_raid_disks.next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
op_amp
id|all_raid_disks
)paren
(brace
id|rdev
op_assign
id|md_list_entry
c_func
(paren
id|tmp
comma
id|mdk_rdev_t
comma
id|all
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;dev
op_eq
id|dev
)paren
r_return
id|rdev
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|macro|GETBLK_FAILED
mdefine_line|#define GETBLK_FAILED KERN_ERR &bslash;&n;&quot;md: getblk failed for device %s&bslash;n&quot;
DECL|function|write_disk_sb
r_static
r_int
id|write_disk_sb
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
r_int
r_int
id|sb_offset
comma
id|size
suffix:semicolon
id|mdp_super_t
op_star
id|sb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rdev-&gt;sb-&gt;md_magic
op_ne
id|MD_SB_MAGIC
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|dev
op_assign
id|rdev-&gt;dev
suffix:semicolon
id|sb_offset
op_assign
id|calc_dev_sboffset
c_func
(paren
id|dev
comma
id|rdev-&gt;mddev
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;sb_offset
op_ne
id|sb_offset
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s&squot;s sb offset has changed from %ld to %ld, skipping&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
comma
id|rdev-&gt;sb_offset
comma
id|sb_offset
)paren
suffix:semicolon
r_goto
id|skip
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the disk went offline meanwhile and it&squot;s just a spare, then&n;&t; * it&squot;s size has changed to zero silently, and the MD code does&n;&t; * not yet know that it&squot;s faulty.&n;&t; */
id|size
op_assign
id|calc_dev_size
c_func
(paren
id|dev
comma
id|rdev-&gt;mddev
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_ne
id|rdev-&gt;size
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s&squot;s size has changed from %ld to %ld since import, skipping&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
comma
id|rdev-&gt;size
comma
id|size
)paren
suffix:semicolon
r_goto
id|skip
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;(write) %s&squot;s sb offset: %ld&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
comma
id|sb_offset
)paren
suffix:semicolon
id|fsync_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|set_blocksize
c_func
(paren
id|dev
comma
id|MD_SB_BYTES
)paren
suffix:semicolon
id|bh
op_assign
id|getblk
c_func
(paren
id|dev
comma
id|sb_offset
op_div
id|MD_SB_BLOCKS
comma
id|MD_SB_BYTES
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|printk
c_func
(paren
id|GETBLK_FAILED
comma
id|partition_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|bh-&gt;b_data
comma
l_int|0
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
id|sb
op_assign
(paren
id|mdp_super_t
op_star
)paren
id|bh-&gt;b_data
suffix:semicolon
id|memcpy
c_func
(paren
id|sb
comma
id|rdev-&gt;sb
comma
id|MD_SB_BYTES
)paren
suffix:semicolon
id|mark_buffer_uptodate
c_func
(paren
id|bh
comma
l_int|1
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|fsync_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|skip
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|GETBLK_FAILED
macro_line|#undef GETBLK_FAILED 
DECL|function|set_this_disk
r_static
r_void
id|set_this_disk
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_int
id|i
comma
id|ok
op_assign
l_int|0
suffix:semicolon
id|mdp_disk_t
op_star
id|desc
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|desc
op_assign
id|mddev-&gt;sb-&gt;disks
op_plus
id|i
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|disk_faulty
c_func
(paren
id|desc
)paren
)paren
(brace
r_if
c_cond
(paren
id|MKDEV
c_func
(paren
id|desc-&gt;major
comma
id|desc-&gt;minor
)paren
op_eq
id|rdev-&gt;dev
)paren
id|ok
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|MKDEV
c_func
(paren
id|desc-&gt;major
comma
id|desc-&gt;minor
)paren
op_eq
id|rdev-&gt;dev
)paren
(brace
id|rdev-&gt;sb-&gt;this_disk
op_assign
op_star
id|desc
suffix:semicolon
id|rdev-&gt;desc_nr
op_assign
id|desc-&gt;number
suffix:semicolon
id|ok
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ok
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|sync_sbs
r_static
r_int
id|sync_sbs
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|mdp_super_t
op_star
id|sb
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
r_continue
suffix:semicolon
id|sb
op_assign
id|rdev-&gt;sb
suffix:semicolon
op_star
id|sb
op_assign
op_star
id|mddev-&gt;sb
suffix:semicolon
id|set_this_disk
c_func
(paren
id|mddev
comma
id|rdev
)paren
suffix:semicolon
id|sb-&gt;sb_csum
op_assign
id|calc_sb_csum
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|md_update_sb
r_int
id|md_update_sb
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|first
comma
id|err
comma
id|count
op_assign
l_int|100
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|repeat
suffix:colon
id|mddev-&gt;sb-&gt;utime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
(paren
op_increment
id|mddev-&gt;sb-&gt;events_lo
)paren
op_eq
l_int|0
)paren
op_increment
id|mddev-&gt;sb-&gt;events_hi
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mddev-&gt;sb-&gt;events_lo
op_or
id|mddev-&gt;sb-&gt;events_hi
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * oops, this 64-bit counter should never wrap.&n;&t;&t; * Either we are in around ~1 trillion A.C., assuming&n;&t;&t; * 1 reboot per second, or we have a bug:&n;&t;&t; */
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|mddev-&gt;sb-&gt;events_lo
op_assign
id|mddev-&gt;sb-&gt;events_hi
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
id|sync_sbs
c_func
(paren
id|mddev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * do not write anything to disk if using&n;&t; * nonpersistent superblocks&n;&t; */
r_if
c_cond
(paren
id|mddev-&gt;sb-&gt;not_persistent
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: updating md%d RAID superblock on device&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|first
op_assign
l_int|1
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|first
)paren
(brace
id|first
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
id|printk
c_func
(paren
l_string|&quot;(skipping faulty &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s &quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;faulty
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;[events: %08lx]&quot;
comma
(paren
r_int
r_int
)paren
id|rdev-&gt;sb-&gt;events_lo
)paren
suffix:semicolon
id|err
op_add_assign
id|write_disk_sb
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;)&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;errors occured during superblock update, repeating&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|count
)paren
r_goto
id|repeat
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;excessive errors occured during superblock update, exiting&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Import a device. If &squot;on_disk&squot;, then sanity check the superblock&n; *&n; * mark the device faulty if:&n; *&n; *   - the device is nonexistent (zero size)&n; *   - the device has no valid superblock&n; *&n; * a faulty rdev _never_ has rdev-&gt;sb set.&n; */
DECL|function|md_import_device
r_static
r_int
id|md_import_device
(paren
id|kdev_t
id|newdev
comma
r_int
id|on_disk
)paren
(brace
r_int
id|err
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|find_rdev_all
c_func
(paren
id|newdev
)paren
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
id|rdev
op_assign
(paren
id|mdk_rdev_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|rdev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;could not alloc mem for %s!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|newdev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|rdev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|rdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_super
c_func
(paren
id|newdev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: can not import %s, has active inodes!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|newdev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|abort_free
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|alloc_disk_sb
c_func
(paren
id|rdev
)paren
)paren
)paren
r_goto
id|abort_free
suffix:semicolon
id|rdev-&gt;dev
op_assign
id|newdev
suffix:semicolon
r_if
c_cond
(paren
id|lock_rdev
c_func
(paren
id|rdev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: could not lock %s, zero-size? Marking faulty.&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|newdev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_free
suffix:semicolon
)brace
id|rdev-&gt;desc_nr
op_assign
op_minus
l_int|1
suffix:semicolon
id|rdev-&gt;faulty
op_assign
l_int|0
suffix:semicolon
id|size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|blk_size
(braket
id|MAJOR
c_func
(paren
id|newdev
)paren
)braket
)paren
id|size
op_assign
id|blk_size
(braket
id|MAJOR
c_func
(paren
id|newdev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|newdev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: %s has zero size, marking faulty!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|newdev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_free
suffix:semicolon
)brace
r_if
c_cond
(paren
id|on_disk
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|read_disk_sb
c_func
(paren
id|rdev
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: could not read %s&squot;s sb, not importing!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|newdev
)paren
)paren
suffix:semicolon
r_goto
id|abort_free
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|check_disk_sb
c_func
(paren
id|rdev
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: %s has invalid sb, not importing!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|newdev
)paren
)paren
suffix:semicolon
r_goto
id|abort_free
suffix:semicolon
)brace
id|rdev-&gt;old_dev
op_assign
id|MKDEV
c_func
(paren
id|rdev-&gt;sb-&gt;this_disk.major
comma
id|rdev-&gt;sb-&gt;this_disk.minor
)paren
suffix:semicolon
id|rdev-&gt;desc_nr
op_assign
id|rdev-&gt;sb-&gt;this_disk.number
suffix:semicolon
)brace
id|md_list_add
c_func
(paren
op_amp
id|rdev-&gt;all
comma
op_amp
id|all_raid_disks
)paren
suffix:semicolon
id|MD_INIT_LIST_HEAD
c_func
(paren
op_amp
id|rdev-&gt;pending
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;faulty
op_logical_and
id|rdev-&gt;sb
)paren
id|free_disk_sb
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|abort_free
suffix:colon
r_if
c_cond
(paren
id|rdev-&gt;sb
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;bdev
)paren
id|unlock_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|free_disk_sb
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Check a full RAID array for plausibility&n; */
DECL|macro|INCONSISTENT
mdefine_line|#define INCONSISTENT KERN_ERR &bslash;&n;&quot;md: fatal superblock inconsistency in %s -- removing from array&bslash;n&quot;
DECL|macro|OUT_OF_DATE
mdefine_line|#define OUT_OF_DATE KERN_ERR &bslash;&n;&quot;md: superblock update time inconsistency -- using the most recent one&bslash;n&quot;
DECL|macro|OLD_VERSION
mdefine_line|#define OLD_VERSION KERN_ALERT &bslash;&n;&quot;md: md%d: unsupported raid array version %d.%d.%d&bslash;n&quot;
DECL|macro|NOT_CLEAN_IGNORE
mdefine_line|#define NOT_CLEAN_IGNORE KERN_ERR &bslash;&n;&quot;md: md%d: raid array is not clean -- starting background reconstruction&bslash;n&quot;
DECL|macro|UNKNOWN_LEVEL
mdefine_line|#define UNKNOWN_LEVEL KERN_ERR &bslash;&n;&quot;md: md%d: unsupported raid level %d&bslash;n&quot;
DECL|function|analyze_sbs
r_static
r_int
id|analyze_sbs
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|out_of_date
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
comma
op_star
id|tmp2
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
comma
op_star
id|rdev2
comma
op_star
id|freshest
suffix:semicolon
id|mdp_super_t
op_star
id|sb
suffix:semicolon
multiline_comment|/*&n;&t; * Verify the RAID superblock on each real device&n;&t; */
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_disk_sb
c_func
(paren
id|rdev
)paren
)paren
r_goto
m_abort
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The superblock constant part has to be the same&n;&t; * for all disks in the array.&n;&t; */
id|sb
op_assign
l_int|NULL
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sb
)paren
(brace
id|sb
op_assign
id|rdev-&gt;sb
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sb_equal
c_func
(paren
id|sb
comma
id|rdev-&gt;sb
)paren
)paren
(brace
id|printk
(paren
id|INCONSISTENT
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
id|kick_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * OK, we have all disks and the array is ready to run. Let&squot;s&n;&t; * find the freshest superblock, that one will be the superblock&n;&t; * that represents the whole array.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb
)paren
r_if
c_cond
(paren
id|alloc_array_sb
c_func
(paren
id|mddev
)paren
)paren
r_goto
m_abort
suffix:semicolon
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
id|freshest
op_assign
l_int|NULL
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
id|__u64
id|ev1
comma
id|ev2
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if the checksum is invalid, use the superblock&n;&t;&t; * only as a last resort. (decrease it&squot;s age by&n;&t;&t; * one event)&n;&t;&t; */
r_if
c_cond
(paren
id|calc_sb_csum
c_func
(paren
id|rdev-&gt;sb
)paren
op_ne
id|rdev-&gt;sb-&gt;sb_csum
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;sb-&gt;events_lo
op_logical_or
id|rdev-&gt;sb-&gt;events_hi
)paren
r_if
c_cond
(paren
(paren
id|rdev-&gt;sb-&gt;events_lo
op_decrement
)paren
op_eq
l_int|0
)paren
id|rdev-&gt;sb-&gt;events_hi
op_decrement
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s&squot;s event counter: %08lx&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
(paren
r_int
r_int
)paren
id|rdev-&gt;sb-&gt;events_lo
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|freshest
)paren
(brace
id|freshest
op_assign
id|rdev
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Find the newest superblock version&n;&t;&t; */
id|ev1
op_assign
id|md_event
c_func
(paren
id|rdev-&gt;sb
)paren
suffix:semicolon
id|ev2
op_assign
id|md_event
c_func
(paren
id|freshest-&gt;sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ev1
op_ne
id|ev2
)paren
(brace
id|out_of_date
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ev1
OG
id|ev2
)paren
id|freshest
op_assign
id|rdev
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|out_of_date
)paren
(brace
id|printk
c_func
(paren
id|OUT_OF_DATE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;freshest: %s&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|freshest-&gt;dev
)paren
)paren
suffix:semicolon
)brace
id|memcpy
(paren
id|sb
comma
id|freshest-&gt;sb
comma
r_sizeof
(paren
op_star
id|sb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * at this point we have picked the &squot;best&squot; superblock&n;&t; * from all available superblocks.&n;&t; * now we validate this superblock and kick out possibly&n;&t; * failed disks.&n;&t; */
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
multiline_comment|/*&n;&t;&t; * Kick all non-fresh devices faulty&n;&t;&t; */
id|__u64
id|ev1
comma
id|ev2
suffix:semicolon
id|ev1
op_assign
id|md_event
c_func
(paren
id|rdev-&gt;sb
)paren
suffix:semicolon
id|ev2
op_assign
id|md_event
c_func
(paren
id|sb
)paren
suffix:semicolon
op_increment
id|ev1
suffix:semicolon
r_if
c_cond
(paren
id|ev1
OL
id|ev2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: kicking non-fresh %s from array!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
id|kick_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Fix up changed device names ... but only if this disk has a&n;&t; * recent update time. Use faulty checksum ones too.&n;&t; */
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
id|__u64
id|ev1
comma
id|ev2
comma
id|ev3
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
multiline_comment|/* REMOVEME */
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|ev1
op_assign
id|md_event
c_func
(paren
id|rdev-&gt;sb
)paren
suffix:semicolon
id|ev2
op_assign
id|md_event
c_func
(paren
id|sb
)paren
suffix:semicolon
id|ev3
op_assign
id|ev2
suffix:semicolon
op_decrement
id|ev3
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rdev-&gt;dev
op_ne
id|rdev-&gt;old_dev
)paren
op_logical_and
(paren
(paren
id|ev1
op_eq
id|ev2
)paren
op_logical_or
(paren
id|ev1
op_eq
id|ev3
)paren
)paren
)paren
(brace
id|mdp_disk_t
op_star
id|desc
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;md: device name has changed from %s to %s since last import!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;old_dev
)paren
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|desc
op_assign
op_amp
id|sb-&gt;disks
(braket
id|rdev-&gt;desc_nr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;old_dev
op_ne
id|MKDEV
c_func
(paren
id|desc-&gt;major
comma
id|desc-&gt;minor
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|desc-&gt;major
op_assign
id|MAJOR
c_func
(paren
id|rdev-&gt;dev
)paren
suffix:semicolon
id|desc-&gt;minor
op_assign
id|MINOR
c_func
(paren
id|rdev-&gt;dev
)paren
suffix:semicolon
id|desc
op_assign
op_amp
id|rdev-&gt;sb-&gt;this_disk
suffix:semicolon
id|desc-&gt;major
op_assign
id|MAJOR
c_func
(paren
id|rdev-&gt;dev
)paren
suffix:semicolon
id|desc-&gt;minor
op_assign
id|MINOR
c_func
(paren
id|rdev-&gt;dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Remove unavailable and faulty devices ...&n;&t; *&n;&t; * note that if an array becomes completely unrunnable due to&n;&t; * missing devices, we do not write the superblock back, so the&n;&t; * administrator has a chance to fix things up. The removal thus&n;&t; * only happens if it&squot;s nonfatal to the contents of the array.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|found
suffix:semicolon
id|mdp_disk_t
op_star
id|desc
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
id|desc
op_assign
id|sb-&gt;disks
op_plus
id|i
suffix:semicolon
id|dev
op_assign
id|MKDEV
c_func
(paren
id|desc-&gt;major
comma
id|desc-&gt;minor
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We kick faulty devices/descriptors immediately.&n;&t;&t; */
r_if
c_cond
(paren
id|disk_faulty
c_func
(paren
id|desc
)paren
)paren
(brace
id|found
op_assign
l_int|0
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_ne
id|desc-&gt;number
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;md%d: kicking faulty %s!&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
id|kick_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
r_if
c_cond
(paren
id|dev
op_eq
id|MKDEV
c_func
(paren
l_int|0
comma
l_int|0
)paren
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;md%d: removing former faulty %s!&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|partition_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
)brace
id|remove_descriptor
c_func
(paren
id|desc
comma
id|sb
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
op_eq
id|MKDEV
c_func
(paren
l_int|0
comma
l_int|0
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Is this device present in the rdev ring?&n;&t;&t; */
id|found
op_assign
l_int|0
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
id|desc-&gt;number
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|found
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;md%d: former device %s is unavailable, removing from array!&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|partition_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|remove_descriptor
c_func
(paren
id|desc
comma
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Double check wether all devices mentioned in the&n;&t; * superblock are in the rdev ring.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mdp_disk_t
op_star
id|desc
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
id|desc
op_assign
id|sb-&gt;disks
op_plus
id|i
suffix:semicolon
id|dev
op_assign
id|MKDEV
c_func
(paren
id|desc-&gt;major
comma
id|desc-&gt;minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
id|MKDEV
c_func
(paren
l_int|0
comma
l_int|0
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|disk_faulty
c_func
(paren
id|desc
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|rdev
op_assign
id|find_rdev
c_func
(paren
id|mddev
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Do a final reality check.&n;&t; */
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * is the desc_nr unique?&n;&t;&t; */
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev2
comma
id|tmp2
)paren
(brace
r_if
c_cond
(paren
(paren
id|rdev2
op_ne
id|rdev
)paren
op_logical_and
(paren
id|rdev2-&gt;desc_nr
op_eq
id|rdev-&gt;desc_nr
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * is the device unique?&n;&t;&t; */
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev2
comma
id|tmp2
)paren
(brace
r_if
c_cond
(paren
(paren
id|rdev2
op_ne
id|rdev
)paren
op_logical_and
(paren
id|rdev2-&gt;dev
op_eq
id|rdev-&gt;dev
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Check if we can support this RAID array&n;&t; */
r_if
c_cond
(paren
id|sb-&gt;major_version
op_ne
id|MD_MAJOR_VERSION
op_logical_or
id|sb-&gt;minor_version
OG
id|MD_MINOR_VERSION
)paren
(brace
id|printk
(paren
id|OLD_VERSION
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|sb-&gt;major_version
comma
id|sb-&gt;minor_version
comma
id|sb-&gt;patch_version
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sb-&gt;state
op_ne
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
)paren
op_logical_and
(paren
(paren
id|sb-&gt;level
op_eq
l_int|1
)paren
op_logical_or
(paren
id|sb-&gt;level
op_eq
l_int|4
)paren
op_logical_or
(paren
id|sb-&gt;level
op_eq
l_int|5
)paren
)paren
)paren
id|printk
(paren
id|NOT_CLEAN_IGNORE
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
m_abort
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|INCONSISTENT
macro_line|#undef INCONSISTENT
DECL|macro|OUT_OF_DATE
macro_line|#undef OUT_OF_DATE
DECL|macro|OLD_VERSION
macro_line|#undef OLD_VERSION
DECL|macro|OLD_LEVEL
macro_line|#undef OLD_LEVEL
DECL|function|device_size_calculation
r_static
r_int
id|device_size_calculation
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|data_disks
op_assign
l_int|0
comma
id|persistent
suffix:semicolon
r_int
r_int
id|readahead
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
multiline_comment|/*&n;&t; * Do device size calculation. Bail out if too small.&n;&t; * (we have to do this after having validated chunk_size,&n;&t; * because device size has to be modulo chunk_size)&n;&t; */
id|persistent
op_assign
op_logical_neg
id|mddev-&gt;sb-&gt;not_persistent
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;size
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|rdev-&gt;size
op_assign
id|calc_dev_size
c_func
(paren
id|rdev-&gt;dev
comma
id|mddev
comma
id|persistent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;size
OL
id|sb-&gt;chunk_size
op_div
l_int|1024
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;Dev %s smaller than chunk_size: %ldk &lt; %dk&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|rdev-&gt;size
comma
id|sb-&gt;chunk_size
op_div
l_int|1024
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|sb-&gt;level
)paren
(brace
r_case
op_minus
l_int|3
suffix:colon
id|data_disks
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
l_int|2
suffix:colon
id|data_disks
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
l_int|1
suffix:colon
id|zoned_raid_size
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|data_disks
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
id|zoned_raid_size
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|data_disks
op_assign
id|sb-&gt;raid_disks
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|data_disks
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_case
l_int|5
suffix:colon
id|data_disks
op_assign
id|sb-&gt;raid_disks
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|UNKNOWN_LEVEL
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|sb-&gt;level
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|md_size
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
)paren
id|md_size
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_assign
id|sb-&gt;size
op_star
id|data_disks
suffix:semicolon
id|readahead
op_assign
id|MD_READAHEAD
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sb-&gt;level
op_eq
l_int|0
)paren
op_logical_or
(paren
id|sb-&gt;level
op_eq
l_int|4
)paren
op_logical_or
(paren
id|sb-&gt;level
op_eq
l_int|5
)paren
)paren
(brace
id|readahead
op_assign
(paren
id|mddev-&gt;sb-&gt;chunk_size
op_rshift
id|PAGE_SHIFT
)paren
op_star
l_int|4
op_star
id|data_disks
suffix:semicolon
r_if
c_cond
(paren
id|readahead
OL
id|data_disks
op_star
(paren
id|MAX_SECTORS
op_rshift
(paren
id|PAGE_SHIFT
op_minus
l_int|9
)paren
)paren
op_star
l_int|2
)paren
id|readahead
op_assign
id|data_disks
op_star
(paren
id|MAX_SECTORS
op_rshift
(paren
id|PAGE_SHIFT
op_minus
l_int|9
)paren
)paren
op_star
l_int|2
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sb-&gt;level
op_eq
op_minus
l_int|3
)paren
id|readahead
op_assign
l_int|0
suffix:semicolon
)brace
id|md_maxreadahead
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_assign
id|readahead
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md%d: max total readahead window set to %ldk&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|readahead
op_star
(paren
id|PAGE_SIZE
op_div
l_int|1024
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md%d: %d data-disks, max readahead per data-disk: %ldk&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|data_disks
comma
id|readahead
op_div
id|data_disks
op_star
(paren
id|PAGE_SIZE
op_div
l_int|1024
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
m_abort
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|TOO_BIG_CHUNKSIZE
mdefine_line|#define TOO_BIG_CHUNKSIZE KERN_ERR &bslash;&n;&quot;too big chunk_size: %d &gt; %d&bslash;n&quot;
DECL|macro|TOO_SMALL_CHUNKSIZE
mdefine_line|#define TOO_SMALL_CHUNKSIZE KERN_ERR &bslash;&n;&quot;too small chunk_size: %d &lt; %ld&bslash;n&quot;
DECL|macro|BAD_CHUNKSIZE
mdefine_line|#define BAD_CHUNKSIZE KERN_ERR &bslash;&n;&quot;no chunksize specified, see &squot;man raidtab&squot;&bslash;n&quot;
DECL|function|do_md_run
r_static
r_int
id|do_md_run
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|pnum
comma
id|err
suffix:semicolon
r_int
id|chunk_size
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;nb_dev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/*&n;&t; * Resize disks to align partitions size on a given&n;&t; * chunk size.&n;&t; */
id|md_size
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Analyze all RAID superblock(s)&n;&t; */
r_if
c_cond
(paren
id|analyze_sbs
c_func
(paren
id|mddev
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|chunk_size
op_assign
id|mddev-&gt;sb-&gt;chunk_size
suffix:semicolon
id|pnum
op_assign
id|level_to_pers
c_func
(paren
id|mddev-&gt;sb-&gt;level
)paren
suffix:semicolon
id|mddev-&gt;param.chunk_size
op_assign
id|chunk_size
suffix:semicolon
id|mddev-&gt;param.personality
op_assign
id|pnum
suffix:semicolon
r_if
c_cond
(paren
id|chunk_size
OG
id|MAX_CHUNK_SIZE
)paren
(brace
id|printk
c_func
(paren
id|TOO_BIG_CHUNKSIZE
comma
id|chunk_size
comma
id|MAX_CHUNK_SIZE
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * chunk-size has to be a power of 2 and multiples of PAGE_SIZE&n;&t; */
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|ffz
c_func
(paren
op_complement
id|chunk_size
)paren
)paren
op_ne
id|chunk_size
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chunk_size
OL
id|PAGE_SIZE
)paren
(brace
id|printk
c_func
(paren
id|TOO_SMALL_CHUNKSIZE
comma
id|chunk_size
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pnum
op_ge
id|MAX_PERSONALITY
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pnum
op_ne
id|RAID1
)paren
op_logical_and
(paren
id|pnum
op_ne
id|LINEAR
)paren
op_logical_and
op_logical_neg
id|chunk_size
)paren
(brace
multiline_comment|/*&n;&t;&t; * &squot;default chunksize&squot; in the old md code used to&n;&t;&t; * be PAGE_SIZE, baaad.&n;&t;&t; * we abort here to be on the safe side. We dont&n;&t;&t; * want to continue the bad practice.&n;&t;&t; */
id|printk
c_func
(paren
id|BAD_CHUNKSIZE
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pers
(braket
id|pnum
)braket
)paren
(brace
macro_line|#ifdef CONFIG_KMOD
r_char
id|module_name
(braket
l_int|80
)braket
suffix:semicolon
id|sprintf
(paren
id|module_name
comma
l_string|&quot;md-personality-%d&quot;
comma
id|pnum
)paren
suffix:semicolon
id|request_module
(paren
id|module_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pers
(braket
id|pnum
)braket
)paren
macro_line|#endif
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|device_size_calculation
c_func
(paren
id|mddev
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * Drop all container device buffers, from now on&n;&t; * the only valid external interface is through the md&n;&t; * device.&n;&t; * Also find largest hardsector size&n;&t; */
id|md_hardsect_sizes
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_assign
l_int|512
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
r_continue
suffix:semicolon
id|fsync_dev
c_func
(paren
id|rdev-&gt;dev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|rdev-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_hardsect_size
c_func
(paren
id|rdev-&gt;dev
)paren
OG
id|md_hardsect_sizes
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
)paren
id|md_hardsect_sizes
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_assign
id|get_hardsect_size
c_func
(paren
id|rdev-&gt;dev
)paren
suffix:semicolon
)brace
id|md_blocksizes
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_assign
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
id|md_blocksizes
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
OL
id|md_hardsect_sizes
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
)paren
id|md_blocksizes
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_assign
id|md_hardsect_sizes
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
suffix:semicolon
id|mddev-&gt;pers
op_assign
id|pers
(braket
id|pnum
)braket
suffix:semicolon
id|err
op_assign
id|mddev-&gt;pers
op_member_access_from_pointer
id|run
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pers-&gt;run() failed ...&bslash;n&quot;
)paren
suffix:semicolon
id|mddev-&gt;pers
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|mddev-&gt;sb-&gt;state
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
suffix:semicolon
id|md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * md_size has units of 1K blocks, which are&n;&t; * twice as large as sectors.&n;&t; */
id|md_hd_struct
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|md_hd_struct
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
dot
id|nr_sects
op_assign
id|md_size
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_lshift
l_int|1
suffix:semicolon
id|read_ahead
(braket
id|MD_MAJOR
)braket
op_assign
l_int|1024
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|macro|TOO_BIG_CHUNKSIZE
macro_line|#undef TOO_BIG_CHUNKSIZE
DECL|macro|BAD_CHUNKSIZE
macro_line|#undef BAD_CHUNKSIZE
DECL|macro|OUT
mdefine_line|#define OUT(x) do { err = (x); goto out; } while (0)
DECL|function|restart_array
r_static
r_int
id|restart_array
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Complain if it has no devices&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;nb_dev
)paren
id|OUT
c_func
(paren
op_minus
id|ENXIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;ro
)paren
id|OUT
c_func
(paren
op_minus
id|EBUSY
)paren
suffix:semicolon
id|mddev-&gt;ro
op_assign
l_int|0
suffix:semicolon
id|set_device_ro
c_func
(paren
id|mddev_to_kdev
c_func
(paren
id|mddev
)paren
comma
l_int|0
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;md%d switched to read-write mode.&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Kick recovery or resync if necessary&n;&t;&t; */
id|md_recover_arrays
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers-&gt;restart_resync
)paren
id|mddev-&gt;pers
op_member_access_from_pointer
id|restart_resync
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
r_else
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|macro|STILL_MOUNTED
mdefine_line|#define STILL_MOUNTED KERN_WARNING &bslash;&n;&quot;md: md%d still mounted.&bslash;n&quot;
DECL|macro|STILL_IN_USE
mdefine_line|#define&t;STILL_IN_USE &bslash;&n;&quot;md: md%d still in use.&bslash;n&quot;
DECL|function|do_md_stop
r_static
r_int
id|do_md_stop
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|ro
)paren
(brace
r_int
id|err
op_assign
l_int|0
comma
id|resync_interrupted
op_assign
l_int|0
suffix:semicolon
id|kdev_t
id|dev
op_assign
id|mddev_to_kdev
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mddev-&gt;active
)paren
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|STILL_IN_USE
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|OUT
c_func
(paren
op_minus
id|EBUSY
)paren
suffix:semicolon
)brace
multiline_comment|/* this shouldn&squot;t be needed as above would have fired */
r_if
c_cond
(paren
op_logical_neg
id|ro
op_logical_and
id|get_super
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
(paren
id|STILL_MOUNTED
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|OUT
c_func
(paren
op_minus
id|EBUSY
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
(brace
multiline_comment|/*&n;&t;&t; * It is safe to call stop here, it only frees private&n;&t;&t; * data. Also, it tells us if a device is unstoppable&n;&t;&t; * (eg. resyncing is in progress)&n;&t;&t; */
r_if
c_cond
(paren
id|mddev-&gt;pers-&gt;stop_resync
)paren
r_if
c_cond
(paren
id|mddev-&gt;pers
op_member_access_from_pointer
id|stop_resync
c_func
(paren
id|mddev
)paren
)paren
id|resync_interrupted
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;recovery_running
)paren
id|md_interrupt_thread
c_func
(paren
id|md_recovery_thread
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This synchronizes with signal delivery to the&n;&t;&t; * resync or reconstruction thread. It also nicely&n;&t;&t; * hangs the process if some reconstruction has not&n;&t;&t; * finished.&n;&t;&t; */
id|down
c_func
(paren
op_amp
id|mddev-&gt;recovery_sem
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mddev-&gt;recovery_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  sync and invalidate buffers because we cannot kill the&n;&t;&t; *  main thread with valid IO transfers still around.&n;&t;&t; *  the kernel lock protects us from new requests being&n;&t;&t; *  added after invalidate_buffers().&n;&t;&t; */
id|fsync_dev
(paren
id|mddev_to_kdev
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|fsync_dev
(paren
id|dev
)paren
suffix:semicolon
id|invalidate_buffers
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ro
)paren
(brace
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
id|OUT
c_func
(paren
op_minus
id|ENXIO
)paren
suffix:semicolon
id|mddev-&gt;ro
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
id|set_device_ro
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers
op_member_access_from_pointer
id|stop
c_func
(paren
id|mddev
)paren
)paren
(brace
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
id|set_device_ro
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|OUT
c_func
(paren
op_minus
id|EBUSY
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
id|mddev-&gt;ro
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;sb
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * mark it clean only if there was no resync&n;&t;&t;&t; * interrupted.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;recovery_running
op_logical_and
op_logical_neg
id|resync_interrupted
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;marking sb clean...&bslash;n&quot;
)paren
suffix:semicolon
id|mddev-&gt;sb-&gt;state
op_or_assign
l_int|1
op_lshift
id|MD_SB_CLEAN
suffix:semicolon
)brace
id|md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ro
)paren
id|set_device_ro
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Free resources if final stop&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ro
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;md%d stopped.&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|free_mddev
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
r_else
id|printk
(paren
id|KERN_INFO
l_string|&quot;md%d switched to read-only mode.&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|macro|OUT
macro_line|#undef OUT
multiline_comment|/*&n; * We have to safely support old arrays too.&n; */
DECL|function|detect_old_array
r_int
id|detect_old_array
(paren
id|mdp_super_t
op_star
id|sb
)paren
(brace
r_if
c_cond
(paren
id|sb-&gt;major_version
OG
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;minor_version
op_ge
l_int|90
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|autorun_array
r_static
r_void
id|autorun_array
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;disks.prev
op_eq
op_amp
id|mddev-&gt;disks
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;running: &quot;
)paren
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&lt;%s&gt;&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nnow!&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
id|do_md_run
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;do_md_run() returned %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * prevent the writeback of an unrunnable array&n;&t;&t; */
id|mddev-&gt;sb_dirty
op_assign
l_int|0
suffix:semicolon
id|do_md_stop
(paren
id|mddev
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * lets try to run arrays based on all disks that have arrived&n; * until now. (those are in the -&gt;pending list)&n; *&n; * the method: pick the first pending disk, collect all disks with&n; * the same UUID, remove all from the pending list and put them into&n; * the &squot;same_array&squot; list. Then order this list based on superblock&n; * update time (freshest comes first), kick out &squot;old&squot; disks and&n; * compare superblocks. If everything&squot;s fine then run it.&n; *&n; * If &quot;unit&quot; is allocated, then bump its reference count&n; */
DECL|function|autorun_devices
r_static
r_void
id|autorun_devices
(paren
id|kdev_t
id|countdev
)paren
(brace
r_struct
id|md_list_head
id|candidates
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev0
comma
op_star
id|rdev
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
id|kdev_t
id|md_kdev
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;autorun ...&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pending_raid_disks.next
op_ne
op_amp
id|pending_raid_disks
)paren
(brace
id|rdev0
op_assign
id|md_list_entry
c_func
(paren
id|pending_raid_disks.next
comma
id|mdk_rdev_t
comma
id|pending
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;considering %s ...&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev0-&gt;dev
)paren
)paren
suffix:semicolon
id|MD_INIT_LIST_HEAD
c_func
(paren
op_amp
id|candidates
)paren
suffix:semicolon
id|ITERATE_RDEV_PENDING
c_func
(paren
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|uuid_equal
c_func
(paren
id|rdev0
comma
id|rdev
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sb_equal
c_func
(paren
id|rdev0-&gt;sb
comma
id|rdev-&gt;sb
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s has same UUID as %s, but superblocks differ ...&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|partition_name
c_func
(paren
id|rdev0-&gt;dev
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  adding %s ...&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
id|md_list_del
c_func
(paren
op_amp
id|rdev-&gt;pending
)paren
suffix:semicolon
id|md_list_add
c_func
(paren
op_amp
id|rdev-&gt;pending
comma
op_amp
id|candidates
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * now we have a set of devices, with all of them having&n;&t;&t; * mostly sane superblocks. It&squot;s time to allocate the&n;&t;&t; * mddev.&n;&t;&t; */
id|md_kdev
op_assign
id|MKDEV
c_func
(paren
id|MD_MAJOR
comma
id|rdev0-&gt;sb-&gt;md_minor
)paren
suffix:semicolon
id|mddev
op_assign
id|kdev_to_mddev
c_func
(paren
id|md_kdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md%d already running, cannot run %s&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|partition_name
c_func
(paren
id|rdev0-&gt;dev
)paren
)paren
suffix:semicolon
id|ITERATE_RDEV_GENERIC
c_func
(paren
id|candidates
comma
id|pending
comma
id|rdev
comma
id|tmp
)paren
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|mddev
op_assign
id|alloc_mddev
c_func
(paren
id|md_kdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: cannot allocate memory for md drive.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|md_kdev
op_eq
id|countdev
)paren
id|atomic_inc
c_func
(paren
op_amp
id|mddev-&gt;active
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;created md%d&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|ITERATE_RDEV_GENERIC
c_func
(paren
id|candidates
comma
id|pending
comma
id|rdev
comma
id|tmp
)paren
(brace
id|bind_rdev_to_array
c_func
(paren
id|rdev
comma
id|mddev
)paren
suffix:semicolon
id|md_list_del
c_func
(paren
op_amp
id|rdev-&gt;pending
)paren
suffix:semicolon
id|MD_INIT_LIST_HEAD
c_func
(paren
op_amp
id|rdev-&gt;pending
)paren
suffix:semicolon
)brace
id|autorun_array
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;... autorun DONE.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * import RAID devices based on one partition&n; * if possible, the array gets run as well.&n; */
DECL|macro|BAD_VERSION
mdefine_line|#define BAD_VERSION KERN_ERR &bslash;&n;&quot;md: %s has RAID superblock version 0.%d, autodetect needs v0.90 or higher&bslash;n&quot;
DECL|macro|OUT_OF_MEM
mdefine_line|#define OUT_OF_MEM KERN_ALERT &bslash;&n;&quot;md: out of memory.&bslash;n&quot;
DECL|macro|NO_DEVICE
mdefine_line|#define NO_DEVICE KERN_ERR &bslash;&n;&quot;md: disabled device %s&bslash;n&quot;
DECL|macro|AUTOADD_FAILED
mdefine_line|#define AUTOADD_FAILED KERN_ERR &bslash;&n;&quot;md: auto-adding devices to md%d FAILED (error %d).&bslash;n&quot;
DECL|macro|AUTOADD_FAILED_USED
mdefine_line|#define AUTOADD_FAILED_USED KERN_ERR &bslash;&n;&quot;md: cannot auto-add device %s to md%d, already used.&bslash;n&quot;
DECL|macro|AUTORUN_FAILED
mdefine_line|#define AUTORUN_FAILED KERN_ERR &bslash;&n;&quot;md: auto-running md%d FAILED (error %d).&bslash;n&quot;
DECL|macro|MDDEV_BUSY
mdefine_line|#define MDDEV_BUSY KERN_ERR &bslash;&n;&quot;md: cannot auto-add to md%d, already running.&bslash;n&quot;
DECL|macro|AUTOADDING
mdefine_line|#define AUTOADDING KERN_INFO &bslash;&n;&quot;md: auto-adding devices to md%d, based on %s&squot;s superblock.&bslash;n&quot;
DECL|macro|AUTORUNNING
mdefine_line|#define AUTORUNNING KERN_INFO &bslash;&n;&quot;md: auto-running md%d.&bslash;n&quot;
DECL|function|autostart_array
r_static
r_int
id|autostart_array
(paren
id|kdev_t
id|startdev
comma
id|kdev_t
id|countdev
)paren
(brace
r_int
id|err
op_assign
op_minus
id|EINVAL
comma
id|i
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
l_int|NULL
suffix:semicolon
id|mdk_rdev_t
op_star
id|start_rdev
op_assign
l_int|NULL
comma
op_star
id|rdev
suffix:semicolon
r_if
c_cond
(paren
id|md_import_device
c_func
(paren
id|startdev
comma
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;could not import %s!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|startdev
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|start_rdev
op_assign
id|find_rdev_all
c_func
(paren
id|startdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|start_rdev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start_rdev-&gt;faulty
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;can not autostart based on faulty %s!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|startdev
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|md_list_add
c_func
(paren
op_amp
id|start_rdev-&gt;pending
comma
op_amp
id|pending_raid_disks
)paren
suffix:semicolon
id|sb
op_assign
id|start_rdev-&gt;sb
suffix:semicolon
id|err
op_assign
id|detect_old_array
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;array version is too old to be autostarted, use raidtools 0.90 mkraid --upgrade&bslash;nto upgrade the array without data loss!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mdp_disk_t
op_star
id|desc
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
id|desc
op_assign
id|sb-&gt;disks
op_plus
id|i
suffix:semicolon
id|dev
op_assign
id|MKDEV
c_func
(paren
id|desc-&gt;major
comma
id|desc-&gt;minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
id|MKDEV
c_func
(paren
l_int|0
comma
l_int|0
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
id|startdev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|md_import_device
c_func
(paren
id|dev
comma
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;could not import %s, trying to run array nevertheless.&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|rdev
op_assign
id|find_rdev_all
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|md_list_add
c_func
(paren
op_amp
id|rdev-&gt;pending
comma
op_amp
id|pending_raid_disks
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * possibly return codes&n;&t; */
id|autorun_devices
c_func
(paren
id|countdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
m_abort
suffix:colon
r_if
c_cond
(paren
id|start_rdev
)paren
id|export_rdev
c_func
(paren
id|start_rdev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|macro|BAD_VERSION
macro_line|#undef BAD_VERSION
DECL|macro|OUT_OF_MEM
macro_line|#undef OUT_OF_MEM
DECL|macro|NO_DEVICE
macro_line|#undef NO_DEVICE
DECL|macro|AUTOADD_FAILED_USED
macro_line|#undef AUTOADD_FAILED_USED
DECL|macro|AUTOADD_FAILED
macro_line|#undef AUTOADD_FAILED
DECL|macro|AUTORUN_FAILED
macro_line|#undef AUTORUN_FAILED
DECL|macro|AUTOADDING
macro_line|#undef AUTOADDING
DECL|macro|AUTORUNNING
macro_line|#undef AUTORUNNING
r_struct
(brace
DECL|member|set
r_int
id|set
suffix:semicolon
DECL|member|noautodetect
r_int
id|noautodetect
suffix:semicolon
DECL|variable|md__initdata
)brace
id|raid_setup_args
id|md__initdata
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_void
id|md_setup_drive
c_func
(paren
r_void
)paren
id|md__init
suffix:semicolon
multiline_comment|/*&n; * Searches all registered partitions for autorun RAID arrays&n; * at boot time.&n; */
macro_line|#ifdef CONFIG_AUTODETECT_RAID
DECL|variable|md__initdata
r_static
r_int
id|detected_devices
(braket
l_int|128
)braket
id|md__initdata
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|dev_cnt
r_static
r_int
id|dev_cnt
op_assign
l_int|0
suffix:semicolon
DECL|function|md_autodetect_dev
r_void
id|md_autodetect_dev
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev_cnt
op_ge
l_int|0
op_logical_and
id|dev_cnt
OL
l_int|127
)paren
id|detected_devices
(braket
id|dev_cnt
op_increment
)braket
op_assign
id|dev
suffix:semicolon
)brace
macro_line|#endif
DECL|function|md_run_setup
r_int
id|md__init
id|md_run_setup
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_AUTODETECT_RAID
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|raid_setup_args.noautodetect
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;skipping autodetection of RAID arrays&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;autodetecting RAID arrays&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kdev_t
id|dev
op_assign
id|detected_devices
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|md_import_device
c_func
(paren
id|dev
comma
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;could not import %s!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Sanity checks:&n;&t;&t;&t; */
id|rdev
op_assign
id|find_rdev_all
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|md_list_add
c_func
(paren
op_amp
id|rdev-&gt;pending
comma
op_amp
id|pending_raid_disks
)paren
suffix:semicolon
)brace
id|autorun_devices
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|dev_cnt
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* make sure further calls to md_autodetect_dev are ignored */
macro_line|#endif
macro_line|#ifdef CONFIG_MD_BOOT
id|md_setup_drive
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_version
r_static
r_int
id|get_version
(paren
r_void
op_star
id|arg
)paren
(brace
id|mdu_version_t
id|ver
suffix:semicolon
id|ver.major
op_assign
id|MD_MAJOR_VERSION
suffix:semicolon
id|ver.minor
op_assign
id|MD_MINOR_VERSION
suffix:semicolon
id|ver.patchlevel
op_assign
id|MD_PATCHLEVEL_VERSION
suffix:semicolon
r_if
c_cond
(paren
id|md_copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ver
comma
r_sizeof
(paren
id|ver
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SET_FROM_SB
mdefine_line|#define SET_FROM_SB(x) info.x = mddev-&gt;sb-&gt;x
DECL|function|get_array_info
r_static
r_int
id|get_array_info
(paren
id|mddev_t
op_star
id|mddev
comma
r_void
op_star
id|arg
)paren
(brace
id|mdu_array_info_t
id|info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|major_version
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|minor_version
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|patch_version
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|ctime
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|level
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|size
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|nr_disks
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|raid_disks
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|md_minor
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|not_persistent
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|utime
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|state
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|active_disks
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|working_disks
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|failed_disks
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|spare_disks
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|layout
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|chunk_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|md_copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SET_FROM_SB
macro_line|#undef SET_FROM_SB
DECL|macro|SET_FROM_SB
mdefine_line|#define SET_FROM_SB(x) info.x = mddev-&gt;sb-&gt;disks[nr].x
DECL|function|get_disk_info
r_static
r_int
id|get_disk_info
(paren
id|mddev_t
op_star
id|mddev
comma
r_void
op_star
id|arg
)paren
(brace
id|mdu_disk_info_t
id|info
suffix:semicolon
r_int
r_int
id|nr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|md_copy_from_user
c_func
(paren
op_amp
id|info
comma
id|arg
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|nr
op_assign
id|info.number
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ge
id|mddev-&gt;sb-&gt;nr_disks
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|major
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|minor
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|raid_disk
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|md_copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SET_FROM_SB
macro_line|#undef SET_FROM_SB
DECL|macro|SET_SB
mdefine_line|#define SET_SB(x) mddev-&gt;sb-&gt;disks[nr].x = info-&gt;x
DECL|function|add_new_disk
r_static
r_int
id|add_new_disk
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdu_disk_info_t
op_star
id|info
)paren
(brace
r_int
id|err
comma
id|size
comma
id|persistent
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_int
r_int
id|nr
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
id|dev
op_assign
id|MKDEV
c_func
(paren
id|info-&gt;major
comma
id|info-&gt;minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_rdev_all
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;device %s already used in a RAID array!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb
)paren
(brace
multiline_comment|/* expecting a device which has a superblock */
id|err
op_assign
id|md_import_device
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md error, md_import_device returned %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rdev
op_assign
id|find_rdev_all
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;nb_dev
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev0
op_assign
id|md_list_entry
c_func
(paren
id|mddev-&gt;disks.next
comma
id|mdk_rdev_t
comma
id|same_set
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uuid_equal
c_func
(paren
id|rdev0
comma
id|rdev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: %s has different UUID to %s&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|partition_name
c_func
(paren
id|rdev0-&gt;dev
)paren
)paren
suffix:semicolon
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sb_equal
c_func
(paren
id|rdev0-&gt;sb
comma
id|rdev-&gt;sb
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: %s has same UUID but different superblock to %s&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|partition_name
c_func
(paren
id|rdev0-&gt;dev
)paren
)paren
suffix:semicolon
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
id|bind_rdev_to_array
c_func
(paren
id|rdev
comma
id|mddev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|nr
op_assign
id|info-&gt;number
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ge
id|mddev-&gt;sb-&gt;nr_disks
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|SET_SB
c_func
(paren
id|number
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|major
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|minor
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|raid_disk
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;state
op_amp
(paren
l_int|1
op_lshift
id|MD_DISK_FAULTY
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|err
op_assign
id|md_import_device
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: error, md_import_device() returned %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rdev
op_assign
id|find_rdev_all
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rdev-&gt;old_dev
op_assign
id|dev
suffix:semicolon
id|rdev-&gt;desc_nr
op_assign
id|info-&gt;number
suffix:semicolon
id|bind_rdev_to_array
c_func
(paren
id|rdev
comma
id|mddev
)paren
suffix:semicolon
id|persistent
op_assign
op_logical_neg
id|mddev-&gt;sb-&gt;not_persistent
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|persistent
)paren
id|printk
c_func
(paren
l_string|&quot;nonpersistent superblock ...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb-&gt;chunk_size
)paren
id|printk
c_func
(paren
l_string|&quot;no chunksize?&bslash;n&quot;
)paren
suffix:semicolon
id|size
op_assign
id|calc_dev_size
c_func
(paren
id|dev
comma
id|mddev
comma
id|persistent
)paren
suffix:semicolon
id|rdev-&gt;sb_offset
op_assign
id|calc_dev_sboffset
c_func
(paren
id|dev
comma
id|mddev
comma
id|persistent
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb-&gt;size
op_logical_or
(paren
id|mddev-&gt;sb-&gt;size
OG
id|size
)paren
)paren
id|mddev-&gt;sb-&gt;size
op_assign
id|size
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * sync all other superblocks with the main superblock&n;&t; */
id|sync_sbs
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SET_SB
macro_line|#undef SET_SB
DECL|function|hot_remove_disk
r_static
r_int
id|hot_remove_disk
(paren
id|mddev_t
op_star
id|mddev
comma
id|kdev_t
id|dev
)paren
(brace
r_int
id|err
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|mdp_disk_t
op_star
id|disk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;trying to remove %s from md%d ... &bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers-&gt;diskop
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md%d: personality does not support diskops!&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rdev
op_assign
id|find_rdev
c_func
(paren
id|mddev
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|disk
op_assign
op_amp
id|mddev-&gt;sb-&gt;disks
(braket
id|rdev-&gt;desc_nr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|disk_active
c_func
(paren
id|disk
)paren
)paren
r_goto
id|busy
suffix:semicolon
r_if
c_cond
(paren
id|disk_removed
c_func
(paren
id|disk
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|err
op_assign
id|mddev-&gt;pers
op_member_access_from_pointer
id|diskop
c_func
(paren
id|mddev
comma
op_amp
id|disk
comma
id|DISKOP_HOT_REMOVE_DISK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EBUSY
)paren
r_goto
id|busy
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|remove_descriptor
c_func
(paren
id|disk
comma
id|mddev-&gt;sb
)paren
suffix:semicolon
id|kick_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|mddev-&gt;sb_dirty
op_assign
l_int|1
suffix:semicolon
id|md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|busy
suffix:colon
id|printk
c_func
(paren
l_string|&quot;cannot remove active disk %s from md%d ... &bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
DECL|function|hot_add_disk
r_static
r_int
id|hot_add_disk
(paren
id|mddev_t
op_star
id|mddev
comma
id|kdev_t
id|dev
)paren
(brace
r_int
id|i
comma
id|err
comma
id|persistent
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|mdp_disk_t
op_star
id|disk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;trying to hot-add %s to md%d ... &bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers-&gt;diskop
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md%d: personality does not support diskops!&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|persistent
op_assign
op_logical_neg
id|mddev-&gt;sb-&gt;not_persistent
suffix:semicolon
id|size
op_assign
id|calc_dev_size
c_func
(paren
id|dev
comma
id|mddev
comma
id|persistent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
id|mddev-&gt;sb-&gt;size
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md%d: disk size %d blocks &lt; array size %d&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|size
comma
id|mddev-&gt;sb-&gt;size
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
id|rdev
op_assign
id|find_rdev
c_func
(paren
id|mddev
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|err
op_assign
id|md_import_device
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: error, md_import_device() returned %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rdev
op_assign
id|find_rdev_all
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: can not hot-add faulty %s disk to md%d!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_export
suffix:semicolon
)brace
id|bind_rdev_to_array
c_func
(paren
id|rdev
comma
id|mddev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The rest should better be atomic, we can have disk failures&n;&t; * noticed in interrupt contexts ...&n;&t; */
id|rdev-&gt;old_dev
op_assign
id|dev
suffix:semicolon
id|rdev-&gt;size
op_assign
id|size
suffix:semicolon
id|rdev-&gt;sb_offset
op_assign
id|calc_dev_sboffset
c_func
(paren
id|dev
comma
id|mddev
comma
id|persistent
)paren
suffix:semicolon
id|disk
op_assign
id|mddev-&gt;sb-&gt;disks
op_plus
id|mddev-&gt;sb-&gt;raid_disks
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|mddev-&gt;sb-&gt;raid_disks
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|disk
op_assign
id|mddev-&gt;sb-&gt;disks
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk-&gt;major
op_logical_and
op_logical_neg
id|disk-&gt;minor
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|disk_removed
c_func
(paren
id|disk
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|MD_SB_DISKS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md%d: can not hot-add to full array!&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|abort_unbind_export
suffix:semicolon
)brace
r_if
c_cond
(paren
id|disk_removed
c_func
(paren
id|disk
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * reuse slot&n;&t;&t; */
r_if
c_cond
(paren
id|disk-&gt;number
op_ne
id|i
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_unbind_export
suffix:semicolon
)brace
)brace
r_else
(brace
id|disk-&gt;number
op_assign
id|i
suffix:semicolon
)brace
id|disk-&gt;raid_disk
op_assign
id|disk-&gt;number
suffix:semicolon
id|disk-&gt;major
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|disk-&gt;minor
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers
op_member_access_from_pointer
id|diskop
c_func
(paren
id|mddev
comma
op_amp
id|disk
comma
id|DISKOP_HOT_ADD_DISK
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_unbind_export
suffix:semicolon
)brace
id|mark_disk_spare
c_func
(paren
id|disk
)paren
suffix:semicolon
id|mddev-&gt;sb-&gt;nr_disks
op_increment
suffix:semicolon
id|mddev-&gt;sb-&gt;spare_disks
op_increment
suffix:semicolon
id|mddev-&gt;sb-&gt;working_disks
op_increment
suffix:semicolon
id|mddev-&gt;sb_dirty
op_assign
l_int|1
suffix:semicolon
id|md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Kick recovery, maybe this spare has to be added to the&n;&t; * array immediately.&n;&t; */
id|md_recover_arrays
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|abort_unbind_export
suffix:colon
id|unbind_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|abort_export
suffix:colon
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|macro|SET_SB
mdefine_line|#define SET_SB(x) mddev-&gt;sb-&gt;x = info-&gt;x
DECL|function|set_array_info
r_static
r_int
id|set_array_info
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdu_array_info_t
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|alloc_array_sb
c_func
(paren
id|mddev
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|mddev-&gt;sb-&gt;major_version
op_assign
id|MD_MAJOR_VERSION
suffix:semicolon
id|mddev-&gt;sb-&gt;minor_version
op_assign
id|MD_MINOR_VERSION
suffix:semicolon
id|mddev-&gt;sb-&gt;patch_version
op_assign
id|MD_PATCHLEVEL_VERSION
suffix:semicolon
id|mddev-&gt;sb-&gt;ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|SET_SB
c_func
(paren
id|level
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|size
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|nr_disks
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|raid_disks
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|md_minor
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|not_persistent
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|state
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|active_disks
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|working_disks
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|failed_disks
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|spare_disks
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|layout
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|chunk_size
)paren
suffix:semicolon
id|mddev-&gt;sb-&gt;md_magic
op_assign
id|MD_SB_MAGIC
suffix:semicolon
multiline_comment|/*&n;&t; * Generate a 128 bit UUID&n;&t; */
id|get_random_bytes
c_func
(paren
op_amp
id|mddev-&gt;sb-&gt;set_uuid0
comma
l_int|4
)paren
suffix:semicolon
id|get_random_bytes
c_func
(paren
op_amp
id|mddev-&gt;sb-&gt;set_uuid1
comma
l_int|4
)paren
suffix:semicolon
id|get_random_bytes
c_func
(paren
op_amp
id|mddev-&gt;sb-&gt;set_uuid2
comma
l_int|4
)paren
suffix:semicolon
id|get_random_bytes
c_func
(paren
op_amp
id|mddev-&gt;sb-&gt;set_uuid3
comma
l_int|4
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SET_SB
macro_line|#undef SET_SB
DECL|function|set_disk_info
r_static
r_int
id|set_disk_info
(paren
id|mddev_t
op_star
id|mddev
comma
r_void
op_star
id|arg
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;not yet&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|clear_array
r_static
r_int
id|clear_array
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;not yet&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|write_raid_info
r_static
r_int
id|write_raid_info
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;not yet&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|protect_array
r_static
r_int
id|protect_array
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;not yet&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|unprotect_array
r_static
r_int
id|unprotect_array
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;not yet&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|set_disk_faulty
r_static
r_int
id|set_disk_faulty
(paren
id|mddev_t
op_star
id|mddev
comma
id|kdev_t
id|dev
)paren
(brace
r_int
id|ret
suffix:semicolon
id|fsync_dev
c_func
(paren
id|mddev_to_kdev
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|md_error
c_func
(paren
id|mddev_to_kdev
c_func
(paren
id|mddev
)paren
comma
id|dev
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|md_ioctl
r_static
r_int
id|md_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
r_int
id|minor
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|hd_geometry
op_star
id|loc
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|arg
suffix:semicolon
id|mddev_t
op_star
id|mddev
op_assign
l_int|NULL
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|md_capable_admin
c_func
(paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|dev
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|MAX_MD_DEVS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * Commands dealing with the RAID driver but not any&n;&t; * particular array:&n;&t; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|RAID_VERSION
suffix:colon
id|err
op_assign
id|get_version
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
id|PRINT_RAID_DEBUG
suffix:colon
id|err
op_assign
l_int|0
suffix:semicolon
id|md_print_devices
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|BLKGETSIZE
suffix:colon
multiline_comment|/* Return device size */
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|err
op_assign
id|md_put_user
c_func
(paren
id|md_hd_struct
(braket
id|minor
)braket
dot
id|nr_sects
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
id|BLKFLSBUF
suffix:colon
id|fsync_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|dev
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
id|BLKRASET
suffix:colon
r_if
c_cond
(paren
id|arg
OG
l_int|0xff
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|read_ahead
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
op_assign
id|arg
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
id|BLKRAGET
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|err
op_assign
id|md_put_user
(paren
id|read_ahead
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
multiline_comment|/*&n;&t; * Commands creating/starting a new array:&n;&t; */
id|mddev
op_assign
id|kdev_to_mddev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SET_ARRAY_INFO
suffix:colon
r_case
id|START_ARRAY
suffix:colon
r_if
c_cond
(paren
id|mddev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;array md%d already exists!&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_default
suffix:colon
(brace
)brace
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SET_ARRAY_INFO
suffix:colon
id|mddev
op_assign
id|alloc_mddev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|mddev-&gt;active
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * alloc_mddev() should possibly self-lock.&n;&t;&t;&t; */
id|err
op_assign
id|lock_mddev
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ioctl, reason %d, cmd %d&bslash;n&quot;
comma
id|err
comma
id|cmd
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;sb
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;array md%d already has a superblock!&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
)paren
(brace
id|mdu_array_info_t
id|info
suffix:semicolon
r_if
c_cond
(paren
id|md_copy_from_user
c_func
(paren
op_amp
id|info
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
id|err
op_assign
id|set_array_info
c_func
(paren
id|mddev
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;couldnt set array info. %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
)brace
r_goto
id|done_unlock
suffix:semicolon
r_case
id|START_ARRAY
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * possibly make it lock the array ...&n;&t;&t;&t; */
id|err
op_assign
id|autostart_array
c_func
(paren
(paren
id|kdev_t
)paren
id|arg
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;autostart %s failed!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
(paren
id|kdev_t
)paren
id|arg
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_goto
id|done
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
multiline_comment|/*&n;&t; * Commands querying/configuring an existing array:&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|mddev
)paren
(brace
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|err
op_assign
id|lock_mddev
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ioctl lock interrupted, reason %d, cmd %d&bslash;n&quot;
comma
id|err
comma
id|cmd
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
multiline_comment|/* if we don&squot;t have a superblock yet, only ADD_NEW_DISK or STOP_ARRAY is allowed */
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb
op_logical_and
id|cmd
op_ne
id|ADD_NEW_DISK
op_logical_and
id|cmd
op_ne
id|STOP_ARRAY
op_logical_and
id|cmd
op_ne
id|RUN_ARRAY
)paren
(brace
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Commands even a read-only array can execute:&n;&t; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|GET_ARRAY_INFO
suffix:colon
id|err
op_assign
id|get_array_info
c_func
(paren
id|mddev
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|GET_DISK_INFO
suffix:colon
id|err
op_assign
id|get_disk_info
c_func
(paren
id|mddev
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|RESTART_ARRAY_RW
suffix:colon
id|err
op_assign
id|restart_array
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|STOP_ARRAY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|err
op_assign
id|do_md_stop
(paren
id|mddev
comma
l_int|0
)paren
)paren
)paren
id|mddev
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|STOP_ARRAY_RO
suffix:colon
id|err
op_assign
id|do_md_stop
(paren
id|mddev
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
multiline_comment|/*&n;&t; * We have a problem here : there is no easy way to give a CHS&n;&t; * virtual geometry. We currently pretend that we have a 2 heads&n;&t; * 4 sectors (with a BIG number of cylinders...). This drives&n;&t; * dosfs just mad... ;-)&n;&t; */
r_case
id|HDIO_GETGEO
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|loc
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
id|err
op_assign
id|md_put_user
(paren
l_int|2
comma
(paren
r_char
op_star
)paren
op_amp
id|loc-&gt;heads
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|abort_unlock
suffix:semicolon
id|err
op_assign
id|md_put_user
(paren
l_int|4
comma
(paren
r_char
op_star
)paren
op_amp
id|loc-&gt;sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|abort_unlock
suffix:semicolon
id|err
op_assign
id|md_put_user
(paren
id|md_hd_struct
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
dot
id|nr_sects
op_div
l_int|8
comma
(paren
r_int
op_star
)paren
op_amp
id|loc-&gt;cylinders
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|abort_unlock
suffix:semicolon
id|err
op_assign
id|md_put_user
(paren
id|md_hd_struct
(braket
id|minor
)braket
dot
id|start_sect
comma
(paren
r_int
op_star
)paren
op_amp
id|loc-&gt;start
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The remaining ioctls are changing the state of the&n;&t; * superblock, so we do not allow read-only arrays&n;&t; * here:&n;&t; */
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
(brace
id|err
op_assign
op_minus
id|EROFS
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CLEAR_ARRAY
suffix:colon
id|err
op_assign
id|clear_array
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|ADD_NEW_DISK
suffix:colon
(brace
id|mdu_disk_info_t
id|info
suffix:semicolon
r_if
c_cond
(paren
id|md_copy_from_user
c_func
(paren
op_amp
id|info
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_else
id|err
op_assign
id|add_new_disk
c_func
(paren
id|mddev
comma
op_amp
id|info
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
)brace
r_case
id|HOT_REMOVE_DISK
suffix:colon
id|err
op_assign
id|hot_remove_disk
c_func
(paren
id|mddev
comma
(paren
id|kdev_t
)paren
id|arg
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|HOT_ADD_DISK
suffix:colon
id|err
op_assign
id|hot_add_disk
c_func
(paren
id|mddev
comma
(paren
id|kdev_t
)paren
id|arg
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|SET_DISK_INFO
suffix:colon
id|err
op_assign
id|set_disk_info
c_func
(paren
id|mddev
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|WRITE_RAID_INFO
suffix:colon
id|err
op_assign
id|write_raid_info
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|UNPROTECT_ARRAY
suffix:colon
id|err
op_assign
id|unprotect_array
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|PROTECT_ARRAY
suffix:colon
id|err
op_assign
id|protect_array
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|SET_DISK_FAULTY
suffix:colon
id|err
op_assign
id|set_disk_faulty
c_func
(paren
id|mddev
comma
(paren
id|kdev_t
)paren
id|arg
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|RUN_ARRAY
suffix:colon
(brace
multiline_comment|/* The data is never used....&n;&t;&t;&t;mdu_param_t param;&n;&t;&t;&t;err = md_copy_from_user(&amp;param, (mdu_param_t *)arg,&n;&t;&t;&t;&t;&t;&t;&t; sizeof(param));&n;&t;&t;&t;if (err)&n;&t;&t;&t;&t;goto abort_unlock;&n;*/
id|err
op_assign
id|do_md_run
(paren
id|mddev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * we have to clean up the mess if&n;&t;&t;&t; * the array cannot be run for some&n;&t;&t;&t; * reason ...&n;&t;&t;&t; */
r_if
c_cond
(paren
id|err
)paren
(brace
id|mddev-&gt;sb_dirty
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|do_md_stop
(paren
id|mddev
comma
l_int|0
)paren
)paren
id|mddev
op_assign
l_int|NULL
suffix:semicolon
)brace
r_goto
id|done_unlock
suffix:semicolon
)brace
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s(pid %d) used obsolete MD ioctl, upgrade your software to use new ictls.&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
id|done_unlock
suffix:colon
id|abort_unlock
suffix:colon
r_if
c_cond
(paren
id|mddev
)paren
id|unlock_mddev
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
l_string|&quot;huh12?&bslash;n&quot;
)paren
suffix:semicolon
m_abort
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|md_open
r_static
r_int
id|md_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
multiline_comment|/*&n;&t; * Always succeed, but increment the usage count&n;&t; */
id|mddev_t
op_star
id|mddev
op_assign
id|kdev_to_mddev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev
)paren
id|atomic_inc
c_func
(paren
op_amp
id|mddev-&gt;active
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|md_release
r_static
r_int
id|md_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|kdev_to_mddev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev
)paren
id|atomic_dec
c_func
(paren
op_amp
id|mddev-&gt;active
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|md_fops
r_static
r_struct
id|block_device_operations
id|md_fops
op_assign
(brace
id|open
suffix:colon
id|md_open
comma
id|release
suffix:colon
id|md_release
comma
id|ioctl
suffix:colon
id|md_ioctl
comma
)brace
suffix:semicolon
DECL|function|md_thread
r_int
id|md_thread
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
id|mdk_thread_t
op_star
id|thread
op_assign
id|arg
suffix:semicolon
id|md_lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Detach thread&n;&t; */
id|daemonize
c_func
(paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
id|thread-&gt;name
)paren
suffix:semicolon
id|md_init_signals
c_func
(paren
)paren
suffix:semicolon
id|md_flush_signals
c_func
(paren
)paren
suffix:semicolon
id|thread-&gt;tsk
op_assign
id|current
suffix:semicolon
multiline_comment|/*&n;&t; * md_thread is a &squot;system-thread&squot;, it&squot;s priority should be very&n;&t; * high. We avoid resource deadlocks individually in each&n;&t; * raid personality. (RAID5 does preallocation) We also use RR and&n;&t; * the very same RT priority as kswapd, thus we will never get&n;&t; * into a priority inversion deadlock.&n;&t; *&n;&t; * we definitely have to have equal or higher priority than&n;&t; * bdflush, otherwise bdflush will deadlock if there are too&n;&t; * many dirty RAID5 blocks.&n;&t; */
id|current-&gt;policy
op_assign
id|SCHED_OTHER
suffix:semicolon
id|current-&gt;nice
op_assign
op_minus
l_int|20
suffix:semicolon
singleline_comment|//&t;md_unlock_kernel();
id|up
c_func
(paren
id|thread-&gt;sem
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|thread-&gt;wqueue
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|current
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|THREAD_WAKEUP
comma
op_amp
id|thread-&gt;flags
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;thread %p went to sleep.&bslash;n&quot;
comma
id|thread
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;thread %p woke up.&bslash;n&quot;
comma
id|thread
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|thread-&gt;wqueue
comma
op_amp
id|wait
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|THREAD_WAKEUP
comma
op_amp
id|thread-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thread-&gt;run
)paren
(brace
id|thread
op_member_access_from_pointer
id|run
c_func
(paren
id|thread-&gt;data
)paren
suffix:semicolon
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
r_if
c_cond
(paren
id|md_signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%8s(%d) flushing signals.&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|md_flush_signals
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
id|thread-&gt;sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|md_wakeup_thread
r_void
id|md_wakeup_thread
c_func
(paren
id|mdk_thread_t
op_star
id|thread
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;waking up MD thread %p.&bslash;n&quot;
comma
id|thread
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|THREAD_WAKEUP
comma
op_amp
id|thread-&gt;flags
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|thread-&gt;wqueue
)paren
suffix:semicolon
)brace
DECL|function|md_register_thread
id|mdk_thread_t
op_star
id|md_register_thread
(paren
r_void
(paren
op_star
id|run
)paren
(paren
r_void
op_star
)paren
comma
r_void
op_star
id|data
comma
r_const
r_char
op_star
id|name
)paren
(brace
id|mdk_thread_t
op_star
id|thread
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|sem
)paren
suffix:semicolon
id|thread
op_assign
(paren
id|mdk_thread_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|mdk_thread_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|thread
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|thread
comma
l_int|0
comma
r_sizeof
(paren
id|mdk_thread_t
)paren
)paren
suffix:semicolon
id|md_init_waitqueue_head
c_func
(paren
op_amp
id|thread-&gt;wqueue
)paren
suffix:semicolon
id|thread-&gt;sem
op_assign
op_amp
id|sem
suffix:semicolon
id|thread-&gt;run
op_assign
id|run
suffix:semicolon
id|thread-&gt;data
op_assign
id|data
suffix:semicolon
id|thread-&gt;name
op_assign
id|name
suffix:semicolon
id|ret
op_assign
id|kernel_thread
c_func
(paren
id|md_thread
comma
id|thread
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|thread
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
r_return
id|thread
suffix:semicolon
)brace
DECL|function|md_interrupt_thread
r_void
id|md_interrupt_thread
(paren
id|mdk_thread_t
op_star
id|thread
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|thread-&gt;tsk
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;interrupting MD-thread pid %d&bslash;n&quot;
comma
id|thread-&gt;tsk-&gt;pid
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|thread-&gt;tsk
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|md_unregister_thread
r_void
id|md_unregister_thread
(paren
id|mdk_thread_t
op_star
id|thread
)paren
(brace
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|sem
)paren
suffix:semicolon
id|thread-&gt;sem
op_assign
op_amp
id|sem
suffix:semicolon
id|thread-&gt;run
op_assign
l_int|NULL
suffix:semicolon
id|thread-&gt;name
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|thread-&gt;tsk
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|md_interrupt_thread
c_func
(paren
id|thread
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
)brace
DECL|function|md_recover_arrays
r_void
id|md_recover_arrays
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|md_recovery_thread
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|md_wakeup_thread
c_func
(paren
id|md_recovery_thread
)paren
suffix:semicolon
)brace
DECL|function|md_error
r_int
id|md_error
(paren
id|kdev_t
id|dev
comma
id|kdev_t
id|rdev
)paren
(brace
id|mddev_t
op_star
id|mddev
suffix:semicolon
id|mdk_rdev_t
op_star
id|rrdev
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|mddev
op_assign
id|kdev_to_mddev
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&t;printk(&quot;md_error dev:(%d:%d), rdev:(%d:%d), (caller: %p,%p,%p,%p).&bslash;n&quot;,MAJOR(dev),MINOR(dev),MAJOR(rdev),MINOR(rdev), __builtin_return_address(0),__builtin_return_address(1),__builtin_return_address(2),__builtin_return_address(3));&n; */
r_if
c_cond
(paren
op_logical_neg
id|mddev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|rrdev
op_assign
id|find_rdev
c_func
(paren
id|mddev
comma
id|rdev
)paren
suffix:semicolon
id|mark_rdev_faulty
c_func
(paren
id|rrdev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if recovery was running, stop it now.&n;&t; */
r_if
c_cond
(paren
id|mddev-&gt;pers-&gt;stop_resync
)paren
id|mddev-&gt;pers
op_member_access_from_pointer
id|stop_resync
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;recovery_running
)paren
id|md_interrupt_thread
c_func
(paren
id|md_recovery_thread
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers-&gt;error_handler
)paren
(brace
id|rc
op_assign
id|mddev-&gt;pers
op_member_access_from_pointer
id|error_handler
c_func
(paren
id|mddev
comma
id|rdev
)paren
suffix:semicolon
id|md_recover_arrays
c_func
(paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|status_unused
r_static
r_int
id|status_unused
(paren
r_char
op_star
id|page
)paren
(brace
r_int
id|sz
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;unused devices: &quot;
)paren
suffix:semicolon
id|ITERATE_RDEV_ALL
c_func
(paren
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;same_set.next
op_logical_and
op_logical_neg
id|rdev-&gt;same_set.prev
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The device is not yet used by any array.&n;&t;&t;&t; */
id|i
op_increment
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;%s &quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&lt;none&gt;&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
DECL|function|status_resync
r_static
r_int
id|status_resync
(paren
r_char
op_star
id|page
comma
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|sz
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|max_blocks
comma
id|resync
comma
id|res
comma
id|dt
comma
id|db
comma
id|rt
suffix:semicolon
id|resync
op_assign
id|mddev-&gt;curr_resync
op_minus
id|atomic_read
c_func
(paren
op_amp
id|mddev-&gt;recovery_active
)paren
suffix:semicolon
id|max_blocks
op_assign
id|mddev-&gt;sb-&gt;size
suffix:semicolon
multiline_comment|/*&n;&t; * Should not happen.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|max_blocks
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|res
op_assign
(paren
id|resync
op_div
l_int|1024
)paren
op_star
l_int|1000
op_div
(paren
id|max_blocks
op_div
l_int|1024
op_plus
l_int|1
)paren
suffix:semicolon
(brace
r_int
id|i
comma
id|x
op_assign
id|res
op_div
l_int|50
comma
id|y
op_assign
l_int|20
op_minus
id|x
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;[&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|x
suffix:semicolon
id|i
op_increment
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;=&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|y
suffix:semicolon
id|i
op_increment
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;.&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;] &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;recovery_running
)paren
multiline_comment|/*&n;&t;&t; * true resync&n;&t;&t; */
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; resync =%3lu.%lu%% (%lu/%lu)&quot;
comma
id|res
op_div
l_int|10
comma
id|res
op_mod
l_int|10
comma
id|resync
comma
id|max_blocks
)paren
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t; * recovery ...&n;&t;&t; */
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; recovery =%3lu.%lu%% (%lu/%lu)&quot;
comma
id|res
op_div
l_int|10
comma
id|res
op_mod
l_int|10
comma
id|resync
comma
id|max_blocks
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We do not want to overflow, so the order of operands and&n;&t; * the * 100 / 100 trick are important. We do a +1 to be&n;&t; * safe against division by zero. We only estimate anyway.&n;&t; *&n;&t; * dt: time from mark until now&n;&t; * db: blocks written from mark until now&n;&t; * rt: remaining time&n;&t; */
id|dt
op_assign
(paren
(paren
id|jiffies
op_minus
id|mddev-&gt;resync_mark
)paren
op_div
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dt
)paren
id|dt
op_increment
suffix:semicolon
id|db
op_assign
id|resync
op_minus
id|mddev-&gt;resync_mark_cnt
suffix:semicolon
id|rt
op_assign
(paren
id|dt
op_star
(paren
(paren
id|max_blocks
op_minus
id|resync
)paren
op_div
(paren
id|db
op_div
l_int|100
op_plus
l_int|1
)paren
)paren
)paren
op_div
l_int|100
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; finish=%lu.%lumin&quot;
comma
id|rt
op_div
l_int|60
comma
(paren
id|rt
op_mod
l_int|60
)paren
op_div
l_int|6
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; speed=%ldK/sec&quot;
comma
id|db
op_div
id|dt
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
DECL|function|md_status_read_proc
r_static
r_int
id|md_status_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|sz
op_assign
l_int|0
comma
id|j
comma
id|size
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
comma
op_star
id|tmp2
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;Personalities : &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|MAX_PERSONALITY
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|pers
(braket
id|j
)braket
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;[%s] &quot;
comma
id|pers
(braket
id|j
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;read_ahead &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_ahead
(braket
id|MD_MAJOR
)braket
op_eq
id|INT_MAX
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;not set&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;%d sectors&bslash;n&quot;
comma
id|read_ahead
(braket
id|MD_MAJOR
)braket
)paren
suffix:semicolon
id|ITERATE_MDDEV
c_func
(paren
id|mddev
comma
id|tmp
)paren
(brace
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;md%d : %sactive&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|mddev-&gt;pers
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;in&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
(brace
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; (read-only)&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; %s&quot;
comma
id|mddev-&gt;pers-&gt;name
)paren
suffix:semicolon
)brace
id|size
op_assign
l_int|0
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp2
)paren
(brace
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; %s[%d]&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|rdev-&gt;desc_nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;(F)&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|size
op_add_assign
id|rdev-&gt;size
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;nb_dev
)paren
(brace
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&bslash;n      %d blocks&quot;
comma
id|md_size
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
)paren
suffix:semicolon
r_else
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&bslash;n      %d blocks&quot;
comma
id|size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers
)paren
(brace
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|sz
op_add_assign
id|mddev-&gt;pers-&gt;status
(paren
id|page
op_plus
id|sz
comma
id|mddev
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&bslash;n      &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;curr_resync
)paren
(brace
id|sz
op_add_assign
id|status_resync
(paren
id|page
op_plus
id|sz
comma
id|mddev
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|md_atomic_read
c_func
(paren
op_amp
id|mddev-&gt;resync_sem.count
)paren
op_ne
l_int|1
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&t;resync=DELAYED&quot;
)paren
suffix:semicolon
)brace
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|sz
op_add_assign
id|status_unused
(paren
id|page
op_plus
id|sz
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
DECL|function|register_md_personality
r_int
id|register_md_personality
(paren
r_int
id|pnum
comma
id|mdk_personality_t
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|pnum
op_ge
id|MAX_PERSONALITY
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pers
(braket
id|pnum
)braket
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|pers
(braket
id|pnum
)braket
op_assign
id|p
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s personality registered&bslash;n&quot;
comma
id|p-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unregister_md_personality
r_int
id|unregister_md_personality
(paren
r_int
id|pnum
)paren
(brace
r_if
c_cond
(paren
id|pnum
op_ge
id|MAX_PERSONALITY
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s personality unregistered&bslash;n&quot;
comma
id|pers
(braket
id|pnum
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|pers
(braket
id|pnum
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_spare
r_static
id|mdp_disk_t
op_star
id|get_spare
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
id|mdp_disk_t
op_star
id|disk
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|disk
op_assign
op_amp
id|sb-&gt;disks
(braket
id|rdev-&gt;desc_nr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|disk_faulty
c_func
(paren
id|disk
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|disk_active
c_func
(paren
id|disk
)paren
)paren
r_continue
suffix:semicolon
r_return
id|disk
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|sync_io
r_static
r_int
r_int
id|sync_io
(braket
id|DK_MAX_MAJOR
)braket
(braket
id|DK_MAX_DISK
)braket
suffix:semicolon
DECL|function|md_sync_acct
r_void
id|md_sync_acct
c_func
(paren
id|kdev_t
id|dev
comma
r_int
r_int
id|nr_sectors
)paren
(brace
r_int
r_int
id|major
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|index
suffix:semicolon
id|index
op_assign
id|disk_index
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|index
op_ge
id|DK_MAX_DISK
)paren
op_logical_or
(paren
id|major
op_ge
id|DK_MAX_MAJOR
)paren
)paren
r_return
suffix:semicolon
id|sync_io
(braket
id|major
)braket
(braket
id|index
)braket
op_add_assign
id|nr_sectors
suffix:semicolon
)brace
DECL|function|is_mddev_idle
r_static
r_int
id|is_mddev_idle
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
r_int
id|idle
suffix:semicolon
r_int
r_int
id|curr_events
suffix:semicolon
id|idle
op_assign
l_int|1
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_int
id|major
op_assign
id|MAJOR
c_func
(paren
id|rdev-&gt;dev
)paren
suffix:semicolon
r_int
id|idx
op_assign
id|disk_index
c_func
(paren
id|rdev-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|idx
op_ge
id|DK_MAX_DISK
)paren
op_logical_or
(paren
id|major
op_ge
id|DK_MAX_MAJOR
)paren
)paren
r_continue
suffix:semicolon
id|curr_events
op_assign
id|kstat.dk_drive_rblk
(braket
id|major
)braket
(braket
id|idx
)braket
op_plus
id|kstat.dk_drive_wblk
(braket
id|major
)braket
(braket
id|idx
)braket
suffix:semicolon
id|curr_events
op_sub_assign
id|sync_io
(braket
id|major
)braket
(braket
id|idx
)braket
suffix:semicolon
singleline_comment|//&t;&t;printk(&quot;events(major: %d, idx: %d): %ld&bslash;n&quot;, major, idx, curr_events);
r_if
c_cond
(paren
id|curr_events
op_ne
id|rdev-&gt;last_events
)paren
(brace
singleline_comment|//&t;&t;&t;printk(&quot;!I(%ld)&quot;, curr_events - rdev-&gt;last_events);
id|rdev-&gt;last_events
op_assign
id|curr_events
suffix:semicolon
id|idle
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|idle
suffix:semicolon
)brace
DECL|variable|resync_wait
id|MD_DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|resync_wait
)paren
suffix:semicolon
DECL|function|md_done_sync
r_void
id|md_done_sync
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|blocks
comma
r_int
id|ok
)paren
(brace
multiline_comment|/* another &quot;blocks&quot; (1K) blocks have been synced */
id|atomic_sub
c_func
(paren
id|blocks
comma
op_amp
id|mddev-&gt;recovery_active
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|mddev-&gt;recovery_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ok
)paren
(brace
singleline_comment|// stop recovery, signal do_sync ....
)brace
)brace
DECL|macro|SYNC_MARKS
mdefine_line|#define SYNC_MARKS&t;10
DECL|macro|SYNC_MARK_STEP
mdefine_line|#define&t;SYNC_MARK_STEP&t;(3*HZ)
DECL|function|md_do_sync
r_int
id|md_do_sync
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdp_disk_t
op_star
id|spare
)paren
(brace
id|mddev_t
op_star
id|mddev2
suffix:semicolon
r_int
r_int
id|max_blocks
comma
id|currspeed
comma
id|j
comma
id|window
comma
id|err
comma
id|serialize
suffix:semicolon
id|kdev_t
id|read_disk
op_assign
id|mddev_to_kdev
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
r_int
id|mark
(braket
id|SYNC_MARKS
)braket
suffix:semicolon
r_int
r_int
id|mark_cnt
(braket
id|SYNC_MARKS
)braket
suffix:semicolon
r_int
id|last_mark
comma
id|m
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|last_check
suffix:semicolon
id|err
op_assign
id|down_interruptible
c_func
(paren
op_amp
id|mddev-&gt;resync_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_nolock
suffix:semicolon
id|recheck
suffix:colon
id|serialize
op_assign
l_int|0
suffix:semicolon
id|ITERATE_MDDEV
c_func
(paren
id|mddev2
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|mddev2
op_eq
id|mddev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mddev2-&gt;curr_resync
op_logical_and
id|match_mddev_units
c_func
(paren
id|mddev
comma
id|mddev2
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: serializing resync, md%d shares one or more physical units with md%d!&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|mdidx
c_func
(paren
id|mddev2
)paren
)paren
suffix:semicolon
id|serialize
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|serialize
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|resync_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|md_signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|md_flush_signals
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINTR
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_goto
id|recheck
suffix:semicolon
)brace
id|mddev-&gt;curr_resync
op_assign
l_int|1
suffix:semicolon
id|max_blocks
op_assign
id|mddev-&gt;sb-&gt;size
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: syncing RAID array md%d&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: minimum _guaranteed_ reconstruction speed: %d KB/sec/disc.&bslash;n&quot;
comma
id|sysctl_speed_limit_min
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: using maximum available idle IO bandwith (but not more than %d KB/sec) for reconstruction.&bslash;n&quot;
comma
id|sysctl_speed_limit_max
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Resync has low priority.&n;&t; */
id|current-&gt;nice
op_assign
l_int|19
suffix:semicolon
id|is_mddev_idle
c_func
(paren
id|mddev
)paren
suffix:semicolon
multiline_comment|/* this also initializes IO event counters */
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|SYNC_MARKS
suffix:semicolon
id|m
op_increment
)paren
(brace
id|mark
(braket
id|m
)braket
op_assign
id|jiffies
suffix:semicolon
id|mark_cnt
(braket
id|m
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|last_mark
op_assign
l_int|0
suffix:semicolon
id|mddev-&gt;resync_mark
op_assign
id|mark
(braket
id|last_mark
)braket
suffix:semicolon
id|mddev-&gt;resync_mark_cnt
op_assign
id|mark_cnt
(braket
id|last_mark
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Tune reconstruction:&n;&t; */
id|window
op_assign
id|MAX_READAHEAD
op_star
(paren
id|PAGE_SIZE
op_div
l_int|1024
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: using %dk window, over a total of %d blocks.&bslash;n&quot;
comma
id|window
comma
id|max_blocks
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|mddev-&gt;recovery_active
comma
l_int|0
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|mddev-&gt;recovery_wait
)paren
suffix:semicolon
id|last_check
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|max_blocks
suffix:semicolon
)paren
(brace
r_int
id|blocks
suffix:semicolon
id|blocks
op_assign
id|mddev-&gt;pers
op_member_access_from_pointer
id|sync_request
c_func
(paren
id|mddev
comma
id|j
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blocks
OL
l_int|0
)paren
(brace
id|err
op_assign
id|blocks
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|atomic_add
c_func
(paren
id|blocks
comma
op_amp
id|mddev-&gt;recovery_active
)paren
suffix:semicolon
id|j
op_add_assign
id|blocks
suffix:semicolon
id|mddev-&gt;curr_resync
op_assign
id|j
suffix:semicolon
r_if
c_cond
(paren
id|last_check
op_plus
id|window
OG
id|j
)paren
r_continue
suffix:semicolon
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
singleline_comment|//??
r_if
c_cond
(paren
id|jiffies
op_ge
id|mark
(braket
id|last_mark
)braket
op_plus
id|SYNC_MARK_STEP
)paren
(brace
multiline_comment|/* step marks */
r_int
id|next
op_assign
(paren
id|last_mark
op_plus
l_int|1
)paren
op_mod
id|SYNC_MARKS
suffix:semicolon
id|mddev-&gt;resync_mark
op_assign
id|mark
(braket
id|next
)braket
suffix:semicolon
id|mddev-&gt;resync_mark_cnt
op_assign
id|mark_cnt
(braket
id|next
)braket
suffix:semicolon
id|mark
(braket
id|next
)braket
op_assign
id|jiffies
suffix:semicolon
id|mark_cnt
(braket
id|next
)braket
op_assign
id|j
op_minus
id|atomic_read
c_func
(paren
op_amp
id|mddev-&gt;recovery_active
)paren
suffix:semicolon
id|last_mark
op_assign
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|md_signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * got a signal, exit.&n;&t;&t;&t; */
id|mddev-&gt;curr_resync
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;md_do_sync() got signal ... exiting&bslash;n&quot;
)paren
suffix:semicolon
id|md_flush_signals
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINTR
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * this loop exits only if either when we are slower than&n;&t;&t; * the &squot;hard&squot; speed limit, or the system was IO-idle for&n;&t;&t; * a jiffy.&n;&t;&t; * the system might be non-idle CPU-wise, but we only care&n;&t;&t; * about not overloading the IO subsystem. (things like an&n;&t;&t; * e2fsck being done on the RAID array should execute fast)&n;&t;&t; */
id|repeat
suffix:colon
r_if
c_cond
(paren
id|md_need_resched
c_func
(paren
id|current
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|currspeed
op_assign
(paren
id|j
op_minus
id|mddev-&gt;resync_mark_cnt
)paren
op_div
(paren
(paren
id|jiffies
op_minus
id|mddev-&gt;resync_mark
)paren
op_div
id|HZ
op_plus
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|currspeed
OG
id|sysctl_speed_limit_min
)paren
(brace
id|current-&gt;nice
op_assign
l_int|19
suffix:semicolon
r_if
c_cond
(paren
(paren
id|currspeed
OG
id|sysctl_speed_limit_max
)paren
op_logical_or
op_logical_neg
id|is_mddev_idle
c_func
(paren
id|mddev
)paren
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|md_schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|md_signal_pending
c_func
(paren
id|current
)paren
)paren
r_goto
id|repeat
suffix:semicolon
)brace
)brace
r_else
id|current-&gt;nice
op_assign
op_minus
l_int|20
suffix:semicolon
)brace
id|fsync_dev
c_func
(paren
id|read_disk
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: md%d: sync done.&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * this also signals &squot;finished resyncing&squot; to md_stop&n;&t; */
id|out
suffix:colon
id|wait_event
c_func
(paren
id|mddev-&gt;recovery_wait
comma
id|atomic_read
c_func
(paren
op_amp
id|mddev-&gt;recovery_active
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mddev-&gt;resync_sem
)paren
suffix:semicolon
id|out_nolock
suffix:colon
id|mddev-&gt;curr_resync
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|resync_wait
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a kernel thread which syncs a spare disk with the active array&n; *&n; * the amount of foolproofing might seem to be a tad excessive, but an&n; * early (not so error-safe) version of raid1syncd synced the first 0.5 gigs&n; * of my root partition with the first 0.5 gigs of my /home partition ... so&n; * i&squot;m a bit nervous ;)&n; */
DECL|function|md_do_recovery
r_void
id|md_do_recovery
(paren
r_void
op_star
id|data
)paren
(brace
r_int
id|err
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
id|mdp_super_t
op_star
id|sb
suffix:semicolon
id|mdp_disk_t
op_star
id|spare
suffix:semicolon
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: recovery thread got woken up ...&bslash;n&quot;
)paren
suffix:semicolon
id|restart
suffix:colon
id|ITERATE_MDDEV
c_func
(paren
id|mddev
comma
id|tmp
)paren
(brace
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;recovery_running
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;active_disks
op_eq
id|sb-&gt;raid_disks
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb-&gt;spare_disks
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md%d: no spare disk to reconstruct array! -- continuing in degraded mode&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * now here we get the spare and resync it.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|spare
op_assign
id|get_spare
c_func
(paren
id|mddev
)paren
)paren
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md%d: resyncing spare disk %s to replace failed disk&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|partition_name
c_func
(paren
id|MKDEV
c_func
(paren
id|spare-&gt;major
comma
id|spare-&gt;minor
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers-&gt;diskop
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers
op_member_access_from_pointer
id|diskop
c_func
(paren
id|mddev
comma
op_amp
id|spare
comma
id|DISKOP_SPARE_WRITE
)paren
)paren
r_continue
suffix:semicolon
id|down
c_func
(paren
op_amp
id|mddev-&gt;recovery_sem
)paren
suffix:semicolon
id|mddev-&gt;recovery_running
op_assign
l_int|1
suffix:semicolon
id|err
op_assign
id|md_do_sync
c_func
(paren
id|mddev
comma
id|spare
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EIO
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md%d: spare disk %s failed, skipping to next spare.&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|partition_name
c_func
(paren
id|MKDEV
c_func
(paren
id|spare-&gt;major
comma
id|spare-&gt;minor
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk_faulty
c_func
(paren
id|spare
)paren
)paren
(brace
id|mddev-&gt;pers
op_member_access_from_pointer
id|diskop
c_func
(paren
id|mddev
comma
op_amp
id|spare
comma
id|DISKOP_SPARE_INACTIVE
)paren
suffix:semicolon
id|mark_disk_faulty
c_func
(paren
id|spare
)paren
suffix:semicolon
id|mark_disk_nonsync
c_func
(paren
id|spare
)paren
suffix:semicolon
id|mark_disk_inactive
c_func
(paren
id|spare
)paren
suffix:semicolon
id|sb-&gt;spare_disks
op_decrement
suffix:semicolon
id|sb-&gt;working_disks
op_decrement
suffix:semicolon
id|sb-&gt;failed_disks
op_increment
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|disk_faulty
c_func
(paren
id|spare
)paren
)paren
id|mddev-&gt;pers
op_member_access_from_pointer
id|diskop
c_func
(paren
id|mddev
comma
op_amp
id|spare
comma
id|DISKOP_SPARE_INACTIVE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EINTR
op_logical_or
id|err
op_eq
op_minus
id|ENOMEM
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Recovery got interrupted, or ran out of mem ...&n;&t;&t;&t; * signal back that we have finished using the array.&n;&t;&t;&t; */
id|mddev-&gt;pers
op_member_access_from_pointer
id|diskop
c_func
(paren
id|mddev
comma
op_amp
id|spare
comma
id|DISKOP_SPARE_INACTIVE
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mddev-&gt;recovery_sem
)paren
suffix:semicolon
id|mddev-&gt;recovery_running
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
(brace
id|mddev-&gt;recovery_running
op_assign
l_int|0
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mddev-&gt;recovery_sem
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|disk_faulty
c_func
(paren
id|spare
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * the SPARE_ACTIVE diskop possibly changes the&n;&t;&t;&t; * pointer too&n;&t;&t;&t; */
id|mddev-&gt;pers
op_member_access_from_pointer
id|diskop
c_func
(paren
id|mddev
comma
op_amp
id|spare
comma
id|DISKOP_SPARE_ACTIVE
)paren
suffix:semicolon
id|mark_disk_sync
c_func
(paren
id|spare
)paren
suffix:semicolon
id|mark_disk_active
c_func
(paren
id|spare
)paren
suffix:semicolon
id|sb-&gt;active_disks
op_increment
suffix:semicolon
id|sb-&gt;spare_disks
op_decrement
suffix:semicolon
)brace
id|mddev-&gt;sb_dirty
op_assign
l_int|1
suffix:semicolon
id|md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: recovery thread finished ...&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|md_notify_reboot
r_int
id|md_notify_reboot
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|code
comma
r_void
op_star
id|x
)paren
(brace
r_struct
id|md_list_head
op_star
id|tmp
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
r_if
c_cond
(paren
(paren
id|code
op_eq
id|MD_SYS_DOWN
)paren
op_logical_or
(paren
id|code
op_eq
id|MD_SYS_HALT
)paren
op_logical_or
(paren
id|code
op_eq
id|MD_SYS_POWER_OFF
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;stopping all md devices.&bslash;n&quot;
)paren
suffix:semicolon
id|ITERATE_MDDEV
c_func
(paren
id|mddev
comma
id|tmp
)paren
id|do_md_stop
(paren
id|mddev
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * certain more exotic SCSI devices are known to be&n;&t;&t; * volatile wrt too early system reboots. While the&n;&t;&t; * right place to handle this issue is the given&n;&t;&t; * driver, we do want to have a safe RAID driver ...&n;&t;&t; */
id|md_mdelay
c_func
(paren
l_int|1000
op_star
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|variable|md_notifier
r_struct
id|notifier_block
id|md_notifier
op_assign
(brace
id|md_notify_reboot
comma
l_int|NULL
comma
l_int|0
)brace
suffix:semicolon
macro_line|#ifndef MODULE
DECL|function|raid_setup
r_static
r_int
id|md__init
id|raid_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|len
comma
id|pos
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|str
)paren
op_plus
l_int|1
suffix:semicolon
id|pos
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|len
)paren
(brace
r_char
op_star
id|comma
op_assign
id|strchr
c_func
(paren
id|str
op_plus
id|pos
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
r_int
id|wlen
suffix:semicolon
r_if
c_cond
(paren
id|comma
)paren
id|wlen
op_assign
(paren
id|comma
op_minus
id|str
)paren
op_minus
id|pos
suffix:semicolon
r_else
id|wlen
op_assign
(paren
id|len
op_minus
l_int|1
)paren
op_minus
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;noautodetect&quot;
comma
id|wlen
)paren
op_eq
l_int|0
)paren
id|raid_setup_args.noautodetect
op_assign
l_int|1
suffix:semicolon
id|pos
op_add_assign
id|wlen
op_plus
l_int|1
suffix:semicolon
)brace
id|raid_setup_args.set
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;raid=&quot;
comma
id|raid_setup
)paren
suffix:semicolon
macro_line|#endif
DECL|function|md_geninit
r_static
r_void
id|md_geninit
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_MD_DEVS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|md_blocksizes
(braket
id|i
)braket
op_assign
l_int|1024
suffix:semicolon
id|md_size
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|md_hardsect_sizes
(braket
id|i
)braket
op_assign
l_int|512
suffix:semicolon
id|md_maxreadahead
(braket
id|i
)braket
op_assign
id|MD_READAHEAD
suffix:semicolon
id|register_disk
c_func
(paren
op_amp
id|md_gendisk
comma
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|i
)paren
comma
l_int|1
comma
op_amp
id|md_fops
comma
l_int|0
)paren
suffix:semicolon
)brace
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|md_blocksizes
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
id|md_size
suffix:semicolon
id|max_readahead
(braket
id|MAJOR_NR
)braket
op_assign
id|md_maxreadahead
suffix:semicolon
id|hardsect_size
(braket
id|MAJOR_NR
)braket
op_assign
id|md_hardsect_sizes
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;md.c: sizeof(mdp_super_t) = %d&bslash;n&quot;
comma
(paren
r_int
)paren
r_sizeof
(paren
id|mdp_super_t
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|create_proc_read_entry
c_func
(paren
l_string|&quot;mdstat&quot;
comma
l_int|0
comma
l_int|NULL
comma
id|md_status_read_proc
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|md_init
r_int
id|md__init
id|md_init
(paren
r_void
)paren
(brace
r_static
r_char
op_star
id|name
op_assign
l_string|&quot;mdrecoveryd&quot;
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;md driver %d.%d.%d MAX_MD_DEVS=%d, MD_SB_DISKS=%d&bslash;n&quot;
comma
id|MD_MAJOR_VERSION
comma
id|MD_MINOR_VERSION
comma
id|MD_PATCHLEVEL_VERSION
comma
id|MAX_MD_DEVS
comma
id|MD_SB_DISKS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_register_blkdev
(paren
id|MAJOR_NR
comma
l_string|&quot;md&quot;
comma
op_amp
id|md_fops
)paren
)paren
(brace
id|printk
(paren
id|KERN_ALERT
l_string|&quot;Unable to get major %d for md&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|devfs_handle
op_assign
id|devfs_mk_dir
(paren
l_int|NULL
comma
l_string|&quot;md&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_register_series
(paren
id|devfs_handle
comma
l_string|&quot;%u&quot;
comma
id|MAX_MD_DEVS
comma
id|DEVFS_FL_DEFAULT
comma
id|MAJOR_NR
comma
l_int|0
comma
id|S_IFBLK
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
op_amp
id|md_fops
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* forward all md request to md_make_request */
id|blk_queue_make_request
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|md_make_request
)paren
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
id|INT_MAX
suffix:semicolon
id|md_gendisk.next
op_assign
id|gendisk_head
suffix:semicolon
id|gendisk_head
op_assign
op_amp
id|md_gendisk
suffix:semicolon
id|md_recovery_thread
op_assign
id|md_register_thread
c_func
(paren
id|md_do_recovery
comma
l_int|NULL
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|md_recovery_thread
)paren
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;bug: couldn&squot;t allocate md_recovery_thread&bslash;n&quot;
)paren
suffix:semicolon
id|md_register_reboot_notifier
c_func
(paren
op_amp
id|md_notifier
)paren
suffix:semicolon
id|raid_table_header
op_assign
id|register_sysctl_table
c_func
(paren
id|raid_root_table
comma
l_int|1
)paren
suffix:semicolon
id|md_geninit
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MD_BOOT
DECL|macro|MAX_MD_BOOT_DEVS
mdefine_line|#define MAX_MD_BOOT_DEVS&t;8
r_struct
(brace
DECL|member|set
r_int
r_int
id|set
suffix:semicolon
DECL|member|pers
r_int
id|pers
(braket
id|MAX_MD_BOOT_DEVS
)braket
suffix:semicolon
DECL|member|chunk
r_int
id|chunk
(braket
id|MAX_MD_BOOT_DEVS
)braket
suffix:semicolon
DECL|member|devices
id|kdev_t
id|devices
(braket
id|MAX_MD_BOOT_DEVS
)braket
(braket
id|MD_SB_DISKS
)braket
suffix:semicolon
DECL|variable|md__initdata
)brace
id|md_setup_args
id|md__initdata
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Parse the command-line parameters given our kernel, but do not&n; * actually try to invoke the MD device now; that is handled by&n; * md_setup_drive after the low-level disk drivers have initialised.&n; *&n; * 27/11/1999: Fixed to work correctly with the 2.3 kernel (which&n; *             assigns the task of parsing integer arguments to the&n; *             invoked program now).  Added ability to initialise all&n; *             the MD devices (by specifying multiple &quot;md=&quot; lines)&n; *             instead of just one.  -- KTK&n; * 18May2000: Added support for persistant-superblock arrays:&n; *             md=n,0,factor,fault,device-list   uses RAID0 for device n&n; *             md=n,-1,factor,fault,device-list  uses LINEAR for device n&n; *             md=n,device-list      reads a RAID superblock from the devices&n; *             elements in device-list are read by name_to_kdev_t so can be&n; *             a hex number or something like /dev/hda1 /dev/sdb&n; */
r_extern
id|kdev_t
id|name_to_kdev_t
c_func
(paren
r_char
op_star
id|line
)paren
id|md__init
suffix:semicolon
DECL|function|md_setup
r_static
r_int
id|md__init
id|md_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|minor
comma
id|level
comma
id|factor
comma
id|fault
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|kdev_t
id|device
suffix:semicolon
r_char
op_star
id|devnames
comma
op_star
id|pername
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|minor
)paren
op_ne
l_int|2
)paren
(brace
multiline_comment|/* MD Number */
id|printk
c_func
(paren
l_string|&quot;md: Too few arguments supplied to md=.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|minor
op_ge
id|MAX_MD_BOOT_DEVS
)paren
(brace
id|printk
(paren
l_string|&quot;md: Minor device number too high.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|md_setup_args.set
op_amp
(paren
l_int|1
op_lshift
id|minor
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;md: Warning - md=%d,... has been specified twice;&bslash;n&quot;
l_string|&quot;    will discard the first definition.&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|level
)paren
)paren
(brace
multiline_comment|/* RAID Personality */
r_case
l_int|2
suffix:colon
multiline_comment|/* could be 0 or -1.. */
r_if
c_cond
(paren
id|level
op_eq
l_int|0
op_logical_or
id|level
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|factor
)paren
op_ne
l_int|2
op_logical_or
multiline_comment|/* Chunk Size */
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|fault
)paren
op_ne
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: Too few arguments supplied to md=.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|md_setup_args.pers
(braket
id|minor
)braket
op_assign
id|level
suffix:semicolon
id|md_setup_args.chunk
(braket
id|minor
)braket
op_assign
l_int|1
op_lshift
(paren
id|factor
op_plus
l_int|12
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|level
)paren
(brace
r_case
op_minus
l_int|1
suffix:colon
id|level
op_assign
id|LINEAR
suffix:semicolon
id|pername
op_assign
l_string|&quot;linear&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
id|level
op_assign
id|RAID0
suffix:semicolon
id|pername
op_assign
l_string|&quot;raid0&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;md: The kernel has not been configured for raid%d&quot;
l_string|&quot; support!&bslash;n&quot;
comma
id|level
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|md_setup_args.pers
(braket
id|minor
)braket
op_assign
id|level
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* FALL THROUGH */
r_case
l_int|1
suffix:colon
multiline_comment|/* the first device is numeric */
id|md_setup_args.devices
(braket
id|minor
)braket
(braket
id|i
op_increment
)braket
op_assign
id|level
suffix:semicolon
multiline_comment|/* FALL THROUGH */
r_case
l_int|0
suffix:colon
id|md_setup_args.pers
(braket
id|minor
)braket
op_assign
l_int|0
suffix:semicolon
id|pername
op_assign
l_string|&quot;super-block&quot;
suffix:semicolon
)brace
id|devnames
op_assign
id|str
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
op_logical_and
id|str
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|device
op_assign
id|name_to_kdev_t
c_func
(paren
id|str
)paren
)paren
)paren
(brace
id|md_setup_args.devices
(braket
id|minor
)braket
(braket
id|i
)braket
op_assign
id|device
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;md: Unknown device name, %s.&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|str
op_assign
id|strchr
c_func
(paren
id|str
comma
l_char|&squot;,&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
id|str
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|printk
(paren
l_string|&quot;md: No devices specified for md%d?&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;md: Will configure md%d (%s) from %s, below.&bslash;n&quot;
comma
id|minor
comma
id|pername
comma
id|devnames
)paren
suffix:semicolon
id|md_setup_args.devices
(braket
id|minor
)braket
(braket
id|i
)braket
op_assign
(paren
id|kdev_t
)paren
l_int|0
suffix:semicolon
id|md_setup_args.set
op_or_assign
(paren
l_int|1
op_lshift
id|minor
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|md_setup_drive
r_void
id|md__init
id|md_setup_drive
c_func
(paren
r_void
)paren
(brace
r_int
id|minor
comma
id|i
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
r_for
c_loop
(paren
id|minor
op_assign
l_int|0
suffix:semicolon
id|minor
OL
id|MAX_MD_BOOT_DEVS
suffix:semicolon
id|minor
op_increment
)paren
(brace
id|mdu_disk_info_t
id|dinfo
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|md_setup_args.set
op_amp
(paren
l_int|1
op_lshift
id|minor
)paren
)paren
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;md: Loading md%d.&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev_map
(braket
id|minor
)braket
dot
id|mddev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;.. md%d already autodetected - use raid=noautodetect&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|mddev
op_assign
id|alloc_mddev
c_func
(paren
id|MKDEV
c_func
(paren
id|MD_MAJOR
comma
id|minor
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|md_setup_args.pers
(braket
id|minor
)braket
)paren
(brace
multiline_comment|/* non-persistent */
id|mdu_array_info_t
id|ainfo
suffix:semicolon
id|ainfo.level
op_assign
id|pers_to_level
c_func
(paren
id|md_setup_args.pers
(braket
id|minor
)braket
)paren
suffix:semicolon
id|ainfo.size
op_assign
l_int|0
suffix:semicolon
id|ainfo.nr_disks
op_assign
l_int|0
suffix:semicolon
id|ainfo.raid_disks
op_assign
l_int|0
suffix:semicolon
id|ainfo.md_minor
op_assign
id|minor
suffix:semicolon
id|ainfo.not_persistent
op_assign
l_int|1
suffix:semicolon
id|ainfo.state
op_assign
id|MD_SB_CLEAN
suffix:semicolon
id|ainfo.active_disks
op_assign
l_int|0
suffix:semicolon
id|ainfo.working_disks
op_assign
l_int|0
suffix:semicolon
id|ainfo.failed_disks
op_assign
l_int|0
suffix:semicolon
id|ainfo.spare_disks
op_assign
l_int|0
suffix:semicolon
id|ainfo.layout
op_assign
l_int|0
suffix:semicolon
id|ainfo.chunk_size
op_assign
id|md_setup_args.chunk
(braket
id|minor
)braket
suffix:semicolon
id|err
op_assign
id|set_array_info
c_func
(paren
id|mddev
comma
op_amp
id|ainfo
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|err
op_logical_and
(paren
id|dev
op_assign
id|md_setup_args.devices
(braket
id|minor
)braket
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dinfo.number
op_assign
id|i
suffix:semicolon
id|dinfo.raid_disk
op_assign
id|i
suffix:semicolon
id|dinfo.state
op_assign
(paren
l_int|1
op_lshift
id|MD_DISK_ACTIVE
)paren
op_or
(paren
l_int|1
op_lshift
id|MD_DISK_SYNC
)paren
suffix:semicolon
id|dinfo.major
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dinfo.minor
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mddev-&gt;sb-&gt;nr_disks
op_increment
suffix:semicolon
id|mddev-&gt;sb-&gt;raid_disks
op_increment
suffix:semicolon
id|mddev-&gt;sb-&gt;active_disks
op_increment
suffix:semicolon
id|mddev-&gt;sb-&gt;working_disks
op_increment
suffix:semicolon
id|err
op_assign
id|add_new_disk
(paren
id|mddev
comma
op_amp
id|dinfo
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* persistent */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|dev
op_assign
id|md_setup_args.devices
(braket
id|minor
)braket
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dinfo.major
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dinfo.minor
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|add_new_disk
(paren
id|mddev
comma
op_amp
id|dinfo
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|do_md_run
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|mddev-&gt;sb_dirty
op_assign
l_int|0
suffix:semicolon
id|do_md_stop
c_func
(paren
id|mddev
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;md: starting md%d failed&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
)brace
)brace
)brace
id|__setup
c_func
(paren
l_string|&quot;md=&quot;
comma
id|md_setup
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
(paren
r_void
)paren
(brace
r_return
id|md_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|free_device_names
r_static
r_void
id|free_device_names
c_func
(paren
r_void
)paren
(brace
r_while
c_loop
(paren
id|device_names.next
op_ne
op_amp
id|device_names
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
op_assign
id|device_names.next
suffix:semicolon
id|list_del
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
(paren
r_void
)paren
(brace
r_struct
id|gendisk
op_star
op_star
id|gendisk_ptr
suffix:semicolon
id|md_unregister_thread
c_func
(paren
id|md_recovery_thread
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|devfs_handle
)paren
suffix:semicolon
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;md&quot;
)paren
suffix:semicolon
id|unregister_reboot_notifier
c_func
(paren
op_amp
id|md_notifier
)paren
suffix:semicolon
id|unregister_sysctl_table
c_func
(paren
id|raid_table_header
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|remove_proc_entry
c_func
(paren
l_string|&quot;mdstat&quot;
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
id|gendisk_ptr
op_assign
op_amp
id|gendisk_head
suffix:semicolon
r_while
c_loop
(paren
op_star
id|gendisk_ptr
)paren
(brace
r_if
c_cond
(paren
op_star
id|gendisk_ptr
op_eq
op_amp
id|md_gendisk
)paren
(brace
op_star
id|gendisk_ptr
op_assign
id|md_gendisk.next
suffix:semicolon
r_break
suffix:semicolon
)brace
id|gendisk_ptr
op_assign
op_amp
(paren
op_star
id|gendisk_ptr
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|queue
op_assign
l_int|NULL
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
l_int|NULL
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
l_int|NULL
suffix:semicolon
id|max_readahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|NULL
suffix:semicolon
id|hardsect_size
(braket
id|MAJOR_NR
)braket
op_assign
l_int|NULL
suffix:semicolon
id|free_device_names
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|md_init
id|__initcall
c_func
(paren
id|md_init
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_AUTODETECT_RAID) || defined(CONFIG_MD_BOOT)
DECL|variable|md_run_setup
id|__initcall
c_func
(paren
id|md_run_setup
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|md_size
id|MD_EXPORT_SYMBOL
c_func
(paren
id|md_size
)paren
suffix:semicolon
DECL|variable|register_md_personality
id|MD_EXPORT_SYMBOL
c_func
(paren
id|register_md_personality
)paren
suffix:semicolon
DECL|variable|unregister_md_personality
id|MD_EXPORT_SYMBOL
c_func
(paren
id|unregister_md_personality
)paren
suffix:semicolon
DECL|variable|partition_name
id|MD_EXPORT_SYMBOL
c_func
(paren
id|partition_name
)paren
suffix:semicolon
DECL|variable|md_error
id|MD_EXPORT_SYMBOL
c_func
(paren
id|md_error
)paren
suffix:semicolon
DECL|variable|md_do_sync
id|MD_EXPORT_SYMBOL
c_func
(paren
id|md_do_sync
)paren
suffix:semicolon
DECL|variable|md_sync_acct
id|MD_EXPORT_SYMBOL
c_func
(paren
id|md_sync_acct
)paren
suffix:semicolon
DECL|variable|md_done_sync
id|MD_EXPORT_SYMBOL
c_func
(paren
id|md_done_sync
)paren
suffix:semicolon
DECL|variable|md_recover_arrays
id|MD_EXPORT_SYMBOL
c_func
(paren
id|md_recover_arrays
)paren
suffix:semicolon
DECL|variable|md_register_thread
id|MD_EXPORT_SYMBOL
c_func
(paren
id|md_register_thread
)paren
suffix:semicolon
DECL|variable|md_unregister_thread
id|MD_EXPORT_SYMBOL
c_func
(paren
id|md_unregister_thread
)paren
suffix:semicolon
DECL|variable|md_update_sb
id|MD_EXPORT_SYMBOL
c_func
(paren
id|md_update_sb
)paren
suffix:semicolon
DECL|variable|md_wakeup_thread
id|MD_EXPORT_SYMBOL
c_func
(paren
id|md_wakeup_thread
)paren
suffix:semicolon
DECL|variable|md_print_devices
id|MD_EXPORT_SYMBOL
c_func
(paren
id|md_print_devices
)paren
suffix:semicolon
DECL|variable|find_rdev_nr
id|MD_EXPORT_SYMBOL
c_func
(paren
id|find_rdev_nr
)paren
suffix:semicolon
DECL|variable|md_interrupt_thread
id|MD_EXPORT_SYMBOL
c_func
(paren
id|md_interrupt_thread
)paren
suffix:semicolon
DECL|variable|mddev_map
id|MD_EXPORT_SYMBOL
c_func
(paren
id|mddev_map
)paren
suffix:semicolon
DECL|variable|md_check_ordering
id|MD_EXPORT_SYMBOL
c_func
(paren
id|md_check_ordering
)paren
suffix:semicolon
eof
