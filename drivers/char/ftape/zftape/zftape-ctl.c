multiline_comment|/* &n; *      Copyright (C) 1996, 1997 Claus-Justus Heine&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; *&n; * $Source: /homes/cvs/ftape-stacked/ftape/zftape/zftape-ctl.c,v $&n; * $Revision: 1.2.6.2 $&n; * $Date: 1997/11/14 18:07:33 $&n; *&n; *      This file contains the non-read/write zftape functions&n; *      for the QIC-40/80/3010/3020 floppy-tape driver for Linux.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/zftape.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VER(2,1,6)
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#else
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#endif
macro_line|#include &quot;../zftape/zftape-init.h&quot;
macro_line|#include &quot;../zftape/zftape-eof.h&quot;
macro_line|#include &quot;../zftape/zftape-ctl.h&quot;
macro_line|#include &quot;../zftape/zftape-write.h&quot;
macro_line|#include &quot;../zftape/zftape-read.h&quot;
macro_line|#include &quot;../zftape/zftape-rw.h&quot;
macro_line|#include &quot;../zftape/zftape-vtbl.h&quot;
multiline_comment|/*      Global vars.&n; */
DECL|variable|zft_write_protected
r_int
id|zft_write_protected
suffix:semicolon
multiline_comment|/* this is when cartridge rdonly or O_RDONLY */
DECL|variable|zft_header_read
r_int
id|zft_header_read
suffix:semicolon
DECL|variable|zft_offline
r_int
id|zft_offline
suffix:semicolon
DECL|variable|zft_unit
r_int
r_int
id|zft_unit
suffix:semicolon
DECL|variable|zft_resid
r_int
id|zft_resid
suffix:semicolon
DECL|variable|zft_mt_compression
r_int
id|zft_mt_compression
suffix:semicolon
multiline_comment|/*      Local vars.&n; */
DECL|variable|going_offline
r_static
r_int
id|going_offline
suffix:semicolon
DECL|typedef|mt_fun
r_typedef
r_int
(paren
id|mt_fun
)paren
(paren
r_int
op_star
id|argptr
)paren
suffix:semicolon
DECL|typedef|mt_funp
r_typedef
r_int
(paren
op_star
id|mt_funp
)paren
(paren
r_int
op_star
id|argptr
)paren
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|function
id|mt_funp
id|function
suffix:semicolon
DECL|member|offline
r_int
id|offline
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* op permitted if offline or no_tape */
DECL|member|write_protected
r_int
id|write_protected
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* op permitted if write-protected    */
DECL|member|not_formatted
r_int
id|not_formatted
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* op permitted if tape not formatted */
DECL|member|raw_mode
r_int
id|raw_mode
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* op permitted if zft_mode == 0    */
DECL|member|need_idle_state
r_int
id|need_idle_state
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* need to call def_idle_state        */
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|typedef|fun_entry
)brace
id|fun_entry
suffix:semicolon
DECL|variable|mt_dummy
DECL|variable|mt_reset
DECL|variable|mt_fsr
DECL|variable|mt_bsr
DECL|variable|mt_rew
DECL|variable|mt_offl
DECL|variable|mt_nop
r_static
id|mt_fun
id|mt_dummy
comma
id|mt_reset
comma
id|mt_fsr
comma
id|mt_bsr
comma
id|mt_rew
comma
id|mt_offl
comma
id|mt_nop
comma
DECL|variable|mt_weof
DECL|variable|mt_erase
DECL|variable|mt_ras2
DECL|variable|mt_setblk
DECL|variable|mt_setdensity
id|mt_weof
comma
id|mt_erase
comma
id|mt_ras2
comma
id|mt_setblk
comma
id|mt_setdensity
comma
DECL|variable|mt_seek
DECL|variable|mt_tell
DECL|variable|mt_reten
DECL|variable|mt_eom
DECL|variable|mt_fsf
DECL|variable|mt_bsf
id|mt_seek
comma
id|mt_tell
comma
id|mt_reten
comma
id|mt_eom
comma
id|mt_fsf
comma
id|mt_bsf
comma
DECL|variable|mt_fsfm
DECL|variable|mt_bsfm
DECL|variable|mt_setdrvbuffer
DECL|variable|mt_compression
id|mt_fsfm
comma
id|mt_bsfm
comma
id|mt_setdrvbuffer
comma
id|mt_compression
suffix:semicolon
DECL|variable|mt_funs
r_static
id|fun_entry
id|mt_funs
(braket
)braket
op_assign
(brace
(brace
id|mt_reset
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_RESET&quot;
)brace
comma
multiline_comment|/*  0 */
(brace
id|mt_fsf
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_string|&quot;MT_FSF&quot;
)brace
comma
(brace
id|mt_bsf
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_string|&quot;MT_BSF&quot;
)brace
comma
(brace
id|mt_fsr
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_string|&quot;MT_FSR&quot;
)brace
comma
(brace
id|mt_bsr
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_string|&quot;MT_BSR&quot;
)brace
comma
(brace
id|mt_weof
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_string|&quot;MT_WEOF&quot;
)brace
comma
multiline_comment|/*  5 */
(brace
id|mt_rew
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_REW&quot;
)brace
comma
(brace
id|mt_offl
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_OFFL&quot;
)brace
comma
(brace
id|mt_nop
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_NOP&quot;
)brace
comma
(brace
id|mt_reten
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_RETEN&quot;
)brace
comma
(brace
id|mt_bsfm
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_string|&quot;MT_BSFM&quot;
)brace
comma
multiline_comment|/* 10 */
(brace
id|mt_fsfm
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_string|&quot;MT_FSFM&quot;
)brace
comma
(brace
id|mt_eom
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_string|&quot;MT_EOM&quot;
)brace
comma
(brace
id|mt_erase
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_ERASE&quot;
)brace
comma
(brace
id|mt_dummy
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_RAS1&quot;
)brace
comma
(brace
id|mt_ras2
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_RAS2&quot;
)brace
comma
(brace
id|mt_dummy
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_RAS3&quot;
)brace
comma
(brace
id|mt_dummy
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;UNKNOWN&quot;
)brace
comma
(brace
id|mt_dummy
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;UNKNOWN&quot;
)brace
comma
(brace
id|mt_dummy
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;UNKNOWN&quot;
)brace
comma
(brace
id|mt_setblk
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_string|&quot;MT_SETBLK&quot;
)brace
comma
multiline_comment|/* 20 */
(brace
id|mt_setdensity
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_SETDENSITY&quot;
)brace
comma
(brace
id|mt_seek
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_string|&quot;MT_SEEK&quot;
)brace
comma
(brace
id|mt_dummy
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_string|&quot;MT_TELL&quot;
)brace
comma
multiline_comment|/* wr-only ?! */
(brace
id|mt_setdrvbuffer
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_SETDRVBUFFER&quot;
)brace
comma
(brace
id|mt_dummy
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_FSS&quot;
)brace
comma
multiline_comment|/* 25 */
(brace
id|mt_dummy
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_BSS&quot;
)brace
comma
(brace
id|mt_dummy
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_WSM&quot;
)brace
comma
(brace
id|mt_dummy
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_LOCK&quot;
)brace
comma
(brace
id|mt_dummy
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_UNLOCK&quot;
)brace
comma
(brace
id|mt_dummy
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_LOAD&quot;
)brace
comma
multiline_comment|/* 30 */
(brace
id|mt_dummy
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_UNLOAD&quot;
)brace
comma
(brace
id|mt_compression
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_string|&quot;MT_COMPRESSION&quot;
)brace
comma
(brace
id|mt_dummy
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_SETPART&quot;
)brace
comma
(brace
id|mt_dummy
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;MT_MKPART&quot;
)brace
)brace
suffix:semicolon
DECL|macro|NR_MT_CMDS
mdefine_line|#define NR_MT_CMDS NR_ITEMS(mt_funs)
DECL|function|zft_reset_position
r_void
id|zft_reset_position
c_func
(paren
id|zft_position
op_star
id|pos
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|pos-&gt;seg_byte_pos
op_assign
id|pos-&gt;volume_pos
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|zft_header_read
)paren
(brace
multiline_comment|/* need to keep track of the volume table and&n;&t;&t; * compression map. We therefor simply&n;&t;&t; * position at the beginning of the first&n;&t;&t; * volume. This covers old ftape archives as&n;&t;&t; * well has various flavours of the&n;&t;&t; * compression map segments. The worst case is&n;&t;&t; * that the compression map shows up as a&n;&t;&t; * additional volume in front of all others.&n;&t;&t; */
id|pos-&gt;seg_pos
op_assign
id|zft_find_volume
c_func
(paren
l_int|0
)paren
op_member_access_from_pointer
id|start_seg
suffix:semicolon
id|pos-&gt;tape_pos
op_assign
id|zft_calc_tape_pos
c_func
(paren
id|pos-&gt;seg_pos
)paren
suffix:semicolon
)brace
r_else
(brace
id|pos-&gt;tape_pos
op_assign
l_int|0
suffix:semicolon
id|pos-&gt;seg_pos
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|zft_just_before_eof
op_assign
l_int|0
suffix:semicolon
id|zft_deblock_segment
op_assign
op_minus
l_int|1
suffix:semicolon
id|zft_io_state
op_assign
id|zft_idle
suffix:semicolon
id|zft_zap_read_buffers
c_func
(paren
)paren
suffix:semicolon
id|zft_prevent_flush
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*  unlock the compresison module if it is loaded.&n;&t; *  The zero arg means not to try to load the module.&n;&t; */
r_if
c_cond
(paren
id|zft_cmpr_lock
c_func
(paren
l_int|0
)paren
op_eq
l_int|0
)paren
(brace
(paren
op_star
id|zft_cmpr_ops-&gt;reset
)paren
(paren
)paren
suffix:semicolon
multiline_comment|/* unlock */
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|zft_init_driver
r_static
r_void
id|zft_init_driver
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|zft_resid
op_assign
id|zft_header_read
op_assign
id|zft_old_ftape
op_assign
id|zft_offline
op_assign
id|zft_write_protected
op_assign
id|going_offline
op_assign
id|zft_mt_compression
op_assign
id|zft_header_changed
op_assign
id|zft_volume_table_changed
op_assign
id|zft_written_segments
op_assign
l_int|0
suffix:semicolon
id|zft_blk_sz
op_assign
id|CONFIG_ZFT_DFLT_BLK_SZ
suffix:semicolon
id|zft_reset_position
c_func
(paren
op_amp
id|zft_pos
)paren
suffix:semicolon
multiline_comment|/* does most of the stuff */
id|ftape_zap_read_buffers
c_func
(paren
)paren
suffix:semicolon
id|ftape_set_state
c_func
(paren
id|idle
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|zft_def_idle_state
r_int
id|zft_def_idle_state
c_func
(paren
r_void
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zft_header_read
)paren
(brace
id|result
op_assign
id|zft_read_header_segments
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|result
op_assign
id|zft_flush_buffers
c_func
(paren
)paren
)paren
op_ge
l_int|0
op_logical_and
id|zft_qic_mode
)paren
(brace
multiline_comment|/*  don&squot;t move past eof&n;&t;&t; */
(paren
r_void
)paren
id|zft_close_volume
c_func
(paren
op_amp
id|zft_pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ftape_abort_operation
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;ftape_abort_operation() failed&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* clear remaining read buffers */
id|zft_zap_read_buffers
c_func
(paren
)paren
suffix:semicolon
id|zft_io_state
op_assign
id|zft_idle
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *                                                                           *&n; *  functions for the MTIOCTOP commands                                      *&n; *                                                                           *&n; *****************************************************************************/
DECL|function|mt_dummy
r_static
r_int
id|mt_dummy
c_func
(paren
r_int
op_star
id|dummy
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE_EXIT
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|mt_reset
r_static
r_int
id|mt_reset
c_func
(paren
r_int
op_star
id|dummy
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
(paren
r_void
)paren
id|ftape_seek_to_bot
c_func
(paren
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_reset_drive
c_func
(paren
)paren
comma
id|zft_init_driver
c_func
(paren
)paren
suffix:semicolon
id|zft_uninit_mem
c_func
(paren
)paren
suffix:semicolon
id|zft_offline
op_assign
l_int|1
)paren
suffix:semicolon
multiline_comment|/*  fake a re-open of the device. This will set all flage and &n;&t; *  allocate buffers as appropriate. The new tape condition will&n;&t; *  force the open routine to do anything we need.&n;&t; */
id|TRACE_CATCH
c_func
(paren
id|_zft_open
c_func
(paren
op_minus
l_int|1
multiline_comment|/* fake reopen */
comma
l_int|0
multiline_comment|/* dummy */
)paren
comma
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|mt_fsf
r_static
r_int
id|mt_fsf
c_func
(paren
r_int
op_star
id|arg
)paren
(brace
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|result
op_assign
id|zft_skip_volumes
c_func
(paren
op_star
id|arg
comma
op_amp
id|zft_pos
)paren
suffix:semicolon
id|zft_just_before_eof
op_assign
l_int|0
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|mt_bsf
r_static
r_int
id|mt_bsf
c_func
(paren
r_int
op_star
id|arg
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_ne
l_int|0
)paren
(brace
id|result
op_assign
id|zft_skip_volumes
c_func
(paren
op_minus
op_star
id|arg
op_plus
l_int|1
comma
op_amp
id|zft_pos
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|seek_block
r_static
r_int
id|seek_block
c_func
(paren
id|__s64
id|data_offset
comma
id|__s64
id|block_increment
comma
id|zft_position
op_star
id|pos
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|__s64
id|new_block_pos
suffix:semicolon
id|__s64
id|vol_block_count
suffix:semicolon
r_const
id|zft_volinfo
op_star
id|volume
suffix:semicolon
r_int
id|exceed
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|volume
op_assign
id|zft_find_volume
c_func
(paren
id|pos-&gt;seg_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|volume-&gt;start_seg
op_eq
l_int|0
op_logical_or
id|volume-&gt;end_seg
op_eq
l_int|0
)paren
(brace
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
)brace
id|new_block_pos
op_assign
(paren
id|zft_div_blksz
c_func
(paren
id|data_offset
comma
id|volume-&gt;blk_sz
)paren
op_plus
id|block_increment
)paren
suffix:semicolon
id|vol_block_count
op_assign
id|zft_div_blksz
c_func
(paren
id|volume-&gt;size
comma
id|volume-&gt;blk_sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_block_pos
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;new_block_pos &quot;
id|LL_X
l_string|&quot; &lt; 0&quot;
comma
id|LL
c_func
(paren
id|new_block_pos
)paren
)paren
suffix:semicolon
id|zft_resid
op_assign
(paren
r_int
)paren
id|new_block_pos
suffix:semicolon
id|new_block_pos
op_assign
l_int|0
suffix:semicolon
id|exceed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|new_block_pos
OG
id|vol_block_count
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;new_block_pos &quot;
id|LL_X
l_string|&quot; exceeds size of volume &quot;
id|LL_X
comma
id|LL
c_func
(paren
id|new_block_pos
)paren
comma
id|LL
c_func
(paren
id|vol_block_count
)paren
)paren
suffix:semicolon
id|zft_resid
op_assign
(paren
r_int
)paren
(paren
id|vol_block_count
op_minus
id|new_block_pos
)paren
suffix:semicolon
id|new_block_pos
op_assign
id|vol_block_count
suffix:semicolon
id|exceed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|exceed
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_use_compression
op_logical_and
id|volume-&gt;use_compression
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|zft_cmpr_lock
c_func
(paren
l_int|1
multiline_comment|/* try to load */
)paren
comma
)paren
suffix:semicolon
id|result
op_assign
(paren
op_star
id|zft_cmpr_ops-&gt;seek
)paren
(paren
id|new_block_pos
comma
id|pos
comma
id|volume
comma
id|zft_deblock_buf
)paren
suffix:semicolon
id|pos-&gt;tape_pos
op_assign
id|zft_calc_tape_pos
c_func
(paren
id|pos-&gt;seg_pos
)paren
suffix:semicolon
id|pos-&gt;tape_pos
op_add_assign
id|pos-&gt;seg_byte_pos
suffix:semicolon
)brace
r_else
(brace
id|pos-&gt;volume_pos
op_assign
id|zft_mul_blksz
c_func
(paren
id|new_block_pos
comma
id|volume-&gt;blk_sz
)paren
suffix:semicolon
id|pos-&gt;tape_pos
op_assign
id|zft_calc_tape_pos
c_func
(paren
id|volume-&gt;start_seg
)paren
suffix:semicolon
id|pos-&gt;tape_pos
op_add_assign
id|pos-&gt;volume_pos
suffix:semicolon
id|pos-&gt;seg_pos
op_assign
id|zft_calc_seg_byte_coord
c_func
(paren
op_amp
id|pos-&gt;seg_byte_pos
comma
id|pos-&gt;tape_pos
)paren
suffix:semicolon
)brace
id|zft_just_before_eof
op_assign
id|volume-&gt;size
op_eq
id|pos-&gt;volume_pos
suffix:semicolon
r_if
c_cond
(paren
id|zft_just_before_eof
)paren
(brace
multiline_comment|/* why this? because zft_file_no checks agains start&n;&t;&t; * and end segment of a volume. We do not want to&n;&t;&t; * advance to the next volume with this function.&n;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;set zft_just_before_eof&quot;
)paren
suffix:semicolon
id|zft_position_before_eof
c_func
(paren
id|pos
comma
id|volume
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;new_seg_pos : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;new_tape_pos: &quot;
id|LL_X
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;vol_size    : &quot;
id|LL_X
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;seg_byte_pos: %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;blk_sz  : %d&quot;
comma
id|pos-&gt;seg_pos
comma
id|LL
c_func
(paren
id|pos-&gt;tape_pos
)paren
comma
id|LL
c_func
(paren
id|volume-&gt;size
)paren
comma
id|pos-&gt;seg_byte_pos
comma
id|volume-&gt;blk_sz
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|exceed
)paren
(brace
id|zft_resid
op_assign
id|new_block_pos
op_minus
id|zft_div_blksz
c_func
(paren
id|pos-&gt;volume_pos
comma
id|volume-&gt;blk_sz
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_resid
OL
l_int|0
)paren
(brace
id|zft_resid
op_assign
op_minus
id|zft_resid
suffix:semicolon
)brace
id|TRACE_EXIT
(paren
(paren
id|exceed
op_logical_or
id|zft_resid
op_ne
l_int|0
)paren
op_logical_and
id|result
op_ge
l_int|0
)paren
ques
c_cond
op_minus
id|EINVAL
suffix:colon
id|result
suffix:semicolon
)brace
DECL|function|mt_fsr
r_static
r_int
id|mt_fsr
c_func
(paren
r_int
op_star
id|arg
)paren
(brace
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|result
op_assign
id|seek_block
c_func
(paren
id|zft_pos.volume_pos
comma
op_star
id|arg
comma
op_amp
id|zft_pos
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|mt_bsr
r_static
r_int
id|mt_bsr
c_func
(paren
r_int
op_star
id|arg
)paren
(brace
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|result
op_assign
id|seek_block
c_func
(paren
id|zft_pos.volume_pos
comma
op_minus
op_star
id|arg
comma
op_amp
id|zft_pos
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|mt_weof
r_static
r_int
id|mt_weof
c_func
(paren
r_int
op_star
id|arg
)paren
(brace
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|zft_flush_buffers
c_func
(paren
)paren
comma
)paren
suffix:semicolon
id|result
op_assign
id|zft_weof
c_func
(paren
op_star
id|arg
comma
op_amp
id|zft_pos
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|mt_rew
r_static
r_int
id|mt_rew
c_func
(paren
r_int
op_star
id|dummy
)paren
(brace
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_header_read
)paren
(brace
(paren
r_void
)paren
id|zft_def_idle_state
c_func
(paren
)paren
suffix:semicolon
)brace
id|result
op_assign
id|ftape_seek_to_bot
c_func
(paren
)paren
suffix:semicolon
id|zft_reset_position
c_func
(paren
op_amp
id|zft_pos
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|mt_offl
r_static
r_int
id|mt_offl
c_func
(paren
r_int
op_star
id|dummy
)paren
(brace
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|going_offline
op_assign
l_int|1
suffix:semicolon
id|result
op_assign
id|mt_rew
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|mt_nop
r_static
r_int
id|mt_nop
c_func
(paren
r_int
op_star
id|dummy
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
multiline_comment|/*  should we set tape status?&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|zft_offline
)paren
(brace
multiline_comment|/* offline includes no_tape */
(paren
r_void
)paren
id|zft_def_idle_state
c_func
(paren
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|mt_reten
r_static
r_int
id|mt_reten
c_func
(paren
r_int
op_star
id|dummy
)paren
(brace
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_header_read
)paren
(brace
(paren
r_void
)paren
id|zft_def_idle_state
c_func
(paren
)paren
suffix:semicolon
)brace
id|result
op_assign
id|ftape_seek_to_eot
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|result
op_assign
id|ftape_seek_to_bot
c_func
(paren
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
c_func
(paren
id|result
)paren
suffix:semicolon
)brace
DECL|function|fsfbsfm
r_static
r_int
id|fsfbsfm
c_func
(paren
r_int
id|arg
comma
id|zft_position
op_star
id|pos
)paren
(brace
r_const
id|zft_volinfo
op_star
id|vtbl
suffix:semicolon
id|__s64
id|block_pos
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
multiline_comment|/* What to do? This should seek to the next file-mark and&n;&t; * position BEFORE. That is, a next write would just extend&n;&t; * the current file.  Well. Let&squot;s just seek to the end of the&n;&t; * current file, if count == 1.  If count &gt; 1, then do a&n;&t; * &quot;mt_fsf(count - 1)&quot;, and then seek to the end of that file.&n;&t; * If count == 0, do nothing&n;&t; */
r_if
c_cond
(paren
id|arg
op_eq
l_int|0
)paren
(brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
id|zft_just_before_eof
op_assign
l_int|0
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|zft_skip_volumes
c_func
(paren
id|arg
OL
l_int|0
ques
c_cond
id|arg
suffix:colon
id|arg
op_minus
l_int|1
comma
id|pos
)paren
comma
r_if
(paren
id|arg
OG
l_int|0
)paren
(brace
id|zft_resid
op_increment
suffix:semicolon
)brace
)paren
suffix:semicolon
id|vtbl
op_assign
id|zft_find_volume
c_func
(paren
id|pos-&gt;seg_pos
)paren
suffix:semicolon
id|block_pos
op_assign
id|zft_div_blksz
c_func
(paren
id|vtbl-&gt;size
comma
id|vtbl-&gt;blk_sz
)paren
suffix:semicolon
(paren
r_void
)paren
id|seek_block
c_func
(paren
l_int|0
comma
id|block_pos
comma
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos-&gt;volume_pos
op_ne
id|vtbl-&gt;size
)paren
(brace
id|zft_just_before_eof
op_assign
l_int|0
suffix:semicolon
id|zft_resid
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* we didn&squot;t managed to go there */
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;wanted file position &quot;
id|LL_X
l_string|&quot;, arrived at &quot;
id|LL_X
comma
id|LL
c_func
(paren
id|vtbl-&gt;size
)paren
comma
id|LL
c_func
(paren
id|pos-&gt;volume_pos
)paren
)paren
suffix:semicolon
)brace
id|zft_just_before_eof
op_assign
l_int|1
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|mt_bsfm
r_static
r_int
id|mt_bsfm
c_func
(paren
r_int
op_star
id|arg
)paren
(brace
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|result
op_assign
id|fsfbsfm
c_func
(paren
op_minus
op_star
id|arg
comma
op_amp
id|zft_pos
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|mt_fsfm
r_static
r_int
id|mt_fsfm
c_func
(paren
r_int
op_star
id|arg
)paren
(brace
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|result
op_assign
id|fsfbsfm
c_func
(paren
op_star
id|arg
comma
op_amp
id|zft_pos
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|mt_eom
r_static
r_int
id|mt_eom
c_func
(paren
r_int
op_star
id|dummy
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|zft_skip_to_eom
c_func
(paren
op_amp
id|zft_pos
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|mt_erase
r_static
r_int
id|mt_erase
c_func
(paren
r_int
op_star
id|dummy
)paren
(brace
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|result
op_assign
id|zft_erase
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|mt_ras2
r_static
r_int
id|mt_ras2
c_func
(paren
r_int
op_star
id|dummy
)paren
(brace
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|ENOSYS
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/*  Sets the new blocksize in BYTES&n; *&n; */
DECL|function|mt_setblk
r_static
r_int
id|mt_setblk
c_func
(paren
r_int
op_star
id|new_size
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
(paren
op_star
id|new_size
)paren
OG
id|ZFT_MAX_BLK_SZ
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;desired blk_sz (%d) should be &lt;= %d bytes&quot;
comma
op_star
id|new_size
comma
id|ZFT_MAX_BLK_SZ
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_star
id|new_size
op_amp
(paren
id|FT_SECTOR_SIZE
op_minus
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;desired blk_sz (%d) must be a multiple of %d bytes&quot;
comma
op_star
id|new_size
comma
id|FT_SECTOR_SIZE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|new_size
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|zft_use_compression
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;Variable block size not yet &quot;
l_string|&quot;supported with compression&quot;
)paren
suffix:semicolon
)brace
op_star
id|new_size
op_assign
l_int|1
suffix:semicolon
)brace
id|zft_blk_sz
op_assign
op_star
id|new_size
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|mt_setdensity
r_static
r_int
id|mt_setdensity
c_func
(paren
r_int
op_star
id|arg
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|SET_TRACE_LEVEL
c_func
(paren
op_star
id|arg
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|TRACE_LEVEL
comma
l_string|&quot;tracing set to %d&quot;
comma
id|TRACE_LEVEL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|TRACE_LEVEL
op_ne
op_star
id|arg
)paren
(brace
id|TRACE_EXIT
op_minus
id|EINVAL
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|mt_seek
r_static
r_int
id|mt_seek
c_func
(paren
r_int
op_star
id|new_block_pos
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|result
op_assign
id|seek_block
c_func
(paren
l_int|0
comma
(paren
id|__s64
)paren
op_star
id|new_block_pos
comma
op_amp
id|zft_pos
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/*  OK, this is totally different from SCSI, but the worst thing that can &n; *  happen is that there is not enough defragmentated memory that can be &n; *  allocated. Also, there is a hardwired limit of 16 dma buffers in the &n; *  stock ftape module. This shouldn&squot;t bring the system down.&n; *&n; * NOTE: the argument specifies the total number of dma buffers to use.&n; *       The driver needs at least 3 buffers to function at all.&n; * &n; */
DECL|function|mt_setdrvbuffer
r_static
r_int
id|mt_setdrvbuffer
c_func
(paren
r_int
op_star
id|cnt
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|cnt
OL
l_int|3
)paren
(brace
id|TRACE_EXIT
op_minus
id|EINVAL
suffix:semicolon
)brace
id|TRACE_CATCH
c_func
(paren
id|ftape_set_nr_buffers
c_func
(paren
op_star
id|cnt
)paren
comma
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/* return the block position from start of volume &n; */
DECL|function|mt_tell
r_static
r_int
id|mt_tell
c_func
(paren
r_int
op_star
id|arg
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
op_star
id|arg
op_assign
id|zft_div_blksz
c_func
(paren
id|zft_pos.volume_pos
comma
id|zft_find_volume
c_func
(paren
id|zft_pos.seg_pos
)paren
op_member_access_from_pointer
id|blk_sz
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|mt_compression
r_static
r_int
id|mt_compression
c_func
(paren
r_int
op_star
id|arg
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
multiline_comment|/*  Ok. We could also check whether compression is available at&n;&t; *  all by trying to load the compression module.  We could&n;&t; *  also check for a block size of 1 byte which is illegal&n;&t; *  with compression.  Instead of doing it here we rely on&n;&t; *  zftape_write() to do the proper checks.&n;&t; */
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
op_star
id|arg
OG
l_int|1
)paren
(brace
id|TRACE_EXIT
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|arg
op_ne
l_int|0
op_logical_and
id|zft_blk_sz
op_eq
l_int|1
)paren
(brace
multiline_comment|/* variable block size */
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;Compression not yet supported &quot;
l_string|&quot;with variable block size&quot;
)paren
suffix:semicolon
)brace
id|zft_mt_compression
op_assign
op_star
id|arg
suffix:semicolon
r_if
c_cond
(paren
(paren
id|zft_unit
op_amp
id|ZFT_ZIP_MODE
)paren
op_eq
l_int|0
)paren
(brace
id|zft_use_compression
op_assign
id|zft_mt_compression
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  check whether write access is allowed. Write access is denied when&n; *  + zft_write_protected == 1 -- this accounts for either hard write &n; *                                protection of the cartridge or for &n; *                                O_RDONLY access mode of the tape device&n; *  + zft_offline == 1         -- this meany that there is either no tape &n; *                                or that the MTOFFLINE ioctl has been &n; *                                previously issued (`soft eject&squot;)&n; *  + ft_formatted == 0        -- this means that the cartridge is not&n; *                                formatted&n; *  Then we distinuguish two cases. When zft_qic_mode is TRUE, then we try&n; *  to emulate a `traditional&squot; (aka SCSI like) UN*X tape device. Therefore we&n; *  deny writes when&n; *  + zft_qic_mode ==1 &amp;&amp; &n; *       (!zft_tape_at_lbot() &amp;&amp;   -- tape no at logical BOT&n; *        !(zft_tape_at_eom() ||   -- tape not at logical EOM (or EOD)&n; *          (zft_tape_at_eom() &amp;&amp;&n; *           zft_old_ftape())))    -- we can&squot;t add new volume to tapes &n; *                                    written by old ftape because ftape&n; *                                    don&squot;t use the volume table&n; *&n; *  when the drive is in true raw mode (aka /dev/rawft0) then we don&squot;t &n; *  care about LBOT and EOM conditions. This device is intended for a &n; *  user level program that wants to truly implement the QIC-80 compliance&n; *  at the logical data layout level of the cartridge, i.e. implement all&n; *  that volume table and volume directory stuff etc.&lt;&n; */
DECL|function|zft_check_write_access
r_int
id|zft_check_write_access
c_func
(paren
id|zft_position
op_star
id|pos
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_offline
)paren
(brace
multiline_comment|/* offline includes no_tape */
id|TRACE_ABORT
c_func
(paren
op_minus
id|ENXIO
comma
id|ft_t_info
comma
l_string|&quot;tape is offline or no cartridge&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ft_formatted
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EACCES
comma
id|ft_t_info
comma
l_string|&quot;tape is not formatted&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_write_protected
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EACCES
comma
id|ft_t_info
comma
l_string|&quot;cartridge write protected&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_qic_mode
)paren
(brace
multiline_comment|/*  check BOT condition */
r_if
c_cond
(paren
op_logical_neg
id|zft_tape_at_lbot
c_func
(paren
id|pos
)paren
)paren
(brace
multiline_comment|/*  protect cartridges written by old ftape if&n;&t;&t;&t; *  not at BOT because they use the vtbl&n;&t;&t;&t; *  segment for storing data&n;&t;&t;&t; */
r_if
c_cond
(paren
id|zft_old_ftape
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EACCES
comma
id|ft_t_warn
comma
l_string|&quot;Cannot write to cartridges written by old ftape when not at BOT&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*  not at BOT, but allow writes at EOD, of course&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|zft_tape_at_eod
c_func
(paren
id|pos
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EACCES
comma
id|ft_t_info
comma
l_string|&quot;tape not at BOT and not at EOD&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*  fine. Now the tape is either at BOT or at EOD. */
)brace
multiline_comment|/* or in raw mode in which case we don&squot;t care about BOT and EOD */
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  decide when we should lock the module in memory, even when calling&n; *  the release routine. This really is necessary for use with&n; *  kerneld.&n; *&n; *  NOTE: we MUST NOT use zft_write_protected, because this includes&n; *  the file access mode as well which has no meaning with our &n; *  asynchronous update scheme.&n; *&n; *  Ugly, ugly. We need to look the module if we changed the block size.&n; *  How sad! Need persistent modules storage!&n; *&n; *  NOTE: I don&squot;t want to lock the module if the number of dma buffers &n; *  has been changed. It&squot;s enough! Stop the story! Give me persisitent&n; *  module storage! Do it!&n; */
DECL|function|zft_dirty
r_int
id|zft_dirty
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ft_formatted
op_logical_or
id|zft_offline
)paren
(brace
multiline_comment|/* cannot be dirty if not formatted or offline */
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_blk_sz
op_ne
id|CONFIG_ZFT_DFLT_BLK_SZ
)paren
(brace
multiline_comment|/* blocksize changed, must lock */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_mt_compression
op_ne
l_int|0
)paren
(brace
multiline_comment|/* compression mode with /dev/qft, must lock */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|zft_header_read
)paren
(brace
multiline_comment|/* tape is logical at BOT, no lock */
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|zft_tape_at_lbot
c_func
(paren
op_amp
id|zft_pos
)paren
)paren
(brace
multiline_comment|/* somewhere inside a volume, lock tape */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_volume_table_changed
op_logical_or
id|zft_header_changed
)paren
(brace
multiline_comment|/* header segments dirty if tape not write protected */
r_return
op_logical_neg
(paren
id|ft_write_protected
op_logical_or
id|zft_old_ftape
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*      OPEN routine called by kernel-interface code&n; *&n; *      NOTE: this is also called by mt_reset() with dev_minor == -1&n; *            to fake a reopen after a reset.&n; */
DECL|function|_zft_open
r_int
id|_zft_open
c_func
(paren
r_int
r_int
id|dev_minor
comma
r_int
r_int
id|access_mode
)paren
(brace
r_static
r_int
r_int
id|tape_unit
suffix:semicolon
r_static
r_int
r_int
id|file_access_mode
suffix:semicolon
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|dev_minor
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* fake reopen */
id|zft_unit
op_assign
id|tape_unit
suffix:semicolon
id|access_mode
op_assign
id|file_access_mode
suffix:semicolon
id|zft_init_driver
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* reset all static data to defaults */
)brace
r_else
(brace
id|tape_unit
op_assign
id|dev_minor
suffix:semicolon
id|file_access_mode
op_assign
id|access_mode
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|ftape_enable
c_func
(paren
id|FTAPE_SEL
c_func
(paren
id|dev_minor
)paren
)paren
)paren
OL
l_int|0
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|ENXIO
comma
id|ft_t_err
comma
l_string|&quot;ftape_enable failed: %d&quot;
comma
id|result
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_new_tape
op_logical_or
id|ft_no_tape
op_logical_or
op_logical_neg
id|ft_formatted
op_logical_or
(paren
id|FTAPE_SEL
c_func
(paren
id|zft_unit
)paren
op_ne
id|FTAPE_SEL
c_func
(paren
id|dev_minor
)paren
)paren
op_logical_or
(paren
id|zft_unit
op_amp
id|ZFT_RAW_MODE
)paren
op_ne
(paren
id|dev_minor
op_amp
id|ZFT_RAW_MODE
)paren
)paren
(brace
multiline_comment|/* reset all static data to defaults,&n;&t;&t;&t; */
id|zft_init_driver
c_func
(paren
)paren
suffix:semicolon
)brace
id|zft_unit
op_assign
id|dev_minor
suffix:semicolon
)brace
id|zft_set_flags
c_func
(paren
id|zft_unit
)paren
suffix:semicolon
multiline_comment|/* decode the minor bits */
r_if
c_cond
(paren
id|zft_blk_sz
op_eq
l_int|1
op_logical_and
id|zft_use_compression
)paren
(brace
id|ftape_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* resets ft_no_tape */
id|TRACE_ABORT
c_func
(paren
op_minus
id|ENODEV
comma
id|ft_t_warn
comma
l_string|&quot;Variable block size not yet &quot;
l_string|&quot;supported with compression&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*  no need for most of the buffers when no tape or not&n;&t; *  formatted.  for the read/write operations, it is the&n;&t; *  regardless whether there is no tape, a not-formatted tape&n;&t; *  or the whether the driver is soft offline.  &n;&t; *  Nevertheless we allow some ioctls with non-formatted tapes, &n;&t; *  like rewind and reset.&n;&t; */
r_if
c_cond
(paren
id|ft_no_tape
op_logical_or
op_logical_neg
id|ft_formatted
)paren
(brace
id|zft_uninit_mem
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_no_tape
)paren
(brace
id|zft_offline
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* so we need not test two variables */
)brace
r_if
c_cond
(paren
(paren
id|access_mode
op_eq
id|O_WRONLY
op_logical_or
id|access_mode
op_eq
id|O_RDWR
)paren
op_logical_and
(paren
id|ft_write_protected
op_logical_or
id|ft_no_tape
)paren
)paren
(brace
id|ftape_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* resets ft_no_tape */
id|TRACE_ABORT
c_func
(paren
id|ft_no_tape
ques
c_cond
op_minus
id|ENXIO
suffix:colon
op_minus
id|EROFS
comma
id|ft_t_warn
comma
l_string|&quot;wrong access mode %s cartridge&quot;
comma
id|ft_no_tape
ques
c_cond
l_string|&quot;without a&quot;
suffix:colon
l_string|&quot;with write protected&quot;
)paren
suffix:semicolon
)brace
id|zft_write_protected
op_assign
(paren
id|access_mode
op_eq
id|O_RDONLY
op_logical_or
id|ft_write_protected
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_write_protected
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;read only access mode: %d, &quot;
l_string|&quot;drive write protected: %d&quot;
comma
id|access_mode
op_eq
id|O_RDONLY
comma
id|ft_write_protected
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|zft_offline
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|zft_vmalloc_once
c_func
(paren
op_amp
id|zft_deblock_buf
comma
id|FT_SEGMENT_SIZE
)paren
comma
id|ftape_disable
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* zft_seg_pos should be greater than the vtbl segpos but not&n;&t; * if in compatability mode and only after we read in the&n;&t; * header segments&n;&t; *&n;&t; * might also be a problem if the user makes a backup with a&n;&t; * *qft* device and rewinds it with a raw device.&n;&t; */
r_if
c_cond
(paren
id|zft_qic_mode
op_logical_and
op_logical_neg
id|zft_old_ftape
op_logical_and
id|zft_pos.seg_pos
op_ge
l_int|0
op_logical_and
id|zft_header_read
op_logical_and
id|zft_pos.seg_pos
op_le
id|ft_first_data_segment
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;you probably mixed up the zftape devices!&quot;
)paren
suffix:semicolon
id|zft_reset_position
c_func
(paren
op_amp
id|zft_pos
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*      RELEASE routine called by kernel-interface code&n; */
DECL|function|_zft_close
r_int
id|_zft_close
c_func
(paren
r_void
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_offline
)paren
(brace
multiline_comment|/* call the hardware release routine. Puts the drive offline */
id|ftape_disable
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ft_write_protected
op_logical_or
id|zft_old_ftape
)paren
)paren
(brace
id|result
op_assign
id|zft_flush_buffers
c_func
(paren
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;writing file mark at current position&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_qic_mode
op_logical_and
id|zft_close_volume
c_func
(paren
op_amp
id|zft_pos
)paren
op_eq
l_int|0
)paren
(brace
id|zft_move_past_eof
c_func
(paren
op_amp
id|zft_pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|zft_tape_at_lbot
c_func
(paren
op_amp
id|zft_pos
)paren
op_logical_or
op_logical_neg
(paren
id|zft_unit
op_amp
id|FTAPE_NO_REWIND
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|result
op_assign
id|zft_update_header_segments
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;Error: unable to update header segments&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
id|ftape_abort_operation
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|zft_unit
op_amp
id|FTAPE_NO_REWIND
)paren
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;rewinding tape&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftape_seek_to_bot
c_func
(paren
)paren
OL
l_int|0
op_logical_and
id|result
op_ge
l_int|0
)paren
(brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* keep old value */
)brace
id|zft_reset_position
c_func
(paren
op_amp
id|zft_pos
)paren
suffix:semicolon
)brace
id|zft_zap_read_buffers
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*  now free up memory as much as possible. We don&squot;t destroy&n;&t; *  the deblock buffer if it containes a valid segment.&n;&t; */
r_if
c_cond
(paren
id|zft_deblock_segment
op_eq
op_minus
l_int|1
)paren
(brace
id|zft_vfree
c_func
(paren
op_amp
id|zft_deblock_buf
comma
id|FT_SEGMENT_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/* high level driver status, forces creation of a new volume&n;&t; * when calling ftape_write again and not zft_just_before_eof&n;&t; */
id|zft_io_state
op_assign
id|zft_idle
suffix:semicolon
r_if
c_cond
(paren
id|going_offline
)paren
(brace
id|zft_init_driver
c_func
(paren
)paren
suffix:semicolon
id|zft_uninit_mem
c_func
(paren
)paren
suffix:semicolon
id|going_offline
op_assign
l_int|0
suffix:semicolon
id|zft_offline
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|zft_dirty
c_func
(paren
)paren
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Keeping module locked in memory because:&bslash;n&quot;
id|KERN_INFO
l_string|&quot;header segments need updating: %s&bslash;n&quot;
id|KERN_INFO
l_string|&quot;tape not at BOT              : %s&quot;
comma
(paren
id|zft_volume_table_changed
op_logical_or
id|zft_header_changed
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
id|zft_tape_at_lbot
c_func
(paren
op_amp
id|zft_pos
)paren
ques
c_cond
l_string|&quot;no&quot;
suffix:colon
l_string|&quot;yes&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|zft_cmpr_lock
c_func
(paren
l_int|0
multiline_comment|/* don&squot;t load */
)paren
op_eq
l_int|0
)paren
(brace
(paren
op_star
id|zft_cmpr_ops-&gt;reset
)paren
(paren
)paren
suffix:semicolon
multiline_comment|/* unlock it again */
)brace
id|zft_memory_stats
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* call the hardware release routine. Puts the drive offline */
id|ftape_disable
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; *  the wrapper function around the wrapper MTIOCTOP ioctl&n; */
DECL|function|mtioctop
r_static
r_int
id|mtioctop
c_func
(paren
r_struct
id|mtop
op_star
id|mtop
comma
r_int
id|arg_size
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|fun_entry
op_star
id|mt_fun_entry
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg_size
op_ne
r_sizeof
(paren
r_struct
id|mtop
)paren
op_logical_or
id|mtop-&gt;mt_op
op_ge
id|NR_MT_CMDS
)paren
(brace
id|TRACE_EXIT
op_minus
id|EINVAL
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;calling MTIOCTOP command: %s&quot;
comma
id|mt_funs
(braket
id|mtop-&gt;mt_op
)braket
dot
id|name
)paren
suffix:semicolon
id|mt_fun_entry
op_assign
op_amp
id|mt_funs
(braket
id|mtop-&gt;mt_op
)braket
suffix:semicolon
id|zft_resid
op_assign
id|mtop-&gt;mt_count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mt_fun_entry-&gt;offline
op_logical_and
id|zft_offline
)paren
(brace
r_if
c_cond
(paren
id|ft_no_tape
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|ENXIO
comma
id|ft_t_info
comma
l_string|&quot;no tape present&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|ENXIO
comma
id|ft_t_info
comma
l_string|&quot;drive is offline&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|mt_fun_entry-&gt;not_formatted
op_logical_and
op_logical_neg
id|ft_formatted
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EACCES
comma
id|ft_t_info
comma
l_string|&quot;tape is not formatted&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mt_fun_entry-&gt;write_protected
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|zft_check_write_access
c_func
(paren
op_amp
id|zft_pos
)paren
comma
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mt_fun_entry-&gt;need_idle_state
op_logical_and
op_logical_neg
(paren
id|zft_offline
op_logical_or
op_logical_neg
id|ft_formatted
)paren
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|zft_def_idle_state
c_func
(paren
)paren
comma
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|zft_qic_mode
op_logical_and
op_logical_neg
id|mt_fun_entry-&gt;raw_mode
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EACCES
comma
id|ft_t_info
comma
l_string|&quot;Drive needs to be in QIC-80 compatibility mode for this command&quot;
)paren
suffix:semicolon
)brace
id|result
op_assign
(paren
id|mt_fun_entry-&gt;function
)paren
(paren
op_amp
id|mtop-&gt;mt_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_tape_at_lbot
c_func
(paren
op_amp
id|zft_pos
)paren
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|zft_update_header_segments
c_func
(paren
)paren
comma
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|zft_resid
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; *  standard MTIOCGET ioctl&n; */
DECL|function|mtiocget
r_static
r_int
id|mtiocget
c_func
(paren
r_struct
id|mtget
op_star
id|mtget
comma
r_int
id|arg_size
)paren
(brace
r_const
id|zft_volinfo
op_star
id|volume
suffix:semicolon
id|__s64
id|max_tape_pos
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg_size
op_ne
r_sizeof
(paren
r_struct
id|mtget
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;bad argument size: %d&quot;
comma
id|arg_size
)paren
suffix:semicolon
)brace
id|mtget-&gt;mt_type
op_assign
id|ft_drive_type.vendor_id
op_plus
l_int|0x800000
suffix:semicolon
id|mtget-&gt;mt_dsreg
op_assign
id|ft_last_status.space
suffix:semicolon
id|mtget-&gt;mt_erreg
op_assign
id|ft_last_error.space
suffix:semicolon
multiline_comment|/* error register */
id|mtget-&gt;mt_resid
op_assign
id|zft_resid
suffix:semicolon
multiline_comment|/* residuum of writes, reads and&n;&t;&t;&t;&t;      * MTIOCTOP commands &n;&t;&t;&t;&t;      */
r_if
c_cond
(paren
op_logical_neg
id|zft_offline
)paren
(brace
multiline_comment|/* neither no_tape nor soft offline */
id|mtget-&gt;mt_gstat
op_assign
id|GMT_ONLINE
c_func
(paren
op_complement
l_int|0UL
)paren
suffix:semicolon
multiline_comment|/* should rather return the status of the cartridge&n;&t;&t; * than the access mode of the file, therefor use&n;&t;&t; * ft_write_protected, not zft_write_protected &n;&t;&t; */
r_if
c_cond
(paren
id|ft_write_protected
)paren
(brace
id|mtget-&gt;mt_gstat
op_or_assign
id|GMT_WR_PROT
c_func
(paren
op_complement
l_int|0UL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_header_read
)paren
(brace
multiline_comment|/* this catches non-formatted */
id|volume
op_assign
id|zft_find_volume
c_func
(paren
id|zft_pos.seg_pos
)paren
suffix:semicolon
id|mtget-&gt;mt_fileno
op_assign
id|volume-&gt;count
suffix:semicolon
id|max_tape_pos
op_assign
id|zft_capacity
op_minus
id|zft_blk_sz
suffix:semicolon
r_if
c_cond
(paren
id|zft_use_compression
)paren
(brace
id|max_tape_pos
op_sub_assign
id|ZFT_CMPR_OVERHEAD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_tape_at_eod
c_func
(paren
op_amp
id|zft_pos
)paren
)paren
(brace
id|mtget-&gt;mt_gstat
op_or_assign
id|GMT_EOD
c_func
(paren
op_complement
l_int|0UL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_pos.tape_pos
OG
id|max_tape_pos
)paren
(brace
id|mtget-&gt;mt_gstat
op_or_assign
id|GMT_EOT
c_func
(paren
op_complement
l_int|0UL
)paren
suffix:semicolon
)brace
id|mtget-&gt;mt_blkno
op_assign
id|zft_div_blksz
c_func
(paren
id|zft_pos.volume_pos
comma
id|volume-&gt;blk_sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_just_before_eof
)paren
(brace
id|mtget-&gt;mt_gstat
op_or_assign
id|GMT_EOF
c_func
(paren
op_complement
l_int|0UL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_tape_at_lbot
c_func
(paren
op_amp
id|zft_pos
)paren
)paren
(brace
id|mtget-&gt;mt_gstat
op_or_assign
id|GMT_BOT
c_func
(paren
op_complement
l_int|0UL
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|mtget-&gt;mt_fileno
op_assign
id|mtget-&gt;mt_blkno
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mtget-&gt;mt_dsreg
op_amp
id|QIC_STATUS_AT_BOT
)paren
(brace
id|mtget-&gt;mt_gstat
op_or_assign
id|GMT_BOT
c_func
(paren
op_complement
l_int|0UL
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|ft_no_tape
)paren
(brace
id|mtget-&gt;mt_gstat
op_assign
id|GMT_DR_OPEN
c_func
(paren
op_complement
l_int|0UL
)paren
suffix:semicolon
)brace
r_else
(brace
id|mtget-&gt;mt_gstat
op_assign
l_int|0UL
suffix:semicolon
)brace
id|mtget-&gt;mt_fileno
op_assign
id|mtget-&gt;mt_blkno
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MTIOCRDFTSEG
multiline_comment|/*&n; *  Read a floppy tape segment. This is useful for manipulating the&n; *  volume table, and read the old header segment before re-formatting&n; *  the cartridge.&n; */
DECL|function|mtiocrdftseg
r_static
r_int
id|mtiocrdftseg
c_func
(paren
r_struct
id|mtftseg
op_star
id|mtftseg
comma
r_int
id|arg_size
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Mag tape ioctl command: MTIOCRDFTSEG&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_qic_mode
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EACCES
comma
id|ft_t_info
comma
l_string|&quot;driver needs to be in raw mode for this ioctl&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg_size
op_ne
r_sizeof
(paren
r_struct
id|mtftseg
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;bad argument size: %d&quot;
comma
id|arg_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_offline
)paren
(brace
id|TRACE_EXIT
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mtftseg-&gt;mt_mode
op_ne
id|FT_RD_SINGLE
op_logical_and
id|mtftseg-&gt;mt_mode
op_ne
id|FT_RD_AHEAD
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;invalid read mode&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ft_formatted
)paren
(brace
id|TRACE_EXIT
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* -ENXIO ? */
)brace
r_if
c_cond
(paren
op_logical_neg
id|zft_header_read
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|zft_def_idle_state
c_func
(paren
)paren
comma
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mtftseg-&gt;mt_segno
OG
id|ft_last_data_segment
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;segment number is too large&quot;
)paren
suffix:semicolon
)brace
id|mtftseg-&gt;mt_result
op_assign
id|ftape_read_segment
c_func
(paren
id|mtftseg-&gt;mt_segno
comma
id|zft_deblock_buf
comma
id|mtftseg-&gt;mt_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mtftseg-&gt;mt_result
OL
l_int|0
)paren
(brace
multiline_comment|/*  a negativ result is not an ioctl error. if&n;&t;&t; *  the user wants to read damaged tapes,&n;&t;&t; *  it&squot;s up to her/him&n;&t;&t; */
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &gt; KERNEL_VER(2,1,3)
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|mtftseg-&gt;mt_data
comma
id|zft_deblock_buf
comma
id|mtftseg-&gt;mt_result
)paren
op_ne
l_int|0
)paren
(brace
id|TRACE_EXIT
op_minus
id|EFAULT
suffix:semicolon
)brace
macro_line|#else
id|TRACE_CATCH
c_func
(paren
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|mtftseg-&gt;mt_data
comma
id|mtftseg-&gt;mt_result
)paren
comma
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|mtftseg-&gt;mt_data
comma
id|zft_deblock_buf
comma
id|mtftseg-&gt;mt_result
)paren
suffix:semicolon
macro_line|#endif
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef MTIOCWRFTSEG
multiline_comment|/*&n; *  write a floppy tape segment. This version features writing of&n; *  deleted address marks, and gracefully ignores the (software)&n; *  ft_formatted flag to support writing of header segments after&n; *  formatting.&n; */
DECL|function|mtiocwrftseg
r_static
r_int
id|mtiocwrftseg
c_func
(paren
r_struct
id|mtftseg
op_star
id|mtftseg
comma
r_int
id|arg_size
)paren
(brace
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Mag tape ioctl command: MTIOCWRFTSEG&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_write_protected
op_logical_or
id|zft_qic_mode
)paren
(brace
id|TRACE_EXIT
op_minus
id|EACCES
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg_size
op_ne
r_sizeof
(paren
r_struct
id|mtftseg
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;bad argument size: %d&quot;
comma
id|arg_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_offline
)paren
(brace
id|TRACE_EXIT
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mtftseg-&gt;mt_mode
op_ne
id|FT_WR_ASYNC
op_logical_and
id|mtftseg-&gt;mt_mode
op_ne
id|FT_WR_MULTI
op_logical_and
id|mtftseg-&gt;mt_mode
op_ne
id|FT_WR_SINGLE
op_logical_and
id|mtftseg-&gt;mt_mode
op_ne
id|FT_WR_DELETE
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;invalid write mode&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  We don&squot;t check for ft_formatted, because this gives&n;&t; *  only the software status of the driver.&n;&t; *&n;&t; *  We assume that the user knows what it is&n;&t; *  doing. And rely on the low level stuff to fail&n;&t; *  when the tape isn&squot;t formatted. We only make sure&n;&t; *  that The header segment buffer is allocated,&n;&t; *  because it holds the bad sector map.&n;&t; */
r_if
c_cond
(paren
id|zft_hseg_buf
op_eq
l_int|NULL
)paren
(brace
id|TRACE_EXIT
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mtftseg-&gt;mt_mode
op_ne
id|FT_WR_DELETE
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &gt; KERNEL_VER(2,1,3)
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|zft_deblock_buf
comma
id|mtftseg-&gt;mt_data
comma
id|FT_SEGMENT_SIZE
)paren
op_ne
l_int|0
)paren
(brace
id|TRACE_EXIT
op_minus
id|EFAULT
suffix:semicolon
)brace
macro_line|#else
id|TRACE_CATCH
c_func
(paren
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|mtftseg-&gt;mt_data
comma
id|FT_SEGMENT_SIZE
)paren
comma
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
id|zft_deblock_buf
comma
id|mtftseg-&gt;mt_data
comma
id|FT_SEGMENT_SIZE
)paren
suffix:semicolon
macro_line|#endif
)brace
id|mtftseg-&gt;mt_result
op_assign
id|ftape_write_segment
c_func
(paren
id|mtftseg-&gt;mt_segno
comma
id|zft_deblock_buf
comma
id|mtftseg-&gt;mt_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mtftseg-&gt;mt_result
op_ge
l_int|0
op_logical_and
id|mtftseg-&gt;mt_mode
op_eq
id|FT_WR_SINGLE
)paren
(brace
multiline_comment|/*  &n;&t;&t; *  a negativ result is not an ioctl error. if&n;&t;&t; *  the user wants to write damaged tapes,&n;&t;&t; *  it&squot;s up to her/him&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|result
op_assign
id|ftape_loop_until_writes_done
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
(brace
id|mtftseg-&gt;mt_result
op_assign
id|result
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef MTIOCVOLINFO
multiline_comment|/*&n; *  get information about volume positioned at.&n; */
DECL|function|mtiocvolinfo
r_static
r_int
id|mtiocvolinfo
c_func
(paren
r_struct
id|mtvolinfo
op_star
id|volinfo
comma
r_int
id|arg_size
)paren
(brace
r_const
id|zft_volinfo
op_star
id|volume
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Mag tape ioctl command: MTIOCVOLINFO&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg_size
op_ne
r_sizeof
(paren
r_struct
id|mtvolinfo
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;bad argument size: %d&quot;
comma
id|arg_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_offline
)paren
(brace
id|TRACE_EXIT
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ft_formatted
)paren
(brace
id|TRACE_EXIT
op_minus
id|EACCES
suffix:semicolon
)brace
id|TRACE_CATCH
c_func
(paren
id|zft_def_idle_state
c_func
(paren
)paren
comma
)paren
suffix:semicolon
id|volume
op_assign
id|zft_find_volume
c_func
(paren
id|zft_pos.seg_pos
)paren
suffix:semicolon
id|volinfo-&gt;mt_volno
op_assign
id|volume-&gt;count
suffix:semicolon
id|volinfo-&gt;mt_blksz
op_assign
id|volume-&gt;blk_sz
op_eq
l_int|1
ques
c_cond
l_int|0
suffix:colon
id|volume-&gt;blk_sz
suffix:semicolon
id|volinfo-&gt;mt_size
op_assign
id|volume-&gt;size
op_rshift
l_int|10
suffix:semicolon
id|volinfo-&gt;mt_rawsize
op_assign
(paren
(paren
id|zft_calc_tape_pos
c_func
(paren
id|volume-&gt;end_seg
op_plus
l_int|1
)paren
op_rshift
l_int|10
)paren
op_minus
(paren
id|zft_calc_tape_pos
c_func
(paren
id|volume-&gt;start_seg
)paren
op_rshift
l_int|10
)paren
)paren
suffix:semicolon
id|volinfo-&gt;mt_cmpr
op_assign
id|volume-&gt;use_compression
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef ZFT_OBSOLETE  
DECL|function|mtioc_zftape_getblksz
r_static
r_int
id|mtioc_zftape_getblksz
c_func
(paren
r_struct
id|mtblksz
op_star
id|blksz
comma
r_int
id|arg_size
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;Mag tape ioctl command: MTIOC_ZTAPE_GETBLKSZ&bslash;n&quot;
id|KERN_INFO
l_string|&quot;This ioctl is here merely for compatibility.&bslash;n&quot;
id|KERN_INFO
l_string|&quot;Please use MTIOCVOLINFO instead&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg_size
op_ne
r_sizeof
(paren
r_struct
id|mtblksz
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;bad argument size: %d&quot;
comma
id|arg_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_offline
)paren
(brace
id|TRACE_EXIT
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ft_formatted
)paren
(brace
id|TRACE_EXIT
op_minus
id|EACCES
suffix:semicolon
)brace
id|TRACE_CATCH
c_func
(paren
id|zft_def_idle_state
c_func
(paren
)paren
comma
)paren
suffix:semicolon
id|blksz-&gt;mt_blksz
op_assign
id|zft_find_volume
c_func
(paren
id|zft_pos.seg_pos
)paren
op_member_access_from_pointer
id|blk_sz
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef MTIOCGETSIZE
multiline_comment|/*&n; *  get the capacity of the tape cartridge.&n; */
DECL|function|mtiocgetsize
r_static
r_int
id|mtiocgetsize
c_func
(paren
r_struct
id|mttapesize
op_star
id|size
comma
r_int
id|arg_size
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Mag tape ioctl command: MTIOC_ZFTAPE_GETSIZE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg_size
op_ne
r_sizeof
(paren
r_struct
id|mttapesize
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;bad argument size: %d&quot;
comma
id|arg_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_offline
)paren
(brace
id|TRACE_EXIT
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ft_formatted
)paren
(brace
id|TRACE_EXIT
op_minus
id|EACCES
suffix:semicolon
)brace
id|TRACE_CATCH
c_func
(paren
id|zft_def_idle_state
c_func
(paren
)paren
comma
)paren
suffix:semicolon
id|size-&gt;mt_capacity
op_assign
(paren
r_int
r_int
)paren
(paren
id|zft_capacity
op_rshift
l_int|10
)paren
suffix:semicolon
id|size-&gt;mt_used
op_assign
(paren
r_int
r_int
)paren
(paren
id|zft_get_eom_pos
c_func
(paren
)paren
op_rshift
l_int|10
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|mtiocpos
r_static
r_int
id|mtiocpos
c_func
(paren
r_struct
id|mtpos
op_star
id|mtpos
comma
r_int
id|arg_size
)paren
(brace
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Mag tape ioctl command: MTIOCPOS&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg_size
op_ne
r_sizeof
(paren
r_struct
id|mtpos
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;bad argument size: %d&quot;
comma
id|arg_size
)paren
suffix:semicolon
)brace
id|result
op_assign
id|mt_tell
c_func
(paren
(paren
r_int
op_star
)paren
op_amp
id|mtpos-&gt;mt_blkno
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
macro_line|#ifdef MTIOCFTFORMAT
multiline_comment|/*&n; * formatting of floppy tape cartridges. This is intended to be used&n; * together with the MTIOCFTCMD ioctl and the new mmap feature &n; */
multiline_comment|/* &n; *  This function uses ftape_decode_header_segment() to inform the low&n; *  level ftape module about the new parameters.&n; *&n; *  It erases the hseg_buf. The calling process must specify all&n; *  parameters to assure proper operation.&n; *&n; *  return values: -EINVAL - wrong argument size&n; *                 -EINVAL - if ftape_decode_header_segment() failed.&n; */
DECL|function|set_format_parms
r_static
r_int
id|set_format_parms
c_func
(paren
r_struct
id|ftfmtparms
op_star
id|p
comma
id|__u8
op_star
id|hseg_buf
)paren
(brace
id|ft_trace_t
id|old_level
op_assign
id|TRACE_LEVEL
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;MTIOCFTFORMAT operation FTFMT_SETPARMS&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|hseg_buf
comma
l_int|0
comma
id|FT_SEGMENT_SIZE
)paren
suffix:semicolon
id|PUT4
c_func
(paren
id|hseg_buf
comma
id|FT_SIGNATURE
comma
id|FT_HSEG_MAGIC
)paren
suffix:semicolon
multiline_comment|/*  fill in user specified parameters&n;&t; */
id|hseg_buf
(braket
id|FT_FMT_CODE
)braket
op_assign
(paren
id|__u8
)paren
id|p-&gt;ft_fmtcode
suffix:semicolon
id|PUT2
c_func
(paren
id|hseg_buf
comma
id|FT_SPT
comma
id|p-&gt;ft_spt
)paren
suffix:semicolon
id|hseg_buf
(braket
id|FT_TPC
)braket
op_assign
(paren
id|__u8
)paren
id|p-&gt;ft_tpc
suffix:semicolon
id|hseg_buf
(braket
id|FT_FHM
)braket
op_assign
(paren
id|__u8
)paren
id|p-&gt;ft_fhm
suffix:semicolon
id|hseg_buf
(braket
id|FT_FTM
)braket
op_assign
(paren
id|__u8
)paren
id|p-&gt;ft_ftm
suffix:semicolon
multiline_comment|/*  fill in sane defaults to make ftape happy.&n;&t; */
id|hseg_buf
(braket
id|FT_FSM
)braket
op_assign
(paren
id|__u8
)paren
l_int|128
suffix:semicolon
multiline_comment|/* 128 is hard wired all over ftape */
r_if
c_cond
(paren
id|p-&gt;ft_fmtcode
op_eq
id|fmt_big
)paren
(brace
id|PUT4
c_func
(paren
id|hseg_buf
comma
id|FT_6_HSEG_1
comma
l_int|0
)paren
suffix:semicolon
id|PUT4
c_func
(paren
id|hseg_buf
comma
id|FT_6_HSEG_2
comma
l_int|1
)paren
suffix:semicolon
id|PUT4
c_func
(paren
id|hseg_buf
comma
id|FT_6_FRST_SEG
comma
l_int|2
)paren
suffix:semicolon
id|PUT4
c_func
(paren
id|hseg_buf
comma
id|FT_6_LAST_SEG
comma
id|p-&gt;ft_spt
op_star
id|p-&gt;ft_tpc
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|PUT2
c_func
(paren
id|hseg_buf
comma
id|FT_HSEG_1
comma
l_int|0
)paren
suffix:semicolon
id|PUT2
c_func
(paren
id|hseg_buf
comma
id|FT_HSEG_2
comma
l_int|1
)paren
suffix:semicolon
id|PUT2
c_func
(paren
id|hseg_buf
comma
id|FT_FRST_SEG
comma
l_int|2
)paren
suffix:semicolon
id|PUT2
c_func
(paren
id|hseg_buf
comma
id|FT_LAST_SEG
comma
id|p-&gt;ft_spt
op_star
id|p-&gt;ft_tpc
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*  Synchronize with the low level module. This is particularly&n;&t; *  needed for unformatted cartridges as the QIC std was previously &n;&t; *  unknown BUT is needed to set data rate and to calculate timeouts.&n;&t; */
id|TRACE_CATCH
c_func
(paren
id|ftape_calibrate_data_rate
c_func
(paren
id|p-&gt;ft_qicstd
op_amp
id|QIC_TAPE_STD_MASK
)paren
comma
id|_res
op_assign
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/*  The following will also recalcualte the timeouts for the tape&n;&t; *  length and QIC std we want to format to.&n;&t; *  abort with -EINVAL rather than -EIO&n;&t; */
id|SET_TRACE_LEVEL
c_func
(paren
id|ft_t_warn
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_decode_header_segment
c_func
(paren
id|hseg_buf
)paren
comma
id|SET_TRACE_LEVEL
c_func
(paren
id|old_level
)paren
suffix:semicolon
id|_res
op_assign
op_minus
id|EINVAL
)paren
suffix:semicolon
id|SET_TRACE_LEVEL
c_func
(paren
id|old_level
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Return the internal SOFTWARE status of the kernel driver. This does&n; *  NOT query the tape drive about its status.&n; */
DECL|function|get_format_parms
r_static
r_int
id|get_format_parms
c_func
(paren
r_struct
id|ftfmtparms
op_star
id|p
comma
id|__u8
op_star
id|hseg_buffer
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;MTIOCFTFORMAT operation FTFMT_GETPARMS&quot;
)paren
suffix:semicolon
id|p-&gt;ft_qicstd
op_assign
id|ft_qic_std
suffix:semicolon
id|p-&gt;ft_fmtcode
op_assign
id|ft_format_code
suffix:semicolon
id|p-&gt;ft_fhm
op_assign
id|hseg_buffer
(braket
id|FT_FHM
)braket
suffix:semicolon
id|p-&gt;ft_ftm
op_assign
id|hseg_buffer
(braket
id|FT_FTM
)braket
suffix:semicolon
id|p-&gt;ft_spt
op_assign
id|ft_segments_per_track
suffix:semicolon
id|p-&gt;ft_tpc
op_assign
id|ft_tracks_per_tape
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|mtiocftformat
r_static
r_int
id|mtiocftformat
c_func
(paren
r_struct
id|mtftformat
op_star
id|mtftformat
comma
r_int
id|arg_size
)paren
(brace
r_int
id|result
suffix:semicolon
r_union
id|fmt_arg
op_star
id|arg
op_assign
op_amp
id|mtftformat-&gt;fmt_arg
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Mag tape ioctl command: MTIOCFTFORMAT&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_offline
)paren
(brace
r_if
c_cond
(paren
id|ft_no_tape
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|ENXIO
comma
id|ft_t_info
comma
l_string|&quot;no tape present&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|ENXIO
comma
id|ft_t_info
comma
l_string|&quot;drive is offline&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|zft_qic_mode
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EACCES
comma
id|ft_t_info
comma
l_string|&quot;driver needs to be in raw mode for this ioctl&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_hseg_buf
op_eq
l_int|NULL
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|zft_vcalloc_once
c_func
(paren
op_amp
id|zft_hseg_buf
comma
id|FT_SEGMENT_SIZE
)paren
comma
)paren
suffix:semicolon
)brace
id|zft_header_read
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|mtftformat-&gt;fmt_op
)paren
(brace
r_case
id|FTFMT_SET_PARMS
suffix:colon
id|TRACE_CATCH
c_func
(paren
id|set_format_parms
c_func
(paren
op_amp
id|arg-&gt;fmt_parms
comma
id|zft_hseg_buf
)paren
comma
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
r_case
id|FTFMT_GET_PARMS
suffix:colon
id|TRACE_CATCH
c_func
(paren
id|get_format_parms
c_func
(paren
op_amp
id|arg-&gt;fmt_parms
comma
id|zft_hseg_buf
)paren
comma
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
r_case
id|FTFMT_FORMAT_TRACK
suffix:colon
r_if
c_cond
(paren
(paren
id|ft_formatted
op_logical_and
id|zft_check_write_access
c_func
(paren
op_amp
id|zft_pos
)paren
OL
l_int|0
)paren
op_logical_or
(paren
op_logical_neg
id|ft_formatted
op_logical_and
id|zft_write_protected
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EACCES
comma
id|ft_t_info
comma
l_string|&quot;Write access denied&quot;
)paren
suffix:semicolon
)brace
id|TRACE_CATCH
c_func
(paren
id|ftape_format_track
c_func
(paren
id|arg-&gt;fmt_track.ft_track
comma
id|arg-&gt;fmt_track.ft_gap3
)paren
comma
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
r_case
id|FTFMT_STATUS
suffix:colon
id|TRACE_CATCH
c_func
(paren
id|ftape_format_status
c_func
(paren
op_amp
id|arg-&gt;fmt_status.ft_segment
)paren
comma
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
r_case
id|FTFMT_VERIFY
suffix:colon
id|TRACE_CATCH
c_func
(paren
id|ftape_verify_segment
c_func
(paren
id|arg-&gt;fmt_verify.ft_segment
comma
(paren
id|SectorMap
op_star
)paren
op_amp
id|arg-&gt;fmt_verify.ft_bsm
)paren
comma
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
r_default
suffix:colon
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_err
comma
l_string|&quot;Invalid format operation&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef MTIOCFTCMD
multiline_comment|/*&n; *  send a QIC-117 command to the drive, with optional timeouts,&n; *  parameter and result bits. This is intended to be used together&n; *  with the formatting ioctl.&n; */
DECL|function|mtiocftcmd
r_static
r_int
id|mtiocftcmd
c_func
(paren
r_struct
id|mtftcmd
op_star
id|ftcmd
comma
r_int
id|arg_size
)paren
(brace
r_int
id|i
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Mag tape ioctl command: MTIOCFTCMD&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EPERM
comma
id|ft_t_info
comma
l_string|&quot;need CAP_SYS_ADMIN capability to send raw qic-117 commands&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_qic_mode
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EACCES
comma
id|ft_t_info
comma
l_string|&quot;driver needs to be in raw mode for this ioctl&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg_size
op_ne
r_sizeof
(paren
r_struct
id|mtftcmd
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;bad argument size: %d&quot;
comma
id|arg_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ftcmd-&gt;ft_wait_before
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|ftape_ready_wait
c_func
(paren
id|ftcmd-&gt;ft_wait_before
comma
op_amp
id|ftcmd-&gt;ft_status
)paren
comma
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ftcmd-&gt;ft_status
op_amp
id|QIC_STATUS_ERROR
)paren
r_goto
id|ftmtcmd_error
suffix:semicolon
r_if
c_cond
(paren
id|ftcmd-&gt;ft_result_bits
op_ne
l_int|0
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|ftape_report_operation
c_func
(paren
op_amp
id|ftcmd-&gt;ft_result
comma
id|ftcmd-&gt;ft_cmd
comma
id|ftcmd-&gt;ft_result_bits
)paren
comma
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE_CATCH
c_func
(paren
id|ftape_command
c_func
(paren
id|ftcmd-&gt;ft_cmd
)paren
comma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftcmd-&gt;ft_status
op_amp
id|QIC_STATUS_ERROR
)paren
r_goto
id|ftmtcmd_error
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ftcmd-&gt;ft_parm_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|ftape_parameter
c_func
(paren
id|ftcmd-&gt;ft_parms
(braket
id|i
)braket
op_amp
l_int|0x0f
)paren
comma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftcmd-&gt;ft_status
op_amp
id|QIC_STATUS_ERROR
)paren
r_goto
id|ftmtcmd_error
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ftcmd-&gt;ft_wait_after
op_ne
l_int|0
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|ftape_ready_wait
c_func
(paren
id|ftcmd-&gt;ft_wait_after
comma
op_amp
id|ftcmd-&gt;ft_status
)paren
comma
)paren
suffix:semicolon
)brace
id|ftmtcmd_error
suffix:colon
r_if
c_cond
(paren
id|ftcmd-&gt;ft_status
op_amp
id|QIC_STATUS_ERROR
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;error status set&quot;
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_report_error
c_func
(paren
op_amp
id|ftcmd-&gt;ft_error
comma
op_amp
id|ftcmd-&gt;ft_cmd
comma
l_int|1
)paren
comma
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
multiline_comment|/* this is not an i/o error */
)brace
macro_line|#endif
multiline_comment|/*  IOCTL routine called by kernel-interface code&n; */
DECL|function|_zft_ioctl
r_int
id|_zft_ioctl
c_func
(paren
r_int
r_int
id|command
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|result
suffix:semicolon
r_union
(brace
r_struct
id|mtop
id|mtop
suffix:semicolon
r_struct
id|mtget
id|mtget
suffix:semicolon
r_struct
id|mtpos
id|mtpos
suffix:semicolon
macro_line|#ifdef MTIOCRDFTSEG
r_struct
id|mtftseg
id|mtftseg
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MTIOCVOLINFO
r_struct
id|mtvolinfo
id|mtvolinfo
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MTIOCGETSIZE
r_struct
id|mttapesize
id|mttapesize
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MTIOCFTFORMAT
r_struct
id|mtftformat
id|mtftformat
suffix:semicolon
macro_line|#endif
macro_line|#ifdef ZFT_OBSOLETE
r_struct
id|mtblksz
id|mtblksz
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MTIOCFTCMD
r_struct
id|mtftcmd
id|mtftcmd
suffix:semicolon
macro_line|#endif
)brace
id|krnl_arg
suffix:semicolon
r_int
id|arg_size
op_assign
id|_IOC_SIZE
c_func
(paren
id|command
)paren
suffix:semicolon
r_int
id|dir
op_assign
id|_IOC_DIR
c_func
(paren
id|command
)paren
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
multiline_comment|/* This check will only catch arguments that are too large !&n;&t; */
r_if
c_cond
(paren
id|dir
op_amp
(paren
id|_IOC_READ
op_or
id|_IOC_WRITE
)paren
op_logical_and
id|arg_size
OG
r_sizeof
(paren
id|krnl_arg
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;bad argument size: %d&quot;
comma
id|arg_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dir
op_amp
id|_IOC_WRITE
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &gt; KERNEL_VER(2,1,3)
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|krnl_arg
comma
id|arg
comma
id|arg_size
)paren
op_ne
l_int|0
)paren
(brace
id|TRACE_EXIT
op_minus
id|EFAULT
suffix:semicolon
)brace
macro_line|#else
id|TRACE_CATCH
c_func
(paren
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|arg
comma
id|arg_size
)paren
comma
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|krnl_arg
comma
id|arg
comma
id|arg_size
)paren
suffix:semicolon
macro_line|#endif
)brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;called with ioctl command: 0x%08x&quot;
comma
id|command
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|command
)paren
(brace
r_case
id|MTIOCTOP
suffix:colon
id|result
op_assign
id|mtioctop
c_func
(paren
op_amp
id|krnl_arg.mtop
comma
id|arg_size
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTIOCGET
suffix:colon
id|result
op_assign
id|mtiocget
c_func
(paren
op_amp
id|krnl_arg.mtget
comma
id|arg_size
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTIOCPOS
suffix:colon
id|result
op_assign
id|mtiocpos
c_func
(paren
op_amp
id|krnl_arg.mtpos
comma
id|arg_size
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef MTIOCVOLINFO
r_case
id|MTIOCVOLINFO
suffix:colon
id|result
op_assign
id|mtiocvolinfo
c_func
(paren
op_amp
id|krnl_arg.mtvolinfo
comma
id|arg_size
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef ZFT_OBSOLETE
r_case
id|MTIOC_ZFTAPE_GETBLKSZ
suffix:colon
id|result
op_assign
id|mtioc_zftape_getblksz
c_func
(paren
op_amp
id|krnl_arg.mtblksz
comma
id|arg_size
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MTIOCRDFTSEG
r_case
id|MTIOCRDFTSEG
suffix:colon
multiline_comment|/* read a segment via ioctl */
id|result
op_assign
id|mtiocrdftseg
c_func
(paren
op_amp
id|krnl_arg.mtftseg
comma
id|arg_size
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MTIOCWRFTSEG
r_case
id|MTIOCWRFTSEG
suffix:colon
multiline_comment|/* write a segment via ioctl */
id|result
op_assign
id|mtiocwrftseg
c_func
(paren
op_amp
id|krnl_arg.mtftseg
comma
id|arg_size
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MTIOCGETSIZE
r_case
id|MTIOCGETSIZE
suffix:colon
id|result
op_assign
id|mtiocgetsize
c_func
(paren
op_amp
id|krnl_arg.mttapesize
comma
id|arg_size
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MTIOCFTFORMAT
r_case
id|MTIOCFTFORMAT
suffix:colon
id|result
op_assign
id|mtiocftformat
c_func
(paren
op_amp
id|krnl_arg.mtftformat
comma
id|arg_size
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MTIOCFTCMD
r_case
id|MTIOCFTCMD
suffix:colon
id|result
op_assign
id|mtiocftcmd
c_func
(paren
op_amp
id|krnl_arg.mtftcmd
comma
id|arg_size
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|result
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|result
op_ge
l_int|0
)paren
op_logical_and
(paren
id|dir
op_amp
id|_IOC_READ
)paren
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &gt; KERNEL_VER(2,1,3)
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|krnl_arg
comma
id|arg_size
)paren
op_ne
l_int|0
)paren
(brace
id|TRACE_EXIT
op_minus
id|EFAULT
suffix:semicolon
)brace
macro_line|#else
id|TRACE_CATCH
c_func
(paren
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|arg
comma
id|arg_size
)paren
comma
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|arg
comma
op_amp
id|krnl_arg
comma
id|arg_size
)paren
suffix:semicolon
macro_line|#endif
)brace
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
eof
