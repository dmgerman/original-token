multiline_comment|/*&n; *      Copyright (C) 1996, 1997 Claus Heine&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; *&n; * $Source: /homes/cvs/ftape-stacked/ftape/zftape/zftape-write.c,v $&n; * $Revision: 1.3 $&n; * $Date: 1997/11/06 00:50:29 $&n; *&n; *      This file contains the writing code&n; *      for the QIC-117 floppy-tape driver for Linux.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/zftape.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VER(2,1,6)
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#else
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#endif
macro_line|#include &quot;../zftape/zftape-init.h&quot;
macro_line|#include &quot;../zftape/zftape-eof.h&quot;
macro_line|#include &quot;../zftape/zftape-ctl.h&quot;
macro_line|#include &quot;../zftape/zftape-write.h&quot;
macro_line|#include &quot;../zftape/zftape-read.h&quot;
macro_line|#include &quot;../zftape/zftape-rw.h&quot;
macro_line|#include &quot;../zftape/zftape-vtbl.h&quot;
multiline_comment|/*      Global vars.&n; */
multiline_comment|/*      Local vars.&n; */
DECL|variable|last_write_failed
r_static
r_int
id|last_write_failed
suffix:semicolon
DECL|variable|need_flush
r_static
r_int
id|need_flush
suffix:semicolon
DECL|function|zft_prevent_flush
r_void
id|zft_prevent_flush
c_func
(paren
r_void
)paren
(brace
id|need_flush
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|zft_write_header_segments
r_static
r_int
id|zft_write_header_segments
c_func
(paren
id|__u8
op_star
id|buffer
)paren
(brace
r_int
id|header_1_ok
op_assign
l_int|0
suffix:semicolon
r_int
id|header_2_ok
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|time_stamp
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_noise
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_abort_operation
c_func
(paren
)paren
comma
)paren
suffix:semicolon
id|ftape_seek_to_bot
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* prevents extra rewind */
r_if
c_cond
(paren
id|GET4
c_func
(paren
id|buffer
comma
l_int|0
)paren
op_ne
id|FT_HSEG_MAGIC
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;wrong header signature found, aborting&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*   Be optimistic: */
id|PUT4
c_func
(paren
id|buffer
comma
id|FT_SEG_CNT
comma
id|zft_written_segments
op_plus
id|GET4
c_func
(paren
id|buffer
comma
id|FT_SEG_CNT
)paren
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|time_stamp
op_assign
id|zft_get_time
c_func
(paren
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|PUT4
c_func
(paren
id|buffer
comma
id|FT_WR_DATE
comma
id|time_stamp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_label_changed
)paren
(brace
id|PUT4
c_func
(paren
id|buffer
comma
id|FT_LABEL_DATE
comma
id|time_stamp
)paren
suffix:semicolon
)brace
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;writing first header segment %d&quot;
comma
id|ft_header_segment_1
)paren
suffix:semicolon
id|header_1_ok
op_assign
id|zft_verify_write_segments
c_func
(paren
id|ft_header_segment_1
comma
id|buffer
comma
id|FT_SEGMENT_SIZE
comma
id|zft_deblock_buf
)paren
op_ge
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;writing second header segment %d&quot;
comma
id|ft_header_segment_2
)paren
suffix:semicolon
id|header_2_ok
op_assign
id|zft_verify_write_segments
c_func
(paren
id|ft_header_segment_2
comma
id|buffer
comma
id|FT_SEGMENT_SIZE
comma
id|zft_deblock_buf
)paren
op_ge
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|header_1_ok
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Warning: &quot;
l_string|&quot;update of first header segment failed&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|header_2_ok
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Warning: &quot;
l_string|&quot;update of second header segment failed&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|header_1_ok
op_logical_and
op_logical_neg
id|header_2_ok
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;Error: &quot;
l_string|&quot;update of both header segments failed.&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|zft_update_header_segments
r_int
id|zft_update_header_segments
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_noise
)paren
suffix:semicolon
multiline_comment|/*  must NOT use zft_write_protected, as it also includes the&n;&t; *  file access mode. But we also want to update when soft&n;&t; *  write protection is enabled (O_RDONLY)&n;&t; */
r_if
c_cond
(paren
id|ft_write_protected
op_logical_or
id|zft_old_ftape
)paren
(brace
id|TRACE_ABORT
c_func
(paren
l_int|0
comma
id|ft_t_noise
comma
l_string|&quot;Tape set read-only: no update&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|zft_header_read
)paren
(brace
id|TRACE_ABORT
c_func
(paren
l_int|0
comma
id|ft_t_noise
comma
l_string|&quot;Nothing to update&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|zft_header_changed
)paren
(brace
id|zft_header_changed
op_assign
id|zft_written_segments
OG
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|zft_header_changed
op_logical_and
op_logical_neg
id|zft_volume_table_changed
)paren
(brace
id|TRACE_ABORT
c_func
(paren
l_int|0
comma
id|ft_t_noise
comma
l_string|&quot;Nothing to update&quot;
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Updating header segments&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftape_get_status
c_func
(paren
)paren
op_member_access_from_pointer
id|fti_state
op_eq
id|writing
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|ftape_loop_until_writes_done
c_func
(paren
)paren
comma
)paren
suffix:semicolon
)brace
id|TRACE_CATCH
c_func
(paren
id|ftape_abort_operation
c_func
(paren
)paren
comma
)paren
suffix:semicolon
id|zft_deblock_segment
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* invalidate the cache */
r_if
c_cond
(paren
id|zft_header_changed
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|zft_write_header_segments
c_func
(paren
id|zft_hseg_buf
)paren
comma
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_volume_table_changed
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|zft_update_volume_table
c_func
(paren
id|ft_first_data_segment
)paren
comma
)paren
suffix:semicolon
)brace
id|zft_header_changed
op_assign
id|zft_volume_table_changed
op_assign
id|zft_label_changed
op_assign
id|zft_written_segments
op_assign
l_int|0
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_abort_operation
c_func
(paren
)paren
comma
)paren
suffix:semicolon
id|ftape_seek_to_bot
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|read_merge_buffer
r_static
r_int
id|read_merge_buffer
c_func
(paren
r_int
id|seg_pos
comma
id|__u8
op_star
id|buffer
comma
r_int
id|offset
comma
r_int
id|seg_sz
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_const
id|ft_trace_t
id|old_tracing
op_assign
id|TRACE_LEVEL
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_qic_mode
)paren
(brace
multiline_comment|/*  writing in the middle of a volume is NOT allowed&n;&t;&t; *&n;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;No need to read a segment&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|buffer
op_plus
id|offset
comma
l_int|0
comma
id|seg_sz
op_minus
id|offset
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_any
comma
l_string|&quot;waiting&quot;
)paren
suffix:semicolon
id|ftape_start_writing
c_func
(paren
id|FT_WR_MULTI
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_loop_until_writes_done
c_func
(paren
)paren
comma
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;trying to read segment %d from offset %d&quot;
comma
id|seg_pos
comma
id|offset
)paren
suffix:semicolon
id|SET_TRACE_LEVEL
c_func
(paren
id|ft_t_bug
)paren
suffix:semicolon
id|result
op_assign
id|zft_fetch_segment_fraction
c_func
(paren
id|seg_pos
comma
id|buffer
comma
id|FT_RD_SINGLE
comma
id|offset
comma
id|seg_sz
op_minus
id|offset
)paren
suffix:semicolon
id|SET_TRACE_LEVEL
c_func
(paren
id|old_tracing
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
(paren
id|seg_sz
op_minus
id|offset
)paren
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Ignore error: read_segment() result: %d&quot;
comma
id|result
)paren
suffix:semicolon
id|memset
c_func
(paren
id|buffer
op_plus
id|offset
comma
l_int|0
comma
id|seg_sz
op_minus
id|offset
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/* flush the write buffer to tape and write an eof-marker at the&n; * current position if not in raw mode.  This function always&n; * positions the tape before the eof-marker.  _ftape_close() should&n; * then advance to the next segment.&n; *&n; * the parameter &quot;finish_volume&quot; describes whether to position before&n; * or after the possibly created file-mark. We always position after&n; * the file-mark when called from ftape_close() and a flush was needed&n; * (that is ftape_write() was the last tape operation before calling&n; * ftape_flush) But we always position before the file-mark when this&n; * function get&squot;s called from outside ftape_close() &n; */
DECL|function|zft_flush_buffers
r_int
id|zft_flush_buffers
c_func
(paren
r_void
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|data_remaining
suffix:semicolon
r_int
id|this_segs_size
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;entered, ftape_state = %d&quot;
comma
id|ftape_get_status
c_func
(paren
)paren
op_member_access_from_pointer
id|fti_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftape_get_status
c_func
(paren
)paren
op_member_access_from_pointer
id|fti_state
op_ne
id|writing
op_logical_and
op_logical_neg
id|need_flush
)paren
(brace
id|TRACE_ABORT
c_func
(paren
l_int|0
comma
id|ft_t_noise
comma
l_string|&quot;no need for flush&quot;
)paren
suffix:semicolon
)brace
id|zft_io_state
op_assign
id|zft_idle
suffix:semicolon
multiline_comment|/*  triggers some initializations for the&n;&t;&t;&t;&t;  *  read and write routines &n;&t;&t;&t;&t;  */
r_if
c_cond
(paren
id|last_write_failed
)paren
(brace
id|ftape_abort_operation
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;flushing write buffers&quot;
)paren
suffix:semicolon
id|this_segs_size
op_assign
id|zft_get_seg_sz
c_func
(paren
id|zft_pos.seg_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this_segs_size
op_eq
id|zft_pos.seg_byte_pos
)paren
(brace
id|zft_pos.seg_pos
op_increment
suffix:semicolon
id|data_remaining
op_assign
id|zft_pos.seg_byte_pos
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|data_remaining
op_assign
id|zft_pos.seg_byte_pos
suffix:semicolon
)brace
multiline_comment|/* If there is any data not written to tape yet, append zero&squot;s&n;&t; * up to the end of the sector (if using compression) or merge&n;&t; * it with the data existing on the tape Then write the&n;&t; * segment(s) to tape.&n;&t; */
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Position:&bslash;n&quot;
id|KERN_INFO
l_string|&quot;seg_pos  : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;byte pos : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;remaining: %d&quot;
comma
id|zft_pos.seg_pos
comma
id|zft_pos.seg_byte_pos
comma
id|data_remaining
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_remaining
OG
l_int|0
)paren
(brace
r_do
(brace
id|this_segs_size
op_assign
id|zft_get_seg_sz
c_func
(paren
id|zft_pos.seg_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this_segs_size
OG
id|data_remaining
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|read_merge_buffer
c_func
(paren
id|zft_pos.seg_pos
comma
id|zft_deblock_buf
comma
id|data_remaining
comma
id|this_segs_size
)paren
comma
id|last_write_failed
op_assign
l_int|1
)paren
suffix:semicolon
)brace
id|result
op_assign
id|ftape_write_segment
c_func
(paren
id|zft_pos.seg_pos
comma
id|zft_deblock_buf
comma
id|FT_WR_MULTI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|this_segs_size
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;flush buffers failed&quot;
)paren
suffix:semicolon
id|zft_pos.tape_pos
op_sub_assign
id|zft_pos.seg_byte_pos
suffix:semicolon
id|zft_pos.seg_byte_pos
op_assign
l_int|0
suffix:semicolon
id|last_write_failed
op_assign
l_int|1
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
id|zft_written_segments
op_increment
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;flush, moved out buffer: %d&quot;
comma
id|result
)paren
suffix:semicolon
multiline_comment|/* need next segment for more data (empty segments?)&n;&t;&t;&t; */
r_if
c_cond
(paren
id|result
OL
id|data_remaining
)paren
(brace
r_if
c_cond
(paren
id|result
OG
l_int|0
)paren
(brace
multiline_comment|/* move remainder to buffer beginning &n;&t;&t;&t;&t;&t; */
id|memmove
c_func
(paren
id|zft_deblock_buf
comma
id|zft_deblock_buf
op_plus
id|result
comma
id|FT_SEGMENT_SIZE
op_minus
id|result
)paren
suffix:semicolon
)brace
)brace
id|data_remaining
op_sub_assign
id|result
suffix:semicolon
id|zft_pos.seg_pos
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|data_remaining
OG
l_int|0
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_any
comma
l_string|&quot;result: %d&quot;
comma
id|result
)paren
suffix:semicolon
id|zft_deblock_segment
op_assign
op_decrement
id|zft_pos.seg_pos
suffix:semicolon
r_if
c_cond
(paren
id|data_remaining
op_eq
l_int|0
)paren
(brace
multiline_comment|/* first byte next segment */
id|zft_pos.seg_byte_pos
op_assign
id|this_segs_size
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* after data previous segment, data_remaining &lt; 0 */
id|zft_pos.seg_byte_pos
op_assign
id|data_remaining
op_plus
id|result
suffix:semicolon
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;zft_deblock_buf empty&quot;
)paren
suffix:semicolon
id|zft_pos.seg_pos
op_decrement
suffix:semicolon
id|zft_pos.seg_byte_pos
op_assign
id|zft_get_seg_sz
(paren
id|zft_pos.seg_pos
)paren
suffix:semicolon
id|ftape_start_writing
c_func
(paren
id|FT_WR_MULTI
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_any
comma
l_string|&quot;waiting&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|ftape_loop_until_writes_done
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* that&squot;s really bad. What to to with zft_tape_pos? &n;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;flush buffers failed&quot;
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_any
comma
l_string|&quot;zft_seg_pos: %d, zft_seg_byte_pos: %d&quot;
comma
id|zft_pos.seg_pos
comma
id|zft_pos.seg_byte_pos
)paren
suffix:semicolon
id|last_write_failed
op_assign
id|need_flush
op_assign
l_int|0
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/* return-value: the number of bytes removed from the user-buffer&n; *&n; * out: &n; *      int *write_cnt: how much actually has been moved to the&n; *                      zft_deblock_buf&n; *      int req_len  : MUST NOT BE CHANGED, except at EOT, in &n; *                      which case it may be adjusted&n; * in : &n; *      char *buff        : the user buffer&n; *      int buf_pos_write : copy of buf_len_wr int&n; *      this_segs_size    : the size in bytes of the actual segment&n; *                          char&n; *      *zft_deblock_buf   : zft_deblock_buf&n; */
DECL|function|zft_simple_write
r_static
r_int
id|zft_simple_write
c_func
(paren
r_int
op_star
id|cnt
comma
id|__u8
op_star
id|dst_buf
comma
r_const
r_int
id|seg_sz
comma
r_const
id|__u8
op_star
id|src_buf
comma
r_const
r_int
id|req_len
comma
r_const
id|zft_position
op_star
id|pos
comma
r_const
id|zft_volinfo
op_star
id|volume
)paren
(brace
r_int
id|space_left
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
multiline_comment|/* volume-&gt;size holds the tape capacity while volume is open */
r_if
c_cond
(paren
id|pos-&gt;tape_pos
op_plus
id|volume-&gt;blk_sz
OG
id|volume-&gt;size
)paren
(brace
id|TRACE_EXIT
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/*  remaining space in this segment, NOT zft_deblock_buf&n;&t; */
id|space_left
op_assign
id|seg_sz
op_minus
id|pos-&gt;seg_byte_pos
suffix:semicolon
op_star
id|cnt
op_assign
id|req_len
OL
id|space_left
ques
c_cond
id|req_len
suffix:colon
id|space_left
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt; KERNEL_VER(2,1,3)
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|dst_buf
op_plus
id|pos-&gt;seg_byte_pos
comma
id|src_buf
comma
op_star
id|cnt
)paren
op_ne
l_int|0
)paren
(brace
id|TRACE_EXIT
op_minus
id|EFAULT
suffix:semicolon
)brace
macro_line|#else
id|TRACE_CATCH
c_func
(paren
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|src_buf
comma
op_star
id|cnt
)paren
comma
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
id|dst_buf
op_plus
id|pos-&gt;seg_byte_pos
comma
id|src_buf
comma
op_star
id|cnt
)paren
suffix:semicolon
macro_line|#endif
id|TRACE_EXIT
op_star
id|cnt
suffix:semicolon
)brace
DECL|function|check_write_access
r_static
r_int
id|check_write_access
c_func
(paren
r_int
id|req_len
comma
r_const
id|zft_volinfo
op_star
op_star
id|volume
comma
id|zft_position
op_star
id|pos
comma
r_const
r_int
r_int
id|blk_sz
)paren
(brace
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|req_len
op_mod
id|zft_blk_sz
)paren
op_ne
l_int|0
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;write-count %d must be multiple of block-size %d&quot;
comma
id|req_len
comma
id|blk_sz
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_io_state
op_eq
id|zft_writing
)paren
(brace
multiline_comment|/*  all other error conditions have been checked earlier&n;&t;&t; */
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
id|zft_io_state
op_assign
id|zft_idle
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|zft_check_write_access
c_func
(paren
id|pos
)paren
comma
)paren
suffix:semicolon
multiline_comment|/*  If we haven&squot;t read the header segment yet, do it now.&n;&t; *  This will verify the configuration, get the bad sector&n;&t; *  table and read the volume table segment &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|zft_header_read
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|zft_read_header_segments
c_func
(paren
)paren
comma
)paren
suffix:semicolon
)brace
multiline_comment|/*  fine. Now the tape is either at BOT or at EOD,&n;&t; *  Write start of volume now&n;&t; */
id|TRACE_CATCH
c_func
(paren
id|zft_open_volume
c_func
(paren
id|pos
comma
id|blk_sz
comma
id|zft_use_compression
)paren
comma
)paren
suffix:semicolon
op_star
id|volume
op_assign
id|zft_find_volume
c_func
(paren
id|pos-&gt;seg_pos
)paren
suffix:semicolon
id|DUMP_VOLINFO
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;&quot;
comma
op_star
id|volume
)paren
suffix:semicolon
id|zft_just_before_eof
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* now merge with old data if neccessary */
r_if
c_cond
(paren
op_logical_neg
id|zft_qic_mode
op_logical_and
id|pos-&gt;seg_byte_pos
op_ne
l_int|0
)paren
(brace
id|result
op_assign
id|zft_fetch_segment
c_func
(paren
id|pos-&gt;seg_pos
comma
id|zft_deblock_buf
comma
id|FT_RD_SINGLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EINTR
op_logical_or
id|result
op_eq
op_minus
id|ENOSPC
)paren
(brace
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;ftape_read_segment() result: %d. &quot;
l_string|&quot;This might be normal when using &quot;
l_string|&quot;a newly&bslash;nformatted tape&quot;
comma
id|result
)paren
suffix:semicolon
id|memset
c_func
(paren
id|zft_deblock_buf
comma
l_char|&squot;&bslash;0&squot;
comma
id|pos-&gt;seg_byte_pos
)paren
suffix:semicolon
)brace
)brace
id|zft_io_state
op_assign
id|zft_writing
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|fill_deblock_buf
r_static
r_int
id|fill_deblock_buf
c_func
(paren
id|__u8
op_star
id|dst_buf
comma
r_const
r_int
id|seg_sz
comma
id|zft_position
op_star
id|pos
comma
r_const
id|zft_volinfo
op_star
id|volume
comma
r_const
r_char
op_star
id|usr_buf
comma
r_const
r_int
id|req_len
)paren
(brace
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|seg_sz
op_eq
l_int|0
)paren
(brace
id|TRACE_ABORT
c_func
(paren
l_int|0
comma
id|ft_t_data_flow
comma
l_string|&quot;empty segment&quot;
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;remaining req_len: %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;          buf_pos: %d&quot;
comma
id|req_len
comma
id|pos-&gt;seg_byte_pos
)paren
suffix:semicolon
multiline_comment|/* zft_deblock_buf will not contain a valid segment any longer */
id|zft_deblock_segment
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|zft_use_compression
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|zft_cmpr_lock
c_func
(paren
l_int|1
multiline_comment|/* try to load */
)paren
comma
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|result
op_assign
(paren
op_star
id|zft_cmpr_ops-&gt;write
)paren
(paren
op_amp
id|cnt
comma
id|dst_buf
comma
id|seg_sz
comma
id|usr_buf
comma
id|req_len
comma
id|pos
comma
id|volume
)paren
comma
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE_CATCH
c_func
(paren
id|result
op_assign
id|zft_simple_write
c_func
(paren
op_amp
id|cnt
comma
id|dst_buf
comma
id|seg_sz
comma
id|usr_buf
comma
id|req_len
comma
id|pos
comma
id|volume
)paren
comma
)paren
suffix:semicolon
)brace
id|pos-&gt;volume_pos
op_add_assign
id|result
suffix:semicolon
id|pos-&gt;seg_byte_pos
op_add_assign
id|cnt
suffix:semicolon
id|pos-&gt;tape_pos
op_add_assign
id|cnt
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;removed from user-buffer : %d bytes.&bslash;n&quot;
id|KERN_INFO
l_string|&quot;copied to zft_deblock_buf: %d bytes.&bslash;n&quot;
id|KERN_INFO
l_string|&quot;zft_tape_pos             : &quot;
id|LL_X
l_string|&quot; bytes.&quot;
comma
id|result
comma
id|cnt
comma
id|LL
c_func
(paren
id|pos-&gt;tape_pos
)paren
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/*  called by the kernel-interface routine &quot;zft_write()&quot;&n; */
DECL|function|_zft_write
r_int
id|_zft_write
c_func
(paren
r_const
r_char
op_star
id|buff
comma
r_int
id|req_len
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|written
op_assign
l_int|0
suffix:semicolon
r_int
id|write_cnt
suffix:semicolon
r_int
id|seg_sz
suffix:semicolon
r_static
r_const
id|zft_volinfo
op_star
id|volume
op_assign
l_int|NULL
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|zft_resid
op_assign
id|req_len
suffix:semicolon
id|last_write_failed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* reset to 0 when successful */
multiline_comment|/* check if write is allowed &n;&t; */
id|TRACE_CATCH
c_func
(paren
id|check_write_access
c_func
(paren
id|req_len
comma
op_amp
id|volume
comma
op_amp
id|zft_pos
comma
id|zft_blk_sz
)paren
comma
)paren
suffix:semicolon
r_while
c_loop
(paren
id|req_len
OG
l_int|0
)paren
(brace
multiline_comment|/* Allow us to escape from this loop with a signal !&n;&t;&t; */
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
id|seg_sz
op_assign
id|zft_get_seg_sz
c_func
(paren
id|zft_pos.seg_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|write_cnt
op_assign
id|fill_deblock_buf
c_func
(paren
id|zft_deblock_buf
comma
id|seg_sz
comma
op_amp
id|zft_pos
comma
id|volume
comma
id|buff
comma
id|req_len
)paren
)paren
OL
l_int|0
)paren
(brace
id|zft_resid
op_sub_assign
id|written
suffix:semicolon
r_if
c_cond
(paren
id|write_cnt
op_eq
op_minus
id|ENOSPC
)paren
(brace
multiline_comment|/* leave the remainder to flush_buffers()&n;&t;&t;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;No space left on device&quot;
)paren
suffix:semicolon
id|last_write_failed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|need_flush
)paren
(brace
id|need_flush
op_assign
id|written
OG
l_int|0
suffix:semicolon
)brace
id|TRACE_EXIT
id|written
OG
l_int|0
ques
c_cond
id|written
suffix:colon
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_else
(brace
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|zft_pos.seg_byte_pos
op_eq
id|seg_sz
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|ftape_write_segment
c_func
(paren
id|zft_pos.seg_pos
comma
id|zft_deblock_buf
comma
id|FT_WR_ASYNC
)paren
comma
id|zft_resid
op_sub_assign
id|written
)paren
suffix:semicolon
id|zft_written_segments
op_increment
suffix:semicolon
id|zft_pos.seg_byte_pos
op_assign
l_int|0
suffix:semicolon
id|zft_deblock_segment
op_assign
id|zft_pos.seg_pos
suffix:semicolon
op_increment
id|zft_pos.seg_pos
suffix:semicolon
)brace
id|written
op_add_assign
id|write_cnt
suffix:semicolon
id|buff
op_add_assign
id|write_cnt
suffix:semicolon
id|req_len
op_sub_assign
id|write_cnt
suffix:semicolon
)brace
multiline_comment|/* while (req_len &gt; 0) */
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;remaining in blocking buffer: %d&quot;
comma
id|zft_pos.seg_byte_pos
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;just written bytes: %d&quot;
comma
id|written
)paren
suffix:semicolon
id|last_write_failed
op_assign
l_int|0
suffix:semicolon
id|zft_resid
op_sub_assign
id|written
suffix:semicolon
id|need_flush
op_assign
id|need_flush
op_logical_or
id|written
OG
l_int|0
suffix:semicolon
id|TRACE_EXIT
id|written
suffix:semicolon
multiline_comment|/* bytes written */
)brace
eof
