multiline_comment|/*&n; *      Copyright (c) 1995-1997 Claus-Justus Heine &n;&n; This program is free software; you can redistribute it and/or&n; modify it under the terms of the GNU General Public License as&n; published by the Free Software Foundation; either version 2, or (at&n; your option) any later version.&n; &n; This program is distributed in the hope that it will be useful, but&n; WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; General Public License for more details.&n; &n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139,&n; USA.&n;&n; *&n; * $Source: /homes/cvs/ftape-stacked/ftape/zftape/zftape-vtbl.c,v $&n; * $Revision: 1.7.6.1 $&n; * $Date: 1997/11/24 13:48:31 $&n; *&n; *      This file defines a volume table as defined in various QIC&n; *      standards.&n; * &n; *      This is a minimal implementation, just allowing ordinary DOS&n; *      :( prgrams to identify the cartridge as used.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/zftape.h&gt;
macro_line|#include &quot;../zftape/zftape-init.h&quot;
macro_line|#include &quot;../zftape/zftape-eof.h&quot;
macro_line|#include &quot;../zftape/zftape-ctl.h&quot;
macro_line|#include &quot;../zftape/zftape-write.h&quot;
macro_line|#include &quot;../zftape/zftape-read.h&quot;
macro_line|#include &quot;../zftape/zftape-rw.h&quot;
macro_line|#include &quot;../zftape/zftape-vtbl.h&quot;
DECL|macro|ZFT_CMAP_HACK
mdefine_line|#define ZFT_CMAP_HACK /* leave this defined to hide the compression map */
multiline_comment|/*&n; *  global variables &n; */
DECL|variable|zft_qic_mode
r_int
id|zft_qic_mode
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* use the vtbl */
DECL|variable|zft_old_ftape
r_int
id|zft_old_ftape
suffix:semicolon
multiline_comment|/* prevents old ftaped tapes to be overwritten */
DECL|variable|zft_volume_table_changed
r_int
id|zft_volume_table_changed
suffix:semicolon
multiline_comment|/* for write_header_segments() */
multiline_comment|/*&n; *  private variables (only exported for inline functions)&n; */
DECL|variable|zft_vtbl
id|LIST_HEAD
c_func
(paren
id|zft_vtbl
)paren
suffix:semicolon
multiline_comment|/*  We could also allocate these dynamically when extracting the volume table&n; *  sizeof(zft_volinfo) is about 32 or something close to that&n; */
DECL|variable|tape_vtbl
r_static
id|zft_volinfo
id|tape_vtbl
suffix:semicolon
DECL|variable|eot_vtbl
r_static
id|zft_volinfo
id|eot_vtbl
suffix:semicolon
DECL|variable|cur_vtbl
r_static
id|zft_volinfo
op_star
id|cur_vtbl
suffix:semicolon
DECL|function|zft_new_vtbl_entry
r_inline
r_void
id|zft_new_vtbl_entry
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
op_assign
op_amp
id|zft_last_vtbl-&gt;node
suffix:semicolon
id|zft_volinfo
op_star
r_new
op_assign
id|zft_kmalloc
c_func
(paren
r_sizeof
(paren
id|zft_volinfo
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|node
comma
id|tmp
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|count
op_assign
id|zft_eom_vtbl-&gt;count
op_increment
suffix:semicolon
)brace
DECL|function|zft_free_vtbl
r_void
id|zft_free_vtbl
c_func
(paren
r_void
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
op_assign
id|zft_vtbl.prev
suffix:semicolon
id|zft_volinfo
op_star
id|vtbl
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
op_amp
id|zft_vtbl
)paren
r_break
suffix:semicolon
id|list_del
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|vtbl
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
id|zft_volinfo
comma
id|node
)paren
suffix:semicolon
id|zft_kfree
c_func
(paren
id|vtbl
comma
r_sizeof
(paren
id|zft_volinfo
)paren
)paren
suffix:semicolon
)brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|zft_vtbl
)paren
suffix:semicolon
id|cur_vtbl
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*  initialize vtbl, called by ftape_new_cartridge()&n; */
DECL|function|zft_init_vtbl
r_void
id|zft_init_vtbl
c_func
(paren
r_void
)paren
(brace
id|zft_volinfo
op_star
r_new
suffix:semicolon
id|zft_free_vtbl
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*  Create the two dummy vtbl entries&n;&t; */
r_new
op_assign
id|zft_kmalloc
c_func
(paren
r_sizeof
(paren
id|zft_volinfo
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|node
comma
op_amp
id|zft_vtbl
)paren
suffix:semicolon
r_new
op_assign
id|zft_kmalloc
c_func
(paren
r_sizeof
(paren
id|zft_volinfo
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|node
comma
op_amp
id|zft_vtbl
)paren
suffix:semicolon
id|zft_head_vtbl-&gt;end_seg
op_assign
id|ft_first_data_segment
suffix:semicolon
id|zft_head_vtbl-&gt;blk_sz
op_assign
id|zft_blk_sz
suffix:semicolon
id|zft_head_vtbl-&gt;count
op_assign
op_minus
l_int|1
suffix:semicolon
id|zft_eom_vtbl-&gt;start_seg
op_assign
id|ft_first_data_segment
op_plus
l_int|1
suffix:semicolon
id|zft_eom_vtbl-&gt;end_seg
op_assign
id|ft_last_data_segment
op_plus
l_int|1
suffix:semicolon
id|zft_eom_vtbl-&gt;blk_sz
op_assign
id|zft_blk_sz
suffix:semicolon
id|zft_eom_vtbl-&gt;count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*  Reset the pointer for zft_find_volume()&n;&t; */
id|cur_vtbl
op_assign
id|zft_eom_vtbl
suffix:semicolon
multiline_comment|/* initialize the dummy vtbl entries for zft_qic_mode == 0&n;&t; */
id|eot_vtbl.start_seg
op_assign
id|ft_last_data_segment
op_plus
l_int|1
suffix:semicolon
id|eot_vtbl.end_seg
op_assign
id|ft_last_data_segment
op_plus
l_int|1
suffix:semicolon
id|eot_vtbl.blk_sz
op_assign
id|zft_blk_sz
suffix:semicolon
id|eot_vtbl.count
op_assign
op_minus
l_int|1
suffix:semicolon
id|tape_vtbl.start_seg
op_assign
id|ft_first_data_segment
suffix:semicolon
id|tape_vtbl.end_seg
op_assign
id|ft_last_data_segment
suffix:semicolon
id|tape_vtbl.blk_sz
op_assign
id|zft_blk_sz
suffix:semicolon
id|tape_vtbl.size
op_assign
id|zft_capacity
suffix:semicolon
id|tape_vtbl.count
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* check for a valid VTBL signature. &n; */
DECL|function|vtbl_signature_valid
r_static
r_int
id|vtbl_signature_valid
c_func
(paren
id|__u8
id|signature
(braket
l_int|4
)braket
)paren
(brace
r_const
r_char
op_star
id|vtbl_ids
(braket
)braket
op_assign
id|VTBL_IDS
suffix:semicolon
multiline_comment|/* valid signatures */
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
(paren
id|j
OL
id|NR_ITEMS
c_func
(paren
id|vtbl_ids
)paren
)paren
op_logical_and
(paren
id|memcmp
c_func
(paren
id|signature
comma
id|vtbl_ids
(braket
id|j
)braket
comma
l_int|4
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|j
op_increment
)paren
suffix:semicolon
r_return
id|j
OL
id|NR_ITEMS
c_func
(paren
id|vtbl_ids
)paren
suffix:semicolon
)brace
multiline_comment|/* We used to store the block-size of the volume in the volume-label,&n; * using the keyword &quot;blocksize&quot;. The blocksize written to the&n; * volume-label is in bytes.&n; *&n; * We use this now only for compatability with old zftape version. We&n; * store the blocksize directly as binary number in the vendor&n; * extension part of the volume entry.&n; */
DECL|function|check_volume_label
r_static
r_int
id|check_volume_label
c_func
(paren
r_const
r_char
op_star
id|label
comma
r_int
op_star
id|blk_sz
)paren
(brace
r_int
id|valid_format
suffix:semicolon
r_char
op_star
id|blocksize
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;called with &bslash;&quot;%s&bslash;&quot; / &bslash;&quot;%s&bslash;&quot;&quot;
comma
id|label
comma
id|ZFT_VOL_NAME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|label
comma
id|ZFT_VOL_NAME
comma
id|strlen
c_func
(paren
id|ZFT_VOL_NAME
)paren
)paren
op_ne
l_int|0
)paren
(brace
op_star
id|blk_sz
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* smallest block size that we allow */
id|valid_format
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;got old style zftape vtbl entry&quot;
)paren
suffix:semicolon
multiline_comment|/* get the default blocksize */
multiline_comment|/* use the kernel strstr()   */
id|blocksize
op_assign
id|strstr
c_func
(paren
id|label
comma
l_string|&quot; blocksize &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blocksize
)paren
(brace
id|blocksize
op_add_assign
id|strlen
c_func
(paren
l_string|&quot; blocksize &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
op_star
id|blk_sz
op_assign
l_int|0
suffix:semicolon
op_star
id|blocksize
op_ge
l_char|&squot;0&squot;
op_logical_and
op_star
id|blocksize
op_le
l_char|&squot;9&squot;
suffix:semicolon
id|blocksize
op_increment
)paren
(brace
op_star
id|blk_sz
op_mul_assign
l_int|10
suffix:semicolon
op_star
id|blk_sz
op_add_assign
op_star
id|blocksize
op_minus
l_char|&squot;0&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|blk_sz
OG
id|ZFT_MAX_BLK_SZ
)paren
(brace
op_star
id|blk_sz
op_assign
l_int|1
suffix:semicolon
id|valid_format
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|valid_format
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
op_star
id|blk_sz
op_assign
l_int|1
suffix:semicolon
id|valid_format
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
id|valid_format
suffix:semicolon
)brace
multiline_comment|/*   check for a zftape volume&n; */
DECL|function|check_volume
r_static
r_int
id|check_volume
c_func
(paren
id|__u8
op_star
id|entry
comma
id|zft_volinfo
op_star
id|volume
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
op_amp
id|entry
(braket
id|VTBL_EXT
op_plus
id|EXT_ZFTAPE_SIG
)braket
comma
id|ZFTAPE_SIG
comma
id|strlen
c_func
(paren
id|ZFTAPE_SIG
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;got new style zftape vtbl entry&quot;
)paren
suffix:semicolon
id|volume-&gt;blk_sz
op_assign
id|GET2
c_func
(paren
id|entry
comma
id|VTBL_EXT
op_plus
id|EXT_ZFTAPE_BLKSZ
)paren
suffix:semicolon
id|volume-&gt;qic113
op_assign
id|entry
(braket
id|VTBL_EXT
op_plus
id|EXT_ZFTAPE_QIC113
)braket
suffix:semicolon
id|TRACE_EXIT
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|TRACE_EXIT
id|check_volume_label
c_func
(paren
op_amp
id|entry
(braket
id|VTBL_DESC
)braket
comma
op_amp
id|volume-&gt;blk_sz
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* create zftape specific vtbl entry, the volume bounds are inserted&n; * in the calling function, zft_create_volume_headers()&n; */
DECL|function|create_zft_volume
r_static
r_void
id|create_zft_volume
c_func
(paren
id|__u8
op_star
id|entry
comma
id|zft_volinfo
op_star
id|vtbl
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|memset
c_func
(paren
id|entry
comma
l_int|0
comma
id|VTBL_SIZE
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|entry
(braket
id|VTBL_SIG
)braket
comma
id|VTBL_ID
comma
l_int|4
)paren
suffix:semicolon
id|sprintf
c_func
(paren
op_amp
id|entry
(braket
id|VTBL_DESC
)braket
comma
id|ZFT_VOL_NAME
l_string|&quot; %03d&quot;
comma
id|vtbl-&gt;count
)paren
suffix:semicolon
id|entry
(braket
id|VTBL_FLAGS
)braket
op_assign
(paren
id|VTBL_FL_NOT_VERIFIED
op_or
id|VTBL_FL_SEG_SPANNING
)paren
suffix:semicolon
id|entry
(braket
id|VTBL_M_NO
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* multi_cartridge_count */
id|strcpy
c_func
(paren
op_amp
id|entry
(braket
id|VTBL_EXT
op_plus
id|EXT_ZFTAPE_SIG
)braket
comma
id|ZFTAPE_SIG
)paren
suffix:semicolon
id|PUT2
c_func
(paren
id|entry
comma
id|VTBL_EXT
op_plus
id|EXT_ZFTAPE_BLKSZ
comma
id|vtbl-&gt;blk_sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_qic113
)paren
(brace
id|PUT8
c_func
(paren
id|entry
comma
id|VTBL_DATA_SIZE
comma
id|vtbl-&gt;size
)paren
suffix:semicolon
id|entry
(braket
id|VTBL_CMPR
)braket
op_assign
id|VTBL_CMPR_UNREG
suffix:semicolon
r_if
c_cond
(paren
id|vtbl-&gt;use_compression
)paren
(brace
multiline_comment|/* use compression: */
id|entry
(braket
id|VTBL_CMPR
)braket
op_or_assign
id|VTBL_CMPR_USED
suffix:semicolon
)brace
id|entry
(braket
id|VTBL_EXT
op_plus
id|EXT_ZFTAPE_QIC113
)braket
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|PUT4
c_func
(paren
id|entry
comma
id|VTBL_DATA_SIZE
comma
id|vtbl-&gt;size
)paren
suffix:semicolon
id|entry
(braket
id|VTBL_K_CMPR
)braket
op_assign
id|VTBL_CMPR_UNREG
suffix:semicolon
r_if
c_cond
(paren
id|vtbl-&gt;use_compression
)paren
(brace
multiline_comment|/* use compression: */
id|entry
(braket
id|VTBL_K_CMPR
)braket
op_or_assign
id|VTBL_CMPR_USED
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ft_format_code
op_eq
id|fmt_big
)paren
(brace
multiline_comment|/* SCSI like vtbl, store the number of used&n;&t;&t; * segments as 4 byte value &n;&t;&t; */
id|PUT4
c_func
(paren
id|entry
comma
id|VTBL_SCSI_SEGS
comma
id|vtbl-&gt;end_seg
op_minus
id|vtbl-&gt;start_seg
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* normal, QIC-80MC like vtbl &n;&t;&t; */
id|PUT2
c_func
(paren
id|entry
comma
id|VTBL_START
comma
id|vtbl-&gt;start_seg
)paren
suffix:semicolon
id|PUT2
c_func
(paren
id|entry
comma
id|VTBL_END
comma
id|vtbl-&gt;end_seg
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/* this one creates the volume headers for each volume. It is assumed&n; * that buffer already contains the old volume-table, so that vtbl&n; * entries without the zft_volume flag set can savely be ignored.&n; */
DECL|function|zft_create_volume_headers
r_void
id|zft_create_volume_headers
c_func
(paren
id|__u8
op_star
id|buffer
)paren
(brace
id|__u8
op_star
id|entry
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|zft_volinfo
op_star
id|vtbl
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
macro_line|#ifdef ZFT_CMAP_HACK
r_if
c_cond
(paren
(paren
id|strncmp
c_func
(paren
op_amp
id|buffer
(braket
id|VTBL_EXT
op_plus
id|EXT_ZFTAPE_SIG
)braket
comma
id|ZFTAPE_SIG
comma
id|strlen
c_func
(paren
id|ZFTAPE_SIG
)paren
)paren
op_eq
l_int|0
)paren
op_logical_and
id|buffer
(braket
id|VTBL_EXT
op_plus
id|EXT_ZFTAPE_CMAP
)braket
op_ne
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;deleting cmap volume&quot;
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|buffer
comma
id|buffer
op_plus
id|VTBL_SIZE
comma
id|FT_SEGMENT_SIZE
op_minus
id|VTBL_SIZE
)paren
suffix:semicolon
)brace
macro_line|#endif
id|entry
op_assign
id|buffer
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|zft_head_vtbl-&gt;node.next
suffix:semicolon
id|tmp
op_ne
op_amp
id|zft_eom_vtbl-&gt;node
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
(brace
id|vtbl
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
id|zft_volinfo
comma
id|node
)paren
suffix:semicolon
multiline_comment|/* we now fill in the values only for newly created volumes.&n;&t;&t; */
r_if
c_cond
(paren
id|vtbl-&gt;new_volume
)paren
(brace
id|create_zft_volume
c_func
(paren
id|entry
comma
id|vtbl
)paren
suffix:semicolon
id|vtbl-&gt;new_volume
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear the flag */
)brace
id|DUMP_VOLINFO
c_func
(paren
id|ft_t_noise
comma
op_amp
id|entry
(braket
id|VTBL_DESC
)braket
comma
id|vtbl
)paren
suffix:semicolon
id|entry
op_add_assign
id|VTBL_SIZE
suffix:semicolon
)brace
id|memset
c_func
(paren
id|entry
comma
l_int|0
comma
id|FT_SEGMENT_SIZE
op_minus
id|zft_eom_vtbl-&gt;count
op_star
id|VTBL_SIZE
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/*  write volume table to tape. Calls zft_create_volume_headers()&n; */
DECL|function|zft_update_volume_table
r_int
id|zft_update_volume_table
c_func
(paren
r_int
r_int
id|segment
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|__u8
op_star
id|verify_buf
op_assign
l_int|NULL
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|result
op_assign
id|ftape_read_segment
c_func
(paren
id|ft_first_data_segment
comma
id|zft_deblock_buf
comma
id|FT_RD_SINGLE
)paren
comma
)paren
suffix:semicolon
id|zft_create_volume_headers
c_func
(paren
id|zft_deblock_buf
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;writing volume table segment %d&quot;
comma
id|segment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_vmalloc_once
c_func
(paren
op_amp
id|verify_buf
comma
id|FT_SEGMENT_SIZE
)paren
op_eq
l_int|0
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|zft_verify_write_segments
c_func
(paren
id|segment
comma
id|zft_deblock_buf
comma
id|result
comma
id|verify_buf
)paren
comma
id|zft_vfree
c_func
(paren
op_amp
id|verify_buf
comma
id|FT_SEGMENT_SIZE
)paren
)paren
suffix:semicolon
id|zft_vfree
c_func
(paren
op_amp
id|verify_buf
comma
id|FT_SEGMENT_SIZE
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE_CATCH
c_func
(paren
id|ftape_write_segment
c_func
(paren
id|segment
comma
id|zft_deblock_buf
comma
id|FT_WR_SINGLE
)paren
comma
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/* non zftape volumes are handled in raw mode. Thus we need to&n; * calculate the raw amount of data contained in those segments.  &n; */
DECL|function|extract_alien_volume
r_static
r_void
id|extract_alien_volume
c_func
(paren
id|__u8
op_star
id|entry
comma
id|zft_volinfo
op_star
id|vtbl
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|vtbl-&gt;size
op_assign
(paren
id|zft_calc_tape_pos
c_func
(paren
id|zft_last_vtbl-&gt;end_seg
op_plus
l_int|1
)paren
op_minus
id|zft_calc_tape_pos
c_func
(paren
id|zft_last_vtbl-&gt;start_seg
)paren
)paren
suffix:semicolon
id|vtbl-&gt;use_compression
op_assign
l_int|0
suffix:semicolon
id|vtbl-&gt;qic113
op_assign
id|zft_qic113
suffix:semicolon
r_if
c_cond
(paren
id|vtbl-&gt;qic113
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Fake alien volume&squot;s size from &quot;
id|LL_X
l_string|&quot; to &quot;
id|LL_X
comma
id|LL
c_func
(paren
id|GET8
c_func
(paren
id|entry
comma
id|VTBL_DATA_SIZE
)paren
)paren
comma
id|LL
c_func
(paren
id|vtbl-&gt;size
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Fake alien volume&squot;s size from %d to &quot;
id|LL_X
comma
(paren
r_int
)paren
id|GET4
c_func
(paren
id|entry
comma
id|VTBL_DATA_SIZE
)paren
comma
id|LL
c_func
(paren
id|vtbl-&gt;size
)paren
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/* extract an zftape specific volume&n; */
DECL|function|extract_zft_volume
r_static
r_void
id|extract_zft_volume
c_func
(paren
id|__u8
op_star
id|entry
comma
id|zft_volinfo
op_star
id|vtbl
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vtbl-&gt;qic113
)paren
(brace
id|vtbl-&gt;size
op_assign
id|GET8
c_func
(paren
id|entry
comma
id|VTBL_DATA_SIZE
)paren
suffix:semicolon
id|vtbl-&gt;use_compression
op_assign
(paren
id|entry
(braket
id|VTBL_CMPR
)braket
op_amp
id|VTBL_CMPR_USED
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|vtbl-&gt;size
op_assign
id|GET4
c_func
(paren
id|entry
comma
id|VTBL_DATA_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
(braket
id|VTBL_K_CMPR
)braket
op_amp
id|VTBL_CMPR_UNREG
)paren
(brace
id|vtbl-&gt;use_compression
op_assign
(paren
id|entry
(braket
id|VTBL_K_CMPR
)braket
op_amp
id|VTBL_CMPR_USED
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry
(braket
id|VTBL_CMPR
)braket
op_amp
id|VTBL_CMPR_UNREG
)paren
(brace
id|vtbl-&gt;use_compression
op_assign
(paren
id|entry
(braket
id|VTBL_CMPR
)braket
op_amp
id|VTBL_CMPR_USED
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Geeh! There is something wrong:&bslash;n&quot;
id|KERN_INFO
l_string|&quot;QIC compression (Rev = K): %x&bslash;n&quot;
id|KERN_INFO
l_string|&quot;QIC compression (Rev &gt; K): %x&quot;
comma
id|entry
(braket
id|VTBL_K_CMPR
)braket
comma
id|entry
(braket
id|VTBL_CMPR
)braket
)paren
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/* extract the volume table from buffer. &quot;buffer&quot; must already contain&n; * the vtbl-segment &n; */
DECL|function|zft_extract_volume_headers
r_int
id|zft_extract_volume_headers
c_func
(paren
id|__u8
op_star
id|buffer
)paren
(brace
id|__u8
op_star
id|entry
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|zft_init_vtbl
c_func
(paren
)paren
suffix:semicolon
id|entry
op_assign
id|buffer
suffix:semicolon
macro_line|#ifdef ZFT_CMAP_HACK
r_if
c_cond
(paren
(paren
id|strncmp
c_func
(paren
op_amp
id|entry
(braket
id|VTBL_EXT
op_plus
id|EXT_ZFTAPE_SIG
)braket
comma
id|ZFTAPE_SIG
comma
id|strlen
c_func
(paren
id|ZFTAPE_SIG
)paren
)paren
op_eq
l_int|0
)paren
op_logical_and
id|entry
(braket
id|VTBL_EXT
op_plus
id|EXT_ZFTAPE_CMAP
)braket
op_ne
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;ignoring cmap volume&quot;
)paren
suffix:semicolon
id|entry
op_add_assign
id|VTBL_SIZE
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* the end of the vtbl is indicated by an invalid signature &n;&t; */
r_while
c_loop
(paren
id|vtbl_signature_valid
c_func
(paren
op_amp
id|entry
(braket
id|VTBL_SIG
)braket
)paren
op_logical_and
(paren
id|entry
op_minus
id|buffer
)paren
OL
id|FT_SEGMENT_SIZE
)paren
(brace
id|zft_new_vtbl_entry
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_format_code
op_eq
id|fmt_big
)paren
(brace
multiline_comment|/* SCSI like vtbl, stores only the number of&n;&t;&t;&t; * segments used &n;&t;&t;&t; */
r_int
r_int
id|num_segments
op_assign
id|GET4
c_func
(paren
id|entry
comma
id|VTBL_SCSI_SEGS
)paren
suffix:semicolon
id|zft_last_vtbl-&gt;start_seg
op_assign
id|zft_eom_vtbl-&gt;start_seg
suffix:semicolon
id|zft_last_vtbl-&gt;end_seg
op_assign
id|zft_last_vtbl-&gt;start_seg
op_plus
id|num_segments
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* `normal&squot;, QIC-80 like vtbl &n;&t;&t;&t; */
id|zft_last_vtbl-&gt;start_seg
op_assign
id|GET2
c_func
(paren
id|entry
comma
id|VTBL_START
)paren
suffix:semicolon
id|zft_last_vtbl-&gt;end_seg
op_assign
id|GET2
c_func
(paren
id|entry
comma
id|VTBL_END
)paren
suffix:semicolon
)brace
id|zft_eom_vtbl-&gt;start_seg
op_assign
id|zft_last_vtbl-&gt;end_seg
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* check if we created this volume and get the&n;&t;&t; * blk_sz &n;&t;&t; */
id|zft_last_vtbl-&gt;zft_volume
op_assign
id|check_volume
c_func
(paren
id|entry
comma
id|zft_last_vtbl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_last_vtbl-&gt;zft_volume
op_eq
l_int|0
)paren
(brace
id|extract_alien_volume
c_func
(paren
id|entry
comma
id|zft_last_vtbl
)paren
suffix:semicolon
)brace
r_else
(brace
id|extract_zft_volume
c_func
(paren
id|entry
comma
id|zft_last_vtbl
)paren
suffix:semicolon
)brace
id|DUMP_VOLINFO
c_func
(paren
id|ft_t_noise
comma
op_amp
id|entry
(braket
id|VTBL_DESC
)braket
comma
id|zft_last_vtbl
)paren
suffix:semicolon
id|entry
op_add_assign
id|VTBL_SIZE
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; *  undefine to test end of tape handling&n; */
id|zft_new_vtbl_entry
c_func
(paren
)paren
suffix:semicolon
id|zft_last_vtbl-&gt;start_seg
op_assign
id|zft_eom_vtbl-&gt;start_seg
suffix:semicolon
id|zft_last_vtbl-&gt;end_seg
op_assign
id|ft_last_data_segment
op_minus
l_int|10
suffix:semicolon
id|zft_last_vtbl-&gt;blk_sz
op_assign
id|zft_blk_sz
suffix:semicolon
id|zft_last_vtbl-&gt;zft_volume
op_assign
l_int|1
suffix:semicolon
id|zft_last_vtbl-&gt;qic113
op_assign
id|zft_qic113
suffix:semicolon
id|zft_last_vtbl-&gt;size
op_assign
(paren
id|zft_calc_tape_pos
c_func
(paren
id|zft_last_vtbl-&gt;end_seg
op_plus
l_int|1
)paren
op_minus
id|zft_calc_tape_pos
c_func
(paren
id|zft_last_vtbl-&gt;start_seg
)paren
)paren
suffix:semicolon
macro_line|#endif
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this functions translates the failed_sector_log, misused as&n; * EOF-marker list, into a virtual volume table. The table mustn&squot;t be&n; * written to tape, because this would occupy the first data segment,&n; * which should be the volume table, but is actualy the first segment&n; * that is filled with data (when using standard ftape).  We assume,&n; * that we get a non-empty failed_sector_log.&n; */
DECL|function|zft_fake_volume_headers
r_int
id|zft_fake_volume_headers
(paren
id|eof_mark_union
op_star
id|eof_map
comma
r_int
id|num_failed_sectors
)paren
(brace
r_int
r_int
id|segment
comma
id|sector
suffix:semicolon
r_int
id|have_eom
op_assign
l_int|0
suffix:semicolon
r_int
id|vol_no
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|num_failed_sectors
op_ge
l_int|2
)paren
op_logical_and
(paren
id|GET2
c_func
(paren
op_amp
id|eof_map
(braket
id|num_failed_sectors
op_minus
l_int|1
)braket
dot
id|mark.segment
comma
l_int|0
)paren
op_eq
id|GET2
c_func
(paren
op_amp
id|eof_map
(braket
id|num_failed_sectors
op_minus
l_int|2
)braket
dot
id|mark.segment
comma
l_int|0
)paren
op_plus
l_int|1
)paren
op_logical_and
(paren
id|GET2
c_func
(paren
op_amp
id|eof_map
(braket
id|num_failed_sectors
op_minus
l_int|1
)braket
dot
id|mark.date
comma
l_int|0
)paren
op_eq
l_int|1
)paren
)paren
(brace
multiline_comment|/* this should be eom. We keep the remainder of the&n;&t;&t; * tape as another volume.&n;&t;&t; */
id|have_eom
op_assign
l_int|1
suffix:semicolon
)brace
id|zft_init_vtbl
c_func
(paren
)paren
suffix:semicolon
id|zft_eom_vtbl-&gt;start_seg
op_assign
id|ft_first_data_segment
suffix:semicolon
r_for
c_loop
(paren
id|vol_no
op_assign
l_int|0
suffix:semicolon
id|vol_no
OL
id|num_failed_sectors
op_minus
id|have_eom
suffix:semicolon
id|vol_no
op_increment
)paren
(brace
id|zft_new_vtbl_entry
c_func
(paren
)paren
suffix:semicolon
id|segment
op_assign
id|GET2
c_func
(paren
op_amp
id|eof_map
(braket
id|vol_no
)braket
dot
id|mark.segment
comma
l_int|0
)paren
suffix:semicolon
id|sector
op_assign
id|GET2
c_func
(paren
op_amp
id|eof_map
(braket
id|vol_no
)braket
dot
id|mark.date
comma
l_int|0
)paren
suffix:semicolon
id|zft_last_vtbl-&gt;start_seg
op_assign
id|zft_eom_vtbl-&gt;start_seg
suffix:semicolon
id|zft_last_vtbl-&gt;end_seg
op_assign
id|segment
suffix:semicolon
id|zft_eom_vtbl-&gt;start_seg
op_assign
id|segment
op_plus
l_int|1
suffix:semicolon
id|zft_last_vtbl-&gt;blk_sz
op_assign
l_int|1
suffix:semicolon
id|zft_last_vtbl-&gt;size
op_assign
(paren
id|zft_calc_tape_pos
c_func
(paren
id|zft_last_vtbl-&gt;end_seg
)paren
op_minus
id|zft_calc_tape_pos
c_func
(paren
id|zft_last_vtbl-&gt;start_seg
)paren
op_plus
(paren
id|sector
op_minus
l_int|1
)paren
op_star
id|FT_SECTOR_SIZE
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;failed sector log: segment: %d, sector: %d&quot;
comma
id|segment
comma
id|sector
)paren
suffix:semicolon
id|DUMP_VOLINFO
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Faked volume&quot;
comma
id|zft_last_vtbl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|have_eom
)paren
(brace
id|zft_new_vtbl_entry
c_func
(paren
)paren
suffix:semicolon
id|zft_last_vtbl-&gt;start_seg
op_assign
id|zft_eom_vtbl-&gt;start_seg
suffix:semicolon
id|zft_last_vtbl-&gt;end_seg
op_assign
id|ft_last_data_segment
suffix:semicolon
id|zft_eom_vtbl-&gt;start_seg
op_assign
id|ft_last_data_segment
op_plus
l_int|1
suffix:semicolon
id|zft_last_vtbl-&gt;size
op_assign
id|zft_capacity
suffix:semicolon
id|zft_last_vtbl-&gt;size
op_sub_assign
id|zft_calc_tape_pos
c_func
(paren
id|zft_last_vtbl-&gt;start_seg
)paren
suffix:semicolon
id|zft_last_vtbl-&gt;blk_sz
op_assign
l_int|1
suffix:semicolon
id|DUMP_VOLINFO
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Faked volume&quot;
comma
id|zft_last_vtbl
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/* update the internal volume table&n; *&n; * if before start of last volume: erase all following volumes if&n; * inside a volume: set end of volume to infinity&n; *&n; * this function is intended to be called every time _ftape_write() is&n; * called&n; *&n; * return: 0 if no new volume was created, 1 if a new volume was&n; * created&n; *&n; * NOTE: we don&squot;t need to check for zft_mode as ftape_write() does&n; * that already. This function gets never called without accessing&n; * zftape via the *qft* devices &n; */
DECL|function|zft_open_volume
r_int
id|zft_open_volume
c_func
(paren
id|zft_position
op_star
id|pos
comma
r_int
id|blk_sz
comma
r_int
id|use_compression
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zft_qic_mode
)paren
(brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_tape_at_lbot
c_func
(paren
id|pos
)paren
)paren
(brace
id|zft_init_vtbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_old_ftape
)paren
(brace
multiline_comment|/* clear old ftape&squot;s eof marks */
id|zft_clear_ftape_file_marks
c_func
(paren
)paren
suffix:semicolon
id|zft_old_ftape
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no longer old ftape */
)brace
id|zft_reset_position
c_func
(paren
id|pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos-&gt;seg_pos
op_ne
id|zft_last_vtbl-&gt;end_seg
op_plus
l_int|1
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_bug
comma
l_string|&quot;BUG: seg_pos: %d, zft_last_vtbl-&gt;end_seg: %d&quot;
comma
id|pos-&gt;seg_pos
comma
id|zft_last_vtbl-&gt;end_seg
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;create new volume&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_eom_vtbl-&gt;count
op_ge
id|ZFT_MAX_VOLUMES
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|ENOSPC
comma
id|ft_t_err
comma
l_string|&quot;Error: maxmimal number of volumes exhausted &quot;
l_string|&quot;(maxmimum is %d)&quot;
comma
id|ZFT_MAX_VOLUMES
)paren
suffix:semicolon
)brace
id|zft_new_vtbl_entry
c_func
(paren
)paren
suffix:semicolon
id|pos-&gt;volume_pos
op_assign
id|pos-&gt;seg_byte_pos
op_assign
l_int|0
suffix:semicolon
id|zft_last_vtbl-&gt;start_seg
op_assign
id|pos-&gt;seg_pos
suffix:semicolon
id|zft_last_vtbl-&gt;end_seg
op_assign
id|ft_last_data_segment
suffix:semicolon
multiline_comment|/* infinity */
id|zft_last_vtbl-&gt;blk_sz
op_assign
id|blk_sz
suffix:semicolon
id|zft_last_vtbl-&gt;size
op_assign
id|zft_capacity
suffix:semicolon
id|zft_last_vtbl-&gt;zft_volume
op_assign
l_int|1
suffix:semicolon
id|zft_last_vtbl-&gt;use_compression
op_assign
id|use_compression
suffix:semicolon
id|zft_last_vtbl-&gt;qic113
op_assign
id|zft_qic113
suffix:semicolon
id|zft_last_vtbl-&gt;new_volume
op_assign
l_int|1
suffix:semicolon
id|zft_last_vtbl-&gt;open
op_assign
l_int|1
suffix:semicolon
id|zft_volume_table_changed
op_assign
l_int|1
suffix:semicolon
id|zft_eom_vtbl-&gt;start_seg
op_assign
id|ft_last_data_segment
op_plus
l_int|1
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  perform mtfsf, mtbsf, not allowed without zft_qic_mode&n; */
DECL|function|zft_skip_volumes
r_int
id|zft_skip_volumes
c_func
(paren
r_int
id|count
comma
id|zft_position
op_star
id|pos
)paren
(brace
r_const
id|zft_volinfo
op_star
id|vtbl
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;count: %d&quot;
comma
id|count
)paren
suffix:semicolon
id|vtbl
op_assign
id|zft_find_volume
c_func
(paren
id|pos-&gt;seg_pos
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
op_logical_and
id|vtbl
op_ne
id|zft_eom_vtbl
)paren
(brace
id|vtbl
op_assign
id|list_entry
c_func
(paren
id|vtbl-&gt;node.next
comma
id|zft_volinfo
comma
id|node
)paren
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
OL
l_int|0
op_logical_and
id|vtbl
op_ne
id|zft_first_vtbl
)paren
(brace
id|vtbl
op_assign
id|list_entry
c_func
(paren
id|vtbl-&gt;node.prev
comma
id|zft_volinfo
comma
id|node
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
id|pos-&gt;seg_pos
op_assign
id|vtbl-&gt;start_seg
suffix:semicolon
id|pos-&gt;seg_byte_pos
op_assign
l_int|0
suffix:semicolon
id|pos-&gt;volume_pos
op_assign
l_int|0
suffix:semicolon
id|pos-&gt;tape_pos
op_assign
id|zft_calc_tape_pos
c_func
(paren
id|pos-&gt;seg_pos
)paren
suffix:semicolon
id|zft_just_before_eof
op_assign
id|vtbl-&gt;size
op_eq
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|zft_cmpr_ops
)paren
(brace
(paren
op_star
id|zft_cmpr_ops-&gt;reset
)paren
(paren
)paren
suffix:semicolon
)brace
id|zft_deblock_segment
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* no need to keep cache */
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;repositioning to:&bslash;n&quot;
id|KERN_INFO
l_string|&quot;zft_seg_pos        : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;zft_seg_byte_pos   : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;zft_tape_pos       : &quot;
id|LL_X
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;zft_volume_pos     : &quot;
id|LL_X
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;file number        : %d&quot;
comma
id|pos-&gt;seg_pos
comma
id|pos-&gt;seg_byte_pos
comma
id|LL
c_func
(paren
id|pos-&gt;tape_pos
)paren
comma
id|LL
c_func
(paren
id|pos-&gt;volume_pos
)paren
comma
id|vtbl-&gt;count
)paren
suffix:semicolon
id|zft_resid
op_assign
id|count
OL
l_int|0
ques
c_cond
op_minus
id|count
suffix:colon
id|count
suffix:semicolon
id|TRACE_EXIT
id|zft_resid
ques
c_cond
op_minus
id|EINVAL
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* the following simply returns the raw data position of the EOM&n; * marker, MTIOCSIZE ioctl &n; */
DECL|function|zft_get_eom_pos
id|__s64
id|zft_get_eom_pos
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|zft_qic_mode
)paren
(brace
r_return
id|zft_calc_tape_pos
c_func
(paren
id|zft_eom_vtbl-&gt;start_seg
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* there is only one volume in raw mode */
r_return
id|zft_capacity
suffix:semicolon
)brace
)brace
multiline_comment|/* skip to eom, used for MTEOM&n; */
DECL|function|zft_skip_to_eom
r_void
id|zft_skip_to_eom
c_func
(paren
id|zft_position
op_star
id|pos
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|pos-&gt;seg_pos
op_assign
id|zft_eom_vtbl-&gt;start_seg
suffix:semicolon
id|pos-&gt;seg_byte_pos
op_assign
id|pos-&gt;volume_pos
op_assign
id|zft_just_before_eof
op_assign
l_int|0
suffix:semicolon
id|pos-&gt;tape_pos
op_assign
id|zft_calc_tape_pos
c_func
(paren
id|pos-&gt;seg_pos
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;ftape positioned to segment %d, data pos &quot;
id|LL_X
comma
id|pos-&gt;seg_pos
comma
id|LL
c_func
(paren
id|pos-&gt;tape_pos
)paren
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/*  write an EOF-marker by setting zft_last_vtbl-&gt;end_seg to seg_pos.&n; *  NOTE: this function assumes that zft_last_vtbl points to a valid&n; *  vtbl entry&n; *&n; *  NOTE: this routine always positions before the EOF marker&n; */
DECL|function|zft_close_volume
r_int
id|zft_close_volume
c_func
(paren
id|zft_position
op_star
id|pos
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_vtbl_empty
op_logical_or
op_logical_neg
id|zft_last_vtbl-&gt;open
)paren
(brace
multiline_comment|/* should not happen */
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;There are no volumes to finish&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos-&gt;seg_byte_pos
op_eq
l_int|0
op_logical_and
id|pos-&gt;seg_pos
op_ne
id|zft_last_vtbl-&gt;start_seg
)paren
(brace
id|pos-&gt;seg_pos
op_decrement
suffix:semicolon
id|pos-&gt;seg_byte_pos
op_assign
id|zft_get_seg_sz
c_func
(paren
id|pos-&gt;seg_pos
)paren
suffix:semicolon
)brace
id|zft_last_vtbl-&gt;end_seg
op_assign
id|pos-&gt;seg_pos
suffix:semicolon
id|zft_last_vtbl-&gt;size
op_assign
id|pos-&gt;volume_pos
suffix:semicolon
id|zft_volume_table_changed
op_assign
l_int|1
suffix:semicolon
id|zft_just_before_eof
op_assign
l_int|1
suffix:semicolon
id|zft_eom_vtbl-&gt;start_seg
op_assign
id|zft_last_vtbl-&gt;end_seg
op_plus
l_int|1
suffix:semicolon
id|zft_last_vtbl-&gt;open
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* closed */
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/* write count file-marks at current position. &n; *&n; *  The tape is positioned after the eof-marker, that is at byte 0 of&n; *  the segment following the eof-marker&n; *&n; *  this function is only allowed in zft_qic_mode&n; *&n; *  Only allowed when tape is at BOT or EOD.&n; */
DECL|function|zft_weof
r_int
id|zft_weof
c_func
(paren
r_int
r_int
id|count
comma
id|zft_position
op_star
id|pos
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
(brace
multiline_comment|/* write zero EOF marks should be a real no-op */
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
id|zft_volume_table_changed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|zft_tape_at_lbot
c_func
(paren
id|pos
)paren
)paren
(brace
id|zft_init_vtbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_old_ftape
)paren
(brace
multiline_comment|/* clear old ftape&squot;s eof marks */
id|zft_clear_ftape_file_marks
c_func
(paren
)paren
suffix:semicolon
id|zft_old_ftape
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no longer old ftape */
)brace
)brace
r_if
c_cond
(paren
id|zft_last_vtbl-&gt;open
)paren
(brace
id|zft_close_volume
c_func
(paren
id|pos
)paren
suffix:semicolon
id|zft_move_past_eof
c_func
(paren
id|pos
)paren
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
multiline_comment|/* now it&squot;s easy, just append eof-marks, that is empty&n;&t; * volumes, to the end of the already recorded media.&n;&t; */
r_while
c_loop
(paren
id|count
OG
l_int|0
op_logical_and
id|pos-&gt;seg_pos
op_le
id|ft_last_data_segment
op_logical_and
id|zft_eom_vtbl-&gt;count
OL
id|ZFT_MAX_VOLUMES
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Writing zero sized file at segment %d&quot;
comma
id|pos-&gt;seg_pos
)paren
suffix:semicolon
id|zft_new_vtbl_entry
c_func
(paren
)paren
suffix:semicolon
id|zft_last_vtbl-&gt;start_seg
op_assign
id|pos-&gt;seg_pos
suffix:semicolon
id|zft_last_vtbl-&gt;end_seg
op_assign
id|pos-&gt;seg_pos
suffix:semicolon
id|zft_last_vtbl-&gt;size
op_assign
l_int|0
suffix:semicolon
id|zft_last_vtbl-&gt;blk_sz
op_assign
id|zft_blk_sz
suffix:semicolon
id|zft_last_vtbl-&gt;zft_volume
op_assign
l_int|1
suffix:semicolon
id|zft_last_vtbl-&gt;use_compression
op_assign
l_int|0
suffix:semicolon
id|pos-&gt;tape_pos
op_add_assign
id|zft_get_seg_sz
c_func
(paren
id|pos-&gt;seg_pos
)paren
suffix:semicolon
id|zft_eom_vtbl-&gt;start_seg
op_assign
op_increment
id|pos-&gt;seg_pos
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
multiline_comment|/*  there are two possibilities: end of tape, or the&n;&t;&t; *  maximum number of files is exhausted.&n;&t;&t; */
id|zft_resid
op_assign
id|count
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Number of marks NOT written: %d&quot;
comma
id|zft_resid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_eom_vtbl-&gt;count
op_eq
id|ZFT_MAX_VOLUMES
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_warn
comma
l_string|&quot;maximum allowed number of files &quot;
l_string|&quot;exhausted: %d&quot;
comma
id|ZFT_MAX_VOLUMES
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|ENOSPC
comma
id|ft_t_noise
comma
l_string|&quot;reached end of tape&quot;
)paren
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|zft_find_volume
r_const
id|zft_volinfo
op_star
id|zft_find_volume
c_func
(paren
r_int
r_int
id|seg_pos
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_any
comma
l_string|&quot;called with seg_pos %d&quot;
comma
id|seg_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zft_qic_mode
)paren
(brace
r_if
c_cond
(paren
id|seg_pos
OG
id|ft_last_data_segment
)paren
(brace
id|TRACE_EXIT
op_amp
id|eot_vtbl
suffix:semicolon
)brace
id|tape_vtbl.blk_sz
op_assign
id|zft_blk_sz
suffix:semicolon
id|TRACE_EXIT
op_amp
id|tape_vtbl
suffix:semicolon
)brace
r_if
c_cond
(paren
id|seg_pos
OL
id|zft_first_vtbl-&gt;start_seg
)paren
(brace
id|TRACE_EXIT
(paren
id|cur_vtbl
op_assign
id|zft_first_vtbl
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|seg_pos
OG
id|cur_vtbl-&gt;end_seg
)paren
(brace
id|cur_vtbl
op_assign
id|list_entry
c_func
(paren
id|cur_vtbl-&gt;node.next
comma
id|zft_volinfo
comma
id|node
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;%d - %d&quot;
comma
id|cur_vtbl-&gt;start_seg
comma
id|cur_vtbl-&gt;end_seg
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|seg_pos
OL
id|cur_vtbl-&gt;start_seg
)paren
(brace
id|cur_vtbl
op_assign
id|list_entry
c_func
(paren
id|cur_vtbl-&gt;node.prev
comma
id|zft_volinfo
comma
id|node
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;%d - %d&quot;
comma
id|cur_vtbl-&gt;start_seg
comma
id|cur_vtbl-&gt;end_seg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|seg_pos
OG
id|cur_vtbl-&gt;end_seg
op_logical_or
id|seg_pos
OL
id|cur_vtbl-&gt;start_seg
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;This cannot happen&quot;
)paren
suffix:semicolon
)brace
id|DUMP_VOLINFO
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;&quot;
comma
id|cur_vtbl
)paren
suffix:semicolon
id|TRACE_EXIT
id|cur_vtbl
suffix:semicolon
)brace
multiline_comment|/* this function really assumes that we are just before eof&n; */
DECL|function|zft_move_past_eof
r_void
id|zft_move_past_eof
c_func
(paren
id|zft_position
op_star
id|pos
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;old seg. pos: %d&quot;
comma
id|pos-&gt;seg_pos
)paren
suffix:semicolon
id|pos-&gt;tape_pos
op_add_assign
id|zft_get_seg_sz
c_func
(paren
id|pos-&gt;seg_pos
op_increment
)paren
op_minus
id|pos-&gt;seg_byte_pos
suffix:semicolon
id|pos-&gt;seg_byte_pos
op_assign
l_int|0
suffix:semicolon
id|pos-&gt;volume_pos
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|zft_cmpr_ops
)paren
(brace
(paren
op_star
id|zft_cmpr_ops-&gt;reset
)paren
(paren
)paren
suffix:semicolon
)brace
id|zft_just_before_eof
op_assign
l_int|0
suffix:semicolon
id|zft_deblock_segment
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* no need to cache it anymore */
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;new seg. pos: %d&quot;
comma
id|pos-&gt;seg_pos
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
eof
