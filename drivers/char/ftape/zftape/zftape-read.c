multiline_comment|/*&n; *      Copyright (C) 1996, 1997 Claus-Justus Heine&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; *&n; * $Source: /homes/cvs/ftape-stacked/ftape/zftape/zftape-read.c,v $&n; * $Revision: 1.2 $&n; * $Date: 1997/10/05 19:19:06 $&n; *&n; *      This file contains the high level reading code&n; *      for the QIC-117 floppy-tape driver for Linux.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/zftape.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VER(2,1,6)
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#else
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#endif
macro_line|#include &quot;../zftape/zftape-init.h&quot;
macro_line|#include &quot;../zftape/zftape-eof.h&quot;
macro_line|#include &quot;../zftape/zftape-ctl.h&quot;
macro_line|#include &quot;../zftape/zftape-write.h&quot;
macro_line|#include &quot;../zftape/zftape-read.h&quot;
macro_line|#include &quot;../zftape/zftape-rw.h&quot;
macro_line|#include &quot;../zftape/zftape-vtbl.h&quot;
multiline_comment|/*      Global vars.&n; */
DECL|variable|zft_just_before_eof
r_int
id|zft_just_before_eof
suffix:semicolon
multiline_comment|/*      Local vars.&n; */
DECL|variable|buf_len_rd
r_static
r_int
id|buf_len_rd
suffix:semicolon
DECL|function|zft_zap_read_buffers
r_void
id|zft_zap_read_buffers
c_func
(paren
r_void
)paren
(brace
id|buf_len_rd
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|zft_read_header_segments
r_int
id|zft_read_header_segments
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|zft_header_read
op_assign
l_int|0
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|zft_vmalloc_once
c_func
(paren
op_amp
id|zft_hseg_buf
comma
id|FT_SEGMENT_SIZE
)paren
comma
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_read_header_segment
c_func
(paren
id|zft_hseg_buf
)paren
comma
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;Segments written since first format: %d&quot;
comma
(paren
r_int
)paren
id|GET4
c_func
(paren
id|zft_hseg_buf
comma
id|FT_SEG_CNT
)paren
)paren
suffix:semicolon
id|zft_qic113
op_assign
(paren
id|ft_format_code
op_ne
id|fmt_normal
op_logical_and
id|ft_format_code
op_ne
id|fmt_1100ft
op_logical_and
id|ft_format_code
op_ne
id|fmt_425ft
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;ft_first_data_segment: %d, ft_last_data_segment: %d&quot;
comma
id|ft_first_data_segment
comma
id|ft_last_data_segment
)paren
suffix:semicolon
id|zft_capacity
op_assign
id|zft_get_capacity
c_func
(paren
)paren
suffix:semicolon
id|zft_old_ftape
op_assign
id|zft_ftape_validate_label
c_func
(paren
op_amp
id|zft_hseg_buf
(braket
id|FT_LABEL
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_old_ftape
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;Found old ftaped tape, emulating eof marks, entering read-only mode&quot;
)paren
suffix:semicolon
id|zft_ftape_extract_file_marks
c_func
(paren
id|zft_hseg_buf
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|zft_fake_volume_headers
c_func
(paren
id|zft_eof_map
comma
id|zft_nr_eof_marks
)paren
comma
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* the specs say that the volume table must be&n;&t;&t; * initialized with zeroes during formatting, so it&n;&t;&t; * MUST be readable, i.e. contain vaid ECC&n;&t;&t; * information.  &n;&t;&t; */
id|TRACE_CATCH
c_func
(paren
id|ftape_read_segment
c_func
(paren
id|ft_first_data_segment
comma
id|zft_deblock_buf
comma
id|FT_RD_SINGLE
)paren
comma
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|zft_extract_volume_headers
c_func
(paren
id|zft_deblock_buf
)paren
comma
)paren
suffix:semicolon
)brace
id|zft_header_read
op_assign
l_int|1
suffix:semicolon
id|zft_set_flags
c_func
(paren
id|zft_unit
)paren
suffix:semicolon
id|zft_reset_position
c_func
(paren
op_amp
id|zft_pos
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|zft_fetch_segment_fraction
r_int
id|zft_fetch_segment_fraction
c_func
(paren
r_const
r_int
r_int
id|segment
comma
r_void
op_star
id|buffer
comma
r_const
id|ft_read_mode_t
id|read_mode
comma
r_const
r_int
r_int
id|start
comma
r_const
r_int
r_int
id|size
)paren
(brace
r_int
id|seg_sz
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|segment
op_eq
id|zft_deblock_segment
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;re-using segment %d already in deblock buffer&quot;
comma
id|segment
)paren
suffix:semicolon
id|seg_sz
op_assign
id|zft_get_seg_sz
c_func
(paren
id|segment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
OG
id|seg_sz
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_bug
comma
l_string|&quot;trying to read beyond end of segment:&bslash;n&quot;
id|KERN_INFO
l_string|&quot;seg_sz : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;start  : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;segment: %d&quot;
comma
id|seg_sz
comma
id|start
comma
id|segment
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|start
op_plus
id|size
)paren
OG
id|seg_sz
)paren
(brace
id|TRACE_EXIT
id|seg_sz
op_minus
id|start
suffix:semicolon
)brace
id|TRACE_EXIT
id|size
suffix:semicolon
)brace
id|seg_sz
op_assign
id|ftape_read_segment_fraction
c_func
(paren
id|segment
comma
id|buffer
comma
id|read_mode
comma
id|start
comma
id|size
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;segment %d, result %d&quot;
comma
id|segment
comma
id|seg_sz
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|seg_sz
op_ge
l_int|0
op_logical_and
id|start
op_eq
l_int|0
op_logical_and
id|size
op_eq
id|FT_SEGMENT_SIZE
)paren
(brace
multiline_comment|/*  this implicitly assumes that we are always called with&n;&t;&t; *  buffer == zft_deblock_buf &n;&t;&t; */
id|zft_deblock_segment
op_assign
id|segment
suffix:semicolon
)brace
r_else
(brace
id|zft_deblock_segment
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|TRACE_EXIT
id|seg_sz
suffix:semicolon
)brace
multiline_comment|/*&n; * out:&n; *&n; * int *read_cnt: the number of bytes we removed from the&n; *                zft_deblock_buf (result)&n; *&n; * int *to_do   : the remaining size of the read-request. Is changed.&n; *&n; * in:&n; *&n; * char *buff      : buff is the address of the upper part of the user&n; *                   buffer, that hasn&squot;t been filled with data yet.&n; * int buf_pos_read: copy of buf_pos_rd&n; * int buf_len_read: copy of buf_len_rd&n; * char *zft_deblock_buf: ftape_zft_deblock_buf&n; *&n; * returns the amount of data actually copied to the user-buffer&n; *&n; * to_do MUST NOT SHRINK except to indicate an EOT. In this case to_do&n; * has to be set to 0. We cannot return -ENOSPC, because we return the&n; * amount of data actually * copied to the user-buffer&n; */
DECL|function|zft_simple_read
r_static
r_int
id|zft_simple_read
(paren
r_int
op_star
id|read_cnt
comma
id|__u8
op_star
id|dst_buf
comma
r_const
r_int
id|to_do
comma
r_const
id|__u8
op_star
id|src_buf
comma
r_const
r_int
id|seg_sz
comma
r_const
id|zft_position
op_star
id|pos
comma
r_const
id|zft_volinfo
op_star
id|volume
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|seg_sz
op_minus
id|pos-&gt;seg_byte_pos
OL
id|to_do
)paren
(brace
op_star
id|read_cnt
op_assign
id|seg_sz
op_minus
id|pos-&gt;seg_byte_pos
suffix:semicolon
)brace
r_else
(brace
op_star
id|read_cnt
op_assign
id|to_do
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &gt; KERNEL_VER(2,1,3)
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|dst_buf
comma
id|src_buf
op_plus
id|pos-&gt;seg_byte_pos
comma
op_star
id|read_cnt
)paren
op_ne
l_int|0
)paren
(brace
id|TRACE_EXIT
op_minus
id|EFAULT
suffix:semicolon
)brace
macro_line|#else
id|TRACE_CATCH
c_func
(paren
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|dst_buf
comma
op_star
id|read_cnt
)paren
comma
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|dst_buf
comma
id|src_buf
op_plus
id|pos-&gt;seg_byte_pos
comma
op_star
id|read_cnt
)paren
suffix:semicolon
macro_line|#endif
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;nr bytes just read: %d&quot;
comma
op_star
id|read_cnt
)paren
suffix:semicolon
id|TRACE_EXIT
op_star
id|read_cnt
suffix:semicolon
)brace
multiline_comment|/* req_len: gets clipped due to EOT of EOF.&n; * req_clipped: is a flag indicating whether req_len was clipped or not&n; * volume: contains information on current volume (blk_sz etc.)&n; */
DECL|function|check_read_access
r_static
r_int
id|check_read_access
c_func
(paren
r_int
op_star
id|req_len
comma
r_const
id|zft_volinfo
op_star
op_star
id|volume
comma
r_int
op_star
id|req_clipped
comma
r_const
id|zft_position
op_star
id|pos
)paren
(brace
r_static
id|__s64
id|remaining
suffix:semicolon
r_static
r_int
id|eod
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_io_state
op_ne
id|zft_reading
)paren
(brace
r_if
c_cond
(paren
id|zft_offline
)paren
(brace
multiline_comment|/* offline includes no_tape */
id|TRACE_ABORT
c_func
(paren
op_minus
id|ENXIO
comma
id|ft_t_warn
comma
l_string|&quot;tape is offline or no cartridge&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ft_formatted
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EACCES
comma
id|ft_t_warn
comma
l_string|&quot;tape is not formatted&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*  now enter defined state, read header segment if not&n;&t;&t; *  already done and flush write buffers&n;&t;&t; */
id|TRACE_CATCH
c_func
(paren
id|zft_def_idle_state
c_func
(paren
)paren
comma
)paren
suffix:semicolon
id|zft_io_state
op_assign
id|zft_reading
suffix:semicolon
r_if
c_cond
(paren
id|zft_tape_at_eod
c_func
(paren
id|pos
)paren
)paren
(brace
id|eod
op_assign
l_int|1
suffix:semicolon
id|TRACE_EXIT
l_int|1
suffix:semicolon
)brace
id|eod
op_assign
l_int|0
suffix:semicolon
op_star
id|volume
op_assign
id|zft_find_volume
c_func
(paren
id|pos-&gt;seg_pos
)paren
suffix:semicolon
multiline_comment|/* get the space left until EOF */
id|remaining
op_assign
id|zft_check_for_eof
c_func
(paren
op_star
id|volume
comma
id|pos
)paren
suffix:semicolon
id|buf_len_rd
op_assign
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;remaining: &quot;
id|LL_X
l_string|&quot;, vol_no: %d&quot;
comma
id|LL
c_func
(paren
id|remaining
)paren
comma
(paren
op_star
id|volume
)paren
op_member_access_from_pointer
id|count
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|zft_tape_at_eod
c_func
(paren
id|pos
)paren
)paren
(brace
r_if
c_cond
(paren
op_increment
id|eod
OG
l_int|2
)paren
(brace
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* st.c also returns -EIO */
)brace
r_else
(brace
id|TRACE_EXIT
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
op_star
id|req_len
op_mod
(paren
op_star
id|volume
)paren
op_member_access_from_pointer
id|blk_sz
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*  this message is informational only. The user gets the&n;&t;&t; *  proper return value&n;&t;&t; */
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_info
comma
l_string|&quot;req_len %d not a multiple of block size %d&quot;
comma
op_star
id|req_len
comma
(paren
op_star
id|volume
)paren
op_member_access_from_pointer
id|blk_sz
)paren
suffix:semicolon
)brace
multiline_comment|/* As GNU tar doesn&squot;t accept partial read counts when the&n;&t; * multiple volume flag is set, we make sure to return the&n;&t; * requested amount of data. Except, of course, at the end of&n;&t; * the tape or file mark.  &n;&t; */
id|remaining
op_sub_assign
op_star
id|req_len
suffix:semicolon
r_if
c_cond
(paren
id|remaining
op_le
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;clipped request from %d to %d.&quot;
comma
op_star
id|req_len
comma
(paren
r_int
)paren
(paren
op_star
id|req_len
op_plus
id|remaining
)paren
)paren
suffix:semicolon
op_star
id|req_len
op_add_assign
id|remaining
suffix:semicolon
op_star
id|req_clipped
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
op_star
id|req_clipped
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this_segs_size: the current segment&squot;s size.&n; * buff: the USER-SPACE buffer provided by the calling function.&n; * req_len: how much data should be read at most.&n; * volume: contains information on current volume (blk_sz etc.)&n; */
DECL|function|empty_deblock_buf
r_static
r_int
id|empty_deblock_buf
c_func
(paren
id|__u8
op_star
id|usr_buf
comma
r_const
r_int
id|req_len
comma
r_const
id|__u8
op_star
id|src_buf
comma
r_const
r_int
id|seg_sz
comma
id|zft_position
op_star
id|pos
comma
r_const
id|zft_volinfo
op_star
id|volume
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;this_segs_size: %d&quot;
comma
id|seg_sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_use_compression
op_logical_and
id|volume-&gt;use_compression
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|zft_cmpr_lock
c_func
(paren
l_int|1
multiline_comment|/* try to load */
)paren
comma
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|result
op_assign
(paren
op_star
id|zft_cmpr_ops-&gt;read
)paren
(paren
op_amp
id|cnt
comma
id|usr_buf
comma
id|req_len
comma
id|src_buf
comma
id|seg_sz
comma
id|pos
comma
id|volume
)paren
comma
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE_CATCH
c_func
(paren
id|result
op_assign
id|zft_simple_read
(paren
op_amp
id|cnt
comma
id|usr_buf
comma
id|req_len
comma
id|src_buf
comma
id|seg_sz
comma
id|pos
comma
id|volume
)paren
comma
)paren
suffix:semicolon
)brace
id|pos-&gt;volume_pos
op_add_assign
id|result
suffix:semicolon
id|pos-&gt;tape_pos
op_add_assign
id|cnt
suffix:semicolon
id|pos-&gt;seg_byte_pos
op_add_assign
id|cnt
suffix:semicolon
id|buf_len_rd
op_sub_assign
id|cnt
suffix:semicolon
multiline_comment|/* remaining bytes in buffer */
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;buf_len_rd: %d, cnt: %d&quot;
comma
id|buf_len_rd
comma
id|cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos-&gt;seg_byte_pos
op_ge
id|seg_sz
)paren
(brace
id|pos-&gt;seg_pos
op_increment
suffix:semicolon
id|pos-&gt;seg_byte_pos
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;bytes moved out of deblock-buffer: %d&quot;
comma
id|cnt
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/* note: we store the segment id of the segment that is inside the&n; * deblock buffer. This spares a lot of ftape_read_segment()s when we&n; * use small block-sizes. The block-size may be 1kb (SECTOR_SIZE). In&n; * this case a MTFSR 28 maybe still inside the same segment.&n; */
DECL|function|_zft_read
r_int
id|_zft_read
c_func
(paren
r_char
op_star
id|buff
comma
r_int
id|req_len
)paren
(brace
r_int
id|req_clipped
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|bytes_read
op_assign
l_int|0
suffix:semicolon
r_static
r_int
r_int
id|seg_sz
op_assign
l_int|0
suffix:semicolon
r_static
r_const
id|zft_volinfo
op_star
id|volume
op_assign
l_int|NULL
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|zft_resid
op_assign
id|req_len
suffix:semicolon
id|result
op_assign
id|check_read_access
c_func
(paren
op_amp
id|req_len
comma
op_amp
id|volume
comma
op_amp
id|req_clipped
comma
op_amp
id|zft_pos
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|result
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* nothing special */
r_case
l_int|1
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;EOD reached&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
multiline_comment|/* EOD */
r_default
suffix:colon
id|TRACE_ABORT
c_func
(paren
id|result
comma
id|ft_t_noise
comma
l_string|&quot;check_read_access() failed with result %d&quot;
comma
id|result
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
r_while
c_loop
(paren
id|req_len
OG
l_int|0
)paren
(brace
multiline_comment|/*  Allow escape from this loop on signal !&n;&t;&t; */
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
multiline_comment|/* buf_len_rd == 0 means that we need to read a new&n;&t;&t; * segment.&n;&t;&t; */
r_if
c_cond
(paren
id|buf_len_rd
op_eq
l_int|0
)paren
(brace
r_while
c_loop
(paren
(paren
id|result
op_assign
id|zft_fetch_segment
c_func
(paren
id|zft_pos.seg_pos
comma
id|zft_deblock_buf
comma
id|FT_RD_AHEAD
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|zft_pos.seg_pos
op_increment
suffix:semicolon
id|zft_pos.seg_byte_pos
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|zft_resid
op_sub_assign
id|bytes_read
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
id|result
comma
id|ft_t_noise
comma
l_string|&quot;zft_fetch_segment(): %d&quot;
comma
id|result
)paren
suffix:semicolon
)brace
id|seg_sz
op_assign
id|result
suffix:semicolon
id|buf_len_rd
op_assign
id|seg_sz
op_minus
id|zft_pos.seg_byte_pos
suffix:semicolon
)brace
id|TRACE_CATCH
c_func
(paren
id|result
op_assign
id|empty_deblock_buf
c_func
(paren
id|buff
comma
id|req_len
comma
id|zft_deblock_buf
comma
id|seg_sz
comma
op_amp
id|zft_pos
comma
id|volume
)paren
comma
id|zft_resid
op_sub_assign
id|bytes_read
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;bytes just read: %d&quot;
comma
id|result
)paren
suffix:semicolon
id|bytes_read
op_add_assign
id|result
suffix:semicolon
multiline_comment|/* what we got so far       */
id|buff
op_add_assign
id|result
suffix:semicolon
multiline_comment|/* index in user-buffer     */
id|req_len
op_sub_assign
id|result
suffix:semicolon
multiline_comment|/* what&squot;s left from req_len */
)brace
multiline_comment|/* while (req_len  &gt; 0) */
r_if
c_cond
(paren
id|req_clipped
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;maybe partial count because of eof mark&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_just_before_eof
op_logical_and
id|bytes_read
op_eq
l_int|0
)paren
(brace
multiline_comment|/* req_len was &gt; 0, but user didn&squot;t get&n;&t;&t;&t; * anything the user has read in the eof-mark &n;&t;&t;&t; */
id|zft_move_past_eof
c_func
(paren
op_amp
id|zft_pos
)paren
suffix:semicolon
id|ftape_abort_operation
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* don&squot;t skip to the next file before the user&n;&t;&t;&t; * tried to read a second time past EOF Just&n;&t;&t;&t; * mark that we are at EOF and maybe decrement&n;&t;&t;&t; * zft_seg_pos to stay in the same volume;&n;&t;&t;&t; */
id|zft_just_before_eof
op_assign
l_int|1
suffix:semicolon
id|zft_position_before_eof
c_func
(paren
op_amp
id|zft_pos
comma
id|volume
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;just before eof&quot;
)paren
suffix:semicolon
)brace
)brace
id|zft_resid
op_sub_assign
id|result
suffix:semicolon
multiline_comment|/* for MTSTATUS       */
id|TRACE_EXIT
id|bytes_read
suffix:semicolon
)brace
eof
