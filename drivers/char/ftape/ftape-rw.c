multiline_comment|/*&n; *      Copyright (C) 1993-1995 Bas Laarhoven.&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; $Source: /home/bas/distr/ftape-2.03b/RCS/ftape-rw.c,v $&n; $Author: bas $&n; *&n; $Revision: 1.54 $&n; $Date: 1995/05/27 08:55:27 $&n; $State: Beta $&n; *&n; *      This file contains some common code for the segment read and segment&n; *      write routines for the QIC-117 floppy-tape driver for Linux.&n; */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &quot;tracing.h&quot;
macro_line|#include &quot;ftape-rw.h&quot;
macro_line|#include &quot;fdc-io.h&quot;
macro_line|#include &quot;kernel-interface.h&quot;
macro_line|#include &quot;qic117.h&quot;
macro_line|#include &quot;ftape-io.h&quot;
macro_line|#include &quot;ftape-ctl.h&quot;
macro_line|#include &quot;ftape-read.h&quot;
macro_line|#include &quot;ftape-eof.h&quot;
macro_line|#include &quot;ecc.h&quot;
macro_line|#include &quot;ftape-bsm.h&quot;
multiline_comment|/*      Global vars.&n; */
DECL|variable|runner_status
r_volatile
r_enum
id|runner_status_enum
id|runner_status
op_assign
id|idle
suffix:semicolon
DECL|variable|deblock_buffer
id|byte
id|deblock_buffer
(braket
(paren
id|SECTORS_PER_SEGMENT
op_minus
l_int|3
)paren
op_star
id|SECTOR_SIZE
)braket
suffix:semicolon
DECL|variable|scratch_buffer
id|byte
id|scratch_buffer
(braket
(paren
id|SECTORS_PER_SEGMENT
op_minus
l_int|3
)paren
op_star
id|SECTOR_SIZE
)braket
suffix:semicolon
DECL|variable|buffer
id|buffer_struct
id|buffer
(braket
id|NR_BUFFERS
)braket
suffix:semicolon
DECL|variable|wait_intr
r_struct
id|wait_queue
op_star
id|wait_intr
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|head
r_volatile
r_int
id|head
suffix:semicolon
DECL|variable|tail
r_volatile
r_int
id|tail
suffix:semicolon
multiline_comment|/* not volatile but need same type as head */
DECL|variable|fdc_setup_error
r_int
id|fdc_setup_error
suffix:semicolon
DECL|variable|ftape_last_segment
id|ftape_last_segment_struct
id|ftape_last_segment
suffix:semicolon
DECL|variable|header_segment_1
r_int
id|header_segment_1
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|header_segment_2
r_int
id|header_segment_2
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|used_header_segment
r_int
id|used_header_segment
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|location
id|location_record
id|location
op_assign
(brace
op_minus
l_int|1
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|tape_running
r_volatile
r_int
id|tape_running
op_assign
l_int|0
suffix:semicolon
DECL|variable|format_code
id|format_type
id|format_code
suffix:semicolon
multiline_comment|/*      Local vars.&n; */
DECL|variable|overrun_count_offset
r_static
r_int
id|overrun_count_offset
op_assign
l_int|0
suffix:semicolon
DECL|variable|inhibit_correction
r_static
r_int
id|inhibit_correction
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*      Increment cyclic buffer nr.&n; */
id|buffer_struct
op_star
DECL|function|next_buffer
id|next_buffer
c_func
(paren
r_volatile
r_int
op_star
id|x
)paren
(brace
r_if
c_cond
(paren
op_increment
op_star
id|x
op_ge
id|NR_BUFFERS
)paren
(brace
op_star
id|x
op_assign
l_int|0
suffix:semicolon
)brace
r_return
op_amp
id|buffer
(braket
op_star
id|x
)braket
suffix:semicolon
)brace
DECL|function|valid_segment_no
r_int
id|valid_segment_no
c_func
(paren
r_int
id|segment
)paren
(brace
r_return
(paren
id|segment
op_ge
id|first_data_segment
op_logical_and
id|segment
op_le
id|ftape_last_segment.id
)paren
suffix:semicolon
)brace
multiline_comment|/*      Count nr of 1&squot;s in pattern.&n; */
DECL|function|count_ones
r_int
id|count_ones
c_func
(paren
r_int
r_int
id|mask
)paren
(brace
r_int
id|bits
suffix:semicolon
r_for
c_loop
(paren
id|bits
op_assign
l_int|0
suffix:semicolon
id|mask
op_ne
l_int|0
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|1
)paren
(brace
op_increment
id|bits
suffix:semicolon
)brace
)brace
r_return
id|bits
suffix:semicolon
)brace
multiline_comment|/*      Calculate Floppy Disk Controller and DMA parameters for a segment.&n; *      head:   selects buffer struct in array.&n; *      offset: number of physical sectors to skip (including bad ones).&n; *      count:  number of physical sectors to handle (including bad ones).&n; */
DECL|function|setup_segment
r_static
r_int
id|setup_segment
c_func
(paren
id|buffer_struct
op_star
id|buff
comma
r_int
r_int
id|segment_id
comma
r_int
r_int
id|sector_offset
comma
r_int
r_int
id|sector_count
comma
r_int
id|retry
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;setup_segment&quot;
)paren
suffix:semicolon
r_int
r_int
id|offset_mask
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
id|buff-&gt;segment_id
op_assign
id|segment_id
suffix:semicolon
id|buff-&gt;sector_offset
op_assign
id|sector_offset
suffix:semicolon
id|buff-&gt;remaining
op_assign
id|sector_count
suffix:semicolon
id|buff-&gt;head
op_assign
id|segment_id
op_div
id|segments_per_head
suffix:semicolon
id|buff-&gt;cyl
op_assign
(paren
id|segment_id
op_mod
id|segments_per_head
)paren
op_div
id|segments_per_cylinder
suffix:semicolon
id|buff-&gt;sect
op_assign
(paren
id|segment_id
op_mod
id|segments_per_cylinder
)paren
op_star
id|SECTORS_PER_SEGMENT
op_plus
l_int|1
suffix:semicolon
id|buff-&gt;deleted
op_assign
l_int|0
suffix:semicolon
id|offset_mask
op_assign
(paren
l_int|1
op_lshift
id|buff-&gt;sector_offset
)paren
op_minus
l_int|1
suffix:semicolon
id|mask
op_assign
id|get_bad_sector_entry
c_func
(paren
id|segment_id
)paren
op_amp
id|offset_mask
suffix:semicolon
r_while
c_loop
(paren
id|mask
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|1
)paren
(brace
id|offset_mask
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* don&squot;t count bad sector */
)brace
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|buff-&gt;data_offset
op_assign
id|count_ones
c_func
(paren
id|offset_mask
)paren
suffix:semicolon
multiline_comment|/* good sectors to skip */
id|buff-&gt;ptr
op_assign
id|buff-&gt;address
op_plus
id|buff-&gt;data_offset
op_star
id|SECTOR_SIZE
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;data offset = %d sectors&quot;
comma
id|buff-&gt;data_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retry
)paren
(brace
id|buff-&gt;soft_error_map
op_and_assign
id|offset_mask
suffix:semicolon
multiline_comment|/* keep skipped part */
)brace
r_else
(brace
id|buff-&gt;hard_error_map
op_assign
id|buff-&gt;soft_error_map
op_assign
l_int|0
suffix:semicolon
)brace
id|buff-&gt;bad_sector_map
op_assign
id|get_bad_sector_entry
c_func
(paren
id|buff-&gt;segment_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff-&gt;bad_sector_map
op_ne
l_int|0
)paren
(brace
id|TRACEx2
c_func
(paren
l_int|4
comma
l_string|&quot;segment: %d, bad sector map: %08lx&quot;
comma
id|buff-&gt;segment_id
comma
id|buff-&gt;bad_sector_map
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;segment: %d&quot;
comma
id|buff-&gt;segment_id
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buff-&gt;sector_offset
OG
l_int|0
)paren
(brace
id|buff-&gt;bad_sector_map
op_rshift_assign
id|buff-&gt;sector_offset
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buff-&gt;sector_offset
op_ne
l_int|0
op_logical_or
id|buff-&gt;remaining
op_ne
id|SECTORS_PER_SEGMENT
)paren
(brace
id|TRACEx2
c_func
(paren
l_int|5
comma
l_string|&quot;sector offset = %d, count = %d&quot;
comma
id|buff-&gt;sector_offset
comma
id|buff-&gt;remaining
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *    Segments with 3 or less sectors are not written with&n;&t; *    valid data because there is no space left for the ecc.&n;&t; *    The data written is whatever happens to be in the buffer.&n;&t; *    Reading such a segment will return a zero byte-count.&n;&t; *    To allow us to read/write segments with all bad sectors&n;&t; *    we fake one readable sector in the segment. This prevents&n;&t; *    having to handle these segments in a very special way.&n;&t; *    It is not important if the reading of this bad sector&n;&t; *    fails or not (the data is ignored). It is only read to&n;&t; *    keep the driver running.&n;&t; *    The QIC-40/80 spec. has no information on how to handle&n;&t; *    this case, so this is my interpretation.&n;&t; */
r_if
c_cond
(paren
id|buff-&gt;bad_sector_map
op_eq
id|EMPTY_SEGMENT
)paren
(brace
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;empty segment, fake first sector good&quot;
)paren
suffix:semicolon
id|buff-&gt;bad_sector_map
op_assign
id|FAKE_SEGMENT
suffix:semicolon
)brace
id|fdc_setup_error
op_assign
l_int|0
suffix:semicolon
id|buff-&gt;next_segment
op_assign
id|segment_id
op_plus
l_int|1
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*      Calculate Floppy Disk Controller and DMA parameters for a new segment.&n; */
DECL|function|setup_new_segment
r_int
id|setup_new_segment
c_func
(paren
id|buffer_struct
op_star
id|buff
comma
r_int
r_int
id|segment_id
comma
r_int
id|skip
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;setup_new_segment&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|old_segment_id
op_assign
op_minus
l_int|1
suffix:semicolon
r_static
r_int
id|old_ftape_state
op_assign
id|idle
suffix:semicolon
r_int
id|retry
op_assign
l_int|0
suffix:semicolon
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
r_int
id|count
op_assign
id|SECTORS_PER_SEGMENT
suffix:semicolon
id|TRACEx3
c_func
(paren
l_int|5
comma
l_string|&quot;%s segment %d (old = %d)&quot;
comma
(paren
id|ftape_state
op_eq
id|reading
)paren
ques
c_cond
l_string|&quot;reading&quot;
suffix:colon
l_string|&quot;writing&quot;
comma
id|segment_id
comma
id|old_segment_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftape_state
op_ne
id|old_ftape_state
)paren
(brace
multiline_comment|/* when verifying */
id|old_segment_id
op_assign
op_minus
l_int|1
suffix:semicolon
id|old_ftape_state
op_assign
id|ftape_state
suffix:semicolon
)brace
r_if
c_cond
(paren
id|segment_id
op_eq
id|old_segment_id
)paren
(brace
op_increment
id|buff-&gt;retry
suffix:semicolon
op_increment
id|history.retries
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;setting up for retry nr %d&quot;
comma
id|buff-&gt;retry
)paren
suffix:semicolon
id|retry
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|skip
op_logical_and
id|buff-&gt;skip
OG
l_int|0
)paren
(brace
multiline_comment|/* allow skip on retry */
id|offset
op_assign
id|buff-&gt;skip
suffix:semicolon
id|count
op_sub_assign
id|offset
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;skipping %d sectors&quot;
comma
id|offset
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|buff-&gt;retry
op_assign
l_int|0
suffix:semicolon
id|buff-&gt;skip
op_assign
l_int|0
suffix:semicolon
id|old_segment_id
op_assign
id|segment_id
suffix:semicolon
)brace
id|result
op_assign
id|setup_segment
c_func
(paren
id|buff
comma
id|segment_id
comma
id|offset
comma
id|count
comma
id|retry
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*      Determine size of next cluster of good sectors.&n; */
DECL|function|calc_next_cluster
r_int
id|calc_next_cluster
c_func
(paren
id|buffer_struct
op_star
id|buff
)paren
(brace
multiline_comment|/* Skip bad sectors.&n;&t; */
r_while
c_loop
(paren
id|buff-&gt;remaining
OG
l_int|0
op_logical_and
(paren
id|buff-&gt;bad_sector_map
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|buff-&gt;bad_sector_map
op_rshift_assign
l_int|1
suffix:semicolon
op_increment
id|buff-&gt;sector_offset
suffix:semicolon
op_decrement
id|buff-&gt;remaining
suffix:semicolon
)brace
multiline_comment|/* Find next cluster of good sectors&n;&t; */
r_if
c_cond
(paren
id|buff-&gt;bad_sector_map
op_eq
l_int|0
)paren
(brace
multiline_comment|/* speed up */
id|buff-&gt;sector_count
op_assign
id|buff-&gt;remaining
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|map
op_assign
id|buff-&gt;bad_sector_map
suffix:semicolon
id|buff-&gt;sector_count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|buff-&gt;sector_count
OL
id|buff-&gt;remaining
op_logical_and
(paren
id|map
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
op_increment
id|buff-&gt;sector_count
suffix:semicolon
id|map
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|buff-&gt;sector_count
suffix:semicolon
)brace
DECL|function|check_bot_eot
r_int
id|check_bot_eot
c_func
(paren
r_int
id|status
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;check_bot_eot&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|QIC_STATUS_AT_BOT
op_or
id|QIC_STATUS_AT_EOT
)paren
)paren
(brace
id|location.bot
op_assign
(paren
(paren
id|location.track
op_amp
l_int|1
)paren
op_eq
l_int|0
ques
c_cond
(paren
id|status
op_amp
id|QIC_STATUS_AT_BOT
)paren
suffix:colon
(paren
id|status
op_amp
id|QIC_STATUS_AT_EOT
)paren
)paren
suffix:semicolon
id|location.eot
op_assign
op_logical_neg
id|location.bot
suffix:semicolon
id|location.segment
op_assign
(paren
id|location.track
op_plus
(paren
id|location.bot
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
)paren
op_star
id|segments_per_track
op_minus
l_int|1
suffix:semicolon
id|location.sector
op_assign
op_minus
l_int|1
suffix:semicolon
id|location.known
op_assign
l_int|1
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;tape at logical %s&quot;
comma
id|location.bot
ques
c_cond
l_string|&quot;bot&quot;
suffix:colon
l_string|&quot;eot&quot;
)paren
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;segment = %d&quot;
comma
id|location.segment
)paren
suffix:semicolon
)brace
r_else
(brace
id|location.known
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|location.known
suffix:semicolon
)brace
multiline_comment|/*      Read Id of first sector passing tape head.&n; */
DECL|function|ftape_read_id
r_int
id|ftape_read_id
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_read_id&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|status
suffix:semicolon
id|byte
id|out
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Assume tape is running on entry, be able to handle&n;&t; * situation where it stopped or is stopping.&n;&t; */
id|location.known
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default is location not known */
id|out
(braket
l_int|0
)braket
op_assign
id|FDC_READID
suffix:semicolon
id|out
(braket
l_int|1
)braket
op_assign
id|FTAPE_UNIT
suffix:semicolon
id|result
op_assign
id|fdc_command
c_func
(paren
id|out
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;fdc_command failed&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
id|fdc_interrupt_wait
c_func
(paren
l_int|20
op_star
id|SECOND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|fdc_sect
op_eq
l_int|0
)paren
(brace
id|result
op_assign
id|ftape_report_drive_status
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
id|QIC_STATUS_READY
)paren
(brace
id|tape_running
op_assign
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;tape has stopped&quot;
)paren
suffix:semicolon
id|check_bot_eot
c_func
(paren
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|location.known
)paren
(brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*  If read-id failed because of a hard or soft&n;&t;&t;&t;&t;&t;&t; *  error, return an error. Higher level must retry!&n;&t;&t;&t;&t;&t;&t; */
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|location.known
op_assign
l_int|1
suffix:semicolon
id|location.segment
op_assign
(paren
id|segments_per_head
op_star
id|fdc_head
op_plus
id|segments_per_cylinder
op_star
id|fdc_cyl
op_plus
(paren
id|fdc_sect
op_minus
l_int|1
)paren
op_div
id|SECTORS_PER_SEGMENT
)paren
suffix:semicolon
id|location.sector
op_assign
(paren
id|fdc_sect
op_minus
l_int|1
)paren
op_mod
id|SECTORS_PER_SEGMENT
suffix:semicolon
id|location.eot
op_assign
id|location.bot
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ETIME
)paren
(brace
multiline_comment|/*  Didn&squot;t find id on tape, must be near end: Wait until stopped.&n;&t;&t;&t; */
id|result
op_assign
id|ftape_ready_wait
c_func
(paren
id|FOREVER
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|tape_running
op_assign
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;tape has stopped&quot;
)paren
suffix:semicolon
id|check_bot_eot
c_func
(paren
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|location.known
)paren
(brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Interrupted or otherwise failing fdc_interrupt_wait()&n;&t;&t;&t; */
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;fdc_interrupt_wait failed :(&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|location.known
)paren
(brace
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;no id found&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|location.sector
op_eq
l_int|0
)paren
(brace
id|TRACEx2
c_func
(paren
l_int|5
comma
l_string|&quot;passing segment %d/%d&quot;
comma
id|location.segment
comma
id|location.sector
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACEx2
c_func
(paren
l_int|6
comma
l_string|&quot;passing segment %d/%d&quot;
comma
id|location.segment
comma
id|location.sector
)paren
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|logical_forward
r_static
r_int
id|logical_forward
c_func
(paren
r_void
)paren
(brace
id|tape_running
op_assign
l_int|1
suffix:semicolon
r_return
id|ftape_command
c_func
(paren
id|QIC_LOGICAL_FORWARD
)paren
suffix:semicolon
)brace
DECL|function|stop_tape
r_static
r_int
id|stop_tape
c_func
(paren
r_int
op_star
id|pstatus
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;stop_tape&quot;
)paren
suffix:semicolon
r_int
id|retry
op_assign
l_int|0
suffix:semicolon
r_int
id|result
suffix:semicolon
r_do
(brace
id|result
op_assign
id|ftape_command_wait
c_func
(paren
id|QIC_STOP_TAPE
comma
id|timeout.stop
comma
id|pstatus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|pstatus
op_amp
id|QIC_STATUS_READY
)paren
op_eq
l_int|0
)paren
(brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|tape_running
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|result
OL
l_int|0
op_logical_and
op_increment
id|retry
op_le
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;failed ! (fatal)&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|ftape_dumb_stop
r_int
id|ftape_dumb_stop
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;ftape_dumb_stop&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|status
suffix:semicolon
multiline_comment|/* Abort current fdc operation if it&squot;s busy (probably read&n;&t; * or write operation pending) with a reset.&n;&t; */
id|result
op_assign
id|fdc_ready_wait
c_func
(paren
l_int|100
multiline_comment|/* usec */
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;aborting fdc operation&quot;
)paren
suffix:semicolon
id|fdc_reset
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*  Reading id&squot;s after the last segment on a track may fail&n;&t; *  but eventually the drive will become ready (logical eot).&n;&t; */
id|result
op_assign
id|ftape_report_drive_status
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
id|location.known
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_and
id|status
op_amp
id|QIC_STATUS_READY
)paren
(brace
multiline_comment|/* Tape is not running any more.&n;&t;&t;&t; */
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;tape already halted&quot;
)paren
suffix:semicolon
id|check_bot_eot
c_func
(paren
id|status
)paren
suffix:semicolon
id|tape_running
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tape_running
)paren
(brace
multiline_comment|/* Tape is (was) still moving.&n;&t;&t;&t; */
macro_line|#ifdef TESTING
id|ftape_read_id
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|result
op_assign
id|stop_tape
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Tape not yet ready but stopped.&n;&t;&t;&t; */
id|result
op_assign
id|ftape_ready_wait
c_func
(paren
id|timeout.pause
comma
op_amp
id|status
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|tape_running
)paren
suffix:semicolon
macro_line|#ifndef TESTING
id|location.known
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*      Wait until runner has finished tail buffer.&n; */
DECL|function|wait_segment
r_int
id|wait_segment
c_func
(paren
id|buffer_state_enum
id|state
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;wait_segment&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|buffer
(braket
id|tail
)braket
dot
id|status
op_eq
id|state
)paren
(brace
multiline_comment|/*  First buffer still being worked on, wait up to timeout.&n;&t;&t; */
id|result
op_assign
id|fdc_interrupt_wait
c_func
(paren
l_int|50
op_star
id|SECOND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|result
op_ne
op_minus
id|EINTR
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;fdc_interrupt_wait failed&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|ETIME
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdc_setup_error
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;setup error&quot;
)paren
suffix:semicolon
multiline_comment|/* recover... */
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* forward */
r_static
r_int
id|seek_forward
c_func
(paren
r_int
id|segment_id
)paren
suffix:semicolon
DECL|function|fast_seek
r_int
id|fast_seek
c_func
(paren
r_int
id|count
comma
r_int
id|reverse
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;fast_seek&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
multiline_comment|/*  If positioned at begin or end of tape, fast seeking needs&n;&t;&t; *  special treatment.&n;&t;&t; *  Starting from logical bot needs a (slow) seek to the first&n;&t;&t; *  segment before the high speed seek. Most drives do this&n;&t;&t; *  automatically but some older don&squot;t, so we treat them&n;&t;&t; *  all the same.&n;&t;&t; *  Starting from logical eot is even more difficult because&n;&t;&t; *  we cannot (slow) reverse seek to the last segment.&n;&t;&t; *  TO BE IMPLEMENTED.&n;&t;&t; */
id|inhibit_correction
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|location.known
op_logical_and
(paren
(paren
id|location.bot
op_logical_and
op_logical_neg
id|reverse
)paren
op_logical_or
(paren
id|location.eot
op_logical_and
id|reverse
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|reverse
)paren
(brace
multiline_comment|/*  (slow) skip to first segment on a track&n;&t;&t;&t;&t; */
id|seek_forward
c_func
(paren
id|location.track
op_star
id|segments_per_track
)paren
suffix:semicolon
op_decrement
id|count
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  When seeking backwards from end-of-tape the number&n;&t;&t;&t;&t; *  of erased gaps found seems to be higher than expected.&n;&t;&t;&t;&t; *  Therefor the drive must skip some more segments than&n;&t;&t;&t;&t; *  calculated, but we don&squot;t know how many.&n;&t;&t;&t;&t; *  Thus we will prevent the re-calculation of offset&n;&t;&t;&t;&t; *  and overshoot when seeking backwards.&n;&t;&t;&t;&t; */
id|inhibit_correction
op_assign
l_int|1
suffix:semicolon
id|count
op_add_assign
l_int|3
suffix:semicolon
multiline_comment|/* best guess */
)brace
)brace
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;warning: zero or negative count: %d&quot;
comma
id|count
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|nibbles
op_assign
id|count
OG
l_int|255
ques
c_cond
l_int|3
suffix:colon
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|4095
)paren
(brace
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;skipping clipped at 4095 segment&quot;
)paren
suffix:semicolon
id|count
op_assign
l_int|4095
suffix:semicolon
)brace
multiline_comment|/* Issue this tape command first. */
r_if
c_cond
(paren
op_logical_neg
id|reverse
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;skipping %d segment(s)&quot;
comma
id|count
)paren
suffix:semicolon
id|result
op_assign
id|ftape_command
c_func
(paren
id|nibbles
op_eq
l_int|3
ques
c_cond
id|QIC_SKIP_EXTENDED_FORWARD
suffix:colon
id|QIC_SKIP_FORWARD
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;backing up %d segment(s)&quot;
comma
id|count
)paren
suffix:semicolon
id|result
op_assign
id|ftape_command
c_func
(paren
id|nibbles
op_eq
l_int|3
ques
c_cond
id|QIC_SKIP_EXTENDED_REVERSE
suffix:colon
id|QIC_SKIP_REVERSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;Skip command failed&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
op_decrement
id|count
suffix:semicolon
multiline_comment|/* 0 means one gap etc. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nibbles
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|result
op_assign
id|ftape_parameter
c_func
(paren
id|count
op_amp
l_int|15
)paren
suffix:semicolon
id|count
op_div_assign
l_int|16
suffix:semicolon
)brace
)brace
id|result
op_assign
id|ftape_ready_wait
c_func
(paren
id|timeout.rewind
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|tape_running
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|validate
r_static
r_int
id|validate
c_func
(paren
r_int
id|id
)paren
(brace
multiline_comment|/*  Check to see if position found is off-track as reported once.&n;&t; *  Because all tracks in one direction lie next to each other,&n;&t; *  if off-track the error will be approximately 2 * segments_per_track.&n;&t; */
r_if
c_cond
(paren
id|location.track
op_eq
op_minus
l_int|1
)paren
(brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* unforeseen situation, don&squot;t generate error */
)brace
r_else
(brace
multiline_comment|/*  Use margin of segments_per_track on both sides because ftape&n;&t;&t; *  needs some margin and the error we&squot;re looking for is much larger !&n;&t;&t; */
r_int
id|lo
op_assign
(paren
id|location.track
op_minus
l_int|1
)paren
op_star
id|segments_per_track
suffix:semicolon
r_int
id|hi
op_assign
(paren
id|location.track
op_plus
l_int|2
)paren
op_star
id|segments_per_track
suffix:semicolon
r_return
(paren
id|id
op_ge
id|lo
op_logical_and
id|id
OL
id|hi
)paren
suffix:semicolon
)brace
)brace
DECL|function|seek_forward
r_static
r_int
id|seek_forward
c_func
(paren
r_int
id|segment_id
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;seek_forward&quot;
)paren
suffix:semicolon
r_int
id|failures
op_assign
l_int|0
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|count
suffix:semicolon
r_static
r_int
id|margin
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* fixed: stop this before target */
r_static
r_int
id|overshoot
op_assign
l_int|1
suffix:semicolon
r_static
r_int
id|min_count
op_assign
l_int|8
suffix:semicolon
r_int
id|expected
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|target
op_assign
id|segment_id
op_minus
id|margin
suffix:semicolon
r_int
id|fast_seeking
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|location.known
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;fatal: cannot seek from unknown location&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|validate
c_func
(paren
id|segment_id
)paren
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;fatal: head off track (bad hardware?)&quot;
)paren
suffix:semicolon
id|ftape_sleep
c_func
(paren
l_int|1
op_star
id|SECOND
)paren
suffix:semicolon
id|ftape_failure
op_assign
l_int|1
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
r_int
id|prev_segment
op_assign
id|location.segment
suffix:semicolon
id|TRACEx4
c_func
(paren
l_int|4
comma
l_string|&quot;from %d/%d to %d/0 - %d&quot;
comma
id|location.segment
comma
id|location.sector
comma
id|segment_id
comma
id|margin
)paren
suffix:semicolon
id|count
op_assign
id|target
op_minus
id|location.segment
op_minus
id|overshoot
suffix:semicolon
id|fast_seeking
op_assign
(paren
id|count
OG
id|min_count
op_plus
(paren
id|location.bot
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fast_seeking
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;fast skipping %d segments&quot;
comma
id|count
)paren
suffix:semicolon
id|expected
op_assign
id|segment_id
op_minus
id|margin
suffix:semicolon
id|fast_seek
c_func
(paren
id|count
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tape_running
)paren
(brace
id|logical_forward
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|location.segment
OL
id|segment_id
)paren
(brace
multiline_comment|/*  This requires at least one sector in a (bad) segment to&n;&t;&t;&t; *  have a valid and readable sector id !&n;&t;&t;&t; *  It looks like this is not guaranteed, so we must try&n;&t;&t;&t; *  to find a way to skip an EMPTY_SEGMENT. !!! FIXME !!!&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ftape_read_id
c_func
(paren
)paren
OL
l_int|0
op_logical_or
op_logical_neg
id|location.known
)paren
(brace
id|location.known
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tape_running
op_logical_or
op_increment
id|failures
OG
id|SECTORS_PER_SEGMENT
op_logical_or
(paren
id|current-&gt;signal
op_amp
id|_DONT_BLOCK
)paren
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;read_id failed completely&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;read_id failed, retry (%d)&quot;
comma
id|failures
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|fast_seeking
)paren
(brace
id|TRACEx4
c_func
(paren
l_int|4
comma
l_string|&quot;ended at %d/%d (%d,%d)&quot;
comma
id|location.segment
comma
id|location.sector
comma
id|overshoot
comma
id|inhibit_correction
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inhibit_correction
op_logical_and
(paren
id|location.segment
template_param
id|expected
op_plus
id|margin
)paren
)paren
(brace
r_int
id|error
op_assign
id|location.segment
op_minus
id|expected
suffix:semicolon
id|TRACEx2
c_func
(paren
l_int|4
comma
l_string|&quot;adjusting overshoot from %d to %d&quot;
comma
id|overshoot
comma
id|overshoot
op_plus
id|error
)paren
suffix:semicolon
id|overshoot
op_add_assign
id|error
suffix:semicolon
multiline_comment|/*  All overshoots have the same direction, so it should&n;&t;&t;&t;&t;&t; *  never become negative, but who knows.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|overshoot
template_param
l_int|10
)paren
(brace
r_if
c_cond
(paren
id|overshoot
OL
l_int|0
)paren
(brace
id|overshoot
op_assign
op_minus
l_int|5
suffix:semicolon
multiline_comment|/* keep sane value */
)brace
r_else
(brace
id|overshoot
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* keep sane value */
)brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;clipped overshoot to %d&quot;
comma
id|overshoot
)paren
suffix:semicolon
)brace
)brace
id|fast_seeking
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|location.known
)paren
(brace
r_if
c_cond
(paren
id|location.segment
OG
id|prev_segment
op_plus
l_int|1
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;missed segment %d while skipping&quot;
comma
id|prev_segment
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|prev_segment
op_assign
id|location.segment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|location.segment
OG
id|segment_id
)paren
(brace
id|TRACEx2
c_func
(paren
l_int|4
comma
l_string|&quot;failed: skip ended at segment %d/%d&quot;
comma
id|location.segment
comma
id|location.sector
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|skip_reverse
r_static
r_int
id|skip_reverse
c_func
(paren
r_int
id|segment_id
comma
r_int
op_star
id|pstatus
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;skip_reverse&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|failures
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|overshoot
op_assign
l_int|1
suffix:semicolon
r_static
r_int
id|min_rewind
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* 1 + overshoot */
r_static
r_const
r_int
id|margin
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* stop this before target */
r_int
id|expected
op_assign
l_int|0
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|short_seek
suffix:semicolon
r_int
id|target
op_assign
id|segment_id
op_minus
id|margin
suffix:semicolon
r_if
c_cond
(paren
id|location.known
op_logical_and
op_logical_neg
id|validate
c_func
(paren
id|segment_id
)paren
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;fatal: head off track (bad hardware?)&quot;
)paren
suffix:semicolon
id|ftape_sleep
c_func
(paren
l_int|1
op_star
id|SECOND
)paren
suffix:semicolon
id|ftape_failure
op_assign
l_int|1
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|location.known
)paren
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;warning: location not known&quot;
)paren
suffix:semicolon
)brace
id|TRACEx4
c_func
(paren
l_int|4
comma
l_string|&quot;from %d/%d to %d/0 - %d&quot;
comma
id|location.segment
comma
id|location.sector
comma
id|segment_id
comma
id|margin
)paren
suffix:semicolon
multiline_comment|/*  min_rewind == 1 + overshoot_when_doing_minimum_rewind&n;&t;&t;&t; *  overshoot  == overshoot_when_doing_larger_rewind&n;&t;&t;&t; *  Initially min_rewind == 1 + overshoot, optimization&n;&t;&t;&t; *  of both values will be done separately.&n;&t;&t;&t; *  overshoot and min_rewind can be negative as both are&n;&t;&t;&t; *  sums of three components:&n;&t;&t;&t; *  any_overshoot == rewind_overshoot - stop_overshoot - start_overshoot&n;&t;&t;&t; */
r_if
c_cond
(paren
id|location.segment
op_minus
id|target
op_minus
(paren
id|min_rewind
op_minus
l_int|1
)paren
OL
l_int|1
)paren
(brace
id|short_seek
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|count
op_assign
id|location.segment
op_minus
id|target
op_minus
id|overshoot
suffix:semicolon
id|short_seek
op_assign
(paren
id|count
OL
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|short_seek
)paren
(brace
id|count
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* do shortest rewind */
id|expected
op_assign
id|location.segment
op_minus
id|min_rewind
suffix:semicolon
r_if
c_cond
(paren
id|expected
op_div
id|segments_per_track
op_ne
id|location.track
)paren
(brace
id|expected
op_assign
id|location.track
op_star
id|segments_per_track
suffix:semicolon
)brace
)brace
r_else
(brace
id|expected
op_assign
id|target
suffix:semicolon
)brace
id|fast_seek
c_func
(paren
id|count
comma
l_int|1
)paren
suffix:semicolon
id|logical_forward
c_func
(paren
)paren
suffix:semicolon
id|result
op_assign
id|ftape_read_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_and
id|location.known
)paren
(brace
id|TRACEx5
c_func
(paren
l_int|4
comma
l_string|&quot;ended at %d/%d (%d,%d,%d)&quot;
comma
id|location.segment
comma
id|location.sector
comma
id|min_rewind
comma
id|overshoot
comma
id|inhibit_correction
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inhibit_correction
op_logical_and
(paren
id|location.segment
template_param
id|expected
op_plus
id|margin
)paren
)paren
(brace
r_int
id|error
op_assign
id|expected
op_minus
id|location.segment
suffix:semicolon
r_if
c_cond
(paren
id|short_seek
)paren
(brace
id|TRACEx2
c_func
(paren
l_int|4
comma
l_string|&quot;adjusting min_rewind from %d to %d&quot;
comma
id|min_rewind
comma
id|min_rewind
op_plus
id|error
)paren
suffix:semicolon
id|min_rewind
op_add_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
id|min_rewind
OL
op_minus
l_int|5
)paren
(brace
multiline_comment|/* is this right ? FIXME ! */
id|min_rewind
op_assign
op_minus
l_int|5
suffix:semicolon
multiline_comment|/* keep sane value */
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;clipped min_rewind to %d&quot;
comma
id|min_rewind
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|TRACEx2
c_func
(paren
l_int|4
comma
l_string|&quot;adjusting overshoot from %d to %d&quot;
comma
id|overshoot
comma
id|overshoot
op_plus
id|error
)paren
suffix:semicolon
id|overshoot
op_add_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
id|overshoot
template_param
l_int|10
)paren
(brace
r_if
c_cond
(paren
id|overshoot
OL
l_int|0
)paren
(brace
id|overshoot
op_assign
op_minus
l_int|5
suffix:semicolon
multiline_comment|/* keep sane value */
)brace
r_else
(brace
id|overshoot
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* keep sane value */
)brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;clipped overshoot to %d&quot;
comma
id|overshoot
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|tape_running
op_logical_and
op_logical_neg
id|location.known
)paren
op_logical_or
op_increment
id|failures
OG
id|SECTORS_PER_SEGMENT
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;read_id failed completely&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;ftape_read_id failed, retry (%d)&quot;
comma
id|failures
)paren
suffix:semicolon
)brace
id|result
op_assign
id|ftape_report_drive_status
c_func
(paren
id|pstatus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACEi
c_func
(paren
l_int|1
comma
l_string|&quot;ftape_report_drive_status failed with code&quot;
comma
id|result
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|location.segment
OG
id|segment_id
op_logical_and
(paren
id|current-&gt;signal
op_amp
id|_DONT_BLOCK
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|location.known
)paren
(brace
id|TRACEx2
c_func
(paren
l_int|4
comma
l_string|&quot;current location: %d/%d&quot;
comma
id|location.segment
comma
id|location.sector
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|determine_position
r_static
r_int
id|determine_position
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;determine_position&quot;
)paren
suffix:semicolon
r_int
id|retry
op_assign
l_int|0
suffix:semicolon
r_int
id|fatal
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tape_running
)paren
(brace
multiline_comment|/*  This should only happen if tape is stopped by isr.&n;&t;&t; */
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;waiting for tape stop&quot;
)paren
suffix:semicolon
id|result
op_assign
id|ftape_ready_wait
c_func
(paren
id|timeout.pause
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;drive still running (fatal)&quot;
)paren
suffix:semicolon
id|tape_running
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* ? */
)brace
)brace
r_else
(brace
id|ftape_report_drive_status
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|QIC_STATUS_READY
)paren
(brace
multiline_comment|/*  Drive must be ready to check error state !&n;&t;&t; */
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;drive is ready&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|QIC_STATUS_ERROR
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
id|command
suffix:semicolon
multiline_comment|/*  Report and clear error state, try to continue.&n;&t;&t;&t; */
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;error status set&quot;
)paren
suffix:semicolon
id|ftape_report_error
c_func
(paren
op_amp
id|error
comma
op_amp
id|command
comma
l_int|1
)paren
suffix:semicolon
id|ftape_ready_wait
c_func
(paren
id|timeout.reset
comma
op_amp
id|status
)paren
suffix:semicolon
id|tape_running
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ? */
)brace
r_if
c_cond
(paren
id|check_bot_eot
c_func
(paren
id|status
)paren
)paren
(brace
r_if
c_cond
(paren
id|location.bot
)paren
(brace
r_if
c_cond
(paren
(paren
id|status
op_amp
id|QIC_STATUS_READY
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* tape moving away from bot/eot, let&squot;s see if we&n;&t;&t;&t;&t;&t; * can catch up with the first segment on this track.&n;&t;&t;&t;&t;&t; */
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;start tape from logical bot&quot;
)paren
suffix:semicolon
id|logical_forward
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* start moving */
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|status
op_amp
id|QIC_STATUS_READY
)paren
op_eq
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;waiting for logical end of track&quot;
)paren
suffix:semicolon
id|result
op_assign
id|ftape_ready_wait
c_func
(paren
id|timeout.reset
comma
op_amp
id|status
)paren
suffix:semicolon
multiline_comment|/* error handling needed ? */
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;tape at logical end of track&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;start tape&quot;
)paren
suffix:semicolon
id|logical_forward
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* start moving */
id|location.known
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not cleared by logical forward ! */
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|location.known
)paren
(brace
multiline_comment|/* tape should be moving now, start reading id&squot;s&n;&t;&t; */
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;location unknown&quot;
)paren
suffix:semicolon
r_do
(brace
id|result
op_assign
id|ftape_read_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/*  read-id somehow failed, tape may have reached end&n;&t;&t;&t;&t; *  or some other error happened.&n;&t;&t;&t;&t; */
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;read-id failed&quot;
)paren
suffix:semicolon
id|ftape_report_drive_status
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|QIC_STATUS_READY
)paren
(brace
id|tape_running
op_assign
l_int|0
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;tape stopped for unknown reason ! status = 0x%02x&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|QIC_STATUS_ERROR
)paren
(brace
id|fatal
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|check_bot_eot
c_func
(paren
id|status
)paren
)paren
(brace
id|result
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|fatal
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* oops, tape stopped but not at end ! */
)brace
)brace
)brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|result
OL
l_int|0
op_logical_and
op_logical_neg
id|fatal
op_logical_and
op_increment
id|retry
OL
id|SECTORS_PER_SEGMENT
)paren
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;tape is positioned at segment %d&quot;
comma
id|location.segment
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*      Get the tape running and position it just before the&n; *      requested segment.&n; *      Seek tape-track and reposition as needed.&n; */
DECL|function|ftape_start_tape
r_int
id|ftape_start_tape
c_func
(paren
r_int
id|segment_id
comma
r_int
id|sector_offset
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;ftape_start_tape&quot;
)paren
suffix:semicolon
r_int
id|track
op_assign
id|segment_id
op_div
id|segments_per_track
suffix:semicolon
r_int
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_int
id|status
suffix:semicolon
r_static
r_int
id|last_segment
op_assign
op_minus
l_int|1
suffix:semicolon
r_static
r_int
id|bad_bus_timing
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of segments passing the head between starting the tape&n;&t; * and being able to access the first sector.&n;&t; */
r_static
r_int
id|start_offset
op_assign
l_int|1
suffix:semicolon
r_int
id|retry
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If sector_offset &gt; 0, seek into wanted segment instead of&n;&t; * into previous.&n;&t; * This allows error recovery if a part of the segment is bad&n;&t; * (erased) causing the tape drive to generate an index pulse&n;&t; * thus causing a no-data error before the requested sector&n;&t; * is reached.&n;&t; */
id|tape_running
op_assign
l_int|0
suffix:semicolon
id|TRACEx3
c_func
(paren
l_int|4
comma
l_string|&quot;target segment: %d/%d%s&quot;
comma
id|segment_id
comma
id|sector_offset
comma
id|buffer
(braket
id|head
)braket
dot
id|retry
OG
l_int|0
ques
c_cond
l_string|&quot; retry&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
(braket
id|head
)braket
dot
id|retry
OG
l_int|0
)paren
(brace
multiline_comment|/* this is a retry */
r_if
c_cond
(paren
op_logical_neg
id|bad_bus_timing
op_logical_and
id|ftape_data_rate
op_eq
l_int|1
op_logical_and
id|history.overrun_errors
op_minus
id|overrun_count_offset
op_ge
l_int|8
)paren
(brace
id|ftape_set_data_rate
c_func
(paren
id|ftape_data_rate
op_plus
l_int|1
)paren
suffix:semicolon
id|bad_bus_timing
op_assign
l_int|1
suffix:semicolon
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;reduced datarate because of excessive overrun errors&quot;
)paren
suffix:semicolon
)brace
)brace
id|last_segment
op_assign
id|segment_id
suffix:semicolon
r_if
c_cond
(paren
id|location.track
op_ne
id|track
op_logical_or
(paren
id|might_be_off_track
op_logical_and
id|buffer
(braket
id|head
)braket
dot
id|retry
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* current track unknown or not equal to destination&n;&t;&t; */
id|ftape_ready_wait
c_func
(paren
id|timeout.seek
comma
op_amp
id|status
)paren
suffix:semicolon
id|ftape_seek_head_to_track
c_func
(paren
id|track
)paren
suffix:semicolon
id|overrun_count_offset
op_assign
id|history.overrun_errors
suffix:semicolon
)brace
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|location.known
)paren
(brace
id|determine_position
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*  Check if we are able to catch the requested segment in time.&n;&t;&t; */
r_if
c_cond
(paren
id|location.known
op_logical_and
id|location.segment
op_ge
id|segment_id
op_minus
(paren
(paren
id|tape_running
op_logical_or
id|location.bot
)paren
ques
c_cond
l_int|0
suffix:colon
id|start_offset
)paren
)paren
(brace
multiline_comment|/*  Too far ahead (in or past target segment).&n;&t;&t;&t; */
r_if
c_cond
(paren
id|tape_running
)paren
(brace
id|result
op_assign
id|stop_tape
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACEi
c_func
(paren
l_int|1
comma
l_string|&quot;stop tape failed with code&quot;
comma
id|result
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;tape stopped&quot;
)paren
suffix:semicolon
id|tape_running
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;repositioning&quot;
)paren
suffix:semicolon
op_increment
id|history.rewinds
suffix:semicolon
r_if
c_cond
(paren
id|segment_id
op_mod
id|segments_per_track
OL
id|start_offset
)paren
(brace
multiline_comment|/*  If seeking to first segments on track better do a complete&n;&t;&t;&t;&t; *  rewind to logical begin of track to get a more steady tape&n;&t;&t;&t;&t; *  motion.&n;&t;&t;&t;&t; */
id|result
op_assign
id|ftape_command_wait
c_func
(paren
(paren
id|location.track
op_amp
l_int|1
)paren
ques
c_cond
id|QIC_PHYSICAL_FORWARD
suffix:colon
id|QIC_PHYSICAL_REVERSE
comma
id|timeout.rewind
comma
op_amp
id|status
)paren
suffix:semicolon
id|check_bot_eot
c_func
(paren
id|status
)paren
suffix:semicolon
multiline_comment|/* update location */
)brace
r_else
(brace
id|result
op_assign
id|skip_reverse
c_func
(paren
id|segment_id
op_minus
id|start_offset
comma
op_amp
id|status
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|location.known
)paren
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;panic: location not known&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current-&gt;signal
op_amp
id|_DONT_BLOCK
)paren
op_logical_or
id|ftape_failure
)paren
(brace
r_break
suffix:semicolon
)brace
r_else
(brace
r_continue
suffix:semicolon
)brace
)brace
id|TRACEx2
c_func
(paren
l_int|4
comma
l_string|&quot;current segment: %d/%d&quot;
comma
id|location.segment
comma
id|location.sector
)paren
suffix:semicolon
multiline_comment|/*  We&squot;re on the right track somewhere before the wanted segment.&n;&t;&t; *  Start tape movement if needed and skip to just before or inside&n;&t;&t; *  the requested segment. Keep tape running.&n;&t;&t; */
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|location.segment
OL
id|segment_id
op_minus
(paren
(paren
id|tape_running
op_logical_or
id|location.bot
)paren
ques
c_cond
l_int|0
suffix:colon
id|start_offset
)paren
)paren
(brace
r_if
c_cond
(paren
id|sector_offset
OG
l_int|0
)paren
(brace
id|result
op_assign
id|seek_forward
c_func
(paren
id|segment_id
)paren
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
id|seek_forward
c_func
(paren
id|segment_id
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_and
id|location.segment
op_ne
id|segment_id
op_minus
(paren
id|sector_offset
OG
l_int|0
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
)paren
(brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|result
OL
l_int|0
op_logical_and
op_logical_neg
id|ftape_failure
op_logical_and
(paren
id|current-&gt;signal
op_amp
id|_DONT_BLOCK
)paren
op_eq
l_int|0
op_logical_and
op_increment
id|retry
op_le
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;failed to reposition&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
eof
