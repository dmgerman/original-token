multiline_comment|/*&n; *      Copyright (C) 1994-1995 Bas Laarhoven.&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; $Source: /home/bas/distr/ftape-2.03b/RCS/fdc-isr.c,v $&n; $Author: bas $&n; *&n; $Revision: 1.36 $&n; $Date: 1995/05/27 08:54:21 $&n; $State: Beta $&n; *&n; *      This file contains the interrupt service routine and associated&n; *      code for the QIC-40/80 tape streamer device driver.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
DECL|macro|volatile
mdefine_line|#define volatile&t;&t;/* */
macro_line|#include &quot;tracing.h&quot;
macro_line|#include &quot;fdc-isr.h&quot;
macro_line|#include &quot;qic117.h&quot;
macro_line|#include &quot;fdc-io.h&quot;
macro_line|#include &quot;ftape-ctl.h&quot;
macro_line|#include &quot;ftape-rw.h&quot;
macro_line|#include &quot;ftape-io.h&quot;
macro_line|#include &quot;calibr.h&quot;
macro_line|#include &quot;ftape-bsm.h&quot;
multiline_comment|/*      Global vars.&n; */
DECL|variable|expected_stray_interrupts
r_volatile
r_int
id|expected_stray_interrupts
op_assign
l_int|0
suffix:semicolon
DECL|variable|seek_completed
r_volatile
r_int
id|seek_completed
op_assign
l_int|0
suffix:semicolon
DECL|variable|interrupt_seen
r_volatile
r_int
id|interrupt_seen
op_assign
l_int|0
suffix:semicolon
DECL|variable|expect_stray_interrupt
r_volatile
r_int
id|expect_stray_interrupt
op_assign
l_int|0
suffix:semicolon
DECL|variable|random_rw
r_int
id|random_rw
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*      Local vars.&n; */
r_typedef
r_enum
(brace
DECL|enumerator|no_error
DECL|enumerator|id_am_error
DECL|enumerator|id_crc_error
id|no_error
op_assign
l_int|0
comma
id|id_am_error
op_assign
l_int|0x01
comma
id|id_crc_error
op_assign
l_int|0x02
comma
DECL|enumerator|data_am_error
DECL|enumerator|data_crc_error
id|data_am_error
op_assign
l_int|0x04
comma
id|data_crc_error
op_assign
l_int|0x08
comma
DECL|enumerator|no_data_error
DECL|enumerator|overrun_error
id|no_data_error
op_assign
l_int|0x10
comma
id|overrun_error
op_assign
l_int|0x20
comma
DECL|typedef|error_cause
)brace
id|error_cause
suffix:semicolon
DECL|variable|hide_interrupt
r_static
r_int
id|hide_interrupt
suffix:semicolon
DECL|variable|stop_read_ahead
r_static
r_int
id|stop_read_ahead
op_assign
l_int|0
suffix:semicolon
DECL|function|print_error_cause
r_static
r_void
id|print_error_cause
c_func
(paren
r_int
id|cause
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;print_error_cause&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cause
)paren
(brace
r_case
id|no_data_error
suffix:colon
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;no data error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|id_am_error
suffix:colon
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;id am error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|id_crc_error
suffix:colon
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;id crc error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|data_am_error
suffix:colon
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;data am error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|data_crc_error
suffix:colon
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;data crc error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|overrun_error
suffix:colon
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;overrun error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
r_static
r_char
op_star
DECL|function|get_fdc_mode_text
id|get_fdc_mode_text
c_func
(paren
id|fdc_mode_enum
id|fdc_mode
)paren
(brace
r_switch
c_cond
(paren
id|fdc_mode
)paren
(brace
r_case
id|fdc_idle
suffix:colon
r_return
l_string|&quot;fdc_idle&quot;
suffix:semicolon
r_case
id|fdc_reading_data
suffix:colon
r_return
l_string|&quot;fdc_reading_data&quot;
suffix:semicolon
r_case
id|fdc_seeking
suffix:colon
r_return
l_string|&quot;fdc_seeking&quot;
suffix:semicolon
r_case
id|fdc_writing_data
suffix:colon
r_return
l_string|&quot;fdc_writing_data&quot;
suffix:semicolon
r_case
id|fdc_reading_id
suffix:colon
r_return
l_string|&quot;fdc_reading_id&quot;
suffix:semicolon
r_case
id|fdc_recalibrating
suffix:colon
r_return
l_string|&quot;fdc_recalibrating&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|decode_irq_cause
id|decode_irq_cause
c_func
(paren
id|fdc_mode_enum
id|fdc_mode
comma
id|byte
id|st
(braket
)braket
comma
r_char
op_star
op_star
id|fdc_mode_txt
comma
id|error_cause
op_star
id|cause
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;decode_irq_cause&quot;
)paren
suffix:semicolon
multiline_comment|/*  Valid st[], decode cause of interrupt.&n;&t; */
op_star
id|fdc_mode_txt
op_assign
id|get_fdc_mode_text
c_func
(paren
id|fdc_mode
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|st
(braket
l_int|0
)braket
op_amp
id|ST0_INT_MASK
)paren
(brace
r_case
id|FDC_INT_NORMAL
suffix:colon
id|TRACEx1
c_func
(paren
id|fdc_mode
op_eq
id|fdc_reading_id
ques
c_cond
l_int|6
suffix:colon
l_int|5
comma
l_string|&quot;normal completion: %s&quot;
comma
op_star
id|fdc_mode_txt
)paren
suffix:semicolon
op_star
id|cause
op_assign
id|no_error
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDC_INT_ABNORMAL
suffix:colon
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;abnormal completion %s&quot;
comma
op_star
id|fdc_mode_txt
)paren
suffix:semicolon
id|TRACEx3
c_func
(paren
l_int|6
comma
l_string|&quot;ST0: 0x%02x, ST1: 0x%02x, ST2: 0x%02x&quot;
comma
id|st
(braket
l_int|0
)braket
comma
id|st
(braket
l_int|1
)braket
comma
id|st
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|TRACEx4
c_func
(paren
l_int|6
comma
l_string|&quot;C: 0x%02x, H: 0x%02x, R: 0x%02x, N: 0x%02x&quot;
comma
id|st
(braket
l_int|3
)braket
comma
id|st
(braket
l_int|4
)braket
comma
id|st
(braket
l_int|5
)braket
comma
id|st
(braket
l_int|6
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
(braket
l_int|1
)braket
op_amp
l_int|0x01
)paren
(brace
r_if
c_cond
(paren
id|st
(braket
l_int|2
)braket
op_amp
l_int|0x01
)paren
(brace
op_star
id|cause
op_assign
id|data_am_error
suffix:semicolon
)brace
r_else
(brace
op_star
id|cause
op_assign
id|id_am_error
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|st
(braket
l_int|1
)braket
op_amp
l_int|0x20
)paren
(brace
r_if
c_cond
(paren
id|st
(braket
l_int|2
)braket
op_amp
l_int|0x20
)paren
(brace
op_star
id|cause
op_assign
id|data_crc_error
suffix:semicolon
)brace
r_else
(brace
op_star
id|cause
op_assign
id|id_crc_error
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|st
(braket
l_int|1
)braket
op_amp
l_int|0x04
)paren
(brace
op_star
id|cause
op_assign
id|no_data_error
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st
(braket
l_int|1
)braket
op_amp
l_int|0x10
)paren
(brace
op_star
id|cause
op_assign
id|overrun_error
suffix:semicolon
)brace
id|print_error_cause
c_func
(paren
op_star
id|cause
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDC_INT_INVALID
suffix:colon
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;invalid completion %s&quot;
comma
op_star
id|fdc_mode_txt
)paren
suffix:semicolon
op_star
id|cause
op_assign
id|no_error
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDC_INT_READYCH
suffix:colon
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;ready change %s&quot;
comma
op_star
id|fdc_mode_txt
)paren
suffix:semicolon
op_star
id|cause
op_assign
id|no_error
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|update_history
r_static
r_void
id|update_history
c_func
(paren
id|error_cause
id|cause
)paren
(brace
r_switch
c_cond
(paren
id|cause
)paren
(brace
r_case
id|id_am_error
suffix:colon
id|history.id_am_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|id_crc_error
suffix:colon
id|history.id_crc_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|data_am_error
suffix:colon
id|history.data_am_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|data_crc_error
suffix:colon
id|history.data_crc_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|overrun_error
suffix:colon
id|history.overrun_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|no_data_error
suffix:colon
id|history.no_data_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
)brace
DECL|function|skip_bad_sector
r_static
r_void
id|skip_bad_sector
c_func
(paren
id|buffer_struct
op_star
id|buff
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;skip_bad_sector&quot;
)paren
suffix:semicolon
multiline_comment|/* Mark sector as soft error and skip it&n;&t; */
r_if
c_cond
(paren
id|buff-&gt;remaining
OG
l_int|0
)paren
(brace
op_increment
id|buff-&gt;sector_offset
suffix:semicolon
op_increment
id|buff-&gt;data_offset
suffix:semicolon
op_decrement
id|buff-&gt;remaining
suffix:semicolon
id|buff-&gt;ptr
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
id|buff-&gt;bad_sector_map
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
op_increment
id|buff-&gt;sector_offset
suffix:semicolon
multiline_comment|/* hack for error maps */
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;skipping last sector in segment&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|update_error_maps
r_static
r_void
id|update_error_maps
c_func
(paren
id|buffer_struct
op_star
id|buff
comma
r_int
id|error_offset
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;update_error_maps&quot;
)paren
suffix:semicolon
r_int
id|hard
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* error_offset is a sector offset !&n;&t; */
r_if
c_cond
(paren
id|buff-&gt;retry
OL
id|SOFT_RETRIES
)paren
(brace
id|buff-&gt;soft_error_map
op_or_assign
(paren
l_int|1
op_lshift
id|error_offset
)paren
suffix:semicolon
)brace
r_else
(brace
id|buff-&gt;hard_error_map
op_or_assign
(paren
l_int|1
op_lshift
id|error_offset
)paren
suffix:semicolon
id|buff-&gt;soft_error_map
op_and_assign
op_complement
id|buff-&gt;hard_error_map
suffix:semicolon
id|buff-&gt;retry
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* will be set to 0 in setup_segment */
id|hard
op_assign
l_int|1
suffix:semicolon
)brace
id|TRACEx2
c_func
(paren
l_int|4
comma
l_string|&quot;sector %d : %s error&quot;
comma
id|SECTOR
c_func
(paren
id|error_offset
)paren
comma
id|hard
ques
c_cond
l_string|&quot;hard&quot;
suffix:colon
l_string|&quot;soft&quot;
)paren
suffix:semicolon
id|TRACEx2
c_func
(paren
l_int|5
comma
l_string|&quot;hard map: 0x%08lx, soft map: 0x%08lx&quot;
comma
id|buff-&gt;hard_error_map
comma
id|buff-&gt;soft_error_map
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/*&n; *  Error cause:   Amount xferred:  Action:&n; *&n; *  id_am_error         0           mark bad and skip&n; *  id_crc_error        0           mark bad and skip&n; *  data_am_error       0           mark bad and skip&n; *  data_crc_error    % 1024        mark bad and skip&n; *  no_data_error       0           retry on write&n; *                                  mark bad and skip on read&n; *  overrun_error  [ 0..all-1 ]     mark bad and skip&n; *  no_error           all          continue&n; */
DECL|function|determine_progress
r_static
r_void
id|determine_progress
c_func
(paren
id|buffer_struct
op_star
id|buff
comma
id|error_cause
id|cause
comma
r_int
id|mode
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;determine_progress&quot;
)paren
suffix:semicolon
r_int
id|nr_not_xferred
suffix:semicolon
r_int
id|nr_xferred
suffix:semicolon
r_int
id|dma_residue
suffix:semicolon
multiline_comment|/*  Using less preferred order of disable_dma and get_dma_residue&n;&t; *  because this seems to fail on at least one system if reversed!&n;&t; */
id|dma_residue
op_assign
id|get_dma_residue
c_func
(paren
id|fdc.dma
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|fdc.dma
)paren
suffix:semicolon
id|nr_xferred
op_assign
id|buff-&gt;sector_count
op_star
id|SECTOR_SIZE
op_minus
id|dma_residue
suffix:semicolon
r_if
c_cond
(paren
id|cause
op_eq
id|no_error
op_logical_and
id|dma_residue
op_eq
l_int|0
)paren
(brace
id|nr_not_xferred
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cause
op_eq
id|no_error
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;unexpected DMA residue: 0x%04x&quot;
comma
id|dma_residue
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|6
comma
l_string|&quot;DMA residue = 0x%04x&quot;
comma
id|dma_residue
)paren
suffix:semicolon
)brace
id|nr_not_xferred
op_assign
(paren
(paren
id|dma_residue
op_plus
(paren
id|SECTOR_SIZE
op_minus
l_int|1
)paren
)paren
op_div
id|SECTOR_SIZE
)paren
suffix:semicolon
id|buff-&gt;sector_count
op_sub_assign
id|nr_not_xferred
suffix:semicolon
multiline_comment|/* adjust to actual value */
)brace
multiline_comment|/*  Update var&squot;s influenced by the DMA operation.&n;&t; */
r_if
c_cond
(paren
id|buff-&gt;sector_count
OG
l_int|0
)paren
(brace
id|buff-&gt;sector_offset
op_add_assign
id|buff-&gt;sector_count
suffix:semicolon
id|buff-&gt;data_offset
op_add_assign
id|buff-&gt;sector_count
suffix:semicolon
id|buff-&gt;ptr
op_add_assign
id|buff-&gt;sector_count
op_star
id|SECTOR_SIZE
suffix:semicolon
id|buff-&gt;remaining
op_sub_assign
id|buff-&gt;sector_count
suffix:semicolon
id|buff-&gt;bad_sector_map
op_rshift_assign
id|buff-&gt;sector_count
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cause
op_eq
id|no_error
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;%d Sector(s) transferred&quot;
comma
id|buff-&gt;sector_count
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cause
op_eq
id|no_data_error
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;Sector %d not found&quot;
comma
id|SECTOR
c_func
(paren
id|buff-&gt;sector_offset
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|nr_xferred
OG
l_int|0
op_logical_or
id|cause
op_eq
id|id_crc_error
op_logical_or
id|cause
op_eq
id|id_am_error
op_logical_or
id|cause
op_eq
id|data_am_error
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;Error in sector %d&quot;
comma
id|SECTOR
c_func
(paren
id|buff-&gt;sector_offset
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cause
op_eq
id|overrun_error
)paren
(brace
multiline_comment|/* got an overrun error on the first byte, must be a hardware problem&n;&t;&t; */
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;Unexpected error: failing DMA controller ?&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;Unexpected error at sector %d&quot;
comma
id|SECTOR
c_func
(paren
id|buff-&gt;sector_offset
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*  Sector_offset points to the problem area, except if we got&n;&t; *  a data_crc_error. In that case it points one past the failing&n;&t; *  sector.&n;&t; *  Now adjust sector_offset so it allways points one past he&n;&t; *  failing sector. I.e. skip the bad sector.&n;&t; */
r_if
c_cond
(paren
id|cause
op_ne
id|no_error
)paren
(brace
r_if
c_cond
(paren
id|cause
op_ne
id|data_crc_error
)paren
(brace
id|skip_bad_sector
c_func
(paren
id|buff
)paren
suffix:semicolon
)brace
id|update_error_maps
c_func
(paren
id|buff
comma
id|buff-&gt;sector_offset
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|calc_steps
r_static
r_int
id|calc_steps
c_func
(paren
r_int
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|current_cylinder
OG
id|cmd
)paren
(brace
r_return
id|current_cylinder
op_minus
id|cmd
suffix:semicolon
)brace
r_else
(brace
r_return
id|current_cylinder
op_plus
id|cmd
suffix:semicolon
)brace
)brace
DECL|function|pause_tape
r_static
r_void
id|pause_tape
c_func
(paren
r_int
id|segment
comma
r_int
id|retry
comma
r_int
id|fdc_mode
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;pause_tape&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/*  The 3rd initializer needs to be explicit or else gcc will&n;&t; *  generate a reference to memset :-(&n;&t; */
id|byte
id|out
(braket
l_int|3
)braket
op_assign
(brace
id|FDC_SEEK
comma
id|FTAPE_UNIT
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*  We&squot;ll use a raw seek command to get the tape to rewind&n;&t; *  and stop for a retry.&n;&t; */
op_increment
id|history.rewinds
suffix:semicolon
r_if
c_cond
(paren
id|qic117_cmds
(braket
id|current_command
)braket
dot
id|non_intr
)paren
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;motion command may be issued too soon&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retry
op_logical_and
(paren
id|fdc_mode
op_eq
id|fdc_reading_data
op_logical_or
id|fdc_mode
op_eq
id|fdc_reading_id
)paren
)paren
(brace
id|current_command
op_assign
id|QIC_MICRO_STEP_PAUSE
suffix:semicolon
id|might_be_off_track
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|current_command
op_assign
id|QIC_PAUSE
suffix:semicolon
)brace
id|out
(braket
l_int|2
)braket
op_assign
id|calc_steps
c_func
(paren
id|current_command
)paren
suffix:semicolon
id|result
op_assign
id|fdc_command
c_func
(paren
id|out
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* issue QIC_117 command */
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;qic-pause failed, status = %d&quot;
comma
id|result
)paren
suffix:semicolon
)brace
r_else
(brace
id|location.known
op_assign
l_int|0
suffix:semicolon
id|runner_status
op_assign
id|idle
suffix:semicolon
id|hide_interrupt
op_assign
l_int|1
suffix:semicolon
id|tape_running
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|stop_tape
r_static
r_void
id|stop_tape
c_func
(paren
r_int
id|segment
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;stop_tape&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
id|byte
id|out
(braket
l_int|3
)braket
op_assign
(brace
id|FDC_SEEK
comma
id|FTAPE_UNIT
comma
id|calc_steps
c_func
(paren
id|QIC_STOP_TAPE
)paren
)brace
suffix:semicolon
r_if
c_cond
(paren
id|qic117_cmds
(braket
id|current_command
)braket
dot
id|non_intr
)paren
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;motion command may be issued too soon&quot;
)paren
suffix:semicolon
)brace
id|current_command
op_assign
id|QIC_STOP_TAPE
suffix:semicolon
multiline_comment|/*  We&squot;ll use a raw seek command to get the tape to stop&n;&t; */
id|result
op_assign
id|fdc_command
c_func
(paren
id|out
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* issue QIC_117 command */
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;qic-stop failed, status = %d&quot;
comma
id|result
)paren
suffix:semicolon
)brace
r_else
(brace
id|runner_status
op_assign
id|idle
suffix:semicolon
id|hide_interrupt
op_assign
l_int|1
suffix:semicolon
id|tape_running
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|continue_xfer
r_static
r_void
id|continue_xfer
c_func
(paren
id|buffer_struct
op_star
op_star
id|p_buff
comma
id|error_cause
id|cause
comma
r_int
id|fdc_mode
comma
r_int
id|skip
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;continue_xfer&quot;
)paren
suffix:semicolon
id|buffer_struct
op_star
id|buff
op_assign
op_star
id|p_buff
suffix:semicolon
r_int
id|write
op_assign
(paren
id|fdc_mode
op_eq
id|fdc_writing_data
)paren
suffix:semicolon
id|byte
id|fdc_op
op_assign
(paren
id|write
)paren
ques
c_cond
id|FDC_WRITE
suffix:colon
id|FDC_READ
suffix:semicolon
r_if
c_cond
(paren
id|skip
OG
l_int|0
)paren
(brace
multiline_comment|/* This part can be removed if it never happens&n;&t;&t; */
r_if
c_cond
(paren
id|runner_status
op_ne
id|running
op_logical_or
(paren
id|buff-&gt;status
op_ne
(paren
id|write
ques
c_cond
id|writing
suffix:colon
id|reading
)paren
)paren
)paren
(brace
id|TRACEx2
c_func
(paren
l_int|1
comma
l_string|&quot;unexpected runner/buffer state %d/%d&quot;
comma
id|runner_status
comma
id|buff-&gt;status
)paren
suffix:semicolon
id|buff-&gt;status
op_assign
id|error
suffix:semicolon
op_star
id|p_buff
op_assign
id|next_buffer
c_func
(paren
op_amp
id|head
)paren
suffix:semicolon
multiline_comment|/* finish this buffer */
id|runner_status
op_assign
id|aborting
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|buff-&gt;remaining
OG
l_int|0
op_logical_and
id|calc_next_cluster
c_func
(paren
op_amp
id|buffer
(braket
id|head
)braket
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/* still sectors left in current segment, continue with this segment&n;&t;&t; */
r_if
c_cond
(paren
id|setup_fdc_and_dma
c_func
(paren
op_amp
id|buffer
(braket
id|head
)braket
comma
id|fdc_op
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* failed, abort operation&n;&t;&t;&t; */
id|buff-&gt;bytes
op_assign
id|buff-&gt;ptr
op_minus
id|buff-&gt;address
suffix:semicolon
id|buff-&gt;status
op_assign
id|error
suffix:semicolon
id|buff
op_assign
op_star
id|p_buff
op_assign
id|next_buffer
c_func
(paren
op_amp
id|head
)paren
suffix:semicolon
multiline_comment|/* finish this buffer */
id|runner_status
op_assign
id|aborting
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* current segment completed&n;&t;&t; */
r_int
id|last_segment
op_assign
id|buff-&gt;segment_id
suffix:semicolon
r_int
id|eot
op_assign
(paren
(paren
id|last_segment
op_plus
l_int|1
)paren
op_mod
id|segments_per_track
)paren
op_eq
l_int|0
suffix:semicolon
r_int
id|next
op_assign
id|buff-&gt;next_segment
suffix:semicolon
multiline_comment|/* 0 means stop ! */
id|buff-&gt;bytes
op_assign
id|buff-&gt;ptr
op_minus
id|buff-&gt;address
suffix:semicolon
id|buff-&gt;status
op_assign
id|done
suffix:semicolon
id|buff
op_assign
op_star
id|p_buff
op_assign
id|next_buffer
c_func
(paren
op_amp
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eot
)paren
(brace
multiline_comment|/* finished last segment on current track, can&squot;t continue&n;&t;&t;&t; */
id|runner_status
op_assign
id|logical_eot
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|next
OG
l_int|0
)paren
(brace
multiline_comment|/* continue with next segment&n;&t;&t;&t; */
r_if
c_cond
(paren
id|buff-&gt;status
op_eq
id|waiting
)paren
(brace
r_if
c_cond
(paren
id|write
op_logical_and
id|next
op_ne
id|buff-&gt;segment_id
)paren
(brace
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;segments out of order, aborting write&quot;
)paren
suffix:semicolon
id|runner_status
op_assign
id|do_abort
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
)brace
r_else
(brace
id|setup_new_segment
c_func
(paren
op_amp
id|buffer
(braket
id|head
)braket
comma
id|next
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stop_read_ahead
)paren
(brace
id|buff-&gt;next_segment
op_assign
l_int|0
suffix:semicolon
id|stop_read_ahead
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|calc_next_cluster
c_func
(paren
op_amp
id|buffer
(braket
id|head
)braket
)paren
op_eq
l_int|0
op_logical_or
id|setup_fdc_and_dma
c_func
(paren
op_amp
id|buffer
(braket
id|head
)braket
comma
id|fdc_op
)paren
op_ne
l_int|0
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|1
comma
l_string|&quot;couldn&squot;t start %s-ahead&quot;
comma
(paren
id|write
)paren
ques
c_cond
l_string|&quot;write&quot;
suffix:colon
l_string|&quot;read&quot;
)paren
suffix:semicolon
id|runner_status
op_assign
id|do_abort
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
)brace
r_else
(brace
id|buff-&gt;status
op_assign
(paren
id|write
)paren
ques
c_cond
id|writing
suffix:colon
id|reading
suffix:semicolon
multiline_comment|/* keep on going */
)brace
)brace
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;all input buffers %s, pausing tape&quot;
comma
(paren
id|write
)paren
ques
c_cond
l_string|&quot;empty&quot;
suffix:colon
l_string|&quot;full&quot;
)paren
suffix:semicolon
id|pause_tape
c_func
(paren
id|last_segment
comma
l_int|0
comma
id|fdc_mode
)paren
suffix:semicolon
id|runner_status
op_assign
id|idle
suffix:semicolon
multiline_comment|/* not quite true until next irq */
)brace
)brace
r_else
(brace
multiline_comment|/* don&squot;t continue with next segment&n;&t;&t;&t; */
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;no %s allowed, stopping tape&quot;
comma
(paren
id|write
)paren
ques
c_cond
l_string|&quot;write next&quot;
suffix:colon
l_string|&quot;read ahead&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|random_rw
)paren
(brace
id|stop_tape
c_func
(paren
id|last_segment
)paren
suffix:semicolon
)brace
r_else
(brace
id|pause_tape
c_func
(paren
id|last_segment
comma
l_int|0
comma
id|fdc_mode
)paren
suffix:semicolon
)brace
id|runner_status
op_assign
id|idle
suffix:semicolon
multiline_comment|/* not quite true until next irq */
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|retry_sector
id|retry_sector
c_func
(paren
id|buffer_struct
op_star
op_star
id|p_buff
comma
id|error_cause
id|cause
comma
r_int
id|fdc_mode
comma
r_int
id|skip
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;retry_sector&quot;
)paren
suffix:semicolon
id|buffer_struct
op_star
id|buff
op_assign
op_star
id|p_buff
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;%s error, will retry&quot;
comma
(paren
id|fdc_mode
op_eq
id|fdc_writing_data
)paren
ques
c_cond
l_string|&quot;write&quot;
suffix:colon
l_string|&quot;read&quot;
)paren
suffix:semicolon
id|pause_tape
c_func
(paren
id|buff-&gt;segment_id
comma
l_int|1
comma
id|fdc_mode
)paren
suffix:semicolon
id|runner_status
op_assign
id|aborting
suffix:semicolon
id|buff-&gt;status
op_assign
id|error
suffix:semicolon
id|buff-&gt;skip
op_assign
id|skip
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
r_static
r_int
DECL|function|find_resume_point
id|find_resume_point
c_func
(paren
id|buffer_struct
op_star
id|buff
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;find_resume_point&quot;
)paren
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_int
r_int
id|map
suffix:semicolon
multiline_comment|/*  This function is to be called after all variables have been&n;&t; *  updated to point past the failing sector.&n;&t; *  If there are any soft errors before the failing sector,&n;&t; *  find the first soft error and return the sector offset.&n;&t; *  Otherwise find the last hard error.&n;&t; *  Note: there should allways be at least one hard or soft error !&n;&t; */
r_if
c_cond
(paren
id|buff-&gt;sector_offset
template_param
l_int|32
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|1
comma
l_string|&quot;bug: sector_offset = %d&quot;
comma
id|buff-&gt;sector_offset
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|buff-&gt;sector_offset
op_ge
l_int|32
)paren
(brace
multiline_comment|/* C-limitation on shift ! */
id|mask
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
r_else
(brace
id|mask
op_assign
(paren
l_int|1
op_lshift
id|buff-&gt;sector_offset
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|map
op_assign
id|buff-&gt;soft_error_map
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|map
)paren
(brace
r_while
c_loop
(paren
(paren
id|map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_eq
l_int|0
)paren
(brace
op_increment
id|i
suffix:semicolon
)brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;at sector %d&quot;
comma
id|SECTOR
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|map
op_assign
id|buff-&gt;hard_error_map
op_amp
id|mask
suffix:semicolon
id|i
op_assign
id|buff-&gt;sector_offset
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|map
)paren
(brace
r_while
c_loop
(paren
(paren
id|map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_eq
l_int|0
)paren
(brace
op_decrement
id|i
suffix:semicolon
)brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;after sector %d&quot;
comma
id|SECTOR
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
op_increment
id|i
suffix:semicolon
multiline_comment|/* first sector after last hard error */
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;bug: no soft or hard errors&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*      FDC interrupt service routine.&n; */
r_void
DECL|function|fdc_isr
id|fdc_isr
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_isr&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|status
suffix:semicolon
id|error_cause
id|cause
op_assign
id|no_error
suffix:semicolon
id|byte
id|in
(braket
l_int|7
)braket
suffix:semicolon
r_static
r_int
id|isr_active
op_assign
l_int|0
suffix:semicolon
r_int
id|t0
suffix:semicolon
id|buffer_struct
op_star
id|buff
op_assign
op_amp
id|buffer
(braket
id|head
)braket
suffix:semicolon
r_int
id|skip
suffix:semicolon
id|t0
op_assign
id|timestamp
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isr_active
)paren
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;nested interrupt, not good !&quot;
)paren
suffix:semicolon
op_star
id|fdc.hook
op_assign
id|fdc_isr
suffix:semicolon
multiline_comment|/* hook our handler into the fdc code again */
id|TRACE_EXIT
suffix:semicolon
r_return
suffix:semicolon
)brace
op_increment
id|isr_active
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* enables interrupts again */
id|status
op_assign
id|inb_p
c_func
(paren
id|fdc.msr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|FDC_BUSY
)paren
(brace
multiline_comment|/*  Entering Result Phase */
id|hide_interrupt
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|fdc_result
c_func
(paren
id|in
comma
l_int|7
)paren
suffix:semicolon
multiline_comment|/* better get it fast ! */
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/*  Entered unknown state...&n;&t;&t;&t; */
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;probably fatal error during FDC Result Phase&quot;
)paren
suffix:semicolon
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;drive may hang until (power) reset :-(&quot;
)paren
suffix:semicolon
multiline_comment|/*  what to do next ????&n;&t;&t;&t; */
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|fdc_mode_txt
suffix:semicolon
id|decode_irq_cause
c_func
(paren
id|fdc_mode
comma
id|in
comma
op_amp
id|fdc_mode_txt
comma
op_amp
id|cause
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_BUFFERS
suffix:semicolon
op_increment
id|i
)paren
(brace
id|TRACEx3
c_func
(paren
l_int|8
comma
l_string|&quot;buffer[%d] status: %d, segment_id: %d&quot;
comma
id|i
comma
id|buffer
(braket
id|i
)braket
dot
id|status
comma
id|buffer
(braket
id|i
)braket
dot
id|segment_id
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|fdc_mode
)paren
(brace
r_case
id|fdc_reading_data
suffix:colon
(brace
r_if
c_cond
(paren
id|cause
op_eq
id|no_error
)paren
(brace
id|TRACEi
c_func
(paren
l_int|5
comma
l_string|&quot;reading segment&quot;
comma
id|buff-&gt;segment_id
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACEi
c_func
(paren
l_int|4
comma
l_string|&quot;error reading segment&quot;
comma
id|buff-&gt;segment_id
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|runner_status
op_eq
id|aborting
op_logical_or
id|runner_status
op_eq
id|do_abort
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;aborting %s&quot;
comma
id|fdc_mode_txt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buff-&gt;retry
OG
l_int|0
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;this is retry nr %d&quot;
comma
id|buff-&gt;retry
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buff-&gt;bad_sector_map
op_eq
id|FAKE_SEGMENT
)paren
(brace
multiline_comment|/* This condition occurs when reading a `fake&squot; sector that&squot;s&n;&t;&t;&t;&t;&t;&t; * not accessible. Doesn&squot;t really matter as we would have&n;&t;&t;&t;&t;&t;&t; * ignored it anyway !&n;&t;&t;&t;&t;&t;&t; * Chance is that we&squot;re past the next segment now, so the&n;&t;&t;&t;&t;&t;&t; * next operation may fail and result in a retry.&n;&t;&t;&t;&t;&t;&t; */
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;skipping empty segment (read)&quot;
)paren
suffix:semicolon
id|buff-&gt;remaining
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* skip failing sector */
id|continue_xfer
c_func
(paren
op_amp
id|buff
comma
id|no_error
comma
id|fdc_mode
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* fake success */
)brace
r_else
(brace
r_switch
c_cond
(paren
id|cause
)paren
(brace
r_case
id|no_error
suffix:colon
(brace
id|determine_progress
c_func
(paren
id|buff
comma
id|cause
comma
id|fdc_reading_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in
(braket
l_int|2
)braket
op_amp
l_int|0x40
)paren
(brace
multiline_comment|/*  Handle deleted data in header segments.&n;&t;&t;&t;&t;&t;&t;&t;&t;&t; *  Skip segment and force read-ahead.&n;&t;&t;&t;&t;&t;&t;&t;&t;&t; */
id|TRACEx1
c_func
(paren
l_int|2
comma
l_string|&quot;deleted data in sector %d&quot;
comma
id|SECTOR
c_func
(paren
id|buff-&gt;sector_offset
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|buff-&gt;deleted
op_assign
l_int|1
suffix:semicolon
id|buff-&gt;remaining
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* abort transfer */
id|buff-&gt;soft_error_map
op_or_assign
(paren
op_minus
l_int|1L
op_lshift
id|buff-&gt;sector_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff-&gt;segment_id
op_eq
l_int|0
)paren
(brace
id|stop_read_ahead
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* stop on next segment */
)brace
id|buff-&gt;next_segment
op_assign
id|buff-&gt;segment_id
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* force read-ahead */
id|skip
op_assign
(paren
id|SECTORS_PER_SEGMENT
op_minus
id|buff-&gt;sector_offset
)paren
suffix:semicolon
)brace
r_else
(brace
id|skip
op_assign
l_int|0
suffix:semicolon
)brace
id|continue_xfer
c_func
(paren
op_amp
id|buff
comma
id|cause
comma
id|fdc_mode
comma
id|skip
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|no_data_error
suffix:colon
multiline_comment|/*  Tape started too far ahead of or behind the right sector.&n;&t;&t;&t;&t;&t;&t;&t; *  This may also happen in the middle of a segment !&n;&t;&t;&t;&t;&t;&t;&t; *  Handle no-data as soft error. If next sector fails too,&n;&t;&t;&t;&t;&t;&t;&t; *  a retry (with needed reposition) will follow.&n;&t;&t;&t;&t;&t;&t;&t; */
r_case
id|id_am_error
suffix:colon
r_case
id|id_crc_error
suffix:colon
r_case
id|data_am_error
suffix:colon
r_case
id|data_crc_error
suffix:colon
r_case
id|overrun_error
suffix:colon
(brace
r_int
id|first_error
op_assign
(paren
id|buff-&gt;soft_error_map
op_eq
l_int|0
op_logical_and
id|buff-&gt;hard_error_map
op_eq
l_int|0
)paren
suffix:semicolon
id|update_history
c_func
(paren
id|cause
)paren
suffix:semicolon
id|determine_progress
c_func
(paren
id|buff
comma
id|cause
comma
id|fdc_reading_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_error
)paren
(brace
id|skip
op_assign
id|buff-&gt;sector_offset
suffix:semicolon
)brace
r_else
(brace
id|skip
op_assign
id|find_resume_point
c_func
(paren
id|buff
)paren
suffix:semicolon
)brace
multiline_comment|/*  Try to resume with next sector on single errors (let ecc&n;&t;&t;&t;&t;&t;&t;&t;&t; *  correct it), but retry on no_data (we&squot;ll be past the&n;&t;&t;&t;&t;&t;&t;&t;&t; *  target when we get here so we cannot retry) or on multiple&n;&t;&t;&t;&t;&t;&t;&t;&t; *  errors (reduce chance on ecc failure).&n;&t;&t;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|first_error
op_logical_and
id|cause
op_ne
id|no_data_error
)paren
(brace
id|continue_xfer
c_func
(paren
op_amp
id|buff
comma
id|cause
comma
id|fdc_mode
comma
id|skip
)paren
suffix:semicolon
)brace
r_else
(brace
id|retry_sector
c_func
(paren
op_amp
id|buff
comma
id|cause
comma
id|fdc_mode
comma
id|skip
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_default
suffix:colon
(brace
multiline_comment|/*  Don&squot;t know why this could happen but find out.&n;&t;&t;&t;&t;&t;&t;&t;&t; */
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;unexpected error&quot;
)paren
suffix:semicolon
id|determine_progress
c_func
(paren
id|buff
comma
id|cause
comma
id|fdc_reading_data
)paren
suffix:semicolon
id|retry_sector
c_func
(paren
op_amp
id|buff
comma
id|cause
comma
id|fdc_mode
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
)brace
r_case
id|fdc_reading_id
suffix:colon
(brace
r_if
c_cond
(paren
id|cause
op_eq
id|no_error
)paren
(brace
id|fdc_cyl
op_assign
id|in
(braket
l_int|3
)braket
suffix:semicolon
id|fdc_head
op_assign
id|in
(braket
l_int|4
)braket
suffix:semicolon
id|fdc_sect
op_assign
id|in
(braket
l_int|5
)braket
suffix:semicolon
id|TRACEx3
c_func
(paren
l_int|6
comma
l_string|&quot;id read: C: 0x%02x, H: 0x%02x, R: 0x%02x&quot;
comma
id|fdc_cyl
comma
id|fdc_head
comma
id|fdc_sect
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* no valid information, use invalid sector */
id|fdc_cyl
op_assign
id|fdc_head
op_assign
id|fdc_sect
op_assign
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;Didn&squot;t find valid sector Id&quot;
)paren
suffix:semicolon
)brace
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|fdc_writing_data
suffix:colon
(brace
r_if
c_cond
(paren
id|cause
op_eq
id|no_error
)paren
(brace
id|TRACEi
c_func
(paren
l_int|5
comma
l_string|&quot;writing segment&quot;
comma
id|buff-&gt;segment_id
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACEi
c_func
(paren
l_int|4
comma
l_string|&quot;error writing segment&quot;
comma
id|buff-&gt;segment_id
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|runner_status
op_eq
id|aborting
op_logical_or
id|runner_status
op_eq
id|do_abort
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;aborting %s&quot;
comma
id|fdc_mode_txt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buff-&gt;retry
OG
l_int|0
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;this is retry nr %d&quot;
comma
id|buff-&gt;retry
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buff-&gt;bad_sector_map
op_eq
id|FAKE_SEGMENT
)paren
(brace
multiline_comment|/* This condition occurs when trying to write to a `fake&squot;&n;&t;&t;&t;&t;&t;&t; * sector that&squot;s not accessible. Doesn&squot;t really matter as&n;&t;&t;&t;&t;&t;&t; * it isn&squot;t used anyway ! Might be located at wrong segment,&n;&t;&t;&t;&t;&t;&t; * then we&squot;ll fail on the next segment.&n;&t;&t;&t;&t;&t;&t; */
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;skipping empty segment (write)&quot;
)paren
suffix:semicolon
id|buff-&gt;remaining
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* skip failing sector */
id|continue_xfer
c_func
(paren
op_amp
id|buff
comma
id|no_error
comma
id|fdc_mode
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* fake success */
)brace
r_else
(brace
r_switch
c_cond
(paren
id|cause
)paren
(brace
r_case
id|no_error
suffix:colon
(brace
id|determine_progress
c_func
(paren
id|buff
comma
id|cause
comma
id|fdc_writing_data
)paren
suffix:semicolon
id|continue_xfer
c_func
(paren
op_amp
id|buff
comma
id|cause
comma
id|fdc_mode
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|no_data_error
suffix:colon
r_case
id|id_am_error
suffix:colon
r_case
id|id_crc_error
suffix:colon
r_case
id|data_am_error
suffix:colon
r_case
id|overrun_error
suffix:colon
(brace
id|update_history
c_func
(paren
id|cause
)paren
suffix:semicolon
id|determine_progress
c_func
(paren
id|buff
comma
id|cause
comma
id|fdc_writing_data
)paren
suffix:semicolon
id|skip
op_assign
id|find_resume_point
c_func
(paren
id|buff
)paren
suffix:semicolon
id|retry_sector
c_func
(paren
op_amp
id|buff
comma
id|cause
comma
id|fdc_mode
comma
id|skip
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
(brace
r_if
c_cond
(paren
id|in
(braket
l_int|1
)braket
op_amp
l_int|0x02
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;media not writable&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;unforseen write error&quot;
)paren
suffix:semicolon
)brace
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|TRACEx1
c_func
(paren
l_int|1
comma
l_string|&quot;Warning: unexpected irq during: %s&quot;
comma
id|fdc_mode_txt
)paren
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|runner_status
op_eq
id|do_abort
)paren
(brace
multiline_comment|/*      cease operation, remember tape position&n;&t;&t;&t; */
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;runner aborting&quot;
)paren
suffix:semicolon
id|runner_status
op_assign
id|aborting
suffix:semicolon
op_increment
id|expected_stray_interrupts
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* !FDC_BUSY  */
multiline_comment|/*  clear interrupt, cause should be gotten by issueing&n;&t;&t; *  a Sense Interrupt Status command.&n;&t;&t; */
r_if
c_cond
(paren
id|fdc_mode
op_eq
id|fdc_recalibrating
op_logical_or
id|fdc_mode
op_eq
id|fdc_seeking
)paren
(brace
r_if
c_cond
(paren
id|hide_interrupt
)paren
(brace
r_int
id|st0
suffix:semicolon
r_int
id|pcn
suffix:semicolon
id|result
op_assign
id|fdc_sense_interrupt_status
c_func
(paren
op_amp
id|st0
comma
op_amp
id|pcn
)paren
suffix:semicolon
id|current_cylinder
op_assign
id|pcn
suffix:semicolon
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;handled hidden interrupt&quot;
)paren
suffix:semicolon
)brace
id|seek_completed
op_assign
l_int|1
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|wait_intr
)paren
(brace
r_if
c_cond
(paren
id|expected_stray_interrupts
op_eq
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;unexpected stray interrupt&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;expected stray interrupt&quot;
)paren
suffix:semicolon
op_decrement
id|expected_stray_interrupts
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|fdc_mode
op_eq
id|fdc_reading_data
op_logical_or
id|fdc_mode
op_eq
id|fdc_writing_data
op_logical_or
id|fdc_mode
op_eq
id|fdc_reading_id
)paren
(brace
id|byte
id|status
op_assign
id|inb_p
c_func
(paren
id|fdc.msr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|FDC_BUSY
)paren
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;***** FDC failure, busy too late&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;***** FDC failure, no busy&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|6
comma
l_string|&quot;awaited stray interrupt&quot;
)paren
suffix:semicolon
)brace
)brace
id|hide_interrupt
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*    Handle sleep code.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hide_interrupt
)paren
(brace
op_increment
id|interrupt_seen
suffix:semicolon
r_if
c_cond
(paren
id|wait_intr
)paren
(brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|wait_intr
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;hiding interrupt while %s&quot;
comma
id|wait_intr
ques
c_cond
l_string|&quot;waiting&quot;
suffix:colon
l_string|&quot;active&quot;
)paren
suffix:semicolon
)brace
id|t0
op_assign
id|timediff
c_func
(paren
id|t0
comma
id|timestamp
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t0
op_ge
l_int|1000
)paren
(brace
multiline_comment|/* only tell us about long calls */
id|TRACEx1
c_func
(paren
l_int|7
comma
l_string|&quot;isr() duration: %5d usec&quot;
comma
id|t0
)paren
suffix:semicolon
)brace
op_star
id|fdc.hook
op_assign
id|fdc_isr
suffix:semicolon
multiline_comment|/* hook our handler into the fdc code again */
id|TRACE_EXIT
suffix:semicolon
op_decrement
id|isr_active
suffix:semicolon
)brace
eof
