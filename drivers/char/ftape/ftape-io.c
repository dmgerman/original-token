multiline_comment|/*&n; *      Copyright (C) 1993-1995 Bas Laarhoven.&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; $Source: /home/bas/distr/ftape-2.03b/RCS/ftape-io.c,v $&n; $Author: bas $&n; *&n; $Revision: 1.58 $&n; $Date: 1995/05/27 08:54:21 $&n; $State: Beta $&n; *&n; *      This file contains the general control functions&n; *      for the QIC-40/80 floppy-tape driver for Linux.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/mtio.h&gt;
macro_line|#include &quot;tracing.h&quot;
macro_line|#include &quot;fdc-io.h&quot;
macro_line|#include &quot;qic117.h&quot;
macro_line|#include &quot;ftape-io.h&quot;
macro_line|#include &quot;ftape-ctl.h&quot;
macro_line|#include &quot;ftape-rw.h&quot;
macro_line|#include &quot;ftape-write.h&quot;
macro_line|#include &quot;ftape-read.h&quot;
macro_line|#include &quot;ftape-eof.h&quot;
macro_line|#include &quot;kernel-interface.h&quot;
macro_line|#include &quot;calibr.h&quot;
multiline_comment|/*      Global vars.&n; */
multiline_comment|/* NOTE: sectors start numbering at 1, all others at 0 ! */
DECL|variable|timeout
id|timeout_table
id|timeout
suffix:semicolon
DECL|variable|drive_type
id|vendor_struct
id|drive_type
suffix:semicolon
DECL|variable|qic_std
r_int
id|qic_std
suffix:semicolon
DECL|variable|tape_len
r_int
id|tape_len
suffix:semicolon
DECL|variable|current_command
r_volatile
r_int
id|current_command
suffix:semicolon
DECL|variable|qic117_cmds
r_const
r_struct
id|qic117_command_table
id|qic117_cmds
(braket
)braket
op_assign
id|QIC117_COMMANDS
suffix:semicolon
DECL|variable|might_be_off_track
r_int
id|might_be_off_track
suffix:semicolon
multiline_comment|/*      Local vars.&n; */
DECL|variable|command_parameter
r_static
r_int
id|command_parameter
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*      command-restrictions is a table according&n; *      to the QIC-117 specs specifying the state&n; *      the drive status should be in at command execution.&n; */
DECL|variable|ftape_errors
r_static
r_const
id|ftape_error
id|ftape_errors
(braket
)braket
op_assign
id|QIC117_ERRORS
suffix:semicolon
DECL|variable|ftape_udelay_count
r_static
r_int
id|ftape_udelay_count
suffix:semicolon
DECL|variable|ftape_udelay_time
r_static
r_int
id|ftape_udelay_time
suffix:semicolon
r_static
r_const
r_struct
(brace
DECL|member|text
r_char
op_star
id|text
suffix:semicolon
DECL|member|fdc_code
r_int
id|fdc_code
suffix:semicolon
DECL|member|drive_code
id|byte
id|drive_code
suffix:semicolon
DECL|member|precomp
r_int
id|precomp
suffix:semicolon
DECL|variable|rates
)brace
id|rates
(braket
l_int|4
)braket
op_assign
(brace
macro_line|#if defined(FDC_82078SL)
(brace
l_string|&quot;2 M&quot;
comma
op_minus
l_int|1
multiline_comment|/* unsupported */
comma
id|QIC_CONFIG_RATE_2000
comma
l_int|0
)brace
comma
macro_line|#else
(brace
l_string|&quot;2 M&quot;
comma
id|fdc_data_rate_2000
comma
id|QIC_CONFIG_RATE_2000
comma
l_int|0
)brace
comma
macro_line|#endif
(brace
l_string|&quot;1 M&quot;
comma
id|fdc_data_rate_1000
comma
id|QIC_CONFIG_RATE_1000
comma
l_int|42
)brace
comma
(brace
l_string|&quot;500 K&quot;
comma
id|fdc_data_rate_500
comma
id|QIC_CONFIG_RATE_500
comma
l_int|125
)brace
comma
(brace
l_string|&quot;250 K&quot;
comma
id|fdc_data_rate_250
comma
id|QIC_CONFIG_RATE_250
comma
l_int|250
)brace
comma
)brace
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|prehistoric
DECL|enumerator|pre_qic117c
DECL|enumerator|post_qic117b
DECL|enumerator|post_qic117d
id|prehistoric
comma
id|pre_qic117c
comma
id|post_qic117b
comma
id|post_qic117d
DECL|typedef|qic_model
)brace
id|qic_model
suffix:semicolon
DECL|function|udelay
r_void
id|udelay
c_func
(paren
r_int
id|usecs
)paren
(brace
r_volatile
r_int
id|count
op_assign
(paren
l_int|1
op_plus
(paren
id|usecs
op_star
id|ftape_udelay_count
op_minus
l_int|1
)paren
op_div
id|ftape_udelay_time
)paren
suffix:semicolon
r_volatile
r_int
id|i
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
)brace
)brace
DECL|function|udelay_calibrate
r_int
id|udelay_calibrate
c_func
(paren
r_void
)paren
(brace
r_return
id|calibrate
c_func
(paren
l_string|&quot;udelay&quot;
comma
id|udelay
comma
op_amp
id|ftape_udelay_count
comma
op_amp
id|ftape_udelay_time
)paren
suffix:semicolon
)brace
multiline_comment|/*      Delay (msec) routine.&n; */
DECL|function|ftape_sleep
r_void
id|ftape_sleep
c_func
(paren
r_int
r_int
id|time
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_sleep&quot;
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ticks
op_assign
l_int|1
op_plus
(paren
id|time
op_plus
id|MSPT
op_minus
l_int|1
)paren
op_div
id|MSPT
suffix:semicolon
multiline_comment|/*    error in range [0..1] MSPT&n;&t; */
r_if
c_cond
(paren
id|time
OL
id|MSPT
)paren
(brace
multiline_comment|/*  Time too small for scheduler, do a busy wait ! */
id|udelay
c_func
(paren
l_int|1000
op_star
id|time
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACEx2
c_func
(paren
l_int|8
comma
l_string|&quot;%d msec, %d ticks&quot;
comma
id|time
comma
id|ticks
)paren
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|ticks
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
r_while
c_loop
(paren
id|current-&gt;state
op_ne
id|TASK_RUNNING
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;awoken by non-blocked signal :-(&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* exit on signal */
)brace
)brace
r_while
c_loop
(paren
id|current-&gt;timeout
OG
l_int|0
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/* forward */
r_int
id|ftape_report_raw_drive_status
c_func
(paren
r_int
op_star
id|status
)paren
suffix:semicolon
multiline_comment|/*      Issue a tape command:&n; *      Generate command # of step pulses.&n; */
DECL|function|ftape_command
r_int
id|ftape_command
c_func
(paren
r_int
id|command
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_command&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|track
suffix:semicolon
r_int
id|old_tracing
op_assign
id|tracing
suffix:semicolon
r_static
r_int
id|level
op_assign
l_int|0
suffix:semicolon
r_int
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|level
OG
l_int|5
)paren
(brace
multiline_comment|/*  This is a bug we&squot;ll want to know about.&n;&t;&t; */
id|TRACEx1
c_func
(paren
l_int|1
comma
l_string|&quot;bug - recursion for command: %d&quot;
comma
id|command
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|command_parameter
)paren
(brace
multiline_comment|/*  Don&squot;t check restrictions for parameters.&n;&t;&t; */
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;called with parameter = %d&quot;
comma
id|command
op_minus
l_int|2
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|command
op_le
l_int|0
op_logical_or
id|command
OG
id|NR_ITEMS
c_func
(paren
id|qic117_cmds
)paren
)paren
(brace
multiline_comment|/*  This is a bug we&squot;ll want to know about too.&n;&t;&t; */
id|TRACEx1
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;bug - bad command: %d&quot;
comma
id|command
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  disable logging and restriction check for some commands,&n;&t;&t; *  check all other commands that have a prescribed starting status.&n;&t;&t; */
r_if
c_cond
(paren
id|command
op_eq
id|QIC_REPORT_DRIVE_STATUS
)paren
(brace
id|TRACE
c_func
(paren
l_int|8
comma
l_string|&quot;report drive status called&quot;
)paren
suffix:semicolon
id|tracing
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|command
op_eq
id|QIC_REPORT_NEXT_BIT
)paren
(brace
id|tracing
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;%s&quot;
comma
id|qic117_cmds
(braket
id|command
)braket
dot
id|name
)paren
suffix:semicolon
multiline_comment|/*  A new motion command during an uninterruptible (motion)&n;&t;&t;&t; *  command requires a ready status before the new command&n;&t;&t;&t; *  can be issued. Otherwise a new motion command needs to&n;&t;&t;&t; *  be checked against required status.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|qic117_cmds
(braket
id|command
)braket
dot
id|cmd_type
op_eq
id|motion
op_logical_and
id|qic117_cmds
(braket
id|current_command
)braket
dot
id|non_intr
)paren
(brace
id|ftape_report_raw_drive_status
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|QIC_STATUS_READY
)paren
op_eq
l_int|0
)paren
(brace
id|TRACEx2
c_func
(paren
l_int|4
comma
l_string|&quot;motion cmd (%d) during non-intr cmd (%d)&quot;
comma
id|command
comma
id|current_command
)paren
suffix:semicolon
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;waiting until drive gets ready&quot;
)paren
suffix:semicolon
id|ftape_ready_wait
c_func
(paren
id|timeout.seek
comma
op_amp
id|status
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|qic117_cmds
(braket
id|command
)braket
dot
id|mask
op_ne
l_int|0
)paren
(brace
id|byte
id|difference
suffix:semicolon
multiline_comment|/*  Some commands do require a certain status:&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|status
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* not yet set */
id|ftape_report_raw_drive_status
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
)brace
id|difference
op_assign
(paren
(paren
id|status
op_xor
id|qic117_cmds
(braket
id|command
)braket
dot
id|state
)paren
op_amp
id|qic117_cmds
(braket
id|command
)braket
dot
id|mask
)paren
suffix:semicolon
multiline_comment|/*  Wait until the drive gets ready. This may last forever&n;&t;&t;&t;&t; *  if the drive never gets ready...&n;&t;&t;&t;&t; */
r_while
c_loop
(paren
(paren
id|difference
op_amp
id|QIC_STATUS_READY
)paren
op_ne
l_int|0
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;command %d issued while not ready&quot;
comma
id|command
)paren
suffix:semicolon
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;waiting until drive gets ready&quot;
)paren
suffix:semicolon
id|ftape_ready_wait
c_func
(paren
id|timeout.seek
comma
op_amp
id|status
)paren
suffix:semicolon
id|difference
op_assign
(paren
(paren
id|status
op_xor
id|qic117_cmds
(braket
id|command
)braket
dot
id|state
)paren
op_amp
id|qic117_cmds
(braket
id|command
)braket
dot
id|mask
)paren
suffix:semicolon
multiline_comment|/*  Bail out on signal !&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
id|_DONT_BLOCK
)paren
(brace
id|result
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|result
op_eq
l_int|0
op_logical_and
(paren
id|difference
op_amp
id|QIC_STATUS_ERROR
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
id|cmd
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;command %d issued while error pending&quot;
comma
id|command
)paren
suffix:semicolon
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;clearing error status&quot;
)paren
suffix:semicolon
id|ftape_report_error
c_func
(paren
op_amp
id|err
comma
op_amp
id|cmd
comma
l_int|1
)paren
suffix:semicolon
id|ftape_report_raw_drive_status
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
id|difference
op_assign
(paren
(paren
id|status
op_xor
id|qic117_cmds
(braket
id|command
)braket
dot
id|state
)paren
op_amp
id|qic117_cmds
(braket
id|command
)braket
dot
id|mask
)paren
suffix:semicolon
multiline_comment|/*  Bail out on fatal signal !&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
id|_DONT_BLOCK
)paren
(brace
id|result
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_and
id|difference
)paren
(brace
multiline_comment|/*  Any remaining difference can&squot;t be solved here.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|difference
op_amp
(paren
id|QIC_STATUS_CARTRIDGE_PRESENT
op_or
id|QIC_STATUS_NEW_CARTRIDGE
op_or
id|QIC_STATUS_REFERENCED
)paren
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;Fatal: tape removed or reinserted !&quot;
)paren
suffix:semicolon
id|ftape_failure
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|TRACEx2
c_func
(paren
l_int|1
comma
l_string|&quot;wrong state: 0x%02x should be: 0x%02x&quot;
comma
id|status
op_amp
id|qic117_cmds
(braket
id|command
)braket
dot
id|mask
comma
id|qic117_cmds
(braket
id|command
)braket
dot
id|state
)paren
suffix:semicolon
)brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_complement
id|status
op_amp
id|QIC_STATUS_READY
op_amp
id|qic117_cmds
(braket
id|command
)braket
dot
id|mask
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;Bad: still busy!&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
)brace
)brace
id|tracing
op_assign
id|old_tracing
suffix:semicolon
multiline_comment|/*  Now all conditions are met or result is &lt; 0.&n;&t; */
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
multiline_comment|/*  Always wait for a command_timeout period to separate&n;&t;&t; *  individuals commands and/or parameters.&n;&t;&t; */
id|ftape_sleep
c_func
(paren
l_int|3
op_star
id|MILLISECOND
)paren
suffix:semicolon
multiline_comment|/*  Keep cylinder nr within range, step towards home if possible.&n;&t;&t; */
r_if
c_cond
(paren
id|current_cylinder
op_ge
id|command
)paren
(brace
id|track
op_assign
id|current_cylinder
op_minus
id|command
suffix:semicolon
)brace
r_else
(brace
id|track
op_assign
id|current_cylinder
op_plus
id|command
suffix:semicolon
)brace
id|result
op_assign
id|fdc_seek
c_func
(paren
id|track
)paren
suffix:semicolon
multiline_comment|/*  position is no longer valid after any of these commands&n;&t;&t; *  have completed.&n;&t;&t; */
r_if
c_cond
(paren
id|qic117_cmds
(braket
id|command
)braket
dot
id|cmd_type
op_eq
id|motion
op_logical_and
id|command
op_ne
id|QIC_LOGICAL_FORWARD
op_logical_and
id|command
op_ne
id|QIC_STOP_TAPE
)paren
(brace
id|location.known
op_assign
l_int|0
suffix:semicolon
)brace
id|command_parameter
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* always turned off for next command */
id|current_command
op_assign
id|command
suffix:semicolon
)brace
op_decrement
id|level
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*      Send a tape command parameter:&n; *      Generates command # of step pulses.&n; *      Skips tape-status call !&n; */
DECL|function|ftape_parameter
r_int
id|ftape_parameter
c_func
(paren
r_int
id|command
)paren
(brace
id|command_parameter
op_assign
l_int|1
suffix:semicolon
r_return
id|ftape_command
c_func
(paren
id|command
op_plus
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*      Wait for the drive to get ready.&n; *      timeout time in milli-seconds&n; *      Returned status is valid if result != -EIO&n; */
DECL|function|ftape_ready_wait
r_int
id|ftape_ready_wait
c_func
(paren
r_int
id|timeout
comma
r_int
op_star
id|status
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_ready_wait&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
r_int
id|t0
suffix:semicolon
r_const
r_int
id|poll_delay
op_assign
l_int|100
op_star
id|MILLISECOND
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|t0
op_assign
id|jiffies
suffix:semicolon
id|result
op_assign
id|ftape_report_raw_drive_status
c_func
(paren
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;ftape_report_raw_drive_status failed&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|status
op_amp
id|QIC_STATUS_READY
)paren
(brace
id|result
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timeout
op_ge
l_int|0
)paren
(brace
multiline_comment|/* this will fail when jiffies wraps around about&n;&t;&t;&t; * once every year :-)&n;&t;&t;&t; */
id|timeout
op_sub_assign
(paren
(paren
id|jiffies
op_minus
id|t0
)paren
op_star
id|SECOND
)paren
op_div
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|timeout
op_le
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;timeout&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|ETIME
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ftape_sleep
c_func
(paren
id|poll_delay
)paren
suffix:semicolon
id|timeout
op_sub_assign
id|poll_delay
suffix:semicolon
)brace
r_else
(brace
id|ftape_sleep
c_func
(paren
id|poll_delay
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
id|_NEVER_BLOCK
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;interrupted by fatal signal&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* exit on signal */
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*      Issue command and wait up to timeout seconds for drive ready&n; */
DECL|function|ftape_command_wait
r_int
id|ftape_command_wait
c_func
(paren
r_int
id|command
comma
r_int
id|timeout
comma
r_int
op_star
id|status
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_command_wait&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* Drive should be ready, issue command&n;&t; */
id|result
op_assign
id|ftape_command
c_func
(paren
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|result
op_assign
id|ftape_ready_wait
c_func
(paren
id|timeout
comma
id|status
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|ftape_parameter_wait
r_int
id|ftape_parameter_wait
c_func
(paren
r_int
id|command
comma
r_int
id|timeout
comma
r_int
op_star
id|status
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_parameter_wait&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* Drive should be ready, issue command&n;&t; */
id|result
op_assign
id|ftape_parameter
c_func
(paren
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|result
op_assign
id|ftape_ready_wait
c_func
(paren
id|timeout
comma
id|status
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*--------------------------------------------------------------------------&n; *      Report operations&n; */
multiline_comment|/* Query the drive about its status.  The command is sent and&n;   result_length bits of status are returned (2 extra bits are read&n;   for start and stop). */
DECL|function|ftape_report_operation
r_static
r_int
id|ftape_report_operation
c_func
(paren
r_int
op_star
id|status
comma
r_int
id|command
comma
r_int
id|result_length
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_report_operation&quot;
)paren
suffix:semicolon
r_int
id|i
comma
id|st3
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
r_int
id|t0
comma
id|t1
comma
id|dt
suffix:semicolon
id|result
op_assign
id|ftape_command
c_func
(paren
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;ftape_command failed&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|t0
op_assign
id|timestamp
c_func
(paren
)paren
suffix:semicolon
id|dt
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
op_increment
id|i
suffix:semicolon
id|ftape_sleep
c_func
(paren
l_int|3
op_star
id|MILLISECOND
)paren
suffix:semicolon
multiline_comment|/* see remark below */
id|result
op_assign
id|fdc_sense_drive_status
c_func
(paren
op_amp
id|st3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;fdc_sense_drive_status failed&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*  Calculate time difference every iteration because timer may&n;&t;&t; *  wrap around (but only one !) and timediff will account for this.&n;&t;&t; *  Note that the sleep above must be &lt; 1/HZ or we&squot;ll lose ticks !&n;&t;&t; */
id|t1
op_assign
id|timestamp
c_func
(paren
)paren
suffix:semicolon
id|dt
op_add_assign
id|timediff
c_func
(paren
id|t0
comma
id|t1
)paren
suffix:semicolon
id|t0
op_assign
id|t1
suffix:semicolon
multiline_comment|/*  Ack should be asserted within Ttimout + Tack = 6 msec.&n;&t;&t; *  Looks like some drives fail to do this so extend this&n;&t;&t; *  period to 300 msec.&n;&t;&t; */
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|st3
op_amp
id|ST3_TRACK_0
)paren
op_logical_and
id|dt
OL
l_int|300000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st3
op_amp
id|ST3_TRACK_0
)paren
(brace
multiline_comment|/*  dt may be larger than expected because of other tasks&n;&t;&t; *  scheduled while we were sleeping.&n;&t;&t; */
r_if
c_cond
(paren
id|i
OG
l_int|1
op_logical_and
id|dt
OG
l_int|6000
)paren
(brace
id|TRACEx2
c_func
(paren
l_int|1
comma
l_string|&quot;Acknowledge after %u msec. (%i iter)&quot;
comma
id|dt
op_div
l_int|1000
comma
id|i
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|TRACEx2
c_func
(paren
l_int|1
comma
l_string|&quot;No acknowledge after %u msec. (%i iter)&quot;
comma
id|dt
op_div
l_int|1000
comma
id|i
)paren
suffix:semicolon
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;timeout on Acknowledge&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
op_star
id|status
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|result_length
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|result
op_assign
id|ftape_command
c_func
(paren
id|QIC_REPORT_NEXT_BIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;report next bit failed&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
macro_line|#if 1
multiline_comment|/*  fdc_seek does interrupt wait, so why should we ?&n;&t;&t; *  (it will only fail causing fdc to be reset...)&n;&t;&t; *  It&squot;s only purpose may be the delay, we&squot;ll have to find out!&n;&t;&t; */
macro_line|#else
id|fdc_interrupt_wait
c_func
(paren
l_int|25
op_star
id|MILLISECOND
)paren
suffix:semicolon
multiline_comment|/* fails only if hw fails */
macro_line|#endif
id|result
op_assign
id|fdc_sense_drive_status
c_func
(paren
op_amp
id|st3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;fdc_sense_drive_status (2) failed&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|result_length
)paren
(brace
op_star
id|status
op_or_assign
(paren
(paren
id|st3
op_amp
id|ST3_TRACK_0
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
op_lshift
id|i
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|st3
op_amp
id|ST3_TRACK_0
)paren
op_eq
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;missing status stop bit&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* this command will put track zero and index back into normal state */
id|result
op_assign
id|ftape_command
c_func
(paren
id|QIC_REPORT_NEXT_BIT
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Report the current drive status. */
DECL|function|ftape_report_raw_drive_status
r_int
id|ftape_report_raw_drive_status
c_func
(paren
r_int
op_star
id|status
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_report_raw_drive_status&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|result
op_assign
id|ftape_report_operation
c_func
(paren
id|status
comma
id|QIC_REPORT_DRIVE_STATUS
comma
l_int|8
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|result
OL
l_int|0
op_logical_and
op_increment
id|count
op_le
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;report_operation failed&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|status
op_amp
id|QIC_STATUS_READY
)paren
(brace
id|current_command
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* completed */
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|ftape_report_drive_status
r_int
id|ftape_report_drive_status
c_func
(paren
r_int
op_star
id|status
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_report_drive_status&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
id|result
op_assign
id|ftape_report_raw_drive_status
c_func
(paren
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;ftape_report_raw_drive_status failed&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|status
op_amp
id|QIC_STATUS_NEW_CARTRIDGE
op_logical_or
op_logical_neg
(paren
op_star
id|status
op_amp
id|QIC_STATUS_CARTRIDGE_PRESENT
)paren
)paren
(brace
id|ftape_failure
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* will inhibit further operations */
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|status
op_amp
id|QIC_STATUS_READY
op_logical_and
op_star
id|status
op_amp
id|QIC_STATUS_ERROR
)paren
(brace
multiline_comment|/*  Let caller handle all errors */
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;warning: error status set!&quot;
)paren
suffix:semicolon
id|result
op_assign
l_int|1
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|ftape_report_error
r_int
id|ftape_report_error
c_func
(paren
r_int
op_star
id|error
comma
r_int
op_star
id|command
comma
r_int
id|report
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_report_error&quot;
)paren
suffix:semicolon
r_int
id|code
suffix:semicolon
r_int
id|result
suffix:semicolon
id|result
op_assign
id|ftape_report_operation
c_func
(paren
op_amp
id|code
comma
id|QIC_REPORT_ERROR_CODE
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
op_star
id|error
op_assign
id|code
op_amp
l_int|0xff
suffix:semicolon
op_star
id|command
op_assign
(paren
id|code
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|report
)paren
(brace
r_if
c_cond
(paren
op_star
id|error
op_ne
l_int|0
)paren
(brace
id|TRACEi
c_func
(paren
l_int|3
comma
l_string|&quot;errorcode:&quot;
comma
op_star
id|error
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|3
comma
l_string|&quot;No error&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|report
op_logical_and
op_star
id|error
op_ne
l_int|0
op_logical_and
id|tracing
OG
l_int|3
)paren
(brace
r_if
c_cond
(paren
op_star
id|error
op_ge
l_int|0
op_logical_and
op_star
id|error
OL
id|NR_ITEMS
c_func
(paren
id|ftape_errors
)paren
)paren
(brace
id|TRACEx1
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;%sFatal ERROR:&quot;
comma
(paren
id|ftape_errors
(braket
op_star
id|error
)braket
dot
id|fatal
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;Non-&quot;
)paren
)paren
suffix:semicolon
id|TRACEx1
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;%s ...&quot;
comma
id|ftape_errors
(braket
op_star
id|error
)braket
dot
id|message
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;Unknown ERROR !&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|command
op_ge
l_int|0
op_logical_and
op_star
id|command
OL
id|NR_ITEMS
c_func
(paren
id|qic117_cmds
)paren
op_logical_and
id|qic117_cmds
(braket
op_star
id|command
)braket
dot
id|name
op_ne
l_int|NULL
)paren
(brace
id|TRACEx1
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;... caused by command &bslash;&squot;%s&bslash;&squot;&quot;
comma
id|qic117_cmds
(braket
op_star
id|command
)braket
dot
id|name
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACEi
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;... caused by unknown command&quot;
comma
op_star
id|command
)paren
suffix:semicolon
)brace
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|ftape_in_error_state
r_int
id|ftape_in_error_state
c_func
(paren
r_int
id|status
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_in_error_state&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|QIC_STATUS_READY
)paren
op_logical_and
(paren
id|status
op_amp
id|QIC_STATUS_ERROR
)paren
)paren
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;warning: error status set!&quot;
)paren
suffix:semicolon
id|result
op_assign
l_int|1
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|ftape_report_configuration
r_static
r_int
id|ftape_report_configuration
c_func
(paren
id|qic_model
op_star
id|model
comma
r_int
op_star
id|rate
comma
r_int
op_star
id|qic_std
comma
r_int
op_star
id|tape_len
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|config
suffix:semicolon
r_int
id|status
suffix:semicolon
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_report_configuration&quot;
)paren
suffix:semicolon
id|result
op_assign
id|ftape_report_operation
c_func
(paren
op_amp
id|config
comma
id|QIC_REPORT_DRIVE_CONFIGURATION
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
op_star
id|model
op_assign
id|prehistoric
suffix:semicolon
op_star
id|rate
op_assign
id|QIC_CONFIG_RATE_500
suffix:semicolon
op_star
id|qic_std
op_assign
id|QIC_TAPE_QIC40
suffix:semicolon
op_star
id|tape_len
op_assign
l_int|205
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_star
id|rate
op_assign
(paren
id|config
op_amp
id|QIC_CONFIG_RATE_MASK
)paren
op_rshift
id|QIC_CONFIG_RATE_SHIFT
suffix:semicolon
id|result
op_assign
id|ftape_report_operation
c_func
(paren
op_amp
id|status
comma
id|QIC_REPORT_TAPE_STATUS
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* pre- QIC117 rev C spec. drive, QIC_CONFIG_80 bit is valid.&n;&t;&t;&t; */
op_star
id|qic_std
op_assign
(paren
id|config
op_amp
id|QIC_CONFIG_80
)paren
ques
c_cond
id|QIC_TAPE_QIC80
suffix:colon
id|QIC_TAPE_QIC40
suffix:semicolon
op_star
id|tape_len
op_assign
(paren
id|config
op_amp
id|QIC_CONFIG_LONG
)paren
ques
c_cond
l_int|307
suffix:colon
l_int|205
suffix:semicolon
op_star
id|model
op_assign
id|pre_qic117c
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_star
id|model
op_assign
id|post_qic117b
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|8
comma
l_string|&quot;report tape status result = %02x&quot;
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* post- QIC117 rev C spec. drive, QIC_CONFIG_80 bit is invalid.&n;&t;&t;&t; */
r_switch
c_cond
(paren
id|status
op_amp
id|QIC_TAPE_STD_MASK
)paren
(brace
r_case
id|QIC_TAPE_QIC40
suffix:colon
r_case
id|QIC_TAPE_QIC80
suffix:colon
r_case
id|QIC_TAPE_QIC3020
suffix:colon
r_case
id|QIC_TAPE_QIC3010
suffix:colon
op_star
id|qic_std
op_assign
id|status
op_amp
id|QIC_TAPE_STD_MASK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|qic_std
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|status
op_amp
id|QIC_TAPE_LEN_MASK
)paren
(brace
r_case
id|QIC_TAPE_205FT
suffix:colon
multiline_comment|/* Unfortunately the new QIC-117 rev G standard shows&n;&t;&t;&t;&t; * no way to discriminate between 205 and 425 ft tapes.&n;&t;&t;&t;&t; * The obvious way seems not to be used: the QIC_CONFIG_LONG&n;&t;&t;&t;&t; * bit isn&squot;t used for this (on all drives ?).&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|config
op_amp
id|QIC_CONFIG_LONG
)paren
(brace
op_star
id|tape_len
op_assign
l_int|425
suffix:semicolon
multiline_comment|/* will this ever execute ??? */
)brace
r_else
(brace
op_star
id|tape_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* length unknown: 205 or 425 ft. */
)brace
r_break
suffix:semicolon
r_case
id|QIC_TAPE_307FT
suffix:colon
op_star
id|tape_len
op_assign
l_int|307
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_400FT
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Trouble! Iomega Ditto 800 and Conner TST800R drives reports&n;&t;&t;&t;&t; * 400ft for 750ft tapes. Yuck, yuck, yuck.  Since the value&n;&t;&t;&t;&t; * is only used to compute a timeout value, the largest of the&n;&t;&t;&t;&t; * two is used.&n;&t;&t;&t;&t; */
op_star
id|tape_len
op_assign
l_int|750
suffix:semicolon
multiline_comment|/* either 400 or 750 ft. */
r_break
suffix:semicolon
r_case
id|QIC_TAPE_1100FT
suffix:colon
op_star
id|tape_len
op_assign
l_int|1100
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_FLEX
suffix:colon
op_star
id|tape_len
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|tape_len
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|qic_std
op_eq
op_minus
l_int|1
op_logical_or
op_star
id|tape_len
op_eq
op_minus
l_int|1
)paren
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;post qic-117b spec drive with unknown tape&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
(paren
id|result
OL
l_int|0
)paren
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_report_rom_version
r_int
id|ftape_report_rom_version
c_func
(paren
r_int
op_star
id|version
)paren
(brace
r_int
id|result
suffix:semicolon
id|result
op_assign
id|ftape_report_operation
c_func
(paren
id|version
comma
id|QIC_REPORT_ROM_VERSION
comma
l_int|8
)paren
suffix:semicolon
r_return
(paren
id|result
OL
l_int|0
)paren
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_report_signature
r_int
id|ftape_report_signature
c_func
(paren
r_int
op_star
id|signature
)paren
(brace
r_int
id|result
suffix:semicolon
id|result
op_assign
id|ftape_command
c_func
(paren
l_int|28
)paren
suffix:semicolon
id|result
op_assign
id|ftape_report_operation
c_func
(paren
id|signature
comma
l_int|9
comma
l_int|8
)paren
suffix:semicolon
id|result
op_assign
id|ftape_command
c_func
(paren
l_int|30
)paren
suffix:semicolon
r_return
(paren
id|result
OL
l_int|0
)paren
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_report_vendor_id
r_void
id|ftape_report_vendor_id
c_func
(paren
r_int
r_int
op_star
id|id
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_report_vendor_id&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/*&n;&t; *    We&squot;ll try to get a vendor id from the drive.&n;&t; *    First according to the QIC-117 spec, a 16-bit id is requested.&n;&t; *    If that fails we&squot;ll try an 8-bit version, otherwise we&squot;ll try&n;&t; *    an undocumented query.&n;&t; */
id|result
op_assign
id|ftape_report_operation
c_func
(paren
(paren
r_int
op_star
)paren
id|id
comma
id|QIC_REPORT_VENDOR_ID
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|result
op_assign
id|ftape_report_operation
c_func
(paren
(paren
r_int
op_star
)paren
id|id
comma
id|QIC_REPORT_VENDOR_ID
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/*  The following is an undocumented call found in the CMS code.&n;&t;&t;&t; */
id|result
op_assign
id|ftape_report_operation
c_func
(paren
(paren
r_int
op_star
)paren
id|id
comma
l_int|24
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
op_star
id|id
op_assign
id|UNKNOWN_VENDOR
suffix:semicolon
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;got old 8 bit id: %04x&quot;
comma
op_star
id|id
)paren
suffix:semicolon
op_star
id|id
op_or_assign
l_int|0x20000
suffix:semicolon
)brace
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;got 8 bit id: %04x&quot;
comma
op_star
id|id
)paren
suffix:semicolon
op_star
id|id
op_or_assign
l_int|0x10000
suffix:semicolon
)brace
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;got 16 bit id: %04x&quot;
comma
op_star
id|id
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|id
op_eq
l_int|0x0047
)paren
(brace
r_int
id|version
suffix:semicolon
r_int
id|sign
suffix:semicolon
id|result
op_assign
id|ftape_report_rom_version
c_func
(paren
op_amp
id|version
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;report rom version failed&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
suffix:semicolon
)brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;CMS rom version: %d&quot;
comma
id|version
)paren
suffix:semicolon
id|ftape_command
c_func
(paren
id|QIC_ENTER_DIAGNOSTIC_1
)paren
suffix:semicolon
id|ftape_command
c_func
(paren
id|QIC_ENTER_DIAGNOSTIC_1
)paren
suffix:semicolon
id|result
op_assign
id|ftape_report_operation
c_func
(paren
op_amp
id|sign
comma
l_int|9
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
r_int
id|error
comma
id|command
suffix:semicolon
id|ftape_report_error
c_func
(paren
op_amp
id|error
comma
op_amp
id|command
comma
l_int|1
)paren
suffix:semicolon
id|ftape_command
c_func
(paren
id|QIC_ENTER_PRIMARY_MODE
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* faalt hier ! */
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;CMS signature: %02x&quot;
comma
id|sign
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sign
op_eq
l_int|0xa5
)paren
(brace
id|result
op_assign
id|ftape_report_operation
c_func
(paren
op_amp
id|sign
comma
l_int|37
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|version
op_ge
l_int|63
)paren
(brace
op_star
id|id
op_assign
l_int|0x8880
suffix:semicolon
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;This is an Iomega drive !&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|id
op_assign
l_int|0x0047
suffix:semicolon
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;This is a real CMS drive !&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
op_star
id|id
op_assign
l_int|0x0047
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;CMS status: %d&quot;
comma
id|sign
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
op_star
id|id
op_assign
id|UNKNOWN_VENDOR
suffix:semicolon
)brace
id|ftape_command
c_func
(paren
id|QIC_ENTER_PRIMARY_MODE
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|ftape_set_rate_test
r_void
id|ftape_set_rate_test
c_func
(paren
r_int
op_star
id|supported
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_set_rate_test&quot;
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|command
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|status
suffix:semicolon
multiline_comment|/*  Check if the drive does support the select rate command by testing&n;&t; *  all different settings.&n;&t; *  If any one is accepted we assume the command is supported, else not.&n;&t; */
op_star
id|supported
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_ITEMS
c_func
(paren
id|rates
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
id|result
op_assign
id|ftape_command
c_func
(paren
id|QIC_SELECT_RATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|result
op_assign
id|ftape_parameter_wait
c_func
(paren
id|rates
(braket
id|i
)braket
dot
id|drive_code
comma
l_int|1
op_star
id|SECOND
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
id|QIC_STATUS_ERROR
)paren
(brace
id|result
op_assign
id|ftape_report_error
c_func
(paren
op_amp
id|error
comma
op_amp
id|command
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|supported
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* did accept a request */
)brace
)brace
)brace
)brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;Select Rate command is%s supported&quot;
comma
op_star
id|supported
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; not&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|ftape_set_data_rate
r_int
id|ftape_set_data_rate
c_func
(paren
r_int
id|new_rate
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_set_data_rate&quot;
)paren
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|data_rate
suffix:semicolon
id|qic_model
id|model
suffix:semicolon
r_int
id|supported
suffix:semicolon
r_static
r_int
id|first_time
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|first_time
)paren
(brace
id|ftape_set_rate_test
c_func
(paren
op_amp
id|supported
)paren
suffix:semicolon
id|first_time
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rates
(braket
id|new_rate
)braket
dot
id|fdc_code
op_eq
op_minus
l_int|1
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;%sb/s data rate not supported by the fdc&quot;
comma
id|rates
(braket
id|new_rate
)braket
dot
id|text
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|command
suffix:semicolon
id|result
op_assign
id|ftape_command
c_func
(paren
id|QIC_SELECT_RATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|result
op_assign
id|ftape_parameter_wait
c_func
(paren
id|rates
(braket
id|new_rate
)braket
dot
id|drive_code
comma
l_int|1
op_star
id|SECOND
comma
op_amp
id|status
)paren
suffix:semicolon
id|result
op_assign
id|ftape_report_raw_drive_status
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
op_logical_and
(paren
id|status
op_amp
id|QIC_STATUS_ERROR
)paren
)paren
(brace
id|result
op_assign
id|ftape_report_error
c_func
(paren
op_amp
id|error
comma
op_amp
id|command
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
op_logical_and
id|supported
op_logical_and
id|error
op_eq
l_int|31
op_logical_and
id|command
op_eq
id|QIC_SELECT_RATE
)paren
(brace
id|result
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|result
op_assign
id|ftape_report_configuration
c_func
(paren
op_amp
id|model
comma
op_amp
id|data_rate
comma
op_amp
id|qic_std
comma
op_amp
id|tape_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
op_logical_and
id|data_rate
op_ne
id|rates
(braket
id|new_rate
)braket
dot
id|drive_code
)paren
(brace
id|result
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;could not set %sb/s data rate&quot;
comma
id|rates
(braket
id|new_rate
)braket
dot
id|text
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACEx2
c_func
(paren
l_int|2
comma
l_string|&quot;%s drive @ %sb/s&quot;
comma
(paren
id|model
op_eq
id|prehistoric
)paren
ques
c_cond
l_string|&quot;prehistoric&quot;
suffix:colon
(paren
(paren
id|model
op_eq
id|pre_qic117c
)paren
ques
c_cond
l_string|&quot;pre QIC-117C&quot;
suffix:colon
(paren
(paren
id|model
op_eq
id|post_qic117b
)paren
ques
c_cond
l_string|&quot;post QIC-117B&quot;
suffix:colon
l_string|&quot;post QIC-117D&quot;
)paren
)paren
comma
id|rates
(braket
id|new_rate
)braket
dot
id|text
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape_len
op_eq
l_int|0
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|2
comma
l_string|&quot;unknown length QIC-%s tape&quot;
comma
(paren
id|qic_std
op_eq
id|QIC_TAPE_QIC40
)paren
ques
c_cond
l_string|&quot;40&quot;
suffix:colon
(paren
(paren
id|qic_std
op_eq
id|QIC_TAPE_QIC80
)paren
ques
c_cond
l_string|&quot;80&quot;
suffix:colon
(paren
(paren
id|qic_std
op_eq
id|QIC_TAPE_QIC3010
)paren
ques
c_cond
l_string|&quot;3010&quot;
suffix:colon
l_string|&quot;3020&quot;
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACEx2
c_func
(paren
l_int|2
comma
l_string|&quot;%d ft. QIC-%s tape&quot;
comma
id|tape_len
comma
(paren
id|qic_std
op_eq
id|QIC_TAPE_QIC40
)paren
ques
c_cond
l_string|&quot;40&quot;
suffix:colon
(paren
(paren
id|qic_std
op_eq
id|QIC_TAPE_QIC80
)paren
ques
c_cond
l_string|&quot;80&quot;
suffix:colon
(paren
(paren
id|qic_std
op_eq
id|QIC_TAPE_QIC3010
)paren
ques
c_cond
l_string|&quot;3010&quot;
suffix:colon
l_string|&quot;3020&quot;
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *  Set data rate and write precompensation as specified:&n;&t;&t;&t; *&n;&t;&t;&t; *            |  QIC-40/80  | QIC-3010/3020&n;&t;&t;&t; *   rate     |   precomp   |    precomp&n;&t;&t;&t; *  ----------+-------------+--------------&n;&t;&t;&t; *  250 Kbps. |   250 ns.   |     0 ns.&n;&t;&t;&t; *  500 Kbps. |   125 ns.   |     0 ns.&n;&t;&t;&t; *    1 Mbps. |    42 ns.   |     0 ns.&n;&t;&t;&t; *    2 Mbps  |      N/A    |     0 ns.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|qic_std
op_eq
id|QIC_TAPE_QIC40
op_logical_or
id|qic_std
op_eq
id|QIC_TAPE_QIC80
)paren
(brace
id|fdc_set_write_precomp
c_func
(paren
id|rates
(braket
id|new_rate
)braket
dot
id|precomp
)paren
suffix:semicolon
)brace
r_else
(brace
id|fdc_set_write_precomp
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|fdc_set_data_rate
c_func
(paren
id|rates
(braket
id|new_rate
)braket
dot
id|fdc_code
)paren
suffix:semicolon
id|ftape_data_rate
op_assign
id|new_rate
suffix:semicolon
multiline_comment|/* store rate set */
)brace
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
op_logical_and
id|result
op_ne
op_minus
id|EINVAL
)paren
(brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*      Seek the head to the specified track.&n; */
DECL|function|ftape_seek_head_to_track
r_int
id|ftape_seek_head_to_track
c_func
(paren
r_int
id|track
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_seek_head_to_track&quot;
)paren
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|result
suffix:semicolon
id|location.track
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* remains set in case of error */
r_if
c_cond
(paren
id|track
OL
l_int|0
op_logical_or
id|track
op_ge
id|tracks_per_tape
)paren
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;track out of bounds&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;seeking track %d&quot;
comma
id|track
)paren
suffix:semicolon
id|result
op_assign
id|ftape_command
c_func
(paren
id|QIC_SEEK_HEAD_TO_TRACK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;ftape_command failed&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
id|ftape_parameter_wait
c_func
(paren
id|track
comma
id|timeout.head_seek
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;ftape_parameter_wait failed&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|location.track
op_assign
id|track
suffix:semicolon
id|might_be_off_track
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|ftape_wakeup_drive
r_int
id|ftape_wakeup_drive
c_func
(paren
id|wake_up_types
id|method
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_wakeup_drive&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|motor_on
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|method
)paren
(brace
r_case
id|wake_up_colorado
suffix:colon
id|result
op_assign
id|ftape_command
c_func
(paren
id|QIC_PHANTOM_SELECT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|result
op_assign
id|ftape_parameter
c_func
(paren
multiline_comment|/* unit */
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|wake_up_mountain
suffix:colon
id|result
op_assign
id|ftape_command
c_func
(paren
id|QIC_SOFT_SELECT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|ftape_sleep
c_func
(paren
id|MILLISECOND
)paren
suffix:semicolon
multiline_comment|/* NEEDED */
id|result
op_assign
id|ftape_parameter
c_func
(paren
l_int|18
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|wake_up_insight
suffix:colon
id|ftape_sleep
c_func
(paren
l_int|100
op_star
id|MILLISECOND
)paren
suffix:semicolon
id|motor_on
op_assign
l_int|1
suffix:semicolon
id|fdc_motor
c_func
(paren
id|motor_on
)paren
suffix:semicolon
multiline_comment|/* enable is done by motor-on */
r_case
id|no_wake_up
suffix:colon
id|result
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|result
op_assign
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* unknown wakeup method */
)brace
multiline_comment|/*  If wakeup succeeded we shouldn&squot;t get an error here..&n;&t; */
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|result
op_assign
id|ftape_report_raw_drive_status
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
op_logical_and
id|motor_on
)paren
(brace
id|fdc_motor
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* motor off if failed */
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|ftape_put_drive_to_sleep
r_int
id|ftape_put_drive_to_sleep
c_func
(paren
id|vendor_struct
id|drive_type
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_put_drive_to_sleep&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
r_switch
c_cond
(paren
id|drive_type.wake_up
)paren
(brace
r_case
id|wake_up_colorado
suffix:colon
id|result
op_assign
id|ftape_command
c_func
(paren
id|QIC_PHANTOM_DESELECT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|wake_up_mountain
suffix:colon
id|result
op_assign
id|ftape_command
c_func
(paren
id|QIC_SOFT_DESELECT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|wake_up_insight
suffix:colon
id|fdc_motor
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* enable is done by motor-on */
r_case
id|no_wake_up
suffix:colon
multiline_comment|/* no wakeup / no sleep ! */
id|result
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|result
op_assign
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* unknown wakeup method */
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|ftape_reset_drive
r_int
id|ftape_reset_drive
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_reset_drive&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|err_code
suffix:semicolon
r_int
id|err_command
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*    We want to re-establish contact with our drive.&n;&t; *    Fire a number of reset commands (single step pulses)&n;&t; *    and pray for success.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
op_increment
id|i
)paren
(brace
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;Resetting fdc&quot;
)paren
suffix:semicolon
id|fdc_reset
c_func
(paren
)paren
suffix:semicolon
id|ftape_sleep
c_func
(paren
l_int|10
op_star
id|MILLISECOND
)paren
suffix:semicolon
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;Reset command to drive&quot;
)paren
suffix:semicolon
id|result
op_assign
id|ftape_command
c_func
(paren
id|QIC_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|ftape_sleep
c_func
(paren
l_int|1
op_star
id|SECOND
)paren
suffix:semicolon
multiline_comment|/* drive not accessible during 1 second */
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;Re-selecting drive&quot;
)paren
suffix:semicolon
multiline_comment|/*  Strange, the QIC-117 specs don&squot;t mention this but the&n;&t;&t;&t; *  drive gets deselected after a soft reset !&n;&t;&t;&t; *  So we need to enable it again.&n;&t;&t;&t; */
id|result
op_assign
id|ftape_wakeup_drive
c_func
(paren
id|drive_type.wake_up
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;Wakeup failed !&quot;
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;Waiting until drive gets ready&quot;
)paren
suffix:semicolon
id|result
op_assign
id|ftape_ready_wait
c_func
(paren
id|timeout.reset
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_and
id|status
op_amp
id|QIC_STATUS_ERROR
)paren
(brace
id|result
op_assign
id|ftape_report_error
c_func
(paren
op_amp
id|err_code
comma
op_amp
id|err_command
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_and
id|err_code
op_eq
l_int|27
)paren
(brace
multiline_comment|/* Okay, drive saw reset command and responded as it should&n;&t;&t;&t;&t;&t; */
r_break
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_else
(brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
id|_DONT_BLOCK
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;aborted by non-blockable signal&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* exit on signal */
)brace
)brace
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;General failure to reset tape drive&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  Restore correct settings&n;&t;&t; */
id|ftape_set_data_rate
c_func
(paren
id|ftape_data_rate
)paren
suffix:semicolon
multiline_comment|/* keep original rate */
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
eof
