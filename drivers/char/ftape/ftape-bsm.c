multiline_comment|/*&n; *      Copyright (C) 1994-1995 Bas Laarhoven.&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; $Source: /home/bas/distr/ftape-2.03b/RCS/ftape-bsm.c,v $&n; $Author: bas $&n; *&n; $Revision: 1.7 $&n; $Date: 1995/04/30 13:15:14 $&n; $State: Beta $&n; *&n; *      This file contains the bad-sector map handling code for&n; *      the QIC-117 floppy tape driver for Linux.&n; *      QIC-40, QIC-80, QIC-3010 and QIC-3020 maps are implemented.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &quot;tracing.h&quot;
macro_line|#include &quot;ftape-bsm.h&quot;
macro_line|#include &quot;ftape-ctl.h&quot;
macro_line|#include &quot;ftape-rw.h&quot;
multiline_comment|/*      Global vars.&n; */
DECL|variable|bad_sector_map_changed
r_int
id|bad_sector_map_changed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*      Local vars.&n; */
DECL|variable|bad_sector_map
r_static
id|byte
id|bad_sector_map
(braket
id|BAD_SECTOR_MAP_SIZE
)braket
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|forward
DECL|enumerator|backward
id|forward
comma
id|backward
DECL|typedef|mode_type
)brace
id|mode_type
suffix:semicolon
macro_line|#if 0
multiline_comment|/*  fix_tape converts a normal QIC-80 tape into a &squot;wide&squot; tape.&n; *  For testing purposes only !&n; */
r_void
id|fix_tape
c_func
(paren
id|byte
op_star
id|buffer
)paren
(brace
r_static
id|byte
id|list
(braket
id|BAD_SECTOR_MAP_SIZE
)braket
suffix:semicolon
r_int
r_int
op_star
id|src_ptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|list
suffix:semicolon
id|byte
op_star
id|dst_ptr
op_assign
id|bad_sector_map
suffix:semicolon
r_int
r_int
id|map
suffix:semicolon
r_int
id|sector
op_assign
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memcpy
c_func
(paren
id|list
comma
id|bad_sector_map
comma
r_sizeof
(paren
id|list
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bad_sector_map
comma
l_int|0
comma
r_sizeof
(paren
id|bad_sector_map
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|byte
op_star
)paren
id|src_ptr
op_minus
id|list
OL
r_sizeof
(paren
id|list
)paren
)paren
(brace
id|map
op_assign
op_star
id|src_ptr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|map
op_eq
id|EMPTY_SEGMENT
)paren
(brace
op_star
(paren
r_int
r_int
op_star
)paren
id|dst_ptr
op_assign
l_int|0x800000
op_plus
id|sector
suffix:semicolon
id|dst_ptr
op_add_assign
l_int|3
suffix:semicolon
id|sector
op_add_assign
id|SECTORS_PER_SEGMENT
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SECTORS_PER_SEGMENT
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|map
op_amp
l_int|1
)paren
(brace
op_star
(paren
r_int
r_int
op_star
)paren
id|dst_ptr
op_assign
id|sector
suffix:semicolon
id|dst_ptr
op_add_assign
l_int|3
suffix:semicolon
)brace
id|map
op_rshift_assign
l_int|1
suffix:semicolon
op_increment
id|sector
suffix:semicolon
)brace
)brace
)brace
id|bad_sector_map_changed
op_assign
l_int|1
suffix:semicolon
op_star
(paren
id|buffer
op_plus
l_int|4
)paren
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* put new format code */
id|format_code
op_assign
l_int|4
suffix:semicolon
)brace
macro_line|#endif
id|byte
op_star
DECL|function|find_end_of_bsm_list
id|find_end_of_bsm_list
c_func
(paren
id|byte
op_star
id|ptr
comma
id|byte
op_star
id|limit
)paren
(brace
r_while
c_loop
(paren
id|ptr
op_plus
l_int|2
OL
id|limit
)paren
(brace
r_if
c_cond
(paren
id|ptr
(braket
l_int|0
)braket
op_logical_or
id|ptr
(braket
l_int|1
)braket
op_logical_or
id|ptr
(braket
l_int|2
)braket
)paren
(brace
id|ptr
op_add_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
r_return
id|ptr
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|store_bad_sector_map
r_void
id|store_bad_sector_map
c_func
(paren
id|byte
op_star
id|buffer
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;store_bad_sector_map&quot;
)paren
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|offset
suffix:semicolon
multiline_comment|/*  Store the bad sector map in buffer.&n;&t; */
r_if
c_cond
(paren
id|format_code
op_eq
l_int|4
)paren
(brace
id|offset
op_assign
l_int|256
suffix:semicolon
id|count
op_assign
r_sizeof
(paren
id|bad_sector_map
)paren
suffix:semicolon
)brace
r_else
(brace
id|offset
op_assign
l_int|2
op_star
id|SECTOR_SIZE
suffix:semicolon
multiline_comment|/* skip failed sector log */
id|count
op_assign
r_sizeof
(paren
id|bad_sector_map
)paren
op_minus
(paren
id|offset
op_minus
l_int|256
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|buffer
op_plus
id|offset
comma
id|bad_sector_map
comma
id|count
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|put_sector
r_void
id|put_sector
c_func
(paren
id|byte
op_star
op_star
id|ptr
comma
r_int
r_int
id|sector
)paren
(brace
op_star
(paren
op_star
id|ptr
)paren
op_increment
op_assign
id|sector
op_amp
l_int|0xff
suffix:semicolon
id|sector
op_rshift_assign
l_int|8
suffix:semicolon
op_star
(paren
op_star
id|ptr
)paren
op_increment
op_assign
id|sector
op_amp
l_int|0xff
suffix:semicolon
id|sector
op_rshift_assign
l_int|8
suffix:semicolon
op_star
(paren
op_star
id|ptr
)paren
op_increment
op_assign
id|sector
op_amp
l_int|0xff
suffix:semicolon
)brace
DECL|function|get_sector
r_int
r_int
id|get_sector
c_func
(paren
id|byte
op_star
op_star
id|ptr
comma
id|mode_type
id|mode
)paren
(brace
r_int
r_int
id|sector
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|forward
)paren
(brace
id|sector
op_assign
op_star
(paren
op_star
id|ptr
)paren
op_increment
suffix:semicolon
id|sector
op_add_assign
op_star
(paren
op_star
id|ptr
)paren
op_increment
op_lshift
l_int|8
suffix:semicolon
id|sector
op_add_assign
op_star
(paren
op_star
id|ptr
)paren
op_increment
op_lshift
l_int|16
suffix:semicolon
)brace
r_else
(brace
id|sector
op_assign
op_star
op_decrement
(paren
op_star
id|ptr
)paren
op_lshift
l_int|16
suffix:semicolon
id|sector
op_add_assign
op_star
op_decrement
(paren
op_star
id|ptr
)paren
op_lshift
l_int|8
suffix:semicolon
id|sector
op_add_assign
op_star
op_decrement
(paren
op_star
id|ptr
)paren
suffix:semicolon
)brace
r_return
id|sector
suffix:semicolon
)brace
DECL|function|extract_bad_sector_map
r_void
id|extract_bad_sector_map
c_func
(paren
id|byte
op_star
id|buffer
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;extract_bad_sector_map&quot;
)paren
suffix:semicolon
multiline_comment|/*  Fill the bad sector map with the contents of buffer.&n;&t; */
r_if
c_cond
(paren
id|format_code
op_eq
l_int|4
)paren
(brace
multiline_comment|/* QIC-3010/3020 and wide QIC-80 tapes no longer have a failed&n;&t;&t; * sector log but use this area to extend the bad sector map.&n;&t;&t; */
id|memcpy
c_func
(paren
id|bad_sector_map
comma
id|buffer
op_plus
l_int|256
comma
r_sizeof
(paren
id|bad_sector_map
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* non-wide QIC-80 tapes have a failed sector log area that&n;&t;&t; * mustn&squot;t be included in the bad sector map.&n;&t;&t; */
id|memcpy
c_func
(paren
id|bad_sector_map
comma
id|buffer
op_plus
l_int|256
op_plus
id|FAILED_SECTOR_LOG_SIZE
comma
r_sizeof
(paren
id|bad_sector_map
)paren
op_minus
id|FAILED_SECTOR_LOG_SIZE
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* for testing of bad sector handling at end of tape&n;&t; */
(paren
(paren
r_int
r_int
op_star
)paren
id|bad_sector_map
)paren
(braket
id|segments_per_track
op_star
id|tracks_per_tape
op_minus
l_int|3
)braket
op_assign
l_int|0x000003e0
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
id|bad_sector_map
)paren
(braket
id|segments_per_track
op_star
id|tracks_per_tape
op_minus
l_int|2
)braket
op_assign
l_int|0xff3fffff
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
id|bad_sector_map
)paren
(braket
id|segments_per_track
op_star
id|tracks_per_tape
op_minus
l_int|1
)braket
op_assign
l_int|0xffffe000
suffix:semicolon
macro_line|#endif
macro_line|#if 0
multiline_comment|/*  Enable to test bad sector handling&n;&t; */
(paren
(paren
r_int
r_int
op_star
)paren
id|bad_sector_map
)paren
(braket
l_int|30
)braket
op_assign
l_int|0xfffffffe
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
id|bad_sector_map
)paren
(braket
l_int|32
)braket
op_assign
l_int|0x7fffffff
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
id|bad_sector_map
)paren
(braket
l_int|34
)braket
op_assign
l_int|0xfffeffff
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
id|bad_sector_map
)paren
(braket
l_int|36
)braket
op_assign
l_int|0x55555555
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
id|bad_sector_map
)paren
(braket
l_int|38
)braket
op_assign
l_int|0xffffffff
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
id|bad_sector_map
)paren
(braket
l_int|50
)braket
op_assign
l_int|0xffff0000
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
id|bad_sector_map
)paren
(braket
l_int|51
)braket
op_assign
l_int|0xffffffff
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
id|bad_sector_map
)paren
(braket
l_int|52
)braket
op_assign
l_int|0xffffffff
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
id|bad_sector_map
)paren
(braket
l_int|53
)braket
op_assign
l_int|0x0000ffff
suffix:semicolon
macro_line|#endif
macro_line|#if 0
multiline_comment|/*  Enable when testing multiple volume tar dumps.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|first_data_segment
suffix:semicolon
id|i
op_le
id|ftape_last_segment.id
op_minus
l_int|7
suffix:semicolon
op_increment
id|i
)paren
(brace
(paren
(paren
r_int
r_int
op_star
)paren
id|bad_sector_map
)paren
(braket
id|i
)braket
op_assign
id|EMPTY_SEGMENT
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if 0
multiline_comment|/*  Enable when testing bit positions in *_error_map&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|first_data_segment
suffix:semicolon
id|i
op_le
id|ftape_last_segment.id
suffix:semicolon
op_increment
id|i
)paren
(brace
(paren
(paren
r_int
r_int
op_star
)paren
id|bad_sector_map
)paren
(braket
id|i
)braket
op_or_assign
l_int|0x00ff00ff
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|tracing
OG
l_int|2
)paren
(brace
r_int
r_int
id|map
suffix:semicolon
r_int
id|good_sectors
op_assign
l_int|0
suffix:semicolon
r_int
id|bad_sectors
suffix:semicolon
r_int
r_int
id|total_bad
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|format_code
op_eq
l_int|4
op_logical_or
id|format_code
op_eq
l_int|3
)paren
(brace
id|byte
op_star
id|ptr
op_assign
id|bad_sector_map
suffix:semicolon
r_int
id|sector
suffix:semicolon
r_do
(brace
id|sector
op_assign
id|get_sector
c_func
(paren
op_amp
id|ptr
comma
id|forward
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sector
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|format_code
op_eq
l_int|4
op_logical_and
id|sector
op_amp
l_int|0x800000
)paren
(brace
id|total_bad
op_add_assign
id|SECTORS_PER_SEGMENT
op_minus
l_int|3
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|6
comma
l_string|&quot;bad segment at sector: %6d&quot;
comma
id|sector
op_amp
l_int|0x7fffff
)paren
suffix:semicolon
)brace
r_else
(brace
op_increment
id|total_bad
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|6
comma
l_string|&quot;bad sector: %6d&quot;
comma
id|sector
)paren
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|sector
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/*  Display end-of-file marks&n;&t;&t;&t; */
r_do
(brace
id|sector
op_assign
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|ptr
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sector
)paren
(brace
id|TRACEx2
c_func
(paren
l_int|4
comma
l_string|&quot;eof mark: %4d/%2d&quot;
comma
id|sector
comma
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|ptr
)paren
op_increment
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|sector
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
id|first_data_segment
suffix:semicolon
id|i
OL
id|segments_per_track
op_star
id|tracks_per_tape
suffix:semicolon
op_increment
id|i
)paren
(brace
id|map
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
id|bad_sector_map
)paren
(braket
id|i
)braket
suffix:semicolon
id|bad_sectors
op_assign
id|count_ones
c_func
(paren
id|map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bad_sectors
OG
l_int|0
)paren
(brace
id|TRACEx2
c_func
(paren
l_int|6
comma
l_string|&quot;bsm for segment %4d: 0x%08x&quot;
comma
id|i
comma
id|map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bad_sectors
OG
id|SECTORS_PER_SEGMENT
op_minus
l_int|3
)paren
(brace
id|bad_sectors
op_assign
id|SECTORS_PER_SEGMENT
op_minus
l_int|3
suffix:semicolon
)brace
id|total_bad
op_add_assign
id|bad_sectors
suffix:semicolon
)brace
)brace
)brace
id|good_sectors
op_assign
(paren
(paren
id|segments_per_track
op_star
id|tracks_per_tape
op_minus
id|first_data_segment
)paren
op_star
(paren
id|SECTORS_PER_SEGMENT
op_minus
l_int|3
)paren
)paren
op_minus
id|total_bad
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|3
comma
l_string|&quot;%d Kb usable on this tape&quot;
comma
id|good_sectors
op_minus
id|ftape_last_segment.free
)paren
suffix:semicolon
r_if
c_cond
(paren
id|total_bad
op_eq
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;WARNING: this tape has no bad blocks registered !&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|2
comma
l_string|&quot;%d bad sectors&quot;
comma
id|total_bad
)paren
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|cvt2map
r_int
r_int
id|cvt2map
c_func
(paren
r_int
id|sector
)paren
(brace
r_return
l_int|1
op_lshift
(paren
(paren
(paren
id|sector
op_amp
l_int|0x7fffff
)paren
op_minus
l_int|1
)paren
op_mod
id|SECTORS_PER_SEGMENT
)paren
suffix:semicolon
)brace
DECL|function|cvt2segment
r_int
id|cvt2segment
c_func
(paren
r_int
id|sector
)paren
(brace
r_return
(paren
(paren
id|sector
op_amp
l_int|0x7fffff
)paren
op_minus
l_int|1
)paren
op_div
id|SECTORS_PER_SEGMENT
suffix:semicolon
)brace
DECL|function|forward_seek_entry
r_int
id|forward_seek_entry
c_func
(paren
r_int
id|segment_id
comma
id|byte
op_star
op_star
id|ptr
comma
r_int
r_int
op_star
id|map
)paren
(brace
id|byte
op_star
id|tmp_ptr
suffix:semicolon
r_int
r_int
id|sector
suffix:semicolon
r_int
id|segment
suffix:semicolon
r_int
id|count
suffix:semicolon
r_do
(brace
id|sector
op_assign
id|get_sector
c_func
(paren
id|ptr
comma
id|forward
)paren
suffix:semicolon
id|segment
op_assign
id|cvt2segment
c_func
(paren
id|sector
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sector
op_ne
l_int|0
op_logical_and
id|segment
OL
id|segment_id
)paren
suffix:semicolon
id|tmp_ptr
op_assign
op_star
id|ptr
op_minus
l_int|3
suffix:semicolon
multiline_comment|/* point to first sector &gt;= segment_id */
multiline_comment|/*  Get all sectors in segment_id&n;&t; */
r_if
c_cond
(paren
id|format_code
op_eq
l_int|4
op_logical_and
(paren
id|sector
op_amp
l_int|0x800000
)paren
op_logical_and
id|segment
op_eq
id|segment_id
)paren
(brace
op_star
id|map
op_assign
id|EMPTY_SEGMENT
suffix:semicolon
id|count
op_assign
l_int|32
suffix:semicolon
)brace
r_else
(brace
op_star
id|map
op_assign
l_int|0
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|sector
op_ne
l_int|0
op_logical_and
id|segment
op_eq
id|segment_id
)paren
(brace
op_star
id|map
op_or_assign
id|cvt2map
c_func
(paren
id|sector
)paren
suffix:semicolon
id|sector
op_assign
id|get_sector
c_func
(paren
id|ptr
comma
id|forward
)paren
suffix:semicolon
id|segment
op_assign
id|cvt2segment
c_func
(paren
id|sector
)paren
suffix:semicolon
op_increment
id|count
suffix:semicolon
)brace
)brace
op_star
id|ptr
op_assign
id|tmp_ptr
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|backwards_seek_entry
r_int
id|backwards_seek_entry
c_func
(paren
r_int
id|segment_id
comma
id|byte
op_star
op_star
id|ptr
comma
r_int
r_int
op_star
id|map
)paren
(brace
r_int
r_int
id|sector
suffix:semicolon
r_int
id|segment
suffix:semicolon
r_int
id|count
suffix:semicolon
op_star
id|map
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ptr
OG
id|bad_sector_map
)paren
(brace
r_do
(brace
id|sector
op_assign
id|get_sector
c_func
(paren
id|ptr
comma
id|backward
)paren
suffix:semicolon
id|segment
op_assign
id|cvt2segment
c_func
(paren
id|sector
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|ptr
OG
id|bad_sector_map
op_logical_and
id|segment
OG
id|segment_id
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|segment
OG
id|segment_id
)paren
(brace
multiline_comment|/*  at start of list, no entry found */
)brace
r_else
r_if
c_cond
(paren
id|segment
OL
id|segment_id
)paren
(brace
multiline_comment|/*  before smaller entry, adjust for overshoot */
op_star
id|ptr
op_add_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  get all sectors in segment_id */
r_if
c_cond
(paren
id|format_code
op_eq
l_int|4
op_logical_and
(paren
id|sector
op_amp
l_int|0x800000
)paren
)paren
(brace
op_star
id|map
op_assign
id|EMPTY_SEGMENT
suffix:semicolon
id|count
op_assign
l_int|32
suffix:semicolon
)brace
r_else
(brace
r_do
(brace
op_star
id|map
op_or_assign
id|cvt2map
c_func
(paren
id|sector
)paren
suffix:semicolon
op_increment
id|count
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ptr
op_le
id|bad_sector_map
)paren
(brace
r_break
suffix:semicolon
)brace
id|sector
op_assign
id|get_sector
c_func
(paren
id|ptr
comma
id|backward
)paren
suffix:semicolon
id|segment
op_assign
id|cvt2segment
c_func
(paren
id|sector
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|segment
op_eq
id|segment_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|segment
OL
id|segment_id
)paren
(brace
op_star
id|ptr
op_add_assign
l_int|3
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
id|count
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|put_bad_sector_entry
r_void
id|put_bad_sector_entry
c_func
(paren
r_int
id|segment_id
comma
r_int
r_int
id|new_map
)paren
(brace
id|byte
op_star
id|ptr
op_assign
id|bad_sector_map
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|new_count
suffix:semicolon
r_int
r_int
id|map
suffix:semicolon
r_if
c_cond
(paren
id|format_code
op_eq
l_int|3
op_logical_or
id|format_code
op_eq
l_int|4
)paren
(brace
id|count
op_assign
id|forward_seek_entry
c_func
(paren
id|segment_id
comma
op_amp
id|ptr
comma
op_amp
id|map
)paren
suffix:semicolon
id|new_count
op_assign
id|count_ones
c_func
(paren
id|new_map
)paren
suffix:semicolon
multiline_comment|/*  If format code == 4 put empty segment instead of 32 bad sectors.&n;&t;&t; */
r_if
c_cond
(paren
id|new_count
op_eq
l_int|32
op_logical_and
id|format_code
op_eq
l_int|4
)paren
(brace
id|new_count
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_ne
id|new_count
)paren
(brace
multiline_comment|/*  insert (or delete if &lt; 0) new_count - count entries.&n;&t;&t;&t; *  Move trailing part of list including terminating 0.&n;&t;&t;&t; */
id|byte
op_star
id|hi_ptr
op_assign
id|ptr
suffix:semicolon
r_do
(brace
)brace
r_while
c_loop
(paren
id|get_sector
c_func
(paren
op_amp
id|hi_ptr
comma
id|forward
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|ptr
op_plus
id|new_count
comma
id|ptr
op_plus
id|count
comma
id|hi_ptr
op_minus
(paren
id|ptr
op_plus
id|count
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_count
op_eq
l_int|1
op_logical_and
id|new_map
op_eq
id|EMPTY_SEGMENT
)paren
(brace
id|put_sector
c_func
(paren
op_amp
id|ptr
comma
l_int|0x800001
op_plus
id|segment_id
op_star
id|SECTORS_PER_SEGMENT
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|new_map
)paren
(brace
r_if
c_cond
(paren
id|new_map
op_amp
l_int|1
)paren
(brace
id|put_sector
c_func
(paren
op_amp
id|ptr
comma
l_int|1
op_plus
id|segment_id
op_star
id|SECTORS_PER_SEGMENT
op_plus
id|i
)paren
suffix:semicolon
)brace
op_increment
id|i
suffix:semicolon
id|new_map
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
(paren
(paren
r_int
r_int
op_star
)paren
id|bad_sector_map
)paren
(braket
id|segment_id
)braket
op_assign
id|new_map
suffix:semicolon
)brace
id|bad_sector_map_changed
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|get_bad_sector_entry
r_int
r_int
id|get_bad_sector_entry
c_func
(paren
r_int
id|segment_id
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;get_bad_sector_entry&quot;
)paren
suffix:semicolon
r_static
r_int
r_int
id|map
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|used_header_segment
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/*  When reading header segment we&squot;ll need a blank map.&n;&t;&t; */
id|map
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|format_code
op_eq
l_int|3
op_logical_or
id|format_code
op_eq
l_int|4
)paren
(brace
multiline_comment|/*  Invariants:&n;&t;&t; *    map - mask value returned on last call.&n;&t;&t; *    ptr - points to first sector greater or equal to&n;&t;&t; *          first sector in last_referenced segment.&n;&t;&t; *    last_referenced - segment id used in the last call,&n;&t;&t; *                      sector and map belong to this id.&n;&t;&t; *  This code is designed for sequential access and retries.&n;&t;&t; *  For true random access it may have to be redesigned.&n;&t;&t; */
r_static
r_int
id|last_reference
op_assign
op_minus
l_int|1
suffix:semicolon
r_static
id|byte
op_star
id|ptr
op_assign
id|bad_sector_map
suffix:semicolon
r_if
c_cond
(paren
id|segment_id
OG
id|last_reference
)paren
(brace
multiline_comment|/*  Skip all sectors before segment_id&n;&t;&t;&t; */
id|forward_seek_entry
c_func
(paren
id|segment_id
comma
op_amp
id|ptr
comma
op_amp
id|map
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|segment_id
OL
id|last_reference
)paren
(brace
multiline_comment|/*  Skip backwards until begin of buffer or first sector in segment_id&n;&t;&t;&t; */
id|backwards_seek_entry
c_func
(paren
id|segment_id
comma
op_amp
id|ptr
comma
op_amp
id|map
)paren
suffix:semicolon
)brace
multiline_comment|/* segment_id == last_reference : keep map */
id|last_reference
op_assign
id|segment_id
suffix:semicolon
)brace
r_else
(brace
id|map
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
id|bad_sector_map
)paren
(braket
id|segment_id
)braket
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|map
suffix:semicolon
)brace
DECL|function|ftape_init_bsm
r_void
id|ftape_init_bsm
c_func
(paren
r_void
)paren
(brace
id|memset
c_func
(paren
id|bad_sector_map
comma
l_int|0
comma
r_sizeof
(paren
id|bad_sector_map
)paren
)paren
suffix:semicolon
)brace
eof
