multiline_comment|/*&n; *      Copyright (C) 1994-1996 Bas Laarhoven,&n; *                (C) 1996-1997 Claus Heine.&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; *&n; * $Source: /homes/cvs/ftape-stacked/ftape/lowlevel/ftape-bsm.c,v $&n; * $Revision: 1.3 $&n; * $Date: 1997/10/05 19:15:15 $&n; *&n; *      This file contains the bad-sector map handling code for&n; *      the QIC-117 floppy tape driver for Linux.&n; *      QIC-40, QIC-80, QIC-3010 and QIC-3020 maps are implemented.&n; */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &quot;../lowlevel/ftape-tracing.h&quot;
macro_line|#include &quot;../lowlevel/ftape-bsm.h&quot;
macro_line|#include &quot;../lowlevel/ftape-ctl.h&quot;
macro_line|#include &quot;../lowlevel/ftape-rw.h&quot;
multiline_comment|/*      Global vars.&n; */
multiline_comment|/*      Local vars.&n; */
DECL|variable|bad_sector_map
r_static
id|__u8
op_star
id|bad_sector_map
suffix:semicolon
DECL|variable|bsm_hash_ptr
r_static
id|SectorCount
op_star
id|bsm_hash_ptr
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|forward
DECL|enumerator|backward
id|forward
comma
id|backward
DECL|typedef|mode_type
)brace
id|mode_type
suffix:semicolon
macro_line|#if 0
multiline_comment|/*  fix_tape converts a normal QIC-80 tape into a &squot;wide&squot; tape.&n; *  For testing purposes only !&n; */
r_void
id|fix_tape
c_func
(paren
id|__u8
op_star
id|buffer
comma
id|ft_format_type
id|new_code
)paren
(brace
r_static
id|__u8
id|list
(braket
id|BAD_SECTOR_MAP_SIZE
)braket
suffix:semicolon
id|SectorMap
op_star
id|src_ptr
op_assign
(paren
id|SectorMap
op_star
)paren
id|list
suffix:semicolon
id|__u8
op_star
id|dst_ptr
op_assign
id|bad_sector_map
suffix:semicolon
id|SectorMap
id|map
suffix:semicolon
r_int
r_int
id|sector
op_assign
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|format_code
op_ne
id|fmt_var
op_logical_and
id|format_code
op_ne
id|fmt_big
)paren
(brace
id|memcpy
c_func
(paren
id|list
comma
id|bad_sector_map
comma
r_sizeof
(paren
id|list
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bad_sector_map
comma
l_int|0
comma
r_sizeof
(paren
id|bad_sector_map
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|__u8
op_star
)paren
id|src_ptr
op_minus
id|list
OL
r_sizeof
(paren
id|list
)paren
)paren
(brace
id|map
op_assign
op_star
id|src_ptr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|map
op_eq
id|EMPTY_SEGMENT
)paren
(brace
op_star
(paren
id|SectorMap
op_star
)paren
id|dst_ptr
op_assign
l_int|0x800000
op_plus
id|sector
suffix:semicolon
id|dst_ptr
op_add_assign
l_int|3
suffix:semicolon
id|sector
op_add_assign
id|SECTORS_PER_SEGMENT
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SECTORS_PER_SEGMENT
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|map
op_amp
l_int|1
)paren
(brace
op_star
(paren
id|SewctorMap
op_star
)paren
id|dst_ptr
op_assign
id|sector
suffix:semicolon
id|dst_ptr
op_add_assign
l_int|3
suffix:semicolon
)brace
id|map
op_rshift_assign
l_int|1
suffix:semicolon
op_increment
id|sector
suffix:semicolon
)brace
)brace
)brace
)brace
id|bad_sector_map_changed
op_assign
l_int|1
suffix:semicolon
op_star
(paren
id|buffer
op_plus
l_int|4
)paren
op_assign
id|new_code
suffix:semicolon
multiline_comment|/* put new format code */
r_if
c_cond
(paren
id|format_code
op_ne
id|fmt_var
op_logical_and
id|new_code
op_eq
id|fmt_big
)paren
(brace
id|PUT4
c_func
(paren
id|buffer
comma
id|FT_6_HSEG_1
comma
(paren
id|__u32
)paren
id|GET2
c_func
(paren
id|buffer
comma
l_int|6
)paren
)paren
suffix:semicolon
id|PUT4
c_func
(paren
id|buffer
comma
id|FT_6_HSEG_2
comma
(paren
id|__u32
)paren
id|GET2
c_func
(paren
id|buffer
comma
l_int|8
)paren
)paren
suffix:semicolon
id|PUT4
c_func
(paren
id|buffer
comma
id|FT_6_FRST_SEG
comma
(paren
id|__u32
)paren
id|GET2
c_func
(paren
id|buffer
comma
l_int|10
)paren
)paren
suffix:semicolon
id|PUT4
c_func
(paren
id|buffer
comma
id|FT_6_LAST_SEG
comma
(paren
id|__u32
)paren
id|GET2
c_func
(paren
id|buffer
comma
l_int|12
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|buffer
op_plus
l_int|6
comma
l_char|&squot;&bslash;0&squot;
comma
l_int|8
)paren
suffix:semicolon
)brace
id|format_code
op_assign
id|new_code
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*   given buffer that contains a header segment, find the end of&n; *   of the bsm list&n; */
DECL|function|ftape_find_end_of_bsm_list
id|__u8
op_star
id|ftape_find_end_of_bsm_list
c_func
(paren
id|__u8
op_star
id|address
)paren
(brace
id|__u8
op_star
id|ptr
op_assign
id|address
op_plus
id|FT_HEADER_END
suffix:semicolon
multiline_comment|/* start of bsm list */
id|__u8
op_star
id|limit
op_assign
id|address
op_plus
id|FT_SEGMENT_SIZE
suffix:semicolon
r_while
c_loop
(paren
id|ptr
op_plus
l_int|2
OL
id|limit
)paren
(brace
r_if
c_cond
(paren
id|ptr
(braket
l_int|0
)braket
op_logical_or
id|ptr
(braket
l_int|1
)braket
op_logical_or
id|ptr
(braket
l_int|2
)braket
)paren
(brace
id|ptr
op_add_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
r_return
id|ptr
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|put_sector
r_static
r_inline
r_void
id|put_sector
c_func
(paren
id|SectorCount
op_star
id|ptr
comma
r_int
r_int
id|sector
)paren
(brace
id|ptr-&gt;bytes
(braket
l_int|0
)braket
op_assign
id|sector
op_amp
l_int|0xff
suffix:semicolon
id|sector
op_rshift_assign
l_int|8
suffix:semicolon
id|ptr-&gt;bytes
(braket
l_int|1
)braket
op_assign
id|sector
op_amp
l_int|0xff
suffix:semicolon
id|sector
op_rshift_assign
l_int|8
suffix:semicolon
id|ptr-&gt;bytes
(braket
l_int|2
)braket
op_assign
id|sector
op_amp
l_int|0xff
suffix:semicolon
)brace
DECL|function|get_sector
r_static
r_inline
r_int
r_int
id|get_sector
c_func
(paren
id|SectorCount
op_star
id|ptr
)paren
(brace
macro_line|#if 1
r_int
r_int
id|sector
suffix:semicolon
id|sector
op_assign
id|ptr-&gt;bytes
(braket
l_int|0
)braket
suffix:semicolon
id|sector
op_add_assign
id|ptr-&gt;bytes
(braket
l_int|1
)braket
op_lshift
l_int|8
suffix:semicolon
id|sector
op_add_assign
id|ptr-&gt;bytes
(braket
l_int|2
)braket
op_lshift
l_int|16
suffix:semicolon
r_return
id|sector
suffix:semicolon
macro_line|#else
multiline_comment|/*  GET4 gets the next four bytes in Intel little endian order&n;&t; *  and converts them to host byte order and handles unaligned&n;&t; *  access.&n;&t; */
r_return
(paren
id|GET4
c_func
(paren
id|ptr
comma
l_int|0
)paren
op_amp
l_int|0x00ffffff
)paren
suffix:semicolon
multiline_comment|/* back to host byte order */
macro_line|#endif
)brace
DECL|function|bsm_debug_fake
r_static
r_void
id|bsm_debug_fake
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* for testing of bad sector handling at end of tape&n;&t; */
macro_line|#if 0
id|ftape_put_bad_sector_entry
(paren
id|segments_per_track
op_star
id|tracks_per_tape
op_minus
l_int|3
comma
l_int|0x000003e0
suffix:semicolon
id|ftape_put_bad_sector_entry
(paren
id|segments_per_track
op_star
id|tracks_per_tape
op_minus
l_int|2
comma
l_int|0xff3fffff
suffix:semicolon
id|ftape_put_bad_sector_entry
(paren
id|segments_per_track
op_star
id|tracks_per_tape
op_minus
l_int|1
comma
l_int|0xffffe000
suffix:semicolon
macro_line|#endif
multiline_comment|/*  Enable to test bad sector handling&n;&t; */
macro_line|#if 0
id|ftape_put_bad_sector_entry
c_func
(paren
l_int|30
comma
l_int|0xfffffffe
)paren
id|ftape_put_bad_sector_entry
c_func
(paren
l_int|32
comma
l_int|0x7fffffff
)paren
suffix:semicolon
id|ftape_put_bad_sector_entry
c_func
(paren
l_int|34
comma
l_int|0xfffeffff
)paren
suffix:semicolon
id|ftape_put_bad_sector_entry
c_func
(paren
l_int|36
comma
l_int|0x55555555
)paren
suffix:semicolon
id|ftape_put_bad_sector_entry
c_func
(paren
l_int|38
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|ftape_put_bad_sector_entry
c_func
(paren
l_int|50
comma
l_int|0xffff0000
)paren
suffix:semicolon
id|ftape_put_bad_sector_entry
c_func
(paren
l_int|51
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|ftape_put_bad_sector_entry
c_func
(paren
l_int|52
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|ftape_put_bad_sector_entry
c_func
(paren
l_int|53
comma
l_int|0x0000ffff
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*  Enable when testing multiple volume tar dumps.&n;&t; */
macro_line|#if 0
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|ft_first_data_segment
suffix:semicolon
id|i
op_le
id|ft_last_data_segment
op_minus
l_int|7
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ftape_put_bad_sector_entry
c_func
(paren
id|i
comma
id|EMPTY_SEGMENT
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*  Enable when testing bit positions in *_error_map&n;&t; */
macro_line|#if 0
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|first_data_segment
suffix:semicolon
id|i
op_le
id|last_data_segment
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ftape_put_bad_sector_entry
c_func
(paren
id|i
comma
id|ftape_get_bad_sector_entry
c_func
(paren
id|i
)paren
op_or
l_int|0x00ff00ff
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
DECL|function|print_bad_sector_map
r_static
r_void
id|print_bad_sector_map
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|good_sectors
suffix:semicolon
r_int
r_int
id|total_bad
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_format_code
op_eq
id|fmt_big
op_logical_or
id|ft_format_code
op_eq
id|fmt_var
op_logical_or
id|ft_format_code
op_eq
id|fmt_1100ft
)paren
(brace
id|SectorCount
op_star
id|ptr
op_assign
(paren
id|SectorCount
op_star
)paren
id|bad_sector_map
suffix:semicolon
r_int
r_int
id|sector
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sector
op_assign
id|get_sector
c_func
(paren
id|ptr
op_increment
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|ft_format_code
op_eq
id|fmt_big
op_logical_or
id|ft_format_code
op_eq
id|fmt_var
)paren
op_logical_and
id|sector
op_amp
l_int|0x800000
)paren
(brace
id|total_bad
op_add_assign
id|FT_SECTORS_PER_SEGMENT
op_minus
l_int|3
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;bad segment at sector: %6d&quot;
comma
id|sector
op_amp
l_int|0x7fffff
)paren
suffix:semicolon
)brace
r_else
(brace
op_increment
id|total_bad
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;bad sector: %6d&quot;
comma
id|sector
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*  Display old ftape&squot;s end-of-file marks&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|sector
op_assign
id|get_unaligned
c_func
(paren
(paren
(paren
id|__u16
op_star
)paren
id|ptr
)paren
op_increment
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Old ftape eof mark: %4d/%2d&quot;
comma
id|sector
comma
id|get_unaligned
c_func
(paren
(paren
(paren
id|__u16
op_star
)paren
id|ptr
)paren
op_increment
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* fixed size format */
r_for
c_loop
(paren
id|i
op_assign
id|ft_first_data_segment
suffix:semicolon
id|i
OL
(paren
r_int
)paren
(paren
id|ft_segments_per_track
op_star
id|ft_tracks_per_tape
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
id|SectorMap
id|map
op_assign
(paren
(paren
id|SectorMap
op_star
)paren
id|bad_sector_map
)paren
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|map
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;bsm for segment %4d: 0x%08x&quot;
comma
id|i
comma
(paren
r_int
r_int
)paren
id|map
)paren
suffix:semicolon
id|total_bad
op_add_assign
(paren
(paren
id|map
op_eq
id|EMPTY_SEGMENT
)paren
ques
c_cond
id|FT_SECTORS_PER_SEGMENT
op_minus
l_int|3
suffix:colon
id|count_ones
c_func
(paren
id|map
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
id|good_sectors
op_assign
(paren
(paren
id|ft_segments_per_track
op_star
id|ft_tracks_per_tape
op_minus
id|ft_first_data_segment
)paren
op_star
(paren
id|FT_SECTORS_PER_SEGMENT
op_minus
l_int|3
)paren
)paren
op_minus
id|total_bad
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;%d Kb usable on this tape&quot;
comma
id|good_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|total_bad
op_eq
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;WARNING: this tape has no bad blocks registered !&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;%d bad sectors&quot;
comma
id|total_bad
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|ftape_extract_bad_sector_map
r_void
id|ftape_extract_bad_sector_map
c_func
(paren
id|__u8
op_star
id|buffer
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
multiline_comment|/*  Fill the bad sector map with the contents of buffer.&n;&t; */
r_if
c_cond
(paren
id|ft_format_code
op_eq
id|fmt_var
op_logical_or
id|ft_format_code
op_eq
id|fmt_big
)paren
(brace
multiline_comment|/* QIC-3010/3020 and wide QIC-80 tapes no longer have a failed&n;&t;&t; * sector log but use this area to extend the bad sector map.&n;&t;&t; */
id|bad_sector_map
op_assign
op_amp
id|buffer
(braket
id|FT_HEADER_END
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* non-wide QIC-80 tapes have a failed sector log area that&n;&t;&t; * mustn&squot;t be included in the bad sector map.&n;&t;&t; */
id|bad_sector_map
op_assign
op_amp
id|buffer
(braket
id|FT_FSL
op_plus
id|FT_FSL_SIZE
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_format_code
op_eq
id|fmt_1100ft
op_logical_or
id|ft_format_code
op_eq
id|fmt_var
op_logical_or
id|ft_format_code
op_eq
id|fmt_big
)paren
(brace
id|bsm_hash_ptr
op_assign
(paren
id|SectorCount
op_star
)paren
id|bad_sector_map
suffix:semicolon
)brace
r_else
(brace
id|bsm_hash_ptr
op_assign
l_int|NULL
suffix:semicolon
)brace
id|bsm_debug_fake
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TRACE_LEVEL
op_ge
id|ft_t_info
)paren
(brace
id|print_bad_sector_map
c_func
(paren
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|cvt2map
r_static
r_inline
id|SectorMap
id|cvt2map
c_func
(paren
r_int
r_int
id|sector
)paren
(brace
r_return
l_int|1
op_lshift
(paren
(paren
(paren
id|sector
op_amp
l_int|0x7fffff
)paren
op_minus
l_int|1
)paren
op_mod
id|FT_SECTORS_PER_SEGMENT
)paren
suffix:semicolon
)brace
DECL|function|cvt2segment
r_static
r_inline
r_int
id|cvt2segment
c_func
(paren
r_int
r_int
id|sector
)paren
(brace
r_return
(paren
(paren
id|sector
op_amp
l_int|0x7fffff
)paren
op_minus
l_int|1
)paren
op_div
id|FT_SECTORS_PER_SEGMENT
suffix:semicolon
)brace
DECL|function|forward_seek_entry
r_static
r_int
id|forward_seek_entry
c_func
(paren
r_int
id|segment_id
comma
id|SectorCount
op_star
op_star
id|ptr
comma
id|SectorMap
op_star
id|map
)paren
(brace
r_int
r_int
id|sector
suffix:semicolon
r_int
id|segment
suffix:semicolon
r_do
(brace
id|sector
op_assign
id|get_sector
c_func
(paren
(paren
op_star
id|ptr
)paren
op_increment
)paren
suffix:semicolon
id|segment
op_assign
id|cvt2segment
c_func
(paren
id|sector
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sector
op_ne
l_int|0
op_logical_and
id|segment
OL
id|segment_id
)paren
suffix:semicolon
(paren
op_star
id|ptr
)paren
op_decrement
suffix:semicolon
multiline_comment|/* point to first sector &gt;= segment_id */
multiline_comment|/*  Get all sectors in segment_id&n;&t; */
r_if
c_cond
(paren
id|sector
op_eq
l_int|0
op_logical_or
id|segment
op_ne
id|segment_id
)paren
(brace
op_star
id|map
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|sector
op_amp
l_int|0x800000
)paren
op_logical_and
(paren
id|ft_format_code
op_eq
id|fmt_var
op_logical_or
id|ft_format_code
op_eq
id|fmt_big
)paren
)paren
(brace
op_star
id|map
op_assign
id|EMPTY_SEGMENT
suffix:semicolon
r_return
id|FT_SECTORS_PER_SEGMENT
suffix:semicolon
)brace
r_else
(brace
r_int
id|count
op_assign
l_int|1
suffix:semicolon
id|SectorCount
op_star
id|tmp_ptr
op_assign
(paren
op_star
id|ptr
)paren
op_plus
l_int|1
suffix:semicolon
op_star
id|map
op_assign
id|cvt2map
c_func
(paren
id|sector
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sector
op_assign
id|get_sector
c_func
(paren
id|tmp_ptr
op_increment
)paren
)paren
op_ne
l_int|0
op_logical_and
(paren
id|segment
op_assign
id|cvt2segment
c_func
(paren
id|sector
)paren
)paren
op_eq
id|segment_id
)paren
(brace
op_star
id|map
op_or_assign
id|cvt2map
c_func
(paren
id|sector
)paren
suffix:semicolon
op_increment
id|count
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
)brace
DECL|function|backwards_seek_entry
r_static
r_int
id|backwards_seek_entry
c_func
(paren
r_int
id|segment_id
comma
id|SectorCount
op_star
op_star
id|ptr
comma
id|SectorMap
op_star
id|map
)paren
(brace
r_int
r_int
id|sector
suffix:semicolon
r_int
id|segment
suffix:semicolon
multiline_comment|/* max unsigned int */
r_if
c_cond
(paren
op_star
id|ptr
op_le
(paren
id|SectorCount
op_star
)paren
id|bad_sector_map
)paren
(brace
op_star
id|map
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_do
(brace
id|sector
op_assign
id|get_sector
c_func
(paren
op_decrement
(paren
op_star
id|ptr
)paren
)paren
suffix:semicolon
id|segment
op_assign
id|cvt2segment
c_func
(paren
id|sector
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|ptr
OG
(paren
id|SectorCount
op_star
)paren
id|bad_sector_map
op_logical_and
id|segment
OG
id|segment_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|segment
OG
id|segment_id
)paren
(brace
multiline_comment|/*  at start of list, no entry found */
op_star
id|map
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|segment
OL
id|segment_id
)paren
(brace
multiline_comment|/*  before smaller entry, adjust for overshoot */
(paren
op_star
id|ptr
)paren
op_increment
suffix:semicolon
op_star
id|map
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|sector
op_amp
l_int|0x800000
)paren
op_logical_and
(paren
id|ft_format_code
op_eq
id|fmt_big
op_logical_or
id|ft_format_code
op_eq
id|fmt_var
)paren
)paren
(brace
op_star
id|map
op_assign
id|EMPTY_SEGMENT
suffix:semicolon
r_return
id|FT_SECTORS_PER_SEGMENT
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  get all sectors in segment_id */
r_int
id|count
op_assign
l_int|1
suffix:semicolon
op_star
id|map
op_assign
id|cvt2map
c_func
(paren
id|sector
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|ptr
OG
(paren
id|SectorCount
op_star
)paren
id|bad_sector_map
)paren
(brace
id|sector
op_assign
id|get_sector
c_func
(paren
op_decrement
(paren
op_star
id|ptr
)paren
)paren
suffix:semicolon
id|segment
op_assign
id|cvt2segment
c_func
(paren
id|sector
)paren
suffix:semicolon
r_if
c_cond
(paren
id|segment
op_ne
id|segment_id
)paren
(brace
r_break
suffix:semicolon
)brace
op_star
id|map
op_or_assign
id|cvt2map
c_func
(paren
id|sector
)paren
suffix:semicolon
op_increment
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
id|segment
OL
id|segment_id
)paren
(brace
(paren
op_star
id|ptr
)paren
op_increment
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
)brace
DECL|function|ftape_put_bad_sector_entry
r_void
id|ftape_put_bad_sector_entry
c_func
(paren
r_int
id|segment_id
comma
id|SectorMap
id|new_map
)paren
(brace
id|SectorCount
op_star
id|ptr
op_assign
(paren
id|SectorCount
op_star
)paren
id|bad_sector_map
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|new_count
suffix:semicolon
id|SectorMap
id|map
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_format_code
op_eq
id|fmt_1100ft
op_logical_or
id|ft_format_code
op_eq
id|fmt_var
op_logical_or
id|ft_format_code
op_eq
id|fmt_big
)paren
(brace
id|count
op_assign
id|forward_seek_entry
c_func
(paren
id|segment_id
comma
op_amp
id|ptr
comma
op_amp
id|map
)paren
suffix:semicolon
id|new_count
op_assign
id|count_ones
c_func
(paren
id|new_map
)paren
suffix:semicolon
multiline_comment|/* If format code == 4 put empty segment instead of 32&n;&t;&t; * bad sectors.&n;&t;&t; */
r_if
c_cond
(paren
id|ft_format_code
op_eq
id|fmt_var
op_logical_or
id|ft_format_code
op_eq
id|fmt_big
)paren
(brace
r_if
c_cond
(paren
id|new_count
op_eq
id|FT_SECTORS_PER_SEGMENT
)paren
(brace
id|new_count
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_eq
id|FT_SECTORS_PER_SEGMENT
)paren
(brace
id|count
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|count
op_ne
id|new_count
)paren
(brace
multiline_comment|/* insert (or delete if &lt; 0) new_count - count&n;&t;&t;&t; * entries.  Move trailing part of list&n;&t;&t;&t; * including terminating 0.&n;&t;&t;&t; */
id|SectorCount
op_star
id|hi_ptr
op_assign
id|ptr
suffix:semicolon
r_do
(brace
)brace
r_while
c_loop
(paren
id|get_sector
c_func
(paren
id|hi_ptr
op_increment
)paren
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/*  Note: ptr is of type byte *, and each bad sector&n;&t;&t;&t; *  consumes 3 bytes.&n;&t;&t;&t; */
id|memmove
c_func
(paren
id|ptr
op_plus
id|new_count
comma
id|ptr
op_plus
id|count
comma
(paren
r_int
)paren
(paren
id|hi_ptr
op_minus
(paren
id|ptr
op_plus
id|count
)paren
)paren
op_star
r_sizeof
(paren
id|SectorCount
)paren
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;putting map 0x%08x at %p, segment %d&quot;
comma
(paren
r_int
r_int
)paren
id|new_map
comma
id|ptr
comma
id|segment_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_count
op_eq
l_int|1
op_logical_and
id|new_map
op_eq
id|EMPTY_SEGMENT
)paren
(brace
id|put_sector
c_func
(paren
id|ptr
op_increment
comma
(paren
l_int|0x800001
op_plus
id|segment_id
op_star
id|FT_SECTORS_PER_SEGMENT
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|new_map
)paren
(brace
r_if
c_cond
(paren
id|new_map
op_amp
l_int|1
)paren
(brace
id|put_sector
c_func
(paren
id|ptr
op_increment
comma
l_int|1
op_plus
id|segment_id
op_star
id|FT_SECTORS_PER_SEGMENT
op_plus
id|i
)paren
suffix:semicolon
)brace
op_increment
id|i
suffix:semicolon
id|new_map
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
(paren
(paren
id|SectorMap
op_star
)paren
id|bad_sector_map
)paren
(braket
id|segment_id
)braket
op_assign
id|new_map
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|ftape_get_bad_sector_entry
id|SectorMap
id|ftape_get_bad_sector_entry
c_func
(paren
r_int
id|segment_id
)paren
(brace
r_if
c_cond
(paren
id|ft_used_header_segment
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/*  When reading header segment we&squot;ll need a blank map.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bsm_hash_ptr
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*  Invariants:&n;&t;&t; *    map - mask value returned on last call.&n;&t;&t; *    bsm_hash_ptr - points to first sector greater or equal to&n;&t;&t; *          first sector in last_referenced segment.&n;&t;&t; *    last_referenced - segment id used in the last call,&n;&t;&t; *                      sector and map belong to this id.&n;&t;&t; *  This code is designed for sequential access and retries.&n;&t;&t; *  For true random access it may have to be redesigned.&n;&t;&t; */
r_static
r_int
id|last_reference
op_assign
op_minus
l_int|1
suffix:semicolon
r_static
id|SectorMap
id|map
suffix:semicolon
r_if
c_cond
(paren
id|segment_id
OG
id|last_reference
)paren
(brace
multiline_comment|/*  Skip all sectors before segment_id&n;&t;&t;&t; */
id|forward_seek_entry
c_func
(paren
id|segment_id
comma
op_amp
id|bsm_hash_ptr
comma
op_amp
id|map
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|segment_id
OL
id|last_reference
)paren
(brace
multiline_comment|/* Skip backwards until begin of buffer or&n;&t;&t;&t; * first sector in segment_id &n;&t;&t;&t; */
id|backwards_seek_entry
c_func
(paren
id|segment_id
comma
op_amp
id|bsm_hash_ptr
comma
op_amp
id|map
)paren
suffix:semicolon
)brace
multiline_comment|/* segment_id == last_reference : keep map */
id|last_reference
op_assign
id|segment_id
suffix:semicolon
r_return
id|map
suffix:semicolon
)brace
r_else
(brace
r_return
(paren
(paren
id|SectorMap
op_star
)paren
id|bad_sector_map
)paren
(braket
id|segment_id
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/*  This is simply here to prevent us from overwriting other kernel&n; *  data. Writes will result in NULL Pointer dereference.&n; */
DECL|function|ftape_init_bsm
r_void
id|ftape_init_bsm
c_func
(paren
r_void
)paren
(brace
id|bad_sector_map
op_assign
l_int|NULL
suffix:semicolon
id|bsm_hash_ptr
op_assign
l_int|NULL
suffix:semicolon
)brace
eof
