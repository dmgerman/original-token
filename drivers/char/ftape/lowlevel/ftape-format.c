multiline_comment|/*&n; * Copyright (C) 1997 Claus-Justus Heine.&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; *&n; * $Source: /homes/cvs/ftape-stacked/ftape/lowlevel/ftape-format.c,v $&n; * $Revision: 1.2.4.1 $&n; * $Date: 1997/11/14 16:05:39 $&n; *&n; *      This file contains the code to support formatting of floppy&n; *      tape cartridges with the QIC-40/80/3010/3020 floppy-tape&n; *      driver &quot;ftape&quot; for Linux.&n; */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &lt;linux/qic117.h&gt;
macro_line|#include &quot;../lowlevel/ftape-tracing.h&quot;
macro_line|#include &quot;../lowlevel/ftape-io.h&quot;
macro_line|#include &quot;../lowlevel/ftape-ctl.h&quot;
macro_line|#include &quot;../lowlevel/ftape-rw.h&quot;
macro_line|#include &quot;../lowlevel/ftape-ecc.h&quot;
macro_line|#include &quot;../lowlevel/ftape-bsm.h&quot;
macro_line|#include &quot;../lowlevel/ftape-format.h&quot;
macro_line|#if defined(TESTING)
DECL|macro|FT_FMT_SEGS_PER_BUF
mdefine_line|#define FT_FMT_SEGS_PER_BUF 50
macro_line|#else
DECL|macro|FT_FMT_SEGS_PER_BUF
mdefine_line|#define FT_FMT_SEGS_PER_BUF (FT_BUFF_SIZE/(4*FT_SECTORS_PER_SEGMENT))
macro_line|#endif
multiline_comment|/*&n; *  first segment of the new buffer&n; */
DECL|variable|switch_segment
r_static
r_int
id|switch_segment
suffix:semicolon
multiline_comment|/*&n; *  at most 256 segments fit into one 32 kb buffer.  Even TR-1 cartridges have&n; *  more than this many segments per track, so better be careful.&n; *&n; *  buffer_struct *buff: buffer to store the formatting coordinates in&n; *  int  start: starting segment for this buffer.&n; *  int    spt: segments per track&n; *&n; *  Note: segment ids are relative to the start of the track here.&n; */
DECL|function|setup_format_buffer
r_static
r_void
id|setup_format_buffer
c_func
(paren
id|buffer_struct
op_star
id|buff
comma
r_int
id|start
comma
r_int
id|spt
comma
id|__u8
id|gap3
)paren
(brace
r_int
id|to_do
op_assign
id|spt
op_minus
id|start
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|to_do
OG
id|FT_FMT_SEGS_PER_BUF
)paren
(brace
id|to_do
op_assign
id|FT_FMT_SEGS_PER_BUF
suffix:semicolon
)brace
id|buff-&gt;ptr
op_assign
id|buff-&gt;address
suffix:semicolon
id|buff-&gt;remaining
op_assign
id|to_do
op_star
id|FT_SECTORS_PER_SEGMENT
suffix:semicolon
multiline_comment|/* # sectors */
id|buff-&gt;bytes
op_assign
id|buff-&gt;remaining
op_star
l_int|4
suffix:semicolon
multiline_comment|/* need 4 bytes per sector */
id|buff-&gt;gap3
op_assign
id|gap3
suffix:semicolon
id|buff-&gt;segment_id
op_assign
id|start
suffix:semicolon
id|buff-&gt;next_segment
op_assign
id|start
op_plus
id|to_do
suffix:semicolon
r_if
c_cond
(paren
id|buff-&gt;next_segment
op_ge
id|spt
)paren
(brace
id|buff-&gt;next_segment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0 means: stop runner */
)brace
id|buff-&gt;status
op_assign
id|waiting
suffix:semicolon
multiline_comment|/* tells the isr that it can use&n;&t;&t;&t;&t;       * this buffer&n;&t;&t;&t;&t;       */
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/*&n; *  start formatting a new track.&n; */
DECL|function|ftape_format_track
r_int
id|ftape_format_track
c_func
(paren
r_const
r_int
r_int
id|track
comma
r_const
id|__u8
id|gap3
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|buffer_struct
op_star
id|tail
comma
op_star
id|head
suffix:semicolon
r_int
id|status
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_ready_wait
c_func
(paren
id|ftape_timeout.pause
comma
op_amp
id|status
)paren
comma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|track
op_amp
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|QIC_STATUS_AT_EOT
)paren
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|ftape_seek_to_eot
c_func
(paren
)paren
comma
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|QIC_STATUS_AT_BOT
)paren
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|ftape_seek_to_bot
c_func
(paren
)paren
comma
)paren
suffix:semicolon
)brace
)brace
id|ftape_abort_operation
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* this sets ft_head = ft_tail = 0 */
id|ftape_set_state
c_func
(paren
id|formatting
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Formatting track %d, logical: from segment %d to %d&quot;
comma
id|track
comma
id|track
op_star
id|ft_segments_per_track
comma
(paren
id|track
op_plus
l_int|1
)paren
op_star
id|ft_segments_per_track
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  initialize the buffer switching protocol for this track&n;&t; */
id|head
op_assign
id|ftape_get_buffer
c_func
(paren
id|ft_queue_head
)paren
suffix:semicolon
multiline_comment|/* tape isn&squot;t running yet */
id|tail
op_assign
id|ftape_get_buffer
c_func
(paren
id|ft_queue_tail
)paren
suffix:semicolon
multiline_comment|/* tape isn&squot;t running yet */
id|switch_segment
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
id|setup_format_buffer
c_func
(paren
id|tail
comma
id|switch_segment
comma
id|ft_segments_per_track
comma
id|gap3
)paren
suffix:semicolon
id|switch_segment
op_assign
id|tail-&gt;next_segment
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|switch_segment
op_ne
l_int|0
)paren
op_logical_and
(paren
(paren
id|tail
op_assign
id|ftape_next_buffer
c_func
(paren
id|ft_queue_tail
)paren
)paren
op_ne
id|head
)paren
)paren
suffix:semicolon
multiline_comment|/* go */
id|head-&gt;status
op_assign
id|formatting
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_seek_head_to_track
c_func
(paren
id|track
)paren
comma
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_command
c_func
(paren
id|QIC_LOGICAL_FORWARD
)paren
comma
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_setup_formatting
c_func
(paren
id|head
)paren
comma
id|restore_flags
c_func
(paren
id|flags
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*   return segment id of segment currently being formatted and do the&n; *   buffer switching stuff.&n; */
DECL|function|ftape_format_status
r_int
id|ftape_format_status
c_func
(paren
r_int
r_int
op_star
id|segment_id
)paren
(brace
id|buffer_struct
op_star
id|tail
op_assign
id|ftape_get_buffer
c_func
(paren
id|ft_queue_tail
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_while
c_loop
(paren
id|switch_segment
op_ne
l_int|0
op_logical_and
id|ftape_get_buffer
c_func
(paren
id|ft_queue_head
)paren
op_ne
id|tail
)paren
(brace
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
multiline_comment|/*  need more buffers, first wait for empty buffer&n;&t;&t; */
id|TRACE_CATCH
c_func
(paren
id|ftape_wait_segment
c_func
(paren
id|formatting
)paren
comma
)paren
suffix:semicolon
multiline_comment|/*  don&squot;t worry for gap3. If we ever hit this piece of code,&n;&t;&t; *  then all buffer already have the correct gap3 set!&n;&t;&t; */
id|setup_format_buffer
c_func
(paren
id|tail
comma
id|switch_segment
comma
id|ft_segments_per_track
comma
id|tail-&gt;gap3
)paren
suffix:semicolon
id|switch_segment
op_assign
id|tail-&gt;next_segment
suffix:semicolon
r_if
c_cond
(paren
id|switch_segment
op_ne
l_int|0
)paren
(brace
id|tail
op_assign
id|ftape_next_buffer
c_func
(paren
id|ft_queue_tail
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*    should runner stop ?&n;&t; */
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|aborting
op_logical_or
id|ft_runner_status
op_eq
id|do_abort
)paren
(brace
id|buffer_struct
op_star
id|head
op_assign
id|ftape_get_buffer
c_func
(paren
id|ft_queue_head
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Error formatting segment %d&quot;
comma
id|ftape_get_buffer
c_func
(paren
id|ft_queue_head
)paren
op_member_access_from_pointer
id|segment_id
)paren
suffix:semicolon
(paren
r_void
)paren
id|ftape_abort_operation
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
(paren
id|head-&gt;status
op_ne
id|error
)paren
ques
c_cond
op_minus
id|EAGAIN
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  don&squot;t care if the timer expires, this is just kind of a&n;&t; *  &quot;select&quot; operation that lets the calling process sleep&n;&t; *  until something has happened&n;&t; */
r_if
c_cond
(paren
id|fdc_interrupt_wait
c_func
(paren
l_int|5
op_star
id|FT_SECOND
)paren
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;End of track %d at segment %d&quot;
comma
id|ft_location.track
comma
id|ftape_get_buffer
c_func
(paren
id|ft_queue_head
)paren
op_member_access_from_pointer
id|segment_id
)paren
suffix:semicolon
id|result
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* end of track, unlock module */
)brace
r_else
(brace
id|result
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  the calling process should use the seg id to determine&n;&t; *  which parts of the dma buffers can be safely overwritten&n;&t; *  with new data.&n;&t; */
op_star
id|segment_id
op_assign
id|ftape_get_buffer
c_func
(paren
id|ft_queue_head
)paren
op_member_access_from_pointer
id|segment_id
suffix:semicolon
multiline_comment|/*&n;&t; *  Internally we start counting segment ids from the start of&n;&t; *  each track when formatting, but externally we keep them&n;&t; *  relative to the start of the tape:&n;&t; */
op_star
id|segment_id
op_add_assign
id|ft_location.track
op_star
id|ft_segments_per_track
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; *  The segment id is relative to the start of the tape&n; */
DECL|function|ftape_verify_segment
r_int
id|ftape_verify_segment
c_func
(paren
r_const
r_int
r_int
id|segment_id
comma
id|SectorMap
op_star
id|bsm
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|verify_done
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Verifying segment %d&quot;
comma
id|segment_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_driver_state
op_ne
id|verifying
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;calling ftape_abort_operation&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftape_abort_operation
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;ftape_abort_operation failed&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
)brace
)brace
op_star
id|bsm
op_assign
l_int|0x00000000
suffix:semicolon
id|ftape_set_state
c_func
(paren
id|verifying
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|buffer_struct
op_star
id|tail
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Allow escape from this loop on signal&n;&t;&t; */
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Search all full buffers for the first matching the&n;&t;&t; *  wanted segment.  Clear other buffers on the fly.&n;&t;&t; */
id|tail
op_assign
id|ftape_get_buffer
c_func
(paren
id|ft_queue_tail
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|verify_done
op_logical_and
id|tail-&gt;status
op_eq
id|done
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  Allow escape from this loop on signal !&n;&t;&t;&t; */
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tail-&gt;segment_id
op_eq
id|segment_id
)paren
(brace
multiline_comment|/*  If out buffer is already full,&n;&t;&t;&t;&t; *  return its contents.  &n;&t;&t;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;found segment in cache: %d&quot;
comma
id|segment_id
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tail-&gt;soft_error_map
op_or
id|tail-&gt;hard_error_map
)paren
op_ne
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;bsm[%d] = 0x%08lx&quot;
comma
id|segment_id
comma
(paren
r_int
r_int
)paren
(paren
id|tail-&gt;soft_error_map
op_or
id|tail-&gt;hard_error_map
)paren
)paren
suffix:semicolon
op_star
id|bsm
op_assign
(paren
id|tail-&gt;soft_error_map
op_or
id|tail-&gt;hard_error_map
)paren
suffix:semicolon
)brace
id|verify_done
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;zapping segment in cache: %d&quot;
comma
id|tail-&gt;segment_id
)paren
suffix:semicolon
)brace
id|tail-&gt;status
op_assign
id|waiting
suffix:semicolon
id|tail
op_assign
id|ftape_next_buffer
c_func
(paren
id|ft_queue_tail
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|verify_done
op_logical_and
id|tail-&gt;status
op_eq
id|verifying
)paren
(brace
r_if
c_cond
(paren
id|tail-&gt;segment_id
op_eq
id|segment_id
)paren
(brace
r_switch
c_cond
(paren
id|ftape_wait_segment
c_func
(paren
id|verifying
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
op_minus
id|EINTR
suffix:colon
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINTR
comma
id|ft_t_warn
comma
l_string|&quot;interrupted by &quot;
l_string|&quot;non-blockable signal&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ftape_abort_operation
c_func
(paren
)paren
suffix:semicolon
id|ftape_set_state
c_func
(paren
id|verifying
)paren
suffix:semicolon
multiline_comment|/* be picky */
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_warn
comma
l_string|&quot;wait_segment failed&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*  We&squot;re reading the wrong segment,&n;&t;&t;&t;&t; *  stop runner.&n;&t;&t;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;verifying wrong segment&quot;
)paren
suffix:semicolon
id|ftape_abort_operation
c_func
(paren
)paren
suffix:semicolon
id|ftape_set_state
c_func
(paren
id|verifying
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*    should runner stop ?&n;&t;&t; */
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|aborting
)paren
(brace
id|buffer_struct
op_star
id|head
op_assign
id|ftape_get_buffer
c_func
(paren
id|ft_queue_head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head-&gt;status
op_eq
id|error
op_logical_or
id|head-&gt;status
op_eq
id|verifying
)paren
(brace
multiline_comment|/* no data or overrun error */
id|head-&gt;status
op_assign
id|waiting
suffix:semicolon
)brace
id|TRACE_CATCH
c_func
(paren
id|ftape_dumb_stop
c_func
(paren
)paren
comma
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  If just passed last segment on tape: wait&n;&t;&t;&t; *  for BOT or EOT mark. Sets ft_runner_status to&n;&t;&t;&t; *  idle if at lEOT and successful &n;&t;&t;&t; */
id|TRACE_CATCH
c_func
(paren
id|ftape_handle_logical_eot
c_func
(paren
)paren
comma
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verify_done
)paren
(brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*    Now at least one buffer is idle!&n;&t;&t; *    Restart runner &amp; tape if needed.&n;&t;&t; */
multiline_comment|/*  We could optimize the following a little bit. We know that &n;&t;&t; *  the bad sector map is empty.&n;&t;&t; */
id|tail
op_assign
id|ftape_get_buffer
c_func
(paren
id|ft_queue_tail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tail-&gt;status
op_eq
id|waiting
)paren
(brace
id|buffer_struct
op_star
id|head
op_assign
id|ftape_get_buffer
c_func
(paren
id|ft_queue_head
)paren
suffix:semicolon
id|ftape_setup_new_segment
c_func
(paren
id|head
comma
id|segment_id
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|ftape_calc_next_cluster
c_func
(paren
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|idle
)paren
(brace
id|result
op_assign
id|ftape_start_tape
c_func
(paren
id|segment_id
comma
id|head-&gt;sector_offset
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|result
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
op_minus
id|ETIME
suffix:colon
r_case
op_minus
id|EINTR
suffix:colon
id|TRACE_ABORT
c_func
(paren
id|result
comma
id|ft_t_err
comma
l_string|&quot;Error: &quot;
l_string|&quot;segment %d unreachable&quot;
comma
id|segment_id
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|bsm
op_assign
id|EMPTY_SEGMENT
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|head-&gt;status
op_assign
id|verifying
suffix:semicolon
id|fdc_setup_read_write
c_func
(paren
id|head
comma
id|FDC_VERIFY
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* not reached */
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
)brace
eof
