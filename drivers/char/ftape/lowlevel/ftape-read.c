multiline_comment|/*&n; *      Copyright (C) 1993-1996 Bas Laarhoven,&n; *                (C) 1996-1997 Claus-Justus Heine.&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; *&n; * $Source: /homes/cvs/ftape-stacked/ftape/lowlevel/ftape-read.c,v $&n; * $Revision: 1.6 $&n; * $Date: 1997/10/21 14:39:22 $&n; *&n; *      This file contains the reading code&n; *      for the QIC-117 floppy-tape driver for Linux.&n; *&n; */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &lt;linux/qic117.h&gt;
macro_line|#include &quot;../lowlevel/ftape-tracing.h&quot;
macro_line|#include &quot;../lowlevel/ftape-read.h&quot;
macro_line|#include &quot;../lowlevel/ftape-io.h&quot;
macro_line|#include &quot;../lowlevel/ftape-ctl.h&quot;
macro_line|#include &quot;../lowlevel/ftape-rw.h&quot;
macro_line|#include &quot;../lowlevel/ftape-write.h&quot;
macro_line|#include &quot;../lowlevel/ftape-ecc.h&quot;
macro_line|#include &quot;../lowlevel/ftape-bsm.h&quot;
multiline_comment|/*      Global vars.&n; */
multiline_comment|/*      Local vars.&n; */
DECL|function|ftape_zap_read_buffers
r_void
id|ftape_zap_read_buffers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ft_nr_buffers
suffix:semicolon
op_increment
id|i
)paren
(brace
multiline_comment|/*  changed to &quot;fit&quot; with dynamic allocation of tape_buffer. --khp  */
id|ft_buffer
(braket
id|i
)braket
op_member_access_from_pointer
id|status
op_assign
id|waiting
suffix:semicolon
id|ft_buffer
(braket
id|i
)braket
op_member_access_from_pointer
id|bytes
op_assign
l_int|0
suffix:semicolon
id|ft_buffer
(braket
id|i
)braket
op_member_access_from_pointer
id|skip
op_assign
l_int|0
suffix:semicolon
id|ft_buffer
(braket
id|i
)braket
op_member_access_from_pointer
id|retry
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&t;ftape_reset_buffer(); */
)brace
DECL|function|convert_sector_map
r_static
id|SectorMap
id|convert_sector_map
c_func
(paren
id|buffer_struct
op_star
id|buff
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|SectorMap
id|bad_map
op_assign
id|ftape_get_bad_sector_entry
c_func
(paren
id|buff-&gt;segment_id
)paren
suffix:semicolon
id|SectorMap
id|src_map
op_assign
id|buff-&gt;soft_error_map
op_or
id|buff-&gt;hard_error_map
suffix:semicolon
id|SectorMap
id|dst_map
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bad_map
op_logical_or
id|src_map
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;bad_map = 0x%08lx&quot;
comma
(paren
r_int
)paren
id|bad_map
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;src_map = 0x%08lx&quot;
comma
(paren
r_int
)paren
id|src_map
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bad_map
)paren
(brace
r_while
c_loop
(paren
(paren
id|bad_map
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|src_map
op_amp
l_int|1
)paren
(brace
id|dst_map
op_or_assign
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
id|src_map
op_rshift_assign
l_int|1
suffix:semicolon
id|bad_map
op_rshift_assign
l_int|1
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
multiline_comment|/* (bad_map &amp; 1) == 1 */
id|src_map
op_rshift_assign
l_int|1
suffix:semicolon
id|bad_map
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|src_map
)paren
(brace
id|dst_map
op_or_assign
(paren
id|src_map
op_lshift
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dst_map
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;dst_map = 0x%08lx&quot;
comma
(paren
r_int
)paren
id|dst_map
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
id|dst_map
suffix:semicolon
)brace
DECL|function|correct_and_copy_fraction
r_static
r_int
id|correct_and_copy_fraction
c_func
(paren
id|buffer_struct
op_star
id|buff
comma
id|__u8
op_star
id|destination
comma
r_int
id|start
comma
r_int
id|size
)paren
(brace
r_struct
id|memory_segment
id|mseg
suffix:semicolon
r_int
id|result
suffix:semicolon
id|SectorMap
id|read_bad
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|mseg.read_bad
op_assign
id|convert_sector_map
c_func
(paren
id|buff
)paren
suffix:semicolon
id|mseg.marked_bad
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not used... */
id|mseg.blocks
op_assign
id|buff-&gt;bytes
op_div
id|FT_SECTOR_SIZE
suffix:semicolon
id|mseg.data
op_assign
id|buff-&gt;address
suffix:semicolon
multiline_comment|/*    If there are no data sectors we can skip this segment.&n;&t; */
r_if
c_cond
(paren
id|mseg.blocks
op_le
l_int|3
)paren
(brace
id|TRACE_ABORT
c_func
(paren
l_int|0
comma
id|ft_t_noise
comma
l_string|&quot;empty segment&quot;
)paren
suffix:semicolon
)brace
id|read_bad
op_assign
id|mseg.read_bad
suffix:semicolon
id|ft_history.crc_errors
op_add_assign
id|count_ones
c_func
(paren
id|read_bad
)paren
suffix:semicolon
id|result
op_assign
id|ftape_ecc_correct_data
c_func
(paren
op_amp
id|mseg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_bad
op_ne
l_int|0
op_logical_or
id|mseg.corrected
op_ne
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;crc error map: 0x%08lx&quot;
comma
(paren
r_int
r_int
)paren
id|read_bad
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;corrected map: 0x%08lx&quot;
comma
(paren
r_int
r_int
)paren
id|mseg.corrected
)paren
suffix:semicolon
id|ft_history.corrected
op_add_assign
id|count_ones
c_func
(paren
id|mseg.corrected
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_eq
id|ECC_CORRECTED
op_logical_or
id|result
op_eq
id|ECC_OK
)paren
(brace
r_if
c_cond
(paren
id|result
op_eq
id|ECC_CORRECTED
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;ecc corrected segment: %d&quot;
comma
id|buff-&gt;segment_id
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start
OL
l_int|0
)paren
(brace
id|start
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|start
op_plus
id|size
)paren
OG
(paren
(paren
id|mseg.blocks
op_minus
l_int|3
)paren
op_star
id|FT_SECTOR_SIZE
)paren
)paren
(brace
id|size
op_assign
(paren
id|mseg.blocks
op_minus
l_int|3
)paren
op_star
id|FT_SECTOR_SIZE
op_minus
id|start
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
OL
l_int|0
)paren
(brace
id|size
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|destination
op_plus
id|start
comma
id|mseg.data
op_plus
id|start
comma
id|size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|read_bad
op_xor
id|mseg.corrected
)paren
op_amp
id|mseg.corrected
)paren
(brace
multiline_comment|/* sectors corrected without crc errors set */
id|ft_history.crc_failures
op_increment
suffix:semicolon
)brace
id|TRACE_EXIT
id|size
suffix:semicolon
multiline_comment|/* (mseg.blocks - 3) * FT_SECTOR_SIZE; */
)brace
r_else
(brace
id|ft_history.ecc_failures
op_increment
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
op_minus
id|EAGAIN
comma
id|ft_t_err
comma
l_string|&quot;ecc failure on segment %d&quot;
comma
id|buff-&gt;segment_id
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*      Read given segment into buffer at address.&n; */
DECL|function|ftape_read_segment_fraction
r_int
id|ftape_read_segment_fraction
c_func
(paren
r_const
r_int
id|segment_id
comma
r_void
op_star
id|address
comma
r_const
id|ft_read_mode_t
id|read_mode
comma
r_const
r_int
id|start
comma
r_const
r_int
id|size
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|retry
op_assign
l_int|0
suffix:semicolon
r_int
id|bytes_read
op_assign
l_int|0
suffix:semicolon
r_int
id|read_done
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|ft_history.used
op_or_assign
l_int|1
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;segment_id = %d&quot;
comma
id|segment_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_driver_state
op_ne
id|reading
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;calling ftape_abort_operation&quot;
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_abort_operation
c_func
(paren
)paren
comma
)paren
suffix:semicolon
id|ftape_set_state
c_func
(paren
id|reading
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|buffer_struct
op_star
id|tail
suffix:semicolon
multiline_comment|/*  Allow escape from this loop on signal !&n;&t;&t; */
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
multiline_comment|/*  Search all full buffers for the first matching the&n;&t;&t; *  wanted segment.  Clear other buffers on the fly.&n;&t;&t; */
id|tail
op_assign
id|ftape_get_buffer
c_func
(paren
id|ft_queue_tail
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|read_done
op_logical_and
id|tail-&gt;status
op_eq
id|done
)paren
(brace
multiline_comment|/*  Allow escape from this loop on signal !&n;&t;&t;&t; */
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tail-&gt;segment_id
op_eq
id|segment_id
)paren
(brace
multiline_comment|/*  If out buffer is already full,&n;&t;&t;&t;&t; *  return its contents.  &n;&t;&t;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;found segment in cache: %d&quot;
comma
id|segment_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tail-&gt;deleted
)paren
(brace
multiline_comment|/*  Return a value that&n;&t;&t;&t;&t;&t; *  read_header_segment&n;&t;&t;&t;&t;&t; *  understands.  As this&n;&t;&t;&t;&t;&t; *  should only occur when&n;&t;&t;&t;&t;&t; *  searching for the header&n;&t;&t;&t;&t;&t; *  segments it shouldn&squot;t be&n;&t;&t;&t;&t;&t; *  misinterpreted elsewhere.&n;&t;&t;&t;&t;&t; */
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
id|result
op_assign
id|correct_and_copy_fraction
c_func
(paren
id|tail
comma
id|address
comma
id|start
comma
id|size
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;segment contains (bytes): %d&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|result
op_ne
op_minus
id|EAGAIN
)paren
(brace
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/* keep read_done == 0, will&n;&t;&t;&t;&t;&t; * trigger&n;&t;&t;&t;&t;&t; * ftape_abort_operation&n;&t;&t;&t;&t;&t; * because reading wrong&n;&t;&t;&t;&t;&t; * segment.&n;&t;&t;&t;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;ecc failed, retry&quot;
)paren
suffix:semicolon
op_increment
id|retry
suffix:semicolon
)brace
r_else
(brace
id|read_done
op_assign
l_int|1
suffix:semicolon
id|bytes_read
op_assign
id|result
suffix:semicolon
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;zapping segment in cache: %d&quot;
comma
id|tail-&gt;segment_id
)paren
suffix:semicolon
)brace
id|tail-&gt;status
op_assign
id|waiting
suffix:semicolon
id|tail
op_assign
id|ftape_next_buffer
c_func
(paren
id|ft_queue_tail
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|read_done
op_logical_and
id|tail-&gt;status
op_eq
id|reading
)paren
(brace
r_if
c_cond
(paren
id|tail-&gt;segment_id
op_eq
id|segment_id
)paren
(brace
r_switch
c_cond
(paren
id|ftape_wait_segment
c_func
(paren
id|reading
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
op_minus
id|EINTR
suffix:colon
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINTR
comma
id|ft_t_warn
comma
l_string|&quot;interrupted by &quot;
l_string|&quot;non-blockable signal&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;wait_segment failed&quot;
)paren
suffix:semicolon
id|ftape_abort_operation
c_func
(paren
)paren
suffix:semicolon
id|ftape_set_state
c_func
(paren
id|reading
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*  We&squot;re reading the wrong segment,&n;&t;&t;&t;&t; *  stop runner.&n;&t;&t;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;reading wrong segment&quot;
)paren
suffix:semicolon
id|ftape_abort_operation
c_func
(paren
)paren
suffix:semicolon
id|ftape_set_state
c_func
(paren
id|reading
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*    should runner stop ?&n;&t;&t; */
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|aborting
)paren
(brace
id|buffer_struct
op_star
id|head
op_assign
id|ftape_get_buffer
c_func
(paren
id|ft_queue_head
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|head-&gt;status
)paren
(brace
r_case
id|error
suffix:colon
id|ft_history.defects
op_add_assign
id|count_ones
c_func
(paren
id|head-&gt;hard_error_map
)paren
suffix:semicolon
r_case
id|reading
suffix:colon
id|head-&gt;status
op_assign
id|waiting
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|TRACE_CATCH
c_func
(paren
id|ftape_dumb_stop
c_func
(paren
)paren
comma
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  If just passed last segment on tape: wait&n;&t;&t;&t; *  for BOT or EOT mark. Sets ft_runner_status to&n;&t;&t;&t; *  idle if at lEOT and successful &n;&t;&t;&t; */
id|TRACE_CATCH
c_func
(paren
id|ftape_handle_logical_eot
c_func
(paren
)paren
comma
)paren
suffix:semicolon
)brace
multiline_comment|/*    If we got a segment: quit, or else retry up to limit.&n;&t;&t; *&n;&t;&t; *    If segment to read is empty, do not start runner for it,&n;&t;&t; *    but wait for next read call.&n;&t;&t; */
r_if
c_cond
(paren
id|read_done
op_logical_or
id|ftape_get_bad_sector_entry
c_func
(paren
id|segment_id
)paren
op_eq
id|EMPTY_SEGMENT
)paren
(brace
multiline_comment|/* bytes_read = 0;  should still be zero */
id|TRACE_EXIT
id|bytes_read
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retry
OG
id|FT_RETRIES_ON_ECC_ERROR
)paren
(brace
id|ft_history.defects
op_increment
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
op_minus
id|ENODATA
comma
id|ft_t_err
comma
l_string|&quot;too many retries on ecc failure&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*    Now at least one buffer is empty !&n;&t;&t; *    Restart runner &amp; tape if needed.&n;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_any
comma
l_string|&quot;head: %d, tail: %d, ft_runner_status: %d&quot;
comma
id|ftape_buffer_id
c_func
(paren
id|ft_queue_head
)paren
comma
id|ftape_buffer_id
c_func
(paren
id|ft_queue_tail
)paren
comma
id|ft_runner_status
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_any
comma
l_string|&quot;buffer[].status, [head]: %d, [tail]: %d&quot;
comma
id|ftape_get_buffer
c_func
(paren
id|ft_queue_head
)paren
op_member_access_from_pointer
id|status
comma
id|ftape_get_buffer
c_func
(paren
id|ft_queue_tail
)paren
op_member_access_from_pointer
id|status
)paren
suffix:semicolon
id|tail
op_assign
id|ftape_get_buffer
c_func
(paren
id|ft_queue_tail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tail-&gt;status
op_eq
id|waiting
)paren
(brace
id|buffer_struct
op_star
id|head
op_assign
id|ftape_get_buffer
c_func
(paren
id|ft_queue_head
)paren
suffix:semicolon
id|ftape_setup_new_segment
c_func
(paren
id|head
comma
id|segment_id
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_mode
op_eq
id|FT_RD_SINGLE
)paren
(brace
multiline_comment|/* disable read-ahead */
id|head-&gt;next_segment
op_assign
l_int|0
suffix:semicolon
)brace
id|ftape_calc_next_cluster
c_func
(paren
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|idle
)paren
(brace
id|result
op_assign
id|ftape_start_tape
c_func
(paren
id|segment_id
comma
id|head-&gt;sector_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE_ABORT
c_func
(paren
id|result
comma
id|ft_t_err
comma
l_string|&quot;Error: &quot;
l_string|&quot;segment %d unreachable&quot;
comma
id|segment_id
)paren
suffix:semicolon
)brace
)brace
id|head-&gt;status
op_assign
id|reading
suffix:semicolon
id|fdc_setup_read_write
c_func
(paren
id|head
comma
id|FDC_READ
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* not reached */
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|ftape_read_header_segment
r_int
id|ftape_read_header_segment
c_func
(paren
id|__u8
op_star
id|address
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|header_segment
suffix:semicolon
r_int
id|first_failed
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|ft_used_header_segment
op_assign
op_minus
l_int|1
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_report_drive_status
c_func
(paren
op_amp
id|status
)paren
comma
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;reading...&quot;
)paren
suffix:semicolon
multiline_comment|/*  We&squot;re looking for the first header segment.&n;&t; *  A header segment cannot contain bad sectors, therefor at the&n;&t; *  tape start, segments with bad sectors are (according to QIC-40/80)&n;&t; *  written with deleted data marks and must be skipped.&n;&t; */
id|memset
c_func
(paren
id|address
comma
l_char|&squot;&bslash;0&squot;
comma
(paren
id|FT_SECTORS_PER_SEGMENT
op_minus
l_int|3
)paren
op_star
id|FT_SECTOR_SIZE
)paren
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
DECL|macro|HEADER_SEGMENT_BOUNDARY
mdefine_line|#define HEADER_SEGMENT_BOUNDARY 68  /* why not 42? */
r_for
c_loop
(paren
id|header_segment
op_assign
l_int|0
suffix:semicolon
id|header_segment
OL
id|HEADER_SEGMENT_BOUNDARY
op_logical_and
id|result
op_eq
l_int|0
suffix:semicolon
op_increment
id|header_segment
)paren
(brace
multiline_comment|/*  Set no read-ahead, the isr will force read-ahead whenever&n;&t;&t; *  it encounters deleted data !&n;&t;&t; */
id|result
op_assign
id|ftape_read_segment
c_func
(paren
id|header_segment
comma
id|address
comma
id|FT_RD_SINGLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
op_logical_and
op_logical_neg
id|first_failed
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;header segment damaged, trying backup&quot;
)paren
suffix:semicolon
id|first_failed
op_assign
l_int|1
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* force read of next (backup) segment */
)brace
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
op_logical_or
id|header_segment
op_ge
id|HEADER_SEGMENT_BOUNDARY
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;no readable header segment found&quot;
)paren
suffix:semicolon
)brace
id|TRACE_CATCH
c_func
(paren
id|ftape_abort_operation
c_func
(paren
)paren
comma
)paren
suffix:semicolon
id|ft_used_header_segment
op_assign
id|header_segment
suffix:semicolon
id|result
op_assign
id|ftape_decode_header_segment
c_func
(paren
id|address
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|ftape_decode_header_segment
r_int
id|ftape_decode_header_segment
c_func
(paren
id|__u8
op_star
id|address
)paren
(brace
r_int
r_int
id|max_floppy_side
suffix:semicolon
r_int
r_int
id|max_floppy_track
suffix:semicolon
r_int
r_int
id|max_floppy_sector
suffix:semicolon
r_int
r_int
id|new_tape_len
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GET4
c_func
(paren
id|address
comma
id|FT_SIGNATURE
)paren
op_eq
id|FT_D2G_MAGIC
)paren
(brace
multiline_comment|/* Ditto 2GB header segment. They encrypt the bad sector map.&n;&t;&t; * We decrypt it and store them in normal format.&n;&t;&t; * I hope this is correct.&n;&t;&t; */
r_int
id|i
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Found Ditto 2GB tape, &quot;
l_string|&quot;trying to decrypt bad sector map&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|256
suffix:semicolon
id|i
OL
l_int|29
op_star
id|FT_SECTOR_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|address
(braket
id|i
)braket
op_assign
op_complement
(paren
id|address
(braket
id|i
)braket
op_minus
(paren
id|i
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
)brace
id|PUT4
c_func
(paren
id|address
comma
l_int|0
comma
id|FT_HSEG_MAGIC
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|GET4
c_func
(paren
id|address
comma
id|FT_SIGNATURE
)paren
op_ne
id|FT_HSEG_MAGIC
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;wrong signature in header segment&quot;
)paren
suffix:semicolon
)brace
id|ft_format_code
op_assign
(paren
id|ft_format_type
)paren
id|address
(braket
id|FT_FMT_CODE
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ft_format_code
op_ne
id|fmt_big
)paren
(brace
id|ft_header_segment_1
op_assign
id|GET2
c_func
(paren
id|address
comma
id|FT_HSEG_1
)paren
suffix:semicolon
id|ft_header_segment_2
op_assign
id|GET2
c_func
(paren
id|address
comma
id|FT_HSEG_2
)paren
suffix:semicolon
id|ft_first_data_segment
op_assign
id|GET2
c_func
(paren
id|address
comma
id|FT_FRST_SEG
)paren
suffix:semicolon
id|ft_last_data_segment
op_assign
id|GET2
c_func
(paren
id|address
comma
id|FT_LAST_SEG
)paren
suffix:semicolon
)brace
r_else
(brace
id|ft_header_segment_1
op_assign
id|GET4
c_func
(paren
id|address
comma
id|FT_6_HSEG_1
)paren
suffix:semicolon
id|ft_header_segment_2
op_assign
id|GET4
c_func
(paren
id|address
comma
id|FT_6_HSEG_2
)paren
suffix:semicolon
id|ft_first_data_segment
op_assign
id|GET4
c_func
(paren
id|address
comma
id|FT_6_FRST_SEG
)paren
suffix:semicolon
id|ft_last_data_segment
op_assign
id|GET4
c_func
(paren
id|address
comma
id|FT_6_LAST_SEG
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;first data segment: %d&quot;
comma
id|ft_first_data_segment
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;last  data segment: %d&quot;
comma
id|ft_last_data_segment
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;header segments are %d and %d&quot;
comma
id|ft_header_segment_1
comma
id|ft_header_segment_2
)paren
suffix:semicolon
multiline_comment|/*    Verify tape parameters...&n;&t; *    QIC-40/80 spec:                 tape_parameters:&n;&t; *&n;&t; *    segments-per-track              segments_per_track&n;&t; *    tracks-per-cartridge            tracks_per_tape&n;&t; *    max-floppy-side                 (segments_per_track *&n;&t; *                                    tracks_per_tape - 1) /&n;&t; *                                    ftape_segments_per_head&n;&t; *    max-floppy-track                ftape_segments_per_head /&n;&t; *                                    ftape_segments_per_cylinder - 1&n;&t; *    max-floppy-sector               ftape_segments_per_cylinder *&n;&t; *                                    FT_SECTORS_PER_SEGMENT&n;&t; */
id|ft_segments_per_track
op_assign
id|GET2
c_func
(paren
id|address
comma
id|FT_SPT
)paren
suffix:semicolon
id|ft_tracks_per_tape
op_assign
id|address
(braket
id|FT_TPC
)braket
suffix:semicolon
id|max_floppy_side
op_assign
id|address
(braket
id|FT_FHM
)braket
suffix:semicolon
id|max_floppy_track
op_assign
id|address
(braket
id|FT_FTM
)braket
suffix:semicolon
id|max_floppy_sector
op_assign
id|address
(braket
id|FT_FSM
)braket
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;(fmt/spt/tpc/fhm/ftm/fsm) = %d/%d/%d/%d/%d/%d&quot;
comma
id|ft_format_code
comma
id|ft_segments_per_track
comma
id|ft_tracks_per_tape
comma
id|max_floppy_side
comma
id|max_floppy_track
comma
id|max_floppy_sector
)paren
suffix:semicolon
id|new_tape_len
op_assign
id|ftape_tape_len
suffix:semicolon
r_switch
c_cond
(paren
id|ft_format_code
)paren
(brace
r_case
id|fmt_425ft
suffix:colon
id|new_tape_len
op_assign
l_int|425
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fmt_normal
suffix:colon
r_if
c_cond
(paren
id|ftape_tape_len
op_eq
l_int|0
)paren
(brace
multiline_comment|/* otherwise 307 ft */
id|new_tape_len
op_assign
l_int|205
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|fmt_1100ft
suffix:colon
id|new_tape_len
op_assign
l_int|1100
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fmt_var
suffix:colon
(brace
r_int
id|segments_per_1000_inch
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* non-zero default for switch */
r_switch
c_cond
(paren
id|ft_qic_std
)paren
(brace
r_case
id|QIC_TAPE_QIC40
suffix:colon
id|segments_per_1000_inch
op_assign
l_int|332
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_QIC80
suffix:colon
id|segments_per_1000_inch
op_assign
l_int|488
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_QIC3010
suffix:colon
id|segments_per_1000_inch
op_assign
l_int|730
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_QIC3020
suffix:colon
id|segments_per_1000_inch
op_assign
l_int|1430
suffix:semicolon
r_break
suffix:semicolon
)brace
id|new_tape_len
op_assign
(paren
l_int|1000
op_star
id|ft_segments_per_track
op_plus
(paren
id|segments_per_1000_inch
op_minus
l_int|1
)paren
)paren
op_div
id|segments_per_1000_inch
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|fmt_big
suffix:colon
(brace
r_int
id|segments_per_1000_inch
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* non-zero default for switch */
r_switch
c_cond
(paren
id|ft_qic_std
)paren
(brace
r_case
id|QIC_TAPE_QIC40
suffix:colon
id|segments_per_1000_inch
op_assign
l_int|332
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_QIC80
suffix:colon
id|segments_per_1000_inch
op_assign
l_int|488
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_QIC3010
suffix:colon
id|segments_per_1000_inch
op_assign
l_int|730
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_QIC3020
suffix:colon
id|segments_per_1000_inch
op_assign
l_int|1430
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_bug
comma
l_string|&quot;%x QIC-standard with fmt-code %d, please report&quot;
comma
id|ft_qic_std
comma
id|ft_format_code
)paren
suffix:semicolon
)brace
id|new_tape_len
op_assign
(paren
(paren
l_int|1000
op_star
id|ft_segments_per_track
op_plus
(paren
id|segments_per_1000_inch
op_minus
l_int|1
)paren
)paren
op_div
id|segments_per_1000_inch
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;unknown tape format, please report !&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_tape_len
op_ne
id|ftape_tape_len
)paren
(brace
id|ftape_tape_len
op_assign
id|new_tape_len
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;calculated tape length is %d ft&quot;
comma
id|ftape_tape_len
)paren
suffix:semicolon
id|ftape_calc_timeouts
c_func
(paren
id|ft_qic_std
comma
id|ft_data_rate
comma
id|ftape_tape_len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_segments_per_track
op_eq
l_int|0
op_logical_and
id|ft_tracks_per_tape
op_eq
l_int|0
op_logical_and
id|max_floppy_side
op_eq
l_int|0
op_logical_and
id|max_floppy_track
op_eq
l_int|0
op_logical_and
id|max_floppy_sector
op_eq
l_int|0
)paren
(brace
multiline_comment|/*  QIC-40 Rev E and earlier has no values in the header.&n;&t;&t; */
id|ft_segments_per_track
op_assign
l_int|68
suffix:semicolon
id|ft_tracks_per_tape
op_assign
l_int|20
suffix:semicolon
id|max_floppy_side
op_assign
l_int|1
suffix:semicolon
id|max_floppy_track
op_assign
l_int|169
suffix:semicolon
id|max_floppy_sector
op_assign
l_int|128
suffix:semicolon
)brace
multiline_comment|/*  This test will compensate for the wrong parameter on tapes&n;&t; *  formatted by Conner software.&n;&t; */
r_if
c_cond
(paren
id|ft_segments_per_track
op_eq
l_int|150
op_logical_and
id|ft_tracks_per_tape
op_eq
l_int|28
op_logical_and
id|max_floppy_side
op_eq
l_int|7
op_logical_and
id|max_floppy_track
op_eq
l_int|149
op_logical_and
id|max_floppy_sector
op_eq
l_int|128
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;the famous CONNER bug: max_floppy_side off by one !&quot;
)paren
suffix:semicolon
id|max_floppy_side
op_assign
l_int|6
suffix:semicolon
)brace
multiline_comment|/*  These tests will compensate for the wrong parameter on tapes&n;&t; *  formatted by ComByte Windows software.&n;&t; *&n;&t; *  First, for 205 foot tapes&n;&t; */
r_if
c_cond
(paren
id|ft_segments_per_track
op_eq
l_int|100
op_logical_and
id|ft_tracks_per_tape
op_eq
l_int|28
op_logical_and
id|max_floppy_side
op_eq
l_int|9
op_logical_and
id|max_floppy_track
op_eq
l_int|149
op_logical_and
id|max_floppy_sector
op_eq
l_int|128
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;the ComByte bug: max_floppy_side incorrect!&quot;
)paren
suffix:semicolon
id|max_floppy_side
op_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/* Next, for 307 foot tapes. */
r_if
c_cond
(paren
id|ft_segments_per_track
op_eq
l_int|150
op_logical_and
id|ft_tracks_per_tape
op_eq
l_int|28
op_logical_and
id|max_floppy_side
op_eq
l_int|9
op_logical_and
id|max_floppy_track
op_eq
l_int|149
op_logical_and
id|max_floppy_sector
op_eq
l_int|128
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;the ComByte bug: max_floppy_side incorrect!&quot;
)paren
suffix:semicolon
id|max_floppy_side
op_assign
l_int|6
suffix:semicolon
)brace
multiline_comment|/*  This test will compensate for the wrong parameter on tapes&n;&t; *  formatted by Colorado Windows software.&n;&t; */
r_if
c_cond
(paren
id|ft_segments_per_track
op_eq
l_int|150
op_logical_and
id|ft_tracks_per_tape
op_eq
l_int|28
op_logical_and
id|max_floppy_side
op_eq
l_int|6
op_logical_and
id|max_floppy_track
op_eq
l_int|150
op_logical_and
id|max_floppy_sector
op_eq
l_int|128
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;the famous Colorado bug: max_floppy_track off by one !&quot;
)paren
suffix:semicolon
id|max_floppy_track
op_assign
l_int|149
suffix:semicolon
)brace
id|ftape_segments_per_head
op_assign
(paren
(paren
id|max_floppy_sector
op_div
id|FT_SECTORS_PER_SEGMENT
)paren
op_star
(paren
id|max_floppy_track
op_plus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/*  This test will compensate for some bug reported by Dima&n;&t; *  Brodsky.  Seems to be a Colorado bug, either. (freebee&n;&t; *  Imation tape shipped together with Colorado T3000&n;&t; */
r_if
c_cond
(paren
(paren
id|ft_format_code
op_eq
id|fmt_var
op_logical_or
id|ft_format_code
op_eq
id|fmt_big
)paren
op_logical_and
id|ft_tracks_per_tape
op_eq
l_int|50
op_logical_and
id|max_floppy_side
op_eq
l_int|54
op_logical_and
id|max_floppy_track
op_eq
l_int|255
op_logical_and
id|max_floppy_sector
op_eq
l_int|128
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;the famous ??? bug: max_floppy_track off by one !&quot;
)paren
suffix:semicolon
id|max_floppy_track
op_assign
l_int|254
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *    Verify drive_configuration with tape parameters&n;&t; */
r_if
c_cond
(paren
id|ftape_segments_per_head
op_eq
l_int|0
op_logical_or
id|ftape_segments_per_cylinder
op_eq
l_int|0
op_logical_or
(paren
(paren
id|ft_segments_per_track
op_star
id|ft_tracks_per_tape
op_minus
l_int|1
)paren
op_div
id|ftape_segments_per_head
op_ne
id|max_floppy_side
)paren
op_logical_or
(paren
id|ftape_segments_per_head
op_div
id|ftape_segments_per_cylinder
op_minus
l_int|1
op_ne
id|max_floppy_track
)paren
op_logical_or
(paren
id|ftape_segments_per_cylinder
op_star
id|FT_SECTORS_PER_SEGMENT
op_ne
id|max_floppy_sector
)paren
macro_line|#ifdef TESTING
op_logical_or
(paren
(paren
id|ft_format_code
op_eq
id|fmt_var
op_logical_or
id|ft_format_code
op_eq
id|fmt_big
)paren
op_logical_and
(paren
id|max_floppy_track
op_ne
l_int|254
op_logical_or
id|max_floppy_sector
op_ne
l_int|128
)paren
)paren
macro_line|#endif
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;Tape parameters inconsistency, please report&quot;
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;reported = %d/%d/%d/%d/%d/%d&quot;
comma
id|ft_format_code
comma
id|ft_segments_per_track
comma
id|ft_tracks_per_tape
comma
id|max_floppy_side
comma
id|max_floppy_track
comma
id|max_floppy_sector
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;required = %d/%d/%d/%d/%d/%d&quot;
comma
id|ft_format_code
comma
id|ft_segments_per_track
comma
id|ft_tracks_per_tape
comma
(paren
(paren
id|ft_segments_per_track
op_star
id|ft_tracks_per_tape
op_minus
l_int|1
)paren
op_div
id|ftape_segments_per_head
)paren
comma
(paren
id|ftape_segments_per_head
op_div
id|ftape_segments_per_cylinder
op_minus
l_int|1
)paren
comma
(paren
id|ftape_segments_per_cylinder
op_star
id|FT_SECTORS_PER_SEGMENT
)paren
)paren
suffix:semicolon
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
)brace
id|ftape_extract_bad_sector_map
c_func
(paren
id|address
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
eof
