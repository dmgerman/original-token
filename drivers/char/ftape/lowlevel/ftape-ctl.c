multiline_comment|/*&n; *      Copyright (C) 1993-1996 Bas Laarhoven,&n; *                    1996-1997 Claus-Justus Heine.&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; *&n; * $Source: /homes/cvs/ftape-stacked/ftape/lowlevel/ftape-ctl.c,v $&n; * $Revision: 1.4 $&n; * $Date: 1997/11/11 14:37:44 $&n; *&n; *      This file contains the non-read/write ftape functions for the&n; *      QIC-40/80/3010/3020 floppy-tape driver &quot;ftape&quot; for Linux.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/wrapper.h&gt;
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &lt;linux/qic117.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VER(2,1,6)
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#else
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/io.h&gt;
multiline_comment|/* ease porting between pre-2.4.x and later kernels */
DECL|macro|vma_get_pgoff
mdefine_line|#define vma_get_pgoff(v)      ((v)-&gt;vm_pgoff)
macro_line|#include &quot;../lowlevel/ftape-tracing.h&quot;
macro_line|#include &quot;../lowlevel/ftape-io.h&quot;
macro_line|#include &quot;../lowlevel/ftape-ctl.h&quot;
macro_line|#include &quot;../lowlevel/ftape-write.h&quot;
macro_line|#include &quot;../lowlevel/ftape-read.h&quot;
macro_line|#include &quot;../lowlevel/ftape-rw.h&quot;
macro_line|#include &quot;../lowlevel/ftape-bsm.h&quot;
multiline_comment|/*      Global vars.&n; */
DECL|variable|ftape_status
id|ftape_info
id|ftape_status
op_assign
(brace
multiline_comment|/*  vendor information */
(brace
l_int|0
comma
)brace
comma
multiline_comment|/* drive type */
multiline_comment|/*  data rates */
l_int|500
comma
multiline_comment|/* used data rate */
l_int|500
comma
multiline_comment|/* drive max rate */
l_int|500
comma
multiline_comment|/* fdc max rate   */
multiline_comment|/*  drive selection, either FTAPE_SEL_A/B/C/D */
op_minus
l_int|1
comma
multiline_comment|/* drive selection */
multiline_comment|/*  flags set after decode the drive and tape status   */
l_int|0
comma
multiline_comment|/* formatted */
l_int|1
comma
multiline_comment|/* no tape */
l_int|1
comma
multiline_comment|/* write protected */
l_int|1
comma
multiline_comment|/* new tape */
multiline_comment|/*  values of last queried drive/tape status and error */
(brace
(brace
l_int|0
comma
)brace
)brace
comma
multiline_comment|/* last error code */
(brace
(brace
l_int|0
comma
)brace
)brace
comma
multiline_comment|/* drive status, configuration, tape status */
multiline_comment|/*  cartridge geometry */
l_int|20
comma
multiline_comment|/* tracks_per_tape */
l_int|102
comma
multiline_comment|/* segments_per_track */
multiline_comment|/*  location of header segments, etc. */
op_minus
l_int|1
comma
multiline_comment|/* used_header_segment */
op_minus
l_int|1
comma
multiline_comment|/* header_segment_1 */
op_minus
l_int|1
comma
multiline_comment|/* header_segment_2 */
op_minus
l_int|1
comma
multiline_comment|/* first_data_segment */
op_minus
l_int|1
comma
multiline_comment|/* last_data_segment */
multiline_comment|/*  the format code as stored in the header segment  */
id|fmt_normal
comma
multiline_comment|/* format code */
multiline_comment|/*  the default for the qic std: unknown */
op_minus
l_int|1
comma
multiline_comment|/*  is tape running? */
id|idle
comma
multiline_comment|/* runner_state */
multiline_comment|/*  is tape reading/writing/verifying/formatting/deleting */
id|idle
comma
multiline_comment|/* driver state */
multiline_comment|/*  flags fatal hardware error */
l_int|1
comma
multiline_comment|/* failure */
multiline_comment|/*  history record */
(brace
l_int|0
comma
)brace
multiline_comment|/* history record */
)brace
suffix:semicolon
DECL|variable|ftape_segments_per_head
r_int
id|ftape_segments_per_head
op_assign
l_int|1020
suffix:semicolon
DECL|variable|ftape_segments_per_cylinder
r_int
id|ftape_segments_per_cylinder
op_assign
l_int|4
suffix:semicolon
DECL|variable|ftape_init_drive_needed
r_int
id|ftape_init_drive_needed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* need to be global for ftape_reset_drive()&n;&t;&t;&t;&t;  * in ftape-io.c&n;&t;&t;&t;&t;  */
multiline_comment|/*      Local vars.&n; */
DECL|variable|vendors
r_static
r_const
id|vendor_struct
id|vendors
(braket
)braket
op_assign
id|QIC117_VENDORS
suffix:semicolon
DECL|variable|methods
r_static
r_const
id|wakeup_method
id|methods
(braket
)braket
op_assign
id|WAKEUP_METHODS
suffix:semicolon
DECL|function|ftape_get_status
r_const
id|ftape_info
op_star
id|ftape_get_status
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined(STATUS_PARANOYA)
r_static
id|ftape_info
id|get_status
suffix:semicolon
id|get_status
op_assign
id|ftape_status
suffix:semicolon
r_return
op_amp
id|get_status
suffix:semicolon
macro_line|#else
r_return
op_amp
id|ftape_status
suffix:semicolon
multiline_comment|/*  maybe return only a copy of it to assure &n;&t;&t;&t;       *  read only access&n;&t;&t;&t;       */
macro_line|#endif
)brace
DECL|function|ftape_set_status
r_void
id|ftape_set_status
c_func
(paren
r_const
id|ftape_info
op_star
id|status
)paren
(brace
id|ftape_status
op_assign
op_star
id|status
suffix:semicolon
)brace
DECL|function|ftape_not_operational
r_static
r_int
id|ftape_not_operational
c_func
(paren
r_int
id|status
)paren
(brace
multiline_comment|/* return true if status indicates tape can not be used.&n;&t; */
r_return
(paren
(paren
id|status
op_xor
id|QIC_STATUS_CARTRIDGE_PRESENT
)paren
op_amp
(paren
id|QIC_STATUS_ERROR
op_or
id|QIC_STATUS_CARTRIDGE_PRESENT
op_or
id|QIC_STATUS_NEW_CARTRIDGE
)paren
)paren
suffix:semicolon
)brace
DECL|function|ftape_seek_to_eot
r_int
id|ftape_seek_to_eot
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_ready_wait
c_func
(paren
id|ftape_timeout.pause
comma
op_amp
id|status
)paren
comma
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|status
op_amp
id|QIC_STATUS_AT_EOT
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ftape_not_operational
c_func
(paren
id|status
)paren
)paren
(brace
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
)brace
id|TRACE_CATCH
c_func
(paren
id|ftape_command_wait
c_func
(paren
id|QIC_PHYSICAL_FORWARD
comma
id|ftape_timeout.rewind
comma
op_amp
id|status
)paren
comma
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_seek_to_bot
r_int
id|ftape_seek_to_bot
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_ready_wait
c_func
(paren
id|ftape_timeout.pause
comma
op_amp
id|status
)paren
comma
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|status
op_amp
id|QIC_STATUS_AT_BOT
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ftape_not_operational
c_func
(paren
id|status
)paren
)paren
(brace
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
)brace
id|TRACE_CATCH
c_func
(paren
id|ftape_command_wait
c_func
(paren
id|QIC_PHYSICAL_REVERSE
comma
id|ftape_timeout.rewind
comma
op_amp
id|status
)paren
comma
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_new_cartridge
r_static
r_int
id|ftape_new_cartridge
c_func
(paren
r_void
)paren
(brace
id|ft_location.track
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* force seek on first access */
id|ftape_zap_read_buffers
c_func
(paren
)paren
suffix:semicolon
id|ftape_zap_write_buffers
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_abort_operation
r_int
id|ftape_abort_operation
c_func
(paren
r_void
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|running
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;aborting runner, waiting&quot;
)paren
suffix:semicolon
id|ft_runner_status
op_assign
id|do_abort
suffix:semicolon
multiline_comment|/* set timeout so that the tape will run to logical EOT&n;&t;&t; * if we missed the last sector and there are no queue pulses.&n;&t;&t; */
id|result
op_assign
id|ftape_dumb_stop
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_runner_status
op_ne
id|idle
)paren
(brace
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|do_abort
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;forcing runner abort&quot;
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;stopping tape&quot;
)paren
suffix:semicolon
id|result
op_assign
id|ftape_stop_tape
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
id|ft_location.known
op_assign
l_int|0
suffix:semicolon
id|ft_runner_status
op_assign
id|idle
suffix:semicolon
)brace
id|ftape_reset_buffer
c_func
(paren
)paren
suffix:semicolon
id|ftape_zap_read_buffers
c_func
(paren
)paren
suffix:semicolon
id|ftape_set_state
c_func
(paren
id|idle
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|lookup_vendor_id
r_static
r_int
id|lookup_vendor_id
c_func
(paren
r_int
r_int
id|vendor_id
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|vendors
(braket
id|i
)braket
dot
id|vendor_id
op_ne
id|vendor_id
)paren
(brace
r_if
c_cond
(paren
op_increment
id|i
op_ge
id|NR_ITEMS
c_func
(paren
id|vendors
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|i
suffix:semicolon
)brace
DECL|function|ftape_detach_drive
r_void
id|ftape_detach_drive
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;disabling tape drive and fdc&quot;
)paren
suffix:semicolon
id|ftape_put_drive_to_sleep
c_func
(paren
id|ft_drive_type.wake_up
)paren
suffix:semicolon
id|fdc_catch_stray_interrupts
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* one always comes */
id|fdc_disable
c_func
(paren
)paren
suffix:semicolon
id|fdc_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
id|fdc_release_regions
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|clear_history
r_static
r_void
id|clear_history
c_func
(paren
r_void
)paren
(brace
id|ft_history.used
op_assign
l_int|0
suffix:semicolon
id|ft_history.id_am_errors
op_assign
id|ft_history.id_crc_errors
op_assign
id|ft_history.data_am_errors
op_assign
id|ft_history.data_crc_errors
op_assign
id|ft_history.overrun_errors
op_assign
id|ft_history.no_data_errors
op_assign
id|ft_history.retries
op_assign
id|ft_history.crc_errors
op_assign
id|ft_history.crc_failures
op_assign
id|ft_history.ecc_failures
op_assign
id|ft_history.corrected
op_assign
id|ft_history.defects
op_assign
id|ft_history.rewinds
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_activate_drive
r_int
id|ftape_activate_drive
c_func
(paren
id|vendor_struct
op_star
id|drive_type
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
multiline_comment|/* If we already know the drive type, wake it up.&n;&t; * Else try to find out what kind of drive is attached.&n;&t; */
r_if
c_cond
(paren
id|drive_type-&gt;wake_up
op_ne
id|unknown_wake_up
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;enabling tape drive and fdc&quot;
)paren
suffix:semicolon
id|result
op_assign
id|ftape_wakeup_drive
c_func
(paren
id|drive_type-&gt;wake_up
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;known wakeup method failed&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|wake_up_types
id|method
suffix:semicolon
r_const
id|ft_trace_t
id|old_tracing
op_assign
id|TRACE_LEVEL
suffix:semicolon
r_if
c_cond
(paren
id|TRACE_LEVEL
OL
id|ft_t_flow
)paren
(brace
id|SET_TRACE_LEVEL
c_func
(paren
id|ft_t_bug
)paren
suffix:semicolon
)brace
multiline_comment|/*  Try to awaken the drive using all known methods.&n;&t;&t; *  Lower tracing for a while.&n;&t;&t; */
r_for
c_loop
(paren
id|method
op_assign
id|no_wake_up
suffix:semicolon
id|method
OL
id|NR_ITEMS
c_func
(paren
id|methods
)paren
suffix:semicolon
op_increment
id|method
)paren
(brace
id|drive_type-&gt;wake_up
op_assign
id|method
suffix:semicolon
macro_line|#ifdef CONFIG_FT_TWO_DRIVES
multiline_comment|/*  Test setup for dual drive configuration.&n;&t;&t;&t; *  /dev/rft2 uses mountain wakeup&n;&t;&t;&t; *  /dev/rft3 uses colorado wakeup&n;&t;&t;&t; *  Other systems will use the normal scheme.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|ft_drive_sel
OL
l_int|2
)paren
op_logical_or
(paren
id|ft_drive_sel
op_eq
l_int|2
op_logical_and
id|method
op_eq
id|FT_WAKE_UP_1
)paren
op_logical_or
(paren
id|ft_drive_sel
op_eq
l_int|3
op_logical_and
id|method
op_eq
id|FT_WAKE_UP_2
)paren
)paren
(brace
id|result
op_assign
id|ftape_wakeup_drive
c_func
(paren
id|drive_type-&gt;wake_up
)paren
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#else
id|result
op_assign
id|ftape_wakeup_drive
c_func
(paren
id|drive_type-&gt;wake_up
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;drive wakeup method: %s&quot;
comma
id|methods
(braket
id|drive_type-&gt;wake_up
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|SET_TRACE_LEVEL
c_func
(paren
id|old_tracing
)paren
suffix:semicolon
r_if
c_cond
(paren
id|method
op_ge
id|NR_ITEMS
c_func
(paren
id|methods
)paren
)paren
(brace
multiline_comment|/* no response at all, cannot open this drive */
id|drive_type-&gt;wake_up
op_assign
id|unknown_wake_up
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;no tape drive found !&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|ftape_get_drive_status
r_int
id|ftape_get_drive_status
c_func
(paren
r_void
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|status
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|ft_no_tape
op_assign
id|ft_write_protected
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*    Tape drive is activated now.&n;&t; *    First clear error status if present.&n;&t; */
r_do
(brace
id|result
op_assign
id|ftape_ready_wait
c_func
(paren
id|ftape_timeout.reset
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ETIME
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;ftape_ready_wait timeout&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EINTR
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;ftape_ready_wait aborted&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;ftape_ready_wait failed&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*  Clear error condition (drive is ready !)&n;&t;&t; */
r_if
c_cond
(paren
id|status
op_amp
id|QIC_STATUS_ERROR
)paren
(brace
r_int
r_int
id|error
suffix:semicolon
id|qic117_cmd_t
id|command
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;error status set&quot;
)paren
suffix:semicolon
id|result
op_assign
id|ftape_report_error
c_func
(paren
op_amp
id|error
comma
op_amp
id|command
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;report_error_code failed: %d&quot;
comma
id|result
)paren
suffix:semicolon
multiline_comment|/* hope it&squot;s working next time */
id|ftape_reset_drive
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;error code   : %d&quot;
comma
id|error
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;error command: %d&quot;
comma
id|command
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|status
op_amp
id|QIC_STATUS_NEW_CARTRIDGE
)paren
(brace
r_int
r_int
id|error
suffix:semicolon
id|qic117_cmd_t
id|command
suffix:semicolon
r_const
id|ft_trace_t
id|old_tracing
op_assign
id|TRACE_LEVEL
suffix:semicolon
id|SET_TRACE_LEVEL
c_func
(paren
id|ft_t_bug
)paren
suffix:semicolon
multiline_comment|/*  Undocumented feature: Must clear (not present!)&n;&t;&t;&t; *  error here or we&squot;ll fail later.&n;&t;&t;&t; */
id|ftape_report_error
c_func
(paren
op_amp
id|error
comma
op_amp
id|command
comma
l_int|1
)paren
suffix:semicolon
id|SET_TRACE_LEVEL
c_func
(paren
id|old_tracing
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;status: new cartridge&quot;
)paren
suffix:semicolon
id|ft_new_tape
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|ft_new_tape
op_assign
l_int|0
suffix:semicolon
)brace
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|status
op_amp
id|QIC_STATUS_ERROR
)paren
suffix:semicolon
id|ft_no_tape
op_assign
op_logical_neg
(paren
id|status
op_amp
id|QIC_STATUS_CARTRIDGE_PRESENT
)paren
suffix:semicolon
id|ft_write_protected
op_assign
(paren
id|status
op_amp
id|QIC_STATUS_WRITE_PROTECT
)paren
op_ne
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ft_no_tape
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;no cartridge present&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ft_write_protected
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Write protected cartridge&quot;
)paren
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_log_vendor_id
r_void
id|ftape_log_vendor_id
c_func
(paren
r_void
)paren
(brace
r_int
id|vendor_index
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|ftape_report_vendor_id
c_func
(paren
op_amp
id|ft_drive_type.vendor_id
)paren
suffix:semicolon
id|vendor_index
op_assign
id|lookup_vendor_id
c_func
(paren
id|ft_drive_type.vendor_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_drive_type.vendor_id
op_eq
id|UNKNOWN_VENDOR
op_logical_and
id|ft_drive_type.wake_up
op_eq
id|wake_up_colorado
)paren
(brace
id|vendor_index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* hack to get rid of all this mail */
id|ft_drive_type.vendor_id
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vendor_index
OL
l_int|0
)paren
(brace
multiline_comment|/* Unknown vendor id, first time opening device.  The&n;&t;&t; * drive_type remains set to type found at wakeup&n;&t;&t; * time, this will probably keep the driver operating&n;&t;&t; * for this new vendor.  &n;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;============ unknown vendor id ===========&bslash;n&quot;
id|KERN_INFO
l_string|&quot;A new, yet unsupported tape drive is found&bslash;n&quot;
id|KERN_INFO
l_string|&quot;Please report the following values:&bslash;n&quot;
id|KERN_INFO
l_string|&quot;   Vendor id     : 0x%04x&bslash;n&quot;
id|KERN_INFO
l_string|&quot;   Wakeup method : %s&bslash;n&quot;
id|KERN_INFO
l_string|&quot;And a description of your tape drive&bslash;n&quot;
id|KERN_INFO
l_string|&quot;to &quot;
id|THE_FTAPE_MAINTAINER
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;==========================================&quot;
comma
id|ft_drive_type.vendor_id
comma
id|methods
(braket
id|ft_drive_type.wake_up
)braket
dot
id|name
)paren
suffix:semicolon
id|ft_drive_type.speed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unknown */
)brace
r_else
(brace
id|ft_drive_type.name
op_assign
id|vendors
(braket
id|vendor_index
)braket
dot
id|name
suffix:semicolon
id|ft_drive_type.speed
op_assign
id|vendors
(braket
id|vendor_index
)braket
dot
id|speed
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;tape drive type: %s&quot;
comma
id|ft_drive_type.name
)paren
suffix:semicolon
multiline_comment|/* scan all methods for this vendor_id in table */
r_while
c_loop
(paren
id|ft_drive_type.wake_up
op_ne
id|vendors
(braket
id|vendor_index
)braket
dot
id|wake_up
)paren
(brace
r_if
c_cond
(paren
id|vendor_index
OL
id|NR_ITEMS
c_func
(paren
id|vendors
)paren
op_minus
l_int|1
op_logical_and
id|vendors
(braket
id|vendor_index
op_plus
l_int|1
)braket
dot
id|vendor_id
op_eq
id|ft_drive_type.vendor_id
)paren
(brace
op_increment
id|vendor_index
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ft_drive_type.wake_up
op_ne
id|vendors
(braket
id|vendor_index
)braket
dot
id|wake_up
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;==========================================&bslash;n&quot;
id|KERN_INFO
l_string|&quot;wakeup type mismatch:&bslash;n&quot;
id|KERN_INFO
l_string|&quot;found: %s, expected: %s&bslash;n&quot;
id|KERN_INFO
l_string|&quot;please report this to &quot;
id|THE_FTAPE_MAINTAINER
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;==========================================&quot;
comma
id|methods
(braket
id|ft_drive_type.wake_up
)braket
dot
id|name
comma
id|methods
(braket
id|vendors
(braket
id|vendor_index
)braket
dot
id|wake_up
)braket
dot
id|name
)paren
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|ftape_calc_timeouts
r_void
id|ftape_calc_timeouts
c_func
(paren
r_int
r_int
id|qic_std
comma
r_int
r_int
id|data_rate
comma
r_int
r_int
id|tape_len
)paren
(brace
r_int
id|speed
suffix:semicolon
multiline_comment|/* deci-ips ! */
r_int
id|ff_speed
suffix:semicolon
r_int
id|length
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
multiline_comment|/*                           tape transport speed&n;&t; *  data rate:        QIC-40   QIC-80   QIC-3010 QIC-3020&n;&t; *&n;&t; *    250 Kbps        25 ips     n/a      n/a      n/a&n;&t; *    500 Kbps        50 ips   34 ips   22.6 ips   n/a&n;&t; *      1 Mbps          n/a    68 ips   45.2 ips 22.6 ips&n;&t; *      2 Mbps          n/a      n/a      n/a    45.2 ips&n;&t; *&n;&t; *  fast tape transport speed is at least 68 ips.&n;&t; */
r_switch
c_cond
(paren
id|qic_std
)paren
(brace
r_case
id|QIC_TAPE_QIC40
suffix:colon
id|speed
op_assign
(paren
id|data_rate
op_eq
l_int|250
)paren
ques
c_cond
l_int|250
suffix:colon
l_int|500
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_QIC80
suffix:colon
id|speed
op_assign
(paren
id|data_rate
op_eq
l_int|500
)paren
ques
c_cond
l_int|340
suffix:colon
l_int|680
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_QIC3010
suffix:colon
id|speed
op_assign
(paren
id|data_rate
op_eq
l_int|500
)paren
ques
c_cond
l_int|226
suffix:colon
l_int|452
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_QIC3020
suffix:colon
id|speed
op_assign
(paren
id|data_rate
op_eq
l_int|1000
)paren
ques
c_cond
l_int|226
suffix:colon
l_int|452
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;Unknown qic_std (bug) ?&quot;
)paren
suffix:semicolon
id|speed
op_assign
l_int|500
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_drive_type.speed
op_eq
l_int|0
)paren
(brace
r_int
r_int
id|t0
suffix:semicolon
r_static
r_int
id|dt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* keep gcc from complaining */
r_static
r_int
id|first_time
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*  Measure the time it takes to wind to EOT and back to BOT.&n;&t;&t; *  If the tape length is known, calculate the rewind speed.&n;&t;&t; *  Else keep the time value for calculation of the rewind&n;&t;&t; *  speed later on, when the length _is_ known.&n;&t;&t; *  Ask for a report only when length and speed are both known.&n;&t;&t; */
r_if
c_cond
(paren
id|first_time
)paren
(brace
id|ftape_seek_to_bot
c_func
(paren
)paren
suffix:semicolon
id|t0
op_assign
id|jiffies
suffix:semicolon
id|ftape_seek_to_eot
c_func
(paren
)paren
suffix:semicolon
id|ftape_seek_to_bot
c_func
(paren
)paren
suffix:semicolon
id|dt
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
id|jiffies
op_minus
id|t0
)paren
op_star
id|FT_USPT
)paren
op_div
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dt
OL
l_int|1
)paren
(brace
id|dt
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* prevent div by zero on failures */
)brace
id|first_time
op_assign
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;trying to determine seek timeout, got %d msec&quot;
comma
id|dt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape_len
op_ne
l_int|0
)paren
(brace
id|ft_drive_type.speed
op_assign
(paren
l_int|2
op_star
l_int|12
op_star
id|tape_len
op_star
l_int|1000
)paren
op_div
id|dt
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;==========================================&bslash;n&quot;
id|KERN_INFO
l_string|&quot;drive type: %s&bslash;n&quot;
id|KERN_INFO
l_string|&quot;delta time = %d ms, length = %d ft&bslash;n&quot;
id|KERN_INFO
l_string|&quot;has a maximum tape speed of %d ips&bslash;n&quot;
id|KERN_INFO
l_string|&quot;please report this to &quot;
id|THE_FTAPE_MAINTAINER
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;==========================================&quot;
comma
id|ft_drive_type.name
comma
id|dt
comma
id|tape_len
comma
id|ft_drive_type.speed
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*  Handle unknown length tapes as very long ones. We&squot;ll&n;&t; *  determine the actual length from a header segment later.&n;&t; *  This is normal for all modern (Wide,TR1/2/3) formats.&n;&t; */
r_if
c_cond
(paren
id|tape_len
op_le
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Unknown tape length, using maximal timeouts&quot;
)paren
suffix:semicolon
id|length
op_assign
id|QIC_TOP_TAPE_LEN
suffix:semicolon
multiline_comment|/* use worst case values */
)brace
r_else
(brace
id|length
op_assign
id|tape_len
suffix:semicolon
multiline_comment|/* use actual values */
)brace
r_if
c_cond
(paren
id|ft_drive_type.speed
op_eq
l_int|0
)paren
(brace
id|ff_speed
op_assign
id|speed
suffix:semicolon
)brace
r_else
(brace
id|ff_speed
op_assign
id|ft_drive_type.speed
suffix:semicolon
)brace
multiline_comment|/*  time to go from bot to eot at normal speed (data rate):&n;&t; *  time = (1+delta) * length (ft) * 12 (inch/ft) / speed (ips)&n;&t; *  delta = 10 % for seek speed, 20 % for rewind speed.&n;&t; */
id|ftape_timeout.seek
op_assign
(paren
id|length
op_star
l_int|132
op_star
id|FT_SECOND
)paren
op_div
id|speed
suffix:semicolon
id|ftape_timeout.rewind
op_assign
(paren
id|length
op_star
l_int|144
op_star
id|FT_SECOND
)paren
op_div
(paren
l_int|10
op_star
id|ff_speed
)paren
suffix:semicolon
id|ftape_timeout.reset
op_assign
l_int|20
op_star
id|FT_SECOND
op_plus
id|ftape_timeout.rewind
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;timeouts for speed = %d, length = %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;seek timeout  : %d sec&bslash;n&quot;
id|KERN_INFO
l_string|&quot;rewind timeout: %d sec&bslash;n&quot;
id|KERN_INFO
l_string|&quot;reset timeout : %d sec&quot;
comma
id|speed
comma
id|length
comma
(paren
id|ftape_timeout.seek
op_plus
l_int|500
)paren
op_div
l_int|1000
comma
(paren
id|ftape_timeout.rewind
op_plus
l_int|500
)paren
op_div
l_int|1000
comma
(paren
id|ftape_timeout.reset
op_plus
l_int|500
)paren
op_div
l_int|1000
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/* This function calibrates the datarate (i.e. determines the maximal&n; * usable data rate) and sets the global variable ft_qic_std to qic_std&n; *&n; */
DECL|function|ftape_calibrate_data_rate
r_int
id|ftape_calibrate_data_rate
c_func
(paren
r_int
r_int
id|qic_std
)paren
(brace
r_int
id|rate
op_assign
id|ft_fdc_rate_limit
suffix:semicolon
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|ft_qic_std
op_assign
id|qic_std
suffix:semicolon
r_if
c_cond
(paren
id|ft_qic_std
op_eq
op_minus
l_int|1
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;Unable to determine data rate if QIC standard is unknown&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*  Select highest rate supported by both fdc and drive.&n;&t; *  Start with highest rate supported by the fdc.&n;&t; */
r_while
c_loop
(paren
id|fdc_set_data_rate
c_func
(paren
id|rate
)paren
template_param
l_int|250
)paren
(brace
id|rate
op_div_assign
l_int|2
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;Highest FDC supported data rate: %d Kbps&quot;
comma
id|rate
)paren
suffix:semicolon
id|ft_fdc_max_rate
op_assign
id|rate
suffix:semicolon
r_do
(brace
id|result
op_assign
id|ftape_set_data_rate
c_func
(paren
id|rate
comma
id|ft_qic_std
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|result
op_eq
op_minus
id|EINVAL
op_logical_and
(paren
id|rate
op_div_assign
l_int|2
)paren
OG
l_int|250
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;set datarate failed&quot;
)paren
suffix:semicolon
)brace
id|ft_data_rate
op_assign
id|rate
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_init_drive
r_int
id|ftape_init_drive
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
id|qic_model
id|model
suffix:semicolon
r_int
r_int
id|qic_std
suffix:semicolon
r_int
r_int
id|data_rate
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|ftape_init_drive_needed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t retry if this fails ? */
id|TRACE_CATCH
c_func
(paren
id|ftape_report_raw_drive_status
c_func
(paren
op_amp
id|status
)paren
comma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|QIC_STATUS_CARTRIDGE_PRESENT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|QIC_STATUS_AT_BOT
)paren
)paren
(brace
multiline_comment|/*  Antique drives will get here after a soft reset,&n;&t;&t;&t; *  modern ones only if the driver is loaded when the&n;&t;&t;&t; *  tape wasn&squot;t rewound properly.&n;&t;&t;&t; */
multiline_comment|/* Tape should be at bot if new cartridge ! */
id|ftape_seek_to_bot
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|QIC_STATUS_REFERENCED
)paren
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;starting seek_load_point&quot;
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_command_wait
c_func
(paren
id|QIC_SEEK_LOAD_POINT
comma
id|ftape_timeout.reset
comma
op_amp
id|status
)paren
comma
)paren
suffix:semicolon
)brace
)brace
id|ft_formatted
op_assign
(paren
id|status
op_amp
id|QIC_STATUS_REFERENCED
)paren
op_ne
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ft_formatted
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Warning: tape is not formatted !&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*  report configuration aborts when ftape_tape_len == -1&n;&t; *  unknown qic_std is okay if not formatted.&n;&t; */
id|TRACE_CATCH
c_func
(paren
id|ftape_report_configuration
c_func
(paren
op_amp
id|model
comma
op_amp
id|data_rate
comma
op_amp
id|qic_std
comma
op_amp
id|ftape_tape_len
)paren
comma
)paren
suffix:semicolon
multiline_comment|/*  Maybe add the following to the /proc entry&n;&t; */
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;%s drive @ %d Kbps&quot;
comma
(paren
id|model
op_eq
id|prehistoric
)paren
ques
c_cond
l_string|&quot;prehistoric&quot;
suffix:colon
(paren
(paren
id|model
op_eq
id|pre_qic117c
)paren
ques
c_cond
l_string|&quot;pre QIC-117C&quot;
suffix:colon
(paren
(paren
id|model
op_eq
id|post_qic117b
)paren
ques
c_cond
l_string|&quot;post QIC-117B&quot;
suffix:colon
l_string|&quot;post QIC-117D&quot;
)paren
)paren
comma
id|data_rate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_formatted
)paren
(brace
multiline_comment|/*  initialize ft_used_data_rate to maximum value &n;&t;&t; *  and set ft_qic_std&n;&t;&t; */
id|TRACE_CATCH
c_func
(paren
id|ftape_calibrate_data_rate
c_func
(paren
id|qic_std
)paren
comma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftape_tape_len
op_eq
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;unknown length QIC-%s tape&quot;
comma
(paren
id|ft_qic_std
op_eq
id|QIC_TAPE_QIC40
)paren
ques
c_cond
l_string|&quot;40&quot;
suffix:colon
(paren
(paren
id|ft_qic_std
op_eq
id|QIC_TAPE_QIC80
)paren
ques
c_cond
l_string|&quot;80&quot;
suffix:colon
(paren
(paren
id|ft_qic_std
op_eq
id|QIC_TAPE_QIC3010
)paren
ques
c_cond
l_string|&quot;3010&quot;
suffix:colon
l_string|&quot;3020&quot;
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;%d ft. QIC-%s tape&quot;
comma
id|ftape_tape_len
comma
(paren
id|ft_qic_std
op_eq
id|QIC_TAPE_QIC40
)paren
ques
c_cond
l_string|&quot;40&quot;
suffix:colon
(paren
(paren
id|ft_qic_std
op_eq
id|QIC_TAPE_QIC80
)paren
ques
c_cond
l_string|&quot;80&quot;
suffix:colon
(paren
(paren
id|ft_qic_std
op_eq
id|QIC_TAPE_QIC3010
)paren
ques
c_cond
l_string|&quot;3010&quot;
suffix:colon
l_string|&quot;3020&quot;
)paren
)paren
)paren
suffix:semicolon
)brace
id|ftape_calc_timeouts
c_func
(paren
id|ft_qic_std
comma
id|ft_data_rate
comma
id|ftape_tape_len
)paren
suffix:semicolon
multiline_comment|/* soft write-protect QIC-40/QIC-80 cartridges used with a&n;&t;&t; * Colorado T3000 drive. Buggy hardware!&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ft_drive_type.vendor_id
op_eq
l_int|0x011c6
)paren
op_logical_and
(paren
(paren
id|ft_qic_std
op_eq
id|QIC_TAPE_QIC40
op_logical_or
id|ft_qic_std
op_eq
id|QIC_TAPE_QIC80
)paren
op_logical_and
op_logical_neg
id|ft_write_protected
)paren
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;The famous Colorado T3000 bug:&bslash;n&quot;
id|KERN_INFO
l_string|&quot;%s drives can&squot;t write QIC40 and QIC80&bslash;n&quot;
id|KERN_INFO
l_string|&quot;cartridges but don&squot;t set the write-protect flag!&quot;
comma
id|ft_drive_type.name
)paren
suffix:semicolon
id|ft_write_protected
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*  Doesn&squot;t make too much sense to set the data rate&n;&t;&t; *  because we don&squot;t know what to use for the write&n;&t;&t; *  precompensation.&n;&t;&t; *  Need to do this again when formatting the cartridge.&n;&t;&t; */
id|ft_data_rate
op_assign
id|data_rate
suffix:semicolon
id|ftape_calc_timeouts
c_func
(paren
id|QIC_TAPE_QIC40
comma
id|data_rate
comma
id|ftape_tape_len
)paren
suffix:semicolon
)brace
id|ftape_new_cartridge
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_munmap
r_static
r_void
id|ftape_munmap
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ft_nr_buffers
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ft_buffer
(braket
id|i
)braket
op_member_access_from_pointer
id|mmapped
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/*   Map the dma buffers into the virtual address range given by vma.&n; *   We only check the caller doesn&squot;t map non-existent buffers. We&n; *   don&squot;t check for multiple mappings.&n; */
DECL|function|ftape_mmap
r_int
id|ftape_mmap
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_int
id|num_buffers
suffix:semicolon
r_int
id|i
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_failure
)paren
(brace
id|TRACE_EXIT
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_READ
op_or
id|VM_WRITE
)paren
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_err
comma
l_string|&quot;Undefined mmap() access&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vma_get_pgoff
c_func
(paren
id|vma
)paren
op_ne
l_int|0
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_err
comma
l_string|&quot;page offset must be 0&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
)paren
op_mod
id|FT_BUFF_SIZE
op_ne
l_int|0
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_err
comma
l_string|&quot;size = %ld, should be a multiple of %d&quot;
comma
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
comma
id|FT_BUFF_SIZE
)paren
suffix:semicolon
)brace
id|num_buffers
op_assign
(paren
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
)paren
op_div
id|FT_BUFF_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|num_buffers
OG
id|ft_nr_buffers
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_err
comma
l_string|&quot;size = %ld, should be less than %d&quot;
comma
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
comma
id|ft_nr_buffers
op_star
id|FT_BUFF_SIZE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_driver_state
op_ne
id|idle
)paren
(brace
multiline_comment|/* this also clears the buffer states &n;&t;&t; */
id|ftape_abort_operation
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ftape_reset_buffer
c_func
(paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_buffers
suffix:semicolon
id|i
op_increment
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|remap_page_range
c_func
(paren
id|vma-&gt;vm_start
op_plus
id|i
op_star
id|FT_BUFF_SIZE
comma
id|virt_to_phys
c_func
(paren
id|ft_buffer
(braket
id|i
)braket
op_member_access_from_pointer
id|address
)paren
comma
id|FT_BUFF_SIZE
comma
id|vma-&gt;vm_page_prot
)paren
comma
id|_res
op_assign
op_minus
id|EAGAIN
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;remapped dma buffer @ %p to location @ %p&quot;
comma
id|ft_buffer
(braket
id|i
)braket
op_member_access_from_pointer
id|address
comma
(paren
r_void
op_star
)paren
(paren
id|vma-&gt;vm_start
op_plus
id|i
op_star
id|FT_BUFF_SIZE
)paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_buffers
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memset
c_func
(paren
id|ft_buffer
(braket
id|i
)braket
op_member_access_from_pointer
id|address
comma
l_int|0xAA
comma
id|FT_BUFF_SIZE
)paren
suffix:semicolon
id|ft_buffer
(braket
id|i
)braket
op_member_access_from_pointer
id|mmapped
op_increment
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
r_static
r_void
id|ftape_init_driver
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* forward declaration */
multiline_comment|/*      OPEN routine called by kernel-interface code&n; */
DECL|function|ftape_enable
r_int
id|ftape_enable
c_func
(paren
r_int
id|drive_selection
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_drive_sel
op_eq
op_minus
l_int|1
op_logical_or
id|ft_drive_sel
op_ne
id|drive_selection
)paren
(brace
multiline_comment|/* Other selection than last time&n;&t;&t; */
id|ftape_init_driver
c_func
(paren
)paren
suffix:semicolon
)brace
id|ft_drive_sel
op_assign
id|FTAPE_SEL
c_func
(paren
id|drive_selection
)paren
suffix:semicolon
id|ft_failure
op_assign
l_int|0
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_init
c_func
(paren
)paren
comma
)paren
suffix:semicolon
multiline_comment|/* init &amp; detect fdc */
id|TRACE_CATCH
c_func
(paren
id|ftape_activate_drive
c_func
(paren
op_amp
id|ft_drive_type
)paren
comma
id|fdc_disable
c_func
(paren
)paren
suffix:semicolon
id|fdc_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
id|fdc_release_regions
c_func
(paren
)paren
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_get_drive_status
c_func
(paren
)paren
comma
id|ftape_detach_drive
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_drive_type.vendor_id
op_eq
id|UNKNOWN_VENDOR
)paren
(brace
id|ftape_log_vendor_id
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_new_tape
)paren
(brace
id|ftape_init_drive_needed
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ft_no_tape
op_logical_and
id|ftape_init_drive_needed
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|ftape_init_drive
c_func
(paren
)paren
comma
id|ftape_detach_drive
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
id|ftape_munmap
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* clear the mmap flag */
id|clear_history
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*   release routine called by the high level interface modules&n; *   zftape or sftape.&n; */
DECL|function|ftape_disable
r_void
id|ftape_disable
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ft_nr_buffers
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ft_buffer
(braket
id|i
)braket
op_member_access_from_pointer
id|mmapped
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;first byte of buffer %d: 0x%02x&quot;
comma
id|i
comma
op_star
id|ft_buffer
(braket
id|i
)braket
op_member_access_from_pointer
id|address
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sigtestsetmask
c_func
(paren
op_amp
id|current-&gt;pending.signal
comma
id|_DONT_BLOCK
)paren
op_logical_and
op_logical_neg
(paren
id|sigtestsetmask
c_func
(paren
op_amp
id|current-&gt;pending.signal
comma
id|_NEVER_BLOCK
)paren
)paren
op_logical_and
id|ftape_tape_running
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Interrupted by fatal signal and tape still running&quot;
)paren
suffix:semicolon
id|ftape_dumb_stop
c_func
(paren
)paren
suffix:semicolon
id|ftape_abort_operation
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* it&squot;s annoying */
)brace
r_else
(brace
id|ftape_set_state
c_func
(paren
id|idle
)paren
suffix:semicolon
)brace
id|ftape_detach_drive
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_history.used
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;== Non-fatal errors this run: ==&quot;
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;fdc isr statistics:&bslash;n&quot;
id|KERN_INFO
l_string|&quot; id_am_errors     : %3d&bslash;n&quot;
id|KERN_INFO
l_string|&quot; id_crc_errors    : %3d&bslash;n&quot;
id|KERN_INFO
l_string|&quot; data_am_errors   : %3d&bslash;n&quot;
id|KERN_INFO
l_string|&quot; data_crc_errors  : %3d&bslash;n&quot;
id|KERN_INFO
l_string|&quot; overrun_errors   : %3d&bslash;n&quot;
id|KERN_INFO
l_string|&quot; no_data_errors   : %3d&bslash;n&quot;
id|KERN_INFO
l_string|&quot; retries          : %3d&quot;
comma
id|ft_history.id_am_errors
comma
id|ft_history.id_crc_errors
comma
id|ft_history.data_am_errors
comma
id|ft_history.data_crc_errors
comma
id|ft_history.overrun_errors
comma
id|ft_history.no_data_errors
comma
id|ft_history.retries
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_history.used
op_amp
l_int|1
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;ecc statistics:&bslash;n&quot;
id|KERN_INFO
l_string|&quot; crc_errors       : %3d&bslash;n&quot;
id|KERN_INFO
l_string|&quot; crc_failures     : %3d&bslash;n&quot;
id|KERN_INFO
l_string|&quot; ecc_failures     : %3d&bslash;n&quot;
id|KERN_INFO
l_string|&quot; sectors corrected: %3d&quot;
comma
id|ft_history.crc_errors
comma
id|ft_history.crc_failures
comma
id|ft_history.ecc_failures
comma
id|ft_history.corrected
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_history.defects
OG
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Warning: %d media defects!&quot;
comma
id|ft_history.defects
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_history.rewinds
OG
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;tape motion statistics:&bslash;n&quot;
id|KERN_INFO
l_string|&quot;repositions       : %3d&quot;
comma
id|ft_history.rewinds
)paren
suffix:semicolon
)brace
)brace
id|ft_failure
op_assign
l_int|1
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|ftape_init_driver
r_static
r_void
id|ftape_init_driver
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|ft_drive_type.vendor_id
op_assign
id|UNKNOWN_VENDOR
suffix:semicolon
id|ft_drive_type.speed
op_assign
l_int|0
suffix:semicolon
id|ft_drive_type.wake_up
op_assign
id|unknown_wake_up
suffix:semicolon
id|ft_drive_type.name
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
id|ftape_timeout.seek
op_assign
l_int|650
op_star
id|FT_SECOND
suffix:semicolon
id|ftape_timeout.reset
op_assign
l_int|670
op_star
id|FT_SECOND
suffix:semicolon
id|ftape_timeout.rewind
op_assign
l_int|650
op_star
id|FT_SECOND
suffix:semicolon
id|ftape_timeout.head_seek
op_assign
l_int|15
op_star
id|FT_SECOND
suffix:semicolon
id|ftape_timeout.stop
op_assign
l_int|5
op_star
id|FT_SECOND
suffix:semicolon
id|ftape_timeout.pause
op_assign
l_int|16
op_star
id|FT_SECOND
suffix:semicolon
id|ft_qic_std
op_assign
op_minus
l_int|1
suffix:semicolon
id|ftape_tape_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unknown */
id|ftape_current_command
op_assign
l_int|0
suffix:semicolon
id|ftape_current_cylinder
op_assign
op_minus
l_int|1
suffix:semicolon
id|ft_segments_per_track
op_assign
l_int|102
suffix:semicolon
id|ftape_segments_per_head
op_assign
l_int|1020
suffix:semicolon
id|ftape_segments_per_cylinder
op_assign
l_int|4
suffix:semicolon
id|ft_tracks_per_tape
op_assign
l_int|20
suffix:semicolon
id|ft_failure
op_assign
l_int|1
suffix:semicolon
id|ft_formatted
op_assign
l_int|0
suffix:semicolon
id|ft_no_tape
op_assign
l_int|1
suffix:semicolon
id|ft_write_protected
op_assign
l_int|1
suffix:semicolon
id|ft_new_tape
op_assign
l_int|1
suffix:semicolon
id|ft_driver_state
op_assign
id|idle
suffix:semicolon
id|ft_data_rate
op_assign
id|ft_fdc_max_rate
op_assign
l_int|500
suffix:semicolon
id|ft_drive_max_rate
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* triggers set_rate_test() */
id|ftape_init_drive_needed
op_assign
l_int|1
suffix:semicolon
id|ft_header_segment_1
op_assign
op_minus
l_int|1
suffix:semicolon
id|ft_header_segment_2
op_assign
op_minus
l_int|1
suffix:semicolon
id|ft_used_header_segment
op_assign
op_minus
l_int|1
suffix:semicolon
id|ft_first_data_segment
op_assign
op_minus
l_int|1
suffix:semicolon
id|ft_last_data_segment
op_assign
op_minus
l_int|1
suffix:semicolon
id|ft_location.track
op_assign
op_minus
l_int|1
suffix:semicolon
id|ft_location.known
op_assign
l_int|0
suffix:semicolon
id|ftape_tape_running
op_assign
l_int|0
suffix:semicolon
id|ftape_might_be_off_track
op_assign
l_int|1
suffix:semicolon
id|ftape_new_cartridge
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* init some tape related variables */
id|ftape_init_bsm
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
eof
